/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

ARENA *__thiscall ServerEntryPoint(ARENA *arenaa, const char *Source);
void __thiscall ShutdownArena(struct ARENA *arenaa);
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team);
void __thiscall PlayerEntering(struct ARENA *arena, struct PLAYER *player);
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player);
bool __thiscall ProcessArena(struct ARENA *arenaa);
int __cdecl PtFuncCompare(struct PLAYER **player, ARENA *arenaa);
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset);
void __thiscall CreateSoccerBall(struct ARENA *arenaa, int PowerBallId);
void __thiscall FlagPositionUpdateSomething(struct ARENA *arenaa, int a2);
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3);
void __thiscall ResetFlagGame(struct ARENA *arenaa);
int __thiscall GetNextFrequencyToJoin(ARENA *arenaa);
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4);
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius);
void __thiscall sub_404980(struct ARENA *arena, struct PLAYER *a2, int a3, int a4);
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4);
void __thiscall LoadArenaSettings_0_0(struct ARENA *arenaa);
void __thiscall LoadArenaMapSomething(struct ARENA *arenaa);
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa);
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3);
void __thiscall sub_405360(struct ARENA *arenaa, int BooleanSendScoreReset);
int __thiscall SoccerGameSomething(ARENA *this, int a2);
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4);
void __thiscall GetScore(struct ARENA *arenaa, struct PLAYER *player);
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena);
int __thiscall GetTotalPlayingPlayers(ARENA *arena);
void __thiscall SendBillerServerConnectPacket(struct BILLING_SERVER_STRUCT *billingStruct, int HandleBillerPacketFuncAddress, const char *ServerName, int ServerId, int GroupId, int ScoreId, const char *Password, int mainServerStructure, struct CONNECTION *encryption);
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct);
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3);
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText);
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage);
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand);
void __thiscall SendBillerUserLoginPacket(BILLING_SERVER_STRUCT *billingServerStruct, const char *Username, const char *Password, int IPAddress, int MachineId, int Timezone, char IsNewUser, int PlayerId, char Unused0, char isSysop);
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize);
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size);
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len);
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len);
void __thiscall SendBillerZoneRevokePermitPacket(BILLING_SERVER_STRUCT *billingServerStruct, int a2, int a3, int a4, int len);
int __thiscall GetBillerLastReconnectTime(BILLING_SERVER_STRUCT *billingServerStruct); // idb
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct);
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename);
void __thiscall WriteCfgFile(struct struc_2 *struc2);
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4);
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count);
void __thiscall sub_4066B0(struct struc_2 *strucValue, const char *Str2, const char *a3, const char *Source, char *Dest, size_t Count);
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source);
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source);
void __thiscall sub_406B30(struct BMP_FILE_STRUCT *BMPFileStruct);
int __thiscall GetTotalTileCount(struct BMP_FILE_STRUCT *BMPFile);
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer);
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize);
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key);
bool __cdecl LoadBMPHeader2(const char *Filename);
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll);
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile);
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2);
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile);
int __thiscall TextFileTotalLines(struct TEXT_FILE_STRUCT *textFile);
char *__thiscall TextFileByIndex(struct TEXT_FILE_STRUCT *textFile, int listMachineIndex);
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer);
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number);
int __thiscall IsBannedMachineId(struct TEXT_FILE_STRUCT *textFile, char *MachineId);
int __cdecl StringCompare(int ElementString, const char **ArrayPointer);
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src);
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int);
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer);
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName);
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
void __cdecl config_read_helper_3(char *a1);
signed int __cdecl CRC32(char *buffer, int fileSize);
void __cdecl RewriteSameFileSomething(char *destination, const char *source);
void __cdecl nullsub_1();
void *__cdecl emalloc(int bytes);
char *__cdecl ExpandMemory(void *lpAddress, int NewSize, int MaxSize);
void __stdcall efree(LPVOID ptr);
void __thiscall ConnectSocket(SOCKET *Socket, const char *Hostname, u_short ConnectPort, u_short ListenPort);
void __thiscall CloseSocketWrapper(struct SOCKET *socket);
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3);
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed);
SOCKET __thiscall ListenOnPort(SOCKET sock, __int16 port, int callback);
void __thiscall ProcessZonePings(int Socket, int ZonePopulation);
PLAYER *__thiscall CreateNewPlayer(PLAYER *player, struct in_addr IPAddress, __int16 a3, NetData *encryption);
void __thiscall DisconnectUser(PLAYER *player);
void __thiscall PlayerHandleGamePacket(struct PLAYER *playerr, unsigned __int8 *packet, int packetSize);
void __thiscall GenerateWarning(struct PLAYER *player, int a2);
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr);
bool __thiscall sub_40CF10(struct PLAYER *player);
void __thiscall sub_40D870(struct PLAYER *playerr);
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency);
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship);
void __thiscall sub_40DEA0(struct PLAYER *player, const void *buf, unsigned int len, int a4);
void __thiscall SendPlayerReliablePacket(struct PLAYER *playerr, const void *buf, unsigned int len, int a4);
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6);
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4);
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend);
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6);
void __thiscall sub_40E220(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6);
void __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, int a6);
void __thiscall sub_40E300(struct PLAYER *player, int a2, char *buf, int len, int a4, int a6, int a7);
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte);
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2);
void __thiscall SendArenaMessagePlayer(struct PLAYER *playerr, const char *a2, char SoundByte);
void __thiscall SendFile(struct PLAYER *playerr, const char *filename);
struct ARENA *__thiscall ArenaHandler(struct PLAYER *player, int ArenaIndex, const char *ArenaName);
void __thiscall SendWeaponPacket(struct PLAYER *playerr);
void __thiscall SendResetScoresPacket(PLAYER *player);
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player);
bool __thiscall SendPlayerScoreUpdateAll(struct PLAYER *playerr);
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2);
void __thiscall LoadZoneCFGSettings(struct ARENA_SETTINGS *arenaSettings, struct SERVERSIDE_ARENA_SETTINGS *serverArenaSettings, const char *a3);
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl loc_411FBC(int argc, int argv, int envp); // weak
void __cdecl ServerInitialize();
signed int __cdecl NewConnectionRequest(int IPAddress, __int16 Port, ENCRYPTION *encryption); // idb
void __cdecl PlayerHandleGamePacketWrapperSomething(char *packet, int packetSize, struct CONNECTION *a3);
void __cdecl ServerMainLoop();
int __cdecl IncreaseRadarValueShowHomeOverFourThousand();
void __cdecl ServerUninitialize();
void __cdecl HandleBillerPacket(__int64 buffer);
void FormatMessageArena(ARENA *arena, const char *Format, ...);
void WriteSubGameLog(const char *Format, ...);
bool __cdecl IsOffensiveName(char *a1);
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2); // idb
void __cdecl SendBillerWarnings(const char *a1, struct PLAYER *player);
void __cdecl ChatProcessor(LPPROCESS_INFORMATION lpProcessInformation, PLAYER *player, char *a4, int arenaPlayerIndex, const char *ChatText, char sound);
void __cdecl SomethingWithSendingChatTypes(struct PLAYER *player, int TargetPlayerId, signed int PlayerId, char *ChatText, char SoundByte);
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3);
void __cdecl ReadServerINI();
void __cdecl LoadTemplateSSS();
void __cdecl LoadMapSomething();
void __cdecl LoadAdvertisements();
void __cdecl CleanUpMemory();
int __cdecl LoadWinsock();
int __stdcall j_WSACleanup();
void __thiscall StartServerListener(struct PACKET_ATTACHMENT *packetAttachment, int a2, int a3, int MaxConnections, int ServerListenPort, int OutgoingBufferSize, int IncomingBufferSize, int PacketHistoryMax);
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment);
void __thiscall SetPacketAttachmentEncryptMode(struct PACKET_ATTACHMENT *packetAttachment, int CommsEncryptMode);
struct CONNECTION *__thiscall SomethingBillerServer(PACKET_ATTACHMENT *packetAttachment, const char *name, u_short hostshort, int a4, int a5);
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename);
char *__thiscall PlayerReadPackets(struct PACKET_ATTACHMENT *packetAttachment, int *RecvLength, int *RemoteIP, int *RemotePort);
bool __thiscall PlayerDoNetworkOps(struct PACKET_ATTACHMENT *packetAttachment);
void __thiscall PlayerHandlePacket(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, signed int Size, int a5, __int16 a6);
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5);
char *__thiscall sub_41B1B0(struct PACKET_ATTACHMENT *packetAttachment, int *a2, int *a3);
void __thiscall ResetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment);
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls);
void __thiscall sub_41B430(struct PACKET_ATTACHMENT *packetAttachment, signed int CommsTransportBufferSize);
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment);
int __stdcall sub_41B570(int a1);
int __cdecl DifferentCompareFunction(_DWORD connection, int ConnectionsArray);
void __thiscall InitializeEncryption(struct CONNECTION *encryption, struct PACKET_ATTACHMENT *packetAttachment, int a3, int a4, int a5, __int16 a6, signed int ServerKey, int a8, int a9);
void *__thiscall sub_41B7A0(struct CONNECTION *encryption);
int __thiscall CheckIfBillingServerIsConnected(int this);
int __thiscall GetProtocolVersion(CONNECTION *connection); // idb
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2);
void __thiscall WriteToNetwork(struct CONNECTION *encryption, const char *buf, unsigned int len);
void __thiscall ProcessCorePackets(struct CONNECTION *encryption, char *buffer, int size, int a5);
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection);
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4);
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename);
void __thiscall GetNewsRequest(struct CONNECTION *encryption, char *MemoryPointer, int a3, int a4);
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4);
void __thiscall GetASyncC2SInfoSomething(struct CONNECTION *encryption, int ASyncC2SEnd, int ASyncC2SStart);
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart);
int __thiscall sub_41CA10(struct CONNECTION *encryptionPointer);
void __thiscall SendPacketCluster(struct CONNECTION *encryptionn, const void *buf, unsigned int len);
void __thiscall sub_41CB20(CONNECTION *encryption);
void __thiscall GetPingLOSSSomething(CONNECTION *encryptionPointer, int *ServerToYou, int *YouToServer);
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5);
void __thiscall OrderDisconnect(struct CONNECTION *encryption);
char *__cdecl GetIPAddressString(struct in_addr in);
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename);
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize);
// int __stdcall compress(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// struct hostent *__stdcall gethostbyname(const char *name);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// u_long __stdcall htonl(u_long hostlong);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp);
// SOCKET __stdcall SOCKET(int af, int type, int protocol);
// int __stdcall closesocket(SOCKET s);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// char *__stdcall inet_ntoa(struct in_addr in);
void __cdecl setRNGSeed(int SeedRNG);
// int __cdecl rand();
// int printf(const char *Format, ...);
// _DWORD __cdecl time(_DWORD Time); weak
// int sprintf(char *Dest, const char *Format, ...);
// char *__cdecl strrchr(const char *Str, int Ch);
// int __cdecl fclose(FILE *File);
// size_t __cdecl fread(void *DstBuf, size_t ElementSize, size_t Count, FILE *File);
// FILE *__cdecl fopen(const char *Filename, const char *Mode);
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File);
// void __usercall _alloca_probe(unsigned int a1@<eax>, char a2);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// _DWORD __cdecl shortsort(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl swap(_DWORD, _DWORD, _DWORD); weak
// int __cdecl operator delete(void *Memory); idb
// void *__cdecl operator new(unsigned int); idb
// int __cdecl __CxxFrameHandler(struct EHExceptionRecord *ExceptionRecord, struct EHRegistrationNode *, int, int); idb
// _DWORD __cdecl _local_unwind2(_DWORD, _DWORD); weak
// int __cdecl atoi(const char *Str);
// int __cdecl isalpha(int C);
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
// char *__cdecl fgets(char *Buf, int MaxCount, FILE *File);
// int fprintf(FILE *File, const char *Format, ...);
// int __cdecl fseek(FILE *File, __int32 Offset, int Origin);
// _DWORD __cdecl _chsize(_DWORD, _DWORD); weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl toupper(int C);
// void __cdecl exit(int Code);
// void *__cdecl malloc(size_t Size);
// void *__cdecl realloc(void *Memory, size_t NewSize);
// void __cdecl free(void *Memory);
int __cdecl RunCommandPrompt(char *argumentsPointer); // idb
// int __cdecl _spawnlp(int, char *Str, int); idb
// clock_t __cdecl clock();
// int __cdecl fflush(FILE *File);
// int __cdecl vsprintf(char *Dest, const char *Format, va_list Args);
// char *__cdecl asctime(const struct tm *Tm);
// struct tm *__cdecl localtime(const time_t *Time);
// double __cdecl difftime(_DWORD Time1, _DWORD);
// char *__cdecl strchr(const char *Str, int Val);
// _DWORD __cdecl _filelength(_DWORD); weak
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
// int __cdecl _output(FILE *File, int, int); idb
// int __usercall sub_4210C9@<eax>(int a1@<ebp>);
// int __usercall sub_4210D6@<eax>(int a1@<ebp>);
int __cdecl sub_421101();
// int sub_42110A(void); weak
// int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *); idb
// void __usercall __noreturn sub_4214B0(int a2@<ebx>, int a3@<edi>, int a4@<esi>);
void __cdecl j__abort();
// void __usercall __noreturn sub_421540(int a2@<ebx>, int a3@<edi>, int a4@<esi>);
int loc_42157F(); // weak
int __cdecl sub_4215AE(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __cdecl _isctype(int C, int Type);
// int __cdecl _spawnvpe(int, char *Str, int, LPVOID lpEnvironment); idb
// signed int __cdecl _spawnve(int a1, char *Str, int a3, LPVOID lpEnvironment);
// int __cdecl comexecmd(int a1, DWORD lpApplicationName, int a3, LPVOID Memory);
// int __cdecl _access(LPCSTR lpFileName, char); idb
// char *__cdecl getenv(const char *VarName);
// _DWORD __cdecl _ftime(_DWORD); weak
BOOL __cdecl DateFunction(int a1);
// _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl unknown_libname_6(int, PVOID TargetFrame, int); idb
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int __cdecl _mbsrchr(char *Str, int); idb
// int __cdecl _mbschr(char *Str, int Val); idb
// int __cdecl _dospawn(int, LPCSTR lpApplicationName, DWORD ExitCode, LPVOID lpEnvironment); idb
// _DWORD __cdecl _cenvarg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_426670(int a1, int a2);
int __cdecl sub_426690(int a1, int a2);
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String);
int __cdecl sub_4266F0(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _fileno(FILE *File);
// int __cdecl _strcmpi(const char *Str1, const char *Str2);
// char *__cdecl _strupr(char *String);
int __cdecl getch();
int __cdecl console_input_wrapper();
// _DWORD __cdecl _getextendedkeycode(_DWORD); weak
// int __cdecl _memicmp(const void *Buf1, const void *Buf2, size_t Size);
// int __initconin(void); weak
// int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
// DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);
// BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
// BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
// DWORD __stdcall GetLastError();
// DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// HANDLE __stdcall LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4288DE; // weak
int dword_429128[2] = { -1, 0 }; // weak
int dword_429140[2] = { -1, 0 }; // weak
int LastBillerPlayerId = 1; // weak
char byte_42BC84[] = { 'M', 'i', 's', 'c', '\0', '\0', '\0', '\0' }; // idb
int UseBillingServer = 1; // weak
char *off_42C848[8] =
{
  "Warbird",
  "Javelin",
  "Spider",
  "Leviathan",
  "Weasel",
  "Terrier",
  "Lancaster",
  "Shark"
}; // weak
int RNGSeed = 1; // weak
FILE stdout = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
int (__cdecl *off_42E734)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_4214B0; // idb
int dword_43099C = 1; // weak
int dword_430A30 = -1; // weak
int dword_430A34 = 0; // weak
int dword_430A38 = 0; // weak
int dword_430A40 = -1; // weak
int dword_430A44 = 0; // weak
int dword_430A48 = 0; // weak
int dword_430E60[6] = { 1024, -1023, 53, 11, 64, 1023 }; // weak
int dword_430E78[6] = { 128, -127, 24, 8, 32, 127 }; // weak
int dword_431490 = -1; // weak
HANDLE dword_4314A0 = (HANDLE)0xFFFFFFFE; // idb
char *DirectoryCurrentNamePassword = NULL;
int AdvertiseSendMode = 0; // weak
char DirectoryIPAddresses[328] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
};
char Filename2[];
struct PACKET_ADVERTISEMENT RegisteredAd[128];
int dword_4317BC; // idb
int LastTimeServerINIWasEdited; // weak
SOCKET *DirectoryConnectSockets[8];
int MiscDisableSharewareShips;
u_short DirectoryPort; // idb
int RadarValue; // weak
struct PACKET_ADVERTISEMENT SharewareAd[128];
int dword_431BF4; // idb
int dword_431E9C[75]; // weak
int dword_431FC8[10]; // weak
BILLING_SERVER_STRUCT *BillingConnectionStructPointer;
int ArenaArrayLength; // weak
int ServerIterations; // weak
int ArenaMinimumPlayers; // weak
int LastTimeMasterCFGWasEdited; // weak
int RecycleServer; // weak
CHAT ChatRelatedArray[64];
struct PACKET_ATTACHMENT *ServerPacketAttachment;
LPVOID CompressedServerMap; // idb
int ArenaSpawnKeepScores; // weak
int dword_437B14; // weak
char FileName[]; // idb
int DoubleValue; // weak
int BillingAttemptTime; // weak
char DirectoryNamePassword[128];
int CommsMaxQueueToLogin; // weak
int CurrentLogLine; // weak
int IsServerRunning; // weak
struct PACKET_ADVERTISEMENT BothAd[128];
char *dword_437CB4;
int ArenaMaxPlayers; // weak
int CommsPacketHistoryMax;
char SuperModeratorPassword[64];
char ModeratorPassword[64];
int MiscMaxSharewarePlayer; // weak
ARENA_SETTINGS ArenaSettings;
int MachineIdArrayCount; // weak
char BillingPassword[32];
int MapChecksum; // idb
int TotalSentForEachPacketType[256];
u_short BillingPort; // idb
LPVOID CompressedNewsMemory; // idb
int MiscLogPoints; // weak
TEXT_FILE_STRUCT *ObscenePointer;
int ScreenValue; // weak
int CPUSlowIterationWarningLevel; // weak
int MaxArenasMemory; // weak
int PermissionMode; // weak
int CommsEncryptMode; // idb
TEXT_FILE_STRUCT *ModeratePointer;
char VIPPassword[64];
TEXT_FILE_STRUCT *PermitPointer;
struct BMP_FILE_STRUCT *BMPFilePointer;
int MiscMaxPlayers; // weak
int BillingReconnectTime; // weak
int PermissionMinimumSecondsToLogin; // weak
TEMPLATE_SSS TotalTemplateSSSList[1400];
int dword_438BC8; // weak
int dword_438BCC; // weak
char dword_438BD0[256]; // idb
char byte_438CD0[]; // idb
char byte_438CD1[]; // idb
char EnergyPassword[];
int PermissionMaxPoints; // weak
CONNECTION *EncryptionStruct;
int BillingGroupId; // idb
int BillingServerId; // idb
KICK KickedUsers[1000]; // weak
int MiscKeepAliveDelay; // weak
int AutoPermissionPoints; // weak
char SysopPassword[];
DWORD CPUSleepTime; // idb
int TotalSentSizeForEachPacketType[256];
char DirectoryDescription[];
SOCKET BillingIP;
int dword_4AF8F8; // weak
int dword_4AF8FC[5]; // weak
char byte_4AF911[]; // weak
int dword_4C8F38; // weak
int dword_4C8F3C; // weak
PLAYER *playerPointerList[1024];
int CPUSleepPerIteration; // weak
char MiscDefaultLevelFile[];
SERVERSIDE_ARENA_SETTINGS ServersideArenaSettings;
char PermissionAutoPermissionMessage[];
int ServerListenPort; // idb
int MiscPointUpdateDiff; // weak
char PermissionAutoPermissionIDList[];
int BillingLogMessages; // weak
int IncreasesRadarValueSomeHow; // weak
SERVER_BIG_ARRAY Security[10];
int CustomArenaMode; // weak
PLAYER *ZonePlayerList[1025];
int MiscServerLog; // weak
int dword_4D55D0; // weak
int MiscMaxSharkwareTime; // weak
int MiscMenuKickOutDelay; // weak
TEXT_FILE_STRUCT *ReservedPointer;
ARENA *Arenas[200];
int PermissionAllowLowBandwidth; // weak
int CPUProcessMaxTime; // weak
int MaxArenas; // weak
int MiscJackpotBroadcastPoints; // weak
int MiscRegisterKickShareware; // weak
int NewsTxtFileChecksum; // idb
int MiscDisableShareware; // weak
int CommsIncomingBufferSize; // idb
int IsEditedServerINIorCFG; // weak
int LastTimeNewsTxtWasEdited; // weak
int ArenaDesiredPlayers; // weak
char LogArray[12288]; // weak
int AdvertiseDuration; // weak
int BillingScoreId; // idb
LPVOID ServerMapAllocatedMemory;
int CommsOutgoingBufferSize; // idb
char BillingServerName[];
SOCKET *ZonePingSocket;
SOCKET BillerSocket;
int Wave; // weak
CHAR ShutdownArguments; // idb
struct TEXT_FILE_STRUCT *IDBlockPointer;
PACKET_ATTACHMENT *ServerStruct; // idb
int AdvertiseDisplayMode; // weak
int ZonePlayerCount; // idb
int MiscDisableSharewareScores; // weak
int TotalTemplateSSSEntries; // weak
int NewsTxtFileSize; // idb
signed int CommsTransportBufferSize; // idb
int DefaultMapFileSize; // idb
int LastServerStatsAndKickedPlayersTime; // weak
int HighestPlayerCountMaybeSomething; // weak
int SharewareAdvertisementsFound; // weak
int RegisteredAdvertisementsFound; // weak
int BothAdvertisementsFound; // weak
FILE *PointsFileHandle; // idb
FILE *SubGameLogFileHandle; // idb
int dword_4D8B14; // weak
int ChatCounter64Max; // weak
int dword_4D8B38; // weak
int dword_4D8B44; // weak
int (__cdecl *dword_4D8BDC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_4D8C18; // weak
struct _TIME_ZONE_INFORMATION TimeZoneInformation; // idb


//----- (00401000) --------------------------------------------------------
ARENA *__thiscall ServerEntryPoint(ARENA *arenaa, const char *Source)
{
  int v3; // eax
  DWORD (__stdcall *GetTickCountt)(); // esi
  FILE *v5; // eax
  FILE *v6; // esi
  int v7; // eax
  unsigned int v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // edi
  DWORD v17; // eax
  __int64 v18; // rax
  int v19; // eax
  int v20; // ecx
  FLAG *v21; // eax
  char ArenaScoreFileName[32]; // [esp+10h] [ebp-120h] BYREF
  char Str[256]; // [esp+30h] [ebp-100h] BYREF

  arenaa->MapAllocatedMemory = 0;
  arenaa->ArenaRecycling = 0;
  arenaa->SecurityChecksumCounterOddValue = 0;
  if ( _strcmpi(Source, "server") )
  {
    strncpy(arenaa->ArenaName, Source, 0x20u);
    arenaa->ArenaName[31] = 0;
  }
  else
  {
    strcpy(arenaa->ArenaName, "unnamed");
  }
  v3 = CustomArenaMode > 0 && arenaa->ArenaName[0];
  GetTickCountt = GetTickCount;
  arenaa->HasScoreFile = v3;
  arenaa->TotalNumScoresInFile = 0;
  arenaa->ScoreFilePointer = 0;
  arenaa->LastSaveStatsTime = GetTickCount() / 0xA;
  arenaa->NeedSettingsUpdate = 0;
  arenaa->AllMessagesLocked = 0;
  arenaa->AllMessagesLockedAgainSomething = 0;
  arenaa->PrivateMessagesLocked = 0;
  arenaa->SpecMessageLock = 0;
  if ( arenaa->HasScoreFile )
  {
    strcpy(ArenaScoreFileName, arenaa->ArenaName);
    strcat(ArenaScoreFileName, ".scr");
    v5 = fopen(ArenaScoreFileName, "rb");
    v6 = v5;
    if ( v5 )
    {
      v7 = _fileno(v5);
      v8 = _filelength(v7);
      arenaa->TotalNumScoresInFile = v8 / 0x12;
      v9 = ExpandMemory(0, 18 * (v8 / 0x12), 1);
      arenaa->ScoreFilePointer = (SCORE *)v9;
      fread(v9, 0x12u, arenaa->TotalNumScoresInFile, v6);
      fclose(v6);
    }
    GetTickCountt = GetTickCount;
  }
  memset(arenaa, 0, 0xFB00u);
  GetModuleFileNameA(0, Str, 0x100u);
  v10 = strrchr(Str, '\\');
  if ( v10 )
    *v10 = 0;
  else
    Str[0] = 0;
  if ( arenaa->HasScoreFile )
  {
    sprintf(arenaa->SettingsFilename, "%s\\%s.cfg", Str, arenaa->ArenaName);
    sprintf(arenaa->MapFilename, "%s.lvl", arenaa->ArenaName);
    sprintf(arenaa->SetLevelMapFilename, "%s.lvl", arenaa->ArenaName);
    if ( _access(arenaa->SettingsFilename, 0) )
      RewriteSameFileSomething(arenaa->SettingsFilename, "server.cfg");
    LOBYTE(v11) = LoadBMPHeader2(arenaa->SetLevelMapFilename);
    if ( !v11 )
    {
      strcpy(arenaa->MapFilename, MiscDefaultLevelFile);
      GetTickCountt = GetTickCount;
    }
    v12 = time(0);
    sprintf(ArenaScoreFileName, "%d", v12);
    WritePrivateProfileStringA("Owner", "LastUsedStamp", ArenaScoreFileName, arenaa->SettingsFilename);
  }
  else
  {
    sprintf(arenaa->SettingsFilename, "%s\\server.cfg", Str);
    strcpy(arenaa->MapFilename, MiscDefaultLevelFile);
    strcpy(arenaa->SetLevelMapFilename, MiscDefaultLevelFile);
    GetTickCountt = GetTickCount;
  }
  printf("Arena Created: (%s) using parameters: %s\n", arenaa->ArenaName, arenaa->SettingsFilename);
  LoadArenaSettings_0_0(arenaa);
  LoadArenaMapSomething(arenaa);
  arenaa->field_1001A = 0;
  arenaa->LastKotHGameResetCheckTime = GetTickCountt() / 0xA;
  arenaa->LastArenaSettingsUpdateTime = GetTickCountt() / 0xA;
  arenaa->LastTerritoryRewardTime = GetTickCountt() / 0xA;
  arenaa->LastPeriodicRewardTime = GetTickCountt() / 0xA;
  arenaa->NumOfBricksInArena = 0;
  arenaa->ArenaPlayerCount = 0;
  arenaa->TotalScoreStructs = 0;
  arenaa->ArenaLocked = 0;
  arenaa->ArenaJackpot = 0;
  arenaa->Freq1Score = 0;
  arenaa->Freq2Score = 0;
  arenaa->Freq3Score = 0;
  arenaa->Freq4Score = 0;
  v13 = arenaa->ServersideArenaSettings.RandomFlags;
  arenaa->FlagCounter = 0;
  arenaa->TotalSoccerBalls = 0;
  if ( v13 && (int)arenaa->ServersideArenaSettings.MaxFlags > 0 )
    v14 = rand() % arenaa->ServersideArenaSettings.MaxFlags + 1;
  else
    v14 = arenaa->ServersideArenaSettings.MaxFlags;
  arenaa->TotalFlags = v14;
  arenaa->LastFlagResetTime = GetTickCountt() / 0xA;
  v15 = rand();
  arenaa->DoorSeedValue = rand() * v15;
  v16 = rand();
  arenaa->PrizeSeedValue = rand() * v16;
  v17 = GetTickCountt();
  arenaa->RandomScrtyDataIndex = 0;
  arenaa->SynchronizationTimeStamp = (v17 / 0xA) & 0x7FFFFFFF;
  arenaa->SettingsChecksum = 0;
  arenaa->MapLVLChecksum = 0;
  arenaa->BrickIdCounter = 0;
  arenaa->GameTimeStart = 0;
  arenaa->GameTimePassed = 0;
  arenaa->field_FF56 = 0;
  arenaa->field_FF20 = 0;
  v18 = 3435973837i64 * GetTickCountt();
  LOBYTE(v18) = arenaa->ArenaName[0];
  arenaa->RecordPointsToLog = 1;
  arenaa->field_FF4E = HIDWORD(v18) >> 3;
  if ( (_BYTE)v18 && !ArenaSpawnKeepScores )
    arenaa->RecordPointsToLog = 0;
  if ( arenaa->HasScoreFile )
    arenaa->RecordPointsToLog = 0;
  if ( arenaa->ServersideArenaSettings.FlagMode == 2 )
  {
    v19 = arenaa->TotalMapTurfFlags;
    if ( arenaa->FlagCounter < v19 )
    {
      v20 = 0;
      arenaa->FlagCounter = v19;
      if ( v19 > 0 )
      {
        v21 = arenaa->Flags;
        do
        {
          v21->XTile = v21[726].CarrierPlayerId;// arena->TurfFlagsCoordinates[v27].XTile;
          v21->YTile = v21[726].OwnerFreq;      // arena->TurfFlagsCoordinates[v27].YTile;
          v21->OwnerFreq = -1;
          v21->CarrierPlayerId = -1;
          ++v20;
          ++v21;
        }
        while ( v20 < arenaa->TotalMapTurfFlags );
      }
    }
  }
  ArenaScoreReset(arenaa, 0);
  arenaa->TotalScoreStructs = 0;
  arenaa->LastTimedGameTime = GetTickCountt() / 0xA;
  arenaa->field_FF20 = 0;
  SoccerGameSomething(arenaa, -1);
  return arenaa;
}
// 401271: variable 'v11' is possibly undefined
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 437B10: using guessed type int ArenaSpawnKeepScores;
// 4D45C0: using guessed type int CustomArenaMode;

//----- (00401590) --------------------------------------------------------
void __thiscall ShutdownArena(struct ARENA *arenaa)
{
  int current_player_counter; // esi
  PLAYER **player; // eax
  int v4; // ecx
  SCORE *v5; // edx
  SCORE *v6; // ecx
  PLAYER *v7; // ecx
  char *v8; // eax
  char *v9; // eax
  DWORD GetTickCountt; // kr00_4
  int v11; // eax
  FILE *v12; // eax
  FILE *v13; // esi
  char Filename[32]; // [esp+10h] [ebp-20h] BYREF

  current_player_counter = 0;
  if ( arenaa->ArenaPlayerCount > 0 )
  {
    player = (PLAYER **)arenaa->playerPointersForSomething;
    do
    {
      if ( !arenaa->ServersideArenaSettings.MiscTimedGame )
      {
        if ( arenaa->HasScoreFile )
        {
          v4 = (*player)->MyArenaScoreIndex;
          if ( v4 >= 0 )
          {
            v5 = (SCORE *)&(*player)->CurrentWins;
            v6 = (SCORE *)&arenaa->ScoreFilePointer[v4].Wins;
            v6->UserId = v5->UserId;
            *(_DWORD *)&v6->Wins = *(_DWORD *)&v5->Wins;
            *(_DWORD *)&v6->Goals = *(_DWORD *)&v5->Goals;
            HIWORD(v6->Points) = HIWORD(v5->Points);
          }
        }
      }
      v7 = *player;
      ++current_player_counter;
      ++player;
      v7->MyArena = 0;
      (*(player - 1))->AlreadySentReliablePacket = 1;
    }
    while ( current_player_counter < arenaa->ArenaPlayerCount );
  }
  v8 = arenaa->MapAllocatedMemory;
  if ( v8 && v8 != ServerMapAllocatedMemory )
    efree(arenaa->MapAllocatedMemory);
  v9 = arenaa->CompressedMap;
  if ( v9 && v9 != CompressedServerMap )
    efree(arenaa->CompressedMap);
  if ( arenaa->ScoreFilePointer )
  {
    GetTickCountt = GetTickCount();
    v11 = arenaa->HasScoreFile;
    arenaa->LastSaveStatsTime = GetTickCountt / 0xA;
    if ( v11 )
    {
      strcpy(Filename, arenaa->ArenaName);
      strcat(Filename, ".scr");
      v12 = fopen(Filename, "wb");
      v13 = v12;
      if ( v12 )
      {
        fwrite(arenaa->ScoreFilePointer, 0x12u, arenaa->TotalNumScoresInFile, v12);
        fclose(v13);
      }
    }
    efree(arenaa->ScoreFilePointer);
  }
}

//----- (00401720) --------------------------------------------------------
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team)
{
  int BrickResendCounter; // ebp
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  char *v9; // edi
  int v10; // ebx
  char *v11; // edi
  signed int Y2Tile; // [esp+10h] [ebp-110h] BYREF
  int Y1Tile; // [esp+14h] [ebp-10Ch] BYREF
  int X2Tile; // [esp+18h] [ebp-108h] BYREF
  int X1Tile; // [esp+1Ch] [ebp-104h] BYREF
  char buf[256]; // [esp+20h] [ebp-100h] BYREF

  if ( arenaa->NumOfBricksInArena < 1024 )
  {
    DoBrickDrop(
      arenaa->MapAllocatedMemory,
      XTiles,
      YTiles,
      &X1Tile,
      &Y1Tile,
      &X2Tile,
      &Y2Tile,
      arenaa->ServersideArenaSettings.BrickSpan);
    if ( X1Tile != X2Tile || Y1Tile != Y2Tile )
    {
      arenaa->Bricks[arenaa->NumOfBricksInArena].X1Tile = X1Tile;
      arenaa->Bricks[arenaa->NumOfBricksInArena].Y1Tile = Y1Tile;
      arenaa->Bricks[arenaa->NumOfBricksInArena].X2Tile = X2Tile;
      arenaa->Bricks[arenaa->NumOfBricksInArena].field_6 = Y2Tile;// field_6 (optimizated ASM)
      arenaa->Bricks[arenaa->NumOfBricksInArena].Team = Team;
      arenaa->Bricks[arenaa->NumOfBricksInArena].BrickId = arenaa->BrickIdCounter++;
      BrickResendCounter = 0;
      arenaa->Bricks[arenaa->NumOfBricksInArena].BrickTimeStamp = (GetTickCount() / 0xA) & 0x7FFFFFFF;
      v6 = arenaa->NumOfBricksInArena;
      buf[0] = 33;
      *(_DWORD *)&buf[1] = *(_DWORD *)&arenaa->Bricks[v6].X1Tile;
      *(_DWORD *)&buf[5] = *(_DWORD *)&arenaa->Bricks[v6].X2Tile;
      *(_DWORD *)&buf[9] = *(_DWORD *)&arenaa->Bricks[v6].Team;
      v7 = arenaa->ServersideArenaSettings.RoutingWallResendCount;
      *(_DWORD *)&buf[13] = arenaa->Bricks[v6].BrickTimeStamp;
      if ( v7 > 0 )
      {
        do
        {
          v8 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            v9 = arenaa->playerPointersForSomething;
            do
            {
              if ( !*(_DWORD *)(*(_DWORD *)v9 + 56) )
                SendPlayerReliablePacket(*(struct PLAYER **)v9, buf, 17u, 0);
              ++v8;
              v9 += 4;
            }
            while ( v8 < arenaa->ArenaPlayerCount );
          }
          SendPacketsToEverybody(ServerPacketAttachment);
          ++BrickResendCounter;
        }
        while ( BrickResendCounter < arenaa->ServersideArenaSettings.RoutingWallResendCount );
      }
      v10 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v11 = arenaa->playerPointersForSomething;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v11 + 56) )
            SendPlayerReliablePacket(*(struct PLAYER **)v11, buf, 0x11u, 1);
          ++v10;
          v11 += 4;
        }
        while ( v10 < arenaa->ArenaPlayerCount );
      }
      ++arenaa->NumOfBricksInArena;
    }
  }
}

//----- (00401920) --------------------------------------------------------
void __thiscall PlayerEntering(struct ARENA *arena, struct PLAYER *player)
{
  signed int v3; // edx
  int IsStaffBoolean; // eax
  signed int playerUserId; // edi
  int maxCounter; // eax
  SCORE *scoreFileAddress; // edx
  int each_count; // esi
  SCORE *CurrentScore; // ecx
  int v10; // eax
  SCORE *scoreFilePointerr; // eax
  __int16 *v12; // ecx
  SCORE *v13; // eax
  int v14; // edx
  SCORE *v15; // edi
  int scoreCount; // eax
  signed int userID; // esi
  int v18; // edx
  SCORE *v19; // ecx
  int v20; // eax
  PLAYER *v21; // esi
  int v22; // ecx
  int v23; // edx
  PLAYER **v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // esi
  char *v28; // ecx
  int v29; // eax
  int v30; // edx
  __int16 v31; // di
  int v32; // edi
  FLAG *v33; // esi
  __int16 v34; // cx
  __int16 v35; // dx
  char *v36; // esi
  PLAYER **v37; // edx
  PLAYER *v38; // edi
  char v39; // al
  int v40; // ecx
  int v41; // edx
  FLAG *v42; // eax
  bool v43; // cc
  int v44; // eax
  PLAYER *v45; // eax
  __int16 v46; // ax
  BRICK v47; // rax
  int v48; // edx
  int v49; // eax
  __int16 v50; // dx
  __int16 v51; // cx
  char v52; // al
  __int16 v53; // dx
  __int16 v54; // ax
  int v55; // ecx
  int v56; // edx
  KD_STRUCT *v57; // eax
  KD_STRUCT v58; // edx
  int v59; // ecx
  PLAYER_DATA_BILLER_PACKET_STRUCT *v60; // [esp-4h] [ebp-5454h]
  char v61; // [esp+13h] [ebp-543Dh] BYREF
  PLAYER **v62; // [esp+14h] [ebp-543Ch]
  int v63; // [esp+18h] [ebp-5438h]
  KD_STRUCT *KD; // [esp+1Ch] [ebp-5434h]
  unsigned __int8 *v65; // [esp+20h] [ebp-5430h]
  char packetBuffer[16]; // [esp+24h] [ebp-542Ch] BYREF
  char v67[20]; // [esp+34h] [ebp-541Ch] BYREF
  char Dest[64]; // [esp+48h] [ebp-5408h] BYREF
  char v69[24]; // [esp+88h] [ebp-53C8h] BYREF
  char v70[99]; // [esp+A0h] [ebp-53B0h] BYREF
  char EmptyBanner[128]; // [esp+104h] [ebp-534Ch] BYREF
  char v72[460]; // [esp+184h] [ebp-52CCh] BYREF
  char buf[4096]; // [esp+350h] [ebp-5100h] BYREF
  char v74[16640]; // [esp+1350h] [ebp-4100h] BYREF

  if ( arena->HasScoreFile )
  {
    if ( arena->ServersideArenaSettings.OwnerUserId == -1 && !arena->ArenaPlayerCount )
    {
      v3 = player->PlayerDataBillerPacket.UserId;
      if ( v3 >= 0 )
      {
        IsStaffBoolean = 0;
        switch ( CustomArenaMode )
        {
          case 1:
            goto IS_STAFF;
          case 2:
            if ( player->IsModerator )
              goto IS_STAFF;
            break;
          case 3:
            if ( player->IsSuperModerator )
              goto IS_STAFF;
            break;
          case 4:
            if ( player->IsSysop )
IS_STAFF:
              IsStaffBoolean = 1;
            break;
          default:
            break;
        }
        if ( IsStaffBoolean )
        {
          arena->ServersideArenaSettings.OwnerUserId = v3;
          strcpy(arena->ServersideArenaSettings.OwnerName, player->PlayerDataBillerPacket.Name);
          sprintf(packetBuffer, "%d", player->PlayerDataBillerPacket.UserId);
          WritePrivateProfileStringA("Owner", "UserId", packetBuffer, arena->SettingsFilename);
          WritePrivateProfileStringA("Owner", "Name", player->PlayerDataBillerPacket.Name, arena->SettingsFilename);
        }
      }
    }
  }
  KD = (KD_STRUCT *)&player->CurrentWins;
  *(_DWORD *)&player->LastCurrentWins = *(_DWORD *)&player->CurrentWins;
  *(_DWORD *)&player->LastGoalCount = *(_DWORD *)&player->CurrentGoals;
  *(int *)((char *)&player->LastKillPoints + 2) = *(int *)((char *)&player->KillPoints + 2);
  HIWORD(player->LastFlagPoints) = HIWORD(player->FlagPoints);
  *(_DWORD *)&arena->playerPointersForSomething[4 * arena->ArenaPlayerCount++] = player;
  player->MyArena = arena;
  *(_DWORD *)&player->PositionByteThree = 0;
  *(int *)((char *)&player->PingTimestamp + 2) = 0;
  *(_DWORD *)&player->YPixels = 0;
  *(_DWORD *)&player->XPixels = 0;
  *(_DWORD *)&player->Bounty = 0;
  player->WeaponsInfo = 0;
  player->Bounty = 10000;
  player->LastSecurityPacketReturnedTime = 0;
  player->SecurityWeaponCountyTotalNew = 0;
  player->SecurityWeaponCountTotal = 0;
  player->SecurityWeaponCount = 0;
  *(_DWORD *)&player->AttachedToPlayerId = -1;
  player->DebtKills = arena->ServersideArenaSettings.KillDebtKills;
  player->KotHDeathCount = 0;
  player->KingCrownKills = 0;
  player->MySoccerReward = 0;
  player->MyArenaScoreIndex = -1;
  if ( arena->HasScoreFile )
  {
    playerUserId = player->PlayerDataBillerPacket.UserId;
    if ( playerUserId >= 0 )
    {
      maxCounter = arena->TotalNumScoresInFile;
      scoreFileAddress = arena->ScoreFilePointer;
      each_count = 0;
      for ( CurrentScore = scoreFileAddress; each_count < maxCounter; ++each_count )
      {
        if ( CurrentScore->UserId == playerUserId )
          break;
        ++CurrentScore;
      }
      if ( each_count == maxCounter )           // Hit Last Score
                                                // 
      {
        v10 = maxCounter + 1;
        arena->TotalNumScoresInFile = v10;
        scoreFilePointerr = (SCORE *)ExpandMemory(scoreFileAddress, 18 * v10, 0x10000);
        arena->ScoreFilePointer = scoreFilePointerr;
        scoreFilePointerr[each_count].UserId = player->PlayerDataBillerPacket.UserId;
        v12 = &arena->ScoreFilePointer[each_count].Wins;
        *(_DWORD *)v12 = 0;
        *((_DWORD *)v12 + 1) = 0;
        *((_DWORD *)v12 + 2) = 0;
        v12[6] = 0;
      }
      player->MyArenaScoreIndex = each_count;
      v13 = (SCORE *)&arena->ScoreFilePointer[each_count].Wins;
      v14 = (int)KD;
      *KD = (KD_STRUCT)v13->UserId;
      *(_DWORD *)(v14 + 4) = *(_DWORD *)&v13->Wins;
      *(_DWORD *)(v14 + 8) = *(_DWORD *)&v13->Goals;
      *(_WORD *)(v14 + 12) = HIWORD(v13->Points);
      *(_DWORD *)&player->PersonalBestWins = v13->UserId;
      *(_DWORD *)&player->PersonalBestGoalCount = *(_DWORD *)&v13->Wins;
      *(int *)((char *)&player->PersonalBestKillPoints + 2) = *(_DWORD *)&v13->Goals;
      HIWORD(player->PersonalBestFlagPoints) = HIWORD(v13->Points);
    }
  }
  if ( (int)arena->ServersideArenaSettings.MiscTimedGame > 0 )
  {
    v15 = (SCORE *)KD;
    scoreCount = 0;
    player->CurrentLosses = 0;
    player->KillPoints = 0;
    LOWORD(v15->UserId) = 0;
    player->FlagPoints = 0;
    player->CurrentGoals = 0;
    userID = player->PlayerDataBillerPacket.UserId;
    if ( userID >= 0 )
    {
      v18 = arena->TotalScoreStructs;
      if ( v18 > 0 )
      {
        v19 = (SCORE *)arena->gap_1003E;
        while ( v19->UserId != userID )
        {
          ++scoreCount;
          ++v19;
          if ( scoreCount >= v18 )
            goto LABEL_30;
        }
        v15->UserId = *(_DWORD *)&arena->gap_1003E[18 * scoreCount + 4];
        *(_DWORD *)&v15->Wins = *(_DWORD *)&arena->gap_1003E[18 * scoreCount + 8];
        *(_DWORD *)&v15->Goals = *(_DWORD *)&arena->gap_1003E[18 * scoreCount + 12];
        HIWORD(v15->Points) = *(_WORD *)&arena->gap_1003E[18 * scoreCount + 16];
      }
LABEL_30:
      if ( scoreCount == arena->TotalScoreStructs )
      {
        v15->UserId = 0;
        *(_DWORD *)&v15->Wins = 0;
        *(_DWORD *)&v15->Goals = 0;
        HIWORD(v15->Points) = 0;
      }
    }
  }
  v20 = arena->ServersideArenaSettings.MiscMaxLossesToPlay;
  if ( v20 > 0 && (unsigned __int16)player->CurrentLosses >= v20 )
    *(_DWORD *)&player->Ship = 8;
  if ( !player->IsModerator )
  {
    v21 = (PLAYER *)arena->ServersideArenaSettings.MiscMaxPlaying;
    if ( (int)v21 > 0 )
    {
      v22 = arena->ArenaPlayerCount;
      v23 = 0;
      if ( v22 > 0 )
      {
        v24 = (PLAYER **)arena->playerPointersForSomething;
        do
        {
          if ( *(_DWORD *)&(*v24)->Ship != 8 )
            ++v23;
          ++v24;
          --v22;
        }
        while ( v22 );
      }
      if ( v23 > (int)v21 )
        *(_DWORD *)&player->Ship = 8;
    }
  }
  if ( player->DemoPlayer )
  {
    v25 = *(_DWORD *)&player->Ship;
    if ( v25 == 5 || v25 == 6 || v25 == 4 || v25 == 7 )
      *(_DWORD *)&player->Ship = 8;
  }
  if ( arena->ArenaLocked )
    *(_DWORD *)&player->Ship = 8;
  v60 = &player->PlayerDataBillerPacket;
  if ( *(_DWORD *)&player->Ship == 8 )
  {
    printf("Player spectating game: %s\n", v60->Name);
    *(_DWORD *)&player->Frequency = arena->ServersideArenaSettings.TeamSpectatorFrequency;
  }
  else
  {
    printf("Player entering game: %s\n", v60->Name);
    v26 = GetNextFrequencyToJoin(arena);
    *(_DWORD *)&player->Frequency = v26;
    if ( arena->ServersideArenaSettings.MiscFrequencyShipTypes )
      *(_DWORD *)&player->Ship = v26 % 8;
  }
  SendPlayerReliablePacket(player, &arena->ArenaSettings, 0x594u, 1);
  if ( arena->ServersideArenaSettings.FlagMode == 2 )
  {
    v27 = arena->FlagCounter;
    buf[0] = 0x22;                              // 0x22 - Turf Flag Update
    v28 = &buf[1];
    if ( v27 > 0 )
    {
      v29 = (int)&arena->Flags[0].OwnerFreq;    // Loop only OwnerFreq's of all flags
      v30 = v27;
      do
      {
        v31 = *(_WORD *)v29;
        v29 += 16;
        *(_WORD *)v28 = v31;
        v28 += 2;
        --v30;
      }
      while ( v30 );
    }
    SendPlayerReliablePacket(player, buf, 2 * v27 + 1, 1);
  }
  else
  {
    v32 = 0;
    if ( arena->FlagCounter > 0 )
    {
      v33 = arena->Flags;
      do
      {
        if ( v33->CarrierPlayerId == -1 && v33->XTile >= 0 && v33->YTile >= 0 )
        {
          v34 = v33->YTile;
          v35 = v33->OwnerFreq;
          *(_WORD *)&packetBuffer[3] = v33->XTile;
          *(_WORD *)&packetBuffer[5] = v34;
          packetBuffer[0] = 0x12;
          *(_WORD *)&packetBuffer[7] = v35;
          *(_WORD *)&packetBuffer[1] = v32;
          SendPlayerReliablePacket(player, packetBuffer, 9u, 1);
        }
        ++v32;
        ++v33;
      }
      while ( v32 < arena->FlagCounter );
    }
  }
  v63 = 0;
  memset(EmptyBanner, 0, sizeof(EmptyBanner));
  v36 = v72;
  if ( arena->ArenaPlayerCount > 0 )
  {
    v62 = (PLAYER **)arena->playerPointersForSomething;
    do
    {
      v37 = v62;
      *v36 = 3;
      v38 = *v37;
      *(_WORD *)(v36 + 51) = (*v37)->PlayerId;
      *(_WORD *)(v36 + 59) = v38->AttachedToPlayerId;
      v36[2] = v38->AllowAudioByte;
      *(_WORD *)(v36 + 53) = v38->Frequency;
      v36[1] = v38->Ship;
      *(_WORD *)(v36 + 55) = v38->CurrentWins;
      *(_WORD *)(v36 + 57) = v38->CurrentLosses;
      *(_DWORD *)(v36 + 43) = v38->KillPoints;
      *(_DWORD *)(v36 + 47) = v38->FlagPoints;
      v36[63] = v38->KotHDeathCount != 0;
      strncpy(v36 + 3, v38->PlayerDataBillerPacket.Name, 0x14u);
      v36[22] = 0;
      strncpy(v36 + 23, v38->PlayerDataBillerPacket.Squad, 0x14u);
      v39 = arena->ArenaSettings.CarryFlags;
      v36[42] = 0;
      *(_WORD *)(v36 + 61) = 0;                 // Flags Held
      if ( v39 )
      {
        v40 = arena->FlagCounter;
        if ( v40 > 0 )
        {
          v41 = *(__int16 *)(v36 + 51);         // Player ID?
          v42 = (FLAG *)&arena->Flags[0].CarrierPlayerId;
          do
          {
            if ( v42->XTile == v41 )
              ++*(_WORD *)(v36 + 61);
            ++v42;
            --v40;
          }
          while ( v40 );
        }
      }
      v36 += 64;
      if ( (unsigned int)(v36 - v72 + 64) > 0x1CC )
      {
        SendPlayerReliablePacket(player, v72, v36 - v72, 1);
        v36 = v72;
      }
      v43 = ++v63 < arena->ArenaPlayerCount;
      ++v62;
    }
    while ( v43 );
  }
  if ( v36 != v72 )
    SendPlayerReliablePacket(player, v72, v36 - v72, 1);
  v44 = arena->ArenaPlayerCount;
  v63 = 0;
  if ( v44 > 0 )
  {
    v62 = (PLAYER **)arena->playerPointersForSomething;
    do
    {
      v45 = *v62;
      if ( (*v62)->FlagPoints + (*v62)->KillPoints >= arena->ServersideArenaSettings.MiscBannerPoints
        || v45->ForceWearBanner )
      {
        v65 = v45->PlayerDataBillerPacket.BannerData;
        if ( memcmp(EmptyBanner, v45->PlayerDataBillerPacket.BannerData, 0x60u) )
        {
          v46 = v45->PlayerId;
          v70[0] = 0x1F;                        // 0x1F - Player Banner Changed
          *(_WORD *)&v70[1] = v46;
          qmemcpy(&v70[3], v65, 0x60u);
          SendPlayerReliablePacket(player, v70, 0x63u, 1);
        }
      }
      v43 = ++v63 < arena->ArenaPlayerCount;
      ++v62;
    }
    while ( v43 );
  }
  *(_DWORD *)&v47.X1Tile = 16 * arena->NumOfBricksInArena;
  v74[0] = 0x21;                                // 0x21 - Brick Dropped
  qmemcpy(&v74[1], arena->Bricks, *(unsigned int *)&v47.X1Tile);
  SendPlayerReliablePacket(player, v74, *(_DWORD *)&v47.X1Tile + 1, 1);
  v69[0] = 0x29;                                // 0x29 - Map Information
  strcpy(&v69[1], arena->MapFilename);
  *(_DWORD *)&v69[17] = arena->MapChecksum;
  SendPlayerReliablePacket(player, v69, 0x15u, 1);
  if ( AdvertiseSendMode == 3 || AdvertiseSendMode == 1 )
    SendAdvertisement(player, 1);
  v61 = 2;
  SendPlayerReliablePacket(player, &v61, 1u, 1);
  player->XPixels = -9999;
  player->YPixels = -9999;
  v48 = arena->PrizeSeedValue;
  v49 = arena->SynchronizationTimeStamp;
  *(_DWORD *)&v67[5] = arena->DoorSeedValue;
  v67[0] = 0x18;                                // 0x18 - Synchronization Request
  *(_DWORD *)&v67[1] = v48;
  *(_DWORD *)&v67[9] = v49;
  *(_DWORD *)&v67[13] = 0;
  SendPlayerReliablePacket(player, v67, 17u, 1);
  v50 = player->PlayerId;
  v51 = player->Frequency;
  Dest[1] = player->Ship;
  v52 = player->AllowAudioByte;
  *(_WORD *)&Dest[51] = v50;
  v53 = player->AttachedToPlayerId;
  Dest[2] = v52;
  v54 = player->CurrentLosses;
  *(_WORD *)&Dest[53] = v51;
  *(_WORD *)&Dest[57] = v54;
  *(_WORD *)&Dest[59] = v53;
  v55 = player->KillPoints;
  *(_WORD *)&Dest[55] = KD->Wins;
  v56 = player->FlagPoints;
  Dest[0] = 3;
  *(_DWORD *)&Dest[43] = v55;
  *(_DWORD *)&Dest[47] = v56;
  *(_WORD *)&Dest[61] = 0;
  strncpy(&Dest[3], player->PlayerDataBillerPacket.Name, 0x14u);
  Dest[22] = 0;
  strncpy(&Dest[23], player->PlayerDataBillerPacket.Squad, 0x14u);
  Dest[42] = 0;
  SendEverybodyButYourself(player, Dest, 0x40u, 1);
  if ( player->KillPoints + player->FlagPoints >= arena->ServersideArenaSettings.MiscBannerPoints
    || player->ForceWearBanner )
  {
    if ( memcmp(EmptyBanner, player->PlayerDataBillerPacket.BannerData, 0x60u) )
    {
      *(_WORD *)&v70[1] = player->PlayerId;
      v70[0] = 0x1F;                            // 0x1F - Player Banner Changed
      qmemcpy(&v70[3], player->PlayerDataBillerPacket.BannerData, 0x60u);
      SendEverybodyButYourself(player, v70, 0x63u, 1);
    }
  }
  v57 = KD;
  v58 = KD[1];
  *(KD_STRUCT *)&player->WinsSomething = *KD;
  v59 = (int)v57[2];
  *(KD_STRUCT *)&player->GoalsSomething = v58;
  v58.Wins = v57[3].Wins;
  *(int *)((char *)&player->KillPointsSomething + 2) = v59;
  HIWORD(player->FlagPointsSomething) = v58.Wins;
}
// 4314B0: using guessed type int AdvertiseSendMode;
// 4D45C0: using guessed type int CustomArenaMode;

//----- (004022D0) --------------------------------------------------------
// Arena.RemovePlayer()
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player)
{
  PLAYER *v2; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  char *v8; // edi
  int v9; // ecx
  PLAYER **v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  PLAYER **v14; // ecx
  int v15; // eax
  bool v16; // zf
  signed int v17; // edi
  int v18; // edx
  int v19; // eax
  SCORE *v20; // ecx
  char *v21; // edx
  int v22; // eax
  int v23; // eax
  __int16 *v24; // edx
  int v25; // eax
  struct PLAYER *v26; // eax
  int v27; // edi
  int v28; // eax
  char *v29; // ebp
  __int16 *v30; // ecx
  __int16 *v31; // ebx

  v2 = player;
  UpdatePowerBallPositionsSomething(player);
  v4 = v2->field_50;
  v5 = v2->field_54;
  v2->MyArena = 0;
  if ( v4 >= 0 && v5 >= 0 && v4 < 8 && v5 < 8 )
  {
    v6 = 251 * (v5 + 8 * v4);
    v7 = 0;
    v8 = &arenaa->PlayerPointers[4 * v6];
    v9 = *((_DWORD *)v8 + 250);
    if ( v9 > 0 )
    {
      v10 = (PLAYER **)v8;
      while ( *v10 != v2 )
      {
        ++v7;
        ++v10;
        if ( v7 >= v9 )
          goto LABEL_11;
      }
      v11 = v9 - 1;
      *((_DWORD *)v8 + 250) = v11;
      *(_DWORD *)&v8[4 * v7] = *(_DWORD *)&v8[4 * v11];
    }
  }
LABEL_11:
  v12 = arenaa->ArenaPlayerCount;
  v13 = 0;
  if ( v12 > 0 )
  {
    v14 = (PLAYER **)arenaa->playerPointersForSomething;
    while ( *v14 != v2 )
    {
      ++v13;
      ++v14;
      if ( v13 >= v12 )
        goto LABEL_17;
    }
    arenaa->ArenaPlayerCount = v12 - 1;
    memcpy(
      &arenaa->playerPointersForSomething[4 * v13],
      &arenaa->playerPointersForSomething[4 * v13 + 4],
      4 * (v12 - 1 + 0x3FFFFFFF * v13));
  }
LABEL_17:
  v15 = arenaa->ServersideArenaSettings.MiscTimedGame;
  v16 = v15 == 0;
  if ( v15 > 0 )
  {
    v17 = v2->PlayerDataBillerPacket.UserId;
    if ( v17 >= 0 )
    {
      v18 = arenaa->TotalScoreStructs;
      v19 = 0;
      if ( v18 > 0 )
      {
        v20 = (SCORE *)arenaa->gap_1003E;
        while ( v20->UserId != v17 )
        {
          ++v19;
          ++v20;
          if ( v19 >= v18 )
            goto LABEL_25;
        }
        v21 = &arenaa->gap_1003E[18 * v19 + 4];
        *(_DWORD *)v21 = *(_DWORD *)&v2->CurrentWins;
        *((_DWORD *)v21 + 1) = *(_DWORD *)&v2->CurrentGoals;
        *((_DWORD *)v21 + 2) = *(int *)((char *)&v2->KillPoints + 2);
        *((_WORD *)v21 + 6) = HIWORD(v2->FlagPoints);
      }
LABEL_25:
      if ( v19 == arenaa->TotalScoreStructs && v19 < 1000 )
      {
        v22 = (int)&arenaa->PlayerPointers[18 * v19];
        *(_DWORD *)(v22 + 65598) = v2->PlayerDataBillerPacket.UserId;
        v22 += 65602;                           // This means +4 (so skip UserId in struct)
        *(_DWORD *)v22 = *(_DWORD *)&v2->CurrentWins;
        *(_DWORD *)(v22 + 4) = *(_DWORD *)&v2->CurrentGoals;
        *(_DWORD *)(v22 + 8) = *(int *)((char *)&v2->KillPoints + 2);
        *(_WORD *)(v22 + 12) = HIWORD(v2->FlagPoints);
        ++arenaa->TotalScoreStructs;
      }
    }
    v16 = arenaa->ServersideArenaSettings.MiscTimedGame == 0;
  }
  if ( v16 )
  {
    if ( arenaa->HasScoreFile )
    {
      v23 = v2->MyArenaScoreIndex;
      if ( v23 >= 0 )
      {
        v24 = &arenaa->ScoreFilePointer[v23].Wins;
        *(_DWORD *)v24 = *(_DWORD *)&v2->CurrentWins;
        *((_DWORD *)v24 + 1) = *(_DWORD *)&v2->CurrentGoals;
        *((_DWORD *)v24 + 2) = *(int *)((char *)&v2->KillPoints + 2);
        v24[6] = HIWORD(v2->FlagPoints);
      }
    }
  }
  if ( v2->IsSysop )
  {
    v25 = v2->ArenaPlayerIndex;
    if ( v25 >= 0 )
    {
      v26 = ZonePlayerList[v25];
      LOWORD(player) = 0x1C;
      if ( v26 )
        SendPlayerReliablePacket(v26, &player, 2u, 1);
    }
  }
  if ( ZonePlayerCount > 0 )
  {
    v27 = 0;
    *(_WORD *)((char *)&player + 1) = v2->PlayerId;
    v28 = arenaa->ArenaPlayerCount;
    LOBYTE(player) = 4;
    if ( v28 > 0 )
    {
      v29 = arenaa->playerPointersForSomething;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v29 + 56) )
          SendPlayerReliablePacket(*(struct PLAYER **)v29, &player, 3u, 1);
        ++v27;
        v29 += 4;
      }
      while ( v27 < arenaa->ArenaPlayerCount );
    }
  }
  CarryFlagsSomething(arenaa, *(_DWORD *)&v2->PlayerId, 0);
  if ( !arenaa->RecordPointsToLog )
  {
    v30 = &v2->LastCurrentWins;
    v31 = &v2->CurrentWins;
    *(_DWORD *)v31 = *(_DWORD *)v30;
    *((_DWORD *)v31 + 1) = *((_DWORD *)v30 + 1);
    *((_DWORD *)v31 + 2) = *((_DWORD *)v30 + 2);
    v31[6] = v30[6];
  }
}

//----- (00402560) --------------------------------------------------------
bool __thiscall ProcessArena(struct ARENA *arenaa)
{
  __int64 v3; // rax
  int v4; // edi
  PLAYER **v5; // esi
  DWORD (__stdcall *GetTickCountt)(); // ebx
  __int64 v7; // rax
  FILE *v8; // eax
  FILE *v9; // esi
  __int64 v10; // rax
  struct ARENA *v11; // eax
  unsigned int v12; // kr1C_4
  int v13; // edi
  char *v14; // ebx
  bool v15; // cc
  int v16; // esi
  char *v17; // ecx
  int *v18; // eax
  int v19; // edx
  __int16 v20; // di
  unsigned int v21; // ebx
  int v22; // esi
  char *v23; // edi
  __int64 v24; // rax
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  char *v28; // esi
  DWORD v29; // kr04_4
  int v30; // eax
  int v31; // eax
  int v32; // esi
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  ARENA_SETTINGS *v36; // eax
  signed int v37; // ebx
  int v38; // edx
  int v39; // esi
  int v40; // edi
  PLAYER **v41; // esi
  int v42; // esi
  int v43; // esi
  int v44; // edx
  int v45; // esi
  int v46; // ecx
  int v47; // eax
  char *v48; // edi
  __int64 v49; // rax
  __int64 v50; // rax
  int v51; // eax
  int v52; // esi
  char *v53; // ebx
  int v54; // edi
  char *v55; // esi
  struct PLAYER *v56; // eax
  int v57; // ebx
  int v58; // ecx
  int v59; // eax
  int v60; // edi
  PLAYER **v61; // edx
  int v62; // esi
  PLAYER *v63; // eax
  int v64; // ecx
  int v65; // esi
  int v66; // eax
  char *v67; // ebx
  PLAYER **v68; // ebx
  int v69; // esi
  PLAYER *v70; // eax
  char *v71; // edi
  int v72; // esi
  char *v73; // edi
  int v74; // esi
  int v75; // eax
  __int64 v76; // rax
  int v77; // edi
  int *v78; // ebx
  int v79; // esi
  int v80; // edx
  int v81; // eax
  int *v82; // ecx
  int v83; // ecx
  PLAYER **v84; // eax
  bool v85; // zf
  int v86; // edx
  int v87; // eax
  char *v88; // ebx
  int v89; // esi
  int v90; // eax
  int v91; // ecx
  int v92; // ebx
  int v93; // ecx
  int v94; // edi
  int v95; // ecx
  struct PLAYER **v96; // ebx
  struct PLAYER *v97; // eax
  int v98; // esi
  int v99; // edi
  char *v100; // esi
  int v101; // ebx
  int v102; // eax
  PLAYER *v103; // eax
  int v104; // edi
  int v105; // ecx
  int *v106; // edx
  PLAYER *v107; // eax
  int v108; // edx
  FLAG *v109; // eax
  int j; // ecx
  int v111; // ecx
  int v112; // esi
  PLAYER **v113; // eax
  int v114; // eax
  DWORD v115; // eax
  int v116; // ecx
  int v117; // eax
  int v118; // ebx
  int v119; // esi
  PLAYER **v120; // ecx
  int v121; // edx
  PLAYER *v122; // eax
  int v123; // edi
  char *v124; // esi
  int v125; // ebx
  char *v126; // esi
  int v127; // eax
  int v128; // edi
  int v129; // eax
  int v130; // ecx
  __int16 *v131; // eax
  __int64 v132; // rax
  __int64 v133; // rax
  DWORD v134; // kr10_4
  int v135; // eax
  int v136; // edx
  int *v137; // ebx
  int v138; // edi
  int v139; // esi
  int v140; // eax
  int *v141; // ecx
  PLAYER **v142; // eax
  int v143; // ecx
  int v144; // ebx
  char *v145; // edi
  int v146; // eax
  int v147; // esi
  int v148; // esi
  int *v149; // eax
  char *v150; // edi
  __int16 v151; // cx
  struct PLAYER **v152; // ebx
  struct PLAYER *v153; // eax
  int v154; // edi
  int v155; // ebx
  char *v156; // esi
  __int64 v157; // rax
  int v158; // eax
  int v159; // esi
  char *v160; // edi
  int v161; // eax
  int v162; // esi
  char *v163; // edi
  int v164; // esi
  char *v165; // edi
  int v166; // esi
  signed int v167; // eax
  int v168; // esi
  char *v169; // edi
  DWORD v170; // eax
  PLAYER **v171; // esi
  int v172; // edi
  int v173; // ecx
  char *v174; // edx
  PLAYER *v175; // eax
  int v176; // ebx
  char *v177; // esi
  int v178; // eax
  int v179; // ecx
  int v180; // eax
  int v181; // eax
  int v182; // ecx
  __int16 *v183; // edx
  int v184; // eax
  int v185; // esi
  char *v186; // edi
  int v187; // esi
  char *v188; // edi
  int v189; // esi
  BRICK *v190; // ebx
  BRICK *v191; // edi
  int v192; // edx
  int *v193; // esi
  int soccerball; // ebx
  PLAYER *v195; // eax
  int v196; // esi
  int v197; // eax
  char v198; // dl
  char *v199; // edi
  ARENA **v200; // [esp+4h] [ebp-27DCh]
  int v201; // [esp+4h] [ebp-27DCh]
  int v202; // [esp+4h] [ebp-27DCh]
  int *v203; // [esp+4h] [ebp-27DCh]
  int v204; // [esp+4h] [ebp-27DCh]
  int v205; // [esp+4h] [ebp-27DCh]
  int *v206; // [esp+8h] [ebp-27D8h]
  int v207; // [esp+8h] [ebp-27D8h]
  int v208; // [esp+8h] [ebp-27D8h]
  int *v209; // [esp+8h] [ebp-27D8h]
  int v210; // [esp+Ch] [ebp-27D4h]
  int v211; // [esp+Ch] [ebp-27D4h]
  int v212; // [esp+Ch] [ebp-27D4h]
  char *v213; // [esp+Ch] [ebp-27D4h]
  int *v214; // [esp+Ch] [ebp-27D4h]
  char *v215; // [esp+Ch] [ebp-27D4h]
  char *v216; // [esp+Ch] [ebp-27D4h]
  int v217; // [esp+10h] [ebp-27D0h]
  int v218; // [esp+10h] [ebp-27D0h]
  int v219; // [esp+10h] [ebp-27D0h]
  int v220; // [esp+10h] [ebp-27D0h]
  char SoundByte; // [esp+14h] [ebp-27CCh]
  int SoundBytea; // [esp+14h] [ebp-27CCh]
  int *SoundByteb; // [esp+14h] [ebp-27CCh]
  char a3[8]; // [esp+18h] [ebp-27C8h] BYREF
  int *i; // [esp+20h] [ebp-27C0h]
  char buf[38]; // [esp+24h] [ebp-27BCh] BYREF
  char a2[6]; // [esp+4Ch] [ebp-2794h] BYREF
  int v228[384]; // [esp+5E0h] [ebp-2200h]
  int v229[384]; // [esp+BE0h] [ebp-1C00h] BYREF
  int FreqList[384]; // [esp+11E0h] [ebp-1600h] BYREF
  char v231[4096]; // [esp+17E0h] [ebp-1000h] BYREF

  if ( arenaa->ArenaRecycling )
    return 1;
  v3 = (int)(GetTickCount() / 0xA - arenaa->LastArenaSettingsUpdateTime);
  if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 6000 || arenaa->NeedSettingsUpdate )
  {
    arenaa->LastArenaSettingsUpdateTime = GetTickCount() / 0xA;
    if ( IsFileLastWrittenTime(arenaa->SettingsFilename, (int)&arenaa->LastSettingsWrittenTime)
      || arenaa->NeedSettingsUpdate )
    {
      arenaa->NeedSettingsUpdate = 0;
      qmemcpy(a2, &arenaa->ArenaSettings, 0x594u);
      LoadArenaSettings_0_0(arenaa);
      if ( !memcmp(a2, &arenaa->ArenaSettings, 0x594u) )
      {
        GetTickCountt = GetTickCount;
      }
      else
      {
        printf("Parameters resent for arena(%s)\n", arenaa->ArenaName);
        v4 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v5 = (PLAYER **)arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v5)->AlreadySentReliablePacket )
              SendPlayerReliablePacket(*v5, &arenaa->ArenaSettings, 0x594u, 1);
            ++v4;
            ++v5;
          }
          while ( v4 < arenaa->ArenaPlayerCount );
        }
        GetTickCountt = GetTickCount;
        arenaa->SettingsChecksum = 0;
        arenaa->MapLVLChecksum = 0;
      }
    }
    else
    {
      GetTickCountt = GetTickCount;
    }
    v7 = (int)(GetTickCountt() / 0xA - arenaa->LastSaveStatsTime);
    if ( (signed int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) > arenaa->ServersideArenaSettings.CustomSaveStatsTime )
    {
      if ( arenaa->ScoreFilePointer )
      {
        arenaa->LastSaveStatsTime = GetTickCountt() / 0xA;
        if ( arenaa->HasScoreFile )
        {
          strcpy(buf, arenaa->ArenaName);
          strcat(buf, ".scr");
          v8 = fopen(buf, "wb");
          v9 = v8;
          if ( v8 )
          {
            fwrite(arenaa->ScoreFilePointer, 0x12u, arenaa->TotalNumScoresInFile, v8);
            fclose(v9);
          }
        }
      }
    }
    v10 = (int)(GetTickCountt() / 0xA - arenaa->LastCheckArenaEmptyTime);
    if ( (int)((HIDWORD(v10) ^ v10) - HIDWORD(v10)) > 60000
      && arenaa->ArenaPlayerCount < ArenaMinimumPlayers
      && !arenaa->ArenaName[0] )
    {
      v210 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v200 = Arenas;
        do
        {
          v11 = *v200;
          if ( *v200 == arenaa )
            break;
          if ( v11->ArenaPlayerCount < ArenaDesiredPlayers && !v11->ArenaName[0] )
          {
            a2[0] = 7;
            a2[1] = 0;
            a2[2] = 2;
            *(_WORD *)&a2[3] = 0;
            strcpy(&a2[5], "Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.");
            v12 = strlen("Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.") + 1;
            v13 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v14 = arenaa->playerPointersForSomething;
              do
              {
                if ( !*(_DWORD *)(*(_DWORD *)v14 + 56) )
                  SendPlayerReliablePacket(*(struct PLAYER **)v14, a2, v12 - 1 + 6, 1);
                ++v13;
                v14 += 4;
              }
              while ( v13 < arenaa->ArenaPlayerCount );
            }
            GetTickCountt = GetTickCount;
            arenaa->LastCheckArenaEmptyTime = GetTickCount() / 0xA;
          }
          v15 = ++v210 < ArenaArrayLength;
          ++v200;
        }
        while ( v15 );
      }
    }
    if ( arenaa->ServersideArenaSettings.FlagMode == 2 )
    {
      v16 = arenaa->FlagCounter;
      v231[0] = 0x22;                           // 0x22 - Turf Flag Update
      v17 = &v231[1];
      if ( v16 > 0 )
      {
        v18 = &arenaa->Flags[0].OwnerFreq;
        v19 = v16;
        do
        {
          v20 = *(_WORD *)v18;
          v18 += 4;
          *(_WORD *)v17 = v20;
          v17 += 2;
          --v19;
        }
        while ( v19 );
      }
      v21 = 2 * v16 + 1;
      v22 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v23 = arenaa->playerPointersForSomething;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v23 + 56) )
            SendPlayerReliablePacket(*(struct PLAYER **)v23, v231, v21, 1);
          ++v22;
          v23 += 4;
        }
        while ( v22 < arenaa->ArenaPlayerCount );
      }
    }
    else
    {
      v24 = (int)(GetTickCountt() / 0xA - arenaa->field_FF4E);
      if ( (int)((HIDWORD(v24) ^ v24) - HIDWORD(v24)) > 12000 )
      {
        if ( arenaa->FlagCounter < arenaa->TotalFlags )
        {
          do
          {
            arenaa->Flags[arenaa->FlagCounter].XTile = -1;
            arenaa->Flags[arenaa->FlagCounter].YTile = -1;
            arenaa->Flags[arenaa->FlagCounter].CarrierPlayerId = -1;
            arenaa->Flags[arenaa->FlagCounter].OwnerFreq = -1;
            v25 = arenaa->FlagCounter + 1;
            arenaa->FlagCounter = v25;
          }
          while ( v25 < arenaa->TotalFlags );
        }
        v26 = arenaa->TotalFlags;
        if ( arenaa->FlagCounter > v26 )
          arenaa->FlagCounter = v26;
      }
      FlagPositionUpdateSomething(arenaa, 1);
    }
    v27 = 0;
    if ( arenaa->ArenaPlayerCount > 0 )
    {
      v28 = arenaa->playerPointersForSomething;
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)v28 + 180) )
        {
          v29 = GetTickCount();
          v30 = *(_DWORD *)v28;
          if ( (int)(v29 / 0xA - *(_DWORD *)(*(_DWORD *)v28 + 180)) > 5000 && !*(_DWORD *)(v30 + 635) )
          {
            if ( arenaa->ServersideArenaSettings.dwordB4 )
            {
              WriteSubGameLog("Player kicked off for not returning security packet: %s\n", (const char *)(v30 + 675));
              *(_DWORD *)(*(_DWORD *)v28 + 789) = 13;
              *(_DWORD *)(*(_DWORD *)v28 + 56) = 1;
            }
            if ( GetRelAckDiff(*(struct CONNECTION **)(*(_DWORD *)v28 + 40), 0) < 3 )
            {
              sprintf(
                a2,
                "WARNING: Security checksum not returned {st=%d,et=%d}",
                *(_DWORD *)(*(_DWORD *)v28 + 180),
                v29 / 0xA);
              SendBillerWarnings(a2, *(struct PLAYER **)v28);
            }
          }
          *(_DWORD *)(*(_DWORD *)v28 + 180) = 0;
        }
        ++v27;
        v28 += 4;
      }
      while ( v27 < arenaa->ArenaPlayerCount );
    }
    v31 = arenaa->ServersideArenaSettings.SoccerBallCount;
    if ( arenaa->TotalSoccerBalls != v31 )
    {
      v32 = 0;
      arenaa->TotalSoccerBalls = v31;
      while ( v32 < arenaa->TotalSoccerBalls )
        CreateSoccerBall(arenaa, v32++);
    }
    v33 = arenaa->SecurityChecksumCounterOddValue;
    arenaa->SecurityChecksumCounterOddValue = v33 + 1;
    if ( (v33 & 1) != 0 )
    {
      v34 = rand() % 500;                       // Random value from Scrty File
      v35 = 0;
      v36 = &arenaa->ArenaSettings;
      arenaa->RandomScrtyDataIndex = v34;
      v37 = *(_DWORD *)&Security[0].ScrtyData[8 * v34];
      v38 = 357;
      do
      {
        v39 = v36->VersionAndManyBitFields;
        v36 = (ARENA_SETTINGS *)((char *)v36 + 4);
        v35 += v37 ^ v39;
        --v38;
      }
      while ( v38 );
      arenaa->SettingsChecksum = v35;
      arenaa->MapLVLChecksum = GenerateLVLChecksum(arenaa->MapAllocatedMemory, v37);
      if ( v37 )
      {
        v40 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v41 = (PLAYER **)arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v41)->AlreadySentReliablePacket && !(*v41)->field_309 )
              (*v41)->LastSecurityPacketReturnedTime = GetTickCount() / 0xA;
            ++v40;
            ++v41;
          }
          while ( v40 < arenaa->ArenaPlayerCount );
        }
      }
      v42 = rand();
      arenaa->DoorSeedValue = rand() * v42;
      v43 = rand();
      arenaa->PrizeSeedValue = rand() * v43;
      v44 = (GetTickCount() / 0xA) & 0x7FFFFFFF;
      v45 = 0;
      arenaa->SynchronizationTimeStamp = v44;
      v46 = arenaa->PrizeSeedValue;
      *(_DWORD *)&buf[5] = arenaa->DoorSeedValue;
      v47 = arenaa->ArenaPlayerCount;
      buf[0] = 0x18;                            // 0x18 - Synchronization Request
      *(_DWORD *)&buf[1] = v46;
      *(_DWORD *)&buf[9] = v44;
      *(_DWORD *)&buf[13] = v37;
      if ( v47 > 0 )
      {
        v48 = arenaa->playerPointersForSomething;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v48 + 56) )
            SendPlayerReliablePacket(*(struct PLAYER **)v48, buf, 0x11u, 1);
          ++v45;
          v48 += 4;
        }
        while ( v45 < arenaa->ArenaPlayerCount );
      }
    }
  }
  v49 = (int)(GetTickCount() / 0xA - arenaa->LastKotHTimer);
  if ( (int)((HIDWORD(v49) ^ v49) - HIDWORD(v49)) > 200 )
  {
    arenaa->LastKotHTimer = GetTickCount() / 0xA;
    if ( (int)arenaa->ServersideArenaSettings.KingDeathCount > 0 )
    {
      if ( arenaa->LastKotHGameResetCheckTime )
      {
        v50 = (int)(GetTickCount() / 0xA - arenaa->LastKotHGameResetCheckTime);
        if ( (int)((HIDWORD(v50) ^ v50) - HIDWORD(v50)) > 12000 )
        {
          if ( arenaa->ArenaPlayerCount > 2 )
          {
            arenaa->LastKotHGameResetCheckTime = 0;
            *(_DWORD *)&a3[2] = arenaa->ServersideArenaSettings.KingExpireTime;
            v51 = arenaa->ArenaPlayerCount;
            v52 = 0;
            a3[0] = 0x2C;                       // 0x2C - KotH Game Reset
            *(_WORD *)&a3[6] = -1;
            a3[1] = 1;
            if ( v51 > 0 )
            {
              v53 = arenaa->playerPointersForSomething;
              do
              {
                if ( !*(_DWORD *)(*(_DWORD *)v53 + 56) )
                  SendPlayerReliablePacket(*(struct PLAYER **)v53, a3, 8u, 1);
                ++v52;
                v53 += 4;
              }
              while ( v52 < arenaa->ArenaPlayerCount );
            }
            v54 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v55 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*(struct PLAYER **)v55, "King of the Hill restarted", 103);
                v56 = *(struct PLAYER **)v55;
                ++v54;
                v55 += 4;
                v56->KotHDeathCount = arenaa->ServersideArenaSettings.KingDeathCount;
              }
              while ( v54 < arenaa->ArenaPlayerCount );
            }
            arenaa->field_1001A = arenaa->ArenaPlayerCount
                                * arenaa->ArenaPlayerCount
                                * arenaa->ServersideArenaSettings.KingRewardFactor
                                / 1000;
          }
          else
          {
            arenaa->LastKotHGameResetCheckTime = GetTickCount() / 0xA;
          }
        }
      }
      else
      {
        v57 = arenaa->ArenaPlayerCount;
        v58 = -1;
        v59 = 0;
        v60 = 1;
        v201 = 0;
        if ( v57 > 0 )
        {
          v61 = (PLAYER **)arenaa->playerPointersForSomething;
          v62 = arenaa->ArenaPlayerCount;
          do
          {
            v63 = *v61;
            if ( (int)(*v61)->KotHDeathCount > 0 )
            {
              if ( v58 == -1 )
                v58 = *(_DWORD *)&v63->Frequency;
              if ( *(_DWORD *)&v63->Frequency == v58 )
                ++v201;
              else
                v60 = 0;
            }
            ++v61;
            --v62;
          }
          while ( v62 );
          v59 = v201;
        }
        if ( v60 )
        {
          v64 = v59;
          if ( v59 <= 1 )
            v64 = 1;
          v65 = 0;
          v66 = arenaa->field_1001A / v64;
          a3[0] = 0x2C;                         // 0x2C - KotH Game Reset
          *(_WORD *)&a3[6] = -1;
          a3[1] = 0;
          v211 = v66;
          if ( v57 > 0 )
          {
            v67 = arenaa->playerPointersForSomething;
            do
            {
              if ( !*(_DWORD *)(*(_DWORD *)v67 + 56) )
                SendPlayerReliablePacket(*(struct PLAYER **)v67, a3, 8u, 1);
              ++v65;
              v67 += 4;
            }
            while ( v65 < arenaa->ArenaPlayerCount );
          }
          SoundByte = 103;
          arenaa->LastKotHGameResetCheckTime = GetTickCount() / 0xA;
          v202 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            v68 = (PLAYER **)arenaa->playerPointersForSomething;
            do
            {
              v69 = 0;
              if ( (int)(*v68)->KotHDeathCount > 0 )
              {
                (*v68)->KotHDeathCount = 0;
                (*v68)->FlagPoints += v211;
                v70 = *v68;
                buf[0] = 9;                     // 0x09 - Player Score Update
                *(_WORD *)&buf[1] = v70->PlayerId;// PlayerId WORD
                *(_DWORD *)&buf[3] = v70->KillPoints;// Kill Points DWORD
                *(_DWORD *)&buf[7] = v70->FlagPoints;// Flag Points DWORD
                *(_WORD *)&buf[11] = v70->CurrentWins;// Wins WORD
                *(_WORD *)&buf[13] = v70->CurrentLosses;// Losses WORD
                if ( arenaa->ArenaPlayerCount > 0 )
                {
                  v71 = arenaa->playerPointersForSomething;
                  do
                  {
                    if ( !*(_DWORD *)(*(_DWORD *)v71 + 56) )
                      SendPlayerReliablePacket(*(struct PLAYER **)v71, buf, 0xFu, 1);
                    ++v69;
                    v71 += 4;
                  }
                  while ( v69 < arenaa->ArenaPlayerCount );
                }
                sprintf(a2, "King of the Hill: %s given %d points", (*v68)->PlayerDataBillerPacket.Name, v211);
                v72 = 0;
                if ( arenaa->ArenaPlayerCount > 0 )
                {
                  v73 = arenaa->playerPointersForSomething;
                  do
                  {
                    SendMessage(*(struct PLAYER **)v73, a2, SoundByte);
                    ++v72;
                    v73 += 4;
                  }
                  while ( v72 < arenaa->ArenaPlayerCount );
                }
                SoundByte = 0;
              }
              ++v68;
              ++v202;
            }
            while ( v202 < arenaa->ArenaPlayerCount );
          }
        }
      }
    }
    v74 = arenaa->FlagCounter;
    if ( v74 <= 0 )
    {
LABEL_295:
      if ( arenaa->GameTimeStart > 0 )
      {
        v157 = (int)(GetTickCount() / 0xA - arenaa->GameTimePassed);
        v158 = arenaa->GameTimeStart - ((HIDWORD(v157) ^ v157) - HIDWORD(v157));
        if ( v158 > 0 )
        {
          if ( v158 >= 6000 || arenaa->field_FF56 >= 2 )
          {
            if ( v158 < 30000 && v158 > 29000 && arenaa->field_FF56 < 1 )
            {
              arenaa->field_FF56 = 1;
              v164 = 0;
              if ( arenaa->ArenaPlayerCount > 0 )
              {
                v165 = arenaa->playerPointersForSomething;
                do
                {
                  SendMessage(*(struct PLAYER **)v165, "NOTICE: 5 minutes remaining.", 0);
                  ++v164;
                  v165 += 4;
                }
                while ( v164 < arenaa->ArenaPlayerCount );
              }
            }
          }
          else
          {
            v161 = arenaa->ArenaPlayerCount;
            v162 = 0;
            arenaa->field_FF56 = 2;
            if ( v161 > 0 )
            {
              v163 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*(struct PLAYER **)v163, "NOTICE: 1 minute remaining.", 0);
                ++v162;
                v163 += 4;
              }
              while ( v162 < arenaa->ArenaPlayerCount );
            }
          }
        }
        else
        {
          v159 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            v160 = arenaa->playerPointersForSomething;
            do
            {
              SendMessage(*(struct PLAYER **)v160, "NOTICE: Game over", 5);
              ++v159;
              v160 += 4;
            }
            while ( v159 < arenaa->ArenaPlayerCount );
          }
          arenaa->GameTimeStart = 0;
          arenaa->field_FF56 = 0;
        }
      }
      if ( (int)arenaa->ServersideArenaSettings.MiscTimedGame > 0 )
      {
        v166 = arenaa->LastTimedGameTime;
        v167 = arenaa->ServersideArenaSettings.MiscTimedGame - abs32(GetTickCount() / 0xA - v166);
        if ( !v166 )
          v167 = -1;
        if ( v167 > 0 )
        {
          if ( v167 >= 6000 || arenaa->field_FF20 >= 2 )
          {
            if ( v167 < 30000 && arenaa->field_FF20 < 1 )
            {
              arenaa->field_FF20 = 1;
              v187 = 0;
              if ( arenaa->ArenaPlayerCount > 0 )
              {
                v188 = arenaa->playerPointersForSomething;
                do
                {
                  SendMessage(*(struct PLAYER **)v188, "NOTICE: 5 minutes remaining in current game.", 0);
                  ++v187;
                  v188 += 4;
                }
                while ( v187 < arenaa->ArenaPlayerCount );
              }
            }
          }
          else
          {
            v184 = arenaa->ArenaPlayerCount;
            v185 = 0;
            arenaa->field_FF20 = 2;
            if ( v184 > 0 )
            {
              v186 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(
                  *(struct PLAYER **)v186,
                  "NOTICE: 1 minute remaining in current game.",
                  arenaa->ArenaSettings.VictoryMusic != 0 ? 0x64 : 0);
                ++v185;
                v186 += 4;
              }
              while ( v185 < arenaa->ArenaPlayerCount );
            }
          }
        }
        else
        {
          if ( arenaa->ServersideArenaSettings.SoccerCapturePoints && arenaa->ServersideArenaSettings.SoccerBallCount )
          {
            GetScore(arenaa, 0);
            v168 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v169 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*(struct PLAYER **)v169, "Soccer game over.", 103);
                ++v168;
                v169 += 4;
              }
              while ( v168 < arenaa->ArenaPlayerCount );
            }
            ArenaScoreReset(arenaa, 1);
            arenaa->TotalScoreStructs = 0;
            v170 = GetTickCount();
          }
          else
          {
            v171 = (PLAYER **)arenaa->playerPointersForSomething;
            qsort(
              arenaa->playerPointersForSomething,
              arenaa->ArenaPlayerCount,
              4u,
              (int (__cdecl *)(const void *, const void *))PtFuncCompare);
            v172 = arenaa->ArenaPlayerCount;
            buf[0] = 0x24;                      // 0x24 - Speed Game Over
            v173 = 0;
            v174 = &buf[28];
            v216 = &buf[8];
            do
            {
              if ( v173 >= v172 )
              {
                *(_WORD *)v174 = -1;
              }
              else
              {
                v175 = *v171;
                *(_WORD *)v174 = (*v171)->PlayerId;
                *(_DWORD *)v216 = v175->FlagPoints + v175->KillPoints;
              }
              ++v173;
              ++v171;
              v174 += 2;
              v216 += 4;
            }
            while ( v173 < 5 );
            v176 = 0;
            if ( v172 > 0 )
            {
              v177 = arenaa->playerPointersForSomething;
              do
              {
                v178 = *(_DWORD *)v177;
                *(_DWORD *)&buf[4] = *(_DWORD *)(*(_DWORD *)v177 + 557) + *(_DWORD *)(*(_DWORD *)v177 + 553);
                *(_WORD *)&buf[2] = v176 + 1;
                if ( *(_DWORD *)(v178 + 567) + *(_DWORD *)(v178 + 571) >= *(int *)&buf[4] )
                {
                  buf[1] = 0;
                }
                else if ( v172 > 10 )
                {
                  v179 = v178 + 547;
                  buf[1] = 1;
                  v180 = v178 + 561;
                  *(_DWORD *)v180 = *(_DWORD *)v179;
                  *(_DWORD *)(v180 + 4) = *(_DWORD *)(v179 + 4);
                  *(_DWORD *)(v180 + 8) = *(_DWORD *)(v179 + 8);
                  *(_WORD *)(v180 + 12) = *(_WORD *)(v179 + 12);
                  if ( arenaa->HasScoreFile )
                  {
                    v181 = *(_DWORD *)(*(_DWORD *)v177 + 351);
                    if ( v181 >= 0 )
                    {
                      v182 = *(_DWORD *)v177 + 561;
                      v183 = &arenaa->ScoreFilePointer[v181].Wins;
                      *(_DWORD *)v183 = *(_DWORD *)v182;
                      *((_DWORD *)v183 + 1) = *(_DWORD *)(v182 + 4);
                      *((_DWORD *)v183 + 2) = *(_DWORD *)(v182 + 8);
                      v183[6] = *(_WORD *)(v182 + 12);
                    }
                  }
                  else if ( BillingConnectionStructPointer && arenaa->RecordPointsToLog )
                  {
                    SendBillerUserScorePacket(
                      BillingConnectionStructPointer,
                      *(_DWORD *)(*(_DWORD *)v177 + 16),
                      (const void *)(*(_DWORD *)v177 + 561),
                      0xEu);
                  }
                }
                SendPlayerReliablePacket(*(struct PLAYER **)v177, buf, 0x26u, 1);
                v172 = arenaa->ArenaPlayerCount;
                ++v176;
                v177 += 4;
              }
              while ( v176 < v172 );
            }
            ArenaScoreReset(arenaa, 0);
            arenaa->TotalScoreStructs = 0;
            v170 = GetTickCount();
          }
          arenaa->LastTimedGameTime = v170 / 0xA;
          arenaa->field_FF20 = 0;
          SoccerGameSomething(arenaa, -1);
        }
      }
      v205 = 0;
      if ( arenaa->NumOfBricksInArena > 0 )
      {
        v189 = 0;
        v190 = arenaa->Bricks;
        v191 = &arenaa->Bricks[1];
        v209 = &arenaa->Bricks[0].BrickTimeStamp;
        do
        {
          if ( (int)abs32(GetTickCount() / 0xA - *v209) > (__int16)arenaa->ArenaSettings.BrickTime )
          {
            v192 = arenaa->NumOfBricksInArena - 1;
            arenaa->NumOfBricksInArena = v192;
            memcpy(v190, v191, 16 * (v189 + v192));
            v189 -= 0xFFFFFFF;
            --v191;
            --v205;
            v209 -= 4;
            --v190;
          }
          v189 += 0xFFFFFFF;
          ++v191;
          ++v190;
          v15 = ++v205 < arenaa->NumOfBricksInArena;
          v209 += 4;
        }
        while ( v15 );
      }
      goto LABEL_358;
    }
    v75 = arenaa->ServersideArenaSettings.FlagMode;
    if ( v75 == 2 )
    {
      v76 = (int)(GetTickCount() / 0xA - arenaa->LastTerritoryRewardTime);
      if ( (signed int)((HIDWORD(v76) ^ v76) - HIDWORD(v76)) > arenaa->ServersideArenaSettings.TerritoryRewardDelay )
      {
        arenaa->LastTerritoryRewardTime = GetTickCount() / 0xA;
        if ( arenaa->ArenaPlayerCount >= 16 )
        {
          v77 = 0;
          SoundBytea = 0;
          if ( arenaa->FlagCounter > 0 )
          {
            v78 = v229;
            v203 = &arenaa->Flags[0].OwnerFreq;
            v79 = 0;
            v212 = arenaa->FlagCounter;
            do
            {
              v80 = *v203;
              if ( *v203 >= 0 )
              {
                v81 = 0;
                if ( v79 > 0 )
                {
                  v82 = FreqList;
                  while ( *v82 != v80 )
                  {
                    ++v81;
                    ++v82;
                    if ( v81 >= v77 )
                      goto LABEL_140;
                  }
                  ++v228[v81];
                }
LABEL_140:
                if ( v81 == v77 )
                {
                  v83 = arenaa->ArenaPlayerCount;
                  FreqList[v79] = v80;
                  v228[v79] = 1;
                  *v78 = 0;
                  if ( v83 > 0 )
                  {
                    v84 = (PLAYER **)arenaa->playerPointersForSomething;
                    do
                    {
                      if ( *(_DWORD *)&(*v84)->Frequency == v80 )
                        ++*v78;
                      ++v84;
                      --v83;
                    }
                    while ( v83 );
                    v77 = SoundBytea;
                  }
                  ++v77;
                  ++v79;
                  SoundBytea = v77;
                  ++v78;
                }
              }
              v85 = v212 == 1;
              v203 += 4;
              --v212;
            }
            while ( !v85 );
          }
          v86 = 0;
          v87 = 0;
          i = 0;
          if ( v77 > 0 )
          {
            do
            {
              if ( v229[v87] >= arenaa->ServersideArenaSettings.TerritoryRewardMinimumPlayers
                && v228[v87] >= arenaa->ServersideArenaSettings.TerritoryRewardBaseFlags )
              {
                ++v86;
              }
              ++v87;
            }
            while ( v87 < v77 );
            i = (int *)v86;
          }
          if ( v86 > 1 )
          {
            v88 = &a2[1];
            a2[0] = 0x23;                       // 0x23 - Flag Reward Granted
            v213 = &a2[1];
            v204 = 0;
            if ( v77 > 0 )
            {
              v206 = FreqList;
              do
              {
                v89 = v229[v204];
                if ( v89 >= arenaa->ServersideArenaSettings.TerritoryRewardMinimumPlayers )
                {
                  v90 = v228[v204];
                  v91 = arenaa->ServersideArenaSettings.TerritoryRewardBaseFlags;
                  if ( v90 >= v91 )
                  {
                    v92 = arenaa->ArenaPlayerCount;
                    v93 = v92 * arenaa->ServersideArenaSettings.TerritoryRewardPoints * ((_DWORD)i - 1) * (v90 - v91);
                    v94 = v93 / 50 / v89;
                    if ( v94 > 0 )
                    {
                      *(_WORD *)v213 = *(_WORD *)v206;
                      v95 = v93 / 50 / v89;
                      if ( v94 >= 30000 )
                        LOWORD(v95) = 30000;
                      *((_WORD *)v213 + 1) = v95;
                      v213 += 4;
                      v217 = 0;
                      if ( v92 > 0 )
                      {
                        v96 = (struct PLAYER **)arenaa->playerPointersForSomething;
                        *(_DWORD *)a3 = *v206;
                        do
                        {
                          v97 = *v96;
                          if ( *(_DWORD *)&(*v96)->Frequency == *(_DWORD *)a3
                            && *(_DWORD *)&v97->Ship != 8
                            && (v97->ShipTogglables & 0x20) == 0 )// Bit Flag - UNKNOWN1:        32;     ?
                          {
                            v98 = v97->KillPoints + v97->FlagPoints;
                            UpdatePoints(v97, 0, v94);
                            if ( v98 < AutoPermissionPoints
                              && AutoPermissionPoints > 0
                              && (*v96)->KillPoints + (*v96)->FlagPoints >= AutoPermissionPoints )
                            {
                              SendMessage(*v96, PermissionAutoPermissionMessage, 0);
                            }
                          }
                          ++v96;
                          ++v217;
                        }
                        while ( v217 < arenaa->ArenaPlayerCount );
                      }
                    }
                  }
                }
                v15 = ++v204 < SoundBytea;
                ++v206;
              }
              while ( v15 );
              v88 = v213;
            }
            v99 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v100 = arenaa->playerPointersForSomething;
              do
              {
                if ( !*(_DWORD *)(*(_DWORD *)v100 + 56) )
                  SendPlayerReliablePacket(*(struct PLAYER **)v100, a2, v88 - a2, 1);
                ++v99;
                v100 += 4;
              }
              while ( v99 < arenaa->ArenaPlayerCount );
            }
            dword_4C8F3C = 0;
          }
        }
      }
      goto LABEL_250;
    }
    if ( v75 && v75 != 1 || (int)arenaa->ServersideArenaSettings.FlagReward <= 0 )
    {
LABEL_250:
      if ( (int)arenaa->ServersideArenaSettings.PeriodicRewardDelay > 0 )
      {
        v133 = (int)(GetTickCount() / 0xA - arenaa->LastPeriodicRewardTime);
        if ( (signed int)((HIDWORD(v133) ^ v133) - HIDWORD(v133)) > arenaa->ServersideArenaSettings.PeriodicRewardDelay )
        {
          v134 = GetTickCount();
          v135 = arenaa->ServersideArenaSettings.PeriodicRewardMinimumPlayers;
          arenaa->LastPeriodicRewardTime = v134 / 0xA;
          v136 = arenaa->ArenaPlayerCount;
          if ( v136 > v135 )
          {
            v208 = 0;
            if ( arenaa->FlagCounter > 0 )
            {
              v137 = FreqList;
              v214 = FreqList;
              SoundByteb = &arenaa->Flags[0].OwnerFreq;
              v138 = 0;
              v218 = arenaa->FlagCounter;
              do
              {
                v139 = *SoundByteb;
                if ( *SoundByteb >= 0 )
                {
                  v140 = 0;
                  if ( v138 > 0 )
                  {
                    v141 = v229;
                    while ( *v141 != v139 )
                    {
                      ++v140;
                      ++v141;
                      if ( v140 >= v208 )
                        goto LABEL_262;
                    }
                    ++v228[v140];
                  }
LABEL_262:
                  if ( v140 == v208 )
                  {
                    v229[v138] = v139;
                    v228[v138] = 1;
                    *v137 = 0;
                    if ( v136 > 0 )
                    {
                      v142 = (PLAYER **)arenaa->playerPointersForSomething;
                      v143 = v136;
                      do
                      {
                        v137 = v214;
                        if ( *(_DWORD *)&(*v142)->Frequency == v139 )
                          ++*v214;
                        ++v142;
                        --v143;
                      }
                      while ( v143 );
                    }
                    ++v138;
                    ++v137;
                    ++v208;
                    v214 = v137;
                  }
                }
                v85 = v218 == 1;
                SoundByteb += 4;
                --v218;
              }
              while ( !v85 );
            }
            v144 = 0;
            a2[0] = 0x23;                       // 0x23 - Flag Reward Granted
            v145 = &a2[1];
            for ( i = 0; v144 < v208; i = (int *)v144 )
            {
              v146 = arenaa->ServersideArenaSettings.PeriodicRewardPoints;
              v147 = v228[v144];
              if ( v146 <= 0 )
                v148 = -(v136 * v146 * v147);
              else
                v148 = v146 * v147;
              if ( v148 > 0 )
              {
                v149 = &v229[v144];
                *(_WORD *)v145 = *(_WORD *)v149;
                v150 = v145 + 2;
                v151 = v148;
                if ( v148 >= 30000 )
                  v151 = 30000;
                *(_WORD *)v150 = v151;
                v145 = v150 + 2;
                v215 = v145;
                v219 = 0;
                if ( v136 > 0 )
                {
                  v152 = (struct PLAYER **)arenaa->playerPointersForSomething;
                  *(_DWORD *)a3 = *v149;
                  do
                  {
                    v153 = *v152;
                    if ( *(_DWORD *)&(*v152)->Frequency == *(_DWORD *)a3
                      && *(_DWORD *)&v153->Ship != 8
                      && (v153->ShipTogglables & 0x20) == 0 )
                    {
                      v154 = v153->KillPoints + v153->FlagPoints;
                      UpdatePoints(v153, 0, v148);
                      if ( v154 < AutoPermissionPoints
                        && AutoPermissionPoints > 0
                        && (*v152)->KillPoints + (*v152)->FlagPoints >= AutoPermissionPoints )
                      {
                        SendMessage(*v152, PermissionAutoPermissionMessage, 0);
                      }
                    }
                    v136 = arenaa->ArenaPlayerCount;
                    ++v152;
                    ++v219;
                  }
                  while ( v219 < v136 );
                  v145 = v215;
                  v144 = (int)i;
                }
              }
              ++v144;
            }
            v155 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v156 = arenaa->playerPointersForSomething;
              do
              {
                if ( !*(_DWORD *)(*(_DWORD *)v156 + 56) )
                  SendPlayerReliablePacket(*(struct PLAYER **)v156, a2, v145 - a2, 1);
                ++v155;
                v156 += 4;
              }
              while ( v155 < arenaa->ArenaPlayerCount );
            }
            dword_4C8F3C = 0;
          }
        }
      }
      goto LABEL_295;
    }
    v101 = -1;
    v207 = -1;
    if ( v75 )
    {
      v108 = arenaa->Flags[0].OwnerFreq;
      v109 = (FLAG *)&arenaa->Flags[0].OwnerFreq;
      if ( v108 < 0 || arenaa->Flags[0].CarrierPlayerId != -1 )
        goto LABEL_204;
      for ( j = 0; j < v74; ++j )
      {
        if ( v109[-1].OwnerFreq != -1 )
          break;
        if ( v109->XTile != v108 )
          break;
        ++v109;
      }
      if ( j != v74 )
        goto LABEL_204;
      v101 = arenaa->Flags[0].OwnerFreq;
    }
    else
    {
      v102 = arenaa->Flags[0].CarrierPlayerId;
      if ( v102 < 0 )
        goto LABEL_204;
      v103 = ZonePlayerList[v102];
      if ( !v103 )
        goto LABEL_204;
      v104 = *(_DWORD *)&v103->Frequency;
      v105 = 1;
      if ( v74 > 1 )
      {
        v106 = &arenaa->Flags[1].CarrierPlayerId;
        do
        {
          if ( *v106 < 0 )
            break;
          v107 = ZonePlayerList[*v106];
          if ( !v107 )
            break;
          if ( *(_DWORD *)&v107->Frequency != v104 )
            break;
          ++v105;
          v106 += 4;
        }
        while ( v105 < v74 );
      }
      if ( v105 != v74 )
        goto LABEL_204;
      v101 = v104;
    }
    v207 = v101;
LABEL_204:
    if ( v101 >= 0 )
    {
      v111 = arenaa->ArenaPlayerCount;
      v112 = 0;
      if ( v111 > 0 )
      {
        v113 = (PLAYER **)arenaa->playerPointersForSomething;
        do
        {
          if ( *(_DWORD *)&(*v113)->Ship != 8 )
            ++v112;
          ++v113;
          --v111;
        }
        while ( v111 );
      }
      v114 = arenaa->ServersideArenaSettings.RandomFlags;
      arenaa->FlagCounter = 0;
      if ( v114 && (int)arenaa->ServersideArenaSettings.MaxFlags > 0 )
        arenaa->TotalFlags = rand() % arenaa->ServersideArenaSettings.MaxFlags + 1;
      else
        arenaa->TotalFlags = arenaa->ServersideArenaSettings.MaxFlags;
      v115 = GetTickCount();
      v116 = arenaa->ServersideArenaSettings.FlagReward * v112 * v112;
      a3[0] = 0x14;                             // 0x14 - Flag Victory
      *(_WORD *)&a3[1] = v207;
      arenaa->LastFlagResetTime = v115 / 0xA;
      v117 = arenaa->ServersideArenaSettings.FlagRewardMode;
      v118 = arenaa->ArenaJackpot + v116 / 1000;
      arenaa->ArenaJackpot = 0;
      *(_DWORD *)&a3[3] = v118;
      if ( v117 == 1 )
      {
        v119 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v120 = (PLAYER **)arenaa->playerPointersForSomething;
          v121 = arenaa->ArenaPlayerCount;
          do
          {
            v122 = *v120;
            if ( *(_DWORD *)&(*v120)->Frequency == v207
              && *(_DWORD *)&v122->Ship != 8
              && (v122->ShipTogglables & 0x20) == 0 )
            {
              ++v119;
            }
            ++v120;
            --v121;
          }
          while ( v121 );
        }
        if ( v119 <= (unsigned __int8)arenaa->ArenaSettings.MaxPerTeam >> 1 )
          v119 = (unsigned __int8)arenaa->ArenaSettings.MaxPerTeam >> 1;
        *(_DWORD *)&a3[3] = (unsigned __int8)arenaa->ArenaSettings.MaxPerTeam * v118 / v119;
      }
      v123 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v124 = arenaa->playerPointersForSomething;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v124 + 56) )
            SendPlayerReliablePacket(*(struct PLAYER **)v124, a3, 7u, 1);
          ++v123;
          v124 += 4;
        }
        while ( v123 < arenaa->ArenaPlayerCount );
      }
      v125 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v126 = arenaa->playerPointersForSomething;
        do
        {
          v127 = *(_DWORD *)v126;
          if ( *(_DWORD *)(*(_DWORD *)v126 + 279) == v207
            && *(_DWORD *)(v127 + 275) != 8
            && (*(_BYTE *)(v127 + 231) & 0x20) == 0 )
          {
            v128 = *(_DWORD *)(v127 + 553) + *(_DWORD *)(v127 + 557);
            UpdatePoints((struct PLAYER *)v127, 0, *(int *)&a3[3]);
            ++*(_WORD *)(*(_DWORD *)v126 + 551);
            if ( !arenaa->ServersideArenaSettings.MiscTimedGame )
            {
              if ( arenaa->HasScoreFile )
              {
                v129 = *(_DWORD *)(*(_DWORD *)v126 + 351);
                if ( v129 >= 0 )
                {
                  v130 = *(_DWORD *)v126 + 547;
                  v131 = &arenaa->ScoreFilePointer[v129].Wins;
                  *(_DWORD *)v131 = *(_DWORD *)v130;
                  *((_DWORD *)v131 + 1) = *(_DWORD *)(v130 + 4);
                  *((_DWORD *)v131 + 2) = *(_DWORD *)(v130 + 8);
                  v131[6] = *(_WORD *)(v130 + 12);
                }
              }
              else if ( BillingConnectionStructPointer && arenaa->RecordPointsToLog )
              {
                SendBillerUserScorePacket(
                  BillingConnectionStructPointer,
                  *(_DWORD *)(*(_DWORD *)v126 + 16),
                  (const void *)(*(_DWORD *)v126 + 547),
                  0xEu);
              }
            }
            if ( v128 < AutoPermissionPoints
              && AutoPermissionPoints > 0
              && *(_DWORD *)(*(_DWORD *)v126 + 553) + *(_DWORD *)(*(_DWORD *)v126 + 557) >= AutoPermissionPoints )
            {
              SendMessage(*(struct PLAYER **)v126, PermissionAutoPermissionMessage, 0);
            }
          }
          ++v125;
          v126 += 4;
        }
        while ( v125 < arenaa->ArenaPlayerCount );
      }
      dword_4C8F3C = 0;
    }
    v132 = (int)(GetTickCount() / 0xA - arenaa->LastFlagResetTime);
    if ( (signed int)((HIDWORD(v132) ^ v132) - HIDWORD(v132)) > arenaa->ServersideArenaSettings.FlagResetDelay )
      ResetFlagGame(arenaa);
    goto LABEL_250;
  }
LABEL_358:
  v220 = 0;
  if ( arenaa->TotalSoccerBalls > 0 )
  {
    v193 = arenaa->SoccerBallTimers;
    soccerball = (int)&arenaa->SoccerBalls[offsetof(ARENA, PlayerPointers)].PlayerId;
    i = arenaa->SoccerBallTimers;
    do
    {
      if ( (signed int)abs32(GetTickCount() / 0xA - *v193) > arenaa->ServersideArenaSettings.SoccerSendTime )
      {
        if ( !*(_DWORD *)(soccerball + 2) && *(__int16 *)soccerball >= 0 )
        {
          v195 = ZonePlayerList[*(__int16 *)soccerball];
          if ( v195 )
          {
            *(_WORD *)(soccerball - 8) = v195->XPixels;
            *(_WORD *)(soccerball - 6) = v195->YPixels;
          }
        }
        *v193 = GetTickCount() / 0xA;
        v196 = 0;
        buf[0] = 0x2E;                          // 0x2E - Power-Ball Position Update
        *(_DWORD *)&buf[1] = *(_DWORD *)(soccerball - offsetof(SOCCER_BALL, PlayerId));
        *(_DWORD *)&buf[5] = *(_DWORD *)(soccerball - offsetof(SOCCER_BALL, PlayerId) + 4);
        *(_DWORD *)&buf[9] = *(_DWORD *)(soccerball - offsetof(SOCCER_BALL, PlayerId) + 8);
        v197 = arenaa->ArenaPlayerCount;
        v198 = *(_BYTE *)(soccerball - offsetof(SOCCER_BALL, PlayerId) + 14);
        *(_WORD *)&buf[13] = *(_WORD *)(soccerball - offsetof(SOCCER_BALL, PlayerId) + 12);
        buf[15] = v198;
        if ( v197 > 0 )
        {
          v199 = arenaa->playerPointersForSomething;
          do
          {
            if ( !*(_DWORD *)(*(_DWORD *)v199 + 56) )
              SendPlayerReliablePacket(*(struct PLAYER **)v199, buf, 0x10u, 0);
            ++v196;
            v199 += 4;
          }
          while ( v196 < arenaa->ArenaPlayerCount );
        }
      }
      v193 = i + 1;
      soccerball += 15;
      v15 = ++v220 < arenaa->TotalSoccerBalls;
      ++i;
    }
    while ( v15 );
  }
  return arenaa->ArenaPlayerCount == 0;
}
// 4033B7: conditional instruction was optimized away because of 'eax.4==1'
// 4033D5: conditional instruction was optimized away because of 'esi.4>=1'
// 431FF4: using guessed type int ArenaArrayLength;
// 431FFC: using guessed type int ArenaMinimumPlayers;
// 4AF32C: using guessed type int AutoPermissionPoints;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4D5928: using guessed type int ArenaDesiredPlayers;
// 402560: using guessed type int var_1C00[384];
// 402560: using guessed type int FreqList[384];
// 402560: using guessed type int var_2200[384];

//----- (00403F60) --------------------------------------------------------
int __cdecl PtFuncCompare(struct PLAYER **player, ARENA *arenaa)
{
  return *(_DWORD *)(*(_DWORD *)arenaa->PlayerPointers + 553)// Just GUESS
       + *(_DWORD *)(*(_DWORD *)arenaa->PlayerPointers + 557)
       - (*player)->KillPoints
       - (*player)->FlagPoints;
}
/* Orphan comments:
Guess just showing PLAYER** Matches with ARENA *
*/

//----- (00403F90) --------------------------------------------------------
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset)
{
  int v3; // eax
  int v4; // ecx
  PLAYER **v5; // eax
  PLAYER *v6; // edx
  int v7; // eax
  int v8; // ebp
  PLAYER **v9; // ebx

  v3 = arenaa->ArenaPlayerCount;                // Suppose to be int
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = (PLAYER **)arenaa->playerPointersForSomething;
    do                                          // (result -1) bug happens because result variable is mutated from different type.
    {
      v6 = *v5;
      ++v4;
      ++v5;
      v6->DebtKills = arenaa->ServersideArenaSettings.KillDebtKills;
      (*(v5 - 1))->CurrentLosses = 0;
      (*(v5 - 1))->CurrentWins = 0;
      (*(v5 - 1))->KillPoints = 0;
      (*(v5 - 1))->FlagPoints = 0;
      (*(v5 - 1))->CurrentGoals = 0;
    }
    while ( v4 < arenaa->ArenaPlayerCount );
  }
  if ( sendScoreReset )
  {
    v7 = arenaa->ArenaPlayerCount;
    v8 = 0;
    LOBYTE(sendScoreReset) = 26;
    *(_WORD *)((char *)&sendScoreReset + 1) = -1;
    if ( v7 > 0 )
    {
      v9 = (PLAYER **)arenaa->playerPointersForSomething;
      do
      {
        if ( !(*v9)->AlreadySentReliablePacket )
          SendPlayerReliablePacket(*v9, &sendScoreReset, 3u, 1);
        ++v8;
        ++v9;
      }
      while ( v8 < arenaa->ArenaPlayerCount );
    }
  }
}

//----- (00404050) --------------------------------------------------------
void __thiscall CreateSoccerBall(struct ARENA *arenaa, int PowerBallId)
{
  int v3; // eax
  __int16 v4; // cx
  char *v5; // esi
  __int16 v6; // ax
  int ReturnXTile; // [esp+Ch] [ebp-8h] BYREF
  int ReturnYTile; // [esp+10h] [ebp-4h] BYREF

  v3 = (__int16)arenaa->ArenaSettings.PrizeMinimumVirtual
     + (__int16)arenaa->ArenaSettings.PrizeUpgradeVirtual * arenaa->ArenaPlayerCount;
  if ( v3 >= 1024 )
    v3 = 1024;
  SomethingWithPrizes(arenaa, (int)&ReturnXTile, (int)&ReturnYTile, 512, 512, v3 / 2);
  v4 = 16 * ReturnYTile;
  v5 = &arenaa->PlayerPointers[12 * PowerBallId + 3 * PowerBallId];
  v6 = 16 * ReturnXTile;
  v5[65394] = PowerBallId;
  *(_WORD *)(v5 + 65395) = v6;
  *(_WORD *)(v5 + 65397) = v4;
  *(_WORD *)(v5 + 65399) = 0;
  *(_WORD *)(v5 + 65401) = 0;
  *(_WORD *)(v5 + 65403) = -1;
  *(_DWORD *)(v5 + 65405) = GetTickCount() / 0xA;
  arenaa->SoccerBallTimers[PowerBallId] = 0;
}

//----- (00404120) --------------------------------------------------------
void __thiscall FlagPositionUpdateSomething(struct ARENA *arenaa, int a2)
{
  FLAG *each_flag; // esi
  int v4; // ebx
  int v5; // eax
  BOOL v6; // eax
  int v7; // eax
  __int16 v8; // cx
  __int16 v9; // dx
  int v10; // eax
  int v11; // ebp
  PLAYER **v12; // ebx
  int v13; // [esp+4h] [ebp-10h]
  char buf[12]; // [esp+8h] [ebp-Ch] BYREF

  v13 = 0;
  if ( arenaa->FlagCounter > 0 )
  {
    each_flag = arenaa->Flags;
    do
    {
      v4 = each_flag->XTile;
      v6 = 1;
      if ( each_flag->XTile >= 0 )
      {
        v5 = each_flag->YTile;
        if ( v5 >= 0 && v4 < 1024 && v5 < 1024 )
          v6 = 0;
      }
      if ( each_flag->CarrierPlayerId == -1 && (a2 || v6) )
      {
        if ( v6 )
        {
          if ( v4 == -1 || !arenaa->ServersideArenaSettings.FlagTerritoryRadius )
          {
            v7 = (__int16)arenaa->ArenaSettings.PrizeMinimumVirtual
               + (__int16)arenaa->ArenaSettings.PrizeUpgradeVirtual * arenaa->ArenaPlayerCount;
            if ( v7 >= 1024 )
              v7 = 1024;
            SomethingWithPrizes(arenaa, (int)each_flag, (int)&each_flag->YTile, 512, 512, v7 / 2);
          }
          else
          {
            SomethingWithPrizes(
              arenaa,
              (int)each_flag,
              (int)&each_flag->YTile,
              abs32(v4),
              abs32(each_flag->YTile),
              arenaa->ServersideArenaSettings.FlagTerritoryRadius);
          }
        }
        v8 = each_flag->XTile;
        v9 = each_flag->YTile;
        *(_WORD *)&buf[7] = each_flag->OwnerFreq;// Owner Frequency
        v10 = arenaa->ArenaPlayerCount;
        *(_WORD *)&buf[3] = v8;                 // X Tiles
        v11 = 0;
        buf[0] = 0x12;                          // 0x12 - Flag Position
        *(_WORD *)&buf[5] = v9;                 // Y Tiles
        *(_WORD *)&buf[1] = v13;                // Flag ID
        if ( v10 > 0 )
        {
          v12 = (PLAYER **)arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v12)->AlreadySentReliablePacket )
              SendPlayerReliablePacket(*v12, buf, 9u, 1);
            ++v11;
            ++v12;
          }
          while ( v11 < arenaa->ArenaPlayerCount );
        }
      }
      ++each_flag;
      ++v13;
    }
    while ( v13 < arenaa->FlagCounter );
  }
}

//----- (00404280) --------------------------------------------------------
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3)
{
  int v3; // ebx
  PLAYER *v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // eax
  int v8; // ebp
  int v9; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // edx
  int v14; // eax
  int v15; // edx
  int *v16; // ecx
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = a2;
  if ( a2 >= 0 && arenaa->ArenaSettings.CarryFlags )
  {
    v5 = ZonePlayerList[a2];
    v6 = -1;
    v7 = -1;
    if ( v5 )
    {
      v8 = v5->XPixels / 16;
      v9 = v5->YPixels / 16;
      if ( arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid )
      {
        v17 = 0;
        while ( 1 )
        {
          v10 = arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid;
          v11 = 2 * (rand() % v10) - v10;
          if ( v11 + v8 > 1 && v11 + v8 < 1024 )
            break;
          if ( ++v17 >= 50 )
            goto LABEL_11;
        }
        v8 += v11;
LABEL_11:
        v18 = 0;
        while ( 1 )
        {
          v12 = arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid;
          v13 = rand() % (2 * v12) - v12;
          if ( v13 + v9 > 1 && v13 + v9 < 1024 )
            break;
          if ( ++v18 >= 50 )
            goto LABEL_17;
        }
        v9 += v13;
      }
LABEL_17:
      v14 = v9;
      v3 = a2;
      v6 = -abs32(v8);
      v7 = -abs32(v14);
    }
    v15 = 0;
    if ( arenaa->FlagCounter > 0 )
    {
      v16 = &arenaa->Flags[0].CarrierPlayerId;
      do
      {
        if ( *v16 == v3 )
        {
          if ( !a3 )
            v16[1] = -1;
          *v16 = -1;
          *(v16 - 2) = v6;
          *(v16 - 1) = v7;
        }
        ++v15;
        v16 += 4;
      }
      while ( v15 < arenaa->FlagCounter );
    }
  }
}

//----- (004043C0) --------------------------------------------------------
// Arena.ResetFlagGame()
void __thiscall ResetFlagGame(struct ARENA *arenaa)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int *v5; // ecx
  int v6; // edi
  char *v7; // ecx
  int *v8; // eax
  int v9; // edx
  __int16 v10; // bp
  unsigned int v11; // ebp
  int v12; // edi
  char *v13; // ebx
  int v14; // eax
  DWORD v15; // kr00_4
  int v16; // eax
  char *v17; // edi
  char v18[8]; // [esp+10h] [ebp-1008h] BYREF
  char buf[4096]; // [esp+18h] [ebp-1000h] BYREF

  v2 = 0;
  v3 = arenaa->ServersideArenaSettings.FlagMode;
  arenaa->ArenaJackpot = 0;
  if ( v3 == 2 )
  {
    v4 = 0;
    if ( arenaa->FlagCounter > 0 )
    {
      v5 = &arenaa->Flags[0].OwnerFreq;
      do
      {
        *v5 = -1;
        ++v4;
        v5 += 4;
      }
      while ( v4 < arenaa->FlagCounter );
    }
    v6 = arenaa->FlagCounter;
    buf[0] = 0x22;                              // 0x22 - Turf Flag Update
    v7 = &buf[1];
    if ( v6 > 0 )
    {
      v8 = &arenaa->Flags[0].OwnerFreq;
      v9 = v6;
      do
      {
        v10 = *(_WORD *)v8;
        v8 += 4;
        *(_WORD *)v7 = v10;
        v7 += 2;
        --v9;
      }
      while ( v9 );
    }
    v11 = 2 * v6 + 1;
    v12 = 0;
    if ( arenaa->ArenaPlayerCount > 0 )
    {
      v13 = arenaa->playerPointersForSomething;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v13 + 56) )
          SendPlayerReliablePacket(*(struct PLAYER **)v13, buf, v11, 1);
        ++v12;
        v13 += 4;
      }
      while ( v12 < arenaa->ArenaPlayerCount );
    }
  }
  else
  {
    v14 = arenaa->ServersideArenaSettings.RandomFlags;
    arenaa->FlagCounter = 0;
    if ( v14 && (int)arenaa->ServersideArenaSettings.MaxFlags > 0 )
      arenaa->TotalFlags = rand() % arenaa->ServersideArenaSettings.MaxFlags + 1;
    else
      arenaa->TotalFlags = arenaa->ServersideArenaSettings.MaxFlags;
    v15 = GetTickCount();
    v16 = arenaa->ArenaPlayerCount;
    v18[0] = 0x14;                              // 0x14 - Flag Victory
    arenaa->LastFlagResetTime = v15 / 0xA;
    *(_WORD *)&v18[1] = -1;                     // Team
    *(_DWORD *)&v18[3] = 0;                     // Jackpot Points
    if ( v16 > 0 )
    {
      v17 = arenaa->playerPointersForSomething;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v17 + 56) )
          SendPlayerReliablePacket(*(struct PLAYER **)v17, v18, 7u, 1);
        ++v2;
        v17 += 4;
      }
      while ( v2 < arenaa->ArenaPlayerCount );
    }
  }
}

//----- (00404530) --------------------------------------------------------
int __thiscall GetNextFrequencyToJoin(ARENA *arenaa)
{
  int TotalPlaying; // ebp
  PLAYER **eachPlayer; // edx
  int ArenaPlayerCount; // esi
  int v5; // eax
  int CurrentFrequency; // esi
  int *NumPlayersPerFreqArrayy; // edi
  int NumPlayersThisFreq; // ecx
  int TotalPlayingg; // [esp+10h] [ebp-324h]
  int NumPlayersPerFreqArray[200]; // [esp+14h] [ebp-320h] BYREF

  memset(NumPlayersPerFreqArray, 0, sizeof(NumPlayersPerFreqArray));
  TotalPlaying = 0;
  TotalPlayingg = 0;
  if ( arenaa->ArenaPlayerCount > 0 )
  {
    eachPlayer = (PLAYER **)arenaa->playerPointersForSomething;
    ArenaPlayerCount = arenaa->ArenaPlayerCount;
    do
    {
      v5 = *(_DWORD *)&(*eachPlayer)->Frequency;
      if ( v5 >= 0 && *(_DWORD *)&(*eachPlayer)->Ship != 8 )
      {
        if ( v5 < 200 )
          ++NumPlayersPerFreqArray[v5];
        ++TotalPlaying;
      }
      ++eachPlayer;
      --ArenaPlayerCount;
    }
    while ( ArenaPlayerCount );
    TotalPlayingg = TotalPlaying;
  }
  CurrentFrequency = 0;
  for ( NumPlayersPerFreqArrayy = NumPlayersPerFreqArray; ; ++NumPlayersPerFreqArrayy )
  {
    if ( CurrentFrequency >= arenaa->ArenaSettings.MaxFrequency )
      return rand() % arenaa->ArenaSettings.MaxFrequency;
    NumPlayersThisFreq = *NumPlayersPerFreqArrayy;
    if ( !*NumPlayersPerFreqArrayy
      || NumPlayersThisFreq < (unsigned __int8)arenaa->ArenaSettings.MaxPerTeam
      && NumPlayersThisFreq <= TotalPlayingg / arenaa->ServersideArenaSettings.TeamDesiredTeams )
    {
      break;
    }
    if ( ++CurrentFrequency >= 200 )
      return rand() % arenaa->ArenaSettings.MaxFrequency;
  }
  return CurrentFrequency;
}
// 404530: using guessed type int NumPlayersPerFreqArray[200];

//----- (00404600) --------------------------------------------------------
// Arena.SendPacket()
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4)
{
  int v5; // edi
  PLAYER **v6; // esi

  v5 = 0;
  if ( arenaa->ArenaPlayerCount > 0 )
  {
    v6 = (PLAYER **)arenaa->playerPointersForSomething;
    do
    {
      if ( !(*v6)->AlreadySentReliablePacket )
        SendPlayerReliablePacket(*v6, buf, len, a4);
      ++v5;
      ++v6;
    }
    while ( v5 < arenaa->ArenaPlayerCount );
  }
}

//----- (00404650) --------------------------------------------------------
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius)
{
  int v6; // ebp
  int v7; // ebx
  int TwoDifference; // eax
  int XTile; // edi
  int YTile; // ebp
  struct ARENA *v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  struct ARENA *v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ecx
  int v31; // eax
  int v33; // [esp+Ch] [ebp-Ch]
  int v34; // [esp+10h] [ebp-8h]
  int a4a; // [esp+24h] [ebp+Ch]
  int a5a; // [esp+28h] [ebp+10h]
  int a6a; // [esp+2Ch] [ebp+14h]
  int a6b; // [esp+2Ch] [ebp+14h]
  int a6c; // [esp+2Ch] [ebp+14h]
  int a6d; // [esp+2Ch] [ebp+14h]
  int a6e; // [esp+2Ch] [ebp+14h]
  int a6f; // [esp+2Ch] [ebp+14h]

  v6 = 2 * Radius;
  v7 = YStart - Radius;
  TwoDifference = XStart - YStart;
  v34 = 0;
  v33 = 2 * Radius;
  a5a = YStart - Radius;
  a4a = TwoDifference;
  while ( 1 )
  {
    XTile = (v7 + TwoDifference < 0 ? 0 : v7 + TwoDifference) + rand() % v6;
    YTile = (v7 < 0 ? 0 : v7) + rand() % v6;
    if ( XTile < 0 || YTile < 0 || XTile >= 1024 || YTile >= 1024 )
    {
      v11 = arena;
      a6a = 1;
    }
    else
    {
      v11 = arena;
      a6a = (unsigned __int8)arena->MapAllocatedMemory[1024 * YTile + XTile];
    }
    v12 = XTile + 1;
    if ( XTile + 1 < 0 || YTile < 0 || v12 >= 1024 || YTile >= 1024 )
      v13 = 1;
    else
      v13 = (unsigned __int8)v11->MapAllocatedMemory[1024 * YTile + v12];
    v14 = v13 + a6a;
    v15 = XTile - 1;
    if ( XTile - 1 < 0 || YTile < 0 || v15 >= 1024 || YTile >= 1024 )
      v16 = 1;
    else
      v16 = (unsigned __int8)v11->MapAllocatedMemory[1024 * YTile + v15];
    a6b = v16 + v14;
    v17 = YTile + 1;
    if ( XTile < 0 || v17 < 0 || XTile >= 1024 || v17 >= 1024 )
      v18 = 1;
    else
      v18 = (unsigned __int8)v11->MapAllocatedMemory[1024 * v17 + XTile];
    v19 = v18 + a6b;
    v20 = YTile - 1;
    if ( XTile < 0 || v20 < 0 || XTile >= 1024 || v20 >= 1024 )
      v21 = 1;
    else
      v21 = (unsigned __int8)v11->MapAllocatedMemory[1024 * v20 + XTile];
    a6c = v21 + v19;
    if ( v12 < 0 || v17 < 0 || v12 >= 1024 || v17 >= 1024 )
      v22 = 1;
    else
      v22 = (unsigned __int8)arena->MapAllocatedMemory[1024 * v17 + v12];
    a6d = v22 + a6c;
    if ( v12 < 0 || v20 < 0 || v12 >= 1024 || v20 >= 1024 )
      v23 = 1;
    else
      v23 = (unsigned __int8)arena->MapAllocatedMemory[1024 * v20 + v12];
    v24 = v23 + a6d;
    v25 = XTile - 1;
    if ( XTile - 1 < 0 || v17 < 0 || v25 >= 1024 || v17 >= 1024 )
      v26 = 1;
    else
      v26 = (unsigned __int8)arena->MapAllocatedMemory[1024 * v17 + v25];
    a6e = v26 + v24;
    if ( v25 < 0 || v20 < 0 || v25 >= 1024 || v20 >= 1024 )
    {
      v27 = arena;
      v28 = 1;
    }
    else
    {
      v27 = arena;
      v28 = (unsigned __int8)arena->MapAllocatedMemory[1024 * v20 + v25];
    }
    v29 = v27->FlagCounter;
    a6f = v28 + a6e;
    v30 = 0;
    if ( v29 > 0 )
    {
      v31 = (int)&v27->Flags[0].YTile;
      while ( *(_DWORD *)(v31 - 4) != XTile || *(_DWORD *)v31 != YTile )
      {
        ++v30;
        v31 += 16;
        if ( v30 >= v29 )
          goto LABEL_64;
      }
      ++a6f;
    }
LABEL_64:
    if ( !a6f )
      v34 = 1;
    v7 = --a5a;
    v33 += 2;
    if ( v34 )
      break;
    TwoDifference = a4a;
    v6 = v33;
  }
  *(_DWORD *)ReturnXTile = XTile;
  *(_DWORD *)ReturnYTile = YTile;
}

//----- (00404980) --------------------------------------------------------
void __thiscall sub_404980(struct ARENA *arena, struct PLAYER *a2, int a3, int a4)
{
  int v4; // eax
  char *v5; // esi
  int v6; // ecx
  struct PLAYER **i; // edx
  int v8; // ecx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = 0;
    v5 = &arena->PlayerPointers[8032 * a3 + 1004 * a4];
    v6 = *((_DWORD *)v5 + 250);
    if ( v6 > 0 )
    {
      for ( i = (struct PLAYER **)v5; *i != a2; ++i )
      {
        if ( ++v4 >= v6 )
          return;
      }
      v8 = v6 - 1;
      *((_DWORD *)v5 + 250) = v8;
      *(_DWORD *)&v5[4 * v4] = *(_DWORD *)&v5[4 * v8];
    }
  }
}

//----- (004049F0) --------------------------------------------------------
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4)
{
  int v4; // eax
  char *v5; // edx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = a4 + 8 * a3;                           // 63 max
    v5 = &arena->PlayerPointers[1004 * v4 + 1000];
    *(_DWORD *)&arena->PlayerPointers[1004 * v4 + 4 * (*(_DWORD *)v5)++] = player;
  }
}

//----- (00404A50) --------------------------------------------------------
void __thiscall LoadArenaSettings_0_0(struct ARENA *arenaa)
{
  char *v2; // esi
  int v3; // eax
  int v4; // esi

  v2 = arenaa->SettingsFilename;
  if ( _strcmpi(arenaa->SettingsFilename, Filename2) )
  {
    IsFileLastWrittenTime(v2, (int)&arenaa->LastSettingsWrittenTime);
    LoadZoneCFGSettings(
      (struct ARENA_SETTINGS *)&arenaa->ServersideArenaSettings,
      (struct SERVERSIDE_ARENA_SETTINGS *)&arenaa->ArenaSettings,
      (const char *)&arenaa->ServersideArenaSettings);
  }
  else
  {
    qmemcpy(&arenaa->ArenaSettings, &ArenaSettings, sizeof(arenaa->ArenaSettings));
    qmemcpy(&arenaa->ServersideArenaSettings, &ServersideArenaSettings, sizeof(arenaa->ServersideArenaSettings));
  }
  v3 = 0;
  arenaa->CalculatedMapZoomFactor = ((__int16)arenaa->ArenaSettings.MapZoomFactor << 14) / 96;
  arenaa->MasterPrizeWeightPoolValue = 0;
  do
  {
    v4 = (unsigned __int8)arenaa->ArenaSettings.SomeUnknownStuffToo[v3 + 7] + arenaa->MasterPrizeWeightPoolValue;
    ++v3;
    arenaa->MasterPrizeWeightPoolValue = v4;
  }
  while ( v3 < 29 );
}
/* Orphan comments:
If fail occurs (arena.cfg is missing) uses default server.cfg settings.
Attempt to load arena settings from file
*/

//----- (00404B10) --------------------------------------------------------
void __thiscall LoadArenaMapSomething(struct ARENA *arenaa)
{
  char *MapFileName; // ebx
  int v3; // esi
  struct BMP_FILE_STRUCT *v4; // edi
  int v5; // ebx
  int v6; // eax
  struct BMP_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct BMP_FILE_STRUCT *v9; // esi
  char *v10; // edi
  int v11; // edi
  int v12; // ebx
  int v13; // ecx
  unsigned int v14; // edx
  int XCoordinateRadius; // edi
  int YCoordinateRadius; // esi
  int XCoordinate; // ecx
  int YCoordinate; // eax
  char *v19; // eax
  unsigned int TileValue; // [esp+10h] [ebp-2Ch] BYREF
  int TileValuePointer; // [esp+14h] [ebp-28h] BYREF
  int i; // [esp+18h] [ebp-24h]
  _DWORD Buffer[5]; // [esp+1Ch] [ebp-20h] BYREF
  int v24; // [esp+38h] [ebp-4h]

  MapFileName = arenaa->MapFilename;
  if ( _strcmpi(MiscDefaultLevelFile, arenaa->MapFilename) )
  {
    Buffer[0] = 42;
    Buffer[1] = 0;
    Buffer[2] = 0;
    Buffer[3] = 0;
    LOBYTE(Buffer[4]) = 0;
    strcpy((char *)Buffer + 1, MapFileName);
    arenaa->CompressedMap = CompressFile(
                              MapFileName,
                              &arenaa->DefaultMapFileSize,
                              &arenaa->MapChecksum,
                              Buffer,
                              0x11u,
                              1,
                              0);
    v7 = (struct BMP_FILE_STRUCT *)operator new(0x110u);
    i = (int)v7;
    v24 = 0;
    if ( v7 )
    {
      LoadBMPHeader(v7, MapFileName);
      v9 = (struct BMP_FILE_STRUCT *)v8;
      TileValuePointer = v8;
    }
    else
    {
      TileValuePointer = 0;
      v9 = 0;
    }
    v24 = -1;
    arenaa->TotalMapTurfFlags = 0;
    v10 = (char *)emalloc(0x100000);
    arenaa->MapAllocatedMemory = v10;
    memset(v10, 0, 0x100000u);
    v11 = GetTotalTileCount(v9);
    v12 = 0;
    for ( i = v11; v12 < v11; ++v12 )
    {
      GetTileValue(v9, v12, (int *)&TileValue);
      if ( (TileValue & 0xFF000000) == 0xAA000000 )// // 0xAA - Turf Flag Tile
      {
        v13 = arenaa->TotalMapTurfFlags;
        if ( v13 < 510 )                        // 510 Flags WOW.. I always thought the limit was 255 flags. [510/2=255] odd :\
        {
          arenaa->TurfFlagsCoordinates[v13].XTile = TileValue & 0xFFF;// X Coord
          arenaa->TurfFlagsCoordinates[arenaa->TotalMapTurfFlags++].YTile = (TileValue >> 12) & 0xFFF;// Y Coord
        }
      }
      else
      {
        arenaa->MapAllocatedMemory[1024 * ((TileValue >> 12) & 0xFFF) + (TileValue & 0xFFF)] = HIBYTE(TileValue);
        v14 = TileValue;
        if ( (TileValue & 0xFF000000) >= 0xD8000000 )//  >= 0xD8 Big Tiles like Asteroids/Space Station/Wormhole and Secret Tiles
        {
          for ( XCoordinateRadius = 0; XCoordinateRadius < 7; ++XCoordinateRadius )
          {
            for ( YCoordinateRadius = 0; YCoordinateRadius < 7; ++YCoordinateRadius )
            {
              XCoordinate = XCoordinateRadius + (v14 & 0xFFF);// X Coord
              YCoordinate = YCoordinateRadius + ((v14 >> 12) & 0xFFF);// Y Coord
              if ( XCoordinate < 1024 && YCoordinate < 1024 )
              {
                v19 = &arenaa->MapAllocatedMemory[1024 * YCoordinate + XCoordinate];
                if ( !*v19 )
                {
                  *v19 = 240;
                  v14 = TileValue;
                }
              }
            }
          }
          v11 = i;
          v9 = (struct BMP_FILE_STRUCT *)TileValuePointer;
        }
      }
    }
    if ( v9 )
    {
      sub_406B30(v9);
      operator delete(v9);
    }
  }
  else
  {
    v3 = 0;
    arenaa->CompressedMap = (char *)CompressedServerMap;
    arenaa->DefaultMapFileSize = DefaultMapFileSize;
    arenaa->MapChecksum = MapChecksum;
    arenaa->MapAllocatedMemory = (char *)ServerMapAllocatedMemory;
    arenaa->TotalMapTurfFlags = 0;
    v4 = BMPFilePointer;
    v5 = GetTotalTileCount(BMPFilePointer);
    if ( v5 > 0 )
    {
      do
      {
        GetTileValue(v4, v3, &TileValuePointer);
        if ( (TileValuePointer & 0xFF000000) == 0xAA000000 )// // 0xAA - Turf Flag Tile
        {
          v6 = arenaa->TotalMapTurfFlags;
          if ( v6 < 510 )                       // 510 Flags WOW.. I always thought the limit was 255 flags. [510/2=255] odd :\
          {
            arenaa->TurfFlagsCoordinates[v6].XTile = TileValuePointer & 0xFFF;// X Coord
            arenaa->TurfFlagsCoordinates[arenaa->TotalMapTurfFlags++].YTile = ((unsigned int)TileValuePointer >> 12) & 0xFFF;// Y Coord
          }
        }
        ++v3;
      }
      while ( v3 < v5 );
    }
  }
}
/* Orphan comments:
0x2A - Compressed Map File
*/
// 404C9E: variable 'v8' is possibly undefined

//----- (00404E20) --------------------------------------------------------
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa)
{
  int MasterPrizeWeightRandomPoolValue; // edx
  int CurrentMasterPrizeWeightValue; // ecx
  int CurrentPrizeId; // esi
  int result; // eax
  int PrizeNegativeFactorRandomValue; // edx

  MasterPrizeWeightRandomPoolValue = rand() % arenaa->MasterPrizeWeightPoolValue;
  CurrentMasterPrizeWeightValue = 0;
  CurrentPrizeId = 0;
  while ( 1 )
  {
    if ( arenaa->ArenaSettings.SomeUnknownStuffToo[CurrentPrizeId + 7] )
    {
      if ( MasterPrizeWeightRandomPoolValue >= CurrentMasterPrizeWeightValue )
      {
        CurrentMasterPrizeWeightValue += (unsigned __int8)arenaa->ArenaSettings.SomeUnknownStuffToo[CurrentPrizeId + 7];
        if ( MasterPrizeWeightRandomPoolValue < CurrentMasterPrizeWeightValue )
          break;
      }
    }
    if ( ++CurrentPrizeId >= 29 )
      return 0;
  }
  PrizeNegativeFactorRandomValue = rand() % (__int16)arenaa->ArenaSettings.PrizeNegativeFactor;
  result = CurrentPrizeId;
  if ( !PrizeNegativeFactorRandomValue )
    result = -CurrentPrizeId;
  return result;
}

//----- (00404E80) --------------------------------------------------------
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3)
{
  const CHAR *v3; // eax
  CHAR v4; // cl
  CHAR *i; // edx
  CHAR v6; // cl
  CHAR v8; // cl
  const CHAR *v9; // eax
  CHAR *j; // edx
  CHAR v11; // cl
  int v12; // ebp
  int v13; // edi
  int v14; // ebx
  TEMPLATE_SSS *v15; // esi
  char *v16; // esi
  int v17; // [esp+10h] [ebp-514h]
  int v18; // [esp+14h] [ebp-510h]
  int v20; // [esp+1Ch] [ebp-508h]
  int v21; // [esp+20h] [ebp-504h]
  char Str2[256]; // [esp+24h] [ebp-500h] BYREF
  CHAR KeyName[240]; // [esp+124h] [ebp-400h] BYREF
  CHAR Str[240]; // [esp+224h] [ebp-300h] BYREF
  CHAR Str1[240]; // [esp+324h] [ebp-200h] BYREF
  char a2[244]; // [esp+424h] [ebp-100h] BYREF

  v3 = a3;
  v4 = *a3;
  for ( i = Str1; v4; ++v3 )
  {
    if ( v4 == 58 )
      break;
    *i = v4;
    v4 = v3[1];
    ++i;
  }
  v6 = *v3;
  *i = 0;
  if ( !v6 )
    return 1;
  v8 = v3[1];
  v9 = v3 + 1;
  for ( j = KeyName; v8; ++v9 )
  {
    if ( v8 == 58 )
      break;
    *j = v8;
    v8 = v9[1];
    ++j;
  }
  v11 = *v9;
  *j = 0;
  if ( !v11 )
    return 1;
  v12 = 0;
  strcpy(Str, v9 + 1);
  if ( !player->IsSysop )
  {
    strcpy(Str2, Str1);
    if ( !_strcmpi(Str2, "Warbird")
      || !_strcmpi(Str2, "Javelin")
      || !_strcmpi(Str2, "Spider")
      || !_strcmpi(Str2, "Leviathan")
      || !_strcmpi(Str2, "Weasel")
      || !_strcmpi(Str2, "Terrier")
      || !_strcmpi(Str2, "Lancaster")
      || !_strcmpi(Str2, "Shark") )
    {
      strcpy(Str2, "All");
    }
    v18 = 0;
    v20 = 0;
    v17 = atoi(Str);
    v21 = 0;
    if ( TotalTemplateSSSEntries <= 0 )
    {
      v13 = v17;
      v14 = v17;
    }
    else
    {
      v13 = v17;
      v14 = v17;
      v15 = TotalTemplateSSSList;
      while ( 1 )
      {
        if ( (!_strcmpi(v15->SomeString32, Str2) || !_strcmpi(v15->SomeString32, Str1))
          && !_strcmpi(v15->KeyName, KeyName)
          && !v15->SomeChar1a )
        {
          v13 = v15->someInteger;
          v14 = v15->someInteger2;
          v12 = 1;
          v18 = v15->SomeChar1b;
          if ( v13 == -999 || v17 >= v13 && v17 <= v14 )
            break;
        }
        ++v15;
        if ( ++v21 >= TotalTemplateSSSEntries )
          goto LABEL_34;
      }
      v20 = 1;
    }
LABEL_34:
    if ( !v12 )
    {
      sprintf(a2, "%s:%s is not a valid user parameter.", Str1, KeyName);
      SendMessage(player, a2, 0);
      return 1;
    }
    if ( !v20 )
    {
      sprintf(a2, "Valid range for parameter %s:%s is (%d through %d)", Str1, KeyName, v13, v14);
      SendMessage(player, a2, 0);
      return 1;
    }
    if ( v18 )
    {
      arenaa->ArenaRecycling = 1;
      if ( !_strcmpi(arenaa->SettingsFilename, Filename2) )
        RecycleServer = 1;
    }
  }
  arenaa->NeedSettingsUpdate = 1;
  v16 = arenaa->SettingsFilename;
  if ( !_strcmpi(arenaa->SettingsFilename, Filename2) )
    IsEditedServerINIorCFG = 1;
  if ( _strcmpi(Str1, "All") )
  {
    WritePrivateProfileStringA(Str1, KeyName, Str, v16);
  }
  else
  {
    WritePrivateProfileStringA("Warbird", KeyName, Str, v16);
    WritePrivateProfileStringA("Javelin", KeyName, Str, v16);
    WritePrivateProfileStringA("Spider", KeyName, Str, v16);
    WritePrivateProfileStringA("Leviathan", KeyName, Str, v16);
    WritePrivateProfileStringA("Terrier", KeyName, Str, v16);
    WritePrivateProfileStringA("Weasel", KeyName, Str, v16);
    WritePrivateProfileStringA("Lancaster", KeyName, Str, v16);
    WritePrivateProfileStringA("Shark", KeyName, Str, v16);
  }
  return 0;
}
// 432004: using guessed type int RecycleServer;
// 4D5920: using guessed type int IsEditedServerINIorCFG;
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;

//----- (00405360) --------------------------------------------------------
void __thiscall sub_405360(struct ARENA *arenaa, int BooleanSendScoreReset)
{
  ArenaScoreReset(arenaa, BooleanSendScoreReset);
  arenaa->TotalScoreStructs = 0;
  arenaa->LastTimedGameTime = GetTickCount() / 0xA;
  arenaa->field_FF20 = 0;
  SoccerGameSomething(arenaa, -1);
}

//----- (004053B0) --------------------------------------------------------
int __thiscall SoccerGameSomething(ARENA *this, int a2)
{
  PLAYER **v3; // ebx
  int v4; // eax
  int v5; // eax
  char *v6; // ecx
  PLAYER *v7; // esi
  int v8; // eax
  int result; // eax
  __int16 *v10; // esi
  int v11; // ecx
  int v12; // edi
  char *v13; // ebx
  int v14; // [esp+10h] [ebp-118h]
  int *v15; // [esp+10h] [ebp-118h]
  int v16; // [esp+14h] [ebp-114h]
  char buf[16]; // [esp+18h] [ebp-110h] BYREF
  char a2a[256]; // [esp+28h] [ebp-100h] BYREF

  if ( a2 >= 0 )
  {
    v14 = 0;
    if ( this->ArenaPlayerCount > 0 )
    {
      v3 = (PLAYER **)this->playerPointersForSomething;
      do
      {
        if ( *(_DWORD *)&(*v3)->Frequency == a2 && (*v3)->MySoccerReward > 0 )
        {
          sprintf(a2a, "Soccer game over.  Personal Reward: %d", (*v3)->MySoccerReward);
          UpdatePoints(*v3, 0, (*v3)->MySoccerReward);
        }
        else
        {
          strcpy(a2a, "Soccer game over.");
        }
        SendMessage(*v3, a2a, 103);
        LOBYTE(v4) = SendPlayerScoreUpdateAll(*v3);
        if ( !v4 )
          SendPlayerScoreUpdate(*v3);
        ++v3;
        ++v14;
      }
      while ( v14 < this->ArenaPlayerCount );
    }
  }
  v5 = 0;
  if ( this->ArenaPlayerCount > 0 )
  {
    v6 = this->playerPointersForSomething;
    do
    {
      v7 = *(PLAYER **)v6;
      ++v5;
      v6 += 4;
      v7->MySoccerReward = 0;
    }
    while ( v5 < this->ArenaPlayerCount );
  }
  this->Freq1Score = 0;
  this->Freq2Score = 0;
  this->Freq3Score = 0;
  this->Freq4Score = 0;
  v8 = this->ServersideArenaSettings.SoccerCapturePoints;
  if ( v8 > 0 )
  {
    this->Freq1Score = v8;
    this->Freq2Score = v8;
    this->Freq3Score = v8;
    this->Freq4Score = v8;
  }
  result = 0;
  v16 = 0;
  if ( this->TotalSoccerBalls > 0 )
  {
    v10 = &this->SoccerBalls[0].YPixels;
    v15 = this->SoccerBallTimers;
    do
    {
      *((_BYTE *)v10 - 3) = result;
      *(v10 - 1) = 0;
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      v10[3] = -1;
      *((_DWORD *)v10 + 2) = 0;
      *v15 = 0;
      *(_DWORD *)&buf[1] = *(_DWORD *)((char *)v10 - 3);
      *(_DWORD *)&buf[5] = *(_DWORD *)((char *)v10 + 1);
      *(_DWORD *)&buf[9] = *(_DWORD *)((char *)v10 + 5);
      *(_WORD *)&buf[13] = *(__int16 *)((char *)v10 + 9);
      buf[15] = *((_BYTE *)v10 + 11);
      v11 = this->ArenaPlayerCount;
      v12 = 0;
      buf[0] = 0x2E;                            // 0x2E - Power-Ball Position Update
      if ( v11 > 0 )
      {
        v13 = this->playerPointersForSomething;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v13 + 56) )
            SendPlayerReliablePacket(*(struct PLAYER **)v13, buf, 16u, 1);
          ++v12;
          v13 += 4;
        }
        while ( v12 < this->ArenaPlayerCount );
        result = v16;
      }
      ++result;
      v10 = (__int16 *)((char *)v10 + 15);
      v16 = result;
      ++v15;
    }
    while ( result < this->TotalSoccerBalls );
  }
  this->TotalSoccerBalls = 0;
  return result;
}
// 405467: variable 'v4' is possibly undefined

//----- (004055D0) --------------------------------------------------------
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4)
{
  int v5; // edi
  int v6; // ebx
  int v7; // ebp
  int result; // eax
  int v9; // eax
  int v10; // edi
  char *v11; // ebx
  int *i; // ecx
  int v13; // edx
  int v14; // ecx
  int *v15; // ecx

  v5 = -1;
  v6 = -1;
  v7 = 0;
  result = SoccerRelatedMath((unsigned __int8)arenaa->ArenaSettings.SoccerMode, a3, a4);
  switch ( arenaa->ArenaSettings.SoccerMode )
  {
    case 1:
    case 2:
      v7 = 2;
      v5 = Frequency & 1;
      v6 = result;
      break;
    case 3:
    case 5:
      v7 = 4;
      v5 = Frequency & 3;
      v6 = result;
      break;
    case 4:
    case 6:
      v7 = 4;
      v5 = Frequency & 3;
      switch ( Frequency & 3 )
      {
        case 0:
          v6 = 3;
          break;
        case 1:
          v6 = 2;
          break;
        case 2:
          v6 = 1;
          break;
        case 3:
          v6 = 0;
          break;
        default:
          goto LABEL_9;
      }
      break;
    default:
      break;
  }
LABEL_9:
  if ( v5 >= 0 )
  {
    result = arenaa->ServersideArenaSettings.SoccerCapturePoints;
    if ( result <= 0 )
    {
      if ( result < 0 )
      {
        ++arenaa->SoccerBallTimers[v5 + 8];
        GetScore(arenaa, 0);
        result = arenaa->SoccerBallTimers[v5 + 8];
        if ( result >= -arenaa->ServersideArenaSettings.SoccerCapturePoints )
        {
          v13 = arenaa->ServersideArenaSettings.SoccerWinBy;
          v14 = 1;
          if ( v13 > 0 )
          {
            result = 0;
            if ( v7 > 0 )
            {
              v15 = &arenaa->Freq1Score;
              while ( result == v5 || arenaa->SoccerBallTimers[v5 + 8] - *v15 >= v13 )
              {
                ++result;
                ++v15;
                if ( result >= v7 )
                {
                  v14 = 1;
                  goto LABEL_33;
                }
              }
              v14 = 0;
            }
          }
LABEL_33:
          if ( v14 )
            return SoccerGameSomething(arenaa, Frequency);
        }
      }
    }
    else
    {
      v9 = arenaa->SoccerBallTimers[v6 + 8];
      if ( v9 )
      {
        arenaa->SoccerBallTimers[v6 + 8] = v9 - 1;
        ++arenaa->SoccerBallTimers[v5 + 8];
      }
      else
      {
        v10 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v11 = arenaa->playerPointersForSomething;
          do
          {
            SendMessage(*(struct PLAYER **)v11, "Enemy goal had no points to give.", 0);
            ++v10;
            v11 += 4;
          }
          while ( v10 < arenaa->ArenaPlayerCount );
        }
      }
      GetScore(arenaa, 0);
      result = 0;
      if ( v7 > 0 )
      {
        for ( i = &arenaa->Freq1Score; *i != arenaa->ServersideArenaSettings.SoccerCapturePoints * v7; ++i )
        {
          if ( ++result >= v7 )
            return result;
        }
        return SoccerGameSomething(arenaa, Frequency);
      }
    }
  }
  return result;
}

//----- (004057C0) --------------------------------------------------------
void __thiscall GetScore(struct ARENA *arenaa, struct PLAYER *player)
{
  char v3; // al
  int v4; // ebx
  struct PLAYER **v5; // esi
  struct PLAYER *v6; // ecx
  int v7; // [esp-8h] [ebp-214h]
  char *v8; // [esp-8h] [ebp-214h]
  int v9; // [esp-4h] [ebp-210h]
  char Buffer1[256]; // [esp+Ch] [ebp-200h] BYREF
  char Buffer2[256]; // [esp+10Ch] [ebp-100h] BYREF

  if ( (int)arenaa->ServersideArenaSettings.SoccerBallCount > 0 && arenaa->ServersideArenaSettings.SoccerCapturePoints )
  {
    v3 = arenaa->ArenaSettings.SoccerMode;
    if ( v3 == 1 || v3 == 2 )
    {
      v9 = arenaa->Freq2Score;
      v7 = arenaa->Freq1Score;
      if ( arenaa->ServersideArenaSettings.MiscFrequencyShipTypes )
        sprintf(Buffer1, "SCORE: Warbirds:%d  Javelins:%d", v7, v9);
      else
        sprintf(Buffer1, "SCORE: Evens:%d  Odds:%d", v7, v9);
    }
    else if ( arenaa->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      sprintf(
        Buffer1,
        "SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d",
        arenaa->Freq1Score,
        arenaa->Freq2Score,
        arenaa->Freq3Score,
        arenaa->Freq4Score);
    }
    else
    {
      sprintf(
        Buffer1,
        "SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d",
        arenaa->Freq1Score,
        arenaa->Freq2Score,
        arenaa->Freq3Score,
        arenaa->Freq4Score);
    }
    if ( player )
    {
      if ( player->MySoccerReward <= 0 )
      {
        SendMessage(player, Buffer1, 0);
      }
      else
      {
        sprintf(Buffer2, "%s  REWARD:%d", Buffer1, player->MySoccerReward);
        SendMessage(player, Buffer2, 0);
      }
    }
    else
    {
      v4 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v5 = (struct PLAYER **)arenaa->playerPointersForSomething;
        do
        {
          v6 = *v5;
          if ( (*v5)->MySoccerReward <= 0 )
          {
            v8 = Buffer1;
          }
          else
          {
            sprintf(Buffer2, "%s  REWARD:%d", Buffer1, (*v5)->MySoccerReward);
            v8 = Buffer2;
            v6 = *v5;
          }
          SendMessage(v6, v8, 0);
          ++v4;
          ++v5;
        }
        while ( v4 < arenaa->ArenaPlayerCount );
      }
    }
  }
}

//----- (00405970) --------------------------------------------------------
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena)
{
  int v1; // edx

  v1 = 0x75;
  if ( arena->MapAllocatedMemory != ServerMapAllocatedMemory )
    v1 = 0x525;
  return v1 + ((unsigned int)(18 * arena->TotalNumScoresInFile) >> 10);
}

//----- (004059A0) --------------------------------------------------------
int __thiscall GetTotalPlayingPlayers(ARENA *arena)
{
  int ArenaPlayerCount; // edx
  int result; // eax
  PLAYER **v3; // ecx

  ArenaPlayerCount = arena->ArenaPlayerCount;
  result = 0;
  if ( ArenaPlayerCount > 0 )
  {
    v3 = (PLAYER **)arena->playerPointersForSomething;
    do
    {
      if ( *(_DWORD *)&(*v3)->Ship != 8 )
        ++result;
      ++v3;
      --ArenaPlayerCount;
    }
    while ( ArenaPlayerCount );
  }
  return result;
}

//----- (004059D0) --------------------------------------------------------
void __thiscall SendBillerServerConnectPacket(struct BILLING_SERVER_STRUCT *billingStruct, int HandleBillerPacketFuncAddress, const char *ServerName, int ServerId, int GroupId, int ScoreId, const char *Password, int mainServerStructure, struct CONNECTION *encryption)
{
  struct CONNECTION *v10; // ecx
  char buf[173]; // [esp+8h] [ebp-B0h] BYREF

  billingStruct->MainServerStructure = mainServerStructure;
  billingStruct->encryption = encryption;
  memset(buf, 0, 0xACu);
  buf[172] = 0;
  billingStruct->HandleBillerPacketFunctionAddress = HandleBillerPacketFuncAddress;
  billingStruct->ZeroValue = 0;
  buf[0] = 2;                                   // 0x02 - Billing Server Connect
  strncpy(&buf[13], ServerName, 0x80u);
  buf[140] = 0;
  strncpy(&buf[141], Password, 0x20u);
  *(_DWORD *)&buf[1] = ServerId;
  v10 = billingStruct->encryption;
  buf[172] = 0;
  *(_DWORD *)&buf[5] = GroupId;
  *(_DWORD *)&buf[9] = ScoreId;
  WriteData(v10, buf, 0xADu, 1);
  billingStruct->GetTickCountValue = GetTickCount() / 0xA;
}

//----- (00405AB0) --------------------------------------------------------
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct)
{
  struct CONNECTION *v2; // ecx
  DWORD StartDelayTime; // esi
  int result; // eax
  char buf; // [esp+1h] [ebp-1h] BYREF

  buf = HIBYTE(billingServerStruct);
  v2 = billingServerStruct->encryption;
  buf = 3;                                      // 0x03 - Billing Server DisconnectPacket
  WriteData(v2, &buf, 1u, 1);
  StartDelayTime = GetTickCount() / 0xA;
  for ( result = GetRelAckDiff(billingServerStruct->encryption, 0);
        result > 0;
        result = GetRelAckDiff(billingServerStruct->encryption, 0) )
  {
    result = abs32(GetTickCount() / 0xA - StartDelayTime);
    if ( result >= 800 )                        // Process Player Packets for only 800 milliseconds?
      break;
    PlayerDoNetworkOps((struct PACKET_ATTACHMENT *)billingServerStruct->MainServerStructure);
  }
  return result;
}

//----- (00405B30) --------------------------------------------------------
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3)
{
  char buf[104]; // [esp+0h] [ebp-68h] BYREF

  if ( a2 >= 0 )
  {
    *(_DWORD *)&buf[1] = a2;
    buf[0] = 0x10;                              // 0x10 - Billing User Banner Packet
    qmemcpy(&buf[5], a3, 0x60u);
    WriteData(billingServerStruct->encryption, buf, 0x65u, 1);
  }
}

//----- (00405B70) --------------------------------------------------------
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  struct CONNECTION *v4; // ecx
  char buf[772]; // [esp+0h] [ebp-304h] BYREF

  if ( a1 >= 0 )
  {
    *(_DWORD *)&buf[1] = a1;
    buf[0] = 0xD;                               // 0x0D - Billing User Demographics Packet
    qmemcpy(&buf[5], (const void *)a2, 0x2FCu);
    v4 = billingServerStruct->encryption;
    buf[769] = *(_BYTE *)(a2 + 764);
    WriteData(v4, buf, 0x302u, 1);
  }
}
// 405B70: inconsistent function type and number of purged bytes

//----- (00405BC0) --------------------------------------------------------
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  char buf[2048]; // [esp+10h] [ebp-9h] BYREF

  *(_DWORD *)&buf[1] = a1;
  *(_DWORD *)&buf[5] = a2;
  buf[0] = 0xE;                                 // 0x0E - Some Unknown Biller Packet (Contains a String)
  strcpy(&buf[9], a3);
  WriteData(billingServerStruct->encryption, buf, strlen(a3) + 10, 1);
}

//----- (00405C40) --------------------------------------------------------
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText)
{
  char buf[2048]; // [esp+4h] [ebp-800h] BYREF

  if ( PlayerId >= 0 )
  {
    *(_DWORD *)&buf[1] = PlayerId;
    buf[0] = 0x14;                              // 0x14 - Billing User Channel Chat
    strncpy(&buf[5], ChannelName, 0x20u);
    buf[36] = 0;
    strcpy(&buf[37], ChatText);
    WriteData(billingServerStruct->encryption, buf, strlen(ChatText) + 38, 1);
  }
}

//----- (00405CD0) --------------------------------------------------------
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage)
{
  char buf[1024]; // [esp+4h] [ebp-400h] BYREF

  if ( PlayerId >= 0 )
  {
    *(_DWORD *)&buf[1] = PlayerId;
    buf[0] = 0xF;                               // 0x0F - Biller Warning Packet
    strcpy(&buf[5], WarningMessage);
    WriteData(billingServerStruct->encryption, buf, strlen(WarningMessage) + 6, 1);
  }
}

//----- (00405D50) --------------------------------------------------------
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand)
{
  char buf[1024]; // [esp+4h] [ebp-400h] BYREF

  if ( a2 >= 0 )
  {
    *(_DWORD *)&buf[1] = a2;
    buf[0] = 0x13;                              // 0x13 - Billing User Command
    strcpy(&buf[5], UserCommand);
    WriteData(billingServerStruct->encryption, buf, strlen(UserCommand) + 6, 1);
  }
}

//----- (00405DD0) --------------------------------------------------------
void __thiscall SendBillerUserLoginPacket(BILLING_SERVER_STRUCT *billingServerStruct, const char *Username, const char *Password, int IPAddress, int MachineId, int Timezone, char IsNewUser, int PlayerId, char Unused0, char isSysop)
{
  struct CONNECTION *v11; // ecx
  _WORD buf[42]; // [esp+8h] [ebp-54h] BYREF

  if ( PlayerId >= 0 )
  {
    LOBYTE(buf[0]) = 4;                         // 0x04 - Billing User Login
    strncpy((char *)&buf[3], Username, 0x20u);
    HIBYTE(buf[18]) = 0;
    strncpy((char *)&buf[19], Password, 0x20u);
    *(_DWORD *)&buf[1] = IPAddress;
    HIBYTE(buf[0]) = IsNewUser;
    *(_DWORD *)&buf[37] = MachineId;
    *(_DWORD *)&buf[39] = Timezone;
    v11 = billingServerStruct->encryption;
    HIBYTE(buf[34]) = 0;                        // Terminate with NULL Password
    *(_DWORD *)&buf[35] = PlayerId;
    LOBYTE(buf[41]) = Unused0;
    HIBYTE(buf[41]) = isSysop;
    WriteData(v11, buf, 0x54u, 1);
  }
}

//----- (00405E70) --------------------------------------------------------
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize)
{
  unsigned int Size; // eax
  char buf[1024]; // [esp+0h] [ebp-400h] BYREF

  if ( PlayerId >= 0 )
  {
    *(_DWORD *)&buf[1] = PlayerId;              // PlayerId
    *(_WORD *)&buf[5] = DisconnectReason;       // Disconnect Reason
    *(_WORD *)&buf[7] = Latency;                // Latency
    *(_WORD *)&buf[9] = Ping;                   // Ping
    buf[0] = 5;                                 // 0x05 - Billing User Logoff
    *(_WORD *)&buf[13] = C2SPacketLoss;
    *(_WORD *)&buf[11] = S2CPacketLoss;
    Size = 15;
    if ( PlayerScore )
    {
      qmemcpy(&buf[15], PlayerScore, ExtraSize);
      Size = ExtraSize + 15;
    }
    WriteData(billingServerStruct->encryption, buf, Size, 1);
  }
}

//----- (00405F20) --------------------------------------------------------
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size)
{
  char buf[1024]; // [esp+0h] [ebp-400h] BYREF

  if ( PlayerId >= 0 )
  {
    *(_DWORD *)&buf[1] = PlayerId;
    buf[0] = 0x11;                              // 0x11 - Billing User Score
    qmemcpy(&buf[5], Score, Size);
    WriteData(billingServerStruct->encryption, buf, Size + 5, 1);
  }
}

//----- (00405F80) --------------------------------------------------------
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len)
{
  char *v6; // ebx
  int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = (char *)emalloc(lena);
  qmemcpy(v6 + 9, a3, len);
  *(_DWORD *)(v6 + 5) = a2;
  *v6 = 6;                                      // 0x06 - Billing PlayerName Packet
  *(_DWORD *)(v6 + 1) = a1;
  qmemcpy(v6 + 9, a3, len);
  WriteData(billingServerStruct->encryption, v6, lena, 1);
  efree(v6);
}

//----- (00406010) --------------------------------------------------------
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len)
{
  char *v6; // ebx
  int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = (char *)emalloc(lena);
  qmemcpy(v6 + 9, a4, len);
  *(_DWORD *)(v6 + 5) = BillingGroupId;
  *v6 = 7;                                      // 0x07 - Billing User Private Chat
  *(_DWORD *)(v6 + 1) = PlayerId;
  qmemcpy(v6 + 9, a4, len);
  WriteData(billingServerStruct->encryption, v6, lena, 1);
  efree(v6);
}

//----- (004060A0) --------------------------------------------------------
void __thiscall SendBillerZoneRevokePermitPacket(BILLING_SERVER_STRUCT *billingServerStruct, int a2, int a3, int a4, int len)
{
  char *v6; // ebx
  int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = (char *)emalloc(lena);
  qmemcpy(v6 + 9, (const void *)a4, len);
  *(_DWORD *)(v6 + 5) = a3;
  *v6 = 0x12;                                   // 0x12 - Billing Something with Zone Player *Revoke or *Permit
  *(_DWORD *)(v6 + 1) = a2;
  qmemcpy(v6 + 9, (const void *)a4, len);
  WriteData(billingServerStruct->encryption, v6, lena, 1);
  efree(v6);
}

//----- (00406130) --------------------------------------------------------
int __thiscall GetBillerLastReconnectTime(BILLING_SERVER_STRUCT *billingServerStruct)
{
  return billingServerStruct->encryption->MenuKickOutDelayTimer;
}

//----- (00406140) --------------------------------------------------------
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct)
{
  __int64 v2; // rax
  DWORD v3; // eax
  struct CONNECTION *v4; // ecx
  char *i; // eax
  void (__cdecl *v6)(char *, int); // ecx
  char buf; // [esp+Bh] [ebp-9h] BYREF
  int a2; // [esp+Ch] [ebp-8h] BYREF
  int a3; // [esp+10h] [ebp-4h] BYREF

  if ( CheckIfBillingServerIsConnected((int)billingServerStruct->encryption) != 2
    || GetRelAckDiff(billingServerStruct->encryption, 0) >= 255 )
  {
    return 1;
  }
  v2 = (int)(GetTickCount() / 0xA - billingServerStruct->GetTickCountValue);
  if ( (int)((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 3000 )
  {
    v3 = GetTickCount();
    v4 = billingServerStruct->encryption;
    billingServerStruct->GetTickCountValue = v3 / 0xA;
    buf = 1;
    WriteData(v4, &buf, 1u, 1);
  }
  for ( i = sub_41B1B0((struct PACKET_ATTACHMENT *)billingServerStruct->MainServerStructure, &a2, &a3);
        i;
        i = sub_41B1B0((struct PACKET_ATTACHMENT *)billingServerStruct->MainServerStructure, &a2, &a3) )
  {
    v6 = (void (__cdecl *)(char *, int))billingServerStruct->HandleBillerPacketFunctionAddress;
    if ( v6 )
      v6(i, a2);
  }
  return 0;
}

//----- (00406210) --------------------------------------------------------
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename)
{
  int v3; // esi
  FILE *v4; // eax
  FILE *v5; // edi
  char *v6; // edx
  char v7; // al
  SETTINGS_CATEGORY *v8; // edi
  SETTINGS_CATEGORY *i; // ecx
  char *v10; // eax
  SETTING *v11; // edx
  char j; // cl
  char k; // cl
  char *v14; // eax
  char v15; // cl
  char *l; // edx
  FILE *v18; // [esp+10h] [ebp-204h]
  char Buf[512]; // [esp+14h] [ebp-200h] BYREF

  strcpy(ConfigSETPointer->Filename, Filename);
  ConfigSETPointer->TotalSettingsCategoryCount = 0;
  ConfigSETPointer->TotalSettingsCount = 0;
  ConfigSETPointer->ShouldCreateFile = 0;
  v3 = -1;
  v4 = fopen(ConfigSETPointer->Filename, "rt");
  v5 = v4;
  v18 = v4;
  if ( v4 )
  {
    if ( (v4->_flag & 0x10) == 0 )              // !ferror(v4)
    {
      do
      {
        Buf[0] = 0;
        fgets(Buf, 512, v5);
        if ( Buf[0] == '[' )
        {
          v3 = ConfigSETPointer->TotalSettingsCategoryCount;
          ConfigSETPointer->TotalSettingsCategoryCount = v3 + 1;
          v6 = &Buf[1];
          v7 = Buf[1];
          v8 = &ConfigSETPointer->SettingCategory[v3];
          for ( i = v8; v7; ++v6 )
          {
            if ( v7 == ']' )
              break;
            i->CategoryName[0] = v7;
            v7 = v6[1];
            i = (SETTINGS_CATEGORY *)((char *)i + 1);
          }
          i->CategoryName[0] = 0;
          v8->SettingId = ConfigSETPointer->TotalSettingsCount;
          v8->SettingsInCategory = 0;
          v5 = v18;
        }
        else if ( isalpha(Buf[0]) && v3 != -1 )
        {
          v10 = Buf;
          v11 = &ConfigSETPointer->Setting[ConfigSETPointer->TotalSettingsCount];
          for ( j = Buf[0]; j; ++v10 )
          {
            if ( j == '=' )
              break;
            if ( j == ' ' )
              break;
            LOBYTE(v11->SettingId) = j;
            j = v10[1];
            v11 = (SETTING *)((char *)v11 + 1);
          }
          LOBYTE(v11->SettingId) = 0;
          for ( k = *v10; k; k = *++v10 )
          {
            if ( k == '=' )
              break;
          }
          if ( *v10 )
          {
            v14 = v10 + 1;
            v15 = *v14;
            for ( l = ConfigSETPointer->Setting[ConfigSETPointer->TotalSettingsCount].SettingValue; v15 >= ' '; ++v14 )
            {
              *l = v15;
              v15 = v14[1];
              ++l;
            }
            *l = 0;
            config_read_helper_3(ConfigSETPointer->Setting[ConfigSETPointer->TotalSettingsCount].SettingValue);
            ++ConfigSETPointer->TotalSettingsCount;
            ++ConfigSETPointer->SettingCategory[v3].SettingsInCategory;
          }
        }
      }
      while ( (v5->_flag & 0x10) == 0 );
    }
    fclose(v5);
  }
  return ConfigSETPointer;
}
/* Orphan comments:
FileName
*/

//----- (004063F0) --------------------------------------------------------
void __thiscall WriteCfgFile(struct struc_2 *struc2)
{
  struc_2 *struc22; // esi
  FILE *v2; // ebp
  int v3; // edi
  int v4; // ebx
  const char *v5; // esi
  int v6; // [esp+8h] [ebp-8h]

  struc22 = struc2;
  if ( struc2->ShouldCreateFile )
  {
    v2 = fopen(struc2->Filename, "wt");
    if ( v2 )
    {
      v6 = 0;
      if ( struc22->TotalSettingsCategoryCount > 0 )
      {
        v3 = (int)&struc22->SettingCategory[0].SettingsInCategory;
        do
        {
          if ( *(int *)v3 > 0 )
          {
            fprintf(v2, "[%s]\n", (const char *)(v3 - 34));
            v4 = 0;
            if ( *(int *)v3 > 0 )
            {
              v5 = (const char *)&struc22->Setting[*(_DWORD *)(v3 - 4)];
              do
              {
                fprintf(v2, "%s=%s\n", v5, v5 + 40);
                ++v4;
                v5 += 140;
              }
              while ( v4 < *(_DWORD *)v3 );
              struc22 = struc2;
            }
            fprintf(v2, "\n");
          }
          v3 += 38;
          ++v6;
        }
        while ( v6 < struc22->TotalSettingsCategoryCount );
      }
      fclose(v2);
    }
  }
}

//----- (004064D0) --------------------------------------------------------
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4)
{
  struc_2 *v4; // ebp
  char *v5; // edi
  int v6; // esi
  int v7; // ebx
  const char *v8; // ebp
  int result; // eax
  int v10; // [esp+10h] [ebp-18h]
  char Source[16]; // [esp+18h] [ebp-10h] BYREF

  v4 = Str1;
  v10 = 0;
  if ( Str1->TotalSettingsCategoryCount <= 0 )
  {
LABEL_10:
    sprintf(Source, "%d", a4);
    FillArenaSettingsStruct(v4, Str2, a3, Source);
    result = a4;
  }
  else
  {
    v5 = (char *)&Str1->SettingCategory[0].SettingsInCategory;
    while ( 1 )
    {
      if ( !_strcmpi(v5 - 34, Str2) )
      {
        v6 = *((_DWORD *)v5 - 1);               // SettingCategory[0].SettingsId
        v7 = 0;
        if ( *(int *)v5 > 0 )                   // Str1->SettingCategory[0].SettingsInCategory
          break;
      }
LABEL_9:
      v5 += 38;                                 // Next SettingsCategory[x]
      if ( ++v10 >= v4->TotalSettingsCategoryCount )// Reached last category
        goto LABEL_10;                          // exit and fill struct and return
    }
    v8 = (const char *)&v4->Setting[v6];        // Setting[x].SettingName
    while ( _strcmpi(v8, a3) )
    {
      ++v7;
      ++v6;
      v8 += 140;
      if ( v7 >= *(_DWORD *)v5 )
      {
        v4 = Str1;
        goto LABEL_9;
      }
    }
    result = atoi(Str1->Setting[v6].SettingValue);
  }
  return result;
}

//----- (004065C0) --------------------------------------------------------
void __thiscall __noreturn GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count)
{
  struct struc_2 *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  char *v12; // [esp-8h] [ebp-20h]
  size_t v13; // [esp-4h] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-8h]

  v6 = Str1;
  v14 = 0;
  if ( Str1->TotalSettingsCategoryCount <= 0 )
  {
LABEL_10:
    FillArenaSettingsStruct(v6, Str2, a3, Source);
    v11 = Count;
    v13 = Count;
    v12 = Source;
  }
  else
  {
    v7 = &Str1->SettingCategory[0].SettingsInCategory;
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v14 >= v6->TotalSettingsCategoryCount )
        goto LABEL_10;
    }
    v10 = (const char *)&v6->Setting[v8];
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = Str1;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v13 = Count;
    v12 = Str1->Setting[v8].SettingValue;
  }
  strncpy(Dest, v12, v13);
  Dest[v11 - 1] = 0;
}

//----- (004066B0) --------------------------------------------------------
void __thiscall sub_4066B0(struct struc_2 *strucValue, const char *Str2, const char *a3, const char *Source, char *Dest, size_t Count)
{
  struct struc_2 *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  size_t v13; // [esp-4h] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-8h]

  v6 = strucValue;
  v14 = 0;
  if ( strucValue->TotalSettingsCategoryCount <= 0 )
  {
LABEL_10:
    v11 = Count;
    v13 = Count;
  }
  else
  {
    v7 = &strucValue->SettingCategory[0].SettingsInCategory;
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v14 >= v6->TotalSettingsCategoryCount )
        goto LABEL_10;
    }
    v10 = (const char *)&v6->Setting[v8];
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = strucValue;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v13 = Count;
    Source = strucValue->Setting[v8].SettingValue;
  }
  strncpy(Dest, Source, v13);
  Dest[v11 - 1] = 0;
}

//----- (00406790) --------------------------------------------------------
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source)
{
  struc_2 *v4; // ebp
  int v5; // esi
  int v6; // eax
  int v7; // edi
  int v8; // eax
  char *v9; // esi
  int v10; // ebx
  int v11; // ecx
  int v12; // esi
  const char *v13; // edi
  char *v14; // ebx
  int v15; // eax
  int *v16; // ecx
  int v17; // [esp+10h] [ebp-Ch]
  char *v18; // [esp+14h] [ebp-8h]
  char *Str2a; // [esp+20h] [ebp+4h]

  v4 = Str1;
  v5 = 0;
  v6 = Str1->TotalSettingsCategoryCount;
  Str1->ShouldCreateFile = 1;
  if ( v6 <= 0 )
  {
LABEL_5:
    strcpy(v4->SettingCategory[v4->TotalSettingsCategoryCount].CategoryName, Str2);
    v4->SettingCategory[v4->TotalSettingsCategoryCount].SettingId = v4->TotalSettingsCount;
    v4->SettingCategory[v4->TotalSettingsCategoryCount].SettingsInCategory = 1;
    v8 = v4->TotalSettingsCount;
    ++v4->TotalSettingsCategoryCount;
    strcpy((char *)&v4->Setting[v8], a3);
    v9 = v4->Setting[v4->TotalSettingsCount].SettingValue;
    strncpy(v9, Source, 0x64u);
    v9[99] = 0;
    ++v4->TotalSettingsCount;
  }
  else
  {
    v7 = (int)Str1;
    while ( _strcmpi((const char *)v7, Str2) )
    {
      ++v5;
      v7 += 38;
      if ( v5 >= v4->TotalSettingsCategoryCount )
        goto LABEL_5;
    }
    v17 = v5;
    v10 = 0;
    v11 = 19 * v5;
    v12 = v4->SettingCategory[v5].SettingId;
    Str2a = (char *)v12;
    v18 = (char *)v4 + 2 * v11;
    if ( *(int *)(v18 + 34) <= 0 )
    {
LABEL_12:
      memcpy(&v4->Setting[v12 + 1], &v4->Setting[v12], 140 * v4->TotalSettingsCount - 140 * v12);
      v14 = v4->Setting[v12].SettingValue;
      strcpy((char *)&v4->Setting[v12], a3);
      strncpy(v14, Source, 0x64u);
      v14[99] = 0;
      ++v4->TotalSettingsCount;
      ++*(_DWORD *)(v18 + 34);
      v15 = 0;
      if ( v4->TotalSettingsCategoryCount > 0 )
      {
        v16 = &v4->SettingCategory[0].SettingId;
        do
        {
          if ( *v16 >= (int)Str2a && v15 != v17 )
            ++*v16;
          ++v15;
          v16 = (int *)((char *)v16 + 38);
        }
        while ( v15 < v4->TotalSettingsCategoryCount );
      }
    }
    else
    {
      v13 = (const char *)&v4->Setting[v12];
      while ( _strcmpi(v13, a3) )
      {
        ++v10;
        ++v12;
        v13 += 140;
        if ( v10 >= *(_DWORD *)(v18 + 34) )
        {
          Str2a = (char *)v12;
          goto LABEL_12;
        }
      }
      strcpy(v4->Setting[v12].SettingValue, Source);
    }
  }
}

//----- (00406A30) --------------------------------------------------------
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source)
{
  FILE *v3; // eax
  FILE *v4; // edi
  int v5; // eax
  int v6; // eax
  int *v7; // eax
  int v8; // edx
  _WORD DstBuf[4]; // [esp+Ch] [ebp-8h] BYREF

  strncpy(Filename->FileName, Source, 0x100u);
  Filename->FileName[255] = 0;
  Filename->BMPPointer = 0;
  Filename->TotalMapTiles = 0;
  v3 = fopen(Filename->FileName, "rb");
  v4 = v3;
  if ( v3 )
  {
    Filename->BMPFileSizeOffset = 0;
    if ( fread(DstBuf, 1u, 6u, v3) == 6 && LOBYTE(DstBuf[0]) == 'B' && HIBYTE(DstBuf[0]) == 'M' )// Load BMP Header.
      Filename->BMPFileSizeOffset = *(_DWORD *)&DstBuf[1];// 4 bytes after BM Header
    fseek(v4, Filename->BMPFileSizeOffset, 0);
    v5 = _fileno(v4);
    v6 = (unsigned int)(_filelength(v5) - Filename->BMPFileSizeOffset) >> 2;// >> 2 same as divide by 4. (powers of 2)
    Filename->TotalMapTiles = v6;
    v7 = (int *)emalloc(4 * v6);
    v8 = Filename->TotalMapTiles;
    Filename->BMPPointer = v7;
    fread(v7, v8, 4u, v4);
    fclose(v4);
  }
  Filename->field_104 = 0;
}
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (00406B30) --------------------------------------------------------
void __thiscall sub_406B30(struct BMP_FILE_STRUCT *BMPFileStruct)
{
  FILE *v2; // edi
  int v3; // eax
  int *v4; // esi
  int v5; // [esp-4h] [ebp-Ch]

  if ( BMPFileStruct->field_104 )
  {
    if ( BMPFileStruct->BMPPointer )
    {
      v2 = fopen(BMPFileStruct->FileName, "rb+");
      if ( v2 || (v2 = fopen(BMPFileStruct->FileName, "wb")) != 0 )
      {
        fseek(v2, BMPFileStruct->BMPFileSizeOffset, 0);
        fwrite(BMPFileStruct->BMPPointer, BMPFileStruct->TotalMapTiles, 4u, v2);
        v5 = BMPFileStruct->BMPFileSizeOffset + 4 * BMPFileStruct->TotalMapTiles;
        v3 = _fileno(v2);
        _chsize(v3, v5);
        fclose(v2);
      }
    }
  }
  v4 = BMPFileStruct->BMPPointer;
  if ( v4 )
    efree(v4);
}
// 41E210: using guessed type _DWORD __cdecl _chsize(_DWORD, _DWORD);

//----- (00406BE0) --------------------------------------------------------
int __thiscall GetTotalTileCount(struct BMP_FILE_STRUCT *BMPFile)
{
  return BMPFile->TotalMapTiles;
}

//----- (00406BF0) --------------------------------------------------------
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi

  // //Looks very complicated with those XOR's and bitwise cleans
  v3 = *TileValuePointer ^ ((unsigned __int16)*TileValuePointer ^ (unsigned __int16)BMPFile->BMPPointer[TileCounter]) & 0xFFF;
  *TileValuePointer = v3;
  v4 = v3 ^ (v3 ^ BMPFile->BMPPointer[TileCounter]) & 0xFFF000;
  *TileValuePointer = v4;
  v5 = BMPFile->BMPPointer[TileCounter];
  *TileValuePointer = v5 ^ (v5 ^ v4) & 0xFFFFFF;
}

//----- (00406C50) --------------------------------------------------------
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize)
{
  int v8; // ebx
  char *MapAllocatedMemoryy; // esi
  int tempXTiles1; // ebx
  int i; // edi
  int tempXTiles2; // edi
  int tempYTiles; // ecx
  char *v14; // eax
  int tempYTiles1; // ecx
  int YTiless; // esi
  char *v17; // eax
  int tempYTiles2; // esi
  int v19; // eax
  int v20; // eax
  signed int j; // ecx
  int v22; // eax
  signed int v23; // eax
  char *v24; // edi
  char *v25; // ebx

  v8 = XTiles;
  if ( XTiles < 0 )
  {
    MapAllocatedMemoryy = MapAllocatedMemory;
  }
  else
  {
    MapAllocatedMemoryy = MapAllocatedMemory;
    do
    {
      if ( MapAllocatedMemory[1024 * YTiles + v8] )
        break;
      --v8;
    }
    while ( v8 >= 0 );
  }
  tempXTiles1 = v8 + 1;
  for ( i = XTiles; i < 1024; ++i )
  {
    if ( MapAllocatedMemoryy[1024 * YTiles + i] )
      break;
  }
  tempXTiles2 = i - 1;
  if ( tempXTiles2 < tempXTiles1 )
    tempXTiles2 = tempXTiles1;
  tempYTiles = YTiles;
  if ( YTiles >= 0 )
  {
    v14 = &MapAllocatedMemoryy[1024 * YTiles + XTiles];
    do
    {
      if ( *v14 )
        break;
      --tempYTiles;
      v14 -= 1024;
    }
    while ( tempYTiles >= 0 );
  }
  tempYTiles1 = tempYTiles + 1;
  YTiless = YTiles;
  if ( YTiles < 1024 )
  {
    v17 = &MapAllocatedMemory[1024 * YTiles + XTiles];
    do
    {
      if ( *v17 )
        break;
      ++YTiless;
      v17 += 1024;
    }
    while ( YTiless < 1024 );
  }
  tempYTiles2 = YTiless - 1;
  if ( tempYTiles2 < tempYTiles1 )
    tempYTiles2 = tempYTiles1;
  v19 = BrickSpanSize / 2;
  if ( tempXTiles2 - tempXTiles1 >= tempYTiles2 - tempYTiles1 )
  {
    if ( tempYTiles1 <= YTiles - v19 )
      tempYTiles1 = YTiles - v19;
    v22 = YTiles + v19;
    if ( tempYTiles2 >= v22 )
      tempYTiles2 = v22;
    v23 = tempYTiles2 - tempYTiles1 + 1;
    if ( v23 < BrickSpanSize )
    {
      v24 = &MapAllocatedMemory[1024 * tempYTiles1 + XTiles];
      v25 = &MapAllocatedMemory[1024 * tempYTiles2 + 1024 + XTiles];
      do
      {
        if ( tempYTiles1 - 1 < 0 || *(v24 - 1024) )
        {
          if ( tempYTiles2 >= 1023 || *v25 )
            break;
          ++tempYTiles2;
          v25 += 1024;
        }
        else
        {
          --tempYTiles1;
          v24 -= 1024;
        }
        ++v23;
      }
      while ( v23 < BrickSpanSize );
    }
    *Y1Tile = tempYTiles1;
    *Y2Tile = tempYTiles2;
    *X1Tile = XTiles;
    *X2Tile = XTiles;
  }
  else
  {
    if ( tempXTiles1 <= XTiles - v19 )
      tempXTiles1 = XTiles - v19;
    v20 = XTiles + v19;
    if ( tempXTiles2 >= v20 )
      tempXTiles2 = v20;
    for ( j = tempXTiles2 - tempXTiles1 + 1; j < BrickSpanSize; ++j )
    {
      if ( tempXTiles1 - 1 < 0 || MapAllocatedMemory[1024 * YTiles - 1 + tempXTiles1] )
      {
        if ( tempXTiles2 >= 1023 || MapAllocatedMemory[1024 * YTiles + 1 + tempXTiles2] )
          break;
        ++tempXTiles2;
      }
      else
      {
        --tempXTiles1;
      }
    }
    *X1Tile = tempXTiles1;
    *X2Tile = tempXTiles2;
    *Y1Tile = YTiles;
    *Y2Tile = YTiles;
  }
}

//----- (00406E30) --------------------------------------------------------
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key)
{
  signed int v2; // edi
  int v3; // ecx
  int v4; // eax
  char *v5; // esi
  unsigned int v6; // ebx
  char *v7; // edx
  char *v8; // ecx
  char v9; // al
  int MapDataa; // [esp+8h] [ebp+4h]

  v2 = Key;
  v3 = Key % 32;
  if ( Key % 32 < 1024 )
  {
    v4 = 1024 - Key % 31;
    v5 = &MapData[1024 * v3 + Key % 31];
    MapDataa = v4;
    v6 = (unsigned int)(1055 - v3) >> 5;        // >> 5 same as divide by 32. (powers of 2), ignore this in checksums for speed lol
    do
    {
      v7 = &v5[v4];
      v8 = v5;
      if ( v5 < &v5[v4] )
      {
        do
        {
          v9 = *v8;
          if ( *v8 && (unsigned __int8)v9 < 0xA1u || v9 == (char)0xAB )
            Key += (unsigned __int8)*v8 ^ v2;
          v8 += 31;
        }
        while ( v8 < v7 );
        v4 = MapDataa;
      }
      v5 += 0x8000;
      --v6;
    }
    while ( v6 );
  }
  return Key;
}

//----- (00406ED0) --------------------------------------------------------
bool __cdecl LoadBMPHeader2(const char *Filename)
{
  bool v1; // bl
  FILE *v2; // eax
  FILE *v3; // ebp
  __int32 BMPFileOffset; // edi
  int v5; // eax
  __int32 v6; // eax
  unsigned __int32 v7; // eax
  signed int v8; // esi
  int *v9; // edi
  int *v10; // ecx
  int v11; // eax
  bool result; // al
  char DstBuf[6]; // [esp+8h] [ebp-8h] BYREF

  v1 = 1;
  v2 = fopen(Filename, "rb");
  v3 = v2;
  if ( !v2 )
    return 0;
  BMPFileOffset = 0;
  if ( fread(DstBuf, 1u, 6u, v2) == 6 && DstBuf[0] == 'B' && DstBuf[1] == 'M' )// Load BMP Header
    BMPFileOffset = *(_DWORD *)&DstBuf[2];      // 4 bytes after BM Header
  v5 = _fileno(v3);
  v6 = _filelength(v5);
  if ( BMPFileOffset < v6
    && BMPFileOffset >= 0
    && (v7 = v6 - BMPFileOffset, v8 = v7 >> 2, 4 * (v7 >> 2) == v7)
    && (fseek(v3, BMPFileOffset, 0), v8 > 0) )
  {
    v9 = (int *)emalloc(4 * v8);
    fread(v9, v8, 4u, v3);
    v10 = v9;
    do
    {
      v11 = *v10;
      if ( (*v10 & 0xFFFu) > 0x400 || (v11 & 0xFFF000u) > 0x400000 || (v11 & 0xFF000000) == 0 )
        v1 = 0;
      ++v10;
      --v8;
    }
    while ( v8 );
    efree(v9);
    fclose(v3);
    result = v1;
  }
  else
  {
    fclose(v3);
    result = 0;
  }
  return result;
}
// 406F8B: conditional instruction was optimized away because of 'esi.4>=1'
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (00407000) --------------------------------------------------------
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll)
{
  textFile->MakeUpperCase = makeUpperCase;
  textFile->AddAll = addAll;
  if ( Source )
  {
    strncpy(textFile->FileName, Source, 0x100u);
    textFile->FileName[255] = 0;
  }
  else
  {
    textFile->FileName[0] = 0;
  }
  textFile->Counter = 0;
  textFile->Pointer = 0;
  LoadTextFile(textFile, 1);
}

//----- (00407060) --------------------------------------------------------
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile)
{
  int i; // edi

  if ( textFile->Pointer )
  {
    for ( i = 0; i < textFile->Counter; ++i )
      efree(textFile->Pointer[i]);
    ExpandMemory(textFile->Pointer, 0, 1);
    textFile->Pointer = 0;
    textFile->Counter = 0;
  }
}

//----- (004070D0) --------------------------------------------------------
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2)
{
  int i; // esi
  FILE *v4; // eax
  FILE *v5; // esi
  char *j; // eax
  char Buf[512]; // [esp+10h] [ebp-200h] BYREF

  if ( a2 || !textFile->FileName[0] || IsFileLastWrittenTime(textFile->FileName, (int)&textFile->LastFileEditTime) )
  {
    if ( textFile->Pointer )
    {
      for ( i = 0; i < textFile->Counter; ++i )
        efree(textFile->Pointer[i]);
      ExpandMemory(textFile->Pointer, 0, 1);
      textFile->Pointer = 0;
      textFile->Counter = 0;
    }
    if ( textFile->FileName[0] )
    {
      v4 = fopen(textFile->FileName, "rt");
      v5 = v4;
      if ( v4 )
      {
        if ( (v4->_flag & 0x10) == 0 )
        {
          do
          {
            if ( fgets(Buf, 512, v5) )
            {
              for ( j = &Buf[strlen(Buf)]; j != Buf; --j )
              {
                if ( *(j - 1) >= ' ' )
                  break;
              }
              *j = 0;
              if ( strlen(Buf) )
                AddLineTextFile(textFile, Buf);
            }
          }
          while ( (v5->_flag & 0x10) == 0 );
        }
        fclose(v5);
      }
    }
  }
}
// 4070D0: using guessed type char Buf[512];

//----- (00407200) --------------------------------------------------------
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile)
{
  FILE *v2; // ebx
  int i; // esi

  if ( textFile->FileName[0] )
  {
    v2 = fopen(textFile->FileName, "wt");       // wt = Write In Text Mode
    if ( v2 )
    {
      for ( i = 0; i < textFile->Counter; ++i )
        fprintf(v2, "%s\n", textFile->Pointer[i]);
      fclose(v2);
    }
  }
}

//----- (00407260) --------------------------------------------------------
int __thiscall TextFileTotalLines(struct TEXT_FILE_STRUCT *textFile)
{
  return textFile->Counter;
}

//----- (00407270) --------------------------------------------------------
char *__thiscall TextFileByIndex(struct TEXT_FILE_STRUCT *textFile, int listMachineIndex)
{
  return textFile->Pointer[listMachineIndex];
}

//----- (00407280) --------------------------------------------------------
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer)
{
  signed int v3; // esi
  int v4; // eax
  char *v5; // eax
  size_t v6; // ecx
  unsigned int FoundPointer; // [esp+10h] [ebp-4h] BYREF
  char *ChatMsgBuffera; // [esp+18h] [ebp+4h]

  v3 = 0;
  v4 = BinarySearch(
         (int)ChatMsgBuffer,
         (unsigned int)textFile->Pointer,
         textFile->Counter,
         4,
         (int (__cdecl *)(_DWORD, _DWORD))StringCompare,
         &FoundPointer);
  if ( !FoundPointer || !textFile->AddAll )
  {
    if ( v4 )
      v3 = (signed int)(v4 - (unsigned int)textFile->Pointer) >> 2;
    v5 = ExpandMemory(textFile->Pointer, 4 * textFile->Counter + 4, 2048);
    v6 = 4 * (textFile->Counter + 0x3FFFFFFF * v3);
    textFile->Pointer = (char **)v5;
    memcpy(&v5[4 * v3 + 4], &v5[4 * v3], v6);
    ChatMsgBuffera = (char *)emalloc(strlen(ChatMsgBuffer) + 1);
    strcpy(ChatMsgBuffera, ChatMsgBuffer);
    textFile->Pointer[v3] = ChatMsgBuffera;
    if ( textFile->MakeUpperCase )
      _strupr(textFile->Pointer[v3]);           // converts any lowercase characters in str to uppercase letters
    ++textFile->Counter;
  }
}
/* Orphan comments:
Make more memory for chat message
Copy chat message into memory
*/

//----- (004073A0) --------------------------------------------------------
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number)
{
  TEXT_FILE_STRUCT *v2; // ecx
  TEXT_FILE_STRUCT *v3; // esi
  int v4; // ecx

  v3 = v2;
  efree(v2->Pointer[(_DWORD)textFile]);
  v4 = v3->Counter - 1;
  v3->Counter = v4;
  memcpy(&v3->Pointer[(_DWORD)textFile], &v3->Pointer[(_DWORD)textFile + 1], 4 * (v4 + 0x3FFFFFFF * (_DWORD)textFile));
  v3->Pointer = (char **)ExpandMemory(v3->Pointer, 4 * v3->Counter, 2048);
}
// 4073A7: variable 'v2' is possibly undefined
// 4073A0: inconsistent function type and number of purged bytes

//----- (00407420) --------------------------------------------------------
int __thiscall IsBannedMachineId(struct TEXT_FILE_STRUCT *textFile, char *MachineId)
{
  int v3; // eax
  int result; // eax

  v3 = BinarySearch(
         (int)MachineId,
         (unsigned int)textFile->Pointer,
         textFile->Counter,
         4,
         (int (__cdecl *)(_DWORD, _DWORD))StringCompare,
         (unsigned int *)&MachineId);
  if ( MachineId )
    result = (signed int)(v3 - (unsigned int)textFile->Pointer) >> 2;
  else
    result = -1;
  return result;
}

//----- (00407470) --------------------------------------------------------
int __cdecl StringCompare(int ElementString, const char **ArrayPointer)
{
  return _strcmpi((const char *)ElementString, *ArrayPointer);
}

//----- (00407490) --------------------------------------------------------
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src)
{
  const char *v2; // esi
  int v3; // ecx
  char v4; // al
  char *i; // ecx

  *a1 = 0;
  v2 = Src;
  if ( isspace(*Src) == ' ' )
  {
    do
      v3 = *++v2;
    while ( isspace(v3) == ' ' );
  }
  v4 = *v2;
  for ( i = a1; v4; ++v2 )
  {
    if ( v4 == ',' )
      break;
    *i = v4;
    v4 = v2[1];
    ++i;
  }
  *i = 0;
  if ( *v2 == ',' )
    ++v2;
  strcpy(Src, v2);
  return a1;
}

//----- (00407510) --------------------------------------------------------
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int a2)
{
  HANDLE v2; // eax
  void *v3; // esi
  struct _FILETIME LastWriteTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+Ch] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+14h] [ebp-8h] BYREF

  v2 = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
  v3 = v2;
  if ( v2 != (HANDLE)-1 )
  {
    GetFileTime(v2, &CreationTime, &LastAccessTime, &LastWriteTime);
    CloseHandle(v3);
    v2 = (HANDLE)LastWriteTime.dwLowDateTime;
  }
  if ( *(HANDLE *)a2 == v2 )
    return 0;
  *(_DWORD *)a2 = v2;
  return 1;
}

//----- (00407580) --------------------------------------------------------
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer)
{
  int mid; // esi
  int result; // eax
  unsigned int LowerBound; // ebp
  unsigned int UpperBound; // edi

  mid = 0;
  result = 0;
  *FoundPointer = 0;
  if ( !TotalElements )
    return result;
  LowerBound = Array;
  UpperBound = Array + ElementSize * (TotalElements - 1);
  if ( Array > UpperBound )
  {
NOT_FOUND:
    if ( result > 0 )
      mid += ElementSize;
    return mid;
  }
  while ( 1 )
  {
    mid = LowerBound + ElementSize * ((int)(UpperBound - LowerBound) / ElementSize / 2);
    result = CompareFunc(ElementToFind, mid);
    if ( result < 0 )
    {
      if ( mid == Array )
        goto NOT_FOUND;
      UpperBound = mid - ElementSize;
      goto CHECK_LOOP_END;
    }
    if ( result <= 0 )
      break;
    LowerBound = mid + ElementSize;
CHECK_LOOP_END:
    if ( LowerBound > UpperBound )
      goto NOT_FOUND;
  }
  *FoundPointer = 1;
  if ( mid == Array )
    return Array;
  while ( 1 )
  {
    mid -= ElementSize;
    if ( CompareFunc(ElementToFind, mid) )
      break;
    if ( mid == Array )
      return Array;
  }
  return mid + ElementSize;
}

//----- (00407630) --------------------------------------------------------
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName)
{
  unsigned int v4; // esi
  char Dest[16]; // [esp+10h] [ebp-10h] BYREF

  v4 = GetPrivateProfileIntA(lpAppName, lpKeyName, -12345678, lpFileName);
  if ( v4 == -12345678 )
  {
    v4 = a3;
    sprintf(Dest, "%d", a3);
    WritePrivateProfileStringA(lpAppName, lpKeyName, Dest, lpFileName);
  }
  return v4;
}

//----- (00407690) --------------------------------------------------------
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
{
  int result; // eax

  GetPrivateProfileStringA(lpAppName, lpKeyName, "1x2y3z4", lpReturnedString, nSize, lpFileName);
  result = strcmp(lpReturnedString, "1x2y3z4");
  if ( !result )
  {
    strcpy(lpReturnedString, lpDefault);
    result = WritePrivateProfileStringA(lpAppName, lpKeyName, lpReturnedString, lpFileName);
  }
  return result;
}

//----- (00407730) --------------------------------------------------------
void __cdecl config_read_helper_3(char *a1)
{
  char *v1; // ecx
  char *v2; // esi
  char v3; // dl
  char i; // dl
  char v5; // bl

  v1 = a1;
  v2 = a1;
  if ( *a1 == ' ' )
  {
    do
      v3 = *++v1;
    while ( v3 == ' ' );
  }
  for ( i = *v1; i; ++v1 )
  {
    if ( i != ' ' || (v5 = v1[1], v5 != ' ') && v5 )
      *v2++ = i;
    i = v1[1];
  }
  *v2 = 0;
}

//----- (00407780) --------------------------------------------------------
signed int __cdecl CRC32(char *buffer, int fileSize)
{
  char *v2; // ecx
  int v3; // eax
  int v5[256]; // [esp+4h] [ebp-400h]

  v5[0] = 0;
  v5[1] = 1996959894;
  v5[2] = -301047508;
  v5[3] = -1727442502;
  v5[4] = 124634137;
  v5[5] = 1886057615;
  v5[6] = -379345611;
  v5[7] = -1637575261;
  v5[8] = 249268274;
  v5[9] = 2044508324;
  v5[10] = -522852066;
  v5[11] = -1747789432;
  v5[12] = 162941995;
  v5[13] = 2125561021;
  v5[14] = -407360249;
  v5[15] = -1866523247;
  v5[16] = 498536548;
  v5[17] = 1789927666;
  v5[18] = -205950648;
  v5[19] = -2067906082;
  v5[20] = 450548861;
  v5[21] = 1843258603;
  v5[22] = -187386543;
  v5[23] = -2083289657;
  v5[24] = 325883990;
  v5[25] = 1684777152;
  v5[26] = -43845254;
  v5[27] = -1973040660;
  v5[28] = 335633487;
  v5[29] = 1661365465;
  v5[30] = -99664541;
  v5[31] = -1928851979;
  v5[32] = 997073096;
  v5[33] = 1281953886;
  v5[34] = -715111964;
  v5[35] = -1570279054;
  v5[36] = 1006888145;
  v5[37] = 1258607687;
  v5[38] = -770865667;
  v5[39] = -1526024853;
  v5[40] = 901097722;
  v5[41] = 1119000684;
  v5[42] = -608450090;
  v5[43] = -1396901568;
  v5[44] = 853044451;
  v5[45] = 1172266101;
  v5[46] = -589951537;
  v5[47] = -1412350631;
  v5[48] = 651767980;
  v5[49] = 1373503546;
  v5[50] = -925412992;
  v5[51] = -1076862698;
  v5[52] = 565507253;
  v5[53] = 1454621731;
  v5[54] = -809855591;
  v5[55] = -1195530993;
  v5[56] = 671266974;
  v5[57] = 1594198024;
  v5[58] = -972236366;
  v5[59] = -1324619484;
  v5[60] = 795835527;
  v5[61] = 1483230225;
  v5[62] = -1050600021;
  v5[63] = -1234817731;
  v5[64] = 1994146192;
  v5[65] = 31158534;
  v5[66] = -1731059524;
  v5[67] = -271249366;
  v5[68] = 1907459465;
  v5[69] = 112637215;
  v5[70] = -1614814043;
  v5[71] = -390540237;
  v5[72] = 2013776290;
  v5[73] = 251722036;
  v5[74] = -1777751922;
  v5[75] = -519137256;
  v5[76] = 2137656763;
  v5[77] = 141376813;
  v5[78] = -1855689577;
  v5[79] = -429695999;
  v5[80] = 1802195444;
  v5[81] = 476864866;
  v5[82] = -2056965928;
  v5[83] = -228458418;
  v5[84] = 1812370925;
  v5[85] = 453092731;
  v5[86] = -2113342271;
  v5[87] = -183516073;
  v5[88] = 1706088902;
  v5[89] = 314042704;
  v5[90] = -1950435094;
  v5[91] = -54949764;
  v5[92] = 1658658271;
  v5[93] = 366619977;
  v5[94] = -1932296973;
  v5[95] = -69972891;
  v5[96] = 1303535960;
  v5[97] = 984961486;
  v5[98] = -1547960204;
  v5[99] = -725929758;
  v5[100] = 1256170817;
  v5[101] = 1037604311;
  v5[102] = -1529756563;
  v5[103] = -740887301;
  v5[104] = 1131014506;
  v5[105] = 879679996;
  v5[106] = -1385723834;
  v5[107] = -631195440;
  v5[108] = 1141124467;
  v5[109] = 855842277;
  v5[110] = -1442165665;
  v5[111] = -586318647;
  v5[112] = 1342533948;
  v5[113] = 654459306;
  v5[114] = -1106571248;
  v5[115] = -921952122;
  v5[116] = 1466479909;
  v5[117] = 544179635;
  v5[118] = -1184443383;
  v5[119] = -832445281;
  v5[120] = 1591671054;
  v5[121] = 702138776;
  v5[122] = -1328506846;
  v5[123] = -942167884;
  v5[124] = 1504918807;
  v5[125] = 783551873;
  v5[126] = -1212326853;
  v5[127] = -1061524307;
  v5[128] = -306674912;
  v5[129] = -1698712650;
  v5[130] = 62317068;
  v5[131] = 1957810842;
  v5[132] = -355121351;
  v5[133] = -1647151185;
  v5[134] = 81470997;
  v5[135] = 1943803523;
  v5[136] = -480048366;
  v5[137] = -1805370492;
  v5[138] = 225274430;
  v5[139] = 2053790376;
  v5[140] = -468791541;
  v5[141] = -1828061283;
  v5[142] = 167816743;
  v5[143] = 2097651377;
  v5[144] = -267414716;
  v5[145] = -2029476910;
  v5[146] = 503444072;
  v5[147] = 1762050814;
  v5[148] = -144550051;
  v5[149] = -2140837941;
  v5[150] = 426522225;
  v5[151] = 1852507879;
  v5[152] = -19653770;
  v5[153] = -1982649376;
  v5[154] = 282753626;
  v5[155] = 1742555852;
  v5[156] = -105259153;
  v5[157] = -1900089351;
  v5[158] = 397917763;
  v5[159] = 1622183637;
  v5[160] = -690576408;
  v5[161] = -1580100738;
  v5[162] = 953729732;
  v5[163] = 1340076626;
  v5[164] = -776247311;
  v5[165] = -1497606297;
  v5[166] = 1068828381;
  v5[167] = 1219638859;
  v5[168] = -670225446;
  v5[169] = -1358292148;
  v5[170] = 906185462;
  v5[171] = 1090812512;
  v5[172] = -547295293;
  v5[173] = -1469587627;
  v5[174] = 829329135;
  v5[175] = 1181335161;
  v5[176] = -882789492;
  v5[177] = -1134132454;
  v5[178] = 628085408;
  v5[179] = 1382605366;
  v5[180] = -871598187;
  v5[181] = -1156888829;
  v5[182] = 570562233;
  v5[183] = 1426400815;
  v5[184] = -977650754;
  v5[185] = -1296233688;
  v5[186] = 733239954;
  v5[187] = 1555261956;
  v5[188] = -1026031705;
  v5[189] = -1244606671;
  v5[190] = 752459403;
  v5[191] = 1541320221;
  v5[192] = -1687895376;
  v5[193] = -328994266;
  v5[194] = 1969922972;
  v5[195] = 40735498;
  v5[196] = -1677130071;
  v5[197] = -351390145;
  v5[198] = 1913087877;
  v5[199] = 83908371;
  v5[200] = -1782625662;
  v5[201] = -491226604;
  v5[202] = 2075208622;
  v5[203] = 213261112;
  v5[204] = -1831694693;
  v5[205] = -438977011;
  v5[206] = 2094854071;
  v5[207] = 198958881;
  v5[208] = -2032938284;
  v5[209] = -237706686;
  v5[210] = 1759359992;
  v5[211] = 534414190;
  v5[212] = -2118248755;
  v5[213] = -155638181;
  v5[214] = 1873836001;
  v5[215] = 414664567;
  v5[216] = -2012718362;
  v5[217] = -15766928;
  v5[218] = 1711684554;
  v5[219] = 285281116;
  v5[220] = -1889165569;
  v5[221] = -127750551;
  v5[222] = 1634467795;
  v5[223] = 376229701;
  v5[224] = -1609899400;
  v5[225] = -686959890;
  v5[226] = 1308918612;
  v5[227] = 956543938;
  v5[228] = -1486412191;
  v5[229] = -799009033;
  v5[230] = 1231636301;
  v5[231] = 1047427035;
  v5[232] = -1362007478;
  v5[233] = -640263460;
  v5[234] = 1088359270;
  v5[235] = 936918000;
  v5[236] = -1447252397;
  v5[237] = -558129467;
  v5[238] = 1202900863;
  v5[239] = 817233897;
  v5[240] = -1111625188;
  v5[241] = -893730166;
  v2 = buffer;
  v3 = -1;
  v5[242] = 1404277552;
  v5[243] = 615818150;
  v5[244] = -1160759803;
  v5[245] = -841546093;
  v5[246] = 1423857449;
  v5[247] = 601450431;
  v5[248] = -1285129682;
  v5[249] = -1000256840;
  v5[250] = 1567103746;
  v5[251] = 711928724;
  v5[252] = -1274298825;
  v5[253] = -1022587231;
  v5[254] = 1510334235;
  for ( v5[255] = 0x2D02EF8D; v2 < &buffer[fileSize]; ++v2 )
    v3 = v5[(unsigned __int8)*v2 ^ (unsigned __int8)v3] ^ (v3 >> 8) & 0xFFFFFF;
  return ~v3;
}

//----- (00408270) --------------------------------------------------------
void __cdecl RewriteSameFileSomething(char *destination, const char *source)
{
  FILE *v2; // esi
  FILE *v3; // edi
  int v4; // eax
  char DstBuf[2048]; // [esp+8h] [ebp-800h] BYREF

  v2 = fopen(source, "rb");
  if ( v2 )
  {
    v3 = fopen(source, "wb");
    if ( v3 )
    {
      while ( (v2->_flag & 0x10) == 0 )
      {
        v4 = fread(DstBuf, 1u, 2048u, v2);
        if ( v4 > 0 )
          fwrite(DstBuf, 1u, v4, v3);
      }
      fclose(v3);
    }
    fclose(v2);
  }
}

//----- (00408310) --------------------------------------------------------
// returns ptr to alloced space, with a preceding dword with the allocced size
// 
// uses virtualalloc if sz is >= half a meg
// 
// ex:
// emalloc(DWORD sz)
//    DWORD *buf = malloc(sz + 4);
//    buf[0] = sz + 4;
//    return &buf[1];
// 
void *__cdecl emalloc(int bytes)
{
  _DWORD *v1; // eax
  void *v2; // esi
  char Dest[256]; // [esp+8h] [ebp-100h] BYREF

  if ( bytes + 4 <= 0x80000 )
    v1 = malloc(bytes + 4);
  else
    v1 = VirtualAlloc(0, bytes + 4, 0x1000u, 4u);
  if ( v1 )
  {
    *v1 = bytes + 4;
    v2 = v1 + 1;
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
  {
    sprintf(Dest, "Out of memory (Alloc:%d)", bytes);
    MessageBoxA(0, Dest, "Error", 0x30u);
    exit(1);
  }
  return v2;
}

//----- (004083A0) --------------------------------------------------------
char *__cdecl ExpandMemory(void *lpAddress, int NewSize, int MaxSize)
{
  int HowMuchBiggerr; // ecx
  int NewSizee; // edi
  char *v5; // eax
  char *v6; // esi
  char *result; // eax
  char *v8; // eax
  int v9; // esi
  signed int v10; // edi
  char *v11; // eax
  char *v12; // eax
  char *v13; // ebp
  unsigned int v14; // ecx
  int *Memory; // [esp+10h] [ebp-104h]
  char Text[256]; // [esp+14h] [ebp-100h] BYREF

  HowMuchBiggerr = MaxSize;
  if ( NewSize > 0x80000 )
    HowMuchBiggerr = 16 * MaxSize;
  NewSizee = HowMuchBiggerr * ((HowMuchBiggerr + NewSize - 1) / HowMuchBiggerr);
  if ( lpAddress )
  {
    if ( NewSizee )
    {
      v9 = *((_DWORD *)lpAddress - 1);          // Okay minus 4 bytes from beginning of pointed data is size? (must be a special structure of some kind)
      v10 = NewSizee + 4;
      Memory = (int *)((char *)lpAddress - 4);
      if ( v10 == v9 )                          // Check if special attribute (Size?) exists and equals the New Size so it can ignore it.
      {
        result = (char *)lpAddress;
      }
      else if ( v9 > 0x80000 || v10 > 0x80000 )
      {
        if ( v10 <= 0x80000 )
          v12 = (char *)malloc(v10);
        else
          v12 = (char *)VirtualAlloc(0, v10, 0x1000u, 4u);
        if ( v12 )
        {
          *(_DWORD *)v12 = v10;
          v13 = v12 + 4;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
        {
          sprintf(Text, "Out of memory (Alloc:%d)", v10 - 4);
          MessageBoxA(0, Text, "Error", 0x30u);
          exit(1);
        }
        v14 = v9 - 4;
        if ( v9 - 4 >= v10 - 4 )
          v14 = v10 - 4;
        qmemcpy(v13, lpAddress, v14);
        if ( *Memory <= 0x80000 )
          free(Memory);
        else
          VirtualFree(Memory, 0, 0x8000u);
        result = v13;
      }
      else
      {
        v11 = (char *)realloc((char *)lpAddress - 4, v10);
        if ( !v11 )
        {
          MessageBoxA(0, "Out of memory (Resize)", "Error", 0x30u);
          exit(1);
        }
        *(_DWORD *)v11 = v10;
        result = v11 + 4;
      }
    }
    else
    {
      v8 = (char *)lpAddress - 4;
      if ( *((int *)lpAddress - 1) <= 0x80000 )
        free(v8);
      else
        VirtualFree(v8, 0, 0x8000u);
      result = 0;
    }
  }
  else
  {
    if ( NewSizee + 4 <= 0x80000 )
      v5 = (char *)malloc(NewSizee + 4);
    else
      v5 = (char *)VirtualAlloc(0, NewSizee + 4, 0x1000u, 4u);
    if ( v5 )
    {
      *(_DWORD *)v5 = NewSizee + 4;
      v6 = v5 + 4;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
    {
      sprintf(Text, "Out of memory (Alloc:%d)", NewSizee);
      MessageBoxA(0, Text, "Error", 0x30u);
      exit(1);
    }
    result = v6;
  }
  return result;
}

//----- (004085C0) --------------------------------------------------------
// see emalloc()
void __stdcall efree(LPVOID ptr)
{
  if ( *((int *)ptr - 1) <= 0x80000 )
    free((char *)ptr - 4);
  else
    VirtualFree((char *)ptr - 4, 0, 0x8000u);
}
// 4085C0: inconsistent function type and number of purged bytes

//----- (004085F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall __noreturn ConnectSocket(SOCKET *Socket, const char *Hostname, u_short ConnectPort, u_short ListenPort)
{
  SOCKET v5; // eax
  u_long v6; // eax
  SOCKET v7; // ecx
  unsigned __int32 v8; // edi
  struct hostent *v9; // eax
  DWORD v10; // kr00_4
  SOCKET v11; // eax
  SOCKET v12; // [esp-14h] [ebp-48h]
  SOCKET v13; // [esp-14h] [ebp-48h]
  SOCKET v14; // [esp-14h] [ebp-48h]
  char optval[4]; // [esp+Ch] [ebp-28h] BYREF
  u_long argp; // [esp+10h] [ebp-24h] BYREF
  struct sockaddr name; // [esp+14h] [ebp-20h] BYREF
  struct sockaddr v18; // [esp+24h] [ebp-10h] BYREF

  v5 = SOCKET(2, 2, 0);
  *Socket = v5;
  argp = 1;
  ioctlsocket(v5, 0x8004667E, &argp);           // #define FIONBIO 0x8004667e
  v12 = *Socket;
  *(_DWORD *)optval = -1;
  setsockopt(v12, 6, 1, optval, 4);
  v13 = *Socket;
  *(_DWORD *)optval = 1024;
  setsockopt(v13, 0xFFFF, 4097, optval, 4);
  v14 = *Socket;
  *(_DWORD *)optval = 1024;
  setsockopt(v14, 0xFFFF, 4098, optval, 4);
  name.sa_family = SOCK_DGRAM;
  *(_WORD *)name.sa_data = htons(ListenPort);
  v6 = htonl(0);
  v7 = *Socket;
  *(_DWORD *)&name.sa_data[2] = v6;
  bind(v7, &name, 16);
  v8 = inet_addr(Hostname);
  if ( v8 == -1 )
  {
    v9 = gethostbyname(Hostname);
    if ( v9 )
      v8 = **(_DWORD **)v9->h_addr_list;
  }
  v18.sa_family = 2;
  *(_DWORD *)&v18.sa_data[2] = v8;
  *(_WORD *)v18.sa_data = htons(ConnectPort);
  connect(*Socket, &v18, 16);
  Socket[1] = -1;
  Socket[2] = -1;
  v10 = GetTickCount();
  v11 = *Socket;
  *(_DWORD *)&ListenPort = v10 / 0xA;
  send(v11, (const char *)&ListenPort, 4, 0);
}
// 408716: inconsistent variable size for '^54.2(ListenPort)'

//----- (00408740) --------------------------------------------------------
void __thiscall CloseSocketWrapper(struct SOCKET *socket)
{
  closesocket(*(_DWORD *)socket);
}

//----- (00408750) --------------------------------------------------------
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3)
{
  char v4[4]; // [esp+Ch] [ebp-404h] BYREF
  char buf[1024]; // [esp+10h] [ebp-400h] BYREF

  if ( a2 && (int)a3 > 0 )
  {
    *(_DWORD *)buf = 0;                         // //Setting the 4 first bytes to 0. Certainly the message header !
    qmemcpy(&buf[4], a2, a3);
    send(*(_DWORD *)this, buf, a3 + 4, 0);
  }
  else
  {
    *(_DWORD *)v4 = GetTickCount() / 0xA;       // This just sends 4 bytes which is just the GetTickCount/10, It's called Directory Server Ping
    send(*(_DWORD *)this, v4, 4, 0);
  }
}
/* Orphan comments:
Looks like Copy by DWORDs, not by Bytes.
This else statement lets the Directory Server know your zone is still up. Keep-Alive packet.
*/

//----- (004087D0) --------------------------------------------------------
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed)
{
  int sizeRecieved; // esi
  _DWORD buf[128]; // [esp+Ch] [ebp-200h] BYREF

  do
  {
    if ( recv(*(_DWORD *)Socket, (char *)buf, 512, 2) == -1 )
      break;
    sizeRecieved = recv(*(_DWORD *)Socket, (char *)buf, 512, 0);
    if ( sizeRecieved == 8 )
    {
      *(_DWORD *)(Socket + 4) = buf[0];
      *(_DWORD *)(Socket + 8) = GetTickCount() / 0xA - buf[1];
    }
  }
  while ( sizeRecieved != -1 );
  *TimeElapsed = *(_DWORD *)(Socket + 8);
  return *(_DWORD *)(Socket + 4);
}

//----- (00408860) --------------------------------------------------------
// PINGSOCKET.PingSocket()
SOCKET __thiscall ListenOnPort(SOCKET sock, __int16 port, int callback)
{
  SOCKET sockkRet; // eax
  u_long v5; // eax
  SOCKET v6; // ecx
  SOCKET v8; // [esp-14h] [ebp-2Ch]
  SOCKET v9; // [esp-14h] [ebp-2Ch]
  SOCKET v10; // [esp-14h] [ebp-2Ch]
  u_long argp; // [esp+4h] [ebp-14h] BYREF
  struct sockaddr name; // [esp+8h] [ebp-10h] BYREF

  *(_DWORD *)(sock + 4) = callback;
  sockkRet = SOCKET(2, 2, 0);
  *(_DWORD *)sock = sockkRet;
  argp = 1;
  ioctlsocket(sockkRet, 0x8004667E, &argp);     // FIONBIO
  v8 = *(_DWORD *)sock;
  callback = -1;
  setsockopt(v8, 6, IP_OPTIONS, (const char *)&callback, 4);
  v9 = *(_DWORD *)sock;
  callback = 0x2000;
  setsockopt(v9, 0xFFFF, 4097, (const char *)&callback, 4);
  v10 = *(_DWORD *)sock;
  callback = 0x2000;
  setsockopt(v10, 0xFFFF, 4098, (const char *)&callback, 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = htons(port);
  v5 = htonl(0);
  v6 = *(_DWORD *)sock;
  *(_DWORD *)&name.sa_data[2] = v5;
  bind(v6, &name, 16);
  return sock;
}

//----- (00408930) --------------------------------------------------------
void __thiscall ProcessZonePings(int Socket, int ZonePopulation)
{
  int i; // ebp
  unsigned int v4; // eax
  void (__cdecl *v5)(ULONG, _DWORD *, unsigned int); // ecx
  SOCKET v6; // eax
  SOCKET v7; // [esp-18h] [ebp-244h]
  int fromlen; // [esp+10h] [ebp-21Ch] BYREF
  _DWORD OutBuffer[2]; // [esp+14h] [ebp-218h] BYREF
  struct sockaddr_in from; // [esp+1Ch] [ebp-210h] BYREF
  _DWORD buf[128]; // [esp+2Ch] [ebp-200h] BYREF

  for ( i = 0; i < 20; ++i )
  {
    v7 = *(_DWORD *)Socket;
    fromlen = 16;
    v4 = recvfrom(v7, (char *)buf, 512, 0, (struct sockaddr *)&from, &fromlen);
    if ( v4 == -1 )
      break;
    if ( v4 >= 4 )
    {
      if ( buf[0] )
      {
        v6 = *(_DWORD *)Socket;
        OutBuffer[1] = buf[0];
        OutBuffer[0] = ZonePopulation;
        sendto(v6, (const char *)OutBuffer, 8, 0, (const struct sockaddr *)&from, 16);
      }
      else
      {
        v5 = *(void (__cdecl **)(ULONG, _DWORD *, unsigned int))(Socket + 4);
        if ( v5 )
        {
          if ( v4 > 4 )
            v5(from.sin_addr.S_un.S_addr, &buf[1], v4 - 4);
        }
      }
    }
  }
}

//----- (004089E0) --------------------------------------------------------
// Player.Player()
PLAYER *__thiscall CreateNewPlayer(PLAYER *player, struct in_addr IPAddress, __int16 a3, NetData *encryption)
{
  CONNECTION *encryptionPointer; // edx
  int v6; // eax

  player->ProcessInformation = 0;
  player->dword4 = 0;
  player->dword8 = 0;
  player->dwordC = 0;
  memset(player->someStringBuffer, 0, sizeof(player->someStringBuffer));
  player->TypedName[0] = 0;
  player->DemoPlayer = 0;
  player->KingCrownKills = 0;
  player->KotHDeathCount = 0;
  player->MyArenaScoreIndex = -1;
  player->IsEnergyShowing = 0;
  player->field_60 = -1;
  player->field_5C = -1;
  player->field_58 = -1;
  player->IsSilenced = 0;
  player->field_15B = 0;
  player->field_50 = -1;
  player->field_54 = -1;
  player->CurrentSecurityPacketModifcationCount = 0;
  player->field_A8 = 0;
  player->DeathsWithoutFiring = 0;
  player->field_3C = 0;
  player->field_4C = -1;
  player->field_153 = 0;
  player->BillerPlayerId = LastBillerPlayerId++;
  player->field_305 = 0;
  player->SlowModem = 0;
  player->AlreadySentReliablePacket = 0;
  player->KickOffDelayTimer = 0;
  player->SendWeaponUpdatePacket = 0;
  player->connection = (CONNECTION *)encryption;
  player->MyArena = 0;
  player->MyLastArena = 0;
  memset(player->VoiceUploads, 0, sizeof(player->VoiceUploads));
  player->PlayerName[0] = 0;
  player->SecurityWeaponCountyTotalNew = 0;
  memset(&player->SecurityPacketCache, 0, sizeof(player->SecurityPacketCache));
  player->S2CPacketLossPercentage = 1000;
  player->C2SPacketLossPercentage = 1000;
  player->field_283 = 0;
  player->IPAddressDWORD = (struct in_addr *)IPAddress.S_un.S_addr;
  player->Port = a3;
  player->pfile329 = 0;
  player->char32d = 0;
  *(_DWORD *)&player->Frequency = -1;
  player->IsSysop = 0;
  player->IsModerator = 0;
  player->IsSuperModerator = 0;
  *(_DWORD *)&player->AttachedToPlayerId = -1;
  memset(&player->PlayerDataBillerPacket, 0, sizeof(player->PlayerDataBillerPacket));// Struct = Name, Squad, BannerData, Usage,AccountCreated, UserId,Extra1,Extra2
  player->PlayerDataBillerPacket.UserId = -1;
  *(_DWORD *)&player->CurrentWins = 0;
  *(_DWORD *)&player->CurrentGoals = 0;
  *(int *)((char *)&player->KillPoints + 2) = 0;
  HIWORD(player->FlagPoints) = 0;
  *(_DWORD *)&player->PersonalBestWins = 0;
  *(_DWORD *)&player->PersonalBestGoalCount = 0;
  *(int *)((char *)&player->PersonalBestKillPoints + 2) = 0;
  HIWORD(player->PersonalBestFlagPoints) = 0;
  player->ArenaPlayerIndex = -1;
  encryptionPointer = player->connection;
  *(_DWORD *)&player->Ship = 8;
  player->IsSpeced = 0;
  player->TotalShipChanges = 0;
  player->ForceWearBanner = 0;
  v6 = encryptionPointer->PlayerId;
  *(_DWORD *)&player->PlayerId = v6;
  ZonePlayerList[v6] = player;
  player->NoPasswordPacketDelayTimer = GetTickCount() / 0xA;
  player->UsageSessionSeconds = time(0);
  player->CurrentSuicideCount = 0;
  player->field_287 = 0;
  player->field_28B = 0;
  player->field_29F = 0;
  player->LastMessageSpamResetCheckTime = GetTickCount() / 0xA;
  player->MessageSpamTotal = 0;
  player->field_29B = 0;
  player->field_29F = 0;
  player->LastSecurityPacketReturnedTime = 0;
  player->C2SCurrentFast = 0;
  player->C2SCurrentSlow = 0;
  player->C2SCurrentTotalFast = 0;
  player->C2SCurrentTotalSlow = 0;
  player->DisconnectReason = 0;
  player->C2SAverageLatencyFirst = 0;
  player->C2SAverageLatencySecond = 0;
  player->ScoreReset = 0;
  player->LatencyKickOutDelayTimer = 0;
  player->field_309 = 1;
  return player;
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 42A534: using guessed type int LastBillerPlayerId;

//----- (00408C30) --------------------------------------------------------
void __thiscall DisconnectUser(PLAYER *player)
{
  char *v2; // esi
  char *v3; // ebp
  int v4; // ecx
  int v5; // ebp
  char i; // al
  ARENA *v7; // ecx
  CONNECTION *v8; // ecx
  VOICE_UPLOAD_STRUCT *v9; // esi
  int v10; // ebp
  BOOL v11; // eax
  int Ping; // [esp+10h] [ebp-B0h] BYREF
  int Latency; // [esp+14h] [ebp-ACh] BYREF
  int MiscTimedGame; // [esp+18h] [ebp-A8h]
  char buffer[33]; // [esp+1Ch] [ebp-A4h] BYREF
  char Str[128]; // [esp+40h] [ebp-80h] BYREF

  if ( player->ProcessInformation )
  {
    TerminateProcess(player->ProcessInformation, 0);
    CloseHandle(player->ProcessInformation);
  }
  if ( player->pfile329 )
  {
    fclose(player->pfile329);
    player->pfile329 = 0;
  }
  if ( AutoPermissionPoints > 0 && player->FlagPoints + player->KillPoints >= AutoPermissionPoints )
  {
    v2 = PermissionAutoPermissionIDList;
    while ( *v2 )
    {
      v3 = Str;
      if ( isdigit(*v2) )
      {
        do
        {
          v4 = v2[1];
          *v3++ = *v2++;
        }
        while ( isdigit(v4) );
      }
      *v3 = 0;
      v5 = atoi(Str);
      if ( v5 && BillingConnectionStructPointer )
      {
        buffer[0] = 1;
        strncpy(&buffer[1], player->PlayerDataBillerPacket.Name, 0x20u);
        buffer[32] = 0;
        SendBillerPlayerNamePacketSomething(BillingConnectionStructPointer, -1, v5, buffer, 0x21u);
      }
      for ( i = *v2; i; i = *++v2 )
      {
        if ( isdigit(i) )
          break;
      }
    }
  }
  v7 = player->MyArena;
  MiscTimedGame = 0;
  if ( v7 )
  {
    MiscTimedGame = v7->ServersideArenaSettings.MiscTimedGame;
    ArenaRemovePlayer(v7, player);
    player->MyArena = 0;
  }
  GetPingLOSSSomething(player->connection, &Latency, &Ping);
  v8 = player->connection;
  Latency = 1000 - Latency;
  Ping = 1000 - Ping;
  sub_41B7A0(v8);
  v9 = player->VoiceUploads;
  v10 = 4;
  ZonePlayerList[*(_DWORD *)&player->PlayerId] = 0;
  do
  {
    if ( v9->VoiceMemoryPointer )
    {
      efree(v9->VoiceMemoryPointer);
      v9->VoiceMemoryPointer = 0;
    }
    ++v9;
    --v10;
  }
  while ( v10 );
  if ( BillingConnectionStructPointer )
  {
    v11 = player->DemoPlayer != 0;
    if ( MiscTimedGame
      || player->FlagPoints
       + player->KillPoints
       + (unsigned __int16)player->CurrentWins
       + (unsigned __int16)player->CurrentLosses <= 5
      && !player->ScoreReset )
    {
      v11 = 1;
    }
    if ( v11 )
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        player->BillerPlayerId,
        player->DisconnectReason,
        Latency,
        Ping,
        10 * player->SecurityPacketCache.CurrentPing,
        10 * player->C2SAverageLatencyFirst / (player->C2SAverageLatencySecond + 1),
        0,
        0);
    else
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        player->BillerPlayerId,
        player->DisconnectReason,               // TODO: This might be WORD not DWORD
        Latency,
        Ping,
        10 * player->SecurityPacketCache.CurrentPing,
        10 * player->C2SAverageLatencyFirst / (player->C2SAverageLatencySecond + 1),
        &player->CurrentWins,
        0xEu);
  }
}
// 4AF32C: using guessed type int AutoPermissionPoints;

//----- (00408E80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __thiscall PlayerHandleGamePacket(struct PLAYER *playerr, unsigned __int8 *packet, int packetSize)
{
  int packett; // ebx
  int PacketType; // ecx
  ARENA *arena; // ecx
  int PowerBallIndex; // esi
  ARENA *v8; // eax
  SOCCER_BALL *v9; // eax
  struct ARENA *v10; // ebp
  int v11; // eax
  ARENA *v12; // esi
  ARENA *v13; // eax
  int v14; // edx
  int v15; // ecx
  PLAYER **v16; // eax
  int v17; // esi
  int v18; // esi
  ARENA *v19; // eax
  PLAYER **v20; // ecx
  PLAYER *v21; // ebx
  struct PLAYER *v22; // ebx
  unsigned int v23; // kr08_4
  unsigned int v24; // kr14_4
  bool v25; // cc
  ARENA *v26; // ecx
  __int16 v27; // ax
  struct ARENA *v28; // ecx
  ARENA *v29; // ecx
  struct ARENA *v30; // ebp
  int v31; // eax
  ARENA *v32; // esi
  int v33; // edx
  int v34; // ecx
  int v35; // eax
  struct ARENA *v36; // ebp
  int v37; // eax
  ARENA *v38; // ecx
  int v39; // eax
  unsigned int v40; // esi
  CHAR *v41; // esi
  unsigned int v42; // kr20_4
  CHAR v43; // al
  __int16 v44; // ax
  __int16 v45; // bx
  ARENA *v46; // eax
  DWORD v47; // eax
  int v48; // ecx
  ARENA_SETTINGS *v49; // eax
  int v50; // edx
  int v51; // edx
  ARENA *v52; // edx
  int v53; // ecx
  int v54; // eax
  int v55; // esi
  char *v56; // eax
  int v57; // edx
  int v58; // eax
  int v59; // eax
  int v60; // esi
  ARENA *v61; // ecx
  unsigned int v62; // kr30_4
  ARENA *v63; // eax
  char *v64; // eax
  int v65; // edx
  int v66; // eax
  char *v67; // ecx
  int v68; // eax
  char *v69; // ecx
  char v70; // dl
  char v71; // al
  _BYTE *v72; // ecx
  int v73; // esi
  int v74; // esi
  int v75; // esi
  CONNECTION *v76; // edi
  int v77; // edx
  int v78; // esi
  ARENA *v79; // ecx
  unsigned int v80; // kr38_4
  __int16 v81; // cx
  __int64 v82; // rax
  __int64 v83; // rax
  int v84; // eax
  int v85; // edx
  int v86; // eax
  PLAYER *v87; // eax
  __int16 v88; // ax
  __int16 v89; // dx
  int v90; // eax
  PLAYER *v91; // eax
  int v92; // eax
  __int16 v93; // ax
  struct ARENA *v94; // ecx
  ARENA *v95; // edx
  __int16 v96; // ax
  PLAYER *v97; // esi
  ARENA *v98; // ecx
  __int16 v99; // ax
  ARENA *v100; // ecx
  int v101; // eax
  __int16 v102; // ax
  struct ARENA *v103; // ecx
  ARENA *v104; // ecx
  int v105; // eax
  int v106; // eax
  int v107; // eax
  struct ARENA *v108; // ecx
  ARENA *v109; // eax
  ARENA *v110; // eax
  int v111; // eax
  int v112; // edx
  ARENA *v113; // eax
  int v114; // ecx
  __int16 v115; // cx
  ARENA *v116; // ecx
  ARENA *v117; // eax
  int v118; // eax
  ARENA *v119; // edi
  int *v120; // edx
  int v121; // eax
  __int16 v122; // ax
  ARENA *v123; // ecx
  int v124; // eax
  int v125; // ebx
  ARENA *v126; // ecx
  int v127; // edi
  ARENA *v128; // ecx
  int v129; // edi
  int v130; // eax
  int v131; // edi
  int v132; // edx
  int v133; // eax
  int v134; // edi
  int v135; // eax
  int v136; // edx
  int *v137; // ecx
  int v138; // ebx
  char *v139; // eax
  int v140; // eax
  unsigned int v141; // ebx
  int v142; // eax
  int v143; // eax
  ARENA *v144; // eax
  int v145; // edx
  int v146; // ecx
  PLAYER *v147; // esi
  int v148; // eax
  int v149; // edi
  int v150; // ebx
  int v151; // edi
  unsigned int v152; // kr40_4
  struct PLAYER *v153; // edi
  ARENA *v154; // ecx
  __int16 v155; // bx
  int v156; // esi
  ARENA *v157; // edi
  __int16 v158; // ax
  __int16 v159; // dx
  ARENA *v160; // ecx
  int v161; // esi
  ARENA *v162; // eax
  int v163; // edi
  int v164; // eax
  int v165; // ecx
  int v166; // edx
  int v167; // ecx
  int v168; // ecx
  int v169; // ebx
  struct PLAYER *v170; // ecx
  PLAYER *v171; // esi
  int v172; // edx
  int v173; // edx
  int v174; // eax
  int v175; // esi
  int v176; // edx
  signed int v177; // edi
  __int64 v178; // rax
  __int64 v179; // rax
  int v180; // edx
  int v181; // eax
  ARENA *v182; // eax
  __int16 v183; // ax
  __int16 v184; // ax
  int v185; // esi
  CONNECTION *v186; // edi
  int v187; // edx
  ARENA *v188; // eax
  __int16 v189; // dx
  __int16 v190; // cx
  int v191; // edx
  __int16 v192; // cx
  int v193; // ebx
  int v194; // edi
  int v195; // esi
  struct PLAYER *v196; // eax
  ARENA *v197; // eax
  ARENA *v198; // esi
  __int64 v199; // rax
  __int16 v200; // ax
  int v201; // ecx
  int v202; // edx
  int v203; // edi
  int *v204; // eax
  __int16 v205; // ax
  ARENA *v206; // eax
  ARENA *v207; // eax
  int v208; // ecx
  int v209; // ecx
  char v210; // al
  ARENA *v211; // eax
  __int16 v212; // cx
  int v213; // edi
  int v214; // esi
  struct PLAYER *v215; // eax
  ARENA *v216; // ecx
  __int16 v217; // ax
  ARENA *v218; // ecx
  int v219; // eax
  __int16 v220; // bx
  int v221; // esi
  PLAYER *v222; // eax
  struct PLAYER *v223; // ecx
  int v224; // ebp
  struct PLAYER *v225; // ecx
  ARENA *v226; // eax
  struct ARENA *v227; // ecx
  VOICE_UPLOAD_STRUCT *v228; // ebp
  int v229; // esi
  ARENA *v230; // eax
  __int16 v231; // dx
  char v232; // al
  __int16 v233; // bx
  int v234; // ebx
  char *v235; // eax
  __int16 v236; // dx
  ARENA *v237; // eax
  char v238; // al
  struct ARENA *v239; // ecx
  ARENA *MyArena; // eax
  ARENA *v241; // eax
  int v242; // eax
  unsigned int v243; // kr60_4
  char *v244; // edx
  int v245; // eax
  PLAYER *v246; // eax
  unsigned int v247; // kr6C_4
  char *v248; // edx
  const char *v249; // edi
  unsigned int v250; // kr78_4
  BOOL v251; // esi
  const char *v252; // edi
  FILE *v253; // eax
  FILE *v254; // esi
  unsigned int v255; // kr88_4
  unsigned int v256; // kr90_4
  __int16 v257; // ax
  PLAYER *v258; // eax
  __int16 v259; // dx
  int v260; // eax
  int v261; // ecx
  ARENA *v262; // eax
  int v263; // edi
  int v264; // esi
  struct PLAYER *v265; // eax
  ARENA *v266; // eax
  int v267; // ecx
  char *v268; // ebx
  int v269; // edi
  char *v270; // esi
  int v271; // ecx
  char v272; // al
  int v273; // eax
  char *v274; // eax
  int v275; // eax
  KICK *v276; // ecx
  int v277; // edx
  int v278; // esi
  PLAYER **v279; // eax
  int v280; // ecx
  int v281; // ebx
  PLAYER **v282; // eax
  PLAYER *v283; // eax
  unsigned int v284; // krA0_4
  BILLING_SERVER_STRUCT *v285; // ecx
  int v286; // ecx
  int v287; // eax
  char *v288; // ecx
  int v289; // eax
  ARENA *v290; // eax
  __int64 v291; // rax
  const char *v292; // [esp-Ah] [ebp-6FEh]
  struct PLAYER *v293; // [esp-6h] [ebp-6FAh]
  const char *v294; // [esp-6h] [ebp-6FAh]
  const char *v295; // [esp-2h] [ebp-6F6h]
  const char *v296; // [esp+Eh] [ebp-6E6h] BYREF
  __int64 buffer2_2; // [esp+12h] [ebp-6E2h] BYREF
  int PacketTypee_6; // [esp+1Ah] [ebp-6DAh]
  int PacketTypee_10; // [esp+1Eh] [ebp-6D6h]
  PLAYER *PacketTypee_14; // [esp+22h] [ebp-6D2h]
  __int16 PacketTypee_18; // [esp+26h] [ebp-6CEh] BYREF
  int PacketTypee_20; // [esp+28h] [ebp-6CCh]
  int PacketTypee_24; // [esp+2Ch] [ebp-6C8h]
  __int64 v304; // [esp+30h] [ebp-6C4h]
  char v305; // [esp+38h] [ebp-6BCh]
  char v306; // [esp+39h] [ebp-6BBh]
  int v307; // [esp+3Ah] [ebp-6BAh]
  int v308; // [esp+3Eh] [ebp-6B6h]
  char buffer[32]; // [esp+48h] [ebp-6ACh] BYREF
  char buffer_28[36]; // [esp+68h] [ebp-68Ch] BYREF
  char v311; // [esp+8Eh] [ebp-666h] BYREF
  char v312; // [esp+8Fh] [ebp-665h]
  char a3; // [esp+90h] [ebp-664h] BYREF
  __int16 a3_1; // [esp+91h] [ebp-663h]
  char a3_3[505]; // [esp+93h] [ebp-661h] BYREF
  char a1[256]; // [esp+28Ch] [ebp-468h] BYREF
  char a1_252[99]; // [esp+38Ch] [ebp-368h] BYREF
  char Dest[256]; // [esp+3F0h] [ebp-304h] BYREF
  _BYTE Dest_254[3]; // [esp+4F2h] [ebp-202h] BYREF
  __int16 buf_1; // [esp+4F5h] [ebp-1FFh]
  char buf_3; // [esp+4F7h] [ebp-1FDh] BYREF
  void *retaddr; // [esp+6F4h] [ebp+0h] OVERLAPPED

  packett = *(int *)((char *)&retaddr + 2);
  PacketType = **(char **)((char *)&retaddr + 2);
  LODWORD(buffer2_2) = PacketType;
  switch ( PacketType )
  {
    case 1:                                     // 0x01 - Arena login
      if ( playerr->PlayerDataBillerPacket.Name[0] )
      {
        if ( playerr->IsSuperModerator || GetProtocolVersion(playerr->connection) == 1 )
        {
          v238 = (*(_BYTE **)((char *)&retaddr + 2))[1];
          if ( v238 > 8 || v238 < 0 )
          {
            if ( !playerr->IsSuperModerator )
            {
              sprintf(&a1[2], "Packet tampering(%d)", **(char **)((char *)&retaddr + 2));
              SendBillerWarnings(&a1[2], playerr);
              v241 = playerr->MyArena;
              if ( v241 )
              {
                if ( v241->ServersideArenaSettings.dwordB4 )
                {
                  playerr->DisconnectReason = 0x10;// 0x10 - Restricted Zone - Compare against local Subspace.exe to determine if an Update is needed.
                  playerr->AlreadySentReliablePacket = 1;
                }
              }
            }
          }
          else
          {
            v239 = playerr->MyArena;
            if ( v239 )
            {
              ArenaRemovePlayer(v239, playerr);
              playerr->MyArena = 0;
            }
            playerr->ArenaPlayerIndex = -1;
            *(_DWORD *)&playerr->Ship = (*(char **)((char *)&retaddr + 2))[1];
            *(_DWORD *)&playerr->AllowAudioByte = (*(char **)((char *)&retaddr + 2))[2];
            playerr->XResolution = (*(__int16 **)((char *)&retaddr + 2))[2];
            playerr->YResolution = (*(__int16 **)((char *)&retaddr + 2))[3];
            playerr->AllowAudioByte2 = (*(char **)((char *)&retaddr + 2))[3];
            if ( playerr->IsSpeced )
              *(_DWORD *)&playerr->Ship = 8;
            playerr->field_309 = 1;
            *(_WORD *)((char *)&v296 + 1) = playerr->PlayerId;// New PlayerId
            LOBYTE(v296) = 1;                   // 0x01 - PlayerID Change
            SendPlayerReliablePacket(playerr, &v296, 3u, 1);
            MyArena = ArenaHandler(
                        playerr,
                        (*(__int16 **)((char *)&retaddr + 2))[4],
                        *(const char **)((char *)&retaddr + 2) + 10);
            playerr->MyArena = MyArena;
            playerr->MyLastArena = (int)MyArena;
            PlayerEntering(MyArena, playerr);
          }
        }
        else
        {
          SendBillerWarnings("Incompatible network protocol attempting to enter game", playerr);
          playerr->AlreadySentReliablePacket = 1;
        }
      }
      return;
    case 2:                                     // 0x02 - Leave arena
      v227 = playerr->MyArena;
      if ( v227 )
      {
        ArenaRemovePlayer(v227, playerr);
        playerr->MyArena = 0;                   // Reset your arena pointer
      }
      printf("Player leaving game: %s\n", playerr->PlayerDataBillerPacket.Name);
      v228 = playerr->VoiceUploads;
      v229 = 4;
      do
      {
        if ( v228->VoiceMemoryPointer )
        {
          efree(v228->VoiceMemoryPointer);
          v228->VoiceMemoryPointer = 0;
        }
        ++v228;
        --v229;
      }
      while ( v229 );
      return;
    case 3:                                     // 0x03 - Position packet
      playerr->field_309 = 0;
      if ( !playerr->MyArena )
        return;
      v70 = (*(_BYTE **)((char *)&retaddr + 2))[10];// Checksum BYTE
      v71 = 0;
      (*(_BYTE **)((char *)&retaddr + 2))[10] = 0;
      v72 = *(void **)((char *)&retaddr + 2);
      v73 = 22;
      do
      {
        v71 ^= *v72++;
        --v73;
      }
      while ( v73 );
      if ( v71 != v70 )
      {
        if ( !playerr->IsSysop )
        {
          v74 = playerr->CurrentSecurityPacketModifcationCount + 1;
          playerr->CurrentSecurityPacketModifcationCount = v74;
          if ( v74 >= playerr->MyArena->ServersideArenaSettings.SecurityPacketModificationMax )
          {
            SendBillerWarnings("C2S position packet checksum error", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
        }
        return;
      }
      if ( ((*(_BYTE **)((char *)&retaddr + 2))[11] & 0x40) != 0 && !playerr->field_3C )// Togglables
        return;
      if ( (*(__int16 **)((char *)&retaddr + 2))[8] > 10000 && !playerr->IsSuperModerator && !playerr->field_305 )// Bounty
        goto LABEL_358;
      if ( ((*(_BYTE **)((char *)&retaddr + 2))[20] & 0x1F) != 0 )
        playerr->DeathsWithoutFiring = 0;
      v75 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 2);
      v76 = playerr->connection;
      v77 = ((v76->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v75;// Timestamp
      v78 = v77;
      PacketTypee_6 = v77;
      if ( v77 < 0 || v77 > 30000 )
      {
        v78 = 0;
        PacketTypee_6 = 0;
      }
      if ( v78 > playerr->MyArena->ServersideArenaSettings.LatencyMaxLatencyForWeapons )
        (*(_WORD **)((char *)&retaddr + 2))[10] &= 0x7F80u;// Weapon Info
      if ( v78 < playerr->MyArena->ServersideArenaSettings.LatencyMaxLatencyForKickOut || v78 > 800 || playerr->IsSysop )
        playerr->LatencyKickOutDelayTimer = GetTickCount() / 0xA;
      if ( v78 < playerr->MyArena->ServersideArenaSettings.LatencySlowPacketTime || v78 > 800 || playerr->IsSysop )
        ++playerr->C2SCurrentFast;
      else
        ++playerr->C2SCurrentSlow;
      if ( playerr->C2SCurrentSlow + playerr->C2SCurrentFast > playerr->MyArena->ServersideArenaSettings.LatencySlowPacketSampleSize )
      {
        playerr->C2SCurrentTotalFast += playerr->C2SCurrentFast;
        playerr->C2SCurrentTotalSlow += playerr->C2SCurrentSlow;
        if ( *(_DWORD *)&playerr->Ship != 8 )
        {
          v79 = playerr->MyArena;
          if ( 1000 * playerr->C2SCurrentSlow / (playerr->C2SCurrentSlow + playerr->C2SCurrentFast) > v79->ServersideArenaSettings.LatencySlowPacketKickoutPercent )
          {
            if ( v79 )
            {
              v311 = 7;                         // 0x07 - Chat
              v312 = 0;
              a3 = 0;
              a3_1 = -1;
              strcpy(a3_3, "You have been put in spectator mode due to high latency (C2S)");
              v80 = strlen("You have been put in spectator mode due to high latency (C2S)") + 1;
              if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                SendPlayerReliablePacket(playerr, &v311, v80 - 1 + 6, 1);
            }
            SetPlayerShip(playerr, 8);
            packett = *(int *)((char *)&retaddr + 2);
            v78 = PacketTypee_6;
          }
        }
        playerr->C2SCurrentFast = 0;
        playerr->C2SCurrentSlow = 0;
      }
      if ( v78 < 800 && v78 > 0 )
      {
        playerr->C2SAverageLatencyFirst += v78;
        ++playerr->C2SAverageLatencySecond;
      }
      v81 = *(_WORD *)(packett + 12);           // X Pixels (0 ... 16384)
      if ( v81 >= 0 && *(__int16 *)(packett + 8) >= 0 && *(_DWORD *)&playerr->Ship != 8 )// Y Pixels (0 ... 16384)
      {
        if ( playerr->MyArena->ServersideArenaSettings.PacketLossDisableWeapons && rand() % 1000 < playerr->field_153 )
          *(_WORD *)(packett + 20) &= 0x7F80u;
        v82 = *(__int16 *)(packett + 12) - playerr->XPixels;// X Pixels (0 ... 16384)
        if ( (int)((HIDWORD(v82) ^ v82) - HIDWORD(v82)) > 512
          || (v83 = *(__int16 *)(packett + 8) - playerr->YPixels,// Y Pixels (0 ... 16384)
              (int)((HIDWORD(v83) ^ v83) - HIDWORD(v83)) > 512) )
        {
          playerr->field_10F = 1;
        }
        if ( (*(_BYTE *)(packett + 11) & 0x20) != 0 && (playerr->ShipTogglables & 0x20) == 0 )// Togglables 
          playerr->field_10F = 1;
        qmemcpy(&playerr->PositionByteThree, *(void **)((char *)&retaddr + 2), 0x16u);
        if ( (playerr->WeaponsInfo & 0x1F) == 8 )
        {
          v84 = playerr->field_283;
          v85 = v84;
          if ( v84 >= 3 )
            v85 = 3;
          if ( v85 >= 0 )
          {
            if ( v84 >= 3 )
              LOBYTE(v84) = 3;
          }
          else
          {
            LOBYTE(v84) = 0;
          }
          playerr->WeaponsInfo = (32 * (v84 & 3)) | playerr->WeaponsInfo & 0xFF9F;
        }
        if ( *(unsigned int *)((char *)&packet + 2) > 0x16 )
        {
          *(_QWORD *)&playerr->EnergyOptional = *(_QWORD *)(*(char **)((char *)&retaddr + 2) + 22);// Energy (Optional)
          playerr->SharpnelMinesBombsBulletsMultifireInformationOptional = (*(_WORD **)((char *)&retaddr + 2))[15];
          playerr->field_10B = 1;
        }
        sub_40D870(playerr);
        playerr->SendWeaponUpdatePacket = 1;
        if ( (playerr->WeaponsInfo & 0x1F) != 0 )
          SendWeaponPacket(playerr);
        return;
      }
      v86 = playerr->ArenaPlayerIndex;
      if ( v86 < 0 )
      {
        if ( v81 < 0 || *(__int16 *)(packett + 8) < 0 )// X Pixel & Y Pixel Checks
        {
          v88 = playerr->XPixels;
          v89 = playerr->YPixels;
          qmemcpy(&playerr->PositionByteThree, *(void **)((char *)&retaddr + 2), 0x16u);
          playerr->XPixels = v88;
          playerr->YPixels = v89;
        }
        else
        {
          qmemcpy(&playerr->PositionByteThree, *(void **)((char *)&retaddr + 2), 0x16u);
        }
      }
      else
      {
        v87 = ZonePlayerList[v86];
        if ( !v87 )
          goto LABEL_196;
        playerr->XPixels = v87->XPixels;
        playerr->YPixels = v87->YPixels;
      }
      sub_40D870(playerr);
LABEL_196:
      v90 = *(_DWORD *)&playerr->AttachedToPlayerId;
      if ( v90 >= 0 )
      {
        v91 = ZonePlayerList[v90];
        if ( v91 )
        {
          playerr->XPixels = v91->XPixels;
          playerr->YPixels = v91->YPixels;
          sub_40D870(playerr);
        }
      }
      return;
    case 5:                                     // 0x05 - Death message
      if ( !playerr->MyArena )
        return;
      UpdatePowerBallPositionsSomething(playerr);
      playerr->KingCrownKills = 0;
      v96 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);// Killer's Player ID
      if ( v96 <= 1024 && *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) <= 20000 && v96 >= 0 )// 20000 Bounty
      {
        PacketTypee_10 = 0;
        PacketTypee_14 = ZonePlayerList[v96];
        v97 = PacketTypee_14;
        if ( PacketTypee_14 && PacketTypee_14->MyArena != playerr->MyArena )
        {
          v97 = 0;
          PacketTypee_14 = 0;
        }
        v98 = playerr->MyArena;
        if ( !v98->ServersideArenaSettings.FlagFriendlyTransfer )
        {
          if ( !v97 )
            goto LABEL_223;
          if ( *(_DWORD *)&v97->Frequency == *(_DWORD *)&playerr->Frequency )// Check for Team Kills?
          {
            v99 = playerr->PlayerId;
            LOBYTE(v296) = 0x16;                // 0x16 - Drop Flag
            *(_WORD *)((char *)&v296 + 1) = v99;
            ArenaSendPacket(v98, (char *)&v296, 3, 1);
            v100 = playerr->MyArena;
            v101 = v100->ServersideArenaSettings.FlagMode;
            if ( v101 )
            {
              if ( v101 == 1 )
              {
                CarryFlagsSomething(v100, *(_DWORD *)&playerr->PlayerId, 1);
                FlagPositionUpdateSomething(playerr->MyArena, 0);
              }
            }
            else
            {
              CarryFlagsSomething(v100, *(_DWORD *)&playerr->PlayerId, 0);
            }
          }
        }
        if ( v97 && *(_DWORD *)&v97->Ship == 8 )
        {
          v102 = playerr->PlayerId;
          v103 = playerr->MyArena;
          LOBYTE(v296) = 0x16;                  // 0x16 - Drop Flag
          *(_WORD *)((char *)&v296 + 1) = v102;
          ArenaSendPacket(v103, (char *)&v296, 3, 1);
          v104 = playerr->MyArena;
          v105 = v104->ServersideArenaSettings.FlagMode;
          if ( v105 )
          {
            if ( v105 == 1 )
            {
              CarryFlagsSomething(v104, *(_DWORD *)&playerr->PlayerId, 1);
              FlagPositionUpdateSomething(playerr->MyArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething(v104, *(_DWORD *)&playerr->PlayerId, 0);
          }
        }
LABEL_223:
        v106 = playerr->KotHDeathCount;
        if ( v106 <= 0 )
        {
          if ( v97 )
          {
            if ( (int)v97->KotHDeathCount > 0 )
            {
              v117 = playerr->MyArena;
              if ( (int)v117->ServersideArenaSettings.KingNonCrownAdjustTime > 0
                && *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) >= v117->ServersideArenaSettings.KingNonCrownMinimumBounty
                && *(_DWORD *)&playerr->Frequency != *(_DWORD *)&v97->Frequency )
              {
                LOBYTE(buffer2_2) = 0x2D;       // 0x2D - Add KotH time
                *(_DWORD *)((char *)&buffer2_2 + 1) = v117->ServersideArenaSettings.KingNonCrownAdjustTime;
                SendPlayerReliablePacket(v97, &buffer2_2, 5u, 1);
              }
            }
          }
        }
        else
        {
          v107 = v106 - 1;
          playerr->KotHDeathCount = v107;
          if ( v107 )
          {
            v109 = playerr->MyArena;
            LOBYTE(buffer2_2) = 0x2B;           // 0x2B - Set Personal KotH Timer
            *(_DWORD *)((char *)&buffer2_2 + 1) = v109->ServersideArenaSettings.KingExpireTime;
            SendPlayerReliablePacket(playerr, &buffer2_2, 5u, 1);
          }
          else
          {
            HIWORD(buffer2_2) = playerr->PlayerId;
            v108 = playerr->MyArena;
            strcpy((char *)&buffer2_2, ",");    // 0x2C - KotH Game Reset
            *(_DWORD *)((char *)&buffer2_2 + 2) = 0;
            ArenaSendPacket(v108, (char *)&buffer2_2, 8, 1);
          }
          if ( v97 )
          {
            if ( (int)v97->KotHDeathCount <= 0 )
            {
              v111 = v97->KingCrownKills + 1;
              v97->KingCrownKills = v111;
              v112 = v111;
              v113 = playerr->MyArena;
              v114 = v113->ServersideArenaSettings.KingCrownRecoverKills;
              if ( v114 > 0 && v112 >= v114 )
              {
                v115 = v97->PlayerId;
                v97->KotHDeathCount = v113->ServersideArenaSettings.KingDeathCount;
                HIWORD(buffer2_2) = v115;
                v116 = playerr->MyArena;
                LOWORD(buffer2_2) = 0x12C;      // 0x2C - KotH Game Reset
                *(_DWORD *)((char *)&buffer2_2 + 2) = v116->ServersideArenaSettings.KingExpireTime;
                ArenaSendPacket(v116, (char *)&buffer2_2, 8, 1);
              }
            }
            else
            {
              v110 = playerr->MyArena;
              LOBYTE(buffer2_2) = 0x2B;         // 0x2B - Set Personal KotH Timer
              *(_DWORD *)((char *)&buffer2_2 + 1) = v110->ServersideArenaSettings.KingExpireTime;
              SendPlayerReliablePacket(v97, &buffer2_2, 5u, 1);
            }
          }
        }
        playerr->DebtKills = playerr->MyArena->ServersideArenaSettings.KillDebtKills;
        v118 = playerr->DeathsWithoutFiring + 1;
        playerr->DeathsWithoutFiring = v118;
        if ( v118 > playerr->MyArena->ServersideArenaSettings.SecurityMaxDeathWithoutFiring && !playerr->IsModerator )
        {
          WriteSubGameLog("Played kicked off for too many deaths without firing: %s\n", playerr->PlayerName);
          playerr->DisconnectReason = 10;       // 0x0A - Server is Full
          playerr->AlreadySentReliablePacket = 1;
        }
        v119 = playerr->MyArena;
        v296 = 0;
        PacketTypee_6 = 0;
        if ( v119->ArenaSettings.CarryFlags && v119->FlagCounter > 0 )
        {
          v120 = &v119->Flags[0].CarrierPlayerId;
          LODWORD(buffer2_2) = v119->FlagCounter;
          do
          {
            v121 = *v120;
            if ( *v120 == *(_DWORD *)&playerr->PlayerId )
              ++v296;
            if ( v121 == *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1) )
              ++PacketTypee_6;
            v120 += 4;
            LODWORD(buffer2_2) = buffer2_2 - 1;
          }
          while ( (_DWORD)buffer2_2 );
        }
        if ( v119->ArenaSettings.CarryFlags == 2 && (int)v296 > 0 && PacketTypee_6 > 0 )
        {
          v122 = playerr->PlayerId;
          LOBYTE(v296) = 22;
          *(_WORD *)((char *)&v296 + 1) = v122;
          ArenaSendPacket(v119, (char *)&v296, 3, 1);
          v123 = playerr->MyArena;
          v124 = v123->ServersideArenaSettings.FlagMode;
          if ( v124 )
          {
            if ( v124 == 1 )
            {
              CarryFlagsSomething(v123, *(_DWORD *)&playerr->PlayerId, 1);
              FlagPositionUpdateSomething(playerr->MyArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething(v123, *(_DWORD *)&playerr->PlayerId, 0);
          }
          v296 = 0;
        }
        if ( *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1) == *(_DWORD *)&playerr->PlayerId )// Killer's Player ID
        {
          v125 = -*(__int16 *)(*(char **)((char *)&retaddr + 2) + 3);
          PacketTypee_10 = v125;
          printf("%s(%d) killed by self\n", playerr->PlayerDataBillerPacket.Name, v125);
          FormatMessageArena(playerr->MyArena, "%s(%d) killed by self\n", playerr->PlayerDataBillerPacket.Name, v125);
          v126 = playerr->MyArena;
          v127 = playerr->CurrentSuicideCount + 1;
          playerr->CurrentSuicideCount = v127;
          if ( v127 > v126->ServersideArenaSettings.SecuritySuicideLimit )
          {
            WriteSubGameLog("Played kicked off for too many suicides: %s\n", playerr->PlayerName);
            playerr->DisconnectReason = 0x13;   // 0x13 - Demo Versions not Allowed
            playerr->AlreadySentReliablePacket = 1;
          }
          CarryFlagsSomething(playerr->MyArena, *(_DWORD *)&playerr->PlayerId, 0);
LABEL_300:
          LODWORD(buffer2_2) = -1;
          if ( v97 )
          {
            v147 = PacketTypee_14;
            v148 = 0;
            v149 = PacketTypee_14->FlagPoints;
            v150 = PacketTypee_14->KillPoints;
            LODWORD(buffer2_2) = *(_DWORD *)&PacketTypee_14->Frequency;
            v151 = v150 + v149;
            if ( PacketTypee_10 > 0 && PacketTypee_6 > 0 )
              v148 = PacketTypee_10 * (__int16)playerr->MyArena->ArenaSettings.FlaggerKillMultiplier;
            UpdatePoints(PacketTypee_14, PacketTypee_10, v148);
            if ( v147->KillPoints < 0 )
              v147->KillPoints = 0;
            if ( v151 < AutoPermissionPoints
              && AutoPermissionPoints > 0
              && PacketTypee_14->KillPoints + PacketTypee_14->FlagPoints >= AutoPermissionPoints )
            {
              if ( PacketTypee_14->MyArena )
              {
                v311 = 7;                       // 0x07 - Chat
                v312 = 0;
                a3 = 0;
                a3_1 = -1;
                strcpy(a3_3, PermissionAutoPermissionMessage);
                v152 = strlen(PermissionAutoPermissionMessage) + 1;
                v153 = PacketTypee_14;
                if ( GetRelAckDiff(PacketTypee_14->connection, 0) < 128 )
                  SendPlayerReliablePacket(v153, &v311, v152 - 1 + 6, 1);
              }
            }
          }
          v154 = playerr->MyArena;
          ++playerr->CurrentLosses;
          v155 = PacketTypee_10;
          v156 = v154->ArenaJackpot;
          v154->ArenaJackpot = v156 + PacketTypee_10 * v154->ServersideArenaSettings.KillJackpotBountyPercent / 1000;
          if ( MiscJackpotBroadcastPoints > 0 )
          {
            v157 = playerr->MyArena;
            PacketTypee_6 = v157->ArenaJackpot / MiscJackpotBroadcastPoints;
            if ( v156 / MiscJackpotBroadcastPoints < PacketTypee_6 )
            {
              v311 = 2;
              v312 = 0;
              sprintf(
                &a3,
                "Jackpot just passed %d points in %s",
                MiscJackpotBroadcastPoints * (v157->ArenaJackpot / MiscJackpotBroadcastPoints),
                BillingServerName);
              if ( BillingConnectionStructPointer )
                SendBillerUserPrivateChatPacket(
                  BillingConnectionStructPointer,
                  -1,
                  BillingGroupId,
                  &v311,
                  strlen(&a3) + 3);
            }
          }
          v158 = playerr->PlayerId;
          buffer[2] = 6;                        // 0x06 - Player Death
          *(_WORD *)&buffer[6] = v158;
          v159 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);
          *(_WORD *)&buffer[10] = (_WORD)v296;
          v160 = playerr->MyArena;
          *(_WORD *)&buffer[4] = v159;
          *(_WORD *)&buffer[8] = v155;
          v161 = 0;
          buffer[3] = GetDeathPrizeGreenId(v160);
          if ( *(_WORD *)&buffer[10] || abs16(*(__int16 *)&buffer[8]) > 0xA0u )
          {
            ArenaSendPacket(playerr->MyArena, &buffer[2], 10, 1);
          }
          else
          {
            v162 = playerr->MyArena;
            if ( v162->ServersideArenaSettings.MiscTimedGame )
            {
              if ( v162->ArenaPlayerCount > 0 )
              {
                v163 = 64288;                   // Skip ArenaName + First Big Array
                do
                {
                  v164 = *(_DWORD *)&v162->PlayerPointers[v163];// playerPointersForSomething
                  v165 = *(_DWORD *)&playerr->PlayerId;
                  v167 = 1;
                  if ( *(_DWORD *)(v164 + 611) != v165 )
                  {
                    v166 = *(_DWORD *)(v164 + 20);
                    if ( v166 != v165 && v166 != *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1) )
                      v167 = 0;
                  }
                  SendPlayerReliablePacket((struct PLAYER *)v164, &buffer[2], 0xAu, v167);
                  v162 = playerr->MyArena;
                  ++v161;
                  v163 += 4;
                }
                while ( v161 < v162->ArenaPlayerCount );
              }
              goto LABEL_348;
            }
            v168 = v162->ArenaPlayerCount;
            PacketTypee_6 = 0;
            if ( v168 > 0 )
            {
              v169 = 64288;                     // Skip ArenaName + First Big Array
              while ( 1 )
              {
                v170 = *(struct PLAYER **)&v162->PlayerPointers[v169];// playerPointersForSomething
                v171 = v170;                    // playerPointersForSomething
                v172 = v170->ArenaPlayerIndex;
                if ( v172 >= 0 )
                  v171 = ZonePlayerList[v172];
                if ( !v171 )
                  goto LABEL_345;
                v173 = *(_DWORD *)&v171->Frequency;
                if ( v173 != *(_DWORD *)&playerr->Frequency && v173 != (_DWORD)buffer2_2 )
                  break;
                v174 = *(_DWORD *)&playerr->PlayerId;
                if ( *(_DWORD *)&v171->AttachedToPlayerId != v174 )
                {
                  v175 = *(_DWORD *)&v171->PlayerId;
                  if ( v175 != v174 && v175 != *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1) )
                    goto LABEL_344;
                }
                SendPlayerReliablePacket(v170, &buffer[2], 0xAu, 1);
LABEL_345:
                v162 = playerr->MyArena;
                v169 += 4;
                v180 = v162->ArenaPlayerCount;
                if ( ++PacketTypee_6 >= v180 )
                  goto LABEL_348;
              }
              v176 = *(_DWORD *)&v171->AttachedToPlayerId;
              if ( v176 >= 0 )
                v171 = ZonePlayerList[v176];
              if ( !v171 )
                goto LABEL_345;
              v177 = v162->ServersideArenaSettings.RoutingDeathDistance;
              v178 = v171->YPixels - playerr->YPixels;
              if ( (int)((HIDWORD(v178) ^ v178) - HIDWORD(v178)) > v177 )
                goto LABEL_345;
              v179 = v171->XPixels - playerr->XPixels;
              if ( (int)((HIDWORD(v179) ^ v179) - HIDWORD(v179)) > v177 )
                goto LABEL_345;
LABEL_344:
              SendPlayerReliablePacket(v170, &buffer[2], 0xAu, 0);
              goto LABEL_345;
            }
          }
LABEL_348:
          v181 = playerr->MyArena->ServersideArenaSettings.MiscMaxLossesToPlay;
          if ( v181 > 0 && (unsigned __int16)playerr->CurrentLosses >= v181 )
            SetPlayerShip(playerr, 8);
          if ( AdvertiseSendMode == 3 || AdvertiseSendMode == 2 )
            SendAdvertisement(playerr, 0);
          if ( PacketTypee_14 )
            SendPlayerScoreUpdateAll(PacketTypee_14);
          SendPlayerScoreUpdateAll(playerr);
          return;
        }
        playerr->CurrentSuicideCount = 0;
        if ( !v97 )
        {
          printf("%s killed by UNKNOWN\n", playerr->PlayerDataBillerPacket.Name);
          CarryFlagsSomething(playerr->MyArena, *(_DWORD *)&playerr->PlayerId, 0);
LABEL_299:
          dword_4D8B14 = *(_DWORD *)&playerr->PlayerId;
          goto LABEL_300;
        }
        v128 = playerr->MyArena;
        if ( (int)v128->ServersideArenaSettings.KillFixedKillReward < 0 )
        {
          v130 = v97->Bounty;
          v131 = (__int16)v128->ArenaSettings.MaxBonus;
          if ( v130 >= 0 )
          {
            v132 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) - v130;
            if ( v132 < v131 )
              v131 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) - v130;
            v133 = -(__int16)v128->ArenaSettings.MaxPenalty;
            if ( v131 <= v133 || (v133 = (__int16)v128->ArenaSettings.MaxBonus, v132 >= v133) )
              v132 = v133;
            v129 = v132 + *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) + (__int16)v128->ArenaSettings.RewardBase;
          }
          else
          {
            v129 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3);
          }
        }
        else
        {
          v129 = v128->ServersideArenaSettings.KillFixedKillReward;
        }
        v134 = v97->Bounty * v128->ServersideArenaSettings.KillBountyRewardPercent / 100 + v129;
        LODWORD(buffer2_2) = v128->ServersideArenaSettings.KillPointsPerFlag;
        PacketTypee_10 = v134;
        if ( (_DWORD)buffer2_2
          && v128->ArenaPlayerCount > v128->ServersideArenaSettings.PeriodicRewardMinimumPlayers
          && *(__int16 *)(*(char **)((char *)&retaddr + 2) + 3) > v128->ServersideArenaSettings.KillPointsMinimumBounty )
        {
          v135 = v128->FlagCounter;
          v136 = 0;
          if ( v135 > 0 )
          {
            v137 = &v128->Flags[0].OwnerFreq;
            do
            {
              if ( *v137 == *(_DWORD *)&v97->Frequency )
                ++v136;
              v137 += 4;
              --v135;
            }
            while ( v135 );
          }
          PacketTypee_10 = buffer2_2 * v136 + v134;
        }
        v138 = 0;
        v139 = &v97->someStringBuffer[4];
        while ( *(_DWORD *)v139 != playerr->PlayerDataBillerPacket.UserId )
        {
          ++v138;
          v139 += 8;
          if ( v138 >= 8 )
          {
            v140 = 0xFFFFFFF;
            goto LABEL_286;
          }
        }
        v291 = (int)(GetTickCount() / 0xA - *(_DWORD *)&v97->someStringBuffer[8 * v138]);
        v140 = (HIDWORD(v291) ^ v291) - HIDWORD(v291);
LABEL_286:
        if ( v140 >= playerr->MyArena->ServersideArenaSettings.KillNoRewardKillDelay )
        {
          v141 = playerr->PlayerDataBillerPacket.UserId;
          *(_DWORD *)&v97->someStringBuffer[8 * v97->field_A8] = GetTickCount() / 0xA;
          *(_DWORD *)&v97->someStringBuffer[8 * v97->field_A8 + 4] = v141;
          v97->field_A8 = (v97->field_A8 + 1) % 8;
          if ( *(_DWORD *)&v97->Frequency != *(_DWORD *)&playerr->Frequency )
          {
            v142 = v97->DebtKills;
            if ( v142 <= 0 )
            {
LABEL_291:
              v143 = PacketTypee_10;
              ++v97->CurrentWins;
              printf(
                "%s(%d) killed by %s\n",
                playerr->PlayerDataBillerPacket.Name,
                v143,
                v97->PlayerDataBillerPacket.Name);
              FormatMessageArena(
                playerr->MyArena,
                "%s(%d) killed by %s\n",
                playerr->PlayerDataBillerPacket.Name,
                PacketTypee_10,
                v97->PlayerDataBillerPacket.Name);
              v144 = playerr->MyArena;
              if ( v144->ArenaSettings.CarryFlags )
              {
                v145 = 0;
                if ( v144->FlagCounter > 0 )
                {
                  v146 = 0;
                  do
                  {
                    if ( v144->Flags[v146].CarrierPlayerId == *(_DWORD *)&playerr->PlayerId )
                    {
                      v144->Flags[v146].CarrierPlayerId = *(_DWORD *)&v97->PlayerId;
                      playerr->MyArena->Flags[v146].OwnerFreq = *(_DWORD *)&v97->Frequency;
                    }
                    v144 = playerr->MyArena;
                    ++v145;
                    ++v146;
                  }
                  while ( v145 < v144->FlagCounter );
                }
              }
              goto LABEL_299;
            }
            v97->DebtKills = v142 - 1;
          }
        }
        PacketTypee_10 = 0;
        goto LABEL_291;
      }
      if ( !playerr->IsSuperModerator )
      {
LABEL_358:
        sprintf(&a1[2], "Packet tampering(%d)", **(char **)((char *)&retaddr + 2));
        SendBillerWarnings(&a1[2], playerr);
        v182 = playerr->MyArena;
        if ( v182 && v182->ServersideArenaSettings.dwordB4 )
          goto LABEL_683;
      }
      return;
    case 6:                                     // 0x06 - Chat message
      if ( !playerr->IsSilenced && playerr->MyArena )
      {
        v236 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 3);
        if ( v236 <= 1024 && v236 >= 0 )
        {
          if ( strlen(*(const char **)((char *)&retaddr + 2) + 5) <= 0xFA )
          {
            if ( playerr->MyArena->ServersideArenaSettings.MessageBongAllowed || playerr->IsModerator )
              v294 = (const char *)(*(char **)((char *)&retaddr + 2))[2];
            else
              v294 = 0;
            ChatProcessor(
              (LPPROCESS_INFORMATION)playerr,
              (PLAYER *)(*(char **)((char *)&retaddr + 2))[1],
              (char *)v236,
              *(int *)((char *)&retaddr + 2) + 5,
              v294,
              (char)v295);
            JUMPOUT(0x40B6CE);
          }
          PacketType = buffer2_2;
        }
        if ( !playerr->IsSuperModerator )
        {
          sprintf(&a1[2], "Packet tampering(%d)", PacketType);
          SendBillerWarnings(&a1[2], playerr);
          v237 = playerr->MyArena;
          if ( v237 )
          {
            if ( v237->ServersideArenaSettings.dwordB4 )
              goto LABEL_683;
          }
        }
      }
      return;
    case 7:                                     // 0x07 - Take Green / Prize
      if ( playerr->MyArena && *(_DWORD *)&playerr->Ship != 8 )
      {
        if ( *(__int16 *)(*(char **)((char *)&retaddr + 2) + 9) >= 29
          || (v183 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 5), v183 < 0)
          || v183 >= 1024
          || (v184 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 7), v184 < 0)
          || v184 >= 1024 )
        {
          if ( !playerr->IsSuperModerator )
          {
            sprintf(&a1[2], "Packet tampering(%d)", PacketType);
            SendBillerWarnings(&a1[2], playerr);
            v197 = playerr->MyArena;
            if ( v197 )
            {
              if ( v197->ServersideArenaSettings.dwordB4 )
                goto LABEL_683;
            }
          }
        }
        else
        {
          v185 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1);
          v186 = playerr->connection;
          v187 = ((v186->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v185;
          if ( v187 < 0 || v187 > 30000 )
            v187 = 0;
          v188 = playerr->MyArena;
          if ( v187 <= v188->ServersideArenaSettings.LatencyMaxLatencyForPrizes
            && playerr->PrizePacketId.PrizeTimeStamp != *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1) )
          {
            buffer[2] = 8;                      // 0x08 - Player got a Prize
            playerr->PrizePacketId = **(PRIZE_PACKET_STRUCT **)((char *)&retaddr + 2);
            v189 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 7);
            *(_WORD *)&buffer[7] = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 5);
            v190 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 9);
            *(_WORD *)&buffer[9] = v189;
            v191 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1);
            *(_WORD *)&buffer[11] = v190;
            v192 = playerr->PlayerId;
            *(_DWORD *)&buffer[3] = v191;
            *(_WORD *)&buffer[13] = v192;
            v193 = v188->ServersideArenaSettings.PrizeS2CTakePrizeReliable;
            if ( v188 )
            {
              v194 = 0;
              if ( v188->ArenaPlayerCount > 0 )
              {
                v195 = 64288;
                do
                {
                  v196 = *(struct PLAYER **)&v188->PlayerPointers[v195];// playerPointersForSomething
                  if ( v196 != playerr && !v196->AlreadySentReliablePacket )
                    SendPlayerReliablePacket(v196, &buffer[2], 0xDu, v193);
                  v188 = playerr->MyArena;
                  ++v194;
                  v195 += 4;
                }
                while ( v194 < v188->ArenaPlayerCount );
              }
            }
          }
        }
      }
      return;
    case 8:                                     // 0x08 - Spectate request
      if ( playerr->MyArena )
      {
        v220 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);
        if ( v220 == -1 || *(_DWORD *)&playerr->Ship == 8 )
        {
          if ( v220 > 1024 || v220 < -1 )
          {
            if ( !playerr->IsSuperModerator )
            {
              sprintf(&a1[2], "Packet tampering(%d)", PacketType);
              SendBillerWarnings(&a1[2], playerr);
              v226 = playerr->MyArena;
              if ( v226 )
              {
                if ( v226->ServersideArenaSettings.dwordB4 )
                  goto LABEL_683;
              }
            }
          }
          else
          {
            v221 = playerr->ArenaPlayerIndex;
            playerr->ArenaPlayerIndex = v220;
            if ( v220 >= 0 )
            {
              v222 = ZonePlayerList[v220];
              if ( v222 )
              {
                playerr->XPixels = v222->XPixels;
                playerr->YPixels = v222->YPixels;
                sub_40D870(playerr);
              }
            }
            if ( playerr->IsSysop )
            {
              LOBYTE(v296) = 0x1C;              // 0x1C - Put player in spectator mode / change extra info flag
              if ( v221 >= 0 )
              {
                v223 = ZonePlayerList[v221];
                BYTE1(v296) = 0;                // Player ID
                if ( v223 )
                  SendPlayerReliablePacket(v223, &v296, 2u, 1);
              }
              v224 = playerr->ArenaPlayerIndex;
              if ( v224 >= 0 )
              {
                v225 = ZonePlayerList[v224];
                BYTE1(v296) = 1;                // Player ID
                if ( v225 )
                  SendPlayerReliablePacket(v225, &v296, 2u, 1);
              }
            }
          }
        }
        else
        {
          WriteSubGameLog("WARNING: Spectator request from non-spectator ship, ignoring\n");
        }
      }
      return;
    case 9:                                     // 0x09 - Password packet
    case 0x23:                                  // 0x23 - Password packet
      v267 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 77);// Mem Checksums [0x01BC] or [444]
      PacketTypee_6 = 0;
      if ( !v267 )
      {
        playerr->DemoPlayer = 1;
        PacketTypee_6 = 1;
      }
      v268 = *(char **)((char *)&retaddr + 2) + 2;
      PacketTypee_14 = (PLAYER *)(*(char **)((char *)&retaddr + 2) + 2);
      strcpy(playerr->TypedName, *(const char **)((char *)&retaddr + 2) + 2);
      config_read_helper_3(*(char **)((char *)&retaddr + 2) + 2);
      printf("Connection request from: %s\n", *(const char **)((char *)&retaddr + 2) + 2);
      v269 = 0;
      PacketTypee_10 = 0;
      v296 = *(char **)((char *)&retaddr + 2) + 34;
      v270 = strrchr(*(const char **)((char *)&retaddr + 2) + 34, '*');// Player Name 32 Bytes Length
      if ( !v270 )
        goto LABEL_605;
      if ( _strcmpi(v270 + 1, SysopPassword) )
      {
        if ( _strcmpi(v270 + 1, SuperModeratorPassword) )
        {
          if ( _strcmpi(v270 + 1, ModeratorPassword) )
          {
            if ( _strcmpi(v270 + 1, VIPPassword) )
              goto LABEL_605;
            v269 = 1;
            PacketTypee_10 = 1;
            WriteSubGameLog("%s>  VIP LOGGED IN\n", v268);
          }
          else
          {
            WriteSubGameLog("%s>  MODERATOR LOGGED IN\n", v268);
            v269 = 1;
            PacketTypee_10 = 1;
            playerr->IsModerator = 1;
          }
        }
        else
        {
          WriteSubGameLog("%s>  SUPER MODERATOR LOGGED IN\n", v268);
          v269 = 1;
          PacketTypee_10 = 1;
          playerr->IsModerator = 1;
          playerr->IsSuperModerator = 1;
        }
      }
      else
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", v268);
        v269 = 1;
        PacketTypee_10 = 1;
        playerr->IsSysop = 1;
        playerr->IsModerator = 1;
        playerr->IsSuperModerator = 1;
      }
      *v270 = 0;
LABEL_605:
      if ( !PacketTypee_6 && BillingConnectionStructPointer && IsBannedMachineId(ModeratePointer, v268) >= 0 )
      {
        v269 = 1;
        PacketTypee_10 = 1;
        playerr->IsModerator = 1;
      }
      playerr->PlayerDataBillerPacket.Name[0] = 0;
      strncpy(playerr->PlayerName, v268, 0x18u);
      playerr->PlayerName[23] = 0;
      playerr->MachineId = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 85);
      playerr->TimeZoneBias = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 71);
      v271 = (*(char **)((char *)&retaddr + 2))[70];
      playerr->ConnectType = v271;
      if ( v271 == 1 )
        playerr->SlowModem = 1;
      if ( !PermissionAllowLowBandwidth && !v269 )
      {
        buffer_28[2] = 0xA;                     // 0x0A - Password response
        buffer_28[3] = 8;                       // Byte [1] - 8 - Connection too slow.
        *(_DWORD *)&buffer_28[4] = 134;         // Byte [2] - Server version 134 - SubSpace 1.34
        SendPlayerReliablePacket(playerr, &buffer_28[2], 0x24u, 1);
        WriteSubGameLog("Played kicked off for having slow modem: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      *(_DWORD *)&playerr->SubspaceVersion = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 75);
      playerr->SubspaceEXEChecksumIndex = 0;
      v272 = **(_BYTE **)((char *)&retaddr + 2);
      if ( **(char **)((char *)&retaddr + 2) >= 0x23 && v272 <= 0x2C )
        playerr->SubspaceEXEChecksumIndex = v272 - 35;
      if ( !Security[playerr->SubspaceEXEChecksumIndex].SubspaceEXEChecksum )
        goto LABEL_618;
      LOBYTE(v273) = IsOffensiveName(v268);
      if ( v273 && !playerr->IsModerator )
      {
        PacketTypee_18 = 0xC0A;                 // 0x0A - Password Packet Response
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        v306 = 0;                               // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
        WriteSubGameLog("Played kicked off, obscene name: %s\n", v268);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      if ( PermissionMode == 1 && !playerr->IsModerator && (PacketTypee_6 || IsBannedMachineId(PermitPointer, v268) < 0) )
      {
LABEL_618:
        PacketTypee_18 = 0x50A;
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        v306 = 0;                               // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
        playerr->KickOffDelayTimer = GetTickCount() / 0xA;
        return;
      }
      v274 = GetIPAddressString((struct in_addr)playerr->IPAddressDWORD);
      if ( IsBannedIPAddress(playerr->SubspaceEXEChecksumIndex, v274) )
      {
        PacketTypee_18 = 0x40A;                 // 0x0A - Password Packet Response
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        v306 = 0;                               // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
        WriteSubGameLog("Played kicked off, IP block: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      sprintf(&buffer[2], "%d", playerr->MachineId);
      if ( IsBannedMachineId(IDBlockPointer, &buffer[2]) >= 0 )
      {
        PacketTypee_18 = 0x40A;                 // 0x0A - Password Packet Response
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        v306 = 0;                               // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
        WriteSubGameLog("Played kicked off, ID block: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      v275 = 0;
      if ( MachineIdArrayCount <= 0 )
        goto LABEL_638;
      v276 = KickedUsers;
      while ( v276->MachineId != playerr->MachineId || playerr->IsSysop )
      {
        ++v275;
        ++v276;
        if ( v275 >= MachineIdArrayCount )
          goto LABEL_638;
      }
      PacketTypee_18 = 0x50A;                   // 0x0A - Password Packet Response
      PacketTypee_20 = 134;                     // Server Version 134 = SubSpace 1.34
      v306 = 0;                                 // Registration Form Request (Boolean)
      SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
      playerr->KickOffDelayTimer = GetTickCount() / 0xA;
LABEL_638:
      if ( !playerr->DemoPlayer )
        goto LABEL_649;
      v277 = ZonePlayerCount;
      v278 = 0;
      if ( ZonePlayerCount > 0 )
      {
        v279 = playerPointerList;
        v280 = ZonePlayerCount;
        do
        {
          if ( (*v279)->DemoPlayer )
            ++v278;
          ++v279;
          --v280;
        }
        while ( v280 );
      }
      if ( MiscMaxSharewarePlayer >= 0 && v278 > MiscMaxSharewarePlayer )
      {
        LOBYTE(PacketTypee_18) = 0xA;
        HIBYTE(PacketTypee_18) = (MiscMaxSharewarePlayer == 0) + 17;
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        v306 = 0;
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
        WriteSubGameLog("Played kicked off, arena full to demo users: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      if ( PacketTypee_6 )
      {
        memset(&playerr->PlayerDataBillerPacket, 0, sizeof(playerr->PlayerDataBillerPacket));// TODO: Erases way past the Name LOL
        sprintf(playerr->PlayerDataBillerPacket.Name, "~Demo%d", *(_DWORD *)&playerr->PlayerId);
        strcpy(playerr->PlayerName, playerr->PlayerDataBillerPacket.Name);
        playerr->PlayerDataBillerPacket.UserId = -1;
        *(_DWORD *)&playerr->CurrentWins = 0;
        *(_DWORD *)&playerr->CurrentGoals = 0;
        *(int *)((char *)&playerr->KillPoints + 2) = 0;
        HIWORD(playerr->FlagPoints) = 0;
LABEL_649:
        v277 = ZonePlayerCount;
      }
      if ( v277 > MiscMaxPlayers && !PacketTypee_10 )
      {
        PacketTypee_6 = 0;
        if ( MiscRegisterKickShareware )
        {
          if ( !playerr->DemoPlayer )
          {
            v281 = 0;
            if ( v277 > 0 )
            {
              v282 = playerPointerList;
              while ( !(*v282)->DemoPlayer )
              {
                ++v281;
                ++v282;
                if ( v281 >= v277 )
                  goto LABEL_663;
              }
              v283 = playerPointerList[v281];
              PacketTypee_6 = 1;
              LODWORD(buffer2_2) = v283;
              if ( v283->MyArena )
              {
                v311 = 7;
                v312 = 0;
                a3 = 0;
                a3_1 = -1;
                strcpy(a3_3, "You have been kicked off to make space for a registered user.");
                v284 = strlen("You have been kicked off to make space for a registered user.") + 1;
                if ( GetRelAckDiff(*(struct CONNECTION **)(buffer2_2 + 40), 0) < 128 )
                  SendPlayerReliablePacket((struct PLAYER *)buffer2_2, &v311, v284 - 1 + 6, 1);
              }
              playerPointerList[v281]->KickOffDelayTimer = GetTickCount() / 0xA;
            }
          }
        }
LABEL_663:
        if ( !PacketTypee_6 )
        {
          PacketTypee_18 = 0x30A;
          PacketTypee_20 = 134;
          v306 = 0;
          SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
          WriteSubGameLog("Played kicked off, arena full: %s\n", playerr->PlayerName);
          playerr->AlreadySentReliablePacket = 1;
          return;
        }
      }
      v285 = BillingConnectionStructPointer;
      if ( BillingConnectionStructPointer )
      {
        if ( !PacketTypee_10 )
        {
          if ( GetRelAckDiff(EncryptionStruct, 0) > CommsMaxQueueToLogin )
          {
            PacketTypee_18 = 0xE0A;             // 0x0A - Password Packet Response
            PacketTypee_20 = 134;               // Server Version 134 = SubSpace 1.34
            v306 = 0;                           // Registration Form Request (Boolean)
            SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
            playerr->AlreadySentReliablePacket = 1;
            return;
          }
          v285 = BillingConnectionStructPointer;
        }
        if ( playerr->DemoPlayer && MiscDisableShareware )
          SendBillerUserLoginPacket(
            v285,
            (const char *)&DirectoryCurrentNamePassword,
            (const char *)&DirectoryCurrentNamePassword,
            (int)playerr->IPAddressDWORD,
            playerr->MachineId,
            playerr->TimeZoneBias,
            (*(_BYTE **)((char *)&retaddr + 2))[1],
            playerr->BillerPlayerId,
            0,
            playerr->IsSysop);
        else
          SendBillerUserLoginPacket(
            v285,
            (const char *)PacketTypee_14,
            v296,
            (int)playerr->IPAddressDWORD,
            playerr->MachineId,
            playerr->TimeZoneBias,
            (*(_BYTE **)((char *)&retaddr + 2))[1],
            playerr->BillerPlayerId,
            0,
            playerr->IsSysop);
      }
      else if ( IsBannedMachineId(ReservedPointer, (char *)PacketTypee_14) < 0 || PacketTypee_10 )
      {
        memset(&playerr->PlayerDataBillerPacket, 0, sizeof(playerr->PlayerDataBillerPacket));// TODO: Clears past the Name limit of 32 bytes.
        PacketTypee_18 = 0xD0A;
        strcpy(playerr->PlayerDataBillerPacket.Name, (const char *)PacketTypee_14);
        PacketTypee_20 = 134;                   // Server Version 134 = SubSpace 1.34
        *(_DWORD *)&playerr->CurrentWins = 0;
        *(_DWORD *)&playerr->CurrentGoals = 0;
        *(int *)((char *)&playerr->KillPoints + 2) = 0;
        HIWORD(playerr->FlagPoints) = 0;
        v286 = playerr->SubspaceEXEChecksumIndex;
        PacketTypee_24 = 0;                     // ? Unknown
        v287 = v286;
        v305 = 0;                               // ? Unknown
        v306 = 0;                               // Registration Form Request (Boolean)
        v288 = Security[v286].SubspaceEXEChecksum;
        v307 = *(_DWORD *)&Security[v287].ScrtyData[4];
        v289 = playerr->IsModerator;
        v304 = (unsigned int)v288;
        v308 = NewsTxtFileChecksum;
        if ( v289 )
        {
          LODWORD(v304) = -1;                   // Subspace.exe Checksum
          v307 = -1;                            // ? Unknown
        }
        SendPlayerReliablePacket(playerr, &PacketTypee_18, 0x24u, 1);
      }
      else
      {
        buffer_28[2] = 0xA;                     // 0x0A - Password Packet Response
        buffer_28[3] = 12;                      // 12 - Offensive name.
        *(_DWORD *)&buffer_28[4] = 134;         // Server Version 134 = SubSpace 1.34
        buffer_28[21] = 0;
        SendPlayerReliablePacket(playerr, &buffer_28[2], 0x24u, 1);
        playerr->KickOffDelayTimer = GetTickCount() / 0xA;
      }
      return;
    case 0xB:                                   // 0x0B - SSUpdate.EXE Request
      v65 = *(_DWORD *)&playerr->SubspaceVersion;
      if ( v65 == 132 && (v66 = playerr->SubspaceEXEChecksumIndex, (v67 = Security[v66].Subspace132EXEBytes) != 0) )
      {
        GetMapLvlRequest(playerr->connection, v67, Security[v66].Subspace132FileSize, 0);
      }
      else if ( v65 == 133 && (v68 = playerr->SubspaceEXEChecksumIndex, (v69 = Security[v68].Subspace133EXEBytes) != 0) )
      {
        GetMapLvlRequest(playerr->connection, v69, Security[v68].Subspace133FileSize, 0);
      }
      else
      {
        GetMapLvlRequest(
          playerr->connection,
          Security[playerr->SubspaceEXEChecksumIndex].Subspace131EXEBytes,
          Security[playerr->SubspaceEXEChecksumIndex].Subspace131FileSize,
          0);
      }
      return;
    case 0xC:                                   // 0x0C - Map.lvl Request
      v63 = playerr->MyArena;
      if ( v63 )
        GetMapLvlRequest(playerr->connection, v63->CompressedMap, v63->DefaultMapFileSize, 0);
      return;
    case 0xD:                                   // 0x0D - News.txt Request
      v64 = (char *)emalloc(NewsTxtFileSize);
      qmemcpy(v64, CompressedNewsMemory, NewsTxtFileSize);
      GetNewsRequest(playerr->connection, v64, NewsTxtFileSize, 0);
      return;
    case 0xE:                                   // 0x0E - Voice Message
      v232 = (*(_BYTE **)((char *)&retaddr + 2))[1];// 4*1024 Max Voice Size is 8192 Bytes
      if ( v232 >= 4 || v232 < 0 || (*(__int16 **)((char *)&retaddr + 2))[1] > 1024 )
      {
        if ( !playerr->IsSuperModerator )
          goto LABEL_589;
      }
      else
      {
        if ( !playerr->VoiceUploads[v232].VoiceMemoryPointer )
        {
          packett = *(int *)((char *)&retaddr + 2);
          playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceMemoryPointer = (char *)emalloc((int)(*(unsigned __int8 **)((char *)&packet + 2) - 4));
          playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceSize = (int)(*(unsigned __int8 **)((char *)&packet + 2)
                                                                                       - 4);
          qmemcpy(
            playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceMemoryPointer,
            *(char **)((char *)&retaddr + 2) + 4,
            (unsigned int)(*(unsigned __int8 **)((char *)&packet + 2) - 4));
        }
        v233 = *(_WORD *)(packett + 2);
        if ( v233 != -1 && v233 != -2 && v233 >= 0 )
        {
          LODWORD(buffer2_2) = ZonePlayerList[v233];
          if ( (_DWORD)buffer2_2 )
          {
            if ( !sub_41CA10(*(struct CONNECTION **)(buffer2_2 + 40)) )
            {
              v234 = playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceSize + 3;
              v235 = (char *)emalloc(v234);
              *v235 = 0xC;                      // 0x0C - Player Voice
              *(_WORD *)(v235 + 1) = playerr->PlayerId;
              qmemcpy(
                v235 + 3,
                playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceMemoryPointer,
                playerr->VoiceUploads[(*(char **)((char *)&retaddr + 2))[1]].VoiceSize);
              GetNewsRequest(*(struct CONNECTION **)(buffer2_2 + 40), v235, v234, 1);
              Wave += v234;
            }
          }
        }
      }
      return;
    case 0xF:
      if ( playerr->MyArena )                   // 0x0F - Frequency change
        PlayerChangeFrequency(playerr, *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1));
      return;
    case 0x10:
      if ( !playerr->MyArena || *(_DWORD *)&playerr->Ship == 8 )
        return;
      v257 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);
      if ( v257 > 1024 || v257 < -1 )
      {
        if ( !playerr->IsSuperModerator )
        {
LABEL_589:
          sprintf(&a1[2], "Packet tampering(%d)", PacketType);
          v293 = playerr;
          goto LABEL_590;
        }
      }
      else
      {
        *(_DWORD *)&playerr->AttachedToPlayerId = v257;
        if ( v257 >= 0 )
        {
          v258 = ZonePlayerList[v257];
          if ( v258 )
          {
            if ( *(_DWORD *)&v258->Frequency != *(_DWORD *)&playerr->Frequency )
            {
              *(_DWORD *)&playerr->AttachedToPlayerId = -1;
              return;
            }
            if ( *(int *)&v258->AttachedToPlayerId >= 0 )
            {
              *(_DWORD *)&playerr->AttachedToPlayerId = -1;
              return;
            }
            playerr->XPixels = v258->XPixels;
            playerr->YPixels = v258->YPixels;
            sub_40D870(playerr);
          }
        }
        v259 = playerr->PlayerId;
        v260 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 1);
        *(_WORD *)((char *)&buffer2_2 + 3) = playerr->AttachedToPlayerId;// Turreter Destination Player ID
        v261 = *(_DWORD *)&playerr->AttachedToPlayerId;
        LOBYTE(buffer2_2) = 0xE;                // 0x0E - Create Turret Link
        *(_WORD *)((char *)&buffer2_2 + 1) = v259;// Turreter Requester Player ID
        if ( v260 == v261 )
        {
          v262 = playerr->MyArena;
          if ( v262 )
          {
            v263 = 0;
            if ( v262->ArenaPlayerCount > 0 )
            {
              v264 = 64288;                     // playerPointersForSomething
              do
              {
                v265 = *(struct PLAYER **)&v262->PlayerPointers[v264];// playerPointersForSomething
                if ( v265 != playerr && !v265->AlreadySentReliablePacket )
                  SendPlayerReliablePacket(v265, &buffer2_2, 5u, 1);
                v262 = playerr->MyArena;
                ++v263;
                v264 += 4;
              }
              while ( v263 < v262->ArenaPlayerCount );
            }
          }
        }
        else
        {
          ArenaSendPacket(playerr->MyArena, (char *)&buffer2_2, 5, 1);
        }
      }
      return;
    case 0x13:                                  // 0x13 - Flag request
      if ( playerr->MyArena )
      {
        if ( *(_DWORD *)&playerr->Ship != 8 )
        {
          v198 = playerr->MyArena;
          v199 = (int)(GetTickCount() / 0xA - playerr->field_15B);
          if ( (signed int)((HIDWORD(v199) ^ v199) - HIDWORD(v199)) >= v198->ServersideArenaSettings.LatencyNoFlagPenalty )
          {
            v200 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);
            v201 = v198->FlagCounter;
            v202 = v200;
            LODWORD(buffer2_2) = v200;
            if ( v200 <= v201 && v200 >= 0 )
            {
              if ( v198->ArenaSettings.CarryFlags != 2 )
                goto LABEL_689;
              v203 = 0;
              if ( v201 > 0 )
              {
                v204 = &v198->Flags[0].CarrierPlayerId;
                do
                {
                  if ( *v204 == *(_DWORD *)&playerr->PlayerId )
                    ++v203;
                  v204 += 4;
                  --v201;
                }
                while ( v201 );
                v202 = buffer2_2;
              }
              if ( v203 <= 0 )
              {
LABEL_689:
                if ( v198->Flags[v202].CarrierPlayerId == -1 )
                {
                  *(_WORD *)((char *)&buffer2_2 + 1) = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);// Flag ID
                  v205 = playerr->PlayerId;
                  LOBYTE(buffer2_2) = 0x13;     // 0x13 - Flag Claim
                  *(_WORD *)((char *)&buffer2_2 + 3) = v205;// Player ID
                  ArenaSendPacket(v198, (char *)&buffer2_2, 5, 1);
                  playerr->MyArena->Flags[*(__int16 *)(*(char **)((char *)&retaddr + 2) + 1)].OwnerFreq = *(_DWORD *)&playerr->Frequency;
                  v206 = playerr->MyArena;
                  if ( v206->ArenaSettings.CarryFlags )
                    v206->Flags[*(__int16 *)(*(char **)((char *)&retaddr + 2) + 1)].CarrierPlayerId = *(_DWORD *)&playerr->PlayerId;
                }
              }
            }
          }
        }
      }
      return;
    case 0x14:                                  // 0x14 - Drop all attached pilots
      v211 = playerr->MyArena;
      if ( v211 )
      {
        v212 = playerr->PlayerId;
        LOBYTE(v296) = 0x15;                    // 0x15 - Destroy Turret Link
        *(_WORD *)((char *)&v296 + 1) = v212;   // Turret Driver Player ID
        v213 = 0;
        if ( v211->ArenaPlayerCount > 0 )
        {
          v214 = 64288;                         // playerPointersForSomething
          do
          {
            v215 = *(struct PLAYER **)&v211->PlayerPointers[v214];// playerPointersForSomething
            if ( v215 != playerr && !v215->AlreadySentReliablePacket )
              SendPlayerReliablePacket(v215, &v296, 3u, 1);
            v211 = playerr->MyArena;
            ++v213;
            v214 += 4;
          }
          while ( v213 < v211->ArenaPlayerCount );
        }
      }
      return;
    case 0x15:                                  // 0x15 - Drop flags
      v216 = playerr->MyArena;
      if ( v216 && v216->ArenaSettings.CarryFlags )
      {
        v217 = playerr->PlayerId;
        LOBYTE(v296) = 0x16;                    //  0x16 - Drop Flag
        *(_WORD *)((char *)&v296 + 1) = v217;   // Carrier Player ID
        ArenaSendPacket(v216, (char *)&v296, 3, 1);
        v218 = playerr->MyArena;
        v219 = v218->ServersideArenaSettings.FlagMode;
        if ( v219 )
        {
          if ( v219 == 1 )
          {
            CarryFlagsSomething(v218, *(_DWORD *)&playerr->PlayerId, 1);
            FlagPositionUpdateSomething(playerr->MyArena, 0);
          }
        }
        else
        {
          CarryFlagsSomething(v218, *(_DWORD *)&playerr->PlayerId, 0);
        }
      }
      return;
    case 0x16:                                  // 0x16 - File transfer
      v242 = playerr->field_58;
      if ( v242 < 0 )
      {
        v245 = playerr->field_60;
        if ( v245 < 0 )
        {
          v251 = playerr->IsSysop != 0;
          v252 = *(char **)((char *)&retaddr + 2) + 1;
          PacketTypee_14 = (PLAYER *)(*(char **)((char *)&retaddr + 2) + 1);
          if ( !_strcmpi(*(const char **)((char *)&retaddr + 2) + 1, "moderate.txt") )
            v251 = 1;
          if ( !_strcmpi(*(const char **)((char *)&retaddr + 2) + 1, "permit.txt") )
            v251 = 1;
          if ( !_strcmpi(*(const char **)((char *)&retaddr + 2) + 1, playerr->MyArena->SetLevelMapFilename)
            && playerr->PlayerDataBillerPacket.UserId == playerr->MyArena->ServersideArenaSettings.OwnerUserId )
          {
            v251 = 1;
          }
          if ( v251 )
          {
            if ( playerr->IsSysop || *(int *)((char *)&packet + 2) <= 0x80000 )// 512 KB Max
            {
              v253 = fopen(*(const char **)((char *)&retaddr + 2) + 1, "wb");
              v254 = v253;
              if ( v253 )
              {
                fwrite(
                  *(char **)((char *)&retaddr + 2) + 17,
                  (size_t)(*(unsigned __int8 **)((char *)&packet + 2) - 17),
                  1u,
                  v253);
                fclose(v254);
              }
              sprintf(&a1[2], "File received: %s", v252);
              if ( playerr->MyArena )
              {
                v311 = 7;
                v312 = 0;
                a3 = 0;
                a3_1 = -1;
                strcpy(a3_3, &a1[2]);
                v255 = strlen(&a1[2]) + 1;
                if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                  SendPlayerReliablePacket(playerr, &v311, v255 - 1 + 6, 1);
                v252 = (const char *)PacketTypee_14;
              }
              if ( !_strcmpi(v252, playerr->MyArena->SetLevelMapFilename) )
              {
                if ( playerr->MyArena )
                {
                  v311 = 7;
                  v312 = 0;
                  a3 = 0;
                  a3_1 = -1;
                  strcpy(a3_3, "Arena is recycling so the change can take effect.");
                  v256 = strlen("Arena is recycling so the change can take effect.") + 1;
                  if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                    SendPlayerReliablePacket(playerr, &v311, v256 - 1 + 6, 1);
                }
                v252 = (const char *)PacketTypee_14;
                playerr->MyArena->ArenaRecycling = 1;
              }
              if ( !_strcmpi(v252, MiscDefaultLevelFile) )
                RecycleServer = 1;
            }
            else if ( playerr->MyArena )
            {
              v311 = 7;                         // 0x07 - Chat
              v312 = 0;
              a3 = 0;
              a3_1 = -1;
              strcpy(a3_3, "File has arrived, but is too big (size limit of 512k)");
              v40 = strlen("File has arrived, but is too big (size limit of 512k)") + 6;
              if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                goto LABEL_553;
            }
          }
        }
        else
        {
          v246 = ZonePlayerList[v245];
          PacketTypee_6 = (int)v246;
          if ( v246 && v246->PlayerDataBillerPacket.UserId == playerr->field_5C )
          {
            PacketTypee_14 = (PLAYER *)(*(char **)((char *)&retaddr + 2) + 1);
            sprintf(
              &a1[2],
              "File arrived at server, forwarding to %s: %s",
              v246->PlayerDataBillerPacket.Name,
              *(const char **)((char *)&retaddr + 2) + 1);
            if ( playerr->MyArena )
            {
              v311 = 7;
              v312 = 0;
              a3 = 0;
              a3_1 = -1;
              strcpy(a3_3, &a1[2]);
              v247 = strlen(&a1[2]) + 1;
              if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                SendPlayerReliablePacket(playerr, &v311, v247 - 1 + 6, 1);
            }
            v248 = (char *)emalloc(*(int *)((char *)&packet + 2));
            qmemcpy(
              v248 + 17,
              *(char **)((char *)&retaddr + 2) + 17,
              (unsigned int)(*(unsigned __int8 **)((char *)&packet + 2) - 17));
            v249 = (const char *)PacketTypee_14;
            *v248 = 0x10;                       // 0x10 - File Transfer
            LODWORD(buffer2_2) = v248 + 1;
            strcpy(v248 + 1, v249);
            GetNewsRequest(*(struct CONNECTION **)(PacketTypee_6 + 40), v248, *(int *)((char *)&packet + 2), 0);
            playerr->field_60 = -1;
            playerr->field_5C = -1;
          }
          else
          {
            sprintf(&a1[2], "File arrived at server, could not forward: %s", *(const char **)((char *)&retaddr + 2) + 1);
            if ( playerr->MyArena )
            {
              v311 = 7;
              v312 = 0;
              a3 = 0;
              a3_1 = -1;
              strcpy(a3_3, &a1[2]);
              v250 = strlen(&a1[2]) + 1;
              if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                SendPlayerReliablePacket(playerr, &v311, v250 - 1 + 6, 1);
            }
            playerr->field_60 = -1;
            playerr->field_5C = -1;
          }
        }
      }
      else
      {
        LODWORD(buffer2_2) = ZonePlayerList[v242];
        if ( (_DWORD)buffer2_2 && *(_DWORD *)(buffer2_2 + 631) )
        {
          sprintf(&a1[2], "File arrived, forwarding: %s", *(const char **)((char *)&retaddr + 2) + 1);
          if ( *(_DWORD *)(buffer2_2 + 28) )
          {
            v311 = 7;
            v312 = 0;
            a3 = 0;
            a3_1 = -1;
            strcpy(a3_3, &a1[2]);
            v243 = strlen(&a1[2]) + 1;
            if ( GetRelAckDiff(*(struct CONNECTION **)(buffer2_2 + 40), 0) < 128 )
              SendPlayerReliablePacket((struct PLAYER *)buffer2_2, &v311, v243 - 1 + 6, 1);
          }
          v244 = (char *)emalloc(*(int *)((char *)&packet + 2));
          qmemcpy(
            v244 + 17,
            *(char **)((char *)&retaddr + 2) + 17,
            (unsigned int)(*(unsigned __int8 **)((char *)&packet + 2) - 17));
          *v244 = 0x10;                         // 0x10 - File Transfer
          PacketTypee_6 = (int)(v244 + 1);
          strcpy(v244 + 1, "pulled.dat");
          GetNewsRequest(*(struct CONNECTION **)(buffer2_2 + 40), v244, *(int *)((char *)&packet + 2), 0);
        }
        playerr->field_58 = -1;
      }
      return;
    case 0x17:                                  // 0x17 - Registration Form Response
      if ( *(unsigned __int8 **)((char *)&packet + 2) == (unsigned __int8 *)766 && BillingConnectionStructPointer )
        SendBillerUserDemographicsPacket(
          BillingConnectionStructPointer,
          playerr->BillerPlayerId,
          *(int *)((char *)&retaddr + 2) + 1,
          v295);
      return;
    case 0x18:                                  // 0x18 - Set ship type
      v207 = playerr->MyArena;
      if ( !v207 )
        return;
      v208 = v207->ServersideArenaSettings.MiscMaxLossesToPlay;
      if ( v208 > 0 && (unsigned __int16)playerr->CurrentLosses >= v208 )
        return;
      if ( playerr->IsSpeced )
        return;
      v209 = (*(unsigned __int8 **)((char *)&retaddr + 2))[1];
      if ( (char)v209 == *(_DWORD *)&playerr->Ship )
        return;
      if ( (_BYTE)v209 == 8 )
        goto LABEL_424;
      if ( !v207->ArenaLocked || playerr->IsSuperModerator )
      {
        if ( playerr->DemoPlayer && ((_BYTE)v209 == 5 || (_BYTE)v209 == 6 || (_BYTE)v209 == 4 || (_BYTE)v209 == 7) )
        {
          v311 = 7;                             // 0x07 - Chat
          v312 = 0;
          a3 = 0;
          a3_1 = -1;
          strcpy(a3_3, "Demo version of SubSpace does not allow the use of that ship type.");
          v40 = strlen("Demo version of SubSpace does not allow the use of that ship type.") + 6;
          if ( GetRelAckDiff(playerr->connection, 0) < 128 )
            goto LABEL_553;
        }
        else
        {
          GetPingLOSSSomething(
            playerr->connection,
            &playerr->S2CPacketLossPercentage,
            &playerr->C2SPacketLossPercentage);
          v207 = playerr->MyArena;
          if ( playerr->S2CPacketLossPercentage >= v207->ServersideArenaSettings.PacketLossS2CKickOutPercent
            && playerr->C2SPacketLossPercentage >= v207->ServersideArenaSettings.PacketLossC2SKickOutPercent
            || playerr->IsSysop )
          {
LABEL_424:
            playerr->DebtKills = v207->ServersideArenaSettings.KillDebtKills;
            v210 = (*(_BYTE **)((char *)&retaddr + 2))[1];
            if ( v210 > 8 || v210 < 0 )
            {
              if ( !playerr->IsSuperModerator )
              {
                sprintf(&a1[2], "Packet tampering(%d)", **(char **)((char *)&retaddr + 2));
                v293 = playerr;
LABEL_590:
                SendBillerWarnings(&a1[2], v293);
                v266 = playerr->MyArena;
                if ( v266 )
                {
                  if ( v266->ServersideArenaSettings.dwordB4 )
                    goto LABEL_683;
                }
              }
            }
            else
            {
              SetPlayerShip(playerr, v210);
            }
          }
          else if ( v207 )
          {
            v311 = 7;                           // 0x07 - Chat
            v312 = 0;
            a3 = 0;
            a3_1 = -1;
            strcpy(a3_3, "Packet loss too high for you to enter the game.");
            v40 = strlen("Packet loss too high for you to enter the game.") + 6;
            if ( GetRelAckDiff(playerr->connection, 0) < 128 )
              goto LABEL_553;
          }
        }
      }
      return;
    case 0x19:                                  // 0x19 - Set personal banner
      qmemcpy(
        playerr->PlayerDataBillerPacket.BannerData,
        *(char **)((char *)&retaddr + 2) + 1,
        sizeof(playerr->PlayerDataBillerPacket.BannerData));
      if ( BillingConnectionStructPointer )
        SendBillerUserBannerPacket(
          BillingConnectionStructPointer,
          playerr->BillerPlayerId,
          *(char **)((char *)&retaddr + 2) + 1);
      LOWORD(v296) = 0x1E;                      // 0x1E - Personal Banner Changed
                                                // Boolean ?Unknown? (0x00)
      SendPlayerReliablePacket(playerr, &v296, 2u, 1);
      v230 = playerr->MyArena;
      if ( v230
        && (playerr->FlagPoints + playerr->KillPoints >= v230->ServersideArenaSettings.MiscBannerPoints
         || playerr->ForceWearBanner) )
      {
        v231 = playerr->PlayerId;
        a1_252[2] = 0x1F;                       // 0x1F - Player Banner Changed
        *(_WORD *)&a1_252[3] = v231;            // PlayerId
        qmemcpy(&a1_252[5], playerr->PlayerDataBillerPacket.BannerData, 0x60u);// Banner Pixels
        ArenaSendPacket(v230, &a1_252[2], 99, 1);
      }
      return;
    case 0x1A:                                  // 0x1A - Security checksum
      if ( playerr->LastSecurityPacketReturnedTime )
      {
        v47 = GetTickCount();
        v51 = playerr->LastSecurityPacketReturnedTime;
        playerr->LastSecurityPacketReturnedTime = 0;
        LODWORD(buffer2_2) = v47 / 0xA - v51;
        playerr->SecurityWeaponCountTotal = playerr->SecurityWeaponCountyTotalNew;
        playerr->SecurityWeaponCount = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1);// Weapon Count
        qmemcpy(&playerr->SecurityPacketCache, *(void **)((char *)&retaddr + 2), sizeof(playerr->SecurityPacketCache));
        LOBYTE(v47) = (*(_BYTE **)((char *)&retaddr + 2))[39];// Slow Frame Detected (Boolean)
        if ( (_BYTE)v47 )
          goto LABEL_76;
        v52 = playerr->MyArena;
        if ( v52 && !playerr->IsSuperModerator && v52->SettingsChecksum )
        {
          v53 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 9);// Subspace.EXE Checksum
          v54 = playerr->SubspaceEXEChecksumIndex;
          if ( *(_DWORD *)&Security[0].ScrtyData[8 * v52->RandomScrtyDataIndex + 4 + v54 * 4036] != v53 )
          {
            v55 = 0;
            v56 = &Security[v54].ScrtyData[4];
            v57 = 500;
            do
            {
              if ( *(_DWORD *)v56 == v53 )
                v55 = 1;
              v56 += 8;
              --v57;
            }
            while ( v57 );
            if ( v55 )
              v292 = "WARNING: Code checksum mismatch - [%d] old match";
            else
              v292 = "WARNING: Code checksum mismatch - [%d] no possible match";
            sprintf(&a1[2], v292, *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 9));// Subspace.EXE Checksum
            SendBillerWarnings(&a1[2], playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          if ( playerr->MyArena->SettingsChecksum != *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 5) )// Settings Checksum
          {
            sprintf(&a1[2], "WARNING: Parameter checksum mismatch: TimeSinceRequest:%d0 ms", (_DWORD)buffer2_2);
            SendBillerWarnings(&a1[2], playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          v58 = *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 13);// Map.LVL Checksum
          if ( v58 != -12345678 && playerr->MyArena->MapLVLChecksum != v58 )
          {
            SendBillerWarnings("WARNING: Level checksum mismatch", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          v59 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 25);
          v60 = *(__int16 *)(*(char **)((char *)&retaddr + 2) + 27) + v59;
          v61 = playerr->MyArena;
          if ( v60 > (__int16)v61->ArenaSettings.ClientSlowPacketSampleSize
            && *(_DWORD *)&playerr->Ship != 8
            && 1000 * v59 / v60 > v61->ServersideArenaSettings.LatencyClientSlowPacketKickoutPercent )
          {
            if ( v61 )
            {
              v311 = 7;                         // 0x07 - Chat
              v312 = 0;
              a3 = 0;
              a3_1 = -1;
              strcpy(a3_3, "You have been put in spectator mode due to high latency (S2C)");
              v62 = strlen("You have been put in spectator mode due to high latency (S2C)") + 1;
              if ( GetRelAckDiff(playerr->connection, 0) < 128 )
                SendPlayerReliablePacket(playerr, &v311, v62 - 1 + 6, 1);
            }
            SetPlayerShip(playerr, 8);
          }
        }
      }
      return;
    case 0x1B:                                  // 0x1B - Security violation
      GenerateWarning(playerr, (*(char **)((char *)&retaddr + 2))[1]);
      return;
    case 0x1C:                                  // 0x1C - Drop Brick
      if ( *(_DWORD *)&playerr->Ship != 8 )
      {
        v44 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 1);
        if ( v44 < 0 || v44 >= 1024 || (v45 = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 3), v45 < 0) || v45 >= 1024 )
        {
          if ( !playerr->IsSuperModerator )
          {
            sprintf(&a1[2], "Packet tampering(%d)", PacketType);
            SendBillerWarnings(&a1[2], playerr);
            v46 = playerr->MyArena;
            if ( v46 )
            {
              if ( v46->ServersideArenaSettings.dwordB4 )
                goto LABEL_683;
            }
          }
        }
        else
        {
          DropBrick(playerr->MyArena, v44, v45, *(_DWORD *)&playerr->Frequency);
        }
      }
      return;
    case 0x1D:                                  // 0x1D - Change Certain Arena Settings
      if ( !playerr->IsSysop )
      {
        v38 = playerr->MyArena;
        v39 = v38->ServersideArenaSettings.OwnerUserId;
        if ( playerr->PlayerDataBillerPacket.UserId != v39 || v39 < 0 )
        {
          if ( !v38 )
            return;
          v311 = 7;                             // 0x07 - Chat
          v312 = 0;
          a3 = 0;
          a3_1 = -1;
          strcpy(a3_3, "Only the owner of this arena can change the settings.");
          v40 = strlen("Only the owner of this arena can change the settings.") + 6;
          if ( GetRelAckDiff(playerr->connection, 0) >= 128 )
            return;
LABEL_553:
          SendPlayerReliablePacket(playerr, &v311, v40, 1);
          return;
        }
      }
      v41 = *(char **)((char *)&retaddr + 2) + 1;
      if ( (*(_BYTE **)((char *)&retaddr + 2))[1] )
      {
        do
        {
          if ( v41 - *(_BYTE **)((char *)&retaddr + 2) >= *(int *)((char *)&packet + 2) )
            break;
          ChangeSettings(playerr->MyArena, playerr, v41);
          v42 = strlen(v41) + 1;
          v43 = v41[v42];
          v41 += v42;
        }
        while ( v43 );
      }
      if ( playerr->MyArena )
      {
        v311 = 7;                               // 0x07 - Chat
        v312 = 0;
        a3 = 0;
        a3_1 = -1;
        strcpy(a3_3, "Settings have been successfully changed.");
        v40 = strlen("Settings have been successfully changed.") + 6;
        if ( GetRelAckDiff(playerr->connection, 0) < 128 )
          goto LABEL_553;
      }
      return;
    case 0x1E:                                  // 0x1E - End Personal KoTH Timer
      v92 = playerr->KotHDeathCount;
      if ( v92 > 0 )
      {
        playerr->KotHDeathCount = v92 - 1;
        playerr->KingCrownKills = 0;
        if ( playerr->KotHDeathCount )
        {
          v95 = playerr->MyArena;
          LOBYTE(buffer2_2) = 0x2B;             // 0x2B - Set Personal KotH Timer
          *(_DWORD *)((char *)&buffer2_2 + 1) = v95->ServersideArenaSettings.KingExpireTime;
          SendPlayerReliablePacket(playerr, &buffer2_2, 5u, 1);
        }
        else
        {
          v93 = playerr->PlayerId;
          *(_DWORD *)((char *)&buffer2_2 + 2) = 0;// Timer Value
          v94 = playerr->MyArena;
          strcpy((char *)&buffer2_2, ",");      // 0x2C - KotH Game Reset
          HIWORD(buffer2_2) = v93;              // Player ID
          ArenaSendPacket(v94, (char *)&buffer2_2, 8, 1);
        }
      }
      return;
    case 0x1F:                                  // 0x1F - Fire a Ball
      arena = playerr->MyArena;
      if ( arena )
      {
        PowerBallIndex = *(int *)((char *)&retaddr + 2) + 1;// Ball ID
        v8 = (ARENA *)((char *)arena
                     + 12 * (*(char **)((char *)&retaddr + 2))[1]
                     + 3 * (*(char **)((char *)&retaddr + 2))[1]);
        if ( v8->SoccerBalls[0].PlayerId == *(_DWORD *)&playerr->PlayerId && !v8->SoccerBalls[0].StartTimeDelay )
        {
          v9 = v8->SoccerBalls;
          *(_DWORD *)&v9->PowerBallId = *(_DWORD *)PowerBallIndex;
          *(_QWORD *)((char *)&v9->YPixels + 1) = *(_QWORD *)(*(char **)((char *)&retaddr + 2) + 5);
          *(_WORD *)((char *)&v9->StartTimeDelay + 1) = *(_WORD *)(*(char **)((char *)&retaddr + 2) + 13);
          HIBYTE(v9->StartTimeDelay) = (*(_BYTE **)((char *)&retaddr + 2))[15];
          playerr->MyArena->SoccerBallTimers[*(char *)PowerBallIndex] = GetTickCount() / 0xA;
          v10 = playerr->MyArena;
          v11 = *(char *)PowerBallIndex;
          buffer[2] = 0x2E;                     // 0x2E  Power-Ball Position Update
          *(SOCCER_BALL *)&buffer[3] = *(SOCCER_BALL *)((char *)v10->SoccerBalls + 12 * v11 + 3 * v11);
          ArenaSendPacket(v10, &buffer[2], 16, 0);
        }
      }
      return;
    case 0x20:                                  // 0x20 - Ball request
      v32 = playerr->MyArena;
      if ( !v32 || *(_DWORD *)&playerr->Ship == 8 )
        return;
      v33 = v32->TotalSoccerBalls;              // It's a mess right now struct is wrong
      v34 = 0;
      if ( v33 <= 0 )
        goto LABEL_46;
      v35 = (int)&v32->SoccerBalls[0].PlayerId; // Start address The first SoccerBall
      while ( *(_DWORD *)(v35 + 2) || *(__int16 *)v35 != *(_DWORD *)&playerr->PlayerId )
      {
        ++v34;
        v35 += 15;
        if ( v34 >= v33 )
        {
LABEL_46:
          if ( *(int *)((char *)&v32->SoccerBalls[0].StartTimeDelay
                      + 12 * (*(char **)((char *)&retaddr + 2))[1]
                      + 3 * (*(char **)((char *)&retaddr + 2))[1]) == *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 2) )
          {
            if ( v32->ArenaPlayerCount > v32->ServersideArenaSettings.SoccerCatchMinimum )
              playerr->MySoccerReward += v32->ServersideArenaSettings.SoccerCatchPoints;
            playerr->MyArena->SoccerBalls[(*(char **)((char *)&retaddr + 2))[1]].StartTimeDelay = 0;
            playerr->MyArena->SoccerBalls[(*(char **)((char *)&retaddr + 2))[1]].PlayerId = playerr->PlayerId;
            playerr->MyArena->SoccerBalls[(*(char **)((char *)&retaddr + 2))[1]].XPixels = playerr->XPixels;
            playerr->MyArena->SoccerBalls[(*(char **)((char *)&retaddr + 2))[1]].YPixels = playerr->YPixels;
            playerr->MyArena->SoccerBallTimers[(*(char **)((char *)&retaddr + 2))[1]] = GetTickCount() / 0xA;
            v36 = playerr->MyArena;
            v37 = (*(char **)((char *)&retaddr + 2))[1];
            buffer[2] = 0x2E;                   // 0x2E - Power-Ball Position Update
            *(SOCCER_BALL *)&buffer[3] = *(SOCCER_BALL *)((char *)v36->SoccerBalls + 12 * v37 + 3 * v37);
            ArenaSendPacket(v36, &buffer[2], 0x10, 0);
          }
          return;
        }
      }
      return;
    case 0x21:                                  // 0x21 - Soccer goal scored
      v12 = playerr->MyArena;
      if ( v12 )
      {
        v13 = (ARENA *)((char *)v12
                      + 12 * (*(char **)((char *)&retaddr + 2))[1]
                      + 3 * (*(char **)((char *)&retaddr + 2))[1]);
        if ( v13->SoccerBalls[0].PlayerId == *(_DWORD *)&playerr->PlayerId )
        {
          if ( v13->SoccerBalls[0].StartTimeDelay )
          {
            v14 = v12->ArenaPlayerCount;
            v15 = 0;
            if ( v14 > 0 )
            {
              v16 = (PLAYER **)v12->playerPointersForSomething;
              do
              {
                if ( *(_DWORD *)&(*v16)->Ship != 8 )
                  ++v15;
                ++v16;
                --v14;
              }
              while ( v14 );
            }
            v17 = v12->ServersideArenaSettings.SoccerReward;
            if ( v17 >= 0 )
              v18 = v17 * v15 * v15 / 1000;
            else
              v18 = -v17;
            PacketTypee_6 = v18;
            if ( v18 )
            {
              sprintf(&Dest[2], "Team Goal! by %s  Reward:%d", playerr->PlayerDataBillerPacket.Name, v18);
              sprintf(&a1[2], "Enemy Goal! by %s  Reward:%d", playerr->PlayerDataBillerPacket.Name, v18);
            }
            else
            {
              sprintf(&Dest[2], "Team Goal! by %s", playerr->PlayerDataBillerPacket.Name);
              sprintf(&a1[2], "Enemy Goal! by %s", playerr->PlayerDataBillerPacket.Name);
            }
            v19 = playerr->MyArena;
            PacketTypee_14 = 0;
            if ( v19->ArenaPlayerCount > 0 )
            {
              v20 = (PLAYER **)64288;
              PacketTypee_10 = 64288;
              while ( 1 )
              {
                v21 = *(PLAYER **)&v19->PlayerPointers[(_DWORD)v20];// playerPointersForSomething
                if ( *(_DWORD *)&v21->Frequency != *(_DWORD *)&playerr->Frequency || *(_DWORD *)&v21->Ship == 8 )
                {
                  if ( v21->MyArena )
                  {
                    v311 = 7;                   // 0x07 - Chat
                    v312 = 0;
                    a3 = 104;
                    a3_1 = -1;
                    strcpy(a3_3, &a1[2]);
                    v24 = strlen(&a1[2]) + 1;
                    if ( GetRelAckDiff(v21->connection, 0) < 128 )// playerPointersForSomething
                      SendPlayerReliablePacket(v21, &v311, v24 - 1 + 6, 1);
                  }
                }
                else
                {
                  v21->FlagPoints += v18;       // playerPointersForSomething
                  ++(*(PLAYER **)((char *)v20 + (unsigned int)playerr->MyArena))->CurrentGoals;// playerPointersForSomething
                  v22 = *(PLAYER **)((char *)v20 + (unsigned int)playerr->MyArena);// playerPointersForSomething
                  if ( v22->MyArena )           // playerPointersForSomething
                  {
                    Dest_254[0] = 7;            // 0x07 - Chat
                    Dest_254[1] = 0;
                    Dest_254[2] = 104;
                    buf_1 = -1;
                    strcpy(&buf_3, &Dest[2]);
                    v23 = strlen(&Dest[2]) + 1;
                    if ( GetRelAckDiff(v22->connection, 0) < 128 )// playerPointersForSomething
                      SendPlayerReliablePacket(v22, Dest_254, v23 - 1 + 6, 1);
                  }
                }
                v19 = playerr->MyArena;
                v20 = (PLAYER **)(PacketTypee_10 + 4);
                v25 = (int)&PacketTypee_14->ProcessInformation + 1 < v19->ArenaPlayerCount;
                PacketTypee_14 = (PLAYER *)((char *)PacketTypee_14 + 1);
                PacketTypee_10 += 4;
                if ( !v25 )
                  break;
                v18 = PacketTypee_6;
              }
              packett = *(int *)((char *)&retaddr + 2);
              v18 = PacketTypee_6;
            }
            v26 = playerr->MyArena;
            if ( v26->ServersideArenaSettings.SoccerCapturePoints )
              SoccerGame2(v26, *(_DWORD *)&playerr->Frequency, *(__int16 *)(packett + 2), *(__int16 *)(packett + 4));
            if ( v18 )
            {
              v27 = playerr->Frequency;
              v28 = playerr->MyArena;
              LOBYTE(buffer2_2) = 0xB;          // 0x0B - Soccer Goal Made
              *(_WORD *)((char *)&buffer2_2 + 1) = v27;
              *(_DWORD *)((char *)&buffer2_2 + 3) = v18;
              ArenaSendPacket(v28, (char *)&buffer2_2, 7, 1);
            }
            v29 = playerr->MyArena;
            if ( v29->TotalSoccerBalls > 0 )
            {
              CreateSoccerBall(v29, *(char *)(packett + 1));
              playerr->MyArena->SoccerBallTimers[*(char *)(packett + 1)] = GetTickCount() / 0xA;
              v30 = playerr->MyArena;
              v31 = *(char *)(packett + 1);
              buffer[2] = 0x2E;                 // 0x2E - Power-Ball Position Update
              *(SOCCER_BALL *)&buffer[3] = *(SOCCER_BALL *)((char *)v30->SoccerBalls + 12 * v31 + 3 * v31);
              ArenaSendPacket(v30, &buffer[2], 0x10, 0);
            }
          }
        }
      }
      return;
    case 0x22:                                  // 0x22 - Security Violation Unknown
      if ( playerr->MyArena && !playerr->IsSuperModerator )
      {
        v47 = (*(unsigned __int8 **)((char *)&retaddr + 2))[17];
        if ( (_BYTE)v47 )
        {
LABEL_76:
          GenerateWarning(playerr, (char)v47);
        }
        else
        {
          if ( *(_DWORD *)&Security[playerr->SubspaceEXEChecksumIndex].ScrtyData[4] != *(_DWORD *)(*(char **)((char *)&retaddr + 2)
                                                                                                 + 9) )
          {
            SendBillerWarnings("WARNING: Code checksum mismatch (unsolicited)", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          v48 = 0;
          v49 = &playerr->MyArena->ArenaSettings;
          v50 = 357;
          do
          {
            v48 += v49->VersionAndManyBitFields;
            v49 = (ARENA_SETTINGS *)((char *)v49 + 4);
            --v50;
          }
          while ( v50 );
          if ( v48 != *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 5) )
          {
            SendBillerWarnings("WARNING: Parameter checksum mismatch (unsolicited)", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;
              playerr->AlreadySentReliablePacket = 1;
            }
          }
        }
      }
      return;
    default:
      if ( !playerr->IsSuperModerator )
      {
        sprintf(&a1[2], "Packet tampering(%d)", PacketType);
        SendBillerWarnings(&a1[2], playerr);
        v290 = playerr->MyArena;
        if ( v290 )
        {
          if ( v290->ServersideArenaSettings.dwordB4 )
          {
LABEL_683:
            playerr->DisconnectReason = 0x10;   // 0x10 - Restricted Zone, Compare against local Subspace.exe to determine if an Update is needed.
            playerr->AlreadySentReliablePacket = 1;
          }
        }
      }
      return;
  }
}
/* Orphan comments:
playerPointersForSomething
Weapon Info
Timer (Optional)
0x0A - Password Packet Response
0x05 - Permission Only Arena
0x0C - Offensive Name
0x0A - Password Packet Response
0x05 - Permission Only Arena
Server Version 134 = SubSpace 1.34
Registration Form Request (Boolean)
0x04 - Locked Out of Zone
0x04 - Locked Out of Zone
0x05 - Permission Only Arena
0x0E - Server Busy, try Later
0x0D - No Active Biller
? Unknown
*/
// 40B6DB: positive sp value 2 has been found
// 40B6C9: control flows out of bounds to 40B6CE
// 40AAF0: conditional instruction was optimized away because of 'esi.4!=0'
// 408E80: variables would overlap: ^720.4 and ^720.6
// 408E80: variables would overlap: ^71C.4(retaddr) and ^71E.4
// 4314B0: using guessed type int AdvertiseSendMode;
// 432004: using guessed type int RecycleServer;
// 437CA0: using guessed type int CommsMaxQueueToLogin;
// 438138: using guessed type int MiscMaxSharewarePlayer;
// 4386D4: using guessed type int MachineIdArrayCount;
// 438B1C: using guessed type int PermissionMode;
// 438B74: using guessed type int MiscMaxPlayers;
// 4AC448: using guessed type KICK KickedUsers[1000];
// 4AF32C: using guessed type int AutoPermissionPoints;
// 4D5900: using guessed type int PermissionAllowLowBandwidth;
// 4D590C: using guessed type int MiscJackpotBroadcastPoints;
// 4D5910: using guessed type int MiscRegisterKickShareware;
// 4D5918: using guessed type int MiscDisableShareware;
// 4D89C8: using guessed type int Wave;
// 4D8B14: using guessed type int dword_4D8B14;

//----- (0040CB80) --------------------------------------------------------
// Player.GenerateWarning()
void __thiscall GenerateWarning(struct PLAYER *player, int a2)
{
  int v3; // edx
  char *securityResult; // eax
  ARENA *v5; // ecx
  int v6; // eax
  ARENA *v7; // eax
  char a1[256]; // [esp+8h] [ebp-100h] BYREF

  if ( !player->IsSuperModerator )
  {
    v3 = 1;
    securityResult = "Unknown integrity violation";
    switch ( a2 )
    {
      case 0:
        securityResult = "Normal integrity";
        goto LABEL_33;
      case 1:
        securityResult = "Slow frame detected";
        goto LABEL_33;
      case 2:
        securityResult = "Current energy higher than top energy";
        goto LABEL_33;
      case 3:
        securityResult = "Top energy higher than max energy";
        goto LABEL_33;
      case 4:
        securityResult = "Max energy without getting prizes";
        goto LABEL_33;
      case 5:
        securityResult = "Recharge rate higher than max recharge rate";
        goto LABEL_33;
      case 6:
        securityResult = "Max recharge rate without getting prizes";
        goto LABEL_33;
      case 7:
        securityResult = "Too many burst used";
        goto LABEL_33;
      case 8:
        securityResult = "Too many repel used";
        goto LABEL_33;
      case 9:
        securityResult = "Too many decoy used";
        goto LABEL_33;
      case 10:
        securityResult = "Too many thor used";
        goto LABEL_33;
      case 11:
        securityResult = "Too many wall blocks used";
        goto LABEL_33;
      case 12:
        securityResult = "Stealth on but never collected";
        goto LABEL_33;
      case 13:
        securityResult = "Cloak on but never collected";
        goto LABEL_33;
      case 14:
        securityResult = "XRadar on but never collected";
        goto LABEL_33;
      case 15:
        securityResult = "AntiWarp on but never collected";
        goto LABEL_33;
      case 16:
        securityResult = "Proximity bombs but never collected";
        goto LABEL_33;
      case 17:
        securityResult = "Bouncing bullets but never collected";
        goto LABEL_33;
      case 18:
        securityResult = "Max guns without getting prizes";
        goto LABEL_33;
      case 19:
        securityResult = "Max bombs without getting prizes";
        goto LABEL_33;
      case 20:
        securityResult = "Shields or Super on longer than possible";
        goto LABEL_33;
      case 21:
        v3 = 0;
        securityResult = "Saved ship weapon limits too high (burst/repel/etc)";
        goto LABEL_33;
      case 22:
        v3 = 0;
        securityResult = "Saved ship weapon level too high (guns/bombs)";
        goto LABEL_33;
      case 23:
        v3 = 0;
        securityResult = "Login checksum mismatch (program exited)";
        goto LABEL_33;
      case 24:
        v5 = player->MyArena;
        v6 = player->CurrentSecurityPacketModifcationCount + 1;
        player->CurrentSecurityPacketModifcationCount = v6;
        if ( v6 < v5->ServersideArenaSettings.SecurityPacketModificationMax )
          return;
        securityResult = "S2C position packet modified";
LABEL_33:
        if ( !player->field_309 || !v3 )
        {
          sprintf(a1, "WARNING: %s", securityResult);
          SendBillerWarnings(a1, player);
          v7 = player->MyArena;
          if ( v7 )
          {
            if ( v7->ServersideArenaSettings.dwordB4 )
            {
              player->DisconnectReason = 3;
              player->AlreadySentReliablePacket = 1;
            }
          }
        }
        break;
      case 25:
        v3 = 0;
        securityResult = "Saved ship checksum mismatch";
        goto LABEL_33;
      case 26:
        securityResult = "Softice Debugger Running";
        goto LABEL_33;
      case 27:
        securityResult = "Data checksum mismatch detected";
        goto LABEL_33;
      case 28:
        securityResult = "Parameter mismatch detected";
        goto LABEL_33;
      default:
        goto LABEL_33;
    }
  }
}

//----- (0040CDB0) --------------------------------------------------------
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr)
{
  ARENA *arena; // ecx
  int XPixels; // eax
  int powerBallId; // ebx
  int v5; // edi
  struct ARENA *v6; // ecx
  int v7; // [esp+8h] [ebp-18h]
  int YPixels; // [esp+Ch] [ebp-14h]
  char buf[16]; // [esp+10h] [ebp-10h] BYREF

  arena = playerr->MyArena;
  if ( arena )
  {
    XPixels = playerr->XPixels;
    YPixels = playerr->YPixels;
    powerBallId = 0;
    v7 = XPixels;
    if ( arena->TotalSoccerBalls > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        if ( !arena->SoccerBalls[v5].StartTimeDelay && arena->SoccerBalls[v5].PlayerId == *(_DWORD *)&playerr->PlayerId )
        {
          if ( XPixels <= 0 || YPixels <= 0 )
          {
            CreateSoccerBall(arena, powerBallId);
          }
          else
          {
            arena->SoccerBalls[v5].PowerBallId = powerBallId;
            playerr->MyArena->SoccerBalls[v5].XPixels = XPixels;
            *(_DWORD *)&playerr->MyArena->SoccerBalls[v5].YPixels = (unsigned __int16)YPixels;
            playerr->MyArena->SoccerBalls[v5].YVelocity = 0;
            playerr->MyArena->SoccerBalls[v5].PlayerId = playerr->PlayerId;
            playerr->MyArena->SoccerBalls[v5].StartTimeDelay = GetTickCount() / 0xA;
            playerr->MyArena->SoccerBallTimers[powerBallId] = GetTickCount() / 0xA;
            v6 = playerr->MyArena;
            buf[0] = 0x2E;
            *(_DWORD *)&buf[1] = *(_DWORD *)&v6->SoccerBalls[v5].PowerBallId;
            *(_DWORD *)&buf[5] = *(_DWORD *)((char *)&v6->SoccerBalls[v5].YPixels + 1);
            *(_DWORD *)&buf[9] = *(_DWORD *)((char *)&v6->SoccerBalls[v5].YVelocity + 1);
            *(_WORD *)&buf[13] = *(_WORD *)((char *)&v6->SoccerBalls[v5].StartTimeDelay + 1);
            buf[15] = HIBYTE(v6->SoccerBalls[v5].StartTimeDelay);
            ArenaSendPacket(v6, buf, 16, 0);
          }
        }
        arena = playerr->MyArena;
        ++powerBallId;
        ++v5;
        if ( powerBallId >= arena->TotalSoccerBalls )
          break;
        XPixels = v7;
      }
    }
  }
}

//----- (0040CF10) --------------------------------------------------------
bool __thiscall sub_40CF10(struct PLAYER *player)
{
  bool result; // al
  DWORD (__stdcall *GetTickCountt)(); // ebx
  __int64 v4; // rax
  __int64 v5; // rax
  DWORD v6; // eax
  unsigned int v7; // kr08_4
  FILE *v8; // ebx
  unsigned int v9; // kr10_4
  signed int v10; // esi
  __int64 v11; // rax
  ARENA *v12; // esi
  unsigned int v13; // kr28_4
  int *v14; // ebx
  int *v15; // esi
  int v16; // edi
  ARENA *v17; // eax
  unsigned int v18; // kr30_4
  int v19; // eax
  int v20; // esi
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  ARENA *v24; // eax
  int v25; // esi
  unsigned int v26; // [esp-8h] [ebp-524h]
  const char *v27; // [esp-8h] [ebp-524h]
  char *v28; // [esp-4h] [ebp-520h]
  char v29; // [esp+13h] [ebp-509h] BYREF
  int i; // [esp+14h] [ebp-508h]
  DWORD ExitCode; // [esp+18h] [ebp-504h] BYREF
  char buf[512]; // [esp+1Ch] [ebp-500h] BYREF
  char Dest[6]; // [esp+21Ch] [ebp-300h] BYREF
  char Buf[512]; // [esp+31Ch] [ebp-200h] BYREF

  if ( player->field_287 > 0 )
    HighestPlayerCountMaybeSomething = 1;
  if ( player->AlreadySentReliablePacket )
    return 1;
  GetTickCountt = GetTickCount;
  if ( player->KickOffDelayTimer )
  {
    v4 = (int)(GetTickCount() / 0xA - player->KickOffDelayTimer);
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) > 1000 )
    {
      printf("KickOffTime expired: %s\n", player->PlayerName);
      return 1;
    }
  }
  if ( !player->PlayerName[0] )
  {
    v5 = (int)(GetTickCount() / 0xA - player->NoPasswordPacketDelayTimer);
    if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 300 )
    {
      printf("No password packet delay exceeded\n");
      player->DisconnectReason = 17;
      return 1;
    }
  }
  if ( !player->MyArena )
  {
    if ( (int)abs32(GetTickCount() / 0xA - player->connection->MenuKickOutDelayTimer) > MiscMenuKickOutDelay )
    {
      v28 = player->PlayerName;
      v27 = "Menu kickout delay exceeded: %s\n";
      goto LABEL_74;
    }
LABEL_72:
    if ( CheckIfBillingServerIsConnected((int)player->connection) != 4 )
      return 0;
    v28 = player->PlayerName;
    v27 = "Connection status read as terminated: %s\n";
LABEL_74:
    printf(v27, v28);                           // Could be 2 different messages above.
    result = 1;
    player->DisconnectReason = 1;
    return result;
  }
  if ( player->ProcessInformation && GetExitCodeProcess(player->ProcessInformation, &ExitCode) && ExitCode != 259 )
  {
    TerminateProcess(player->ProcessInformation, 0);
    CloseHandle(player->ProcessInformation);
    v6 = ExitCode;
    player->ProcessInformation = 0;
    player->dword4 = 0;
    player->dword8 = 0;
    player->dwordC = 0;
    sprintf(Dest, "SPAWN TERMINATED: %d", v6);
    if ( player->MyArena )
    {
      Buf[0] = 7;
      Buf[1] = 0;
      Buf[2] = 0;
      *(_WORD *)&Buf[3] = -1;
      strcpy(&Buf[5], Dest);
      v7 = strlen(Dest) + 1;
      if ( GetRelAckDiff(player->connection, 0) < 128 )
        SendPlayerReliablePacket(player, Buf, v7 - 1 + 6, 1);
    }
    v8 = fopen("spawn.log", "rt");
    if ( v8 )
    {
      for ( i = 0; i < 40; ++i )
      {
        Buf[0] = 0;
        fgets(Buf, 256, v8);
        if ( player->MyArena )
        {
          buf[0] = 7;                           // 0x07 - Chat
          buf[1] = 0;
          buf[2] = 0;
          *(_WORD *)&buf[3] = -1;
          strcpy(&buf[5], Buf);
          v9 = strlen(Buf) + 1;
          if ( GetRelAckDiff(player->connection, 0) < 128 )
            SendPlayerReliablePacket(player, buf, v9 - 1 + 6, 1);
        }
        if ( (v8->_flag & 0x10) != 0 )
          break;
      }
      fclose(v8);
    }
    GetTickCountt = GetTickCount;
  }
  v10 = abs32(GetTickCountt() / 0xA - player->connection->MenuKickOutDelayTimer);
  if ( v10 > player->MyArena->ServersideArenaSettings.LatencyNoFlagDelay )
    player->field_15B = GetTickCountt() / 0xA;
  if ( v10 <= player->MyArena->ServersideArenaSettings.LatencyKickOutDelay
    || player->IsSysop && (int)abs32(GetTickCountt() / 0xA - player->connection->MenuKickOutDelayTimer) <= 6000 )
  {
    if ( player->DemoPlayer )
    {
      v11 = (int)(GetTickCountt() / 0xA - player->NoPasswordPacketDelayTimer);
      if ( (int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) > MiscMaxSharkwareTime )
      {
        WriteSubGameLog("Shareware Timer Expired: %s\n", player->PlayerName);
        *(_WORD *)&buf[3] = player->PlayerId;
        player->DisconnectReason = 22;
        buf[0] = 7;
        buf[1] = 0;
        buf[2] = 0;
        strcpy(
          &buf[5],
          "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.");
        v26 = strlen(
                "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.")
            + 6;
        goto LABEL_82;
      }
    }
    if ( (int)abs32(GetTickCountt() / 0xA - player->connection->KeepAliveDelayTimer) > MiscKeepAliveDelay )
    {
      v29 = 0x27;                               // 0x27 - Keep-Alive, Single byte packet
      SendPlayerReliablePacket(player, &v29, 1u, 0);
    }
    if ( *(_DWORD *)&player->Ship != 8 )
    {
      if ( player->LatencyKickOutDelayTimer )
      {
        v12 = player->MyArena;
        if ( (signed int)(GetTickCountt() / 0xA - player->LatencyKickOutDelayTimer) > v12->ServersideArenaSettings.LatencyKickOutTime
          && !player->IsSysop )
        {
          if ( v12 )
          {
            buf[0] = 7;                         // 0x07 - Chat
            buf[1] = 0;
            buf[2] = 0;
            *(_WORD *)&buf[3] = -1;
            strcpy(&buf[5], "You have been put in spectator mode due to high latency (spike)");
            v13 = strlen("You have been put in spectator mode due to high latency (spike)") + 1;
            if ( GetRelAckDiff(player->connection, 0) < 128 )
              SendPlayerReliablePacket(player, buf, v13 - 1 + 6, 1);
          }
          SetPlayerShip(player, 8);
        }
      }
    }
    v14 = &player->C2SPacketLossPercentage;
    v15 = &player->S2CPacketLossPercentage;
    GetPingLOSSSomething(player->connection, &player->S2CPacketLossPercentage, &player->C2SPacketLossPercentage);
    v16 = 0;
    if ( *(_DWORD *)&player->Ship == 8 )
      v16 = player->MyArena->ServersideArenaSettings.PacketLossSpectatorPercentAdjust;
    v17 = player->MyArena;
    if ( (*v15 < v17->ServersideArenaSettings.PacketLossS2CKickOutPercent - v16
       || *v14 < v17->ServersideArenaSettings.PacketLossC2SKickOutPercent - v16
       || *v14 > v17->ServersideArenaSettings.PacketLossC2SNegativeKickOutPercent + v16 + 1000)
      && !player->IsSysop )
    {
      if ( *(_DWORD *)&player->Ship == 8 )
      {
        WriteSubGameLog(
          "Packet loss too high S2C:%d%%, C2S:%d%%, kicking out player: %s\n",
          (1000 - *v15) / 10,
          (1000 - *v14) / 10,
          player->PlayerName);
        v24 = player->MyArena;
        v25 = *v15;
        if ( v25 >= v24->ServersideArenaSettings.PacketLossS2CKickOutPercent - v16 )
        {
          if ( *v14 <= v24->ServersideArenaSettings.PacketLossC2SNegativeKickOutPercent + v16 + 1000 )
            player->DisconnectReason = 7;
          else
            player->DisconnectReason = 23;
        }
        else
        {
          player->DisconnectReason = 6;
        }
        sprintf(
          Dest,
          "WARNING: Disconnected because of high packet loss (ServerToYou:%d%%, YouToServer:%d%%)",
          (1000 - v25) / 10,
          (1000 - *v14) / 10);
        *(_WORD *)&buf[3] = player->PlayerId;
        buf[0] = 7;                             // 0x07 - Chat
        buf[1] = 0;
        buf[2] = 0;
        strcpy(&buf[5], Dest);
        v26 = strlen(Dest) + 6;
        goto LABEL_82;
      }
      if ( v17 )
      {
        buf[0] = 7;                             // 0x07 - Chat
        buf[1] = 0;
        buf[2] = 0;
        *(_WORD *)&buf[3] = -1;
        strcpy(&buf[5], "You have been put in spectator mode due to high packet loss");
        v18 = strlen("You have been put in spectator mode due to high packet loss") + 1;
        if ( GetRelAckDiff(player->connection, 0) < 128 )
          SendPlayerReliablePacket(player, buf, v18 - 1 + 6, 1);
      }
      SetPlayerShip(player, 8);
    }
    v19 = *v14;
    if ( *v14 >= 1000 )
      v19 = 1000;
    v20 = player->S2CPacketLossPercentage;
    v21 = v19 - v20;
    player->field_153 = v21;
    if ( v20 > 900 || player->IsSysop || v21 < 0 )
      player->field_153 = 0;
    if ( v20 < 1000 )
    {
      v22 = player->SecurityWeaponCountTotal;
      if ( v22 > 400 && *(_DWORD *)&player->Ship != 8 )
      {
        v23 = 1000 * player->SecurityWeaponCount / v22;
        if ( v20 - v23 > 100
          && v23 < player->MyArena->ServersideArenaSettings.SecurityS2CKickOutPercentWeapons
          && !player->IsSysop )
        {
          sprintf(Dest, "S2C weapon packet loss too high(S2CW=%d%%)(S2C=%d%%)", (1000 - v23) / 10, (1000 - v20) / 10);
          SendBillerWarnings(Dest, player);
          player->DisconnectReason = 3;
          return 1;
        }
      }
    }
    goto LABEL_72;
  }
  WriteSubGameLog("Kickout delay exceeded: %s\n", player->PlayerName);
  player->DisconnectReason = 9;
  *(_WORD *)&buf[3] = player->PlayerId;
  buf[0] = 7;                                   // 0x07 - Chat
  buf[1] = 0;
  buf[2] = 0;
  strcpy(&buf[5], "WARNING: You have been disconnected because server has not been receiving data from you.");
  v26 = strlen("WARNING: You have been disconnected because server has not been receiving data from you.") + 6;
LABEL_82:
  SendPlayerReliablePacket(player, buf, v26, 0);
  sub_41CB20(player->connection);
  return 1;
}
/* Orphan comments:
(1000 - v38) / 10)
(1000 - v40) / 10)
*/
// 4AF328: using guessed type int MiscKeepAliveDelay;
// 4D55D4: using guessed type int MiscMaxSharkwareTime;
// 4D55D8: using guessed type int MiscMenuKickOutDelay;
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;

//----- (0040D870) --------------------------------------------------------
void __thiscall sub_40D870(struct PLAYER *playerr)
{
  ARENA *arena; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  __int64 v9; // rax
  int v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // ebx
  struct ARENA *v14; // ecx

  arena = playerr->MyArena;
  v3 = playerr->XPixels - arena->CalculatedMapZoomFactor;
  playerr->LooksLikeX1BigOfSomething = v3;
  if ( v3 < 0 )
    playerr->LooksLikeX1BigOfSomething = 0;
  v4 = 2 * (0x2000 - arena->CalculatedMapZoomFactor);
  if ( playerr->LooksLikeX1BigOfSomething > v4 )
    playerr->LooksLikeX1BigOfSomething = v4;
  v5 = playerr->YPixels - arena->CalculatedMapZoomFactor;
  playerr->LooksLikeYBigOfSomething = v5;
  if ( v5 < 0 )
    playerr->LooksLikeYBigOfSomething = 0;
  v6 = 2 * (0x2000 - arena->CalculatedMapZoomFactor);
  if ( playerr->LooksLikeYBigOfSomething > v6 )
    playerr->LooksLikeYBigOfSomething = v6;
  v7 = playerr->LooksLikeYBigOfSomething;
  playerr->LooksLikeXSmallOfSomething = playerr->LooksLikeX1BigOfSomething + 2 * arena->CalculatedMapZoomFactor;
  v8 = v7 + 2 * arena->CalculatedMapZoomFactor;
  playerr->LooksLikeYSmallOfSomething = v8;
  if ( arena )
  {
    v9 = playerr->LooksLikeX1BigOfSomething + playerr->LooksLikeXSmallOfSomething;
    v10 = (WORD2(v9) & 0xFFF) + v9;
    v11 = playerr->field_50;
    v12 = v10 >> 12;
    v13 = (v8 + playerr->LooksLikeYBigOfSomething) / 4096;
    if ( v12 != v11 || v13 != playerr->field_54 )
    {
      sub_404980(arena, playerr, v11, playerr->field_54);
      v14 = playerr->MyArena;
      playerr->field_50 = v12;
      playerr->field_54 = v13;
      AddPlayerToArenaSomething(v14, playerr, v12, v13);
    }
  }
}

//----- (0040D980) --------------------------------------------------------
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency)
{
  signed int NewFrequencyyy; // edi
  ARENA *arena; // esi
  PLAYER **v5; // ecx
  int v6; // edx
  int v7; // eax
  signed int v8; // ecx
  signed int v9; // eax
  unsigned int v10; // kr08_4
  int v11; // ecx
  int v12; // edx
  PLAYER **v13; // eax
  int v14; // ecx
  __int16 v15; // ax
  ARENA *v16; // ecx
  __int16 v17; // dx
  char buf[6]; // [esp+10h] [ebp-20Ch] BYREF
  char v19[3]; // [esp+18h] [ebp-204h] BYREF
  _DWORD buffer[128]; // [esp+1Ch] [ebp-200h] BYREF

  NewFrequencyyy = NewFrequency;
  arena = player->MyArena;
  if ( NewFrequency >= arena->ArenaSettings.MaxFrequency )
    return;
  if ( (int)arena->ServersideArenaSettings.TeamForceEvenTeams > 0 && !player->IsSuperModerator )
  {
    memset(buffer, 0, 0x100u);
    if ( arena->ArenaPlayerCount > 0 )
    {
      v5 = (PLAYER **)arena->playerPointersForSomething;
      v6 = arena->ArenaPlayerCount;
      do
      {
        v7 = *(_DWORD *)&(*v5)->Frequency;
        if ( v7 < 64 )
          ++buffer[v7];
        ++v5;
        --v6;
      }
      while ( v6 );
    }
    v8 = *(_DWORD *)&player->Frequency;
    v9 = arena->ServersideArenaSettings.TeamDesiredTeams;
    if ( v8 < v9
      && NewFrequency < v9
      && v9 < 64
      && buffer[v8] + arena->ServersideArenaSettings.TeamForceEvenTeams - 1 <= buffer[NewFrequency] )
    {
      if ( arena )
      {
        strcpy((char *)buffer, "\a");           // 0x07 - Chat
        BYTE2(buffer[0]) = 0;
        *(_WORD *)((char *)buffer + 3) = -1;
        strcpy((char *)&buffer[1] + 1, "Changing frequencies would make the teams too uneven.");
        v10 = strlen("Changing frequencies would make the teams too uneven.") + 1;
        if ( GetRelAckDiff(player->connection, 0) < 128 )
          SendPlayerReliablePacket(player, buffer, v10 - 1 + 6, 1);
      }
      return;
    }
    NewFrequencyyy = NewFrequency;
  }
  player->DebtKills = arena->ServersideArenaSettings.KillDebtKills;
  v11 = arena->ArenaPlayerCount;
  v12 = 0;
  if ( v11 > 0 )
  {
    v13 = (PLAYER **)arena->playerPointersForSomething;
    do
    {
      if ( *(_DWORD *)&(*v13)->Frequency == NewFrequencyyy )
        ++v12;
      ++v13;
      --v11;
    }
    while ( v11 );
  }
  v14 = (unsigned __int8)arena->ArenaSettings.MaxPerTeam;
  if ( arena->ArenaSettings.MaxPerPrivateTeam )
    v14 = (unsigned __int8)arena->ArenaSettings.MaxPerPrivateTeam;
  if ( v12 < v14 || player->IsSysop )
  {
    v15 = player->PlayerId;
    *(_DWORD *)&player->Frequency = NewFrequencyyy;
    buf[0] = 0xD;                               // 0x0D - Player Changed Frequency
    *(_WORD *)&buf[1] = v15;                    // Player ID
    *(_WORD *)&buf[3] = NewFrequencyyy;         // Frequency
    buf[5] = -1;                                // Ship
    if ( arena->ServersideArenaSettings.MiscFrequencyShipTypes && *(_DWORD *)&player->Ship != 8 )
    {
      *(_DWORD *)&player->Ship = NewFrequencyyy % 8;// Either (Freq % -8) or (Freq & 7) is correct here, -8 is a power of 2 so it works perfect.
      buf[5] = player->Ship;                    // Ship
    }
    ArenaSendPacket(arena, buf, 6, 1);
    CarryFlagsSomething(player->MyArena, *(_DWORD *)&player->PlayerId, 0);
    UpdatePowerBallPositionsSomething(player);
    v16 = player->MyArena;
    if ( v16->ServersideArenaSettings.MiscResetScoreOnFrequencyChange )
    {
      v17 = player->PlayerId;
      player->CurrentLosses = 0;
      player->CurrentWins = 0;
      player->KillPoints = 0;
      player->FlagPoints = 0;
      player->CurrentGoals = 0;
      player->ScoreReset = 1;
      v19[0] = 0x1A;                            // Player ID
      *(_WORD *)&v19[1] = v17;
      if ( v16 )
        ArenaSendPacket(v16, v19, 3, 1);
    }
  }
}

//----- (0040DC00) --------------------------------------------------------
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship)
{
  __int16 v3; // ax
  struct ARENA *v4; // ecx
  __int16 v5; // ax
  __int16 v6; // dx
  ARENA *v7; // ecx
  __int16 v8; // si
  ARENA *v9; // esi
  unsigned int v10; // kr08_4
  __int16 v11; // ax
  ARENA *v12; // ecx
  int v13; // esi
  char buffer2[6]; // [esp+10h] [ebp-210h] BYREF
  char buffer1[5]; // [esp+18h] [ebp-208h] BYREF
  char buf[512]; // [esp+20h] [ebp-200h] BYREF

  if ( *(int *)&player->AttachedToPlayerId >= 0 )
  {
    v3 = player->PlayerId;
    v4 = player->MyArena;
    buffer1[0] = 0xE;                           // 0x0E - Create Turret Link
    *(_WORD *)&buffer1[3] = -1;
    *(_WORD *)&buffer1[1] = v3;
    *(_DWORD *)&player->AttachedToPlayerId = -1;
    ArenaSendPacket(v4, buffer1, 5, 1);
  }
  LOBYTE(v5) = Ship;
  v6 = player->PlayerId;
  buffer2[0] = 0x1D;                            // 0x1D - Player Team and Ship Changed
  *(_WORD *)&buffer2[2] = v6;
  buffer2[1] = Ship;
  if ( (_BYTE)Ship == 8 )                       // Spec Ship
  {
    v7 = player->MyArena;
    v8 = v7->ServersideArenaSettings.TeamSpectatorFrequency;
    *(_WORD *)&buffer2[4] = v8;
LABEL_18:
    *(_DWORD *)&player->Ship = (char)v5;
    *(_DWORD *)&player->AttachedToPlayerId = -1;
    player->ArenaPlayerIndex = -1;
    *(_DWORD *)&player->Frequency = v8;
    ArenaSendPacket(v7, buffer2, 6, 1);
    CarryFlagsSomething(player->MyArena, *(_DWORD *)&player->PlayerId, 0);
    UpdatePowerBallPositionsSomething(player);
    v12 = player->MyArena;
    v13 = player->TotalShipChanges + 1;
    player->TotalShipChanges = v13;
    if ( v13 > v12->ServersideArenaSettings.SecurityMaxShipTypeSwitchCount )
    {
      WriteSubGameLog("Played kicked off for too many ship type changes: %s\n", player->PlayerName);
      *(_WORD *)&buf[3] = player->PlayerId;
      player->DisconnectReason = 15;
      player->AlreadySentReliablePacket = 1;
      buf[0] = 7;                               // 0x07 - Chat
      buf[1] = 0;
      buf[2] = 0;
      strcpy(&buf[5], "WARNING: You have been disconnected for too many ship type changes.");
      SendPlayerReliablePacket(
        player,
        buf,
        strlen("WARNING: You have been disconnected for too many ship type changes.") + 6,
        0);
      sub_41CB20(player->connection);
    }
    return;
  }
  if ( *(_DWORD *)&player->Ship != 8 )          // Any Ship other then Spec
  {
    v7 = player->MyArena;
    if ( v7->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      PlayerChangeFrequency(player, Ship);
      return;
    }
    v8 = player->Frequency;
    *(_WORD *)&buffer2[4] = v8;
    goto LABEL_18;
  }
  if ( player->IsModerator
    || (int)player->MyArena->ServersideArenaSettings.MiscMaxPlaying <= 0
    || (v9 = player->MyArena, GetTotalPlayingPlayers(v9) <= v9->ServersideArenaSettings.MiscMaxPlaying) )
  {
    v11 = GetNextFrequencyToJoin(player->MyArena);
    v7 = player->MyArena;
    v8 = v11;                                   // 0x07 - Chat
    *(_WORD *)&buffer2[4] = v11;
    if ( v7->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      v5 = v11 % 8;                             // Either (Freq % -8) or (Freq & 7) is correct here, -8 is a power of 2 so it works perfect.
      buffer2[1] = v5;
    }
    else
    {
      LOBYTE(v5) = buffer2[1];
    }
    goto LABEL_18;
  }
  if ( v9 )
  {
    *(_WORD *)&buf[3] = -1;
    buf[0] = 7;
    buf[1] = 0;
    buf[2] = 0;
    strcpy(&buf[5], "There are too many people playing the game right now, try again later.");
    v10 = strlen("There are too many people playing the game right now, try again later.") + 1;
    if ( GetRelAckDiff(player->connection, 0) < 128 )
      SendPlayerReliablePacket(player, buf, v10 - 1 + 6, 1);
  }
}

//----- (0040DEA0) --------------------------------------------------------
void __thiscall sub_40DEA0(struct PLAYER *player, const void *buf, unsigned int len, int a4)
{
  ARENA *v5; // eax

  if ( !player->field_309 )
  {
    v5 = player->MyArena;
    if ( v5 )
    {
      if ( a4 == 21 && (*((_BYTE *)buf + 19) & 0x1F) != 0 )
      {
        ++player->SecurityWeaponCountyTotalNew;
        if ( player->S2CPacketLossPercentage < v5->ServersideArenaSettings.RoutingDoubleSendPercent )
        {
          SendPlayerReliablePacket(player, buf, len, 0);
          ++player->SecurityWeaponCountyTotalNew;
          ++dword_4C8F38;
          sub_41CB20(player->connection);
        }
      }
      SendPlayerReliablePacket(player, buf, len, 0);
    }
  }
}
// 4C8F38: using guessed type int dword_4C8F38;

//----- (0040DF30) --------------------------------------------------------
void __thiscall SendPlayerReliablePacket(struct PLAYER *playerr, const void *buf, unsigned int len, int a4)
{
  struct ARENA *v5; // eax
  int v6; // eax

  if ( a4
    || !playerr->field_309
    && ((v5 = playerr->MyArena) == 0
     || playerr->connection->RatioBytesSent <= v5->ServersideArenaSettings.LatencyCutbackWatermark
     || *(_BYTE *)buf == 5) )
  {
    if ( !WriteData(playerr->connection, buf, len, a4) && a4 )
    {
      WriteSubGameLog(
        "Reliable packet lost(%d) to: %s (pending=%d current=%d diff=%d)\n",
        *(unsigned __int8 *)buf,
        playerr->PlayerDataBillerPacket.Name,
        playerr->connection->ReliablePacketsPending,
        playerr->connection->ReliablePacketsCurrent,
        playerr->connection->ReliablePacketsCurrent - playerr->connection->ReliablePacketsPending);
      v6 = playerr->IsSysop;
      playerr->DisconnectReason = 8;
      playerr->AlreadySentReliablePacket = 1;
      if ( v6 )
        LogReliablePackets(playerr->connection, "reliable.txt");
    }
    ++TotalSentForEachPacketType[*(char *)buf]; // All Packet Types Sent (I guess used for packet statistics)
    TotalSentSizeForEachPacketType[*(char *)buf] += len;// All Packet Types Sizes Sent (I guess used for packet statistics)
  }
}

//----- (0040E000) --------------------------------------------------------
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6)
{
  if ( (!a5 || !player->AllowAudioByte2) && (!a6 || *(_DWORD *)&player->Ship == 8) )
    SendPlayerReliablePacket(player, buf, len, a4);
}

//----- (0040E040) --------------------------------------------------------
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4)
{
  ARENA *arena; // eax
  int v6; // ebx
  int v7; // edi
  struct PLAYER *v8; // eax

  arena = player->MyArena;
  if ( arena )
  {
    v6 = 0;
    if ( arena->ArenaPlayerCount > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(struct PLAYER **)&arena->PlayerPointers[v7];// playerPointersForSomething
        if ( v8 != player && !v8->AlreadySentReliablePacket )
          SendPlayerReliablePacket(v8, buf, len, a4);
        arena = player->MyArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < arena->ArenaPlayerCount );
    }
  }
}

//----- (0040E0A0) --------------------------------------------------------
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend)
{
  ARENA *v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // eax

  v5 = player->MyArena;
  if ( v5 )
  {
    v6 = 0;
    if ( v5->ArenaPlayerCount > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(_DWORD *)&v5->PlayerPointers[v7];
        if ( (struct PLAYER *)v8 != player && *(_DWORD *)(v8 + 279) == *(_DWORD *)&player->Frequency )
          SendPlayerReliablePacket((struct PLAYER *)v8, buf, len, IsReliableSend);
        v5 = player->MyArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < v5->ArenaPlayerCount );
    }
  }
}

//----- (0040E110) --------------------------------------------------------
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  ARENA *v7; // eax
  int v8; // ebp
  PLAYER *v9; // ecx
  PLAYER *v10; // esi
  int v11; // edx
  int v12; // edx
  signed int v13; // edi
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // [esp+0h] [ebp-4h]

  v7 = player->MyArena;
  if ( v7 )
  {
    v16 = 0;
    if ( v7->ArenaPlayerCount > 0 )
    {
      v8 = 64288;
      do
      {
        v9 = *(PLAYER **)&v7->PlayerPointers[v8];// playerPointersForSomething
        v10 = v9;                               // playerPointersForSomething
        if ( v9 != player )
        {
          v11 = v9->ArenaPlayerIndex;
          if ( v11 >= 0 )
            v10 = ZonePlayerList[v11];
          if ( v10 )
          {
            v12 = *(_DWORD *)&v10->AttachedToPlayerId;
            if ( v12 >= 0 )
              v10 = ZonePlayerList[v12];
            if ( v10 )
            {
              if ( v9->IsSysop
                || (v13 = v7->ServersideArenaSettings.MessageDistance,
                    v14 = v10->YPixels - player->YPixels,
                    (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) <= v13)
                && (v15 = v10->XPixels - player->XPixels, (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) <= v13) )
              {
                if ( (!a5 || !v9->AllowAudioByte2) && (!a6 || *(_DWORD *)&v9->Ship == 8) )
                  SendPlayerReliablePacket(v9, buf, len, a4);
              }
            }
          }
        }
        v7 = player->MyArena;
        v8 += 4;
        ++v16;
      }
      while ( v16 < v7->ArenaPlayerCount );
    }
  }
}

//----- (0040E220) --------------------------------------------------------
void __thiscall sub_40E220(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  ARENA *arena; // eax
  int v8; // ebx
  int v9; // edi
  PLAYER *v10; // ecx

  arena = player->MyArena;
  if ( arena )
  {
    v8 = 0;
    if ( arena->ArenaPlayerCount > 0 )
    {
      v9 = 64288;
      do
      {
        v10 = *(PLAYER **)&arena->PlayerPointers[v9];// playerPointersForSomething
        if ( v10 != player
          && *(_DWORD *)&v10->Frequency == *(_DWORD *)&player->Frequency
          && (!a5 || !v10->AllowAudioByte2)
          && (!a6 || *(_DWORD *)&v10->Ship == 8) )
        {
          SendPlayerReliablePacket(v10, buf, len, a4);
        }
        arena = player->MyArena;
        ++v8;
        v9 += 4;
      }
      while ( v8 < arena->ArenaPlayerCount );
    }
  }
}

//----- (0040E2B0) --------------------------------------------------------
void __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  PLAYER *v6; // ecx

  v6 = ZonePlayerList[ArenaPlayerIndex];
  if ( v6 && (!a5 || !v6->AllowAudioByte2) && (!a6 || *(_DWORD *)&v6->Ship == 8) )
    SendPlayerReliablePacket(v6, buf, len, a4);
}

//----- (0040E300) --------------------------------------------------------
void __thiscall sub_40E300(struct PLAYER *player, int a2, char *buf, int len, int a4, int a6, int a7)
{
  struct PLAYER *v7; // ebx
  ARENA *v8; // eax
  int v9; // edi
  int v10; // esi
  struct PLAYER *v11; // ecx

  v7 = ZonePlayerList[a2];
  if ( v7 )
  {
    v8 = v7->MyArena;
    if ( v8 )
    {
      v9 = 0;
      if ( v8->ArenaPlayerCount > 0 )
      {
        v10 = 64288;
        do
        {
          v11 = *(struct PLAYER **)&v8->PlayerPointers[v10];// playerPointersForSomething
          if ( v11 != player
            && *(_DWORD *)&v11->Frequency == *(_DWORD *)&v7->Frequency
            && (!a6 || !v11->AllowAudioByte2)
            && (!a7 || *(_DWORD *)&v11->Ship == 8) )
          {
            SendPlayerReliablePacket(v11, buf, len, a4);
          }
          v8 = v7->MyArena;
          ++v9;
          v10 += 4;
        }
        while ( v9 < v8->ArenaPlayerCount );
      }
    }
  }
}

//----- (0040E3A0) --------------------------------------------------------
// Player.SendMessage()
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte)
{
  unsigned int v4; // kr08_4
  char buf[512]; // [esp+10h] [ebp-200h] BYREF

  if ( player->MyArena )
  {
    buf[2] = SoundByte;                         // Sound Byte
    buf[0] = 7;                                 // 0x07 - Chat
    buf[1] = 0;                                 // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
    *(_WORD *)&buf[3] = -1;                     // Originator ID
    strcpy(&buf[5], a2);
    v4 = strlen(a2) + 1;
    if ( GetRelAckDiff(player->connection, 0) < 128 )
      SendPlayerReliablePacket(player, buf, v4 - 1 + 6, 1);
  }
}
/* Orphan comments:
Chat Message
*/

//----- (0040E440) --------------------------------------------------------
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2)
{
  char buf[512]; // [esp+4h] [ebp-200h] BYREF

  if ( player->MyArena )
  {
    buf[0] = 7;                                 // 0x07 - Chat
    buf[1] = 9;                                 // Chat Type - 0x09 - Channel message
    buf[2] = 0;                                 // Sound Byte
    *(_WORD *)&buf[3] = -1;                     // Originator ID
    strcpy(&buf[5], a2);
    SendPlayerReliablePacket(player, buf, strlen(a2) + 6, 1);
  }
}
/* Orphan comments:
Chat Message
*/

//----- (0040E4C0) --------------------------------------------------------
void __thiscall SendArenaMessagePlayer(struct PLAYER *playerr, const char *a2, char SoundByte)
{
  __int16 v4; // cx
  char buf[6]; // [esp+10h] [ebp-5h] BYREF

  v4 = playerr->PlayerId;
  buf[2] = SoundByte;                           // Sound Byte
  *(_WORD *)&buf[3] = v4;                       // Originator ID
  buf[0] = 7;                                   // 0x07 - Chat
  buf[1] = 0;                                   // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
  strcpy(&buf[5], a2);
  SendPlayerReliablePacket(playerr, buf, strlen(a2) + 6, 0);
  sub_41CB20(playerr->connection);
}
/* Orphan comments:
Chat Message
*/

//----- (0040E550) --------------------------------------------------------
// Player.SendFile()
void __thiscall SendFile(struct PLAYER *playerr, const char *filename)
{
  struct PLAYER *player; // esi
  FILE *v3; // eax
  FILE *v4; // edi
  int v5; // eax
  size_t v6; // ebp
  char *v7; // esi
  char buf[17]; // [esp+10h] [ebp-14h] BYREF

  player = playerr;
  v3 = fopen(filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    v5 = _fileno(v3);
    v6 = _filelength(v5);
    v7 = (char *)emalloc(v6 + 17);
    fread(v7 + 17, 1u, v6, v4);
    fclose(v4);
    *v7 = 16;
    strncpy(v7 + 1, filename, 0x10u);
    v7[16] = 0;
    GetNewsRequest(playerr->connection, v7, v6 + 17, 0);
  }
  else
  {
    buf[0] = 0x10;                              // 0x10 - File Transfer
    strncpy(&buf[1], filename, 0x10u);
    buf[16] = 0;                                // File Data... is 0 (No idea what this means)
    SendPlayerReliablePacket(player, buf, 17u, 1);
  }
}
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (0040E620) --------------------------------------------------------
struct ARENA *__thiscall ArenaHandler(struct PLAYER *player, int ArenaIndex, const char *ArenaName)
{
  int v3; // ebx
  struct PLAYER *v4; // edx
  int v5; // ecx
  struct ARENA *result; // eax
  char *v7; // ebp
  ARENA **v8; // ebx
  ARENA *v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // esi
  int v13; // eax
  ARENA *v14; // esi
  ARENA **v15; // edx
  int v16; // edi
  int v17; // esi
  ARENA *v18; // eax
  int v19; // edi
  ARENA **v20; // esi
  ARENA *v21; // eax
  ARENA *v22; // eax
  int v23; // esi
  int i; // eax
  ARENA *v25; // edx
  ARENA **j; // esi
  ARENA *v27; // eax
  int v28; // ecx
  int ArenaIndexa; // [esp+24h] [ebp+4h]

  v3 = 0;
  v4 = player;
  if ( ArenaIndex < 0 )
  {
    if ( ArenaIndex == -1 && (v7 = player->PlayerDataBillerPacket.Squad, player->PlayerDataBillerPacket.Squad[0]) )
    {
      v5 = ArenaArrayLength;
      ArenaIndexa = 0;
      if ( ArenaArrayLength > 0 )
      {
        v8 = Arenas;
        while ( 1 )
        {
          v9 = *v8;
          if ( !(*v8)->ArenaName[0] )
          {
            v10 = v9->ArenaPlayerCount;
            if ( v10 < ArenaMaxPlayers )
            {
              v11 = 0;
              if ( v10 > 0 )
                break;
            }
          }
LABEL_18:
          ++v8;
          if ( ++ArenaIndexa >= v5 )
            goto LABEL_54;
        }
        v12 = 64288;
        while ( _strcmpi((const char *)(*(_DWORD *)&v9->PlayerPointers[v12] + 399), v7) )// playerPointersForSomething
        {
          v9 = *v8;
          ++v11;
          v12 += 4;
          if ( v11 >= (*v8)->ArenaPlayerCount )
          {
            v5 = ArenaArrayLength;
            goto LABEL_18;
          }
        }
        return Arenas[ArenaIndexa];
      }
    }
    else if ( ArenaIndex == -2 )
    {
      v5 = ArenaArrayLength;
      v13 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v14 = (ARENA *)v4->MyLastArena;
        v15 = Arenas;
        while ( *v15 != v14 )
        {
          ++v13;
          ++v15;
          if ( v13 >= ArenaArrayLength )
            goto LABEL_28;
        }
        v3 = v13;
      }
LABEL_28:
      v16 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v17 = v3 + 1;
        do
        {
          v18 = Arenas[v17 % ArenaArrayLength];
          if ( !v18->ArenaName[0] && (player->IsModerator || v18->ArenaPlayerCount < ArenaMaxPlayers) )
            return Arenas[v17 % ArenaArrayLength];
          ++v16;
          ++v17;
        }
        while ( v16 < ArenaArrayLength );
      }
    }
    else if ( ArenaIndex == -3 )
    {
      v5 = ArenaArrayLength;
      v19 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v20 = Arenas;
        while ( 1 )
        {
          v3 += GetArenaMemoryTotal(*v20);
          if ( !_strcmpi((*v20)->ArenaName, ArenaName) )
            break;
          v5 = ArenaArrayLength;
          ++v19;
          ++v20;
          if ( v19 >= ArenaArrayLength )
            goto LABEL_46;
        }
        if ( player->IsModerator )
          goto LABEL_68;
        if ( Arenas[v19]->ArenaPlayerCount < ArenaMaxPlayers )
          return Arenas[v19];
        v5 = ArenaArrayLength;
LABEL_46:
        v4 = player;
      }
      if ( v19 == v5 && (v4->IsSuperModerator || v5 < MaxArenas && v3 < MaxArenasMemory) )
      {
        v21 = (ARENA *)operator new(0x1D40Eu);
        if ( v21 )
        {
          v22 = ServerEntryPoint(v21, ArenaName);
LABEL_72:
          v28 = ArenaArrayLength;
          Arenas[ArenaArrayLength] = v22;
          result = Arenas[v28];
          ArenaArrayLength = v28 + 1;
          return result;
        }
LABEL_71:
        v22 = 0;
        goto LABEL_72;
      }
    }
    else
    {
      v5 = ArenaArrayLength;
    }
  }
  else
  {
    v5 = ArenaArrayLength;
    if ( ArenaIndex < ArenaArrayLength
      && (v4->IsModerator || !Arenas[ArenaIndex]->ArenaName[0] && Arenas[ArenaIndex]->ArenaPlayerCount < ArenaMaxPlayers) )
    {
      return Arenas[ArenaIndex];
    }
  }
LABEL_54:
  v23 = -1;
  for ( i = 0; i < v5; ++i )
  {
    v25 = Arenas[i];
    if ( !v25->ArenaName[0] && (v23 == -1 || v25->ArenaPlayerCount < Arenas[v23]->ArenaPlayerCount) )
      v23 = i;
  }
  if ( v23 == -1 || (result = Arenas[v23], result->ArenaPlayerCount >= ArenaMaxPlayers) )
  {
    v27 = (ARENA *)operator new(0x1D40Eu);
    if ( v27 )
    {
      v22 = ServerEntryPoint(v27, (const char *)&DirectoryCurrentNamePassword);
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  v19 = 0;
  if ( v5 > 0 )
  {
    for ( j = Arenas; (*j)->ArenaName[0] || (*j)->ArenaPlayerCount >= ArenaDesiredPlayers; ++j )
    {
      if ( ++v19 >= v5 )
        return result;
    }
LABEL_68:
    result = Arenas[v19];
  }
  return result;
}
// 40E677: conditional instruction was optimized away because of 'edx.4==0'
// 431FF4: using guessed type int ArenaArrayLength;
// 4380B0: using guessed type int ArenaMaxPlayers;
// 438B18: using guessed type int MaxArenasMemory;
// 4D5908: using guessed type int MaxArenas;
// 4D5928: using guessed type int ArenaDesiredPlayers;

//----- (0040E990) --------------------------------------------------------
void __thiscall SendWeaponPacket(struct PLAYER *playerr)
{
  int v2; // eax
  __int16 v3; // cx
  __int16 v4; // dx
  CONNECTION *v5; // edi
  __int16 v6; // ax
  DWORD v7; // eax
  int v8; // ebp
  int v9; // edi
  DWORD v10; // edx
  CONNECTION *v11; // ebp
  int v12; // edx
  int v13; // edi
  CONNECTION *v14; // ebp
  int v15; // edx
  __int16 v16; // cx
  __int16 v17; // ax
  char v18; // al
  _BYTE *v19; // ecx
  int v20; // edx
  ARENA *v21; // eax
  int v22; // ecx
  __int16 v23; // dx
  __int16 v24; // ax
  CONNECTION *v25; // edi
  __int16 v26; // cx
  DWORD v27; // eax
  int v28; // ebp
  int v29; // edi
  DWORD v30; // edx
  CONNECTION *v31; // ebp
  int v32; // edx
  int v33; // edx
  int v34; // edi
  CONNECTION *v35; // ebp
  char v36; // al
  char v37; // cl
  __int16 v38; // ax
  __int16 v39; // cx
  CONNECTION *v40; // edi
  __int16 v41; // dx
  DWORD v42; // eax
  int v43; // ebp
  int v44; // edi
  DWORD v45; // edx
  CONNECTION *v46; // ebp
  int v47; // edx
  unsigned __int8 v48; // al
  int v49; // edi
  CONNECTION *v50; // ebp
  int v51; // edx
  __int16 v52; // dx
  char v53; // al
  __int16 v54; // cx
  __int16 v55; // ax
  int v56; // edx
  __int16 v57; // cx
  char v58; // al
  _BYTE *v59; // ecx
  int v60; // eax
  char *v61; // ecx
  __int16 v62; // dx
  int v63; // edx
  int v64; // edi
  __int16 v65; // ax
  bool v66; // cc
  bool v67; // cc
  ARENA *v68; // eax
  int v69; // ebp
  int v70; // esi
  int v71; // edx
  int v72; // ecx
  unsigned int v73; // edi
  int v74; // eax
  int v75; // esi
  int v76; // ecx
  int v77; // ebp
  int v78; // edx
  int v79; // eax
  int v80; // eax
  int v81; // edi
  int v82; // eax
  int v83; // ecx
  int *v84; // eax
  struct PLAYER *v85; // ebp
  int v86; // eax
  int v87; // eax
  PLAYER *v88; // ecx
  int v89; // eax
  __int64 v90; // rax
  unsigned int v91; // esi
  ARENA *v92; // eax
  int v93; // ecx
  int v94; // eax
  bool v95; // zf
  int len; // [esp+10h] [ebp-DCh]
  int v97; // [esp+14h] [ebp-D8h]
  int v98; // [esp+14h] [ebp-D8h]
  int v99; // [esp+18h] [ebp-D4h]
  int v100; // [esp+18h] [ebp-D4h]
  int v101; // [esp+1Ch] [ebp-D0h]
  int v102; // [esp+1Ch] [ebp-D0h]
  int v103; // [esp+20h] [ebp-CCh]
  int v104; // [esp+20h] [ebp-CCh]
  _DWORD buf[8]; // [esp+24h] [ebp-C8h] BYREF
  int v106; // [esp+44h] [ebp-A8h]
  int v107; // [esp+48h] [ebp-A4h]
  int v108; // [esp+4Ch] [ebp-A0h]
  int *v109; // [esp+50h] [ebp-9Ch]
  int v110; // [esp+54h] [ebp-98h]
  int v111; // [esp+58h] [ebp-94h]
  int *v112; // [esp+5Ch] [ebp-90h]
  int v113; // [esp+60h] [ebp-8Ch]
  int v114; // [esp+64h] [ebp-88h]
  int v115; // [esp+68h] [ebp-84h]
  _WORD v116[64]; // [esp+6Ch] [ebp-80h] BYREF

  v2 = playerr->field_28B;
  playerr->SendWeaponUpdatePacket = 0;
  if ( v2 )
  {
    v3 = playerr->YPixels;
    v4 = playerr->XVelocity;
    v5 = playerr->connection;
    LOWORD(buf[1]) = playerr->XPixels;          // X Pixels (0-16384)
    v6 = playerr->YVelocity;
    *(_WORD *)((char *)&buf[3] + 3) = v3;
    LOBYTE(v3) = playerr->ShipDirection;
    LOBYTE(buf[0]) = 5;                         // 0x05 - Large Position Packet (Weapons Packet)
    HIWORD(buf[2]) = v4;                        // X Velocity
    HIWORD(buf[1]) = v6;                        // Y Velocity
    BYTE1(buf[0]) = v3;                         // Direction (0-360)
    v7 = GetTickCount();
    v8 = v5->SyncResponseLocalTimeStamp;
    v9 = playerr->PingTimestamp;
    v10 = v8 + v7 / 0xA;
    v11 = playerr->connection;
    HIWORD(buf[0]) = v10;
    v12 = ((v11->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v9;
    if ( v12 < 0 || v12 > 30000 )
      v12 = 0;
    if ( v12 <= 255 )
    {
      v13 = playerr->PingTimestamp;
      v14 = playerr->connection;
      v15 = ((v14->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v13;
      if ( v15 < 0 || v15 > 30000 )
        LOBYTE(v15) = 0;
      BYTE2(buf[3]) = v15;                      // Ping
    }
    else
    {
      BYTE2(buf[3]) = -1;                       // Ping
    }
    v16 = playerr->WeaponsInfo;
    LOWORD(buf[2]) = 1014;                      // Special PlayerId?
    v17 = v16 & 0x1F;
    BYTE1(buf[3]) = 0;
    *(_WORD *)((char *)&buf[4] + 1) = 0;
    if ( v17 == 3 || v17 == 4 || v17 == 1 || v17 == 2 )
      *(_WORD *)((char *)&buf[4] + 3) = v16 ^ (v16 ^ v16 & 0x80 ^ (v16 & 0x1F ^ *(_WORD *)((_BYTE *)&buf[4] + 3) & 0xFF80) & 0xFC7F) & 0x3FF;
    else
      *(_WORD *)((char *)&buf[4] + 3) = 0;
    v18 = 0;
    v19 = buf;
    LOBYTE(buf[3]) = 0;                         // Checksum
    v20 = 21;
    do
    {
      v18 ^= *v19++;
      --v20;
    }
    while ( v20 );
    LOBYTE(buf[3]) = v18;                       // Computed Checksum
    if ( !playerr->field_309 )
    {
      v21 = playerr->MyArena;
      if ( v21 )
      {
        if ( (buf[4] & 0x1F000000) != 0 )
        {
          v22 = playerr->S2CPacketLossPercentage;
          ++playerr->SecurityWeaponCountyTotalNew;
          if ( v22 < v21->ServersideArenaSettings.RoutingDoubleSendPercent )
          {
            SendPlayerReliablePacket(playerr, buf, 0x15u, 0);
            ++playerr->SecurityWeaponCountyTotalNew;
            ++dword_4C8F38;
            sub_41CB20(playerr->connection);
          }
        }
        SendPlayerReliablePacket(playerr, buf, 0x15u, 0);
      }
    }
  }
  if ( *(int *)&playerr->Ship < 8 && playerr->MyArena )
  {
    if ( *(int *)&playerr->PlayerId > 255 || playerr->Bounty > 255 || (playerr->WeaponsInfo & 0x1F) != 0 )
    {
      v38 = playerr->YPixels;
      v39 = playerr->XVelocity;
      v40 = playerr->connection;
      v116[2] = playerr->XPixels;
      v41 = playerr->YVelocity;
      *(_WORD *)((char *)&v116[7] + 1) = v38;
      LOBYTE(v38) = playerr->ShipDirection;
      len = 21;
      LOBYTE(v116[0]) = 5;                      // 0x05 - Large Position Packet (Weapons Packet)
      v116[5] = v39;
      v116[3] = v41;
      HIBYTE(v116[0]) = v38;
      v42 = GetTickCount();
      v43 = v40->SyncResponseLocalTimeStamp;
      v44 = playerr->PingTimestamp;
      v45 = v43 + v42 / 0xA;
      v46 = playerr->connection;
      v116[1] = v45;
      v47 = ((v46->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v44;
      if ( v47 < 0 || v47 > 30000 )
        v47 = 0;
      if ( v47 <= 255 )
      {
        v49 = playerr->PingTimestamp;
        v50 = playerr->connection;
        v51 = ((v50->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v49;
        if ( v51 < 0 || v51 > 30000 )
          LOBYTE(v51) = 0;
        v48 = v51;
      }
      else
      {
        v48 = -1;
      }
      v52 = playerr->PlayerId;
      LOBYTE(v116[7]) = v48;
      v53 = playerr->ShipTogglables;
      v54 = playerr->Bounty;
      v116[4] = v52;
      HIBYTE(v116[6]) = v53;
      v55 = playerr->WeaponsInfo;
      *(_WORD *)((char *)&v116[8] + 1) = v54;
      *(_WORD *)((char *)&v116[9] + 1) ^= ((unsigned __int8)v55 ^ HIBYTE(v116[9])) & 0x1F;// BitFlags
      *(_WORD *)((char *)&v116[9] + 1) ^= ((unsigned __int8)v55 ^ HIBYTE(v116[9])) & 0x60;
      *(_WORD *)((char *)&v116[9] + 1) ^= ((unsigned __int8)v55 ^ HIBYTE(v116[9])) & 0x80;
      *(_WORD *)((char *)&v116[9] + 1) ^= (v55 ^ *(_WORD *)((char *)&v116[9] + 1)) & 0x300;
      *(_WORD *)((char *)&v116[9] + 1) ^= (v55 ^ *(_WORD *)((char *)&v116[9] + 1)) & 0x7C00;
      v56 = 21;
      v57 = v55 ^ (v55 ^ *(_WORD *)((char *)&v116[9] + 1)) & 0x7FFF;
      v58 = 0;
      *(_WORD *)((char *)&v116[9] + 1) = v57;
      LOBYTE(v116[6]) = 0;
      v59 = v116;
      do
      {
        v58 ^= *v59++;
        --v56;
      }
      while ( v56 );
      LOBYTE(v116[6]) = v58;
    }
    else
    {
      v23 = playerr->YPixels;
      v24 = playerr->XVelocity;
      v25 = playerr->connection;
      v116[2] = playerr->XPixels;
      v26 = playerr->YVelocity;
      v116[6] = v23;
      LOBYTE(v23) = playerr->ShipDirection;
      len = 16;
      LOBYTE(v116[0]) = 0x28;                   // 0x28 - Small Position Packet
      v116[7] = v24;
      v116[5] = v26;
      HIBYTE(v116[0]) = v23;
      v27 = GetTickCount();
      v28 = v25->SyncResponseLocalTimeStamp;
      v29 = playerr->PingTimestamp;
      v30 = v28 + v27 / 0xA;
      v31 = playerr->connection;
      v116[1] = v30;
      v32 = ((v31->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v29;
      if ( v32 < 0 || v32 > 30000 )
        v32 = 0;
      if ( v32 <= 255 )
      {
        v34 = playerr->PingTimestamp;
        v35 = playerr->connection;
        v33 = ((v35->SyncResponseLocalTimeStamp + GetTickCount() / 0xA) & 0x7FFFFFFF) - v34;
        if ( v33 < 0 || v33 > 30000 )
          LOBYTE(v33) = 0;
      }
      else
      {
        LOBYTE(v33) = -1;
      }
      v36 = playerr->ShipTogglables;
      v37 = playerr->Bounty;
      LOBYTE(v116[3]) = v33;
      LOBYTE(v116[4]) = playerr->PlayerId;
      HIBYTE(v116[4]) = v36;
      HIBYTE(v116[3]) = v37;
    }
    if ( playerr->field_10B )
    {
      v60 = len;
      v61 = (char *)v116 + len;
      *(_DWORD *)v61 = playerr->EnergyOptional;
      v62 = playerr->SharpnelMinesBombsBulletsMultifireInformationOptional;
      *((_DWORD *)v61 + 1) = playerr->TimerOptional;
      *((_WORD *)v61 + 4) = v62;
      buf[6] = len + 10;
    }
    else
    {
      *(_WORD *)((char *)v116 + len) = playerr->Energy;
      buf[6] = len + 2;
      v60 = len;
    }
    v63 = 0;
    v64 = 0;
    v103 = 0;
    v97 = 0;
    v99 = 0;
    if ( v60 != 21 )
      goto LABEL_79;
    v65 = HIBYTE(v116[9]) & 0x1F;
    if ( v65 == 6 || v65 == 3 && SLOBYTE(v116[10]) < 0 || v65 == 4 && SLOBYTE(v116[10]) < 0 || v65 == 5 || v65 == 8 )
    {
      playerr->field_10F = 1;
    }
    else if ( v65 == 4 || v65 == 3 )
    {
      if ( SHIBYTE(v116[0]) < 5 || SHIBYTE(v116[0]) > 35 )
        v97 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      if ( SHIBYTE(v116[0]) > 5 )
      {
        v66 = SHIBYTE(v116[0]) <= 15;
        if ( SHIBYTE(v116[0]) >= 15 )
          goto LABEL_71;
        v64 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      }
      v66 = SHIBYTE(v116[0]) <= 15;
LABEL_71:
      if ( !v66 )
      {
        v67 = SHIBYTE(v116[0]) <= 25;
        if ( SHIBYTE(v116[0]) >= 25 )
        {
LABEL_75:
          if ( !v67 && SHIBYTE(v116[0]) < 35 )
          {
            v63 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
            v103 = v63;
          }
          goto LABEL_79;
        }
        v99 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      }
      v67 = SHIBYTE(v116[0]) <= 25;
      goto LABEL_75;
    }
LABEL_79:
    if ( playerr->field_10F )
    {
      v68 = playerr->MyArena;
      v101 = 0;
      if ( v68->ArenaPlayerCount > 0 )
      {
        v69 = 64288;
        do
        {
          v70 = *(_DWORD *)&v68->PlayerPointers[v69];// playerPointersForSomething
          if ( (struct PLAYER *)v70 != playerr )
          {
            v71 = *(_DWORD *)(v70 + 631);
            if ( v71 || !playerr->field_3C || (v72 = playerr->field_4C, v72 < 0) || v72 == *(_DWORD *)(v70 + 20) )
            {
              v73 = len;
              if ( *(_DWORD *)(v70 + 68)
                || *(_DWORD *)(v70 + 371) == *(_DWORD *)&playerr->PlayerId
                && (v68->ArenaSettings.ExtraPositionData || v71) )
              {
                v73 = buf[6];
              }
              if ( !*(_DWORD *)(v70 + 777) )
              {
                v74 = *(_DWORD *)(v70 + 28);
                if ( v74 )
                {
                  if ( len == 21 && (v116[9] & 0x1F00) != 0 )
                  {
                    ++*(_DWORD *)(v70 + 287);
                    if ( *(_DWORD *)(v70 + 801) < *(_DWORD *)(v74 + 109902) )
                    {
                      SendPlayerReliablePacket((struct PLAYER *)v70, v116, v73, 0);
                      ++*(_DWORD *)(v70 + 287);
                      ++dword_4C8F38;
                      sub_41CB20(*(CONNECTION **)(v70 + 40));
                    }
                  }
                  SendPlayerReliablePacket((struct PLAYER *)v70, v116, v73, 0);
                }
              }
            }
          }
          v68 = playerr->MyArena;
          v69 += 4;
          ++v101;
        }
        while ( v101 < v68->ArenaPlayerCount );
      }
    }
    else
    {
      v75 = (playerr->LooksLikeX1BigOfSomething - v63) / 2048;
      if ( v75 < 0 )
        v75 = 0;
      v76 = (v64 + playerr->LooksLikeXSmallOfSomething) / 2048;
      if ( v76 >= 8 )
        v76 = 7;
      v77 = (playerr->LooksLikeYBigOfSomething - v97) / 2048;
      v102 = v77;
      if ( v77 < 0 )
      {
        v102 = 0;
        v77 = 0;
      }
      v107 = (v99 + playerr->LooksLikeYSmallOfSomething) / 2048;
      v78 = v107;
      if ( v107 >= 8 )
      {
        v78 = 7;
        v107 = 7;
      }
      v79 = playerr->XPixels;
      v114 = v79 + v64;
      v111 = v79 - v103;
      v80 = playerr->YPixels;
      v113 = v80 + v99;
      v115 = v80 - v97;
      v104 = 128;
      v100 = 128;
      if ( len == 21 && (v116[9] & 0x1F00) != 0 )
      {
        v104 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBulletAdjust + 128;
        v100 = v104;
      }
      if ( v75 <= v76 )
      {
        v81 = 1004 * (v77 + 8 * v75);
        v106 = v81;
        v108 = v76 - v75 + 1;
        do
        {
          if ( v77 <= v78 )
          {
            v82 = v81;
            v110 = v81;
            v83 = v78 - v77 + 1;
            buf[7] = v83;
            do
            {
              v98 = 0;
              v84 = (int *)&playerr->MyArena->PlayerPointers[v82];
              v112 = v84;
              if ( v84[250] > 0 )
              {
                v109 = v84;
                do
                {
                  v85 = (struct PLAYER *)*v84;
                  if ( (struct PLAYER *)*v84 != playerr )
                  {
                    if ( v85->IsSysop
                      || !playerr->field_3C
                      || (v86 = playerr->field_4C, v86 < 0)
                      || v86 == *(_DWORD *)&v85->PlayerId )
                    {
                      v87 = v85->ArenaPlayerIndex;
                      v88 = v85;
                      if ( v87 < 0 || (v88 = ZonePlayerList[v87]) != 0 )
                      {
                        v89 = *(_DWORD *)&v88->AttachedToPlayerId;
                        if ( v89 < 0 || (v88 = ZonePlayerList[v89]) != 0 )
                        {
                          if ( (int)abs32(v88->YPixels - playerr->YPixels) > v100 + v85->YResolution / 2
                            || (v90 = v88->XPixels - playerr->XPixels,
                                (int)((HIDWORD(v90) ^ v90) - HIDWORD(v90)) > v104 + v85->XResolution / 2) )
                          {
                            if ( v114 >= v88->LooksLikeX1BigOfSomething
                              && v111 <= v88->LooksLikeXSmallOfSomething
                              && v113 >= v88->LooksLikeYBigOfSomething
                              && v115 <= v88->LooksLikeYSmallOfSomething
                              && (len == 21 && (HIBYTE(v116[9]) & 0x1Fu) > 2
                               || v98 % playerr->MyArena->ServersideArenaSettings.RoutingRadarFavor == *(_DWORD *)playerr->gap_11B) )
                            {
                              if ( IncreasesRadarValueSomeHow >= 4000 )
                                IncreaseRadarValueShowHomeOverFourThousand();
                              v94 = 26 * IncreasesRadarValueSomeHow;
                              qmemcpy((char *)dword_4AF8FC + 26 * IncreasesRadarValueSomeHow, v116, len);
                              byte_4AF911[v94] = len;
                              *(int *)((char *)&dword_4AF8F8 + v94) = *(_DWORD *)&v85->PlayerId;
                              ++IncreasesRadarValueSomeHow;
                            }
                          }
                          else
                          {
                            v91 = len;
                            if ( v85->IsEnergyShowing
                              || v85->ArenaPlayerIndex == *(_DWORD *)&playerr->PlayerId
                              && (playerr->MyArena->ArenaSettings.ExtraPositionData || v85->IsSysop) )
                            {
                              v91 = buf[6];
                            }
                            if ( !v85->field_309 )
                            {
                              v92 = v85->MyArena;
                              if ( v92 )
                              {
                                if ( len == 21 && (v116[9] & 0x1F00) != 0 )
                                {
                                  v93 = v85->S2CPacketLossPercentage;
                                  ++v85->SecurityWeaponCountyTotalNew;
                                  if ( v93 < v92->ServersideArenaSettings.RoutingDoubleSendPercent )
                                  {
                                    SendPlayerReliablePacket(v85, v116, v91, 0);
                                    ++v85->SecurityWeaponCountyTotalNew;
                                    ++dword_4C8F38;
                                    sub_41CB20(v85->connection);
                                  }
                                }
                                SendPlayerReliablePacket(v85, v116, v91, 0);
                              }
                            }
                            ++dword_4D55D0;
                          }
                        }
                      }
                    }
                  }
                  v84 = v109 + 1;
                  v66 = ++v98 < v112[250];
                  ++v109;
                }
                while ( v66 );
                v77 = v102;
                v78 = v107;
                v81 = v106;
                v83 = buf[7];
              }
              v82 = v110 + 1004;
              --v83;
              v110 += 1004;
              buf[7] = v83;
            }
            while ( v83 );
          }
          v81 += 8032;
          v95 = v108 == 1;
          v106 = v81;
          --v108;
        }
        while ( !v95 );
      }
      *(_DWORD *)playerr->gap_11B = (*(_DWORD *)playerr->gap_11B + 1)
                                  % playerr->MyArena->ServersideArenaSettings.RoutingRadarFavor;
    }
  }
  playerr->field_10F = 0;
  playerr->field_10B = 0;
}
/* Orphan comments:
 Large Position Packet (Weapons Packet) Without Optionals
*/
// 4AF8F8: using guessed type int dword_4AF8F8;
// 4AF8FC: using guessed type int dword_4AF8FC[5];
// 4C8F38: using guessed type int dword_4C8F38;
// 4CA814: using guessed type int IncreasesRadarValueSomeHow;
// 4D55D0: using guessed type int dword_4D55D0;

//----- (0040F4A0) --------------------------------------------------------
void __thiscall SendResetScoresPacket(PLAYER *player)
{
  __int16 v1; // dx
  struct ARENA *arena; // ecx
  char buf[4]; // [esp+0h] [ebp-4h] BYREF

  *(_DWORD *)buf = player;
  v1 = player->PlayerId;
  player->CurrentLosses = 0;
  player->CurrentWins = 0;
  player->KillPoints = 0;
  player->FlagPoints = 0;
  player->CurrentGoals = 0;
  player->ScoreReset = 1;
  arena = player->MyArena;
  buf[0] = 0x1A;                                // 0x1A - Reset Score(s)
  *(_WORD *)&buf[1] = v1;
  if ( arena )
    ArenaSendPacket(arena, buf, 3, 1);
}

//----- (0040F500) --------------------------------------------------------
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player)
{
  __int16 v1; // ax
  __int16 v2; // dx
  int v3; // eax
  char buf[16]; // [esp+0h] [ebp-10h] BYREF

  v1 = player->PlayerId;
  *(_DWORD *)&buf[3] = player->KillPoints;      // Kill Points
  v2 = player->CurrentWins;
  *(_WORD *)&buf[1] = v1;                       // Player ID
  v3 = player->FlagPoints;
  *(_WORD *)&buf[11] = v2;                      // Wins
  *(_DWORD *)&buf[7] = v3;                      // Flag Points
  LOWORD(v3) = player->CurrentLosses;
  buf[0] = 9;                                   // 0x09 - Player Score Update
  *(_WORD *)&buf[13] = v3;                      // Losses
  SendPlayerReliablePacket(player, buf, 0xFu, 1);
}

//----- (0040F550) --------------------------------------------------------
bool __thiscall SendPlayerScoreUpdateAll(struct PLAYER *playerr)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebp
  int v5; // ecx
  ARENA *v6; // eax
  __int16 v7; // dx
  int v8; // ebp
  __int16 v9; // cx
  int v10; // ebp
  int v11; // ebp
  int v12; // edi
  int v13; // ebx
  struct PLAYER *v14; // eax
  ARENA *v15; // eax
  char buf[16]; // [esp+10h] [ebp-10h] BYREF

  v2 = playerr->KillPoints;
  v3 = playerr->KillPointsSomething;
  v4 = playerr->FlagPointsSomething;
  v5 = playerr->FlagPoints;
  if ( v5 + v2 - v3 - v4 <= MiscPointUpdateDiff )
    return 0;
  if ( !dword_4C8F3C )
    return 0;
  v6 = playerr->MyArena;
  if ( !v6 )
    return 0;
  *(_DWORD *)&buf[3] = v2;                      // Kill Points
  v7 = playerr->CurrentLosses;
  v8 = *(_DWORD *)&playerr->CurrentWins;
  *(_DWORD *)&buf[7] = v5;                      // Flag Points
  *(_DWORD *)&playerr->WinsSomething = v8;
  v9 = playerr->CurrentWins;
  v10 = *(_DWORD *)&playerr->CurrentGoals;
  buf[0] = 9;                                   // 0x09 - Player Score Update
  *(_DWORD *)&playerr->GoalsSomething = v10;
  *(_WORD *)&buf[11] = v9;                      // Wins
  v11 = *(int *)((char *)&playerr->KillPoints + 2);
  *(_WORD *)&buf[13] = v7;                      // Losses
  *(int *)((char *)&playerr->KillPointsSomething + 2) = v11;
  HIWORD(playerr->FlagPointsSomething) = HIWORD(playerr->FlagPoints);
  *(_WORD *)&buf[1] = playerr->PlayerId;        // Player ID
  v12 = 0;
  if ( v6->ArenaPlayerCount > 0 )
  {
    v13 = 64288;
    do
    {
      v14 = *(struct PLAYER **)&v6->PlayerPointers[v13];// playerPointersForSomething
      if ( v14 != playerr && !v14->AlreadySentReliablePacket )
        SendPlayerReliablePacket(v14, buf, 0xFu, 0);
      v6 = playerr->MyArena;
      ++v12;
      v13 += 4;
    }
    while ( v12 < v6->ArenaPlayerCount );
  }
  SendPlayerReliablePacket(playerr, buf, 0xFu, 1);
  if ( BillingConnectionStructPointer )
  {
    v15 = playerr->MyArena;
    if ( !v15->ServersideArenaSettings.MiscTimedGame )
    {
      if ( v15->RecordPointsToLog )
      {
        if ( (MiscDisableSharewareScores || MiscDisableShareware) && playerr->DemoPlayer )
          return 1;
        SendBillerUserScorePacket(BillingConnectionStructPointer, playerr->BillerPlayerId, &playerr->CurrentWins, 0xEu);
      }
    }
  }
  return 1;
}
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4CA60C: using guessed type int MiscPointUpdateDiff;
// 4D5918: using guessed type int MiscDisableShareware;
// 4D8AE0: using guessed type int MiscDisableSharewareScores;

//----- (0040F6B0) --------------------------------------------------------
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2)
{
  __int64 v3; // rax
  DWORD v4; // kr00_4
  int v5; // eax
  int v6; // edx
  int v7; // edx
  int v8; // edx

  if ( a2
    || (v3 = (int)(GetTickCount() / 0xA - playerr->LastAdvertisementTime),
        (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) >= 3000) )
  {
    v4 = GetTickCount();
    v5 = playerr->DemoPlayer;
    playerr->LastAdvertisementTime = v4 / 0xA;
    if ( v5 )
    {
      if ( BothAdvertisementsFound > 0 || SharewareAdvertisementsFound > 0 )
      {
        v6 = rand() % (BothAdvertisementsFound + SharewareAdvertisementsFound);
        if ( v6 >= BothAdvertisementsFound )
        {
          v7 = v6 - BothAdvertisementsFound;
          if ( a2 )
            SendPlayerReliablePacket(playerr, SharewareAd[v7].PacketBuffer, *(&dword_431BF4 + 2 * v7), 1);
          else
            GetMapLvlRequest(playerr->connection, SharewareAd[v7].PacketBuffer, *(&dword_431BF4 + 2 * v7), 0);
          return;
        }
        if ( a2 )
        {
LABEL_19:
          SendPlayerReliablePacket(playerr, BothAd[v6].PacketBuffer, (unsigned int)(&dword_437CB4)[2 * v6], 1);
          return;
        }
LABEL_20:
        GetMapLvlRequest(playerr->connection, BothAd[v6].PacketBuffer, (int)(&dword_437CB4)[2 * v6], 0);
        return;
      }
    }
    else if ( BothAdvertisementsFound > 0 || RegisteredAdvertisementsFound > 0 )
    {
      v6 = rand() % (BothAdvertisementsFound + RegisteredAdvertisementsFound);
      if ( v6 < BothAdvertisementsFound )
      {
        if ( a2 )
          goto LABEL_19;
        goto LABEL_20;
      }
      v8 = v6 - BothAdvertisementsFound;
      if ( a2 )
        SendPlayerReliablePacket(playerr, RegisteredAd[v8].PacketBuffer, *(&dword_4317BC + 2 * v8), 1);
      else
        GetMapLvlRequest(playerr->connection, RegisteredAd[v8].PacketBuffer, *(&dword_4317BC + 2 * v8), 0);
    }
  }
}
// 4D8AFC: using guessed type int SharewareAdvertisementsFound;
// 4D8B00: using guessed type int RegisteredAdvertisementsFound;
// 4D8B04: using guessed type int BothAdvertisementsFound;

//----- (0040F840) --------------------------------------------------------
void __thiscall LoadZoneCFGSettings(struct ARENA_SETTINGS *arenaSettings, struct SERVERSIDE_ARENA_SETTINGS *serverArenaSettings, const char *a3)
{
  struc_2 *v3; // eax
  struc_2 *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  const char *v33; // edi
  int *v34; // esi
  int v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // ecx
  int v39; // eax
  char v40; // al
  int v41; // edx
  char v42; // al
  int v43; // ecx
  char v44; // al
  int v45; // edx
  int v46; // eax
  int v47; // [esp-4h] [ebp-44h]
  char *Str1[8]; // [esp+14h] [ebp-2Ch]
  int v49; // [esp+3Ch] [ebp-4h]
  char *Filename; // [esp+4Ch] [ebp+Ch]
  char *Filenamea; // [esp+4Ch] [ebp+Ch]

  v3 = (struc_2 *)operator new(177996u);
  v49 = 0;
  if ( v3 )
    v4 = ReadSettingsSomething(v3, Filename);
  else
    v4 = 0;
  v49 = -1;
  if ( serverArenaSettings )
  {
    memset(serverArenaSettings, 0, 0x594u);
    LOBYTE(serverArenaSettings->OwnerUserId) = 15;
    HIBYTE(serverArenaSettings[1].SecurityMaxShipTypeSwitchCount) = 0;
    v5 = GetCFGSettingInteger(v4, "PrizeWeight", "QuickCharge", 80);
    if ( v5 > 255 )
      LOBYTE(v5) = -1;
    LOBYTE(serverArenaSettings[1].SecurityPacketModificationMax) = v5;
    v6 = GetCFGSettingInteger(v4, "PrizeWeight", "Energy", 70);
    if ( v6 > 255 )
      LOBYTE(v6) = -1;
    BYTE1(serverArenaSettings[1].SecurityPacketModificationMax) = v6;
    v7 = GetCFGSettingInteger(v4, "PrizeWeight", "Rotation", 60);
    if ( v7 > 255 )
      LOBYTE(v7) = -1;
    BYTE2(serverArenaSettings[1].SecurityPacketModificationMax) = v7;
    v8 = GetCFGSettingInteger(v4, "PrizeWeight", "Stealth", 30);
    if ( v8 > 255 )
      LOBYTE(v8) = -1;
    HIBYTE(serverArenaSettings[1].SecurityPacketModificationMax) = v8;
    v9 = GetCFGSettingInteger(v4, "PrizeWeight", "Cloak", 20);
    if ( v9 > 255 )
      LOBYTE(v9) = -1;
    LOBYTE(serverArenaSettings[1].SecurityMaxDeathWithoutFiring) = v9;
    v10 = GetCFGSettingInteger(v4, "PrizeWeight", "AntiWarp", 20);
    if ( v10 > 255 )
      LOBYTE(v10) = -1;
    HIBYTE(serverArenaSettings[1].LatencyNoFlagPenalty) = v10;
    v11 = GetCFGSettingInteger(v4, "PrizeWeight", "XRadar", 20);
    if ( v11 > 255 )
      LOBYTE(v11) = -1;
    BYTE1(serverArenaSettings[1].SecurityMaxDeathWithoutFiring) = v11;
    v12 = GetCFGSettingInteger(v4, "PrizeWeight", "Warp", 40);
    if ( v12 > 255 )
      LOBYTE(v12) = -1;
    BYTE2(serverArenaSettings[1].SecurityMaxDeathWithoutFiring) = v12;
    v13 = GetCFGSettingInteger(v4, "PrizeWeight", "Gun", 60);
    if ( v13 > 255 )
      LOBYTE(v13) = -1;
    HIBYTE(serverArenaSettings[1].SecurityMaxDeathWithoutFiring) = v13;
    v14 = GetCFGSettingInteger(v4, "PrizeWeight", "Bomb", 50);
    if ( v14 > 255 )
      LOBYTE(v14) = -1;
    LOBYTE(serverArenaSettings[1].LatencyKickOutDelay) = v14;
    v15 = GetCFGSettingInteger(v4, "PrizeWeight", "BouncingBullets", 30);
    if ( v15 > 255 )
      LOBYTE(v15) = -1;
    BYTE1(serverArenaSettings[1].LatencyKickOutDelay) = v15;
    v16 = GetCFGSettingInteger(v4, "PrizeWeight", "Thruster", 70);
    if ( v16 > 255 )
      LOBYTE(v16) = -1;
    BYTE2(serverArenaSettings[1].LatencyKickOutDelay) = v16;
    v17 = GetCFGSettingInteger(v4, "PrizeWeight", "TopSpeed", 70);
    if ( v17 > 255 )
      LOBYTE(v17) = -1;
    HIBYTE(serverArenaSettings[1].LatencyKickOutDelay) = v17;
    v18 = GetCFGSettingInteger(v4, "PrizeWeight", "Recharge", 60);
    if ( v18 > 255 )
      LOBYTE(v18) = -1;
    LOBYTE(serverArenaSettings[1].LatencyNoFlagDelay) = v18;
    v19 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiFire", 30);
    if ( v19 > 255 )
      LOBYTE(v19) = -1;
    BYTE2(serverArenaSettings[1].LatencyNoFlagDelay) = v19;
    v20 = GetCFGSettingInteger(v4, "PrizeWeight", "Proximity", 30);
    if ( v20 > 255 )
      LOBYTE(v20) = -1;
    HIBYTE(serverArenaSettings[1].LatencyNoFlagDelay) = v20;
    v21 = GetCFGSettingInteger(v4, "PrizeWeight", "Glue", 20);
    if ( v21 > 255 )
      LOBYTE(v21) = -1;
    BYTE1(serverArenaSettings[1].LatencyNoFlagDelay) = v21;
    v22 = GetCFGSettingInteger(v4, "PrizeWeight", "AllWeapons", 10);
    if ( v22 > 255 )
      LOBYTE(v22) = -1;
    LOBYTE(serverArenaSettings[1].LatencyNoFlagPenalty) = v22;
    v23 = GetCFGSettingInteger(v4, "PrizeWeight", "Shields", 10);
    if ( v23 > 255 )
      LOBYTE(v23) = -1;
    BYTE1(serverArenaSettings[1].LatencyNoFlagPenalty) = v23;
    v24 = GetCFGSettingInteger(v4, "PrizeWeight", "Shrapnel", 40);
    if ( v24 > 255 )
      LOBYTE(v24) = -1;
    BYTE2(serverArenaSettings[1].LatencyNoFlagPenalty) = v24;
    v25 = GetCFGSettingInteger(v4, "PrizeWeight", "Repel", 40);
    if ( v25 > 255 )
      LOBYTE(v25) = -1;
    LOBYTE(serverArenaSettings[1].LatencySlowPacketKickoutPercent) = v25;
    v26 = GetCFGSettingInteger(v4, "PrizeWeight", "Burst", 30);
    if ( v26 > 255 )
      LOBYTE(v26) = -1;
    BYTE1(serverArenaSettings[1].LatencySlowPacketKickoutPercent) = v26;
    v27 = GetCFGSettingInteger(v4, "PrizeWeight", "Decoy", 20);
    if ( v27 > 255 )
      LOBYTE(v27) = -1;
    BYTE2(serverArenaSettings[1].LatencySlowPacketKickoutPercent) = v27;
    v28 = GetCFGSettingInteger(v4, "PrizeWeight", "Thor", 30);
    if ( v28 > 255 )
      LOBYTE(v28) = -1;
    HIBYTE(serverArenaSettings[1].LatencySlowPacketKickoutPercent) = v28;
    v29 = GetCFGSettingInteger(v4, "PrizeWeight", "Portal", 30);
    if ( v29 > 255 )
      LOBYTE(v29) = -1;
    HIBYTE(serverArenaSettings[1].LatencyClientSlowPacketKickoutPercent) = v29;
    v30 = GetCFGSettingInteger(v4, "PrizeWeight", "Brick", 10);
    if ( v30 > 255 )
      LOBYTE(v30) = -1;
    BYTE1(serverArenaSettings[1].LatencyClientSlowPacketKickoutPercent) = v30;
    v31 = GetCFGSettingInteger(v4, "PrizeWeight", "Rocket", 10);
    if ( v31 > 255 )
      LOBYTE(v31) = -1;
    BYTE2(serverArenaSettings[1].LatencyClientSlowPacketKickoutPercent) = v31;
    v32 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiPrize", 20);
    if ( v32 > 255 )
      LOBYTE(v32) = -1;
    LOBYTE(serverArenaSettings[1].LatencyClientSlowPacketKickoutPercent) = v32;
    Str1[0] = "Warbird";
    Str1[1] = "Javelin";
    Str1[2] = "Spider";
    Str1[3] = "Leviathan";
    Str1[4] = "Terrier";
    Str1[5] = "Weasel";
    Str1[6] = "Lancaster";
    Str1[7] = "Shark";
    for ( Filenamea = 0; (int)Filenamea < 8; ++Filenamea )
    {
      v33 = Str1[(_DWORD)Filenamea];
      v34 = &serverArenaSettings->CustomSaveStatsTime + 36 * (_DWORD)Filenamea;
      *v34 = GetCFGSettingInteger(v4, v33, "SuperTime", 6000);
      v34[1] = GetCFGSettingInteger(v4, v33, "ShieldsTime", 4000);
      *((_WORD *)v34 + 4) = GetCFGSettingInteger(v4, v33, "Gravity", 1500);
      *((_WORD *)v34 + 5) = GetCFGSettingInteger(v4, v33, "GravityTopSpeed", 100);
      *((_WORD *)v34 + 6) = GetCFGSettingInteger(v4, v33, "BulletFireEnergy", 20);
      *((_WORD *)v34 + 7) = GetCFGSettingInteger(v4, v33, "MultiFireEnergy", 30);
      *((_WORD *)v34 + 8) = GetCFGSettingInteger(v4, v33, "BombFireEnergy", 300);
      *((_WORD *)v34 + 9) = GetCFGSettingInteger(v4, v33, "BombFireEnergyUpgrade", 50);
      *((_WORD *)v34 + 10) = GetCFGSettingInteger(v4, v33, "LandmineFireEnergy", 300);
      *((_WORD *)v34 + 11) = GetCFGSettingInteger(v4, v33, "LandmineFireEnergyUpgrade", 150);
      *((_WORD *)v34 + 12) = GetCFGSettingInteger(v4, v33, "BulletSpeed", 2000);
      *((_WORD *)v34 + 13) = GetCFGSettingInteger(v4, v33, "BombSpeed", 2000);
      v35 = -(Filenamea != (char *)4);
      LOBYTE(v35) = v35 & 0xFB;
      *((_WORD *)v34 + 40) = GetCFGSettingInteger(v4, v33, "BulletFireDelay", v35 + 30);
      *((_WORD *)v34 + 41) = GetCFGSettingInteger(v4, v33, "MultiFireDelay", 50);
      *((_WORD *)v34 + 42) = GetCFGSettingInteger(v4, v33, "BombFireDelay", 150);
      *((_WORD *)v34 + 43) = GetCFGSettingInteger(v4, v33, "LandmineFireDelay", 125);
      *((_WORD *)v34 + 15) = GetCFGSettingInteger(v4, v33, "MultiFireAngle", 500);
      v36 = -(Filenamea != (char *)7);
      LOBYTE(v36) = v36 & 0x38;
      *((_WORD *)v34 + 16) = GetCFGSettingInteger(v4, v33, "CloakEnergy", v36 + 300);
      *((_WORD *)v34 + 17) = GetCFGSettingInteger(v4, v33, "StealthEnergy", Filenamea != (char *)7 ? 333 : 300);
      *((_WORD *)v34 + 18) = GetCFGSettingInteger(v4, v33, "AntiWarpEnergy", 100);
      *((_WORD *)v34 + 19) = GetCFGSettingInteger(v4, v33, "XRadarEnergy", 250);
      if ( Filenamea )
      {
        if ( Filenamea == (char *)7 )
          v47 = 280;
        else
          v47 = 230;
      }
      else
      {
        v47 = 300;
      }
      *((_WORD *)&serverArenaSettings->KillDebtKills + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                   v4,
                                                                                   v33,
                                                                                   "MaximumRotation",
                                                                                   v47);
      if ( Filenamea == (char *)7 || (v37 = 17, !Filenamea) )
        v37 = 19;
      *((_WORD *)&serverArenaSettings->KillDebtKills + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "MaximumThrust",
                                                                                       v37);
      *((_WORD *)&serverArenaSettings->KillPointsPerFlag + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "MaximumSpeed",
                                                                                       Filenamea != (char *)1 ? 3250 : 3750);
      *((_WORD *)&serverArenaSettings->KillPointsPerFlag + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                           v4,
                                                                                           v33,
                                                                                           "MaximumRecharge",
                                                                                           1150);
      *((_WORD *)&serverArenaSettings->KillPointsMinimumBounty + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "MaximumEnergy",
                                                                                             Filenamea != (char *)7 ? 1700 : 1750);
      *((_WORD *)&serverArenaSettings->KillPointsMinimumBounty + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "InitialRotation",
                                                                                                 Filenamea != 0 ? 200 : 210);
      *((_WORD *)&serverArenaSettings->KillNoRewardKillDelay + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                           v4,
                                                                                           v33,
                                                                                           "InitialThrust",
                                                                                           16 - (Filenamea != 0));
      v38 = -(Filenamea != (char *)1);
      LOBYTE(v38) = v38 & 0x42;
      *((_WORD *)&serverArenaSettings->KillNoRewardKillDelay + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                               v4,
                                                                                               v33,
                                                                                               "InitialSpeed",
                                                                                               v38 + 2200);
      *((_WORD *)&serverArenaSettings->KillBountyRewardPercent + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "InitialRecharge",
                                                                                             Filenamea != (char *)2 ? 400 : 500);
      *((_WORD *)&serverArenaSettings->KillBountyRewardPercent + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "InitialEnergy",
                                                                                                 1000);
      *((_WORD *)&serverArenaSettings->KillFixedKillReward + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                         v4,
                                                                                         v33,
                                                                                         "UpgradeRotation",
                                                                                         40);
      *((_WORD *)&serverArenaSettings->KillFixedKillReward + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "UpgradeThrust",
                                                                                             2);
      *((_WORD *)&serverArenaSettings->PacketLossC2SKickOutPercent + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "UpgradeSpeed",
                                                                                                 250);
      *((_WORD *)&serverArenaSettings->PacketLossC2SKickOutPercent + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                                     v4,
                                                                                                     v33,
                                                                                                     "UpgradeRecharge",
                                                                                                     166);
      *((_WORD *)&serverArenaSettings->PacketLossC2SNegativeKickOutPercent + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(v4, v33, "UpgradeEnergy", 100);
      *((_WORD *)&serverArenaSettings->PacketLossC2SNegativeKickOutPercent + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(v4, v33, "AfterburnerEnergy", 1200);
      *((_WORD *)&serverArenaSettings->PacketLossS2CKickOutPercent + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "BombThrust",
                                                                                                 400);
      *((_WORD *)&serverArenaSettings->PacketLossS2CKickOutPercent + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                                     v4,
                                                                                                     v33,
                                                                                                     "BurstSpeed",
                                                                                                     3000);
      *((_BYTE *)&serverArenaSettings->TeamSpectatorFrequency + 144 * (_DWORD)Filenamea + 3) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "BurstShrapnel",
                                                                                                 24);
      *((_WORD *)&serverArenaSettings->PacketLossSpectatorPercentAdjust + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(v4, v33, "TurretThrustPenalty", 1);
      *((_WORD *)&serverArenaSettings->PacketLossSpectatorPercentAdjust + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(v4, v33, "TurretSpeedPenalty", 125);
      *((_BYTE *)&serverArenaSettings->TeamSpectatorFrequency + 144 * (_DWORD)Filenamea + 2) = GetCFGSettingInteger(
                                                                                                 v4,
                                                                                                 v33,
                                                                                                 "TurretLimit",
                                                                                                 5);
      *((_WORD *)&serverArenaSettings->MaxFlags + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                              v4,
                                                                              v33,
                                                                              "RocketTime",
                                                                              1000);
      *((_WORD *)&serverArenaSettings->MaxFlags + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                  v4,
                                                                                  v33,
                                                                                  "InitialBounty",
                                                                                  0);
      *((_BYTE *)&serverArenaSettings->MiscMaxLossesToPlay + 144 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                          v4,
                                                                                          v33,
                                                                                          "MaxMines",
                                                                                          5);
      *((_BYTE *)&serverArenaSettings->MiscMaxLossesToPlay + 144 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                              v4,
                                                                                              v33,
                                                                                              "RepelMax",
                                                                                              3);
      *((_BYTE *)&serverArenaSettings->MiscMaxLossesToPlay + 144 * (_DWORD)Filenamea + 2) = GetCFGSettingInteger(
                                                                                              v4,
                                                                                              v33,
                                                                                              "BurstMax",
                                                                                              3);
      *((_BYTE *)&serverArenaSettings->MiscMaxLossesToPlay + 144 * (_DWORD)Filenamea + 3) = GetCFGSettingInteger(
                                                                                              v4,
                                                                                              v33,
                                                                                              "DecoyMax",
                                                                                              3);
      *((_BYTE *)&serverArenaSettings->MiscSpectatorQuiet + 144 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                         v4,
                                                                                         v33,
                                                                                         "ThorMax",
                                                                                         3);
      *((_BYTE *)&serverArenaSettings->MiscSpectatorQuiet + 144 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "BrickMax",
                                                                                             3);
      *((_BYTE *)&serverArenaSettings->MiscSpectatorQuiet + 144 * (_DWORD)Filenamea + 2) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "RocketMax",
                                                                                             3);
      *((_BYTE *)&serverArenaSettings->MiscSpectatorQuiet + 144 * (_DWORD)Filenamea + 3) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "PortalMax",
                                                                                             3);
      *((_BYTE *)&serverArenaSettings->MessageBongAllowed + 144 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                         v4,
                                                                                         v33,
                                                                                         "InitialRepel",
                                                                                         0);
      *((_BYTE *)&serverArenaSettings->MessageBongAllowed + 144 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "InitialBurst",
                                                                                             0);
      *((_BYTE *)&serverArenaSettings->MessageBongAllowed + 144 * (_DWORD)Filenamea + 2) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "InitialBrick",
                                                                                             0);
      *((_BYTE *)&serverArenaSettings->MessageBongAllowed + 144 * (_DWORD)Filenamea + 3) = GetCFGSettingInteger(
                                                                                             v4,
                                                                                             v33,
                                                                                             "InitialRocket",
                                                                                             0);
      *((_BYTE *)&serverArenaSettings->FlagMode + 144 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                               v4,
                                                                               v33,
                                                                               "InitialThor",
                                                                               0);
      *((_BYTE *)&serverArenaSettings->FlagMode + 144 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                   v4,
                                                                                   v33,
                                                                                   "InitialDecoy",
                                                                                   Filenamea == (char *)2);
      *((_BYTE *)&serverArenaSettings->FlagMode + 144 * (_DWORD)Filenamea + 2) = GetCFGSettingInteger(
                                                                                   v4,
                                                                                   v33,
                                                                                   "InitialPortal",
                                                                                   0);
      *((_BYTE *)&serverArenaSettings->FlagMode + 144 * (_DWORD)Filenamea + 3) = GetCFGSettingInteger(
                                                                                   v4,
                                                                                   v33,
                                                                                   "BombBounceCount",
                                                                                   Filenamea == (char *)6);
      v39 = Filenamea == (char *)2 || Filenamea == (char *)7;
      v40 = GetCFGSettingInteger(v4, v33, "CloakStatus", v39);
      v41 = *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea);
      BYTE1(v41) &= 0xF3u;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = v41 | ((v40 & 3) << 10);
      v42 = GetCFGSettingInteger(v4, v33, "StealthStatus", (Filenamea == (char *)2) + 1);
      v43 = *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea);
      BYTE1(v43) &= 0xCFu;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((v42 & 3) << 12) | v43;
      v44 = GetCFGSettingInteger(v4, v33, "XRadarStatus", 1);
      v45 = *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea);
      BYTE1(v45) &= 0x3Fu;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((v44 & 3) << 14) | v45;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "AntiWarpStatus",
                                                                                       1) & 3) << 16) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFFFCFFFF;
      *((_WORD *)&serverArenaSettings->FlagReward + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                v4,
                                                                                v33,
                                                                                "DamageFactor",
                                                                                30);
      *((_WORD *)&serverArenaSettings->FlagReward + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                    v4,
                                                                                    v33,
                                                                                    "PrizeShareLimit",
                                                                                    100);
      *((_WORD *)&serverArenaSettings->FlagRewardMode + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                    v4,
                                                                                    v33,
                                                                                    "AttachBounty",
                                                                                    12);
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) ^= ((unsigned __int8)GetCFGSettingInteger(v4, v33, "ShrapnelMax", Filenamea != (char *)5 ? 8 : 0) ^ (unsigned __int8)*(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea)) & 0x1F;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = (32
                                                                                  * (GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "ShrapnelRate",
                                                                                       2) & 0x1F)) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFFFFFC1F;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "MaxGuns",
                                                                                       3) & 3) << 20) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFFCFFFFF;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "MaxBombs",
                                                                                       (Filenamea == (char *)3) + 2) & 3) << 24) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFCFFFFFF;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "InitialGuns",
                                                                                       (Filenamea == (char *)4) + 1) & 3) << 18) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFFF3FFFF;
      v46 = Filenamea == (char *)3 || Filenamea == (char *)5;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "InitialBombs",
                                                                                       v46) & 3) << 22) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFF3FFFFF;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = *(&serverArenaSettings->KillJackpotBountyPercent
                                                                                   + 36 * (_DWORD)Filenamea) & 0xF7FFFFFF | ((GetCFGSettingInteger(v4, v33, "EmpBomb", Filenamea == (char *)5) & 1) << 27);
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "SeeMines",
                                                                                       Filenamea == (char *)5) & 1) << 28) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xEFFFFFFF;
      *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) = ((GetCFGSettingInteger(
                                                                                       v4,
                                                                                       v33,
                                                                                       "DoubleBarrel",
                                                                                       Filenamea == (char *)4) & 1) << 26) | *(&serverArenaSettings->KillJackpotBountyPercent + 36 * (_DWORD)Filenamea) & 0xFBFFFFFF;
      *((_WORD *)&serverArenaSettings->FlagFriendlyTransfer + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                          v4,
                                                                                          v33,
                                                                                          "SoccerBallFriction",
                                                                                          12);
      *((_WORD *)&serverArenaSettings->FlagFriendlyTransfer + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                              v4,
                                                                                              v33,
                                                                                              "SoccerBallProximity",
                                                                                              64);
      *((_WORD *)&serverArenaSettings->FlagRewardMode + 72 * (_DWORD)Filenamea + 1) = GetCFGSettingInteger(
                                                                                        v4,
                                                                                        v33,
                                                                                        "SoccerThrowTime",
                                                                                        1200);
      *((_WORD *)&serverArenaSettings->TeamSpectatorFrequency + 72 * (_DWORD)Filenamea) = GetCFGSettingInteger(
                                                                                            v4,
                                                                                            v33,
                                                                                            "SoccerBallSpeed",
                                                                                            2500);
    }
    *(_DWORD *)&serverArenaSettings->MiscSheepMessage[236] = 1000
                                                           * GetCFGSettingInteger(
                                                               v4,
                                                               "Bullet",
                                                               "BulletDamageLevel",
                                                               200);
    *(_DWORD *)&serverArenaSettings->OwnerName[24] = 1000
                                                   * GetCFGSettingInteger(v4, "Bullet", "BulletDamageUpgrade", 100);
    *(_DWORD *)&serverArenaSettings->MiscSheepMessage[244] = GetCFGSettingInteger(v4, "Bullet", "BulletAliveTime", 550);
    *(_DWORD *)&serverArenaSettings->MiscSheepMessage[240] = 1000
                                                           * GetCFGSettingInteger(v4, "Bomb", "BombDamageLevel", 750);
    *(_DWORD *)&serverArenaSettings->MiscSheepMessage[248] = GetCFGSettingInteger(v4, "Bomb", "BombAliveTime", 6000);
    HIWORD(serverArenaSettings[1].KillDebtKills) = GetCFGSettingInteger(v4, "Bomb", "BombExplodeDelay", 150);
    HIWORD(serverArenaSettings[1].KillPointsPerFlag) = GetCFGSettingInteger(v4, "Bomb", "BombExplodePixels", 80);
    LOWORD(serverArenaSettings[1].KillBountyRewardPercent) = GetCFGSettingInteger(v4, "Bomb", "ProximityDistance", 3);
    HIWORD(serverArenaSettings[1].KillPointsMinimumBounty) = GetCFGSettingInteger(v4, "Bomb", "JitterTime", 72);
    BYTE1(serverArenaSettings[1].MessageTeamReliable) = GetCFGSettingInteger(v4, "Bomb", "BombSafety", 1);
    HIWORD(serverArenaSettings[1].MiscMaxLossesToPlay) = GetCFGSettingInteger(v4, "Bomb", "EBombShutdownTime", 400);
    LOWORD(serverArenaSettings[1].MiscSpectatorQuiet) = GetCFGSettingInteger(v4, "Bomb", "EBombDamagePercent", 1000);
    LOWORD(serverArenaSettings[1].FlagMode) = GetCFGSettingInteger(v4, "Bomb", "BBombDamagePercent", 1000);
    *(_DWORD *)&serverArenaSettings->OwnerName[16] = GetCFGSettingInteger(v4, "Mine", "MineAliveTime", 12000);
    HIBYTE(serverArenaSettings[1].MessageReliable) = GetCFGSettingInteger(v4, "Mine", "TeamMaxMines", 12);
    serverArenaSettings[1].TerritoryRewardMinimumPlayers = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelSpeed", 3000);
    serverArenaSettings[1].FlagResetDelay = 1000 * GetCFGSettingInteger(v4, "Shrapnel", "InactiveShrapDamage", 3);
    HIWORD(serverArenaSettings[1].FlagMode) = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelDamagePercent", 1000);
    LOBYTE(serverArenaSettings[1].MessageQuickMessageLimit) = GetCFGSettingInteger(v4, "Shrapnel", "Random", 1);
    *(_DWORD *)&serverArenaSettings->OwnerName[20] = 1000 * GetCFGSettingInteger(v4, "Burst", "BurstDamageLevel", 515);
    LOWORD(serverArenaSettings[1].FlagRewardMode) = GetCFGSettingInteger(v4, "Toggle", "AntiWarpPixels", 1500);
    LOWORD(serverArenaSettings[1].TeamSpectatorFrequency) = GetCFGSettingInteger(v4, "Prize", "MultiPrizeCount", 10);
    LOWORD(serverArenaSettings[1].TeamDesiredTeams) = GetCFGSettingInteger(v4, "Prize", "PrizeFactor", 1000);
    HIWORD(serverArenaSettings[1].TeamDesiredTeams) = GetCFGSettingInteger(v4, "Prize", "PrizeDelay", 300);
    BYTE1(serverArenaSettings[1].MessageDistance) = GetCFGSettingInteger(v4, "Prize", "PrizeHideCount", 30);
    LOWORD(serverArenaSettings[1].RandomFlags) = GetCFGSettingInteger(v4, "Prize", "MinimumVirtual", 256);
    HIWORD(serverArenaSettings[1].RandomFlags) = GetCFGSettingInteger(v4, "Prize", "UpgradeVirtual", 6);
    LOWORD(serverArenaSettings[1].MaxFlags) = GetCFGSettingInteger(v4, "Prize", "PrizeMaxExist", 8000);
    HIWORD(serverArenaSettings[1].MaxFlags) = GetCFGSettingInteger(v4, "Prize", "PrizeMinExist", 4000);
    LOWORD(serverArenaSettings[1].FlagReward) = GetCFGSettingInteger(v4, "Prize", "PrizeNegativeFactor", 300);
    LOWORD(serverArenaSettings[1].KillPointsMinimumBounty) = GetCFGSettingInteger(v4, "Prize", "DeathPrizeTime", 800);
    HIWORD(serverArenaSettings[1].KillNoRewardKillDelay) = GetCFGSettingInteger(v4, "Prize", "EngineShutdownTime", 700);
    HIBYTE(serverArenaSettings[1].MessageTeamReliable) = GetCFGSettingInteger(v4, "Prize", "TakePrizeReliable", 0);
    LOWORD(serverArenaSettings[1].PacketLossSpectatorPercentAdjust) = GetCFGSettingInteger(
                                                                        v4,
                                                                        "Flag",
                                                                        "FlaggerOnRadar",
                                                                        1);
    HIWORD(serverArenaSettings[1].PacketLossSpectatorPercentAdjust) = GetCFGSettingInteger(
                                                                        v4,
                                                                        "Flag",
                                                                        "FlaggerKillMultiplier",
                                                                        2);
    LOBYTE(serverArenaSettings[1].dwordB4) = GetCFGSettingInteger(v4, "Flag", "FlaggerGunUpgrade", 0);
    BYTE1(serverArenaSettings[1].dwordB4) = GetCFGSettingInteger(v4, "Flag", "FlaggerBombUpgrade", 0);
    LOWORD(serverArenaSettings[1].MiscTimedGame) = GetCFGSettingInteger(v4, "Flag", "FlaggerFireCostPercent", 1000);
    HIWORD(serverArenaSettings[1].MiscTimedGame) = GetCFGSettingInteger(v4, "Flag", "FlaggerDamagePercent", 1000);
    LOWORD(serverArenaSettings[1].FlagTerritoryRadius) = GetCFGSettingInteger(v4, "Flag", "FlaggerBombFireDelay", 0);
    HIWORD(serverArenaSettings[1].BrickSpan) = GetCFGSettingInteger(v4, "Flag", "FlaggerSpeedAdjustment", 0);
    LOWORD(serverArenaSettings[1].BrickSpan) = GetCFGSettingInteger(v4, "Flag", "FlaggerThrustAdjustment", 0);
    LOBYTE(serverArenaSettings[1].SecurityS2CKickOutPercentWeapons) = GetCFGSettingInteger(v4, "Flag", "CarryFlags", 1);
    *(_DWORD *)&serverArenaSettings->OwnerName[28] = GetCFGSettingInteger(v4, "Flag", "FlagDropDelay", 0);
    HIWORD(serverArenaSettings[1].KillJackpotBountyPercent) = GetCFGSettingInteger(v4, "Flag", "FlagDropResetReward", 0);
    serverArenaSettings[1].OwnerUserId = GetCFGSettingInteger(v4, "Flag", "EnterGameFlaggingDelay", 12000);
    LOWORD(serverArenaSettings[1].FlagFriendlyTransfer) = GetCFGSettingInteger(v4, "Flag", "FlagBlankDelay", 200);
    HIWORD(serverArenaSettings[1].FlagFriendlyTransfer) = GetCFGSettingInteger(v4, "Flag", "NoDataFlagDropDelay", 500);
    BYTE1(serverArenaSettings[1].MessageQuickMessageLimit) = GetCFGSettingInteger(v4, "Soccer", "BallBounce", 1);
    BYTE2(serverArenaSettings[1].MessageQuickMessageLimit) = GetCFGSettingInteger(v4, "Soccer", "AllowBombs", 1);
    HIBYTE(serverArenaSettings[1].MessageQuickMessageLimit) = GetCFGSettingInteger(v4, "Soccer", "AllowGuns", 1);
    HIWORD(serverArenaSettings[1].FlagTerritoryRadius) = GetCFGSettingInteger(v4, "Soccer", "PassDelay", 20);
    LOBYTE(serverArenaSettings[1].MessageReliable) = GetCFGSettingInteger(v4, "Soccer", "Mode", 1);
    LOWORD(serverArenaSettings[1].FlagTerritoryRadiusCentroid) = GetCFGSettingInteger(
                                                                   v4,
                                                                   "Soccer",
                                                                   "BallBlankDelay",
                                                                   200);
    BYTE2(serverArenaSettings[1].dwordB4) = GetCFGSettingInteger(v4, "Soccer", "UseFlagger", 0);
    HIBYTE(serverArenaSettings[1].dwordB4) = GetCFGSettingInteger(v4, "Soccer", "BallLocation", 0);
    BYTE2(serverArenaSettings[1].SecurityS2CKickOutPercentWeapons) = GetCFGSettingInteger(v4, "Radar", "RadarMode", 0);
    HIWORD(serverArenaSettings[1].MiscSpectatorQuiet) = GetCFGSettingInteger(v4, "Radar", "RadarNeutralSize", 128);
    HIWORD(serverArenaSettings[1].KillFixedKillReward) = GetCFGSettingInteger(v4, "Radar", "MapZoomFactor", 10);
    *(_DWORD *)&serverArenaSettings->OwnerName[8] = GetCFGSettingInteger(v4, "Team", "MaxFrequency", 9999);
    BYTE1(serverArenaSettings[1].MessageReliable) = GetCFGSettingInteger(v4, "Team", "MaxPerTeam", 6);
    BYTE2(serverArenaSettings[1].MessageReliable) = GetCFGSettingInteger(v4, "Team", "MaxPerPrivateTeam", 0);
    LOWORD(serverArenaSettings[1].PacketLossC2SKickOutPercent) = GetCFGSettingInteger(v4, "Kill", "MaxBonus", 0);
    HIWORD(serverArenaSettings[1].PacketLossC2SKickOutPercent) = GetCFGSettingInteger(v4, "Kill", "MaxPenalty", 0);
    LOWORD(serverArenaSettings[1].PacketLossC2SNegativeKickOutPercent) = GetCFGSettingInteger(
                                                                           v4,
                                                                           "Kill",
                                                                           "RewardBase",
                                                                           0);
    HIWORD(serverArenaSettings[1].KillBountyRewardPercent) = GetCFGSettingInteger(
                                                               v4,
                                                               "Kill",
                                                               "BountyIncreaseForKill",
                                                               6);
    LOWORD(serverArenaSettings[1].KillNoRewardKillDelay) = GetCFGSettingInteger(v4, "Kill", "EnterDelay", 200);
    *(_DWORD *)&serverArenaSettings->OwnerName[12] = GetCFGSettingInteger(v4, "Repel", "RepelSpeed", 5000);
    HIWORD(serverArenaSettings[1].PacketLossC2SNegativeKickOutPercent) = GetCFGSettingInteger(
                                                                           v4,
                                                                           "Repel",
                                                                           "RepelTime",
                                                                           225);
    LOWORD(serverArenaSettings[1].PacketLossS2CKickOutPercent) = GetCFGSettingInteger(v4, "Repel", "RepelDistance", 512);
    BYTE2(serverArenaSettings[1].MessageTeamReliable) = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    LOBYTE(serverArenaSettings[1].MessageDistance) = GetCFGSettingInteger(v4, "Message", "AllowAudioMessages", 1);
    LOBYTE(serverArenaSettings[1].MessageTeamReliable) = GetCFGSettingInteger(v4, "Wormhole", "GravityBombs", 1);
    serverArenaSettings[1].TerritoryRewardDelay = GetCFGSettingInteger(v4, "Wormhole", "SwitchTime", 0);
    LOWORD(serverArenaSettings[1].KillDebtKills) = GetCFGSettingInteger(v4, "Latency", "SendRoutePercent", 500);
    LOWORD(serverArenaSettings[1].CostPurchaseAnytime) = GetCFGSettingInteger(
                                                           v4,
                                                           "Latency",
                                                           "ClientSlowPacketSampleSize",
                                                           100);
    HIWORD(serverArenaSettings[1].TeamSpectatorFrequency) = GetCFGSettingInteger(v4, "Brick", "BrickTime", 12000);
    serverArenaSettings[1].CustomSaveStatsTime = GetCFGSettingInteger(v4, "Rocket", "RocketThrust", 25);
    serverArenaSettings[1].MiscBannerPoints = GetCFGSettingInteger(v4, "Rocket", "RocketSpeed", 5500);
    HIWORD(serverArenaSettings[1].FlagReward) = GetCFGSettingInteger(v4, "Door", "DoorDelay", 400);
    HIWORD(serverArenaSettings[1].FlagRewardMode) = GetCFGSettingInteger(v4, "Door", "DoorMode", -1);
    LOWORD(serverArenaSettings[1].MessageBongAllowed) = GetCFGSettingInteger(v4, byte_42BC84, "WarpPointDelay", 6000);
    *(_DWORD *)&serverArenaSettings->MiscSheepMessage[252] = GetCFGSettingInteger(
                                                               v4,
                                                               byte_42BC84,
                                                               "DecoyAliveTime",
                                                               3000);
    LOWORD(serverArenaSettings[1].KillFixedKillReward) = GetCFGSettingInteger(v4, byte_42BC84, "BounceFactor", 22);
    LOWORD(serverArenaSettings[1].KillPointsPerFlag) = GetCFGSettingInteger(v4, byte_42BC84, "SendPositionDelay", 10);
    HIBYTE(serverArenaSettings[1].MessageDistance) = GetCFGSettingInteger(v4, byte_42BC84, "SlowFrameCheck", 0);
    BYTE1(serverArenaSettings[1].SecurityS2CKickOutPercentWeapons) = GetCFGSettingInteger(
                                                                       v4,
                                                                       byte_42BC84,
                                                                       "AllowSavedShips",
                                                                       1);
    *(_DWORD *)serverArenaSettings->OwnerName = GetCFGSettingInteger(v4, byte_42BC84, "SafetyLimit", 90000);
    *(_DWORD *)&serverArenaSettings->OwnerName[4] = GetCFGSettingInteger(v4, byte_42BC84, "FrequencyShift", 900);
    HIWORD(serverArenaSettings[1].PacketLossS2CKickOutPercent) = GetCFGSettingInteger(
                                                                   v4,
                                                                   byte_42BC84,
                                                                   "TickerDelay",
                                                                   1000);
    BYTE2(serverArenaSettings[1].MessageDistance) = GetCFGSettingInteger(v4, byte_42BC84, "ExtraPositionData", 0);
    LOWORD(serverArenaSettings[1].MiscMaxLossesToPlay) = GetCFGSettingInteger(v4, byte_42BC84, "WarpRadiusLimit", 1024);
    serverArenaSettings[1].TerritoryRewardBaseFlags = GetCFGSettingInteger(
                                                        v4,
                                                        byte_42BC84,
                                                        "ActivateAppShutdownTime",
                                                        1500);
    HIWORD(serverArenaSettings[1].MessageBongAllowed) = GetCFGSettingInteger(v4, byte_42BC84, "NearDeathLevel", 0);
    HIBYTE(serverArenaSettings[1].SecurityS2CKickOutPercentWeapons) = GetCFGSettingInteger(
                                                                        v4,
                                                                        byte_42BC84,
                                                                        "VictoryMusic",
                                                                        1);
    LOWORD(serverArenaSettings[1].KillJackpotBountyPercent) = GetCFGSettingInteger(
                                                                v4,
                                                                "Latency",
                                                                "ClientSlowPacketTime",
                                                                40);
    HIWORD(serverArenaSettings[1].FlagTerritoryRadiusCentroid) = GetCFGSettingInteger(
                                                                   v4,
                                                                   "Latency",
                                                                   "S2CNoDataKickoutDelay",
                                                                   500);
  }
  if ( a3 )
  {
    *((_DWORD *)a3 + 1) = GetCFGSettingInteger(v4, "Custom", "SaveStatsTime", 720000);
    *((_DWORD *)a3 + 4) = GetCFGSettingInteger(v4, "Territory", "RewardDelay", 60000);
    *((_DWORD *)a3 + 5) = GetCFGSettingInteger(v4, "Territory", "RewardBaseFlags", 8);
    *((_DWORD *)a3 + 6) = GetCFGSettingInteger(v4, "Territory", "RewardMinimumPlayers", 5);
    *((_DWORD *)a3 + 7) = GetCFGSettingInteger(v4, "Territory", "RewardPoints", 30);
    *((_DWORD *)a3 + 8) = GetCFGSettingInteger(v4, "Periodic", "RewardDelay", 0);
    *((_DWORD *)a3 + 9) = GetCFGSettingInteger(v4, "Periodic", "RewardMinimumPlayers", 16);
    *((_DWORD *)a3 + 10) = GetCFGSettingInteger(v4, "Periodic", "RewardPoints", 50);
    *((_DWORD *)a3 + 31) = GetCFGSettingInteger(v4, "Flag", "FlagMode", 0);
    *((_DWORD *)a3 + 3) = GetCFGSettingInteger(v4, "Flag", "FlagResetDelay", 1440000);
    *((_DWORD *)a3 + 23) = GetCFGSettingInteger(v4, "Flag", "MaxFlags", 16);
    *((_DWORD *)a3 + 22) = GetCFGSettingInteger(v4, "Flag", "RandomFlags", 0);
    *((_DWORD *)a3 + 24) = GetCFGSettingInteger(v4, "Flag", "FlagReward", 1000);
    *((_DWORD *)a3 + 25) = GetCFGSettingInteger(v4, "Flag", "FlagRewardMode", 0);
    *((_DWORD *)a3 + 34) = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadius", 8);
    *((_DWORD *)a3 + 35) = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadiusCentroid", 0);
    *((_DWORD *)a3 + 26) = GetCFGSettingInteger(v4, "Flag", "FriendlyTransfer", 1);
    *((_DWORD *)a3 + 12) = GetCFGSettingInteger(v4, "Kill", "KillPointsPerFlag", 0);
    *((_DWORD *)a3 + 13) = GetCFGSettingInteger(v4, "Kill", "KillPointsMinimumBounty", 50);
    *((_DWORD *)a3 + 11) = GetCFGSettingInteger(v4, "Kill", "DebtKills", 0);
    *((_DWORD *)a3 + 14) = GetCFGSettingInteger(v4, "Kill", "NoRewardKillDelay", 0);
    *((_DWORD *)a3 + 15) = GetCFGSettingInteger(v4, "Kill", "BountyRewardPercent", 0);
    *((_DWORD *)a3 + 16) = GetCFGSettingInteger(v4, "Kill", "FixedKillReward", -1);
    *((_DWORD *)a3 + 32) = GetCFGSettingInteger(v4, "Kill", "JackpotBountyPercent", 0);
    *((_DWORD *)a3 + 39) = GetCFGSettingInteger(v4, "Team", "ForceEvenTeams", 0);
    *((_DWORD *)a3 + 21) = GetCFGSettingInteger(v4, "Team", "DesiredTeams", 2);
    *((_DWORD *)a3 + 27) = GetCFGSettingInteger(v4, "Team", "SpectatorFrequency", 8025);
    *((_DWORD *)a3 + 36) = GetCFGSettingInteger(v4, "Brick", "BrickSpan", 7);
    *((_DWORD *)a3 + 38) = GetCFGSettingInteger(v4, byte_42BC84, "FrequencyShipTypes", 0);
    *((_DWORD *)a3 + 2) = GetCFGSettingInteger(v4, byte_42BC84, "BannerPoints", 5000);
    *((_DWORD *)a3 + 28) = GetCFGSettingInteger(v4, byte_42BC84, "MaxLossesToPlay", 0);
    *((_DWORD *)a3 + 29) = GetCFGSettingInteger(v4, byte_42BC84, "SpectatorQuiet", 0);
    *((_DWORD *)a3 + 33) = GetCFGSettingInteger(v4, byte_42BC84, "TimedGame", 0);
    GetCFGSettingString(
      v4,
      byte_42BC84,
      "SheepMessage",
      "Sheep successfully cloned -- hello Dolly",
      (char *)a3 + 920,
      0x100u);
  }
  if ( v4 )
  {
    WriteCfgFile(v4);
    operator delete(v4);
  }
}
// 40F840: inconsistent function type and number of purged bytes

//----- (00411D70) --------------------------------------------------------
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3)
{
  int result; // eax

  switch ( SoccerMode )
  {
    case 1:
      result = a2 >= 512;
      break;
    case 2:
      result = a3 >= 512;
      break;
    case 3:
    case 4:
      if ( a2 >= 512 )
        result = a3 >= 512 ? 3 : 1;
      else
        result = a3 >= 512 ? 2 : 0;
      break;
    case 5:
    case 6:
      if ( a2 >= a3 )
        result = (a2 >= 1024 - a3) + 2;
      else
        result = a2 >= 1024 - a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00411E30) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *v3; // eax
  char *v4; // eax
  char *v6; // eax
  unsigned int v7; // ecx
  char v8; // al
  char *v9; // edi
  char *v10; // edx
  char *v11; // eax
  unsigned int v12; // kr04_4
  char *v13; // edi
  char *v14; // esi
  char v15; // cl
  char *v16; // edx
  unsigned int v17; // eax
  int v18; // edi
  const char **v19; // esi
  int v20; // [esp+0h] [ebp-70h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-64h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-20h] BYREF
  int *v23; // [esp+60h] [ebp-10h]
  int v24; // [esp+6Ch] [ebp-4h]

  v23 = &v20;
  v3 = GetCommandLineA();
  v4 = strstr(v3, "/SPAWN");
  if ( v4 )
    return RunCommandPrompt(v4 + 7);            // /SPAWN and SPACE
  GetModuleFileNameA(0, FileName, 0x100u);
  v6 = strrchr(FileName, '\\');
  if ( v6 )
  {
    v10 = v6 + 1;
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = v10;
  }
  else
  {
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = FileName;
  }
  qmemcpy(v9, "server.ini", 4 * (v7 >> 2) + (v8 & 3));
  GetModuleFileNameA(0, Filename2, 0x100u);
  v11 = strrchr(Filename2, '\\');
  if ( v11 )
  {
    v16 = v11 + 1;
    v17 = strlen("server.cfg") + 1;
    qmemcpy(v16, "server.cfg", 4 * (v17 >> 2));
    v14 = &MEMORY[0x42A098][4 * (v17 >> 2)];
    v13 = &v16[4 * (v17 >> 2)];
    v15 = v17;
  }
  else
  {
    v12 = strlen("server.cfg") + 1;
    qmemcpy(Filename2, "server.cfg", 4 * (v12 >> 2));
    v14 = &MEMORY[0x42A098][4 * (v12 >> 2)];
    v13 = &Filename2[4 * (v12 >> 2)];
    v15 = v12;
  }
  qmemcpy(v13, v14, v15 & 3);
  if ( argc > 1 )
  {
    v18 = argc - 1;
    v19 = argv + 1;
    do
    {
      if ( !_strcmpi(*v19, "/nb") )
        UseBillingServer = 0;
      ++v19;
      --v18;
    }
    while ( v18 );
  }
  ShutdownArguments = 0;
  nullsub_1();
  IsServerRunning = 0;
  while ( !IsServerRunning )
  {
    ServerInitialize();
    v24 = 0;
    ServerMainLoop();
    v24 = -1;
    ServerUninitialize();
  }
  nullsub_1();
  if ( ShutdownArguments )
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    StartupInfo.cb = 68;
    StartupInfo.lpTitle = "Spawned Command";
    CreateProcessA(0, &ShutdownArguments, 0, 0, 0, 0x210u, 0, 0, &StartupInfo, &ProcessInformation);
  }
  return 0;
}
// 42C840: using guessed type int UseBillingServer;
// 437CA8: using guessed type int IsServerRunning;

//----- (00412060) --------------------------------------------------------
void __cdecl ServerInitialize()
{
  int v0; // eax
  struct ARENA_SETTINGS *v1; // ecx
  int v2; // edi
  ARENA **v3; // esi
  SERVER_BIG_ARRAY *v4; // eax
  FILE *v5; // eax
  FILE *v6; // esi
  int v7; // eax
  struct TEXT_FILE_STRUCT *v8; // eax
  TEXT_FILE_STRUCT *v9; // eax
  struct TEXT_FILE_STRUCT *v10; // eax
  TEXT_FILE_STRUCT *v11; // eax
  DWORD v12; // esi
  int v13; // ebx
  struct PACKET_ATTACHMENT *v14; // eax
  PACKET_ATTACHMENT *v15; // eax
  DWORD v16; // esi
  int v17; // eax
  PACKET_ATTACHMENT *v18; // ebx
  struct PACKET_ATTACHMENT *v19; // eax
  PACKET_ATTACHMENT *v20; // eax
  int v21; // eax
  BILLING_SERVER_STRUCT *billingStruct; // eax
  BILLING_SERVER_STRUCT *v23; // eax
  PACKET_ATTACHMENT *v24; // esi
  SOCKET *BillerSockett; // eax
  SOCKET **v26; // esi
  SOCKET *DirectorySockett; // eax
  struct TEXT_FILE_STRUCT *v28; // eax
  TEXT_FILE_STRUCT *v29; // eax
  struct TEXT_FILE_STRUCT *v30; // eax
  struct TEXT_FILE_STRUCT *v31; // eax
  struct TEXT_FILE_STRUCT *v32; // eax
  TEXT_FILE_STRUCT *v33; // eax
  struct TEXT_FILE_STRUCT *v34; // eax
  TEXT_FILE_STRUCT *v35; // eax
  struct TEXT_FILE_STRUCT *v36; // eax
  TEXT_FILE_STRUCT *v37; // eax
  void *v38; // eax
  SOCKET *v39; // eax
  struct PACKET_ATTACHMENT *v40; // eax
  struct PACKET_ATTACHMENT *v41; // eax
  int SecurityArrayIndex; // [esp+14h] [ebp-428h]
  int LocalPointer; // [esp+18h] [ebp-424h] BYREF
  char Buffer[17]; // [esp+1Ch] [ebp-420h] BYREF
  char cp[512]; // [esp+30h] [ebp-40Ch] BYREF
  int Src[128]; // [esp+230h] [ebp-20Ch] BYREF
  int WhichPartRan; // [esp+438h] [ebp-4h]

  ShutdownArguments = 0;
  RecycleServer = 0;
  SubGameLogFileHandle = fopen("subgame.log", "wt");
  WriteSubGameLog("SubSpace Game Server f%d.%02d%c\n", 1, 34, 98);
  if ( SubGameLogFileHandle )
  {
    fclose(SubGameLogFileHandle);
    SubGameLogFileHandle = 0;
  }
  v0 = clock();
  setRNGSeed(v0);
  memset(LogArray, 0, sizeof(LogArray));
  memset(ZonePlayerList, 0, sizeof(ZonePlayerList));
  memset(ChatRelatedArray, 0, sizeof(ChatRelatedArray));
  MachineIdArrayCount = 0;
  CurrentLogLine = 0;
  ZonePlayerCount = 0;
  IncreasesRadarValueSomeHow = 0;
  dword_4D55D0 = 0;
  dword_4C8F38 = 0;
  PointsFileHandle = 0;
  SharewareAdvertisementsFound = 0;
  RegisteredAdvertisementsFound = 0;
  BothAdvertisementsFound = 0;
  ChatCounter64Max = 0;
  LoadWinsock();
  IsFileLastWrittenTime(FileName, (int)&LastTimeServerINIWasEdited);
  ReadServerINI();
  IsFileLastWrittenTime(Filename2, (int)&LastTimeMasterCFGWasEdited);
  LoadZoneCFGSettings(v1, (struct SERVERSIDE_ARENA_SETTINGS *)&ArenaSettings, (const char *)&ServersideArenaSettings);
  v2 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v3 = Arenas;
    do
    {
      if ( !_strcmpi((*v3)->SettingsFilename, Filename2) )
        (*v3)->NeedSettingsUpdate = 1;
      ++v2;
      ++v3;
    }
    while ( v2 < ArenaArrayLength );
  }
  LoadTemplateSSS();
  LoadMapSomething();
  LoadAdvertisements();
  *(_DWORD *)Buffer = 16;
  *(_DWORD *)&Buffer[4] = 0;                    // No FileName
  *(_DWORD *)&Buffer[8] = 0;                    // No FileName
  *(_DWORD *)&Buffer[12] = 0;                   // No FileName
  SecurityArrayIndex = 0;
  Buffer[16] = 0;                               // No FileName
  memset(Security, 0, sizeof(Security));
  do
  {
    if ( SecurityArrayIndex )
    {
      sprintf((char *)Src, "version%d\\", SecurityArrayIndex);
    }
    else if ( _access("version0", 0) == -1 )
    {
      LOBYTE(Src[0]) = 0;
    }
    else
    {
      sprintf((char *)Src, "version%d\\", 0);
    }
    v4 = &Security[SecurityArrayIndex];
    v4->Subspace131EXEBytes = 0;
    v4->Subspace133EXEBytes = 0;
    v4->Subspace132EXEBytes = 0;
    strcpy(cp, (const char *)Src);
    strcat(cp, "Update.exe");
    if ( _access(cp, 0) != -1 )
      Security[SecurityArrayIndex].Subspace131EXEBytes = CompressFile(
                                                           cp,
                                                           &Security[SecurityArrayIndex].Subspace131FileSize,
                                                           &LocalPointer,
                                                           Buffer,
                                                           0x11u,
                                                           0,
                                                           0);
    strcpy(cp, (const char *)Src);
    strcat(cp, "Update1.exe");
    if ( _access(cp, 0) != -1 )
      Security[SecurityArrayIndex].Subspace133EXEBytes = CompressFile(
                                                           cp,
                                                           &Security[SecurityArrayIndex].Subspace133FileSize,
                                                           &LocalPointer,
                                                           Buffer,
                                                           0x11u,
                                                           0,
                                                           0);
    strcpy(cp, (const char *)Src);
    strcat(cp, "Update2.exe");
    if ( _access(cp, 0) != -1 )
      Security[SecurityArrayIndex].Subspace132EXEBytes = CompressFile(
                                                           cp,
                                                           &Security[SecurityArrayIndex].Subspace132FileSize,
                                                           &LocalPointer,
                                                           Buffer,
                                                           0x11u,
                                                           0,
                                                           0);
    strcpy(cp, (const char *)Src);
    strcat(cp, "subspace.exe");
    if ( _access(cp, 0) != -1 )
    {
      Security[SecurityArrayIndex].SubspaceEXEChecksum = (char *)GetSubspaceEXEChecksum((int)cp, cp);
      _spawnlp(0, cp, (int)cp);
      v5 = fopen("scrty", "rb");
      v6 = v5;
      if ( v5 )
      {
        v7 = _fileno(v5);
        if ( _filelength(v7) != 4000 )
        {
          printf("Security file invalid size\n");
          exit(1);
        }
        fread(Security[SecurityArrayIndex].ScrtyData, 1u, 0xFA0u, v6);
        fclose(v6);
      }
      strcpy(cp, (const char *)Src);
      strcat(cp, "ipblock.txt");
      v8 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      WhichPartRan = 0;
      if ( v8 )
        InitializeTextFile(v8, cp, 1, 1);
      else
        v9 = 0;
      Security[SecurityArrayIndex].IPBlockText = v9;
      strcpy(cp, (const char *)Src);
      WhichPartRan = -1;
      strcat(cp, "ipallow.txt");
      v10 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      WhichPartRan = 1;
      if ( v10 )
        InitializeTextFile(v10, cp, 1, 1);
      else
        v11 = 0;
      WhichPartRan = -1;
      Security[SecurityArrayIndex].IPAllowText = v11;
    }
    ++SecurityArrayIndex;
  }
  while ( SecurityArrayIndex < 10 );
  CompressedNewsMemory = CompressFile("news.txt", &NewsTxtFileSize, &NewsTxtFileChecksum, Buffer, 0x11u, 1, 0);
  SetConsoleTitleA(BillingServerName);
  dword_4C8F3C = 1;
  memset(TotalSentForEachPacketType, 0, sizeof(TotalSentForEachPacketType));
  memset(TotalSentSizeForEachPacketType, 0, sizeof(TotalSentSizeForEachPacketType));
  memset(DirectoryConnectSockets, 0, sizeof(DirectoryConnectSockets));
  RadarValue = 0;
  ScreenValue = 0;
  ServerIterations = 0;
  DoubleValue = 0;
  Wave = 0;
  BillerSocket = 0;
  ServerStruct = 0;
  BillingConnectionStructPointer = 0;
  if ( UseBillingServer )
  {
    v12 = GetTickCount() / 0xA;
    v13 = GetTickCount() / 0xA;
    LocalPointer = v13;
    v14 = (struct PACKET_ATTACHMENT *)operator new(0x8C5Cu);
    WhichPartRan = 2;
    if ( v14 )
      StartServerListener(v14, 0, 0, 16, 0, 0x2000, 0x2000, 1);
    else
      v15 = 0;
    WhichPartRan = -1;
    ServerStruct = v15;
    EncryptionStruct = 0;
    while ( (int)abs32(GetTickCount() / 0xA - v13) < BillingAttemptTime )
    {
      if ( !EncryptionStruct )
      {
        WriteSubGameLog("Attempting to establish link to billing server...\n");
        v16 = GetTickCount() / 0xA;
        v17 = rand();
        EncryptionStruct = SomethingBillerServer(
                             ServerStruct,
                             (const char *)&BillingIP,
                             BillingPort,
                             ((int)(v16 + v17) >> 31) - (((int)(v16 + v17) >> 31) ^ (v16 + v17)),
                             0);
        v12 = GetTickCount() / 0xA;
      }
      PlayerDoNetworkOps(ServerStruct);
      if ( CheckIfBillingServerIsConnected((int)EncryptionStruct) == 2 )
        break;
      if ( (int)abs32(GetTickCount() / 0xA - v12) > 2000 )
      {
        sub_41B7A0(EncryptionStruct);
        v18 = ServerStruct;
        EncryptionStruct = 0;
        if ( ServerStruct )
        {
          CleanUpPacketAttachment(ServerStruct);
          operator delete(v18);
        }
        v19 = (struct PACKET_ATTACHMENT *)operator new(0x8C5Cu);
        WhichPartRan = 3;
        if ( v19 )
          StartServerListener(v19, 0, 0, 16, 0, 0x2000, 0x2000, 1);
        else
          v20 = 0;
        v13 = LocalPointer;
        WhichPartRan = -1;
        ServerStruct = v20;
      }
      if ( console_input_wrapper() )
      {
        v21 = getch();
        if ( (!v21 || v21 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          exit(1);
        }
      }
    }
    if ( CheckIfBillingServerIsConnected((int)EncryptionStruct) == 2 )
    {
      WriteSubGameLog("Billing server connected.\n");
      billingStruct = (BILLING_SERVER_STRUCT *)operator new(0x18u);
      WhichPartRan = 4;
      if ( billingStruct )
      {
        SendBillerServerConnectPacket(
          billingStruct,
          (int)HandleBillerPacket,
          BillingServerName,
          BillingServerId,
          BillingGroupId,
          BillingScoreId,
          BillingPassword,
          (int)ServerStruct,
          EncryptionStruct);
        WhichPartRan = -1;
        BillingConnectionStructPointer = v23;
      }
      else
      {
        WhichPartRan = -1;
        BillingConnectionStructPointer = 0;
      }
    }
    else
    {
      WriteSubGameLog("ERROR: Could not connect to billing server.\n");
      v24 = ServerStruct;
      BillingConnectionStructPointer = 0;
      if ( ServerStruct )
      {
        CleanUpPacketAttachment(ServerStruct);
        operator delete(v24);
      }
      ServerStruct = 0;
      WriteSubGameLog("Starting server in stand-alone mode.\n");
      BillerSockett = (SOCKET *)operator new(0xCu);
      WhichPartRan = 5;
      if ( BillerSockett )
        ConnectSocket(BillerSockett, (const char *)&BillingIP, BillingPort + 1, 0);
      WhichPartRan = -1;
      BillerSocket = 0;
    }
  }
  if ( strlen(DirectoryIPAddresses) > 4 )
  {
    strcpy((char *)Src, DirectoryIPAddresses);
    v26 = DirectoryConnectSockets;
    do
    {
      if ( !GetSplitNextDirectoryIP(cp, (char *)Src) )
        break;
      DirectorySockett = (SOCKET *)operator new(0xCu);
      WhichPartRan = 6;
      if ( DirectorySockett )
        ConnectSocket(DirectorySockett, cp, DirectoryPort, 0);
      *v26++ = 0;
      WhichPartRan = -1;
    }
    while ( (int)v26 < (int)&MiscDisableSharewareShips );
  }
  v28 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  WhichPartRan = 7;
  if ( v28 )
    InitializeTextFile(v28, "obscene.txt", 1, 1);
  else
    v29 = 0;
  WhichPartRan = -1;
  ObscenePointer = v29;
  v30 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  WhichPartRan = 8;
  if ( v30 )
    InitializeTextFile(v30, "idblock.txt", 0, 1);
  else
    v31 = 0;
  WhichPartRan = -1;
  IDBlockPointer = v31;
  v32 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  WhichPartRan = 9;
  if ( v32 )
    InitializeTextFile(v32, "permit.txt", 0, 1);
  else
    v33 = 0;
  WhichPartRan = -1;
  PermitPointer = v33;
  v34 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  WhichPartRan = 10;
  if ( v34 )
    InitializeTextFile(v34, "moderate.txt", 0, 1);
  else
    v35 = 0;
  WhichPartRan = -1;
  ModeratePointer = v35;
  v36 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  WhichPartRan = 11;
  if ( v36 )
    InitializeTextFile(v36, "reserved.txt", 0, 1);
  else
    v37 = 0;
  WhichPartRan = -1;
  ReservedPointer = v37;
  ServerListenPort = GetPrivateProfileIntWrapper(byte_42BC84, "Port", 382u, FileName);
  v38 = operator new(8u);
  WhichPartRan = 12;
  if ( v38 )
    v39 = (SOCKET *)ListenOnPort((SOCKET)v38, ServerListenPort + 1, (int)nullsub_1);
  else
    v39 = 0;
  WhichPartRan = -1;
  ZonePingSocket = v39;
  ArenaArrayLength = 0;
  v40 = (struct PACKET_ATTACHMENT *)operator new(35932u);
  WhichPartRan = 13;
  if ( v40 )
    StartServerListener(
      v40,
      (int)NewConnectionRequest,
      (int)PlayerHandleGamePacketWrapperSomething,
      1024,
      ServerListenPort,
      CommsOutgoingBufferSize,
      CommsIncomingBufferSize,
      CommsPacketHistoryMax);
  else
    v41 = 0;
  WhichPartRan = -1;
  ServerPacketAttachment = v41;
  SetPacketAttachmentEncryptMode(v41, CommsEncryptMode);
  sub_41B430(ServerPacketAttachment, CommsTransportBufferSize);
}
/* Orphan comments:
0x10 - File Transfer
*/
// 412186: variable 'v1' is possibly undefined
// 4125C8: variable 'v9' is possibly undefined
// 412663: variable 'v11' is possibly undefined
// 41278C: variable 'v15' is possibly undefined
// 4128CF: variable 'v20' is possibly undefined
// 4129B9: variable 'v23' is possibly undefined
// 412B48: variable 'v29' is possibly undefined
// 412B87: variable 'v31' is possibly undefined
// 412BC6: variable 'v33' is possibly undefined
// 412C05: variable 'v35' is possibly undefined
// 412C53: variable 'v37' is possibly undefined
// 412D12: variable 'v41' is possibly undefined
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 42C840: using guessed type int UseBillingServer;
// 431BB8: using guessed type int LastTimeServerINIWasEdited;
// 431BE8: using guessed type int RadarValue;
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432000: using guessed type int LastTimeMasterCFGWasEdited;
// 432004: using guessed type int RecycleServer;
// 437C18: using guessed type int DoubleValue;
// 437C1C: using guessed type int BillingAttemptTime;
// 437CA4: using guessed type int CurrentLogLine;
// 4386D4: using guessed type int MachineIdArrayCount;
// 438B10: using guessed type int ScreenValue;
// 4C8F38: using guessed type int dword_4C8F38;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4CA814: using guessed type int IncreasesRadarValueSomeHow;
// 4D55D0: using guessed type int dword_4D55D0;
// 4D89C8: using guessed type int Wave;
// 4D8AFC: using guessed type int SharewareAdvertisementsFound;
// 4D8B00: using guessed type int RegisteredAdvertisementsFound;
// 4D8B04: using guessed type int BothAdvertisementsFound;
// 4D8B18: using guessed type int ChatCounter64Max;

//----- (00412D50) --------------------------------------------------------
signed int __cdecl NewConnectionRequest(int IPAddress, __int16 Port, ENCRYPTION *encryption)
{
  int v3; // ebp
  int v4; // edi
  PLAYER **v5; // esi
  PLAYER **v6; // ebx
  PLAYER *v7; // eax
  PLAYER *v8; // eax
  int v9; // ecx
  PLAYER *Memory; // [esp+10h] [ebp-10h]

  v3 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v4 = 0;
    v5 = playerPointerList;
    v6 = &playerPointerList[1];
    do
    {
      if ( (*v5)->IPAddressDWORD == (struct in_addr *)IPAddress && (*v5)->Port == Port )
      {
        printf("Connection broken because same ip/port requested another connection\n");
        OrderDisconnect((*v5)->connection);
        Memory = *v5;
        if ( *v5 )
        {
          DisconnectUser(*v5);
          operator delete(Memory);
        }
        --ZonePlayerCount;
        memcpy(v5, v6, 4 * (v4 + ZonePlayerCount));
        --v3;
        v4 -= 0x3FFFFFFF;
        --v6;
        --v5;
      }
      ++v3;
      v4 += 0x3FFFFFFF;
      ++v6;
      ++v5;
    }
    while ( v3 < ZonePlayerCount );
  }
  v7 = (PLAYER *)operator new(0x35Du);
  if ( v7 )
    v8 = CreateNewPlayer(v7, (struct in_addr)IPAddress, Port, encryption);
  else
    v8 = 0;
  v9 = ZonePlayerCount;
  playerPointerList[ZonePlayerCount] = v8;
  ZonePlayerCount = v9 + 1;
  return 1;
}

//----- (00412E80) --------------------------------------------------------
void __cdecl PlayerHandleGamePacketWrapperSomething(char *packet, int packetSize, struct CONNECTION *a3)
{
  struct PLAYER *v3; // ecx

  v3 = ZonePlayerList[a3->PlayerId];
  if ( v3 )
    PlayerHandleGamePacket(v3, (unsigned __int8 *)packet, packetSize);
}

//----- (00412EB0) --------------------------------------------------------
void __cdecl ServerMainLoop()
{
  int (*GetTickCountt)(void); // ebp
  int i; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // edi
  struct PLAYER **v5; // esi
  unsigned int v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // edi
  struct PLAYER **v10; // esi
  int v11; // eax
  int v12; // edi
  char *v13; // esi
  struct PLAYER *v14; // ecx
  unsigned int v15; // eax
  int v16; // edi
  struct PLAYER **v17; // esi
  PLAYER **v18; // ebp
  int v19; // eax
  int v20; // edi
  struct ARENA **v21; // esi
  ARENA **v22; // ebp
  int v23; // eax
  DWORD (__stdcall *v24)(); // ebp
  int v25; // ebx
  int v26; // esi
  KICK *v27; // ebp
  KICK *v28; // edi
  __int64 v29; // rax
  DWORD v30; // eax
  int v31; // esi
  struct ARENA_SETTINGS *v32; // ecx
  int v33; // edi
  ARENA **v34; // esi
  struct TEXT_FILE_STRUCT **v35; // esi
  struct TEXT_FILE_STRUCT *v36; // ecx
  int v37; // edi
  struct PLAYER **v38; // esi
  DWORD v39; // eax
  int v40; // esi
  PLAYER *player; // [esp+10h] [ebp-1F4h]
  struct ARENA *bufa; // [esp+10h] [ebp-1F4h]
  DWORD LastSettingsReReadTime; // [esp+10h] [ebp-1F4h]
  DWORD LastPlayerArenaCheckTime; // [esp+14h] [ebp-1F0h]
  unsigned int LastDirectoryServerPingedTime; // [esp+18h] [ebp-1ECh]
  DWORD LastFilesReReadAndBillerConnectionCheckTime; // [esp+1Ch] [ebp-1E8h]
  unsigned int LastCPUIterationTime; // [esp+20h] [ebp-1E4h]
  char Buffer[17]; // [esp+24h] [ebp-1E0h] BYREF
  int v49; // [esp+38h] [ebp-1CCh] BYREF
  int v50; // [esp+3Ch] [ebp-1C8h] BYREF
  _WORD a2[226]; // [esp+40h] [ebp-1C4h] BYREF

  GetTickCount();
  GetTickCount();
  LastPlayerArenaCheckTime = GetTickCount() / 0xA;
  GetTickCount();
  GetTickCount();
  LastFilesReReadAndBillerConnectionCheckTime = GetTickCount() / 0xA;
  GetTickCount();
  LastDirectoryServerPingedTime = 0;
  IsEditedServerINIorCFG = 0;
  if ( !IsServerRunning )
  {
    GetTickCountt = (int (*)(void))GetTickCount;
    for ( i = 0; ; i = 0 )
    {
      if ( RecycleServer )
        return;
      LastCPUIterationTime = GetTickCountt() / 0xAu;
      if ( console_input_wrapper() )
      {
        v2 = getch();
        if ( (!v2 || v2 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          IsServerRunning = 1;
          return;
        }
      }
      if ( BillingConnectionStructPointer )
      {
        if ( IsBillingServerDisconnected(BillingConnectionStructPointer) )
        {
          WriteSubGameLog("Connection to billing server broken\n");
          RecycleServer = 1;
        }
        v3 = GetBillerLastReconnectTime(BillingConnectionStructPointer);
        if ( (int)(GetTickCountt() / 0xAu - v3) > BillingReconnectTime )
        {
          WriteSubGameLog("Connection to billing server timed out\n");
          RecycleServer = 1;
        }
        if ( RecycleServer )
        {
          v4 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v5 = playerPointerList;
            do
            {
              if ( (*v5)->MyArena )
                SendMessage(*v5, "NOTICE: Server recycling, please log back in shortly.", 1);
              ++v4;
              ++v5;
            }
            while ( v4 < ZonePlayerCount );
          }
          SendPacketsToEverybody(ServerPacketAttachment);
        }
      }
      ProcessZonePings((int)ZonePingSocket, ZonePlayerCount);
      v6 = GetTickCountt() / 0xAu;
      LOBYTE(v7) = PlayerDoNetworkOps(ServerPacketAttachment);
      if ( v7 )
      {
        do
        {
          if ( (int)(GetTickCountt() / 0xAu - v6) >= CPUProcessMaxTime )
            break;
          LOBYTE(v8) = PlayerDoNetworkOps(ServerPacketAttachment);
        }
        while ( v8 );
      }
      v9 = 0;
      if ( ZonePlayerCount > 0 )
      {
        v10 = playerPointerList;
        do
        {
          if ( (*v10)->SendWeaponUpdatePacket )
            SendWeaponPacket(*v10);
          ++v9;
          ++v10;
        }
        while ( v9 < ZonePlayerCount );
      }
      SendPacketsToEverybody(ServerPacketAttachment);
      v11 = IncreasesRadarValueSomeHow;
      ScreenValue += dword_4D55D0;
      v12 = 0;
      DoubleValue += dword_4C8F38;
      dword_4D55D0 = 0;
      dword_4C8F38 = 0;
      RadarValue += IncreasesRadarValueSomeHow;
      if ( IncreasesRadarValueSomeHow > 0 )
      {
        v13 = byte_4AF911;
        do
        {
          v14 = ZonePlayerList[*(_DWORD *)(v13 - 25)];
          if ( v14 )
          {
            sub_40DEA0(v14, v13 - 21, *v13, *v13);
            v11 = IncreasesRadarValueSomeHow;
          }
          ++v12;
          v13 += 26;
        }
        while ( v12 < v11 );
      }
      IncreasesRadarValueSomeHow = 0;
      if ( (int)abs32(GetTickCountt() / 0xAu - LastPlayerArenaCheckTime) > 30 )
      {
        v15 = GetTickCountt();
        HighestPlayerCountMaybeSomething = 0;
        LastPlayerArenaCheckTime = v15 / 0xA;
        if ( ZonePlayerCount > 0 )
        {
          v16 = 0;
          v17 = playerPointerList;
          v18 = &playerPointerList[1];
          do
          {
            LOBYTE(v19) = sub_40CF10(*v17);
            if ( v19 )
            {
              player = *v17;
              --ZonePlayerCount;
              memcpy(v17, v18, 4 * (v16 + ZonePlayerCount));
              if ( player )
              {
                DisconnectUser(player);
                operator delete(player);
              }
              --i;
              v16 -= 0x3FFFFFFF;
              --v18;
              --v17;
            }
            ++i;
            v16 += 0x3FFFFFFF;
            ++v18;
            ++v17;
          }
          while ( i < ZonePlayerCount );
          i = 0;
        }
        if ( ArenaArrayLength > 0 )
        {
          v20 = 0;
          v21 = Arenas;
          v22 = &Arenas[1];
          do
          {
            LOBYTE(v23) = ProcessArena(*v21);
            if ( v23 )
            {
              if ( (*v21)->ArenaName[0] )
                WriteSubGameLog("Private arena dropped: %s\n", (*v21)->ArenaName);
              else
                WriteSubGameLog("Arena dropped\n");
              bufa = *v21;
              if ( *v21 )
              {
                ShutdownArena(*v21);
                operator delete(bufa);
              }
              --ArenaArrayLength;
              memcpy(v21, v22, 4 * (v20 + ArenaArrayLength));
              --i;
              v20 -= 0x3FFFFFFF;
              --v22;
              --v21;
            }
            ++i;
            v20 += 0x3FFFFFFF;
            ++v22;
            ++v21;
          }
          while ( i < ArenaArrayLength );
        }
      }
      SendPacketsToEverybody(ServerPacketAttachment);
      ++ServerIterations;
      if ( (int)(GetTickCount() / 0xA - LastServerStatsAndKickedPlayersTime) > 6000 )
      {
        v24 = GetTickCount;
        memset(TotalSentForEachPacketType, 0, sizeof(TotalSentForEachPacketType));
        v25 = 0;
        memset(TotalSentSizeForEachPacketType, 0, sizeof(TotalSentSizeForEachPacketType));
        RadarValue = 0;
        ScreenValue = 0;
        ServerIterations = 0;
        DoubleValue = 0;
        Wave = 0;
        LastServerStatsAndKickedPlayersTime = GetTickCount() / 0xA;
        ResetPacketStatistics(ServerPacketAttachment);
        if ( MachineIdArrayCount <= 0 )
          goto SKIP_KICKED_USERS;
        v26 = 0;
        v27 = KickedUsers;
        v28 = &KickedUsers[1];
        do
        {
          v29 = (int)(GetTickCount() / 0xA - KickedUsers[v26].KickStartTime);
          if ( (signed int)((HIDWORD(v29) ^ v29) - HIDWORD(v29)) > KickedUsers[v26].KickDelayMilliseconds )
          {
            --MachineIdArrayCount;
            memcpy(v27, v28, 12 * MachineIdArrayCount - v26 * 12);
            --v25;
            --v26;
            --v28;
            --v27;
          }
          ++v25;
          ++v26;
          ++v28;
          ++v27;
        }
        while ( v25 < MachineIdArrayCount );
      }
      v24 = GetTickCount;
SKIP_KICKED_USERS:
      if ( (int)abs32(v24() / 0xA - LastDirectoryServerPingedTime) > 6000 )
      {
        v30 = v24();
        memset(a2, 0, 448u);
        LastDirectoryServerPingedTime = v30 / 0xA;
        a2[224] = 0;
        a2[1] = ZonePlayerCount;                // Player Count Directory Server
        a2[2] = BillingConnectionStructPointer != 0;// Score Keeping Directory Server
        *(_DWORD *)&a2[3] = 134;                // Server Version, Directory Server
        a2[0] = ServerListenPort;               // Sever Port, Directory Server
        strncpy((char *)&a2[5], BillingServerName, 0x20u);// Zone Name, Directory Server
        HIBYTE(a2[20]) = 0;
        strncpy((char *)&a2[21], DirectoryNamePassword, 0x10u);// Directory Password , Directory Server
        HIBYTE(a2[28]) = 0;
        strncpy((char *)&a2[45], DirectoryDescription, 250u);// Zone Description, Directory Server
        HIBYTE(a2[169]) = 0;
        v31 = (int)DirectoryConnectSockets;
        do
        {
          if ( *(_DWORD *)v31 )
          {
            SendDirectoryServerZoneUpdatePacket(*(void **)v31, a2, strlen((const char *)&a2[45]) + 91);// 91+250+91 = 432, yet memset is 448
            GetSocketRecvLag(*(_DWORD *)v31, &v50);
          }
          v31 += 4;
        }
        while ( v31 < (int)&MiscDisableSharewareShips );
      }
      if ( (int)abs32(v24() / 0xA - LastFilesReReadAndBillerConnectionCheckTime) > 18000 || IsEditedServerINIorCFG )
      {
        LastSettingsReReadTime = v24() / 0xA;
        if ( BillerSocket && !BillingConnectionStructPointer )
          SendDirectoryServerZoneUpdatePacket((void *)BillerSocket, 0, 0);
        dword_4C8F3C = 1;
        IsEditedServerINIorCFG = 0;
        LastFilesReReadAndBillerConnectionCheckTime = v24() / 0xA;
        if ( IsFileLastWrittenTime(FileName, (int)&LastTimeServerINIWasEdited) )
        {
          printf("INI settings different, re-reading\n");
          ReadServerINI();
          SetPacketAttachmentEncryptMode(ServerPacketAttachment, CommsEncryptMode);
          sub_41B430(ServerPacketAttachment, CommsTransportBufferSize);
        }
        if ( IsFileLastWrittenTime(Filename2, (int)&LastTimeMasterCFGWasEdited) )
        {
          printf("Master CFG settings different, re-reading\n");
          LoadZoneCFGSettings(
            v32,
            (struct SERVERSIDE_ARENA_SETTINGS *)&ArenaSettings,
            (const char *)&ServersideArenaSettings);
          v33 = 0;
          if ( ArenaArrayLength > 0 )
          {
            v34 = Arenas;
            do
            {
              if ( !_strcmpi((*v34)->SettingsFilename, Filename2) )
                (*v34)->NeedSettingsUpdate = 1;
              ++v33;
              ++v34;
            }
            while ( v33 < ArenaArrayLength );
          }
        }
        v35 = &Security[0].IPAllowText;
        do
        {
          v36 = *(v35 - 1);
          if ( v36 )
            LoadTextFile(v36, 0);
          if ( *v35 )
            LoadTextFile(*v35, 0);
          v35 += 1009;
        }
        while ( (int)v35 < (int)&ZonePlayerList[1006] );
        LoadTextFile(IDBlockPointer, 0);
        LoadTextFile(ObscenePointer, 0);
        LoadTextFile(PermitPointer, 0);
        LoadTextFile(ModeratePointer, 0);
        LoadTextFile(ReservedPointer, 0);
        *(_DWORD *)Buffer = 16;
        *(_DWORD *)&Buffer[4] = 0;
        *(_DWORD *)&Buffer[8] = 0;
        *(_DWORD *)&Buffer[12] = 0;
        Buffer[16] = 0;
        if ( IsFileLastWrittenTime("news.txt", (int)&LastTimeNewsTxtWasEdited) )
        {
          if ( CompressedNewsMemory )
            efree(CompressedNewsMemory);
          CompressedNewsMemory = CompressFile("news.txt", &NewsTxtFileSize, &NewsTxtFileChecksum, Buffer, 17u, 1, 0);
        }
        if ( BillerSocket && !BillingConnectionStructPointer && GetSocketRecvLag(BillerSocket, &v49) >= 0 )
        {
          v37 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v38 = playerPointerList;
            do
            {
              if ( (*v38)->MyArena )
                SendMessage(*v38, "NOTICE: Server recycling in order to restore scores, please log back in.", 1);
              ++v37;
              ++v38;
            }
            while ( v37 < ZonePlayerCount );
          }
          SendPacketsToEverybody(ServerPacketAttachment);
          RecycleServer = 1;
        }
        v39 = v24();
        printf("Re-read Settings: %d ms\n", 10 * (v39 / 0xA - LastSettingsReReadTime));
        fflush(&stdout);
      }
      sub_41B570(100);
      v40 = v24() / 0xA - LastCPUIterationTime;
      if ( v40 <= 2 || CPUSleepPerIteration )
        Sleep(CPUSleepTime);
      if ( v40 > CPUSlowIterationWarningLevel )
        WriteSubGameLog("Slow iteration warning: %d ms\n", 10 * v40);
      if ( IsServerRunning )
        return;
      GetTickCountt = (int (*)(void))GetTickCount;
    }
  }
}
/* Orphan comments:
0x10 - File Transfer
*/
// 41303A: variable 'v7' is possibly undefined
// 413062: variable 'v8' is possibly undefined
// 413175: variable 'v19' is possibly undefined
// 4131FA: variable 'v23' is possibly undefined
// 4135A1: variable 'v32' is possibly undefined
// 431BB8: using guessed type int LastTimeServerINIWasEdited;
// 431BE8: using guessed type int RadarValue;
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432000: using guessed type int LastTimeMasterCFGWasEdited;
// 432004: using guessed type int RecycleServer;
// 437C18: using guessed type int DoubleValue;
// 437CA8: using guessed type int IsServerRunning;
// 4386D4: using guessed type int MachineIdArrayCount;
// 438B10: using guessed type int ScreenValue;
// 438B14: using guessed type int CPUSlowIterationWarningLevel;
// 438B78: using guessed type int BillingReconnectTime;
// 4AC448: using guessed type KICK KickedUsers[1000];
// 4C8F38: using guessed type int dword_4C8F38;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4C9F44: using guessed type int CPUSleepPerIteration;
// 4CA814: using guessed type int IncreasesRadarValueSomeHow;
// 4D55D0: using guessed type int dword_4D55D0;
// 4D5904: using guessed type int CPUProcessMaxTime;
// 4D5920: using guessed type int IsEditedServerINIorCFG;
// 4D5924: using guessed type int LastTimeNewsTxtWasEdited;
// 4D89C8: using guessed type int Wave;
// 4D8AF4: using guessed type int LastServerStatsAndKickedPlayersTime;
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;

//----- (004137F0) --------------------------------------------------------
int __cdecl IncreaseRadarValueShowHomeOverFourThousand()
{
  int result; // eax
  int v1; // edi
  char *v2; // esi
  struct PLAYER *v3; // ecx

  result = IncreasesRadarValueSomeHow;
  v1 = 0;
  RadarValue += IncreasesRadarValueSomeHow;
  if ( IncreasesRadarValueSomeHow > 0 )
  {
    v2 = byte_4AF911;
    do
    {
      v3 = ZonePlayerList[*(_DWORD *)(v2 - 25)];
      if ( v3 )
      {
        sub_40DEA0(v3, v2 - 21, *v2, *v2);
        result = IncreasesRadarValueSomeHow;
      }
      ++v1;
      v2 += 26;
    }
    while ( v1 < result );
  }
  IncreasesRadarValueSomeHow = 0;
  return result;
}
// 431BE8: using guessed type int RadarValue;
// 4CA814: using guessed type int IncreasesRadarValueSomeHow;

//----- (00413850) --------------------------------------------------------
void __cdecl ServerUninitialize()
{
  int v0; // eax
  bool v1; // cc
  PLAYER **v2; // edi
  int v3; // ebx
  PLAYER *v4; // esi
  int v5; // ebx
  struct ARENA **v6; // edi
  struct ARENA *v7; // esi
  struct PACKET_ATTACHMENT *v8; // esi
  SOCKET *v9; // esi
  void *v10; // esi
  BILLING_SERVER_STRUCT *v11; // esi
  PACKET_ATTACHMENT *v12; // esi
  struct SOCKET **v13; // edi
  struct SOCKET *v14; // esi
  TEXT_FILE_STRUCT *v15; // esi
  TEXT_FILE_STRUCT *v16; // esi
  TEXT_FILE_STRUCT *v17; // esi
  TEXT_FILE_STRUCT *v18; // esi
  struct TEXT_FILE_STRUCT *v19; // esi
  TEXT_FILE_STRUCT **v20; // ebx
  void *v21; // esi
  TEXT_FILE_STRUCT *v22; // esi
  LPVOID *v23; // esi
  int v24; // edi
  struct BMP_FILE_STRUCT *v25; // esi

  v0 = ZonePlayerCount;
  v1 = ZonePlayerCount <= 0;
  ZonePlayerCount = 0;
  if ( !v1 )
  {
    v2 = playerPointerList;
    v3 = v0;
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        DisconnectUser(*v2);
        operator delete(v4);
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v5 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v6 = Arenas;
    do
    {
      v7 = *v6;
      if ( *v6 )
      {
        ShutdownArena(*v6);
        operator delete(v7);
      }
      ++v5;
      ++v6;
    }
    while ( v5 < ArenaArrayLength );
  }
  ArenaArrayLength = 0;
  if ( PointsFileHandle )
  {
    fclose(PointsFileHandle);
    PointsFileHandle = 0;
  }
  v8 = ServerPacketAttachment;
  if ( ServerPacketAttachment )
  {
    CleanUpPacketAttachment(ServerPacketAttachment);
    operator delete(v8);
  }
  v9 = ZonePingSocket;
  if ( ZonePingSocket )
  {
    CloseSocketWrapper((struct SOCKET *)ZonePingSocket);
    operator delete(v9);
  }
  v10 = (void *)BillerSocket;
  if ( BillerSocket )
  {
    CloseSocketWrapper((struct SOCKET *)BillerSocket);
    operator delete(v10);
  }
  v11 = BillingConnectionStructPointer;
  if ( BillingConnectionStructPointer )
  {
    CleanUpBilling(BillingConnectionStructPointer);
    operator delete(v11);
  }
  v12 = ServerStruct;
  if ( ServerStruct )
  {
    CleanUpPacketAttachment(ServerStruct);
    operator delete(v12);
  }
  v13 = (struct SOCKET **)DirectoryConnectSockets;
  do
  {
    v14 = *v13;
    if ( *v13 )
    {
      CloseSocketWrapper(*v13);
      operator delete(v14);
    }
    ++v13;
  }
  while ( (int)v13 < (int)&MiscDisableSharewareShips );
  v15 = ObscenePointer;
  if ( ObscenePointer )
  {
    CleanTextFileMemory(ObscenePointer);
    operator delete(v15);
  }
  v16 = PermitPointer;
  if ( PermitPointer )
  {
    CleanTextFileMemory(PermitPointer);
    operator delete(v16);
  }
  v17 = ModeratePointer;
  if ( ModeratePointer )
  {
    CleanTextFileMemory(ModeratePointer);
    operator delete(v17);
  }
  v18 = ReservedPointer;
  if ( ReservedPointer )
  {
    CleanTextFileMemory(ReservedPointer);
    operator delete(v18);
  }
  v19 = IDBlockPointer;
  if ( IDBlockPointer )
  {
    CleanTextFileMemory(IDBlockPointer);
    operator delete(v19);
  }
  if ( CompressedNewsMemory )
  {
    efree(CompressedNewsMemory);
    CompressedNewsMemory = 0;
  }
  v20 = &Security[0].IPAllowText;
  do
  {
    v21 = *(v20 - 1);
    if ( v21 )
    {
      CleanTextFileMemory(*(v20 - 1));
      operator delete(v21);
    }
    v22 = *v20;
    if ( *v20 )
    {
      CleanTextFileMemory(*v20);
      operator delete(v22);
    }
    v23 = (LPVOID *)(v20 - 1008);
    v24 = 3;
    do
    {
      if ( *v23 )
      {
        efree(*v23);
        *v23 = 0;
      }
      ++v23;
      --v24;
    }
    while ( v24 );
    v20 += 1009;
  }
  while ( (int)v20 < (int)&ZonePlayerList[1006] );
  v25 = BMPFilePointer;
  if ( BMPFilePointer )
  {
    sub_406B30(BMPFilePointer);
    operator delete(v25);
  }
  efree(CompressedServerMap);
  efree(ServerMapAllocatedMemory);
  CleanUpMemory();
  j_WSACleanup();
  if ( SubGameLogFileHandle )
    fclose(SubGameLogFileHandle);
  SubGameLogFileHandle = 0;
}
// 431FF4: using guessed type int ArenaArrayLength;

//----- (00413AE0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __cdecl HandleBillerPacket(__int64 buffer)
{
  int v1; // eax
  struct PLAYER **v2; // esi
  int v3; // edx
  struct PLAYER **k; // eax
  int v5; // ecx
  PLAYER **j; // eax
  PLAYER *v7; // esi
  int v8; // ecx
  PLAYER **i; // eax
  PLAYER *v10; // ebp
  char v11; // al
  __int16 v12; // ax
  int v13; // ebx
  _DWORD *v14; // eax
  PLAYER **v15; // esi
  ARENA *v16; // eax
  __int16 *v17; // eax
  int v18; // ecx
  PLAYER *v19; // edi
  bool v20; // cc
  int v21; // ecx
  int v22; // eax
  char *v23; // ecx
  int v24; // edx
  int v25; // eax
  char v26; // [esp-2h] [ebp-84Ah]
  char v27; // [esp+11h] [ebp-837h] BYREF
  int v28; // [esp+12h] [ebp-836h]
  _DWORD *v29; // [esp+16h] [ebp-832h]
  PLAYER **v30; // [esp+1Ah] [ebp-82Eh]
  int Src_2; // [esp+1Eh] [ebp-82Ah]
  _BYTE v32[2]; // [esp+22h] [ebp-826h] BYREF
  _DWORD buf[9]; // [esp+24h] [ebp-824h] BYREF
  void *retaddr; // [esp+848h] [ebp+0h] OVERLAPPED

  switch ( **(_BYTE **)((char *)&retaddr + 2) )
  {
    case 1:
      v8 = 0;
      v28 = *(_DWORD *)((char *)&buffer + 2) - 178;
      v29 = *(char **)((char *)&retaddr + 2) + 178;
      if ( ZonePlayerCount > 0 )
      {
        for ( i = playerPointerList; ; ++i )
        {
          v10 = *i;
          if ( (*i)->BillerPlayerId == *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 2) )
            break;
          if ( ++v8 >= ZonePlayerCount )
            return;
        }
        v11 = (*(_BYTE **)((char *)&retaddr + 2))[1];
        v27 = 0xA;                              // 0x0A - Server is Full
        Src_2 = 0;
        switch ( v11 )
        {
          case 0:
          case 6:
            v27 = 0;                            // 0x00 - Login OK
            if ( v11 == 6 )
              Src_2 = 1;
            v13 = (int)&v10->CurrentWins;
            qmemcpy(
              &v10->PlayerDataBillerPacket,
              *(char **)((char *)&retaddr + 2) + 6,
              sizeof(v10->PlayerDataBillerPacket));
            if ( v28 == 14 )
            {
              v14 = v29;
              *(_DWORD *)v13 = *v29;
              *(_DWORD *)&v10->CurrentGoals = v14[1];
              *(int *)((char *)&v10->KillPoints + 2) = v14[2];
              HIWORD(v10->FlagPoints) = *((_WORD *)v14 + 6);
            }
            else
            {
              *(_DWORD *)v13 = 0;
              *(_DWORD *)&v10->CurrentGoals = 0;
              *(int *)((char *)&v10->KillPoints + 2) = 0;
              HIWORD(v10->FlagPoints) = 0;
            }
            if ( v10->DemoPlayer )
            {
              *(_DWORD *)v13 = 0;
              *(_DWORD *)&v10->CurrentGoals = 0;
              *(int *)((char *)&v10->KillPoints + 2) = 0;
              HIWORD(v10->FlagPoints) = 0;
            }
            *(_DWORD *)&v10->PersonalBestWins = *(_DWORD *)v13;
            *(_DWORD *)&v10->PersonalBestGoalCount = *(_DWORD *)&v10->CurrentGoals;
            *(int *)((char *)&v10->PersonalBestKillPoints + 2) = *(int *)((char *)&v10->KillPoints + 2);
            HIWORD(v10->PersonalBestFlagPoints) = HIWORD(v10->FlagPoints);
            if ( !v10->IsModerator )
            {
              if ( PermissionMaxPoints && v10->FlagPoints + v10->KillPoints > PermissionMaxPoints )
                v27 = 7;                        // 0x07 - Too many points to Play here
              if ( (signed int)v10->PlayerDataBillerPacket.UsageTotalSeconds < PermissionMinimumSecondsToLogin )
                v27 = 0xF;                      // 0x0F - Not enough usage to play here.
            }
            v29 = 0;
            if ( ZonePlayerCount > 0 )
            {
              v28 = 0;
              v15 = playerPointerList;
              v30 = &playerPointerList[1];
              do
              {
                if ( *v15 != v10 && !_strcmpi((*v15)->PlayerDataBillerPacket.Name, v10->PlayerDataBillerPacket.Name) )
                {
                  WriteSubGameLog(
                    "Player %s already on, kicking them off (lost connection probably)\n",
                    v10->PlayerDataBillerPacket.Name);
                  v16 = v10->MyArena;
                  if ( v16 )
                  {
                    if ( !v16->ServersideArenaSettings.MiscTimedGame )
                    {
                      v17 = &(*v15)->CurrentWins;
                      if ( (unsigned __int16)*v17
                         + (*v15)->KillPoints
                         + (*v15)->FlagPoints
                         + (unsigned __int16)(*v15)->CurrentLosses > *(unsigned __int16 *)v13
                                                                   + v10->FlagPoints
                                                                   + v10->KillPoints
                                                                   + (unsigned __int16)v10->CurrentLosses )
                      {
                        *(_DWORD *)v13 = *(_DWORD *)v17;
                        *(_DWORD *)&v10->CurrentGoals = *((_DWORD *)v17 + 1);
                        *(int *)((char *)&v10->KillPoints + 2) = *((_DWORD *)v17 + 2);
                        HIWORD(v10->FlagPoints) = v17[6];
                        v18 = (int)&(*v15)->PersonalBestWins;
                        *(_DWORD *)&v10->PersonalBestWins = *(_DWORD *)v18;
                        *(_DWORD *)&v10->PersonalBestGoalCount = *(_DWORD *)(v18 + 4);
                        *(int *)((char *)&v10->PersonalBestKillPoints + 2) = *(_DWORD *)(v18 + 8);
                        HIWORD(v10->PersonalBestFlagPoints) = *(_WORD *)(v18 + 12);
                      }
                    }
                  }
                  v19 = *v15;
                  if ( *v15 )
                  {
                    DisconnectUser(*v15);
                    operator delete(v19);
                  }
                  --ZonePlayerCount;
                  memcpy(v15, v30, 4 * (v28 + ZonePlayerCount));
                  v29 = (_DWORD *)((char *)v29 - 1);
                  v28 -= 0x3FFFFFFF;
                  --v30;
                  --v15;
                }
                v28 += 0x3FFFFFFF;
                ++v15;
                v20 = (int)v29 + 1 < ZonePlayerCount;
                v29 = (_DWORD *)((char *)v29 + 1);
                ++v30;
              }
              while ( v20 );
            }
            if ( PermissionMode == 2 && !v10->IsModerator && IsBannedMachineId(PermitPointer, v10->PlayerName) < 0 )
              goto LABEL_71;
            break;
          case 1:
            v27 = 1;                            // 0x01 - Unregistered Player
            break;
          case 2:
            v27 = 2;                            // 0x02 - Bad Password
            v10->DisconnectReason = 18;
            v10->KickOffDelayTimer = GetTickCount() / 0xA;
            break;
          case 3:
            v27 = 4;                            // 0x04 - Locked Out of Zone
            WriteSubGameLog("Player kicked off for IP block: %s\n", v10->PlayerName);
            v10->DisconnectReason = 11;
            v10->AlreadySentReliablePacket = 1;
            break;
          case 4:
            v27 = 0xA;                          // 0x0A - Server is Full
            break;
          case 5:
            v27 = 0xB;                          // 0x0B - Invalid Name
            break;
          case 7:
            v27 = 0xE;                          // 0x0E - Server Busy, try Later
            break;
          case 8:
            v27 = 0x10;                         // 0x10 - Restricted Zone
            *(_DWORD *)&v10->CurrentWins = 0;
            *(_DWORD *)&v10->CurrentGoals = 0;
            *(int *)((char *)&v10->KillPoints + 2) = 0;
            HIWORD(v10->FlagPoints) = 0;
            *(_DWORD *)&v10->PersonalBestWins = *(_DWORD *)&v10->CurrentWins;
            *(_DWORD *)&v10->PersonalBestGoalCount = *(_DWORD *)&v10->CurrentGoals;
            v12 = HIWORD(v10->FlagPoints);
            *(int *)((char *)&v10->PersonalBestKillPoints + 2) = *(int *)((char *)&v10->KillPoints + 2);
            HIWORD(v10->PersonalBestFlagPoints) = v12;
            qmemcpy(
              &v10->PlayerDataBillerPacket,
              *(char **)((char *)&retaddr + 2) + 6,
              sizeof(v10->PlayerDataBillerPacket));
            strcpy(v10->PlayerDataBillerPacket.Name, v10->PlayerName);
            v10->BillerPlayerId = -1;
            if ( PermissionMode == 2 && !v10->IsModerator )
            {
LABEL_71:
              v27 = 6;                          // 0x06 - Permission to Spectate Only
              v10->IsSpeced = 1;
            }
            break;
          default:
            break;
        }
        v32[1] = v27;                           // Login Response
        v21 = v10->SubspaceEXEChecksumIndex;
        *(_DWORD *)((char *)&buf[5] + 2) = NewsTxtFileChecksum;// News.txt Checksum
        BYTE1(buf[4]) = Src_2;                  // Registration Form Request (Boolean)
        v32[0] = 0xA;                           // 0x0A - Password Packet Response
        v22 = v21;
        buf[0] = 134;                           // Server Version
        buf[1] = 0;                             // ? Unknown
        v23 = Security[v21].SubspaceEXEChecksum;// Subspace.exe Checksum
        v24 = *(_DWORD *)&Security[v22].ScrtyData[4];
        v25 = v10->IsModerator;
        buf[3] = 0;                             // ? Unknown
        LOBYTE(buf[4]) = 0;                     // ? Unknown
        buf[2] = v23;
        *(_DWORD *)((char *)&buf[4] + 2) = v24;
        if ( v25 )
        {
          buf[2] = -1;
          *(_DWORD *)((char *)&buf[4] + 2) = -1;
        }
        SendPlayerReliablePacket(v10, v32, 36u, 1);
        if ( !v10->DemoPlayer )
        {
          v27 = 0x31;                           // 0x31 - Post Login Sequence
          SendPlayerReliablePacket(v10, &v27, 1u, 1);
        }
      }
      break;
    case 2:
      WriteSubGameLog("Shutdown packet received, shutting down server...\n");
      IsServerRunning = 1;
      break;
    case 3:
      if ( (*(_BYTE **)((char *)&retaddr + 2))[5] == 1 )
      {
        if ( IsBannedMachineId(PermitPointer, *(char **)((char *)&retaddr + 2) + 6) < 0 )
        {
          AddLineTextFile(PermitPointer, *(char **)((char *)&retaddr + 2) + 6);
          WriteTextFileToFile(PermitPointer);
        }
      }
      else if ( (*(_BYTE **)((char *)&retaddr + 2))[5] == 2 )
      {
        if ( (*(_BYTE **)((char *)&retaddr + 2))[7] == ':' )
        {
          ChatProcessor(
            0,
            (PLAYER *)7,
            0,
            *(int *)((char *)&retaddr + 2) + 7,
            (const char *)(*(char **)((char *)&retaddr + 2))[6],
            v26);
          JUMPOUT(0x413C71);
        }
        ChatProcessor(
          0,
          0,
          0,
          *(int *)((char *)&retaddr + 2) + 7,
          (const char *)(*(char **)((char *)&retaddr + 2))[6],
          v26);
        JUMPOUT(0x413C90);
      }
      return;
    case 4:
      RecycleServer = 1;
      break;
    case 8:
      v5 = 0;
      if ( ZonePlayerCount > 0 )
      {
        for ( j = playerPointerList; ; ++j )
        {
          v7 = *j;
          if ( (*j)->BillerPlayerId == *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1) )
            break;
          if ( ++v5 >= ZonePlayerCount )
            return;
        }
        WriteSubGameLog(
          "Player kicked off by billing server, reason #%d\n",
          *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 5));
        v7->DisconnectReason = 21;
        v7->AlreadySentReliablePacket = 1;
      }
      break;
    case 9:
      v3 = 0;
      if ( ZonePlayerCount > 0 )
      {
        for ( k = playerPointerList; (*k)->BillerPlayerId != *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1); ++k )
        {
          if ( ++v3 >= ZonePlayerCount )
            return;
        }
        SendMessage(*k, *(const char **)((char *)&retaddr + 2) + 5, 0);
      }
      break;
    case 0xA:
      v1 = 0;
      v2 = playerPointerList;
      if ( ZonePlayerCount > 0 )
      {
        while ( (*v2)->BillerPlayerId != *(_DWORD *)(*(char **)((char *)&retaddr + 2) + 1) )
        {
          ++v1;
          ++v2;
          if ( v1 >= ZonePlayerCount )
            return;
        }
        sprintf(
          (char *)&buf[8] + 2,
          "%d:%s",
          (*(char **)((char *)&retaddr + 2))[5],
          *(const char **)((char *)&retaddr + 2) + 6);
        SendChannelMessage(*v2, (const char *)&buf[8] + 2);
      }
      break;
    default:
      return;
  }
}
// 413C7E: positive sp value 2 has been found
// 413C6C: control flows out of bounds to 413C71
// 413C8B: control flows out of bounds to 413C90
// 413F2A: conditional instruction was optimized away because of 'eax.4==0'
// 413AE0: variables would overlap: ^860.4(retaddr) and ^862.4
// 432004: using guessed type int RecycleServer;
// 437CA8: using guessed type int IsServerRunning;
// 438B1C: using guessed type int PermissionMode;
// 438B7C: using guessed type int PermissionMinimumSecondsToLogin;
// 4AC438: using guessed type int PermissionMaxPoints;

//----- (004141F0) --------------------------------------------------------
void FormatMessageArena(ARENA *arena, const char *Format, ...)
{
  struct tm *timeinfo; // eax
  char *v3; // eax
  int v4; // edi
  PLAYER **v5; // esi
  FILE *v6; // eax
  char Str[132]; // [esp+Ch] [ebp-484h] BYREF
  char v8[512]; // [esp+90h] [ebp-400h] BYREF
  char Dest[512]; // [esp+290h] [ebp-200h] BYREF
  va_list Args; // [esp+49Ch] [ebp+Ch] BYREF

  va_start(Args, Format);
  time(Str);
  timeinfo = localtime((const time_t *)Str);
  strcpy(&Str[4], asctime(timeinfo));
  v3 = strstr(&Str[4], " 199");                 // 199x year?
  if ( v3 || (v3 = strstr(&Str[4], " 200")) != 0 )// 200x year?
    *v3 = 0;                                    // Useless code I guess?
  vsprintf(v8, Format, Args);
  sprintf(Dest, "%s:  %s", &Str[4], v8);
  v4 = 0;
  if ( arena->ArenaPlayerCount > 0 )
  {
    v5 = (PLAYER **)arena->playerPointersForSomething;
    do
    {
      v6 = (*v5)->pfile329;
      if ( v6 )
        fprintf(v6, "%s", Dest);
      ++v4;
      ++v5;
    }
    while ( v4 < arena->ArenaPlayerCount );
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (00414310) --------------------------------------------------------
void WriteSubGameLog(const char *Format, ...)
{
  FILE *v1; // eax
  struct tm *timeinfo; // eax
  char *v3; // eax
  char *v4; // edx
  char *v5; // eax
  char v6; // cl
  char Str[132]; // [esp+8h] [ebp-484h] BYREF
  char Dest[512]; // [esp+8Ch] [ebp-400h] BYREF
  char v9[512]; // [esp+28Ch] [ebp-200h] BYREF
  va_list Args; // [esp+494h] [ebp+8h] BYREF

  va_start(Args, Format);
  v1 = SubGameLogFileHandle;
  if ( SubGameLogFileHandle )
    goto LABEL_5;
  if ( MiscServerLog )
  {
    v1 = fopen("subgame.log", "at");
    SubGameLogFileHandle = v1;
  }
  if ( v1 )
  {
LABEL_5:
    if ( !MiscServerLog )
    {
      fclose(v1);
      SubGameLogFileHandle = 0;
    }
  }
  time(Str);
  timeinfo = localtime((const time_t *)Str);
  strcpy(&Str[4], asctime(timeinfo));
  v3 = strstr(&Str[4], " 199");                 // 199x year?
  if ( v3 || (v3 = strstr(&Str[4], " 200")) != 0 )// 200x year?
    *v3 = 0;                                    // Useless code I guess?
  vsprintf(v9, Format, Args);
  sprintf(Dest, "%s:  %s", &Str[4], v9);
  if ( SubGameLogFileHandle )
    fprintf(SubGameLogFileHandle, "%s", Dest);
  printf("%s", Dest);
  v4 = &LogArray[256 * CurrentLogLine];
  strcpy(v4, Dest);
  v5 = v4;
  if ( *v4 >= 32 )
  {
    do
      v6 = *++v5;
    while ( v6 >= 32 );
  }
  *v5 = 0;
  CurrentLogLine = (CurrentLogLine + 1) % 48;
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 437CA4: using guessed type int CurrentLogLine;
// 4D55CC: using guessed type int MiscServerLog;

//----- (004144C0) --------------------------------------------------------
bool __cdecl IsOffensiveName(char *a1)
{
  char *v1; // esi
  char *v2; // edi
  TEXT_FILE_STRUCT *v4; // ecx
  int v5; // edi
  int v6; // esi
  char *v7; // eax
  char *v8; // eax
  char Str[400]; // [esp+8h] [ebp-190h] BYREF

  v1 = a1;
  v2 = Str;
  if ( *a1 )
  {
    do
    {
      if ( isalpha(*v1) )
        *v2++ = toupper(*v1);
    }
    while ( *++v1 );
  }
  v4 = ObscenePointer;
  *v2 = 0;
  v5 = TextFileTotalLines(v4);
  v6 = 0;
  if ( v5 <= 0 )
  {
    LOBYTE(v8) = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = TextFileByIndex(ObscenePointer, v6);
      v8 = strstr(Str, v7);
      if ( v8 )                                 // found
        break;
      if ( ++v6 >= v5 )                         // checked all on list and not found
        return (char)v8;
    }
    LOBYTE(v8) = 1;
  }
  return (char)v8;
}

//----- (00414560) --------------------------------------------------------
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2)
{
  int v2; // ebp
  int v3; // ebx
  struct TEXT_FILE_STRUCT *v4; // edx
  unsigned int v5; // kr04_4
  signed int v6; // esi
  int v7; // eax
  char *v8; // edx
  unsigned int v9; // ecx
  TEXT_FILE_STRUCT *v11; // edx
  unsigned int v12; // kr10_4
  signed int v13; // esi
  int v14; // ebp
  char *v15; // edx
  unsigned int v16; // ecx
  int v17; // [esp+14h] [ebp-4h]
  int v18; // [esp+14h] [ebp-4h]
  int SecurityArrayIndexa; // [esp+1Ch] [ebp+4h]

  v2 = 0;
  v3 = SecurityArrayIndex;
  v4 = Security[SecurityArrayIndex].IPAllowText;
  if ( !v4 )
    goto LABEL_17;
  SecurityArrayIndexa = 1;
  v5 = strlen(a2) + 1;
  v6 = v5 - 1;
  if ( v5 == 1 )
  {
    SecurityArrayIndexa = 0;
  }
  else
  {
    v7 = TextFileTotalLines(v4);
    v17 = v7;
    if ( v7 )
    {
      if ( v7 > 0 )
      {
        while ( 1 )
        {
          v8 = TextFileByIndex(Security[v3].IPBlockText, v2);
          if ( v6 >= (int)strlen(v8) )
            v9 = strlen(v8);
          else
            v9 = v6;
          if ( !memcmp(a2, v8, v9) )
            SecurityArrayIndexa = 0;
          if ( ++v2 >= v17 )
            break;
          v6 = v5 - 1;
        }
      }
    }
    else
    {
      SecurityArrayIndexa = 0;
    }
  }
  if ( SecurityArrayIndexa )
    return 1;
LABEL_17:
  v11 = Security[v3].IPBlockText;
  if ( !v11 )
    return 0;
  v12 = strlen(a2) + 1;
  v13 = v12 - 1;
  if ( v12 == 1 )
    return 0;
  v14 = 0;
  v18 = TextFileTotalLines(v11);
  if ( v18 <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = TextFileByIndex(Security[v3].IPBlockText, v14);
    v16 = v13 >= (int)strlen(v15) ? strlen(v15) : v13;
    if ( !memcmp(a2, v15, v16) )
      break;
    if ( ++v14 >= v18 )
      return 0;
    v13 = v12 - 1;
  }
  return 1;
}

//----- (004146D0) --------------------------------------------------------
void __cdecl SendBillerWarnings(const char *a1, struct PLAYER *player)
{
  int v2; // eax
  char *v3; // eax
  int v4; // esi
  struct PLAYER **v5; // ebx
  struct PLAYER *v6; // edx
  int v7; // [esp-4h] [ebp-414h]
  int v8; // [esp-4h] [ebp-414h]
  char stringBuffer[512]; // [esp+10h] [ebp-400h] BYREF
  char buffer[512]; // [esp+210h] [ebp-200h] BYREF

  strcpy(stringBuffer, a1);
  if ( player )
  {
    v7 = player->UsageSessionSeconds;
    v2 = time(0);
    v8 = (__int64)difftime(v2, v7);
    v3 = GetIPAddressString((struct in_addr)player->IPAddressDWORD);
    sprintf(stringBuffer, "%s (%s)(%d)(%s)(sec=%d)", a1, player->PlayerName, player->MachineId, v3, v8);
  }
  WriteSubGameLog("%s\n", stringBuffer);
  *(_WORD *)&buffer[3] = -1;                    // Originator ID
  buffer[0] = 7;                                // 0x07 - Chat
  buffer[1] = 8;                                // Chat Type - 0x08 - Red server errors, without a name tag (S2C only)
  buffer[2] = 0;                                // Sound Byte
  strcpy(&buffer[5], stringBuffer);             // Chat Message
  v4 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v5 = playerPointerList;
    do
    {
      v6 = *v5;
      if ( (*v5)->MyArena && v6->IsSysop )
        SendPlayerReliablePacket(v6, buffer, strlen(stringBuffer) + 6, 1);
      ++v4;
      ++v5;
    }
    while ( v4 < ZonePlayerCount );
  }
  if ( BillingConnectionStructPointer )
  {
    if ( player )
      SendBillerWarningPacket(BillingConnectionStructPointer, player->BillerPlayerId, stringBuffer);
    else
      SendBillerWarningPacket(BillingConnectionStructPointer, 0, stringBuffer);
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (00414850) --------------------------------------------------------
void __cdecl ChatProcessor(LPPROCESS_INFORMATION lpProcessInformation, PLAYER *player, char *a4, int arenaPlayerIndex, const char *ChatText, char sound)
{
  int v6; // edi
  struct _EXCEPTION_REGISTRATION_RECORD *v7; // eax
  void *v8; // esp
  char *v9; // ebx
  PLAYER *v10; // ebp
  PLAYER *v11; // edi
  PLAYER *v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // eax
  char v16; // al
  const char *v17; // ebx
  struct BILLING_SERVER_STRUCT *v18; // edx
  PLAYER *v19; // eax
  int v20; // esi
  char *v21; // ecx
  int v22; // edx
  int v23; // ebx
  ARENA *v24; // eax
  int v25; // esi
  int v26; // edi
  int v27; // eax
  ARENA **v28; // ecx
  int v29; // esi
  int v30; // edi
  int v31; // esi
  int v32; // ecx
  int v33; // eax
  int v34; // eax
  char *v35; // ebx
  char v36; // al
  int v37; // eax
  char *v38; // ebx
  char v39; // al
  int v40; // eax
  char *v41; // ebx
  char v42; // al
  struct TEXT_FILE_STRUCT *v43; // ebx
  char *v44; // edx
  char *v45; // edi
  int v46; // edi
  int n; // esi
  char *v48; // eax
  int ii; // esi
  const char *v50; // edx
  char *v51; // ebx
  PLAYER *v52; // eax
  int v53; // edx
  BOOL v54; // ecx
  PLAYER *v55; // eax
  int v56; // edx
  BOOL v57; // ecx
  char v58; // cl
  char *v59; // eax
  char *jj; // edx
  char v61; // cl
  char v62; // cl
  char *v63; // eax
  char *kk; // edx
  char v65; // cl
  char v66; // cl
  _BYTE *v67; // eax
  char *ll; // edx
  char *v69; // eax
  char v70; // al
  char *v71; // esi
  char *mm; // ecx
  char v73; // al
  char v74; // al
  _BYTE *v75; // esi
  char *nn; // ecx
  char v77; // al
  _BYTE *v78; // esi
  char *i1; // ecx
  char *v80; // ebx
  BILLING_SERVER_STRUCT *v81; // edx
  int v82; // eax
  char *v83; // ebx
  char v84; // al
  ARENA *v85; // eax
  unsigned int v86; // kr48_4
  int v87; // edi
  struct PLAYER **v88; // ebx
  PLAYER *v89; // ecx
  PLAYER *v90; // esi
  char *v91; // eax
  ARENA *v92; // eax
  int v93; // ecx
  int v94; // eax
  struct CONNECTION *v95; // ecx
  int v96; // edi
  int v97; // edx
  int v98; // edi
  double v99; // st7
  int v100; // eax
  int v101; // ecx
  int v102; // eax
  double v103; // st7
  int v104; // ecx
  unsigned int v105; // edx
  unsigned int v106; // edi
  int v107; // eax
  int v108; // edi
  int v109; // ecx
  struct CONNECTION *v110; // ecx
  PLAYER *v111; // eax
  int v112; // edx
  int v113; // eax
  char *v114; // edi
  char v115; // al
  char v116; // al
  bool v117; // zf
  __int16 v118; // ax
  PLAYER *v119; // edi
  ARENA *v120; // eax
  int v121; // ecx
  int v122; // edx
  PLAYER *v123; // eax
  ARENA *v124; // eax
  int v125; // ecx
  int v126; // edx
  PLAYER *v127; // eax
  PLAYER *v128; // eax
  char *v129; // eax
  int v130; // eax
  char *v131; // edi
  char v132; // al
  ARENA *v133; // eax
  unsigned int v134; // kr5C_4
  int v135; // eax
  char *v136; // edi
  char v137; // al
  int v138; // eax
  char *v139; // edi
  char v140; // al
  struct TEXT_FILE_STRUCT *v141; // eax
  __int16 v142; // ax
  PLAYER *v143; // esi
  int v144; // edx
  char v145; // al
  char *v146; // edi
  char v147; // al
  PLAYER *v148; // esi
  int v149; // edx
  PLAYER *v150; // esi
  int v151; // edi
  int v152; // eax
  int v153; // esi
  int v154; // eax
  struct ARENA *v155; // ecx
  int v156; // edi
  struct ARENA **v157; // esi
  struct PLAYER *v158; // ecx
  int v159; // edi
  struct PLAYER **v160; // esi
  PLAYER *v161; // ecx
  ARENA *v162; // ecx
  FILE *v163; // eax
  const char *v164; // edi
  int v165; // ebx
  int v166; // eax
  FILE *v167; // eax
  ARENA *v168; // eax
  int v169; // esi
  int v170; // edi
  const char *v171; // esi
  int v172; // edx
  int v173; // eax
  int v174; // esi
  char *i; // ebx
  int j; // ebx
  ARENA *v177; // eax
  int v178; // ecx
  const char *v179; // edi
  int v180; // ebx
  int v181; // esi
  ARENA *v182; // edx
  int v183; // eax
  int v184; // esi
  int v185; // edi
  int *v186; // edx
  int v187; // ecx
  __int64 v188; // rax
  ARENA *v189; // eax
  int v190; // edx
  int v191; // ecx
  __int16 v192; // ax
  int v193; // eax
  int v194; // ecx
  int v195; // eax
  int UserIdCheck; // eax
  ARENA *v197; // ecx
  char *v198; // eax
  char *v199; // edx
  char *v200; // ebx
  struc_2 *v201; // eax
  struc_2 *v202; // esi
  char *v203; // esi
  char **v204; // ebp
  int v205; // eax
  int v206; // eax
  int v207; // eax
  char *v208; // edx
  struct ARENA *v209; // ecx
  int v210; // ebx
  PLAYER *v211; // ecx
  int v212; // esi
  __int64 v213; // rax
  __int64 v214; // rax
  const char *v215; // edi
  int v216; // edx
  int v217; // ecx
  int v218; // edx
  char *v219; // ebx
  char *v220; // ebx
  ARENA *v221; // eax
  signed int v222; // ecx
  signed int v223; // ecx
  unsigned __int64 v224; // rax
  int v225; // ecx
  signed int v226; // eax
  char v227; // al
  char *v228; // edi
  char *k; // ecx
  char v230; // al
  char v231; // al
  char *v232; // edi
  char *l; // ecx
  char v234; // al
  char *v235; // edi
  char *v236; // esi
  struct TEXT_FILE_STRUCT *v238; // ecx
  int v239; // edi
  int v240; // esi
  char *v241; // eax
  ARENA *v242; // ecx
  int v243; // eax
  LPPROCESS_INFORMATION v244; // eax
  __int64 v245; // rax
  __int64 v246; // rax
  __int64 v247; // rax
  const char *v248; // ebx
  char *v249; // edi
  char *v250; // esi
  ARENA *v251; // eax
  ARENA *v252; // eax
  char *v253; // eax
  int v254; // edx
  struct PLAYER *v255; // esi
  bool v256; // cc
  ARENA **v257; // edi
  ARENA *v258; // eax
  int v259; // ebx
  int v260; // esi
  unsigned int v261; // krA4_4
  ARENA **v262; // esi
  int v263; // ebp
  int v264; // edi
  ARENA *v265; // edx
  int v266; // esi
  unsigned int v267; // ecx
  char *v268; // ecx
  char v269; // al
  char *m; // edx
  char v271; // al
  char v272; // al
  const char *v273; // ecx
  int v274; // eax
  int v275; // eax
  unsigned int v276; // krB4_4
  int v277; // edi
  struct PLAYER **v278; // ebp
  unsigned __int64 v279; // [esp+0h] [ebp-16090h]
  int v280; // [esp+8h] [ebp-16088h]
  const char *v281; // [esp+8h] [ebp-16088h]
  int v282; // [esp+Ch] [ebp-16084h]
  int v283; // [esp+Ch] [ebp-16084h]
  const char *v284; // [esp+10h] [ebp-16080h]
  unsigned __int64 v285; // [esp+10h] [ebp-16080h]
  const char *v286; // [esp+10h] [ebp-16080h]
  __int64 v287; // [esp+10h] [ebp-16080h]
  const char *v288; // [esp+10h] [ebp-16080h]
  const char *v289; // [esp+10h] [ebp-16080h]
  unsigned __int64 v290; // [esp+10h] [ebp-16080h]
  unsigned __int64 v291; // [esp+10h] [ebp-16080h]
  BOOL v292; // [esp+14h] [ebp-1607Ch]
  int v293; // [esp+14h] [ebp-1607Ch]
  int v294; // [esp+14h] [ebp-1607Ch]
  char *v295; // [esp+14h] [ebp-1607Ch]
  int v296; // [esp+18h] [ebp-16078h]
  ARENA **a5; // [esp+28h] [ebp-16068h] BYREF
  struct ARENA *a6; // [esp+2Ch] [ebp-16064h] BYREF
  int a3; // [esp+30h] [ebp-16060h] BYREF
  int YouToServer; // [esp+34h] [ebp-1605Ch] BYREF
  char Buffer3[7]; // [esp+38h] [ebp-16058h] BYREF
  char v302; // [esp+3Fh] [ebp-16051h] BYREF
  size_t Size; // [esp+40h] [ebp-16050h] BYREF
  int v304; // [esp+44h] [ebp-1604Ch]
  int ASyncS2CEnd; // [esp+48h] [ebp-16048h] BYREF
  int a2; // [esp+4Ch] [ebp-16044h] BYREF
  char v307[15]; // [esp+50h] [ebp-16040h] BYREF
  int v308; // [esp+60h] [ebp-16030h] BYREF
  char array1[32]; // [esp+64h] [ebp-1602Ch] BYREF
  char CommandLine[256]; // [esp+84h] [ebp-1600Ch] BYREF
  char Dest[256]; // [esp+184h] [ebp-15F0Ch] BYREF
  char Str1[64]; // [esp+284h] [ebp-15E0Ch] BYREF
  char AppName[64]; // [esp+2C4h] [ebp-15DCCh] BYREF
  char buf[512]; // [esp+304h] [ebp-15D8Ch] BYREF
  _STARTUPINFOA startupInfo; // [esp+504h] [ebp-15B8Ch] BYREF
  char v316[6]; // [esp+604h] [ebp-15A8Ch] BYREF
  char v317[6]; // [esp+804h] [ebp-1588Ch] BYREF
  char FileTransferBuffer[17]; // [esp+2804h] [ebp-1388Ch] BYREF
  char v319; // [esp+2815h] [ebp-1387Bh] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v320; // [esp+16084h] [ebp-Ch]
  void *v321; // [esp+16088h] [ebp-8h]
  int v322; // [esp+1608Ch] [ebp-4h]
  PLAYER *retaddr[2]; // [esp+16090h] [ebp+0h]
  char *a4a; // [esp+160A0h] [ebp+10h]

  v322 = -1;
  v7 = NtCurrentTeb()->NtTib.ExceptionList;
  v321 = &loc_4288DE;
  v320 = v7;
  v8 = alloca(0x1605C);
  v9 = a4;
  v10 = retaddr[1];
  v296 = v6;
  if ( retaddr[1] && retaddr[1]->IsModerator && *a4 == '8' || strlen(a4) > 0xFA )
    return;
  v11 = player;
  SomethingWithSendingChatTypes(retaddr[1], (int)lpProcessInformation, (signed int)player, a4, arenaPlayerIndex);
  if ( retaddr[1] )
  {
    v12 = 0;
    if ( (int)player >= 0 && (int)player < 1024 )
      v12 = ZonePlayerList[(_DWORD)player];
    v13 = BillingLogMessages;
    if ( BillingLogMessages <= (signed int)retaddr[1]->PlayerDataBillerPacket.Extra2 )
      v13 = retaddr[1]->PlayerDataBillerPacket.Extra2;
    if ( v12 && v12->PlayerDataBillerPacket.Extra2 )
    {
      if ( v13 )
      {
LABEL_16:
        v14 = -1;
        switch ( (unsigned int)lpProcessInformation )
        {
          case 3u:
            v14 = -2;
            break;
          case 4u:
            v14 = -3;
            break;
          case 5u:
            if ( v12 )
              v14 = v12->PlayerDataBillerPacket.UserId;
            break;
          case 9u:
            v14 = -4;
            break;
          default:
            break;
        }
        if ( v13 == 3
          || v13 == 2
          && (lpProcessInformation == (LPPROCESS_INFORMATION)3
           || lpProcessInformation == (LPPROCESS_INFORMATION)4
           || lpProcessInformation == (LPPROCESS_INFORMATION)5
           || lpProcessInformation == (LPPROCESS_INFORMATION)9
           || *a4 == '*')
          || v13 == 1 && (lpProcessInformation == (LPPROCESS_INFORMATION)5 || *a4 == '*') )
        {
          v15 = retaddr[1]->PlayerDataBillerPacket.UserId;
          if ( v15 >= 0 )
          {
            if ( BillingConnectionStructPointer )
              SendBillerUnknownPacket(BillingConnectionStructPointer, v15, v14, a4);
          }
        }
        goto LABEL_35;
      }
      v13 = *a4 != '*';
    }
    if ( !v13 )
      goto LABEL_35;
    goto LABEL_16;
  }
LABEL_35:
  v16 = *a4;
  if ( *a4 != '*' )
  {
    if ( retaddr[1] )
    {
      a6 = retaddr[1]->MyArena;
      if ( a6 )
      {
        if ( v16 == '?' )
        {
          if ( !strcmp(a4, "?usage") )
          {
            v294 = retaddr[1]->UsageSessionSeconds;
            v173 = time(0);
            v174 = (__int64)difftime(v173, v294);
            sprintf(CommandLine, "Session Usage: %5d hours %d minutes", v174 / 3600, v174 / 60 % 60);
            SendMessage(retaddr[1], CommandLine, 0);
            sprintf(
              CommandLine,
              "  Total Usage: %5d hours %d minutes",
              (signed int)(retaddr[1]->PlayerDataBillerPacket.UsageTotalSeconds + v174) / 3600,
              (signed int)(retaddr[1]->PlayerDataBillerPacket.UsageTotalSeconds + v174) / 60 % 60);
            SendMessage(retaddr[1], CommandLine, 0);
            v279 = __PAIR64__(
                     retaddr[1]->PlayerDataBillerPacket.AccountCreationDay,
                     retaddr[1]->PlayerDataBillerPacket.AccountCreationMonth);
            sprintf(
              CommandLine,
              " First played: %d-%d-%d %d:%d:%d",
              (_DWORD)v279,
              HIDWORD(v279),
              (__int16)retaddr[1]->PlayerDataBillerPacket.AccountCreationYear,
              retaddr[1]->PlayerDataBillerPacket.AccountCreationHour,
              retaddr[1]->PlayerDataBillerPacket.AccountCreationMinute,
              retaddr[1]->PlayerDataBillerPacket.AccountCreationSecond);
            SendMessage(retaddr[1], CommandLine, 0);
            return;
          }
          if ( !strcmp(a4, "?sheep") )
          {
            SendMessage(retaddr[1], a6->ServersideArenaSettings.MiscSheepMessage, 24);
            return;
          }
          if ( !memcmp(a4, "?buy", 4u) )
          {
            for ( i = a4 + 4; *i == ' ' || *i == '='; ++i )
              ;
            a4a = i;
            if ( *i )
            {
              if ( *(_DWORD *)&retaddr[1]->Ship == 8 )
              {
                SendMessage(retaddr[1], "Spectators cannot purchase items.", 0);
              }
              else if ( a6->ServersideArenaSettings.CostPurchaseAnytime || (retaddr[1]->ShipTogglables & 0x20) != 0 )
              {
                v180 = 0;
                v181 = 0;
                while ( _strcmpi(retaddr[1]->MyArena->ServersideArenaSettings.BuySettings[v181].ItemName, a4a) )
                {
                  ++v181;
                  ++v180;
                  if ( v181 >= 24 )
                    goto LABEL_495;
                }
                v182 = retaddr[1]->MyArena;
                v183 = retaddr[1]->FlagPoints;
                v184 = v180;
                v185 = v182->ServersideArenaSettings.BuySettings[v180].ItemPrice;
                v186 = &v182->ServersideArenaSettings.BuySettings[v180].ItemPrice;
                if ( v185 )
                {
                  if ( v185 <= v183 + retaddr[1]->KillPoints )
                  {
                    v187 = *v186;
                    if ( *v186 <= v183 )
                    {
                      HIDWORD(v287) = -v187;
                      LODWORD(v287) = 0;
                    }
                    else
                    {
                      HIDWORD(v188) = -v183;
                      LODWORD(v188) = v183 - v187;
                      v287 = v188;
                    }
                    UpdatePoints(retaddr[1], v287, SHIDWORD(v287));
                    v189 = retaddr[1]->MyArena;
                    Buffer3[0] = 0x20;
                    *(_WORD *)&Buffer3[3] = v189->ServersideArenaSettings.BuySettings[v184].ItemId;
                    *(_WORD *)&Buffer3[1] = 1;
                    SendPlayerReliablePacket(retaddr[1], Buffer3, 5u, 1);
                    v190 = retaddr[1]->FlagPoints;
                    v191 = retaddr[1]->KillPoints;
                    *(_WORD *)&v307[1] = retaddr[1]->PlayerId;
                    v192 = retaddr[1]->CurrentWins;
                    *(_DWORD *)&v307[7] = v190;
                    *(_DWORD *)&v307[3] = v191;
                    LOWORD(v191) = retaddr[1]->CurrentLosses;
                    *(_WORD *)&v307[11] = v192;
                    v193 = *(_DWORD *)&retaddr[1]->CurrentWins;
                    *(_WORD *)&v307[13] = v191;
                    v194 = *(_DWORD *)&retaddr[1]->CurrentGoals;
                    *(_DWORD *)&retaddr[1]->WinsSomething = v193;
                    v195 = *(int *)((char *)&retaddr[1]->KillPoints + 2);
                    v307[0] = 9;
                    *(_DWORD *)&retaddr[1]->GoalsSomething = v194;
                    LOWORD(v194) = HIWORD(retaddr[1]->FlagPoints);
                    *(int *)((char *)&retaddr[1]->KillPointsSomething + 2) = v195;
                    HIWORD(retaddr[1]->FlagPointsSomething) = v194;
                    SendPlayerReliablePacket(retaddr[1], v307, 0xFu, 1);
                    if ( retaddr[1]->MyArena->ServersideArenaSettings.BuySettings[v184].ItemPrice > 500 )
                      SendEverybodyButYourself(retaddr[1], v307, 0xFu, 0);
                  }
                  else
                  {
                    SendMessage(retaddr[1], "You do not have enough points to purchase that item.", 0);
                  }
                }
                else
                {
                  SendMessage(retaddr[1], "That item is not available for purchase.", 0);
                }
LABEL_495:
                if ( v180 == 24 )
                  SendMessage(retaddr[1], "Invalid item specified for purchase.", 0);
              }
              else
              {
                SendMessage(retaddr[1], "You must be in safe zone to purchase items.", 0);
              }
              return;
            }
            CommandLine[0] = 0;
            for ( j = 0; j < 576; j += 24 )
            {
              v177 = (ARENA *)((char *)retaddr[1]->MyArena + j);
              v178 = v177->ServersideArenaSettings.BuySettings[0].ItemPrice;
              if ( v178 > 0 )
              {
                sprintf(Dest, "%s=%d", (const char *)v177->ServersideArenaSettings.BuySettings, v178);
                if ( strlen(Dest) + strlen(CommandLine) > 0x4B )
                {
                  SendMessage(retaddr[1], CommandLine, 0);
                  CommandLine[0] = 0;
                }
                v179 = " ";
                if ( !CommandLine[0] )
                  v179 = "PRICE: ";
                strcat(CommandLine, v179);
                strcat(CommandLine, Dest);
              }
            }
            if ( !CommandLine[0] )
              return;
LABEL_477:
            SendMessage(retaddr[1], CommandLine, 0);
            return;
          }
          if ( !strcmp(a4, "?zone") )
          {
            SendMessage(retaddr[1], BillingServerName, 0);
            return;
          }
          if ( !strcmp(a4, "?userid") )
          {
            sprintf(Dest, "UserId:%d", retaddr[1]->PlayerDataBillerPacket.UserId);
            SendMessage(retaddr[1], Dest, 0);
            return;
          }
          if ( !strcmp(a4, "?owner") )
          {
            sprintf(Dest, "Arena Owner:%s", a6->ServersideArenaSettings.OwnerName);
            SendMessage(retaddr[1], Dest, 0);
            return;
          }
          if ( !strcmp(a4, "?getsettings") )
          {
            if ( retaddr[1]->IsSysop
              || (UserIdCheck = a6->ServersideArenaSettings.OwnerUserId,
                  retaddr[1]->PlayerDataBillerPacket.UserId == UserIdCheck)
              && UserIdCheck >= 0 )
            {
              SendMessage(retaddr[1], "File being sent, please wait.", 0);
              v197 = retaddr[1]->MyArena;
              FileTransferBuffer[0] = 0x10;     // 0x10 - File Transfer
              v198 = strrchr(v197->SettingsFilename, '\\');
              if ( v198 )
              {
                strcpy(&FileTransferBuffer[1], v198 + 1);
                v199 = strrchr(&FileTransferBuffer[1], '.');
                if ( v199 )
                  strcpy(v199, ".set");
                v200 = &v319;
                v201 = (struc_2 *)operator new(0x2B74Cu);
                *(_DWORD *)Buffer3 = v201;
                v322 = 0;
                if ( v201 )
                {
                  v202 = ReadSettingsSomething(v201, retaddr[1]->MyArena->SettingsFilename);
                  a5 = (ARENA **)v202;
                }
                else
                {
                  a5 = 0;
                  v202 = 0;
                }
                v322 = -1;
                a3 = 0;
                if ( TotalTemplateSSSEntries > 0 )
                {
                  v203 = dword_438BD0;
                  do
                  {
                    if ( !v203[256] || v10->IsSysop )
                    {
                      if ( _strcmpi(v203 - 80, "All") )
                      {
                        sub_4066B0(
                          (struct struc_2 *)a5,
                          v203 - 80,
                          v203 - 48,
                          (const char *)&DirectoryCurrentNamePassword,
                          Dest,
                          0x100u);
                        v206 = *((_DWORD *)v203 - 2);
                        if ( v206 == -999 )
                          sprintf(v200, "%s:%s:%s:::%s\r\n", v203 - 80, v203 - 48, Dest, v203);
                        else
                          sprintf(
                            v200,
                            "%s:%s:%s:%d:%d:%s\r\n",
                            v203 - 80,
                            v203 - 48,
                            Dest,
                            v206,
                            *((_DWORD *)v203 - 1),
                            v203);
                        v200 += strlen(v200);
                      }
                      else
                      {
                        v204 = off_42C848;
                        do
                        {
                          sub_4066B0(
                            (struct struc_2 *)a5,
                            *v204,
                            v203 - 48,
                            (const char *)&DirectoryCurrentNamePassword,
                            CommandLine,
                            256u);
                          if ( (int)v204 <= (int)off_42C848 )
                          {
                            v205 = *((_DWORD *)v203 - 2);
                            if ( v205 == -999 )
                              sprintf(v200, "%s:%s:%s:::%s\r\n", *v204, v203 - 48, CommandLine, v203);
                            else
                              sprintf(
                                v200,
                                "%s:%s:%s:%d:%d:%s\r\n",
                                *v204,
                                v203 - 48,
                                CommandLine,
                                v205,
                                *((_DWORD *)v203 - 1),
                                v203);
                          }
                          else
                          {
                            sprintf(v200, "%s:%s:%s:*\r\n", *v204, v203 - 48, CommandLine);
                          }
                          ++v204;
                          v200 += strlen(v200);
                        }
                        while ( (int)v204 < (int)"Spawned Command" );
                      }
                    }
                    v10 = retaddr[1];
                    v203 += 338;
                    ++a3;
                  }
                  while ( a3 < TotalTemplateSSSEntries );
                  v202 = (struc_2 *)a5;
                }
                SendPlayerReliablePacket(v10, FileTransferBuffer, v200 - FileTransferBuffer, 1);
                if ( v202 )
                {
                  WriteCfgFile(v202);
                  operator delete(v202);
                }
              }
            }
            else
            {
              SendMessage(retaddr[1], "Only the owner of this arena can view the settings.", 0);
            }
            return;
          }
          if ( !memcmp(a4, "?setlevel ", 0xAu) )
          {
            if ( retaddr[1]->IsSysop
              || (v207 = a6->ServersideArenaSettings.OwnerUserId, retaddr[1]->PlayerDataBillerPacket.UserId == v207)
              && v207 >= 0 )
            {
              buf[0] = 25;
              strncpy(&buf[1], a4 + 10, 256u);
              v208 = retaddr[1]->MyArena->SetLevelMapFilename;
              buf[256] = 0;
              strncpy(&buf[257], v208, 0x10u);
              buf[272] = 0;
              SendPlayerReliablePacket(retaddr[1], buf, 0x111u, 1);
            }
            else
            {
              SendMessage(retaddr[1], "Only the owner of this arena can change the level.", 0);
            }
            return;
          }
          if ( !strcmp(a4, "?recycle") )
          {
            if ( retaddr[1]->IsSysop
              || retaddr[1]->PlayerDataBillerPacket.UserId == a6->ServersideArenaSettings.OwnerUserId )
            {
              a6->ArenaRecycling = 1;
            }
            else
            {
              SendMessage(retaddr[1], "Only the owner of this arena can recycle it.", 0);
            }
            return;
          }
          if ( !strcmp(a4, "?spec") )
          {
            v209 = a6;
            CommandLine[0] = 0;
            a3 = 0;
            if ( a6->ArenaPlayerCount > 0 )
            {
              v210 = 64288;
              do
              {
                v211 = *(PLAYER **)&v209->PlayerPointers[v210];// playerPointersForSomething
                v212 = 0;
                if ( retaddr[1]->IsSuperModerator )
                {
                  if ( *(_DWORD *)&v211->Ship == 8 && v211->ArenaPlayerIndex < 0 )
                  {
                    v213 = v211->XPixels - retaddr[1]->XPixels;
                    if ( (int)((HIDWORD(v213) ^ v213) - HIDWORD(v213)) < 1280 )
                    {
                      v214 = v211->YPixels - retaddr[1]->YPixels;
                      if ( (int)((HIDWORD(v214) ^ v214) - HIDWORD(v214)) < 1024 )
                        v212 = 1;
                    }
                  }
                }
                if ( (v211->ArenaPlayerIndex == *(_DWORD *)&retaddr[1]->PlayerId || v212)
                  && (retaddr[1]->IsSysop || !v211->IsModerator) )
                {
                  if ( v212 )
                    v288 = "*%s";
                  else
                    v288 = "%s";
                  sprintf(Dest, v288, &v211->PlayerDataBillerPacket);
                  if ( strlen(Dest) + strlen(CommandLine) > 0x4B )
                  {
                    SendMessage(retaddr[1], CommandLine, 0);
                    CommandLine[0] = 0;
                  }
                  v215 = ",";
                  if ( !CommandLine[0] )
                    v215 = "SPEC: ";
                  strcat(CommandLine, v215);
                  strcat(CommandLine, Dest);
                }
                v209 = retaddr[1]->MyArena;
                v210 += 4;
                v216 = v209->ArenaPlayerCount;
                ++a3;
              }
              while ( a3 < v216 );
            }
            if ( !CommandLine[0] )
              return;
            goto LABEL_477;
          }
          if ( !strcmp(a4, "?packetloss") )
          {
            GetPingLOSSSomething(retaddr[1]->connection, (int *)&a5, &YouToServer);
            v217 = 1000 - YouToServer;
            v117 = a5 == (ARENA **)1000;
            a5 = (ARENA **)(1000 - (_DWORD)a5);
            YouToServer = 1000 - YouToServer;
            if ( !v117 || v217 )
              sprintf(
                CommandLine,
                "PACKET LOSS ServerToYou:%.1f%%  YouToServer:%.1f%%",
                (double)(int)a5 * 0.1,
                (double)YouToServer * 0.1);
            else
              sprintf(CommandLine, "PACKET LOSS Unknown, check again in a few minutes.");
            SendMessage(retaddr[1], CommandLine, 0);
            return;
          }
          if ( !strcmp(a4, "?jackpot") )
          {
            sprintf(Dest, "Current Jackpot: %d", a6->ArenaJackpot);
            SendMessage(retaddr[1], Dest, 0);
            return;
          }
          if ( !strcmp(a4, "?crown") )
          {
            if ( (int)a6->ServersideArenaSettings.KingDeathCount <= 0
              || (int)a6->ServersideArenaSettings.KingCrownRecoverKills <= 0 )
            {
              SendMessage(retaddr[1], "This is not a king of the hill style game or crowns cannot be recovered.", 0);
            }
            else if ( (int)retaddr[1]->KotHDeathCount <= 0 )
            {
              sprintf(
                Dest,
                "Kills needed for crown: %d",
                a6->ServersideArenaSettings.KingCrownRecoverKills - retaddr[1]->KingCrownKills);
              SendMessage(retaddr[1], Dest, 0);
            }
            else
            {
              SendMessage(retaddr[1], "You already have a crown.", 0);
            }
            return;
          }
          if ( !strcmp(a4, "?score") )
          {
            GetScore(a6, retaddr[1]);
            return;
          }
          if ( !strcmp(a4, "?arena") )
          {
            v218 = 0;
            v317[0] = 0x2F;                     // 0x2F - Arena Directory Listing
            v219 = &v317[1];
            a3 = 0;
            if ( ArenaArrayLength > 0 )
            {
              a5 = Arenas;
              do
              {
                if ( (*a5)->ArenaName[0] != '#' || retaddr[1]->IsModerator || retaddr[1]->MyArena == *a5 )
                {
                  if ( (*a5)->ArenaName[0] )
                  {
                    v295 = (*a5)->ArenaName;
                    v289 = "%s";
                  }
                  else
                  {
                    v295 = (char *)v218;
                    v289 = "%d";
                  }
                  sprintf(CommandLine, v289, v295);
                  strcpy(v219, CommandLine);
                  v220 = &v219[strlen(CommandLine) + 1];
                  v221 = *a5;
                  if ( *a5 == retaddr[1]->MyArena )
                    *(_WORD *)v220 = -LOWORD(v221->ArenaPlayerCount);
                  else
                    *(_WORD *)v220 = v221->ArenaPlayerCount;
                  v218 = a3;
                  v219 = v220 + 2;
                }
                a3 = ++v218;
                ++a5;
              }
              while ( v218 < ArenaArrayLength );
            }
            SendPlayerReliablePacket(retaddr[1], v317, v219 - v317, 1);
            return;
          }
          if ( !strcmp(a4, "?time") )
          {
            if ( (int)a6->ServersideArenaSettings.MiscTimedGame <= 0 )
            {
              if ( !a6->GameTimeStart )
              {
                if ( retaddr[1]->IsModerator )
                {
                  v223 = retaddr[1]->MyArena->ServersideArenaSettings.TerritoryRewardDelay
                       - abs32(GetTickCount() / 0xA - retaddr[1]->MyArena->LastTerritoryRewardTime);
                  if ( v223 < 0 )
                    v223 = 0;
                  sprintf(CommandLine, "Time left to reward: %d minutes %d seconds", v223 / 6000, v223 % 6000 / 100);
                  SendMessage(retaddr[1], CommandLine, 0);
                }
                else
                {
                  SendMessage(retaddr[1], "This zone does not have a game time limit", 0);
                }
                return;
              }
              v222 = retaddr[1]->MyArena->GameTimeStart
                   - abs32(GetTickCount() / 0xA - retaddr[1]->MyArena->GameTimePassed);
              if ( v222 < 0 )
                v222 = 0;
            }
            else
            {
              v222 = retaddr[1]->MyArena->ServersideArenaSettings.MiscTimedGame
                   - abs32(GetTickCount() / 0xA - retaddr[1]->MyArena->LastTimedGameTime);
              if ( v222 < 0 )
                v222 = 0;
            }
            sprintf(CommandLine, "Time left: %d minutes %d seconds", v222 / 6000, v222 % 6000 / 100);
            SendMessage(retaddr[1], CommandLine, 0);
            return;
          }
          if ( !strcmp(a4, "?best") )
          {
            if ( (int)a6->ServersideArenaSettings.MiscTimedGame <= 0 )
            {
              HIDWORD(v224) = (unsigned __int16)retaddr[1]->CurrentLosses;
              LODWORD(v224) = (unsigned __int16)retaddr[1]->CurrentWins;
              v290 = v224;
              v283 = retaddr[1]->KillPoints + retaddr[1]->FlagPoints;
              v281 = "CURRENT SCORE  Points:%d  Win:%d  Lose:%d";
            }
            else
            {
              v290 = __PAIR64__(
                       (unsigned __int16)retaddr[1]->PersonalBestDeaths,
                       (unsigned __int16)retaddr[1]->PersonalBestWins);
              v283 = retaddr[1]->PersonalBestFlagPoints + retaddr[1]->PersonalBestKillPoints;
              v281 = "PERSONAL BEST  Points:%d  Win:%d  Lose:%d";
            }
            sprintf(Dest, v281, v283, v290);
            SendMessage(retaddr[1], Dest, 0);
            return;
          }
          if ( !memcmp(a4, "?set ", 5u) || !memcmp(a4, "?get ", 5u) )
          {
            v225 = 0;
            if ( retaddr[1]->IsSysop
              || (v226 = retaddr[1]->PlayerDataBillerPacket.UserId, v226 >= 0)
              && a6->HasScoreFile
              && a6->ServersideArenaSettings.OwnerUserId == v226 )
            {
              v225 = 1;
            }
            if ( v225 )
            {
              v227 = a4[5];
              v228 = a4 + 5;
              for ( k = AppName; v227; ++v228 )
              {
                if ( v227 == ':' )
                  break;
                *k = v227;
                v227 = v228[1];
                ++k;
              }
              v230 = *v228;
              *k = 0;
              if ( v230 )
              {
                v231 = v228[1];
                v232 = v228 + 1;
                for ( l = Str1; v231; ++v232 )
                {
                  if ( v231 == '=' )
                    break;
                  if ( v231 == ':' )
                    break;
                  *l = v231;
                  v231 = v232[1];
                  ++l;
                }
                v234 = *v232;
                *l = 0;
                if ( v234 )
                  ++v232;
                strcpy(Dest, v232);
                if ( _memicmp(a4, "?set ", 5u)
                  || (sprintf((char *)&startupInfo, "%s:%s:%s", AppName, Str1, Dest),
                      !ChangeSettings(retaddr[1]->MyArena, retaddr[1], (const CHAR *)&startupInfo)) )
                {
                  if ( !_strcmpi(AppName, "All") )
                    strcpy(AppName, "Warbird");
                  GetPrivateProfileStringA(
                    AppName,
                    Str1,
                    "InvalidTag",
                    CommandLine,
                    128u,
                    retaddr[1]->MyArena->SettingsFilename);
                  sprintf(buf, "%s:%s=%s", AppName, Str1, CommandLine);
                  SendMessage(retaddr[1], buf, 0);
                }
              }
            }
            else
            {
              SendMessage(retaddr[1], "You do not have permission to set parameters in this arena.", 0);
            }
            return;
          }
          if ( isalpha(a4[1]) )
          {
            if ( BillingConnectionStructPointer )
              biller_user_command(BillingConnectionStructPointer, retaddr[1]->BillerPlayerId, a4);
            return;
          }
        }
      }
    }
    v235 = buf;
    v236 = a4;
    if ( *a4 )
    {
      do
      {
        if ( isalpha(*v236) )
          *v235++ = toupper(*v236);
      }
      while ( *++v236 );
    }
    v238 = ObscenePointer;
    *v235 = 0;
    v239 = TextFileTotalLines(v238);
    v240 = 0;
    if ( v239 <= 0 )
    {
LABEL_656:
      a5 = 0;
    }
    else
    {
      while ( 1 )
      {
        v241 = TextFileByIndex(ObscenePointer, v240);
        if ( strstr(buf, v241) )
          break;
        if ( ++v240 >= v239 )
          goto LABEL_656;
      }
      a5 = (ARENA **)1;
    }
    a6 = 0;
    if ( retaddr[1] )
    {
      if ( *(_DWORD *)&retaddr[1]->Ship == 8
        && retaddr[1]->MyArena->ServersideArenaSettings.MiscSpectatorQuiet
        && !retaddr[1]->IsModerator )
      {
        a6 = (struct ARENA *)1;
      }
      if ( (int)(GetTickCount() / 0xA - retaddr[1]->LastMessageSpamResetCheckTime) >= 100 )
      {
        retaddr[1]->MessageSpamTotal = 0;
      }
      else
      {
        v242 = retaddr[1]->MyArena;
        v243 = retaddr[1]->MessageSpamTotal + 1;
        retaddr[1]->MessageSpamTotal = v243;
        if ( v243 > v242->ServersideArenaSettings.MessageQuickMessageLimit && !retaddr[1]->IsSysop )
        {
          WriteSubGameLog("Played kicked off for message flooding: %s\n", retaddr[1]->PlayerName);
          retaddr[1]->DisconnectReason = 12;
          retaddr[1]->AlreadySentReliablePacket = 1;
          SendArenaMessagePlayer(retaddr[1], "WARNING: You have been disconnected for message flooding.", 0);
          return;
        }
      }
      retaddr[1]->LastMessageSpamResetCheckTime = GetTickCount() / 0xA;
    }
    v244 = lpProcessInformation;
    if ( lpProcessInformation == (LPPROCESS_INFORMATION)1 || lpProcessInformation == (LPPROCESS_INFORMATION)2 )
    {
      if ( retaddr[1] )
      {
        if ( retaddr[1]->MyArena )
        {
          v245 = (int)(GetTickCount() / 0xA - retaddr[1]->MyArena->LastTimedGameTime);
          if ( (int)((HIDWORD(v245) ^ v245) - HIDWORD(v245)) < 600 )
            return;
          v246 = (int)(GetTickCount() / 0xA - retaddr[1]->MyArena->LastFlagResetTime);
          if ( (int)((HIDWORD(v246) ^ v246) - HIDWORD(v246)) < 500 )
            return;
          v247 = (int)(GetTickCount() / 0xA - retaddr[1]->MyArena->LastTerritoryRewardTime);
          if ( (int)((HIDWORD(v247) ^ v247) - HIDWORD(v247)) < 500 )
            return;
        }
      }
      v248 = (const char *)&DirectoryCurrentNamePassword;
      a3 = (int)&DirectoryCurrentNamePassword;
      if ( retaddr[1] )
      {
        v248 = retaddr[1]->PlayerDataBillerPacket.Name;
        a3 = (int)retaddr[1]->PlayerDataBillerPacket.Name;
      }
      if ( *v248 && ChatCounter64Max > 0 )
      {
        if ( !strcmp((const char *)&dword_431FC8[91 * ChatCounter64Max], v248)
          && !strcmp((const char *)&dword_431E9C[91 * ChatCounter64Max], a4) )
        {
          return;
        }
        v248 = (const char *)a3;
      }
      v249 = (char *)(364 * ChatCounter64Max + 4399112);
      ChatCounter64Max = (ChatCounter64Max + 1) % 64;
      strncpy(v249, a4, 0x12Cu);
      v250 = v249 + 300;
      v249[299] = 0;
      strncpy(v249 + 300, v248, 0x20u);
      v249 += 332;
      v250[31] = 0;
      strncpy(v249, "(Everyone)", 0x20u);
      v249[31] = 0;
      if ( retaddr[1] )
      {
        v251 = retaddr[1]->MyArena;
        if ( v251 )
          FormatMessageArena(v251, "%16.16s>%s\n", v250, a4);
      }
      v244 = lpProcessInformation;
    }
    v316[0] = 7;
    v316[1] = (char)v244;
    v316[2] = arenaPlayerIndex;
    if ( v244 == (LPPROCESS_INFORMATION)7 )
    {
      if ( !retaddr[1]
        || (v252 = retaddr[1]->MyArena) == 0
        || retaddr[1]->IsModerator
        || v252->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
        || !v252->PrivateMessagesLocked )
      {
        *(_WORD *)&v316[3] = 0;
        v253 = strchr(a4 + 1, ':');
        *(_DWORD *)Buffer3 = v253;
        if ( v253 )
        {
          v254 = v253 - a4 - 1;
          Size = v254;
          qmemcpy(CommandLine, a4 + 1, v254);
          v255 = 0;
          v256 = ArenaArrayLength <= 0;
          CommandLine[v254] = 0;
          YouToServer = 0;
          a3 = 0;
          if ( !v256 )
          {
            v257 = Arenas;
            do
            {
              v258 = *v257;
              v259 = 0;
              if ( (*v257)->ArenaPlayerCount > 0 )
              {
                v260 = 64288;
                while ( _strcmpi(CommandLine, (const char *)(*(_DWORD *)&v258->PlayerPointers[v260] + 375)) )// playerPointersForSomething
                                                // 
                {
                  if ( !YouToServer
                    && retaddr[1]
                    && !_memicmp(CommandLine, (const void *)(*(_DWORD *)&(*v257)->PlayerPointers[v260] + 375), Size) )
                  {
                    YouToServer = *(_DWORD *)&(*v257)->PlayerPointers[v260];// playerPointersForSomething
                  }
                  v258 = *v257;
                  ++v259;
                  v260 += 4;
                  if ( v259 >= (*v257)->ArenaPlayerCount )
                    goto LABEL_706;
                }
                YouToServer = *(_DWORD *)&(*v257)->playerPointersForSomething[4 * v259];
              }
LABEL_706:
              ++v257;
              ++a3;
            }
            while ( a3 < ArenaArrayLength );
            v254 = Size;
            v253 = *(char **)Buffer3;
            v255 = (struct PLAYER *)YouToServer;
          }
          if ( v255 )
          {
            if ( retaddr[1] )
              sprintf(&v316[5], "(%s)>%s", retaddr[1]->PlayerDataBillerPacket.Name, v253 + 1);
            else
              sprintf(&v316[5], "%s", v253 + 1);
            SendToSpectators(v255, v316, strlen(&v316[5]) + 6, 1, (int)a5, (int)a6);
          }
          else if ( retaddr[1] )
          {
            buf[0] = 2;
            buf[1] = arenaPlayerIndex;
            sprintf(&buf[2], ":%s:(%s)>%s", CommandLine, retaddr[1]->PlayerDataBillerPacket.Name, v253 + 1);
            if ( BillingConnectionStructPointer )
              SendBillerUserPrivateChatPacket(
                BillingConnectionStructPointer,
                -1,
                BillingGroupId,
                buf,
                strlen(&buf[2]) + 3);
          }
          else if ( CommandLine[0] == '#' && v254 > 2 && CommandLine[1] != ' ' )
          {
            sprintf(&v316[5], "%s", v253 + 1);
            v261 = strlen(&v316[5]) + 1;
            a3 = 0;
            if ( ArenaArrayLength > 0 )
            {
              v262 = Arenas;
              do
              {
                v263 = 0;
                if ( (*v262)->ArenaPlayerCount > 0 )
                {
                  v264 = 64288;
                  do
                  {
                    v291 = __PAIR64__(*(_DWORD *)&(*v262)->PlayerPointers[v264] + 399, &CommandLine[1]);
                    if ( !_strcmpi((const char *)v291, (const char *)HIDWORD(v291)) )
                      SendToSpectators(
                        *(struct PLAYER **)&(*v262)->PlayerPointers[v264],// playerPointersForSomething
                        v316,
                        v261 - 1 + 6,
                        1,
                        (int)a5,
                        (int)a6);
                    ++v263;
                    v264 += 4;
                  }
                  while ( v263 < (*v262)->ArenaPlayerCount );
                }
                ++v262;
                ++a3;
              }
              while ( a3 < ArenaArrayLength );
            }
          }
        }
      }
    }
    else if ( retaddr[1] && (v265 = retaddr[1]->MyArena) != 0 )
    {
      *(_WORD *)&v316[3] = retaddr[1]->PlayerId;
      *(_DWORD *)Buffer3 = strcpy(&v316[5], a4);
      v266 = v265->ServersideArenaSettings.MessageReliable;
      v267 = strlen(a4) + 6;
      if ( v265->ArenaPlayerCount < 20 )
        v266 = 1;
      switch ( (unsigned int)lpProcessInformation )
      {
        case 1u:
        case 2u:
          if ( retaddr[1]->IsModerator
            || v265->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
            || !v265->AllMessagesLocked )
          {
            SomethingWithAttachedPlayer(retaddr[1], v316, v267, v266, (int)a5, (int)a6);
          }
          break;
        case 3u:
          if ( retaddr[1]->IsModerator
            || v265->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
            || !v265->AllMessagesLockedAgainSomething )
          {
            v274 = v265->ServersideArenaSettings.MessageTeamReliable || v266;
            sub_40E220(retaddr[1], v316, v267, v274, (int)a5, (int)a6);
          }
          break;
        case 4u:
          if ( retaddr[1]->IsModerator
            || v265->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
            || !v265->AllMessagesLockedAgainSomething )
          {
            v275 = v265->ServersideArenaSettings.MessageTeamReliable || v266;
            sub_40E300(retaddr[1], (int)player, v316, v267, v275, (int)a5, (int)a6);
          }
          break;
        case 5u:
          if ( retaddr[1]->IsModerator
            || v265->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
            || !v265->PrivateMessagesLocked )
          {
            SomethingWithAudioByteAndShip8((int)player, v316, v267, 1, (int)a5, (int)a6);
          }
          break;
        case 9u:
          if ( retaddr[1]->IsModerator
            || v265->SpecMessageLock && *(_DWORD *)&retaddr[1]->Ship != 8
            || !v265->PrivateMessagesLocked )
          {
            if ( BillingConnectionStructPointer )
            {
              if ( *a4 == ';' || isdigit(*a4) && a4[1] == ';' )
              {
                v268 = a4;
                if ( *a4 == ';' )
                  v268 = a4 + 1;
                v269 = *v268;
                for ( m = Str1; v269; ++v268 )
                {
                  if ( v269 == ';' )
                    break;
                  if ( v269 == ':' )
                    break;
                  *m = v269;
                  v269 = v268[1];
                  ++m;
                }
                v271 = *v268;
                *m = 0;
                if ( v271 )
                {
                  v272 = v268[1];
                  v273 = v268 + 1;
                  if ( v272 )
                  {
                    if ( Str1[0] )
                      SendBillerUserChannelChatPacket(
                        BillingConnectionStructPointer,
                        retaddr[1]->BillerPlayerId,
                        Str1,
                        v273);
                  }
                }
              }
              else
              {
                SendBillerUserChannelChatPacket(
                  BillingConnectionStructPointer,
                  retaddr[1]->BillerPlayerId,
                  (const char *)&DirectoryCurrentNamePassword,
                  a4);
              }
            }
            else
            {
              SendMessage(retaddr[1], "Chat channels not available at this time.", 0);
            }
          }
          break;
        default:
          return;
      }
    }
    else
    {
      buf[2] = arenaPlayerIndex;
      buf[0] = 7;
      buf[1] = 0;
      *(_WORD *)&buf[3] = 0;
      strcpy(&buf[5], a4);
      v276 = strlen(a4) + 1;
      v277 = 0;
      if ( ZonePlayerCount > 0 )
      {
        v278 = playerPointerList;
        do
        {
          if ( (*v278)->MyArena )
            SendPlayerReliablePacket(*v278, buf, v276 - 1 + 6, 1);
          ++v277;
          ++v278;
        }
        while ( v277 < ZonePlayerCount );
      }
    }
    return;
  }
  if ( !retaddr[1] )
    goto LABEL_41;
  if ( !retaddr[1]->IsModerator )
    goto LABEL_443;
  v9 = a4;
  v11 = player;
  if ( !retaddr[1]->IsSuperModerator )
    goto LABEL_294;
  if ( retaddr[1]->IsSysop )
  {
LABEL_41:
    if ( !_memicmp(v9, "**", 2u) && retaddr[1] )
    {
      v17 = v9 + 2;
      buf[1] = arenaPlayerIndex;
      buf[0] = 2;
      v18 = BillingConnectionStructPointer;
      strcpy(&buf[2], v17);
      if ( v18 )
        SendBillerUserPrivateChatPacket(v18, retaddr[1]->BillerPlayerId, BillingGroupId, buf, strlen(v17) + 3);
      return;
    }
    if ( _memicmp(v9, "*energy", 7u) || !retaddr[1] )
    {
      if ( !_memicmp(v9, "*stat", 5u) && retaddr[1] )
      {
        v23 = GetTickCount() / 0xA - LastServerStatsAndKickedPlayersTime;
        YouToServer = v23;
        if ( v23 <= 0 )
        {
          v23 = 1;
          YouToServer = 1;
        }
        v24 = retaddr[1]->MyArena;
        a5 = 0;
        if ( v24->ArenaPlayerCount > 0 )
        {
          v25 = 0;
          v26 = 64288;
          do
          {
            v27 = GetRelAckDiff(*(struct CONNECTION **)(*(_DWORD *)&v24->PlayerPointers[v26] + 40), 0);// playerPointersForSomething
            v26 += 4;
            v28 = (ARENA **)((char *)a5 + v27);
            v24 = retaddr[1]->MyArena;
            a5 = v28;
            ++v25;
          }
          while ( v25 < v24->ArenaPlayerCount );
          a5 = (ARENA **)(10 * (int)a5 / retaddr[1]->MyArena->ArenaPlayerCount);
        }
        GetPacketStatistics(ServerPacketAttachment, &a2, (int *)&a6, &ASyncS2CEnd, (int *)&Size, &a3);
        sprintf(
          Dest,
          "Send:%d(%d)  Recv:%d(%d)  RelOut:%.1f  Multi:%.1f\n",
          100 * a2 / v23,
          100 * (int)a6 / v23,
          100 * ASyncS2CEnd / v23,
          (int)(100 * Size) / v23,
          (double)(int)a5 * 0.1,                // 0.1
          (double)a3 * 100.0 / (double)YouToServer);// 100.0
        SendMessage(retaddr[1], Dest, 0);
        v29 = 0;
        if ( EncryptionStruct )
          v29 = GetRelAckDiff(EncryptionStruct, 0);
        sprintf(
          Dest,
          "Iterations:%d  Players:%d  BillingRelOut:%d  Wave:%d\n",
          100 * ServerIterations / v23,
          ZonePlayerCount,
          v29,
          100 * Wave / v23);
        SendMessage(retaddr[1], Dest, 0);
        sprintf(
          Dest,
          "Screen:%d  Radar:%d  Double:%d  Timer:%d\n",
          100 * ScreenValue / v23,
          100 * RadarValue / v23,
          100 * DoubleValue / v23,
          v23 / 100);
        SendMessage(retaddr[1], Dest, 0);
        v30 = 0;
        v31 = 0;
        if ( ArenaArrayLength > 0 )
        {
          YouToServer = (int)Arenas;
          do
          {
            v30 += GetArenaMemoryTotal(*(ARENA **)YouToServer);
            ++v31;
            YouToServer += 4;
          }
          while ( v31 < ArenaArrayLength );
        }
        sprintf(Dest, "MemoryUsage:%dk\n", v30);
        SendMessage(retaddr[1], Dest, 0);
        v32 = 0;
        Dest[0] = 0;
        YouToServer = 0;
        do
        {
          v33 = TotalSentForEachPacketType[v32];
          if ( v33 )
          {
            sprintf(AppName, "%d:%d(%d)  ", v32, 100 * TotalSentSizeForEachPacketType[v32] / v23, 100 * v33 / v23);
            if ( strlen(AppName) + strlen(Dest) > 0x4B )
            {
              SendMessage(retaddr[1], Dest, 0);
              Dest[0] = 0;
            }
            strcat(Dest, AppName);
            v32 = YouToServer;
          }
          YouToServer = ++v32;
        }
        while ( v32 < 256 );
        if ( Dest[0] )
          SendMessage(retaddr[1], Dest, 0);
        goto LABEL_172;
      }
      if ( !_memicmp(v9, "*addword", 8u) )
      {
        v34 = (unsigned __int8)v9[8];
        v35 = v9 + 8;
        a4 = v35;
        if ( (_BYTE)v34 == ' ' )
        {
          do
            v36 = *++v35;
          while ( v36 == ' ' );
          a4 = v35;
        }
        if ( *v35 )
        {
          AddLineTextFile(ObscenePointer, v35);
          WriteTextFileToFile(ObscenePointer);
          if ( retaddr[1] )
          {
            sprintf(CommandLine, "Obscene Word Added: %s", v35);
            SendMessage(retaddr[1], CommandLine, 0);
          }
        }
        goto LABEL_172;
      }
      if ( _memicmp(v9, "*addmachine", 0xBu) )
      {
        if ( !_memicmp(v9, "*removemachine", 0xEu) )
        {
          v40 = (unsigned __int8)v9[14];
          v41 = v9 + 14;
          a4 = v41;
          if ( (_BYTE)v40 == ' ' )
          {
            do
              v42 = *++v41;
            while ( v42 == ' ' );
            a4 = v41;
          }
          if ( *v41 )
          {
            v43 = 0;
            YouToServer = TextFileTotalLines(IDBlockPointer);
            if ( YouToServer > 0 )
            {
              do
              {
                v44 = TextFileByIndex(IDBlockPointer, (int)v43);
                v45 = a4;
                if ( strlen(a4) >= strlen(v44) )
                  v45 = v44;
                if ( !memcmp(a4, v44, strlen(v45)) )
                {
                  ListMachineSomething(v43, v296);
                  --YouToServer;
                }
                else
                {
                  v43 = (struct TEXT_FILE_STRUCT *)((char *)v43 + 1);
                }
              }
              while ( (int)v43 < YouToServer );
            }
            WriteTextFileToFile(IDBlockPointer);
            if ( retaddr[1] )
              SendMessage(retaddr[1], "MachineId Block Removed", 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(v9, "*listmachine", 0xCu) && retaddr[1] )
        {
          v46 = TextFileTotalLines(IDBlockPointer);
          for ( n = 0; n < v46; ++n )
          {
            v48 = TextFileByIndex(IDBlockPointer, n);
            SendMessage(retaddr[1], v48, 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(v9, "*log", 4u) && retaddr[1] )
        {
          for ( ii = 0; ii < 48; ++ii )
          {
            v50 = &LogArray[256 * ((ii + CurrentLogLine) % 48)];
            if ( *v50 )
              SendMessage(retaddr[1], v50, 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(v9, "*shutdown", 9u) )
        {
          if ( retaddr[1] )
            SendMessage(retaddr[1], "Shutting down server...", 0);
          printf("Shutting down server...\n");
          v51 = v9 + 9;
          RecycleServer = 1;
          IsServerRunning = 1;
          ShutdownArguments = 0;
          a4 = v51;
          if ( *v51 == 32 )
            a4 = ++v51;
          if ( *v51 )
            strcpy(&ShutdownArguments, v51);
          goto LABEL_172;
        }
        if ( !_memicmp(v9, "*sysop", 6u) )
        {
          if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
          {
            v52 = ZonePlayerList[(_DWORD)v11];
            if ( v52 )
            {
              v53 = v52->IsSysop;
              v54 = v53 == 0;
              v52->IsSysop = v54;
              v52->IsSuperModerator = v54;
              v52->IsModerator = v54;
              if ( v53 )
                SendMessage(retaddr[1], "Player Sysop Mode OFF", 0);
              else
                SendMessage(retaddr[1], "Player Sysop Mode ON", 0);
            }
          }
          goto LABEL_172;
        }
        if ( !_memicmp(v9, "*smoderator", 0xBu) )
        {
          if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
          {
            v55 = ZonePlayerList[(_DWORD)v11];
            if ( v55 )
            {
              v56 = v55->IsSuperModerator;
              v57 = v56 == 0;
              v55->IsSuperModerator = v57;
              v55->IsModerator = v57;
              if ( v56 )
                SendMessage(retaddr[1], "Player Super Moderator Mode OFF", 0);
              else
                SendMessage(retaddr[1], "Player Super Moderator Mode ON", 0);
            }
          }
          goto LABEL_172;
        }
        if ( _memicmp(v9, "*s*", 3u) && _memicmp(v9, "*g*", 3u) )
        {
          if ( !_memicmp(v9, "*set ", 5u) )
          {
            v58 = v9[5];
            v59 = v9 + 5;
            for ( jj = Str1; v58; ++v59 )
            {
              if ( v58 == ':' )
                break;
              *jj = v58;
              v58 = v59[1];
              ++jj;
            }
            v61 = *v59;
            *jj = 0;
            if ( !v61 )
              return;
            v62 = v59[1];
            v63 = v59 + 1;
            for ( kk = array1; v62; ++v63 )
            {
              if ( v62 == ':' )
                break;
              *kk = v62;
              v62 = v63[1];
              ++kk;
            }
            v65 = *v63;
            *kk = 0;
            if ( !v65 )
              return;
            v66 = v63[1];
            v67 = v63 + 1;
            for ( ll = Dest; v66; ++v67 )
            {
              *ll = v66;
              v66 = v67[1];
              ++ll;
            }
            *ll = 0;
            GetModuleFileNameA(0, (LPSTR)&startupInfo, 256u);
            v69 = strrchr((const char *)&startupInfo, '\\');
            if ( v69 )
              *v69 = 0;
            else
              LOBYTE(startupInfo.cb) = 0;
            sprintf(CommandLine, "%s\\server.cfg", (const char *)&startupInfo);
            if ( _strcmpi(Str1, "All") )
            {
              WritePrivateProfileStringA(Str1, array1, Dest, CommandLine);
            }
            else
            {
              WritePrivateProfileStringA("Warbird", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Javelin", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Spider", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Leviathan", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Weasel", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Terrier", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Lancaster", array1, Dest, CommandLine);
              WritePrivateProfileStringA("Shark", array1, Dest, CommandLine);
            }
            if ( retaddr[1] )
              SendMessage(retaddr[1], "Change complete", 0);
          }
          goto LABEL_172;
        }
        v70 = v9[3];
        v71 = v9 + 3;
        for ( mm = Str1; v70; ++v71 )
        {
          if ( v70 == ':' )
            break;
          *mm = v70;
          v70 = v71[1];
          ++mm;
        }
        v73 = *v71;
        *mm = 0;
        if ( !v73 )
          return;
        v74 = v71[1];
        v75 = v71 + 1;
        for ( nn = array1; v74; ++v75 )
        {
          if ( v74 == ':' )
            break;
          *nn = v74;
          v74 = v75[1];
          ++nn;
        }
        *nn = 0;
        if ( !_memicmp(v9, "*s*", 3u) )
        {
          if ( !*v75 )
            return;
          v77 = v75[1];
          v78 = v75 + 1;
          for ( i1 = AppName; v77; ++v78 )
          {
            *i1 = v77;
            v77 = v78[1];
            ++i1;
          }
          *i1 = 0;
          WritePrivateProfileStringA(Str1, array1, AppName, FileName);
          IsEditedServerINIorCFG = 1;
        }
        if ( !retaddr[1] )
          goto LABEL_172;
        GetPrivateProfileStringA(Str1, array1, "InvalidTag", (LPSTR)&startupInfo, 64u, FileName);
        sprintf(Dest, "%s:%s:%s", Str1, array1, (const char *)&startupInfo);
        v21 = Dest;
      }
      else
      {
        v37 = (unsigned __int8)v9[11];
        v38 = v9 + 11;
        a4 = v38;
        if ( (_BYTE)v37 == ' ' )
        {
          do
            v39 = *++v38;
          while ( v39 == ' ' );
          a4 = v38;
        }
        if ( !*v38 )
          goto LABEL_172;
        AddLineTextFile(IDBlockPointer, v38);
        WriteTextFileToFile(IDBlockPointer);
        if ( !retaddr[1] )
          goto LABEL_172;
        sprintf(CommandLine, "MachineId Block Added: %s", v38);
        v21 = CommandLine;
      }
      goto LABEL_171;
    }
    if ( lpProcessInformation != (LPPROCESS_INFORMATION)5 )
    {
      if ( retaddr[1]->MyArena )
      {
        v22 = retaddr[1]->IsEnergyShowing;
        retaddr[1]->IsEnergyShowing = v22 == 0;
        if ( v22 )
          SendMessage(retaddr[1], "Showing Energy OFF", 0);
        else
          SendMessage(retaddr[1], "Showing Energy ON", 0);
      }
      goto LABEL_172;
    }
    v19 = ZonePlayerList[(_DWORD)v11];
    if ( v19 )
    {
      v20 = v19->IsEnergyShowing;
      v19->IsEnergyShowing = v20 == 0;
      if ( v20 )
        v284 = "Showing Energy OFF for %s";
      else
        v284 = "Showing Energy ON for %s";
      sprintf(CommandLine, v284, &v19->PlayerDataBillerPacket);
      v21 = CommandLine;
LABEL_171:
      SendMessage(retaddr[1], v21, 0);
      goto LABEL_172;
    }
  }
LABEL_172:
  if ( !_memicmp(a4, "*szone", 6u) && retaddr[1] )
  {
    v80 = a4 + 6;
    if ( a4[6] == ' ' )
      v80 = a4 + 7;
    if ( *v80 == '_' )
      *v80 = ' ';
    if ( retaddr[1]->IsSysop || *v80 != '*' || !_memicmp(v80, "*permit", 7u) || !_memicmp(v80, "*revoke", 7u) )
    {
      buf[1] = arenaPlayerIndex;
      buf[0] = 2;
      v81 = BillingConnectionStructPointer;
      strcpy(&buf[2], v80);
      if ( v81 )
        SendBillerZoneRevokePermitPacket(v81, retaddr[1]->BillerPlayerId, BillingScoreId, (int)buf, strlen(v80) + 3);
    }
    return;
  }
  if ( _memicmp(a4, "*zone", 5u) )
  {
    if ( _memicmp(a4, "*where", 6u) || !retaddr[1] )
    {
      if ( _memicmp(a4, "*info", 5u) || !retaddr[1] )
      {
        if ( _memicmp(a4, "*getlist", 8u) || !retaddr[1] )
        {
          if ( _memicmp(a4, "*putlist", 8u) || !retaddr[1] )
          {
            if ( _memicmp(a4, "*getmodlist", 0xBu) || !retaddr[1] )
            {
              if ( _memicmp(a4, "*putmodlist", 0xBu) || !retaddr[1] )
              {
                if ( _memicmp(a4, "*recycle", 8u) )
                {
                  if ( _memicmp(a4, "*moderator", 0xAu) )
                  {
                    if ( _memicmp(a4, "*restart", 8u) || !retaddr[1] )
                    {
                      if ( _memicmp(a4, "*prize", 6u) )
                      {
                        if ( !_memicmp(a4, "*trace", 6u) && retaddr[1] )
                        {
                          if ( retaddr[1]->ProcessInformation
                            && GetExitCodeProcess(retaddr[1]->ProcessInformation, (LPDWORD)Buffer3) )
                          {
                            if ( *(_DWORD *)Buffer3 == 259 )
                              TerminateProcess(retaddr[1]->ProcessInformation, 0);
                            CloseHandle(retaddr[1]->ProcessInformation);
                            retaddr[1]->ProcessInformation = 0;
                            retaddr[1]->dword4 = 0;
                            retaddr[1]->dword8 = 0;
                            retaddr[1]->dwordC = 0;
                          }
                          if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                          {
                            v128 = ZonePlayerList[(_DWORD)player];
                            if ( v128 )
                            {
                              v129 = GetIPAddressString((struct in_addr)v128->IPAddressDWORD);
                              sprintf(CommandLine, "SUBGAME /SPAWN tracert %s > spawn.log", v129);
                              memset(&startupInfo, 0, sizeof(startupInfo));
                              startupInfo.cb = 68;
                              startupInfo.lpTitle = "Spawned TRACERT";
                              CreateProcessA(
                                0,
                                CommandLine,
                                0,
                                0,
                                0,
                                0x20u,
                                0,
                                0,
                                &startupInfo,
                                (LPPROCESS_INFORMATION)retaddr[1]);
                              SendMessage(retaddr[1], "SPAWN STARTED", 0);
                            }
                          }
                        }
                      }
                      else
                      {
                        v113 = (unsigned __int8)a4[6];
                        v114 = a4 + 6;
                        a4 += 6;
                        if ( (_BYTE)v113 == ' ' )
                        {
                          do
                            v115 = *++v114;
                          while ( v115 == ' ' );
                          a4 = v114;
                        }
                        v116 = *v114;
                        v117 = *v114 == '#';
                        Buffer3[0] = 0x20;      // 0x20 - Collect prize or get prized or buy item
                        *(_WORD *)&Buffer3[3] = 0;
                        *(_WORD *)&Buffer3[1] = 1;
                        if ( v117 )
                        {
                          *(_WORD *)&Buffer3[3] = atoi(v114 + 1);
                        }
                        else if ( isdigit(v116) )
                        {
                          *(_WORD *)&Buffer3[1] = atoi(v114);
                        }
                        if ( !retaddr[1]->IsSysop )
                        {
                          v118 = *(_WORD *)&Buffer3[1];
                          strcpy(&Buffer3[1], "d");
                          if ( v118 <= 100 )
                            *(_WORD *)&Buffer3[1] = v118;
                        }
                        if ( retaddr[1] )
                          SendMessage(retaddr[1], "Granting prize(s)", 0);
                        if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                        {
                          v119 = ZonePlayerList[(_DWORD)player];
                          if ( v119 )
                          {
                            SendPlayerReliablePacket(v119, Buffer3, 5u, 1);
                            v119->field_305 = 1;
                          }
                        }
                        else if ( lpProcessInformation == (LPPROCESS_INFORMATION)3 )
                        {
                          SendReliablePacketToMyFrequency(retaddr[1], Buffer3, 5u, 1);
                          SendPlayerReliablePacket(retaddr[1], Buffer3, 5u, 1);
                          v120 = retaddr[1]->MyArena;
                          v121 = 0;
                          if ( v120->ArenaPlayerCount > 0 )
                          {
                            v122 = 64288;
                            do
                            {
                              v123 = *(PLAYER **)&v120->PlayerPointers[v122];// playerPointersForSomething
                              ++v121;
                              v122 += 4;
                              v123->field_305 = 1;
                              v120 = retaddr[1]->MyArena;
                            }
                            while ( v121 < v120->ArenaPlayerCount );
                          }
                        }
                        else
                        {
                          ArenaSendPacket(retaddr[1]->MyArena, Buffer3, 5, 1);
                          v124 = retaddr[1]->MyArena;
                          v125 = 0;
                          if ( v124->ArenaPlayerCount > 0 )
                          {
                            v126 = 64288;
                            do
                            {
                              v127 = *(PLAYER **)&v124->PlayerPointers[v126];// playerPointersForSomething
                              ++v125;
                              v126 += 4;
                              v127->field_305 = 1;
                              v124 = retaddr[1]->MyArena;
                            }
                            while ( v125 < v124->ArenaPlayerCount );
                          }
                        }
                      }
                    }
                    else
                    {
                      retaddr[1]->MyArena->LastTimedGameTime = 0;// WHERE DOES THIS BELONG WHO KNOWS!
                    }
                  }
                  else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                  {
                    v111 = ZonePlayerList[(_DWORD)player];
                    if ( v111 )
                    {
                      v112 = v111->IsModerator;
                      v111->IsModerator = v112 == 0;
                      if ( v112 )
                        SendMessage(retaddr[1], "Player Moderator Mode OFF", 0);
                      else
                        SendMessage(retaddr[1], "Player Moderator Mode ON", 0);
                    }
                  }
                }
                else
                {
                  if ( retaddr[1] )
                    SendMessage(retaddr[1], "Recycling Server", 0);
                  RecycleServer = 1;
                }
              }
              else
              {
                buf[0] = 25;
                strncpy(&buf[257], "moderate.txt", 0x10u);
                buf[272] = 0;
                strncpy(&buf[1], "moderate.txt", 0x100u);
                buf[256] = 0;
                SendPlayerReliablePacket(retaddr[1], buf, 0x111u, 1);
              }
            }
            else
            {
              SendMessage(retaddr[1], "File sent: moderate.txt (please wait...)", 0);
              SendFile(retaddr[1], "moderate.txt");
            }
          }
          else
          {
            buf[0] = 25;
            strncpy(&buf[1], "permit.txt", 0x100u);
            buf[256] = 0;
            strncpy(&buf[257], "permit.txt", 0x10u);
            buf[272] = 0;
            SendPlayerReliablePacket(retaddr[1], buf, 0x111u, 1);
          }
        }
        else
        {
          SendMessage(retaddr[1], "File sent: permit.txt (please wait...)", 0);
          SendFile(retaddr[1], "permit.txt");
        }
      }
      else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
      {
        v90 = ZonePlayerList[(_DWORD)player];
        if ( v90 )
        {
          v292 = v90->DemoPlayer != 0;
          v282 = *(_DWORD *)&v90->Frequency;
          v280 = v90->TimeZoneBias;
          v91 = GetIPAddressString((struct in_addr)v90->IPAddressDWORD);
          sprintf(
            CommandLine,
            "IP:%s  TimeZoneBias:%d  Freq:%d  TypedName:%s  Demo:%d",
            v91,
            v280,
            v282,
            v90->TypedName,
            v292);
          if ( retaddr[1]->IsSysop )
            sprintf(&CommandLine[strlen(CommandLine)], "  MachineId:%d", v90->MachineId);
          SendMessage(retaddr[1], CommandLine, 0);
          v92 = retaddr[1]->MyArena;
          if ( (int)v92->ServersideArenaSettings.KingDeathCount > 0 )
          {
            v285 = __PAIR64__(
                     v92->ServersideArenaSettings.KingCrownRecoverKills - v90->KingCrownKills,
                     v90->KotHDeathCount);
            sprintf(CommandLine, "DeathsLeft:%d  KillsNeeded:%d", (_DWORD)v285, HIDWORD(v285));
            SendMessage(retaddr[1], CommandLine, 0);
          }
          sprintf(
            CommandLine,
            "Ping:%dms  LowPing:%dms  HighPing:%dms  AvePing:%dms",
            10 * (__int16)v90->SecurityPacketCache.CurrentPing,
            10 * (__int16)v90->SecurityPacketCache.LowPing,
            10 * (__int16)v90->SecurityPacketCache.HighPing,
            10 * (__int16)v90->SecurityPacketCache.AveragePing);
          SendMessage(retaddr[1], CommandLine, 0);
          sprintf(
            CommandLine,
            "S2CAveLatency:%dms  C2SAveLatency:%dms",
            (__int16)v90->SecurityPacketCache.S2CAverageLatency,
            10 * v90->C2SAverageLatencyFirst / (v90->C2SAverageLatencySecond + 1));
          v93 = v90->SecurityWeaponCountTotal;
          v94 = 1000;
          if ( v93 > 200 )
            v94 = 1000 * v90->SecurityWeaponCount / v93;
          a3 = 1000 - v94;
          GetPingLOSSSomething(v90->connection, (int *)&a6, &YouToServer);
          a6 = (struct ARENA *)(1000 - (_DWORD)a6);
          v95 = v90->connection;
          YouToServer = 1000 - YouToServer;
          v96 = GetRelAckDiff(v95, (int)&a2);
          sprintf(CommandLine, "LOSS: S2C:%.1f%%  C2S:%.1f%%", (double)(int)a6 * 0.1, (double)YouToServer * 0.1);
          if ( retaddr[1]->IsSysop )
            sprintf(
              &CommandLine[strlen(CommandLine)],
              "  S2CWeapons:%.1f%%  S2C_RelOut:%d(%d)",
              (double)a3 * 0.1,
              v96,
              a2);
          SendMessage(retaddr[1], CommandLine, 0);
          if ( retaddr[1]->IsSuperModerator )
          {
            GetPacketCountInfoSomething(v90->connection, (int)&v308, (int)&a3, (int)&Size, (int)&ASyncS2CEnd);
            sprintf(CommandLine, "S2C:%d-->%d  C2S:%d-->%d", v308, ASyncS2CEnd, Size, a3);
            SendMessage(retaddr[1], CommandLine, 0);
            v97 = v90->C2SCurrentFast;
            v98 = v90->C2SCurrentSlow;
            v99 = 0.0;
            a5 = 0;
            v304 = v98;
            *(_DWORD *)Buffer3 = v98 + v97;
            if ( v98 + v97 > 0 )
              *(float *)&a5 = (double)v304 * 100.0 / (double)*(int *)Buffer3;
            v100 = v90->C2SCurrentTotalSlow;
            v101 = v90->C2SCurrentTotalFast;
            *(_DWORD *)Buffer3 = v100;
            v304 = v101 + v100;
            if ( v101 + v100 > 0 )
              v99 = (double)*(int *)Buffer3 * 100.0 / (double)v304;
            sprintf(
              CommandLine,
              "C2S CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v98,
              v97,
              *(float *)&a5,
              v100,
              v101,
              v99);
            SendMessage(retaddr[1], CommandLine, 0);
            v102 = (__int16)v90->SecurityPacketCache.S2CCurrentSlow;
            v103 = 0.0;
            v104 = (__int16)v90->SecurityPacketCache.S2CCurrentFast;
            a5 = 0;
            *(_DWORD *)Buffer3 = v102;
            v304 = v104 + v102;
            if ( v104 + v102 > 0 )
              *(float *)&a5 = (double)*(int *)Buffer3 * 100.0 / (double)v304;
            v105 = v90->SecurityPacketCache.S2CCurrentTotalFast;
            v106 = v90->SecurityPacketCache.S2CCurrentTotalSlow;
            *(_DWORD *)Buffer3 = v106;
            v304 = v106 + v105;
            if ( (int)(v106 + v105) > 0 )
              v103 = (double)*(int *)Buffer3 * 100.0 / (double)v304;
            sprintf(
              CommandLine,
              "S2C CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v102,
              v104,
              *(float *)&a5,
              v106,
              v105,
              v103);
            SendMessage(retaddr[1], CommandLine, 0);
          }
          v293 = v90->UsageSessionSeconds;
          v107 = time(0);
          v108 = (__int64)difftime(v107, v293);
          sprintf(Dest, "TIME: Session:%5d:%02d:00", v108 / 3600, v108 / 60 % 60);
          if ( retaddr[1]->IsSysop )
          {
            v109 = v108 + v90->PlayerDataBillerPacket.UsageTotalSeconds;
            sprintf(
              &Dest[strlen(Dest)],
              "  Total:%5d:%02d:00  Created: %d-%d-%d %02d:%02d:%02d",
              v109 / 3600,
              v109 / 60 % 60,
              v90->PlayerDataBillerPacket.AccountCreationMonth,
              v90->PlayerDataBillerPacket.AccountCreationDay,
              (__int16)v90->PlayerDataBillerPacket.AccountCreationYear,
              v90->PlayerDataBillerPacket.AccountCreationHour,
              v90->PlayerDataBillerPacket.AccountCreationMinute,
              v90->PlayerDataBillerPacket.AccountCreationSecond);
          }
          SendMessage(retaddr[1], Dest, 0);
          if ( retaddr[1]->IsSysop )
          {
            if ( (int)retaddr[1]->MyArena->ServersideArenaSettings.MiscTimedGame > 0 )
            {
              sprintf(
                CommandLine,
                "BEST SCORE Points:%d  Win:%d  Lose:%d",
                v90->PersonalBestFlagPoints + v90->PersonalBestKillPoints,
                (unsigned __int16)v90->PersonalBestWins,
                (unsigned __int16)v90->PersonalBestDeaths);
              SendMessage(retaddr[1], CommandLine, 0);
            }
            v110 = v90->connection;
            a5 = 0;
            a3 = 0;
            ASyncS2CEnd = 0;
            Size = 0;
            GetASyncC2SInfoSomething(v110, (int)&a5, (int)&a3);
            GetASyncS2CInfoSomething(v90->connection, (int)&ASyncS2CEnd, (int)&Size);
            if ( (int)a5 > 0 || ASyncS2CEnd > 0 )
            {
              sprintf(CommandLine, "Async C2S:%d of %d  S2C:%d of %d", a3, a5, Size, ASyncS2CEnd);
              SendMessage(retaddr[1], CommandLine, 0);
            }
          }
        }
      }
    }
    else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
    {
      v89 = ZonePlayerList[(_DWORD)player];
      if ( v89 )
      {
        sprintf(
          AppName,
          "%s: %c%d",
          v89->PlayerName,
          10 * (v89->XPixels / 16) / 512 + 'A',
          10 * (v89->YPixels / 16) / 512 + 1);
        SendMessage(retaddr[1], AppName, 0);
      }
    }
  }
  else
  {
    v82 = (unsigned __int8)a4[5];
    v83 = a4 + 5;
    a4 += 5;
    if ( (_BYTE)v82 == ' ' )
    {
      do
        v84 = *++v83;
      while ( v84 == ' ' );
      a4 = v83;
    }
    if ( retaddr[1] )
    {
      v85 = retaddr[1]->MyArena;
      if ( v85 )
        FormatMessageArena(v85, "%s\n", v83);
    }
    if ( *v83 == '_' )
      *v83 = ' ';
    buf[2] = arenaPlayerIndex;
    buf[0] = 7;
    buf[1] = 0;
    *(_WORD *)&buf[3] = -1;
    strcpy(&buf[5], v83);
    v86 = strlen(v83) + 1;
    v87 = 0;
    if ( ZonePlayerCount > 0 )
    {
      v88 = playerPointerList;
      do
      {
        if ( (*v88)->MyArena )
          SendPlayerReliablePacket(*v88, buf, v86 - 1 + 6, 1);
        ++v87;
        ++v88;
      }
      while ( v87 < ZonePlayerCount );
    }
  }
LABEL_294:
  if ( _memicmp(a4, "*arena", 6u) )
  {
    if ( !_memicmp(a4, "*permit", 7u) )
    {
      v135 = (unsigned __int8)a4[7];
      v136 = a4 + 7;
      a4 += 7;
      if ( (_BYTE)v135 == 32 )
      {
        do
          v137 = *++v136;
        while ( v137 == 32 );
        a4 = v136;
      }
      if ( *v136 )
      {
        AddLineTextFile(PermitPointer, v136);
        WriteTextFileToFile(PermitPointer);
        if ( !retaddr[1] )
          return;
        sprintf(CommandLine, "Permission Added: %s", v136);
        SendMessage(retaddr[1], CommandLine, 0);
      }
      goto LABEL_443;
    }
    if ( _memicmp(a4, "*revoke", 7u) )
    {
      if ( _memicmp(a4, "*banner", 7u) || !retaddr[1] )
      {
        if ( _memicmp(a4, "*shutup", 7u) || !retaddr[1] )
        {
          if ( _memicmp(a4, "*lock", 5u) || !retaddr[1] )
          {
            if ( _memicmp(a4, "*timer", 6u) || !retaddr[1] )
            {
              if ( _memicmp(a4, "*spec", 5u) || !retaddr[1] )
              {
                if ( _memicmp(a4, "*kill", 5u) || !retaddr[1] )
                {
                  if ( _memicmp(a4, "*flagreset", 0xAu) )
                  {
                    if ( _memicmp(a4, "*shipreset", 0xAu) )
                    {
                      if ( _memicmp(a4, "*scorereset", 0xBu) )
                      {
                        if ( _memicmp(a4, "*timereset", 0xAu) )
                        {
                          if ( _memicmp(a4, "*beginlog", 9u) || !retaddr[1] )
                          {
                            if ( !_memicmp(a4, "*endlog", 7u) )
                            {
                              if ( !retaddr[1] )
                                return;
                              v167 = retaddr[1]->pfile329;
                              if ( v167 )
                              {
                                fprintf(v167, "Name               Win  Lose  Points\n");
                                fprintf(retaddr[1]->pfile329, "---------------- ----- ----- -------\n");
                                v168 = retaddr[1]->MyArena;
                                if ( v168 )
                                {
                                  v169 = 0;
                                  if ( v168->ArenaPlayerCount > 0 )
                                  {
                                    v170 = 64288;
                                    do
                                    {
                                      fprintf(
                                        retaddr[1]->pfile329,
                                        "%-16.16s %5d %5d %7d\n",
                                        (const char *)(*(_DWORD *)&v168->PlayerPointers[v170] + 375),
                                        *(unsigned __int16 *)(*(_DWORD *)&v168->PlayerPointers[v170] + 547),
                                        *(unsigned __int16 *)(*(_DWORD *)&v168->PlayerPointers[v170] + 549),
                                        *(_DWORD *)(*(_DWORD *)&v168->PlayerPointers[v170] + 557)
                                      + *(_DWORD *)(*(_DWORD *)&v168->PlayerPointers[v170] + 553));
                                      v168 = retaddr[1]->MyArena;
                                      ++v169;
                                      v170 += 4;
                                    }
                                    while ( v169 < v168->ArenaPlayerCount );
                                  }
                                }
                                fprintf(retaddr[1]->pfile329, "\nLOG FINISHED\n");
                                fclose(retaddr[1]->pfile329);
                                retaddr[1]->pfile329 = 0;
                                sprintf(Dest, "Logging session closed, sending file: %s", &retaddr[1]->char32d);
                                SendMessage(retaddr[1], Dest, 0);
                                SendFile(retaddr[1], &retaddr[1]->char32d);
                              }
                            }
                          }
                          else
                          {
                            v163 = retaddr[1]->pfile329;
                            v164 = a4 + 9;
                            a4 += 9;
                            if ( v163 )
                              fclose(v163);
                            v165 = rand();
                            v166 = rand();
                            sprintf(&retaddr[1]->char32d, "SS%d.log", v166 + v165);
                            retaddr[1]->pfile329 = fopen(&retaddr[1]->char32d, "wt");
                            sprintf(Dest, "Logging session to: %s", &retaddr[1]->char32d);
                            SendMessage(retaddr[1], Dest, 0);
                            fprintf(retaddr[1]->pfile329, "LOG STARTED:%s\n", v164);
                          }
                        }
                        else
                        {
                          if ( !retaddr[1] )
                            return;
                          v162 = retaddr[1]->MyArena;
                          if ( v162 )
                          {
                            if ( (int)v162->ServersideArenaSettings.MiscTimedGame <= 0 )
                              SendMessage(retaddr[1], "Invalid command, this is not a timed game", 0);
                            else
                              sub_405360(v162, 1);
                          }
                        }
                      }
                      else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                      {
                        if ( retaddr[1] )
                          SendMessage(retaddr[1], "Player score reset", 0);
                        v161 = ZonePlayerList[(_DWORD)player];
                        if ( v161 )
                          SendResetScoresPacket(v161);
                      }
                      else
                      {
                        if ( !retaddr[1] )
                          return;
                        ArenaScoreReset(retaddr[1]->MyArena, 1);
                      }
                    }
                    else
                    {
                      v302 = 27;
                      if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                      {
                        if ( retaddr[1] )
                          SendMessage(retaddr[1], "Player ship reset", 0);
                        v158 = ZonePlayerList[(_DWORD)player];
                        if ( v158 )
                          SendPlayerReliablePacket(v158, &v302, 1u, 1);
                      }
                      else if ( retaddr[1] )
                      {
                        SendMessage(retaddr[1], "All ships reset", 0);
                        ArenaSendPacket(retaddr[1]->MyArena, &v302, 1, 1);
                      }
                      else
                      {
                        v159 = 0;
                        if ( ZonePlayerCount > 0 )
                        {
                          v160 = playerPointerList;
                          do
                          {
                            if ( (*v160)->MyArena )
                              SendPlayerReliablePacket(*v160, &v302, 1u, 1);
                            ++v159;
                            ++v160;
                          }
                          while ( v159 < ZonePlayerCount );
                        }
                      }
                    }
                  }
                  else if ( retaddr[1] )
                  {
                    SendMessage(retaddr[1], "Flag game being reset", 0);
                    v155 = retaddr[1]->MyArena;
                    if ( v155 )
                      ResetFlagGame(v155);
                  }
                  else
                  {
                    v156 = 0;
                    if ( ArenaArrayLength > 0 )
                    {
                      v157 = Arenas;
                      do
                      {
                        ResetFlagGame(*v157);
                        ++v156;
                        ++v157;
                      }
                      while ( v156 < ArenaArrayLength );
                    }
                  }
                }
                else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
                {
                  v150 = ZonePlayerList[(_DWORD)player];
                  if ( v150 )
                  {
                    if ( retaddr[1]->IsSysop || !v150->IsSuperModerator )
                    {
                      v150->DisconnectReason = 4;
                      v150->AlreadySentReliablePacket = 1;
                      WriteSubGameLog("Player kicked off by moderator: %s\n", v150->PlayerDataBillerPacket.Name);
                      SendMessage(retaddr[1], "Player kicked off", 0);
                      if ( a4[5] == 32 )
                      {
                        v151 = atoi(a4 + 6);
                        if ( v151 > 0 )
                        {
                          v152 = MachineIdArrayCount;
                          if ( MachineIdArrayCount < 1000 )
                          {
                            KickedUsers[MachineIdArrayCount].MachineId = v150->MachineId;
                            v153 = v152;
                            KickedUsers[v153].KickStartTime = GetTickCount() / 0xA;
                            v154 = MachineIdArrayCount + 1;
                            KickedUsers[v153].KickDelayMilliseconds = 6000 * v151;
                            MachineIdArrayCount = v154;
                          }
                        }
                      }
                    }
                    else
                    {
                      SendMessage(v150, "Moderator attempted to kick you off", 0);
                    }
                  }
                }
              }
              else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
              {
                v148 = ZonePlayerList[(_DWORD)player];
                if ( v148 )
                {
                  if ( retaddr[1]->IsSysop || !v148->IsSuperModerator )
                  {
                    if ( *(_DWORD *)&v148->Ship != 8 )
                      SetPlayerShip(v148, 8);
                    v149 = v148->IsSpeced;
                    v148->IsSpeced = v149 == 0;
                    if ( v149 )
                      SendMessage(retaddr[1], "Player free to enter arena", 0);
                    else
                      SendMessage(retaddr[1], "Player locked in spectator mode", 0);
                  }
                }
              }
            }
            else
            {
              v145 = a4[6];
              v146 = a4 + 6;
              a4 += 6;
              if ( v145 == ' ' )
              {
                do
                  v147 = *++v146;
                while ( v147 == ' ' );
                a4 = v146;
              }
              if ( *v146 )
              {
                retaddr[1]->MyArena->GameTimeStart = 6000 * atoi(v146);
                retaddr[1]->MyArena->GameTimePassed = GetTickCount() / 0xA;
                retaddr[1]->MyArena->field_FF56 = 0;
              }
            }
          }
          else if ( retaddr[1]->MyArena )
          {
            if ( _memicmp(a4, "*lockpublic", 0xBu) )
            {
              if ( _memicmp(a4, "*lockteam", 9u) )
              {
                if ( _memicmp(a4, "*lockprivate", 0xCu) )
                {
                  if ( _memicmp(a4, "*lockall", 8u) )
                  {
                    if ( _memicmp(a4, "*lockspec", 9u) )
                    {
                      if ( !a4[5] )
                      {
                        retaddr[1]->MyArena->ArenaLocked = retaddr[1]->MyArena->ArenaLocked == 0;
                        if ( retaddr[1]->MyArena->ArenaLocked )
                          SendMessage(retaddr[1], "Arena LOCKED", 0);
                        else
                          SendMessage(retaddr[1], "Arena UNLOCKED", 0);
                      }
                    }
                    else
                    {
                      retaddr[1]->MyArena->SpecMessageLock = retaddr[1]->MyArena->SpecMessageLock == 0;
                      if ( retaddr[1]->MyArena->SpecMessageLock )
                        SendMessage(retaddr[1], "Message lock applies to spectators only.", 0);
                      else
                        SendMessage(retaddr[1], "Message lock applies to everybody.", 0);
                    }
                  }
                  else
                  {
                    retaddr[1]->MyArena->AllMessagesLocked = retaddr[1]->MyArena->AllMessagesLocked == 0;
                    retaddr[1]->MyArena->AllMessagesLockedAgainSomething = retaddr[1]->MyArena->AllMessagesLocked;
                    if ( retaddr[1]->MyArena->AllMessagesLocked )
                      SendMessage(retaddr[1], "All Messages LOCKED", 0);
                    else
                      SendMessage(retaddr[1], "All Messages UNLOCKED", 0);
                  }
                }
                else
                {
                  retaddr[1]->MyArena->PrivateMessagesLocked = retaddr[1]->MyArena->PrivateMessagesLocked == 0;
                  if ( retaddr[1]->MyArena->PrivateMessagesLocked )
                    SendMessage(retaddr[1], "Private Messages LOCKED", 0);
                  else
                    SendMessage(retaddr[1], "Private Messages UNLOCKED", 0);
                }
              }
              else
              {
                retaddr[1]->MyArena->AllMessagesLocked = retaddr[1]->MyArena->AllMessagesLocked == 0;
                if ( retaddr[1]->MyArena->AllMessagesLocked )
                  SendMessage(retaddr[1], "Team Messages LOCKED", 0);
                else
                  SendMessage(retaddr[1], "Team Messages UNLOCKED", 0);
              }
            }
            else
            {
              retaddr[1]->MyArena->AllMessagesLocked = retaddr[1]->MyArena->AllMessagesLocked == 0;
              if ( retaddr[1]->MyArena->AllMessagesLocked )
                SendMessage(retaddr[1], "Public Messages LOCKED", 0);
              else
                SendMessage(retaddr[1], "Public Messages UNLOCKED", 0);
            }
          }
        }
        else if ( lpProcessInformation == (LPPROCESS_INFORMATION)5 )
        {
          v143 = ZonePlayerList[(_DWORD)player];
          if ( v143 )
          {
            if ( v143->IsSysop || v143->IsSuperModerator && !retaddr[1]->IsSysop )
            {
              sprintf(Dest, "%s tried to shut you up", retaddr[1]->PlayerDataBillerPacket.Name);
              SendMessage(v143, Dest, 0);
            }
            else
            {
              v144 = v143->IsSilenced;
              v143->IsSilenced = v144 == 0;
              if ( v144 )
                v286 = "%s can now speak";
              else
                v286 = "%s has been silenced";
              sprintf(Dest, v286, &v143->PlayerDataBillerPacket);
              SendMessage(retaddr[1], Dest, 0);
            }
          }
        }
      }
      else
      {
        retaddr[1]->ForceWearBanner = 1;
        v142 = retaddr[1]->PlayerId;
        Dest[0] = 31;
        *(_WORD *)&Dest[1] = v142;
        qmemcpy(&Dest[3], retaddr[1]->PlayerDataBillerPacket.BannerData, 0x60u);
        ArenaSendPacket(retaddr[1]->MyArena, Dest, 99, 1);
      }
      goto LABEL_443;
    }
    v138 = (unsigned __int8)a4[7];
    v139 = a4 + 7;
    a4 += 7;
    if ( (_BYTE)v138 == ' ' )
    {
      do
        v140 = *++v139;
      while ( v140 == ' ' );
      a4 = v139;
    }
    if ( *v139 )
    {
      if ( !strcmp(v139, "*") )
      {
        CleanTextFileMemory(PermitPointer);
      }
      else
      {
        v141 = (struct TEXT_FILE_STRUCT *)IsBannedMachineId(PermitPointer, v139);
        if ( (int)v141 >= 0 )
          ListMachineSomething(v141, v296);
      }
      WriteTextFileToFile(PermitPointer);
      if ( !retaddr[1] )
        return;
      SendMessage(retaddr[1], "Permission revoked", 0);
    }
LABEL_443:
    if ( retaddr[1] )
    {
      v171 = a4 + 1;
      if ( !_strcmpi(a4 + 1, SysopPassword) )
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", retaddr[1]->PlayerDataBillerPacket.Name);
        retaddr[1]->IsSysop = 1;
        retaddr[1]->IsModerator = 1;
        retaddr[1]->IsSuperModerator = 1;
      }
      if ( !_strcmpi(v171, SuperModeratorPassword) )
      {
        WriteSubGameLog("%s> SUPER MODERATOR LOGGED IN\n", retaddr[1]->PlayerDataBillerPacket.Name);
        retaddr[1]->IsModerator = 1;
        retaddr[1]->IsSuperModerator = 1;
      }
      if ( !_strcmpi(v171, ModeratorPassword) )
      {
        WriteSubGameLog("%s> MODERATOR LOGGED IN\n", retaddr[1]->PlayerDataBillerPacket.Name);
        retaddr[1]->IsModerator = 1;
      }
      if ( !_strcmpi(v171, EnergyPassword) )
      {
        WriteSubGameLog("%s> ENERGY VIEWING TURNED ON/OFF\n", retaddr[1]->PlayerDataBillerPacket.Name);
        if ( retaddr[1]->MyArena )
        {
          v172 = retaddr[1]->IsEnergyShowing;
          retaddr[1]->IsEnergyShowing = v172 == 0;
          if ( v172 )
            SendMessage(retaddr[1], "Showing Energy OFF", 0);
          else
            SendMessage(retaddr[1], "Showing Energy ON", 0);
        }
      }
    }
    return;
  }
  v130 = (unsigned __int8)a4[6];
  v131 = a4 + 6;
  a4 += 6;
  if ( (_BYTE)v130 == ' ' )
  {
    do
      v132 = *++v131;
    while ( v132 == ' ' );
    a4 = v131;
  }
  if ( *v131 == '_' )
    *v131 = ' ';
  if ( retaddr[1] )
  {
    v133 = retaddr[1]->MyArena;
    if ( v133 )
      FormatMessageArena(v133, "%s\n", v131);
  }
  buf[2] = arenaPlayerIndex;
  buf[0] = 7;
  buf[1] = 0;
  *(_WORD *)&buf[3] = -1;
  strcpy(&buf[5], a4);
  v134 = strlen(a4) + 1;
  if ( retaddr[1] )
  {
    ArenaSendPacket(retaddr[1]->MyArena, buf, v134 + 5, 1);
    goto LABEL_443;
  }
}
/* Orphan comments:
isModerator != isModerator
playerPointersForSomething
Append .set after the dot
playerPointersForSomething
playerPointersForSomething
*/
// 414850: could not find valid save-restore pair for edi
// 4149DE: conditional instruction was optimized away because of 'ebp.4!=0'
// 4149F0: conditional instruction was optimized away because of 'ebp.4!=0'
// 414BA9: conditional instruction was optimized away because of 'ecx.4>=1'
// 416F2F: conditional instruction was optimized away because of 'eax.4!=0'
// 414880: variable 'v6' is possibly undefined
// 41506F: variable 'v296' is possibly undefined
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 42C848: using guessed type char *off_42C848[8];
// 431BE8: using guessed type int RadarValue;
// 431E9C: using guessed type int dword_431E9C[75];
// 431FC8: using guessed type int dword_431FC8[10];
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432004: using guessed type int RecycleServer;
// 437C18: using guessed type int DoubleValue;
// 437CA4: using guessed type int CurrentLogLine;
// 437CA8: using guessed type int IsServerRunning;
// 4386D4: using guessed type int MachineIdArrayCount;
// 438B10: using guessed type int ScreenValue;
// 4AC448: using guessed type KICK KickedUsers[1000];
// 4CA810: using guessed type int BillingLogMessages;
// 4D5920: using guessed type int IsEditedServerINIorCFG;
// 4D89C8: using guessed type int Wave;
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;
// 4D8AF4: using guessed type int LastServerStatsAndKickedPlayersTime;
// 4D8B18: using guessed type int ChatCounter64Max;

//----- (00418F20) --------------------------------------------------------
void __cdecl SomethingWithSendingChatTypes(struct PLAYER *player, int TargetPlayerId, signed int PlayerId, char *ChatText, char SoundByte)
{
  signed int v5; // edx
  struct PLAYER *v6; // ecx
  PLAYER *v7; // esi
  struct PLAYER **v8; // ebp
  struct PLAYER *v9; // eax
  const char *v10; // edi
  struct PLAYER *v11; // ecx
  const char *v12; // [esp-8h] [ebp-424h]
  int v13; // [esp-4h] [ebp-420h]
  PLAYER *v14; // [esp+10h] [ebp-40Ch]
  int v15; // [esp+14h] [ebp-408h]
  int v16; // [esp+18h] [ebp-404h]
  char Dest[512]; // [esp+1Ch] [ebp-400h] BYREF
  char buf[3]; // [esp+21Ch] [ebp-200h] BYREF
  __int16 v19; // [esp+21Fh] [ebp-1FDh]
  char v20[507]; // [esp+221h] [ebp-1FBh] BYREF

  if ( HighestPlayerCountMaybeSomething )
  {
    v5 = PlayerId;
    v15 = -1;
    v14 = 0;
    if ( PlayerId >= 0 && PlayerId < 1024 )
      v14 = ZonePlayerList[PlayerId];
    if ( TargetPlayerId == 3 && (v6 = player) != 0 )
    {
      v15 = *(_DWORD *)&player->Frequency;
      v7 = v14;
    }
    else
    {
      v7 = v14;
      if ( TargetPlayerId == 4 && v14 )
        v15 = *(_DWORD *)&v14->Frequency;
      v6 = player;
    }
    v16 = 0;
    if ( ZonePlayerCount > 0 )
    {
      v8 = playerPointerList;
      while ( 1 )
      {
        v9 = *v8;
        if ( (*v8)->MyArena )
        {
          if ( v9->field_287 > 0 )
          {
            Dest[0] = 0;
            if ( (TargetPlayerId != 5 || *(_DWORD *)&v9->PlayerId != v5) && v6 != v9 )
            {
              if ( v6 )
              {
                sprintf(Dest, "%s> %s ", v6->PlayerDataBillerPacket.Name, ChatText);
                switch ( TargetPlayerId )
                {
                  case 3:
                    v13 = v15;
                    v12 = "(TEAM:%d)";
                    goto LABEL_26;
                  case 4:
                    sprintf(&Dest[strlen(Dest)], "(ENEMYTEAM:%d)", v15);
                    goto LABEL_31;
                  case 5:
                    if ( v7 )
                    {
                      v13 = (int)v7->PlayerDataBillerPacket.Name;
                      v12 = "(TO:%s)";
LABEL_26:
                      sprintf(&Dest[strlen(Dest)], v12, v13);
                    }
                    else
                    {
                      v10 = "(TO:----)";
LABEL_30:
                      strcat(Dest, v10);
                    }
LABEL_31:
                    v11 = *v8;
                    if ( player->MyArena == (*v8)->MyArena )
                    {
                      if ( *(_DWORD *)&v11->Frequency == v15
                        || (TargetPlayerId == 1 || TargetPlayerId == 2) && *ChatText != '*' && *ChatText != '?'
                        || TargetPlayerId != 5 && v11->field_287 < 2 )
                      {
                        goto LABEL_46;
                      }
                    }
                    else
                    {
                      if ( v11->field_287 < 3 )
                        goto LABEL_46;
                      strcat(Dest, "(SPAWN)");
                    }
                    break;
                  case 7:
                    v10 = "(FIND)";
                    goto LABEL_30;
                  case 9:
                    v10 = "(CHAT)";
                    goto LABEL_30;
                  default:
                    goto LABEL_31;
                }
              }
              else
              {
                if ( v9->field_287 < 4 )
                  goto LABEL_46;
                sprintf(Dest, "*> %s ", ChatText);
              }
              if ( Dest[0] )
              {
                buf[2] = SoundByte;
                buf[0] = 7;
                buf[1] = 6;
                v19 = -1;
                strcpy(v20, Dest);
                SendPlayerReliablePacket(*v8, buf, strlen(Dest) + 6, 1);
              }
            }
          }
        }
LABEL_46:
        ++v8;
        if ( ++v16 >= ZonePlayerCount )
          return;
        v7 = v14;
        v5 = PlayerId;
        v6 = player;
      }
    }
  }
}
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;
// 418F20: using guessed type char Dest[512];

//----- (00419270) --------------------------------------------------------
// updates the points a player has, logging if necessary
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3)
{
  int v3; // ecx
  FILE *v4; // eax
  struct ARENA *arena; // ecx
  char buffer[16]; // [esp+Ch] [ebp-10h] BYREF

  v3 = a3 + player->FlagPoints;
  player->KillPoints += a2;
  player->FlagPoints = v3;
  if ( MiscLogPoints && BillingConnectionStructPointer )
  {
    v4 = PointsFileHandle;
    if ( !PointsFileHandle )
    {
      v4 = fopen("points.log", "ab");
      PointsFileHandle = v4;
    }
    arena = player->MyArena;
    if ( arena && arena->RecordPointsToLog )
    {
      if ( v4 )
      {
        *(_DWORD *)buffer = player->PlayerDataBillerPacket.UserId;
        *(_DWORD *)&buffer[4] = a2;
        *(_DWORD *)&buffer[8] = a3;
        *(_DWORD *)&buffer[12] = time(0);
        fwrite(buffer, 16u, 1u, PointsFileHandle);
      }
    }
  }
  else if ( PointsFileHandle )
  {
    fclose(PointsFileHandle);
    PointsFileHandle = 0;
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 438B08: using guessed type int MiscLogPoints;

//----- (00419350) --------------------------------------------------------
void __cdecl ReadServerINI()
{
  DWORD v0; // edi
  int v1; // eax
  DWORD v2; // edi
  int v3; // eax
  DWORD v4; // edi
  int v5; // eax
  DWORD v6; // edi
  int v7; // eax
  DWORD v8; // esi
  int v9; // eax
  int v10; // eax
  char Dest[16]; // [esp+Ch] [ebp-10h] BYREF

  CustomArenaMode = GetPrivateProfileIntWrapper("Custom", "ArenaMode", 0, FileName);
  ArenaMaxPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMaxPlayers", 0x3Cu, FileName);
  ArenaDesiredPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaDesiredPlayers", 0x28u, FileName);
  ArenaMinimumPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMinimumPlayers", 0xFu, FileName);
  ArenaSpawnKeepScores = GetPrivateProfileIntWrapper("Arena", "SpawnKeepScores", 0, FileName);
  MaxArenas = GetPrivateProfileIntWrapper("Arena", "MaxArenas", 0x64u, FileName);
  MaxArenasMemory = GetPrivateProfileIntWrapper("Arena", "MaxArenasMemory", 0xFA00u, FileName);
  CommsMaxQueueToLogin = GetPrivateProfileIntWrapper("Comms", "MaxQueueToLogin", 0x10u, FileName);
  CommsPacketHistoryMax = GetPrivateProfileIntWrapper("Comms", "PacketHistoryMax", 0x7D0u, FileName);
  CommsIncomingBufferSize = GetPrivateProfileIntWrapper("Comms", "IncomingBufferSize", 0x20000u, FileName);
  CommsOutgoingBufferSize = GetPrivateProfileIntWrapper("Comms", "OutgoingBufferSize", 0x20000u, FileName);
  CommsTransportBufferSize = GetPrivateProfileIntWrapper("Comms", "TransportBufferSize", 0xA0u, FileName);
  MiscDisableShareware = 1;
  MiscDisableSharewareShips = 1;
  MiscDisableSharewareScores = 1;
  CommsEncryptMode = 1;
  dword_437B14 = 1;
  BillingLogMessages = 0;
  MiscRegisterKickShareware = 1;
  MiscMaxSharewarePlayer = GetPrivateProfileIntWrapper(byte_42BC84, "MaxSharewarePlayers", 0xFFFFFFFF, FileName);
  MiscMaxSharkwareTime = GetPrivateProfileIntWrapper(byte_42BC84, "MaxSharewareTime", 0x15F90u, FileName);
  MiscMaxPlayers = GetPrivateProfileIntWrapper(byte_42BC84, "MaxPlayers", 0x78u, FileName);
  MiscMenuKickOutDelay = GetPrivateProfileIntWrapper(byte_42BC84, "MenuKickOutDelay", 0x2EE0u, FileName);
  MiscLogPoints = GetPrivateProfileIntWrapper(byte_42BC84, "LogPoints", 0, FileName);
  MiscPointUpdateDiff = GetPrivateProfileIntWrapper(byte_42BC84, "PointUpdateDiff", 0x1F4u, FileName);
  MiscJackpotBroadcastPoints = GetPrivateProfileIntWrapper(byte_42BC84, "JackpotBroadcastPoints", 0, FileName);
  MiscServerLog = GetPrivateProfileIntWrapper(byte_42BC84, "ServerLog", 0, FileName);
  MiscKeepAliveDelay = GetPrivateProfileIntWrapper(byte_42BC84, "KeepAliveDelay", 0x190u, FileName);
  GetPrivateProfileStringWrapper(
    byte_42BC84,
    "DefaultLevelFile",
    "changeme.lvl",
    MiscDefaultLevelFile,
    0x100u,
    FileName);
  CPUProcessMaxTime = GetPrivateProfileIntWrapper("CPU", "ProcessMaxTime", 4u, FileName);
  CPUSleepPerIteration = GetPrivateProfileIntWrapper("CPU", "SleepPerIteration", 0, FileName);
  CPUSleepTime = GetPrivateProfileIntWrapper("CPU", "SleepTime", 0, FileName);
  CPUSlowIterationWarningLevel = GetPrivateProfileIntWrapper("CPU", "SlowIterationWarningLevel", 0x64u, FileName);
  PermissionAllowLowBandwidth = GetPrivateProfileIntWrapper("Permission", "AllowLowBandwidth", 1u, FileName);
  PermissionMinimumSecondsToLogin = GetPrivateProfileIntWrapper("Permission", "MinimumSecondsToLogin", 0, FileName);
  PermissionMaxPoints = GetPrivateProfileIntWrapper("Permission", "PermissionMaxPoints", 0, FileName);
  PermissionMode = GetPrivateProfileIntWrapper("Permission", "PermissionMode", 0, FileName);
  AutoPermissionPoints = GetPrivateProfileIntWrapper("Permission", "AutoPermissionPoints", 0, FileName);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionIDList",
    "0",
    PermissionAutoPermissionIDList,
    0x200u,
    FileName);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionMessage",
    "Congratulations",
    PermissionAutoPermissionMessage,
    0x100u,
    FileName);
  v0 = GetTickCount() / 0xA;
  v1 = rand();
  sprintf(Dest, "%d", abs32(v0 + v1));
  GetPrivateProfileStringWrapper("Password", "SysopPassword", Dest, SysopPassword, 0x40u, FileName);
  v2 = GetTickCount() / 0xA;
  v3 = rand();
  sprintf(Dest, "%d", abs32(v2 + v3));
  GetPrivateProfileStringWrapper("Password", "EnergyPassword", Dest, EnergyPassword, 0x40u, FileName);
  v4 = GetTickCount() / 0xA;
  v5 = rand();
  sprintf(Dest, "%d", abs32(v4 + v5));
  GetPrivateProfileStringWrapper("Password", "ModeratorPassword", Dest, ModeratorPassword, 0x40u, FileName);
  v6 = GetTickCount() / 0xA;
  v7 = rand();
  sprintf(Dest, "%d", abs32(v6 + v7));
  GetPrivateProfileStringWrapper("Password", "SuperModeratorPassword", Dest, SuperModeratorPassword, 0x40u, FileName);
  v8 = GetTickCount() / 0xA;
  v9 = rand();
  sprintf(Dest, "%d", abs32(v8 + v9));
  GetPrivateProfileStringWrapper("Password", "VIPPassword", Dest, VIPPassword, 0x40u, FileName);
  GetPrivateProfileStringWrapper("Billing", "IP", "127.0.0.1", (LPSTR)&BillingIP, 0x80u, FileName);
  GetPrivateProfileStringWrapper("Billing", "Password", "money", BillingPassword, 0x20u, FileName);
  GetPrivateProfileStringWrapper("Billing", "ServerName", "Unknown", BillingServerName, 0x80u, FileName);
  *(_DWORD *)&BillingPort = GetPrivateProfileIntWrapper("Billing", "Port", 0x384u, FileName);
  v10 = rand();
  BillingServerId = GetPrivateProfileIntWrapper("Billing", "ServerId", v10, FileName);
  BillingGroupId = GetPrivateProfileIntWrapper("Billing", "GroupId", 1u, FileName);
  BillingScoreId = GetPrivateProfileIntWrapper("Billing", "ScoreId", 0, FileName);
  BillingReconnectTime = GetPrivateProfileIntWrapper("Billing", "ReconnectTime", 0x2EE0u, FileName);
  BillingAttemptTime = GetPrivateProfileIntWrapper("Billing", "AttemptTime", 0x2710u, FileName);
  AdvertiseSendMode = GetPrivateProfileIntWrapper("Advertise", "SendMode", 0, FileName);
  AdvertiseDisplayMode = GetPrivateProfileIntWrapper("Advertise", "DisplayMode", 2u, FileName);
  AdvertiseDuration = GetPrivateProfileIntWrapper("Advertise", "Duration", 0x2EE0u, FileName);
  GetPrivateProfileStringWrapper("Directory", "IP", "sscentral.vie.com", DirectoryIPAddresses, 0x200u, FileName);
  GetPrivateProfileStringWrapper("Directory", "Description", "None", DirectoryDescription, 0x100u, FileName);
  GetPrivateProfileStringWrapper(
    "Directory",
    "NamePassword",
    (LPSTR)&DirectoryCurrentNamePassword,
    DirectoryNamePassword,
    0x80u,
    FileName);
  *(_DWORD *)&DirectoryPort = GetPrivateProfileIntWrapper("Directory", "Port", 4991u, FileName);
}
// 4314B0: using guessed type int AdvertiseSendMode;
// 431FFC: using guessed type int ArenaMinimumPlayers;
// 437B10: using guessed type int ArenaSpawnKeepScores;
// 437B14: using guessed type int dword_437B14;
// 437C1C: using guessed type int BillingAttemptTime;
// 437CA0: using guessed type int CommsMaxQueueToLogin;
// 4380B0: using guessed type int ArenaMaxPlayers;
// 438138: using guessed type int MiscMaxSharewarePlayer;
// 438B08: using guessed type int MiscLogPoints;
// 438B14: using guessed type int CPUSlowIterationWarningLevel;
// 438B18: using guessed type int MaxArenasMemory;
// 438B1C: using guessed type int PermissionMode;
// 438B74: using guessed type int MiscMaxPlayers;
// 438B78: using guessed type int BillingReconnectTime;
// 438B7C: using guessed type int PermissionMinimumSecondsToLogin;
// 4AC438: using guessed type int PermissionMaxPoints;
// 4AF328: using guessed type int MiscKeepAliveDelay;
// 4AF32C: using guessed type int AutoPermissionPoints;
// 4C9F44: using guessed type int CPUSleepPerIteration;
// 4CA60C: using guessed type int MiscPointUpdateDiff;
// 4CA810: using guessed type int BillingLogMessages;
// 4D45C0: using guessed type int CustomArenaMode;
// 4D55CC: using guessed type int MiscServerLog;
// 4D55D4: using guessed type int MiscMaxSharkwareTime;
// 4D55D8: using guessed type int MiscMenuKickOutDelay;
// 4D5900: using guessed type int PermissionAllowLowBandwidth;
// 4D5904: using guessed type int CPUProcessMaxTime;
// 4D5908: using guessed type int MaxArenas;
// 4D590C: using guessed type int MiscJackpotBroadcastPoints;
// 4D5910: using guessed type int MiscRegisterKickShareware;
// 4D5918: using guessed type int MiscDisableShareware;
// 4D5928: using guessed type int ArenaDesiredPlayers;
// 4D8930: using guessed type int AdvertiseDuration;
// 4D8AD8: using guessed type int AdvertiseDisplayMode;
// 4D8AE0: using guessed type int MiscDisableSharewareScores;

//----- (00419B60) --------------------------------------------------------
void __cdecl LoadTemplateSSS()
{
  FILE *fileHandle; // eax
  FILE *fileHandlee; // edi
  char *v2; // eax
  char v3; // cl
  char *i; // edx
  char v5; // cl
  char *j; // edx
  char v7; // cl
  char *k; // edx
  char v9; // cl
  char *l; // edx
  char v11; // dl
  char *m; // ecx
  int v13; // eax
  TEMPLATE_SSS *v14; // esi
  char *v15; // esi
  char *v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int v20; // eax
  char boolean1; // [esp+8h] [ebp-888h]
  char boolean2; // [esp+Ch] [ebp-884h]
  char v23[64]; // [esp+10h] [ebp-880h] BYREF
  char Source[32]; // [esp+50h] [ebp-840h] BYREF
  char v25[256]; // [esp+90h] [ebp-800h] BYREF
  char Str[256]; // [esp+190h] [ebp-700h] BYREF
  char v27[512]; // [esp+290h] [ebp-600h] BYREF
  char Buf[1024]; // [esp+490h] [ebp-400h] BYREF

  TotalTemplateSSSEntries = 0;
  fileHandle = fopen("template.sss", "rt");
  fileHandlee = fileHandle;
  if ( fileHandle )
  {
    if ( (fileHandle->_flag & 0x10) == 0 )
    {
      do
      {
        if ( fgets(Buf, 1024, fileHandlee) && (isalpha(Buf[0]) || Buf[0] == '*' || Buf[0] == '+') )
        {
          Source[0] = 0;
          v23[0] = 0;
          Str[0] = 0;
          v25[0] = 0;
          v27[0] = 0;
          v2 = Buf;
          boolean1 = 0;
          if ( Buf[0] == '*' )
          {
            boolean1 = 1;
            v2 = &Buf[1];
          }
          boolean2 = 1;
          if ( *v2 == '+' )
          {
            boolean2 = 0;
            ++v2;
          }
          v3 = *v2;
          for ( i = Source; v3 != ':'; ++v2 )
          {
            if ( !v3 )
              break;
            *i = v3;
            v3 = v2[1];
            ++i;
          }
          *i = 0;
          if ( v2 )
            ++v2;
          v5 = *v2;
          for ( j = v23; v5 != ':'; ++v2 )
          {
            if ( !v5 )
              break;
            *j = v5;
            v5 = v2[1];
            ++j;
          }
          *j = 0;
          if ( v2 )
            ++v2;
          v7 = *v2;
          for ( k = Str; v7 != ':'; ++v2 )
          {
            if ( !v7 )
              break;
            *k = v7;
            v7 = v2[1];
            ++k;
          }
          *k = 0;
          if ( v2 )
            ++v2;
          v9 = *v2;
          for ( l = v25; v9 != ':'; ++v2 )
          {
            if ( !v9 )
              break;
            *l = v9;
            v9 = v2[1];
            ++l;
          }
          *l = 0;
          if ( v2 )
            ++v2;
          v11 = *v2;
          for ( m = v27; v11 >= ' '; ++v2 )
          {
            *m = v11;
            v11 = v2[1];
            ++m;
          }
          *m = 0;
          v13 = TotalTemplateSSSEntries;
          byte_438CD0[v13 * 338] = boolean1;
          byte_438CD1[v13 * 338] = boolean2;
          v14 = &TotalTemplateSSSList[v13];
          strncpy(TotalTemplateSSSList[v13].SomeString32, Source, 0x20u);
          v14->SomeString32[31] = 0;
          v15 = TotalTemplateSSSList[TotalTemplateSSSEntries].KeyName;
          strncpy(v15, v23, 0x28u);
          v15[39] = 0;
          v16 = &dword_438BD0[338 * TotalTemplateSSSEntries];
          strncpy(v16, v27, 0x100u);
          v16[255] = 0;
          v17 = TotalTemplateSSSEntries;
          v18 = 338 * TotalTemplateSSSEntries;
          if ( Str[0] )
          {
            v19 = atoi(Str);
            v17 = TotalTemplateSSSEntries;
            *(int *)((char *)&dword_438BC8 + v18) = v19;
          }
          else
          {
            *(int *)((char *)&dword_438BC8 + 338 * TotalTemplateSSSEntries) = -999;
          }
          if ( v25[0] )
          {
            v20 = atoi(v25);
            v17 = TotalTemplateSSSEntries;
            *(int *)((char *)&dword_438BCC + 338 * TotalTemplateSSSEntries) = v20;
          }
          else
          {
            *(int *)((char *)&dword_438BCC + v18) = -999;
          }
          TotalTemplateSSSEntries = v17 + 1;
        }
      }
      while ( (fileHandlee->_flag & 0x10) == 0 );
    }
    fclose(fileHandlee);
  }
  printf("Template.sss read, %d entries found\n", TotalTemplateSSSEntries);
}
// 438BC8: using guessed type int dword_438BC8;
// 438BCC: using guessed type int dword_438BCC;
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;

//----- (00419E50) --------------------------------------------------------
void __cdecl LoadMapSomething()
{
  int tileCounter; // ebx
  struct BMP_FILE_STRUCT *v1; // eax
  struct BMP_FILE_STRUCT *v2; // eax
  int BMPFileSizeTotal; // ebp
  unsigned int TileValuee; // edx
  int XRadiusCounter; // edi
  int YRadiusCounter; // esi
  int XCoordinate; // ecx
  int YCoordinate; // eax
  _BYTE *CheckTileValue; // eax
  unsigned int TileValue; // [esp+10h] [ebp-24h] BYREF
  char Buffer[17]; // [esp+14h] [ebp-20h] BYREF
  int v12; // [esp+30h] [ebp-4h]

  tileCounter = 0;
  if ( _access(MiscDefaultLevelFile, 0) )
  {
    printf(
      "Could not find specified level file (%s), make sure a level file with this name is in the server directory.",
      MiscDefaultLevelFile);
    exit(1);
  }
  *(_DWORD *)Buffer = 42;
  *(_DWORD *)&Buffer[4] = 0;
  *(_DWORD *)&Buffer[8] = 0;
  *(_DWORD *)&Buffer[12] = 0;
  Buffer[16] = 0;
  strcpy(&Buffer[1], MiscDefaultLevelFile);
  CompressedServerMap = CompressFile(MiscDefaultLevelFile, &DefaultMapFileSize, &MapChecksum, Buffer, 0x11u, 1, 0);
  v1 = (struct BMP_FILE_STRUCT *)operator new(0x110u);
  TileValue = (unsigned int)v1;
  v12 = 0;
  if ( v1 )
    LoadBMPHeader(v1, MiscDefaultLevelFile);
  else
    v2 = 0;
  v12 = -1;
  BMPFilePointer = v2;
  ServerMapAllocatedMemory = emalloc(0x100000);
  memset(ServerMapAllocatedMemory, 0, 0x100000u);
  BMPFileSizeTotal = GetTotalTileCount(BMPFilePointer);
  if ( BMPFileSizeTotal > 0 )
  {
    do
    {
      GetTileValue(BMPFilePointer, tileCounter, (int *)&TileValue);
      if ( (TileValue & 0xFF000000) != 0xAA000000 )// Anything other then 0xAA - Turf Flag Tile
      {
        *((_BYTE *)ServerMapAllocatedMemory + 1024 * ((TileValue >> 12) & 0xFFF) + (TileValue & 0xFFF)) = HIBYTE(TileValue);
        TileValuee = TileValue;
        if ( (TileValue & 0xFF000000) >= 0xD8000000 )// >= 0xD8 Big Tiles like Asteroids/Space Station/Wormhole and Secret Tiles
        {
          for ( XRadiusCounter = 0; XRadiusCounter < 7; ++XRadiusCounter )
          {
            for ( YRadiusCounter = 0; YRadiusCounter < 7; ++YRadiusCounter )
            {
              XCoordinate = XRadiusCounter + (TileValuee & 0xFFF);
              YCoordinate = YRadiusCounter + ((TileValuee >> 12) & 0xFFF);
              if ( XCoordinate < 1024 && YCoordinate < 1024 )
              {
                CheckTileValue = (char *)ServerMapAllocatedMemory + 1024 * YCoordinate + XCoordinate;//  1024x1024 memory required
                if ( !*CheckTileValue )
                {
                  *CheckTileValue = 0xF0;       // Set's the tile to default value of 0xF0 -  Invisible on screen, visible on radar, solid block (like any other tile).
                  TileValuee = TileValue;
                }
              }
            }
          }
        }
      }
      ++tileCounter;
    }
    while ( tileCounter < BMPFileSizeTotal );
  }
}
/* Orphan comments:
0x2A - Compressed Map File
*/
// 419F37: variable 'v2' is possibly undefined

//----- (0041A040) --------------------------------------------------------
void __cdecl LoadAdvertisements()
{
  int v0; // esi
  HANDLE v1; // ebx
  LONG BMPHEIGHT; // esi
  size_t v3; // edi
  int BothTotalPacketSize; // ebp
  char *BothAdPacketBuffer; // ebx
  FILE *v6; // eax
  int v7; // esi
  bool v8; // zf
  int v9; // eax
  int v10; // eax
  int v11; // esi
  HANDLE v12; // ebx
  LONG v13; // esi
  size_t v14; // edi
  int v15; // ebp
  char *v16; // ebx
  FILE *v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // eax
  int v21; // esi
  HANDLE v22; // ebx
  LONG v23; // esi
  size_t v24; // edi
  int v25; // ebp
  char *v26; // ebx
  FILE *v27; // eax
  int v28; // esi
  int v29; // eax
  int v30; // eax
  unsigned int BMPWIDTH; // [esp+10h] [ebp-8C0h]
  unsigned int BMPWIDTHa; // [esp+10h] [ebp-8C0h]
  unsigned int BMPWIDTHb; // [esp+10h] [ebp-8C0h]
  FILE *File; // [esp+14h] [ebp-8BCh]
  FILE *Filea; // [esp+14h] [ebp-8BCh]
  FILE *Fileb; // [esp+14h] [ebp-8BCh]
  char *v37; // [esp+18h] [ebp-8B8h]
  FILE *v38; // [esp+18h] [ebp-8B8h]
  FILE *v39; // [esp+18h] [ebp-8B8h]
  int v40; // [esp+1Ch] [ebp-8B4h]
  int v41; // [esp+1Ch] [ebp-8B4h]
  int v42; // [esp+1Ch] [ebp-8B4h]
  int v43; // [esp+20h] [ebp-8B0h]
  int v44; // [esp+20h] [ebp-8B0h]
  int v45; // [esp+20h] [ebp-8B0h]
  size_t v46; // [esp+24h] [ebp-8ACh]
  size_t v47; // [esp+24h] [ebp-8ACh]
  size_t v48; // [esp+24h] [ebp-8ACh]
  _WORD DstBuf[8]; // [esp+28h] [ebp-8A8h] BYREF
  BITMAP bm; // [esp+38h] [ebp-898h] BYREF
  char Dest[128]; // [esp+50h] [ebp-880h] BYREF
  char v52[2048]; // [esp+D0h] [ebp-800h] BYREF

  v0 = 0;
  SharewareAdvertisementsFound = 0;
  RegisteredAdvertisementsFound = 0;
  BothAdvertisementsFound = 0;
  v43 = 0;
  do
  {
    sprintf(Dest, "b_ad%d.bmp", v0);
    if ( _access(Dest, 0) )
    {
      v10 = BothAdvertisementsFound;
    }
    else
    {
      v1 = LoadImageA(0, Dest, 0, 0, 0, 0x2010u);
      GetObjectA(v1, 24, &bm);
      BMPHEIGHT = bm.bmHeight;
      BMPWIDTH = bm.bmWidth;
      v3 = 4 * ((bm.bmWidth + 3) / 4);
      v46 = v3;
      DeleteObject(v1);
      BothTotalPacketSize = BMPWIDTH * BMPHEIGHT + 10;
      BothAdPacketBuffer = (char *)emalloc(BothTotalPacketSize);
      *BothAdPacketBuffer = 0x30;               // 0x30 - Zone Banner Advertisements
      BothAdPacketBuffer[1] = AdvertiseDisplayMode;
      *((_WORD *)BothAdPacketBuffer + 1) = BMPWIDTH;
      *((_WORD *)BothAdPacketBuffer + 2) = BMPHEIGHT;
      *(_DWORD *)(BothAdPacketBuffer + 6) = AdvertiseDuration;
      v6 = fopen(Dest, "rb");
      File = v6;
      if ( v6 )
      {
        fread(DstBuf, 1u, 14u, v6);
        fseek(File, *(__int32 *)&DstBuf[5], 0); // //Goes to offset where Pixels are found.
        v7 = BMPHEIGHT - 1;
        if ( v7 >= 0 )
        {
          v37 = &BothAdPacketBuffer[BMPWIDTH * v7 + 10];
          v40 = v7 + 1;
          while ( 1 )
          {
            fread(v52, 1u, v3, File);
            qmemcpy(v37, v52, BMPWIDTH);
            v8 = v40 == 1;
            v37 -= BMPWIDTH;
            --v40;
            if ( v8 )
              break;
            v3 = v46;
          }
        }
        fclose(File);
      }
      v9 = BothAdvertisementsFound;
      v0 = v43;
      (&dword_437CB4)[2 * BothAdvertisementsFound] = (char *)BothTotalPacketSize;
      BothAd[v9].PacketBuffer = BothAdPacketBuffer;
      v10 = v9 + 1;
      BothAdvertisementsFound = v10;
    }
    v43 = ++v0;
  }
  while ( v0 < 128 );
  printf("%d both advertisements found\n", v10);
  v11 = 0;
  v44 = 0;
  do
  {
    sprintf(Dest, "s_ad%d.bmp", v11);
    if ( _access(Dest, 0) )
    {
      v20 = SharewareAdvertisementsFound;
    }
    else
    {
      v12 = LoadImageA(0, Dest, 0, 0, 0, 0x2010u);
      GetObjectA(v12, 24, &bm);
      v13 = bm.bmHeight;
      BMPWIDTHa = bm.bmWidth;
      v14 = 4 * ((bm.bmWidth + 3) / 4);
      v47 = v14;
      DeleteObject(v12);
      v15 = BMPWIDTHa * v13 + 10;
      v16 = (char *)emalloc(v15);
      *v16 = 0x30;                              // 0x30 - Zone Banner Advertisements
      v16[1] = AdvertiseDisplayMode;
      *((_WORD *)v16 + 1) = BMPWIDTHa;
      *((_WORD *)v16 + 2) = v13;
      *(_DWORD *)(v16 + 6) = AdvertiseDuration;
      v17 = fopen(Dest, "rb");
      v38 = v17;
      if ( v17 )
      {
        fread(DstBuf, 1u, 0xEu, v17);
        fseek(v38, *(__int32 *)&DstBuf[5], 0);  // //Goes to offset where Pixels are found.
        v18 = v13 - 1;
        if ( v18 >= 0 )
        {
          Filea = (FILE *)&v16[BMPWIDTHa * v18 + 10];
          v41 = v18 + 1;
          while ( 1 )
          {
            fread(v52, 1u, v14, v38);
            qmemcpy(Filea, v52, BMPWIDTHa);
            v8 = v41 == 1;
            Filea = (FILE *)((char *)Filea - BMPWIDTHa);
            --v41;
            if ( v8 )
              break;
            v14 = v47;
          }
        }
        fclose(v38);
      }
      v19 = SharewareAdvertisementsFound;
      v11 = v44;
      *(&dword_431BF4 + 2 * SharewareAdvertisementsFound) = v15;
      SharewareAd[v19].PacketBuffer = v16;
      v20 = v19 + 1;
      SharewareAdvertisementsFound = v20;
    }
    v44 = ++v11;
  }
  while ( v11 < 128 );
  printf("%d shareware advertisements found\n", v20);
  v21 = 0;
  v45 = 0;
  do
  {
    sprintf(Dest, "r_ad%d.bmp", v21);
    if ( _access(Dest, 0) )
    {
      v30 = RegisteredAdvertisementsFound;
    }
    else
    {
      v22 = LoadImageA(0, Dest, 0, 0, 0, 0x2010u);
      GetObjectA(v22, 24, &bm);
      v23 = bm.bmHeight;
      BMPWIDTHb = bm.bmWidth;
      v24 = 4 * ((bm.bmWidth + 3) / 4);
      v48 = v24;
      DeleteObject(v22);
      v25 = BMPWIDTHb * v23 + 10;
      v26 = (char *)emalloc(v25);
      *v26 = 0x30;                              // 0x30 - Zone Banner Advertisements
      v26[1] = AdvertiseDisplayMode;
      *((_WORD *)v26 + 1) = BMPWIDTHb;
      *((_WORD *)v26 + 2) = v23;
      *(_DWORD *)(v26 + 6) = AdvertiseDuration;
      v27 = fopen(Dest, "rb");
      v39 = v27;
      if ( v27 )
      {
        fread(DstBuf, 1u, 0xEu, v27);
        fseek(v39, *(__int32 *)&DstBuf[5], 0);  // //Goes to offset where Pixels are found.
        v28 = v23 - 1;
        if ( v28 >= 0 )
        {
          Fileb = (FILE *)&v26[BMPWIDTHb * v28 + 10];
          v42 = v28 + 1;
          while ( 1 )
          {
            fread(v52, 1u, v24, v39);
            qmemcpy(Fileb, v52, BMPWIDTHb);
            v8 = v42 == 1;
            Fileb = (FILE *)((char *)Fileb - BMPWIDTHb);
            --v42;
            if ( v8 )
              break;
            v24 = v48;
          }
        }
        fclose(v39);
      }
      v29 = RegisteredAdvertisementsFound;
      v21 = v45;
      *(&dword_4317BC + 2 * RegisteredAdvertisementsFound) = v25;
      RegisteredAd[v29].PacketBuffer = v26;
      v30 = v29 + 1;
      RegisteredAdvertisementsFound = v30;
    }
    v45 = ++v21;
  }
  while ( v21 < 128 );
  printf("%d registered advertisements found\n", v30);
}
/* Orphan comments:
Existence only
Existence only
Existence only
*/
// 4D8930: using guessed type int AdvertiseDuration;
// 4D8AD8: using guessed type int AdvertiseDisplayMode;
// 4D8AFC: using guessed type int SharewareAdvertisementsFound;
// 4D8B00: using guessed type int RegisteredAdvertisementsFound;
// 4D8B04: using guessed type int BothAdvertisementsFound;

//----- (0041A580) --------------------------------------------------------
void __cdecl CleanUpMemory()
{
  int v0; // esi
  struct PACKET_ADVERTISEMENT *v1; // edi
  int v2; // edi
  struct PACKET_ADVERTISEMENT *v3; // esi
  int v4; // edi
  struct PACKET_ADVERTISEMENT *v5; // esi

  v0 = 0;
  if ( RegisteredAdvertisementsFound > 0 )
  {
    v1 = RegisteredAd;
    do
    {
      if ( v1->PacketBuffer )
        efree(v1->PacketBuffer);
      ++v0;
      ++v1;
    }
    while ( v0 < RegisteredAdvertisementsFound );
  }
  v2 = 0;
  RegisteredAdvertisementsFound = 0;
  if ( SharewareAdvertisementsFound > 0 )
  {
    v3 = SharewareAd;
    do
    {
      if ( v3->PacketBuffer )
        efree(v3->PacketBuffer);
      ++v2;
      ++v3;
    }
    while ( v2 < SharewareAdvertisementsFound );
  }
  v4 = 0;
  SharewareAdvertisementsFound = 0;
  if ( BothAdvertisementsFound > 0 )
  {
    v5 = BothAd;
    do
    {
      if ( v5->PacketBuffer )
        efree(v5->PacketBuffer);
      ++v4;
      ++v5;
    }
    while ( v4 < BothAdvertisementsFound );
  }
  BothAdvertisementsFound = 0;
}
// 4D8AFC: using guessed type int SharewareAdvertisementsFound;
// 4D8B00: using guessed type int RegisteredAdvertisementsFound;
// 4D8B04: using guessed type int BothAdvertisementsFound;

//----- (0041A630) --------------------------------------------------------
int __cdecl LoadWinsock()
{
  struct WSAData WSAData; // [esp+0h] [ebp-190h] BYREF

  return WSAStartup(0x101u, &WSAData);
}

//----- (0041A660) --------------------------------------------------------
void __thiscall StartServerListener(struct PACKET_ATTACHMENT *packetAttachment, int a2, int a3, int MaxConnections, int ServerListenPort, int OutgoingBufferSize, int IncomingBufferSize, int PacketHistoryMax)
{
  int v8; // eax
  struct PACKET_ATTACHMENT_HISTORY *v10; // edi
  int v11; // eax
  int v12; // edi
  CONNECTION *v13; // eax
  int v14; // ecx
  int v15; // edx
  struct CONNECTION *v16; // edi
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  u_short v20; // cx
  int v21; // [esp-14h] [ebp-34h]
  int v22; // [esp-14h] [ebp-34h]
  int v23; // [esp-14h] [ebp-34h]
  u_long argp; // [esp+Ch] [ebp-14h] BYREF
  struct sockaddr name; // [esp+10h] [ebp-10h] BYREF

  v8 = PacketHistoryMax;
  if ( PacketHistoryMax < 1 )
    v8 = 1;
  packetAttachment->PacketHistoryMax = v8;
  packetAttachment->PacketCurrentHistory = 0;
  v10 = (struct PACKET_ATTACHMENT_HISTORY *)emalloc(540 * v8);
  v11 = packetAttachment->PacketHistoryMax;
  packetAttachment->recievePacketBuffer = v10;
  memset(v10, 0, 4 * ((unsigned int)(540 * v11) >> 2));
  packetAttachment->dword0 = a2;
  packetAttachment->EncryptMode = 0;
  packetAttachment->CommsTransportBufferSizeLimited = 0;
  packetAttachment->dword4 = a3;
  packetAttachment->MaxConnections = MaxConnections;
  packetAttachment->Port = ServerListenPort;
  packetAttachment->TickCountDividedBy10 = GetTickCount() / 0xA;
  packetAttachment->dword24 = 500;
  packetAttachment->TotalPacketSendLength = 0;
  packetAttachment->TotalPacketSendCalls = 0;
  packetAttachment->TotalPacketRecvLength = 0;
  packetAttachment->TotalPacketRecvCalls = 0;
  packetAttachment->TotalPacketClustersCalls = 0;
  memset(packetAttachment->field_34, 0, sizeof(packetAttachment->field_34));
  v12 = packetAttachment->MaxConnections;
  packetAttachment->SomeCounter = 0;
  packetAttachment->dword8C34 = 0;
  v13 = (CONNECTION *)operator new(3190 * v12);
  if ( v13 )
  {
    if ( v12 - 1 >= 0 )
    {
      v14 = (int)&v13->state;
      v15 = v12;
      do
      {
        *(_DWORD *)v14 = 0;
        v14 += 3190;
        --v15;
      }
      while ( v15 );
    }
    v16 = v13;
  }
  else
  {
    v16 = 0;
  }
  v17 = packetAttachment->MaxConnections;
  packetAttachment->SomePointer = v16;
  memset(v16, 0, 3190 * v17);
  v18 = packetAttachment->MaxConnections;
  packetAttachment->TotalConnections = 0;
  packetAttachment->Connections = (struct CONNECTION **)emalloc(4 * v18);
  v19 = SOCKET(2, 2, 0);
  packetAttachment->Socket = v19;
  argp = 1;
  ioctlsocket(v19, 0x8004667E, &argp);          // FIONBIO 
  v21 = packetAttachment->Socket;
  PacketHistoryMax = -1;
  setsockopt(v21, 6, IP_OPTIONS, (const char *)&PacketHistoryMax, 4);
  v22 = packetAttachment->Socket;
  PacketHistoryMax = OutgoingBufferSize;
  setsockopt(v22, 0xFFFF, 4097, (const char *)&PacketHistoryMax, 4);
  v23 = packetAttachment->Socket;
  PacketHistoryMax = IncomingBufferSize;
  setsockopt(v23, 0xFFFF, 4098, (const char *)&PacketHistoryMax, 4);
  v20 = packetAttachment->Port;
  name.sa_family = 2;
  *(_WORD *)name.sa_data = htons(v20);
  *(_DWORD *)&name.sa_data[2] = htonl(0);
  bind(packetAttachment->Socket, &name, 16);
}

//----- (0041A870) --------------------------------------------------------
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment)
{
  int v2; // ebx
  CONNECTION *encryption; // esi
  int v4; // ebx
  char *v5; // esi

  v2 = 0;
  for ( encryption = packetAttachment->SomePointer; v2 < packetAttachment->MaxConnections; ++encryption )
  {
    if ( encryption->state )
      sub_41B7A0(encryption);
    ++v2;
  }
  closesocket(packetAttachment->Socket);
  operator delete(packetAttachment->SomePointer);
  v4 = 0;
  if ( (int)packetAttachment->SomeCounter > 0 )
  {
    v5 = (char *)&packetAttachment->field_34[0].LargePacketBuffer;
    do
    {
      if ( *(_DWORD *)v5 )
      {
        efree(*(LPVOID *)v5);
        *(_DWORD *)v5 = 0;
      }
      ++v4;
      v5 += 140;
    }
    while ( v4 < packetAttachment->SomeCounter );
  }
  efree(packetAttachment->Connections);
  efree(packetAttachment->recievePacketBuffer);
}

//----- (0041A910) --------------------------------------------------------
void __thiscall SetPacketAttachmentEncryptMode(struct PACKET_ATTACHMENT *packetAttachment, int CommsEncryptMode)
{
  packetAttachment->EncryptMode = CommsEncryptMode;
}

//----- (0041A920) --------------------------------------------------------
struct CONNECTION *__thiscall SomethingBillerServer(PACKET_ATTACHMENT *packetAttachment, const char *name, u_short hostshort, int a4, int a5)
{
  const char *v5; // edi
  struct in_addr *v7; // ebp
  struct hostent *v8; // eax
  int v9; // ecx
  int v10; // edi
  int v11; // eax
  CONNECTION *v12; // ebx
  __int16 v13; // ax
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  struct CONNECTION **v17; // eax
  int v18; // eax
  struct CONNECTION **v19; // ecx
  int v21; // [esp-10h] [ebp-2Ch]
  int v22; // [esp-Ch] [ebp-28h]
  int v23; // [esp-4h] [ebp-20h]
  int ElementToFind; // [esp+10h] [ebp-Ch] BYREF
  __int16 v25; // [esp+14h] [ebp-8h]
  int v26; // [esp+16h] [ebp-6h]

  v5 = name;
  v7 = (struct in_addr *)inet_addr(name);
  if ( v7 == (struct in_addr *)-1 )
  {
    v8 = gethostbyname(v5);
    if ( !v8 )
      return 0;
    v7 = **(struct in_addr ***)v8->h_addr_list;
  }
  v9 = packetAttachment->MaxConnections;
  v10 = 0;
  if ( v9 <= 0 )
  {
LABEL_8:
    v10 = -1;
  }
  else
  {
    v11 = (int)&packetAttachment->SomePointer->state;
    while ( *(_DWORD *)v11 )
    {
      ++v10;
      v11 += 3190;
      if ( v10 >= v9 )
        goto LABEL_8;
    }
  }
  if ( v10 == -1 )
    return 0;
  v23 = a5;
  v12 = &packetAttachment->SomePointer[v10];
  v22 = a4;
  v13 = htons(hostshort);
  InitializeEncryption(v12, packetAttachment, 1, v10, (int)v7, v13, v22, 1, v23);
  v14 = packetAttachment->TotalConnections;
  v15 = 0;
  if ( v14 )
  {
    v16 = v12->RemoteIP;
    v25 = v12->RemotePort;
    ElementToFind = v16;
    v21 = v14;
    v17 = packetAttachment->Connections;
    v26 = v12->PlayerId;
    v18 = BinarySearch((int)&ElementToFind, (unsigned int)v17, v21, 4, DifferentCompareFunction, (unsigned int *)&name);
    v19 = packetAttachment->Connections;
    v15 = (v18 - (int)v19) >> 2;
    memcpy(&v19[v15 + 1], &v19[v15], 4 * (packetAttachment->TotalConnections + 0x3FFFFFFF * v15));
  }
  packetAttachment->Connections[v15] = v12;
  ++packetAttachment->TotalConnections;
  return v12;
}

//----- (0041AA50) --------------------------------------------------------
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename)
{
  FILE *v3; // eax
  int v4; // ecx
  char *v5; // ebp
  int v6; // edx
  struct PACKET_ATTACHMENT_HISTORY *v7; // ecx
  int v8; // esi
  int v9; // edi
  char *v10; // ebp
  char *v11; // eax
  FILE *File; // [esp+0h] [ebp-4h]
  char *Filenamea; // [esp+8h] [ebp+4h]

  v3 = fopen(Filename, "wt");
  File = v3;
  if ( v3 )
  {
    v4 = packetAttachment->PacketHistoryMax;
    v5 = 0;
    Filenamea = 0;
    if ( v4 > 0 )
    {
      do
      {
        v6 = (int)&v5[packetAttachment->PacketCurrentHistory] % v4;
        v7 = packetAttachment->recievePacketBuffer;
        v8 = v6;
        v9 = v7[v6].PacketLength;
        if ( v9 > 0 )
        {
          v10 = v7[v6].PacketBuffer;
          v11 = inet_ntoa(*(struct in_addr *)(v10 + 532));
          fprintf(File, "%16s,%5d %3d: ", v11, packetAttachment->recievePacketBuffer[v8].RemotePort, v9);
          do
          {
            fprintf(File, "%02x ", (unsigned __int8)*v10++);
            --v9;
          }
          while ( v9 );
          fprintf(File, "\n");
          v5 = Filenamea;
        }
        v4 = packetAttachment->PacketHistoryMax;
        Filenamea = ++v5;
      }
      while ( (int)v5 < v4 );
      v3 = File;
    }
    fclose(v3);
  }
}

//----- (0041AB30) --------------------------------------------------------
char *__thiscall PlayerReadPackets(struct PACKET_ATTACHMENT *packetAttachment, int *RecvLength, int *RemoteIP, int *RemotePort)
{
  int v5; // eax
  struct PACKET_ATTACHMENT_HISTORY *v6; // edx
  int v7; // edi
  int RecvLenn; // eax
  int RecvLen; // ecx
  struct PACKET_ATTACHMENT_HISTORY *v10; // eax
  int v11; // edx
  char **result; // eax
  int fromlen; // [esp+8h] [ebp-14h] BYREF
  struct sockaddr from; // [esp+Ch] [ebp-10h] BYREF

  v5 = packetAttachment->PacketCurrentHistory;
  v6 = packetAttachment->recievePacketBuffer;
  fromlen = 16;
  v7 = v5;
  RecvLenn = recvfrom(packetAttachment->Socket, v6[v5].PacketBuffer, 512, 0, &from, &fromlen);
  RecvLen = RecvLenn;
  if ( RecvLenn == -1 )
    return 0;
  packetAttachment->recievePacketBuffer[v7].PacketLength = RecvLenn;
  v10 = packetAttachment->recievePacketBuffer;
  packetAttachment->PacketCurrentHistory = (packetAttachment->PacketCurrentHistory + 1)
                                         % packetAttachment->PacketHistoryMax;
  v10[v7].RemoteIP = *(_DWORD *)&from.sa_data[2];
  packetAttachment->recievePacketBuffer[v7].RemotePort = *(_WORD *)from.sa_data;
  *RemoteIP = *(_DWORD *)&from.sa_data[2];
  *(_WORD *)RemotePort = *(_WORD *)from.sa_data;
  *RecvLength = RecvLen;
  v11 = packetAttachment->TotalPacketRecvCalls;
  packetAttachment->TotalPacketRecvLength += RecvLen;
  result = (char **)&packetAttachment->recievePacketBuffer[v7];
  packetAttachment->TotalPacketRecvCalls = v11 + 1;
  return (char *)result;
}

//----- (0041AC00) --------------------------------------------------------
// send/recv packets
bool __thiscall PlayerDoNetworkOps(struct PACKET_ATTACHMENT *packetAttachment)
{
  __int64 v2; // rax
  DWORD v3; // kr00_4
  int v4; // eax
  int v5; // esi
  __int64 v6; // rax
  DWORD v7; // kr04_4
  int v8; // eax
  int v9; // ebx
  struct CONNECTION *v10; // esi
  int v11; // eax
  char *v12; // eax
  char *v14; // [esp-8h] [ebp-20h]
  unsigned int v15; // [esp-4h] [ebp-1Ch]
  int a6; // [esp+Ch] [ebp-Ch] BYREF
  int a5; // [esp+10h] [ebp-8h] BYREF
  signed int Size; // [esp+14h] [ebp-4h] BYREF

  v2 = (int)(GetTickCount() / 0xA - packetAttachment->TickCountDividedBy10Two);
  if ( (int)((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 10 )
  {
    v3 = GetTickCount();
    v4 = packetAttachment->TotalConnections;
    v5 = 0;
    packetAttachment->TickCountDividedBy10Two = v3 / 0xA;
    if ( v4 > 0 )
    {
      do
        SendBiDirectionalCorePackets(packetAttachment->Connections[v5++]);
      while ( v5 < packetAttachment->TotalConnections );
    }
  }
  if ( (int)packetAttachment->CommsTransportBufferSizeLimited > 0 )
  {
    v6 = (int)(GetTickCount() / 0xA - packetAttachment->TickCountDividedBy10);
    if ( (int)((HIDWORD(v6) ^ v6) - HIDWORD(v6)) >= 100 )
    {
      v7 = GetTickCount();
      v8 = packetAttachment->TotalConnections;
      v9 = 0;
      packetAttachment->TickCountDividedBy10 = v7 / 0xA;
      if ( v8 > 0 )
      {
        do
        {
          v10 = packetAttachment->Connections[v9];
          v11 = v10->ClusterPacketLength - (_DWORD)v10 - 2706;
          if ( v11 > 2 )
          {
            if ( (unsigned __int8)v10->ClusterPacket[2] + 3 == v11 )
            {
              v15 = v10->ClusterPacketLength - (_DWORD)v10 - 2709;
              v14 = &v10->ClusterPacket[3];
            }
            else
            {
              v15 = v10->ClusterPacketLength - (_DWORD)v10 - 2706;
              v14 = v10->ClusterPacket;
            }
            WriteToNetwork(v10, v14, v15);
            v10->ClusterPacketLength = (int)v10->ClusterPacket;
          }
          ++v9;
        }
        while ( v9 < packetAttachment->TotalConnections );
      }
    }
  }
  v12 = PlayerReadPackets(packetAttachment, &Size, &a5, &a6);
  if ( !v12 )
    return 0;
  PlayerHandlePacket(packetAttachment, v12, Size, a5, a6);
  return 1;
}

//----- (0041AD60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall PlayerHandlePacket(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, signed int Size, int a5, __int16 a6)
{
  int v6; // eax
  CONNECTION **v7; // eax
  CONNECTION *connectionn; // ebp
  char *v9; // ebx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  CONNECTION *encryption; // edi
  int v18; // eax
  int v19; // ebp
  int v20; // ecx
  struct CONNECTION **v21; // eax
  int v22; // eax
  struct CONNECTION **v23; // ecx
  int v24; // eax
  int v25; // ecx
  unsigned int v26; // edx
  DWORD v27; // kr00_4
  int v28; // eax
  int v29; // ecx
  int v30; // ecx
  char *v31; // eax
  char *v32; // esi
  int v33; // edx
  char *v34; // edi
  int v35; // ecx
  int v36; // ebx
  int v37; // eax
  int *v38; // esi
  int v39; // edx
  char *SSEncryptionTablee; // edi
  int v41; // ecx
  int v42; // ebx
  struct CONNECTION **v43; // [esp-14h] [ebp-38h]
  int v44; // [esp-10h] [ebp-34h]
  unsigned int buf[2]; // [esp+10h] [ebp-14h] BYREF
  int ElementToFind; // [esp+18h] [ebp-Ch] BYREF
  __int16 v47; // [esp+1Ch] [ebp-8h]
  int v48; // [esp+1Eh] [ebp-6h]
  int ptra; // [esp+28h] [ebp+4h]

  ElementToFind = a5;
  v6 = packetAttachment->TotalConnections;
  v47 = a6;
  v43 = packetAttachment->Connections;
  v48 = -1;
  v7 = (CONNECTION **)BinarySearch((int)&ElementToFind, (unsigned int)v43, v6, 4, DifferentCompareFunction, buf);
  if ( buf[0] )
    connectionn = *v7;
  else
    connectionn = 0;
  v9 = buffer;
  if ( *buffer || buffer[1] != 1 )
  {
    if ( !connectionn )
      return;
    v27 = GetTickCount();
    v28 = connectionn->ServerKey;
    v29 = connectionn->TotalPacketsRecieved + 1;
    connectionn->MenuKickOutDelayTimer = v27 / 0xA;
    connectionn->TotalPacketsRecieved = v29;
    v30 = Size;
    if ( v28 <= 0 )
      goto LABEL_44;
    if ( *buffer )
    {
      v37 = (int)(buffer + 1);
      v38 = (int *)&buffer[4 * ((unsigned int)(Size + 2) >> 2) + 1];// >> 2 same as divide by 4. (powers of 2)
      v39 = connectionn->ServerKey;
      if ( buffer + 1 == (char *)v38 )
      {
LABEL_44:
        ProcessCorePackets(connectionn, v9, v30, 0);
        return;
      }
      SSEncryptionTablee = &connectionn->SSEncryptionTable[-v37];// First you go back Huge amount (possibly 2 Billion index's back, impossible but it works
      do
      {
        v41 = *(_DWORD *)v37;
        v42 = v39 ^ *(_DWORD *)&SSEncryptionTablee[v37];// Then it goes back to (possibly 2 billion index's back, which cancels out back into reasonable values)
        v37 += 4;                               // Go up by 4 bytes (DWORDS)
        *(_DWORD *)(v37 - 4) = v41 ^ v42;       // Previous DWORD Computation
        v39 = v41;
      }
      while ( (int *)v37 != v38 );
    }
    else
    {
      if ( buffer[1] == 2 )
        goto LABEL_44;
      if ( Size < 2 )
        return;
      v31 = buffer + 2;
      v32 = &buffer[4 * ((unsigned int)(Size + 1) >> 2) + 2];// >> 2 same as divide by 4. (powers of 2)
      v33 = connectionn->ServerKey;
      if ( buffer + 2 == v32 )
        goto LABEL_44;
      v34 = (char *)(connectionn->SSEncryptionTable - v31);
      do
      {
        v35 = *(_DWORD *)v31;
        v36 = v33 ^ *(_DWORD *)&v34[(_DWORD)v31];
        v31 += 4;
        *((_DWORD *)v31 - 1) = v35 ^ v36;
        v33 = v35;
      }
      while ( v31 != v32 );
    }
    v9 = buffer;
    v30 = Size;
    goto LABEL_44;
  }
  ptra = 0;
  if ( Size >= 8 )
    ptra = *((__int16 *)v9 + 3);
  if ( ptra != 1 )
    goto LABEL_9;
  v11 = packetAttachment->EncryptMode;
  if ( v11 )
  {
    v12 = v11 - 1;
    if ( !v12 )
    {
      v10 = abs32(*(_DWORD *)(v9 + 2));
      goto LABEL_15;
    }
    if ( v12 == 1 )
    {
LABEL_9:
      v10 = -abs32(*(_DWORD *)(v9 + 2));
LABEL_15:
      *(_DWORD *)(v9 + 2) = v10;
    }
  }
  if ( connectionn && (v13 = *(_DWORD *)(v9 + 2), connectionn->ServerKey == v13) )
  {
    LOWORD(buf[0]) = 512;
    *(unsigned int *)((char *)buf + 2) = v13;
    WriteToNetwork(connectionn, (const char *)buf, 6u);
  }
  else
  {
    v14 = packetAttachment->MaxConnections;
    v15 = 0;
    if ( v14 <= 0 )
    {
LABEL_23:
      v15 = -1;
    }
    else
    {
      v16 = (int)&packetAttachment->SomePointer->state;
      while ( *(_DWORD *)v16 )
      {
        ++v15;
        v16 += 3190;
        if ( v15 >= v14 )
          goto LABEL_23;
      }
    }
    if ( v15 != -1 && packetAttachment->dword0 )
    {
      encryption = &packetAttachment->SomePointer[v15];
      InitializeEncryption(encryption, packetAttachment, 3, v15, a5, a6, *(_DWORD *)(v9 + 2), ptra, 0);
      encryption->TotalPacketsRecieved = 1;
      v18 = packetAttachment->TotalConnections;
      v19 = 0;
      if ( v18 )
      {
        v20 = encryption->RemoteIP;
        v47 = encryption->RemotePort;
        ElementToFind = v20;
        v44 = v18;
        v21 = packetAttachment->Connections;
        v48 = encryption->PlayerId;
        v22 = BinarySearch(
                (int)&ElementToFind,
                (unsigned int)v21,
                v44,
                4,
                DifferentCompareFunction,
                (unsigned int *)&Size);
        v23 = packetAttachment->Connections;
        v19 = (v22 - (int)v23) >> 2;
        memcpy(&v23[v19 + 1], &v23[v19], 4 * (packetAttachment->TotalConnections + 0x3FFFFFFF * v19));
      }
      v24 = a6;
      v25 = a5;
      packetAttachment->Connections[v19] = encryption;
      ++packetAttachment->TotalConnections;
      if ( ((int (__cdecl *)(int, int, CONNECTION *))packetAttachment->dword0)(v25, v24, encryption) )
      {
        encryption->state = 2;
        v26 = *(_DWORD *)(v9 + 2);
        LOWORD(buf[0]) = 512;
        *(unsigned int *)((char *)buf + 2) = v26;
        WriteToNetwork(encryption, (const char *)buf, 6u);
      }
      else
      {
        sub_41B7A0(encryption);
      }
    }
  }
}
/* Orphan comments:
0x02 - Encryption Response
*/
// 41AFE8: conditional instruction was optimized away because of 'al.1==0'
// 41AF3C: inconsistent variable size for '^54.2(a6)'

//----- (0041B070) --------------------------------------------------------
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5)
{
  void (__cdecl *v6)(char *, unsigned int, struct CONNECTION *); // eax
  char *v7; // ebp
  int v8; // ecx
  char *v9; // esi
  char *v10; // edi

  v6 = (void (__cdecl *)(char *, unsigned int, struct CONNECTION *))packetAttachment->dword4;
  if ( v6 )
  {
    v7 = buffer;
    v6(buffer, packetLength, encryption);
  }
  else
  {
    packetAttachment->field_34[packetAttachment->SomeCounter].PacketLength = packetLength;
    packetAttachment->field_34[packetAttachment->SomeCounter].encryption = encryption;
    if ( a5 )
    {
      v7 = buffer;
      a5 = 0;
      packetAttachment->field_34[packetAttachment->SomeCounter].LargePacketBuffer = buffer;
    }
    else
    {
      v7 = buffer;
      if ( (unsigned int)packetLength >= 0x80 )
      {
        packetAttachment->field_34[packetAttachment->SomeCounter].LargePacketBuffer = (char *)emalloc(packetLength);
        v8 = packetLength;
        v9 = buffer;
        v10 = packetAttachment->field_34[packetAttachment->SomeCounter].LargePacketBuffer;
      }
      else
      {
        v8 = packetLength;
        v9 = buffer;
        packetAttachment->field_34[packetAttachment->SomeCounter].LargePacketBuffer = 0;
        v10 = packetAttachment->field_34[packetAttachment->SomeCounter].SmallPacketBuffer;
      }
      qmemcpy(v10, v9, v8);
    }
    ++packetAttachment->SomeCounter;
  }
  if ( a5 )
    efree(v7);
}

//----- (0041B1B0) --------------------------------------------------------
char *__thiscall sub_41B1B0(struct PACKET_ATTACHMENT *packetAttachment, int *a2, int *a3)
{
  int v4; // ecx
  __int64 v5; // rax
  DWORD v6; // kr00_4
  int v7; // eax
  int v8; // edi
  __int64 v9; // rax
  DWORD v10; // kr04_4
  int v11; // eax
  int v12; // ebx
  struct CONNECTION *v13; // edi
  int v14; // eax
  char *v15; // eax
  int v16; // ecx
  char *result; // eax
  char *v18; // ecx
  char *v19; // [esp-8h] [ebp-20h]
  unsigned int v20; // [esp-4h] [ebp-1Ch]
  int RemotePort; // [esp+Ch] [ebp-Ch] BYREF
  int RemoteIP; // [esp+10h] [ebp-8h] BYREF
  int RecvLength; // [esp+14h] [ebp-4h] BYREF

  v4 = packetAttachment->dword8C34;
  if ( v4 > 0 && *((_DWORD *)&packetAttachment->recievePacketBuffer + 35 * v4) )
  {
    efree(*((LPVOID *)&packetAttachment->recievePacketBuffer + 35 * v4));
    *((_DWORD *)&packetAttachment->recievePacketBuffer + 35 * packetAttachment->dword8C34) = 0;
  }
  if ( packetAttachment->SomeCounter == packetAttachment->dword8C34 )
  {
    packetAttachment->dword8C34 = 0;
    packetAttachment->SomeCounter = 0;
    v5 = (int)(GetTickCount() / 0xA - packetAttachment->TickCountDividedBy10Two);
    if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 10 )
    {
      v6 = GetTickCount();
      v7 = packetAttachment->TotalConnections;
      v8 = 0;
      packetAttachment->TickCountDividedBy10Two = v6 / 0xA;
      if ( v7 > 0 )
      {
        do
          SendBiDirectionalCorePackets(packetAttachment->Connections[v8++]);
        while ( v8 < packetAttachment->TotalConnections );
      }
    }
    if ( (int)packetAttachment->CommsTransportBufferSizeLimited > 0 )
    {
      v9 = (int)(GetTickCount() / 0xA - packetAttachment->TickCountDividedBy10);
      if ( (int)((HIDWORD(v9) ^ v9) - HIDWORD(v9)) >= 100 )
      {
        v10 = GetTickCount();
        v11 = packetAttachment->TotalConnections;
        v12 = 0;
        packetAttachment->TickCountDividedBy10 = v10 / 0xA;
        if ( v11 > 0 )
        {
          do
          {
            v13 = packetAttachment->Connections[v12];
            v14 = v13->ClusterPacketLength - (_DWORD)v13 - 0xA92;
            if ( v14 > 2 )
            {
              if ( (unsigned __int8)v13->ClusterPacket[2] + 3 == v14 )
              {
                v20 = v13->ClusterPacketLength - (_DWORD)v13 - 0xA95;
                v19 = &v13->ClusterPacket[3];
              }
              else
              {
                v20 = v13->ClusterPacketLength - (_DWORD)v13 - 0xA92;
                v19 = v13->ClusterPacket;
              }
              WriteToNetwork(v13, v19, v20);
              v13->ClusterPacketLength = (int)v13->ClusterPacket;
            }
            ++v12;
          }
          while ( v12 < packetAttachment->TotalConnections );
        }
      }
    }
    v15 = PlayerReadPackets(packetAttachment, &RecvLength, &RemoteIP, &RemotePort);
    if ( v15 )
      PlayerHandlePacket(packetAttachment, v15, RecvLength, RemoteIP, RemotePort);
  }
  v16 = packetAttachment->dword8C34;
  if ( packetAttachment->SomeCounter == v16 )
    return 0;
  v18 = (char *)packetAttachment + 140 * v16;
  result = (char *)*((_DWORD *)v18 + 45);
  if ( !result )
    result = v18 + 52;                          // SmallPacketBuffer
  *a2 = *((_DWORD *)v18 + 46);                  // PacketLength
                                                // 
  *a3 = (int)packetAttachment->field_34[packetAttachment->dword8C34++].encryption;
  return result;
}

//----- (0041B3D0) --------------------------------------------------------
void __thiscall ResetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment)
{
  packetAttachment->TotalPacketSendLength = 0;
  packetAttachment->TotalPacketSendCalls = 0;
  packetAttachment->TotalPacketRecvLength = 0;
  packetAttachment->TotalPacketRecvCalls = 0;
  packetAttachment->TotalPacketClustersCalls = 0;
}

//----- (0041B3F0) --------------------------------------------------------
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls)
{
  *TotalPacketSendLength = packetAttachment->TotalPacketSendLength;
  *TotalPacketRecvLength = packetAttachment->TotalPacketRecvLength;
  *TotalPacketSendCalls = packetAttachment->TotalPacketSendCalls;
  *TotalPacketRecvCalls = packetAttachment->TotalPacketRecvCalls;
  *TotalPacketClustersCalls = packetAttachment->TotalPacketClustersCalls;
}

//----- (0041B430) --------------------------------------------------------
void __thiscall sub_41B430(struct PACKET_ATTACHMENT *packetAttachment, signed int CommsTransportBufferSize)
{
  DWORD v3; // kr00_4
  int v4; // eax
  int v5; // edi
  CONNECTION *v6; // esi
  int v7; // eax
  signed int v8; // eax
  char *v9; // [esp-8h] [ebp-14h]
  unsigned int v10; // [esp-4h] [ebp-10h]

  v3 = GetTickCount();
  v4 = packetAttachment->TotalConnections;
  v5 = 0;
  packetAttachment->TickCountDividedBy10 = v3 / 0xA;
  if ( v4 > 0 )
  {
    do
    {
      v6 = packetAttachment->Connections[v5];
      v7 = v6->ClusterPacketLength - (_DWORD)v6 - 2706;
      if ( v7 > 2 )
      {
        if ( (unsigned __int8)v6->ClusterPacket[2] + 3 == v7 )
        {
          v10 = v6->ClusterPacketLength - (_DWORD)v6 - 2709;
          v9 = &v6->ClusterPacket[3];
        }
        else
        {
          v10 = v6->ClusterPacketLength - (_DWORD)v6 - 2706;
          v9 = v6->ClusterPacket;
        }
        WriteToNetwork(v6, v9, v10);
        v6->ClusterPacketLength = (int)v6->ClusterPacket;
      }
      ++v5;
    }
    while ( v5 < packetAttachment->TotalConnections );
  }
  v8 = CommsTransportBufferSize;
  if ( CommsTransportBufferSize >= 384 )
    v8 = 384;
  packetAttachment->CommsTransportBufferSizeLimited = v8;
}

//----- (0041B4E0) --------------------------------------------------------
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment)
{
  DWORD v2; // kr00_4
  int v3; // eax
  int v4; // edi
  CONNECTION *v5; // esi
  int v6; // eax
  char *v7; // [esp-Ch] [ebp-14h]
  unsigned int v8; // [esp-8h] [ebp-10h]

  v2 = GetTickCount();
  v3 = packetAttachment->TotalConnections;
  v4 = 0;
  packetAttachment->TickCountDividedBy10 = v2 / 0xA;
  if ( v3 > 0 )
  {
    do
    {
      v5 = packetAttachment->Connections[v4];
      v6 = v5->ClusterPacketLength - (_DWORD)v5 - 0xA92;
      if ( v6 > 2 )
      {
        if ( (unsigned __int8)v5->ClusterPacket[2] + 3 == v6 )// Is Cluster Packet?
        {
          v8 = v5->ClusterPacketLength - (_DWORD)v5 - 0xA95;
          v7 = &v5->ClusterPacket[3];
        }
        else
        {
          v8 = v5->ClusterPacketLength - (_DWORD)v5 - 0xA92;
          v7 = v5->ClusterPacket;
        }
        WriteToNetwork(v5, v7, v8);
        v5->ClusterPacketLength = (int)v5->ClusterPacket;
      }
      ++v4;
    }
    while ( v4 < packetAttachment->TotalConnections );
  }
}

//----- (0041B570) --------------------------------------------------------
int __stdcall sub_41B570(int a1)
{
  return 1;
}

//----- (0041B580) --------------------------------------------------------
int __cdecl DifferentCompareFunction(int connection, int ConnectionsArray)
{
  CONNECTION *v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  int v5; // edx

  v2 = *(CONNECTION **)ConnectionsArray;
  v3 = **(_DWORD **)ConnectionsArray;
  if ( *(_DWORD *)connection > v3 )
    return 1;
  if ( *(_DWORD *)connection < v3 )
    return -1;
  v5 = *(_DWORD *)(connection + 6);
  result = *(unsigned __int16 *)(connection + 4) - (unsigned __int16)v2->RemotePort;
  if ( v5 != -1 && !result )
    result = v5 - v2->PlayerId;
  return result;
}

//----- (0041B5D0) --------------------------------------------------------
void __thiscall InitializeEncryption(struct CONNECTION *encryption, struct PACKET_ATTACHMENT *packetAttachment, int a3, int a4, int a5, __int16 a6, signed int ServerKey, int a8, int a9)
{
  signed int v10; // edi
  __int16 *v11; // ebp
  int a6a; // [esp+24h] [ebp+14h]

  v10 = ServerKey;
  encryption->ProtocolVersion = a8;
  encryption->MyPacketAttachment = packetAttachment;
  encryption->state = a3;
  encryption->PlayerId = a4;
  encryption->RemoteIP = a5;
  encryption->RemotePort = a6;
  encryption->dword6 = a9;
  encryption->dwordA = 9999999;
  encryption->SyncResponseLocalTimeStamp = 0;
  encryption->dword12 = 0;
  encryption->dword16 = 0;
  encryption->TotalSyncResponses = 0;
  encryption->dword1E = 0;
  encryption->LowestSyncResponseDelay = 0;
  encryption->HighestSyncResponseDelay = 0;
  encryption->ServerKey = ServerKey;
  v11 = (__int16 *)encryption->SSEncryptionTable;
  a6a = 260;
  do
  {
    v10 = 16807 * (v10 % 127773) - 2836 * (v10 / 127773) + 123;
    if ( v10 <= 0 )
      v10 += 2147483647;
    *v11++ = v10;
    --a6a;
  }
  while ( a6a );
  encryption->KeepAliveDelayTimer = 0;
  encryption->MenuKickOutDelayTimer = GetTickCount() / 0xA;
  encryption->KeepAliveDelayTimer = GetTickCount() / 0xA;
  encryption->SmallChunkPacketSize = 0;
  encryption->SmallChunkPacketBuffer = 0;
  encryption->RatioBytesSent = 0;
  encryption->TotalBytesSentNew = 0;
  encryption->LastTotalBytesSent = 0;
  encryption->LastRatioSendTime = GetTickCount() / 0xA;
  encryption->CurrentReliableMessageACKID = 0;
  encryption->HighestRecievedReliableMessageACKID = 0;
  encryption->ReliablePacketsCurrent = 0;
  encryption->MaxBillerPacketSizeQueue = 0;
  encryption->ReliablePacketsPending = 0;
  memset(encryption->ReliableInPackets, 0, sizeof(encryption->ReliableInPackets));
  memset(encryption->PacketPointers, 0, sizeof(encryption->PacketPointers));
  encryption->ServerToYou = 1000;
  encryption->YouToServer = 1000;
  encryption->TotalPacketsSent = 0;
  encryption->TotalPacketsRecieved = 0;
  encryption->TotalPacketsClientRecieved = 0;
  encryption->TotalPacketsClientSent = 0;
  encryption->ClusterPacketLength = (int)encryption->ClusterPacket;
  memset(encryption->HugeChunk, 0, sizeof(encryption->HugeChunk));
  encryption->TotalHugeChunks = 0;
  encryption->HugeChunkMemory = 0;
  encryption->ASyncC2SEnd = 0;
  encryption->ASyncC2SStart = 0;
}

//----- (0041B7A0) --------------------------------------------------------
void *__thiscall sub_41B7A0(struct CONNECTION *encryption)
{
  int v2; // eax
  int v3; // ebp
  struct HUGE_CHUNK_STRUCT *v4; // esi
  char *v5; // eax
  LPVOID *v6; // esi
  int v7; // ebp
  struct PACKET_ATTACHMENT *v8; // esi
  __int16 v9; // dx
  int v10; // eax
  int v11; // edx
  struct CONNECTION **encryptionResult; // eax
  int v13; // ecx
  struct CONNECTION **v14; // esi
  char *v15; // [esp-8h] [ebp-28h]
  unsigned int v16; // [esp-4h] [ebp-24h]
  char buf[4]; // [esp+10h] [ebp-10h] BYREF
  int ElementToFind; // [esp+14h] [ebp-Ch] BYREF
  __int16 v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ah] [ebp-6h]

  v2 = encryption->ClusterPacketLength - (_DWORD)encryption - 2706;
  if ( v2 > 2 )
  {
    if ( (unsigned __int8)encryption->ClusterPacket[2] + 3 == v2 )// Is Cluster Packet?
    {
      v16 = encryption->ClusterPacketLength - (_DWORD)encryption - 2709;
      v15 = &encryption->ClusterPacket[3];
    }
    else
    {
      v16 = encryption->ClusterPacketLength - (_DWORD)encryption - 2706;
      v15 = encryption->ClusterPacket;
    }
    WriteToNetwork(encryption, v15, v16);
    encryption->ClusterPacketLength = (int)encryption->ClusterPacket;
  }
  if ( encryption->state == 2 )
  {
    buf[0] = 0;
    buf[1] = 7;
    WriteToNetwork(encryption, buf, 2u);
  }
  v3 = 0;
  if ( encryption->TotalHugeChunks > 0 )
  {
    v4 = encryption->HugeChunk;
    do
    {
      if ( v4->field_C )
        efree(v4->PacketBuffer);
      ++v3;
      ++v4;
    }
    while ( v3 < encryption->TotalHugeChunks );
  }
  v5 = encryption->HugeChunkMemory;
  encryption->TotalHugeChunks = 0;
  if ( v5 )
    efree(v5);
  encryption->HugeChunkMemory = 0;
  encryption->ASyncC2SEnd = 0;
  encryption->ASyncC2SStart = 0;
  v6 = (LPVOID *)encryption->ReliableInPackets;
  v7 = 256;
  do
  {
    if ( v6[256] )
    {
      efree(v6[256]);
      v6[256] = 0;
    }
    if ( *v6 )
    {
      efree(*v6);
      *v6 = 0;
    }
    ++v6;
    --v7;
  }
  while ( v7 );
  if ( encryption->SmallChunkPacketBuffer )
  {
    efree(encryption->SmallChunkPacketBuffer);
    encryption->SmallChunkPacketBuffer = 0;
  }
  v8 = encryption->MyPacketAttachment;
  v9 = encryption->RemotePort;
  v10 = encryption->PlayerId;
  ElementToFind = encryption->RemoteIP;
  v19 = v9;
  v11 = v8->TotalConnections;
  v20 = v10;
  encryptionResult = (struct CONNECTION **)BinarySearch(
                                             (int)&ElementToFind,
                                             (unsigned int)v8->Connections,
                                             v11,
                                             4,
                                             DifferentCompareFunction,
                                             (unsigned int *)buf);
  if ( *(_DWORD *)buf )
  {
    v13 = v8->TotalConnections - 1;
    v8->TotalConnections = v13;
    v14 = v8->Connections;
    encryptionResult = (struct CONNECTION **)memcpy(
                                               &v14[encryptionResult - v14],
                                               &v14[encryptionResult - v14 + 1],
                                               4 * (v13 + 0x3FFFFFFF * (encryptionResult - v14)));
  }
  encryption->state = 0;
  return encryptionResult;
}

//----- (0041B950) --------------------------------------------------------
int __thiscall CheckIfBillingServerIsConnected(int this)
{
  return *(_DWORD *)(this + 50);
}

//----- (0041B960) --------------------------------------------------------
int __thiscall GetProtocolVersion(CONNECTION *connection)
{
  return connection->ProtocolVersion;
}

//----- (0041B970) --------------------------------------------------------
// NetworkData.GetRelAckDiff()
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = encryption->MaxBillerPacketSizeQueue;
  return encryption->ReliablePacketsCurrent - encryption->ReliablePacketsPending;
}

//----- (0041B9A0) --------------------------------------------------------
void __thiscall WriteToNetwork(struct CONNECTION *encryption, const char *buf, unsigned int len)
{
  int v4; // edx
  const char *v5; // ebp
  char v6; // al
  char *v7; // ecx
  char *v8; // esi
  int v9; // eax
  int v10; // eax
  char *v11; // ecx
  char *v12; // esi
  int v13; // eax
  int v14; // eax
  DWORD v15; // kr00_4
  int v16; // ecx
  int v17; // eax
  __int64 v18; // rax
  int v19; // ecx
  int v20; // edi
  int v21; // edx
  struct PACKET_ATTACHMENT *v22; // edi
  __int16 v23; // cx
  int v24; // eax
  SOCKET v25; // [esp-24h] [ebp-43Ch]
  char v26; // [esp+7h] [ebp-411h]
  struct sockaddr to; // [esp+8h] [ebp-410h] BYREF
  char buffer[1024]; // [esp+18h] [ebp-400h] BYREF

  if ( encryption->state != 4 )
  {
    v4 = encryption->ServerKey;
    v5 = buf;
    if ( v4 > 0 )
    {
      v26 = *buf;
      if ( *buf || (v6 = buf[1], v6 != 1) && v6 != 2 )
      {
        qmemcpy(buffer, buf, len);
        if ( v26 )
        {
          v11 = &buffer[1];
          v12 = &buffer[4 * ((len + 2) >> 2) + 1];
          if ( &buffer[1] != v12 )
          {
            do
            {
              v13 = *(_DWORD *)v11 ^ *(_DWORD *)&v11[encryption->SSEncryptionTable - &buffer[1]];
              v11 += 4;
              v14 = v4 ^ v13;
              *((_DWORD *)v11 - 1) = v14;
              v4 = v14;
            }
            while ( v11 != v12 );
          }
        }
        else
        {
          v7 = &buffer[2];
          v8 = &buffer[4 * ((len + 1) >> 2) + 2];
          if ( &buffer[2] != v8 )
          {
            do
            {
              v9 = *(_DWORD *)v7 ^ *(_DWORD *)&v7[encryption->SSEncryptionTable - &buffer[2]];
              v7 += 4;
              v10 = v4 ^ v9;
              *((_DWORD *)v7 - 1) = v10;
              v4 = v10;
            }
            while ( v7 != v8 );
          }
        }
        v5 = buffer;
      }
    }
    v15 = GetTickCount();
    v16 = encryption->TotalPacketsSent;
    v17 = encryption->TotalBytesSentNew;
    encryption->KeepAliveDelayTimer = v15 / 0xA;
    encryption->TotalPacketsSent = v16 + 1;
    encryption->TotalBytesSentNew = len + v17;
    v18 = (int)(encryption->LastRatioSendTime - GetTickCount() / 0xA);
    v19 = (HIDWORD(v18) ^ v18) - HIDWORD(v18);
    if ( v19 >= 100 )
    {
      v20 = encryption->TotalBytesSentNew;
      v21 = encryption->LastTotalBytesSent;
      encryption->LastTotalBytesSent = v20;
      encryption->RatioBytesSent = 100 * (v20 - v21) / v19;
      encryption->LastRatioSendTime = GetTickCount() / 0xA;
    }
    v22 = encryption->MyPacketAttachment;
    v23 = encryption->RemotePort;
    *(_DWORD *)&to.sa_data[2] = encryption->RemoteIP;
    v25 = v22->Socket;
    to.sa_family = 2;
    *(_WORD *)to.sa_data = v23;
    sendto(v25, v5, len, 0, &to, 16);
    v24 = v22->TotalPacketSendCalls + 1;
    v22->TotalPacketSendLength += len;
    v22->TotalPacketSendCalls = v24;
  }
}

//----- (0041BB70) --------------------------------------------------------
void __thiscall ProcessCorePackets(struct CONNECTION *encryption, char *buffer, int size, int a5)
{
  int v5; // ecx
  char *v6; // esi
  int v7; // edi
  int v8; // esi
  char *v9; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int i; // esi
  int v22; // eax
  int v23; // ebx
  __int16 v24; // di
  char *v25; // eax
  DWORD v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rax
  int v32; // eax
  int v33; // ecx
  int v34; // ecx
  int v35; // edi
  struct HUGE_CHUNK_STRUCT *v36; // esi
  char *v37; // eax
  int v38; // edi
  struct HUGE_CHUNK_STRUCT *v39; // esi
  char *v40; // eax
  int v41; // ebx
  char *v42; // eax
  int v43; // eax
  char *v44; // ecx
  int v45; // esi
  int v46; // eax
  char *v47; // esi
  char *j; // ebx
  int v49; // edx
  char *v50; // esi
  int v51; // edi
  char *v52; // [esp-Ch] [ebp-28h]
  int v53; // [esp-8h] [ebp-24h]
  char OutBuffer[10]; // [esp+10h] [ebp-Ch] BYREF

  v5 = encryption->state;
  if ( v5 == 4 )
  {
LABEL_12:
    v6 = buffer;
    goto RETURN_FREE_MEMORY;
  }
  v6 = buffer;
  if ( !*buffer )
  {
    v7 = size;
    if ( size <= 1 )
      goto RETURN_FREE_MEMORY;
    switch ( buffer[1] )
    {
      case 2:                                   // 0x02 - Encryption Response
        if ( v5 != 1 )
          goto RETURN_FREE_MEMORY;
        v8 = *(_DWORD *)(buffer + 2);           // Client Encryption Key
        if ( abs32(encryption->ServerKey) == abs32(v8) )
        {
          encryption->ServerKey = v8;
          v9 = encryption->SSEncryptionTable;
          v10 = 260;
          do
          {
            v8 = 16807 * (v8 % 127773) - 2836 * (v8 / 127773) + 123;
            if ( v8 <= 0 )
              v8 += 0x7FFFFFFF;
            *(_WORD *)v9 = v8;
            v9 += 2;
            --v10;
          }
          while ( v10 );
          encryption->state = 2;
        }
        goto LABEL_12;
      case 3:                                   // 0x03 - Reliable Message
        if ( (unsigned int)size < 6 )
          goto RETURN_FREE_MEMORY;
        v16 = *(_DWORD *)(buffer + 2);
        OutBuffer[0] = 0;
        OutBuffer[1] = 4;                       // 0x04 - Reliable ACK
        *(_DWORD *)&OutBuffer[2] = v16;         // ACK ID
        SendPacketCluster(encryption, OutBuffer, 6u);
        v17 = *(_DWORD *)(buffer + 2);
        if ( v17 > encryption->HighestRecievedReliableMessageACKID )
          encryption->HighestRecievedReliableMessageACKID = v17;
        v18 = *(_DWORD *)(buffer + 2);
        v19 = encryption->CurrentReliableMessageACKID;
        if ( v19 > v18 )
          goto RETURN_FREE_MEMORY;
        if ( v19 == v18 )
        {
          ProcessCorePackets(encryption, buffer + 6, v7 - 6, 0);
          v20 = encryption->CurrentReliableMessageACKID + 1;
          encryption->CurrentReliableMessageACKID = v20;
          for ( i = ((v20 >> 31) ^ (unsigned __int8)abs32(v20)) - (v20 >> 31);
                encryption->ReliableInPackets[i];
                i = ((v22 >> 31) ^ (unsigned __int8)abs32(v22)) - (v22 >> 31) )
          {
            ProcessCorePackets(
              encryption,
              encryption->ReliableInPackets[i] + 2,
              *(__int16 *)encryption->ReliableInPackets[i],
              0);
            efree(encryption->ReliableInPackets[i]);
            encryption->ReliableInPackets[i] = 0;
            v22 = encryption->CurrentReliableMessageACKID + 1;
            encryption->CurrentReliableMessageACKID = v22;
          }
        }
        else
        {
          v23 = ((v18 >> 31) ^ (unsigned __int8)abs32(v18)) - (v18 >> 31);
          if ( !encryption->ReliableInPackets[v23] )
          {
            v24 = v7 - 6;
            v25 = (char *)emalloc(v24 + 2);
            encryption->ReliableInPackets[v23] = v25;
            *(_WORD *)v25 = v24;
            qmemcpy(encryption->ReliableInPackets[v23] + 2, buffer + 6, v24);
          }
        }
        goto LABEL_12;
      case 4:                                   // 0x04 - Reliable ACK
        if ( (unsigned int)size < 6 )
          goto RETURN_FREE_MEMORY;
        v11 = *(_DWORD *)(buffer + 2);
        if ( encryption->ReliablePacketsPending > v11 || v11 >= encryption->ReliablePacketsCurrent )
          goto RETURN_FREE_MEMORY;
        v12 = ((v11 >> 31) ^ (unsigned __int8)abs32(v11)) - (v11 >> 31);
        v13 = encryption->PacketPointers[v12];
        if ( v13 )
        {
          encryption->MaxBillerPacketSizeQueue -= *(__int16 *)(v13 + 4);
          efree((LPVOID)encryption->PacketPointers[v12]);
          encryption->PacketPointers[v12] = 0;
          v14 = encryption->ReliablePacketsCurrent;
          if ( encryption->ReliablePacketsPending < v14 )
          {
            do
            {
              v15 = encryption->ReliablePacketsPending;
              if ( encryption->PacketPointers[((v15 >> 31) ^ (unsigned __int8)abs32(v15)) - (v15 >> 31)] )
                break;
              encryption->ReliablePacketsPending = v15 + 1;
            }
            while ( v15 + 1 < v14 );
          }
        }
        goto LABEL_12;
      case 5:                                   // 0x05 - Sync Request To Sync Time
        v32 = *(_DWORD *)(buffer + 2);
        OutBuffer[0] = 0;
        OutBuffer[1] = 6;                       // 0x06 - Sync Response
        *(_DWORD *)&OutBuffer[2] = v32;         // Received Timestamp
        *(_DWORD *)&OutBuffer[6] = GetTickCount() / 0xA;// Local Timestamp
        WriteToNetwork(encryption, OutBuffer, 0xAu);
        encryption->TotalPacketsClientRecieved = *(_DWORD *)(buffer + 6);// most likely means TotalPacketsRecieved Something
        encryption->TotalPacketsClientSent = *(_DWORD *)(buffer + 10);// most likely means TotalPacketsSent Something
        if ( v7 > 6 )
        {
          v33 = encryption->TotalPacketsSent;
          if ( v33 <= 300 )
            encryption->ServerToYou = 1000;
          else
            encryption->ServerToYou = 1000 * *(_DWORD *)(buffer + 10) / v33;
          v34 = *(_DWORD *)(buffer + 6);
          if ( v34 <= 300 )
            encryption->YouToServer = 1000;
          else
            encryption->YouToServer = 1000 * encryption->TotalPacketsRecieved / v34;
        }
        goto RETURN_FREE_MEMORY;
      case 6:                                   // 0x06 - Sync Response
        v26 = GetTickCount() / 0xA;
        v27 = encryption->dword1E;
        v28 = v26 - *(_DWORD *)(buffer + 2);    // Received Timestamp
        ++encryption->TotalSyncResponses;
        v29 = encryption->LowestSyncResponseDelay;
        encryption->dword1E = v28 + v27;
        if ( !v29 || v28 < v29 )
          encryption->LowestSyncResponseDelay = v28;
        if ( v28 > encryption->HighestSyncResponseDelay )
          encryption->HighestSyncResponseDelay = v28;
        if ( v28 <= encryption->dwordA + 1
          || (v30 = (int)(GetTickCount() / 0xA - encryption->dword16), (int)((HIDWORD(v30) ^ v30) - HIDWORD(v30)) > 12000) )
        {
          if ( v28 < 2 * encryption->dwordA
            || (v31 = (int)(GetTickCount() / 0xA - encryption->dword16),
                (int)((HIDWORD(v31) ^ v31) - HIDWORD(v31)) > 60000) )
          {
            encryption->SyncResponseLocalTimeStamp = *(_DWORD *)(buffer + 6)// Local Timestamp
                                                   + v28 * (1000 - encryption->MyPacketAttachment->dword24) / 1000
                                                   - v26;
            encryption->dword16 = GetTickCount() / 0xA;
            encryption->dwordA = v28;
          }
        }
        goto LABEL_12;
      case 7:                                   // 0x07 - Order to Disconnect
        goto LABEL_78;
      case 8:                                   // 0x08 - Small Chunk Body
      case 9:                                   // 0x09 - Small Chunk Tail
        v41 = encryption->SmallChunkPacketSize;
        v53 = size + v41 - 2;
        v52 = encryption->SmallChunkPacketBuffer;
        encryption->SmallChunkPacketSize = v53;
        v42 = ExpandMemory(v52, v53, 1);
        encryption->SmallChunkPacketBuffer = v42;
        qmemcpy(&v42[v41], buffer + 2, v7 - 2);
        if ( buffer[1] == 9 )                   // tail detected only
        {
          ProcessCorePackets(encryption, encryption->SmallChunkPacketBuffer, encryption->SmallChunkPacketSize, 1);
          encryption->SmallChunkPacketBuffer = 0;
          encryption->SmallChunkPacketSize = 0;
        }
        goto LABEL_12;
      case 10:                                  // 0x0A - HUGE Chunk
        if ( (unsigned int)size < 6 )
          goto RETURN_FREE_MEMORY;
        v43 = *(_DWORD *)(buffer + 2);
        if ( v43 < 0 || v43 >= 20971520 )       // 20 Megabytes (if it's in bytes)
        {
LABEL_78:
          encryption->state = 4;
          goto RETURN_FREE_MEMORY;
        }
        v44 = encryption->HugeChunkMemory;
        encryption->ASyncC2SEnd = v43;
        if ( !v44 )
        {
          encryption->HugeChunkMemory = (char *)emalloc(v43);
          encryption->ASyncC2SStart = 0;
        }
        qmemcpy(&encryption->HugeChunkMemory[encryption->ASyncC2SStart], buffer + 6, v7 - 6);
        v45 = v7 - 6 + encryption->ASyncC2SStart;
        v46 = encryption->ASyncC2SEnd;
        encryption->ASyncC2SStart = v45;
        if ( v45 == v46 )
        {
          ProcessCorePackets(encryption, encryption->HugeChunkMemory, v46, 1);
          encryption->ASyncC2SStart = 0;
          encryption->ASyncC2SEnd = 0;
          encryption->HugeChunkMemory = 0;
        }
        break;
      case 11:                                  // 0x0B - Cancel Huge Chunk
        v35 = 0;
        if ( encryption->TotalHugeChunks > 0 )
        {
          v36 = encryption->HugeChunk;
          do
          {
            if ( v36->field_C )
              efree(v36->PacketBuffer);
            ++v35;
            ++v36;
          }
          while ( v35 < encryption->TotalHugeChunks );
          v6 = buffer;
        }
        v37 = encryption->HugeChunkMemory;
        encryption->TotalHugeChunks = 0;
        if ( v37 )
          efree(v37);
        encryption->HugeChunkMemory = 0;
        encryption->ASyncC2SEnd = 0;
        encryption->ASyncC2SStart = 0;
        LOWORD(size) = 3072;
        WriteData(encryption, &size, 2u, 1);
        goto RETURN_FREE_MEMORY;
      case 12:                                  // 0x0C - Cancel Huge Chunk ACK
        v38 = 0;
        if ( encryption->TotalHugeChunks > 0 )
        {
          v39 = encryption->HugeChunk;
          do
          {
            if ( v39->field_C )
              efree(v39->PacketBuffer);
            ++v38;
            ++v39;
          }
          while ( v38 < encryption->TotalHugeChunks );
          v6 = buffer;
        }
        v40 = encryption->HugeChunkMemory;
        encryption->TotalHugeChunks = 0;
        if ( v40 )
          efree(v40);
        encryption->HugeChunkMemory = 0;
        encryption->ASyncC2SEnd = 0;
        encryption->ASyncC2SStart = 0;
        goto RETURN_FREE_MEMORY;
      case 14:                                  // 0x0E - Packet Cluster
        v47 = buffer + 2;
        for ( j = &buffer[size]; v47 < j; v47 = &v50[v51] )
        {
          v49 = (unsigned __int8)*v47;
          v50 = v47 + 1;
          v51 = v49;
          ProcessCorePackets(encryption, v50, v49, 0);
        }
        goto LABEL_12;
      default:
        goto RETURN_FREE_MEMORY;
    }
    goto LABEL_12;
  }
  ProcessRegularPackets(encryption->MyPacketAttachment, buffer, size, encryption, a5);
  a5 = 0;
RETURN_FREE_MEMORY:
  if ( a5 )
    efree(v6);
}

//----- (0041C2B0) --------------------------------------------------------
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // edx
  __int64 v5; // rax
  int v6; // eax
  DWORD v7; // kr00_4
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ebx
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  signed int v15; // ebx
  DWORD v16; // esi
  unsigned __int8 *v17; // ecx
  signed int v18; // edi
  int v19; // ebx
  int i; // edi
  unsigned __int8 *v21; // ecx
  char buffer1[14]; // [esp+10h] [ebp-210h] BYREF
  _WORD buffer2[256]; // [esp+20h] [ebp-200h] BYREF

  v2 = connection->state;
  if ( v2 == 1 )
  {
    v3 = (int)(GetTickCount() / 0xA - connection->KeepAliveDelayTimer);
    if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 100 )
    {
      v4 = connection->ServerKey;
      buffer1[0] = 0;                           // BI : Bi-directional Core Packets
      buffer1[1] = 1;                           // 0x01 - Encryption Request
      *(_DWORD *)&buffer1[2] = v4;              // Client Encryption Key
      *(_WORD *)&buffer1[6] = 1;                // Client Version/Type
      WriteToNetwork(connection, buffer1, 8u);
    }
  }
  else if ( v2 == 2 )
  {
    if ( connection->dword6 )
    {
      if ( (v5 = (int)(GetTickCount() / 0xA - connection->dword12), v6 = (HIDWORD(v5) ^ v5) - HIDWORD(v5), v6 > 2000)
        || v6 > 500 && (int)connection->dwordA > 300
        || v6 > 50 && (int)connection->dwordA > 1000 )
      {
        connection->dword12 = GetTickCount() / 0xA;
        buffer1[0] = 0;                         // BI : Bi-directional Core Packets
        buffer1[1] = 5;                         // 0x05 - Sync Request To Sync Time
        v7 = GetTickCount();
        v8 = connection->TotalPacketsRecieved;
        *(_DWORD *)&buffer1[2] = v7 / 0xA;      // Timestamp
        *(_DWORD *)&buffer1[6] = connection->TotalPacketsSent + 1;// Total Packets Sent
        *(_DWORD *)&buffer1[10] = v8;           // Total Packets Received
        WriteToNetwork(connection, buffer1, 14u);
      }
    }
    while ( connection->TotalHugeChunks > 0 )
    {
      v9 = connection->MaxBillerPacketSizeQueue;
      if ( v9 >= 2048
        || connection->ReliablePacketsCurrent - connection->ReliablePacketsPending >= 128
        || connection->HugeChunk[0].field_10 && v9 > 256 )
      {
        break;
      }
      v10 = connection->HugeChunk[0].SentLength;
      *(_DWORD *)&buffer2[1] = connection->HugeChunk[0].TotalLength;// Total Length (guess, since it's a biller packet)
      buffer2[0] = 2560;                        // BI : Bi-directional Core Packets (guess, since it's biller packet)
      v11 = 480;
      if ( *(_DWORD *)&buffer2[1] - v10 <= 480 )
        v11 = *(_DWORD *)&buffer2[1] - v10;
      qmemcpy(&buffer2[3], &connection->HugeChunk[0].PacketBuffer[connection->HugeChunk[0].SentLength], v11);
      WriteData(connection, buffer2, v11 + 6, 1);
      v12 = connection->HugeChunk[0].TotalLength;
      v13 = v11 + connection->HugeChunk[0].SentLength;
      connection->HugeChunk[0].SentLength = v13;
      if ( v13 == v12 )
      {
        if ( connection->HugeChunk[0].field_C )
          efree(connection->HugeChunk[0].PacketBuffer);
        v14 = connection->TotalHugeChunks - 1;
        connection->TotalHugeChunks = v14;
        memcpy(connection->HugeChunk, &connection->HugeChunk[1], 20 * v14);
      }
    }
    if ( connection->ReliablePacketsPending < connection->ReliablePacketsCurrent )
    {
      *(_DWORD *)buffer1 = 0;
      v15 = 90;
      v16 = GetTickCount() / 0xA;
      v17 = (unsigned __int8 *)connection->PacketPointers[((connection->ReliablePacketsPending >> 31) ^ (unsigned __int8)abs32(connection->ReliablePacketsPending))
                                                        - (connection->ReliablePacketsPending >> 31)];
      v18 = *((__int16 *)v17 + 2);
      if ( v18 > 256 )
        v15 = 170;
      if ( (int)abs32(v16 - *(_DWORD *)v17) <= v15 )
      {
        v19 = *(_DWORD *)buffer1;
      }
      else
      {
        *(_DWORD *)v17 = v16;
        SendPacketCluster(connection, v17 + 6, v18);
        v19 = 1;
      }
      for ( i = connection->ReliablePacketsPending + 1; i < connection->ReliablePacketsCurrent; ++i )
      {
        if ( v19 >= 3 )
          break;
        v21 = (unsigned __int8 *)connection->PacketPointers[((i >> 31) ^ (unsigned __int8)abs32(i)) - (i >> 31)];
        if ( v21 )
        {
          if ( (int)abs32(v16 - *(_DWORD *)v21) > 200 )
          {
            *(_DWORD *)v21 = v16;
            SendPacketCluster(connection, v21 + 6, *((__int16 *)v21 + 2));
          }
          ++v19;
        }
      }
    }
  }
}
/* Orphan comments:
0x0A - HUGE Chunk (guess, since it's biller packet)
*/

//----- (0041C5E0) --------------------------------------------------------
// NetworkData.WriteData()
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4)
{
  unsigned int v4; // edi
  signed int v6; // esi
  unsigned int v7; // ebp
  int v9; // esi
  DWORD *v10; // eax
  DWORD *v11; // ebp
  DWORD v12; // edx
  _WORD *v13; // ebp
  char *v14; // ebp
  int v15; // edx
  signed int i; // [esp+10h] [ebp-1FCh]
  unsigned int v17; // [esp+10h] [ebp-1FCh]
  BOOL v18; // [esp+14h] [ebp-1F8h]
  char v19[500]; // [esp+18h] [ebp-1F4h] BYREF

  v4 = len;
  if ( (int)len > 496 )
  {
    v6 = 0;
    for ( i = 0; ; v6 = i )
    {
      v7 = v4 - v6;
      if ( (int)(v4 - v6) >= 480 )
        v7 = 480;
      v19[1] = (v7 == v4 - v6) + 8;
      v19[0] = 0;
      qmemcpy(&v19[2], (char *)buf + v6, v7);
      if ( !WriteData(encryptionn, v19, v7 + 2, 1) )
        break;
      i += v7;
      if ( i >= (int)len )
        return 1;
      v4 = len;
    }
    return 0;
  }
  if ( a4 )
  {
    if ( encryptionn->ReliablePacketsCurrent - encryptionn->ReliablePacketsPending >= 255 )
      return 0;
    v18 = encryptionn->MaxBillerPacketSizeQueue < 4096;
    v17 = len + 6;
    v9 = ((encryptionn->ReliablePacketsCurrent >> 31) ^ (unsigned __int8)abs32(encryptionn->ReliablePacketsCurrent))
       - (encryptionn->ReliablePacketsCurrent >> 31);
    v10 = (DWORD *)emalloc(len + 12);
    encryptionn->PacketPointers[v9] = (int)v10;
    v11 = v10;
    if ( v18 )
      v12 = GetTickCount() / 0xA;
    else
      v12 = 0;
    *v11 = v12;
    v13 = v11 + 1;
    *v13 = v17;
    v14 = (char *)(v13 + 1);
    *v14 = 0;
    v14[1] = 3;
    *(_DWORD *)(v14 + 2) = encryptionn->ReliablePacketsCurrent;
    qmemcpy(v14 + 6, buf, len);
    v15 = encryptionn->ReliablePacketsCurrent + 1;
    encryptionn->MaxBillerPacketSizeQueue += v17;
    encryptionn->ReliablePacketsCurrent = v15;
    if ( v18 )
      SendPacketCluster(encryptionn, v14, v17);
  }
  else
  {
    SendPacketCluster(encryptionn, buf, len);
  }
  return 1;
}
/* Orphan comments:
Very crazy if statement after the OR hard to understand, could run code and still return?
*/
// 41C607: conditional instruction was optimized away because of '%len.4>=1F1'

//----- (0041C7C0) --------------------------------------------------------
// Player.LogReliablePackets()
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename)
{
  struct CONNECTION *encryptionn; // edi
  FILE *v3; // ebx
  int i; // ebp
  int v5; // esi
  int v6; // edi
  unsigned __int8 *v7; // esi

  encryptionn = encryption;
  v3 = fopen(Filename, "wt");
  if ( v3 )
  {
    for ( i = encryptionn->ReliablePacketsPending; i < encryptionn->ReliablePacketsCurrent; ++i )
    {
      v5 = encryptionn->PacketPointers[((i >> 31) ^ (unsigned __int8)abs32(i)) - (i >> 31)];
      if ( v5 )
      {
        v6 = *(__int16 *)(v5 + 4);
        fprintf(v3, "%10d %4d: ", *(_DWORD *)v5, v6);
        v7 = (unsigned __int8 *)(v5 + 6);
        if ( v6 > 0 )
        {
          do
          {
            fprintf(v3, "%02x ", *v7++);
            --v6;
          }
          while ( v6 );
        }
        fprintf(v3, "\n");
        encryptionn = encryption;
      }
      else
      {
        fprintf(v3, "Acknowledged\n");
      }
    }
    fclose(v3);
  }
}

//----- (0041C890) --------------------------------------------------------
void __thiscall GetNewsRequest(struct CONNECTION *encryption, char *MemoryPointer, int a3, int a4)
{
  int v4; // eax

  v4 = encryption->TotalHugeChunks;
  if ( v4 < 4 )
  {
    encryption->HugeChunk[v4].PacketBuffer = MemoryPointer;
    encryption->HugeChunk[encryption->TotalHugeChunks].TotalLength = a3;
    encryption->HugeChunk[encryption->TotalHugeChunks].SentLength = 0;
    encryption->HugeChunk[encryption->TotalHugeChunks].field_C = 1;
    encryption->HugeChunk[encryption->TotalHugeChunks++].field_10 = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041C920) --------------------------------------------------------
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4)
{
  int v4; // eax

  v4 = encryption->TotalHugeChunks;
  if ( v4 < 4 )
  {
    encryption->HugeChunk[v4].PacketBuffer = a2;
    encryption->HugeChunk[encryption->TotalHugeChunks].TotalLength = a3;
    encryption->HugeChunk[encryption->TotalHugeChunks].SentLength = 0;
    encryption->HugeChunk[encryption->TotalHugeChunks].field_C = 0;
    encryption->HugeChunk[encryption->TotalHugeChunks++].field_10 = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041C9B0) --------------------------------------------------------
void __thiscall GetASyncC2SInfoSomething(struct CONNECTION *encryption, int ASyncC2SEnd, int ASyncC2SStart)
{
  *(_DWORD *)ASyncC2SEnd = encryption->ASyncC2SEnd;
  *(_DWORD *)ASyncC2SStart = encryption->ASyncC2SStart;
}

//----- (0041C9D0) --------------------------------------------------------
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart)
{
  if ( encryption->TotalHugeChunks <= 0 )
  {
    *(_DWORD *)ASyncS2CEnd = 0;
    *(_DWORD *)ASyncS2CStart = 0;
  }
  else
  {
    *(_DWORD *)ASyncS2CEnd = encryption->HugeChunk[0].TotalLength;
    *(_DWORD *)ASyncS2CStart = encryption->HugeChunk[0].SentLength;
  }
}

//----- (0041CA10) --------------------------------------------------------
int __thiscall sub_41CA10(struct CONNECTION *encryptionPointer)
{
  return encryptionPointer->TotalHugeChunks;
}

//----- (0041CA20) --------------------------------------------------------
// NetworkData.something()
void __thiscall SendPacketCluster(struct CONNECTION *encryptionn, const void *buf, unsigned int len)
{
  signed int v4; // ecx
  int v5; // eax
  _BYTE *v6; // ecx
  void *v7; // ecx
  char *v8; // [esp-8h] [ebp-18h]
  unsigned int v9; // [esp-4h] [ebp-14h]

  if ( (int)len > 255 || (v4 = encryptionn->MyPacketAttachment->CommsTransportBufferSizeLimited, (int)(len + 3) > v4) )
  {
    WriteToNetwork(encryptionn, (const char *)buf, len);
  }
  else
  {
    v5 = encryptionn->ClusterPacketLength - (_DWORD)encryptionn - 0xA92;
    if ( (int)(v5 + len + 1) > v4 )
    {
      if ( v5 > 2 && (unsigned __int8)encryptionn->ClusterPacket[2] + 3 == v5 )
      {
        v9 = encryptionn->ClusterPacketLength - (_DWORD)encryptionn - 0xA95;
        v8 = &encryptionn->ClusterPacket[3];
      }
      else
      {
        v9 = encryptionn->ClusterPacketLength - (_DWORD)encryptionn - 0xA92;
        v8 = encryptionn->ClusterPacket;
      }
      WriteToNetwork(encryptionn, v8, v9);
      v5 = 0;
      encryptionn->ClusterPacketLength = (int)encryptionn->ClusterPacket;
    }
    if ( v5 )
    {
      ++encryptionn->MyPacketAttachment->TotalPacketClustersCalls;
    }
    else
    {
      *(_BYTE *)encryptionn->ClusterPacketLength = 0;
      v6 = (_BYTE *)(encryptionn->ClusterPacketLength + 1);
      encryptionn->ClusterPacketLength = (int)v6;
      *v6 = 14;
      ++encryptionn->ClusterPacketLength;
    }
    *(_BYTE *)encryptionn->ClusterPacketLength = len;
    v7 = (void *)(encryptionn->ClusterPacketLength + 1);
    encryptionn->ClusterPacketLength = (int)v7;
    qmemcpy(v7, buf, len);
    encryptionn->ClusterPacketLength += len;
  }
}

//----- (0041CB20) --------------------------------------------------------
void __thiscall sub_41CB20(CONNECTION *encryption)
{
  int v2; // eax
  char *Buffer; // [esp-8h] [ebp-Ch]
  unsigned int PacketLength; // [esp-4h] [ebp-8h]

  v2 = encryption->ClusterPacketLength - (_DWORD)encryption - 0xA92;
  if ( v2 > 2 )
  {
    if ( (unsigned __int8)encryption->ClusterPacket[2] + 3 == v2 )
    {
      PacketLength = encryption->ClusterPacketLength - (_DWORD)encryption - 0xA95;
      Buffer = &encryption->ClusterPacket[3];
    }
    else
    {
      PacketLength = encryption->ClusterPacketLength - (_DWORD)encryption - 0xA92;
      Buffer = encryption->ClusterPacket;
    }
    WriteToNetwork(encryption, Buffer, PacketLength);
    encryption->ClusterPacketLength = (int)encryption->ClusterPacket;
  }
}

//----- (0041CB70) --------------------------------------------------------
void __thiscall GetPingLOSSSomething(CONNECTION *encryptionPointer, int *ServerToYou, int *YouToServer)
{
  *ServerToYou = encryptionPointer->ServerToYou;
  *YouToServer = encryptionPointer->YouToServer;
}

//----- (0041CB90) --------------------------------------------------------
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a2 = this->TotalPacketsSent;
  *(_DWORD *)a3 = this->TotalPacketsRecieved;
  *(_DWORD *)a4 = this->TotalPacketsClientRecieved;
  *(_DWORD *)a5 = this->TotalPacketsClientSent;
}

//----- (0041CBD0) --------------------------------------------------------
void __thiscall OrderDisconnect(struct CONNECTION *encryption)
{
  encryption->state = 4;
}

//----- (0041CBE0) --------------------------------------------------------
char *__cdecl GetIPAddressString(struct in_addr in)
{
  return inet_ntoa(in);
}

//----- (0041CBF0) --------------------------------------------------------
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename)
{
  char *v2; // eax
  int OutSize; // [esp+0h] [ebp-4h] BYREF

  OutSize = this;
  v2 = CompressFile(Filename, &OutSize, (int *)&Filename, 0, 0, 0, 0);
  if ( v2 )
    efree(v2);
  return (int)Filename;
}
// 41CBF0: inconsistent function type and number of purged bytes

//----- (0041CC30) --------------------------------------------------------
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize)
{
  FILE *v7; // eax
  FILE *v8; // edi
  char *result; // eax
  int v10; // eax
  size_t v11; // ebx
  char *v12; // esi
  char *v13; // edi
  char *v14; // eax
  char *v15; // ebp
  char *ptra; // [esp+18h] [ebp+Ch]

  v7 = fopen(Filename, "rb");
  v8 = v7;
  if ( v7 )
  {
    v10 = _fileno(v7);
    v11 = _filelength(v10);
    v12 = (char *)emalloc(v11);
    fread(v12, v11, 1u, v8);
    fclose(v8);
    if ( FileSize )
      *(_DWORD *)FileSize = v11;
    if ( CRC_32 )
      *CRC_32 = CRC32(v12, v11);
    if ( DoFileCompression )
    {
      FileSize = (int)(4 * v11) / 3 + 12;
      v13 = ExpandMemory(0, FileSize, 1);
      if ( compress(v13, &FileSize, v12, v11) )
      {
        efree(v13);
        ptra = 0;
      }
      else
      {
        v14 = ExpandMemory(v13, FileSize, 1);
        Filename = (const char *)FileSize;
        ptra = v14;
      }
      *OutSize = (int)&Filename[bytes];
      v15 = (char *)emalloc((int)&Filename[bytes]);
      if ( Buffer )
        qmemcpy(v15, Buffer, bytes);
      qmemcpy(&v15[bytes], ptra, (unsigned int)Filename);
      efree(ptra);
    }
    else
    {
      *OutSize = v11 + bytes;
      v15 = (char *)emalloc(v11 + bytes);
      if ( Buffer )
        qmemcpy(v15, Buffer, bytes);
      qmemcpy(&v15[bytes], v12, v11);
    }
    efree(v12);
    result = v15;
  }
  else
  {
    if ( CRC_32 )
      *CRC_32 = 0;
    if ( FileSize )
      *(_DWORD *)FileSize = 0;
    *OutSize = bytes;
    result = (char *)emalloc(bytes);
    if ( Buffer )
      qmemcpy(result, Buffer, bytes);
  }
  return result;
}
// 41CE30: using guessed type int __stdcall compress(_DWORD, _DWORD, _DWORD, _DWORD);
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (0041CEA0) --------------------------------------------------------
void __cdecl setRNGSeed(int SeedRNG)
{
  RNGSeed = SeedRNG;
}
// 42E458: using guessed type int RNGSeed;

//----- (0041E940) --------------------------------------------------------
int __cdecl RunCommandPrompt(char *argumentsPointer)
{
  int result; // eax
  char *v2; // eax
  int arguments[4]; // [esp+0h] [ebp-10h] BYREF

  result = (int)getenv(MEMORY[0x429050]);
  arguments[0] = result;
  if ( argumentsPointer )
  {
    arguments[1] = (int)"/c";
    arguments[2] = (int)argumentsPointer;
    arguments[3] = 0;
    if ( !result
      || (result = _spawnve(0, (char *)result, (int)arguments, 0), result == -1)
      && (dword_4D8B38 == 2 || dword_4D8B38 == 13) )// _P_WAIT 
    {
      v2 = "command.com";
      if ( (dword_4D8B44 & 0x8000) == 0 )       // Byte 2
        v2 = "cmd.exe";
      arguments[0] = (int)v2;
      result = _spawnvpe(0, v2, (int)arguments, 0);// _P_WAIT
    }
  }
  else if ( result )
  {
    result = _access((LPCSTR)result, 0) == 0;
  }
  return result;
}
// 4D8B38: using guessed type int dword_4D8B38;
// 4D8B44: using guessed type int dword_4D8B44;

//----- (004210C9) --------------------------------------------------------
int __usercall sub_4210C9@<eax>(int a1@<ebp>)
{
  return ExFilterRethrow(*(struct _EXCEPTION_POINTERS **)(a1 - 20));
}

//----- (004210D6) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_4210D6@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 44) = 0;
  _local_unwind2(a1 - 16, -1);
  return 0;
}
// 4210FD: positive sp value C has been found
// 4210D6: could not find valid save-restore pair for ebx
// 4210D6: could not find valid save-restore pair for edi
// 4210D6: could not find valid save-restore pair for esi
// 41DEC2: using guessed type _DWORD __cdecl _local_unwind2(_DWORD, _DWORD);

//----- (00421101) --------------------------------------------------------
int __cdecl sub_421101()
{
  return sub_42110A();
}
// 42110A: using guessed type int sub_42110A(void);

//----- (004214B0) --------------------------------------------------------
void __usercall __noreturn sub_4214B0(int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  int *v7; // [esp+0h] [ebp-18h]
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // [esp+8h] [ebp-10h]
  int (__cdecl *v9)(int, PVOID, int); // [esp+Ch] [ebp-Ch]
  int *v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]

  v10 = dword_429128;
  v9 = unknown_libname_6;
  v8 = NtCurrentTeb()->NtTib.ExceptionList;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  v7 = &v4;
  v11 = 0;
  if ( dword_4D8BDC )
  {
    v11 = 1;
    dword_4D8BDC(v4, v5, v6, v7);
    v11 = 0;
  }
  v11 = -1;
  j__abort();
}
// 429128: using guessed type int[2];
// 4D8BDC: using guessed type int (__cdecl *dword_4D8BDC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00421540) --------------------------------------------------------
void __usercall __noreturn sub_421540(int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  int *v7; // [esp+0h] [ebp-18h]
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // [esp+8h] [ebp-10h]
  int (__cdecl *v9)(int, PVOID, int); // [esp+Ch] [ebp-Ch]
  int *v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]

  v10 = dword_429140;
  v9 = unknown_libname_6;
  v8 = NtCurrentTeb()->NtTib.ExceptionList;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  v7 = &v4;
  v11 = 0;
  if ( off_42E734 )
  {
    v11 = 1;
    off_42E734(v4, v5, v6, v7);
  }
  v11 = -1;
  sub_4215AE(v4, v5, v6, v7);
}
// 4215AE: using guessed type int __cdecl sub_4215AE(_DWORD, _DWORD, _DWORD, _DWORD);
// 429140: using guessed type int[2];

//----- (00423390) --------------------------------------------------------
BOOL __cdecl DateFunction(int a1)
{
  BOOL result; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp-28h] [ebp-30h]
  int v6; // [esp-24h] [ebp-2Ch]
  int v7; // [esp-20h] [ebp-28h]
  int v8; // [esp-1Ch] [ebp-24h]
  int v9; // [esp-18h] [ebp-20h]
  int v10; // [esp-14h] [ebp-1Ch]

  if ( !dword_43099C )
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 != dword_430A30 || v2 != dword_430A40 )
  {
    if ( dword_4D8C18 )
    {
      if ( TimeZoneInformation.DaylightDate.wYear )
      {
        v10 = TimeZoneInformation.DaylightDate.wDay;
        v9 = 0;
        v8 = 0;
        v7 = TimeZoneInformation.DaylightDate.wMonth;
        v6 = *(_DWORD *)(a1 + 20);
        v5 = 0;
      }
      else
      {
        v10 = 0;
        v9 = TimeZoneInformation.DaylightDate.wDayOfWeek;
        v8 = TimeZoneInformation.DaylightDate.wDay;
        v7 = TimeZoneInformation.DaylightDate.wMonth;
        v6 = *(_DWORD *)(a1 + 20);
        v5 = 1;
      }
      cvtdate(
        1,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        TimeZoneInformation.DaylightDate.wHour,
        TimeZoneInformation.DaylightDate.wMinute,
        TimeZoneInformation.DaylightDate.wSecond,
        TimeZoneInformation.DaylightDate.wMilliseconds);
      if ( TimeZoneInformation.StandardDate.wYear )
        cvtdate(
          0,
          0,
          *(_DWORD *)(a1 + 20),
          TimeZoneInformation.StandardDate.wMonth,
          0,
          0,
          TimeZoneInformation.StandardDate.wDay,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
      else
        cvtdate(
          0,
          1,
          *(_DWORD *)(a1 + 20),
          TimeZoneInformation.StandardDate.wMonth,
          TimeZoneInformation.StandardDate.wDay,
          TimeZoneInformation.StandardDate.wDayOfWeek,
          0,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate(0, 1, *(_DWORD *)(a1 + 20), 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = *(_DWORD *)(a1 + 28);
  if ( dword_430A34 < dword_430A44 )
  {
    if ( v3 >= dword_430A34 && v3 <= dword_430A44 )
    {
      if ( v3 > dword_430A34 && v3 < dword_430A44 )
        return 1;
      goto LABEL_25;
    }
    return 0;
  }
  if ( v3 < dword_430A44 || v3 > dword_430A34 )
    return 1;
  if ( v3 > dword_430A44 && v3 < dword_430A34 )
    return 0;
LABEL_25:
  v4 = 1000 * (*(_DWORD *)a1 + 60 * (*(_DWORD *)(a1 + 4) + 60 * *(_DWORD *)(a1 + 8)));
  if ( v3 == dword_430A34 )
    result = v4 >= dword_430A38;
  else
    result = v4 < dword_430A48;
  return result;
}
// 423600: using guessed type _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43099C: using guessed type int dword_43099C;
// 430A30: using guessed type int dword_430A30;
// 430A34: using guessed type int dword_430A34;
// 430A38: using guessed type int dword_430A38;
// 430A40: using guessed type int dword_430A40;
// 430A44: using guessed type int dword_430A44;
// 430A48: using guessed type int dword_430A48;
// 4D8C18: using guessed type int dword_4D8C18;

//----- (00426670) --------------------------------------------------------
int __cdecl sub_426670(int a1, int a2)
{
  return _ld12cvt(a1, a2, dword_430E60);
}
// 4264A0: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);
// 430E60: using guessed type int dword_430E60[6];

//----- (00426690) --------------------------------------------------------
int __cdecl sub_426690(int a1, int a2)
{
  return _ld12cvt(a1, a2, dword_430E78);
}
// 4264A0: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);
// 430E78: using guessed type int dword_430E78[6];

//----- (004266B0) --------------------------------------------------------
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &String, String, 0, 0, 0, 0);
  return sub_426670((int)v3, (int)Result);
}
// 427370: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004266F0) --------------------------------------------------------
int __cdecl sub_4266F0(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_426690((int)v3, a1);
}
// 427370: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004283A0) --------------------------------------------------------
int __cdecl getch()
{
  int result; // eax
  int v1; // esi
  unsigned __int8 *v2; // eax
  DWORD NumberOfEventsRead; // [esp+10h] [ebp-1Ch] BYREF
  DWORD dwMode; // [esp+14h] [ebp-18h] BYREF
  struct _INPUT_RECORD Buffer; // [esp+18h] [ebp-14h] BYREF

  if ( dword_431490 == -1 )
  {
    result = (int)dword_4314A0;
    if ( dword_4314A0 != (HANDLE)-1 )
    {
      if ( dword_4314A0 == (HANDLE)-2 )
      {
        __initconin();
        result = (int)dword_4314A0;
      }
      GetConsoleMode((HANDLE)result, &dwMode);
      SetConsoleMode(dword_4314A0, 0);
      if ( ReadConsoleInputA(dword_4314A0, &Buffer, 1u, &NumberOfEventsRead) )
      {
        while ( NumberOfEventsRead )
        {
          if ( Buffer.EventType == 1 && Buffer.Event.KeyEvent.bKeyDown )
          {
            v1 = (unsigned __int8)Buffer.Event.KeyEvent.uChar.AsciiChar;
            if ( Buffer.Event.KeyEvent.uChar.AsciiChar )
              goto LABEL_14;
            v2 = (unsigned __int8 *)_getextendedkeycode(&Buffer.Event);
            if ( v2 )
            {
              v1 = *v2;
              dword_431490 = v2[1];
              goto LABEL_14;
            }
          }
          if ( !ReadConsoleInputA(dword_4314A0, &Buffer, 1u, &NumberOfEventsRead) )
            break;
        }
      }
      v1 = -1;
LABEL_14:
      SetConsoleMode(dword_4314A0, dwMode);
      result = v1;
    }
  }
  else
  {
    result = (unsigned __int8)dword_431490;
    dword_431490 = -1;
  }
  return result;
}
// 4285A0: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 428720: using guessed type int __initconin(void);
// 431490: using guessed type int dword_431490;

//----- (004284B0) --------------------------------------------------------
int __cdecl console_input_wrapper()
{
  HANDLE v1; // eax
  int v2; // eax
  void *v3; // esp
  int *v4; // edi
  DWORD v5; // eax
  int *i; // esi
  int v7; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+4h] [ebp-Ch] BYREF
  DWORD nLength; // [esp+8h] [ebp-8h] BYREF
  DWORD NumberOfEventsRead; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_431490 != -1 )
    return 1;
  v1 = dword_4314A0;
  if ( dword_4314A0 == (HANDLE)-2 )
  {
    __initconin();
    v1 = dword_4314A0;
  }
  if ( v1 != (HANDLE)-1 )
  {
    if ( GetNumberOfConsoleInputEvents(v1, &nLength) )
    {
      if ( nLength )
      {
        v2 = 20 * nLength + 3;
        LOBYTE(v2) = v2 & 0xFC;
        v3 = alloca(v2);
        v4 = &v7;
        if ( &v7 )
        {
          if ( PeekConsoleInputA(dword_4314A0, (PINPUT_RECORD)&v7, nLength, &NumberOfEventsRead) )
          {
            v5 = NumberOfEventsRead;
            if ( NumberOfEventsRead )
            {
              if ( NumberOfEventsRead <= nLength )
              {
                for ( i = &v8; ; i += 5 )
                {
                  if ( *(_WORD *)v4 == 1 && *i )
                  {
                    if ( *((_BYTE *)i + 10) || _getextendedkeycode(i) )
                      return 1;
                    v5 = NumberOfEventsRead;
                  }
                  --v5;
                  v4 += 5;
                  NumberOfEventsRead = v5;
                  if ( !v5 )
                    return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 428545: conditional instruction was optimized away because of '%NumberOfEventsRead.4!=0'
// 4285A0: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 428720: using guessed type int __initconin(void);
// 431490: using guessed type int dword_431490;

// nfuncs=448 queued=188 decompiled=188 lumina nreq=0 worse=0 better=0
// ALL OK, 188 function(s) have been successfully decompiled
