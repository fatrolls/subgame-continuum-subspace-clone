/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// void __userpurge Create(ARENA *a1@<ecx>, char *name, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13);
void __thiscall ArenaShutdownArena(int this);
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team);
points_data *__thiscall ArenaAddPlayer(ARENA *arena, PLAYER *p);
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player);
bool __thiscall sub_402560(int this);
int loc_403507(); // weak
int __cdecl sub_403F60(int a1, int a2);
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset);
int __thiscall sub_404050(int this, int a2);
int __thiscall sub_404120(int this, int a2);
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3); // idb
void __thiscall ResetFlagGame(struct ARENA *arenaa);
int __thiscall j_lpfnFixExport16(_DWORD); // weak
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4);
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius);
void __thiscall sub_404980(void *this, int a2, __int64 a3);
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4);
void __thiscall LoadArenaSettings_0(struct ARENA *arenaa);
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this); // idb
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa); // idb
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3); // idb
int __thiscall sub_405360(int this, int a2);
int __thiscall SoccerGameSomething(ARENA *this, int a2); // idb
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4); // idb
void __thiscall GetScore(SoccerScores *SoccerScores, int a2);
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena); // idb
int __thiscall GetTotalPlayingPlayers(ARENA *arena); // idb
int __thiscall sub_4059D0(int this, int a2, const char *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct); // idb
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3);
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText);
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage);
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand);
void __thiscall j_lpfnFixExport10(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr); // idb
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize);
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size);
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len);
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len);
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int a2, int a3, int a4, int len);
int __thiscall sub_406130(int this);
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct); // idb
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename); // idb
void __thiscall WriteCfgFile(struct struc_2 *struc2);
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4);
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count);
char *__thiscall sub_4066B0(int this, const char *a2, const char *a3, const char *a4, char *a5, size_t a6);
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source);
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source);
void __thiscall sub_406B30(int this);
int __thiscall sub_406BE0(int this);
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer);
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize);
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key);
signed int __cdecl sub_406ED0(int level_file);
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll);
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile);
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2);
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile);
int __thiscall sub_407260(int this);
int __thiscall sub_407270(int this, int a2);
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer);
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number);
int __thiscall sub_407420(int this, int a2);
int __stdcall loc_407470(char); // weak
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src);
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int);
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer);
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName);
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
void __cdecl config_read_helper_3(char *a1);
signed int __cdecl CRC32(char *buffer, int fileSize);
int __cdecl sub_408270(int a1);
_DWORD __cdecl loc_40829E(_DWORD, _DWORD, _DWORD, char); // weak
void *__cdecl emalloc(int bytes);
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3);
void __stdcall efree(LPVOID ptr);
SOCKET *__thiscall ConnectSocket(SOCKET *this, char *cp, int netshort, unsigned int buf);
int __thiscall sub_408740(SOCKET *this);
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3);
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed); // idb
PINGSOCKET *__thiscall ListenOnPort(PINGSOCKET *socket, __int16 port, void *callback);
void __thiscall ProcessZonePings(int Socket, int ZonePopulation);
PLAYER *__thiscall CreateNewPlayer(PLAYER *this, struct in_addr in, __int16 a3, NetData *nd);
void __thiscall DisconnectPlayer(PLAYER *p); // idb
int __thiscall PlayerHandleGamePacket(PLAYER *p, BYTE *pkt, DWORD pkt_sz); // idb
void __thiscall GenerateWarning(struct PLAYER *player, int a2);
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr);
signed int __thiscall CheckUserStopPlaying(int this);
void __thiscall sub_40D8D0(int this);
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency);
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship);
int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD); // weak
// int __userpurge sub_40DF06@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, _BYTE *a5, void *buf, int buf_sz);
int __thiscall PlayerSendPacket(PLAYER *player, void *buf, int buf_sz, BOOL bSendReliable); // idb
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6);
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4);
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend);
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6);
int __thiscall sub_40E280(int this, char *buf, unsigned int buf_sz, BOOL bSendReliable, int a5, int a6);
void __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, int a6);
int __thiscall sub_40E360(void *this, int a2, char *buf, unsigned int buf_sz, BOOL bSendReliable, int a6, int a7);
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte);
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2);
void __thiscall SendArenaMessagePlayer(PLAYER *playerr, const char *a2, char SoundByte);
int __thiscall SendFile(int *this, char *filename);
ARENA *__thiscall PlayerFindSuitableArena(PLAYER *p, DWORD join_type, char *arena_preference); // idb
int __thiscall SendWeaponPacket(int this);
void __thiscall SendResetScoresPacket(PLAYER *player);
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player);
signed int __thiscall SendPlayerScoreUpdateAll(int this);
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2);
void __cdecl LoadArenaSettings(struct_ArenaSettings *ArenaSettings, struct_ArenaSettings *a2, const char *a3);
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3);
int __cdecl main(int argc, const char **argv, const char **envp);
signed int __cdecl ServerInitialize();
void __cdecl NewConnectionRequest(struct in_addr in, __int16 port);
int __cdecl sub_412EF0(int, int, int); // idb
void __cdecl ServerMainloop();
int __cdecl IncreaseRadarValueShowHomeOverFourThousand();
void __cdecl ServerUninitialize();
// void __usercall sub_413B50(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5);
void FormatMessageArena(ARENA *arena, const char *Format, ...);
void WriteSubGameLog(const char *Format, ...);
bool __cdecl IsOffensiveName(char *a1);
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2); // idb
int __cdecl ProtocolViolation();
// void __usercall process_text_packet(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, Player *p, DWORD msg_type, DWORD target_index, char *msg, DWORD arg5);
void __thiscall init_new_player(PLAYER *this);
char *__cdecl fix_dll_loader(const char *a1, const char *a2);
int __stdcall create_arena(int, int); // weak
int __cdecl sub_415800(int a1, int a2);
int __cdecl sub_415820();
// void __userpurge sub_415850(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6, int a7);
// void __userpurge sub_415870(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// void __userpurge sub_4158A0(int a1@<ebx>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// void __userpurge sub_415920(int a1@<ebp>, int a2, int a3, int a4, int a5);
int sub_415940(void); // weak
// void __userpurge sub_415980(int a1@<edi>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13);
// void __usercall CommandHandler_2(char *a1@<ebx>, PLAYER *a2@<ebp>, int a3@<edi>, unsigned int a4@<esi>, int a5, int a6, int a7, int SoccerScores, char a9);
int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __userpurge sub_419A70@<eax>(int this@<ecx>, int a2@<edx>, int a3@<ebp>, char *buf, unsigned int buf_sz, BOOL bSendReliable);
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3);
unsigned int __cdecl LoadServerIni();
void __cdecl LoadTemplateSSS();
int __cdecl sub_41AA20();
void __cdecl LoadAdvertisements();
void __cdecl CleanUpMemory();
int __cdecl InitWinsock();
int j_WSACleanup(void); // weak
int *__thiscall setup_stuff_and_socket(int *this, int lpfnNewConnectionRequest, int lpfnOnEachPacket, int a4, int a5, int dwSendBufSz, int dwRecvBufSz, int optval);
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment);
int __thiscall sub_41B4E0(int this, int a2);
Encryption_Struct *__thiscall SomethingBillerServer(struct_v9 *this, struct_v9 *name, const char *hostshort, u_short EncryptionRNGSeed, signed int a5, int retstr);
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename);
Packet *__thiscall PlayerReadPackets(struct_v9 *this, int lpdwBytesRead, int a3, int a4);
signed int __thiscall PlayerDoNetworkOps(struct_v9 *this); // idb
// void __userpurge PlayerHandlePacket(PLAYER *p@<ecx>, BYTE *packet, DWORD dwBytesRead, DWORD dwIPAddress, int wSrcPort, int a6, int a7, int a8, int a9, int a10);
int __stdcall loc_41BBAD(int, int, int, int); // weak
int __stdcall loc_41BC22(int, int, int, int); // weak
int __stdcall loc_41BC25(int, int, int, int); // weak
int __stdcall loc_41BC2D(int, int, int, int); // weak
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5);
int __thiscall sub_41BD80(int this, int a2, int a3);
int __thiscall sub_41BFA0(int this);
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls);
signed int __thiscall sub_41C000(void *this, signed int a2);
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment);
int __cdecl DifferentCompareFunction(_DWORD connection, int ConnectionsArray);
int __thiscall encrypt_init(char *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __thiscall sub_41C360(int this);
int __thiscall sub_41C510(int this);
int __thiscall sub_41C520(int this);
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2);
// void __userpurge WriteToNetwork(int a1@<ecx>, char *buf, int len, int a4, int a5, int a6, int a7, int a8, int a9, char a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62);
int __stdcall loc_41C632(char *buf, int len); // weak
void __thiscall NetDataHandleCorePacket(NETDATA *nd, void *packet, int packet_sz, int a4);
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection);
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4);
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename);
signed int __thiscall sub_41D440(int this, int a2, int a3, int a4);
int __stdcall sub_41D4C3(int, int, int); // weak
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4);
int __thiscall sub_41D560(int this, int a2, int a3);
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart);
int __thiscall sub_41D5C0(int this);
void __thiscall SendPacketCluster(struct CONNECTION *encryptionn, const void *buf, unsigned int len);
void __thiscall sub_41D6D0(int this);
int __thiscall sub_41D720(int this, int a2, int a3);
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5);
void __thiscall sub_41D780(int this);
char *__cdecl get_text_ip(struct in_addr in); // idb
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename);
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize);
// int __cdecl compress(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall send(SOCKET s, const char *buf, int len, int flags); idb
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen); idb
// struct hostent *__stdcall gethostbyname(const char *name); idb
// unsigned __int32 __stdcall inet_addr(const char *cp); idb
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen); idb
// u_long __stdcall ntohl(u_long netlong); idb
// u_short __stdcall ntohs(u_short netshort); idb
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen); idb
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp); idb
// SOCKET __stdcall socket(int af, int type, int protocol); idb
// int __stdcall closesocket(SOCKET s); idb
// int __stdcall recv(SOCKET s, char *buf, int len, int flags); idb
int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen); // idb
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); idb
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); idb
// char *__stdcall inet_ntoa(struct in_addr in); idb
int __cdecl srand(int a1);
// int rand(void); idb
// _DWORD printf(const char *, ...); weak
// time_t __cdecl time(time_t *); idb
// _DWORD sprintf(_DWORD, const char *, ...); weak
// char *__cdecl strrchr(const char *, int); idb
// _DWORD __cdecl fclose(_DWORD); weak
// _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl fopen(_DWORD, _DWORD); weak
// char *__cdecl strncpy(char *, const char *, size_t); idb
// _DWORD __cdecl fwrite(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t); idb
// void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); idb
// int __cdecl operator delete(void *); idb
// void *__cdecl operator new(unsigned int); weak
// int __cdecl atoi(const char *); idb
// int __cdecl isalpha(int); idb
// int __cdecl isdigit(int); idb
// int __cdecl isspace(int); idb
// _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD); weak
// _DWORD fprintf(_DWORD, const char *, ...); weak
// int __cdecl fseek(int, LONG lDistanceToMove, int); idb
// int __cdecl _chsize(_DWORD, _DWORD); weak
// char *__cdecl strstr(const char *, const char *); idb
// int __cdecl toupper(int); idb
// void __cdecl exit(int); idb
// void *__cdecl malloc(size_t); idb
// void *__cdecl realloc(void *, size_t); idb
// void __cdecl free(void *); idb
char *__cdecl RunCommandPrompt(char *argumentsPointer);
// _DWORD _spawnlp(_DWORD, _DWORD, ...); weak
// clock_t clock(void); idb
// _DWORD __cdecl fflush(_DWORD); weak
// _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD); weak
// char *__cdecl asctime(const struct tm *); idb
// struct tm *__cdecl localtime(const time_t *); idb
// double __cdecl difftime(time_t, time_t); idb
// _DWORD __cdecl _filelength(_DWORD); weak
void sub_422060();
void __cdecl sub_4220CE();
void sub_4220F0();
void sub_42215E();
// _DWORD __cdecl _spawnvpe(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _spawnve(_DWORD, char *, _DWORD, _DWORD); weak
// int __cdecl _access(LPCSTR lpFileName, char); idb
// char *__cdecl getenv(const char *); idb
bool __cdecl DateFunction(int a1);
// _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl unknown_libname_5(int, int, int); weak
// void abort(void); idb
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_427220(int a1, int a2);
int __cdecl sub_427240(int a1, int a2);
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String);
int __cdecl sub_4272A0(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _fileno(_DWORD); weak
// int __cdecl _strcmpi(const char *, const char *); idb
// char *__cdecl _strupr(char *); idb
int __cdecl getch();
int __cdecl console_input_wrapper();
// _DWORD __cdecl _getextendedkeycode(_DWORD); weak
// int __cdecl _memicmp(const void *, const void *, unsigned int); idb
// int __initconin(void); weak
// int unknown_libname_14(); weak
// int __stdcall GetObjectA(HGDIOBJ, int, LPVOID); idb
// BOOL __stdcall DeleteObject(HGDIOBJ); idb
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize); idb
// BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName); idb
// DWORD GetTickCount(void); idb
// BOOL __stdcall CloseHandle(HANDLE hObject); idb
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime); idb
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); idb
// UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName); idb
// DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); idb
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect); idb
// BOOL __stdcall VirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode); idb
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); idb
// LPSTR GetCommandLineA(void); idb
// BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle); idb
// void __stdcall Sleep(DWORD dwMilliseconds); idb
// BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents); idb
// BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead); idb
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode); idb
// BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode); idb
// BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead); idb
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName); idb
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); idb
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); idb
// HANDLE __stdcall LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT); idb
int __thiscall sub_100010E0(void *this, int a2, int a3);
unsigned int __thiscall sub_10001120(void *this, const char *a2);
int __thiscall sub_10001240(int this, int a2);
int __thiscall sub_10001320(int a1);
int __thiscall ReadsScrty1File(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_10001A50(void *this);
int __thiscall ReadScrty1File(void *this, char *FileName, int a3, int a4);
int __thiscall sub_10001D90(void *this);
int __thiscall ReadScrty1FileOffset(void *this, int a2, int a3);
bool __thiscall sub_10001F70(void *this);
int __thiscall sub_10002090(void *this);
char __thiscall sub_100024F0(void *this, int a2, int a3);
_BOOL1 __thiscall sub_100027F0(void *this);
signed int __thiscall sub_10002830(void *this);
int __thiscall sub_100028D0(void *this);
unsigned int __thiscall sub_10002A10(void *this, int a2, int a3);
void __thiscall sub_10002B80(void *this);
int __cdecl sub_10002CC0(int a1);
int __fastcall sub_10002D10(int a1, int a2);
int __thiscall sub_10002D60(void *this);
int __cdecl sub_10002D70(int a1);
const char *__fastcall sub_10002E30(void *a1, int a2, int a3, unsigned __int8 a4, int a5);
char *__fastcall strncpyt(void *dst, void *src, int len);
char *__fastcall sub_10003060(const char *a1, const void *a2, signed int a3);
int __fastcall sub_100030E0(int a1, const char *a2);
char __fastcall sub_10003220(int a1, int a2, char a3);
char *__thiscall sub_10003240(void *this);
char *__thiscall sub_10003260(void *this);
char *__fastcall sub_10003280(int a1);
int __thiscall sub_100033A0(void *this);
int sub_10003E70(const char **a1, const char *a2, ...);
int __fastcall sub_10004F40(const char *a1, va_list a2);
int sub_10005120(int a1, ...);
const char **sub_10005140(const char **a1, const char *a2, ...);
// char __userpurge sub_100052C0@<al>(int a1@<ecx>, int a2@<edx>, int esi0@<esi>, int a3, int a4, char a5);
void __fastcall sub_10005390(int a1, int a2, unsigned int a3, int a4);
int __thiscall sub_10005460(int this, int a2);
int __thiscall sub_10005490(int this);
int __thiscall sub_100054B0(void *this, int a2);
int __thiscall sub_10005590(int this);
int __thiscall sub_10005630(void *this);
int __thiscall sub_10005650(int this);
int __thiscall sub_10005670(int this);
int __thiscall sub_10005690(void *this);
int __thiscall sub_100056A0(void *this);
u_long __thiscall sub_100056B0(u_long netlong);
int __thiscall sub_100056C0(void *this);
int __cdecl sub_100056D1();
int __thiscall sub_100056E0(int this);
int __thiscall sub_10005700(int this);
// char __userpurge sub_10005750@<al>(int a1@<ecx>, int a2@<esi>, int a3, int a4);
int __thiscall sub_100057B0(void *this, int a2);
char __thiscall sub_100057F0(void *this);
int __thiscall sub_10005850(int this, int a2);
char __thiscall sub_100058A0(void *this, int a2);
char __thiscall sub_10005980(void *this, int a2);
char __thiscall sub_10005BD0(void *this, int a2);
_BOOL1 __thiscall sub_10005DA0(int this, int a2);
char __thiscall sub_10005E60(void *this, int a2, int a3);
char __thiscall sub_10006000(void *this, int a2);
int __thiscall sub_10006100(void *this, int a2, signed int a3);
signed int __thiscall sub_100061C0(void *this, int a2, int a3);
int __thiscall sub_10006280(int this, void *a2, int a3);
void *__thiscall sub_10006300(void *this, const void *src);
int __thiscall sub_10006410(void *this, int a2);
int __thiscall sub_10006450(void *this, int a2);
int __fastcall sub_10006490(int a1, unsigned int a2);
int __fastcall sub_100064D0(char *a1, signed int **a2);
_BYTE *__thiscall sub_100065C0(void *this);
signed int __fastcall sub_100065F0(int a1, unsigned int a2, unsigned int a3);
_BOOL1 __thiscall sub_10006880(int this, signed int a2, int a3);
int __thiscall sub_10006A60(int this, const void *a2, signed int a3);
int __thiscall sub_10006AA0(int this, void *a2, int a3, int a4);
int __thiscall sub_10006C10(int this, int a2);
int __thiscall sub_10006C80(int this, int a2);
int __thiscall sub_10006CD0(int this);
char __thiscall sub_10006CF0(int this, int a2);
int __thiscall sub_10006DA0(int this);
char __thiscall sub_10006DC0(void *this);
int __fastcall sub_10006DF0(int this, _DWORD edx0, signed int a2);
int __thiscall sub_10006FB0(int this);
char __thiscall sub_10007060(int this);
int __thiscall sub_10007160(int this, const void *a2, signed int a3, int a4);
int __thiscall sub_10007240(int this, void *a2, int a3, int a4, int a5);
void *__thiscall sub_10007470(void *this);
int __cdecl sub_100074E0();
void sub_10007540(void); // idb
int __thiscall sub_10007550(int this);
unsigned __int8 *__thiscall sub_100075A0(int this);
char __thiscall sub_10007650(int this, int a2);
int __thiscall sub_100076D0(int this, const void *a2, char a3);
char __thiscall sub_10007740(int this, int a2);
char __thiscall sub_100077B0(int this, char a2);
char __thiscall sub_10008030(int this, int a2);
char __thiscall sub_100080F0(int this, int a2);
int __thiscall sub_10008170(void **this);
int __thiscall sub_10008190(int this, int a2);
int __stdcall loc_1000820B(int); // weak
int (__stdcall *__cdecl sub_1000821E())(int);
int __cdecl sub_10008230();
int __cdecl sub_100082E0();
long double __cdecl sub_10008340();
long double __cdecl sub_100083C0();
signed __int64 __cdecl sub_10008440();
signed __int64 __thiscall sub_100084C0(void *this, double a2);
int __thiscall sub_10008500(void *this);
_BOOL1 __thiscall sub_10008570(void *this, int a2);
int __thiscall sub_100085E0(int this, int a2);
int __thiscall sub_10008660(int this);
int __thiscall sub_100086D0(int this, int a2);
long double __thiscall sub_100086E0(int this);
// _DWORD __stdcall unknown_libname_56(_DWORD); weak
// _DWORD *__userpurge sub_10008800@<eax>(void **a1@<ecx>, int a2@<ebx>, int a3);
char __thiscall ContinuumEncrypt(void *this, int a2, int a3, unsigned int a4);
unsigned int __thiscall ContinuumDecrypt(void *this, int a2, int a3, unsigned int a4);
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2);
size_t __thiscall sub_1000A060(void *this, int a2, const void *a3, size_t a4);
unsigned int __thiscall sub_1000A150(void *this, void *a2, int a3, unsigned int a4);
char __thiscall sub_1000A270(int this, int a2);
bool __thiscall sub_1000A300(int this, int a2);
_DWORD *__thiscall sub_1000A370(int this);
int __thiscall sub_1000A420(int this);
int __thiscall sub_1000A440(int this);
int __thiscall sub_1000A470(void *this, LPCSTR lpFileName);
char __thiscall sub_1000A860(int this, int a2, int a3, int a4, int a5);
void *__thiscall sub_1000A9F0(void *this, int a2, unsigned int a3, int a4, int a5);
int __thiscall sub_1000AA50(int this, int a2, unsigned int a3, int a4);
char __thiscall sub_1000AAA0(void *this, int a2, int a3, int a4);
char __thiscall sub_1000AD20(int this, int a2, int a3, int a4);
unsigned int __thiscall sub_1000AEA0(void *this);
unsigned int __thiscall sub_1000B3B0(int this, int a2, int a3);
char *__thiscall sub_1000B400(int this, char a2, const void *src, char a4);
char __thiscall sub_1000B5B0(void *this, int a2, char *a3, const char *a4);
char *__thiscall sub_1000B6E0(int this, int a2, char a3);
int __thiscall sub_1000B780(void *this);
int __cdecl sub_1000B7B0();
int __cdecl sub_1000B7D0();
int __cdecl sub_1000B7F0();
int __cdecl sub_1000B810();
int __thiscall sub_1000B8B0(int this);
int __stdcall sub_1000B8D0(const void *player);
int __stdcall sub_1000B9A0(const char *msg, char msg_type);
LPCSTR __stdcall sub_1000B9F0(int a1, int a2, int a3);
int __cdecl sub_1000BA20();
char __stdcall sub_1000BA30(int a1, int a2, int a3, int a4);
int __stdcall sub_1000BAB0(char *a1, int a2, int a3);
int __cdecl sub_1000BB60();
int __cdecl sub_1000BB70();
void __thiscall sub_1000BB80(void *this, int a2, const char *a3);
signed int __thiscall WriteDataProxyRemoveLater(int this, char *buf, unsigned int buf_sz, BOOL bReliable);
void __thiscall sub_1000BBC0(int this, char *buf, unsigned int len);
void __thiscall sub_1000BBE0(int this, int a2, int a3, int a4);
void __thiscall sub_1000BC00(int this);
void __thiscall biller_player_login(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr); // idb
int __thiscall sub_1000BD10(int this, const char *lpszSection, const char *lpszKey, int DefaultVal);
int __thiscall sub_1000BD30(int this, char *buf, unsigned int buf_sz, BOOL bSendReliable);
void __thiscall sub_1000BD50(void *this, int ship);
void __thiscall sub_1000BD90(int this, signed int a2);
void __thiscall sub_1000BDC0(int this);
signed int __thiscall sub_1000BDE0(void *this, const char *filename);
void __thiscall sub_1000BE30(int this, const char *msg, char msg_type);
void __thiscall sub_1000BE50(int this, const char *reason, char something);
int __thiscall sub_1000BE70(PLAYER *this, const void *src, void *buf, char buf_sz);
int __thiscall sub_1000BEF0(PLAYER *this, BYTE *pkt, DWORD pkt_sz);
void __thiscall sub_1000BF10(int this, int a2);
int __thiscall sub_1000BF30(PLAYER *this, const void *buf);
void __thiscall sub_1000BF90(int this, int a2);
void __thiscall sub_1000C000(void *this, char *reason);
char __thiscall sub_1000C0B0(void *this, int a2);
char __thiscall sub_1000C130(void *this, int a2);
char *__thiscall sub_1000C1B0(int this, char a2);
char __fastcall find_player_request(PLAYER *requester, char *target_name);
int __thiscall sub_1000C400(void *this, int a2, int a3);
int __thiscall sub_1000C480(int this);
int __thiscall sub_1000CF20(void *this, int a2, unsigned __int8 a3, int a4);
int __fastcall sub_1000D0B0(int a1, int a2, int a3);
int __thiscall sub_1000D170(int this);
int __thiscall sub_1000D470(int this);
char __thiscall sub_1000D490(void *this, int a2);
char __thiscall sub_1000D590(void *this, int a2);
int __fastcall sub_1000D660(int a1, int a2);
int __fastcall sub_1000D680(int a1, int a2, int a3);
int __cdecl sub_1000D770();
int __fastcall sub_1000D7F0(int a1, int a2);
// void unknown_libname_57(void); idb
int __fastcall sub_1000D820(int a1, int a2);
// void unknown_libname_58(void); idb
int __fastcall sub_1000D850(int a1, int a2);
// void unknown_libname_59(void); idb
int __fastcall sub_1000D880(int a1, int a2);
int __fastcall sub_1000D8A0(int a1, int a2, int a3);
int __cdecl sub_1000DA00();
int __thiscall sub_1000DAB0(int this);
_DWORD sub_1000DBE0(); // weak
int __stdcall fix_export_0(void *msg, PLAYER *ship, char *buf, struct PLAYER *arena);
int __thiscall sub_10010460(int this, int a2, int a3);
void __thiscall sub_10010490(int this, int a2, double a3, int msg);
int __thiscall sub_10010510(int this);
// void __userpurge sub_10010530(int a1@<ecx>, int a2@<ebx>, int a3);
void __thiscall sub_100106E0(int this, char a2);
int __thiscall sub_10010810(int this, int a2);
_BOOL1 __fastcall sub_10010840(int a1);
_BOOL1 __thiscall sub_10010860(int this);
void __thiscall sub_100108A0(int this);
bool __thiscall sub_100108F0(int this);
void __thiscall sub_10010970(void *this);
void __thiscall sub_100109B0(int this);
char __thiscall sub_10010A10(int this);
const char *__thiscall sub_10010A70(int this);
void __thiscall fix_04(int this, BYTE *buf, DWORD pkt_sz);
_DWORD *__thiscall sub_100122C0(int this);
unsigned int __thiscall sub_10012520(int this);
unsigned int __thiscall sub_100125F0(int ap);
PLAYER *__thiscall CtmPlayerJustConnected(PLAYER *p);
void __thiscall sub_10012C40(void *this, int player);
int __thiscall sub_10012DA0(void *this);
int __stdcall sub_10012E80(void *a1);
int __thiscall Fix_44(PLAYER *p);
signed int __thiscall Fix_10(PLAYER *this);
int __thiscall sub_10013250(int this);
void __thiscall sub_100137F0(int this);
void __thiscall sub_10013980(int this, const void *buf, size_t buf_sz, int a4);
int __thiscall Fix_PlayerInit(int this);
int __cdecl sub_10013B10();
void __cdecl BillingServerRecievedPacket(char *player, int classptr);
int __stdcall fix_1c(SOCKET s, char *buf, int a3, int flags, struct sockaddr *from, int *fromlen);
int __fastcall sub_10014C30(unsigned int a1, int a2);
int __stdcall sub_10014CC0(int a1, int a2);
size_t __stdcall sub_100150F0(int a1, const void *a2, size_t a3, int a4);
unsigned int __stdcall sub_10015120(int a1, int a2, unsigned int a3);
void __stdcall fix_PacketHandler(int a1, int len);
int __cdecl sub_100151C0(int ap, int a2);
int __cdecl sub_10015390();
int sub_10015450();
void __stdcall sub_10015510(int a1, int buf);
signed int __stdcall sub_10015590(int a1, int a2, int a3);
int __thiscall sub_10015610(int this);
int __thiscall sub_10015620(void **this);
int __thiscall sub_10015680(void **this);
_DWORD *__thiscall sub_100156A0(void *this, int a2);
int __thiscall sub_100157A0(int this, int a2);
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD); // weak
u_long __stdcall ntohl_0(u_long netlong); // idb
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F();
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_006F(_DWORD);
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD); // weak
int j_FIX_DLL_WSOCK32_dll_ord_0006(void); // weak
int j_FIX_DLL_WSOCK32_dll_ord_000D(void); // weak
int j_FIX_DLL_WSOCK32_dll_ord_0001(void); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0013(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0010(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int j_FIX_DLL_WSOCK32_dll_ord_0034(void); // weak
unsigned __int32 __stdcall inet_addr_0(const char *cp); // idb
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0033(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0097(_DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0011(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD); // weak
char *__cdecl strncpy_0(char *, const char *, size_t);
void __stdcall _JumpToContinuation(void *, struct EHRegistrationNode *); // idb
// _DWORD __cdecl sub_10015B59(_DWORD, _DWORD); weak
// _DWORD __cdecl sub_10015B60(_DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_60(_DWORD, _DWORD); weak
// int __usercall __CxxFrameHandler_0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4, int a5, int a6, int a7);
void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *, const struct _s_FuncInfo *, void *, int, unsigned __int32); // idb
// int __usercall CatchGuardHandler@<eax>(int a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5);
// _DWORD __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, _DWORD, struct EHRegistrationNode *); weak
// int __usercall TranslatorGuardHandler@<eax>(int a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a5);
const struct _s_TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *, int, int, unsigned int *, unsigned int *); // idb
int __cdecl _global_unwind2_0(PVOID TargetFrame); // idb
int __cdecl loc_10015E3C(int); // weak
signed int __cdecl _unwind_handler(int a1, int a2, int a3, int a4);
int __cdecl _local_unwind2_0(int a1, int a2);
int __cdecl _abnormal_termination_0();
// int __userpurge sub_10015EF1@<eax>(int result@<eax>, int a2@<ecx>, int a3@<ebp>, int a4);
_DWORD __stdcall loc_10015EFA(_DWORD); // weak
void __cdecl _cinit_0();
void __cdecl sub_10015F3F(int a1);
void __cdecl sub_10015F50(int a1);
void __cdecl doexit_0(UINT uExitCode, int a2, int a3);
void __cdecl sub_10016018(unsigned int a1, unsigned int a2);
int __cdecl atol_0(const char *String);
int __thiscall atol_1(void *this, signed int *a2);
int __fastcall sub_100162C0(int a1, int a2);
char *__cdecl strchr_0(const char *Str, int Val);
int __cdecl loc_100162D6(int, char); // weak
int __cdecl vsprintf_0(char *, const char *, va_list);
int (__cdecl *__cdecl sub_100163DD(int a1))(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int (*__cdecl sub_100163ED(int (*a1)()))();
int __cdecl sub_100163FD(int a1);
int (__cdecl *__cdecl sub_1001640D(int (*a1)()))(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
char *__thiscall sub_100164A4(void *this);
void *__thiscall sub_100164A8(void *this, int a2);
void *__thiscall sub_100164B3(void *this, int a2);
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// __int64 __stdcall _allmul_0(__int64 a1, __int64 a2);
void *__cdecl memcpy_0(void *, const void *, size_t); // idb
int __cdecl loc_1001664C(int, int, int); // weak
int __cdecl loc_100167D4(int, int, int); // weak
int __cdecl toupper_0(int);
int __cdecl tolower_0(int);
// void *__cdecl memchr(const void *, int, size_t); idb
int sprintf_0(char *, const char *, ...);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list); idb
// int __cdecl atexit(void (*)(void)); idb
// void __cdecl _assert(void *, void *, unsigned int); idb
int __cdecl sub_10016FAF(unsigned __int8 *a1, int a2);
// int __usercall sub_10016FE0@<eax>(int a2@<esi>);
unsigned int __cdecl sub_10016FF7();
void *__cdecl _cfltcvt_init_0();
// signed __int64 __usercall _ftol_0@<edx:eax>(long double a1@<st0>);
// void __usercall _alloca_probe_0(unsigned int a1@<eax>, int a2);
// _DWORD __stdcall `eh vector constructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __usercall sub_10017122(int a1@<ebp>);
// _DWORD __stdcall `eh vector destructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall __ArrayUnwind(void *, unsigned int, _DWORD, void (__thiscall *)(void *)); weak
int __cdecl isalpha_0(int);
int __cdecl sub_100172AC(int a1);
int __cdecl loc_100172B5(wint_t); // idb
int __cdecl sub_100172C3(int a1);
// int __cdecl isalnum(int); idb
char *__cdecl strrchr_0(const char *, int);
int __cdecl sub_100174D1();
time_t __cdecl time_0(time_t *);
// _DWORD __stdcall _CRT_INIT(_DWORD, _DWORD, _DWORD); weak
int __stdcall FIX_DLL_start(int a1, int a2, int a3);
void __cdecl _amsg_exit_0(int rterrnum);
// int __usercall __InternalCxxFrameHandler_0@<eax>(int a2@<ecx>, int a3@<ebx>, int a4, int a5, int a6, int a7, int a8, int a9, struct EHRegistrationNode *a10, char a11);
// int __usercall FindHandler@<eax>(const struct _s_FuncInfo *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a6, struct _CONTEXT *a7, void *a8, const struct _s_FuncInfo *a9, char a10, int a11, PVOID TargetFrame);
unsigned int __cdecl FindHandlerForForeignException(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4, const struct _s_FuncInfo *a5, int a6, int a7, PVOID TargetFrame);
// _DWORD __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *); weak
// unsigned int __usercall sub_10017A9A@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8, int a9);
// void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8); weak
void *__cdecl sub_10017BC9(int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_10017C8F@<eax>(int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>);
// char *__usercall BuildCatchObject@<eax>(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5);
// _DWORD __cdecl unknown_libname_64(_DWORD); weak
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2);
// _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD); weak
// int __usercall sub_10017F9C@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8);
// int __usercall sub_10018002@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8);
int __cdecl _isctype_0(int, int);
int __cdecl _flsbuf_0(int, FILE *);
int __cdecl _output_0(FILE *File, int, int); // idb
int __cdecl write_char_0(int, FILE *File, int); // idb
int __cdecl write_multi_char_0(int a1, int a2, int a3, int a4);
int __cdecl write_string_0(int, int, FILE *File, int); // idb
int __cdecl sub_100189C1(int a1);
__int64 __cdecl sub_100189CE(int a1);
__int16 __cdecl sub_100189DE(int a1);
void __cdecl sub_100189EC(unsigned int a1);
// int __cdecl strcmp(const char *, const char *); idb
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int); // idb
_BYTE *__cdecl strncnt_0(int a1, int a2);
void *__cdecl sub_10018D97(unsigned int a1, int a2);
int __cdecl sub_10019037(unsigned int a1);
void *__cdecl sub_10019098(int a1);
void *__cdecl _nh_malloc_0(size_t Size, int a2);
void *__cdecl sub_100190D6(int a1);
int __cdecl fflush_0(FILE *);
signed int __cdecl _flush_0(int a1);
signed int __cdecl flsall_0(int a1);
int fprintf_0(FILE *, const char *, ...);
int __cdecl raise_0(int);
_DWORD *__cdecl siglookup_0(int a1);
int __cdecl __crtMessageBoxA_0();
// size_t __cdecl strlen(const char *); idb
// char *__cdecl strcpy(char *, const char *); idb
// char *__cdecl strcat(char *, const char *); idb
signed int __cdecl _stbuf_0(int a1);
signed int __cdecl _ftbuf_0(int a1, int a2);
// int *__usercall _FF_MSGBANNER_0@<eax>(int a2@<esi>);
// int *__usercall _NMSG_WRITE_0@<eax>(int a1@<esi>, DWORD NumberOfBytesWritten);
unsigned int __cdecl sub_10019CC7();
bool __cdecl _ms_p5_test_fdiv_0();
int __cdecl _ms_p5_mp_test_fdiv_0();
signed int __cdecl __loctotime_t_0(int a1, signed int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1001A31E(int a1);
int __cdecl sub_1001A34B();
signed int __cdecl sub_1001A493(int a1);
// int __usercall sub_1001A4F0@<eax>(int a1@<ebx>, int a2@<ebp>);
int _ioinit_0();
void __cdecl _setenvp_0();
int __fastcall _setargv_0(int a1, int a2);
int __cdecl parse_cmdline_0(int a1, int a2, int a3, int a4, int a5);
void *__cdecl __crtGetEnvironmentStringsA_0();
bool __cdecl sub_1001AB9E(int a1, int a2);
bool __cdecl sub_1001ABBA(int a1, int a2);
bool __cdecl sub_1001ABD6(int a1);
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); // idb
int __cdecl _lseek_0(int, int, int);
int __cdecl _write_0(int, const void *, unsigned int);
int __cdecl _getbuf_0(int a1);
int __cdecl _isatty_0(int);
int __cdecl wctomb_0(char *, wchar_t);
// __int64 __stdcall _aulldiv_0(unsigned __int64 a1, unsigned int a2, unsigned int a3);
// int __stdcall _aullrem_0(unsigned __int64 a1, __int64 a2);
// int __cdecl __sbh_heap_init(_DWORD); weak
unsigned int __cdecl __sbh_find_block_0(int a1);
unsigned int __cdecl sub_1001B27A(unsigned int a1, int a2);
_DWORD *__cdecl __sbh_alloc_block_0(int a1);
// int __thiscall __sbh_alloc_new_region(_DWORD); weak
// _DWORD __cdecl __sbh_alloc_new_group(_DWORD); weak
signed int __cdecl __sbh_resize_block_0(int a1, int a2, int a3);
void **__cdecl sub_1001C170();
void *__cdecl sub_1001C2B4(void **a1);
void __cdecl sub_1001C30A(int a1);
unsigned int __cdecl sub_1001C3CC(unsigned int a1, int a2, int a3);
void __cdecl sub_1001C423(int a1, int a2, int a3);
_BYTE *__cdecl sub_1001C468(unsigned int a1);
int __cdecl sub_1001C670(int a1, unsigned int a2, unsigned int a3);
signed int __cdecl sub_1001C794(int a1, int a2, unsigned int a3, unsigned int a4);
bool __cdecl sub_1001C9B1(int a1);
int __cdecl _commit_0(int);
int __cdecl _freebuf_0(_iobuf *stream);
unsigned int __cdecl _control87_0(unsigned int, unsigned int);
unsigned int __cdecl sub_1001D070(int a1, int a2);
char __cdecl _abstract_cw_0(__int16 a1);
char __cdecl _hw_cw_0(int a1);
signed int __cdecl _ZeroTail_0(int a1, signed int a2);
signed int __cdecl _IncMan_0(int a1, signed int a2);
signed int __cdecl _RoundMan_0(int a1, signed int a2);
// void *__cdecl memset(void *, int, size_t); idb
void sub_1001D888();
void __cdecl sub_1001D891();
void __cdecl _tzset_0();
// _DWORD __cdecl _isindst(_DWORD); weak
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// __int32 __cdecl strtol(const char *, char **, int); idb
char *__cdecl strstr_0(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t); idb
int __cdecl _setmbcp_0(int);
int __cdecl getSystemCP_0(int a1);
signed int __cdecl CPtoLCID_0(int a1);
int __cdecl setSBCS_0();
// int setSBUpLow(void); weak
signed int __cdecl sub_1001E4BC();
_DWORD *__cdecl _dosmaperr_0(unsigned int a1);
int __cdecl _alloc_osfhnd_0();
// int __usercall _set_osfhnd_0@<eax>(int a1@<ebx>, int a2, HANDLE hHandle);
signed int __cdecl _free_osfhnd_0(signed int a1);
int __cdecl _get_osfhandle_0(int);
int __cdecl fclose_0(FILE *);
signed int __cdecl __addl_0(unsigned int a1, unsigned int a2, int a3);
signed int __cdecl __add_12_0(int a1, int a2);
int __cdecl __shl_12_0(int a1);
int __cdecl __shr_12_0(int a1);
__int16 __cdecl __mtold12_0(int a1, int a2, int a3);
int __cdecl __strgtold12_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __cdecl _I10_OUTPUT_0(__int64 a1, int a2, int a3, char a4, int a5);
char *__cdecl getenv_0(const char *);
int __cdecl _close_0(int);
int __cdecl __ld12mul_0(int a1, int a2);
void __cdecl __multtenpow12_0(int a1, signed int a2, int a3);
int __cdecl _mbsnbicoll_0(const unsigned __int8 *, const unsigned __int8 *, size_t);
signed int __cdecl __wtomb_environ_0();
int __cdecl __crtCompareStringA_0(int a1, int a2, unsigned __int8 *a3, int a4, unsigned __int8 *a5, int a6, int a7);
_BYTE *__cdecl sub_1001F82C(int a1, int a2);
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int); // idb
int __cdecl findenv_0(unsigned __int8 *a1, size_t a2);
_DWORD *__cdecl copy_environ_0(const char *a1);
unsigned __int8 *__cdecl _mbschr_0(const unsigned __int8 *, unsigned int);
char *__cdecl _strdup_0(const char *);
int __cdecl j_FIX_DLL_KERNEL32_dll_RtlUnwind(_DWORD, _DWORD, _DWORD, _DWORD); // weak
unsigned int __cdecl _memicmp_0(const void *a1, const void *a2, unsigned int a3);
// _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD); weak
// int __usercall SEH_10001240@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_10005140@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_100052C0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_10005700@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_10006DF0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_10006FB0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_10008190@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_1000A370@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_1000C480@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_1000D170@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_1000D680@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_1000D8A0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall SEH_100125F0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
// int __usercall sub_10020028@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6);
DWORD __stdcall GetPrivateProfileStringA_0(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
int __stdcall recvfrom_0(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); // idb

//-------------------------------------------------------------------------
// Data declarations

int dword_400000[1024] =
{
  9460301,
  3,
  4,
  65535,
  184,
  0,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  247078670,
  -855002112,
  1275181089,
  1750344141,
  1881174889,
  1919381362,
  1663069537,
  1869508193,
  1700929652,
  1853190688,
  544106784,
  542330692,
  1701080941,
  168627502,
  36,
  0,
  17744,
  262476,
  894409439,
  0,
  0,
  17760480,
  327947,
  165376,
  726528,
  0,
  130544,
  4096,
  172032,
  4194304,
  4096,
  512,
  4,
  0,
  4,
  0,
  905216,
  1024,
  0,
  3,
  1048576,
  4096,
  1048576,
  4096,
  0,
  16,
  0,
  0,
  901120,
  120,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  901632,
  392,
  0,
  0,
  0,
  0,
  0,
  0,
  2019914798,
  116,
  165045,
  4096,
  165376,
  1024,
  0,
  0,
  0,
  1610612768,
  1633972782,
  24948,
  1872,
  172032,
  2048,
  166400,
  0,
  0,
  0,
  1073741888,
  1952539694,
  97,
  721868,
  176128,
  30720,
  168448,
  0,
  0,
  0,
  -1073741760,
  1633970478,
  24948,
  2318,
  901120,
  2560,
  199168,
  0,
  0,
  0,
  -1073741760,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18934913,
  1431502848,
  1474923350,
  874822795,
  855638017,
  -1328781093,
  -1651965886,
  119818,
  2530697,
  -1990787071,
  16724125,
  2110711808,
  -998047742,
  1975551240,
  -1329283288,
  -914161598,
  -139529473,
  -1913050159,
  16449685,
  -1950250240,
  -1040544777,
  -1510800663,
  -511457141,
  -341511421,
  11898133,
  1778385147,
  -396994784,
  118336,
  -2012429181,
  490282846,
  5068976,
  -1657270402,
  64256,
  28837748,
  -352321536,
  -1950338302,
  1304564789,
  579176704,
  -1996488448,
  21402269,
  -1768060672,
  -16776890,
  -1194816554,
  -858993459,
  -356392457,
  -1902802685,
  -1996488378,
  16713885,
  714967296,
  -1996488448,
  16789149,
  849185024,
  -1996488448,
  16791197,
  580729088,
  251658496,
  51844,
  12422400,
  -2097151749,
  -1070334007,
  270816397,
  -772296974,
  -1066862293,
  -1962917200,
  -1946711103,
  609521146,
  48873748,
  -930372109,
  -511459277,
  -1079708925,
  4370616,
  -218117757,
  735180718,
  -1946711047,
  -2083419142,
  -1359806519,
  -1051735413,
  -1510800663,
  1150143115,
  -511503324,
  -1527558141,
  30230504,
  -2081387776,
  -214234940,
  -396994700,
  162968,
  1342489731,
  32243688,
  -1194816768,
  954437177,
  -356392457,
  -1835693822,
  -2097151674,
  344786116,
  1793249746,
  -397192703,
  29212,
  -1995651965,
  21403269,
  -1836217600,
  1442840902,
  1343384145,
  30114792,
  281314048,
  -889526186,
  -998047743,
  339053316,
  -1929359934,
  -1188027308,
  16064,
  -41172941,
  65640,
  -1410117120,
  202768211,
  -1929359934,
  1781539908,
  -1712828324,
  -2097151542,
  -1019541308,
  411567220,
  1552418027,
  -2054475740,
  65570,
  -2054307013,
  110830,
  14517263,
  -1114832896,
  64256,
  807685261,
  -1402449577,
  1342194352,
  30011368,
  281314048,
  -1309768307,
  1750532097,
  4370596,
  -908400560,
  -998047743,
  -293237492,
  1459618226,
  1118872680,
  -974630912,
  -2097151543,
  -1114829628,
  110830,
  -169322669,
  -2097151450,
  -1065023292,
  703139444,
  1459618119,
  7345128,
  147096320,
  -1292991091,
  -397410303,
  23652,
  -2063285117,
  -1087736384,
  5026360,
  -218117757,
  735180718,
  -1949201415,
  -289567241,
  -1056964175,
  -1510800663,
  -511456629,
  -1952124157,
  1304564789,
  10414336,
  -2097152000,
  -1924135740,
  1746150468,
  4370580,
  -917837744,
  -998047743,
  -293237492,
  -1929379408,
  1343235148,
  -1333499823,
  2087190594,
  -16760144,
  1304563733,
  -1922438400,
  1378886740,
  1118858344,
  434655232,
  -1090518583,
  5026360,
  872401283,
  214205376,
  -772296974,
  -1785857749,
  111086,
  -141835893,
  -1785857397,
  111342,
  -217912895,
  868780965,
  65110976,
  952083699,
  -2097132366,
  -1359806519,
  -114568713,
  -141835893,
  -373163381,
  -1952058622,
  65110984,
  898344179,
  5095956,
  -1326545523,
  -1924136959,
  16449669,
  1080578048,
  -402636112,
  116536,
  -1962097533,
  921626829,
  -846528512,
  3647464,
  446531840,
  -16776960,
  -1194816554,
  -858993459,
  -356392457,
  513116419,
  -16776960,
  -1194292266,
  -858993459,
  -356392201,
  278235395,
  -16776961,
  -1194816554,
  -858993459,
  -356392457,
  345344259,
  -16776961,
  -1194292266,
  -858993459,
  -356392201,
  177048835,
  855638272,
  412453312,
  -1996488449,
  25598621,
  211650816,
  -1996488449,
  16792221,
  1587382528,
  -1996488449,
  16737949,
  -1996388096,
  1099498561,
  205621512,
  -1399945845,
  -1019543551,
  -1499554423,
  -1651965951,
  65390,
  -1657202828,
  109714,
  1307053950,
  -1728052794,
  -1399669257,
  -347996159,
  -1835693306,
  -1996488276,
  16738965,
  -1948844288,
  -858933048,
  -503853876,
  -1996231999,
  16728725,
  -971053056,
  -125108223,
  29759464,
  -122745088,
  -14369399,
  166199296,
  -1962933818,
  -972887816,
  -1357971455,
  683510264,
  -16776961,
  -1194292266,
  -858993459,
  -356392201,
  -1933053,
  -1988100097,
  16725149,
  747997440,
  -1996488449,
  16726173,
  1016957184,
  1711276287,
  -12542583,
  -1651965952,
  65362,
  -10838647,
  -1651965952,
  65366,
  -14639735,
  -687931392,
  -843528053,
  -137573172,
  8751841,
  -956301061,
  16736901,
  256,
  65716480,
  -1786133702,
  65358,
  490278516,
  4427264,
  -1651964299,
  65378,
  2268473,
  108265473,
  -10314359,
  -1115488256,
  109746,
  -1958054654,
  30672517,
  -1634891008,
  989856166,
  859471304,
  -1983693879,
  27696773,
  -1926332928,
  25599621,
  1754303232,
  -1996488659,
  1821412112,
  -1996488659,
  -897383344,
  206604799,
  -1962389367,
  30672533,
  -1065139968,
  2093628176,
  -846507048,
  2768872,
  983402752,
  -16776960,
  -1194816554,
  -858993459,
  -356392457,
  -1946195453,
  1184205261,
  -1996488449,
  16720029,
  1043785728,
  -1956708352,
  1532845765,
  18924673,
  79822848,
  -1869574144,
  -1869574000,
  1394666627,
  1448466827,
  -15957109,
  -315424768,
  -985926093,
  -1922400681,
  16457859,
  -1163183872,
  1962934700,
  581646655,
  1946157312,
  -1961850057,
  89994,
  2093824768,
  -1766094037,
  -1929379514,
  -1031681780,
  547,
  72305805,
  965294731,
  -1996195189,
  2055931001,
  142182664,
  206736230,
  206670182,
  -2092562293,
  1770587328,
  -61830372,
  20464327,
  -1962934272,
  16714891,
  2096184064,
  176393116,
  989856212,
  990999749,
  1302079493,
  1342796800,
  7313384,
  79987456,
  -1275427957,
  -985989119,
  87757172,
  4427260,
  -11531916,
  1122942997,
  965775360,
  21403307,
  -997978368,
  -16777216,
  1304564757,
  -1194816768,
  -858993459,
  -2087984649,
  119826,
  990112449,
  -1902933563,
  251658566,
  36740,
  12291328,
  -2097151749,
  -1070334007,
  270816397,
  -772296974,
  -731317973,
  -1962917200,
  -1946711103,
  609521146,
  48873748,
  -930372109,
  -511459277,
  -1079708925,
  4370616,
  -218117757,
  735180718,
  -1946711047,
  -2083419142,
  -1359806519,
  -1051735413,
  -1510800663,
  1150143115,
  -511503324,
  -1527558141,
  29864936,
  -2081387776,
  -180680508,
  -1953815948,
  83602,
  1184273291,
  1364590593,
  -397274518,
  116916,
  1443939459,
  29727720,
  79987456,
  1184269195,
  -397410303,
  28332,
  1594147971,
  -2091164322,
  -1866260284,
  17886337,
  1431502848,
  1475447638,
  -2036679039,
  67108865,
  -1928396800,
  469,
  -1396275573,
  1284308993,
  -1924132828,
  1360798804,
  472138893,
  613714770,
  308,
  673467533,
  612666192,
  308,
  177113937,
  1375732180,
  -571977392,
  -1962934188,
  -1958992828,
  -2093472692,
  -1053089596,
  1418399861,
  1284183076,
  -784658396,
  25134095,
  -1903493120,
  99994,
  1711595969,
  -1708030839,
  -1962933946,
  25598614,
  1149986304,
  -490662876,
  -2071370236,
  21404722,
  -1701934336,
  1711276422,
  405034123,
  1711595969,
  -1640917879,
  -1962933946,
  25598598,
  1284204032,
  1778716708,
  -1056964588,
  -1989802784,
  -1769263092,
  99994,
  612666214,
  300,
  1711596225,
  -1573747575,
  -1962933946,
  25598606,
  -1769249280,
  65344,
  1711595969,
  -1540254583,
  1711276358,
  -12548353,
  369033216,
  5095956,
  -843528053,
  -137573172,
  -1702458399,
  855638406,
  65716717,
  -2130386751,
  -30,
  815040895,
  83622,
  -2036691317,
  -507445247,
  608486916,
  -1802690272,
  21404209,
  830769920,
  83610,
  556024969,
  -1996207477,
  -1960500148,
  1149831234,
  -2037700316,
  109906,
  -2062792053,
  608995776,
  -1957855699,
  16714886,
  -2049232128,
  -1926529344,
  16457918,
  -1961915648,
  -1065011135,
  6950517,
  606360717,
  -397274774,
  50912,
  -15956341,
  -2092761088,
  -667220793,
  227269500,
  4427256,
  27781096,
  1384549120,
  1157628333,
  -1283659717,
  -15956341,
  -617414656,
  729727109,
  -81740147,
  260767744,
  -2059910773,
  1779332544,
  608472321,
  1343318564,
  13013992,
  210144000,
  1124073727,
  990168963,
  -2392872,
  25598598,
  1566465792,
  281313627,
  -1040187391,
  -1869610996,
  5521592,
  -942217216,
  -1957494783,
  -1400154663,
  5524516,
  579046144,
  1442840832,
  -2081017001,
  -969146417,
  14648335,
  -1153892352,
  109622,
  13862159,
  -1288110080,
  65292,
  13075727,
  -1786052608,
  539,
  -1945119173,
  185,
  1487932811,
  -1070399411,
  66683721,
  620701815,
  1076019341,
  2142583040,
  1946157058,
  957541145,
  162741,
  -351308800,
  2008365320,
  1946157058,
  112645,
  -969211904,
  -1114800268,
  375,
  872401283,
  915638720,
  -234880596,
  735180718,
  -829190663,
  -1962933840,
  -1946711103,
  609521146,
  48873764,
  -930372109,
  -217849469,
  462261156,
  1358954498,
  1118868584,
  300438016,
  -1962933822,
  1304563773,
  214205184,
  -1326533747,
  1150091265,
  1347822628,
  1118902376,
  -1334024192,
  -671154110,
  24610189,
  1347813376,
  1118900328,
  -1334024192,
  -671154110,
  872402819,
  595955190,
  -1929379838,
  150925,
  608471296,
  -1995404516,
  72387345,
  -1962651255,
  1367935056,
  1725051656,
  1712078987,
  -1962131063,
  16714891,
  -595227392,
  -1996488704,
  -81753172,
  -1953824768,
  65292,
  210471233,
  -1996488449,
  277421149,
  -1996205943,
  1351157840,
  273713420,
  340822374,
  -326776986,
  268435456,
  -1263171289,
  -1996488704,
  73653,
  599099648,
  -1996488703,
  75701,
  1673365760,
  -1962934270,
  28074635,
  -1064466176,
  -1996488704,
  201141,
  -726300416,
  -1996488704,
  55477,
  1606256896,
  -1962934271,
  16786051,
  264649472,
  52868,
  465406720,
  989855746,
  -1064562690,
  -1962934272,
  21402243,
  -1768715520,
  855638342,
  -2050323466,
  957120192,
  -2096597959,
  994448065,
  1005878512,
  1078425072,
  16777320,
  -1836873472,
  -1929379514,
  -523124732,
  1978159696,
  -1929379736,
  -2088110580,
  83606,
  35362187,
  -998047744,
  -1981689588,
  -1819606764,
  83606,
  1284358195,
  25756689,
  -1996209783,
  -1989801919,
  -1249309631,
  351,
  1184269195,
  344784897,
  1346670070,
  609520388,
  -1949791460,
  -1959622351,
  1921582193,
  141658884,
  856191625,
  1233872630,
  1250518540,
  -1928819956,
  143765,
  831359232,
  -1962934270,
  1250493512,
  138971908,
  1711819401,
  1712078987,
  957104777,
  28097203,
  -2054287616,
  -1962934272,
  857482364,
  -2054592832,
  549,
  36275593,
  -1989804032,
  763726087,
  1711276034,
  36144521,
  -1249181696,
  539,
  1484582971,
  3838859,
  -801439743,
  -1953679234,
  65598,
  175386937,
  314671936
}; // idb
void locret_408300; // idb
int HackedRecvFrom = -290970113; // idb
_UNKNOWN loc_4159B8; // weak
double dbl_42A000 =  100.0; // weak
double dbl_42A008 =  0.1; // weak
float flt_42A010 =  0.0; // weak
float flt_42A014 =  100.0; // weak
_UNKNOWN unk_42A128; // weak
_UNKNOWN unk_42A140; // weak
char aServer_cfg[11] = "server.cfg"; // weak
int dword_42B534 = 1; // weak
int dword_42D860 = 1; // weak
void *off_42EA3C = &unk_444150; // weak
const CHAR lpfnFixFunctionArray_lpfnFixExport0 = '\x90'; // idb
int (__stdcall *lpfnFixExport1)(_DWORD, _DWORD) = &fix_04; // weak
char lpfnFixExport2[] = { '\x10', ';', '\x01', '\x10' }; // idb
int (*lpfnFixExport5)() = &Fix_PlayerInit; // weak
int lpfnFixExport6 = 268516928; // idb
int (__stdcall *lpfnFixExport8)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_100150F0; // weak
int (__stdcall *lpfnFixExport9)(_DWORD, _DWORD, _DWORD) = &sub_10015120; // weak
int (__thiscall *lpfnFixExport11)(_DWORD, _DWORD, _DWORD) = &fix_PacketHandler; // weak
int (__stdcall *lpfnFixExport12)(_DWORD, _DWORD) = &sub_10014CC0; // weak
int (__stdcall *lpfnFixExport13)(_DWORD) = &sub_10012E80; // weak
int (__thiscall *lpfnFixExport14)(_DWORD, _DWORD) = &sub_10012C40; // weak
int (*lpfnFixExport15)(void) = &sub_100151C0; // weak
int (*lpfnFixExport18)(void) = &sub_10015390; // weak
int (__thiscall *lpfnFixExport19)(_DWORD) = &sub_10015450; // weak
int (__thiscall *lpfnFixExport20)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_10013980; // idb
int rand_seed = 1; // weak
_UNKNOWN unk_42F788; // weak
int (*off_42FA24)(void) = &sub_422060; // weak
int dword_431C8C = 1; // weak
int dword_431D20 = -1; // weak
int dword_431D24 = 0; // weak
int dword_431D28 = 0; // weak
int dword_431D30 = -1; // weak
int dword_431D34 = 0; // weak
int dword_431D38 = 0; // weak
_UNKNOWN unk_432150; // weak
_UNKNOWN unk_432168; // weak
int dword_432780 = -1; // weak
HANDLE hConsoleHandle = (HANDLE)0xFFFFFFFE; // idb
CHAR Default = '\0'; // idb
int dwAdvertise_SendMode = 0; // weak
char lpszDirectory_IP[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
CHAR Filename[256]; // idb
int dword_432AA8; // idb
int dword_432AAC[255]; // idb
_UNKNOWN unk_432EA8; // weak
_UNKNOWN unk_432EB0; // weak
int dwMisc_DisableSharewareShips; // weak
int dwDirectory_Port; // idb
int dword_432ED8; // weak
void *buf; // idb
int buf_sz[170]; // idb
struct BILLING_SERVER_STRUCT *FindMeOut1; // idb
int nArenas; // idb
int dword_4332E8; // weak
int dwArena_ArenaMinimumPlayers; // weak
_UNKNOWN unk_4332F0; // weak
int bRecycleServer; // weak
char byte_4332F8; // idb
LPCSTR lpFileName; // idb
int dword_438DFC; // idb
int bArena_SpawnKeepScore; // weak
int dwPermission_AllowBadMachineID; // weak
CHAR aServerIni; // idb
int dword_438F08; // weak
int dwBilling_AttemptTime; // weak
char lpszDirectory_NamePassword[]; // idb
int dwComms_MaxQueueToLogIn; // weak
int dword_438F94; // weak
int bServerIsRunning; // weak
int dword_438FA0; // idb
int dword_438FA4[255]; // idb
int dwArena_ArenaMaxPlayers; // weak
char dwComms_PacketHistoryMax; // idb
char lpszPassword_SupermoderatorPassword[]; // idb
char lpszPassword_ModeratorPassword[]; // idb
int dwMisc_MaxSharewarePlayers; // weak
struct_ArenaSettings ArenaSettings; // idb
int dword_4399C4; // weak
char lpsz_Billing_Password[]; // idb
int dword_4399E8; // weak
int dword_4399F0[256]; // idb
int dwBilling_Port; // weak
void *memory; // idb
int dwMisc_LogPoints; // weak
int dword_439DFC; // idb
int dword_439E00; // weak
int dwCPU_SlowIterationWarningLevel; // weak
int dwArena_MaxArenasMemory; // weak
int dwPermission_PermissionMode; // weak
int dwComms_EncryptMode; // weak
int dword_439E14; // idb
char lpszPassword_VIPPassword[]; // idb
int dword_439E58; // idb
void *dword_439E60; // idb
int dwMisc_MaxPlayers; // weak
int dwBilling_ReconnectTime; // weak
int dwPermission_MininumSecondsToLogin; // weak
char dword_439E70[32]; // idb
char byte_439E90; // idb
int dword_439EB8; // weak
int dword_439EBC; // weak
char byte_439EC0; // idb
char byte_439FC0[]; // weak
char byte_439FC1[41359]; // idb
char lpszPassword_EnergyPassword[]; // idb
int dwPermission_PermissionMaxPoints; // weak
int dword_4AD72C; // idb
int dwBilling_GroupID; // idb
int dwBilling_ServerID; // idb
int dword_4AD738[]; // weak
int dword_4AD73C[]; // weak
int dword_4AD740[]; // weak
_UNKNOWN unk_4AD744; // weak
int dwMisc_KeepAliveDelay; // weak
int dword_4B061C; // weak
CHAR szSysopPassword[60]; // idb
DWORD dwZonePopulation; // idb
DWORD dwCPU_SleepTime; // idb
int dword_4B0668[256]; // idb
char lpsz_Directory_Description[]; // idb
CHAR lpszIP_Billing; // idb
int dword_4B0BE8; // weak
int dword_4B0BEC; // weak
char byte_4B0C01[103975]; // idb
int dword_4CA228; // weak
int dword_4CA22C; // weak
int PlayerArray2[]; // weak
_UNKNOWN unk_4CA234; // weak
int dwCPU_SleepPerIteration; // weak
CHAR aMisc_DefaultLevelFile; // idb
const CHAR FileName; // idb
char lpszPermission_AutoPermissionMessage[]; // idb
int wServerPort; // idb
int dwMisc_PointUpdateDiff; // weak
char lpszPermission_AutoPermissionIDList[]; // idb
int dwBilling_LogMessages; // weak
int dword_4CBB04; // weak
int dword_4CBB08[]; // weak
int dword_4CBB0C[]; // weak
int dword_4CBB10[]; // weak
int dword_4CBB14[]; // weak
int dword_4CBB18[]; // weak
int dword_4CBB1C[]; // weak
int dword_4CBB20[]; // weak
int dword_4CBB24[]; // weak
int dword_4CBB28[]; // weak
int dword_4CCAC4[]; // weak
int dword_4CCAC8[]; // weak
int dword_4CCAE4; // weak
int dwCustom_ArenaMode; // weak
PLAYER *PlayerArray; // idb
_UNKNOWN unk_4D6858; // weak
_UNKNOWN unk_4D6870; // weak
int dwMisc_ServerLog; // weak
int dword_4D68C0; // weak
int dwMisc_MaxSharewareTime; // weak
int dwMisc_MenuKickoutDelay; // weak
int dword_4D68CC; // idb
int ArenaArray[]; // weak
int dwPermission_AllowLowBandwidth; // weak
int dwCPU_ProcessMaxTime; // weak
int dwArena_MaxArenas; // weak
int dwMisc_JackpotBroadcastPoints; // weak
int dwMisc_RegisterKickShareware; // weak
int dword_4D6C04; // weak
int dwMisc_DisableShareware; // weak
int dwComms_IncomingBufferSize; // idb
int dword_4D6C10; // weak
_UNKNOWN unk_4D6C14; // weak
int dwArena_ArenaDesiredPlayers; // weak
int dword_4D6C20[]; // weak
int dwAdvertise_Duration; // weak
int dwBilling_ScoreID; // idb
int big_global_buffer; // idb
int dwComms_OutgoingBufferSize; // idb
const CHAR lpsz_Billing_ServerName; // idb
WORLD *lpPingSocket; // idb
void *dwServerSocket; // idb
int dword_4D9CB8; // weak
CHAR ShutdownSpawnCmdLine[256]; // idb
int dword_4D9DC0; // idb
int dword_4D9DC4; // idb
int dwAdvertise_DisplayMode; // weak
int nPlayerArray2; // weak
int dwMisc_DisableSharewareScores; // weak
int numTemplateSSSEntriesCount; // weak
DWORD sz; // idb
LPCSTR dwComms_TransportBufferSize; // idb
int dword_4D9DE0; // weak
int dword_4D9DE4; // weak
int dword_4D9DE8; // weak
int highestNumSharewareAdsCount; // weak
int highestNumRegisteredAdsCount; // weak
int dword_4D9DF4; // weak
int pFILE_points_log; // weak
int pFILE_subgame_log; // weak
int dword_4D9E08; // weak
int dword_4D9E28; // weak
int dword_4D9E34; // weak
int (*dword_4D9ECC)(void); // weak
int dword_4D9F08; // weak
struct _TIME_ZONE_INFORMATION stru_4D9F10; // idb
_UNKNOWN unk_10019D40; // weak
_UNKNOWN unk_10019D9A; // weak
_UNKNOWN unk_10019DE8; // weak
_UNKNOWN unk_10019E00; // weak
_UNKNOWN unk_1001A105; // weak
_UNKNOWN unknown_libname_67; // weak
_UNKNOWN loc_1001C9D0; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD) = (int (__stdcall *)(_DWORD))0x22984; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetLocalTime)(_DWORD) = (int (__cdecl *)(_DWORD))0x22992; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x229B0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x229BC; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_CreateFileA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x229CE; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadReadPtr)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x229DC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD) = (int (__cdecl *)(_DWORD))0x22A1A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileSize)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22A2A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22A38; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_DeleteFileA)(_DWORD) = (int (__stdcall *)(_DWORD))0x22A54; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22A82; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileTime)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22A9C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD) = (int (__stdcall *)(_DWORD))0x22AE8; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22AF4; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_Sleep)(_DWORD) = (int (__cdecl *)(_DWORD))0x22B6C; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22BA0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x22BB0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x22BBE; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD) = (int (__stdcall *)(_DWORD))0x22BCE; // weak
int (*FIX_DLL_KERNEL32_dll_GetVersion)(void) = (int (*)(void))0x22C48; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD) = (int (__cdecl *)(_DWORD))0x22C56; // weak
int (*FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency)(void) = (int (*)(void))0x22C70; // weak
int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA = 142476; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_WriteProcessMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22CC0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_OpenProcess)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22CD6; // weak
int (*FIX_DLL_KERNEL32_dll_GetCurrentProcessId)(void) = (int (*)(void))0x22CE4; // weak
int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD) = (int (__fastcall *)(_DWORD, _DWORD))0x22CFA; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x23080; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x2306E; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x2305E; // weak
int (*FIX_DLL_KERNEL32_dll_GetOEMCP)(void) = (int (*)(void))0x23052; // weak
int (*FIX_DLL_KERNEL32_dll_GetACP)(void) = (int (*)(void))0x23048; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x2303C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x23010; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeW)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22FFE; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22FEC; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadCodePtr)(_DWORD) = (int (__stdcall *)(_DWORD))0x22FDC; // weak
int (__thiscall *FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA)(_DWORD) = (int (__thiscall *)(_DWORD))0x23092; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadWritePtr)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22FCC; // weak
int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW)(void) = (int (*)(void))0x22FB2; // weak
int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStrings)(void) = (int (*)(void))0x22F9A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW)(_DWORD) = (int (__cdecl *)(_DWORD))0x22F80; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22F66; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetStartupInfoA)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F54; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileType)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F46; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_SetHandleCount)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F34; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x22F26; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapCreate)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22F18; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F0A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetVersionExA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22EFA; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22EE0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22ECC; // weak
int (__thiscall *FIX_DLL_KERNEL32_dll_GetStdHandle)(_DWORD) = (int (__thiscall *)(_DWORD))0x22EBC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LoadLibraryA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22EAC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetProcAddress)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x22E9A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_ExitProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D62; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_TerminateProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D70; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetCurrentProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D84; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_RaiseException)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22D98; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD) = (int (__stdcall *)(_DWORD))0x22DAA; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetSystemTime)(_DWORD) = (int (__cdecl *)(_DWORD))0x22DC4; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22DE6; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E10; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E26; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E3C; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E4C; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_HeapReAlloc)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22E5C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x22E6A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_HeapSize)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22E76; // weak
int dword_1002122C[384] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  270598144,
  811802690,
  1353007236,
  1894211782,
  -1859550968,
  -1318346422,
  -777141876,
  -235937330,
  34607665,
  575812211,
  1117016757,
  1658221303,
  -2095541447,
  -1554336901,
  -1013132355,
  -471927809,
  876815458,
  335610912,
  1959224550,
  1418020004,
  -1253333654,
  -1794538200,
  -170924562,
  -712129108,
  645019219,
  103814673,
  1727428311,
  1186223765,
  -1485129893,
  -2026334439,
  -402720801,
  -943925347,
  1491421380,
  2024237190,
  409012288,
  941828098,
  -638727732,
  -105911922,
  -1721136824,
  -1188321014,
  1255430901,
  1788246711,
  173021809,
  705837619,
  -874718211,
  -341902401,
  -1957127303,
  -1424311493,
  2089249958,
  1556434148,
  1006840866,
  474025056,
  -40899154,
  -573714964,
  -1123308246,
  -1656124056,
  1857453719,
  1324637909,
  775044627,
  242228817,
  -272695393,
  -805511203,
  -1355104485,
  -1887920295,
  -2119593592,
  -1578389046,
  -1053961972,
  -512757426,
  10555520,
  551760066,
  1076187140,
  1617391686,
  -1818721351,
  -1277516805,
  -753089731,
  -211885185,
  311427761,
  852632307,
  1377059381,
  1918263927,
  -1513376278,
  -2054580824,
  -447744658,
  -988949204,
  616772834,
  75568288,
  1682404454,
  1141199908,
  -1208309797,
  -1749514343,
  -142678177,
  -683882723,
  921839315,
  380634769,
  1987470935,
  1446266389,
  -915547828,
  -382732018,
  -1981179448,
  -1448363638,
  1214601284,
  1747417094,
  148969664,
  681785474,
  -614675587,
  -81859777,
  -1680307207,
  -1147491397,
  1515473525,
  2048289335,
  449841905,
  982657715,
  -317719250,
  -850535060,
  -1383350870,
  -1916166680,
  1812429862,
  1279614052,
  746798242,
  213982432,
  -12652769,
  -545468579,
  -1078284389,
  -1611100199,
  2117496343,
  1584680533,
  1051864723,
  519048913
}; // idb
char byte_1002182C[256] =
{
  '\0',
  '^',
  '',
  '',
  'a',
  '?',
  '\xDD',
  '\x83',
  '',
  '\x9C',
  '~',
  ' ',
  '',
  '\xFD',
  '\x1F',
  'A',
  '\x9D',
  '',
  '!',
  '\x7F',
  '\xFC',
  '',
  '@',
  '\x1E',
  '_',
  '\x01',
  '',
  '',
  '>',
  '`',
  '\x82',
  '\xDC',
  '#',
  '}',
  '\x9F',
  '',
  'B',
  '\x1C',
  '\xFE',
  '',
  '',
  '',
  ']',
  '\x03',
  '',
  '\xDE',
  '<',
  'b',
  '',
  '',
  '\x02',
  '\\',
  '',
  '\x81',
  'c',
  '=',
  '|',
  '\"',
  '',
  '\x9E',
  '\x1D',
  'C',
  '',
  '\xFF',
  'F',
  '\x18',
  '',
  '',
  '\'',
  'y',
  '\x9B',
  '',
  '\x84',
  '',
  '8',
  'f',
  '',
  '',
  'Y',
  '\a',
  '\xDB',
  '',
  'g',
  '9',
  '',
  '',
  '\x06',
  'X',
  '\x19',
  'G',
  '',
  '',
  'x',
  '&',
  '',
  '\x9A',
  'e',
  ';',
  '',
  '\x87',
  '\x04',
  'Z',
  '',
  '',
  '',
  '',
  '\x1B',
  'E',
  '',
  '\x98',
  'z',
  '$',
  '',
  '',
  'D',
  '\x1A',
  '\x99',
  '',
  '%',
  '{',
  ':',
  'd',
  '\x86',
  '',
  '[',
  '\x05',
  '',
  '',
  '\x8C',
  '',
  '0',
  'n',
  '',
  '',
  'Q',
  '\x0F',
  'N',
  '\x10',
  '',
  '',
  '/',
  'q',
  '',
  '',
  '\x11',
  'O',
  '',
  '',
  'p',
  '.',
  '',
  '',
  '',
  '\x8D',
  'o',
  '1',
  '',
  '',
  '\x0E',
  'P',
  '',
  '',
  '\x13',
  'M',
  '',
  '\x90',
  'r',
  ',',
  'm',
  '3',
  '',
  '\x8F',
  '\f',
  'R',
  '',
  '',
  '2',
  'l',
  '\x8E',
  '',
  'S',
  '\r',
  '',
  '',
  '',
  '',
  'L',
  '\x12',
  '',
  '',
  '-',
  's',
  '',
  '',
  'v',
  '(',
  '',
  '',
  '\x17',
  'I',
  '\b',
  'V',
  '',
  '',
  'i',
  '7',
  '',
  '\x8B',
  'W',
  '\t',
  '',
  '',
  '6',
  'h',
  '\x8A',
  '',
  '',
  '',
  ')',
  'w',
  '',
  '',
  'H',
  '\x16',
  '',
  '',
  'U',
  '\v',
  '\x88',
  '',
  '4',
  'j',
  '+',
  'u',
  '',
  '',
  'J',
  '\x14',
  '',
  '',
  't',
  '*',
  '',
  '',
  '\x15',
  'K',
  '',
  '',
  '',
  '',
  '\n',
  'T',
  '',
  '\x89',
  'k',
  '5'
}; // idb
void *off_1002192C = &unk_10001210; // weak
void *off_10021930 = &unk_100012E0; // weak
void *off_10021934 = &unk_10001440; // weak
double dbl_10021940 =  1000.0; // weak
double dbl_10021948 =  1.0; // weak
void *off_10021958 = &unk_100170AF; // weak
_UNKNOWN unk_1002197C; // weak
int dword_10021998[] = { 83 }; // weak
_DWORD dword_1002199C[45] =
{
  83,
  83,
  1,
  83,
  83,
  166,
  16,
  83,
  250,
  83,
  333,
  333,
  333,
  333,
  333,
  83,
  83,
  83,
  83,
  83,
  83,
  333,
  1000,
  83,
  1000,
  1000,
  83,
  41,
  333,
  83,
  83,
  83,
  83,
  83,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250
}; // idb
int (__stdcall *off_10021A50)(int, int, int) = &sub_1000B9F0; // weak
void *off_10021A6C = &unk_100170AF; // weak
int (*off_10021A70[2])() = { &sub_1000D170, &sub_1000C480 }; // weak
int (*off_10021A74)() = &sub_1000C480; // weak
double dbl_10021A78 =  0.1; // weak
double dbl_10021A80 =  10.0; // weak
double dbl_10021A88 =  100.0; // weak
int (__stdcall *off_10021A94)(char) = &type_info::`scalar deleting destructor'; // weak
_UNKNOWN unk_10021A98; // weak
_UNKNOWN unk_10021C28; // weak
_UNKNOWN unk_10021C38; // weak
_UNKNOWN unk_10021C50; // weak
_UNKNOWN unk_10021C70; // weak
char byte_10021C80[8] = { '', '\x7F', '\x01', '\x10', '\xDD', '\x7F', '\x01', '\x10' }; // idb
_UNKNOWN unk_10021C88; // weak
char byte_10021CA0[116] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  'n',
  '\0',
  'u',
  '\0',
  'l',
  '\0',
  'l',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  'n',
  'u',
  'l',
  'l',
  ')',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10021D14; // weak
_UNKNOWN unk_10021D18; // weak
_UNKNOWN unk_10021D20; // weak
double dbl_10022018 =  4195835.0; // weak
double dbl_10022020 =  3145727.0; // weak
_UNKNOWN unk_10022090; // weak
_UNKNOWN unk_10022100; // weak
_UNKNOWN unk_10022160; // weak
__TI_flags _TI2_AVfile_exception__ = 0; // weak
_UNKNOWN unk_10022298; // weak
_UNKNOWN unk_10022388; // weak
_UNKNOWN unk_100223B0; // weak
_UNKNOWN unk_100223D8; // weak
_UNKNOWN unk_10022400; // weak
_UNKNOWN unk_10022430; // weak
_UNKNOWN unk_10022468; // weak
_UNKNOWN unk_100224C0; // weak
_UNKNOWN unk_10022510; // weak
_UNKNOWN unk_10022570; // weak
_UNKNOWN unk_100225E0; // weak
_UNKNOWN unk_10022608; // weak
_UNKNOWN unk_10022670; // weak
_UNKNOWN unk_100226D0; // weak
_UNKNOWN unk_10024000; // weak
_UNKNOWN loc_1002402B; // weak
_UNKNOWN unk_10024034; // weak
_UNKNOWN unk_10024048; // weak
_UNKNOWN unk_1002404C; // weak
_UNKNOWN unk_10024054; // weak
_UNKNOWN unk_10024058; // weak
_UNKNOWN unk_10024060; // weak
_UNKNOWN unk_10024084; // weak
char aFalse[6] = { 'f', 'a', 'l', 's', 'e', '\0' }; // weak
_UNKNOWN loc_100240C7; // weak
char byte_100242D8 = '\x01'; // weak
int dword_100243E8 = 1024; // weak
int (*off_10024608)(const char *, ...) = &WriteSubGameLog; // idb
int (__cdecl *off_1002460C)(_DWORD, _DWORD) = &IsFileLastWrittenTime; // weak
int (__cdecl *off_10024610)(_DWORD, _DWORD) = &sub_413B50; // weak
int (__cdecl *off_10024618)(_DWORD) = &efree; // weak
_UNKNOWN unk_1002461C; // weak
char *off_10024650[12] =
{
  "Warbird",
  "Javelin",
  "Spider",
  "Leviathan",
  "Terrier",
  "Weasel",
  "Lancaster",
  "Shark",
  "Repel",
  "Decoy",
  "Burst",
  "Thor"
}; // weak
int dword_1002465C[] = { 268585144 }; // weak
int dword_10024680[] = { 268585072 }; // weak
char *off_100246F8[8] =
{
  "Warbird",
  "Javelin",
  "Spider",
  "Leviathan",
  "Terrier",
  "Weasel",
  "Lancaster",
  "Shark"
}; // weak
int FIX_DLL_Cmd[22] =
{
  268492176,
  268503808,
  268516112,
  268511056,
  268513088,
  268515952,
  268516928,
  268517888,
  268521712,
  268521760,
  268483616,
  268521808,
  268520640,
  268512896,
  268512320,
  268521920,
  268510496,
  268512928,
  268522384,
  268522576,
  268515712,
  268522768
}; // weak
_UNKNOWN unk_10024A20; // weak
_UNKNOWN unk_10024A24; // weak
const char aBanRem[] = "Ban rem"; // idb
_UNKNOWN loc_1002500A; // weak
_UNKNOWN loc_10025018; // weak
void *off_100251F4 = &unk_454956; // weak
char aProcessDebugger[18] = "Process debugger "; // weak
_DWORD dword_10025D60[6] = { 429065504, 0, 0, 0, 268573332, 0 }; // idb
int (*off_10025DCC)(void) = &sub_10016FF7; // weak
int dword_10025DE0 = 1; // weak
int (__cdecl *off_10025DE4)(_DWORD) = &sub_10015F50; // weak
int (*off_10025DF0[2])() = { &sub_10017F9C, &sub_10017F9C }; // weak
int (__cdecl *off_10025DF4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_10017F9C; // weak
int dword_10025DF8 = 268590594; // weak
_DWORD dword_10026004 = 1; // idb
char byte_10026008 = '.'; // weak
int dword_10026010 = 268573964; // weak
int dword_10026014 = 268573948; // weak
FILE stru_10026040 = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
FILE stru_10026060 = { NULL, 0, NULL, 2, 2, 0, 0, NULL }; // idb
int dword_100262A0[] = { 2 }; // weak
int dword_100262A4[] = { 268574676 }; // weak
int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_1001D888; // weak
int (__cdecl *off_10026334)(_DWORD) = &sub_1001D888; // weak
int dword_10026338 = 268556424; // weak
int (__cdecl *off_1002633C)(_DWORD) = &sub_1001D888; // weak
int dword_10026340 = 268556424; // weak
int dword_10026344 = 268556424; // weak
_UNKNOWN unk_10026350; // weak
void *off_10026360 = &off_10026360; // weak
int dword_10026364 = 268591968; // weak
int dword_10026370 = -1; // weak
int dword_10028380 = 268591968; // weak
int dword_10028384 = 480; // weak
_UNKNOWN unk_10028390; // weak
int dword_10028394 = 11; // weak
int dword_10028408 = 3; // weak
int dword_1002840C = 7; // weak
int dword_10028410 = 10; // weak
int dword_10028414 = 140; // weak
int dword_10028450 = 28800; // weak
int dword_10028454 = 1; // weak
int dword_10028458 = -3600; // weak
char *off_100284DC = &unk_1002845C; // idb
char *off_100284E0 = &unk_1002849C; // idb
int dword_100284E8 = -1; // weak
int dword_100284EC = 0; // weak
int dword_100284F0 = 0; // weak
int dword_100284F8 = -1; // weak
int dword_100284FC = 0; // weak
int dword_10028500[] = { 0 }; // weak
int dword_10028504[12] = { -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 }; // idb
int dword_10028534[] = { 365 }; // weak
int dword_10028538[14] = { -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364, 0 }; // idb
char byte_10028570[8] = { '\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_10028578; // weak
int dword_1002857C[] = { -2105965984 }; // weak
int dword_10028588[] = { 57254 }; // weak
_UNKNOWN unk_10028668; // weak
int dword_1002866C[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // idb
_UNKNOWN unk_100287D0; // weak
_UNKNOWN unk_10028930; // weak
char byte_10028A9C[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100290BC; // weak
int dword_10029240; // weak
char byte_10029244; // weak
__int64 qword_10029250; // weak
double dbl_10029258; // weak
double dbl_10029260; // weak
char byte_10029268; // weak
int dword_1002926C; // weak
void unk_10029270; // idb
int dword_100292F0[]; // weak
int dword_100292F4; // weak
int dword_100292F8; // weak
int dword_100292FC; // weak
int dword_10029300; // weak
int dword_10029308; // weak
int dword_1002930C; // weak
int dword_10029310; // weak
int dword_10029318[21504]; // idb
_UNKNOWN unk_1003E318; // weak
_DWORD dword_1003E438[39696]; // idb
int dword_10065078; // weak
int dword_1006507C; // weak
_UNKNOWN unk_10065080; // weak
int dword_100651A0; // weak
int dword_100651A4; // weak
__int16 word_100651A8[]; // weak
int dword_101A51A0; // weak
int dword_101A51A8; // weak
int dword_101A52E8; // weak
int dword_101A52F0; // weak
_UNKNOWN unk_101A52F4; // weak
_UNKNOWN unk_101A5314; // weak
int dword_101A5334; // weak
int dword_101A5338; // weak
int dword_101A533C; // weak
int dword_101A5340; // weak
int dword_101A5344; // weak
int dword_101A5348; // weak
int dword_101A5350; // weak
int dword_101A5354; // weak
int dword_101A5358; // weak
int dword_101A535C; // weak
int dword_101A5360; // weak
int dword_101A5368[3]; // idb
int dword_101A5374; // weak
int dword_101A5378; // weak
char byte_101A537F; // weak
char byte_101A5380; // weak
char byte_101A5381; // weak
char byte_101A5382; // weak
char byte_101A5383; // weak
char byte_101A5384; // weak
char byte_101A5385; // weak
char byte_101A5386; // weak
char byte_101A5388; // weak
char byte_101A5389; // weak
char byte_101A538A; // weak
char byte_101A538B; // weak
int dword_101A538C; // weak
int dword_101A5394; // weak
int dword_101A5398[]; // weak
int dword_101A539C[4095]; // idb
int dword_101A9398; // weak
char byte_101A939C; // idb
int dword_101A93E0; // weak
char byte_101A93E4[]; // idb
int dword_101A94E8; // weak
int dword_101A94EC; // weak
int dword_101A94F0; // weak
int dword_101A94F8; // weak
int dword_101A9500; // weak
int dword_101A9504; // weak
int dword_101A9508; // weak
void unk_101A9517; // idb
_UNKNOWN unk_101A9718; // weak
int dword_101B0718; // weak
void *dword_101B0720[71]; // idb
char byte_101B083C; // weak
char byte_101B083D[10239]; // idb
char byte_101B303C; // weak
int dword_101B3040; // weak
int dword_101B3044; // weak
int dword_101B3048; // weak
int dword_101B304C; // weak
int dword_101B3050; // weak
char byte_101B3054; // weak
int dword_101B3058; // weak
int dword_101B3060[21504]; // idb
int dword_101C8060; // weak
int dword_101C8064; // weak
int dword_101C8068; // weak
int dword_101C806C; // weak
int dword_101C8070; // weak
int dword_101C8074; // weak
int dword_101C8078; // weak
int dword_101C8090; // weak
int dword_101C8094; // weak
int dword_101C809C; // weak
int dword_101C80A0; // weak
int dword_101C80A4; // weak
int dword_101C80AC; // weak
char byte_101C80B4; // weak
int dword_101C80B8; // weak
int dword_101C80BC; // weak
int dword_101C80C4; // weak
int dword_101C80C8; // weak
int dword_101C80D0; // weak
__int16 word_101C80D6; // weak
__int16 word_101C80D8; // weak
__int16 word_101C80DA; // weak
int dword_101C80E0; // weak
char *dword_101C80E4; // idb
int dword_101C80EC; // weak
int dword_101C80F0; // weak
int dword_101C80F4; // weak
int dword_101C80F8; // weak
int dword_101C80FC; // weak
int (__cdecl *dword_101C8100)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_101C8108; // weak
_UNKNOWN unk_101C810C; // weak
int dword_101C8114; // weak
_DWORD dword_101C8124; // idb
int dword_101C812C; // weak
int dword_101C8130; // weak
int dword_101C8134; // weak
int dword_101C8138; // weak
int dword_101C813C; // weak
int (__cdecl *dword_101C8144)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_101C8148)(void); // weak
int (__cdecl *dword_101C814C)(_DWORD); // weak
int dword_101C8150[]; // weak
int (*dword_101C8158)(void); // weak
_UNKNOWN unk_101C816C; // weak
int dword_101C8270; // weak
int dword_101C8274; // weak
int dword_101C8278; // weak
int (__cdecl *dword_101C827C)(_DWORD); // weak
int dword_101C8280; // weak
int dword_101C8284; // weak
int dword_101C82B8; // weak
int dword_101C82C0; // weak
_UNKNOWN unk_101C82C4; // weak
__int16 word_101C8306; // weak
int dword_101C8314; // weak
_UNKNOWN unk_101C8318; // weak
__int16 word_101C835A; // weak
int dword_101C8368; // weak
char *dword_101C836C; // idb
int dword_101C8370; // weak
int dword_101C8374; // weak
int dword_101C8378; // weak
_DWORD dword_101C837C; // idb
_DWORD dword_101C8380[3]; // idb
int dword_101C838C; // weak
_UNKNOWN unk_101C84A0; // weak
char byte_101C84A1[259]; // idb
int dword_101C85A4; // weak
int dword_101C85AC; // weak
int dword_101C85B0; // weak
void *dword_101C85B8; // idb
int dword_101C85BC; // weak
_DWORD dword_101C85C0; // idb
int dword_101C85C4; // weak
int dword_101C85E0[]; // weak
_UNKNOWN unk_101C85E4; // weak
_DWORD dword_101C86E0; // idb
_DWORD dword_101C86E4; // idb
int dword_101C86E8; // weak
int dword_101C86EC; // weak
int dword_101C9700; // weak
int dword_101C9704; // weak
int (__stdcall *dword_101C9708)(_DWORD, _DWORD, _DWORD); // weak
int dword_101C970C; // weak
int dword_101C9710; // weak
int dword_101C9714; // weak
int dword_101C9718; // weak


//----- (00401000) --------------------------------------------------------
// Arena.Create()
void __userpurge Create(ARENA *a1@<ecx>, char *name, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13)
{
  bool v14; // eax
  DWORD (*v15)(void); // esi
  int v16; // eax
  int v17; // esi
  int v18; // eax
  unsigned int v19; // eax
  LPVOID v20; // eax
  char *v21; // eax
  int v22; // eax
  int v23; // edx
  int v24; // edi
  int v25; // edi
  DWORD v26; // eax
  __int64 v27; // rax
  int v28; // eax
  int v29; // ecx
  char *v30; // eax
  char v31[8]; // [esp+10h] [ebp-120h] BYREF
  CHAR Filename[256]; // [esp+30h] [ebp-100h] BYREF

  *(_DWORD *)&a1->field_1B8DE[6956] = 0;
  *(_DWORD *)a1->field_10026 = 0;
  *(_DWORD *)&a1->field_FF10[32] = 0;
  if ( _strcmpi(name, "server") )
  {
    strncpy(a1->name, name, 0x20u);
    a1->name[31] = 0;
  }
  else
  {
    strcpy(a1->name, "unnamed");
  }
  v14 = dwCustom_ArenaMode > 0 && a1->name[offsetof(ARENA, field_0)];
  v15 = GetTickCount;
  a1->bHasScrFile = v14;
  *(_DWORD *)&a1->field_10026[18028] = 0;
  *(_DWORD *)&a1->field_10026[18032] = 0;
  *(_DWORD *)&a1->field_10026[18024] = GetTickCount() / 0xA;
  *(_DWORD *)a1->gap_FF08 = 0;
  *(_DWORD *)&a1->field_10026[4] = 0;
  *(_DWORD *)&a1->field_10026[8] = 0;
  *(_DWORD *)&a1->field_10026[12] = 0;
  *(_DWORD *)&a1->field_10026[16] = 0;
  if ( a1->bHasScrFile )
  {
    strcpy(v31, a1->name);
    strcat(v31, ".scr");
    v16 = fopen(v31, "rb");
    v17 = v16;
    if ( v16 )
    {
      v18 = _fileno(v16);
      v19 = _filelength(v18);
      *(_DWORD *)&a1->field_10026[18028] = v19 / 0x12;
      v20 = ExpandMemory(0, 18 * (v19 / 0x12), 1);
      *(_DWORD *)&a1->field_10026[18032] = v20;
      fread(v20, 18, *(_DWORD *)&a1->field_10026[18028], v17);
      fclose(v17);
    }
    v15 = GetTickCount;
  }
  memset(a1, 0, 0xFB00u);
  GetModuleFileNameA(0, Filename, 0x100u);
  v21 = strrchr(Filename, 92);
  if ( v21 )
    *v21 = 0;
  else
    Filename[0] = 0;
  if ( a1->bHasScrFile )
  {
    sprintf(a1->szConfigFile, "%s\\%s.cfg", Filename, a1->name);
    sprintf(a1->szLevelFile1, "%s.lvl", a1->name);
    sprintf(a1->szLevelFile2, "%s.lvl", a1->name);
    if ( _access(a1->szConfigFile, 0) )
    {
      sub_415980((int)a1->szConfigFile, (int)name, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
      return;
    }
    if ( !sub_406ED0((int)a1->szLevelFile2) )
    {
      strcpy(a1->szLevelFile1, &aMisc_DefaultLevelFile);
      v15 = GetTickCount;
    }
  }
  else
  {
    sprintf(a1->szConfigFile, "%s\\server.cfg", Filename);
    strcpy(a1->szLevelFile1, &aMisc_DefaultLevelFile);
    strcpy(a1->szLevelFile2, &aMisc_DefaultLevelFile);
    v15 = GetTickCount;
  }
  printf("Arena Created: (%s) using parameters: %s\n", a1->name, a1->szConfigFile);
  LoadArenaSettings_0(a1);
  SomethingThatLoadsZoneMap((struct_ARENA *)a1);
  *(_DWORD *)&a1->field_FF6A[176] = 0;
  *(_DWORD *)&a1->field_FF6A[180] = v15() / 0xA;
  *(_DWORD *)a1->field_FF10 = v15() / 0xA;
  *(_DWORD *)&a1->field_FF10[4] = v15() / 0xA;
  *(_DWORD *)&a1->field_FF10[8] = v15() / 0xA;
  *(_DWORD *)&a1->field_10026[34420] = 0;
  a1->nPlayersHere = 0;
  *(_DWORD *)&a1->field_10026[20] = 0;
  *(_DWORD *)&a1->field_FF10[78] = 0;
  a1->ArenaJackpot = 0;
  *(_DWORD *)&a1->field_FF6A[160] = 0;
  *(_DWORD *)&a1->field_FF6A[164] = 0;
  *(_DWORD *)&a1->field_FF6A[168] = 0;
  *(_DWORD *)&a1->field_FF6A[172] = 0;
  v22 = *(_DWORD *)&a1->field_10026[44136];
  *(_DWORD *)&a1->field_10026[42616] = 0;
  *(_DWORD *)&a1->field_FF6A[4] = 0;
  if ( v22 && *(int *)&a1->field_10026[44140] > 0 )
    v23 = rand() % *(_DWORD *)&a1->field_10026[44140] + 1;
  else
    v23 = *(_DWORD *)&a1->field_10026[44140];
  *(_DWORD *)a1->field_FF6A = v23;
  *(_DWORD *)&a1->field_FF10[50] = v15() / 0xA;
  v24 = rand();
  *(_DWORD *)&a1->field_FF10[20] = rand() * v24;
  v25 = rand();
  *(_DWORD *)&a1->field_FF10[24] = rand() * v25;
  v26 = v15();
  *(_DWORD *)&a1->field_FF10[36] = 0;
  *(_DWORD *)&a1->field_FF10[28] = (v26 / 0xA) & 0x7FFFFFFF;
  *(_DWORD *)&a1->field_FF10[40] = 0;
  *(_DWORD *)&a1->field_FF10[44] = 0;
  *(_WORD *)&a1->field_FF10[48] = 0;
  *(_DWORD *)&a1->field_FF10[66] = 0;
  *(_DWORD *)&a1->field_FF10[74] = 0;
  *(_DWORD *)&a1->field_FF10[70] = 0;
  *(_DWORD *)&a1->field_FF10[16] = 0;
  v27 = 3435973837i64 * v15();
  LOBYTE(v27) = a1->name[0];
  a1->bRecordPointsToLog = 1;
  *(_DWORD *)&a1->field_FF10[62] = HIDWORD(v27) >> 3;
  if ( (_BYTE)v27 && !bArena_SpawnKeepScore )
    a1->bRecordPointsToLog = 0;
  if ( a1->bHasScrFile )
    a1->bRecordPointsToLog = 0;
  if ( *(_DWORD *)&a1->field_10026[44172] == 2 )
  {
    v28 = *(_DWORD *)&a1->field_1B8DE[6952];
    if ( *(_DWORD *)&a1->field_10026[42616] < v28 )
    {
      v29 = 0;
      *(_DWORD *)&a1->field_10026[42616] = v28;
      if ( v28 > 0 )
      {
        v30 = &a1->field_10026[34424];
        do
        {
          *(_DWORD *)v30 = *((_DWORD *)v30 + 2906);
          *((_DWORD *)v30 + 1) = *((_DWORD *)v30 + 2907);
          *((_DWORD *)v30 + 3) = -1;
          *((_DWORD *)v30 + 2) = -1;
          ++v29;
          v30 += 16;
        }
        while ( v29 < *(_DWORD *)&a1->field_1B8DE[6952] );
      }
    }
  }
  ArenaScoreReset(a1, 0);
  *(_DWORD *)&a1->field_10026[20] = 0;
  *(_DWORD *)&a1->field_FF10[54] = v15() / 0xA;
  *(_DWORD *)&a1->field_FF10[16] = 0;
  SoccerGameSomething(a1, -1);
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);
// 438E00: using guessed type int bArena_SpawnKeepScore;
// 4D58B0: using guessed type int dwCustom_ArenaMode;

//----- (00401590) --------------------------------------------------------
void __thiscall ArenaShutdownArena(int this)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  DWORD v10; // kr00_4
  int v11; // eax
  int v12; // eax
  int v13; // esi
  char v14[32]; // [esp+10h] [ebp-20h] BYREF

  v2 = 0;
  if ( *(int *)(this + 65292) > 0 )
  {
    v3 = this + 64288;
    do
    {
      if ( !*(_DWORD *)(this + 109754) )
      {
        if ( *(_DWORD *)(this + 65570) )
        {
          v4 = *(_DWORD *)(*(_DWORD *)v3 + 351);
          if ( v4 >= 0 )
          {
            v5 = *(_DWORD *)v3 + 547;
            v6 = *(_DWORD *)(this + 83606) + 18 * v4 + 4;
            *(_DWORD *)v6 = *(_DWORD *)v5;
            *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 4);
            *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 8);
            *(_WORD *)(v6 + 12) = *(_WORD *)(v5 + 12);
          }
        }
      }
      v7 = *(_DWORD *)v3;
      ++v2;
      v3 += 4;
      *(_DWORD *)(v7 + 28) = 0;
      *(_DWORD *)(*(_DWORD *)(v3 - 4) + 56) = 1;
    }
    while ( v2 < *(_DWORD *)(this + 65292) );
  }
  v8 = *(_DWORD *)(this + 119818);
  if ( v8 && v8 != big_global_buffer )
    efree(*(LPVOID *)(this + 119818));
  v9 = *(_DWORD *)(this + 111610);
  if ( v9 && v9 != dword_438DFC )
    lpfnFixExport13(*(_DWORD *)(this + 111610));
  if ( *(_DWORD *)(this + 83606) )
  {
    v10 = GetTickCount();
    v11 = *(_DWORD *)(this + 119826);
    *(_DWORD *)(this + 83598) = v10 / 0xA;
    if ( v11 )
    {
      strcpy(v14, (const char *)(this + 64256));
      strcat(v14, ".scr");
      v12 = fopen(v14, "wb");
      v13 = v12;
      if ( v12 )
      {
        fwrite(*(_DWORD *)(this + 83606), 18, *(_DWORD *)(this + 83602), v12);
        fclose(v13);
      }
    }
    efree(*(LPVOID *)(this + 83606));
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 42EEC0: using guessed type int (__stdcall *lpfnFixExport13)(_DWORD);

//----- (00401720) --------------------------------------------------------
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team)
{
  int v5; // ebp
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  char *v9; // edi
  int v10; // ebx
  char *v11; // edi
  int v12; // [esp+10h] [ebp-110h] BYREF
  int v13; // [esp+14h] [ebp-10Ch] BYREF
  int v14; // [esp+18h] [ebp-108h] BYREF
  int v15; // [esp+1Ch] [ebp-104h] BYREF
  char buf; // [esp+20h] [ebp-100h] BYREF
  int v17; // [esp+21h] [ebp-FFh]
  int v18; // [esp+25h] [ebp-FBh]
  int v19; // [esp+29h] [ebp-F7h]
  int v20; // [esp+2Dh] [ebp-F3h]

  if ( *(int *)&arenaa->field_10026[34420] < 1024 )
  {
    DoBrickDrop(
      *(char **)&arenaa->field_1B8DE[6956],
      XTiles,
      YTiles,
      &v15,
      &v13,
      &v14,
      &v12,
      *(_DWORD *)&arenaa->field_10026[44192]);
    if ( v15 != v14 || v13 != v12 )
    {
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18036] = v15;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18038] = v13;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18040] = v14;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18042] = v12;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18044] = Team;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18046] = (*(_WORD *)&arenaa->field_FF10[48])++;
      v5 = 0;
      *(_DWORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18048] = (GetTickCount() / 0xA) & 0x7FFFFFFF;
      v6 = 16 * *(_DWORD *)&arenaa->field_10026[34420];
      buf = 33;
      v17 = *(_DWORD *)&arenaa->field_10026[v6 + 18036];
      v18 = *(_DWORD *)&arenaa->field_10026[v6 + 18040];
      v19 = *(_DWORD *)&arenaa->field_10026[v6 + 18044];
      v7 = *(_DWORD *)&arenaa->field_10026[44332];
      v20 = *(_DWORD *)&arenaa->field_10026[v6 + 18048];
      if ( v7 > 0 )
      {
        do
        {
          v8 = 0;
          if ( arenaa->nPlayersHere > 0 )
          {
            v9 = arenaa->PlayerArray;
            do
            {
              if ( !*(_DWORD *)(*(_DWORD *)v9 + 56) )
                PlayerSendPacket(*(PLAYER **)v9, &buf, 17, 0);
              ++v8;
              v9 += 4;
            }
            while ( v8 < arenaa->nPlayersHere );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)lpFileName);
          ++v5;
        }
        while ( v5 < *(_DWORD *)&arenaa->field_10026[44332] );
      }
      v10 = 0;
      if ( arenaa->nPlayersHere > 0 )
      {
        v11 = arenaa->PlayerArray;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v11 + 56) )
            PlayerSendPacket(*(PLAYER **)v11, &buf, 17, 1);
          ++v10;
          v11 += 4;
        }
        while ( v10 < arenaa->nPlayersHere );
      }
      ++*(_DWORD *)&arenaa->field_10026[34420];
    }
  }
}

//----- (00401920) --------------------------------------------------------
// a player is entering an arena for the first time
points_data *__thiscall ArenaAddPlayer(ARENA *arena, PLAYER *p)
{
  int playerUserId; // edx
  int makeIntoArenaOwner; // eax
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  _DWORD *i; // ecx
  int v10; // eax
  char *v11; // eax
  int v12; // ecx
  int v13; // eax
  points_data *v14; // edi
  int v15; // eax
  int v16; // esi
  int v17; // edx
  char *v18; // ecx
  int v19; // eax
  int v20; // esi
  int v21; // ecx
  int v22; // edx
  char *v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // esi
  char *v27; // ecx
  char *v28; // eax
  int v29; // edx
  __int16 v30; // di
  int v31; // edi
  char *v32; // esi
  __int16 v33; // cx
  __int16 v34; // dx
  char *v35; // esi
  int v36; // edx
  int v37; // edi
  char v38; // al
  int v39; // ecx
  int v40; // edx
  char *v41; // eax
  _BOOL1 v42; // cc
  int v43; // eax
  int v44; // eax
  __int16 v45; // ax
  unsigned int v46; // eax
  int v47; // edx
  int v48; // eax
  __int16 v49; // dx
  __int16 v50; // cx
  char v51; // al
  __int16 v52; // dx
  __int16 v53; // ax
  int v54; // ecx
  int v55; // edx
  points_data *result; // eax
  int v57; // edx
  int v58; // ecx
  char *playerName; // [esp-4h] [ebp-5454h]
  char v60; // [esp+13h] [ebp-543Dh] BYREF
  char *v61; // [esp+14h] [ebp-543Ch]
  int v62; // [esp+18h] [ebp-5438h]
  points_data *scoredata; // [esp+1Ch] [ebp-5434h]
  const void *v64; // [esp+20h] [ebp-5430h]
  CHAR String; // [esp+24h] [ebp-542Ch] BYREF
  __int16 v66; // [esp+25h] [ebp-542Bh]
  __int16 v67; // [esp+27h] [ebp-5429h]
  __int16 v68; // [esp+29h] [ebp-5427h]
  __int16 v69; // [esp+2Bh] [ebp-5425h]
  char v70; // [esp+34h] [ebp-541Ch] BYREF
  int v71; // [esp+35h] [ebp-541Bh]
  int v72; // [esp+39h] [ebp-5417h]
  int v73; // [esp+3Dh] [ebp-5413h]
  int v74; // [esp+41h] [ebp-540Fh]
  char v75[3]; // [esp+48h] [ebp-5408h] BYREF
  char v76[20]; // [esp+4Bh] [ebp-5405h] BYREF
  char v77[20]; // [esp+5Fh] [ebp-53F1h] BYREF
  int v78; // [esp+73h] [ebp-53DDh]
  int v79; // [esp+77h] [ebp-53D9h]
  __int16 v80; // [esp+7Bh] [ebp-53D5h]
  __int16 v81; // [esp+7Dh] [ebp-53D3h]
  __int16 v82; // [esp+7Fh] [ebp-53D1h]
  __int16 v83; // [esp+81h] [ebp-53CFh]
  __int16 v84; // [esp+83h] [ebp-53CDh]
  int v85; // [esp+85h] [ebp-53CBh]
  char v86; // [esp+A0h] [ebp-53B0h] BYREF
  __int16 v87; // [esp+A1h] [ebp-53AFh]
  char v88[96]; // [esp+A3h] [ebp-53ADh] BYREF
  char v89[128]; // [esp+104h] [ebp-534Ch] BYREF
  char v90[460]; // [esp+184h] [ebp-52CCh] BYREF
  char buf; // [esp+350h] [ebp-5100h] BYREF
  char v92; // [esp+351h] [ebp-50FFh] BYREF
  char v93; // [esp+1350h] [ebp-4100h] BYREF
  char v94[16639]; // [esp+1351h] [ebp-40FFh] BYREF

  if ( arena->bHasScrFile )
  {
    if ( *(_DWORD *)&arena->field_10026[44048] == -1 && !arena->nPlayersHere )
    {
      playerUserId = p->dwUserID;
      if ( playerUserId >= 0 )
      {
        makeIntoArenaOwner = 0;
        switch ( dwCustom_ArenaMode )
        {
          case 1:
            goto LABEL_11;
          case 2:
            if ( p->bIsModerator )
              goto LABEL_11;
            break;
          case 3:
            if ( p->bIsSmod )
              goto LABEL_11;
            break;
          case 4:
            if ( p->bIsSysop )
LABEL_11:
              makeIntoArenaOwner = 1;
            break;
          default:
            break;
        }
        if ( makeIntoArenaOwner )
        {
          *(_DWORD *)&arena->field_10026[44048] = playerUserId;
          strcpy(arena->szArenaOwner, p->player_name);
          sprintf(&String, "%d", p->dwUserID);
          WritePrivateProfileStringA("Owner", "UserId", &String, arena->szConfigFile);
          WritePrivateProfileStringA("Owner", "Name", p->player_name, arena->szConfigFile);
        }
      }
    }
  }
  scoredata = &p->score;
  *(points_data *)&p->field_231[28] = p->score;
  *(_DWORD *)&arena->PlayerArray[4 * arena->nPlayersHere++] = p;
  p->lpCurrentArena = (int)arena;
  *(_DWORD *)&p->field_44[152] = 0;
  *(_DWORD *)&p->field_44[156] = 0;
  *(_DWORD *)&p->yPixels = 0;
  *(_DWORD *)&p->xPixels = 0;
  *(_DWORD *)&p->field_EA[2] = 0;
  *(_WORD *)&p->field_EA[6] = 0;
  *(_WORD *)&p->field_EA[2] = 10000;
  *(_DWORD *)&p->field_44[112] = 0;
  *(_DWORD *)&p->field_117[8] = 0;
  *(_DWORD *)&p->field_117[12] = 0;
  *(_DWORD *)&p->field_117[16] = 0;
  *(_DWORD *)&p->field_231[50] = -1;
  *(_DWORD *)&p->field_44[124] = *(_DWORD *)&arena->field_10026[44092];
  *(_DWORD *)&p->field_2F9[24] = 0;
  *(_DWORD *)&p->field_44[144] = 0;
  *(_DWORD *)&p->field_44[148] = 0;
  *(_DWORD *)&p->field_117[72] = -1;
  if ( arena->bHasScrFile )
  {
    v5 = p->dwUserID;
    if ( v5 >= 0 )
    {
      v6 = *(_DWORD *)&arena->field_10026[18028];
      v7 = *(_DWORD **)&arena->field_10026[18032];
      v8 = 0;
      for ( i = v7; v8 < v6; ++v8 )
      {
        if ( *i == v5 )
          break;
        i = (_DWORD *)((char *)i + 18);
      }
      if ( v8 == v6 )
      {
        v10 = v6 + 1;
        *(_DWORD *)&arena->field_10026[18028] = v10;
        v11 = (char *)ExpandMemory(v7, 18 * v10, 0x10000);
        *(_DWORD *)&arena->field_10026[18032] = v11;
        *(_DWORD *)&v11[18 * v8] = p->dwUserID;
        v12 = 18 * v8 + *(_DWORD *)&arena->field_10026[18032] + 4;
        *(_DWORD *)v12 = 0;
        *(_DWORD *)(v12 + 4) = 0;
        *(_DWORD *)(v12 + 8) = 0;
        *(_WORD *)(v12 + 12) = 0;
      }
      *(_DWORD *)&p->field_117[72] = v8;
      v13 = *(_DWORD *)&arena->field_10026[18032] + 18 * v8 + 4;
      *scoredata = *(points_data *)v13;
      *(_DWORD *)p->field_231 = *(_DWORD *)v13;
      *(_DWORD *)&p->field_231[4] = *(_DWORD *)(v13 + 4);
      *(_DWORD *)&p->field_231[8] = *(_DWORD *)(v13 + 8);
      *(_WORD *)&p->field_231[12] = *(_WORD *)(v13 + 12);
    }
  }
  if ( *(int *)&arena->field_10026[44180] > 0 )
  {
    v14 = scoredata;
    v15 = 0;
    p->score.losses = 0;
    p->score.points = 0;
    v14->wins = 0;
    p->score.flag_points = 0;
    p->score.flags = 0;
    v16 = p->dwUserID;
    if ( v16 >= 0 )
    {
      v17 = *(_DWORD *)&arena->field_10026[20];
      if ( v17 > 0 )
      {
        v18 = &arena->field_10026[24];
        while ( *(_DWORD *)v18 != v16 )
        {
          ++v15;
          v18 += 18;
          if ( v15 >= v17 )
            goto LABEL_30;
        }
        *(_DWORD *)&v14->wins = *(_DWORD *)&arena->field_10026[18 * v15 + 28];
        *(_DWORD *)&v14->flags = *(_DWORD *)&arena->field_10026[18 * v15 + 32];
        *(int *)((char *)&v14->points + 2) = *(_DWORD *)&arena->field_10026[18 * v15 + 36];
        HIWORD(v14->flag_points) = *(_WORD *)&arena->field_10026[18 * v15 + 40];
      }
LABEL_30:
      if ( v15 == *(_DWORD *)&arena->field_10026[20] )
      {
        *(_DWORD *)&v14->wins = 0;
        *(_DWORD *)&v14->flags = 0;
        *(int *)((char *)&v14->points + 2) = 0;
        HIWORD(v14->flag_points) = 0;
      }
    }
  }
  v19 = *(_DWORD *)&arena->field_10026[44160];
  if ( v19 > 0 && (unsigned __int16)p->score.losses >= v19 )
    p->dwShip = 8;
  if ( !p->bIsModerator )
  {
    v20 = *(_DWORD *)&arena->field_10026[44296];
    if ( v20 > 0 )
    {
      v21 = arena->nPlayersHere;
      v22 = 0;
      if ( v21 > 0 )
      {
        v23 = arena->PlayerArray;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)v23 + 275) != 8 )
            ++v22;
          v23 += 4;
          --v21;
        }
        while ( v21 );
      }
      if ( v22 > v20 )
        p->dwShip = 8;
    }
  }
  if ( dwMisc_DisableSharewareShips )
  {
    if ( *(_DWORD *)&p->field_44[4] )
    {
      v24 = p->dwShip;
      if ( v24 == 5 || v24 == 6 || v24 == 4 || v24 == 7 )
        p->dwShip = 8;
    }
  }
  if ( *(_DWORD *)&arena->field_FF10[78] )
    p->dwShip = 8;
  playerName = p->player_name;
  if ( p->dwShip == 8 )
  {
    printf("Player spectating game: %s\n", playerName);
    *(_DWORD *)p->field_117 = *(_DWORD *)&arena->field_10026[44156];
  }
  else
  {
    printf("Player entering game: %s\n", playerName);
    v25 = j_lpfnFixExport16(arena);
    *(_DWORD *)p->field_117 = v25;
    if ( *(_DWORD *)&arena->field_10026[44200] )
      p->dwShip = v25 % 8;
  }
  PlayerSendPacket(p, &arena->field_10026[42620], 1428, 1);
  if ( *(_DWORD *)&arena->field_10026[44172] == 2 )
  {
    v26 = *(_DWORD *)&arena->field_10026[42616];
    buf = 34;
    v27 = &v92;
    if ( v26 > 0 )
    {
      v28 = &arena->field_10026[34436];
      v29 = v26;
      do
      {
        v30 = *(_WORD *)v28;
        v28 += 16;
        *(_WORD *)v27 = v30;
        v27 += 2;
        --v29;
      }
      while ( v29 );
    }
    PlayerSendPacket(p, &buf, 2 * v26 + 1, 1);
  }
  else
  {
    v31 = 0;
    if ( *(int *)&arena->field_10026[42616] > 0 )
    {
      v32 = &arena->field_10026[34424];
      do
      {
        if ( *((_DWORD *)v32 + 2) == -1 && *(_DWORD *)v32 >= '\0' && *((int *)v32 + 1) >= 0 )
        {
          v33 = *((_WORD *)v32 + 2);
          v34 = *((_WORD *)v32 + 6);
          v67 = *(_WORD *)v32;
          v68 = v33;
          String = 18;
          v69 = v34;
          v66 = v31;
          PlayerSendPacket(p, &String, 9, 1);
        }
        ++v31;
        v32 += 16;
      }
      while ( v31 < *(_DWORD *)&arena->field_10026[42616] );
    }
  }
  v62 = 0;
  memset(v89, 0, sizeof(v89));
  v35 = v90;
  if ( arena->nPlayersHere > 0 )
  {
    v61 = arena->PlayerArray;
    do
    {
      v36 = (int)v61;
      *v35 = 3;
      v37 = *(_DWORD *)v36;
      *(_WORD *)(v35 + 51) = *(_WORD *)(*(_DWORD *)v36 + 20);
      *(_WORD *)(v35 + 59) = *(_WORD *)(v37 + 611);
      v35[2] = *(_BYTE *)(v37 + 615);
      *(_WORD *)(v35 + 53) = *(_WORD *)(v37 + 279);
      v35[1] = *(_BYTE *)(v37 + 275);
      *(_WORD *)(v35 + 55) = *(_WORD *)(v37 + 547);
      *(_WORD *)(v35 + 57) = *(_WORD *)(v37 + 549);
      *(_DWORD *)(v35 + 43) = *(_DWORD *)(v37 + 553);
      *(_DWORD *)(v35 + 47) = *(_DWORD *)(v37 + 557);
      v35[63] = *(_DWORD *)(v37 + 785) != 0;
      strncpy(v35 + 3, (const char *)(v37 + 375), 0x14u);
      v35[22] = 0;
      strncpy(v35 + 23, (const char *)(v37 + 399), 0x14u);
      v38 = arena->field_10026[44004];
      v35[42] = 0;
      *(_WORD *)(v35 + 61) = 0;
      if ( v38 )
      {
        v39 = *(_DWORD *)&arena->field_10026[42616];
        if ( v39 > 0 )
        {
          v40 = *(__int16 *)(v35 + 51);
          v41 = &arena->field_10026[34432];
          do
          {
            if ( *(_DWORD *)v41 == v40 )
              ++*(_WORD *)(v35 + 61);
            v41 += 16;
            --v39;
          }
          while ( v39 );
        }
      }
      v35 += 64;
      if ( (unsigned int)(v35 - v90 + 64) > 0x1CC )
      {
        PlayerSendPacket(p, v90, v35 - v90, 1);
        v35 = v90;
      }
      v42 = ++v62 < arena->nPlayersHere;
      v61 += 4;
    }
    while ( v42 );
  }
  if ( v35 != v90 )
    PlayerSendPacket(p, v90, v35 - v90, 1);
  v43 = arena->nPlayersHere;
  v62 = 0;
  if ( v43 > 0 )
  {
    v61 = arena->PlayerArray;
    do
    {
      v44 = *(_DWORD *)v61;
      if ( *(_DWORD *)(*(_DWORD *)v61 + 553) + *(_DWORD *)(*(_DWORD *)v61 + 557) >= *(_DWORD *)&arena->field_10026[44056]
        || *(_DWORD *)(v44 + 48) )
      {
        v64 = (const void *)(v44 + 423);
        if ( memcmp(v89, (const void *)(v44 + 423), 0x60u) )
        {
          v45 = *(_WORD *)(v44 + 20);
          v86 = 31;
          v87 = v45;
          qmemcpy(v88, v64, sizeof(v88));
          PlayerSendPacket(p, &v86, 99, 1);
        }
      }
      v42 = ++v62 < arena->nPlayersHere;
      v61 += 4;
    }
    while ( v42 );
  }
  v46 = 16 * *(_DWORD *)&arena->field_10026[34420];
  v93 = 33;
  qmemcpy(v94, &arena->field_10026[18036], v46);
  PlayerSendPacket(p, &v93, v46 + 1, 1);
  lpfnFixExport14(arena, p);
  v60 = 2;
  PlayerSendPacket(p, &v60, 1, 1);
  p->xPixels = -9999;
  p->yPixels = -9999;
  v47 = *(_DWORD *)&arena->field_FF10[24];
  v48 = *(_DWORD *)&arena->field_FF10[28];
  v72 = *(_DWORD *)&arena->field_FF10[20];
  v70 = 24;
  v71 = v47;
  v73 = v48;
  v74 = 0;
  PlayerSendPacket(p, &v70, 17, 1);
  v49 = p->field_14;
  v50 = *(_WORD *)p->field_117;
  v75[1] = p->dwShip;
  v51 = p->bFilterObscene;
  v80 = v49;
  v52 = *(_WORD *)&p->field_231[50];
  v75[2] = v51;
  v53 = p->score.losses;
  v81 = v50;
  v83 = v53;
  v84 = v52;
  v54 = p->score.points;
  v82 = scoredata->wins;
  v55 = p->score.flag_points;
  v75[0] = 3;
  v78 = v54;
  v79 = v55;
  v85 = 0;
  strncpy(v76, p->player_name, 0x14u);
  v76[19] = 0;
  strncpy(v77, p->field_18F, 0x14u);
  v77[19] = 0;
  SendEverybodyButYourself(p, v75, 0x40u, 1);
  if ( p->score.points + p->score.flag_points >= *(_DWORD *)&arena->field_10026[44056] || *(_DWORD *)&p->field_2C[4] )
  {
    if ( memcmp(v89, &p->field_18F[24], 0x60u) )
    {
      v87 = p->field_14;
      v86 = 31;
      qmemcpy(v88, &p->field_18F[24], sizeof(v88));
      SendEverybodyButYourself(p, &v86, 0x63u, 1);
    }
  }
  result = scoredata;
  v57 = *(_DWORD *)&scoredata->flags;
  *(_DWORD *)&p->field_231[14] = *(_DWORD *)&scoredata->wins;
  v58 = *(int *)((char *)&result->points + 2);
  *(_DWORD *)&p->field_231[18] = v57;
  LOWORD(v57) = HIWORD(result->flag_points);
  *(_DWORD *)&p->field_231[22] = v58;
  *(_WORD *)&p->field_231[26] = v57;
  return result;
}
// 404530: using guessed type int __thiscall j_lpfnFixExport16(_DWORD);
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 42EEC4: using guessed type int (__thiscall *lpfnFixExport14)(_DWORD, _DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4D58B0: using guessed type int dwCustom_ArenaMode;

//----- (004022D0) --------------------------------------------------------
// Arena.RemovePlayer()
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player)
{
  struct PLAYER *v2; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  char *v8; // edi
  int v9; // ecx
  struct PLAYER **v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  char *v14; // ecx
  int v15; // eax
  _BOOL1 v16; // zf
  int v17; // edi
  int v18; // edx
  int v19; // eax
  char *v20; // ecx
  char *v21; // edx
  char *v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  PLAYER *v26; // eax
  int v27; // edi
  int v28; // eax
  char *v29; // ebp
  char *v30; // ecx
  points_data *v31; // ebx

  v2 = player;
  UpdatePowerBallPositionsSomething(player);
  v4 = *(_DWORD *)&v2->field_44[12];
  v5 = *(_DWORD *)&v2->field_44[16];
  v2->lpCurrentArena = 0;
  if ( v4 >= 0 && v5 >= 0 && v4 < 8 && v5 < 8 )
  {
    v6 = 251 * (v5 + 8 * v4);
    v7 = 0;
    v8 = &arenaa->field_0[4 * v6];
    v9 = *((_DWORD *)v8 + 250);
    if ( v9 > 0 )
    {
      v10 = (struct PLAYER **)v8;
      while ( *v10 != v2 )
      {
        ++v7;
        ++v10;
        if ( v7 >= v9 )
          goto LABEL_11;
      }
      v11 = v9 - 1;
      *((_DWORD *)v8 + 250) = v11;
      *(_DWORD *)&v8[4 * v7] = *(_DWORD *)&v8[4 * v11];
    }
  }
LABEL_11:
  v12 = arenaa->nPlayersHere;
  v13 = 0;
  if ( v12 > 0 )
  {
    v14 = arenaa->PlayerArray;
    while ( *(struct PLAYER **)v14 != v2 )
    {
      ++v13;
      v14 += 4;
      if ( v13 >= v12 )
        goto LABEL_17;
    }
    arenaa->nPlayersHere = v12 - 1;
    memcpy(&arenaa->PlayerArray[4 * v13], &arenaa->PlayerArray[4 * v13 + 4], 4 * (v12 - 1 + 0x3FFFFFFF * v13));
  }
LABEL_17:
  v15 = *(_DWORD *)&arenaa->field_10026[44180];
  v16 = v15 == 0;
  if ( v15 > 0 )
  {
    v17 = v2->dwUserID;
    if ( v17 >= 0 )
    {
      v18 = *(_DWORD *)&arenaa->field_10026[20];
      v19 = 0;
      if ( v18 > 0 )
      {
        v20 = &arenaa->field_10026[24];
        while ( *(_DWORD *)v20 != v17 )
        {
          ++v19;
          v20 += 18;
          if ( v19 >= v18 )
            goto LABEL_25;
        }
        v21 = &arenaa->field_10026[18 * v19 + 28];
        *(_DWORD *)v21 = *(_DWORD *)&v2->score.wins;
        *((_DWORD *)v21 + 1) = *(_DWORD *)&v2->score.flags;
        *((_DWORD *)v21 + 2) = *(int *)((char *)&v2->score.points + 2);
        *((_WORD *)v21 + 6) = HIWORD(v2->score.flag_points);
      }
LABEL_25:
      if ( v19 == *(_DWORD *)&arenaa->field_10026[20] && v19 < 1000 )
      {
        v22 = &arenaa->field_0[18 * v19];
        *(_DWORD *)(v22 + 65598) = v2->dwUserID;
        v22 += 65602;
        *(_DWORD *)v22 = *(_DWORD *)&v2->score.wins;
        *((_DWORD *)v22 + 1) = *(_DWORD *)&v2->score.flags;
        *((_DWORD *)v22 + 2) = *(int *)((char *)&v2->score.points + 2);
        *((_WORD *)v22 + 6) = HIWORD(v2->score.flag_points);
        ++*(_DWORD *)&arenaa->field_10026[20];
      }
    }
    v16 = *(_DWORD *)&arenaa->field_10026[44180] == 0;
  }
  if ( v16 )
  {
    if ( arenaa->bHasScrFile )
    {
      v23 = *(_DWORD *)&v2->field_117[72];
      if ( v23 >= 0 )
      {
        v24 = *(_DWORD *)&arenaa->field_10026[18032] + 18 * v23 + 4;
        *(_DWORD *)v24 = *(_DWORD *)&v2->score.wins;
        *(_DWORD *)(v24 + 4) = *(_DWORD *)&v2->score.flags;
        *(_DWORD *)(v24 + 8) = *(int *)((char *)&v2->score.points + 2);
        *(_WORD *)(v24 + 12) = HIWORD(v2->score.flag_points);
      }
    }
  }
  if ( v2->bIsSysop )
  {
    v25 = *(_DWORD *)&v2->field_117[92];
    if ( v25 >= 0 )
    {
      v26 = *(&PlayerArray + v25);
      LOWORD(player) = 28;
      if ( v26 )
        PlayerSendPacket(v26, &player, 2, 1);
    }
  }
  if ( nPlayerArray2 > 0 )
  {
    v27 = 0;
    *(_WORD *)((char *)&player + 1) = v2->field_14;
    v28 = arenaa->nPlayersHere;
    LOBYTE(player) = 4;
    if ( v28 > 0 )
    {
      v29 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v29 + 56) )
          PlayerSendPacket(*(PLAYER **)v29, &player, 3, 1);
        ++v27;
        v29 += 4;
      }
      while ( v27 < arenaa->nPlayersHere );
    }
  }
  CarryFlagsSomething(arenaa, *(_DWORD *)&v2->field_14, 0);
  if ( !arenaa->bRecordPointsToLog )
  {
    v30 = &v2->field_231[28];
    v31 = &v2->score;
    *(_DWORD *)&v31->wins = *(_DWORD *)v30;
    *(_DWORD *)&v31->flags = *((_DWORD *)v30 + 1);
    *(int *)((char *)&v31->points + 2) = *((_DWORD *)v30 + 2);
    HIWORD(v31->flag_points) = *((_WORD *)v30 + 6);
  }
}
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (00402560) --------------------------------------------------------
#error "403542: cannot convert to microcode (funcsize=1160)"

//----- (00403F60) --------------------------------------------------------
int __cdecl sub_403F60(int a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)a2 + 553)
       + *(_DWORD *)(*(_DWORD *)a2 + 557)
       - *(_DWORD *)(*(_DWORD *)a1 + 557)
       - *(_DWORD *)(*(_DWORD *)a1 + 553);
}

//----- (00403F90) --------------------------------------------------------
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset)
{
  int v3; // eax
  int v4; // ecx
  char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // ebp
  char *v9; // ebx

  v3 = arenaa->nPlayersHere;
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = arenaa->PlayerArray;
    do
    {
      v6 = *(_DWORD *)v5;
      ++v4;
      v5 += 4;
      *(_DWORD *)(v6 + 192) = *(_DWORD *)&arenaa->field_10026[44092];
      *(_WORD *)(*((_DWORD *)v5 - 1) + 0x225) = 0;
      *(_WORD *)(*((_DWORD *)v5 - 1) + offsetof(PLAYER, score)) = 0;
      *(_DWORD *)(*((_DWORD *)v5 - 1) + 0x229) = 0;
      *(_DWORD *)(*((_DWORD *)v5 - 1) + 0x22D) = 0;
      *(_WORD *)(*((_DWORD *)v5 - 1) + 0x227) = 0;
    }
    while ( v4 < arenaa->nPlayersHere );
  }
  if ( sendScoreReset )
  {
    v7 = arenaa->nPlayersHere;
    v8 = 0;
    LOBYTE(sendScoreReset) = 26;
    *(_WORD *)((char *)&sendScoreReset + 1) = -1;
    if ( v7 > 0 )
    {
      v9 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v9 + 56) )
          PlayerSendPacket(*(PLAYER **)v9, &sendScoreReset, 3, 1);
        ++v8;
        v9 += 4;
      }
      while ( v8 < arenaa->nPlayersHere );
    }
  }
}

//----- (00404050) --------------------------------------------------------
int __thiscall sub_404050(int this, int a2)
{
  int v3; // eax
  __int16 v4; // dx
  int v5; // esi
  __int16 v6; // ax
  __int64 v7; // rax
  int v9; // [esp+Ch] [ebp-8h] BYREF
  int v10; // [esp+10h] [ebp-4h] BYREF

  v3 = *(__int16 *)(this + 109490) + *(_DWORD *)(this + 65292) * *(__int16 *)(this + 109492);
  if ( v3 >= 1024 )
    v3 = 1024;
  SomethingWithPrizes((struct ARENA *)this, (int)&v9, (int)&v10, 512, 512, v3 / 2);// 512, 512 are coordinates for middle of map.
  v4 = 16 * v9;
  v5 = 3 * a2 + this + 12 * a2;
  v6 = 16 * v10;
  *(_BYTE *)(v5 + 65394) = a2;
  *(_WORD *)(v5 + 65395) = v4;
  *(_WORD *)(v5 + 65397) = v6;
  *(_WORD *)(v5 + 65399) = 0;
  *(_WORD *)(v5 + 65401) = 0;
  *(_WORD *)(v5 + 65403) = -1;
  v7 = 3435973837i64 * GetTickCount();
  *(_DWORD *)(v5 + 65405) = HIDWORD(v7) >> 3;
  *(_DWORD *)(this + 4 * a2 + 65514) = 0;
  return v7;
}

//----- (00404120) --------------------------------------------------------
int __thiscall sub_404120(int this, int a2)
{
  int result; // eax
  int v4; // esi
  int v5; // ebx
  int v6; // eax
  bool v7; // eax
  int v8; // eax
  __int16 v9; // cx
  __int16 v10; // dx
  int v11; // ebp
  int v12; // eax
  PLAYER **v13; // ebx
  int v14; // [esp+4h] [ebp-10h]
  char buf; // [esp+8h] [ebp-Ch] BYREF
  __int16 v16; // [esp+9h] [ebp-Bh]
  __int16 v17; // [esp+Bh] [ebp-9h]
  __int16 v18; // [esp+Dh] [ebp-7h]
  __int16 v19; // [esp+Fh] [ebp-5h]

  v14 = 0;
  result = *(_DWORD *)(this + 108190);
  if ( result > 0 )
  {
    v4 = this + 99998;
    do
    {
      v5 = *(_DWORD *)v4;
      v7 = 1;
      if ( *(int *)v4 >= 0 )
      {
        v6 = *(_DWORD *)(v4 + 4);
        if ( v6 >= 0 && v5 < 1024 && v6 < 1024 )
          v7 = 0;
      }
      if ( *(_DWORD *)(v4 + 8) == -1 && (a2 || v7) )
      {
        if ( v7 )
        {
          if ( v5 == -1 || !*(_DWORD *)(this + 109758) )
          {
            v8 = *(__int16 *)(this + 109490) + *(_DWORD *)(this + 65292) * *(__int16 *)(this + 109492);
            if ( v8 >= 1024 )
              v8 = 1024;
            SomethingWithPrizes((struct ARENA *)this, v4, v4 + 4, 512, 512, v8 / 2);
          }
          else
          {
            SomethingWithPrizes(
              (struct ARENA *)this,
              v4,
              v4 + 4,
              abs32(v5),
              abs32(*(_DWORD *)(v4 + 4)),
              *(_DWORD *)(this + 109758));
          }
        }
        v9 = *(_WORD *)(v4 + 4);
        v10 = *(_WORD *)(v4 + 12);
        v17 = *(_WORD *)v4;
        v11 = 0;
        v16 = v14;
        v12 = *(_DWORD *)(this + 65292);
        buf = 18;
        v18 = v9;
        v19 = v10;
        if ( v12 > 0 )
        {
          v13 = (PLAYER **)(this + 64288);
          do
          {
            if ( !*(_DWORD *)&(*v13)->field_2C[12] )
              PlayerSendPacket(*v13, &buf, 9, 1);
            ++v11;
            ++v13;
          }
          while ( v11 < *(_DWORD *)(this + 65292) );
        }
      }
      result = v14 + 1;
      v4 += 16;
      ++v14;
    }
    while ( v14 < *(_DWORD *)(this + 108190) );
  }
  return result;
}

//----- (00404280) --------------------------------------------------------
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3)
{
  int v3; // ebx
  int v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // eax
  int v8; // ebp
  int v9; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // edx
  int v14; // eax
  int v15; // edx
  char *v16; // ecx
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = a2;
  if ( a2 >= 0 && arenaa->field_10026[44004] )
  {
    v5 = (int)*(&PlayerArray + a2);
    v6 = -1;
    v7 = -1;
    if ( v5 )
    {
      v8 = *(__int16 *)(v5 + 232) / 16;
      v9 = *(__int16 *)(v5 + 228) / 16;
      if ( *(_DWORD *)&arenaa->field_10026[44188] )
      {
        v17 = 0;
        while ( 1 )
        {
          v10 = *(_DWORD *)&arenaa->field_10026[44188];
          v11 = 2 * (rand() % v10) - v10;
          if ( v11 + v8 > 1 && v11 + v8 < 1024 )
            break;
          if ( ++v17 >= 50 )
            goto LABEL_11;
        }
        v8 += v11;
LABEL_11:
        v18 = 0;
        while ( 1 )
        {
          v12 = *(_DWORD *)&arenaa->field_10026[44188];
          v13 = rand() % (2 * v12) - v12;
          if ( v13 + v9 > 1 && v13 + v9 < 1024 )
            break;
          if ( ++v18 >= 50 )
            goto LABEL_17;
        }
        v9 += v13;
      }
LABEL_17:
      v14 = v9;
      v3 = a2;
      v6 = -abs32(v8);
      v7 = -abs32(v14);
    }
    v15 = 0;
    if ( *(int *)&arenaa->field_10026[42616] > 0 )
    {
      v16 = &arenaa->field_10026[34432];
      do
      {
        if ( *(_DWORD *)v16 == v3 )
        {
          if ( !a3 )
            *((_DWORD *)v16 + 1) = -1;
          *(_DWORD *)v16 = -1;
          *((_DWORD *)v16 - 2) = v6;
          *((_DWORD *)v16 - 1) = v7;
        }
        ++v15;
        v16 += 16;
      }
      while ( v15 < *(_DWORD *)&arenaa->field_10026[42616] );
    }
  }
}

//----- (004043C0) --------------------------------------------------------
// Arena.ResetFlagGame()
void __thiscall ResetFlagGame(struct ARENA *arenaa)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  char *v5; // ecx
  int v6; // edi
  char *v7; // ecx
  char *v8; // eax
  int v9; // edx
  __int16 v10; // bp
  int v11; // ebp
  int v12; // edi
  char *v13; // ebx
  int v14; // eax
  DWORD v15; // kr00_4
  int v16; // eax
  char *v17; // edi
  char v18; // [esp+10h] [ebp-1008h] BYREF
  __int16 v19; // [esp+11h] [ebp-1007h]
  int v20; // [esp+13h] [ebp-1005h]
  char buf; // [esp+18h] [ebp-1000h] BYREF
  char v22; // [esp+19h] [ebp-FFFh] BYREF

  v2 = 0;
  v3 = *(_DWORD *)&arenaa->field_10026[44172];
  arenaa->ArenaJackpot = 0;
  if ( v3 == 2 )
  {
    v4 = 0;
    if ( *(int *)&arenaa->field_10026[42616] > 0 )
    {
      v5 = &arenaa->field_10026[34436];
      do
      {
        *(_DWORD *)v5 = -1;
        ++v4;
        v5 += 16;
      }
      while ( v4 < *(_DWORD *)&arenaa->field_10026[42616] );
    }
    v6 = *(_DWORD *)&arenaa->field_10026[42616];
    buf = 34;
    v7 = &v22;
    if ( v6 > 0 )
    {
      v8 = &arenaa->field_10026[34436];
      v9 = v6;
      do
      {
        v10 = *(_WORD *)v8;
        v8 += 16;
        *(_WORD *)v7 = v10;
        v7 += 2;
        --v9;
      }
      while ( v9 );
    }
    v11 = 2 * v6 + 1;
    v12 = 0;
    if ( arenaa->nPlayersHere > 0 )
    {
      v13 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v13 + 56) )
          PlayerSendPacket(*(PLAYER **)v13, &buf, v11, 1);
        ++v12;
        v13 += 4;
      }
      while ( v12 < arenaa->nPlayersHere );
    }
  }
  else
  {
    v14 = *(_DWORD *)&arenaa->field_10026[44136];
    *(_DWORD *)&arenaa->field_10026[42616] = 0;
    if ( v14 && *(int *)&arenaa->field_10026[44140] > 0 )
      *(_DWORD *)arenaa->field_FF6A = rand() % *(_DWORD *)&arenaa->field_10026[44140] + 1;
    else
      *(_DWORD *)arenaa->field_FF6A = *(_DWORD *)&arenaa->field_10026[44140];
    v15 = GetTickCount();
    v16 = arenaa->nPlayersHere;
    v18 = 20;
    *(_DWORD *)&arenaa->field_FF10[50] = v15 / 0xA;
    v19 = -1;
    v20 = 0;
    if ( v16 > 0 )
    {
      v17 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v17 + 56) )
          PlayerSendPacket(*(PLAYER **)v17, &v18, 7, 1);
        ++v2;
        v17 += 4;
      }
      while ( v2 < arenaa->nPlayersHere );
    }
  }
}

//----- (00404600) --------------------------------------------------------
// Arena.SendPacket()
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4)
{
  int v5; // edi
  char *v6; // esi

  v5 = 0;
  if ( arenaa->nPlayersHere > 0 )
  {
    v6 = arenaa->PlayerArray;
    do
    {
      if ( !*(_DWORD *)(*(_DWORD *)v6 + 56) )
        PlayerSendPacket(*(PLAYER **)v6, buf, len, a4);
      ++v5;
      v6 += 4;
    }
    while ( v5 < arenaa->nPlayersHere );
  }
}

//----- (00404650) --------------------------------------------------------
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius)
{
  int v6; // ebp
  int v7; // ebx
  int v8; // eax
  int v9; // edi
  int v10; // ebp
  struct ARENA *v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  struct ARENA *v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ecx
  char *v31; // eax
  int v33; // [esp+Ch] [ebp-Ch]
  int v34; // [esp+10h] [ebp-8h]
  int v35; // [esp+24h] [ebp+Ch]
  int v36; // [esp+28h] [ebp+10h]
  int v37; // [esp+2Ch] [ebp+14h]
  int v38; // [esp+2Ch] [ebp+14h]
  int v39; // [esp+2Ch] [ebp+14h]
  int v40; // [esp+2Ch] [ebp+14h]
  int v41; // [esp+2Ch] [ebp+14h]
  int v42; // [esp+2Ch] [ebp+14h]

  v6 = 2 * Radius;
  v7 = YStart - Radius;
  v8 = XStart - YStart;
  v34 = 0;
  v33 = 2 * Radius;
  v36 = YStart - Radius;
  v35 = v8;
  while ( 1 )
  {
    v9 = (v7 + v8 < 0 ? 0 : v7 + v8) + rand() % v6;
    v10 = (v7 < 0 ? 0 : v7) + rand() % v6;
    if ( v9 < 0 || v10 < 0 || v9 >= 1024 || v10 >= 1024 )// min and max coordinates for a map
    {
      v11 = arena;
      v37 = 1;
    }
    else
    {
      v11 = arena;
      v37 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v10 << 10) + v9);
    }
    v12 = v9 + 1;
    if ( v9 + 1 < 0 || v10 < 0 || v12 >= 1024 || v10 >= 1024 )
      v13 = 1;
    else
      v13 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v10 << 10) + v12);
    v14 = v13 + v37;
    v15 = v9 - 1;
    if ( v9 - 1 < 0 || v10 < 0 || v15 >= 1024 || v10 >= 1024 )
      v16 = 1;
    else
      v16 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v10 << 10) + v15);
    v38 = v16 + v14;
    v17 = v10 + 1;
    if ( v9 < 0 || v17 < 0 || v9 >= 1024 || v17 >= 1024 )
      v18 = 1;
    else
      v18 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v17 << 10) + v9);
    v19 = v18 + v38;
    v20 = v10 - 1;
    if ( v9 < 0 || v20 < 0 || v9 >= 1024 || v20 >= 1024 )
      v21 = 1;
    else
      v21 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v20 << 10) + v9);
    v39 = v21 + v19;
    if ( v12 < 0 || v17 < 0 || v12 >= 1024 || v17 >= 1024 )
      v22 = 1;
    else
      v22 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v17 << 10) + v12);
    v40 = v22 + v39;
    if ( v12 < 0 || v20 < 0 || v12 >= 1024 || v20 >= 1024 )
      v23 = 1;
    else
      v23 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v20 << 10) + v12);
    v24 = v23 + v40;
    v25 = v9 - 1;
    if ( v9 - 1 < 0 || v17 < 0 || v25 >= 1024 || v17 >= 1024 )
      v26 = 1;
    else
      v26 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v17 << 10) + v25);
    v41 = v26 + v24;
    if ( v25 < 0 || v20 < 0 || v25 >= 1024 || v20 >= 1024 )
    {
      v27 = arena;
      v28 = 1;
    }
    else
    {
      v27 = arena;
      v28 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v20 << 10) + v25);
    }
    v29 = *(_DWORD *)&v27->field_10026[42616];
    v42 = v28 + v41;
    v30 = 0;
    if ( v29 > 0 )
    {
      v31 = &v27->field_10026[34428];
      while ( *((_DWORD *)v31 - 1) != v9 || *(_DWORD *)v31 != v10 )
      {
        ++v30;
        v31 += 16;
        if ( v30 >= v29 )
          goto LABEL_64;
      }
      ++v42;
    }
LABEL_64:
    if ( !v42 )
      v34 = 1;
    v7 = --v36;
    v33 += 2;
    if ( v34 )
      break;
    v8 = v35;
    v6 = v33;
  }
  *(_DWORD *)ReturnXTile = v9;
  *(_DWORD *)ReturnYTile = v10;
}

//----- (00404980) --------------------------------------------------------
void __thiscall sub_404980(void *this, int a2, __int64 a3)
{
  int v3; // eax
  char *v4; // esi
  int v5; // ecx
  _DWORD *i; // edx
  int v7; // ecx

  if ( (int)a3 >= 0 && a3 >= 0 && (int)a3 < 8 && SHIDWORD(a3) < 8 )
  {
    v3 = 0;
    v4 = (char *)this + 8032 * a3 + 1004 * HIDWORD(a3);
    v5 = *((_DWORD *)v4 + 250);
    if ( v5 > 0 )
    {
      for ( i = v4; *i != a2; ++i )
      {
        if ( ++v3 >= v5 )
          return;
      }
      v7 = v5 - 1;
      *((_DWORD *)v4 + 250) = v7;
      *(_DWORD *)&v4[4 * v3] = *(_DWORD *)&v4[4 * v7];
    }
  }
}

//----- (004049F0) --------------------------------------------------------
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4)
{
  int v4; // eax
  char *v5; // edx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = a4 + 8 * a3;
    v5 = &arena->field_0[1004 * v4 + 1000];
    *(_DWORD *)&arena->field_0[1004 * v4 + 4 * (*(_DWORD *)v5)++] = player;
  }
}

//----- (00404A50) --------------------------------------------------------
void __thiscall LoadArenaSettings_0(struct ARENA *arenaa)
{
  char *v2; // esi
  int v3; // eax
  int v4; // esi

  v2 = arenaa->szConfigFile;
  if ( _strcmpi(arenaa->szConfigFile, Filename) )
  {
    IsFileLastWrittenTime(v2, (int)arenaa->dwLastConfigReadTime);
    LoadArenaSettings(
      (struct_ArenaSettings *)&arenaa->field_10026[42620],
      (struct_ArenaSettings *)&arenaa->field_10026[44048],
      v2);
  }
  else
  {
    qmemcpy(&arenaa->field_10026[42620], &ArenaSettings, 0x594u);
    qmemcpy(&arenaa->field_10026[44048], &FileName, 0x4B8u);
  }
  v3 = 0;
  *(_DWORD *)&arenaa->dwLastConfigReadTime[8] = (*(__int16 *)&arenaa->field_10026[43894] << 14) / 96;
  *(_DWORD *)&arenaa->dwLastConfigReadTime[4] = 0;
  do
  {
    v4 = (unsigned __int8)arenaa->field_10026[v3 + 44019] + *(_DWORD *)&arenaa->dwLastConfigReadTime[4];
    ++v3;
    *(_DWORD *)&arenaa->dwLastConfigReadTime[4] = v4;
  }
  while ( v3 < 29 );
}

//----- (00404B10) --------------------------------------------------------
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this)
{
  const char *v2; // ebx
  int v3; // esi
  struct BMP_FILE_STRUCT *v4; // edi
  int v5; // ebx
  int v6; // eax
  struct BMP_FILE_STRUCT *v7; // eax
  unsigned int v8; // eax
  struct BMP_FILE_STRUCT *v9; // esi
  void *v10; // edi
  int v11; // edi
  int v12; // ebx
  int v13; // ecx
  unsigned int v14; // edx
  int j; // edi
  int k; // esi
  int v17; // ecx
  int v18; // eax
  _BYTE *v19; // eax
  unsigned int v20; // [esp+10h] [ebp-2Ch] BYREF
  unsigned int v21; // [esp+14h] [ebp-28h] BYREF
  struct BMP_FILE_STRUCT *i; // [esp+18h] [ebp-24h]
  int v23[4]; // [esp+1Ch] [ebp-20h] BYREF
  char v24; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  v2 = (char *)this + 111086;
  if ( _strcmpi(&aMisc_DefaultLevelFile, (const char *)this + 111086) )
  {
    v23[0] = 42;
    v23[1] = 0;
    v23[2] = 0;
    v23[3] = 0;
    v24 = 0;
    strcpy((char *)v23 + 1, v2);
    *(_DWORD *)((char *)this + 111610) = CompressFile(
                                           v2,
                                           (int *)((char *)this + 111614),
                                           (int *)((char *)this + 111618),
                                           v23,
                                           0x11u,
                                           1,
                                           0);
    v7 = (struct BMP_FILE_STRUCT *)operator new(272u);
    i = v7;
    v25 = 0;
    if ( v7 )
    {
      LoadBMPHeader(v7, v2);
      v9 = (struct BMP_FILE_STRUCT *)v8;
      v21 = v8;
    }
    else
    {
      v21 = 0;
      v9 = 0;
    }
    v25 = -1;
    *(_DWORD *)((char *)this + 119814) = 0;
    v10 = emalloc(0x100000);
    *(_DWORD *)((char *)this + 119818) = v10;
    memset(v10, 0, 0x100000u);
    v11 = sub_406BE0((int)v9);
    v12 = 0;
    for ( i = (struct BMP_FILE_STRUCT *)v11; v12 < v11; ++v12 )
    {
      GetTileValue(v9, v12, (int *)&v20);
      if ( (v20 & 0xFF000000) == 0xAA000000 )
      {
        v13 = *(_DWORD *)((char *)this + 119814);
        if ( v13 < 510 )
        {
          *(_DWORD *)((char *)this + 16 * v13 + 111622) = v20 & 0xFFF;
          *(_DWORD *)((char *)this + 16 * (*(_DWORD *)((char *)this + 119814))++ + 111626) = (v20 >> 12) & 0xFFF;
        }
      }
      else
      {
        *(_BYTE *)((v20 & 0xFFF) + (((v20 >> 12) & 0xFFF) << 10) + *(_DWORD *)((char *)this + 119818)) = HIBYTE(v20);
        v14 = v20;
        if ( (v20 & 0xFF000000) >= 0xD8000000 )
        {
          for ( j = 0; j < 7; ++j )
          {
            for ( k = 0; k < 7; ++k )
            {
              v17 = j + (v14 & 0xFFF);
              v18 = k + ((v14 >> 12) & 0xFFF);
              if ( v17 < 1024 && v18 < 1024 )
              {
                v19 = (_BYTE *)(*(_DWORD *)((char *)this + 119818) + v17 + (v18 << 10));
                if ( !*v19 )
                {
                  *v19 = -16;
                  v14 = v20;
                }
              }
            }
          }
          v11 = (int)i;
          v9 = (struct BMP_FILE_STRUCT *)v21;
        }
      }
    }
    if ( v9 )
    {
      sub_406B30((int)v9);
      operator delete(v9);
    }
  }
  else
  {
    v3 = 0;
    *(_DWORD *)((char *)this + 111610) = dword_438DFC;
    *(_DWORD *)((char *)this + 111614) = dword_4D9DE0;
    *(_DWORD *)((char *)this + 111618) = dword_4399E8;
    *(_DWORD *)((char *)this + 119818) = big_global_buffer;
    *(_DWORD *)((char *)this + 119814) = 0;
    v4 = (struct BMP_FILE_STRUCT *)dword_439E60;
    v5 = sub_406BE0((int)dword_439E60);
    if ( v5 > 0 )
    {
      do
      {
        GetTileValue(v4, v3, (int *)&v21);
        if ( (v21 & 0xFF000000) == -1442840576 )
        {
          v6 = *(_DWORD *)((char *)this + 119814);
          if ( v6 < 510 )
          {
            *(_DWORD *)((char *)this + 16 * v6 + 111622) = v21 & 0xFFF;
            *(_DWORD *)((char *)this + 16 * (*(_DWORD *)((char *)this + 119814))++ + 111626) = (v21 >> 12) & 0xFFF;
          }
        }
        ++v3;
      }
      while ( v3 < v5 );
    }
  }
}
// 404C9E: variable 'v8' is possibly undefined
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4399E8: using guessed type int dword_4399E8;
// 4D9DE0: using guessed type int dword_4D9DE0;

//----- (00404E20) --------------------------------------------------------
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa)
{
  int v2; // edx
  int v3; // ecx
  int v4; // esi
  int result; // eax
  int v6; // edx

  v2 = rand() % *(_DWORD *)&arenaa->dwLastConfigReadTime[4];
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    if ( arenaa->field_10026[v4 + 44019] )
    {
      if ( v2 >= v3 )
      {
        v3 += (unsigned __int8)arenaa->field_10026[v4 + 44019];
        if ( v2 < v3 )
          break;
      }
    }
    if ( ++v4 >= 29 )
      return 0;
  }
  v6 = rand() % *(__int16 *)&arenaa->field_10026[43924];
  result = v4;
  if ( !v6 )
    result = -v4;
  return result;
}

//----- (00404E80) --------------------------------------------------------
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3)
{
  const CHAR *v3; // eax
  CHAR v4; // cl
  char *i; // edx
  CHAR v6; // cl
  char v8; // cl
  const CHAR *v9; // eax
  char *j; // edx
  CHAR v11; // cl
  int v12; // ebp
  int v13; // edi
  int v14; // ebx
  char *v15; // esi
  char *v16; // esi
  int v17; // [esp+10h] [ebp-514h]
  int v18; // [esp+14h] [ebp-510h]
  int v20; // [esp+1Ch] [ebp-508h]
  int v21; // [esp+20h] [ebp-504h]
  char v22[256]; // [esp+24h] [ebp-500h] BYREF
  char KeyName[256]; // [esp+124h] [ebp-400h] BYREF
  char String[256]; // [esp+224h] [ebp-300h] BYREF
  char AppName[256]; // [esp+324h] [ebp-200h] BYREF
  char msg[256]; // [esp+424h] [ebp-100h] BYREF

  v3 = a3;
  v4 = *a3;
  for ( i = AppName; v4; ++v3 )
  {
    if ( v4 == 58 )
      break;
    *i = v4;
    v4 = v3[1];
    ++i;
  }
  v6 = *v3;
  *i = 0;
  if ( !v6 )
    return 1;
  v8 = v3[1];
  v9 = v3 + 1;
  for ( j = KeyName; v8; ++v9 )
  {
    if ( v8 == 58 )
      break;
    *j = v8;
    v8 = v9[1];
    ++j;
  }
  v11 = *v9;
  *j = 0;
  if ( !v11 )
    return 1;
  v12 = 0;
  strcpy(String, v9 + 1);
  if ( !player->bIsSysop )
  {
    strcpy(v22, AppName);
    if ( !_strcmpi(v22, "Warbird")
      || !_strcmpi(v22, "Javelin")
      || !_strcmpi(v22, "Spider")
      || !_strcmpi(v22, "Leviathan")
      || !_strcmpi(v22, "Weasel")
      || !_strcmpi(v22, "Terrier")
      || !_strcmpi(v22, "Lancaster")
      || !_strcmpi(v22, "Shark") )
    {
      strcpy(v22, "All");
    }
    v18 = 0;
    v20 = 0;
    v17 = atoi(String);
    v21 = 0;
    if ( numTemplateSSSEntriesCount <= 0 )
    {
      v13 = v17;
      v14 = v17;
    }
    else
    {
      v13 = v17;
      v14 = v17;
      v15 = dword_439E70;
      while ( 1 )
      {
        if ( (!_strcmpi(v15, v22) || !_strcmpi(v15, AppName)) && !_strcmpi(v15 + 32, KeyName) && !v15[336] )
        {
          v13 = *((_DWORD *)v15 + 18);
          v14 = *((_DWORD *)v15 + 19);
          v12 = 1;
          v18 = v15[337];
          if ( v13 == -999 || v17 >= v13 && v17 <= v14 )
            break;
        }
        v15 += 338;
        if ( ++v21 >= numTemplateSSSEntriesCount )
          goto LABEL_34;
      }
      v20 = 1;
    }
LABEL_34:
    if ( !v12 )
    {
      sprintf(msg, "%s:%s is not a valid user parameter.", AppName, KeyName);
      SendMessage(player, msg, 0);
      return 1;
    }
    if ( !v20 )
    {
      sprintf(msg, "Valid range for parameter %s:%s is (%d through %d)", AppName, KeyName, v13, v14);
      SendMessage(player, msg, 0);
      return 1;
    }
    if ( v18 )
    {
      *(_DWORD *)arenaa->field_10026 = 1;
      if ( !_strcmpi(arenaa->szConfigFile, Filename) )
        bRecycleServer = 1;
    }
  }
  *(_DWORD *)arenaa->gap_FF08 = 1;
  v16 = arenaa->szConfigFile;
  if ( !_strcmpi(arenaa->szConfigFile, Filename) )
    dword_4D6C10 = 1;
  if ( _strcmpi(AppName, "All") )
  {
    WritePrivateProfileStringA(AppName, KeyName, String, v16);
  }
  else
  {
    WritePrivateProfileStringA("Warbird", KeyName, String, v16);
    WritePrivateProfileStringA("Javelin", KeyName, String, v16);
    WritePrivateProfileStringA("Spider", KeyName, String, v16);
    WritePrivateProfileStringA("Leviathan", KeyName, String, v16);
    WritePrivateProfileStringA("Terrier", KeyName, String, v16);
    WritePrivateProfileStringA("Weasel", KeyName, String, v16);
    WritePrivateProfileStringA("Lancaster", KeyName, String, v16);
    WritePrivateProfileStringA("Shark", KeyName, String, v16);
  }
  return 0;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4332F4: using guessed type int bRecycleServer;
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9DD4: using guessed type int numTemplateSSSEntriesCount;

//----- (00405360) --------------------------------------------------------
int __thiscall sub_405360(int this, int a2)
{
  ArenaScoreReset((struct ARENA *)this, a2);
  *(_DWORD *)(this + 65594) = 0;
  *(_DWORD *)(this + 65350) = GetTickCount() / 0xA;
  *(_DWORD *)(this + 65312) = 0;
  return SoccerGameSomething((ARENA *)this, -1);
}

//----- (004053B0) --------------------------------------------------------
int __thiscall SoccerGameSomething(ARENA *this, int a2)
{
  char *v3; // ebx
  int v4; // eax
  char *v5; // ecx
  int v6; // esi
  int v7; // eax
  int result; // eax
  char *v9; // esi
  int v10; // ecx
  int v11; // edi
  char *v12; // ebx
  int v13; // [esp+10h] [ebp-118h]
  char *v14; // [esp+10h] [ebp-118h]
  int v15; // [esp+14h] [ebp-114h]
  char buf; // [esp+18h] [ebp-110h] BYREF
  int v17; // [esp+19h] [ebp-10Fh]
  int v18; // [esp+1Dh] [ebp-10Bh]
  int v19; // [esp+21h] [ebp-107h]
  __int16 v20; // [esp+25h] [ebp-103h]
  char v21; // [esp+27h] [ebp-101h]
  char msg[256]; // [esp+28h] [ebp-100h] BYREF

  if ( a2 >= 0 )
  {
    v13 = 0;
    if ( this->nPlayersHere > 0 )
    {
      v3 = this->PlayerArray;
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)v3 + 279) == a2 && *(int *)(*(_DWORD *)v3 + 216) > 0 )
        {
          sprintf(msg, "Soccer game over.  Personal Reward: %d", *(_DWORD *)(*(_DWORD *)v3 + 216));
          UpdatePoints(*(struct PLAYER **)v3, 0, *(_DWORD *)(*(_DWORD *)v3 + 216));
        }
        else
        {
          strcpy(msg, "Soccer game over.");
        }
        SendMessage(*(struct PLAYER **)v3, msg, 103);
        if ( !SendPlayerScoreUpdateAll(*(_DWORD *)v3) )
          SendPlayerScoreUpdate(*(struct PLAYER **)v3);
        v3 += 4;
        ++v13;
      }
      while ( v13 < this->nPlayersHere );
    }
  }
  v4 = 0;
  if ( this->nPlayersHere > 0 )
  {
    v5 = this->PlayerArray;
    do
    {
      v6 = *(_DWORD *)v5;
      ++v4;
      v5 += 4;
      *(_DWORD *)(v6 + 216) = 0;
    }
    while ( v4 < this->nPlayersHere );
  }
  *(_DWORD *)&this->field_FF6A[160] = 0;
  *(_DWORD *)&this->field_FF6A[164] = 0;
  *(_DWORD *)&this->field_FF6A[168] = 0;
  *(_DWORD *)&this->field_FF6A[172] = 0;
  v7 = *(_DWORD *)&this->field_10026[44372];
  if ( v7 > 0 )
  {
    *(_DWORD *)&this->field_FF6A[160] = v7;
    *(_DWORD *)&this->field_FF6A[164] = v7;
    *(_DWORD *)&this->field_FF6A[168] = v7;
    *(_DWORD *)&this->field_FF6A[172] = v7;
  }
  result = 0;
  v15 = 0;
  if ( *(int *)&this->field_FF6A[4] > 0 )
  {
    v9 = &this->field_FF6A[11];
    v14 = &this->field_FF6A[128];
    do
    {
      *(v9 - 3) = result;
      *((_WORD *)v9 - 1) = 0;
      *(_WORD *)v9 = 0;
      *((_WORD *)v9 + 1) = 0;
      *((_WORD *)v9 + 2) = 0;
      *((_WORD *)v9 + 3) = -1;
      *((_DWORD *)v9 + 2) = 0;
      *(_DWORD *)v14 = 0;
      v17 = *(_DWORD *)(v9 - 3);
      v18 = *(_DWORD *)(v9 + 1);
      v19 = *(_DWORD *)(v9 + 5);
      v20 = *(_WORD *)(v9 + 9);
      v21 = v9[11];
      v10 = this->nPlayersHere;
      v11 = 0;
      buf = 46;
      if ( v10 > 0 )
      {
        v12 = this->PlayerArray;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v12 + 56) )
            PlayerSendPacket(*(PLAYER **)v12, &buf, 16, 1);
          ++v11;
          v12 += 4;
        }
        while ( v11 < this->nPlayersHere );
        result = v15;
      }
      ++result;
      v9 += 15;
      v15 = result;
      v14 += 4;
    }
    while ( result < *(_DWORD *)&this->field_FF6A[4] );
  }
  *(_DWORD *)&this->field_FF6A[4] = 0;
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004055D0) --------------------------------------------------------
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4)
{
  int v5; // edi
  int v6; // ebx
  int v7; // ebp
  int result; // eax
  int v9; // eax
  int v10; // edi
  char *v11; // ebx
  char *i; // ecx
  int v13; // edx
  int v14; // ecx
  char *v15; // ecx

  v5 = -1;
  v6 = -1;
  v7 = 0;
  result = SoccerRelatedMath((unsigned __int8)arenaa->field_10026[43992], a3, a4);
  switch ( arenaa->field_10026[43992] )
  {
    case 1:
    case 2:
      v7 = 2;
      v5 = Frequency & 1;
      v6 = result;
      break;
    case 3:
    case 5:
      v7 = 4;
      v5 = Frequency & 3;
      v6 = result;
      break;
    case 4:
    case 6:
      v7 = 4;
      v5 = Frequency & 3;
      switch ( Frequency & 3 )
      {
        case 0:
          v6 = 3;
          break;
        case 1:
          v6 = 2;
          break;
        case 2:
          v6 = 1;
          break;
        case 3:
          v6 = 0;
          break;
        default:
          goto LABEL_9;
      }
      break;
    default:
      break;
  }
LABEL_9:
  if ( v5 >= 0 )
  {
    result = *(_DWORD *)&arenaa->field_10026[44372];
    if ( result <= 0 )
    {
      if ( result < 0 )
      {
        ++*(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
        GetScore((SoccerScores *)arenaa, 0);
        result = *(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
        if ( result >= -*(_DWORD *)&arenaa->field_10026[44372] )
        {
          v13 = *(_DWORD *)&arenaa->field_10026[44380];
          v14 = 1;
          if ( v13 > 0 )
          {
            result = 0;
            if ( v7 > 0 )
            {
              v15 = &arenaa->field_FF6A[160];
              while ( result == v5 || *(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160] - *(_DWORD *)v15 >= v13 )
              {
                ++result;
                v15 += 4;
                if ( result >= v7 )
                {
                  v14 = 1;
                  goto LABEL_33;
                }
              }
              v14 = 0;
            }
          }
LABEL_33:
          if ( v14 )
            return SoccerGameSomething(arenaa, Frequency);
        }
      }
    }
    else
    {
      v9 = *(_DWORD *)&arenaa->field_FF6A[4 * v6 + 160];
      if ( v9 )
      {
        *(_DWORD *)&arenaa->field_FF6A[4 * v6 + 160] = v9 - 1;
        ++*(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
      }
      else
      {
        v10 = 0;
        if ( arenaa->nPlayersHere > 0 )
        {
          v11 = arenaa->PlayerArray;
          do
          {
            SendMessage(*(struct PLAYER **)v11, "Enemy goal had no points to give.", 0);
            ++v10;
            v11 += 4;
          }
          while ( v10 < arenaa->nPlayersHere );
        }
      }
      GetScore((SoccerScores *)arenaa, 0);
      result = 0;
      if ( v7 > 0 )
      {
        for ( i = &arenaa->field_FF6A[160]; *(_DWORD *)i != *(_DWORD *)&arenaa->field_10026[44372] * v7; i += 4 )
        {
          if ( ++result >= v7 )
            return result;
        }
        return SoccerGameSomething(arenaa, Frequency);
      }
    }
  }
  return result;
}

//----- (004057C0) --------------------------------------------------------
void __thiscall GetScore(SoccerScores *SoccerScores, int a2)
{
  char v3; // al
  int v4; // ebx
  _BYTE *v5; // esi
  struct PLAYER *v6; // ecx
  int v7; // [esp-8h] [ebp-214h]
  char *v8; // [esp-8h] [ebp-214h]
  int v9; // [esp-4h] [ebp-210h]
  char v10[256]; // [esp+Ch] [ebp-200h] BYREF
  char msg[256]; // [esp+10Ch] [ebp-100h] BYREF

  if ( (int)SoccerScores->dword1AD6E > 0 && SoccerScores->dword1AD7A )
  {
    v3 = SoccerScores->byte1ABFE;
    if ( v3 == 1 || v3 == 2 )
    {
      v9 = SoccerScores->Team1Score;
      v7 = SoccerScores->Team0Score;
      if ( SoccerScores->dword1ACCE )
        sprintf(v10, "SCORE: Warbirds:%d  Javelins:%d", v7, v9);
      else
        sprintf(v10, "SCORE: Evens:%d  Odds:%d", v7, v9);
    }
    else if ( SoccerScores->dword1ACCE )
    {
      sprintf(
        v10,
        "SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d",
        SoccerScores->Team0Score,
        SoccerScores->Team1Score,
        SoccerScores->Team2Score,
        SoccerScores->Team3Score);
    }
    else
    {
      sprintf(
        v10,
        "SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d",
        SoccerScores->Team0Score,
        SoccerScores->Team1Score,
        SoccerScores->Team2Score,
        SoccerScores->Team3Score);
    }
    if ( a2 )
    {
      if ( *(int *)(a2 + 216) <= 0 )
      {
        SendMessage((struct PLAYER *)a2, v10, 0);
      }
      else
      {
        sprintf(msg, "%s  REWARD:%d", v10, *(_DWORD *)(a2 + 216));
        SendMessage((struct PLAYER *)a2, msg, 0);
      }
    }
    else
    {
      v4 = 0;
      if ( *(int *)&SoccerScores->f0[65292] > 0 )
      {
        v5 = &SoccerScores->f0[64288];
        do
        {
          v6 = *(struct PLAYER **)v5;
          if ( *(int *)(*(_DWORD *)v5 + 216) <= 0 )
          {
            v8 = v10;
          }
          else
          {
            sprintf(msg, "%s  REWARD:%d", v10, *(_DWORD *)(*(_DWORD *)v5 + 216));
            v8 = msg;
            v6 = *(struct PLAYER **)v5;
          }
          SendMessage(v6, v8, 0);
          ++v4;
          v5 += 4;
        }
        while ( v4 < *(_DWORD *)&SoccerScores->f0[offsetof(ARENA, nPlayersHere)] );
      }
    }
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00405970) --------------------------------------------------------
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena)
{
  int v1; // edx

  v1 = 117;
  if ( *(_DWORD *)&arena->field_1B8DE[6956] != big_global_buffer )
    v1 = 1317;
  return v1 + ((unsigned int)(18 * *(_DWORD *)&arena->field_10026[18028]) >> 10);
}

//----- (004059A0) --------------------------------------------------------
int __thiscall GetTotalPlayingPlayers(ARENA *arena)
{
  int v1; // edx
  int result; // eax
  char *v3; // ecx

  v1 = arena->nPlayersHere;
  result = 0;
  if ( v1 > 0 )
  {
    v3 = arena->PlayerArray;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v3 + offsetof(PLAYER, dwShip)) != 8 )
        ++result;
      v3 += 4;
      --v1;
    }
    while ( v1 );
  }
  return result;
}

//----- (004059D0) --------------------------------------------------------
int __thiscall sub_4059D0(int this, int a2, const char *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  char v10[176]; // [esp+8h] [ebp-B0h] BYREF

  *(_DWORD *)this = a8;
  *(_DWORD *)(this + 4) = a9;
  memset(v10, 0, 172u);
  v10[172] = 0;
  *(_DWORD *)(this + 12) = a2;
  *(_DWORD *)(this + 20) = 0;
  v10[0] = 2;
  strncpy(&v10[13], a3, 128u);
  v10[140] = 0;
  return sub_415940();
}
// 415940: using guessed type int sub_415940(void);

//----- (00405AB0) --------------------------------------------------------
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct)
{
  struct CONNECTION *v2; // ecx
  DWORD v3; // esi
  int result; // eax
  char buf; // [esp+1h] [ebp-1h] BYREF

  buf = HIBYTE(billingServerStruct);
  v2 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
  buf = 3;
  WriteData(v2, &buf, 1u, 1);
  v3 = GetTickCount() / 0xA;
  for ( result = GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0);
        result > 0;
        result = GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0) )
  {
    result = abs32(GetTickCount() / 0xA - v3);
    if ( result >= 800 )
      break;
    PlayerDoNetworkOps(*(struct_v9 **)billingServerStruct);
  }
  return result;
}

//----- (00405B30) --------------------------------------------------------
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3)
{
  char buf; // [esp+0h] [ebp-68h] BYREF
  int v4; // [esp+1h] [ebp-67h]
  char v5[96]; // [esp+5h] [ebp-63h] BYREF

  if ( a2 >= 0 )
  {
    v4 = a2;
    buf = 16;
    qmemcpy(v5, a3, sizeof(v5));
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, 0x65u, 1);
  }
}

//----- (00405B70) --------------------------------------------------------
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  struct CONNECTION *v4; // ecx
  char buf; // [esp+0h] [ebp-304h] BYREF
  int v6; // [esp+1h] [ebp-303h]
  char v7[767]; // [esp+5h] [ebp-2FFh] BYREF

  if ( a1 >= 0 )
  {
    v6 = a1;
    buf = 13;
    qmemcpy(v7, (const void *)a2, 0x2FCu);
    v4 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
    v7[764] = *(_BYTE *)(a2 + 764);
    WriteData(v4, &buf, 0x302u, 1);
  }
}
// 405B70: inconsistent function type and number of purged bytes

//----- (00405BC0) --------------------------------------------------------
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  char buf; // [esp+10h] [ebp-9h] BYREF
  int v5; // [esp+11h] [ebp-8h]
  int v6; // [esp+15h] [ebp-4h]
  char v7[2039]; // [esp+19h] [ebp+0h] BYREF

  v5 = a1;
  v6 = a2;
  buf = 14;
  strcpy(v7, a3);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(a3) + 10, 1);
}

//----- (00405C40) --------------------------------------------------------
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText)
{
  char buf; // [esp+4h] [ebp-800h] BYREF
  int v6; // [esp+5h] [ebp-7FFh]
  char v7[32]; // [esp+9h] [ebp-7FBh] BYREF
  char v8[2011]; // [esp+29h] [ebp-7DBh] BYREF

  if ( PlayerId >= 0 )
  {
    v6 = PlayerId;
    buf = 20;
    strncpy(v7, ChannelName, 0x20u);
    v7[31] = 0;
    strcpy(v8, ChatText);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(ChatText) + 38, 1);
  }
}

//----- (00405CD0) --------------------------------------------------------
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage)
{
  char buf; // [esp+4h] [ebp-400h] BYREF
  int v4; // [esp+5h] [ebp-3FFh]
  char v5[1019]; // [esp+9h] [ebp-3FBh] BYREF

  if ( PlayerId >= 0 )
  {
    v4 = PlayerId;
    buf = 15;
    strcpy(v5, WarningMessage);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(WarningMessage) + 6, 1);
  }
}

//----- (00405D50) --------------------------------------------------------
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand)
{
  char buf; // [esp+4h] [ebp-400h] BYREF
  int v4; // [esp+5h] [ebp-3FFh]
  char v5[1019]; // [esp+9h] [ebp-3FBh] BYREF

  if ( a2 >= 0 )
  {
    v4 = a2;
    buf = 19;
    strcpy(v5, UserCommand);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(UserCommand) + 6, 1);
  }
}

//----- (00405E70) --------------------------------------------------------
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize)
{
  unsigned int v9; // eax
  char packetId; // [esp+0h] [ebp-400h] BYREF
  int v11; // [esp+1h] [ebp-3FFh]
  __int16 v12; // [esp+5h] [ebp-3FBh]
  __int16 v13; // [esp+7h] [ebp-3F9h]
  __int16 v14; // [esp+9h] [ebp-3F7h]
  __int16 v15; // [esp+Bh] [ebp-3F5h]
  __int16 v16; // [esp+Dh] [ebp-3F3h]
  char v17[1009]; // [esp+Fh] [ebp-3F1h] BYREF

  if ( PlayerId >= 0 )
  {
    v11 = PlayerId;
    v12 = DisconnectReason;
    v13 = Latency;
    v14 = Ping;
    packetId = 5;
    v16 = C2SPacketLoss;
    v15 = S2CPacketLoss;
    v9 = 15;
    if ( PlayerScore )
    {
      qmemcpy(v17, PlayerScore, ExtraSize);
      v9 = ExtraSize + 15;
    }
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &packetId, v9, 1);
  }
}
// 405E70: using guessed type char var_3F1[1009];

//----- (00405F20) --------------------------------------------------------
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size)
{
  char packetId; // [esp+0h] [ebp-400h] BYREF
  int v5; // [esp+1h] [ebp-3FFh]
  char v6[1019]; // [esp+5h] [ebp-3FBh] BYREF

  if ( PlayerId >= 0 )
  {
    v5 = PlayerId;
    packetId = 17;
    qmemcpy(v6, Score, Size);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &packetId, Size + 5, 1);
  }
}

//----- (00405F80) --------------------------------------------------------
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len)
{
  char *packet; // ebx
  int buf_sz; // [esp+24h] [ebp+10h]

  buf_sz = len + 9;
  packet = (char *)emalloc(buf_sz);
  qmemcpy(packet + 9, a3, len);
  *(_DWORD *)(packet + 5) = a2;
  *packet = 6;                                  // packetId (Billing Server?)
  *(_DWORD *)(packet + 1) = a1;
  qmemcpy(packet + 9, a3, len);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), packet, buf_sz, 1);
  efree(packet);
}

//----- (00406010) --------------------------------------------------------
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len)
{
  char *packet; // ebx
  int buf_sz; // [esp+24h] [ebp+10h]

  buf_sz = len + 9;
  packet = (char *)emalloc(buf_sz);
  qmemcpy(packet + 9, a4, len);
  *(_DWORD *)(packet + 5) = BillingGroupId;
  *packet = 7;                                  // packetId (Billing Server)
  *(_DWORD *)(packet + 1) = PlayerId;
  qmemcpy(packet + 9, a4, len);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), packet, buf_sz, 1);
  efree(packet);
}

//----- (004060A0) --------------------------------------------------------
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int a2, int a3, int a4, int len)
{
  char *v6; // ebx
  int buf_sz; // [esp+24h] [ebp+10h]

  buf_sz = len + 9;
  v6 = (char *)emalloc(buf_sz);
  qmemcpy(v6 + 9, (const void *)a4, len);
  *(_DWORD *)(v6 + 5) = a3;
  *v6 = 18;                                     // Billing server? packet Id
  *(_DWORD *)(v6 + 1) = a2;
  qmemcpy(v6 + 9, (const void *)a4, len);
  WriteData(this[1], v6, buf_sz, 1);
  efree(v6);
}

//----- (00406130) --------------------------------------------------------
int __thiscall sub_406130(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 58);
}

//----- (00406140) --------------------------------------------------------
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct)
{
  __int64 v2; // rax
  DWORD v3; // eax
  struct CONNECTION *v4; // ecx
  int i; // eax
  void (__cdecl *v6)(int, int); // ecx
  char buf; // [esp+Bh] [ebp-9h] BYREF
  int v9; // [esp+Ch] [ebp-8h] BYREF
  char v10[4]; // [esp+10h] [ebp-4h] BYREF

  if ( sub_41C510(*((_DWORD *)billingServerStruct + 1)) != 2
    || GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0) >= 255 )
  {
    return 1;
  }
  v2 = (int)(GetTickCount() / 0xA - *((_DWORD *)billingServerStruct + 4));
  if ( (int)((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 3000 )
  {
    v3 = GetTickCount();
    v4 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
    *((_DWORD *)billingServerStruct + 4) = v3 / 0xA;
    buf = 1;
    WriteData(v4, &buf, 1u, 1);
  }
  for ( i = sub_41BD80(*(_DWORD *)billingServerStruct, (int)&v9, (int)v10);
        i;
        i = sub_41BD80(*(_DWORD *)billingServerStruct, (int)&v9, (int)v10) )
  {
    v6 = (void (__cdecl *)(int, int))*((_DWORD *)billingServerStruct + 3);
    if ( v6 )
      v6(i, v9);
  }
  return 0;
}

//----- (00406210) --------------------------------------------------------
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename)
{
  int v3; // esi
  int v4; // eax
  int v5; // edi
  char *v6; // edx
  char v7; // al
  char *v8; // edi
  char *i; // ecx
  char *v10; // eax
  char *v11; // edx
  char j; // cl
  char k; // cl
  char *v14; // eax
  char v15; // cl
  char *l; // edx
  int v18; // [esp+10h] [ebp-204h]
  char v19; // [esp+14h] [ebp-200h] BYREF
  char v20; // [esp+15h] [ebp-1FFh] BYREF

  strcpy((char *)ConfigSETPointer + 177740, Filename);
  *((_DWORD *)ConfigSETPointer + 2432) = 0;
  *((_DWORD *)ConfigSETPointer + 44433) = 0;
  *((_DWORD *)ConfigSETPointer + 44434) = 0;
  v3 = -1;
  v4 = fopen((char *)ConfigSETPointer + 177740, "rt");
  v5 = v4;
  v18 = v4;
  if ( v4 )
  {
    if ( (*(_BYTE *)(v4 + 12) & 0x10) == 0 )
    {
      do
      {
        v19 = 0;
        fgets(&v19, 512, v5);
        if ( v19 == 91 )
        {
          v3 = *((_DWORD *)ConfigSETPointer + 2432);
          *((_DWORD *)ConfigSETPointer + 2432) = v3 + 1;
          v6 = &v20;
          v7 = v20;
          v8 = (char *)ConfigSETPointer + 38 * v3;
          for ( i = v8; v7; ++v6 )
          {
            if ( v7 == 93 )
              break;
            *i = v7;
            v7 = v6[1];
            ++i;
          }
          *i = 0;
          *(_DWORD *)(v8 + 30) = *((_DWORD *)ConfigSETPointer + 44433);
          *(_DWORD *)(v8 + 34) = 0;
          v5 = v18;
        }
        else if ( isalpha(v19) && v3 != -1 )
        {
          v10 = &v19;
          v11 = (char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9732;
          for ( j = v19; j; ++v10 )
          {
            if ( j == 61 )
              break;
            if ( j == 32 )
              break;
            *v11 = j;
            j = v10[1];
            ++v11;
          }
          *v11 = 0;
          for ( k = *v10; k; k = *++v10 )
          {
            if ( k == 61 )
              break;
          }
          if ( *v10 )
          {
            v14 = v10 + 1;
            v15 = *v14;
            for ( l = (char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9772; v15 >= 32; ++v14 )
            {
              *l = v15;
              v15 = v14[1];
              ++l;
            }
            *l = 0;
            config_read_helper_3((char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9772);
            ++*((_DWORD *)ConfigSETPointer + 44433);
            ++*(_DWORD *)((char *)ConfigSETPointer + 38 * v3 + 34);
          }
        }
      }
      while ( (*(_BYTE *)(v5 + 12) & 0x10) == 0 );
    }
    fclose(v5);
  }
  return ConfigSETPointer;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);

//----- (004063F0) --------------------------------------------------------
void __thiscall WriteCfgFile(struct struc_2 *struc2)
{
  struct struc_2 *v1; // esi
  int v2; // ebp
  _DWORD *v3; // edi
  int v4; // ebx
  const char *v5; // esi
  int v6; // [esp+8h] [ebp-8h]

  v1 = struc2;
  if ( *((_DWORD *)struc2 + 44434) )
  {
    v2 = fopen((char *)struc2 + 177740, "wt");
    if ( v2 )
    {
      v6 = 0;
      if ( *((int *)v1 + 2432) > 0 )
      {
        v3 = (_DWORD *)((char *)v1 + 34);
        do
        {
          if ( (int)*v3 > 0 )
          {
            fprintf(v2, "[%s]\n", (const char *)v3 - 34);
            v4 = 0;
            if ( (int)*v3 > 0 )
            {
              v5 = (char *)v1 + 140 * *(v3 - 1) + 9732;
              do
              {
                fprintf(v2, "%s=%s\n", v5, v5 + 40);
                ++v4;
                v5 += 140;
              }
              while ( v4 < *v3 );
              v1 = struc2;
            }
            fprintf(v2, (const char *)L"\n");
          }
          v3 = (_DWORD *)((char *)v3 + 38);
          ++v6;
        }
        while ( v6 < *((_DWORD *)v1 + 2432) );
      }
      fclose(v2);
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (004064D0) --------------------------------------------------------
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4)
{
  struct struc_2 *v4; // ebp
  int *v5; // edi
  int v6; // esi
  int v7; // ebx
  const char *v8; // ebp
  int result; // eax
  int v10; // [esp+10h] [ebp-18h]
  char v12[16]; // [esp+18h] [ebp-10h] BYREF

  v4 = Str1;
  v10 = 0;
  if ( *((int *)Str1 + 2432) <= 0 )
  {
LABEL_10:
    sprintf(v12, "%d", a4);
    FillArenaSettingsStruct(v4, Str2, a3, v12);
    result = a4;
  }
  else
  {
    v5 = (int *)((char *)Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v5 - 34, Str2) )
      {
        v6 = *(v5 - 1);
        v7 = 0;
        if ( *v5 > 0 )
          break;
      }
LABEL_9:
      v5 = (int *)((char *)v5 + 38);
      if ( ++v10 >= *((_DWORD *)v4 + 2432) )
        goto LABEL_10;
    }
    v8 = (char *)v4 + 140 * v6 + 9732;
    while ( _strcmpi(v8, a3) )
    {
      ++v7;
      ++v6;
      v8 += 140;
      if ( v7 >= *v5 )
      {
        v4 = Str1;
        goto LABEL_9;
      }
    }
    result = atoi((const char *)Str1 + 140 * v6 + 9772);
  }
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004065C0) --------------------------------------------------------
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count)
{
  struct struc_2 *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  char *v12; // [esp-8h] [ebp-20h]
  size_t v13; // [esp-4h] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-8h]

  v6 = Str1;
  v14 = 0;
  if ( *((int *)Str1 + 2432) <= 0 )
  {
LABEL_10:
    FillArenaSettingsStruct(v6, Str2, a3, Source);
    v11 = Count;
    v13 = Count;
    v12 = Source;
  }
  else
  {
    v7 = (int *)((char *)Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v14 >= *((_DWORD *)v6 + 2432) )
        goto LABEL_10;
    }
    v10 = (char *)v6 + 140 * v8 + 9732;
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = Str1;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v13 = Count;
    v12 = (char *)Str1 + 140 * v8 + 9772;
  }
  strncpy(Dest, v12, v13);
  Dest[v11 - 1] = 0;
}

//----- (004066B0) --------------------------------------------------------
char *__thiscall sub_4066B0(int this, const char *a2, const char *a3, const char *a4, char *a5, size_t a6)
{
  int v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  size_t v14; // [esp-4h] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-8h]

  v6 = this;
  v15 = 0;
  if ( *(int *)(this + 9728) <= 0 )
  {
LABEL_10:
    v11 = a6;
    v14 = a6;
  }
  else
  {
    v7 = (int *)(this + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, a2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v15 >= *(_DWORD *)(v6 + 9728) )
        goto LABEL_10;
    }
    v10 = (const char *)(v6 + 140 * v8 + 9732);
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = this;
        goto LABEL_9;
      }
    }
    v11 = a6;
    v14 = a6;
    a4 = (const char *)(this + 140 * v8 + 9772);
  }
  strncpy(a5, a4, v14);
  a5[v11 - 1] = 0;
  return a5;
}

//----- (00406790) --------------------------------------------------------
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source)
{
  struc_2 *v4; // ebp
  int v5; // esi
  int v6; // eax
  struc_2 *v7; // edi
  int v8; // eax
  char *v9; // esi
  int v10; // ebx
  int v11; // ecx
  char *v12; // esi
  const char *v13; // edi
  char *v14; // ebx
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // [esp+10h] [ebp-Ch]
  char *v18; // [esp+14h] [ebp-8h]
  char *v19; // [esp+20h] [ebp+4h]

  v4 = Str1;
  v5 = 0;
  v6 = *((_DWORD *)Str1 + 2432);
  *((_DWORD *)Str1 + 44434) = 1;
  if ( v6 <= 0 )
  {
LABEL_5:
    strcpy((char *)v4 + 38 * *((_DWORD *)v4 + 2432), Str2);
    *(_DWORD *)((char *)v4 + 38 * *((_DWORD *)v4 + 2432) + 30) = *((_DWORD *)v4 + 44433);
    *(_DWORD *)((char *)v4 + 38 * *((_DWORD *)v4 + 2432) + 34) = 1;
    v8 = 7 * *((_DWORD *)v4 + 44433);
    ++*((_DWORD *)v4 + 2432);
    strcpy((char *)v4 + 20 * v8 + 9732, a3);
    v9 = (char *)v4 + 140 * *((_DWORD *)v4 + 44433) + 9772;
    strncpy(v9, Source, 0x64u);
    v9[99] = 0;
    ++*((_DWORD *)v4 + 44433);
  }
  else
  {
    v7 = Str1;
    while ( _strcmpi((const char *)v7, Str2) )
    {
      ++v5;
      v7 = (struc_2 *)((char *)v7 + 38);
      if ( v5 >= *((_DWORD *)v4 + 2432) )
        goto LABEL_5;
    }
    v17 = v5;
    v10 = 0;
    v11 = 19 * v5;
    v12 = *(char **)((char *)v4 + 38 * v5 + 30);
    v19 = v12;
    v18 = (char *)v4 + 2 * v11;
    if ( *(int *)(v18 + 34) <= 0 )
    {
LABEL_12:
      memcpy(
        (char *)v4 + 140 * (_DWORD)v12 + 9872,
        (char *)v4 + 140 * (_DWORD)v12 + 9732,
        140 * *((_DWORD *)v4 + 44433) - 140 * (_DWORD)v12);
      v14 = (char *)v4 + 140 * (_DWORD)v12 + 9772;
      strcpy((char *)v4 + 140 * (_DWORD)v12 + 9732, a3);
      strncpy(v14, Source, 0x64u);
      v14[99] = 0;
      ++*((_DWORD *)v4 + 44433);
      ++*(_DWORD *)(v18 + 34);
      v15 = 0;
      if ( *((int *)v4 + 2432) > 0 )
      {
        v16 = (_DWORD *)((char *)v4 + 30);
        do
        {
          if ( *v16 >= (int)v19 && v15 != v17 )
            ++*v16;
          ++v15;
          v16 = (_DWORD *)((char *)v16 + 38);
        }
        while ( v15 < *((_DWORD *)v4 + 2432) );
      }
    }
    else
    {
      v13 = (char *)v4 + 140 * (_DWORD)v12 + 9732;
      while ( _strcmpi(v13, a3) )
      {
        ++v10;
        ++v12;
        v13 += 140;
        if ( v10 >= *(_DWORD *)(v18 + 34) )
        {
          v19 = v12;
          goto LABEL_12;
        }
      }
      strcpy((char *)v4 + 140 * (_DWORD)v12 + 9772, Source);
    }
  }
}

//----- (00406A30) --------------------------------------------------------
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax
  unsigned int v6; // eax
  void *v7; // eax
  int v8; // edx
  char v9[2]; // [esp+Ch] [ebp-8h] BYREF
  int v10; // [esp+Eh] [ebp-6h]

  strncpy((char *)Filename, Source, 0x100u);
  *((_BYTE *)Filename + 255) = 0;
  *((_DWORD *)Filename + 66) = 0;
  *((_DWORD *)Filename + 67) = 0;
  v3 = fopen(Filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    *((_DWORD *)Filename + 64) = 0;
    if ( fread(v9, 1, 6, v3) == 6 && v9[0] == 66 && v9[1] == 77 )
      *((_DWORD *)Filename + 64) = v10;
    fseek(v4, *((_DWORD *)Filename + 64), 0);
    v5 = _fileno(v4);
    v6 = (unsigned int)(_filelength(v5) - *((_DWORD *)Filename + 64)) >> 2;
    *((_DWORD *)Filename + 67) = v6;
    v7 = emalloc(4 * v6);
    v8 = *((_DWORD *)Filename + 67);
    *((_DWORD *)Filename + 66) = v7;
    fread(v7, v8, 4, v4);
    fclose(v4);
  }
  *((_DWORD *)Filename + 65) = 0;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00406B30) --------------------------------------------------------
void __thiscall sub_406B30(int this)
{
  int v2; // edi
  int v3; // eax
  void *v4; // esi
  int v5; // [esp-4h] [ebp-Ch]

  if ( *(_DWORD *)(this + 260) )
  {
    if ( *(_DWORD *)(this + 264) )
    {
      v2 = fopen(this, "rb+");
      if ( v2 || (v2 = fopen(this, "wb")) != 0 )
      {
        fseek(v2, *(_DWORD *)(this + 256), 0);
        fwrite(*(_DWORD *)(this + 264), *(_DWORD *)(this + 268), 4, v2);
        v5 = *(_DWORD *)(this + 256) + 4 * *(_DWORD *)(this + 268);
        v3 = _fileno(v2);
        _chsize(v3, v5);
        fclose(v2);
      }
    }
  }
  v4 = *(void **)(this + 264);
  if ( v4 )
    efree(v4);
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 41EDC0: using guessed type int __cdecl _chsize(_DWORD, _DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00406BE0) --------------------------------------------------------
int __thiscall sub_406BE0(int this)
{
  return *(_DWORD *)(this + 268);
}

//----- (00406BF0) --------------------------------------------------------
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi

  v3 = *TileValuePointer ^ ((unsigned __int16)*TileValuePointer ^ (unsigned __int16)*(_DWORD *)(*((_DWORD *)BMPFile + 66)
                                                                                              + 4 * TileCounter)) & 0xFFF;
  *TileValuePointer = v3;
  v4 = v3 ^ (v3 ^ *(_DWORD *)(*((_DWORD *)BMPFile + 66) + 4 * TileCounter)) & 0xFFF000;
  *TileValuePointer = v4;
  v5 = *(_DWORD *)(*((_DWORD *)BMPFile + 66) + 4 * TileCounter);
  *TileValuePointer = v5 ^ (v5 ^ v4) & 0xFFFFFF;
}

//----- (00406C50) --------------------------------------------------------
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize)
{
  int v8; // ebx
  char *v9; // esi
  int v10; // ebx
  int i; // edi
  int v12; // edi
  int v13; // ecx
  char *v14; // eax
  int v15; // ecx
  int v16; // esi
  char *v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // eax
  signed int j; // ecx
  int v22; // eax
  signed int v23; // eax
  char *v24; // edi
  char *v25; // ebx

  v8 = XTiles;
  if ( XTiles < 0 )
  {
    v9 = MapAllocatedMemory;
  }
  else
  {
    v9 = MapAllocatedMemory;
    do
    {
      if ( MapAllocatedMemory[1024 * YTiles + v8] )
        break;
      --v8;
    }
    while ( v8 >= 0 );
  }
  v10 = v8 + 1;
  for ( i = XTiles; i < 1024; ++i )
  {
    if ( v9[1024 * YTiles + i] )
      break;
  }
  v12 = i - 1;
  if ( v12 < v10 )
    v12 = v10;
  v13 = YTiles;
  if ( YTiles >= 0 )
  {
    v14 = &v9[1024 * YTiles + XTiles];
    do
    {
      if ( *v14 )
        break;
      --v13;
      v14 -= 1024;
    }
    while ( v13 >= 0 );
  }
  v15 = v13 + 1;
  v16 = YTiles;
  if ( YTiles < 1024 )
  {
    v17 = &MapAllocatedMemory[1024 * YTiles + XTiles];
    do
    {
      if ( *v17 )
        break;
      ++v16;
      v17 += 1024;
    }
    while ( v16 < 1024 );
  }
  v18 = v16 - 1;
  if ( v18 < v15 )
    v18 = v15;
  v19 = BrickSpanSize / 2;
  if ( v12 - v10 >= v18 - v15 )
  {
    if ( v15 <= YTiles - v19 )
      v15 = YTiles - v19;
    v22 = YTiles + v19;
    if ( v18 >= v22 )
      v18 = v22;
    v23 = v18 - v15 + 1;
    if ( v23 < BrickSpanSize )
    {
      v24 = &MapAllocatedMemory[1024 * v15 + XTiles];
      v25 = &MapAllocatedMemory[1024 * v18 + 1024 + XTiles];
      do
      {
        if ( v15 - 1 < 0 || *(v24 - 1024) )
        {
          if ( v18 >= 1023 || *v25 )
            break;
          ++v18;
          v25 += 1024;
        }
        else
        {
          --v15;
          v24 -= 1024;
        }
        ++v23;
      }
      while ( v23 < BrickSpanSize );
    }
    *Y1Tile = v15;
    *Y2Tile = v18;
    *X1Tile = XTiles;
    *X2Tile = XTiles;
  }
  else
  {
    if ( v10 <= XTiles - v19 )
      v10 = XTiles - v19;
    v20 = XTiles + v19;
    if ( v12 >= v20 )
      v12 = v20;
    for ( j = v12 - v10 + 1; j < BrickSpanSize; ++j )
    {
      if ( v10 - 1 < 0 || MapAllocatedMemory[1024 * YTiles - 1 + v10] )
      {
        if ( v12 >= 1023 || MapAllocatedMemory[1024 * YTiles + 1 + v12] )
          break;
        ++v12;
      }
      else
      {
        --v10;
      }
    }
    *X1Tile = v10;
    *X2Tile = v12;
    *Y1Tile = YTiles;
    *Y2Tile = YTiles;
  }
}

//----- (00406E30) --------------------------------------------------------
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key)
{
  signed int v2; // edi
  int v3; // ecx
  int v4; // eax
  char *v5; // esi
  unsigned int v6; // ebx
  char *v7; // edx
  char *v8; // ecx
  char v9; // al
  int v11; // [esp+8h] [ebp+4h]

  v2 = Key;
  v3 = Key % 32;
  if ( Key % 32 < 1024 )
  {
    v4 = 1024 - Key % 31;
    v5 = &MapData[1024 * v3 + Key % 31];
    v11 = v4;
    v6 = (unsigned int)(1055 - v3) >> 5;
    do
    {
      v7 = &v5[v4];
      v8 = v5;
      if ( v5 < &v5[v4] )
      {
        do
        {
          v9 = *v8;
          if ( *v8 && (unsigned __int8)v9 < 0xA1u || v9 == -85 )
            Key += (unsigned __int8)*v8 ^ v2;
          v8 += 31;
        }
        while ( v8 < v7 );
        v4 = v11;
      }
      v5 += 0x8000;
      --v6;
    }
    while ( v6 );
  }
  return Key;
}

//----- (00406ED0) --------------------------------------------------------
signed int __cdecl sub_406ED0(int level_file)
{
  signed int v1; // ebx
  int v2; // eax
  int v3; // ebp
  LONG v4; // edi
  int v5; // eax
  LONG v6; // eax
  unsigned int v7; // eax
  int v8; // esi
  int *v9; // edi
  int *v10; // ecx
  int v11; // eax
  signed int result; // eax
  char v13[2]; // [esp+8h] [ebp-8h] BYREF
  LONG v14; // [esp+Ah] [ebp-6h]

  v1 = 1;
  v2 = fopen(level_file, "rb");
  v3 = v2;
  if ( !v2 )
    return 0;
  v4 = 0;
  if ( fread(v13, 1, 6, v2) == 6 && v13[0] == 66 && v13[1] == 77 )
    v4 = v14;
  v5 = _fileno(v3);
  v6 = _filelength(v5);
  if ( v4 < v6 && v4 >= 0 && (v7 = v6 - v4, v8 = v7 >> 2, 4 * (v7 >> 2) == v7) && (fseek(v3, v4, 0), v8 > 0) )
  {
    v9 = (int *)emalloc(4 * v8);
    fread(v9, v8, 4, v3);
    v10 = v9;
    do
    {
      v11 = *v10;
      if ( (*v10 & 0xFFFu) > 0x400 || (v11 & 0xFFF000u) > (unsigned int)dword_400000 || (v11 & 0xFF000000) == 0 )
        v1 = 0;
      ++v10;
      --v8;
    }
    while ( v8 );
    efree(v9);
    fclose(v3);
    result = v1;
  }
  else
  {
    fclose(v3);
    result = 0;
  }
  return result;
}
// 406F8B: conditional instruction was optimized away because of 'esi.4>=1'
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00407000) --------------------------------------------------------
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll)
{
  *((_DWORD *)textFile + 66) = makeUpperCase;
  *((_DWORD *)textFile + 67) = addAll;
  if ( Source )
  {
    strncpy((char *)textFile, Source, 0x100u);
    *((_BYTE *)textFile + 255) = 0;
  }
  else
  {
    *(_BYTE *)textFile = 0;
  }
  *((_DWORD *)textFile + 65) = 0;
  *((_DWORD *)textFile + 64) = 0;
  LoadTextFile(textFile, 1);
}

//----- (00407060) --------------------------------------------------------
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile)
{
  int i; // edi

  if ( *((_DWORD *)textFile + 64) )
  {
    for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
      efree(*(LPVOID *)(*((_DWORD *)textFile + 64) + 4 * i));
    ExpandMemory(*((LPVOID *)textFile + 64), 0, 1);
    *((_DWORD *)textFile + 64) = 0;
    *((_DWORD *)textFile + 65) = 0;
  }
}

//----- (004070D0) --------------------------------------------------------
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2)
{
  int i; // esi
  int v4; // eax
  int v5; // esi
  char *j; // eax
  char v7[512]; // [esp+10h] [ebp-200h] BYREF

  if ( a2 || !*(_BYTE *)textFile || IsFileLastWrittenTime((LPCSTR)textFile, (int)textFile + 272) )
  {
    if ( *((_DWORD *)textFile + 64) )
    {
      for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
        efree(*(LPVOID *)(*((_DWORD *)textFile + 64) + 4 * i));
      ExpandMemory(*((LPVOID *)textFile + 64), 0, 1);
      *((_DWORD *)textFile + 64) = 0;
      *((_DWORD *)textFile + 65) = 0;
    }
    if ( *(_BYTE *)textFile )
    {
      v4 = fopen(textFile, "rt");
      v5 = v4;
      if ( v4 )
      {
        if ( (*(_BYTE *)(v4 + 12) & 0x10) == 0 )
        {
          do
          {
            if ( fgets(v7, 512, v5) )
            {
              for ( j = &v7[strlen(v7)]; j != v7; --j )
              {
                if ( *(j - 1) >= 32 )
                  break;
              }
              *j = 0;
              if ( strlen(v7) )
                AddLineTextFile(textFile, v7);
            }
          }
          while ( (*(_BYTE *)(v5 + 12) & 0x10) == 0 );
        }
        fclose(v5);
      }
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 4070D0: using guessed type char var_200[512];

//----- (00407200) --------------------------------------------------------
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile)
{
  int v2; // ebx
  int i; // esi

  if ( *(_BYTE *)textFile )
  {
    v2 = fopen(textFile, "wt");
    if ( v2 )
    {
      for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
        fprintf(v2, "%s\n", *(const char **)(*((_DWORD *)textFile + 64) + 4 * i));
      fclose(v2);
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);

//----- (00407260) --------------------------------------------------------
int __thiscall sub_407260(int this)
{
  return *(_DWORD *)(this + 260);
}

//----- (00407270) --------------------------------------------------------
int __thiscall sub_407270(int this, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(this + 256) + 4 * a2);
}

//----- (00407280) --------------------------------------------------------
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer)
{
  int v3; // esi
  int v4; // eax
  char *v5; // eax
  size_t v6; // ecx
  unsigned int v8; // [esp+10h] [ebp-4h] BYREF
  char *v9; // [esp+18h] [ebp+4h]

  v3 = 0;
  v4 = BinarySearch(
         (int)ChatMsgBuffer,
         *((_DWORD *)textFile + 64),
         *((_DWORD *)textFile + 65),
         4,
         (int (__cdecl *)(_DWORD, _DWORD))loc_407470,
         &v8);
  if ( !v8 || !*((_DWORD *)textFile + 67) )
  {
    if ( v4 )
      v3 = (v4 - *((_DWORD *)textFile + 64)) >> 2;
    v5 = (char *)ExpandMemory(*((LPVOID *)textFile + 64), 4 * *((_DWORD *)textFile + 65) + 4, 2048);
    v6 = 4 * (*((_DWORD *)textFile + 65) + 0x3FFFFFFF * v3);
    *((_DWORD *)textFile + 64) = v5;
    memcpy(&v5[4 * v3 + 4], &v5[4 * v3], v6);
    v9 = (char *)emalloc(strlen(ChatMsgBuffer) + 1);
    strcpy(v9, ChatMsgBuffer);
    *(_DWORD *)(*((_DWORD *)textFile + 64) + 4 * v3) = v9;
    if ( *((_DWORD *)textFile + 66) )
      _strupr(*(char **)(*((_DWORD *)textFile + 64) + 4 * v3));
    ++*((_DWORD *)textFile + 65);
  }
}
// 407470: using guessed type int __stdcall loc_407470(char);

//----- (004073A0) --------------------------------------------------------
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number)
{
  int v2; // ecx
  int v3; // esi
  int v4; // ecx

  v3 = v2;
  efree(*(LPVOID *)(*(_DWORD *)(v2 + 256) + 4 * (_DWORD)textFile));
  v4 = *(_DWORD *)(v3 + 260) - 1;
  *(_DWORD *)(v3 + 260) = v4;
  memcpy(
    (void *)(4 * (_DWORD)textFile + *(_DWORD *)(v3 + 256)),
    (const void *)(*(_DWORD *)(v3 + 256) + 4 * (_DWORD)textFile + 4),
    4 * (v4 + 0x3FFFFFFF * (_DWORD)textFile));
  *(_DWORD *)(v3 + 256) = ExpandMemory(*(LPVOID *)(v3 + 256), 4 * *(_DWORD *)(v3 + 260), 2048);
}
// 4073A7: variable 'v2' is possibly undefined
// 4073A0: inconsistent function type and number of purged bytes

//----- (00407420) --------------------------------------------------------
int __thiscall sub_407420(int this, int a2)
{
  int v3; // eax
  int result; // eax

  v3 = BinarySearch(
         a2,
         *(_DWORD *)(this + 256),
         *(_DWORD *)(this + 260),
         4,
         (int (__cdecl *)(_DWORD, _DWORD))loc_407470,
         (unsigned int *)&a2);
  if ( a2 )
    result = (v3 - *(_DWORD *)(this + 256)) >> 2;
  else
    result = -1;
  return result;
}
// 407470: using guessed type int __stdcall loc_407470(char);

//----- (00407490) --------------------------------------------------------
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src)
{
  char *v2; // esi
  int v3; // ecx
  char v4; // al
  char *i; // ecx

  *a1 = 0;
  v2 = Src;
  if ( isspace(*Src) == 32 )
  {
    do
      v3 = *++v2;
    while ( isspace(v3) == 32 );
  }
  v4 = *v2;
  for ( i = a1; v4; ++v2 )
  {
    if ( v4 == 44 )
      break;
    *i = v4;
    v4 = v2[1];
    ++i;
  }
  *i = 0;
  if ( *v2 == 44 )
    ++v2;
  strcpy(Src, v2);
  return a1;
}

//----- (00407510) --------------------------------------------------------
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int a2)
{
  HANDLE v2; // eax
  void *v3; // esi
  struct _FILETIME LastWriteTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+Ch] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+14h] [ebp-8h] BYREF

  v2 = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
  v3 = v2;
  if ( v2 != (HANDLE)-1 )
  {
    GetFileTime(v2, &CreationTime, &LastAccessTime, &LastWriteTime);
    CloseHandle(v3);
    v2 = (HANDLE)LastWriteTime.dwLowDateTime;
  }
  if ( *(HANDLE *)a2 == v2 )
    return 0;
  *(_DWORD *)a2 = v2;
  return 1;
}

//----- (00407580) --------------------------------------------------------
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer)
{
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // edi

  v6 = 0;
  result = 0;
  *FoundPointer = 0;
  if ( !TotalElements )
    return result;
  v8 = Array;
  v9 = Array + ElementSize * (TotalElements - 1);
  if ( Array > v9 )
  {
LABEL_9:
    if ( result > 0 )
      v6 += ElementSize;
    return v6;
  }
  while ( 1 )
  {
    v6 = v8 + ElementSize * ((int)(v9 - v8) / ElementSize / 2);
    result = CompareFunc(ElementToFind, v6);
    if ( result < 0 )
    {
      if ( v6 == Array )
        goto LABEL_9;
      v9 = v6 - ElementSize;
      goto LABEL_8;
    }
    if ( result <= 0 )
      break;
    v8 = v6 + ElementSize;
LABEL_8:
    if ( v8 > v9 )
      goto LABEL_9;
  }
  *FoundPointer = 1;
  if ( v6 == Array )
    return Array;
  while ( 1 )
  {
    v6 -= ElementSize;
    if ( CompareFunc(ElementToFind, v6) )
      break;
    if ( v6 == Array )
      return Array;
  }
  return v6 + ElementSize;
}

//----- (00407630) --------------------------------------------------------
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName)
{
  UINT v4; // esi
  CHAR String[12]; // [esp+10h] [ebp-10h] BYREF

  v4 = GetPrivateProfileIntA(lpAppName, lpKeyName, -12345678, lpFileName);
  if ( v4 == -12345678 )
  {
    v4 = a3;
    sprintf(String, "%d", a3);
    WritePrivateProfileStringA(lpAppName, lpKeyName, String, lpFileName);
  }
  return v4;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00407690) --------------------------------------------------------
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
{
  int result; // eax

  GetPrivateProfileStringA(lpAppName, lpKeyName, "1x2y3z4", lpReturnedString, nSize, lpFileName);
  result = strcmp(lpReturnedString, "1x2y3z4");
  if ( !result )
  {
    strcpy(lpReturnedString, lpDefault);
    result = WritePrivateProfileStringA(lpAppName, lpKeyName, lpReturnedString, lpFileName);
  }
  return result;
}

//----- (00407730) --------------------------------------------------------
void __cdecl config_read_helper_3(char *a1)
{
  char *v1; // ecx
  char *v2; // esi
  char v3; // dl
  char i; // dl
  char v5; // bl

  v1 = a1;
  v2 = a1;
  if ( *a1 == 32 )
  {
    do
      v3 = *++v1;
    while ( v3 == 32 );
  }
  for ( i = *v1; i; ++v1 )
  {
    if ( i != 32 || (v5 = v1[1], v5 != 32) && v5 )
      *v2++ = i;
    i = v1[1];
  }
  *v2 = 0;
}

//----- (00407780) --------------------------------------------------------
signed int __cdecl CRC32(char *buffer, int fileSize)
{
  char *v2; // ecx
  int v3; // eax
  int v5[256]; // [esp+4h] [ebp-400h]

  v5[0] = 0;
  v5[1] = 1996959894;
  v5[2] = -301047508;
  v5[3] = -1727442502;
  v5[4] = 124634137;
  v5[5] = 1886057615;
  v5[6] = -379345611;
  v5[7] = -1637575261;
  v5[8] = 249268274;
  v5[9] = 2044508324;
  v5[10] = -522852066;
  v5[11] = -1747789432;
  v5[12] = 162941995;
  v5[13] = 2125561021;
  v5[14] = -407360249;
  v5[15] = -1866523247;
  v5[16] = 498536548;
  v5[17] = 1789927666;
  v5[18] = -205950648;
  v5[19] = -2067906082;
  v5[20] = 450548861;
  v5[21] = 1843258603;
  v5[22] = -187386543;
  v5[23] = -2083289657;
  v5[24] = 325883990;
  v5[25] = 1684777152;
  v5[26] = -43845254;
  v5[27] = -1973040660;
  v5[28] = 335633487;
  v5[29] = 1661365465;
  v5[30] = -99664541;
  v5[31] = -1928851979;
  v5[32] = 997073096;
  v5[33] = 1281953886;
  v5[34] = -715111964;
  v5[35] = -1570279054;
  v5[36] = 1006888145;
  v5[37] = 1258607687;
  v5[38] = -770865667;
  v5[39] = -1526024853;
  v5[40] = 901097722;
  v5[41] = 1119000684;
  v5[42] = -608450090;
  v5[43] = -1396901568;
  v5[44] = 853044451;
  v5[45] = 1172266101;
  v5[46] = -589951537;
  v5[47] = -1412350631;
  v5[48] = 651767980;
  v5[49] = 1373503546;
  v5[50] = -925412992;
  v5[51] = -1076862698;
  v5[52] = 565507253;
  v5[53] = 1454621731;
  v5[54] = -809855591;
  v5[55] = -1195530993;
  v5[56] = 671266974;
  v5[57] = 1594198024;
  v5[58] = -972236366;
  v5[59] = -1324619484;
  v5[60] = 795835527;
  v5[61] = 1483230225;
  v5[62] = -1050600021;
  v5[63] = -1234817731;
  v5[64] = 1994146192;
  v5[65] = 31158534;
  v5[66] = -1731059524;
  v5[67] = -271249366;
  v5[68] = 1907459465;
  v5[69] = 112637215;
  v5[70] = -1614814043;
  v5[71] = -390540237;
  v5[72] = 2013776290;
  v5[73] = 251722036;
  v5[74] = -1777751922;
  v5[75] = -519137256;
  v5[76] = 2137656763;
  v5[77] = 141376813;
  v5[78] = -1855689577;
  v5[79] = -429695999;
  v5[80] = 1802195444;
  v5[81] = 476864866;
  v5[82] = -2056965928;
  v5[83] = -228458418;
  v5[84] = 1812370925;
  v5[85] = 453092731;
  v5[86] = -2113342271;
  v5[87] = -183516073;
  v5[88] = 1706088902;
  v5[89] = 314042704;
  v5[90] = -1950435094;
  v5[91] = -54949764;
  v5[92] = 1658658271;
  v5[93] = 366619977;
  v5[94] = -1932296973;
  v5[95] = -69972891;
  v5[96] = 1303535960;
  v5[97] = 984961486;
  v5[98] = -1547960204;
  v5[99] = -725929758;
  v5[100] = 1256170817;
  v5[101] = 1037604311;
  v5[102] = -1529756563;
  v5[103] = -740887301;
  v5[104] = 1131014506;
  v5[105] = 879679996;
  v5[106] = -1385723834;
  v5[107] = -631195440;
  v5[108] = 1141124467;
  v5[109] = 855842277;
  v5[110] = -1442165665;
  v5[111] = -586318647;
  v5[112] = 1342533948;
  v5[113] = 654459306;
  v5[114] = -1106571248;
  v5[115] = -921952122;
  v5[116] = 1466479909;
  v5[117] = 544179635;
  v5[118] = -1184443383;
  v5[119] = -832445281;
  v5[120] = 1591671054;
  v5[121] = 702138776;
  v5[122] = -1328506846;
  v5[123] = -942167884;
  v5[124] = 1504918807;
  v5[125] = 783551873;
  v5[126] = -1212326853;
  v5[127] = -1061524307;
  v5[128] = -306674912;
  v5[129] = -1698712650;
  v5[130] = 62317068;
  v5[131] = 1957810842;
  v5[132] = -355121351;
  v5[133] = -1647151185;
  v5[134] = 81470997;
  v5[135] = 1943803523;
  v5[136] = -480048366;
  v5[137] = -1805370492;
  v5[138] = 225274430;
  v5[139] = 2053790376;
  v5[140] = -468791541;
  v5[141] = -1828061283;
  v5[142] = 167816743;
  v5[143] = 2097651377;
  v5[144] = -267414716;
  v5[145] = -2029476910;
  v5[146] = 503444072;
  v5[147] = 1762050814;
  v5[148] = -144550051;
  v5[149] = -2140837941;
  v5[150] = 426522225;
  v5[151] = 1852507879;
  v5[152] = -19653770;
  v5[153] = -1982649376;
  v5[154] = 282753626;
  v5[155] = 1742555852;
  v5[156] = -105259153;
  v5[157] = -1900089351;
  v5[158] = 397917763;
  v5[159] = 1622183637;
  v5[160] = -690576408;
  v5[161] = -1580100738;
  v5[162] = 953729732;
  v5[163] = 1340076626;
  v5[164] = -776247311;
  v5[165] = -1497606297;
  v5[166] = 1068828381;
  v5[167] = 1219638859;
  v5[168] = -670225446;
  v5[169] = -1358292148;
  v5[170] = 906185462;
  v5[171] = 1090812512;
  v5[172] = -547295293;
  v5[173] = -1469587627;
  v5[174] = 829329135;
  v5[175] = 1181335161;
  v5[176] = -882789492;
  v5[177] = -1134132454;
  v5[178] = 628085408;
  v5[179] = 1382605366;
  v5[180] = -871598187;
  v5[181] = -1156888829;
  v5[182] = 570562233;
  v5[183] = 1426400815;
  v5[184] = -977650754;
  v5[185] = -1296233688;
  v5[186] = 733239954;
  v5[187] = 1555261956;
  v5[188] = -1026031705;
  v5[189] = -1244606671;
  v5[190] = 752459403;
  v5[191] = 1541320221;
  v5[192] = -1687895376;
  v5[193] = -328994266;
  v5[194] = 1969922972;
  v5[195] = 40735498;
  v5[196] = -1677130071;
  v5[197] = -351390145;
  v5[198] = 1913087877;
  v5[199] = 83908371;
  v5[200] = -1782625662;
  v5[201] = -491226604;
  v5[202] = 2075208622;
  v5[203] = 213261112;
  v5[204] = -1831694693;
  v5[205] = -438977011;
  v5[206] = 2094854071;
  v5[207] = 198958881;
  v5[208] = -2032938284;
  v5[209] = -237706686;
  v5[210] = 1759359992;
  v5[211] = 534414190;
  v5[212] = -2118248755;
  v5[213] = -155638181;
  v5[214] = 1873836001;
  v5[215] = 414664567;
  v5[216] = -2012718362;
  v5[217] = -15766928;
  v5[218] = 1711684554;
  v5[219] = 285281116;
  v5[220] = -1889165569;
  v5[221] = -127750551;
  v5[222] = 1634467795;
  v5[223] = 376229701;
  v5[224] = -1609899400;
  v5[225] = -686959890;
  v5[226] = 1308918612;
  v5[227] = 956543938;
  v5[228] = -1486412191;
  v5[229] = -799009033;
  v5[230] = 1231636301;
  v5[231] = 1047427035;
  v5[232] = -1362007478;
  v5[233] = -640263460;
  v5[234] = 1088359270;
  v5[235] = 936918000;
  v5[236] = -1447252397;
  v5[237] = -558129467;
  v5[238] = 1202900863;
  v5[239] = 817233897;
  v5[240] = -1111625188;
  v5[241] = -893730166;
  v2 = buffer;
  v3 = -1;
  v5[242] = 1404277552;
  v5[243] = 615818150;
  v5[244] = -1160759803;
  v5[245] = -841546093;
  v5[246] = 1423857449;
  v5[247] = 601450431;
  v5[248] = -1285129682;
  v5[249] = -1000256840;
  v5[250] = 1567103746;
  v5[251] = 711928724;
  v5[252] = -1274298825;
  v5[253] = -1022587231;
  v5[254] = 1510334235;
  for ( v5[255] = 755167117; v2 < &buffer[fileSize]; ++v2 )
    v3 = v5[(unsigned __int8)*v2 ^ (unsigned __int8)v3] ^ (v3 >> 8) & 0xFFFFFF;
  return ~v3;
}

//----- (00408270) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_408270(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // edi
  int v4; // eax
  int v5; // [esp+8h] [ebp-800h] BYREF
  void *retaddr; // [esp+808h] [ebp+0h]

  result = fopen(a1, "rb");
  v2 = result;
  if ( result )
  {
    v3 = fopen(retaddr, "wb");
    if ( v3 )
    {
      while ( (*(_BYTE *)(v2 + 12) & 0x10) == 0 )
      {
        v4 = fread(&v5, 1, 2048, v2);
        if ( v4 > 0 )
          fwrite(&v5, 1, v4, v3);
      }
      fclose(v3);
    }
    result = fclose(v2);
  }
  return result;
}
// 4082FB: positive sp value 4 has been found
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00408310) --------------------------------------------------------
// returns ptr to alloced space, with a preceding dword with the allocced size
// 
// uses virtualalloc if sz is >= half a meg
// 
// ex:
// emalloc(DWORD sz)
//    DWORD *buf = malloc(sz + 4);
//    buf[0] = sz + 4;
//    return &buf[1];
// 
void *__cdecl emalloc(int bytes)
{
  _DWORD *v1; // eax
  void *v2; // esi
  CHAR Text[252]; // [esp+8h] [ebp-100h] BYREF

  if ( bytes + 4 <= 0x80000 )
    v1 = malloc(bytes + 4);
  else
    v1 = VirtualAlloc(0, bytes + 4, MEM_COMMIT, 4u);
  if ( v1 )
  {
    *v1 = bytes + 4;
    v2 = v1 + 1;
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
  {
    sprintf(Text, "Out of memory (Alloc:%d)", bytes);
    MessageBoxA(0, Text, "Error", 48u);
    exit(1);
  }
  return v2;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004083A0) --------------------------------------------------------
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3)
{
  int v3; // ecx
  int v4; // edi
  _DWORD *v5; // eax
  LPVOID v6; // esi
  LPVOID result; // eax
  char *v8; // eax
  int v9; // esi
  signed int v10; // edi
  signed int *v11; // eax
  signed int *v12; // eax
  void *v13; // ebp
  unsigned int v14; // ecx
  int *v15; // [esp+10h] [ebp-104h]
  CHAR Text[256]; // [esp+14h] [ebp-100h] BYREF

  v3 = a3;
  if ( a2 > 0x80000 )
    v3 = 16 * a3;
  v4 = v3 * ((v3 + a2 - 1) / v3);
  if ( lpAddress )
  {
    if ( v4 )
    {
      v9 = *((_DWORD *)lpAddress - 1);
      v10 = v4 + 4;
      v15 = (int *)((char *)lpAddress - 4);
      if ( v10 == v9 )
      {
        result = lpAddress;
      }
      else if ( v9 > 0x80000 || v10 > 0x80000 )
      {
        if ( v10 <= 0x80000 )
          v12 = (signed int *)malloc(v10);
        else
          v12 = (signed int *)VirtualAlloc(0, v10, MEM_COMMIT, PAGE_READWRITE);
        if ( v12 )
        {
          *v12 = v10;
          v13 = v12 + 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
        {
          sprintf(Text, "Out of memory (Alloc:%d)", v10 - 4);
          MessageBoxA(0, Text, "Error", 0x30u);
          exit(1);
        }
        v14 = v9 - 4;
        if ( v9 - 4 >= v10 - 4 )
          v14 = v10 - 4;
        qmemcpy(v13, lpAddress, v14);
        if ( *v15 <= 0x80000 )
          free(v15);
        else
          VirtualFree(v15, 0, MEM_RELEASE);
        result = v13;
      }
      else
      {
        v11 = (signed int *)realloc((char *)lpAddress - 4, v10);
        if ( !v11 )
        {
          MessageBoxA(0, "Out of memory (Resize)", "Error", 0x30u);
          exit(1);
        }
        *v11 = v10;
        result = v11 + 1;
      }
    }
    else
    {
      v8 = (char *)lpAddress - 4;
      if ( *((int *)lpAddress - 1) <= 0x80000 )
        free(v8);
      else
        VirtualFree(v8, 0, MEM_RELEASE);
      result = 0;
    }
  }
  else
  {
    if ( v4 + 4 <= 0x80000 )
      v5 = malloc(v4 + 4);
    else
      v5 = VirtualAlloc(0, v4 + 4, 0x1000u, 4u);
    if ( v5 )
    {
      *v5 = v4 + 4;
      v6 = v5 + 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
    {
      sprintf(Text, "Out of memory (Alloc:%d)", v4);
      MessageBoxA(0, Text, "Error", 0x30u);
      exit(1);
    }
    result = v6;
  }
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004085C0) --------------------------------------------------------
// see emalloc()
void __stdcall efree(LPVOID ptr)
{
  if ( *((int *)ptr - 1) <= 0x80000 )
    free((char *)ptr - 4);
  else
    VirtualFree((char *)ptr - 4, 0, 0x8000u);
}
// 4085C0: inconsistent function type and number of purged bytes

//----- (004085F0) --------------------------------------------------------
SOCKET *__thiscall ConnectSocket(SOCKET *this, char *cp, int netshort, unsigned int buf)
{
  SOCKET v5; // eax
  u_long v6; // eax
  SOCKET v7; // ecx
  unsigned __int32 v8; // edi
  struct hostent *v9; // eax
  DWORD v10; // kr00_4
  SOCKET v11; // eax
  SOCKET v13; // [esp-14h] [ebp-48h]
  SOCKET v14; // [esp-14h] [ebp-48h]
  SOCKET v15; // [esp-14h] [ebp-48h]
  char optval[4]; // [esp+Ch] [ebp-28h] BYREF
  u_long argp; // [esp+10h] [ebp-24h] BYREF
  struct sockaddr name; // [esp+14h] [ebp-20h] BYREF
  struct sockaddr v19; // [esp+24h] [ebp-10h] BYREF

  v5 = socket(2, 2, 0);
  *this = v5;
  argp = 1;
  ioctlsocket(v5, -2147195266, &argp);
  v13 = *this;
  *(_DWORD *)optval = -1;
  setsockopt(v13, 6, SO_DEBUG, optval, 4);
  v14 = *this;
  *(_DWORD *)optval = 0x8000;
  setsockopt(v14, 0xFFFF, SO_SNDBUF, optval, 4);
  v15 = *this;
  *(_DWORD *)optval = 0x8000;
  setsockopt(v15, 0xFFFF, SO_RCVBUF, optval, 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(buf);
  v6 = ntohl(0);
  v7 = *this;
  *(_DWORD *)&name.sa_data[2] = v6;
  bind(v7, &name, 16);
  v8 = inet_addr(cp);
  if ( v8 == -1 )
  {
    v9 = gethostbyname(cp);
    if ( v9 )
      v8 = **(_DWORD **)v9->h_addr_list;
  }
  v19.sa_family = 2;
  *(_DWORD *)&v19.sa_data[2] = v8;
  *(_WORD *)v19.sa_data = ntohs(netshort);
  connect(*this, &v19, 16);
  this[1] = -1;
  this[2] = -1;
  v10 = GetTickCount();
  v11 = *this;
  buf = v10 / 0xA;
  send(v11, (const char *)&buf, 4, 0);
  return this;
}

//----- (00408740) --------------------------------------------------------
int __thiscall sub_408740(SOCKET *this)
{
  return closesocket(*this);
}

//----- (00408750) --------------------------------------------------------
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3)
{
  DWORD v4; // [esp+Ch] [ebp-404h] BYREF
  char buf[4]; // [esp+10h] [ebp-400h] BYREF
  char v6[1020]; // [esp+14h] [ebp-3FCh] BYREF

  if ( a2 && (int)a3 > 0 )
  {
    *(_DWORD *)buf = 0;
    qmemcpy(v6, a2, a3);
    send(*(_DWORD *)this, buf, a3 + 4, 0);
  }
  else
  {
    v4 = GetTickCount() / 0xA;
    send(*(_DWORD *)this, (const char *)&v4, 4, 0);
  }
}
// 408750: using guessed type char var_3FC[1020];

//----- (004087D0) --------------------------------------------------------
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed)
{
  int v3; // esi
  char buf[4]; // [esp+Ch] [ebp-200h] BYREF
  int v6; // [esp+10h] [ebp-1FCh]

  do
  {
    if ( recv(*(_DWORD *)Socket, buf, 512, MSG_PEEK) == -1 )
      break;
    v3 = recv(*(_DWORD *)Socket, buf, 512, 0);
    if ( v3 == 8 )
    {
      *(_DWORD *)(Socket + 4) = *(_DWORD *)buf;
      *(_DWORD *)(Socket + 8) = GetTickCount() / 0xA - v6;
    }
  }
  while ( v3 != -1 );
  *TimeElapsed = *(_DWORD *)(Socket + 8);
  return *(_DWORD *)(Socket + 4);
}

//----- (00408860) --------------------------------------------------------
// PINGSOCKET.PingSocket()
PINGSOCKET *__thiscall ListenOnPort(PINGSOCKET *socket, __int16 port, void *callback)
{
  SOCKET v4; // eax
  u_long v5; // eax
  int v6; // ecx
  int v8; // [esp-14h] [ebp-2Ch]
  int v9; // [esp-14h] [ebp-2Ch]
  int v10; // [esp-14h] [ebp-2Ch]
  u_long argp; // [esp+4h] [ebp-14h] BYREF
  struct sockaddr name; // [esp+8h] [ebp-10h] BYREF

  socket->fnCallback = (int)callback;
  v4 = ::socket(AF_INET, SOCK_DGRAM, 0);
  socket->socket = v4;
  argp = 1;
  ioctlsocket(v4, -2147195266, &argp);
  v8 = socket->socket;
  callback = (void *)-1;
  setsockopt(v8, 6, 1, (const char *)&callback, 4);
  v9 = socket->socket;
  callback = (void *)0x2000;
  setsockopt(v9, 0xFFFF, SO_SNDBUF, (const char *)&callback, 4);
  v10 = socket->socket;
  callback = (void *)0x2000;
  setsockopt(v10, 0xFFFF, SO_RCVBUF, (const char *)&callback, 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(port);
  v5 = ntohl(0);
  v6 = socket->socket;
  *(_DWORD *)&name.sa_data[2] = v5;
  bind(v6, &name, 16);
  return socket;
}

//----- (00408930) --------------------------------------------------------
void __thiscall ProcessZonePings(int Socket, int ZonePopulation)
{
  int i; // ebp
  unsigned int v4; // eax
  void (__stdcall *v5)(_DWORD, char *, unsigned int); // ecx
  SOCKET v6; // eax
  SOCKET v7; // [esp-18h] [ebp-244h]
  int fromlen; // [esp+10h] [ebp-21Ch] BYREF
  int v9[2]; // [esp+14h] [ebp-218h] BYREF
  struct sockaddr from; // [esp+1Ch] [ebp-210h] BYREF
  char buf[4]; // [esp+2Ch] [ebp-200h] BYREF
  char v12[508]; // [esp+30h] [ebp-1FCh] BYREF

  for ( i = 0; i < 20; ++i )
  {
    v7 = *(_DWORD *)Socket;
    fromlen = 16;
    v4 = recvfrom(v7, buf, 512, 0, &from, &fromlen);
    if ( v4 == -1 )
      break;
    if ( v4 >= 4 )
    {
      if ( *(_DWORD *)buf )
      {
        v6 = *(_DWORD *)Socket;
        v9[1] = *(_DWORD *)buf;
        v9[0] = ZonePopulation;
        sendto(v6, (const char *)v9, 8, 0, &from, 16);
      }
      else
      {
        v5 = *(void (__stdcall **)(_DWORD, char *, unsigned int))(Socket + 4);
        if ( v5 )
        {
          if ( v4 > 4 )
            v5(*(_DWORD *)&from.sa_data[2], v12, v4 - 4);
        }
      }
    }
  }
}

//----- (004089E0) --------------------------------------------------------
// Player.Player()
PLAYER *__thiscall CreateNewPlayer(PLAYER *this, struct in_addr in, __int16 a3, NetData *nd)
{
  int v5; // edx
  int v6; // eax

  this->hProcess = 0;
  *(_DWORD *)this->field_4 = 0;
  *(_DWORD *)&this->field_4[4] = 0;
  *(_DWORD *)&this->field_4[8] = 0;
  memset(&this->field_44[36], 0, 0x40u);
  this->field_2B7[4] = 0;
  *(_DWORD *)&this->field_44[4] = 0;
  *(_DWORD *)&this->field_44[144] = 0;
  *(_DWORD *)&this->field_2F9[24] = 0;
  *(_DWORD *)&this->field_117[72] = -1;
  *(_DWORD *)this->field_44 = 0;
  *(_DWORD *)&this->field_44[28] = -1;
  *(_DWORD *)&this->field_44[24] = -1;
  *(_DWORD *)&this->field_44[20] = -1;
  this->bIsSilenced = 0;
  *(_DWORD *)&this->field_117[68] = 0;
  *(_DWORD *)&this->field_44[12] = -1;
  *(_DWORD *)&this->field_44[16] = -1;
  *(_DWORD *)&this->field_117[64] = 0;
  *(_DWORD *)&this->field_44[100] = 0;
  *(_DWORD *)&this->field_44[120] = 0;
  *(_DWORD *)&this->field_2C[16] = 0;
  *(_DWORD *)&this->field_44[8] = -1;
  *(_DWORD *)&this->field_117[60] = 0;
  this->connection_id = dword_42B534++;
  *(_DWORD *)&this->field_2F9[12] = 0;
  *(_DWORD *)&this->field_2C[8] = 0;
  *(_DWORD *)&this->field_2C[12] = 0;
  *(_DWORD *)&this->field_44[104] = 0;
  *(_DWORD *)&this->field_EA[19] = 0;
  this->lpNetworkData = (int)nd;
  this->lpCurrentArena = 0;
  *(_DWORD *)this->lpArenaPointer2 = 0;
  memset(&this->lpSomePtr, 0, 0x20u);
  this->Name[0] = 0;
  *(_DWORD *)&this->field_117[8] = 0;
  memset(&this->field_117[20], 0, 0x28u);
  *(_DWORD *)&this->field_319[8] = 1000;
  *(_DWORD *)&this->field_319[12] = 1000;
  *(_DWORD *)this->field_283 = 0;
  this->in_addr = in;
  this->port = a3;
  this->beginlog_file_ptr = 0;
  LOBYTE(this->beginlog_file_name) = 0;
  *(_DWORD *)this->field_117 = -1;
  this->bIsSysop = 0;
  this->bIsModerator = 0;
  this->bIsSmod = 0;
  *(_DWORD *)&this->field_231[50] = -1;
  memset(this->player_name, 0, 0xACu);
  this->dwUserID = -1;
  *(_DWORD *)&this->score.wins = 0;
  *(_DWORD *)&this->score.flags = 0;
  *(int *)((char *)&this->score.points + 2) = 0;
  HIWORD(this->score.flag_points) = 0;
  *(_DWORD *)this->field_231 = 0;
  *(_DWORD *)&this->field_231[4] = 0;
  *(_DWORD *)&this->field_231[8] = 0;
  *(_WORD *)&this->field_231[12] = 0;
  *(_DWORD *)&this->field_117[92] = -1;
  v5 = this->lpNetworkData;
  this->dwShip = 8;
  *(_DWORD *)&this->field_2B7[52] = 0;
  *(_DWORD *)&this->field_2B7[56] = 0;
  *(_DWORD *)&this->field_2C[4] = 0;
  v6 = *(_DWORD *)(v5 + 46);
  *(_DWORD *)&this->field_14 = v6;
  *(&PlayerArray + v6) = this;
  *(_DWORD *)&this->field_231[46] = GetTickCount() / 0xA;
  *(_DWORD *)&this->field_2F9[4] = time(0);
  *(_DWORD *)&this->field_283[20] = 0;
  *(_DWORD *)&this->field_283[4] = 0;
  *(_DWORD *)&this->field_283[8] = 0;
  *(_DWORD *)&this->field_283[28] = 0;
  *(_DWORD *)&this->field_283[12] = GetTickCount() / 0xA;
  *(_DWORD *)&this->field_283[16] = 0;
  *(_DWORD *)&this->field_283[24] = 0;
  *(_DWORD *)&this->field_283[28] = 0;
  *(_DWORD *)&this->field_44[112] = 0;
  *(_DWORD *)&this->field_44[128] = 0;
  *(_DWORD *)&this->field_44[132] = 0;
  *(_DWORD *)&this->field_44[136] = 0;
  *(_DWORD *)&this->field_44[140] = 0;
  this->dwDisconnectReason = 0;
  *(_DWORD *)this->field_319 = 0;
  *(_DWORD *)&this->field_319[4] = 0;
  *(_DWORD *)&this->field_2F9[20] = 0;
  *(_DWORD *)&this->field_44[116] = 0;
  *(_DWORD *)&this->field_2F9[16] = 1;
  return this;
}
// 42B534: using guessed type int dword_42B534;

//----- (00408C30) --------------------------------------------------------
// Player.Disconnect()
void __thiscall DisconnectPlayer(PLAYER *p)
{
  char *v2; // esi
  char *v3; // ebp
  int v4; // ecx
  int v5; // ebp
  char i; // al
  int v7; // ecx
  int v8; // ecx
  int *v9; // esi
  int v10; // ebp
  int v11; // eax
  int lag2; // [esp+10h] [ebp-B0h] BYREF
  int lag1; // [esp+14h] [ebp-ACh] BYREF
  int v14; // [esp+18h] [ebp-A8h]
  char v15; // [esp+1Ch] [ebp-A4h] BYREF
  char v16[35]; // [esp+1Dh] [ebp-A3h] BYREF
  char v17[128]; // [esp+40h] [ebp-80h] BYREF

  if ( p->hProcess )
  {
    TerminateProcess((HANDLE)p->hProcess, 0);
    CloseHandle((HANDLE)p->hProcess);
  }
  if ( p->beginlog_file_ptr )
  {
    fclose(p->beginlog_file_ptr);
    p->beginlog_file_ptr = 0;
  }
  if ( dword_4B061C > 0 && p->score.points + p->score.flag_points >= dword_4B061C )
  {
    v2 = lpszPermission_AutoPermissionIDList;
    while ( *v2 )
    {
      v3 = v17;
      if ( isdigit(*v2) )
      {
        do
        {
          v4 = v2[1];
          *v3++ = *v2++;
        }
        while ( isdigit(v4) );
      }
      *v3 = 0;
      v5 = atoi(v17);
      if ( v5 && FindMeOut1 )
      {
        v15 = 1;
        strncpy(v16, p->player_name, 0x20u);
        v16[31] = 0;
        SendBillerPlayerNamePacketSomething((struct BILLING_SERVER_STRUCT *)FindMeOut1, -1, v5, &v15, 0x21u);
      }
      for ( i = *v2; i; i = *++v2 )
      {
        if ( isdigit(i) )
          break;
      }
    }
  }
  v7 = p->lpCurrentArena;
  v14 = 0;
  if ( v7 )
  {
    v14 = *(_DWORD *)(v7 + 109754);
    ArenaRemovePlayer((struct ARENA *)v7, p);
    p->lpCurrentArena = 0;
  }
  sub_41D720(p->lpNetworkData, (int)&lag1, (int)&lag2);
  v8 = p->lpNetworkData;
  lag1 = 1000 - lag1;
  lag2 = 1000 - lag2;
  sub_41C360(v8);
  v9 = &p->lpSomePtr;
  v10 = 4;
  *(&PlayerArray + *(_DWORD *)&p->field_14) = 0;
  do
  {
    if ( *v9 )
    {
      efree((LPVOID)*v9);
      *v9 = 0;
    }
    v9 += 2;
    --v10;
  }
  while ( v10 );
  if ( FindMeOut1 )
  {
    v11 = 0;
    if ( dwMisc_DisableSharewareScores && *(_DWORD *)&p->field_44[4] )
      v11 = 1;
    if ( v14
      || (unsigned __int16)p->score.losses + (unsigned __int16)p->score.wins + p->score.points + p->score.flag_points <= 5
      && !*(_DWORD *)&p->field_2F9[20] )
    {
      v11 = 1;
    }
    if ( v11 )
      SendBillerUserLogoffPacket(
        (struct BILLING_SERVER_STRUCT *)FindMeOut1,
        p->connection_id,
        p->dwDisconnectReason,
        lag1,
        lag2,
        10 * *(_WORD *)&p->field_117[51],
        10 * *(_DWORD *)p->field_319 / (*(_DWORD *)&p->field_319[4] + 1),
        0,
        0);
    else
      SendBillerUserLogoffPacket(
        (struct BILLING_SERVER_STRUCT *)FindMeOut1,
        p->connection_id,
        p->dwDisconnectReason,
        lag1,
        lag2,
        10 * *(_WORD *)&p->field_117[51],
        10 * *(_DWORD *)p->field_319 / (*(_DWORD *)&p->field_319[4] + 1),
        &p->score,
        0xEu);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 4B061C: using guessed type int dword_4B061C;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (0040CBE0) --------------------------------------------------------
// Player.GenerateWarning()
void __thiscall GenerateWarning(struct PLAYER *player, int a2)
{
  int v3; // edx
  const char *v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  char violation[252]; // [esp+8h] [ebp-100h] BYREF

  if ( !player->bIsSmod )
  {
    v3 = 1;
    v4 = "Unknown integrity violation";
    switch ( a2 )
    {
      case 0:
        v4 = "Normal integrity";
        goto LABEL_33;
      case 1:
        v4 = "Slow frame detected";
        goto LABEL_33;
      case 2:
        v4 = "Current energy higher than top energy";
        goto LABEL_33;
      case 3:
        v4 = "Top energy higher than max energy";
        goto LABEL_33;
      case 4:
        v4 = "Max energy without getting prizes";
        goto LABEL_33;
      case 5:
        v4 = "Recharge rate higher than max recharge rate";
        goto LABEL_33;
      case 6:
        v4 = "Max recharge rate without getting prizes";
        goto LABEL_33;
      case 7:
        v4 = "Too many burst used";
        goto LABEL_33;
      case 8:
        v4 = "Too many repel used";
        goto LABEL_33;
      case 9:
        v4 = "Too many decoy used";
        goto LABEL_33;
      case 10:
        v4 = "Too many thor used";
        goto LABEL_33;
      case 11:
        v4 = "Too many wall blocks used";
        goto LABEL_33;
      case 12:
        v4 = "Stealth on but never collected";
        goto LABEL_33;
      case 13:
        v4 = "Cloak on but never collected";
        goto LABEL_33;
      case 14:
        v4 = "XRadar on but never collected";
        goto LABEL_33;
      case 15:
        v4 = "AntiWarp on but never collected";
        goto LABEL_33;
      case 16:
        v4 = "Proximity bombs but never collected";
        goto LABEL_33;
      case 17:
        v4 = "Bouncing bullets but never collected";
        goto LABEL_33;
      case 18:
        v4 = "Max guns without getting prizes";
        goto LABEL_33;
      case 19:
        v4 = "Max bombs without getting prizes";
        goto LABEL_33;
      case 20:
        v4 = "Shields or Super on longer than possible";
        goto LABEL_33;
      case 21:
        v3 = 0;
        v4 = "Saved ship weapon limits too high (burst/repel/etc)";
        goto LABEL_33;
      case 22:
        v3 = 0;
        v4 = "Saved ship weapon level too high (guns/bombs)";
        goto LABEL_33;
      case 23:
        v3 = 0;
        v4 = "Login checksum mismatch (program exited)";
        goto LABEL_33;
      case 24:
        v5 = player->lpCurrentArena;
        v6 = *(_DWORD *)&player->field_117[64] + 1;
        *(_DWORD *)&player->field_117[64] = v6;
        if ( v6 < *(_DWORD *)(v5 + 109814) )
          return;
        v4 = "S2C position packet modified";
LABEL_33:
        if ( !*(_DWORD *)&player->field_2F9[16] || !v3 )
        {
          sprintf(violation, "WARNING: %s", v4);
          ProtocolViolation();
          v7 = player->lpCurrentArena;
          if ( v7 )
          {
            if ( *(_DWORD *)(v7 + 109802) )
            {
              player->dwDisconnectReason = 3;
              *(_DWORD *)&player->field_2C[12] = 1;
            }
          }
        }
        break;
      case 25:
        v3 = 0;
        v4 = "Saved ship checksum mismatch";
        goto LABEL_33;
      case 26:
        v4 = "Softice Debugger Running";
        goto LABEL_33;
      case 27:
        v4 = "Data checksum mismatch detected";
        goto LABEL_33;
      case 28:
        v4 = "Parameter mismatch detected";
        goto LABEL_33;
      default:
        goto LABEL_33;
    }
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (0040CE10) --------------------------------------------------------
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr)
{
  int v2; // ecx
  int v3; // eax
  int v4; // ebx
  int v5; // edi
  struct ARENA *v6; // ecx
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  char buf; // [esp+10h] [ebp-10h] BYREF
  int v10; // [esp+11h] [ebp-Fh]
  int v11; // [esp+15h] [ebp-Bh]
  int v12; // [esp+19h] [ebp-7h]
  __int16 v13; // [esp+1Dh] [ebp-3h]
  char v14; // [esp+1Fh] [ebp-1h]

  v2 = playerr->lpCurrentArena;
  if ( v2 )
  {
    v3 = playerr->xPixels;
    v8 = playerr->yPixels;
    v4 = 0;
    v7 = v3;
    if ( *(int *)(v2 + 65390) > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        if ( !*(_DWORD *)(v5 + v2 + 65405) && *(__int16 *)(v5 + v2 + 65403) == *(_DWORD *)&playerr->field_14 )
        {
          if ( v3 <= 0 || v8 <= 0 )
          {
            sub_404050(v2, v4);
          }
          else
          {
            *(_BYTE *)(v5 + v2 + 65394) = v4;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65395) = v3;
            *(_DWORD *)(playerr->lpCurrentArena + v5 + 65397) = (unsigned __int16)v8;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65401) = 0;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65403) = playerr->field_14;
            *(_DWORD *)(playerr->lpCurrentArena + v5 + 65405) = GetTickCount() / 0xA;
            *(_DWORD *)(playerr->lpCurrentArena + 4 * v4 + 65514) = GetTickCount() / 0xA;
            v6 = (struct ARENA *)playerr->lpCurrentArena;
            buf = 46;
            v10 = *(_DWORD *)&v6->field_FF6A[v5 + 8];
            v11 = *(_DWORD *)&v6->field_FF6A[v5 + 12];
            v12 = *(_DWORD *)&v6->field_FF6A[v5 + 16];
            v13 = *(_WORD *)&v6->field_FF6A[v5 + 20];
            v14 = v6->field_FF6A[v5 + 22];
            ArenaSendPacket(v6, &buf, 16, 0);
          }
        }
        v2 = playerr->lpCurrentArena;
        ++v4;
        v5 += 15;
        if ( v4 >= *(_DWORD *)(v2 + 65390) )
          break;
        v3 = v7;
      }
    }
  }
}

//----- (0040CF70) --------------------------------------------------------
signed int __thiscall CheckUserStopPlaying(int this)
{
  signed int result; // eax
  DWORD (*v3)(void); // ebx
  __int64 v4; // rax
  __int64 v5; // rax
  DWORD v6; // eax
  unsigned int v7; // kr08_4
  int v8; // ebx
  unsigned int v9; // kr10_4
  signed int v10; // esi
  __int64 v11; // rax
  int v12; // esi
  unsigned int v13; // kr28_4
  int *YouToServerValue; // ebx
  int *v15; // esi
  int v16; // edi
  int v17; // eax
  unsigned int v18; // kr30_4
  int v19; // eax
  int v20; // esi
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  int v24; // eax
  int v25; // esi
  int v26; // [esp-8h] [ebp-524h]
  const char *v27; // [esp-8h] [ebp-524h]
  int v28; // [esp-4h] [ebp-520h]
  char v29; // [esp+13h] [ebp-509h] BYREF
  int i; // [esp+14h] [ebp-508h]
  DWORD ExitCode; // [esp+18h] [ebp-504h] BYREF
  char v32; // [esp+1Ch] [ebp-500h] BYREF
  char v33; // [esp+1Dh] [ebp-4FFh]
  char v34; // [esp+1Eh] [ebp-4FEh]
  __int16 v35; // [esp+1Fh] [ebp-4FDh]
  char v36[507]; // [esp+21h] [ebp-4FBh] BYREF
  char violation[256]; // [esp+21Ch] [ebp-300h] BYREF
  char buf[3]; // [esp+31Ch] [ebp-200h] BYREF
  __int16 v39; // [esp+31Fh] [ebp-1FDh]
  char v40[507]; // [esp+321h] [ebp-1FBh] BYREF

  if ( *(int *)(this + 647) > 0 )
    dword_4D9DE8 = 1;
  if ( *(_DWORD *)(this + 56) )
    return 1;
  v3 = GetTickCount;
  if ( *(_DWORD *)(this + 172) )
  {
    v4 = (int)(GetTickCount() / 0xA - *(_DWORD *)(this + 172));
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) > 1000 )
    {
      printf("KickOffTime expired: %s\n", (const char *)(this + offsetof(PLAYER, Name)));
      return 1;
    }
  }
  if ( !*(_BYTE *)(this + 675) )
  {
    v5 = (int)(GetTickCount() / 0xA - *(_DWORD *)(this + 607));
    if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 300 )
    {
      *(_DWORD *)(this + 16) = -1;
      *(_DWORD *)(this + 789) = 17;
      return 1;
    }
  }
  if ( !*(_DWORD *)(this + 28) )
  {
    if ( (int)abs32(GetTickCount() / 0xA - *(_DWORD *)(*(_DWORD *)(this + 40) + 58)) > dwMisc_MenuKickoutDelay )
    {
      v28 = this + 675;
      v27 = "Menu kickout delay exceeded: %s\n";
      goto LABEL_74;
    }
LABEL_72:
    if ( sub_41C510(*(_DWORD *)(this + 40)) != 4 )
      return 0;
    v28 = this + 675;
    v27 = "Connection status read as terminated: %s\n";
LABEL_74:
    printf(v27, v28);
    result = 1;
    *(_DWORD *)(this + 789) = 1;
    return result;
  }
  if ( *(_DWORD *)this && GetExitCodeProcess(*(HANDLE *)this, &ExitCode) && ExitCode != 259 )
  {
    TerminateProcess(*(HANDLE *)this, 0);
    CloseHandle(*(HANDLE *)this);
    v6 = ExitCode;
    *(_DWORD *)this = 0;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 12) = 0;
    sprintf(violation, "SPAWN TERMINATED: %d", v6);
    if ( *(_DWORD *)(this + 28) )
    {
      buf[0] = 7;
      buf[1] = 0;
      buf[2] = 0;
      v39 = -1;
      strcpy(v40, violation);
      v7 = strlen(violation) + 1;
      if ( GetRelAckDiff(*(struct CONNECTION **)(this + 40), 0) < 128 )
        PlayerSendPacket((PLAYER *)this, buf, v7 - 1 + 6, 1);
    }
    v8 = fopen("spawn.log", "rt");
    if ( v8 )
    {
      for ( i = 0; i < 40; ++i )
      {
        buf[0] = 0;
        fgets(buf, 256, v8);
        if ( *(_DWORD *)(this + 28) )
        {
          v32 = 7;
          v33 = 0;
          v34 = 0;
          v35 = -1;
          strcpy(v36, buf);
          v9 = strlen(buf) + 1;
          if ( GetRelAckDiff(*(struct CONNECTION **)(this + offsetof(PLAYER, lpNetworkData)), 0) < 128 )
            PlayerSendPacket((PLAYER *)this, &v32, v9 - 1 + 6, 1);
        }
        if ( (*(_BYTE *)(v8 + 12) & 0x10) != 0 )
          break;
      }
      fclose(v8);
    }
    v3 = GetTickCount;
  }
  v10 = abs32(v3() / 0xA - *(_DWORD *)(*(_DWORD *)(this + 40) + 58));
  if ( v10 > *(_DWORD *)(*(_DWORD *)(this + 28) + 109826) )
    *(_DWORD *)(this + 347) = v3() / 0xA;
  if ( v10 <= *(_DWORD *)(*(_DWORD *)(this + 28) + 109822)
    || *(_DWORD *)(this + 631) && (int)abs32(v3() / 0xA - *(_DWORD *)(*(_DWORD *)(this + 40) + 58)) <= 6000 )
  {
    if ( *(_DWORD *)(this + 72) )
    {
      v11 = (int)(v3() / 0xA - *(_DWORD *)(this + 607));
      if ( (int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) > dwMisc_MaxSharewareTime )
      {
        WriteSubGameLog("Shareware Timer Expired: %s\n", (const char *)(this + 675));
        v35 = *(_WORD *)(this + 20);
        *(_DWORD *)(this + 789) = 22;
        v32 = 7;
        v33 = 0;
        v34 = 0;
        strcpy(
          v36,
          "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.");
        v26 = strlen(
                "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.")
            + 6;
        goto LABEL_82;
      }
    }
    if ( (signed int)abs32(v3() / 0xA - *(_DWORD *)(*(_DWORD *)(this + 40) + 54)) > *(_DWORD *)(this + 1014) )
    {
      v29 = 39;
      WriteData(*(struct CONNECTION **)(this + 40), &v29, 1u, 0);
    }
    if ( *(_DWORD *)(this + 275) != 8 )
    {
      if ( *(_DWORD *)(this + 184) )
      {
        v12 = *(_DWORD *)(this + 28);
        if ( (signed int)(v3() / 0xA - *(_DWORD *)(this + 184)) > *(_DWORD *)(v12 + 109866) && !*(_DWORD *)(this + 631) )
        {
          if ( v12 )
          {
            v32 = 7;
            v33 = 0;
            v34 = 0;
            v35 = -1;
            strcpy(v36, "You have been put in spectator mode due to high latency (spike)");
            v13 = strlen("You have been put in spectator mode due to high latency (spike)") + 1;
            if ( GetRelAckDiff(*(struct CONNECTION **)(this + 40), 0) < 128 )
              PlayerSendPacket((PLAYER *)this, &v32, v13 - 1 + 6, 1);
          }
          SetPlayerShip((struct PLAYER *)this, 8);
        }
      }
    }
    YouToServerValue = (int *)(this + 805);
    v15 = (int *)(this + 801);
    sub_41D720(*(_DWORD *)(this + 40), this + 801, this + 805);
    v16 = 0;
    if ( *(_DWORD *)(this + 275) == 8 )
      v16 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109702);
    v17 = *(_DWORD *)(this + 28);
    if ( (*v15 < *(_DWORD *)(v17 + 109698) - v16
       || *YouToServerValue < *(_DWORD *)(v17 + 109690) - v16
       || *YouToServerValue > *(_DWORD *)(v17 + 109694) + v16 + 1000)
      && !*(_DWORD *)(this + 631) )
    {
      if ( *(_DWORD *)(this + 275) == 8 )
      {
        WriteSubGameLog(
          "Packet loss too high S2C:%d%%, C2S:%d%%, kicking out player: %s\n",
          (1000 - *v15) / 10,
          (1000 - *YouToServerValue) / 10,
          (const char *)(this + 675));
        v24 = *(_DWORD *)(this + 28);
        v25 = *v15;
        if ( v25 >= *(_DWORD *)(v24 + 109698) - v16 )
        {
          if ( *YouToServerValue <= *(_DWORD *)(v24 + 109694) + v16 + 1000 )
            *(_DWORD *)(this + 789) = 7;
          else
            *(_DWORD *)(this + 789) = 23;
        }
        else
        {
          *(_DWORD *)(this + 789) = 6;
        }
        sprintf(
          violation,
          "WARNING: Disconnected because of high packet loss (ServerToYou:%d%%, YouToServer:%d%%)",
          (1000 - v25) / 10,
          (1000 - *YouToServerValue) / 10);
        v35 = *(_WORD *)(this + 20);
        v32 = 7;
        v33 = 0;
        v34 = 0;
        strcpy(v36, violation);
        v26 = strlen(violation) + 6;
        goto LABEL_82;
      }
      if ( v17 )
      {
        v32 = 7;
        v33 = 0;
        v34 = 0;
        v35 = -1;
        strcpy(v36, "You have been put in spectator mode due to high packet loss");
        v18 = strlen("You have been put in spectator mode due to high packet loss") + 1;
        if ( GetRelAckDiff(*(struct CONNECTION **)(this + 40), 0) < 128 )
          PlayerSendPacket((PLAYER *)this, &v32, v18 - 1 + 6, 1);
      }
      SetPlayerShip((struct PLAYER *)this, 8);
    }
    v19 = *YouToServerValue;
    if ( *YouToServerValue >= 1000 )
      v19 = 1000;
    v20 = *(_DWORD *)(this + 801);
    v21 = v19 - v20;
    *(_DWORD *)(this + 339) = v21;
    if ( v20 > 900 || *(_DWORD *)(this + 631) || v21 < 0 )
      *(_DWORD *)(this + 339) = 0;
    if ( v20 < 1000 )
    {
      v22 = *(_DWORD *)(this + 291);
      if ( v22 > 400 && *(_DWORD *)(this + 275) != 8 )
      {
        v23 = 1000 * *(_DWORD *)(this + 295) / v22;
        if ( v20 - v23 > 100 && v23 < *(_DWORD *)(*(_DWORD *)(this + 28) + 109798) && !*(_DWORD *)(this + 631) )
        {
          sprintf(
            violation,
            "S2C weapon packet loss too high(S2CW=%d%%)(S2C=%d%%)",
            (1000 - v23) / 10,
            (1000 - v20) / 10);
          ProtocolViolation();
          *(_DWORD *)(this + 789) = 3;
          return 1;
        }
      }
    }
    goto LABEL_72;
  }
  WriteSubGameLog("Kickout delay exceeded: %s\n", (const char *)(this + 675));
  *(_DWORD *)(this + 789) = 9;
  v35 = *(_WORD *)(this + 20);
  v32 = 7;
  v33 = 0;
  v34 = 0;
  strcpy(v36, "WARNING: You have been disconnected because server has not been receiving data from you.");
  v26 = strlen("WARNING: You have been disconnected because server has not been receiving data from you.") + 6;
LABEL_82:
  PlayerSendPacket((PLAYER *)this, &v32, v26, 0);
  sub_41D6D0(*(_DWORD *)(this + 40));
  return 1;
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 4D68C4: using guessed type int dwMisc_MaxSharewareTime;
// 4D68C8: using guessed type int dwMisc_MenuKickoutDelay;
// 4D9DE8: using guessed type int dword_4D9DE8;
// 40CF70: using guessed type char var_4FB[507];

//----- (0040D8D0) --------------------------------------------------------
void __thiscall sub_40D8D0(int this)
{
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  __int64 v9; // rax
  int v10; // edi
  int v11; // ebx
  struct ARENA *v12; // ecx

  v2 = *(_DWORD *)(this + 28);
  v3 = *(__int16 *)(this + 232) - *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 355) = v3;
  if ( v3 < 0 )
    *(_DWORD *)(this + 355) = 0;
  v4 = 2 * (0x2000 - *(_DWORD *)(v2 + 111606));
  if ( *(_DWORD *)(this + 355) > v4 )
    *(_DWORD *)(this + 355) = v4;
  v5 = *(__int16 *)(this + 228) - *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 363) = v5;
  if ( v5 < 0 )
    *(_DWORD *)(this + 363) = 0;
  v6 = 2 * (0x2000 - *(_DWORD *)(v2 + 111606));
  if ( *(_DWORD *)(this + 363) > v6 )
    *(_DWORD *)(this + 363) = v6;
  v7 = *(_DWORD *)(this + 363);
  *(_DWORD *)(this + 359) = *(_DWORD *)(this + 355) + 2 * *(_DWORD *)(v2 + 111606);
  v8 = v7 + 2 * *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 367) = v8;
  if ( v2 )
  {
    v9 = *(_DWORD *)(this + 355) + *(_DWORD *)(this + 359);
    v10 = ((WORD2(v9) & 0xFFF) + (int)v9) >> 12;
    v11 = (v8 + *(_DWORD *)(this + 363)) / 4096;
    if ( v10 != *(_DWORD *)(this + 80) || v11 != *(_DWORD *)(this + 84) )
    {
      sub_404980((void *)v2, this, *(_QWORD *)(this + 80));
      v12 = *(struct ARENA **)(this + 28);
      *(_DWORD *)(this + 80) = v10;
      *(_DWORD *)(this + 84) = v11;
      AddPlayerToArenaSomething(v12, (struct PLAYER *)this, v10, v11);
    }
  }
}

//----- (0040D9E0) --------------------------------------------------------
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency)
{
  signed int v3; // edi
  int v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  signed int v8; // ecx
  signed int v9; // eax
  unsigned int v10; // kr08_4
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  __int16 v15; // ax
  int v16; // ecx
  __int16 v17; // dx
  char v18; // [esp+10h] [ebp-20Ch] BYREF
  __int16 v19; // [esp+11h] [ebp-20Bh]
  __int16 v20; // [esp+13h] [ebp-209h]
  char v21; // [esp+15h] [ebp-207h]
  char v22; // [esp+18h] [ebp-204h] BYREF
  __int16 v23; // [esp+19h] [ebp-203h]
  int buf[128]; // [esp+1Ch] [ebp-200h] BYREF

  v3 = NewFrequency;
  v4 = player->lpCurrentArena;
  if ( NewFrequency >= *(_DWORD *)(v4 + 109378) )
    return;
  if ( *(int *)(v4 + 109778) > 0 && !player->bIsSmod )
  {
    memset(buf, 0, 0x100u);
    if ( *(int *)(v4 + 65292) > 0 )
    {
      v5 = v4 + 64288;
      v6 = *(_DWORD *)(v4 + 65292);
      do
      {
        v7 = *(_DWORD *)(*(_DWORD *)v5 + 279);
        if ( v7 < 64 )
          ++buf[v7];
        v5 += 4;
        --v6;
      }
      while ( v6 );
    }
    v8 = *(_DWORD *)player->field_117;
    v9 = *(_DWORD *)(v4 + 109706);
    if ( v8 < v9 && NewFrequency < v9 && v9 < 64 && buf[v8] + *(_DWORD *)(v4 + 109778) - 1 <= buf[NewFrequency] )
    {
      if ( v4 )
      {
        LOWORD(buf[0]) = 7;
        BYTE2(buf[0]) = 0;
        *(_WORD *)((char *)buf + 3) = -1;
        strcpy((char *)&buf[1] + 1, "Changing frequencies would make the teams too uneven.");
        v10 = strlen("Changing frequencies would make the teams too uneven.") + 1;
        if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
          PlayerSendPacket(player, buf, v10 - 1 + 6, 1);
      }
      return;
    }
    v3 = NewFrequency;
  }
  *(_DWORD *)&player->field_44[124] = *(_DWORD *)(v4 + 109666);
  v11 = *(_DWORD *)(v4 + 65292);
  v12 = 0;
  if ( v11 > 0 )
  {
    v13 = v4 + 64288;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v13 + 279) == v3 )
        ++v12;
      v13 += 4;
      --v11;
    }
    while ( v11 );
  }
  v14 = *(unsigned __int8 *)(v4 + 109567);
  if ( *(_BYTE *)(v4 + 109568) )
    v14 = *(unsigned __int8 *)(v4 + 109568);
  if ( v12 < v14 || player->bIsSysop )
  {
    v15 = player->field_14;
    *(_DWORD *)player->field_117 = v3;
    v18 = 13;
    v19 = v15;
    v20 = v3;
    v21 = -1;
    if ( *(_DWORD *)(v4 + 109774) && player->dwShip != 8 )
    {
      player->dwShip = v3 % 8;
      v21 = player->dwShip;
    }
    ArenaSendPacket((struct ARENA *)v4, &v18, 6, 1);
    CarryFlagsSomething((ARENA *)player->lpCurrentArena, *(_DWORD *)&player->field_14, 0);
    UpdatePowerBallPositionsSomething(player);
    v16 = player->lpCurrentArena;
    if ( *(_DWORD *)(v16 + 109962) )
    {
      v17 = player->field_14;
      player->score.losses = 0;
      player->score.wins = 0;
      player->score.points = 0;
      player->score.flag_points = 0;
      player->score.flags = 0;
      *(_DWORD *)&player->field_2F9[20] = 1;
      v22 = 26;
      v23 = v17;
      if ( v16 )
        ArenaSendPacket((struct ARENA *)v16, &v22, 3, 1);
    }
  }
}

//----- (0040DC60) --------------------------------------------------------
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship)
{
  __int16 v3; // ax
  struct ARENA *v4; // ecx
  __int16 v5; // ax
  __int16 v6; // dx
  int v7; // ecx
  __int16 v8; // si
  int v9; // esi
  unsigned int v10; // kr08_4
  __int16 v11; // ax
  int v12; // ecx
  int v13; // esi
  char v14; // [esp+10h] [ebp-210h] BYREF
  char v15; // [esp+11h] [ebp-20Fh]
  __int16 v16; // [esp+12h] [ebp-20Eh]
  __int16 v17; // [esp+14h] [ebp-20Ch]
  char buf; // [esp+18h] [ebp-208h] BYREF
  __int16 v19; // [esp+19h] [ebp-207h]
  __int16 v20; // [esp+1Bh] [ebp-205h]
  char v21; // [esp+20h] [ebp-200h] BYREF
  char v22; // [esp+21h] [ebp-1FFh]
  char v23; // [esp+22h] [ebp-1FEh]
  __int16 v24; // [esp+23h] [ebp-1FDh]
  char v25[507]; // [esp+25h] [ebp-1FBh] BYREF

  if ( *(int *)&player->field_231[50] >= 0 )
  {
    v3 = player->field_14;
    v4 = (struct ARENA *)player->lpCurrentArena;
    buf = 14;
    v20 = -1;
    v19 = v3;
    *(_DWORD *)&player->field_231[50] = -1;
    ArenaSendPacket(v4, &buf, 5, 1);
  }
  LOBYTE(v5) = Ship;
  v6 = player->field_14;
  v14 = 29;
  v16 = v6;
  v15 = Ship;
  if ( (_BYTE)Ship == 8 )
  {
    v7 = player->lpCurrentArena;
    v8 = *(_WORD *)(v7 + 109730);
    v17 = v8;
LABEL_18:
    player->dwShip = (char)v5;
    *(_DWORD *)&player->field_231[50] = -1;
    *(_DWORD *)&player->field_117[92] = -1;
    *(_DWORD *)player->field_117 = v8;
    ArenaSendPacket((struct ARENA *)v7, &v14, 6, 1);
    CarryFlagsSomething((ARENA *)player->lpCurrentArena, *(_DWORD *)&player->field_14, 0);
    UpdatePowerBallPositionsSomething(player);
    v12 = player->lpCurrentArena;
    v13 = *(_DWORD *)&player->field_2B7[56] + 1;
    *(_DWORD *)&player->field_2B7[56] = v13;
    if ( v13 > *(_DWORD *)(v12 + 109810) )
    {
      WriteSubGameLog("Played kicked off for too many ship type changes: %s\n", player->Name);
      v24 = player->field_14;
      player->dwDisconnectReason = 15;
      *(_DWORD *)&player->field_2C[12] = 1;
      v21 = 7;
      v22 = 0;
      v23 = 0;
      strcpy(v25, "WARNING: You have been disconnected for too many ship type changes.");
      PlayerSendPacket(
        player,
        &v21,
        strlen("WARNING: You have been disconnected for too many ship type changes.") + 6,
        0);
      sub_41D6D0(player->lpNetworkData);
    }
    return;
  }
  if ( player->dwShip != 8 )
  {
    v7 = player->lpCurrentArena;
    if ( *(_DWORD *)(v7 + 109774) )
    {
      PlayerChangeFrequency(player, Ship);
      return;
    }
    v8 = *(_WORD *)player->field_117;
    v17 = v8;
    goto LABEL_18;
  }
  if ( player->bIsModerator
    || *(int *)(player->lpCurrentArena + 109870) <= 0
    || (v9 = player->lpCurrentArena, GetTotalPlayingPlayers((ARENA *)v9) <= *(_DWORD *)(v9 + 109870)) )
  {
    v11 = j_lpfnFixExport16(player->lpCurrentArena);
    v7 = player->lpCurrentArena;
    v8 = v11;
    v17 = v11;
    if ( *(_DWORD *)(v7 + 109774) )
    {
      v5 = v11 % 8;
      v15 = v5;
    }
    else
    {
      LOBYTE(v5) = v15;
    }
    goto LABEL_18;
  }
  if ( v9 )
  {
    v24 = -1;
    v21 = 7;
    v22 = 0;
    v23 = 0;
    strcpy(v25, "There are too many people playing the game right now, try again later.");
    v10 = strlen("There are too many people playing the game right now, try again later.") + 1;
    if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
      PlayerSendPacket(player, &v21, v10 - 1 + 6, 1);
  }
}
// 404530: using guessed type int __thiscall j_lpfnFixExport16(_DWORD);

//----- (0040DF06) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_40DF06@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, _BYTE *a5, void *buf, int buf_sz)
{
  _BOOL1 v7; // cf
  int v8; // esi
  char *v9; // eax
  int v11; // [esp+72h] [ebp-4h] BYREF

  v9 = (char *)a1 + *a1;
  v7 = __CFADD__((_BYTE)v9, *(_BYTE *)(a3 - 1955367488));
  *(_BYTE *)(a3 - 1955367488) += (_BYTE)v9;
  v8 = a4 + 1;
  *((_BYTE *)&v11 + 2 * a3 - 117) = 0;
  LOBYTE(v9) = ((_BYTE)v9 - (v7 - 123)) & 0x10;
  if ( a2 == 21 && (a5[19] & 0x1F) != 0 )
  {
    ++*(_DWORD *)(v8 + 287);
    if ( *(_DWORD *)(v8 + 801) < *(_DWORD *)(v9 + 109902) )
    {
      PlayerSendPacket((PLAYER *)v8, a5, (int)buf, 0);
      ++*(_DWORD *)(v8 + 287);
      ++dword_4CA228;
      sub_41D6D0(*(_DWORD *)(v8 + 40));
    }
  }
  return PlayerSendPacket((PLAYER *)v8, a5, (int)buf, 0);
}
// 40DF81: positive sp value 4 has been found
// 4CA228: using guessed type int dword_4CA228;

//----- (0040DF90) --------------------------------------------------------
// Player.SendPacket()
int __thiscall PlayerSendPacket(PLAYER *player, void *buf, int buf_sz, BOOL bSendReliable)
{
  int result; // eax
  int v6; // eax

  if ( bSendReliable
    || (result = *(_DWORD *)&player->field_2F9[16]) == 0
    && ((result = player->lpCurrentArena) == 0
     || *(_DWORD *)(player->lpNetworkData + 2690) <= *(_DWORD *)&player->field_341[189]
     || *(_BYTE *)buf == 5) )
  {
    if ( !WriteData((struct CONNECTION *)player->lpNetworkData, buf, buf_sz, bSendReliable) && bSendReliable )
    {
      WriteSubGameLog(
        "Reliable packet lost(%d) to: %s (pending=%d current=%d diff=%d)\n",
        *(unsigned __int8 *)buf,
        player->player_name,
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, pending_ack)),
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, current_ack)),
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, current_ack))
      - *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, pending_ack)));
      v6 = player->bIsSysop;
      player->dwDisconnectReason = 8;
      *(_DWORD *)&player->field_2C[12] = 1;
      if ( v6 )
        LogReliablePackets((struct CONNECTION *)player->lpNetworkData, "reliable.txt");
    }
    ++dword_4399F0[*(char *)buf];
    result = *(char *)buf;
    dword_4B0668[result] += buf_sz;
  }
  return result;
}

//----- (0040E060) --------------------------------------------------------
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6)
{
  if ( (!a5 || !player->bWaveMessages) && (!a6 || player->dwShip == 8) )
    PlayerSendPacket(player, buf, len, a4);
}

//----- (0040E0A0) --------------------------------------------------------
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4)
{
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // eax

  v5 = player->lpCurrentArena;
  if ( v5 )
  {
    v6 = 0;
    if ( *(int *)(v5 + 65292) > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(_DWORD *)(v7 + v5);
        if ( (struct PLAYER *)v8 != player && !*(_DWORD *)(v8 + 56) )
          PlayerSendPacket((PLAYER *)v8, (void *)buf, len, a4);
        v5 = player->lpCurrentArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < *(_DWORD *)(v5 + 65292) );
    }
  }
}

//----- (0040E100) --------------------------------------------------------
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend)
{
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // eax

  v5 = player->lpCurrentArena;
  if ( v5 )
  {
    v6 = 0;
    if ( *(int *)(v5 + 65292) > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(_DWORD *)(v7 + v5);
        if ( (struct PLAYER *)v8 != player && *(_DWORD *)(v8 + 279) == *(_DWORD *)player->field_117 )
          PlayerSendPacket((PLAYER *)v8, (void *)buf, len, IsReliableSend);
        v5 = player->lpCurrentArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < *(_DWORD *)(v5 + 65292) );
    }
  }
}

//----- (0040E170) --------------------------------------------------------
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  int v7; // eax
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edx
  int v12; // edx
  signed int v13; // edi
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // [esp+0h] [ebp-4h]

  v7 = player->lpCurrentArena;
  if ( v7 )
  {
    v16 = 0;
    if ( *(int *)(v7 + 65292) > 0 )
    {
      v8 = 64288;
      do
      {
        v9 = *(_DWORD *)(v8 + v7);
        v10 = v9;
        if ( (struct PLAYER *)v9 != player )
        {
          v11 = *(_DWORD *)(v9 + 371);
          if ( v11 >= 0 )
            v10 = (int)*(&PlayerArray + v11);
          if ( v10 )
          {
            v12 = *(_DWORD *)(v10 + 611);
            if ( v12 >= 0 )
              v10 = (int)*(&PlayerArray + v12);
            if ( v10 )
            {
              if ( *(_DWORD *)(v9 + 631)
                || (v13 = *(_DWORD *)(v7 + 109794),
                    v14 = *(__int16 *)(v10 + 228) - player->yPixels,
                    (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) <= v13)
                && (v15 = *(__int16 *)(v10 + 232) - player->xPixels, (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) <= v13) )
              {
                if ( (!a5 || !*(_DWORD *)(v9 + 627)) && (!a6 || *(_DWORD *)(v9 + 275) == 8) )
                  PlayerSendPacket((PLAYER *)v9, (void *)buf, len, a4);
              }
            }
          }
        }
        v7 = player->lpCurrentArena;
        v8 += 4;
        ++v16;
      }
      while ( v16 < *(_DWORD *)(v7 + 65292) );
    }
  }
}

//----- (0040E280) --------------------------------------------------------
int __thiscall sub_40E280(int this, char *buf, unsigned int buf_sz, BOOL bSendReliable, int a5, int a6)
{
  int result; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // ecx

  result = *(_DWORD *)(this + 28);
  if ( result )
  {
    v8 = 0;
    if ( *(int *)(result + 65292) > 0 )
    {
      v9 = 64288;
      do
      {
        v10 = *(_DWORD *)(v9 + result);
        if ( v10 != this
          && *(_DWORD *)(v10 + 279) == *(_DWORD *)(this + 279)
          && (!a5 || !*(_DWORD *)(v10 + 627))
          && (!a6 || *(_DWORD *)(v10 + 275) == 8) )
        {
          PlayerSendPacket((PLAYER *)v10, buf, buf_sz, bSendReliable);
        }
        result = *(_DWORD *)(this + 28);
        ++v8;
        v9 += 4;
      }
      while ( v8 < *(_DWORD *)(result + 65292) );
    }
  }
  return result;
}

//----- (0040E310) --------------------------------------------------------
void __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  PLAYER *v6; // ecx

  v6 = *(&PlayerArray + ArenaPlayerIndex);
  if ( v6 && (!a5 || !v6->bWaveMessages) && (!a6 || v6->dwShip == 8) )
    PlayerSendPacket(v6, (void *)buf, len, a4);
}

//----- (0040E360) --------------------------------------------------------
int __thiscall sub_40E360(void *this, int a2, char *buf, unsigned int buf_sz, BOOL bSendReliable, int a6, int a7)
{
  int result; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // esi
  int v11; // ecx

  result = a2;
  v8 = (int)*(&PlayerArray + a2);
  if ( v8 )
  {
    result = *(_DWORD *)(v8 + 28);
    if ( result )
    {
      v9 = 0;
      if ( *(int *)(result + 65292) > 0 )
      {
        v10 = 64288;
        do
        {
          v11 = *(_DWORD *)(v10 + result);
          if ( (void *)v11 != this
            && *(_DWORD *)(v11 + 279) == *(_DWORD *)(v8 + 279)
            && (!a6 || !*(_DWORD *)(v11 + 627))
            && (!a7 || *(_DWORD *)(v11 + 275) == 8) )
          {
            PlayerSendPacket((PLAYER *)v11, buf, buf_sz, bSendReliable);
          }
          result = *(_DWORD *)(v8 + 28);
          ++v9;
          v10 += 4;
        }
        while ( v9 < *(_DWORD *)(result + 65292) );
      }
    }
  }
  return result;
}

//----- (0040E400) --------------------------------------------------------
// Player.SendMessage()
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte)
{
  unsigned int v4; // kr08_4
  char buf[3]; // [esp+10h] [ebp-200h] BYREF
  __int16 v6; // [esp+13h] [ebp-1FDh]
  char v7[507]; // [esp+15h] [ebp-1FBh] BYREF

  if ( player->lpCurrentArena )
  {
    buf[2] = SoundByte;
    buf[0] = 7;
    buf[1] = 0;
    v6 = -1;
    strcpy(v7, a2);
    v4 = strlen(a2) + 1;
    if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
      PlayerSendPacket(player, buf, v4 - 1 + 6, 1);
  }
}

//----- (0040E4A0) --------------------------------------------------------
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2)
{
  char buf[3]; // [esp+4h] [ebp-200h] BYREF
  __int16 v3; // [esp+7h] [ebp-1FDh]
  char v4[507]; // [esp+9h] [ebp-1FBh] BYREF

  if ( player->lpCurrentArena )
  {
    buf[0] = 7;
    buf[1] = 9;
    buf[2] = 0;
    v3 = -1;
    strcpy(v4, a2);
    PlayerSendPacket(player, buf, strlen(a2) + 6, 1);
  }
}

//----- (0040E520) --------------------------------------------------------
void __thiscall SendArenaMessagePlayer(PLAYER *playerr, const char *a2, char SoundByte)
{
  __int16 v4; // cx
  char buf[3]; // [esp+10h] [ebp-5h] BYREF
  __int16 v6; // [esp+13h] [ebp-2h]
  char v7[507]; // [esp+15h] [ebp+0h] BYREF

  v4 = playerr->field_14;
  buf[2] = SoundByte;
  v6 = v4;
  buf[0] = 7;
  buf[1] = 0;
  strcpy(v7, a2);
  PlayerSendPacket(playerr, buf, strlen(a2) + 6, 0);
  sub_41D6D0(playerr->lpNetworkData);
}

//----- (0040E5B0) --------------------------------------------------------
// Player.SendFile()
int __thiscall SendFile(int *this, char *filename)
{
  PLAYER *v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // ebp
  _BYTE *v7; // esi
  int result; // eax
  char buf; // [esp+10h] [ebp-14h] BYREF
  char v11[19]; // [esp+11h] [ebp-13h] BYREF

  v2 = (PLAYER *)this;
  v3 = fopen(filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    v5 = _fileno(v3);
    v6 = _filelength(v5);
    v7 = emalloc(v6 + 17);
    fread(v7 + 17, 1, v6, v4);
    fclose(v4);
    *v7 = 16;
    strncpy(v7 + 1, filename, 0x10u);
    v7[16] = 0;
    result = sub_41D440(this[10], (int)v7, v6 + 17, 0);
  }
  else
  {
    buf = 16;
    strncpy(v11, filename, 0x10u);
    v11[15] = 0;
    result = PlayerSendPacket(v2, &buf, 17, 1);
  }
  return result;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (0040E680) --------------------------------------------------------
// Player.PlayerFindSuitableArena()
ARENA *__thiscall PlayerFindSuitableArena(PLAYER *p, DWORD join_type, char *arena_preference)
{
  int v3; // ebx
  PLAYER *v4; // edx
  int v5; // ecx
  ARENA *v6; // esi
  ARENA *result; // eax
  char *v8; // ebp
  int *v9; // ebx
  ARENA *v10; // eax
  int v11; // edx
  int v12; // edi
  unsigned int v13; // esi
  int v14; // eax
  int v15; // esi
  int *v16; // edx
  int v17; // edi
  int v18; // esi
  ARENA *v19; // eax
  int v20; // edi
  ARENA **v21; // esi
  int v22; // esi
  int i; // eax
  int v24; // edx
  int *j; // esi
  int v26; // ecx
  int v28; // [esp+24h] [ebp+4h]
  void *v29; // [esp+24h] [ebp+4h]

  v3 = 0;
  v4 = p;
  if ( (join_type & 0x80000000) != 0 )
  {
    if ( join_type == -1 && (v8 = p->field_18F, p->field_18F[0]) )
    {
      v5 = nArenas;
      v28 = 0;
      if ( nArenas > 0 )
      {
        v9 = ArenaArray;
        while ( 1 )
        {
          v10 = (ARENA *)*v9;
          if ( !*(_BYTE *)(*v9 + offsetof(ARENA, name)) )
          {
            v11 = v10->nPlayersHere;
            if ( v11 < *(_DWORD *)&v10->dwMaxPlayers )
            {
              v12 = 0;
              if ( v11 > 0 )
                break;
            }
          }
LABEL_18:
          ++v9;
          if ( ++v28 >= v5 )
            goto LABEL_54;
        }
        v13 = offsetof(ARENA, PlayerArray);
        while ( _strcmpi((const char *)(*(_DWORD *)&v10->field_0[v13] + 399), v8) )
        {
          v10 = (ARENA *)*v9;
          ++v12;
          v13 += 4;
          if ( v12 >= *(_DWORD *)(*v9 + offsetof(ARENA, nPlayersHere)) )
          {
            v5 = nArenas;
            goto LABEL_18;
          }
        }
        return (ARENA *)ArenaArray[v28];
      }
    }
    else if ( join_type == -2 )
    {
      v5 = nArenas;
      v14 = 0;
      if ( nArenas > 0 )
      {
        v15 = *(_DWORD *)v4->lpArenaPointer2;
        v16 = ArenaArray;
        while ( *v16 != v15 )
        {
          ++v14;
          ++v16;
          if ( v14 >= nArenas )
            goto LABEL_28;
        }
        v3 = v14;
      }
LABEL_28:
      v17 = 0;
      if ( nArenas > 0 )
      {
        v18 = v3 + 1;
        do
        {
          v19 = (ARENA *)ArenaArray[v18 % nArenas];
          if ( !v19->name[offsetof(ARENA, field_0)]
            && (p->bIsModerator || v19->nPlayersHere < *(_DWORD *)&v19->dwMaxPlayers) )
          {
            return (ARENA *)ArenaArray[v18 % nArenas];
          }
          ++v17;
          ++v18;
        }
        while ( v17 < nArenas );
      }
    }
    else if ( join_type == -3 )
    {
      v5 = nArenas;
      v20 = 0;
      if ( nArenas > 0 )
      {
        v21 = (ARENA **)ArenaArray;
        while ( 1 )
        {
          v3 += GetArenaMemoryTotal(*v21);
          if ( !_strcmpi((*v21)->name, arena_preference) )
            break;
          v5 = nArenas;
          ++v20;
          ++v21;
          if ( v20 >= nArenas )
            goto LABEL_46;
        }
        if ( p->bIsModerator )
          goto LABEL_68;
        if ( *(_DWORD *)(ArenaArray[v20] + 65292) < *(_DWORD *)(ArenaArray[v20] + 119822) )
          return (ARENA *)ArenaArray[v20];
        v5 = nArenas;
LABEL_46:
        v4 = p;
      }
      if ( v20 == v5 && (v4->bIsSmod || v5 < dwArena_MaxArenas && v3 < dwArena_MaxArenasMemory) )
      {
        v29 = operator new(0x1DC00u);
        if ( !v29 )
        {
LABEL_70:
          v26 = nArenas;
          ArenaArray[nArenas] = 0;
          result = (ARENA *)ArenaArray[v26];
          nArenas = v26 + 1;
          return result;
        }
        return (ARENA *)create_arena((int)v29, (int)arena_preference);
      }
    }
    else
    {
      v5 = nArenas;
    }
  }
  else
  {
    v5 = nArenas;
    if ( (int)join_type < nArenas )
    {
      if ( v4->bIsModerator )
        return (ARENA *)ArenaArray[join_type];
      v6 = (ARENA *)ArenaArray[join_type];
      if ( !v6->name[offsetof(ARENA, field_0)]
        && *(_DWORD *)(ArenaArray[join_type] + offsetof(ARENA, nPlayersHere)) < *(_DWORD *)&v6->dwMaxPlayers )
      {
        return (ARENA *)ArenaArray[join_type];
      }
    }
  }
LABEL_54:
  v22 = -1;
  for ( i = 0; i < v5; ++i )
  {
    v24 = ArenaArray[i];
    if ( !*(_BYTE *)(v24 + 64256) && (v22 == -1 || *(_DWORD *)(v24 + 65292) < *(_DWORD *)(ArenaArray[v22] + 65292)) )
      v22 = i;
  }
  if ( v22 == -1 || (result = (ARENA *)ArenaArray[v22], result->nPlayersHere >= *(_DWORD *)&result->dwMaxPlayers) )
  {
    v29 = operator new(0x1DC00u);
    if ( !v29 )
      goto LABEL_70;
    return (ARENA *)create_arena((int)v29, (int)arena_preference);
  }
  v20 = 0;
  if ( v5 > 0 )
  {
    for ( j = ArenaArray;
          *(_BYTE *)(*j + offsetof(ARENA, name))
       || *(_DWORD *)(*j + offsetof(ARENA, nPlayersHere)) >= dwArena_ArenaDesiredPlayers;
          ++j )
    {
      if ( ++v20 >= v5 )
        return result;
    }
LABEL_68:
    result = (ARENA *)ArenaArray[v20];
  }
  return result;
}
// 40E6D7: conditional instruction was optimized away because of 'edx.4==0'
// 4157E0: using guessed type int __stdcall create_arena(int, int);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 439E08: using guessed type int dwArena_MaxArenasMemory;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6BF8: using guessed type int dwArena_MaxArenas;
// 4D6C18: using guessed type int dwArena_ArenaDesiredPlayers;

//----- (0040E9F0) --------------------------------------------------------
int __thiscall SendWeaponPacket(int this)
{
  int v2; // eax
  __int16 v3; // cx
  __int16 v4; // dx
  int v5; // edi
  __int16 v6; // ax
  DWORD v7; // eax
  int v8; // ebp
  int v9; // edi
  DWORD v10; // edx
  int v11; // ebp
  int v12; // edx
  int v13; // edi
  int v14; // ebp
  int v15; // edx
  __int16 v16; // cx
  __int16 v17; // ax
  char v18; // al
  char *v19; // ecx
  int v20; // edx
  int v21; // eax
  int v22; // ecx
  __int16 v23; // dx
  __int16 v24; // ax
  int v25; // edi
  __int16 v26; // cx
  DWORD v27; // eax
  int v28; // ebp
  int v29; // edi
  DWORD v30; // edx
  int v31; // ebp
  int v32; // edx
  int v33; // edx
  int v34; // edi
  int v35; // ebp
  char v36; // al
  char v37; // cl
  __int16 v38; // ax
  __int16 v39; // cx
  int v40; // edi
  __int16 v41; // dx
  DWORD v42; // eax
  int v43; // ebp
  int v44; // edi
  DWORD v45; // edx
  int v46; // ebp
  int v47; // edx
  char v48; // al
  int v49; // edi
  int v50; // ebp
  int v51; // edx
  __int16 v52; // dx
  char v53; // al
  __int16 v54; // cx
  __int16 v55; // ax
  int v56; // edx
  __int16 v57; // cx
  char v58; // al
  int *v59; // ecx
  unsigned int v60; // eax
  char *v61; // ecx
  __int16 v62; // dx
  int v63; // edx
  int v64; // edi
  __int16 v65; // ax
  _BOOL1 v66; // cc
  _BOOL1 v67; // cc
  int v68; // eax
  int v69; // ebp
  _DWORD *v70; // esi
  int v71; // edx
  int v72; // ecx
  int v73; // edi
  int v74; // esi
  int v75; // ecx
  int v76; // ebp
  int v77; // edx
  int v78; // eax
  int v79; // eax
  int v80; // edi
  int v81; // eax
  int v82; // ecx
  _DWORD *v83; // eax
  _DWORD *v84; // ebp
  int v85; // eax
  int v86; // eax
  _DWORD *v87; // ecx
  int v88; // eax
  __int64 v89; // rax
  int v90; // esi
  int v91; // eax
  _BOOL1 v92; // zf
  int result; // eax
  unsigned int v94; // [esp+10h] [ebp-DCh]
  int v95; // [esp+14h] [ebp-D8h]
  int v96; // [esp+14h] [ebp-D8h]
  int v97; // [esp+18h] [ebp-D4h]
  int v98; // [esp+18h] [ebp-D4h]
  int v99; // [esp+1Ch] [ebp-D0h]
  int v100; // [esp+20h] [ebp-CCh]
  int v101; // [esp+20h] [ebp-CCh]
  char buf[2]; // [esp+24h] [ebp-C8h] BYREF
  __int16 v103; // [esp+26h] [ebp-C6h]
  __int16 v104; // [esp+28h] [ebp-C4h]
  __int16 v105; // [esp+2Ah] [ebp-C2h]
  __int16 v106; // [esp+2Ch] [ebp-C0h]
  __int16 v107; // [esp+2Eh] [ebp-BEh]
  char v108; // [esp+30h] [ebp-BCh]
  char v109; // [esp+31h] [ebp-BBh]
  char v110; // [esp+32h] [ebp-BAh]
  __int16 v111; // [esp+33h] [ebp-B9h]
  __int16 v112; // [esp+35h] [ebp-B7h]
  int v113; // [esp+37h] [ebp-B5h]
  int v114; // [esp+3Ch] [ebp-B0h]
  int v115; // [esp+40h] [ebp-ACh]
  int v116; // [esp+44h] [ebp-A8h]
  int v117; // [esp+48h] [ebp-A4h]
  int v118; // [esp+4Ch] [ebp-A0h]
  _DWORD *v119; // [esp+50h] [ebp-9Ch]
  int v120; // [esp+54h] [ebp-98h]
  int v121; // [esp+58h] [ebp-94h]
  _DWORD *v122; // [esp+5Ch] [ebp-90h]
  int v123; // [esp+60h] [ebp-8Ch]
  int v124; // [esp+64h] [ebp-88h]
  int v125; // [esp+68h] [ebp-84h]
  int v126; // [esp+6Ch] [ebp-80h] BYREF
  __int16 v127; // [esp+70h] [ebp-7Ch]
  __int16 v128; // [esp+72h] [ebp-7Ah]
  __int16 v129; // [esp+74h] [ebp-78h]
  __int16 v130; // [esp+76h] [ebp-76h]
  __int16 v131; // [esp+78h] [ebp-74h]
  char v132[3]; // [esp+7Ah] [ebp-72h]
  __int16 v133; // [esp+7Dh] [ebp-6Fh]
  int v134; // [esp+7Fh] [ebp-6Dh]

  v2 = *(_DWORD *)(this + 651);
  *(_DWORD *)(this + 253) = 0;
  if ( v2 )
  {
    v3 = *(_WORD *)(this + 228);
    v4 = *(_WORD *)(this + 226);
    v5 = *(_DWORD *)(this + 40);
    v104 = *(_WORD *)(this + 232);
    v6 = *(_WORD *)(this + 234);
    v111 = v3;
    LOBYTE(v3) = *(_BYTE *)(this + 221);
    buf[0] = 5;
    v107 = v4;
    v105 = v6;
    buf[1] = v3;
    v7 = GetTickCount();
    v8 = *(_DWORD *)(v5 + 14);
    v9 = *(_DWORD *)(this + 222);
    v10 = v8 + v7 / 0xA;
    v11 = *(_DWORD *)(this + 40);
    v103 = v10;
    v12 = ((*(_DWORD *)(v11 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v9;
    if ( v12 < 0 || v12 > 30000 )
      v12 = 0;
    if ( v12 <= 255 )
    {
      v13 = *(_DWORD *)(this + 222);
      v14 = *(_DWORD *)(this + 40);
      v15 = ((*(_DWORD *)(v14 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v13;
      if ( v15 < 0 || v15 > 30000 )
        LOBYTE(v15) = 0;
      v110 = v15;
    }
    else
    {
      v110 = -1;
    }
    v16 = *(_WORD *)(this + 240);
    v106 = 1014;
    v17 = v16 & 0x1F;
    v109 = 0;
    v112 = 0;
    if ( v17 == 3 || v17 == 4 || v17 == 1 || v17 == 2 )
      LOWORD(v113) = v16 ^ (v16 ^ v16 & 0x80 ^ (v16 & 0x1F ^ v113 & 0xFF80) & 0xFC7F) & 0x3FF;
    else
      LOWORD(v113) = 0;
    v18 = 0;
    v19 = buf;
    v108 = 0;
    v20 = 21;
    do
    {
      v18 ^= *v19++;
      --v20;
    }
    while ( v20 );
    v108 = v18;
    if ( !*(_DWORD *)(this + 777) )
    {
      v21 = *(_DWORD *)(this + 28);
      if ( v21 )
      {
        if ( (v113 & 0x1F) != 0 )
        {
          v22 = *(_DWORD *)(this + 801);
          ++*(_DWORD *)(this + 287);
          if ( v22 < *(_DWORD *)(v21 + 109902) )
          {
            PlayerSendPacket((PLAYER *)this, buf, 21, 0);
            ++*(_DWORD *)(this + 287);
            ++dword_4CA228;
            sub_41D6D0(*(_DWORD *)(this + 40));
          }
        }
        PlayerSendPacket((PLAYER *)this, buf, 21, 0);
      }
    }
  }
  if ( *(int *)(this + 275) < 8 && *(_DWORD *)(this + 28) )
  {
    if ( *(int *)(this + 20) > 255 || *(__int16 *)(this + 236) > 255 || (*(_BYTE *)(this + 240) & 0x1F) != 0 )
    {
      v38 = *(_WORD *)(this + 228);
      v39 = *(_WORD *)(this + 226);
      v40 = *(_DWORD *)(this + 40);
      v127 = *(_WORD *)(this + 232);
      v41 = *(_WORD *)(this + 234);
      *(_WORD *)&v132[1] = v38;
      LOBYTE(v38) = *(_BYTE *)(this + 221);
      v94 = 21;
      LOBYTE(v126) = 5;
      v130 = v39;
      v128 = v41;
      BYTE1(v126) = v38;
      v42 = GetTickCount();
      v43 = *(_DWORD *)(v40 + 14);
      v44 = *(_DWORD *)(this + 222);
      v45 = v43 + v42 / 0xA;
      v46 = *(_DWORD *)(this + 40);
      HIWORD(v126) = v45;
      v47 = ((*(_DWORD *)(v46 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v44;
      if ( v47 < 0 || v47 > 30000 )
        v47 = 0;
      if ( v47 <= 255 )
      {
        v49 = *(_DWORD *)(this + 222);
        v50 = *(_DWORD *)(this + 40);
        v51 = ((*(_DWORD *)(v50 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v49;
        if ( v51 < 0 || v51 > 30000 )
          LOBYTE(v51) = 0;
        v48 = v51;
      }
      else
      {
        v48 = -1;
      }
      v52 = *(_WORD *)(this + 20);
      v132[0] = v48;
      v53 = *(_BYTE *)(this + 231);
      v54 = *(_WORD *)(this + 236);
      v129 = v52;
      HIBYTE(v131) = v53;
      v55 = *(_WORD *)(this + 240);
      v133 = v54;
      LOWORD(v134) = ((unsigned __int8)v55 ^ (unsigned __int8)v134) & 0x1F ^ v134;
      LOWORD(v134) = ((unsigned __int8)v55 ^ (unsigned __int8)v134) & 0x60 ^ v134;
      LOWORD(v134) = ((unsigned __int8)v55 ^ (unsigned __int8)v134) & 0x80 ^ v134;
      LOWORD(v134) = (v55 ^ v134) & 0x300 ^ v134;
      LOWORD(v134) = (v55 ^ v134) & 0x7C00 ^ v134;
      v56 = 21;
      v57 = v55 ^ (v55 ^ v134) & 0x7FFF;
      v58 = 0;
      LOWORD(v134) = v57;
      LOBYTE(v131) = 0;
      v59 = &v126;
      do
      {
        v58 ^= *(_BYTE *)v59;
        v59 = (int *)((char *)v59 + 1);
        --v56;
      }
      while ( v56 );
      LOBYTE(v131) = v58;
    }
    else
    {
      v23 = *(_WORD *)(this + 228);
      v24 = *(_WORD *)(this + 226);
      v25 = *(_DWORD *)(this + 40);
      v127 = *(_WORD *)(this + 232);
      v26 = *(_WORD *)(this + 234);
      v131 = v23;
      LOBYTE(v23) = *(_BYTE *)(this + 221);
      v94 = 16;
      LOBYTE(v126) = 40;
      *(_WORD *)v132 = v24;
      v130 = v26;
      BYTE1(v126) = v23;
      v27 = GetTickCount();
      v28 = *(_DWORD *)(v25 + 14);
      v29 = *(_DWORD *)(this + 222);
      v30 = v28 + v27 / 0xA;
      v31 = *(_DWORD *)(this + 40);
      HIWORD(v126) = v30;
      v32 = ((*(_DWORD *)(v31 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v29;
      if ( v32 < 0 || v32 > 30000 )
        v32 = 0;
      if ( v32 <= 255 )
      {
        v34 = *(_DWORD *)(this + 222);
        v35 = *(_DWORD *)(this + 40);
        v33 = ((*(_DWORD *)(v35 + 14) + GetTickCount() / 0xA) & 0x7FFFFFFF) - v34;
        if ( v33 < 0 || v33 > 30000 )
          LOBYTE(v33) = 0;
      }
      else
      {
        LOBYTE(v33) = -1;
      }
      v36 = *(_BYTE *)(this + 231);
      v37 = *(_BYTE *)(this + 236);
      LOBYTE(v128) = v33;
      LOBYTE(v129) = *(_BYTE *)(this + 20);
      HIBYTE(v129) = v36;
      HIBYTE(v128) = v37;
    }
    if ( *(_DWORD *)(this + 267) )
    {
      v60 = v94;
      v61 = (char *)&v126 + v94;
      *(_DWORD *)v61 = *(_DWORD *)(this + 257);
      v62 = *(_WORD *)(this + 265);
      *((_DWORD *)v61 + 1) = *(_DWORD *)(this + 261);
      *((_WORD *)v61 + 4) = v62;
      v114 = v94 + 10;
    }
    else
    {
      *(_WORD *)((char *)&v126 + v94) = *(_WORD *)(this + 238);
      v114 = v94 + 2;
      v60 = v94;
    }
    v63 = 0;
    v64 = 0;
    v100 = 0;
    v95 = 0;
    v97 = 0;
    if ( v60 != 21 )
      goto LABEL_79;
    v65 = v134 & 0x1F;
    if ( v65 == 6 || v65 == 3 && (v134 & 0x8000) != 0 || v65 == 4 && (v134 & 0x8000) != 0 || v65 == 5 || v65 == 8 )
    {
      *(_DWORD *)(this + 271) = 1;
    }
    else if ( v65 == 4 || v65 == 3 )
    {
      if ( SBYTE1(v126) < 5 || SBYTE1(v126) > 35 )
        v95 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109894);
      if ( SBYTE1(v126) > 5 )
      {
        v66 = SBYTE1(v126) <= 15;
        if ( SBYTE1(v126) >= 15 )
          goto LABEL_71;
        v64 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109894);
      }
      v66 = SBYTE1(v126) <= 15;
LABEL_71:
      if ( !v66 )
      {
        v67 = SBYTE1(v126) <= 25;
        if ( SBYTE1(v126) >= 25 )
        {
LABEL_75:
          if ( !v67 && SBYTE1(v126) < 35 )
          {
            v63 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109894);
            v100 = v63;
          }
          goto LABEL_79;
        }
        v97 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109894);
      }
      v67 = SBYTE1(v126) <= 25;
      goto LABEL_75;
    }
LABEL_79:
    if ( *(_DWORD *)(this + 271) )
    {
      v68 = *(_DWORD *)(this + 28);
      if ( *(int *)(v68 + 65292) > 0 )
      {
        v69 = 64288;
        do
        {
          v70 = *(_DWORD **)(v69 + v68);
          if ( v70 != (_DWORD *)this )
          {
            v71 = *(_DWORD *)((char *)v70 + 631);
            if ( v71 || !*(_DWORD *)(this + 60) || (v72 = *(_DWORD *)(this + 76), v72 < 0) || v72 == v70[5] )
            {
              v73 = v94;
              if ( v70[17]
                || *(_DWORD *)((char *)v70 + 371) == *(_DWORD *)(this + 20) && (*(_BYTE *)(v68 + 109576) || v71) )
              {
                v73 = v114;
              }
              lpfnFixExport20(v70, &v126, v73, v73);
            }
          }
          v68 = *(_DWORD *)(this + 28);
          v69 += 4;
          ++v100;
        }
        while ( v100 < *(_DWORD *)(v68 + 65292) );
      }
    }
    else
    {
      v74 = (*(_DWORD *)(this + 355) - v63) / 2048;
      if ( v74 < 0 )
        v74 = 0;
      v75 = (v64 + *(_DWORD *)(this + 359)) / 2048;
      if ( v75 >= 8 )
        v75 = 7;
      v76 = (*(_DWORD *)(this + 363) - v95) / 2048;
      v99 = v76;
      if ( v76 < 0 )
      {
        v99 = 0;
        v76 = 0;
      }
      v117 = (v97 + *(_DWORD *)(this + 367)) / 2048;
      v77 = v117;
      if ( v117 >= 8 )
      {
        v77 = 7;
        v117 = 7;
      }
      v78 = *(__int16 *)(this + 232);
      v124 = v78 + v64;
      v121 = v78 - v100;
      v79 = *(__int16 *)(this + 228);
      v123 = v79 + v97;
      v125 = v79 - v95;
      v101 = 128;
      v98 = 128;
      if ( v94 == 21 && (v134 & 0x1F) != 0 )
      {
        v101 = *(_DWORD *)(*(_DWORD *)(this + 28) + 109890) + 128;
        v98 = v101;
      }
      if ( v74 <= v75 )
      {
        v80 = 1004 * (v76 + 8 * v74);
        v116 = v80;
        v118 = v75 - v74 + 1;
        do
        {
          if ( v76 <= v77 )
          {
            v81 = v80;
            v120 = v80;
            v82 = v77 - v76 + 1;
            v115 = v82;
            do
            {
              v96 = 0;
              v83 = (_DWORD *)(*(_DWORD *)(this + 28) + v81);
              v122 = v83;
              if ( (int)v83[250] > 0 )
              {
                v119 = v83;
                do
                {
                  v84 = (_DWORD *)*v83;
                  if ( *v83 != this )
                  {
                    if ( *(_DWORD *)((char *)v84 + 631)
                      || !*(_DWORD *)(this + 60)
                      || (v85 = *(_DWORD *)(this + 76), v85 < 0)
                      || v85 == v84[5] )
                    {
                      v86 = *(_DWORD *)((char *)v84 + 371);
                      v87 = v84;
                      if ( v86 < 0 || (v87 = *(&PlayerArray + v86)) != 0 )
                      {
                        v88 = *(_DWORD *)((char *)v87 + 611);
                        if ( v88 < 0 || (v87 = *(&PlayerArray + v88)) != 0 )
                        {
                          if ( (int)abs32(*((__int16 *)v87 + 114) - *(__int16 *)(this + 228)) > v98
                                                                                              + *(_DWORD *)((char *)v84 + 623)
                                                                                              / 2
                            || (v89 = *((__int16 *)v87 + 116) - *(__int16 *)(this + 232),
                                (int)((HIDWORD(v89) ^ v89) - HIDWORD(v89)) > v101 + *(_DWORD *)((char *)v84 + 619) / 2) )
                          {
                            if ( v124 >= *(_DWORD *)((char *)v87 + 355)
                              && v121 <= *(_DWORD *)((char *)v87 + 359)
                              && v123 >= *(_DWORD *)((char *)v87 + 363)
                              && v125 <= *(_DWORD *)((char *)v87 + 367)
                              && (v94 == 21 && (v134 & 0x1Fu) > 2
                               || v96 % *(_DWORD *)(*(_DWORD *)(this + 28) + 109886) == *(_DWORD *)(this + 283)) )
                            {
                              if ( dword_4CBB04 >= 4000 )
                                IncreaseRadarValueShowHomeOverFourThousand();
                              v91 = 26 * dword_4CBB04;
                              qmemcpy((char *)&dword_4B0BEC + 26 * dword_4CBB04, &v126, v94);
                              byte_4B0C01[v91] = v94;
                              *(int *)((char *)&dword_4B0BE8 + v91) = v84[5];
                              ++dword_4CBB04;
                            }
                          }
                          else
                          {
                            v90 = v94;
                            if ( v84[17]
                              || *(_DWORD *)((char *)v84 + 371) == *(_DWORD *)(this + 20)
                              && (*(_BYTE *)(*(_DWORD *)(this + 28) + 109576) || *(_DWORD *)((char *)v84 + 631)) )
                            {
                              v90 = v114;
                            }
                            lpfnFixExport20(v84, &v126, v90, v90);
                            ++dword_4D68C0;
                          }
                        }
                      }
                    }
                  }
                  v83 = v119 + 1;
                  v66 = ++v96 < v122[250];
                  ++v119;
                }
                while ( v66 );
                v76 = v99;
                v77 = v117;
                v80 = v116;
                v82 = v115;
              }
              v81 = v120 + 1004;
              --v82;
              v120 += 1004;
              v115 = v82;
            }
            while ( v82 );
          }
          v80 += 8032;
          v92 = v118 == 1;
          v116 = v80;
          --v118;
        }
        while ( !v92 );
      }
      *(_DWORD *)(this + 283) = (*(_DWORD *)(this + 283) + 1) % *(_DWORD *)(*(_DWORD *)(this + 28) + 109886);
    }
  }
  result = 0;
  *(_DWORD *)(this + 271) = 0;
  *(_DWORD *)(this + 267) = 0;
  return result;
}
// 4B0BE8: using guessed type int dword_4B0BE8;
// 4B0BEC: using guessed type int dword_4B0BEC;
// 4CA228: using guessed type int dword_4CA228;
// 4CBB04: using guessed type int dword_4CBB04;
// 4D68C0: using guessed type int dword_4D68C0;

//----- (0040F500) --------------------------------------------------------
void __thiscall SendResetScoresPacket(PLAYER *player)
{
  __int16 v1; // dx
  struct ARENA *v2; // ecx
  PLAYER *buf; // [esp+0h] [ebp-4h] BYREF

  buf = player;
  v1 = player->field_14;
  player->score.losses = 0;
  player->score.wins = 0;
  player->score.points = 0;
  player->score.flag_points = 0;
  player->score.flags = 0;
  *(_DWORD *)&player->field_2F9[20] = 1;
  v2 = (struct ARENA *)player->lpCurrentArena;
  LOBYTE(buf) = 26;
  *(_WORD *)((char *)&buf + 1) = v1;
  if ( v2 )
    ArenaSendPacket(v2, (char *)&buf, 3, 1);
}

//----- (0040F560) --------------------------------------------------------
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player)
{
  __int16 v1; // ax
  __int16 v2; // dx
  int v3; // eax
  char buf; // [esp+0h] [ebp-10h] BYREF
  __int16 v5; // [esp+1h] [ebp-Fh]
  int v6; // [esp+3h] [ebp-Dh]
  int v7; // [esp+7h] [ebp-9h]
  __int16 v8; // [esp+Bh] [ebp-5h]
  __int16 v9; // [esp+Dh] [ebp-3h]

  v1 = player->field_14;
  v6 = player->score.points;
  v2 = player->score.wins;
  v5 = v1;
  v3 = player->score.flag_points;
  v8 = v2;
  v7 = v3;
  LOWORD(v3) = player->score.losses;
  buf = 9;
  v9 = v3;
  PlayerSendPacket(player, &buf, 15, 1);
}

//----- (0040F5B0) --------------------------------------------------------
signed int __thiscall SendPlayerScoreUpdateAll(int this)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebp
  int v5; // ecx
  int v6; // eax
  __int16 v7; // cx
  int v8; // ebp
  __int16 v9; // dx
  int v10; // ebp
  int v11; // ebp
  int v12; // edi
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  char buf; // [esp+10h] [ebp-10h] BYREF
  __int16 v18; // [esp+11h] [ebp-Fh]
  int v19; // [esp+13h] [ebp-Dh]
  int v20; // [esp+17h] [ebp-9h]
  __int16 v21; // [esp+1Bh] [ebp-5h]
  __int16 v22; // [esp+1Dh] [ebp-3h]

  v2 = *(_DWORD *)(this + 557);
  v3 = *(_DWORD *)(this + 581);
  v4 = *(_DWORD *)(this + 585);
  v5 = *(_DWORD *)(this + 553);
  if ( v5 + v2 - v3 - v4 <= dwMisc_PointUpdateDiff )
    return 0;
  if ( !dword_4CA22C )
    return 0;
  v6 = *(_DWORD *)(this + 28);
  if ( !v6 )
    return 0;
  v19 = v5;
  v7 = *(_WORD *)(this + 547);
  v8 = *(_DWORD *)(this + 547);
  v20 = v2;
  *(_DWORD *)(this + 575) = v8;
  v9 = *(_WORD *)(this + 549);
  v10 = *(_DWORD *)(this + 551);
  buf = 9;
  *(_DWORD *)(this + 579) = v10;
  v21 = v7;
  v11 = *(_DWORD *)(this + 555);
  v22 = v9;
  *(_DWORD *)(this + 583) = v11;
  *(_WORD *)(this + 587) = *(_WORD *)(this + 559);
  v18 = *(_WORD *)(this + 20);
  v12 = 0;
  if ( *(int *)(v6 + 65292) > 0 )
  {
    v13 = 64288;
    do
    {
      v14 = *(_DWORD *)(v13 + v6);
      if ( v14 != this && !*(_DWORD *)(v14 + 56) )
        PlayerSendPacket((PLAYER *)v14, &buf, 15, 0);
      v6 = *(_DWORD *)(this + 28);
      ++v12;
      v13 += 4;
    }
    while ( v12 < *(_DWORD *)(v6 + 65292) );
  }
  PlayerSendPacket((PLAYER *)this, &buf, 15, 1);
  if ( FindMeOut1 )
  {
    v15 = *(_DWORD *)(this + 28);
    if ( !*(_DWORD *)(v15 + 109754) )
    {
      if ( *(_DWORD *)(v15 + 65378) )
      {
        if ( (dwMisc_DisableSharewareScores || dwMisc_DisableShareware) && *(_DWORD *)(this + 72) )
          return 1;
        SendBillerUserScorePacket(
          (struct BILLING_SERVER_STRUCT *)FindMeOut1,
          *(_DWORD *)(this + offsetof(PLAYER, connection_id)),
          (const void *)(this + offsetof(PLAYER, score)),
          0xEu);
      }
    }
  }
  return 1;
}
// 4CA22C: using guessed type int dword_4CA22C;
// 4CB8FC: using guessed type int dwMisc_PointUpdateDiff;
// 4D6C08: using guessed type int dwMisc_DisableShareware;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (0040F710) --------------------------------------------------------
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2)
{
  __int64 v3; // rax
  DWORD v4; // kr00_4
  int v5; // eax
  int v6; // edx
  int v7; // edx
  int v8; // edx

  if ( a2
    || (v3 = (int)(GetTickCount() / 0xA - *(_DWORD *)&playerr->lpArenaPointer2[4]),
        (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) >= 3000) )
  {
    v4 = GetTickCount();
    v5 = *(_DWORD *)&playerr->field_44[4];
    *(_DWORD *)&playerr->lpArenaPointer2[4] = v4 / 0xA;
    if ( v5 )
    {
      if ( dword_4D9DF4 > 0 || highestNumSharewareAdsCount > 0 )
      {
        v6 = rand() % (dword_4D9DF4 + highestNumSharewareAdsCount);
        if ( v6 >= dword_4D9DF4 )
        {
          v7 = v6 - dword_4D9DF4;
          if ( a2 )
            PlayerSendPacket(playerr, *(&buf + 2 * v7), buf_sz[2 * v7], 1);
          else
            GetMapLvlRequest((struct CONNECTION *)playerr->lpNetworkData, (char *)*(&buf + 2 * v7), buf_sz[2 * v7], 0);
          return;
        }
        if ( a2 )
        {
LABEL_19:
          PlayerSendPacket(playerr, (void *)*(&dword_438FA0 + 2 * v6), dword_438FA4[2 * v6], 1);
          return;
        }
LABEL_20:
        GetMapLvlRequest(
          (struct CONNECTION *)playerr->lpNetworkData,
          (char *)*(&dword_438FA0 + 2 * v6),
          dword_438FA4[2 * v6],
          0);
        return;
      }
    }
    else if ( dword_4D9DF4 > 0 || highestNumRegisteredAdsCount > 0 )
    {
      v6 = rand() % (dword_4D9DF4 + highestNumRegisteredAdsCount);
      if ( v6 < dword_4D9DF4 )
      {
        if ( a2 )
          goto LABEL_19;
        goto LABEL_20;
      }
      v8 = v6 - dword_4D9DF4;
      if ( a2 )
        PlayerSendPacket(playerr, (void *)*(&dword_432AA8 + 2 * v8), dword_432AAC[2 * v8], 1);
      else
        GetMapLvlRequest(
          (struct CONNECTION *)playerr->lpNetworkData,
          (char *)*(&dword_432AA8 + 2 * v8),
          dword_432AAC[2 * v8],
          0);
    }
  }
}
// 4D9DEC: using guessed type int highestNumSharewareAdsCount;
// 4D9DF0: using guessed type int highestNumRegisteredAdsCount;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0040F8A0) --------------------------------------------------------
// the flow control before some of the get config calls sets the default value for the ships is its variable
// these are vie settings
// 
// when the compiler uses branchless logic for this there are no jumps so it looks
// like strange math. it is really only flow control.
void __cdecl LoadArenaSettings(struct_ArenaSettings *ArenaSettings, struct_ArenaSettings *a2, const char *a3)
{
  struc_2 *v3; // eax
  struct struc_2 *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  const char *v32; // edi
  _BYTE *v33; // esi
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  char v39; // al
  int v40; // edx
  char v41; // al
  int v42; // ecx
  char v43; // al
  int v44; // edx
  int v45; // eax
  int *v46; // esi
  int v47; // edi
  char v48; // [esp-4h] [ebp-44h]
  int v49; // [esp-4h] [ebp-44h]
  char *lpszSection[8]; // [esp+14h] [ebp-2Ch]
  int v51; // [esp+3Ch] [ebp-4h]
  int i; // [esp+4Ch] [ebp+Ch]

  v3 = (struc_2 *)operator new(0x2B74Cu);
  v51 = 0;
  if ( v3 )
    v4 = ReadSettingsSomething(v3, a3);
  else
    v4 = 0;
  v51 = -1;
  if ( ArenaSettings )
  {
    memset(ArenaSettings, 0, sizeof(struct_ArenaSettings));
    ArenaSettings->byte0 = 15;
    ArenaSettings->byte577 = 0;
    v48 = GetCFGSettingInteger(v4, "PrizeWeight", "QuickCharge", 80);
    lpfnFixExport12(ArenaSettings, v4);
    ArenaSettings->byte578 = v48;
    v5 = GetCFGSettingInteger(v4, "PrizeWeight", "Energy", 70);
    if ( v5 > 255 )
      LOBYTE(v5) = -1;
    ArenaSettings->byte579 = v5;
    v6 = GetCFGSettingInteger(v4, "PrizeWeight", "Rotation", 60);
    if ( v6 > 255 )
      LOBYTE(v6) = -1;
    ArenaSettings->byte57A = v6;
    v7 = GetCFGSettingInteger(v4, "PrizeWeight", "Stealth", 30);
    if ( v7 > 255 )
      LOBYTE(v7) = -1;
    ArenaSettings->byte57B = v7;
    v8 = GetCFGSettingInteger(v4, "PrizeWeight", "Cloak", 20);
    if ( v8 > 255 )
      LOBYTE(v8) = -1;
    ArenaSettings->byte57C = v8;
    v9 = GetCFGSettingInteger(v4, "PrizeWeight", "AntiWarp", 20);
    if ( v9 > 255 )
      LOBYTE(v9) = -1;
    ArenaSettings->byte58B = v9;
    v10 = GetCFGSettingInteger(v4, "PrizeWeight", "XRadar", 20);
    if ( v10 > 255 )
      LOBYTE(v10) = -1;
    ArenaSettings->byte57D = v10;
    v11 = GetCFGSettingInteger(v4, "PrizeWeight", "Warp", 40);
    if ( v11 > 255 )
      LOBYTE(v11) = -1;
    ArenaSettings->byte57E = v11;
    v12 = GetCFGSettingInteger(v4, "PrizeWeight", "Gun", 60);
    if ( v12 > 255 )
      LOBYTE(v12) = -1;
    ArenaSettings->byte57F = v12;
    v13 = GetCFGSettingInteger(v4, "PrizeWeight", "Bomb", 50);
    if ( v13 > 255 )
      LOBYTE(v13) = -1;
    ArenaSettings->byte580 = v13;
    v14 = GetCFGSettingInteger(v4, "PrizeWeight", "BouncingBullets", 30);
    if ( v14 > 255 )
      LOBYTE(v14) = -1;
    ArenaSettings->byte581 = v14;
    v15 = GetCFGSettingInteger(v4, "PrizeWeight", "Thruster", 70);
    if ( v15 > 255 )
      LOBYTE(v15) = -1;
    ArenaSettings->byte582 = v15;
    v16 = GetCFGSettingInteger(v4, "PrizeWeight", "TopSpeed", 70);
    if ( v16 > 255 )
      LOBYTE(v16) = -1;
    ArenaSettings->byte583 = v16;
    v17 = GetCFGSettingInteger(v4, "PrizeWeight", "Recharge", 60);
    if ( v17 > 255 )
      LOBYTE(v17) = -1;
    ArenaSettings->byte584 = v17;
    v18 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiFire", 30);
    if ( v18 > 255 )
      LOBYTE(v18) = -1;
    ArenaSettings->byte586 = v18;
    v19 = GetCFGSettingInteger(v4, "PrizeWeight", "Proximity", 30);
    if ( v19 > 255 )
      LOBYTE(v19) = -1;
    ArenaSettings->byte587 = v19;
    v20 = GetCFGSettingInteger(v4, "PrizeWeight", "Glue", 20);
    if ( v20 > 255 )
      LOBYTE(v20) = -1;
    ArenaSettings->byte585 = v20;
    v21 = GetCFGSettingInteger(v4, "PrizeWeight", "AllWeapons", 10);
    if ( v21 > 255 )
      LOBYTE(v21) = -1;
    ArenaSettings->byte588 = v21;
    v22 = GetCFGSettingInteger(v4, "PrizeWeight", "Shields", 10);
    if ( v22 > 255 )
      LOBYTE(v22) = -1;
    ArenaSettings->byte589 = v22;
    v23 = GetCFGSettingInteger(v4, "PrizeWeight", "Shrapnel", 40);
    if ( v23 > 255 )
      LOBYTE(v23) = -1;
    ArenaSettings->byte58A = v23;
    v24 = GetCFGSettingInteger(v4, "PrizeWeight", "Repel", 40);
    if ( v24 > 255 )
      LOBYTE(v24) = -1;
    ArenaSettings->byte58C = v24;
    v25 = GetCFGSettingInteger(v4, "PrizeWeight", "Burst", 30);
    if ( v25 > 255 )
      LOBYTE(v25) = -1;
    ArenaSettings->byte58D = v25;
    v26 = GetCFGSettingInteger(v4, "PrizeWeight", "Decoy", 20);
    if ( v26 > 255 )
      LOBYTE(v26) = -1;
    ArenaSettings->byte58E = v26;
    v27 = GetCFGSettingInteger(v4, "PrizeWeight", "Thor", 30);
    if ( v27 > 255 )
      LOBYTE(v27) = -1;
    ArenaSettings->byte58F = v27;
    v28 = GetCFGSettingInteger(v4, "PrizeWeight", "Portal", 30);
    if ( v28 > 255 )
      LOBYTE(v28) = -1;
    ArenaSettings->byte593 = v28;
    v29 = GetCFGSettingInteger(v4, "PrizeWeight", "Brick", 10);
    if ( v29 > 255 )
      LOBYTE(v29) = -1;
    ArenaSettings->byte591 = v29;
    v30 = GetCFGSettingInteger(v4, "PrizeWeight", "Rocket", 10);
    if ( v30 > 255 )
      LOBYTE(v30) = -1;
    ArenaSettings->byte592 = v30;
    v31 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiPrize", 20);
    if ( v31 > 255 )
      LOBYTE(v31) = -1;
    ArenaSettings->byte590 = v31;
    lpszSection[0] = "Warbird";
    lpszSection[1] = "Javelin";
    lpszSection[2] = "Spider";
    lpszSection[3] = "Leviathan";
    lpszSection[4] = "Terrier";
    lpszSection[5] = "Weasel";
    lpszSection[6] = "Lancaster";
    lpszSection[7] = "Shark";
    for ( i = 0; i < 8; ++i )
    {
      v32 = lpszSection[i];
      v33 = &ArenaSettings->f1[144 * i + 3];
      *(_DWORD *)v33 = GetCFGSettingInteger(v4, v32, "SuperTime", 6000);
      *((_DWORD *)v33 + 1) = GetCFGSettingInteger(v4, v32, "ShieldsTime", 4000);
      *((_WORD *)v33 + 4) = GetCFGSettingInteger(v4, v32, "Gravity", 1500);
      *((_WORD *)v33 + 5) = GetCFGSettingInteger(v4, v32, "GravityTopSpeed", 100);
      *((_WORD *)v33 + 6) = GetCFGSettingInteger(v4, v32, "BulletFireEnergy", 20);
      *((_WORD *)v33 + 7) = GetCFGSettingInteger(v4, v32, "MultiFireEnergy", 30);
      *((_WORD *)v33 + 8) = GetCFGSettingInteger(v4, v32, "BombFireEnergy", 300);
      *((_WORD *)v33 + 9) = GetCFGSettingInteger(v4, v32, "BombFireEnergyUpgrade", 50);
      *((_WORD *)v33 + 10) = GetCFGSettingInteger(v4, v32, "LandmineFireEnergy", 300);
      *((_WORD *)v33 + 11) = GetCFGSettingInteger(v4, v32, "LandmineFireEnergyUpgrade", 150);
      *((_WORD *)v33 + 12) = GetCFGSettingInteger(v4, v32, "BulletSpeed", 2000);
      *((_WORD *)v33 + 13) = GetCFGSettingInteger(v4, v32, "BombSpeed", 2000);
      v34 = -(i != 4);
      LOBYTE(v34) = v34 & 0xFB;
      *((_WORD *)v33 + 40) = GetCFGSettingInteger(v4, v32, "BulletFireDelay", v34 + 30);
      *((_WORD *)v33 + 41) = GetCFGSettingInteger(v4, v32, "MultiFireDelay", 50);
      *((_WORD *)v33 + 42) = GetCFGSettingInteger(v4, v32, "BombFireDelay", 150);
      *((_WORD *)v33 + 43) = GetCFGSettingInteger(v4, v32, "LandmineFireDelay", 125);
      *((_WORD *)v33 + 15) = GetCFGSettingInteger(v4, v32, "MultiFireAngle", 500);
      v35 = -(i != 7);
      LOBYTE(v35) = v35 & 0x38;
      *((_WORD *)v33 + 16) = GetCFGSettingInteger(v4, v32, "CloakEnergy", v35 + 300);
      *((_WORD *)v33 + 17) = GetCFGSettingInteger(v4, v32, "StealthEnergy", i != 7 ? 333 : 300);
      *((_WORD *)v33 + 18) = GetCFGSettingInteger(v4, v32, "AntiWarpEnergy", 100);
      *((_WORD *)v33 + 19) = GetCFGSettingInteger(v4, v32, "XRadarEnergy", 250);
      if ( i )
      {
        if ( i == 7 )
          v49 = 280;
        else
          v49 = 230;
      }
      else
      {
        v49 = 300;
      }
      *(_WORD *)&ArenaSettings->f1[144 * i + 43] = GetCFGSettingInteger(v4, v32, "MaximumRotation", v49);
      if ( i == 7 || (v36 = 17, !i) )
        v36 = 19;
      *(_WORD *)&ArenaSettings->f1[144 * i + 45] = GetCFGSettingInteger(v4, v32, "MaximumThrust", v36);
      *(_WORD *)&ArenaSettings->f1[144 * i + 47] = GetCFGSettingInteger(v4, v32, "MaximumSpeed", i != 1 ? 3250 : 3750);
      *(_WORD *)&ArenaSettings->f1[144 * i + 49] = GetCFGSettingInteger(v4, v32, "MaximumRecharge", 1150);
      *(_WORD *)&ArenaSettings->f1[144 * i + 51] = GetCFGSettingInteger(v4, v32, "MaximumEnergy", i != 7 ? 1700 : 1750);
      *(_WORD *)&ArenaSettings->f1[144 * i + 53] = GetCFGSettingInteger(v4, v32, "InitialRotation", i != 0 ? 200 : 210);
      *(_WORD *)&ArenaSettings->f1[144 * i + 55] = GetCFGSettingInteger(v4, v32, "InitialThrust", 16 - (i != 0));
      v37 = -(i != 1);
      LOBYTE(v37) = v37 & 0x42;
      *(_WORD *)&ArenaSettings->f1[144 * i + 57] = GetCFGSettingInteger(v4, v32, "InitialSpeed", v37 + 2200);
      *(_WORD *)&ArenaSettings->f1[144 * i + 59] = GetCFGSettingInteger(v4, v32, "InitialRecharge", i != 2 ? 400 : 500);
      *(_WORD *)&ArenaSettings->f1[144 * i + 61] = GetCFGSettingInteger(v4, v32, "InitialEnergy", 1000);
      *(_WORD *)&ArenaSettings->f1[144 * i + 63] = GetCFGSettingInteger(v4, v32, "UpgradeRotation", 40);
      *(_WORD *)&ArenaSettings->f1[144 * i + 65] = GetCFGSettingInteger(v4, v32, "UpgradeThrust", 2);
      *(_WORD *)&ArenaSettings->f1[144 * i + 67] = GetCFGSettingInteger(v4, v32, "UpgradeSpeed", 250);
      *(_WORD *)&ArenaSettings->f1[144 * i + 69] = GetCFGSettingInteger(v4, v32, "UpgradeRecharge", 166);
      *(_WORD *)&ArenaSettings->f1[144 * i + 71] = GetCFGSettingInteger(v4, v32, "UpgradeEnergy", 100);
      *(_WORD *)&ArenaSettings->f1[144 * i + 73] = GetCFGSettingInteger(v4, v32, "AfterburnerEnergy", 1200);
      *(_WORD *)&ArenaSettings->f1[144 * i + 75] = GetCFGSettingInteger(v4, v32, "BombThrust", 400);
      *(_WORD *)&ArenaSettings->f1[144 * i + 77] = GetCFGSettingInteger(v4, v32, "BurstSpeed", 3000);
      ArenaSettings->f1[144 * i + 110] = GetCFGSettingInteger(v4, v32, "BurstShrapnel", 24);
      *(_WORD *)&ArenaSettings->f1[144 * i + 79] = GetCFGSettingInteger(v4, v32, "TurretThrustPenalty", 1);
      *(_WORD *)&ArenaSettings->f1[144 * i + 81] = GetCFGSettingInteger(v4, v32, "TurretSpeedPenalty", 125);
      ArenaSettings->f1[144 * i + 109] = GetCFGSettingInteger(v4, v32, "TurretLimit", 5);
      *(_WORD *)&ArenaSettings->f1[144 * i + 91] = GetCFGSettingInteger(v4, v32, "RocketTime", 1000);
      *(_WORD *)&ArenaSettings->f1[144 * i + 93] = GetCFGSettingInteger(v4, v32, "InitialBounty", 0);
      ArenaSettings->f1[144 * i + 111] = GetCFGSettingInteger(v4, v32, "MaxMines", 5);
      ArenaSettings->f1[144 * i + 112] = GetCFGSettingInteger(v4, v32, "RepelMax", 3);
      ArenaSettings->f1[144 * i + 113] = GetCFGSettingInteger(v4, v32, "BurstMax", 3);
      ArenaSettings->f1[144 * i + 114] = GetCFGSettingInteger(v4, v32, "DecoyMax", 3);
      ArenaSettings->f1[144 * i + 115] = GetCFGSettingInteger(v4, v32, "ThorMax", 3);
      ArenaSettings->f1[144 * i + 116] = GetCFGSettingInteger(v4, v32, "BrickMax", 3);
      ArenaSettings->f1[144 * i + 117] = GetCFGSettingInteger(v4, v32, "RocketMax", 3);
      ArenaSettings->f1[144 * i + 118] = GetCFGSettingInteger(v4, v32, "PortalMax", 3);
      ArenaSettings->f1[144 * i + 119] = GetCFGSettingInteger(v4, v32, "InitialRepel", 0);
      ArenaSettings->f1[144 * i + 120] = GetCFGSettingInteger(v4, v32, "InitialBurst", 0);
      ArenaSettings->f1[144 * i + 121] = GetCFGSettingInteger(v4, v32, "InitialBrick", 0);
      ArenaSettings->f1[144 * i + 122] = GetCFGSettingInteger(v4, v32, "InitialRocket", 0);
      ArenaSettings->f1[144 * i + 123] = GetCFGSettingInteger(v4, v32, "InitialThor", 0);
      ArenaSettings->f1[144 * i + 124] = GetCFGSettingInteger(v4, v32, "InitialDecoy", i == 2);
      ArenaSettings->f1[144 * i + 125] = GetCFGSettingInteger(v4, v32, "InitialPortal", 0);
      ArenaSettings->f1[144 * i + 126] = GetCFGSettingInteger(v4, v32, "BombBounceCount", i == 6);
      v38 = i == 2 || i == 7;
      v39 = GetCFGSettingInteger(v4, v32, "CloakStatus", v38);
      v40 = *(_DWORD *)&ArenaSettings->f1[144 * i + 127];
      BYTE1(v40) &= 0xF3u;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = v40 | ((v39 & 3) << 10);
      v41 = GetCFGSettingInteger(v4, v32, "StealthStatus", (i == 2) + 1);
      v42 = *(_DWORD *)&ArenaSettings->f1[144 * i + 127];
      BYTE1(v42) &= 0xCFu;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((v41 & 3) << 12) | v42;
      v43 = GetCFGSettingInteger(v4, v32, "XRadarStatus", 1);
      v44 = *(_DWORD *)&ArenaSettings->f1[144 * i + 127];
      BYTE1(v44) &= 0x3Fu;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((v43 & 3) << 14) | v44;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "AntiWarpStatus", 1) & 3) << 16) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFFFCFFFF;
      *(_WORD *)&ArenaSettings->f1[144 * i + 95] = GetCFGSettingInteger(v4, v32, "DamageFactor", 30);
      *(_WORD *)&ArenaSettings->f1[144 * i + 97] = GetCFGSettingInteger(v4, v32, "PrizeShareLimit", 100);
      *(_WORD *)&ArenaSettings->f1[144 * i + 99] = GetCFGSettingInteger(v4, v32, "AttachBounty", 12);
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] ^= ((unsigned __int8)GetCFGSettingInteger(
                                                                          v4,
                                                                          v32,
                                                                          "ShrapnelMax",
                                                                          i != 5 ? 8 : 0) ^ (unsigned __int8)*(_DWORD *)&ArenaSettings->f1[144 * i + 0x7F]) & 0x1F;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = (32 * (GetCFGSettingInteger(v4, v32, "ShrapnelRate", 2) & 0x1F)) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFFFFFC1F;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "MaxGuns", 3) & 3) << 20) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFFCFFFFF;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "MaxBombs", (i == 3) + 2) & 3) << 24) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFCFFFFFF;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "InitialGuns", (i == 4) + 1) & 3) << 18) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFFF3FFFF;
      v45 = i == 3 || i == 5;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "InitialBombs", v45) & 3) << 22) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFF3FFFFF;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "EmpBomb", i == 5) & 1) << 27) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xF7FFFFFF;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "SeeMines", i == 5) & 1) << 28) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xEFFFFFFF;
      *(_DWORD *)&ArenaSettings->f1[144 * i + 127] = ((GetCFGSettingInteger(v4, v32, "DoubleBarrel", i == 4) & 1) << 26) | *(_DWORD *)&ArenaSettings->f1[144 * i + 127] & 0xFBFFFFFF;
      *(_WORD *)&ArenaSettings->f1[144 * i + 103] = GetCFGSettingInteger(v4, v32, "SoccerBallFriction", 12);
      *(_WORD *)&ArenaSettings->f1[144 * i + 105] = GetCFGSettingInteger(v4, v32, "SoccerBallProximity", 64);
      *(_WORD *)&ArenaSettings->f1[144 * i + 101] = GetCFGSettingInteger(v4, v32, "SoccerThrowTime", 1200);
      *(_WORD *)&ArenaSettings->f1[144 * i + 107] = GetCFGSettingInteger(v4, v32, "SoccerBallSpeed", 2500);
    }
    ArenaSettings->dword484 = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageLevel", 200);
    ArenaSettings->dword4B0 = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageUpgrade", 100);
    ArenaSettings->dword48C = GetCFGSettingInteger(v4, "Bullet", "BulletAliveTime", 550);
    ArenaSettings->dword488 = 1000 * GetCFGSettingInteger(v4, "Bomb", "BombDamageLevel", 750);
    ArenaSettings->dword490 = GetCFGSettingInteger(v4, "Bomb", "BombAliveTime", 6000);
    ArenaSettings->word4E6 = GetCFGSettingInteger(v4, "Bomb", "BombExplodeDelay", 150);
    ArenaSettings->word4EA = GetCFGSettingInteger(v4, "Bomb", "BombExplodePixels", 80);
    ArenaSettings->word4F4 = GetCFGSettingInteger(v4, "Bomb", "ProximityDistance", 3);
    ArenaSettings->word4EE = GetCFGSettingInteger(v4, "Bomb", "JitterTime", 72);
    ArenaSettings->byte561 = GetCFGSettingInteger(v4, "Bomb", "BombSafety", 1);
    ArenaSettings->word52A = GetCFGSettingInteger(v4, "Bomb", "EBombShutdownTime", 400);
    ArenaSettings->word52C = GetCFGSettingInteger(v4, "Bomb", "EBombDamagePercent", 1000);
    ArenaSettings->word534 = GetCFGSettingInteger(v4, "Bomb", "BBombDamagePercent", 1000);
    ArenaSettings->dword4A8 = GetCFGSettingInteger(v4, "Mine", "MineAliveTime", 12000);
    ArenaSettings->byte55F = GetCFGSettingInteger(v4, "Mine", "TeamMaxMines", 12);
    ArenaSettings->dword4D0 = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelSpeed", 3000);
    ArenaSettings->dword4C4 = 1000 * GetCFGSettingInteger(v4, "Shrapnel", "InactiveShrapDamage", 3);
    ArenaSettings->word536 = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelDamagePercent", 1000);
    ArenaSettings->byte558 = GetCFGSettingInteger(v4, "Shrapnel", "Random", 1);
    ArenaSettings->dword4AC = 1000 * GetCFGSettingInteger(v4, "Burst", "BurstDamageLevel", 515);
    ArenaSettings->word51C = GetCFGSettingInteger(v4, "Toggle", "AntiWarpPixels", 1500);
    ArenaSettings->word524 = GetCFGSettingInteger(v4, "Prize", "MultiPrizeCount", 10);
    ArenaSettings->word50C = GetCFGSettingInteger(v4, "Prize", "PrizeFactor", 1000);
    ArenaSettings->word50E = GetCFGSettingInteger(v4, "Prize", "PrizeDelay", 300);
    ArenaSettings->byte565 = GetCFGSettingInteger(v4, "Prize", "PrizeHideCount", 30);
    ArenaSettings->word510 = GetCFGSettingInteger(v4, "Prize", "MinimumVirtual", 256);
    ArenaSettings->word512 = GetCFGSettingInteger(v4, "Prize", "UpgradeVirtual", 6);
    ArenaSettings->word514 = GetCFGSettingInteger(v4, "Prize", "PrizeMaxExist", 8000);
    ArenaSettings->word516 = GetCFGSettingInteger(v4, "Prize", "PrizeMinExist", 4000);
    ArenaSettings->word518 = GetCFGSettingInteger(v4, "Prize", "PrizeNegativeFactor", 300);
    ArenaSettings->word4EC = GetCFGSettingInteger(v4, "Prize", "DeathPrizeTime", 800);
    ArenaSettings->word4F2 = GetCFGSettingInteger(v4, "Prize", "EngineShutdownTime", 700);
    ArenaSettings->byte563 = GetCFGSettingInteger(v4, "Prize", "TakePrizeReliable", 0);
    ArenaSettings->word508 = GetCFGSettingInteger(v4, "Flag", "FlaggerOnRadar", 1);
    ArenaSettings->word50A = GetCFGSettingInteger(v4, "Flag", "FlaggerKillMultiplier", 2);
    ArenaSettings->byte56C = GetCFGSettingInteger(v4, "Flag", "FlaggerGunUpgrade", 0);
    ArenaSettings->byte56D = GetCFGSettingInteger(v4, "Flag", "FlaggerBombUpgrade", 0);
    ArenaSettings->word53C = GetCFGSettingInteger(v4, "Flag", "FlaggerFireCostPercent", 1000);
    ArenaSettings->word53E = GetCFGSettingInteger(v4, "Flag", "FlaggerDamagePercent", 1000);
    ArenaSettings->word540 = GetCFGSettingInteger(v4, "Flag", "FlaggerBombFireDelay", 0);
    ArenaSettings->word54A = GetCFGSettingInteger(v4, "Flag", "FlaggerSpeedAdjustment", 0);
    ArenaSettings->word548 = GetCFGSettingInteger(v4, "Flag", "FlaggerThrustAdjustment", 0);
    ArenaSettings->byte568 = GetCFGSettingInteger(v4, "Flag", "CarryFlags", 1);
    ArenaSettings->dword4B4 = GetCFGSettingInteger(v4, "Flag", "FlagDropDelay", 0);
    ArenaSettings->word53A = GetCFGSettingInteger(v4, "Flag", "FlagDropResetReward", 0);
    ArenaSettings->dword4B8 = GetCFGSettingInteger(v4, "Flag", "EnterGameFlaggingDelay", 12000);
    ArenaSettings->word520 = GetCFGSettingInteger(v4, "Flag", "FlagBlankDelay", 200);
    ArenaSettings->word522 = GetCFGSettingInteger(v4, "Flag", "NoDataFlagDropDelay", 500);
    ArenaSettings->byte559 = GetCFGSettingInteger(v4, "Soccer", "BallBounce", 1);
    ArenaSettings->byte55A = GetCFGSettingInteger(v4, "Soccer", "AllowBombs", 1);
    ArenaSettings->byte55B = GetCFGSettingInteger(v4, "Soccer", "AllowGuns", 1);
    ArenaSettings->word542 = GetCFGSettingInteger(v4, "Soccer", "PassDelay", 20);
    ArenaSettings->byte55C = GetCFGSettingInteger(v4, "Soccer", "Mode", 1);
    ArenaSettings->word544 = GetCFGSettingInteger(v4, "Soccer", "BallBlankDelay", 200);
    ArenaSettings->byte56E = GetCFGSettingInteger(v4, "Soccer", "UseFlagger", 0);
    ArenaSettings->byte56F = GetCFGSettingInteger(v4, "Soccer", "BallLocation", 0);
    ArenaSettings->byte56A = GetCFGSettingInteger(v4, "Radar", "RadarMode", 0);
    ArenaSettings->word52E = GetCFGSettingInteger(v4, "Radar", "RadarNeutralSize", 128);
    ArenaSettings->word4FA = GetCFGSettingInteger(v4, "Radar", "MapZoomFactor", 10);
    ArenaSettings->dword4A0 = GetCFGSettingInteger(v4, "Team", "MaxFrequency", 9999);
    ArenaSettings->byte55D = GetCFGSettingInteger(v4, "Team", "MaxPerTeam", 6);
    ArenaSettings->byte55E = GetCFGSettingInteger(v4, "Team", "MaxPerPrivateTeam", 0);
    ArenaSettings->word4FC = GetCFGSettingInteger(v4, "Kill", "MaxBonus", 0);
    ArenaSettings->word4FE = GetCFGSettingInteger(v4, "Kill", "MaxPenalty", 0);
    ArenaSettings->word500 = GetCFGSettingInteger(v4, "Kill", "RewardBase", 0);
    ArenaSettings->word4F6 = GetCFGSettingInteger(v4, "Kill", "BountyIncreaseForKill", 6);
    ArenaSettings->word4F0 = GetCFGSettingInteger(v4, "Kill", "EnterDelay", 200);
    ArenaSettings->dword4A4 = GetCFGSettingInteger(v4, "Repel", "RepelSpeed", 5000);
    ArenaSettings->word502 = GetCFGSettingInteger(v4, "Repel", "RepelTime", 225);
    ArenaSettings->word504 = GetCFGSettingInteger(v4, "Repel", "RepelDistance", 512);
    ArenaSettings->byte562 = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    ArenaSettings->byte564 = GetCFGSettingInteger(v4, "Message", "AllowAudioMessages", 1);
    ArenaSettings->byte560 = GetCFGSettingInteger(v4, "Wormhole", "GravityBombs", 1);
    ArenaSettings->dword4C8 = GetCFGSettingInteger(v4, "Wormhole", "SwitchTime", 0);
    ArenaSettings->word4E4 = GetCFGSettingInteger(v4, "Latency", "SendRoutePercent", 500);
    ArenaSettings->word54C = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketSampleSize", 100);
    ArenaSettings->word526 = GetCFGSettingInteger(v4, "Brick", "BrickTime", 12000);
    ArenaSettings->dword4BC = GetCFGSettingInteger(v4, "Rocket", "RocketThrust", 25);
    ArenaSettings->dword4C0 = GetCFGSettingInteger(v4, "Rocket", "RocketSpeed", 5500);
    ArenaSettings->word51A = GetCFGSettingInteger(v4, "Door", "DoorDelay", 400);
    ArenaSettings->word51E = GetCFGSettingInteger(v4, "Door", "DoorMode", -1);
    ArenaSettings->word530 = GetCFGSettingInteger(v4, "Misc", "WarpPointDelay", 6000);
    ArenaSettings->dword494 = GetCFGSettingInteger(v4, "Misc", "DecoyAliveTime", 3000);
    ArenaSettings->word4F8 = GetCFGSettingInteger(v4, "Misc", "BounceFactor", 22);
    ArenaSettings->word4E8 = GetCFGSettingInteger(v4, "Misc", "SendPositionDelay", 10);
    ArenaSettings->byte567 = GetCFGSettingInteger(v4, "Misc", "SlowFrameCheck", 0);
    ArenaSettings->byte569 = GetCFGSettingInteger(v4, "Misc", "AllowSavedShips", 1);
    ArenaSettings->dword498 = GetCFGSettingInteger(v4, "Misc", "SafetyLimit", 90000);
    ArenaSettings->dword49C = GetCFGSettingInteger(v4, "Misc", "FrequencyShift", 900);
    ArenaSettings->word506 = GetCFGSettingInteger(v4, "Misc", "TickerDelay", 1000);
    ArenaSettings->byte566 = GetCFGSettingInteger(v4, "Misc", "ExtraPositionData", 0);
    ArenaSettings->word528 = GetCFGSettingInteger(v4, "Misc", "WarpRadiusLimit", 1024);
    ArenaSettings->dword4CC = GetCFGSettingInteger(v4, "Misc", "ActivateAppShutdownTime", 1500);
    ArenaSettings->word532 = GetCFGSettingInteger(v4, "Misc", "NearDeathLevel", 0);
    ArenaSettings->byte56B = GetCFGSettingInteger(v4, "Misc", "VictoryMusic", 1);
    ArenaSettings->word538 = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketTime", 40);
    ArenaSettings->word546 = GetCFGSettingInteger(v4, "Latency", "S2CNoDataKickoutDelay", 500);
  }
  if ( a2 )
  {
    *(_DWORD *)&a2->f1[3] = GetCFGSettingInteger(v4, "Custom", "SaveStatsTime", 720000);
    *(_DWORD *)&a2->f1[15] = GetCFGSettingInteger(v4, "Territory", "RewardDelay", 60000);
    *(_DWORD *)&a2->f1[19] = GetCFGSettingInteger(v4, "Territory", "RewardBaseFlags", 8);
    *(_DWORD *)&a2->f1[23] = GetCFGSettingInteger(v4, "Territory", "RewardMinimumPlayers", 5);
    *(_DWORD *)&a2->f1[27] = GetCFGSettingInteger(v4, "Territory", "RewardPoints", 30);
    *(_DWORD *)&a2->f1[31] = GetCFGSettingInteger(v4, "Periodic", "RewardDelay", 0);
    *(_DWORD *)&a2->f1[35] = GetCFGSettingInteger(v4, "Periodic", "RewardMinimumPlayers", 16);
    *(_DWORD *)&a2->f1[39] = GetCFGSettingInteger(v4, "Periodic", "RewardPoints", 50);
    *(_DWORD *)&a2->f1[123] = GetCFGSettingInteger(v4, "Flag", "FlagMode", 0);
    *(_DWORD *)&a2->f1[11] = GetCFGSettingInteger(v4, "Flag", "FlagResetDelay", 1440000);
    *(_DWORD *)&a2->f1[91] = GetCFGSettingInteger(v4, "Flag", "MaxFlags", 16);
    *(_DWORD *)&a2->f1[87] = GetCFGSettingInteger(v4, "Flag", "RandomFlags", 0);
    *(_DWORD *)&a2->f1[95] = GetCFGSettingInteger(v4, "Flag", "FlagReward", 1000);
    *(_DWORD *)&a2->f1[99] = GetCFGSettingInteger(v4, "Flag", "FlagRewardMode", 0);
    *(_DWORD *)&a2->f1[135] = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadius", 8);
    *(_DWORD *)&a2->f1[139] = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadiusCentroid", 0);
    *(_DWORD *)&a2->f1[103] = GetCFGSettingInteger(v4, "Flag", "FriendlyTransfer", 1);
    *(_DWORD *)&a2->f1[47] = GetCFGSettingInteger(v4, "Kill", "KillPointsPerFlag", 0);
    *(_DWORD *)&a2->f1[51] = GetCFGSettingInteger(v4, "Kill", "KillPointsMinimumBounty", 50);
    *(_DWORD *)&a2->f1[43] = GetCFGSettingInteger(v4, "Kill", "DebtKills", 0);
    *(_DWORD *)&a2->f1[55] = GetCFGSettingInteger(v4, "Kill", "NoRewardKillDelay", 0);
    *(_DWORD *)&a2->f1[59] = GetCFGSettingInteger(v4, "Kill", "BountyRewardPercent", 0);
    *(_DWORD *)&a2->f1[63] = GetCFGSettingInteger(v4, "Kill", "FixedKillReward", -1);
    *(_DWORD *)&a2->f1[127] = GetCFGSettingInteger(v4, "Kill", "JackpotBountyPercent", 0);
    *(_DWORD *)&a2->f1[155] = GetCFGSettingInteger(v4, "Team", "ForceEvenTeams", 0);
    *(_DWORD *)&a2->f1[83] = GetCFGSettingInteger(v4, "Team", "DesiredTeams", 2);
    *(_DWORD *)&a2->f1[107] = GetCFGSettingInteger(v4, "Team", "SpectatorFrequency", 8025);
    *(_DWORD *)&a2->f1[143] = GetCFGSettingInteger(v4, "Brick", "BrickSpan", 7);
    *(_DWORD *)&a2->f1[151] = GetCFGSettingInteger(v4, "Misc", "FrequencyShipTypes", 0);
    *(_DWORD *)&a2->f1[7] = GetCFGSettingInteger(v4, "Misc", "BannerPoints", 5000);
    *(_DWORD *)&a2->f1[111] = GetCFGSettingInteger(v4, "Misc", "MaxLossesToPlay", 0);
    *(_DWORD *)&a2->f1[115] = GetCFGSettingInteger(v4, "Misc", "SpectatorQuiet", 0);
    *(_DWORD *)&a2->f1[131] = GetCFGSettingInteger(v4, "Misc", "TimedGame", 0);
    GetCFGSettingString(v4, "Misc", "SheepMessage", "Sheep successfully cloned -- hello Dolly", &a2->f1[919], 0x100u);
    *(_DWORD *)&a2->f1[339] = GetCFGSettingInteger(v4, "Misc", "ResetScoreOnFrequencyChange", 0);
    *(_DWORD *)&a2->f1[247] = GetCFGSettingInteger(v4, "Misc", "MaxPlaying", 0);
    *(_DWORD *)&a2->f1[119] = GetCFGSettingInteger(v4, "Message", "BongAllowed", 0);
    *(_DWORD *)&a2->f1[159] = GetCFGSettingInteger(v4, "Message", "QuickMessageLimit", 8);
    *(_DWORD *)&a2->f1[163] = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    *(_DWORD *)&a2->f1[167] = GetCFGSettingInteger(v4, "Message", "MessageTeamReliable", 1);
    *(_DWORD *)&a2->f1[171] = GetCFGSettingInteger(v4, "Message", "MessageDistance", 17000);
    *(_DWORD *)&a2->f1[179] = GetCFGSettingInteger(v4, "Security", "SecurityKickOff", 1);
    *(_DWORD *)&a2->f1[175] = GetCFGSettingInteger(v4, "Security", "S2CKickOutPercentWeapons", 700);
    *(_DWORD *)&a2->f1[183] = GetCFGSettingInteger(v4, "Security", "SuicideLimit", 10);
    *(_DWORD *)&a2->f1[187] = GetCFGSettingInteger(v4, "Security", "MaxShipTypeSwitchCount", 40);
    *(_DWORD *)&a2->f1[191] = GetCFGSettingInteger(v4, "Security", "PacketModificationMax", 3);
    *(_DWORD *)&a2->f1[195] = GetCFGSettingInteger(v4, "Security", "MaxDeathWithoutFiring", 5);
    *(_DWORD *)&a2->f1[67] = GetCFGSettingInteger(v4, "PacketLoss", "C2SKickOutPercent", 800);
    *(_DWORD *)&a2->f1[71] = GetCFGSettingInteger(v4, "PacketLoss", "C2SNegativeKickOutPercent", 50);
    *(_DWORD *)&a2->f1[75] = GetCFGSettingInteger(v4, "PacketLoss", "S2CKickOutPercent", 800);
    *(_DWORD *)&a2->f1[79] = GetCFGSettingInteger(v4, "PacketLoss", "SpectatorPercentAdjust", 100);
    *(_DWORD *)&a2->f1[255] = GetCFGSettingInteger(v4, "PacketLoss", "PacketLossDisableWeapons", 1);
    *(_DWORD *)&a2->f1[199] = GetCFGSettingInteger(v4, "Latency", "KickOutDelay", 1000);
    *(_DWORD *)&a2->f1[203] = GetCFGSettingInteger(v4, "Latency", "NoFlagDelay", 300);
    *(_DWORD *)&a2->f1[207] = GetCFGSettingInteger(v4, "Latency", "NoFlagPenalty", 1000);
    *(_DWORD *)&a2->f1[211] = GetCFGSettingInteger(v4, "Latency", "SlowPacketKickoutPercent", 200);
    *(_DWORD *)&a2->f1[215] = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketKickoutPercent", 200);
    *(_DWORD *)&a2->f1[223] = GetCFGSettingInteger(v4, "Latency", "SlowPacketTime", 50);
    *(_DWORD *)&a2->f1[227] = GetCFGSettingInteger(v4, "Latency", "SlowPacketSampleSize", 300);
    *(_DWORD *)&a2->f1[231] = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForWeapons", 45);
    *(_DWORD *)&a2->f1[235] = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForPrizes", 80);
    *(_DWORD *)&a2->f1[239] = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForKickOut", 120);
    *(_DWORD *)&a2->f1[243] = GetCFGSettingInteger(v4, "Latency", "LatencyKickOutTime", 2200);
    *(_DWORD *)&a2->f1[251] = GetCFGSettingInteger(v4, "Latency", "CutbackWatermark", 2400);
    *(_DWORD *)&a2->f1[259] = GetCFGSettingInteger(v4, "Prize", "S2CTakePrizeReliable", 0);
    *(_DWORD *)&a2->f1[263] = GetCFGSettingInteger(v4, "Routing", "RadarFavor", 3);
    *(_DWORD *)&a2->f1[267] = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBulletAdjust", 512);
    *(_DWORD *)&a2->f1[271] = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBombAdjust", 2048);
    *(_DWORD *)&a2->f1[275] = GetCFGSettingInteger(v4, "Routing", "DeathDistance", 2800);
    *(_DWORD *)&a2->f1[279] = GetCFGSettingInteger(v4, "Routing", "DoubleSendPercent", 880);
    *(_DWORD *)&a2->f1[283] = GetCFGSettingInteger(v4, "Routing", "WallResendCount", 2);
    *(_DWORD *)&a2->f1[311] = GetCFGSettingInteger(v4, "Soccer", "BallCount", 0);
    *(_DWORD *)&a2->f1[315] = GetCFGSettingInteger(v4, "Soccer", "SendTime", 200);
    *(_DWORD *)&a2->f1[319] = GetCFGSettingInteger(v4, "Soccer", "Reward", 1000);
    *(_DWORD *)&a2->f1[323] = GetCFGSettingInteger(v4, "Soccer", "CapturePoints", 0);
    *(_DWORD *)&a2->f1[335] = GetCFGSettingInteger(v4, "Soccer", "CatchMinimum", 12);
    *(_DWORD *)&a2->f1[327] = GetCFGSettingInteger(v4, "Soccer", "CatchPoints", 0);
    *(_DWORD *)&a2->f1[331] = GetCFGSettingInteger(v4, "Soccer", "WinBy", 0);
    *(_DWORD *)&a2->f1[287] = GetCFGSettingInteger(v4, "King", "DeathCount", 0);
    *(_DWORD *)&a2->f1[291] = GetCFGSettingInteger(v4, "King", "ExpireTime", 30000);
    *(_DWORD *)&a2->f1[303] = GetCFGSettingInteger(v4, "King", "RewardFactor", 1000);
    *(_DWORD *)&a2->f1[295] = GetCFGSettingInteger(v4, "King", "NonCrownAdjustTime", 3000);
    *(_DWORD *)&a2->f1[299] = GetCFGSettingInteger(v4, "King", "NonCrownMinimumBounty", 100);
    *(_DWORD *)&a2->f1[307] = GetCFGSettingInteger(v4, "King", "CrownRecoverKills", 3);
    memset(&a2->f1[343], 0, 0x240u);
    strcpy(&a2->f1[343], "Recharge");
    *(_DWORD *)&a2->f1[363] = 1;
    strcpy(&a2->f1[367], "Energy");
    *(_DWORD *)&a2->f1[387] = 2;
    strcpy(&a2->f1[391], "Rotation");
    *(_DWORD *)&a2->f1[411] = 3;
    strcpy(&a2->f1[415], "Stealth");
    *(_DWORD *)&a2->f1[435] = 4;
    strcpy(&a2->f1[439], "Cloak");
    *(_DWORD *)&a2->f1[459] = 5;
    strcpy(&a2->f1[463], "XRadar");
    *(_DWORD *)&a2->f1[483] = 6;
    strcpy(&a2->f1[487], "Gun");
    *(_DWORD *)&a2->f1[507] = 8;
    strcpy(&a2->f1[511], "Bomb");
    *(_DWORD *)&a2->f1[531] = 9;
    strcpy(&a2->f1[535], "Bounce");
    *(_DWORD *)&a2->f1[555] = 10;
    strcpy(&a2->f1[559], "Thrust");
    *(_DWORD *)&a2->f1[579] = 11;
    strcpy(&a2->f1[583], "Speed");
    *(_DWORD *)&a2->f1[603] = 12;
    strcpy(&a2->f1[607], "MultiFire");
    *(_DWORD *)&a2->f1[627] = 15;
    strcpy(&a2->f1[631], "Prox");
    *(_DWORD *)&a2->f1[651] = 16;
    strcpy(&a2->f1[655], "Super");
    *(_DWORD *)&a2->f1[675] = 17;
    strcpy(&a2->f1[679], "Shield");
    *(_DWORD *)&a2->f1[699] = 18;
    strcpy(&a2->f1[703], "Shrap");
    *(_DWORD *)&a2->f1[723] = 19;
    strcpy(&a2->f1[727], "AntiWarp");
    *(_DWORD *)&a2->f1[747] = 20;
    strcpy(&a2->f1[751], "Repel");
    *(_DWORD *)&a2->f1[771] = 21;
    strcpy(&a2->f1[775], "Burst");
    *(_DWORD *)&a2->f1[795] = 22;
    strcpy(&a2->f1[799], "Decoy");
    *(_DWORD *)&a2->f1[819] = 23;
    strcpy(&a2->f1[823], "Thor");
    *(_DWORD *)&a2->f1[843] = 24;
    strcpy(&a2->f1[847], "Brick");
    *(_DWORD *)&a2->f1[867] = 26;
    strcpy(&a2->f1[871], "Rocket");
    *(_DWORD *)&a2->f1[891] = 27;
    strcpy(&a2->f1[895], "Portal");
    *(_DWORD *)&a2->f1[915] = 28;
    v46 = (int *)&a2->f1[359];
    v47 = 24;
    do
    {
      *v46 = GetCFGSettingInteger(v4, "Cost", (const char *)v46 - 16, 0);
      v46 += 6;
      --v47;
    }
    while ( v47 );
    *(_DWORD *)&a2->f1[147] = GetCFGSettingInteger(v4, "Cost", "PurchaseAnytime", 0);
    *(_DWORD *)&a2->byte0 = GetCFGSettingInteger(v4, "Owner", "UserId", -1);
    GetCFGSettingString(v4, "Owner", "Name", "None", (char *)&a2->dword498, 0x20u);
  }
  if ( v4 )
  {
    WriteCfgFile(v4);
    operator delete(v4);
  }
}
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 42EEBC: using guessed type int (__stdcall *lpfnFixExport12)(_DWORD, _DWORD);

//----- (00411DE0) --------------------------------------------------------
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3)
{
  int result; // eax

  switch ( SoccerMode )
  {
    case 1:
      result = a2 >= 512;
      break;
    case 2:
      result = a3 >= 512;
      break;
    case 3:
    case 4:
      if ( a2 >= 512 )
        result = a3 >= 512 ? 3 : 1;
      else
        result = a3 >= 512 ? 2 : 0;
      break;
    case 5:
    case 6:
      if ( a2 >= a3 )
        result = (a2 >= 1024 - a3) + 2;
      else
        result = a2 >= 1024 - a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00411EA0) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *v3; // eax
  char *v4; // eax
  char *v6; // eax
  unsigned int v7; // ecx
  char v8; // al
  CHAR *v9; // edi
  CHAR *v10; // edx
  char *v11; // eax
  unsigned int v12; // kr04_4
  CHAR *v13; // edi
  char *v14; // esi
  char v15; // cl
  char *v16; // edx
  unsigned int v17; // eax
  int v18; // edi
  const char **v19; // esi
  int v20; // [esp+0h] [ebp-70h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-64h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-20h] BYREF
  int *v23; // [esp+60h] [ebp-10h]
  int v24; // [esp+6Ch] [ebp-4h]

  v23 = &v20;
  v3 = GetCommandLineA();
  v4 = fix_dll_loader(v3, "/SPAWN");
  if ( v4 )
    return (int)RunCommandPrompt(v4 + 7);
  GetModuleFileNameA(0, &aServerIni, 0x100u);
  v6 = strrchr(&aServerIni, 92);
  if ( v6 )
  {
    v10 = v6 + 1;
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = v10;
  }
  else
  {
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = &aServerIni;
  }
  qmemcpy(v9, "server.ini", 4 * (v7 >> 2) + (v8 & 3));
  GetModuleFileNameA(0, Filename, 0x100u);
  v11 = strrchr(Filename, 92);
  if ( v11 )
  {
    v16 = v11 + 1;
    v17 = strlen("server.cfg") + 1;
    qmemcpy(v16, "server.cfg", 4 * (v17 >> 2));
    v14 = &aServer_cfg[4 * (v17 >> 2)];
    v13 = &v16[4 * (v17 >> 2)];
    v15 = v17;
  }
  else
  {
    v12 = strlen("server.cfg") + 1;
    qmemcpy(Filename, "server.cfg", 4 * (v12 >> 2));
    v14 = &aServer_cfg[4 * (v12 >> 2)];
    v13 = &Filename[4 * (v12 >> 2)];
    v15 = v12;
  }
  qmemcpy(v13, v14, v15 & 3);
  if ( argc > 1 )
  {
    v18 = argc - 1;
    v19 = argv + 1;
    do
    {
      if ( !_strcmpi(*v19, "/nb") )
        dword_42D860 = 0;
      ++v19;
      --v18;
    }
    while ( v18 );
  }
  ShutdownSpawnCmdLine = 0;
  ((void (*)(void))&locret_408300)();
  bServerIsRunning = 0;
  while ( !bServerIsRunning )
  {
    ServerInitialize();
    v24 = 0;
    ServerMainloop();
    v24 = -1;
    ServerUninitialize();
  }
  ((void (*)(void))&locret_408300)();
  if ( ShutdownSpawnCmdLine )
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    StartupInfo.cb = 68;
    StartupInfo.lpTitle = "Spawned Command";
    CreateProcessA(0, &ShutdownSpawnCmdLine, 0, 0, 0, 0x210u, 0, 0, &StartupInfo, &ProcessInformation);
  }
  return 0;
}
// 408300: invalid function type has been ignored
// 42D860: using guessed type int dword_42D860;
// 438F98: using guessed type int bServerIsRunning;

//----- (004120D0) --------------------------------------------------------
signed int __cdecl ServerInitialize()
{
  int v0; // eax
  int v1; // edi
  int *v2; // esi
  int *v3; // eax
  int v4; // eax
  int v5; // esi
  int v6; // eax
  struct TEXT_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct TEXT_FILE_STRUCT *v9; // eax
  int v10; // eax
  DWORD v11; // esi
  int v12; // ebx
  int *v13; // eax
  int *v14; // eax
  DWORD v15; // esi
  int v16; // eax
  void *v17; // ebx
  int *v18; // eax
  int *v19; // eax
  int v20; // eax
  void *v21; // eax
  void *v22; // eax
  void *v23; // esi
  SOCKET *v24; // eax
  SOCKET *v25; // eax
  SOCKET **v26; // esi
  SOCKET *v27; // eax
  SOCKET *v28; // eax
  struct TEXT_FILE_STRUCT *v29; // eax
  int v30; // eax
  struct TEXT_FILE_STRUCT *v31; // eax
  int v32; // eax
  struct TEXT_FILE_STRUCT *v33; // eax
  int v34; // eax
  struct TEXT_FILE_STRUCT *v35; // eax
  int v36; // eax
  struct TEXT_FILE_STRUCT *v37; // eax
  int v38; // eax
  PINGSOCKET *v39; // eax
  PINGSOCKET *v40; // eax
  int *v41; // eax
  int *v42; // eax
  const wchar_t *v44; // [esp-8h] [ebp-444h]
  int v45; // [esp+0h] [ebp-43Ch]
  int v46; // [esp+14h] [ebp-428h]
  int v47; // [esp+18h] [ebp-424h] BYREF
  int v48[4]; // [esp+1Ch] [ebp-420h] BYREF
  int v49; // [esp+2Ch] [ebp-410h]
  int cp[128]; // [esp+30h] [ebp-40Ch] BYREF
  int v51[122]; // [esp+230h] [ebp-20Ch] BYREF
  int v52; // [esp+418h] [ebp-24h]
  int v53; // [esp+438h] [ebp-4h]

  ShutdownSpawnCmdLine = 0;
  bRecycleServer = 0;
  pFILE_subgame_log = fopen("subgame.log", "wt");
  WriteSubGameLog("SubSpace Game Server v1.34\n", 1, 34, 98);
  if ( pFILE_subgame_log )
  {
    fclose(pFILE_subgame_log);
    pFILE_subgame_log = 0;
  }
  v0 = clock();
  srand(v0);
  memset(dword_4D6C20, 0, 0x3000u);
  memset(&PlayerArray, 0, 0x1004u);
  memset(&byte_4332F8, 0, 0x5B00u);
  dword_4399C4 = 0;
  dword_438F94 = 0;
  nPlayerArray2 = 0;
  dword_4CBB04 = 0;
  dword_4D68C0 = 0;
  dword_4CA228 = 0;
  pFILE_points_log = 0;
  highestNumSharewareAdsCount = 0;
  highestNumRegisteredAdsCount = 0;
  dword_4D9DF4 = 0;
  dword_4D9E08 = 0;
  InitWinsock();
  IsFileLastWrittenTime(&aServerIni, (int)&unk_432EA8);
  LoadServerIni();
  IsFileLastWrittenTime(Filename, (int)&unk_4332F0);
  LoadArenaSettings(&ArenaSettings, (struct_ArenaSettings *)&FileName, Filename);
  v1 = 0;
  if ( nArenas > 0 )
  {
    v2 = ArenaArray;
    do
    {
      if ( !_strcmpi((const char *)(*v2 + 110830), Filename) )
        *(_DWORD *)(*v2 + 65288) = 1;
      ++v1;
      ++v2;
    }
    while ( v1 < nArenas );
  }
  LoadTemplateSSS();
  sub_41AA20();
  LoadAdvertisements();
  v48[0] = 16;
  v48[1] = 0;
  v48[2] = 0;
  v48[3] = 0;
  v46 = 0;
  LOBYTE(v49) = 0;
  memset(dword_4CBB08, 0, 0x9DA8u);
  do
  {
    if ( v46 )
    {
      sprintf(v51, "version%d\\", v46);
    }
    else if ( _access("version0", 0) == -1 )
    {
      LOBYTE(v51[0]) = 0;
    }
    else
    {
      sprintf(v51, "version%d\\", 0);
    }
    v3 = &dword_4CBB08[1009 * v46];
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    strcpy((char *)cp, (const char *)v51);
    strcat((char *)cp, "Update.exe");
    if ( _access((LPCSTR)cp, 0) != -1 )
      dword_4CBB08[1009 * v46] = (int)CompressFile((const char *)cp, &dword_4CBB14[1009 * v46], &v47, v48, 0x11u, 0, 0);
    strcpy((char *)cp, (const char *)v51);
    strcat((char *)cp, "Update1.exe");
    if ( _access((LPCSTR)cp, 0) != -1 )
      dword_4CBB0C[1009 * v46] = (int)CompressFile((const char *)cp, &dword_4CBB18[1009 * v46], &v47, v48, 0x11u, 0, 0);
    strcpy((char *)cp, (const char *)v51);
    strcat((char *)cp, "Update2.exe");
    if ( _access((LPCSTR)cp, 0) != -1 )
      dword_4CBB10[1009 * v46] = (int)CompressFile((const char *)cp, &dword_4CBB1C[1009 * v46], &v47, v48, 0x11u, 0, 0);
    strcpy((char *)cp, (const char *)v51);
    strcat((char *)cp, "subspace.exe");
    if ( _access((LPCSTR)cp, 0) != -1 )
    {
      dword_4CBB20[1009 * v46] = GetSubspaceEXEChecksum((int)cp, (char *)cp);
      if ( v46 )
        v44 = L"S";
      else
        v44 = L"Z";
      _spawnlp(0, cp, cp, v44, 0);
      v4 = fopen("scrty", "rb");
      v5 = v4;
      if ( v4 )
      {
        v6 = _fileno(v4);
        if ( _filelength(v6) != 4000 )
        {
          printf("Security file invalid size\n");
          exit(1);
        }
        fread(&dword_4CBB24[1009 * v46], 1, 4000, v5);
        fclose(v5);
      }
      strcpy((char *)cp, (const char *)v51);
      strcat((char *)cp, "ipblock.txt");
      v7 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      v53 = 0;
      if ( v7 )
        InitializeTextFile(v7, (const char *)cp, 1, 1);
      else
        v8 = 0;
      dword_4CCAC4[1009 * v46] = v8;
      strcpy((char *)cp, (const char *)v51);
      v53 = -1;
      strcat((char *)cp, "ipallow.txt");
      v9 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      v53 = 1;
      if ( v9 )
        InitializeTextFile(v9, (const char *)cp, 1, 1);
      else
        v10 = 0;
      v53 = -1;
      dword_4CCAC8[1009 * v46] = v10;
    }
    ++v46;
  }
  while ( v46 < 10 );
  memory = CompressFile("news.txt", (int *)&sz, &dword_4D6C04, v48, 0x11u, 1, 0);
  SetConsoleTitleA(&lpsz_Billing_ServerName);
  dword_4CA22C = 1;
  memset(dword_4399F0, 0, sizeof(dword_4399F0));
  memset(dword_4B0668, 0, sizeof(dword_4B0668));
  memset(&unk_432EB0, 0, 0x20u);
  dword_432ED8 = 0;
  dword_439E00 = 0;
  dword_4332E8 = 0;
  dword_438F08 = 0;
  dword_4D9CB8 = 0;
  dwServerSocket = 0;
  dword_4D9DC4 = 0;
  FindMeOut1 = 0;
  if ( dword_42D860 )
  {
    v11 = GetTickCount() / 0xA;
    v12 = GetTickCount() / 0xA;
    v47 = v12;
    v13 = (int *)operator new(0x8C5Cu);
    v53 = 2;
    if ( v13 )
      v14 = setup_stuff_and_socket(v13, 0, 0, 16, 0, 0x2000, 0x2000, 1);
    else
      v14 = 0;
    v53 = -1;
    dword_4D9DC4 = (int)v14;
    dword_4AD72C = 0;
    while ( (int)abs32(GetTickCount() / 0xA - v12) < dwBilling_AttemptTime )
    {
      if ( !dword_4AD72C )
      {
        WriteSubGameLog("Attempting to establish link to billing server...\n");
        v15 = GetTickCount() / 0xA;
        v16 = rand();
        dword_4AD72C = (int)SomethingBillerServer(
                              (struct_v9 *)dword_4D9DC4,
                              (struct_v9 *)&lpszIP_Billing,
                              (const char *)dwBilling_Port,
                              ((int)(v15 + v16) >> 31) - (((int)(v15 + v16) >> 31) ^ (v15 + v16)),
                              0,
                              v45);
        v11 = GetTickCount() / 0xA;
      }
      PlayerDoNetworkOps((struct_v9 *)dword_4D9DC4);
      if ( sub_41C510(dword_4AD72C) == 2 )
        break;
      if ( (int)abs32(GetTickCount() / 0xA - v11) > 2000 )
      {
        sub_41C360(dword_4AD72C);
        v17 = (void *)dword_4D9DC4;
        dword_4AD72C = 0;
        if ( dword_4D9DC4 )
        {
          CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
          operator delete(v17);
        }
        v18 = (int *)operator new(0x8C5Cu);
        v53 = 3;
        if ( v18 )
          v19 = setup_stuff_and_socket(v18, 0, 0, 16, 0, 0x2000, 0x2000, 1);
        else
          v19 = 0;
        v12 = v47;
        v53 = -1;
        dword_4D9DC4 = (int)v19;
      }
      if ( console_input_wrapper() )
      {
        v20 = getch();
        if ( (!v20 || v20 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          exit(1);
        }
      }
    }
    if ( sub_41C510(dword_4AD72C) == 2 )
    {
      WriteSubGameLog("Billing server connected.\n");
      v21 = operator new(0x20u);
      v53 = 4;
      if ( v21 )
      {
        v22 = (void *)sub_4059D0(
                        (int)v21,
                        lpfnFixExport6,
                        &lpsz_Billing_ServerName,
                        dwBilling_ServerID,
                        dwBilling_GroupID,
                        dwBilling_ScoreID,
                        (int)lpsz_Billing_Password,
                        dword_4D9DC4,
                        dword_4AD72C);
        v52 = -1;
        FindMeOut1 = v22;
      }
      else
      {
        v53 = -1;
        FindMeOut1 = 0;
      }
    }
    else
    {
      WriteSubGameLog("ERROR: Could not connect to billing server.\n");
      v23 = (void *)dword_4D9DC4;
      FindMeOut1 = 0;
      if ( dword_4D9DC4 )
      {
        CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
        operator delete(v23);
      }
      dword_4D9DC4 = 0;
      WriteSubGameLog("Starting server in stand-alone mode.\n");
      v24 = (SOCKET *)operator new(0xCu);
      v53 = 5;
      if ( v24 )
        v25 = ConnectSocket(v24, &lpszIP_Billing, dwBilling_Port + 1, 0);
      else
        v25 = 0;
      v53 = -1;
      dwServerSocket = v25;
    }
  }
  if ( strlen(lpszDirectory_IP) > 4 )
  {
    strcpy((char *)v51, lpszDirectory_IP);
    v26 = (SOCKET **)&unk_432EB0;
    do
    {
      if ( !GetSplitNextDirectoryIP((char *)cp, (char *)v51) )
        break;
      v27 = (SOCKET *)operator new(0xCu);
      v53 = 6;
      v28 = v27 ? ConnectSocket(v27, (char *)cp, dwDirectory_Port, 0) : 0;
      *v26++ = v28;
      v53 = -1;
    }
    while ( (int)v26 < (int)&dwMisc_DisableSharewareShips );
  }
  v29 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v53 = 7;
  if ( v29 )
    InitializeTextFile(v29, "obscene.txt", 1, 1);
  else
    v30 = 0;
  v53 = -1;
  dword_439DFC = v30;
  v31 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v53 = 8;
  if ( v31 )
    InitializeTextFile(v31, "idblock.txt", 0, 1);
  else
    v32 = 0;
  v53 = -1;
  dword_4D9DC0 = v32;
  v33 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v53 = 9;
  if ( v33 )
    InitializeTextFile(v33, "permit.txt", 0, 1);
  else
    v34 = 0;
  v53 = -1;
  dword_439E58 = v34;
  v35 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v53 = 10;
  if ( v35 )
    InitializeTextFile(v35, "moderate.txt", 0, 1);
  else
    v36 = 0;
  v53 = -1;
  dword_439E14 = v36;
  v37 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v53 = 11;
  if ( v37 )
    InitializeTextFile(v37, "reserved.txt", 0, 1);
  else
    v38 = 0;
  v53 = -1;
  dword_4D68CC = v38;
  wServerPort = GetPrivateProfileIntWrapper("Misc", "Port", 0x17Eu, &aServerIni);
  v39 = (PINGSOCKET *)operator new(8u);
  v53 = 12;
  if ( v39 )
    v40 = ListenOnPort(v39, wServerPort + 1, &locret_408300);
  else
    v40 = 0;
  v53 = -1;
  lpPingSocket = (WORLD *)v40;
  nArenas = 0;
  v41 = (int *)operator new(0x8C5Cu);
  v53 = 13;
  if ( v41 )
    v42 = setup_stuff_and_socket(
            v41,
            (int)NewConnectionRequest,
            (int)sub_412EF0,
            1024,
            wServerPort,
            dwComms_OutgoingBufferSize,
            dwComms_IncomingBufferSize,
            *(int *)&dwComms_PacketHistoryMax);
  else
    v42 = 0;
  v53 = -1;
  lpFileName = (LPCSTR)v42;
  sub_41B4E0((int)v42, dwComms_EncryptMode);
  return sub_41C000((void *)lpFileName, (signed int)dwComms_TransportBufferSize);
}
// 412638: variable 'v8' is possibly undefined
// 4126D3: variable 'v10' is possibly undefined
// 412872: variable 'v45' is possibly undefined
// 412BB8: variable 'v30' is possibly undefined
// 412BF7: variable 'v32' is possibly undefined
// 412C36: variable 'v34' is possibly undefined
// 412C75: variable 'v36' is possibly undefined
// 412CC3: variable 'v38' is possibly undefined
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 41F5A0: using guessed type _DWORD _spawnlp(_DWORD, _DWORD, ...);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);
// 42D860: using guessed type int dword_42D860;
// 42DA24: using guessed type wchar_t aS_0[2];
// 42DA28: using guessed type wchar_t aZ[2];
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F0C: using guessed type int dwBilling_AttemptTime;
// 438F94: using guessed type int dword_438F94;
// 4399C4: using guessed type int dword_4399C4;
// 439DF0: using guessed type int dwBilling_Port;
// 439E00: using guessed type int dword_439E00;
// 439E10: using guessed type int dwComms_EncryptMode;
// 4CA228: using guessed type int dword_4CA228;
// 4CA22C: using guessed type int dword_4CA22C;
// 4CBB04: using guessed type int dword_4CBB04;
// 4CBB08: using guessed type int dword_4CBB08[];
// 4CBB0C: using guessed type int dword_4CBB0C[];
// 4CBB10: using guessed type int dword_4CBB10[];
// 4CBB14: using guessed type int dword_4CBB14[];
// 4CBB18: using guessed type int dword_4CBB18[];
// 4CBB1C: using guessed type int dword_4CBB1C[];
// 4CBB20: using guessed type int dword_4CBB20[];
// 4CBB24: using guessed type int dword_4CBB24[];
// 4CCAC4: using guessed type int dword_4CCAC4[];
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68C0: using guessed type int dword_4D68C0;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C04: using guessed type int dword_4D6C04;
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int nPlayerArray2;
// 4D9DEC: using guessed type int highestNumSharewareAdsCount;
// 4D9DF0: using guessed type int highestNumRegisteredAdsCount;
// 4D9DF4: using guessed type int dword_4D9DF4;
// 4D9DF8: using guessed type int pFILE_points_log;
// 4D9DFC: using guessed type int pFILE_subgame_log;
// 4D9E08: using guessed type int dword_4D9E08;

//----- (00412DC0) --------------------------------------------------------
void __cdecl NewConnectionRequest(struct in_addr in, __int16 port)
{
  int v2; // ebp
  int v3; // edi
  PLAYER **v4; // esi
  char *v5; // ebx
  PLAYER *v6; // eax
  int v7; // ecx
  PLAYER *v8; // [esp+10h] [ebp-10h]

  v2 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v3 = 0;
    v4 = (PLAYER **)PlayerArray2;
    v5 = (char *)&unk_4CA234;
    do
    {
      if ( (*v4)->in_addr.S_un.S_addr == in && (*v4)->port == port )
      {
        printf("Connection broken because same ip/port requested another connection\n");
        sub_41D780((*v4)->lpNetworkData);
        v8 = *v4;
        if ( *v4 )
        {
          DisconnectPlayer(*v4);
          operator delete(v8);
        }
        --nPlayerArray2;
        memcpy(v4, v5, 4 * (v3 + nPlayerArray2));
        --v2;
        v3 -= 0x3FFFFFFF;
        v5 -= 4;
        --v4;
      }
      ++v2;
      v3 += 0x3FFFFFFF;
      v5 += 4;
      ++v4;
    }
    while ( v2 < nPlayerArray2 );
  }
  v6 = (PLAYER *)operator new(0x10000u);
  if ( v6 )
  {
    init_new_player(v6);
  }
  else
  {
    v7 = nPlayerArray2;
    PlayerArray2[nPlayerArray2] = 0;
    nPlayerArray2 = v7 + 1;
  }
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (00412EF0) --------------------------------------------------------
int __cdecl sub_412EF0(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  if ( *(&PlayerArray + *(_DWORD *)(a3 + 46)) )
    result = sub_415800(a1, a2);
  return result;
}

//----- (00412F20) --------------------------------------------------------
void __cdecl ServerMainloop()
{
  int (*v0)(void); // ebp
  int i; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // edi
  struct PLAYER **v5; // esi
  unsigned int v6; // esi
  int v7; // edi
  int *v8; // esi
  int v9; // eax
  int v10; // edi
  char *v11; // esi
  unsigned int v12; // kr08_4
  int v13; // edi
  int *v14; // esi
  int v15; // edi
  int *v16; // esi
  DWORD (*v17)(void); // ebp
  int v18; // ebx
  int v19; // esi
  int *v20; // ebp
  char *v21; // edi
  __int64 v22; // rax
  DWORD v23; // eax
  void **v24; // esi
  int v25; // edi
  int *v26; // esi
  struct TEXT_FILE_STRUCT **v27; // esi
  struct TEXT_FILE_STRUCT *v28; // ecx
  int v29; // edi
  struct PLAYER **v30; // esi
  DWORD v31; // eax
  int v32; // esi
  PLAYER *p; // [esp+10h] [ebp-1F4h]
  PLAYER *pa; // [esp+10h] [ebp-1F4h]
  DWORD pb; // [esp+10h] [ebp-1F4h]
  DWORD v36; // [esp+14h] [ebp-1F0h]
  unsigned int v37; // [esp+18h] [ebp-1ECh]
  DWORD v38; // [esp+1Ch] [ebp-1E8h]
  unsigned int v39; // [esp+20h] [ebp-1E4h]
  int v40[4]; // [esp+24h] [ebp-1E0h] BYREF
  char v41; // [esp+34h] [ebp-1D0h]
  int v42; // [esp+38h] [ebp-1CCh] BYREF
  int v43; // [esp+3Ch] [ebp-1C8h] BYREF
  __int16 v44[226]; // [esp+40h] [ebp-1C4h] BYREF

  GetTickCount();
  GetTickCount();
  v36 = GetTickCount() / 0xA;
  GetTickCount();
  GetTickCount();
  v38 = GetTickCount() / 0xA;
  GetTickCount();
  v37 = 0;
  dword_4D6C10 = 0;
  if ( !bServerIsRunning )
  {
    v0 = (int (*)(void))GetTickCount;
    for ( i = 0; ; i = 0 )
    {
      if ( bRecycleServer )
        return;
      v39 = v0() / 0xAu;
      if ( console_input_wrapper() )
      {
        v2 = getch();
        if ( (!v2 || v2 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          bServerIsRunning = 1;
          return;
        }
      }
      if ( FindMeOut1 )
      {
        if ( IsBillingServerDisconnected(FindMeOut1) )
        {
          WriteSubGameLog("Connection to billing server broken\n");
          bRecycleServer = 1;
        }
        v3 = sub_406130((int)FindMeOut1);
        if ( (int)(v0() / 0xAu - v3) > dwBilling_ReconnectTime )
        {
          WriteSubGameLog("Connection to billing server timed out\n");
          bRecycleServer = 1;
        }
        if ( bRecycleServer )
        {
          v4 = 0;
          if ( nPlayerArray2 > 0 )
          {
            v5 = (struct PLAYER **)PlayerArray2;
            do
            {
              if ( (*v5)->lpCurrentArena )
                SendMessage(*v5, "NOTICE: Server recycling, please log back in shortly.", 1);
              ++v4;
              ++v5;
            }
            while ( v4 < nPlayerArray2 );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)lpFileName);
        }
      }
      ProcessZonePings((int)lpPingSocket, dwZonePopulation);
      v6 = v0() / 0xAu;
      if ( PlayerDoNetworkOps((struct_v9 *)lpFileName) )
      {
        while ( (int)(v0() / 0xAu - v6) < dwCPU_ProcessMaxTime && PlayerDoNetworkOps((struct_v9 *)lpFileName) )
          ;
      }
      v7 = 0;
      if ( nPlayerArray2 > 0 )
      {
        v8 = PlayerArray2;
        do
        {
          if ( *(_DWORD *)(*v8 + 253) )
            SendWeaponPacket(*v8);
          ++v7;
          ++v8;
        }
        while ( v7 < nPlayerArray2 );
      }
      v9 = dword_4CBB04;
      dword_439E00 += dword_4D68C0;
      v10 = 0;
      dword_438F08 += dword_4CA228;
      dword_4D68C0 = 0;
      dword_4CA228 = 0;
      dword_432ED8 += dword_4CBB04;
      if ( dword_4CBB04 > 0 )
      {
        v11 = byte_4B0C01;
        do
        {
          if ( *(&PlayerArray + *(_DWORD *)(v11 - 25)) )
          {
            j_lpfnFixExport20(v11 - 21, *v11, *v11);
            v9 = dword_4CBB04;
          }
          ++v10;
          v11 += 26;
        }
        while ( v10 < v9 );
      }
      dword_4CBB04 = 0;
      if ( (int)abs32(v0() / 0xAu - v36) > 30 )
      {
        v12 = v0();
        dword_4D9DE8 = 0;
        v36 = v12 / 0xA;
        if ( nPlayerArray2 > 0 )
        {
          v13 = 0;
          v14 = PlayerArray2;
          v0 = (int (*)(void))&unk_4CA234;
          do
          {
            if ( CheckUserStopPlaying(*v14) )
            {
              p = (PLAYER *)*v14;
              --nPlayerArray2;
              memcpy(v14, v0, 4 * (v13 + nPlayerArray2));
              if ( p )
              {
                DisconnectPlayer(p);
                operator delete(p);
              }
              --i;
              v13 -= 0x3FFFFFFF;
              v0 = (int (*)(void))((char *)v0 - 4);
              --v14;
            }
            ++i;
            v13 += 0x3FFFFFFF;
            v0 = (int (*)(void))((char *)v0 + 4);
            ++v14;
          }
          while ( i < nPlayerArray2 );
          i = 0;
        }
        if ( nArenas > 0 )
        {
          v15 = 0;
          v16 = ArenaArray;
          sub_415820();
          do
          {
            if ( sub_402560(*v16) )
            {
              if ( *(_BYTE *)(*v16 + offsetof(ARENA, name)) )
                WriteSubGameLog("Private arena dropped: %s\n", (const char *)(*v16 + offsetof(ARENA, name)));
              else
                WriteSubGameLog("Arena dropped\n");
              pa = (PLAYER *)*v16;
              if ( *v16 )
              {
                ArenaShutdownArena(*v16);
                operator delete(pa);
              }
              --nArenas;
              memcpy(v16, v0, 4 * (v15 + nArenas));
              --i;
              v15 -= 0x3FFFFFFF;
              v0 = (int (*)(void))((char *)v0 - 4);
              --v16;
            }
            ++i;
            v15 += 0x3FFFFFFF;
            v0 = (int (*)(void))((char *)v0 + 4);
            ++v16;
          }
          while ( i < nArenas );
        }
      }
      lpfnFixExport18();
      ++dword_4332E8;
      if ( (int)(GetTickCount() / 0xA - dword_4D9DE4) > 6000 )
      {
        v17 = GetTickCount;
        memset(dword_4399F0, 0, sizeof(dword_4399F0));
        v18 = 0;
        memset(dword_4B0668, 0, sizeof(dword_4B0668));
        dword_432ED8 = 0;
        dword_439E00 = 0;
        dword_4332E8 = 0;
        dword_438F08 = 0;
        dword_4D9CB8 = 0;
        dword_4D9DE4 = GetTickCount() / 0xA;
        sub_41BFA0((int)lpFileName);
        if ( dword_4399C4 <= 0 )
          goto LABEL_60;
        v19 = 0;
        v20 = &dword_4AD738;
        v21 = (char *)&unk_4AD744;
        do
        {
          v22 = (int)(GetTickCount() / 0xA - dword_4AD73C[v19]);
          if ( (int)((HIDWORD(v22) ^ v22) - HIDWORD(v22)) > dword_4AD740[v19] )
          {
            --dword_4399C4;
            memcpy(v20, v21, 12 * dword_4399C4 - v19 * 4);
            --v18;
            v19 -= 3;
            v21 -= 12;
            v20 -= 3;
          }
          ++v18;
          v19 += 3;
          v21 += 12;
          v20 += 3;
        }
        while ( v18 < dword_4399C4 );
      }
      v17 = GetTickCount;
LABEL_60:
      if ( (int)abs32(v17() / 0xA - v37) > 6000 )
      {
        v23 = v17();
        memset(v44, 0, 0x1C0u);
        v37 = v23 / 0xA;
        v44[224] = 0;
        v44[1] = dwZonePopulation;
        v44[2] = FindMeOut1 != 0;
        *(_DWORD *)&v44[3] = 134;
        v44[0] = wServerPort;
        strncpy((char *)&v44[5], &lpsz_Billing_ServerName, 0x20u);
        HIBYTE(v44[20]) = 0;
        strncpy((char *)&v44[21], lpszDirectory_NamePassword, 0x10u);
        HIBYTE(v44[28]) = 0;
        strncpy((char *)&v44[45], lpsz_Directory_Description, 0xFAu);
        HIBYTE(v44[169]) = 0;
        v24 = (void **)&unk_432EB0;
        do
        {
          if ( *v24 )
          {
            SendDirectoryServerZoneUpdatePacket(*v24, v44, strlen((const char *)&v44[45]) + 91);
            GetSocketRecvLag((SOCKET)*v24, &v43);
          }
          ++v24;
        }
        while ( (int)v24 < (int)&dwMisc_DisableSharewareShips );
      }
      if ( (int)abs32(v17() / 0xA - v38) > 18000 || dword_4D6C10 )
      {
        pb = v17() / 0xA;
        if ( dwServerSocket && !FindMeOut1 )
          SendDirectoryServerZoneUpdatePacket(dwServerSocket, 0, 0);
        dword_4CA22C = 1;
        dword_4D6C10 = 0;
        v38 = v17() / 0xA;
        if ( IsFileLastWrittenTime(&aServerIni, (int)&unk_432EA8) )
        {
          printf("INI settings different, re-reading\n");
          LoadServerIni();
          sub_41B4E0((int)lpFileName, dwComms_EncryptMode);
          sub_41C000((void *)lpFileName, (signed int)dwComms_TransportBufferSize);
        }
        if ( IsFileLastWrittenTime(Filename, (int)&unk_4332F0) )
        {
          printf("Master CFG settings different, re-reading\n");
          LoadArenaSettings(&ArenaSettings, (struct_ArenaSettings *)&FileName, Filename);
          v25 = 0;
          if ( nArenas > 0 )
          {
            v26 = ArenaArray;
            do
            {
              if ( !_strcmpi((const char *)(*v26 + 110830), Filename) )
                *(_DWORD *)(*v26 + 65288) = 1;
              ++v25;
              ++v26;
            }
            while ( v25 < nArenas );
          }
        }
        v27 = (struct TEXT_FILE_STRUCT **)dword_4CCAC8;
        do
        {
          v28 = *(v27 - 1);
          if ( v28 )
            LoadTextFile(v28, 0);
          if ( *v27 )
            LoadTextFile(*v27, 0);
          v27 += 1009;
        }
        while ( (int)v27 < (int)&unk_4D6870 );
        LoadTextFile((struct TEXT_FILE_STRUCT *)dword_4D9DC0, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)dword_439DFC, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)dword_439E58, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)dword_439E14, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)dword_4D68CC, 0);
        v40[0] = 16;
        v40[1] = 0;
        v40[2] = 0;
        v40[3] = 0;
        v41 = 0;
        if ( IsFileLastWrittenTime("news.txt", (int)&unk_4D6C14) )
        {
          if ( memory )
            efree(memory);
          memory = CompressFile("news.txt", (int *)&sz, &dword_4D6C04, v40, 0x11u, 1, 0);
        }
        if ( dwServerSocket && !FindMeOut1 && GetSocketRecvLag((SOCKET)dwServerSocket, &v42) >= 0 )
        {
          v29 = 0;
          if ( nPlayerArray2 > 0 )
          {
            v30 = (struct PLAYER **)PlayerArray2;
            do
            {
              if ( (*v30)->lpCurrentArena )
                SendMessage(*v30, "NOTICE: Server recycling in order to restore scores, please log back in.", 1);
              ++v29;
              ++v30;
            }
            while ( v29 < nPlayerArray2 );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)lpFileName);
          bRecycleServer = 1;
        }
        v31 = v17();
        printf("Re-read Settings: %d ms\n", 10 * (v31 / 0xA - pb));
        fflush(&unk_42F788);
      }
      lpfnFixExport19(lpFileName);
      v32 = v17() / 0xA - v39;
      if ( v32 <= 2 || dwCPU_SleepPerIteration )
        Sleep(dwCPU_SleepTime);
      if ( v32 > dwCPU_SlowIterationWarningLevel )
        WriteSubGameLog("Slow iteration warning: %d ms\n", 10 * v32);
      if ( bServerIsRunning )
        return;
      v0 = (int (*)(void))GetTickCount;
    }
  }
}
// 40DF00: using guessed type int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD);
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41F620: using guessed type _DWORD __cdecl fflush(_DWORD);
// 42EED4: using guessed type int (*lpfnFixExport18)(void);
// 42EED8: using guessed type int (__thiscall *lpfnFixExport19)(_DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F98: using guessed type int bServerIsRunning;
// 4399C4: using guessed type int dword_4399C4;
// 439E00: using guessed type int dword_439E00;
// 439E04: using guessed type int dwCPU_SlowIterationWarningLevel;
// 439E10: using guessed type int dwComms_EncryptMode;
// 439E68: using guessed type int dwBilling_ReconnectTime;
// 4AD738: using guessed type int dword_4AD738;
// 4AD73C: using guessed type int dword_4AD73C[];
// 4AD740: using guessed type int dword_4AD740[];
// 4CA228: using guessed type int dword_4CA228;
// 4CA22C: using guessed type int dword_4CA22C;
// 4CA230: using guessed type int PlayerArray2[];
// 4CB234: using guessed type int dwCPU_SleepPerIteration;
// 4CBB04: using guessed type int dword_4CBB04;
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68C0: using guessed type int dword_4D68C0;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6BF4: using guessed type int dwCPU_ProcessMaxTime;
// 4D6C04: using guessed type int dword_4D6C04;
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int nPlayerArray2;
// 4D9DE4: using guessed type int dword_4D9DE4;
// 4D9DE8: using guessed type int dword_4D9DE8;

//----- (00413860) --------------------------------------------------------
int __cdecl IncreaseRadarValueShowHomeOverFourThousand()
{
  int result; // eax
  int v1; // edi
  char *v2; // esi

  result = dword_4CBB04;
  v1 = 0;
  dword_432ED8 += dword_4CBB04;
  if ( dword_4CBB04 > 0 )
  {
    v2 = byte_4B0C01;
    do
    {
      if ( *(&PlayerArray + *(_DWORD *)(v2 - 25)) )
      {
        j_lpfnFixExport20(v2 - 21, *v2, *v2);
        result = dword_4CBB04;
      }
      ++v1;
      v2 += 26;
    }
    while ( v1 < result );
  }
  dword_4CBB04 = 0;
  return result;
}
// 40DF00: using guessed type int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD);
// 432ED8: using guessed type int dword_432ED8;
// 4CBB04: using guessed type int dword_4CBB04;

//----- (004138C0) --------------------------------------------------------
void __cdecl ServerUninitialize()
{
  int v0; // eax
  _BOOL1 v1; // cc
  PLAYER **v2; // edi
  int v3; // ebx
  PLAYER *v4; // esi
  int v5; // ebx
  int *v6; // edi
  void *v7; // esi
  CHAR *v8; // esi
  WORLD *v9; // esi
  void *v10; // esi
  struct BILLING_SERVER_STRUCT *v11; // esi
  void *v12; // esi
  SOCKET **v13; // edi
  SOCKET *v14; // esi
  void *v15; // esi
  void *v16; // esi
  void *v17; // esi
  void *v18; // esi
  void *v19; // esi
  TEXT_FILE_STRUCT **v20; // ebx
  void *v21; // esi
  TEXT_FILE_STRUCT *v22; // esi
  LPVOID *v23; // esi
  int v24; // edi
  void *v25; // esi

  v0 = nPlayerArray2;
  v1 = nPlayerArray2 <= 0;
  nPlayerArray2 = 0;
  if ( !v1 )
  {
    v2 = (PLAYER **)PlayerArray2;
    v3 = v0;
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        DisconnectPlayer(*v2);
        operator delete(v4);
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v5 = 0;
  if ( nArenas > 0 )
  {
    v6 = ArenaArray;
    do
    {
      v7 = (void *)*v6;
      if ( *v6 )
      {
        ArenaShutdownArena(*v6);
        operator delete(v7);
      }
      ++v5;
      ++v6;
    }
    while ( v5 < nArenas );
  }
  nArenas = 0;
  if ( pFILE_points_log )
  {
    fclose(pFILE_points_log);
    pFILE_points_log = 0;
  }
  v8 = (CHAR *)lpFileName;
  if ( lpFileName )
  {
    CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)lpFileName);
    operator delete(v8);
  }
  v9 = lpPingSocket;
  if ( lpPingSocket )
  {
    sub_408740((SOCKET *)lpPingSocket);
    operator delete(v9);
  }
  v10 = dwServerSocket;
  if ( dwServerSocket )
  {
    sub_408740((SOCKET *)dwServerSocket);
    operator delete(v10);
  }
  v11 = FindMeOut1;
  if ( FindMeOut1 )
  {
    CleanUpBilling(FindMeOut1);
    operator delete(v11);
  }
  v12 = (void *)dword_4D9DC4;
  if ( dword_4D9DC4 )
  {
    CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
    operator delete(v12);
  }
  v13 = (SOCKET **)&unk_432EB0;
  do
  {
    v14 = *v13;
    if ( *v13 )
    {
      sub_408740(*v13);
      operator delete(v14);
    }
    ++v13;
  }
  while ( (int)v13 < (int)&dwMisc_DisableSharewareShips );
  v15 = (void *)dword_439DFC;
  if ( dword_439DFC )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_439DFC);
    operator delete(v15);
  }
  v16 = (void *)dword_439E58;
  if ( dword_439E58 )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_439E58);
    operator delete(v16);
  }
  v17 = (void *)dword_439E14;
  if ( dword_439E14 )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_439E14);
    operator delete(v17);
  }
  v18 = (void *)dword_4D68CC;
  if ( dword_4D68CC )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_4D68CC);
    operator delete(v18);
  }
  v19 = (void *)dword_4D9DC0;
  if ( dword_4D9DC0 )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_4D9DC0);
    operator delete(v19);
  }
  if ( memory )
  {
    efree(memory);
    memory = 0;
  }
  v20 = (TEXT_FILE_STRUCT **)dword_4CCAC8;
  do
  {
    v21 = *(v20 - 1);
    if ( v21 )
    {
      CleanTextFileMemory(*(v20 - 1));
      operator delete(v21);
    }
    v22 = *v20;
    if ( *v20 )
    {
      CleanTextFileMemory(*v20);
      operator delete(v22);
    }
    v23 = (LPVOID *)(v20 - 1008);
    v24 = 3;
    do
    {
      if ( *v23 )
      {
        efree(*v23);
        *v23 = 0;
      }
      ++v23;
      --v24;
    }
    while ( v24 );
    v20 += 1009;
  }
  while ( (int)v20 < (int)&unk_4D6870 );
  v25 = dword_439E60;
  if ( dword_439E60 )
  {
    sub_406B30((int)dword_439E60);
    operator delete(v25);
  }
  efree((LPVOID)dword_438DFC);
  efree((LPVOID)big_global_buffer);
  CleanUpMemory();
  j_WSACleanup();
  if ( pFILE_subgame_log )
    fclose(pFILE_subgame_log);
  pFILE_subgame_log = 0;
}
// 41B220: using guessed type int j_WSACleanup(void);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4CA230: using guessed type int PlayerArray2[];
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 4D9DF8: using guessed type int pFILE_points_log;
// 4D9DFC: using guessed type int pFILE_subgame_log;

//----- (00413B50) --------------------------------------------------------
void __usercall sub_413B50(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  int v5; // eax
  struct PLAYER **v6; // esi
  int v7; // edx
  struct PLAYER **j; // eax
  int v9; // ecx
  int *i; // eax
  int v11; // esi
  int v12; // ecx
  int *v13; // eax
  int v14; // ebp
  char v15; // al
  __int16 v16; // ax
  _DWORD *v17; // ebx
  PLAYER **v18; // esi
  int v19; // eax
  points_data *v20; // eax
  int v21; // ecx
  PLAYER *v22; // edi
  _BOOL1 v23; // cc
  int v24; // [esp+14h] [ebp-834h]
  int v25; // [esp+18h] [ebp-830h]
  char *v26; // [esp+1Ch] [ebp-82Ch]
  char v27[2048]; // [esp+48h] [ebp-800h] BYREF

  if ( (unsigned int)(*(char *)a4 - 1) <= 9 )
  {
    switch ( *(_BYTE *)a4 )
    {
      case 1:
        v12 = 0;
        if ( nPlayerArray2 > 0 )
        {
          v13 = PlayerArray2;
          do
          {
            v14 = *v13;
            if ( *(_DWORD *)(*v13 + offsetof(PLAYER, connection_id)) == *(_DWORD *)(a4 + 2) )
            {
              v15 = *(_BYTE *)(a4 + 1);
              switch ( v15 )
              {
                case 0:
                case 6:
                  v17 = (_DWORD *)(v14 + 547);
                  qmemcpy((void *)(v14 + 375), (const void *)(a4 + 6), 0xACu);
                  if ( a5 == 192 )
                  {
                    *v17 = *(_DWORD *)(a4 + 178);
                    *(_DWORD *)(v14 + 551) = *(_DWORD *)(a4 + 182);
                    *(_DWORD *)(v14 + 555) = *(_DWORD *)(a4 + 186);
                    *(_WORD *)(v14 + 559) = *(_WORD *)(a4 + 190);
                  }
                  else
                  {
                    *v17 = 0;
                    *(_DWORD *)(v14 + 551) = 0;
                    *(_DWORD *)(v14 + 555) = 0;
                    *(_WORD *)(v14 + 559) = 0;
                  }
                  if ( dwMisc_DisableSharewareScores && *(_DWORD *)(v14 + 72) )
                  {
                    *v17 = 0;
                    *(_DWORD *)(v14 + 551) = 0;
                    *(_DWORD *)(v14 + 555) = 0;
                    *(_WORD *)(v14 + 559) = 0;
                  }
                  *(_DWORD *)(v14 + 561) = *v17;
                  *(_DWORD *)(v14 + 565) = *(_DWORD *)(v14 + 551);
                  *(_DWORD *)(v14 + 569) = *(_DWORD *)(v14 + 555);
                  *(_WORD *)(v14 + 573) = *(_WORD *)(v14 + 559);
                  v25 = 0;
                  if ( nPlayerArray2 > 0 )
                  {
                    v24 = 0;
                    v18 = (PLAYER **)PlayerArray2;
                    v26 = (char *)&unk_4CA234;
                    do
                    {
                      if ( *v18 != (PLAYER *)v14 && !_strcmpi((*v18)->player_name, (const char *)(v14 + 375)) )
                      {
                        WriteSubGameLog(
                          "Player %s already on, kicking them off (lost connection probably)\n",
                          (const char *)(v14 + 375));
                        v19 = *(_DWORD *)(v14 + 28);
                        if ( v19 )
                        {
                          if ( !*(_DWORD *)(v19 + 109754) )
                          {
                            v20 = &(*v18)->score;
                            if ( (unsigned __int16)v20->wins
                               + (*v18)->score.points
                               + (*v18)->score.flag_points
                               + (unsigned __int16)(*v18)->score.losses > *(unsigned __int16 *)v17
                                                                        + *(unsigned __int16 *)(v14 + 549)
                                                                        + *(_DWORD *)(v14 + 557)
                                                                        + *(_DWORD *)(v14 + 553) )
                            {
                              *v17 = *(_DWORD *)&v20->wins;
                              *(_DWORD *)(v14 + 551) = *(_DWORD *)&v20->flags;
                              *(_DWORD *)(v14 + 555) = *(int *)((char *)&v20->points + 2);
                              *(_WORD *)(v14 + 559) = HIWORD(v20->flag_points);
                              v21 = (int)(*v18)->field_231;
                              *(_DWORD *)(v14 + 561) = *(_DWORD *)v21;
                              *(_DWORD *)(v14 + 565) = *(_DWORD *)(v21 + 4);
                              *(_DWORD *)(v14 + 569) = *(_DWORD *)(v21 + 8);
                              *(_WORD *)(v14 + 573) = *(_WORD *)(v21 + 12);
                            }
                          }
                        }
                        v22 = *v18;
                        if ( *v18 )
                        {
                          DisconnectPlayer(*v18);
                          operator delete(v22);
                        }
                        --nPlayerArray2;
                        memcpy(v18, v26, 4 * (v24 + nPlayerArray2));
                        --v25;
                        v24 -= 0x3FFFFFFF;
                        v26 -= 4;
                        --v18;
                      }
                      v24 += 0x3FFFFFFF;
                      ++v18;
                      v23 = ++v25 < nPlayerArray2;
                      v26 += 4;
                    }
                    while ( v23 );
                  }
                  if ( dwPermission_PermissionMode == 2
                    && !*(_DWORD *)(v14 + 639)
                    && sub_407420(dword_439E58, v14 + 675) < 0 )
                  {
                    goto LABEL_61;
                  }
                  break;
                case 2:
                  *(_DWORD *)(v14 + 789) = 18;
                  *(_DWORD *)(v14 + 172) = GetTickCount() / 0xA;
                  break;
                case 3:
                  WriteSubGameLog("Player kicked off for IP block: %s\n", (const char *)(v14 + 675));
                  *(_DWORD *)(v14 + 789) = 11;
                  *(_DWORD *)(v14 + 56) = 1;
                  break;
                case 8:
                  *(_DWORD *)(v14 + 547) = 0;
                  *(_DWORD *)(v14 + 551) = 0;
                  *(_DWORD *)(v14 + 555) = 0;
                  *(_WORD *)(v14 + 559) = 0;
                  *(_DWORD *)(v14 + 561) = *(_DWORD *)(v14 + 547);
                  *(_DWORD *)(v14 + 565) = *(_DWORD *)(v14 + 551);
                  v16 = *(_WORD *)(v14 + 559);
                  *(_DWORD *)(v14 + 569) = *(_DWORD *)(v14 + 555);
                  *(_WORD *)(v14 + 573) = v16;
                  qmemcpy((void *)(v14 + 375), (const void *)(a4 + 6), 0xACu);
                  strcpy((char *)(v14 + 375), (const char *)(v14 + 675));
                  *(_DWORD *)(v14 + 16) = -1;
                  if ( dwPermission_PermissionMode == 2 && !*(_DWORD *)(v14 + 639) )
LABEL_61:
                    *(_DWORD *)(v14 + 747) = 1;
                  break;
                default:
                  break;
              }
              JUMPOUT(0x419A51);
            }
            ++v12;
            ++v13;
          }
          while ( v12 < nPlayerArray2 );
        }
        break;
      case 2:
        WriteSubGameLog("Shutdown packet received, shutting down server...\n");
        bServerIsRunning = 1;
        break;
      case 3:
        if ( *(_BYTE *)(a4 + 5) == 1 )
        {
          if ( sub_407420(dword_439E58, a4 + 6) < 0 )
          {
            AddLineTextFile((struct TEXT_FILE_STRUCT *)dword_439E58, (char *)(a4 + 6));
            WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_439E58);
          }
        }
        else if ( *(_BYTE *)(a4 + 5) == 2 )
        {
          if ( *(_BYTE *)(a4 + 7) == 58 )
            process_text_packet(a4, a1, a2, a3, 0, 7u, 0, (char *)(a4 + 7), *(char *)(a4 + 6));
          else
            process_text_packet(a4, a1, a2, a3, 0, 0, 0, (char *)(a4 + 7), *(char *)(a4 + 6));
        }
        break;
      case 4:
        bRecycleServer = 1;
        break;
      case 8:
        v9 = 0;
        if ( nPlayerArray2 > 0 )
        {
          for ( i = PlayerArray2; ; ++i )
          {
            v11 = *i;
            if ( *(_DWORD *)(*i + 16) == *(_DWORD *)(a4 + 1) )
              break;
            if ( ++v9 >= nPlayerArray2 )
              return;
          }
          WriteSubGameLog("Player kicked off by billing server, reason #%d\n", *(_DWORD *)(a4 + 5));
          *(_DWORD *)(v11 + 789) = 21;
          *(_DWORD *)(v11 + 56) = 1;
        }
        break;
      case 9:
        v7 = 0;
        if ( nPlayerArray2 > 0 )
        {
          for ( j = (struct PLAYER **)PlayerArray2; (*j)->connection_id != *(_DWORD *)(a4 + 1); ++j )
          {
            if ( ++v7 >= nPlayerArray2 )
              return;
          }
          SendMessage(*j, (const char *)(a4 + 5), 0);
        }
        break;
      case 0xA:
        v5 = 0;
        v6 = (struct PLAYER **)PlayerArray2;
        if ( nPlayerArray2 > 0 )
        {
          while ( (*v6)->connection_id != *(_DWORD *)(a4 + 1) )
          {
            ++v5;
            ++v6;
            if ( v5 >= nPlayerArray2 )
              return;
          }
          sprintf(v27, "%d:%s", *(char *)(a4 + 5), (const char *)(a4 + 6));
          SendChannelMessage(*v6, v27);
        }
        break;
      default:
        return;
    }
  }
}
// 4141D8: control flows out of bounds to 419A51
// 413FA1: conditional instruction was optimized away because of 'eax.4==0'
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4332F4: using guessed type int bRecycleServer;
// 438F98: using guessed type int bServerIsRunning;
// 439E0C: using guessed type int dwPermission_PermissionMode;
// 439E6C: using guessed type int dwPermission_MininumSecondsToLogin;
// 4AD728: using guessed type int dwPermission_PermissionMaxPoints;
// 4CA230: using guessed type int PlayerArray2[];
// 4D6C04: using guessed type int dword_4D6C04;
// 4D9DCC: using guessed type int nPlayerArray2;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (00414270) --------------------------------------------------------
void FormatMessageArena(ARENA *arena, const char *Format, ...)
{
  const struct tm *v2; // eax
  char *v3; // eax
  int v4; // edi
  char *v5; // esi
  int v6; // eax
  time_t v7; // [esp+Ch] [ebp-484h] BYREF
  char v8[128]; // [esp+10h] [ebp-480h] BYREF
  char v9[512]; // [esp+90h] [ebp-400h] BYREF
  char v10[512]; // [esp+290h] [ebp-200h] BYREF
  va_list va; // [esp+49Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  time(&v7);
  v2 = localtime(&v7);
  strcpy(v8, asctime(v2));
  v3 = strstr(v8, " 199");
  if ( v3 || (v3 = strstr(v8, " 200")) != 0 )
    *v3 = 0;
  vsprintf(v9, Format, va);
  sprintf(v10, "%s:  %s", v8, v9);
  v4 = 0;
  if ( arena->nPlayersHere > 0 )
  {
    v5 = arena->PlayerArray;
    do
    {
      v6 = *(_DWORD *)(*(_DWORD *)v5 + 809);
      if ( v6 )
        fprintf(v6, "%s", v10);
      ++v4;
      v5 += 4;
    }
    while ( v4 < arena->nPlayersHere );
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 41F850: using guessed type _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD);

//----- (00414390) --------------------------------------------------------
void WriteSubGameLog(const char *Format, ...)
{
  int v1; // eax
  const struct tm *v2; // eax
  char *v3; // eax
  char *v4; // edx
  char *v5; // eax
  char v6; // cl
  time_t v7; // [esp+8h] [ebp-484h] BYREF
  char v8[128]; // [esp+Ch] [ebp-480h] BYREF
  char v9[512]; // [esp+8Ch] [ebp-400h] BYREF
  char v10[512]; // [esp+28Ch] [ebp-200h] BYREF
  va_list va; // [esp+494h] [ebp+8h] BYREF

  va_start(va, Format);
  v1 = pFILE_subgame_log;
  if ( pFILE_subgame_log )
    goto subgame_log_is_open;
  if ( dwMisc_ServerLog )
  {
    v1 = fopen("subgame.log", "at");
    pFILE_subgame_log = v1;
  }
  if ( v1 )
  {
subgame_log_is_open:
    if ( !dwMisc_ServerLog )
    {
      fclose(v1);
      pFILE_subgame_log = 0;
    }
  }
  time(&v7);
  v2 = localtime(&v7);
  strcpy(v8, asctime(v2));
  v3 = strstr(v8, " 199");
  if ( v3 || (v3 = strstr(v8, " 200")) != 0 )
    *v3 = 0;
  vsprintf(v10, Format, va);
  sprintf(v9, "%s:  %s", v8, v10);
  if ( pFILE_subgame_log )
    fprintf(pFILE_subgame_log, "%s", v9);
  printf("%s", v9);
  v4 = (char *)&dword_4D6C20[64 * dword_438F94];
  strcpy(v4, v9);
  v5 = v4;
  if ( *v4 >= 32 )
  {
    do
      v6 = *++v5;
    while ( v6 >= 32 );
  }
  *v5 = 0;
  dword_438F94 = (dword_438F94 + 1) % 48;
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 41F850: using guessed type _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD);
// 438F94: using guessed type int dword_438F94;
// 4D68BC: using guessed type int dwMisc_ServerLog;
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9DFC: using guessed type int pFILE_subgame_log;

//----- (00414540) --------------------------------------------------------
bool __cdecl IsOffensiveName(char *a1)
{
  char *v1; // esi
  char *v2; // edi
  int v4; // ecx
  int v5; // edi
  int v6; // esi
  const char *v7; // eax
  bool result; // eax
  char v9[400]; // [esp+8h] [ebp-190h] BYREF

  v1 = a1;
  v2 = v9;
  if ( *a1 )
  {
    do
    {
      if ( isalpha(*v1) )
        *v2++ = toupper(*v1);
    }
    while ( *++v1 );
  }
  v4 = dword_439DFC;
  *v2 = 0;
  v5 = sub_407260(v4);
  v6 = 0;
  if ( v5 <= 0 )
    return 0;
  while ( 1 )
  {
    v7 = (const char *)sub_407270(dword_439DFC, v6);
    result = (bool)strstr(v9, v7);
    if ( result )
      break;
    if ( ++v6 >= v5 )
      return result;
  }
  return 1;
}

//----- (004145E0) --------------------------------------------------------
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2)
{
  int v2; // ebp
  int v3; // ebx
  int v4; // edx
  unsigned int v5; // kr04_4
  signed int v6; // esi
  int v7; // eax
  const char *v8; // edx
  unsigned int v9; // ecx
  int v11; // edx
  unsigned int v12; // kr10_4
  signed int v13; // esi
  int v14; // ebp
  const char *v15; // edx
  unsigned int v16; // ecx
  int v17; // [esp+14h] [ebp-4h]
  int v18; // [esp+14h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+4h]

  v2 = 0;
  v3 = 1009 * SecurityArrayIndex;
  v4 = dword_4CCAC8[1009 * SecurityArrayIndex];
  if ( !v4 )
    goto LABEL_17;
  v19 = 1;
  v5 = strlen(a2) + 1;
  v6 = v5 - 1;
  if ( v5 == 1 )
  {
    v19 = 0;
  }
  else
  {
    v7 = sub_407260(v4);
    v17 = v7;
    if ( v7 )
    {
      if ( v7 > 0 )
      {
        while ( 1 )
        {
          v8 = (const char *)sub_407270(dword_4CCAC4[v3], v2);
          if ( v6 >= (int)strlen(v8) )
            v9 = strlen(v8);
          else
            v9 = v6;
          if ( !memcmp(a2, v8, v9) )
            v19 = 0;
          if ( ++v2 >= v17 )
            break;
          v6 = v5 - 1;
        }
      }
    }
    else
    {
      v19 = 0;
    }
  }
  if ( v19 )
    return 1;
LABEL_17:
  v11 = dword_4CCAC4[v3];
  if ( !v11 )
    return 0;
  v12 = strlen(a2) + 1;
  v13 = v12 - 1;
  if ( v12 == 1 )
    return 0;
  v14 = 0;
  v18 = sub_407260(v11);
  if ( v18 <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = (const char *)sub_407270(dword_4CCAC4[v3], v14);
    v16 = v13 >= (int)strlen(v15) ? strlen(v15) : v13;
    if ( !memcmp(a2, v15, v16) )
      break;
    if ( ++v14 >= v18 )
      return 0;
    v13 = v12 - 1;
  }
  return 1;
}
// 4CCAC4: using guessed type int dword_4CCAC4[];
// 4CCAC8: using guessed type int dword_4CCAC8[];

//----- (00414750) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl ProtocolViolation()
{
  return lpfnFixExport15();
}
// 4148B2: positive sp value 400 has been found
// 42EEC8: using guessed type int (*lpfnFixExport15)(void);

//----- (004148D0) --------------------------------------------------------
void __usercall process_text_packet(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, Player *p, DWORD msg_type, DWORD target_index, char *msg, DWORD arg5)
{
  void *v9; // esp
  char *v10; // ebx
  int v11; // edi
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // eax
  const char *v16; // ebx
  struct BILLING_SERVER_STRUCT *v17; // edx
  int v18; // eax
  int v19; // esi
  signed int v20; // ebx
  int v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // eax
  int v25; // ecx
  int v26; // esi
  int v27; // edi
  int v28; // esi
  int v29; // ecx
  int v30; // eax
  char v31; // al
  char *v32; // ebx
  char v33; // al
  char v34; // al
  char *v35; // ebx
  char v36; // al
  char v37; // al
  _BYTE *v38; // ebx
  char v39; // al
  struct TEXT_FILE_STRUCT *v40; // ebx
  const char *v41; // edx
  const char *v42; // edi
  int v43; // edi
  int i; // esi
  const char *v45; // eax
  int j; // esi
  const char *v47; // edx
  const char *v48; // ebx
  _BOOL1 v49; // zf
  int v50; // esi
  char v51; // al
  const char *v52; // ebx
  char v53; // al
  int v54; // esi
  char v55; // al
  const char *v56; // ebx
  char v57; // al
  int v58; // eax
  int v59; // eax
  int v60; // ecx
  int v61; // eax
  __int16 v62; // ax
  char v63; // dl
  int v64; // eax
  const char *v65; // [esp+8h] [ebp-16628h]
  int v66; // [esp+10h] [ebp-16620h]
  int v67; // [esp+20h] [ebp-16610h] BYREF
  int v68; // [esp+24h] [ebp-1660Ch]
  int v69; // [esp+28h] [ebp-16608h]
  int v70[3]; // [esp+2Ch] [ebp-16604h] BYREF
  int v71; // [esp+38h] [ebp-165F8h] BYREF
  int v72; // [esp+40h] [ebp-165F0h] BYREF
  int v73[14]; // [esp+44h] [ebp-165ECh] BYREF
  char buf[3]; // [esp+7Ch] [ebp-165B4h] BYREF
  char v75[20]; // [esp+7Fh] [ebp-165B1h] BYREF
  char v76[20]; // [esp+93h] [ebp-1659Dh] BYREF
  int v77; // [esp+A7h] [ebp-16589h]
  int v78; // [esp+ABh] [ebp-16585h]
  __int16 v79; // [esp+AFh] [ebp-16581h]
  __int16 v80; // [esp+B1h] [ebp-1657Fh]
  __int16 v81; // [esp+B3h] [ebp-1657Dh]
  __int16 v82; // [esp+B5h] [ebp-1657Bh]
  __int16 v83; // [esp+B7h] [ebp-16579h]
  __int16 v84; // [esp+B9h] [ebp-16577h]
  char v85[256]; // [esp+BCh] [ebp-16574h] BYREF
  char msga[320]; // [esp+1BCh] [ebp-16474h] BYREF
  char v87[2]; // [esp+2FCh] [ebp-16334h] BYREF
  char v88[510]; // [esp+2FEh] [ebp-16332h] BYREF
  char v89[90408]; // [esp+4FCh] [ebp-16134h] BYREF
  unsigned int v90; // [esp+16624h] [ebp-Ch]
  int (*v91)(); // [esp+16628h] [ebp-8h]
  int v92; // [esp+1662Ch] [ebp-4h]
  void *retaddr; // [esp+16630h] [ebp+0h]

  v92 = -1;
  v91 = unknown_libname_14;
  v90 = __readfsdword(0);
  v9 = alloca(91632);
  v70[1] = a1;
  v10 = msg;
  v70[0] = a2;
  v69 = a4;
  v68 = a3;
  if ( p && *(_DWORD *)CONTAINING_RECORD(p, PLAYER, field_4)->field_283 && *msg == '8'
    || strlen(msg) > 0xFA
    || (v11 = target_index,
        nullsub_2(p, msg_type, target_index, msg, arg5),
        v67 = a4,
        v64 = (*(int (__stdcall **)(char *, Player *, DWORD, DWORD))&lpfnFixFunctionArray_lpfnFixExport0)(
                msg,
                p,
                msg_type,
                target_index),
        !v64) )
  {
return_something:
    JUMPOUT(0x4199E0);
  }
  if ( p )
  {
    v12 = 0;
    if ( (target_index & 0x80000000) == 0 && (int)target_index < 1024 )
      v12 = (int)*(&PlayerArray + target_index);
    v13 = dwBilling_LogMessages;
    if ( dwBilling_LogMessages <= *(_DWORD *)((char *)p + 543) )
      v13 = *(_DWORD *)((char *)p + 543);
    if ( v12 && *(_DWORD *)(v12 + 543) )
    {
      if ( v13 )
      {
LABEL_17:
        v14 = -1;
        switch ( v90 )
        {
          case 3u:
            v14 = -2;
            break;
          case 4u:
            v14 = -3;
            break;
          case 5u:
            if ( v12 )
              v14 = *(_DWORD *)(v12 + 539);
            break;
          case 9u:
            v14 = -4;
            break;
          default:
            break;
        }
        if ( v13 == 3
          || v13 == 2 && (v90 == 3 || v90 == 4 || v90 == 5 || v90 == 9 || *msg == 42)
          || v13 == 1 && (v90 == 5 || *msg == 42) )
        {
          v15 = *(_DWORD *)((char *)p + 539);
          if ( v15 >= 0 )
          {
            if ( FindMeOut1 )
              SendBillerUnknownPacket(FindMeOut1, v15, v14, msg);
          }
        }
        goto LABEL_36;
      }
      v13 = *msg != 42;
    }
    if ( !v13 )
      goto LABEL_36;
    goto LABEL_17;
  }
LABEL_36:
  if ( *msg != 42 )
    JUMPOUT(0x417ADA);
  if ( p )
  {
    if ( !*(_DWORD *)((char *)p + 639) )
      JUMPOUT(0x4179AC);
    v10 = (char *)v92;
    if ( !*(_DWORD *)((char *)p + 635) )
      JUMPOUT(0x416DC5);
    v11 = (int)v91;
    if ( !*(_DWORD *)((char *)p + 631) )
      goto cmd_szone;
  }
  if ( !_memicmp(v10, "**", 2u) && p )
  {
    v16 = v10 + 2;
    v87[1] = (char)retaddr;
    v87[0] = 2;
    v17 = FindMeOut1;
    strcpy(v88, v16);
    if ( v17 )
      SendBillerUserPrivateChatPacket(v17, *((_DWORD *)p + 4), dwBilling_GroupID, v87, strlen(v16) + 3);
    goto return_something;
  }
  if ( !_memicmp(v10, "*energy", 7u) && p )
  {
    if ( v90 == 5 )
    {
      v18 = (int)*(&PlayerArray + v11);
      if ( v18 )
      {
        v19 = *(_DWORD *)(v18 + 68);
        *(_DWORD *)(v18 + 68) = v19 == 0;
        if ( v19 )
          v65 = "Showing Energy OFF for %s";
        else
          v65 = "Showing Energy ON for %s";
        sprintf(v85, v65, v18 + 375);
        goto send_msg_to_player;
      }
    }
    else if ( *((_DWORD *)p + 7) )
    {
      *((_DWORD *)p + 17) = *((_DWORD *)p + 17) == 0;
      goto send_msg_to_player;
    }
cmd_szone:
    JUMPOUT(0x415FAF);
  }
  if ( !_memicmp(v10, "*stat", 5u) && p )
  {
    v20 = GetTickCount() / 0xA - dword_4D9DE4;
    v69 = v20;
    if ( v20 <= 0 )
    {
      v20 = 1;
      v69 = 1;
    }
    v21 = *((_DWORD *)p + 7);
    v68 = 0;
    if ( *(int *)(v21 + 65292) > 0 )
    {
      v22 = 0;
      v23 = 64288;
      do
      {
        v24 = GetRelAckDiff(*(struct CONNECTION **)(*(_DWORD *)(v23 + v21) + 40), 0);
        v23 += 4;
        v25 = v24 + v68;
        v21 = *((_DWORD *)p + 7);
        v68 = v25;
        ++v22;
      }
      while ( v22 < *(_DWORD *)(v21 + 65292) );
      v68 = 10 * v68 / *(_DWORD *)(*((_DWORD *)p + 7) + 65292);
    }
    GetPacketStatistics((struct PACKET_ATTACHMENT *)lpFileName, v73, &v67, &v72, &v71, v70);
    sprintf(
      msga,
      "Send:%d(%d)  Recv:%d(%d)  RelOut:%.1f  Multi:%.1f\n",
      100 * v73[0] / v20,
      100 * v67 / v20,
      100 * v72 / v20,
      100 * v71 / v20,
      (double)((long double)v68 * dbl_42A008),
      (double)((long double)v70[0] * dbl_42A000 / (long double)v69));
    SendMessage((struct PLAYER *)p, msga, 0);
    v26 = 0;
    if ( dword_4AD72C )
      v26 = GetRelAckDiff((struct CONNECTION *)dword_4AD72C, 0);
    sprintf(
      msga,
      "Iterations:%d  Players:%d  BillingRelOut:%d  Wave:%d\n",
      100 * dword_4332E8 / v20,
      nPlayerArray2,
      v26,
      100 * dword_4D9CB8 / v20);
    SendMessage((struct PLAYER *)p, msga, 0);
    sprintf(
      msga,
      "Screen:%d  Radar:%d  Double:%d  Timer:%d\n",
      100 * dword_439E00 / v20,
      100 * dword_432ED8 / v20,
      100 * dword_438F08 / v20,
      v20 / 100);
    SendMessage((struct PLAYER *)p, msga, 0);
    v27 = 0;
    v28 = 0;
    if ( nArenas > 0 )
    {
      v69 = (int)ArenaArray;
      do
      {
        v27 += GetArenaMemoryTotal(*(ARENA **)v69);
        ++v28;
        v69 += 4;
      }
      while ( v28 < nArenas );
    }
    sprintf(msga, "MemoryUsage:%dk\n", v27);
    SendMessage((struct PLAYER *)p, msga, 0);
    v29 = 0;
    msga[0] = 0;
    v69 = 0;
    do
    {
      v30 = dword_4399F0[v29];
      if ( v30 )
      {
        sprintf(buf, "%d:%d(%d)  ", v29, 100 * dword_4B0668[v29] / v20, 100 * v30 / v20);
        if ( strlen(msga) + strlen(buf) > 0x4B )
        {
          SendMessage((struct PLAYER *)p, msga, 0);
          msga[0] = 0;
        }
        strcat(msga, buf);
        v29 = v69;
      }
      v69 = ++v29;
    }
    while ( v29 < 256 );
    if ( !msga[0] )
      goto cmd_szone;
    goto LABEL_173;
  }
  if ( !_memicmp(v10, "*addword", 8u) )
  {
    v31 = v10[8];
    v32 = v10 + 8;
    v92 = (int)v32;
    if ( v31 == 32 )
    {
      do
        v33 = *++v32;
      while ( v33 == 32 );
      v92 = (int)v32;
    }
    if ( *v32 )
    {
      AddLineTextFile((struct TEXT_FILE_STRUCT *)dword_439DFC, v32);
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_439DFC);
      if ( p )
      {
        sprintf(v85, "Obscene Word Added: %s", v32);
        goto send_msg_to_player;
      }
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*addmachine", 0xBu) )
  {
    v34 = v10[11];
    v35 = v10 + 11;
    v92 = (int)v35;
    if ( v34 == 32 )
    {
      do
        v36 = *++v35;
      while ( v36 == 32 );
      v92 = (int)v35;
    }
    if ( *v35 )
    {
      AddLineTextFile((struct TEXT_FILE_STRUCT *)dword_4D9DC0, v35);
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_4D9DC0);
      if ( p )
      {
        sprintf(v85, "MachineId Block Added: %s", v35);
        goto send_msg_to_player;
      }
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*removemachine", 0xEu) )
  {
    v37 = v10[14];
    v38 = v10 + 14;
    v92 = (int)v38;
    if ( v37 == 32 )
    {
      do
        v39 = *++v38;
      while ( v39 == 32 );
      v92 = (int)v38;
    }
    if ( !*v38 )
      goto cmd_szone;
    v40 = 0;
    v69 = sub_407260(dword_4D9DC0);
    if ( v69 > 0 )
    {
      do
      {
        v41 = (const char *)sub_407270(dword_4D9DC0, (int)v40);
        v42 = (const char *)v92;
        if ( strlen((const char *)v92) >= strlen(v41) )
          v42 = v41;
        if ( !memcmp((const void *)v92, v41, strlen(v42)) )
        {
          ListMachineSomething(v40, v66);
          --v69;
        }
        else
        {
          v40 = (struct TEXT_FILE_STRUCT *)((char *)v40 + 1);
        }
      }
      while ( (int)v40 < v69 );
    }
    WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_4D9DC0);
    if ( !p )
      goto cmd_szone;
send_msg_to_player:
    JUMPOUT(0x415FA8);
  }
  if ( !_memicmp(v10, "*listmachine", 0xCu) && p )
  {
    v43 = sub_407260(dword_4D9DC0);
    for ( i = 0; i < v43; ++i )
    {
      v45 = (const char *)sub_407270(dword_4D9DC0, i);
      SendMessage((struct PLAYER *)p, v45, 0);
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*log", 4u) && p )
  {
    for ( j = 0; j < 48; ++j )
    {
      v47 = (const char *)&dword_4D6C20[64 * ((j + dword_438F94) % 48)];
      if ( *v47 )
        SendMessage((struct PLAYER *)p, v47, 0);
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*shutdown", 9u) )
  {
    if ( p )
      SendMessage((struct PLAYER *)p, "Shutting down server...", 0);
    printf("Shutting down server...\n");
    v48 = v10 + 9;
    bRecycleServer = 1;
    bServerIsRunning = 1;
    ShutdownSpawnCmdLine[0] = 0;
    v49 = *v48 == 32;
    v92 = (int)v48;
    if ( v49 )
      v92 = (int)++v48;
    if ( *v48 )
      strcpy(ShutdownSpawnCmdLine, v48);
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*lowbandwidth", 0xDu) )
  {
    if ( v90 != 5 )
      goto cmd_szone;
    v50 = (int)*(&PlayerArray + v11);
    if ( !v50 )
      goto cmd_szone;
    v51 = v10[13];
    v52 = v10 + 13;
    v92 = (int)v52;
    if ( v51 == 32 )
    {
      do
        v53 = *++v52;
      while ( v53 == 32 );
      v92 = (int)v52;
    }
    if ( *v52 )
      *(_DWORD *)(v50 + 52) = atoi(v52);
    else
      *(_DWORD *)(v50 + 52) = 1;
    sprintf(v89, "Player Marked As Low Bandwidth: %d", *(_DWORD *)(v50 + 52));
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*messagelogging", 0xFu) )
  {
    if ( v90 != 5 )
      goto cmd_szone;
    v54 = (int)*(&PlayerArray + v11);
    if ( !v54 )
      goto cmd_szone;
    v55 = v10[15];
    v56 = v10 + 15;
    v92 = (int)v56;
    if ( v55 == 32 )
    {
      do
        v57 = *++v56;
      while ( v57 == 32 );
      v92 = (int)v56;
    }
    v58 = atoi(v56);
    *(_DWORD *)(v54 + 543) = v58;
    sprintf(v89, (const char *)&lpfnFixExport8, v58);
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*thor ", 6u) && p )
  {
    v59 = atoi(v10 + 6);
    if ( v90 != 5 )
    {
      if ( *((_DWORD *)p + 7) )
      {
        *(_DWORD *)((char *)p + 643) = v59;
        sprintf(v85, "Thor Adjust %d", v59);
        goto send_msg_to_player;
      }
      goto cmd_szone;
    }
    v60 = (int)*(&PlayerArray + v11);
    if ( !v60 )
      goto cmd_szone;
    *(_DWORD *)(v60 + 643) = v59;
    sprintf(v85, "Thor Adjust %d for %s", v59, (const char *)(v60 + 375));
LABEL_173:
    JUMPOUT(0x415FA7);
  }
  v61 = _memicmp(v10, "*mirror", 7u);
  if ( !v61 && p )
  {
    LOBYTE(v61) = *(_DWORD *)((char *)p + 651) == 0;
    *(_DWORD *)((char *)p + 651) = v61;
    if ( v61 )
    {
      v62 = *(_WORD *)((char *)p + 279);
      buf[0] = 3;
      v79 = 1014;
      v83 = -1;
      buf[2] = 0;
      v80 = v62;
      buf[1] = 2;
      v81 = 0;
      v82 = 0;
      v77 = 0;
      v84 = 0;
      v78 = 0;
      strncpy(v75, "(Mirror)", 0x14u);
      v75[19] = 0;
      strncpy(v76, "Sysop", 0x14u);
      v76[19] = 0;
      PlayerSendPacket((PLAYER *)p, buf, 64, 1);
    }
    else
    {
      LOBYTE(v67) = 4;
      *(_WORD *)((char *)&v67 + 1) = 1014;
      PlayerSendPacket((PLAYER *)p, &v67, 3, 1);
    }
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*ufo", 4u) && p )
  {
    if ( v90 == 5 )
    {
      if ( !*(&PlayerArray + v11) )
        goto return_something;
      *((_DWORD *)p + 19) = v11;
    }
    else
    {
      *((_DWORD *)p + 19) = -1;
    }
    *((_DWORD *)p + 15) = *((_DWORD *)p + 15) == 0;
    v63 = *((_BYTE *)p + 60);
    LOBYTE(v67) = 37;
    BYTE1(v67) = v63;
    PlayerSendPacket((PLAYER *)p, &v67, 2, 1);
    goto cmd_szone;
  }
  CommandHandler_2(v10, (PLAYER *)p, v11, 5u, (int)p, msg_type, target_index, (int)msg, arg5);
}
// 414B0B: control flows out of bounds to 4199E0
// 414B94: control flows out of bounds to 415FA8
// 414F4A: control flows out of bounds to 415FA7
// 41517A: control flows out of bounds to 415FAF
// 414A36: control flows out of bounds to 417ADA
// 414A48: control flows out of bounds to 4179AC
// 414A61: control flows out of bounds to 416DC5
// 42EE8C: invalid function type has been ignored
// 414A57: conditional instruction was optimized away because of 'ebp.4!=0'
// 414A70: conditional instruction was optimized away because of 'ebp.4!=0'
// 414C33: conditional instruction was optimized away because of 'ecx.4>=1'
// 4150FF: variable 'v66' is possibly undefined
// 419A50: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 42948E: using guessed type int unknown_libname_14();
// 42A000: using guessed type double dbl_42A000;
// 42A008: using guessed type double dbl_42A008;
// 42EEAC: using guessed type int (__stdcall *lpfnFixExport8)(_DWORD, _DWORD, _DWORD, _DWORD);
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F94: using guessed type int dword_438F94;
// 438F98: using guessed type int bServerIsRunning;
// 439E00: using guessed type int dword_439E00;
// 4CBB00: using guessed type int dwBilling_LogMessages;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int nPlayerArray2;
// 4D9DE4: using guessed type int dword_4D9DE4;

//----- (00415740) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __thiscall init_new_player(PLAYER *this)
{
  PLAYER *v1; // eax
  struct in_addr v2; // [esp-Ch] [ebp-Ch]
  __int16 v3; // [esp-8h] [ebp-8h]
  NetData *v4; // [esp-4h] [ebp-4h]

  v1 = CreateNewPlayer(this, v2, v3, v4);
  ((void (__thiscall *)(PLAYER *))lpfnFixExport5)(v1);
  JUMPOUT(0x412EBD);
}
// 415745: positive sp value C has been found
// 41574D: control flows out of bounds to 412EBD
// 415740: variable 'v2' is possibly undefined
// 415740: variable 'v3' is possibly undefined
// 415740: variable 'v4' is possibly undefined
// 42EEA0: using guessed type int (*lpfnFixExport5)();

//----- (00415770) --------------------------------------------------------
// this function loads fix.dll, and it is inside a nop'd out command handler.
// 22 function addrs in the array.
char *__cdecl fix_dll_loader(const char *a1, const char *a2)
{
  HMODULE v2; // eax
  unsigned int v3; // edi
  FARPROC v4; // eax

  v2 = LoadLibraryA(&lpfnFixFunctionArray_lpfnFixExport0);
  v3 = 0;
  v4 = GetProcAddress(v2, lpfnFixExport2);
  if ( !v4 )
    JUMPOUT(0x64);
  do
  {
    *((_DWORD *)&lpfnFixFunctionArray_lpfnFixExport0 + v3) = *((_DWORD *)v4 + v3);
    ++v3;
  }
  while ( v3 < 0x16 );
  return strstr(a1, a2);
}
// 415792: control flows out of bounds to 64

//----- (004157E0) --------------------------------------------------------
#error "4157E0: call analysis failed (funcsize=4)"

//----- (00415800) --------------------------------------------------------
int __cdecl sub_415800(int a1, int a2)
{
  return lpfnFixExport1(a1, a2);
}
// 42EE90: using guessed type int (__stdcall *lpfnFixExport1)(_DWORD, _DWORD);

//----- (00415820) --------------------------------------------------------
int __cdecl sub_415820()
{
  return ((int (*)(void))lpfnFixExport2)();
}
// 42EE94: invalid function type has been ignored

//----- (00415850) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_415850(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6, int a7)
{
  int v7; // [esp-20h] [ebp-20h]
  int v8; // [esp-1Ch] [ebp-1Ch]
  int v9; // [esp-18h] [ebp-18h]
  int v10; // [esp-14h] [ebp-14h]
  int v11; // [esp-10h] [ebp-10h]
  int v12; // [esp-Ch] [ebp-Ch]
  int v13; // [esp-8h] [ebp-8h]
  int v14; // [esp-4h] [ebp-4h]

  encrypt_init(a1, v7, v8, v9, v10, v11, v12, v13, v14);
  if ( *(_DWORD *)(a3 + 66) >= 0x10u )
    qmemcpy((void *)(a3 + 70), (const void *)(a2 + 8), 0x5Cu);
  JUMPOUT(0x41BA88);
}
// 415855: positive sp value 20 has been found
// 41586A: control flows out of bounds to 41BA88
// 415850: variable 'v7' is possibly undefined
// 415850: variable 'v8' is possibly undefined
// 415850: variable 'v9' is possibly undefined
// 415850: variable 'v10' is possibly undefined
// 415850: variable 'v11' is possibly undefined
// 415850: variable 'v12' is possibly undefined
// 415850: variable 'v13' is possibly undefined
// 415850: variable 'v14' is possibly undefined

//----- (00415870) --------------------------------------------------------
void __userpurge sub_415870(int a1@<ebp>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // [esp+0h] [ebp-Ch]
  int v11; // [esp+4h] [ebp-8h]
  int v12; // [esp+8h] [ebp-4h]

  if ( !lpfnFixExport9(v10, v11, v12) )
  {
    --*(_DWORD *)(a1 + 2670);
    JUMPOUT(0x41BC2D);
  }
  JUMPOUT(0x41BC25);
}
// 415884: control flows out of bounds to 41BC25
// 41588F: control flows out of bounds to 41BC2D
// 415877: variable 'v10' is possibly undefined
// 415877: variable 'v11' is possibly undefined
// 415877: variable 'v12' is possibly undefined
// 42EEB0: using guessed type int (__stdcall *lpfnFixExport9)(_DWORD, _DWORD, _DWORD);

//----- (004158A0) --------------------------------------------------------
void __userpurge sub_4158A0(int a1@<ebx>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  STACK[0x42C] = lpfnFixExport8(a1, a2, STACK[0x42C], &a11);
  JUMPOUT(0x41C632);
}
// 4158BC: control flows out of bounds to 41C632
// 42EEAC: using guessed type int (__stdcall *lpfnFixExport8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00415920) --------------------------------------------------------
void __userpurge sub_415920(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  if ( *(int *)(a1 + 62) > 0 )
    JUMPOUT(0x41BBAD);
  JUMPOUT(0x41BC22);
}
// 415931: control flows out of bounds to 41BBAD
// 415924: control flows out of bounds to 41BC22

//----- (00415940) --------------------------------------------------------
#error "415940: call analysis failed (funcsize=9)"

//----- (00415980) --------------------------------------------------------
void __userpurge sub_415980(int a1@<edi>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13)
{
  if ( (_BYTE)dwCustom_ArenaMode == 5 )
    sprintf(a1, (const char *)&loc_4159B8, &a13);
  else
    sub_408270(a1);
  JUMPOUT(0x401260);
}
// 41599C: control flows out of bounds to 401260
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4D58B0: using guessed type int dwCustom_ArenaMode;

//----- (00415A26) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall CommandHandler_2(char *a1@<ebx>, PLAYER *a2@<ebp>, int a3@<edi>, unsigned int a4@<esi>, int a5, int a6, int a7, int SoccerScores, char a9)
{
  _WORD *v9; // ecx
  int v10; // eax
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  bool v15; // ecx
  int v16; // eax
  int v17; // edx
  bool v18; // ecx
  char v19; // cl
  char *v20; // eax
  char *i; // edx
  char v22; // cl
  char v23; // cl
  char *v24; // eax
  _BYTE *j; // edx
  char v26; // cl
  char v27; // cl
  _BYTE *v28; // eax
  char *k; // edx
  char *v30; // eax
  char v31; // al
  char *v32; // esi
  char *l; // ecx
  char v34; // al
  char v35; // al
  _BYTE *v36; // esi
  _BYTE *m; // ecx
  char v38; // al
  _BYTE *v39; // esi
  char *n; // ecx
  char *v41; // ebx
  struct CONNECTION **v42; // edx
  char v43; // al
  char *v44; // ebx
  char v45; // al
  ARENA *v46; // eax
  unsigned int v47; // kr14_4
  int v48; // edi
  PLAYER **v49; // ebx
  int v50; // ecx
  int v51; // esi
  const char *v52; // eax
  int v53; // eax
  int v54; // ecx
  int v55; // eax
  struct CONNECTION *v56; // ecx
  int v57; // edi
  int v58; // edx
  int v59; // edi
  long double v60; // fst7
  int v61; // eax
  int v62; // ecx
  int v63; // eax
  long double v64; // fst7
  int v65; // ecx
  int v66; // edx
  int v67; // edi
  time_t v68; // eax
  int v69; // edi
  int v70; // ecx
  int v71; // ecx
  const char *v72; // eax
  int v73; // ecx
  int v74; // eax
  int v75; // edx
  char v76; // al
  const char *v77; // edi
  char v78; // al
  char v79; // al
  _BOOL1 v80; // zf
  __int16 v81; // ax
  int v82; // edi
  int v83; // eax
  int v84; // ecx
  int v85; // edx
  int v86; // eax
  int v87; // eax
  int v88; // ecx
  int v89; // edx
  int v90; // eax
  int v91; // eax
  const char *v92; // eax
  char v93; // al
  char *v94; // edi
  char v95; // al
  ARENA *v96; // eax
  unsigned int v97; // kr2C_4
  char v98; // al
  char *v99; // edi
  char v100; // al
  char v101; // al
  const char *v102; // edi
  char v103; // al
  struct TEXT_FILE_STRUCT *v104; // eax
  __int16 v105; // ax
  PLAYER *v106; // esi
  int v107; // edx
  char v108; // al
  const char *v109; // edi
  char v110; // al
  int v111; // esi
  int v112; // edx
  PLAYER *v113; // esi
  int v114; // edi
  int v115; // eax
  int v116; // esi
  int v117; // eax
  struct ARENA *v118; // ecx
  int v119; // edi
  struct ARENA **v120; // esi
  PLAYER *v121; // ecx
  int v122; // edi
  PLAYER **v123; // esi
  PLAYER *v124; // ecx
  int v125; // ecx
  int v126; // eax
  const char *v127; // edi
  int v128; // ebx
  int v129; // eax
  int v130; // eax
  ARENA *v131; // eax
  int v132; // esi
  unsigned int v133; // edi
  const char *v134; // esi
  int v135; // edx
  int v136; // [esp-16604h] [ebp-1661Ch]
  int v137; // [esp-16600h] [ebp-16618h]
  const char *v138; // [esp-165FCh] [ebp-16614h]
  bool v139; // [esp-165F8h] [ebp-16610h]
  time_t v140; // [esp-165F8h] [ebp-16610h]
  int v141; // [esp-165F4h] [ebp-1660Ch]
  int v142; // [esp-165E4h] [ebp-165FCh] BYREF
  float v143; // [esp-165E0h] [ebp-165F8h] BYREF
  int v144; // [esp-165DCh] [ebp-165F4h] BYREF
  int v145; // [esp-165D8h] [ebp-165F0h] BYREF
  _BYTE v146[5]; // [esp-165D4h] [ebp-165ECh] BYREF
  int v147; // [esp-165CCh] [ebp-165E4h] BYREF
  int v148; // [esp-165C8h] [ebp-165E0h]
  int v149; // [esp-165C4h] [ebp-165DCh] BYREF
  int v150; // [esp-165C0h] [ebp-165D8h] BYREF
  _DWORD v151[12]; // [esp-165BCh] [ebp-165D4h] BYREF
  int v152; // [esp-1658Ch] [ebp-165A4h] BYREF
  char v153[64]; // [esp-16588h] [ebp-165A0h] BYREF
  CHAR v154[256]; // [esp-16548h] [ebp-16560h] BYREF
  char v155; // [esp-16448h] [ebp-16460h] BYREF
  __int16 v156; // [esp-16447h] [ebp-1645Fh]
  _BYTE v157[96]; // [esp-16445h] [ebp-1645Dh] BYREF
  char v158[64]; // [esp-16348h] [ebp-16360h] BYREF
  char v159; // [esp-16308h] [ebp-16320h] BYREF
  char v160; // [esp-16307h] [ebp-1631Fh] BYREF
  char v161; // [esp-16306h] [ebp-1631Eh] BYREF
  __int16 v162; // [esp-16305h] [ebp-1631Dh]
  char v163[251]; // [esp-16303h] [ebp-1631Bh] BYREF
  char v164; // [esp-16208h] [ebp-16220h]
  char v165[15]; // [esp-16207h] [ebp-1621Fh] BYREF
  char v166; // [esp-161F8h] [ebp-16210h]
  struct _STARTUPINFOA v167[11]; // [esp-16108h] [ebp-16120h] BYREF
  _DWORD v168[22402]; // [esp-15E08h] [ebp-15E20h] BYREF

  if ( _memicmp(a1, "*super", 6u) || !a2 )
  {
    if ( _memicmp(a1, "*sysop", 6u) )
    {
      if ( _memicmp(a1, "*smoderator", 0xBu) )
      {
        if ( _memicmp(a1, "*s*", 3u) && _memicmp(a1, "*g*", 3u) )
        {
          if ( !_memicmp(a1, "*set ", a4) )
          {
            v19 = a1[5];
            v20 = a1 + 5;
            for ( i = v158; v19; ++v20 )
            {
              if ( v19 == 58 )
                break;
              *i = v19;
              v19 = v20[1];
              ++i;
            }
            v22 = *v20;
            *i = 0;
            if ( !v22 )
              return;
            v23 = v20[1];
            v24 = v20 + 1;
            for ( j = v151; v23; ++v24 )
            {
              if ( v23 == 58 )
                break;
              *j = v23;
              v23 = v24[1];
              ++j;
            }
            v26 = *v24;
            *j = 0;
            if ( !v26 )
              return;
            v27 = v24[1];
            v28 = v24 + 1;
            for ( k = &v155; v27; ++v28 )
            {
              *k = v27;
              v27 = v28[1];
              ++k;
            }
            *k = 0;
            GetModuleFileNameA(0, (LPSTR)v167, 0x100u);
            v30 = strrchr((const char *)v167, 92);
            if ( v30 )
              *v30 = 0;
            else
              LOBYTE(v167[0].cb) = 0;
            sprintf(v154, "%s\\server.cfg", (const char *)v167);
            if ( _strcmpi(v158, "All") )
            {
              WritePrivateProfileStringA(v158, (LPCSTR)v151, &v155, v154);
            }
            else
            {
              WritePrivateProfileStringA("Warbird", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Javelin", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Spider", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Leviathan", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Weasel", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Terrier", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Lancaster", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Shark", (LPCSTR)v151, &v155, v154);
            }
            if ( a2 )
              SendMessage(a2, "Change complete", 0);
          }
        }
        else
        {
          v31 = a1[3];
          v32 = a1 + 3;
          for ( l = v158; v31; ++v32 )
          {
            if ( v31 == 58 )
              break;
            *l = v31;
            v31 = v32[1];
            ++l;
          }
          v34 = *v32;
          *l = 0;
          if ( !v34 )
            return;
          v35 = v32[1];
          v36 = v32 + 1;
          for ( m = v151; v35; ++v36 )
          {
            if ( v35 == 58 )
              break;
            *m = v35;
            v35 = v36[1];
            ++m;
          }
          *m = 0;
          if ( !_memicmp(a1, "*s*", 3u) )
          {
            if ( !*v36 )
              return;
            v38 = v36[1];
            v39 = v36 + 1;
            for ( n = v153; v38; ++v39 )
            {
              *n = v38;
              v38 = v39[1];
              ++n;
            }
            *n = 0;
            WritePrivateProfileStringA(v158, (LPCSTR)v151, v153, &aServerIni);
            dword_4D6C10 = 1;
          }
          if ( a2 )
          {
            GetPrivateProfileStringA(v158, (LPCSTR)v151, "InvalidTag", (LPSTR)v167, 0x40u, &aServerIni);
            sprintf(&v155, "%s:%s:%s", v158, (const char *)v151, (const char *)v167);
            SendMessage(a2, &v155, 0);
          }
        }
      }
      else if ( a6 == a4 )
      {
        v16 = (int)*(&PlayerArray + a3);
        if ( v16 )
        {
          v17 = *(_DWORD *)(v16 + 635);
          v18 = v17 == 0;
          *(_DWORD *)(v16 + 635) = v18;
          *(_DWORD *)(v16 + 639) = v18;
          if ( v17 )
            SendMessage(a2, "Player Super Moderator Mode OFF", 0);
          else
            SendMessage(a2, "Player Super Moderator Mode ON", 0);
        }
      }
    }
    else if ( a6 == a4 )
    {
      v13 = (int)*(&PlayerArray + a3);
      if ( v13 )
      {
        v14 = *(_DWORD *)(v13 + 631);
        v15 = v14 == 0;
        *(_DWORD *)(v13 + 631) = v15;
        *(_DWORD *)(v13 + 635) = v15;
        *(_DWORD *)(v13 + 639) = v15;
        if ( v14 )
          SendMessage(a2, "Player Sysop Mode OFF", 0);
        else
          SendMessage(a2, "Player Sysop Mode ON", 0);
      }
    }
  }
  else
  {
    qmemcpy(v168, (const void *)(a2->lpCurrentArena + 108194), 0x594u);
    v9 = (_WORD *)&v168[4] + 1;
    v144 = 8;
    do
    {
      *(v9 - 1) = 0;
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      v9[3] = 0;
      v9[29] = 0;
      v9[4] = 0;
      v9[33] = 10;
      v9[34] = 10;
      v9[35] = 10;
      v9[36] = 10;
      v9[9] = 0;
      v9[10] = 0;
      v9[12] = 0;
      v10 = (__int16)v9[14];
      v9 += 72;
      *(v9 - 58) = 5 * v10 / 2;
      *(v9 - 57) *= 3;
      *(v9 - 56) *= 16;
      *(v9 - 54) = *(v9 - 59);
      *(v9 - 53) = *(v9 - 58);
      *(v9 - 52) = *(v9 - 57);
      *(v9 - 50) = *(v9 - 55);
      *(v9 - 51) = *(v9 - 56);
      *(v9 - 61) = 0;
      *((_BYTE *)v9 - 50) = 0x80;
      *((_BYTE *)v9 - 49) = 117;
      *((_BYTE *)v9 - 48) = 0x80;
      *((_BYTE *)v9 - 47) = 0x80;
      *((_BYTE *)v9 - 46) = 0x80;
      *((_BYTE *)v9 - 45) = 0x80;
      *((_BYTE *)v9 - 44) = 0x80;
      *((_BYTE *)v9 - 43) = 0x80;
      *(v9 - 44) = 0;
      v11 = *(_DWORD *)(v9 - 17) & 0xFFFFFE1F;
      BYTE1(v11) |= 2u;
      *(_DWORD *)(v9 - 17) = v11;
      v12 = v144;
      *(v9 - 33) = 100;
      *(v9 - 32) = 999;
      *(v9 - 31) = 0;
      v144 = v12 - 1;
    }
    while ( v12 != 1 );
    v168[289] = 0;
    v168[300] = 0;
    v168[299] = 0;
    v168[290] = 0;
    HIWORD(v168[316]) = 0;
    BYTE1(v168[343]) = 0x80;
    HIBYTE(v168[343]) = 0x80;
    PlayerSendPacket(a2, v168, 1428, 1);
  }
  if ( !_memicmp((const void *)SoccerScores, "*szone", 6u) && a2 )
  {
    v41 = (char *)(SoccerScores + 6);
    if ( *(_BYTE *)(SoccerScores + 6) == 32 )
      v41 = (char *)(SoccerScores + 7);
    if ( *v41 == 95 )
      *v41 = 32;
    if ( a2->bIsSysop || *v41 != 42 || !_memicmp(v41, "*permit", 7u) || !_memicmp(v41, "*revoke", 7u) )
    {
      v160 = a9;
      v159 = 2;
      v42 = (struct CONNECTION **)FindMeOut1;
      strcpy(&v161, v41);
      if ( v42 )
        SendBillerZoneRevokePermitPacket(v42, a2->connection_id, dwBilling_ScoreID, (int)&v159, strlen(v41) + 3);
    }
    return;
  }
  if ( _memicmp((const void *)SoccerScores, "*zone", 5u) )
  {
    if ( _memicmp((const void *)SoccerScores, "*where", 6u) || !a2 )
    {
      if ( _memicmp((const void *)SoccerScores, "*info", 5u) || !a2 )
      {
        if ( _memicmp((const void *)SoccerScores, "*getlist", 8u) || !a2 )
        {
          if ( _memicmp((const void *)SoccerScores, "*putlist", 8u) || !a2 )
          {
            if ( _memicmp((const void *)SoccerScores, "*getmodlist", 0xBu) || !a2 )
            {
              if ( _memicmp((const void *)SoccerScores, "*putmodlist", 0xBu) || !a2 )
              {
                if ( _memicmp((const void *)SoccerScores, "*recycle", 8u) )
                {
                  if ( _memicmp((const void *)SoccerScores, "*moderator", 0xAu) )
                  {
                    if ( _memicmp((const void *)SoccerScores, "*restart", 8u) || !a2 )
                    {
                      if ( _memicmp((const void *)SoccerScores, "*prize", 6u) )
                      {
                        if ( !_memicmp((const void *)SoccerScores, "*trace", 6u) && a2 )
                        {
                          if ( a2->hProcess && GetExitCodeProcess((HANDLE)a2->hProcess, (LPDWORD)v146) )
                          {
                            if ( *(_DWORD *)v146 == 259 )
                              TerminateProcess((HANDLE)a2->hProcess, 0);
                            CloseHandle((HANDLE)a2->hProcess);
                            a2->hProcess = 0;
                            *(_DWORD *)a2->field_4 = 0;
                            *(_DWORD *)&a2->field_4[4] = 0;
                            *(_DWORD *)&a2->field_4[8] = 0;
                          }
                          if ( a6 == 5 )
                          {
                            v91 = (int)*(&PlayerArray + a7);
                            if ( v91 )
                            {
                              v92 = get_text_ip(*(struct in_addr *)(v91 + 755));
                              sprintf(v154, "SUBGAME2 /SPAWN tracert %s > spawn.log", v92);
                              memset(v167, 0, 0x44u);
                              v167[0].cb = 68;
                              v167[0].lpTitle = "Spawned TRACERT";
                              CreateProcessA(0, v154, 0, 0, 0, 0x20u, 0, 0, v167, (LPPROCESS_INFORMATION)a2);
                              SendMessage(a2, "SPAWN STARTED", 0);
                            }
                          }
                        }
                      }
                      else
                      {
                        v76 = *(_BYTE *)(SoccerScores + 6);
                        v77 = (const char *)(SoccerScores + 6);
                        SoccerScores += 6;
                        if ( v76 == 32 )
                        {
                          do
                            v78 = *++v77;
                          while ( v78 == 32 );
                          SoccerScores = (int)v77;
                        }
                        v79 = *v77;
                        v80 = *v77 == 35;
                        v146[0] = 32;
                        *(_WORD *)&v146[3] = 0;
                        *(_WORD *)&v146[1] = 1;
                        if ( v80 )
                        {
                          *(_WORD *)&v146[3] = atoi(v77 + 1);
                        }
                        else if ( isdigit(v79) )
                        {
                          *(_WORD *)&v146[1] = atoi(v77);
                        }
                        if ( !a2->bIsSysop )
                        {
                          v81 = *(_WORD *)&v146[1];
                          *(_WORD *)&v146[1] = 100;
                          if ( v81 <= 100 )
                            *(_WORD *)&v146[1] = v81;
                        }
                        if ( a2 )
                          SendMessage(a2, "Granting prize(s)", 0);
                        if ( a6 == 5 )
                        {
                          v82 = (int)*(&PlayerArray + a7);
                          if ( v82 )
                          {
                            PlayerSendPacket((PLAYER *)v82, v146, 5, 1);
                            *(_DWORD *)(v82 + 773) = 1;
                          }
                        }
                        else if ( a6 == 3 )
                        {
                          SendReliablePacketToMyFrequency(a2, v146, 5u, 1);
                          PlayerSendPacket(a2, v146, 5, 1);
                          v83 = a2->lpCurrentArena;
                          v84 = 0;
                          if ( *(int *)(v83 + 65292) > 0 )
                          {
                            v85 = 64288;
                            do
                            {
                              v86 = *(_DWORD *)(v85 + v83);
                              ++v84;
                              v85 += 4;
                              *(_DWORD *)(v86 + 773) = 1;
                              v83 = a2->lpCurrentArena;
                            }
                            while ( v84 < *(_DWORD *)(v83 + 65292) );
                          }
                        }
                        else
                        {
                          ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, v146, 5, 1);
                          v87 = a2->lpCurrentArena;
                          v88 = 0;
                          if ( *(int *)(v87 + 65292) > 0 )
                          {
                            v89 = 64288;
                            do
                            {
                              v90 = *(_DWORD *)(v89 + v87);
                              ++v88;
                              v89 += 4;
                              *(_DWORD *)(v90 + 773) = 1;
                              v87 = a2->lpCurrentArena;
                            }
                            while ( v88 < *(_DWORD *)(v87 + 65292) );
                          }
                        }
                      }
                    }
                    else
                    {
                      *(_DWORD *)(a2->lpCurrentArena + 65350) = 0;
                    }
                  }
                  else if ( a6 == 5 )
                  {
                    v74 = (int)*(&PlayerArray + a7);
                    if ( v74 )
                    {
                      v75 = *(_DWORD *)(v74 + 639);
                      *(_DWORD *)(v74 + 639) = v75 == 0;
                      if ( v75 )
                        SendMessage(a2, "Player Moderator Mode OFF", 0);
                      else
                        SendMessage(a2, "Player Moderator Mode ON", 0);
                    }
                  }
                }
                else
                {
                  if ( a2 )
                    SendMessage(a2, "Recycling Server", 0);
                  bRecycleServer = 1;
                }
              }
              else
              {
                v159 = 25;
                strncpy(v165, "moderate.txt", 0x10u);
                v166 = 0;
                strncpy(&v160, "moderate.txt", 0x100u);
                v164 = 0;
                PlayerSendPacket(a2, &v159, 273, 1);
              }
            }
            else
            {
              SendMessage(a2, "File sent: moderate.txt (please wait...)", 0);
              SendFile(&a2->hProcess, "moderate.txt");
            }
          }
          else
          {
            v159 = 25;
            strncpy(&v160, "permit.txt", 0x100u);
            v164 = 0;
            strncpy(v165, "permit.txt", 0x10u);
            v166 = 0;
            PlayerSendPacket(a2, &v159, 273, 1);
          }
        }
        else
        {
          SendMessage(a2, "File sent: permit.txt (please wait...)", 0);
          SendFile(&a2->hProcess, "permit.txt");
        }
      }
      else if ( a6 == 5 )
      {
        v51 = (int)*(&PlayerArray + a7);
        if ( v51 )
        {
          v139 = *(_DWORD *)(v51 + 72) != 0;
          v137 = *(_DWORD *)(v51 + 279);
          v136 = *(_DWORD *)(v51 + 769);
          v52 = get_text_ip(*(struct in_addr *)(v51 + 755));
          sprintf(
            v154,
            "IP:%s  TimeZoneBias:%d  Freq:%d  TypedName:%s  Demo:%d",
            v52,
            v136,
            v137,
            (const char *)(v51 + 699),
            v139);
          if ( a2->bIsSysop )
            sprintf(&v154[strlen(v154)], "  MachineId:%d", *(_DWORD *)(v51 + 761));
          SendMessage(a2, v154, 0);
          v53 = a2->lpCurrentArena;
          if ( *(int *)(v53 + 109910) > 0 )
          {
            sprintf(
              v154,
              "DeathsLeft:%d  KillsNeeded:%d",
              *(_DWORD *)(v51 + 785),
              *(_DWORD *)(v53 + 109930) - *(_DWORD *)(v51 + 212));
            SendMessage(a2, v154, 0);
          }
          sprintf(
            v154,
            "Ping:%dms  LowPing:%dms  HighPing:%dms  AvePing:%dms",
            10 * *(__int16 *)(v51 + 330),
            10 * *(__int16 *)(v51 + 334),
            10 * *(__int16 *)(v51 + 336),
            10 * *(__int16 *)(v51 + 332));
          SendMessage(a2, v154, 0);
          sprintf(
            v154,
            "S2CAveLatency:%dms  C2SAveLatency:%dms",
            *(__int16 *)(v51 + 328),
            10 * *(_DWORD *)(v51 + 793) / (*(_DWORD *)(v51 + 797) + 1));
          v54 = *(_DWORD *)(v51 + 291);
          v55 = 1000;
          if ( v54 > 200 )
            v55 = 1000 * *(_DWORD *)(v51 + 295) / v54;
          v145 = 1000 - v55;
          sub_41D720(*(_DWORD *)(v51 + 40), (int)&v142, (int)&v144);
          v142 = 1000 - v142;
          v56 = *(struct CONNECTION **)(v51 + 40);
          v144 = 1000 - v144;
          v57 = GetRelAckDiff(v56, (int)&v150);
          sprintf(
            v154,
            "LOSS: S2C:%.1f%%  C2S:%.1f%%",
            (double)((long double)v142 * dbl_42A008),
            (double)((long double)v144 * dbl_42A008));
          if ( a2->bIsSysop )
            sprintf(
              &v154[strlen(v154)],
              "  S2CWeapons:%.1f%%  S2C_RelOut:%d(%d)",
              (double)((long double)v145 * dbl_42A008),
              v57,
              v150);
          SendMessage(a2, v154, 0);
          if ( a2->bIsSmod )
          {
            GetPacketCountInfoSomething(
              *(struct CONNECTION **)(v51 + 40),
              (int)&v152,
              (int)&v145,
              (int)&v147,
              (int)&v149);
            sprintf(v154, "S2C:%d-->%d  C2S:%d-->%d", v152, v149, v147, v145);
            SendMessage(a2, v154, 0);
            v58 = *(_DWORD *)(v51 + 200);
            v59 = *(_DWORD *)(v51 + 196);
            v60 = flt_42A010;
            v143 = 0.0;
            v148 = v58;
            *(_DWORD *)v146 = v59 + v58;
            if ( v59 + v58 > 0 )
              v143 = (long double)v148 * flt_42A014 / (long double)*(int *)v146;
            v61 = *(_DWORD *)(v51 + 208);
            v62 = *(_DWORD *)(v51 + 204);
            *(_DWORD *)v146 = v61;
            v148 = v62 + v61;
            if ( v62 + v61 > 0 )
              v60 = (long double)*(int *)v146 * flt_42A014 / (long double)v148;
            sprintf(
              v154,
              "C2S CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v58,
              v59,
              v143,
              v61,
              v62,
              (double)v60);
            SendMessage(a2, v154, 0);
            v63 = *(__int16 *)(v51 + 326);
            v64 = flt_42A010;
            v65 = *(__int16 *)(v51 + 324);
            v143 = 0.0;
            *(_DWORD *)v146 = v65;
            v148 = v65 + v63;
            if ( v65 + v63 > 0 )
              v143 = (long double)*(int *)v146 * flt_42A014 / (long double)v148;
            v66 = *(_DWORD *)(v51 + 320);
            v67 = *(_DWORD *)(v51 + 316);
            *(_DWORD *)v146 = v67;
            v148 = v67 + v66;
            if ( v67 + v66 > 0 )
              v64 = (long double)*(int *)v146 * flt_42A014 / (long double)v148;
            sprintf(
              v154,
              "S2C CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v65,
              v63,
              v143,
              v67,
              v66,
              (double)v64);
            SendMessage(a2, v154, 0);
          }
          v140 = *(_DWORD *)(v51 + 765);
          v68 = time(0);
          v69 = (__int64)difftime(v68, v140);
          sprintf(&v155, "TIME: Session:%5d:%02d:00", v69 / 3600, v69 / 60 % 60);
          if ( a2->bIsSysop )
          {
            v70 = v69 + *(_DWORD *)(v51 + 519);
            sprintf(
              &v155 + strlen(&v155),
              "  Total:%5d:%02d:00  Created: %d-%d-%d %02d:%02d:%02d",
              v70 / 3600,
              v70 / 60 % 60,
              *(unsigned __int16 *)(v51 + 525),
              *(unsigned __int16 *)(v51 + 527),
              *(__int16 *)(v51 + 523),
              *(unsigned __int16 *)(v51 + 529),
              *(unsigned __int16 *)(v51 + 531),
              *(unsigned __int16 *)(v51 + 533));
          }
          SendMessage(a2, &v155, 0);
          if ( a2->bIsSysop )
          {
            v71 = *(_DWORD *)(v51 + 44);
            v151[0] = "Unknown";
            v151[1] = "SlowModem";
            v151[2] = "FastModem";
            v151[3] = "UnknownModem";
            v151[4] = "UnknownNotRAS";
            v151[5] = "ISDN";
            v151[6] = &off_42EA3C;
            v151[7] = "Switch";
            v72 = "InvalidValue";
            if ( v71 < 5 )
              v72 = (const char *)v151[v71];
            sprintf(
              v154,
              "Bytes/Sec:%d  LowBandwidth:%d  MessageLogging:%d  ConnectType:%s",
              *(_DWORD *)(*(_DWORD *)(v51 + 40) + 2690),
              *(_DWORD *)(v51 + 52),
              *(_DWORD *)(v51 + 543),
              v72);
            SendMessage(a2, v154, 0);
            if ( *(int *)(a2->lpCurrentArena + 109754) > 0 )
            {
              sprintf(
                v154,
                "BEST SCORE Points:%d  Win:%d  Lose:%d",
                *(_DWORD *)(v51 + 567) + *(_DWORD *)(v51 + 571),
                *(unsigned __int16 *)(v51 + 561),
                *(unsigned __int16 *)(v51 + 563));
              SendMessage(a2, v154, 0);
            }
            v73 = *(_DWORD *)(v51 + 40);
            v143 = 0.0;
            v145 = 0;
            v149 = 0;
            v147 = 0;
            sub_41D560(v73, (int)&v143, (int)&v145);
            GetASyncS2CInfoSomething(*(struct CONNECTION **)(v51 + 40), (int)&v149, (int)&v147);
            if ( SLODWORD(v143) > 0 || v149 > 0 )
            {
              sprintf(v154, "Async C2S:%d of %d  S2C:%d of %d", v145, v143, v147, v149);
              SendMessage(a2, v154, 0);
            }
          }
        }
      }
    }
    else if ( a6 == 5 )
    {
      v50 = (int)*(&PlayerArray + a7);
      if ( v50 )
      {
        sprintf(
          v153,
          "%s: %c%d",
          (const char *)(v50 + 675),
          10 * (*(__int16 *)(v50 + 232) / 16) / 512 + 'A',
          10 * (*(__int16 *)(v50 + 228) / 16) / 512 + 1);
        SendMessage(a2, v153, 0);
      }
    }
  }
  else
  {
    v43 = *(_BYTE *)(SoccerScores + 5);
    v44 = (char *)(SoccerScores + 5);
    SoccerScores += 5;
    if ( v43 == 32 )
    {
      do
        v45 = *++v44;
      while ( v45 == 32 );
      SoccerScores = (int)v44;
    }
    if ( a2 )
    {
      v46 = (ARENA *)a2->lpCurrentArena;
      if ( v46 )
        FormatMessageArena(v46, "%s\n", v44);
    }
    if ( *v44 == 95 )
      *v44 = 32;
    v161 = a9;
    v159 = 7;
    v160 = 0;
    v162 = -1;
    strcpy(v163, v44);
    v47 = strlen(v44) + 1;
    v48 = 0;
    if ( nPlayerArray2 > 0 )
    {
      v49 = (PLAYER **)PlayerArray2;
      do
      {
        if ( (*v49)->lpCurrentArena )
          PlayerSendPacket(*v49, &v159, v47 - 1 + 6, 1);
        ++v48;
        ++v49;
      }
      while ( v48 < nPlayerArray2 );
    }
  }
  if ( _memicmp((const void *)SoccerScores, "*arena", 6u) )
  {
    if ( !_memicmp((const void *)SoccerScores, "*permit", 7u) )
    {
      v98 = *(_BYTE *)(SoccerScores + 7);
      v99 = (char *)(SoccerScores + 7);
      SoccerScores += 7;
      if ( v98 == 32 )
      {
        do
          v100 = *++v99;
        while ( v100 == 32 );
        SoccerScores = (int)v99;
      }
      if ( *v99 )
      {
        AddLineTextFile((struct TEXT_FILE_STRUCT *)dword_439E58, v99);
        WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_439E58);
        if ( !a2 )
          return;
        sprintf(v154, "Permission Added: %s", v99);
        SendMessage(a2, v154, 0);
      }
      goto exit_handler;
    }
    if ( _memicmp((const void *)SoccerScores, "*revoke", 7u) )
    {
      if ( _memicmp((const void *)SoccerScores, "*banner", 7u) || !a2 )
      {
        if ( _memicmp((const void *)SoccerScores, "*shutup", 7u) || !a2 )
        {
          if ( _memicmp((const void *)SoccerScores, "*lock", 5u) || !a2 )
          {
            if ( _memicmp((const void *)SoccerScores, "*timer", 6u) || !a2 )
            {
              if ( _memicmp((const void *)SoccerScores, "*spec", 5u) || !a2 )
              {
                if ( _memicmp((const void *)SoccerScores, "*kill", 5u) || !a2 )
                {
                  if ( _memicmp((const void *)SoccerScores, "*flagreset", 0xAu) )
                  {
                    if ( _memicmp((const void *)SoccerScores, "*shipreset", 0xAu) )
                    {
                      if ( _memicmp((const void *)SoccerScores, "*scorereset", 0xBu) )
                      {
                        if ( _memicmp((const void *)SoccerScores, "*timereset", 0xAu) )
                        {
                          if ( _memicmp((const void *)SoccerScores, "*beginlog", 9u) || !a2 )
                          {
                            if ( !_memicmp((const void *)SoccerScores, "*endlog", 7u) )
                            {
                              if ( !a2 )
                                return;
                              v130 = a2->beginlog_file_ptr;
                              if ( v130 )
                              {
                                fprintf(v130, "Name               Win  Lose  Points\n");
                                fprintf(a2->beginlog_file_ptr, "---------------- ----- ----- -------\n");
                                v131 = (ARENA *)a2->lpCurrentArena;
                                if ( v131 )
                                {
                                  v132 = 0;
                                  if ( v131->nPlayersHere > 0 )
                                  {
                                    v133 = offsetof(ARENA, PlayerArray);
                                    do
                                    {
                                      fprintf(
                                        a2->beginlog_file_ptr,
                                        "%-16.16s %5d %5d %7d\n",
                                        (const char *)(*(_DWORD *)&v131->field_0[v133] + 375),
                                        *(unsigned __int16 *)(*(_DWORD *)&v131->field_0[v133] + offsetof(PLAYER, score)),
                                        *(unsigned __int16 *)(*(_DWORD *)&v131->field_0[v133] + 0x225),
                                        *(_DWORD *)(*(_DWORD *)&v131->field_0[v133] + 0x22D)
                                      + *(_DWORD *)(*(_DWORD *)&v131->field_0[v133] + 0x229));
                                      v131 = (ARENA *)a2->lpCurrentArena;
                                      ++v132;
                                      v133 += 4;
                                    }
                                    while ( v132 < v131->nPlayersHere );
                                  }
                                }
                                fprintf(a2->beginlog_file_ptr, "\nLOG FINISHED\n");
                                fclose(a2->beginlog_file_ptr);
                                a2->beginlog_file_ptr = 0;
                                sprintf(
                                  &v155,
                                  "Logging session closed, sending file: %s",
                                  (const char *)&a2->beginlog_file_name);
                                SendMessage(a2, &v155, 0);
                                SendFile(&a2->hProcess, (char *)&a2->beginlog_file_name);
                              }
                            }
                          }
                          else
                          {
                            v126 = a2->beginlog_file_ptr;
                            v127 = (const char *)(SoccerScores + 9);
                            SoccerScores += 9;
                            if ( v126 )
                              fclose(v126);
                            v128 = rand();
                            v129 = rand();
                            sprintf(&a2->beginlog_file_name, "SS%d.log", v129 + v128);
                            a2->beginlog_file_ptr = fopen(&a2->beginlog_file_name, "wt");
                            sprintf(&v155, "Logging session to: %s", (const char *)&a2->beginlog_file_name);
                            SendMessage(a2, &v155, 0);
                            fprintf(a2->beginlog_file_ptr, "LOG STARTED:%s\n", v127);
                          }
                        }
                        else
                        {
                          if ( !a2 )
                            return;
                          v125 = a2->lpCurrentArena;
                          if ( v125 )
                          {
                            if ( *(int *)(v125 + 109754) <= 0 )
                              SendMessage(a2, "Invalid command, this is not a timed game", 0);
                            else
                              sub_405360(v125, 1);
                          }
                        }
                      }
                      else if ( a6 == 5 )
                      {
                        if ( a2 )
                          SendMessage(a2, "Player score reset", 0);
                        v124 = *(&PlayerArray + a7);
                        if ( v124 )
                          SendResetScoresPacket(v124);
                      }
                      else
                      {
                        if ( !a2 )
                          return;
                        ArenaScoreReset((struct ARENA *)a2->lpCurrentArena, 1);
                      }
                    }
                    else
                    {
                      LOBYTE(v142) = 27;
                      if ( a6 == 5 )
                      {
                        if ( a2 )
                          SendMessage(a2, "Player ship reset", 0);
                        v121 = *(&PlayerArray + a7);
                        if ( v121 )
                          PlayerSendPacket(v121, &v142, 1, 1);
                      }
                      else if ( a2 )
                      {
                        SendMessage(a2, "All ships reset", 0);
                        ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, (char *)&v142, 1, 1);
                      }
                      else
                      {
                        v122 = 0;
                        if ( nPlayerArray2 > 0 )
                        {
                          v123 = (PLAYER **)PlayerArray2;
                          do
                          {
                            if ( (*v123)->lpCurrentArena )
                              PlayerSendPacket(*v123, &v142, 1, 1);
                            ++v122;
                            ++v123;
                          }
                          while ( v122 < nPlayerArray2 );
                        }
                      }
                    }
                  }
                  else if ( a2 )
                  {
                    SendMessage(a2, "Flag game being reset", 0);
                    v118 = (struct ARENA *)a2->lpCurrentArena;
                    if ( v118 )
                      ResetFlagGame(v118);
                  }
                  else
                  {
                    v119 = 0;
                    if ( nArenas > 0 )
                    {
                      v120 = (struct ARENA **)ArenaArray;
                      do
                      {
                        ResetFlagGame(*v120);
                        ++v119;
                        ++v120;
                      }
                      while ( v119 < nArenas );
                    }
                  }
                }
                else if ( a6 == 5 )
                {
                  v113 = *(&PlayerArray + a7);
                  if ( v113 )
                  {
                    if ( a2->bIsSysop || !v113->bIsSmod )
                    {
                      v113->dwDisconnectReason = 4;
                      *(_DWORD *)&v113->field_2C[12] = 1;
                      WriteSubGameLog("Player kicked off by moderator: %s\n", v113->player_name);
                      SendMessage(a2, "Player kicked off", 0);
                      if ( *(_BYTE *)(SoccerScores + 5) == 32 )
                      {
                        v114 = atoi((const char *)(SoccerScores + 6));
                        if ( v114 > 0 )
                        {
                          v115 = dword_4399C4;
                          if ( dword_4399C4 < 1000 )
                          {
                            dword_4AD738[3 * dword_4399C4] = *(_DWORD *)v113->field_2F9;
                            v116 = 3 * v115;
                            dword_4AD73C[v116] = GetTickCount() / 0xA;
                            v117 = dword_4399C4 + 1;
                            dword_4AD740[v116] = 6000 * v114;
                            dword_4399C4 = v117;
                          }
                        }
                      }
                    }
                    else
                    {
                      SendMessage(v113, "Moderator attempted to kick you off", 0);
                    }
                  }
                }
              }
              else if ( a6 == 5 )
              {
                v111 = (int)*(&PlayerArray + a7);
                if ( v111 )
                {
                  if ( a2->bIsSysop || !*(_DWORD *)(v111 + 635) )
                  {
                    if ( *(_DWORD *)(v111 + 275) != 8 )
                      SetPlayerShip((struct PLAYER *)v111, 8);
                    v112 = *(_DWORD *)(v111 + 747);
                    *(_DWORD *)(v111 + 747) = v112 == 0;
                    if ( v112 )
                      SendMessage(a2, "Player free to enter arena", 0);
                    else
                      SendMessage(a2, "Player locked in spectator mode", 0);
                  }
                }
              }
            }
            else
            {
              v108 = *(_BYTE *)(SoccerScores + 6);
              v109 = (const char *)(SoccerScores + 6);
              SoccerScores += 6;
              if ( v108 == 32 )
              {
                do
                  v110 = *++v109;
                while ( v110 == 32 );
                SoccerScores = (int)v109;
              }
              if ( *v109 )
              {
                *(_DWORD *)(a2->lpCurrentArena + 65362) = 6000 * atoi(v109);
                *(_DWORD *)(a2->lpCurrentArena + 65370) = GetTickCount() / 0xA;
                *(_DWORD *)(a2->lpCurrentArena + 65366) = 0;
              }
            }
          }
          else if ( a2->lpCurrentArena )
          {
            if ( _memicmp((const void *)SoccerScores, "*lockpublic", 0xBu) )
            {
              if ( _memicmp((const void *)SoccerScores, "*lockteam", 9u) )
              {
                if ( _memicmp((const void *)SoccerScores, "*lockprivate", 0xCu) )
                {
                  if ( _memicmp((const void *)SoccerScores, "*lockall", 8u) )
                  {
                    if ( _memicmp((const void *)SoccerScores, "*lockspec", 9u) )
                    {
                      if ( !*(_BYTE *)(SoccerScores + 5) )
                      {
                        *(_DWORD *)(a2->lpCurrentArena + 65374) = *(_DWORD *)(a2->lpCurrentArena + 65374) == 0;
                        if ( *(_DWORD *)(a2->lpCurrentArena + 65374) )
                          SendMessage(a2, "Arena LOCKED", 0);
                        else
                          SendMessage(a2, "Arena UNLOCKED", 0);
                      }
                    }
                    else
                    {
                      *(_DWORD *)(a2->lpCurrentArena + 65590) = *(_DWORD *)(a2->lpCurrentArena + 65590) == 0;
                      if ( *(_DWORD *)(a2->lpCurrentArena + 65590) )
                        SendMessage(a2, "Message lock applies to spectators only.", 0);
                      else
                        SendMessage(a2, "Message lock applies to everybody.", 0);
                    }
                  }
                  else
                  {
                    *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
                    *(_DWORD *)(a2->lpCurrentArena + 65582) = *(_DWORD *)(a2->lpCurrentArena + 65578);
                    if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                      SendMessage(a2, "All Messages LOCKED", 0);
                    else
                      SendMessage(a2, "All Messages UNLOCKED", 0);
                  }
                }
                else
                {
                  *(_DWORD *)(a2->lpCurrentArena + 65586) = *(_DWORD *)(a2->lpCurrentArena + 65586) == 0;
                  if ( *(_DWORD *)(a2->lpCurrentArena + 65586) )
                    SendMessage(a2, "Private Messages LOCKED", 0);
                  else
                    SendMessage(a2, "Private Messages UNLOCKED", 0);
                }
              }
              else
              {
                *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
                if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                  SendMessage(a2, "Team Messages LOCKED", 0);
                else
                  SendMessage(a2, "Team Messages UNLOCKED", 0);
              }
            }
            else
            {
              *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
              if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                SendMessage(a2, "Public Messages LOCKED", 0);
              else
                SendMessage(a2, "Public Messages UNLOCKED", 0);
            }
          }
        }
        else if ( a6 == 5 )
        {
          v106 = *(&PlayerArray + a7);
          if ( v106 )
          {
            if ( v106->bIsSysop || v106->bIsSmod && !a2->bIsSysop )
            {
              sprintf(&v155, "%s tried to shut you up", a2->player_name);
              SendMessage(v106, &v155, 0);
            }
            else
            {
              v107 = v106->bIsSilenced;
              v106->bIsSilenced = v107 == 0;
              if ( v107 )
                v138 = "%s can now speak";
              else
                v138 = "%s has been silenced";
              sprintf(&v155, v138, v106->player_name);
              SendMessage(a2, &v155, 0);
            }
          }
        }
      }
      else
      {
        *(_DWORD *)&a2->field_2C[4] = 1;
        v105 = a2->field_14;
        v155 = 31;
        v156 = v105;
        qmemcpy(v157, &a2->field_18F[24], sizeof(v157));
        ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, &v155, 99, 1);
      }
      goto exit_handler;
    }
    v101 = *(_BYTE *)(SoccerScores + 7);
    v102 = (const char *)(SoccerScores + 7);
    SoccerScores += 7;
    if ( v101 == 32 )
    {
      do
        v103 = *++v102;
      while ( v103 == 32 );
      SoccerScores = (int)v102;
    }
    if ( *v102 )
    {
      if ( !strcmp(v102, (const char *)L"*") )
      {
        CleanTextFileMemory((TEXT_FILE_STRUCT *)dword_439E58);
      }
      else
      {
        v104 = (struct TEXT_FILE_STRUCT *)sub_407420(dword_439E58, (int)v102);
        if ( (int)v104 >= 0 )
          ListMachineSomething(v104, v141);
      }
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)dword_439E58);
      if ( !a2 )
        return;
      SendMessage(a2, "Permission revoked", 0);
    }
exit_handler:
    if ( a2 )
    {
      v134 = (const char *)(SoccerScores + 1);
      if ( !_strcmpi((const char *)(SoccerScores + 1), szSysopPassword) )
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", a2->player_name);
        a2->bIsSysop = 1;
        a2->bIsModerator = 1;
        a2->bIsSmod = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_SupermoderatorPassword) )
      {
        WriteSubGameLog("%s> SUPER MODERATOR LOGGED IN\n", a2->player_name);
        a2->bIsModerator = 1;
        a2->bIsSmod = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_ModeratorPassword) )
      {
        WriteSubGameLog("%s> MODERATOR LOGGED IN\n", a2->player_name);
        a2->bIsModerator = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_EnergyPassword) )
      {
        WriteSubGameLog("%s> ENERGY VIEWING TURNED ON/OFF\n", a2->player_name);
        if ( a2->lpCurrentArena )
        {
          v135 = *(_DWORD *)a2->field_44;
          *(_DWORD *)a2->field_44 = v135 == 0;
          if ( v135 )
            SendMessage(a2, "Showing Energy OFF", 0);
          else
            SendMessage(a2, "Showing Energy ON", 0);
        }
      }
    }
    return;
  }
  v93 = *(_BYTE *)(SoccerScores + 6);
  v94 = (char *)(SoccerScores + 6);
  SoccerScores += 6;
  if ( v93 == 32 )
  {
    do
      v95 = *++v94;
    while ( v95 == 32 );
    SoccerScores = (int)v94;
  }
  if ( *v94 == 95 )
    *v94 = 32;
  if ( a2 )
  {
    v96 = (ARENA *)a2->lpCurrentArena;
    if ( v96 )
      FormatMessageArena(v96, "%s\n", v94);
  }
  v161 = a9;
  v159 = 7;
  v160 = 0;
  v162 = -1;
  strcpy(v163, (const char *)SoccerScores);
  v97 = strlen((const char *)SoccerScores) + 1;
  if ( a2 )
  {
    ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, &v159, v97 + 5, 1);
    goto exit_handler;
  }
}
// 4199F8: positive sp value 1660C has been found
// 415A26: could not find valid save-restore pair for ebx
// 4179DE: conditional instruction was optimized away because of 'eax.4!=0'
// 416FCE: variable 'v141' is possibly undefined
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42A008: using guessed type double dbl_42A008;
// 42A010: using guessed type float flt_42A010;
// 42A014: using guessed type float flt_42A014;
// 42E820: using guessed type wchar_t asc_42E820[2];
// 42EA3C: using guessed type void *off_42EA3C;
// 4332F4: using guessed type int bRecycleServer;
// 4399C4: using guessed type int dword_4399C4;
// 4AD738: using guessed type int dword_4AD738[];
// 4AD73C: using guessed type int dword_4AD73C[];
// 4AD740: using guessed type int dword_4AD740[];
// 4CA230: using guessed type int PlayerArray2[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (00419A70) --------------------------------------------------------
int __userpurge sub_419A70@<eax>(int this@<ecx>, int a2@<edx>, int a3@<ebp>, char *buf, unsigned int buf_sz, BOOL bSendReliable)
{
  *(_BYTE *)(a2 + 6) = *(_DWORD *)(a3 + 1026);
  return PlayerSendPacket((PLAYER *)this, buf, buf_sz, bSendReliable);
}

//----- (00419DA0) --------------------------------------------------------
// updates the points a player has, logging if necessary
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  ARENA *v5; // ecx
  int v6[4]; // [esp+Ch] [ebp-10h] BYREF

  v3 = a3 + player->score.flag_points;
  player->score.points += a2;
  player->score.flag_points = v3;
  if ( dwMisc_LogPoints && FindMeOut1 )
  {
    v4 = pFILE_points_log;
    if ( !pFILE_points_log )
    {
      v4 = fopen("points.log", "ab");
      pFILE_points_log = v4;
    }
    v5 = (ARENA *)player->lpCurrentArena;
    if ( v5 && v5->bRecordPointsToLog )
    {
      if ( v4 )
      {
        v6[0] = player->dwUserID;
        v6[1] = a2;
        v6[2] = a3;
        v6[3] = time(0);
        fwrite(v6, 16, 1, pFILE_points_log);
      }
    }
  }
  else if ( pFILE_points_log )
  {
    fclose(pFILE_points_log);
    pFILE_points_log = 0;
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(_DWORD, _DWORD, _DWORD, _DWORD);
// 439DF8: using guessed type int dwMisc_LogPoints;
// 4D9DF8: using guessed type int pFILE_points_log;

//----- (00419E80) --------------------------------------------------------
unsigned int __cdecl LoadServerIni()
{
  DWORD v0; // edi
  int v1; // eax
  DWORD v2; // edi
  int v3; // eax
  DWORD v4; // edi
  int v5; // eax
  DWORD v6; // edi
  int v7; // eax
  DWORD v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int result; // eax
  CHAR Default[16]; // [esp+8h] [ebp-10h] BYREF

  dwCustom_ArenaMode = GetPrivateProfileIntWrapper("Custom", "ArenaMode", 0, &aServerIni);
  dwArena_ArenaMaxPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMaxPlayers", 0x3Cu, &aServerIni);
  dwArena_ArenaDesiredPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaDesiredPlayers", 0x28u, &aServerIni);
  dwArena_ArenaMinimumPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMinimumPlayers", 0xFu, &aServerIni);
  bArena_SpawnKeepScore = GetPrivateProfileIntWrapper("Arena", "SpawnKeepScores", 0, &aServerIni);
  dwArena_MaxArenas = GetPrivateProfileIntWrapper("Arena", "MaxArenas", 0x64u, &aServerIni);
  dwArena_MaxArenasMemory = GetPrivateProfileIntWrapper("Arena", "MaxArenasMemory", 0xFA00u, &aServerIni);
  dwComms_MaxQueueToLogIn = GetPrivateProfileIntWrapper("Comms", "MaxQueueToLogin", 0x10u, &aServerIni);
  *(_DWORD *)&dwComms_PacketHistoryMax = GetPrivateProfileIntWrapper("Comms", "PacketHistoryMax", 0x7D0u, &aServerIni);
  dwComms_IncomingBufferSize = GetPrivateProfileIntWrapper("Comms", "IncomingBufferSize", 0x20000u, &aServerIni);
  dwComms_OutgoingBufferSize = GetPrivateProfileIntWrapper("Comms", "OutgoingBufferSize", 0x20000u, &aServerIni);
  dwComms_TransportBufferSize = (LPCSTR)GetPrivateProfileIntWrapper("Comms", "TransportBufferSize", 0xA0u, &aServerIni);
  dwComms_EncryptMode = GetPrivateProfileIntWrapper("Comms", "EncryptMode", 1u, &aServerIni);
  dwBilling_LogMessages = GetPrivateProfileIntWrapper("Billing", "LogMessages", 0, &aServerIni);
  dwMisc_DisableShareware = GetPrivateProfileIntWrapper("Misc", "DisableSharewareNames", 0, &aServerIni);
  dwMisc_DisableSharewareShips = GetPrivateProfileIntWrapper("Misc", "DisableSharewareShips", 0, &aServerIni);
  dwMisc_DisableSharewareScores = GetPrivateProfileIntWrapper("Misc", "DisableSharewareScores", 0, &aServerIni);
  dwPermission_AllowBadMachineID = GetPrivateProfileIntWrapper("Permission", "AllowBadMachineId", 1u, &aServerIni);
  dwMisc_RegisterKickShareware = GetPrivateProfileIntWrapper("Misc", "RegisterKickShareware", 1u, &aServerIni);
  dwMisc_MaxSharewarePlayers = GetPrivateProfileIntWrapper("Misc", "MaxSharewarePlayers", 0xFFFFFFFF, &aServerIni);
  dwMisc_MaxSharewareTime = GetPrivateProfileIntWrapper("Misc", "MaxSharewareTime", 0x15F90u, &aServerIni);
  dwMisc_MaxPlayers = GetPrivateProfileIntWrapper("Misc", "MaxPlayers", 0x78u, &aServerIni);
  dwMisc_MenuKickoutDelay = GetPrivateProfileIntWrapper("Misc", "MenuKickOutDelay", 0x2EE0u, &aServerIni);
  dwMisc_LogPoints = GetPrivateProfileIntWrapper("Misc", "LogPoints", 0, &aServerIni);
  dwMisc_PointUpdateDiff = GetPrivateProfileIntWrapper("Misc", "PointUpdateDiff", 0x1F4u, &aServerIni);
  dwMisc_JackpotBroadcastPoints = GetPrivateProfileIntWrapper("Misc", "JackpotBroadcastPoints", 0, &aServerIni);
  dwMisc_ServerLog = GetPrivateProfileIntWrapper("Misc", "ServerLog", 0, &aServerIni);
  dwMisc_KeepAliveDelay = GetPrivateProfileIntWrapper("Misc", "KeepAliveDelay", 0x190u, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Misc",
    "DefaultLevelFile",
    "changeme.lvl",
    &aMisc_DefaultLevelFile,
    0x100u,
    &aServerIni);
  dwCPU_ProcessMaxTime = GetPrivateProfileIntWrapper("CPU", "ProcessMaxTime", 4u, &aServerIni);
  dwCPU_SleepPerIteration = GetPrivateProfileIntWrapper("CPU", "SleepPerIteration", 0, &aServerIni);
  dwCPU_SleepTime = GetPrivateProfileIntWrapper("CPU", "SleepTime", 0, &aServerIni);
  dwCPU_SlowIterationWarningLevel = GetPrivateProfileIntWrapper("CPU", "SlowIterationWarningLevel", 0x64u, &aServerIni);
  dwPermission_AllowLowBandwidth = GetPrivateProfileIntWrapper("Permission", "AllowLowBandwidth", 1u, &aServerIni);
  dwPermission_MininumSecondsToLogin = GetPrivateProfileIntWrapper(
                                         "Permission",
                                         "MinimumSecondsToLogin",
                                         0,
                                         &aServerIni);
  dwPermission_PermissionMaxPoints = GetPrivateProfileIntWrapper("Permission", "PermissionMaxPoints", 0, &aServerIni);
  dwPermission_PermissionMode = GetPrivateProfileIntWrapper("Permission", "PermissionMode", 0, &aServerIni);
  dword_4B061C = GetPrivateProfileIntWrapper("Permission", "AutoPermissionPoints", 0, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionIDList",
    L"0",
    lpszPermission_AutoPermissionIDList,
    0x200u,
    &aServerIni);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionMessage",
    "Congratulations",
    lpszPermission_AutoPermissionMessage,
    0x100u,
    &aServerIni);
  v0 = GetTickCount() / 0xA;
  v1 = rand();
  sprintf(Default, "%d", abs32(v0 + v1));
  GetPrivateProfileStringWrapper("Password", "SysopPassword", Default, &szSysopPassword, 0x40u, &aServerIni);
  v2 = GetTickCount() / 0xA;
  v3 = rand();
  sprintf(Default, "%d", abs32(v2 + v3));
  GetPrivateProfileStringWrapper("Password", "EnergyPassword", Default, lpszPassword_EnergyPassword, 0x40u, &aServerIni);
  v4 = GetTickCount() / 0xA;
  v5 = rand();
  sprintf(Default, "%d", abs32(v4 + v5));
  GetPrivateProfileStringWrapper(
    "Password",
    "ModeratorPassword",
    Default,
    lpszPassword_ModeratorPassword,
    0x40u,
    &aServerIni);
  v6 = GetTickCount() / 0xA;
  v7 = rand();
  sprintf(Default, "%d", abs32(v6 + v7));
  GetPrivateProfileStringWrapper(
    "Password",
    "SuperModeratorPassword",
    Default,
    lpszPassword_SupermoderatorPassword,
    0x40u,
    &aServerIni);
  v8 = GetTickCount() / 0xA;
  v9 = rand();
  sprintf(Default, "%d", abs32(v8 + v9));
  GetPrivateProfileStringWrapper("Password", "VIPPassword", Default, lpszPassword_VIPPassword, 0x40u, &aServerIni);
  GetPrivateProfileStringWrapper("Billing", "IP", "127.0.0.1", &lpszIP_Billing, 0x80u, &aServerIni);
  GetPrivateProfileStringWrapper("Billing", "Password", "money", lpsz_Billing_Password, 0x20u, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Billing",
    "ServerName",
    "Unknown",
    (LPSTR)&lpsz_Billing_ServerName,
    0x80u,
    &aServerIni);
  dwBilling_Port = GetPrivateProfileIntWrapper("Billing", "Port", 0x384u, &aServerIni);
  v10 = rand();
  dwBilling_ServerID = GetPrivateProfileIntWrapper("Billing", "ServerId", v10, &aServerIni);
  dwBilling_GroupID = GetPrivateProfileIntWrapper("Billing", "GroupId", 1u, &aServerIni);
  dwBilling_ScoreID = GetPrivateProfileIntWrapper("Billing", "ScoreId", 0, &aServerIni);
  dwBilling_ReconnectTime = GetPrivateProfileIntWrapper("Billing", "ReconnectTime", 0x2EE0u, &aServerIni);
  dwBilling_AttemptTime = GetPrivateProfileIntWrapper("Billing", "AttemptTime", 0x2710u, &aServerIni);
  dwAdvertise_SendMode = GetPrivateProfileIntWrapper("Advertise", "SendMode", 0, &aServerIni);
  dwAdvertise_DisplayMode = GetPrivateProfileIntWrapper("Advertise", "DisplayMode", 2u, &aServerIni);
  dwAdvertise_Duration = GetPrivateProfileIntWrapper("Advertise", "Duration", 0x2EE0u, &aServerIni);
  GetPrivateProfileStringWrapper("Directory", "IP", "sscentral.vie.com", lpszDirectory_IP, 0x200u, &aServerIni);
  GetPrivateProfileStringWrapper("Directory", "Description", "None", lpsz_Directory_Description, 0x100u, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Directory",
    "NamePassword",
    &::Default,
    lpszDirectory_NamePassword,
    0x80u,
    &aServerIni);
  result = GetPrivateProfileIntWrapper("Directory", "Port", 0x137Fu, &aServerIni);
  dwDirectory_Port = result;
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4327A0: using guessed type int dwAdvertise_SendMode;
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4332EC: using guessed type int dwArena_ArenaMinimumPlayers;
// 438E00: using guessed type int bArena_SpawnKeepScore;
// 438E04: using guessed type int dwPermission_AllowBadMachineID;
// 438F0C: using guessed type int dwBilling_AttemptTime;
// 438F90: using guessed type int dwComms_MaxQueueToLogIn;
// 4393A0: using guessed type int dwArena_ArenaMaxPlayers;
// 439428: using guessed type int dwMisc_MaxSharewarePlayers;
// 439DF0: using guessed type int dwBilling_Port;
// 439DF8: using guessed type int dwMisc_LogPoints;
// 439E04: using guessed type int dwCPU_SlowIterationWarningLevel;
// 439E08: using guessed type int dwArena_MaxArenasMemory;
// 439E0C: using guessed type int dwPermission_PermissionMode;
// 439E10: using guessed type int dwComms_EncryptMode;
// 439E64: using guessed type int dwMisc_MaxPlayers;
// 439E68: using guessed type int dwBilling_ReconnectTime;
// 439E6C: using guessed type int dwPermission_MininumSecondsToLogin;
// 4AD728: using guessed type int dwPermission_PermissionMaxPoints;
// 4B0618: using guessed type int dwMisc_KeepAliveDelay;
// 4B061C: using guessed type int dword_4B061C;
// 4CB234: using guessed type int dwCPU_SleepPerIteration;
// 4CB8FC: using guessed type int dwMisc_PointUpdateDiff;
// 4CBB00: using guessed type int dwBilling_LogMessages;
// 4D58B0: using guessed type int dwCustom_ArenaMode;
// 4D68BC: using guessed type int dwMisc_ServerLog;
// 4D68C4: using guessed type int dwMisc_MaxSharewareTime;
// 4D68C8: using guessed type int dwMisc_MenuKickoutDelay;
// 4D6BF0: using guessed type int dwPermission_AllowLowBandwidth;
// 4D6BF4: using guessed type int dwCPU_ProcessMaxTime;
// 4D6BF8: using guessed type int dwArena_MaxArenas;
// 4D6BFC: using guessed type int dwMisc_JackpotBroadcastPoints;
// 4D6C00: using guessed type int dwMisc_RegisterKickShareware;
// 4D6C08: using guessed type int dwMisc_DisableShareware;
// 4D6C18: using guessed type int dwArena_ArenaDesiredPlayers;
// 4D9C20: using guessed type int dwAdvertise_Duration;
// 4D9DC8: using guessed type int dwAdvertise_DisplayMode;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (0041A730) --------------------------------------------------------
void __cdecl LoadTemplateSSS()
{
  int v0; // eax
  int v1; // edi
  char *v2; // eax
  char v3; // cl
  char *i; // edx
  char v5; // cl
  char *j; // edx
  char v7; // cl
  char *k; // edx
  char v9; // cl
  char *l; // edx
  char v11; // dl
  char *m; // ecx
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  char *v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int v20; // eax
  char v21; // [esp+8h] [ebp-888h]
  char v22; // [esp+Ch] [ebp-884h]
  char v23[64]; // [esp+10h] [ebp-880h] BYREF
  char v24[64]; // [esp+50h] [ebp-840h] BYREF
  char v25[256]; // [esp+90h] [ebp-800h] BYREF
  char v26[256]; // [esp+190h] [ebp-700h] BYREF
  char v27[512]; // [esp+290h] [ebp-600h] BYREF
  char v28; // [esp+490h] [ebp-400h] BYREF
  char v29; // [esp+491h] [ebp-3FFh] BYREF

  numTemplateSSSEntriesCount = 0;
  v0 = fopen("template.sss", "rt");
  v1 = v0;
  if ( v0 )
  {
    if ( (*(_BYTE *)(v0 + 12) & 0x10) == 0 )
    {
      do
      {
        if ( fgets(&v28, 1024, v1) && (isalpha(v28) || v28 == '*' || v28 == '+') )
        {
          v24[0] = 0;
          v23[0] = 0;
          v26[0] = 0;
          v25[0] = 0;
          v27[0] = 0;
          v2 = &v28;
          v21 = 0;
          if ( v28 == '*' )
          {
            v21 = 1;
            v2 = &v29;
          }
          v22 = 1;
          if ( *v2 == '+' )
          {
            v22 = 0;
            ++v2;
          }
          v3 = *v2;
          for ( i = v24; v3 != ':'; ++v2 )
          {
            if ( !v3 )
              break;
            *i = v3;
            v3 = v2[1];
            ++i;
          }
          *i = 0;
          if ( v2 )
            ++v2;
          v5 = *v2;
          for ( j = v23; v5 != ':'; ++v2 )
          {
            if ( !v5 )
              break;
            *j = v5;
            v5 = v2[1];
            ++j;
          }
          *j = 0;
          if ( v2 )
            ++v2;
          v7 = *v2;
          for ( k = v26; v7 != ':'; ++v2 )
          {
            if ( !v7 )
              break;
            *k = v7;
            v7 = v2[1];
            ++k;
          }
          *k = 0;
          if ( v2 )
            ++v2;
          v9 = *v2;
          for ( l = v25; v9 != ':'; ++v2 )
          {
            if ( !v9 )
              break;
            *l = v9;
            v9 = v2[1];
            ++l;
          }
          *l = 0;
          if ( v2 )
            ++v2;
          v11 = *v2;
          for ( m = v27; v11 >= ' '; ++v2 )
          {
            *m = v11;
            v11 = v2[1];
            ++m;
          }
          *m = 0;
          v13 = 338 * numTemplateSSSEntriesCount;
          byte_439FC0[v13] = v21;
          byte_439FC1[v13] = v22;
          v14 = &dword_439E70[v13];
          strncpy(&dword_439E70[v13], v24, 0x20u);
          v14[31] = 0;
          v15 = &byte_439E90 + 338 * numTemplateSSSEntriesCount;
          strncpy(v15, v23, 0x28u);
          v15[39] = 0;
          v16 = &byte_439EC0 + 338 * numTemplateSSSEntriesCount;
          strncpy(v16, v27, 0x100u);
          v16[255] = 0;
          v17 = numTemplateSSSEntriesCount;
          v18 = 338 * numTemplateSSSEntriesCount;
          if ( v26[0] )
          {
            v19 = atoi(v26);
            v17 = numTemplateSSSEntriesCount;
            *(int *)((char *)&dword_439EB8 + v18) = v19;
          }
          else
          {
            *(int *)((char *)&dword_439EB8 + 338 * numTemplateSSSEntriesCount) = -999;
          }
          if ( v25[0] )
          {
            v20 = atoi(v25);
            v17 = numTemplateSSSEntriesCount;
            *(int *)((char *)&dword_439EBC + 338 * numTemplateSSSEntriesCount) = v20;
          }
          else
          {
            *(int *)((char *)&dword_439EBC + v18) = -999;
          }
          numTemplateSSSEntriesCount = v17 + 1;
        }
      }
      while ( (*(_BYTE *)(v1 + 12) & 0x10) == 0 );
    }
    fclose(v1);
  }
  printf("Template.sss read, %d entries found\n", numTemplateSSSEntriesCount);
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 439EB8: using guessed type int dword_439EB8;
// 439EBC: using guessed type int dword_439EBC;
// 4D9DD4: using guessed type int numTemplateSSSEntriesCount;

//----- (0041AA20) --------------------------------------------------------
int __cdecl sub_41AA20()
{
  int v0; // ebx
  struct BMP_FILE_STRUCT *v1; // eax
  void *v2; // eax
  int result; // eax
  int v4; // ebp
  unsigned int v5; // edx
  int i; // edi
  int j; // esi
  int v8; // ecx
  unsigned int v9; // [esp+10h] [ebp-24h] BYREF
  int v10[4]; // [esp+14h] [ebp-20h] BYREF
  char v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+30h] [ebp-4h]

  v0 = 0;
  if ( _access(&aMisc_DefaultLevelFile, 0) )
  {
    printf(
      "Could not find specified level file (%s), make sure a level file with this name is in the server directory.",
      &aMisc_DefaultLevelFile);
    exit(1);
  }
  v10[0] = 42;
  v10[1] = 0;
  v10[2] = 0;
  v10[3] = 0;
  v11 = 0;
  strcpy((char *)v10 + 1, &aMisc_DefaultLevelFile);
  dword_438DFC = (int)CompressFile(&aMisc_DefaultLevelFile, &dword_4D9DE0, &dword_4399E8, v10, 0x11u, 1, 0);
  v1 = (struct BMP_FILE_STRUCT *)operator new(0x110u);
  v9 = (unsigned int)v1;
  v12 = 0;
  if ( v1 )
    LoadBMPHeader(v1, &aMisc_DefaultLevelFile);
  else
    v2 = 0;
  v12 = -1;
  dword_439E60 = v2;
  big_global_buffer = (int)emalloc(0x100000);
  memset((void *)big_global_buffer, 0, 0x100000u);
  result = sub_406BE0((int)dword_439E60);
  v4 = result;
  if ( result > 0 )
  {
    do
    {
      GetTileValue((struct BMP_FILE_STRUCT *)dword_439E60, v0, (int *)&v9);
      result = v9;
      if ( (v9 & 0xFF000000) != -1442840576 )
      {
        *(_BYTE *)((v9 & 0xFFF) + (((v9 >> 12) & 0xFFF) << 10) + big_global_buffer) = HIBYTE(v9);
        v5 = v9;
        result = v9 & 0xFF000000;
        if ( (v9 & 0xFF000000) >= 0xD8000000 )
        {
          for ( i = 0; i < 7; ++i )
          {
            for ( j = 0; j < 7; ++j )
            {
              v8 = i + (v5 & 0xFFF);
              result = j + ((v5 >> 12) & 0xFFF);
              if ( v8 < 1024 && result < 1024 )
              {
                result = big_global_buffer + v8 + (result << 10);
                if ( !*(_BYTE *)result )
                {
                  *(_BYTE *)result = -16;
                  v5 = v9;
                }
              }
            }
          }
        }
      }
      ++v0;
    }
    while ( v0 < v4 );
  }
  return result;
}
// 41AB07: variable 'v2' is possibly undefined
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4399E8: using guessed type int dword_4399E8;
// 4D9DE0: using guessed type int dword_4D9DE0;

//----- (0041AC10) --------------------------------------------------------
void __cdecl LoadAdvertisements()
{
  int BMPImageCounter1; // esi
  HANDLE v1; // ebx
  int v2; // esi
  int v3; // edi
  int v4; // ebp
  char *v5; // ebx
  int v6; // eax
  int v7; // esi
  _BOOL1 v8; // zf
  int v9; // eax
  int v10; // eax
  int BMPImageCounter2; // esi
  HANDLE v12; // ebx
  int v13; // esi
  int v14; // edi
  int v15; // ebp
  char *v16; // ebx
  int v17; // eax
  int v18; // esi
  int v19; // eax
  int NumSharewareAdsCount; // eax
  int BMPImageCounter3; // esi
  HANDLE v22; // ebx
  int v23; // esi
  int v24; // edi
  int v25; // ebp
  char *v26; // ebx
  int v27; // eax
  int v28; // esi
  int v29; // eax
  int NumRegisteredAdsCount; // eax
  unsigned int v31; // [esp+10h] [ebp-8C0h]
  unsigned int v32; // [esp+10h] [ebp-8C0h]
  unsigned int v33; // [esp+10h] [ebp-8C0h]
  int v34; // [esp+14h] [ebp-8BCh]
  char *v35; // [esp+14h] [ebp-8BCh]
  char *v36; // [esp+14h] [ebp-8BCh]
  char *v37; // [esp+18h] [ebp-8B8h]
  int v38; // [esp+18h] [ebp-8B8h]
  int v39; // [esp+18h] [ebp-8B8h]
  int v40; // [esp+1Ch] [ebp-8B4h]
  int v41; // [esp+1Ch] [ebp-8B4h]
  int v42; // [esp+1Ch] [ebp-8B4h]
  int v43; // [esp+20h] [ebp-8B0h]
  int v44; // [esp+20h] [ebp-8B0h]
  int v45; // [esp+20h] [ebp-8B0h]
  int v46; // [esp+24h] [ebp-8ACh]
  int v47; // [esp+24h] [ebp-8ACh]
  int v48; // [esp+24h] [ebp-8ACh]
  char v49[10]; // [esp+28h] [ebp-8A8h] BYREF
  LONG lDistanceToMove; // [esp+32h] [ebp-89Eh]
  char v51[4]; // [esp+38h] [ebp-898h] BYREF
  unsigned int v52; // [esp+3Ch] [ebp-894h]
  int v53; // [esp+40h] [ebp-890h]
  CHAR FileName[128]; // [esp+50h] [ebp-880h] BYREF
  char v55[2048]; // [esp+D0h] [ebp-800h] BYREF

  BMPImageCounter1 = 0;
  highestNumSharewareAdsCount = 0;
  highestNumRegisteredAdsCount = 0;
  dword_4D9DF4 = 0;
  v43 = 0;
  do
  {
    sprintf(FileName, "b_ad%d.bmp", BMPImageCounter1);
    if ( _access(FileName, 0) )
    {
      v10 = dword_4D9DF4;
    }
    else
    {
      v1 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v1, 24, v51);
      v2 = v53;
      v31 = v52;
      v3 = 4 * ((int)(v52 + 3) / 4);
      v46 = v3;
      DeleteObject(v1);
      v4 = v31 * v2 + 10;
      v5 = (char *)emalloc(v4);
      *v5 = 48;
      v5[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v5 + 1) = v31;
      *((_WORD *)v5 + 2) = v2;
      *(_DWORD *)(v5 + 6) = dwAdvertise_Duration;
      v6 = fopen(FileName, "rb");
      v34 = v6;
      if ( v6 )
      {
        fread(v49, 1, 14, v6);
        fseek(v34, lDistanceToMove, 0);
        v7 = v2 - 1;
        if ( v7 >= 0 )
        {
          v37 = &v5[v31 * v7 + 10];
          v40 = v7 + 1;
          while ( 1 )
          {
            fread(v55, 1, v3, v34);
            qmemcpy(v37, v55, v31);
            v8 = v40 == 1;
            v37 -= v31;
            --v40;
            if ( v8 )
              break;
            v3 = v46;
          }
        }
        fclose(v34);
      }
      v9 = dword_4D9DF4;
      BMPImageCounter1 = v43;
      dword_438FA4[2 * dword_4D9DF4] = v4;
      *(&dword_438FA0 + 2 * v9) = (int)v5;
      v10 = v9 + 1;
      dword_4D9DF4 = v10;
    }
    v43 = ++BMPImageCounter1;
  }
  while ( BMPImageCounter1 < 128 );
  printf("%d both advertisements found\n", v10);
  BMPImageCounter2 = 0;
  v44 = 0;
  do
  {
    sprintf(FileName, "s_ad%d.bmp", BMPImageCounter2);
    if ( _access(FileName, 0) )
    {
      NumSharewareAdsCount = highestNumSharewareAdsCount;
    }
    else
    {
      v12 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v12, 24, v51);
      v13 = v53;
      v32 = v52;
      v14 = 4 * ((int)(v52 + 3) / 4);
      v47 = v14;
      DeleteObject(v12);
      v15 = v32 * v13 + 10;
      v16 = (char *)emalloc(v15);
      *v16 = 48;
      v16[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v16 + 1) = v32;
      *((_WORD *)v16 + 2) = v13;
      *(_DWORD *)(v16 + 6) = dwAdvertise_Duration;
      v17 = fopen(FileName, "rb");
      v38 = v17;
      if ( v17 )
      {
        fread(v49, 1, 14, v17);
        fseek(v38, lDistanceToMove, 0);
        v18 = v13 - 1;
        if ( v18 >= 0 )
        {
          v35 = &v16[v32 * v18 + 10];
          v41 = v18 + 1;
          while ( 1 )
          {
            fread(v55, 1, v14, v38);
            qmemcpy(v35, v55, v32);
            v8 = v41 == 1;
            v35 -= v32;
            --v41;
            if ( v8 )
              break;
            v14 = v47;
          }
        }
        fclose(v38);
      }
      v19 = highestNumSharewareAdsCount;
      BMPImageCounter2 = v44;
      buf_sz[2 * highestNumSharewareAdsCount] = v15;
      *(&buf + 2 * v19) = v16;
      NumSharewareAdsCount = v19 + 1;
      highestNumSharewareAdsCount = NumSharewareAdsCount;
    }
    v44 = ++BMPImageCounter2;
  }
  while ( BMPImageCounter2 < 128 );
  printf("%d shareware advertisements found\n", NumSharewareAdsCount);
  BMPImageCounter3 = 0;
  v45 = 0;
  do
  {
    sprintf(FileName, "r_ad%d.bmp", BMPImageCounter3);
    if ( _access(FileName, 0) )
    {
      NumRegisteredAdsCount = highestNumRegisteredAdsCount;
    }
    else
    {
      v22 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v22, 24, v51);
      v23 = v53;
      v33 = v52;
      v24 = 4 * ((int)(v52 + 3) / 4);
      v48 = v24;
      DeleteObject(v22);
      v25 = v33 * v23 + 10;
      v26 = (char *)emalloc(v25);
      *v26 = 48;
      v26[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v26 + 1) = v33;
      *((_WORD *)v26 + 2) = v23;
      *(_DWORD *)(v26 + 6) = dwAdvertise_Duration;
      v27 = fopen(FileName, "rb");
      v39 = v27;
      if ( v27 )
      {
        fread(v49, 1, 14, v27);
        fseek(v39, lDistanceToMove, 0);
        v28 = v23 - 1;
        if ( v28 >= 0 )
        {
          v36 = &v26[v33 * v28 + 10];
          v42 = v28 + 1;
          while ( 1 )
          {
            fread(v55, 1, v24, v39);
            qmemcpy(v36, v55, v33);
            v8 = v42 == 1;
            v36 -= v33;
            --v42;
            if ( v8 )
              break;
            v24 = v48;
          }
        }
        fclose(v39);
      }
      v29 = highestNumRegisteredAdsCount;
      BMPImageCounter3 = v45;
      dword_432AAC[2 * highestNumRegisteredAdsCount] = v25;
      *(&dword_432AA8 + 2 * v29) = (int)v26;
      NumRegisteredAdsCount = v29 + 1;
      highestNumRegisteredAdsCount = NumRegisteredAdsCount;
    }
    v45 = ++BMPImageCounter3;
  }
  while ( BMPImageCounter3 < 128 );
  printf("%d registered advertisements found\n", NumRegisteredAdsCount);
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 4D9C20: using guessed type int dwAdvertise_Duration;
// 4D9DC8: using guessed type int dwAdvertise_DisplayMode;
// 4D9DEC: using guessed type int highestNumSharewareAdsCount;
// 4D9DF0: using guessed type int highestNumRegisteredAdsCount;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0041B150) --------------------------------------------------------
void __cdecl CleanUpMemory()
{
  int v0; // esi
  LPVOID *v1; // edi
  int v2; // edi
  LPVOID *v3; // esi
  int v4; // edi
  LPVOID *v5; // esi

  v0 = 0;
  if ( highestNumRegisteredAdsCount > 0 )
  {
    v1 = (LPVOID *)&dword_432AA8;
    do
    {
      if ( *v1 )
        efree(*v1);
      ++v0;
      v1 += 2;
    }
    while ( v0 < highestNumRegisteredAdsCount );
  }
  v2 = 0;
  highestNumRegisteredAdsCount = 0;
  if ( highestNumSharewareAdsCount > 0 )
  {
    v3 = &buf;
    do
    {
      if ( *v3 )
        efree(*v3);
      ++v2;
      v3 += 2;
    }
    while ( v2 < highestNumSharewareAdsCount );
  }
  v4 = 0;
  highestNumSharewareAdsCount = 0;
  if ( dword_4D9DF4 > 0 )
  {
    v5 = (LPVOID *)&dword_438FA0;
    do
    {
      if ( *v5 )
        efree(*v5);
      ++v4;
      v5 += 2;
    }
    while ( v4 < dword_4D9DF4 );
  }
  dword_4D9DF4 = 0;
}
// 4D9DEC: using guessed type int highestNumSharewareAdsCount;
// 4D9DF0: using guessed type int highestNumRegisteredAdsCount;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0041B200) --------------------------------------------------------
int __cdecl InitWinsock()
{
  struct WSAData WSAData; // [esp+0h] [ebp-190h] BYREF

  return WSAStartup(0x101u, &WSAData);
}

//----- (0041B230) --------------------------------------------------------
int *__thiscall setup_stuff_and_socket(int *this, int lpfnNewConnectionRequest, int lpfnOnEachPacket, int a4, int a5, int dwSendBufSz, int dwRecvBufSz, int optval)
{
  int v9; // eax
  void *v10; // edi
  int v11; // eax
  int v12; // edi
  char *v13; // eax
  _DWORD *v14; // ecx
  int v15; // edx
  void *v16; // edi
  int v17; // ecx
  int v18; // eax
  SOCKET v19; // eax
  u_short v20; // cx
  SOCKET v22; // [esp-14h] [ebp-34h]
  SOCKET v23; // [esp-14h] [ebp-34h]
  SOCKET v24; // [esp-14h] [ebp-34h]
  u_long argp; // [esp+Ch] [ebp-14h] BYREF
  struct sockaddr name; // [esp+10h] [ebp-10h] BYREF

  v9 = optval + 5;
  this[11] = optval + 5;
  this[12] = 0;
  v10 = emalloc(540 * v9);
  v11 = this[11];
  this[10] = (int)v10;
  memset(v10, 0, 4 * ((unsigned int)(540 * v11) >> 2));
  *this = lpfnNewConnectionRequest;
  this[8] = 0;
  this[8980] = 0;
  this[1] = lpfnOnEachPacket;
  this[3] = a4;
  this[2] = a5;
  this[8979] = GetTickCount() / 0xA;
  this[9] = 500;
  this[8975] = 0;
  this[8976] = 0;
  this[8977] = 0;
  this[8978] = 0;
  this[4] = 0;
  memset(this + 13, 0, 0x8C00u);
  v12 = this[3];
  this[8974] = 0;
  this[8973] = 0;
  v13 = (char *)operator new(3190 * v12);
  if ( v13 )
  {
    if ( v12 - 1 >= 0 )
    {
      v14 = v13 + 50;
      v15 = v12;
      do
      {
        *v14 = 0;
        v14 = (_DWORD *)((char *)v14 + 3190);
        --v15;
      }
      while ( v15 );
    }
    v16 = v13;
  }
  else
  {
    v16 = 0;
  }
  v17 = this[3];
  this[5] = (int)v16;
  memset(v16, 0, 3190 * v17);
  v18 = this[3];
  this[8982] = 0;
  this[8981] = (int)emalloc(4 * v18);
  v19 = socket(AF_INET, SOCK_DGRAM, 0);
  this[6] = v19;
  argp = 1;
  ioctlsocket(v19, -2147195266, &argp);
  v22 = this[6];
  optval = -1;
  setsockopt(v22, 6, SO_DEBUG, (const char *)&optval, 4);
  v23 = this[6];
  optval = dwSendBufSz;
  setsockopt(v23, 0xFFFF, SO_SNDBUF, (const char *)&optval, 4);
  v24 = this[6];
  optval = dwRecvBufSz;
  setsockopt(v24, 0xFFFF, SO_RCVBUF, (const char *)&optval, 4);
  v20 = *((_WORD *)this + 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(v20);
  *(_DWORD *)&name.sa_data[2] = ntohl(0);
  bind(this[6], &name, 16);
  return this;
}
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);

//----- (0041B440) --------------------------------------------------------
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment)
{
  int v2; // ebx
  int i; // esi
  int v4; // ebx
  LPVOID *v5; // esi

  v2 = 0;
  for ( i = *((_DWORD *)packetAttachment + 5); v2 < *((_DWORD *)packetAttachment + 3); i += 3190 )
  {
    if ( *(_DWORD *)(i + 50) )
      sub_41C360(i);
    ++v2;
  }
  closesocket(*((_DWORD *)packetAttachment + 6));
  operator delete(*((void **)packetAttachment + 5));
  v4 = 0;
  if ( *((int *)packetAttachment + 8974) > 0 )
  {
    v5 = (LPVOID *)((char *)packetAttachment + 180);
    do
    {
      if ( *v5 )
      {
        efree(*v5);
        *v5 = 0;
      }
      ++v4;
      v5 += 35;
    }
    while ( v4 < *((_DWORD *)packetAttachment + 8974) );
  }
  efree(*((LPVOID *)packetAttachment + 8981));
  efree(*((LPVOID *)packetAttachment + 10));
}

//----- (0041B4E0) --------------------------------------------------------
int __thiscall sub_41B4E0(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(this + 32) = a2;
  return result;
}

//----- (0041B4F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
Encryption_Struct *__thiscall SomethingBillerServer(struct_v9 *this, struct_v9 *name, const char *hostshort, u_short EncryptionRNGSeed, signed int a5, int retstr)
{
  struct_v9 *v6; // edi
  int v8; // ebp
  struct hostent *v9; // eax
  int v10; // ecx
  int v11; // edi
  _DWORD *v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // edi
  int v17; // ecx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v22; // [esp-10h] [ebp-2Ch]
  int v23; // [esp-Ch] [ebp-28h]
  int v24; // [esp-4h] [ebp-20h]
  int v25; // [esp+10h] [ebp-Ch] BYREF
  __int16 v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+16h] [ebp-6h]

  v6 = name;
  v8 = inet_addr((const char *)name);
  if ( v8 == -1 )
  {
    v9 = gethostbyname((const char *)v6);
    if ( !v9 )
      return 0;
    v8 = **(_DWORD **)v9->h_addr_list;
  }
  v10 = *((_DWORD *)this + 3);
  v11 = 0;
  if ( v10 <= 0 )
  {
LABEL_8:
    v11 = -1;
  }
  else
  {
    v12 = (_DWORD *)(*((_DWORD *)this + 5) + 50);
    while ( *v12 )
    {
      ++v11;
      v12 = (_DWORD *)((char *)v12 + 3190);
      if ( v11 >= v10 )
        goto LABEL_8;
    }
  }
  if ( v11 == -1 )
    return 0;
  v24 = a5;
  v13 = *((_DWORD *)this + 5) + 3190 * v11;
  v23 = EncryptionRNGSeed;
  LOWORD(v14) = ntohs((u_short)hostshort);
  encrypt_init((char *)v13, (int)this, 1, v11, v8, v14, v23, 1, v24);
  v15 = *((_DWORD *)this + 8982);
  v16 = 0;
  if ( v15 )
  {
    v17 = *(_DWORD *)v13;
    v26 = *(_WORD *)(v13 + 4);
    v25 = v17;
    v22 = v15;
    v18 = *((_DWORD *)this + 8981);
    v27 = *(_DWORD *)(v13 + 46);
    v19 = BinarySearch((int)&v25, v18, v22, 4, DifferentCompareFunction, (unsigned int *)&name);
    v20 = *((_DWORD *)this + 8981);
    v16 = (v19 - v20) >> 2;
    memcpy(
      (void *)(v20 + 4 * v16 + 4),
      (const void *)(v20 + 4 * v16),
      4 * (*((_DWORD *)this + 8982) + 0x3FFFFFFF * v16));
  }
  *(_DWORD *)(*((_DWORD *)this + 8981) + 4 * v16) = v13;
  ++*((_DWORD *)this + 8982);
  return (Encryption_Struct *)v13;
}
// 41B569: inconsistent variable size for '^48.2(EncryptionRNGSeed)'
// 41B4F0: inconsistent function type and number of purged bytes

//----- (0041B620) --------------------------------------------------------
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ebp
  int v6; // edx
  int v7; // ecx
  int v8; // esi
  int v9; // edi
  struct in_addr *v10; // ebp
  const char *v11; // eax
  int v12; // [esp+0h] [ebp-4h]
  int v13; // [esp+8h] [ebp+4h]

  v3 = fopen(Filename, "wt");
  v12 = v3;
  if ( v3 )
  {
    v4 = *((_DWORD *)packetAttachment + 11);
    v5 = 0;
    v13 = 0;
    if ( v4 > 0 )
    {
      do
      {
        v6 = (*((_DWORD *)packetAttachment + 12) + v5) % v4;
        v7 = *((_DWORD *)packetAttachment + 10);
        v8 = 540 * v6;
        v9 = *(__int16 *)(v7 + 540 * v6 + 536);
        if ( v9 > 0 )
        {
          v10 = (struct in_addr *)(v7 + 540 * v6);
          v11 = inet_ntoa(v10[133]);
          fprintf(v12, "%16s,%5d %3d: ", v11, *(__int16 *)(*((_DWORD *)packetAttachment + 10) + v8 + 538), v9);
          do
          {
            fprintf(v12, "%02x ", v10->S_un.S_un_b.s_b1);
            v10 = (struct in_addr *)((char *)v10 + 1);
            --v9;
          }
          while ( v9 );
          fprintf(v12, (const char *)L"\n");
          v5 = v13;
        }
        v4 = *((_DWORD *)packetAttachment + 11);
        v13 = ++v5;
      }
      while ( v5 < v4 );
      v3 = v12;
    }
    fclose(v3);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (0041B700) --------------------------------------------------------
Packet *__thiscall PlayerReadPackets(struct_v9 *this, int lpdwBytesRead, int a3, int a4)
{
  int v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  Packet *result; // eax
  int v13; // [esp+8h] [ebp-14h] BYREF
  char v14[2]; // [esp+Ch] [ebp-10h] BYREF
  __int16 v15; // [esp+Eh] [ebp-Eh]
  int v16; // [esp+10h] [ebp-Ch]

  v5 = *((_DWORD *)this + 12);
  v6 = *(_DWORD *)CONTAINING_RECORD(this, PLAYER, field_4)->field_2C;
  v13 = 16;
  v7 = 540 * v5;
  v8 = ((int (__stdcall *)(_DWORD, int, int, _DWORD, char *, int *))HackedRecvFrom)(
         *((_DWORD *)this + 6),
         540 * v5 + v6,
         512,
         0,
         v14,
         &v13);
  v9 = v8;
  if ( v8 == -1 )
    return 0;
  *(_WORD *)(*((_DWORD *)this + 0xA) + v7 + 536) = v8;
  v10 = *((_DWORD *)this + 0xA);
  *((_DWORD *)this + 12) = (*((_DWORD *)this + 12) + 1) % *((_DWORD *)this + 0xB);
  *(_DWORD *)(v10 + v7 + 532) = v16;
  *(_WORD *)(*((_DWORD *)this + 0xA) + v7 + 538) = v15;
  *(_DWORD *)a3 = v16;
  *(_WORD *)a4 = v15;
  *(_DWORD *)lpdwBytesRead = v9;
  v11 = *((_DWORD *)this + 8978);
  *((_DWORD *)this + 8977) += v9;
  result = (Packet *)(v7 + *((_DWORD *)this + 0xA));
  *((_DWORD *)this + 8978) = v11 + 1;
  return result;
}
// 415840: invalid function type has been ignored

//----- (0041B7D0) --------------------------------------------------------
#error "41B8C4: call analysis failed (funcsize=121)"

//----- (0041B930) --------------------------------------------------------
void __userpurge PlayerHandlePacket(PLAYER *p@<ecx>, BYTE *packet, DWORD dwBytesRead, DWORD dwIPAddress, int wSrcPort, int a6, int a7, int a8, int a9, int a10)
{
  int v11; // eax
  int *v12; // eax
  int v13; // ebp
  unsigned int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  _DWORD *v20; // eax
  DWORD v21; // kr00_4
  unsigned int v22; // eax
  unsigned int v23; // [esp-4h] [ebp-38h]
  unsigned int v24; // [esp+20h] [ebp-14h] BYREF
  DWORD v25; // [esp+28h] [ebp-Ch] BYREF
  __int16 v26; // [esp+2Ch] [ebp-8h]
  int v27; // [esp+2Eh] [ebp-6h]
  int v28; // [esp+38h] [ebp+4h]

  v25 = dwIPAddress;
  v11 = *(_DWORD *)&p[27].field_2C[1];
  v26 = wSrcPort;
  v23 = *(int *)((char *)&p[27].lpNetworkData + 1);
  v27 = -1;
  v12 = (int *)BinarySearch((int)&v25, v23, v11, 4, DifferentCompareFunction, &v24);
  if ( v24 )
    v13 = *v12;
  else
    v13 = 0;
  if ( *packet || packet[1] != 1 )
  {
    if ( v13 )
    {
      v21 = GetTickCount();
      ++*(_DWORD *)(v13 + 2670);
      v22 = *(_DWORD *)(v13 + 66);
      *(_DWORD *)(v13 + 58) = v21 / 0xA;
      if ( v22 >= 0x10 )
        sub_415870(v13, (int)packet, dwBytesRead, dwIPAddress, wSrcPort, a6, a7, a8, a9, a10);
      else
        sub_415920(v13, (int)packet, dwBytesRead, dwIPAddress, wSrcPort);
    }
    return;
  }
  v28 = 0;
  if ( (int)dwBytesRead >= 8 )
    v28 = *((__int16 *)packet + 3);
  if ( v28 != 1 )
    goto LABEL_9;
  v16 = *(_DWORD *)p->lpArenaPointer2;
  if ( v16 )
  {
    v17 = v16 - 1;
    if ( !v17 )
    {
      v15 = abs32(*(_DWORD *)(packet + 2));
      goto LABEL_15;
    }
    if ( v17 == 1 )
    {
LABEL_9:
      v15 = -abs32(*(_DWORD *)(packet + 2));
LABEL_15:
      *(_DWORD *)(packet + 2) = v15;
    }
  }
  if ( v13 && *(_DWORD *)(v13 + 62) == *(_DWORD *)(packet + 2) )
  {
    lpfnFixExport11(&v24, v13, *(_DWORD *)(packet + 2));
  }
  else
  {
    v18 = *(_DWORD *)&p->field_4[8];
    v19 = 0;
    if ( v18 <= 0 )
    {
LABEL_23:
      v19 = -1;
    }
    else
    {
      v20 = (_DWORD *)(*(_DWORD *)&p->field_14 + 50);
      while ( *v20 )
      {
        ++v19;
        v20 = (_DWORD *)((char *)v20 + 3190);
        if ( v19 >= v18 )
          goto LABEL_23;
      }
    }
    if ( v19 != -1 )
    {
      if ( p->hProcess )
        sub_415850(
          (char *)(*(_DWORD *)&p->field_14 + 3190 * v19),
          (int)packet,
          *(_DWORD *)&p->field_14 + 3190 * v19,
          v28,
          dwBytesRead,
          dwIPAddress,
          wSrcPort);
    }
  }
}
// 42EEB8: using guessed type int (__thiscall *lpfnFixExport11)(_DWORD, _DWORD, _DWORD);

//----- (0041BC40) --------------------------------------------------------
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5)
{
  void (__cdecl *v6)(char *, int, struct CONNECTION *); // eax
  char *v7; // ebp
  int v8; // ecx
  char *v9; // esi
  char *v10; // edi

  v6 = (void (__cdecl *)(char *, int, struct CONNECTION *))*((_DWORD *)packetAttachment + 1);
  if ( v6 )
  {
    v7 = buffer;
    v6(buffer, packetLength, encryption);
  }
  else
  {
    *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 46) = packetLength;
    *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 47) = encryption;
    if ( a5 )
    {
      v7 = buffer;
      a5 = 0;
      *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = buffer;
    }
    else
    {
      v7 = buffer;
      if ( (unsigned int)packetLength >= 0x80 )
      {
        *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = emalloc(packetLength);
        v8 = packetLength;
        v9 = buffer;
        v10 = (char *)*((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45);
      }
      else
      {
        v8 = packetLength;
        v9 = buffer;
        *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = 0;
        v10 = (char *)packetAttachment + 140 * *((_DWORD *)packetAttachment + 8974) + 52;
      }
      qmemcpy(v10, v9, v8);
    }
    ++*((_DWORD *)packetAttachment + 8974);
  }
  if ( a5 )
    efree(v7);
}

//----- (0041BD80) --------------------------------------------------------
#error "41BEDB: call analysis failed (funcsize=170)"

//----- (0041BFA0) --------------------------------------------------------
int __thiscall sub_41BFA0(int this)
{
  int result; // eax

  result = 0;
  *(_DWORD *)(this + 35900) = 0;
  *(_DWORD *)(this + 35904) = 0;
  *(_DWORD *)(this + 35908) = 0;
  *(_DWORD *)(this + 35912) = 0;
  *(_DWORD *)(this + 16) = 0;
  return result;
}

//----- (0041BFC0) --------------------------------------------------------
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls)
{
  *TotalPacketSendLength = *((_DWORD *)packetAttachment + 8975);
  *TotalPacketRecvLength = *((_DWORD *)packetAttachment + 8977);
  *TotalPacketSendCalls = *((_DWORD *)packetAttachment + 8976);
  *TotalPacketRecvCalls = *((_DWORD *)packetAttachment + 8978);
  *TotalPacketClustersCalls = *((_DWORD *)packetAttachment + 4);
}

//----- (0041C000) --------------------------------------------------------
#error "41C06A: call analysis failed (funcsize=51)"

//----- (0041C0B0) --------------------------------------------------------
#error "41C11A: call analysis failed (funcsize=46)"

//----- (0041C150) --------------------------------------------------------
int __cdecl DifferentCompareFunction(int connection, int ConnectionsArray)
{
  unsigned int *v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  int v5; // edx

  v2 = *(unsigned int **)ConnectionsArray;
  v3 = **(_DWORD **)ConnectionsArray;
  if ( *(_DWORD *)connection > v3 )
    return 1;
  if ( *(_DWORD *)connection < v3 )
    return -1;
  v5 = *(_DWORD *)(connection + 6);
  result = *(unsigned __int16 *)(connection + 4) - *((unsigned __int16 *)v2 + 2);
  if ( v5 != -1 && !result )
    result = v5 - *(unsigned int *)((char *)v2 + 46);
  return result;
}

//----- (0041C1A0) --------------------------------------------------------
int __thiscall encrypt_init(char *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v10; // ecx
  _WORD *v11; // edi
  int result; // eax
  int v13; // [esp+20h] [ebp+14h]

  *(_DWORD *)(this + 66) = a8;
  *(_DWORD *)(this + 42) = a2;
  *(_DWORD *)(this + 50) = a3;
  *(_DWORD *)(this + 46) = a4;
  *(_DWORD *)this = a5;
  v10 = a7;
  *((_WORD *)this + 2) = a6;
  *(_DWORD *)(this + 6) = a9;
  *(_DWORD *)(this + 10) = 9999999;
  *(_DWORD *)(this + 14) = 0;
  *(_DWORD *)(this + 18) = 0;
  *(_DWORD *)(this + 22) = 0;
  *(_DWORD *)(this + 26) = 0;
  *(_DWORD *)(this + 30) = 0;
  *(_DWORD *)(this + 34) = 0;
  *(_DWORD *)(this + 38) = 0;
  *(_DWORD *)(this + 62) = a7;
  v11 = this + 70;
  v13 = 260;
  do
  {
    v10 = 16807 * (v10 % 127773) - 2836 * (v10 / 127773) + 123;
    if ( v10 <= 0 )
      v10 += 0x7FFFFFFF;
    *v11++ = v10;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)(this + 54) = 0;
  *(_DWORD *)(this + 58) = GetTickCount() / 0xA;
  *(_DWORD *)(this + 54) = GetTickCount() / 0xA;
  *(_DWORD *)(this + 590) = 0;
  *(_DWORD *)(this + 594) = 0;
  *(_DWORD *)(this + 2690) = 0;
  *(_DWORD *)(this + 2694) = 0;
  *(_DWORD *)(this + 2698) = 0;
  *(_DWORD *)(this + 2702) = GetTickCount() / 0xA;
  *(_DWORD *)(this + 598) = 0;
  *(_DWORD *)(this + 602) = 0;
  *(_DWORD *)(this + 606) = 0;
  *(_DWORD *)(this + 614) = 0;
  *(_DWORD *)(this + 610) = 0;
  memset(this + 618, 0, 0x400u);
  memset(this + 1642, 0, 0x400u);
  *(_DWORD *)(this + 2682) = 1000;
  *(_DWORD *)(this + 2686) = 1000;
  *(_DWORD *)(this + 3090) = this + 2706;
  result = 0;
  *(_DWORD *)(this + 2666) = 0;
  *(_DWORD *)(this + 2670) = 0;
  *(_DWORD *)(this + 2674) = 0;
  *(_DWORD *)(this + 2678) = 0;
  memset(this + 3094, 0, 0x50u);
  *(_DWORD *)(this + 3174) = 0;
  *(_DWORD *)(this + 3178) = 0;
  *(_DWORD *)(this + 3182) = 0;
  *(_DWORD *)(this + 3186) = 0;
  return result;
}

//----- (0041C360) --------------------------------------------------------
#error "41C3A1: call analysis failed (funcsize=138)"

//----- (0041C510) --------------------------------------------------------
int __thiscall sub_41C510(int this)
{
  return *(_DWORD *)(this + 50);
}

//----- (0041C520) --------------------------------------------------------
int __thiscall sub_41C520(int this)
{
  return *(_DWORD *)(this + 66);
}

//----- (0041C530) --------------------------------------------------------
// NetworkData.GetRelAckDiff()
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = *(_DWORD *)((char *)encryption + 614);
  return CONTAINING_RECORD(encryption, NETDATA, field_0)->current_ack
       - CONTAINING_RECORD(encryption, NETDATA, field_0)->pending_ack;
}

//----- (0041C560) --------------------------------------------------------
// NetworkData.WriteToNetwork
void __userpurge WriteToNetwork(int a1@<ecx>, char *buf, int len, int a4, int a5, int a6, int a7, int a8, int a9, char a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62)
{
  int v63; // ebp
  _BOOL1 v64; // cc
  char *v65; // eax
  int v66; // esi
  char *v67; // edx
  int v68; // ecx
  int v69; // esi
  int v70; // edi
  char *v71; // eax
  int v72; // esi
  char *v73; // edx
  int v74; // ecx
  int v75; // esi
  int v76; // edi
  DWORD v77; // kr00_4
  int v78; // ecx
  int v79; // eax
  __int64 v80; // rax
  int v81; // ecx
  int v82; // edi
  int v83; // edx
  _DWORD *v84; // edi
  __int16 v85; // cx
  int v86; // eax
  SOCKET v87; // [esp-24h] [ebp-43Ch]
  char v88; // [esp+7h] [ebp-411h]
  struct sockaddr to; // [esp+8h] [ebp-410h] BYREF
  char v90; // [esp+18h] [ebp-400h] BYREF
  char v91; // [esp+19h] [ebp-3FFh] BYREF
  char v92[1022]; // [esp+1Ah] [ebp-3FEh] BYREF

  if ( *(_DWORD *)(a1 + 50) != 4 )
  {
    v63 = *(_DWORD *)(a1 + 62);
    if ( *(_DWORD *)(a1 + 66) >= 0x10u )
    {
      sub_4158A0(
        a1,
        (int)buf,
        (int)buf,
        len,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14,
        a15,
        a16,
        a17,
        a18,
        a19,
        a20,
        a21,
        a22,
        a23,
        a24,
        a25,
        a26,
        a27,
        a28,
        a29,
        a30,
        a31,
        a32,
        a33,
        a34,
        a35,
        a36,
        a37,
        a38,
        a39,
        a40,
        a41,
        a42,
        a43,
        a44,
        a45,
        a46,
        a47,
        a48,
        a49,
        a50,
        a51,
        a52,
        a53,
        a54,
        a55,
        a56,
        a57,
        a58,
        a59,
        a60,
        a61,
        a62);
    }
    else
    {
      v88 = *buf;
      if ( *buf )
      {
LABEL_7:
        qmemcpy(&v90, buf, len);
        if ( v88 )
        {
          v71 = &v91;
          v72 = a1 + 70;
          v73 = &v91 + 4 * ((unsigned int)(len + 2) >> 2);
          v74 = v63;
          if ( &v91 != v73 )
          {
            v75 = v72 - (_DWORD)&v91;
            do
            {
              v76 = *(_DWORD *)&v71[v75];
              v71 += 4;
              v74 ^= v76 ^ *((_DWORD *)v71 - 1);
              *((_DWORD *)v71 - 1) = v74;
            }
            while ( v71 != v73 );
          }
        }
        else
        {
          v65 = v92;
          v66 = a1 + 70;
          v67 = &v92[4 * ((unsigned int)(len + 1) >> 2)];
          v68 = v63;
          if ( v92 != v67 )
          {
            v69 = v66 - (_DWORD)v92;
            do
            {
              v70 = *(_DWORD *)&v65[v69];
              v65 += 4;
              v68 ^= v70 ^ *((_DWORD *)v65 - 1);
              *((_DWORD *)v65 - 1) = v68;
            }
            while ( v65 != v67 );
          }
        }
        buf = &v90;
      }
      else
      {
        v64 = buf[1] <= 2;
        while ( !v64 )
        {
          v64 = v63 <= 0;
          if ( v63 > 0 )
            goto LABEL_7;
        }
      }
      v77 = GetTickCount();
      v78 = *(_DWORD *)(a1 + 2666) + 1;
      v79 = len + *(_DWORD *)(a1 + 2694);
      *(_DWORD *)(a1 + 54) = v77 / 0xA;
      *(_DWORD *)(a1 + 2666) = v78;
      *(_DWORD *)(a1 + 2694) = v79;
      v80 = (int)(*(_DWORD *)(a1 + 2702) - GetTickCount() / 0xA);
      v81 = (HIDWORD(v80) ^ v80) - HIDWORD(v80);
      if ( v81 >= 100 )
      {
        v82 = *(_DWORD *)(a1 + 2694);
        v83 = *(_DWORD *)(a1 + 2698);
        *(_DWORD *)(a1 + 2698) = v82;
        *(_DWORD *)(a1 + 2690) = 100 * (v82 - v83) / v81;
        *(_DWORD *)(a1 + 2702) = GetTickCount() / 0xA;
      }
      v84 = *(_DWORD **)(a1 + 42);
      v85 = *(_WORD *)(a1 + 4);
      *(_DWORD *)&to.sa_data[2] = *(_DWORD *)a1;
      *(_WORD *)to.sa_data = v85;
      v87 = v84[6];
      to.sa_family = 2;
      sendto(v87, buf, len, 0, &to, 16);
      v86 = v84[8976] + 1;
      v84[8975] += len;
      v84[8976] = v86;
    }
  }
}
// 41C560: using guessed type char var_3FE[1022];

//----- (0041C730) --------------------------------------------------------
void __thiscall NetDataHandleCorePacket(NETDATA *nd, void *packet, int packet_sz, int a4)
{
  int v5; // ecx
  void *v6; // esi
  int v7; // edi
  int v8; // ecx
  char *v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int i; // esi
  int v22; // eax
  int v23; // ebx
  __int16 v24; // di
  _WORD *v25; // eax
  DWORD v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rax
  int v32; // edi
  char *v33; // esi
  void *v34; // eax
  int v35; // edi
  char *v36; // esi
  void *v37; // eax
  char *v38; // esi
  char *v39; // ebx
  int v40; // edx
  char *v41; // esi
  char *v42; // edi
  char buf[2]; // [esp+10h] [ebp-Ch] BYREF
  int v44; // [esp+12h] [ebp-Ah]

  v5 = *(_DWORD *)&nd->field_0[50];
  if ( v5 == 4 )
  {
LABEL_12:
    v6 = packet;
    goto free_ptr_return;
  }
  v6 = packet;
  if ( !*(_BYTE *)packet )
  {
    v7 = packet_sz;
    if ( packet_sz <= 1 )
      goto free_ptr_return;
    switch ( *((_BYTE *)packet + 1) )
    {
      case 2:
        if ( v5 != 1 )
          goto free_ptr_return;
        v8 = *(_DWORD *)((char *)packet + 2);
        if ( abs32(*(_DWORD *)&nd->field_0[62]) != abs32(v8) )
          goto free_ptr_return;
        *(_DWORD *)&nd->field_0[62] = v8;
        v9 = &nd->field_0[70];
        v10 = 260;
        do
        {
          v8 = 16807 * (v8 % 127773) - 2836 * (v8 / 127773) + 123;
          if ( v8 <= 0 )
            v8 += 0x7FFFFFFF;
          *(_WORD *)v9 = v8;
          v9 += 2;
          --v10;
        }
        while ( v10 );
        *(_DWORD *)&nd->field_0[50] = 2;
        break;
      case 3:
        if ( (unsigned int)packet_sz < 6 )
          goto free_ptr_return;
        v16 = *(_DWORD *)((char *)packet + 2);
        buf[1] = 4;
        v44 = v16;
        buf[0] = 0;
        SendPacketCluster((struct CONNECTION *)nd, buf, 6u);
        v17 = *(_DWORD *)((char *)packet + 2);
        if ( v17 > *(_DWORD *)&nd->field_0[602] )
          *(_DWORD *)&nd->field_0[602] = v17;
        v18 = *(_DWORD *)((char *)packet + 2);
        v19 = *(_DWORD *)&nd->field_0[598];
        if ( v19 > v18 )
          goto free_ptr_return;
        if ( v19 == v18 )
        {
          NetDataHandleCorePacket(nd, (char *)packet + 6, v7 - 6, 0);
          v20 = *(_DWORD *)&nd->field_0[598] + 1;
          *(_DWORD *)&nd->field_0[598] = v20;
          for ( i = ((v20 >> 31) ^ (unsigned __int8)abs32(v20)) - (v20 >> 31);
                *(_DWORD *)&nd->field_266[4 * i + 4];
                i = ((v22 >> 31) ^ (unsigned __int8)abs32(v22)) - (v22 >> 31) )
          {
            NetDataHandleCorePacket(
              nd,
              (void *)(*(_DWORD *)&nd->field_266[4 * i + 4] + 2),
              **(__int16 **)&nd->field_266[4 * i + 4],
              0);
            efree(*(LPVOID *)&nd->field_266[4 * i + 4]);
            *(_DWORD *)&nd->field_266[4 * i + 4] = 0;
            v22 = *(_DWORD *)&nd->field_0[598] + 1;
            *(_DWORD *)&nd->field_0[598] = v22;
          }
        }
        else
        {
          v23 = ((v18 >> 31) ^ (unsigned __int8)abs32(v18)) - (v18 >> 31);
          if ( !*(_DWORD *)&nd->field_266[4 * v23 + 4] )
          {
            v24 = v7 - 6;
            v25 = emalloc(v24 + 2);
            *(_DWORD *)&nd->field_266[4 * v23 + 4] = v25;
            *v25 = v24;
            qmemcpy((void *)(*(_DWORD *)&nd->field_266[4 * v23 + 4] + 2), (char *)packet + 6, v24);
          }
        }
        break;
      case 4:
        if ( (unsigned int)packet_sz < 6 )
          goto free_ptr_return;
        v11 = *(_DWORD *)((char *)packet + 2);
        if ( nd->pending_ack > v11 || v11 >= nd->current_ack )
          goto free_ptr_return;
        v12 = ((v11 >> 31) ^ (unsigned __int8)abs32(v11)) - (v11 >> 31);
        v13 = *(_DWORD *)&nd->field_266[4 * v12 + 1028];
        if ( v13 )
        {
          *(_DWORD *)nd->field_266 -= *(__int16 *)(v13 + 4);
          efree(*(LPVOID *)&nd->field_266[4 * v12 + 1028]);
          *(_DWORD *)&nd->field_266[4 * v12 + 1028] = 0;
          v14 = nd->current_ack;
          if ( nd->pending_ack < v14 )
          {
            do
            {
              v15 = nd->pending_ack;
              if ( *(_DWORD *)&nd->field_266[4 * (((v15 >> 31) ^ (unsigned __int8)abs32(v15)) - (v15 >> 31)) + 1028] )
                break;
              nd->pending_ack = v15 + 1;
            }
            while ( v15 + 1 < v14 );
          }
        }
        break;
      case 5:
        JUMPOUT(0x4159F0);
      case 6:
        v26 = GetTickCount() / 0xA;
        v27 = *(_DWORD *)&nd->field_0[30];
        v28 = v26 - *(_DWORD *)((char *)packet + 2);
        ++*(_DWORD *)&nd->field_0[26];
        v29 = *(_DWORD *)&nd->field_0[34];
        *(_DWORD *)&nd->field_0[30] = v28 + v27;
        if ( !v29 || v28 < v29 )
          *(_DWORD *)&nd->field_0[34] = v28;
        if ( v28 > *(_DWORD *)&nd->field_0[38] )
          *(_DWORD *)&nd->field_0[38] = v28;
        if ( v28 <= *(_DWORD *)&nd->field_0[10] + 1
          || (v30 = (int)(GetTickCount() / 0xA - *(_DWORD *)&nd->field_0[22]),
              (int)((HIDWORD(v30) ^ v30) - HIDWORD(v30)) > 12000) )
        {
          if ( v28 < 2 * *(_DWORD *)&nd->field_0[10]
            || (v31 = (int)(GetTickCount() / 0xA - *(_DWORD *)&nd->field_0[22]),
                (int)((HIDWORD(v31) ^ v31) - HIDWORD(v31)) > 60000) )
          {
            *(_DWORD *)&nd->field_0[14] = *(_DWORD *)((char *)packet + 6)
                                        + v28 * (1000 - *(_DWORD *)(*(_DWORD *)&nd->field_0[42] + 36)) / 1000
                                        - v26;
            *(_DWORD *)&nd->field_0[22] = GetTickCount() / 0xA;
            *(_DWORD *)&nd->field_0[10] = v28;
          }
        }
        goto LABEL_12;
      case 7:
        *(_DWORD *)&nd->field_0[50] = 4;
        goto free_ptr_return;
      case 8:
      case 9:
        JUMPOUT(0x415970);
      case 0xA:
        JUMPOUT(0x4158E0);
      case 0xB:
        v32 = 0;
        if ( *(int *)&nd->field_A36[560] > 0 )
        {
          v33 = &nd->field_A36[480];
          do
          {
            if ( *((_DWORD *)v33 + 3) )
              efree(*(LPVOID *)v33);
            ++v32;
            v33 += 20;
          }
          while ( v32 < *(_DWORD *)&nd->field_A36[560] );
          v6 = packet;
        }
        v34 = (void *)nd->lpIncTransferData;
        *(_DWORD *)&nd->field_A36[560] = 0;
        if ( v34 )
          efree(v34);
        nd->lpIncTransferData = 0;
        nd->dwIncTransferSize = 0;
        nd->dwIncTransferBytesRcvd = 0;
        LOWORD(packet_sz) = 3072;
        WriteData((struct CONNECTION *)nd, &packet_sz, 2u, 1);
        goto free_ptr_return;
      case 0xC:
        v35 = 0;
        if ( *(int *)&nd->field_A36[560] > 0 )
        {
          v36 = &nd->field_A36[480];
          do
          {
            if ( *((_DWORD *)v36 + 3) )
              efree(*(LPVOID *)v36);
            ++v35;
            v36 += 20;
          }
          while ( v35 < *(_DWORD *)&nd->field_A36[560] );
          v6 = packet;
        }
        v37 = (void *)nd->lpIncTransferData;
        *(_DWORD *)&nd->field_A36[560] = 0;
        if ( v37 )
          efree(v37);
        nd->lpIncTransferData = 0;
        nd->dwIncTransferSize = 0;
        nd->dwIncTransferBytesRcvd = 0;
        goto free_ptr_return;
      case 0xE:
        v38 = (char *)packet + 2;
        v39 = (char *)packet + packet_sz;
        while ( 1 )
        {
          v40 = (unsigned __int8)*v38;
          v41 = v38 + 1;
          v42 = &v41[v40];
          if ( &v41[v40] > v39 )
            break;
          NetDataHandleCorePacket(nd, v41, v40, 0);
          v38 = v42;
        }
        goto LABEL_12;
      default:
        goto free_ptr_return;
    }
    goto LABEL_12;
  }
  ProcessRegularPackets(
    *(struct PACKET_ATTACHMENT **)&nd->field_0[42],
    (char *)packet,
    packet_sz,
    (struct CONNECTION *)nd,
    a4);
  a4 = 0;
free_ptr_return:
  if ( a4 )
    efree(v6);
}
// 41C773: control flows out of bounds to 4158E0
// 41C773: control flows out of bounds to 415970
// 41C773: control flows out of bounds to 4159F0

//----- (0041CE60) --------------------------------------------------------
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // edx
  __int64 v5; // rax
  int v6; // eax
  DWORD v7; // kr00_4
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ebx
  int v12; // ecx
  unsigned int v13; // eax
  int v14; // eax
  signed int v15; // ebx
  DWORD v16; // esi
  int v17; // ecx
  signed int v18; // edi
  int v19; // ebx
  int i; // edi
  int v21; // ecx
  int v22; // [esp+0h] [ebp-220h]
  int v23; // [esp+4h] [ebp-21Ch]
  int v24; // [esp+8h] [ebp-218h]
  int v25; // [esp+Ch] [ebp-214h]
  long double buf; // [esp+10h] [ebp-210h] BYREF
  _WORD v27[3]; // [esp+1Ah] [ebp-206h]
  __int64 v28; // [esp+20h] [ebp-200h] BYREF
  int v29; // [esp+28h] [ebp-1F8h]
  int v30; // [esp+2Ch] [ebp-1F4h]
  int v31; // [esp+30h] [ebp-1F0h]
  int v32; // [esp+34h] [ebp-1ECh]
  int v33; // [esp+38h] [ebp-1E8h]
  int v34; // [esp+3Ch] [ebp-1E4h]
  int v35; // [esp+40h] [ebp-1E0h]
  int v36; // [esp+44h] [ebp-1DCh]
  int v37; // [esp+48h] [ebp-1D8h]
  int v38; // [esp+4Ch] [ebp-1D4h]
  int v39; // [esp+50h] [ebp-1D0h]
  int v40; // [esp+54h] [ebp-1CCh]
  int v41; // [esp+58h] [ebp-1C8h]
  int v42; // [esp+5Ch] [ebp-1C4h]
  int v43; // [esp+60h] [ebp-1C0h]
  int v44; // [esp+64h] [ebp-1BCh]
  int v45; // [esp+68h] [ebp-1B8h]
  int v46; // [esp+6Ch] [ebp-1B4h]
  int v47; // [esp+70h] [ebp-1B0h]
  int v48; // [esp+74h] [ebp-1ACh]
  int v49; // [esp+78h] [ebp-1A8h]
  int v50; // [esp+7Ch] [ebp-1A4h]
  int v51; // [esp+80h] [ebp-1A0h]
  int v52; // [esp+84h] [ebp-19Ch]
  int v53; // [esp+88h] [ebp-198h]
  int v54; // [esp+8Ch] [ebp-194h]
  int v55; // [esp+90h] [ebp-190h]
  int v56; // [esp+94h] [ebp-18Ch]
  int v57; // [esp+98h] [ebp-188h]
  int v58; // [esp+9Ch] [ebp-184h]
  int v59; // [esp+A0h] [ebp-180h]
  int v60; // [esp+A4h] [ebp-17Ch]
  int v61; // [esp+A8h] [ebp-178h]
  int v62; // [esp+ACh] [ebp-174h]
  int v63; // [esp+B0h] [ebp-170h]
  int v64; // [esp+B4h] [ebp-16Ch]
  int v65; // [esp+B8h] [ebp-168h]
  int v66; // [esp+BCh] [ebp-164h]
  int v67; // [esp+C0h] [ebp-160h]
  int v68; // [esp+C4h] [ebp-15Ch]
  int v69; // [esp+C8h] [ebp-158h]
  int v70; // [esp+CCh] [ebp-154h]
  int v71; // [esp+D0h] [ebp-150h]
  int v72; // [esp+D4h] [ebp-14Ch]
  int v73; // [esp+D8h] [ebp-148h]
  int v74; // [esp+DCh] [ebp-144h]
  int v75; // [esp+E0h] [ebp-140h]
  int v76; // [esp+E4h] [ebp-13Ch]
  int v77; // [esp+E8h] [ebp-138h]

  v2 = *(_DWORD *)((char *)connection + 50);
  if ( v2 == 1 )
  {
    v3 = (int)(GetTickCount() / 0xA - *(_DWORD *)((char *)connection + 54));
    if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 100 )
    {
      v4 = *(_DWORD *)((char *)connection + 62);
      LOWORD(buf) = 256;
      *(_DWORD *)((char *)&buf + 2) = v4;
      WORD3(buf) = 1;
      WriteToNetwork(
        (int)connection,
        (char *)&buf,
        8,
        v22,
        v23,
        v24,
        v25,
        SLODWORD(buf),
        SDWORD1(buf),
        SBYTE8(buf),
        *(int *)&v27[1],
        v28,
        SHIDWORD(v28),
        v29,
        v30,
        v31,
        v32,
        v33,
        v34,
        v35,
        v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        v49,
        v50,
        v51,
        v52,
        v53,
        v54,
        v55,
        v56,
        v57,
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v64,
        v65,
        v66,
        v67,
        v68,
        v69,
        v70,
        v71,
        v72,
        v73,
        v74,
        v75,
        v76,
        v77);
    }
  }
  else if ( v2 == 2 )
  {
    if ( *(_DWORD *)((char *)connection + 6) )
    {
      if ( (v5 = (int)(GetTickCount() / 0xA - *(_DWORD *)((char *)connection + 18)),
            v6 = (HIDWORD(v5) ^ v5) - HIDWORD(v5),
            v6 > 2000)
        || v6 > 500 && *(int *)((char *)connection + 10) > 300
        || v6 > 50 && *(int *)((char *)connection + 10) > 1000 )
      {
        *(_DWORD *)((char *)connection + 18) = GetTickCount() / 0xA;
        LOWORD(buf) = 1280;
        v7 = GetTickCount();
        v8 = *(_DWORD *)((char *)connection + 2670);
        *(_DWORD *)((char *)&buf + 2) = v7 / 0xA;
        *(_DWORD *)((char *)&buf + 6) = *(_DWORD *)((char *)connection + 2666) + 1;
        v27[1] = HIWORD(v8);
        WriteToNetwork(
          (int)connection,
          (char *)&buf,
          14,
          v22,
          v23,
          v24,
          v25,
          SLODWORD(buf),
          SDWORD1(buf),
          SBYTE8(buf),
          *(int *)&v27[1],
          v28,
          SHIDWORD(v28),
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          v68,
          v69,
          v70,
          v71,
          v72,
          v73,
          v74,
          v75,
          v76,
          v77);
      }
    }
    while ( *(int *)((char *)connection + 3174) > 0 )
    {
      v9 = *(_DWORD *)((char *)connection + 614);
      if ( v9 >= 2048
        || *(_DWORD *)((char *)connection + offsetof(NETDATA, current_ack))
         - *(_DWORD *)((char *)connection + offsetof(NETDATA, pending_ack)) >= 128
        || *(_DWORD *)((char *)connection + 3110) && v9 > 256 )
      {
        break;
      }
      v10 = *(_DWORD *)((char *)connection + 3102);
      *(_DWORD *)((char *)&v28 + 2) = *(_DWORD *)((char *)connection + 3098);
      LOWORD(v28) = 2560;
      v11 = 480;
      if ( *(_DWORD *)((char *)&v28 + 2) - v10 <= 480 )
        v11 = *(_DWORD *)((char *)&v28 + 2) - v10;
      qmemcpy(
        (char *)&v28 + 6,
        (const void *)(*(_DWORD *)((char *)connection + 3102) + *(_DWORD *)((char *)connection + 3094)),
        v11);
      WriteData(connection, &v28, v11 + 6, 1);
      v12 = *(_DWORD *)((char *)connection + 3098);
      v13 = v11 + *(_DWORD *)((char *)connection + 3102);
      *(_DWORD *)((char *)connection + 3102) = v13;
      if ( v13 == v12 )
      {
        if ( *(_DWORD *)((char *)connection + 3106) )
          efree(*(LPVOID *)((char *)connection + 3094));
        v14 = *(_DWORD *)((char *)connection + 3174) - 1;
        *(_DWORD *)((char *)connection + 3174) = v14;
        memcpy((char *)connection + 3094, (char *)connection + 3114, 20 * v14);
      }
    }
    if ( *(_DWORD *)((char *)connection + 610) < *(_DWORD *)((char *)connection + 606) )
    {
      LODWORD(buf) = 0;
      v15 = 90;
      v16 = GetTickCount() / 0xA;
      v17 = *(_DWORD *)((char *)connection
                      + 4
                      * (((*(int *)((char *)connection + 610) >> 31) ^ (unsigned __int8)abs32(*(_DWORD *)((char *)connection + 610)))
                       - (*(int *)((char *)connection + 610) >> 31))
                      + 1642);
      v18 = *(__int16 *)(v17 + 4);
      if ( v18 > 256 )
        v15 = 170;
      if ( (int)abs32(v16 - *(_DWORD *)v17) <= v15 )
      {
        v19 = LODWORD(buf);
      }
      else
      {
        *(_DWORD *)v17 = v16;
        SendPacketCluster(connection, (const void *)(v17 + 6), v18);
        v19 = 1;
      }
      for ( i = *(_DWORD *)((char *)connection + 610) + 1; i < *(_DWORD *)((char *)connection + 606); ++i )
      {
        if ( v19 >= 3 )
          break;
        v21 = *(_DWORD *)((char *)connection + 4 * (((i >> 31) ^ (unsigned __int8)abs32(i)) - (i >> 31)) + 1642);
        if ( v21 )
        {
          if ( (int)abs32(v16 - *(_DWORD *)v21) > 200 )
          {
            *(_DWORD *)v21 = v16;
            SendPacketCluster(connection, (const void *)(v21 + 6), *(__int16 *)(v21 + 4));
          }
          ++v19;
        }
      }
    }
  }
}
// 41CEBC: variable 'v22' is possibly undefined
// 41CEBC: variable 'v23' is possibly undefined
// 41CEBC: variable 'v24' is possibly undefined
// 41CEBC: variable 'v25' is possibly undefined

//----- (0041D190) --------------------------------------------------------
// NetworkData.WriteData()
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4)
{
  unsigned int v4; // edi
  signed int v6; // esi
  unsigned int v7; // ebp
  int v9; // esi
  DWORD *v10; // eax
  DWORD *v11; // ebp
  DWORD v12; // edx
  _WORD *v13; // ebp
  char *v14; // ebp
  int v15; // edx
  signed int i; // [esp+10h] [ebp-1FCh]
  unsigned int v17; // [esp+10h] [ebp-1FCh]
  bool v18; // [esp+14h] [ebp-1F8h]
  char bufa[2]; // [esp+18h] [ebp-1F4h] BYREF
  char v20[498]; // [esp+1Ah] [ebp-1F2h] BYREF

  v4 = len;
  if ( (int)len > 496 )
  {
    v6 = 0;
    for ( i = 0; ; v6 = i )
    {
      v7 = v4 - v6;
      if ( (int)(v4 - v6) >= 480 )
        v7 = 480;
      bufa[1] = (v7 == v4 - v6) + 8;
      bufa[0] = 0;
      qmemcpy(v20, (char *)buf + v6, v7);
      if ( !WriteData(encryptionn, bufa, v7 + 2, 1) )
        break;
      i += v7;
      if ( i >= (int)len )
        return 1;
      v4 = len;
    }
    return 0;
  }
  if ( a4 )
  {
    if ( CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack
       - CONTAINING_RECORD(encryptionn, NETDATA, field_0)->pending_ack >= 255 )
      return 0;
    v18 = *(_DWORD *)((char *)encryptionn + 614) < 4096;
    v17 = len + 6;
    v9 = ((CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack >> 31) ^ (unsigned __int8)abs32(CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack))
       - (CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack >> 31);
    v10 = (DWORD *)emalloc(len + 12);
    *(_DWORD *)((char *)encryptionn + 4 * v9 + 1642) = v10;
    v11 = v10;
    if ( v18 )
      v12 = GetTickCount() / 0xA;
    else
      v12 = 0;
    *v11 = v12;
    v13 = v11 + 1;
    *v13 = v17;
    v14 = (char *)(v13 + 1);
    *v14 = 0;
    v14[1] = 3;
    *(_DWORD *)(v14 + 2) = *(_DWORD *)((char *)encryptionn + offsetof(NETDATA, current_ack));
    qmemcpy(v14 + 6, buf, len);
    v15 = *(_DWORD *)((char *)encryptionn + offsetof(NETDATA, current_ack)) + 1;
    *(_DWORD *)((char *)encryptionn + 614) += v17;
    *(_DWORD *)((char *)encryptionn + 606) = v15;
    if ( v18 )
      SendPacketCluster(encryptionn, v14, v17);
  }
  else
  {
    SendPacketCluster(encryptionn, buf, len);
  }
  return 1;
}
// 41D1B7: conditional instruction was optimized away because of '%arg_4.4>=1F1'

//----- (0041D370) --------------------------------------------------------
// Player.LogReliablePackets()
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename)
{
  char *v2; // edi
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // edi
  unsigned __int8 *v7; // esi

  v2 = (char *)encryption;
  v3 = fopen(Filename, "wt");
  if ( v3 )
  {
    v4 = *(_DWORD *)(v2 + offsetof(NETDATA, pending_ack));
    if ( v4 < *(_DWORD *)(v2 + offsetof(NETDATA, current_ack)) )
    {
      do
      {
        v5 = *(_DWORD *)&v2[4 * (((v4 >> 31) ^ (unsigned __int8)abs32(v4)) - (v4 >> 31)) + 1642];
        if ( v5 )
        {
          v6 = *(__int16 *)(v5 + 4);
          fprintf(v3, "%10d %4d: ", *(_DWORD *)v5, v6);
          v7 = (unsigned __int8 *)(v5 + 6);
          if ( v6 > 0 )
          {
            do
            {
              fprintf(v3, "%02x ", *v7++);
              --v6;
            }
            while ( v6 );
          }
          fprintf(v3, (const char *)L"\n");
          v2 = (char *)encryption;
        }
        else
        {
          fprintf(v3, "Acknowledged\n");
        }
        ++v4;
      }
      while ( v4 < *(_DWORD *)(v2 + 606) );
    }
    fclose(v3);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (0041D440) --------------------------------------------------------
signed int __thiscall sub_41D440(int this, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = *(_DWORD *)(this + 3174);
  if ( v4 >= 4 )
    return sub_41D4C3(a2, a3, a4);
  *(_DWORD *)(this + 20 * v4 + 3094) = a2;
  *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3098) = a3;
  *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3102) = 0;
  *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3106) = 1;
  *(_DWORD *)(this + 20 * (*(_DWORD *)(this + 3174))++ + 3110) = a4;
  SendBiDirectionalCorePackets((struct CONNECTION *)this);
  return 1;
}
// 41D4C3: using guessed type int __stdcall sub_41D4C3(int, int, int);

//----- (0041D4C3) --------------------------------------------------------
int __stdcall sub_41D4C3(int a1, int a2, int a3)
{
  return 0;
}
// 41D4C3: using guessed type int __stdcall sub_41D4C3(int, int, int);

//----- (0041D4D0) --------------------------------------------------------
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4)
{
  int v4; // eax

  v4 = *(_DWORD *)((char *)encryption + 3174);
  if ( v4 < 4 )
  {
    *(_DWORD *)((char *)encryption + 20 * v4 + 3094) = a2;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3098) = a3;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3102) = 0;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3106) = 0;
    *(_DWORD *)((char *)encryption + 20 * (*(_DWORD *)((char *)encryption + 3174))++ + 3110) = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041D560) --------------------------------------------------------
int __thiscall sub_41D560(int this, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)a2 = *(_DWORD *)(this + 3182);
  result = *(_DWORD *)(this + 3186);
  *(_DWORD *)a3 = result;
  return result;
}

//----- (0041D580) --------------------------------------------------------
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart)
{
  if ( *(int *)((char *)encryption + 3174) <= 0 )
  {
    *(_DWORD *)ASyncS2CEnd = 0;
    *(_DWORD *)ASyncS2CStart = 0;
  }
  else
  {
    *(_DWORD *)ASyncS2CEnd = *(_DWORD *)((char *)encryption + 3098);
    *(_DWORD *)ASyncS2CStart = *(_DWORD *)((char *)encryption + 3102);
  }
}

//----- (0041D5C0) --------------------------------------------------------
int __thiscall sub_41D5C0(int this)
{
  return *(_DWORD *)(this + 3174);
}

//----- (0041D5D0) --------------------------------------------------------
#error "41D6C0: call analysis failed (funcsize=84)"

//----- (0041D6D0) --------------------------------------------------------
#error "41D70B: call analysis failed (funcsize=26)"

//----- (0041D720) --------------------------------------------------------
int __thiscall sub_41D720(int this, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)a2 = *(_DWORD *)(this + 2682);
  result = *(_DWORD *)(this + 2686);
  *(_DWORD *)a3 = result;
  return result;
}

//----- (0041D740) --------------------------------------------------------
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a2 = *(_DWORD *)((char *)this + 2666);
  *(_DWORD *)a3 = *(_DWORD *)((char *)this + 2670);
  *(_DWORD *)a4 = *(_DWORD *)((char *)this + 2674);
  *(_DWORD *)a5 = *(_DWORD *)((char *)this + 2678);
}

//----- (0041D780) --------------------------------------------------------
void __thiscall sub_41D780(int this)
{
  *(_DWORD *)(this + 50) = 4;
}

//----- (0041D790) --------------------------------------------------------
char *__cdecl get_text_ip(struct in_addr in)
{
  return inet_ntoa(in);
}

//----- (0041D7A0) --------------------------------------------------------
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename)
{
  char *v2; // eax
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = this;
  v2 = CompressFile(Filename, &v4, (int *)&Filename, 0, 0, 0, 0);
  if ( v2 )
    efree(v2);
  return (int)Filename;
}
// 41D7A0: inconsistent function type and number of purged bytes

//----- (0041D7E0) --------------------------------------------------------
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize)
{
  unsigned int v7; // edi
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // edi
  char *result; // eax
  int v12; // eax
  unsigned int v13; // ebx
  char *v14; // esi
  void *v15; // edi
  void *v16; // ebp
  unsigned int v17; // [esp+0h] [ebp-Ch]
  _DWORD *v18; // [esp+4h] [ebp-8h]
  void *memory; // [esp+8h] [ebp-4h]
  const void *retaddr; // [esp+Ch] [ebp+0h]

  v18 = v8;
  v17 = v7;
  v9 = fopen(Filename, "rb");
  v10 = v9;
  if ( v9 )
  {
    v12 = _fileno(v9);
    v13 = _filelength(v12);
    v14 = (char *)emalloc(v13);
    memory = v14;
    fread(v14, v13, 1, v10);
    fclose(v10);
    if ( FileSize )
      *(_DWORD *)FileSize = v13;
    if ( CRC_32 )
      *CRC_32 = CRC32(v14, v13);
    if ( DoFileCompression )
    {
      FileSize = (int)(4 * v13) / 3 + 12;
      v15 = ExpandMemory(0, FileSize, 1);
      if ( compress(v15, &FileSize, v14, v13) )
      {
        efree(v15);
        memory = 0;
      }
      else
      {
        v17 = (unsigned int)CRC_32;
        memory = ExpandMemory(v15, (int)CRC_32, 1);
      }
      *v18 = &Filename[v17];
      v16 = emalloc((int)&Filename[v17]);
      if ( retaddr )
        qmemcpy(v16, retaddr, (unsigned int)Filename);
      qmemcpy((void *)&Filename[(_DWORD)v16], memory, v17);
      efree(memory);
    }
    else
    {
      *OutSize = v13 + bytes;
      v16 = emalloc(v13 + bytes);
      if ( Buffer )
        qmemcpy(v16, Buffer, bytes);
      qmemcpy((char *)v16 + bytes, v14, v13);
    }
    efree(memory);
    result = (char *)v16;
  }
  else
  {
    if ( CRC_32 )
      *CRC_32 = 0;
    if ( FileSize )
      *(_DWORD *)FileSize = 0;
    *OutSize = bytes;
    result = (char *)emalloc(bytes);
    if ( Buffer )
      qmemcpy(result, Buffer, bytes);
  }
  return result;
}
// 41D7E0: could not find valid save-restore pair for edi
// 41D7E0: could not find valid save-restore pair for esi
// 41D7E5: variable 'v8' is possibly undefined
// 41D7E6: variable 'v7' is possibly undefined
// 41D9E0: using guessed type int __cdecl compress(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (0041DA50) --------------------------------------------------------
int __cdecl srand(int a1)
{
  int result; // eax

  result = a1;
  rand_seed = a1;
  return result;
}
// 42F744: using guessed type int rand_seed;

//----- (0041F4F0) --------------------------------------------------------
char *__cdecl RunCommandPrompt(char *argumentsPointer)
{
  char *result; // eax
  const char *v2; // eax
  int v3[4]; // [esp+0h] [ebp-10h] BYREF

  result = getenv("COMSPEC");
  v3[0] = (int)result;
  if ( argumentsPointer )
  {
    v3[1] = (int)"/c";
    v3[2] = (int)argumentsPointer;
    v3[3] = 0;
    if ( !result
      || (result = (char *)_spawnve(0, result, v3, 0), result == (char *)-1)
      && (dword_4D9E28 == 2 || dword_4D9E28 == 13) )
    {
      v2 = "command.com";
      if ( (dword_4D9E34 & 0x8000) == 0 )
        v2 = "cmd.exe";
      v3[0] = (int)v2;
      result = (char *)_spawnvpe(0, v2, v3, 0);
    }
  }
  else if ( result )
  {
    result = (char *)(_access(result, 0) == 0);
  }
  return result;
}
// 4234E0: using guessed type _DWORD __cdecl _spawnvpe(_DWORD, _DWORD, _DWORD, _DWORD);
// 4236D0: using guessed type _DWORD __cdecl _spawnve(_DWORD, char *, _DWORD, _DWORD);
// 4D9E28: using guessed type int dword_4D9E28;
// 4D9E34: using guessed type int dword_4D9E34;

//----- (00422060) --------------------------------------------------------
void sub_422060()
{
  _DWORD v1[8]; // [esp-Ch] [ebp-24h] BYREF
  int v2; // [esp+14h] [ebp-4h]

  v1[7] = &unk_42A128;
  v1[6] = unknown_libname_5;
  v1[5] = __readfsdword(0);
  v1[3] = v1;
  v2 = 0;
  if ( dword_4D9ECC )
  {
    v2 = 1;
    dword_4D9ECC();
    v2 = 0;
  }
  v2 = -1;
  sub_4220CE();
}
// 425408: using guessed type int __cdecl unknown_libname_5(int, int, int);
// 4D9ECC: using guessed type int (*dword_4D9ECC)(void);

//----- (004220CE) --------------------------------------------------------
// attributes: thunk
void __cdecl sub_4220CE()
{
  abort();
}

//----- (004220F0) --------------------------------------------------------
void sub_4220F0()
{
  _DWORD v1[8]; // [esp-Ch] [ebp-24h] BYREF
  int v2; // [esp+14h] [ebp-4h]

  v1[7] = &unk_42A140;
  v1[6] = unknown_libname_5;
  v1[5] = __readfsdword(0);
  v1[3] = v1;
  v2 = 0;
  if ( off_42FA24 )
  {
    v2 = 1;
    off_42FA24();
    v2 = 0;
  }
  v2 = -1;
  sub_42215E();
}
// 425408: using guessed type int __cdecl unknown_libname_5(int, int, int);
// 42FA24: using guessed type int (*off_42FA24)(void);

//----- (0042215E) --------------------------------------------------------
// attributes: thunk
void sub_42215E()
{
  sub_422060();
}

//----- (00423F40) --------------------------------------------------------
bool __cdecl DateFunction(int a1)
{
  bool result; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp-28h] [ebp-30h]
  int v6; // [esp-24h] [ebp-2Ch]
  int v7; // [esp-20h] [ebp-28h]
  int v8; // [esp-1Ch] [ebp-24h]
  int v9; // [esp-18h] [ebp-20h]
  int v10; // [esp-14h] [ebp-1Ch]

  if ( !dword_431C8C )
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 != dword_431D20 || v2 != dword_431D30 )
  {
    if ( dword_4D9F08 )
    {
      if ( stru_4D9F10.DaylightDate.wYear )
      {
        v10 = stru_4D9F10.DaylightDate.wDay;
        v9 = 0;
        v8 = 0;
        v7 = stru_4D9F10.DaylightDate.wMonth;
        v6 = *(_DWORD *)(a1 + 20);
        v5 = 0;
      }
      else
      {
        v10 = 0;
        v9 = stru_4D9F10.DaylightDate.wDayOfWeek;
        v8 = stru_4D9F10.DaylightDate.wDay;
        v7 = stru_4D9F10.DaylightDate.wMonth;
        v6 = *(_DWORD *)(a1 + 20);
        v5 = 1;
      }
      cvtdate(
        1,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        stru_4D9F10.DaylightDate.wHour,
        stru_4D9F10.DaylightDate.wMinute,
        stru_4D9F10.DaylightDate.wSecond,
        stru_4D9F10.DaylightDate.wMilliseconds);
      if ( stru_4D9F10.StandardDate.wYear )
        cvtdate(
          0,
          0,
          *(_DWORD *)(a1 + 20),
          stru_4D9F10.StandardDate.wMonth,
          0,
          0,
          stru_4D9F10.StandardDate.wDay,
          stru_4D9F10.StandardDate.wHour,
          stru_4D9F10.StandardDate.wMinute,
          stru_4D9F10.StandardDate.wSecond,
          stru_4D9F10.StandardDate.wMilliseconds);
      else
        cvtdate(
          0,
          1,
          *(_DWORD *)(a1 + 20),
          stru_4D9F10.StandardDate.wMonth,
          stru_4D9F10.StandardDate.wDay,
          stru_4D9F10.StandardDate.wDayOfWeek,
          0,
          stru_4D9F10.StandardDate.wHour,
          stru_4D9F10.StandardDate.wMinute,
          stru_4D9F10.StandardDate.wSecond,
          stru_4D9F10.StandardDate.wMilliseconds);
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate(0, 1, *(_DWORD *)(a1 + 20), 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = *(_DWORD *)(a1 + 28);
  if ( dword_431D24 < dword_431D34 )
  {
    if ( v3 >= dword_431D24 && v3 <= dword_431D34 )
    {
      if ( v3 > dword_431D24 && v3 < dword_431D34 )
        return 1;
      goto LABEL_25;
    }
    return 0;
  }
  if ( v3 < dword_431D34 || v3 > dword_431D24 )
    return 1;
  if ( v3 > dword_431D34 && v3 < dword_431D24 )
    return 0;
LABEL_25:
  v4 = 1000 * (*(_DWORD *)a1 + 60 * (*(_DWORD *)(a1 + 4) + 60 * *(_DWORD *)(a1 + 8)));
  if ( v3 == dword_431D24 )
    result = v4 >= dword_431D28;
  else
    result = v4 < dword_431D38;
  return result;
}
// 4241B0: using guessed type _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 431C8C: using guessed type int dword_431C8C;
// 431D20: using guessed type int dword_431D20;
// 431D24: using guessed type int dword_431D24;
// 431D28: using guessed type int dword_431D28;
// 431D30: using guessed type int dword_431D30;
// 431D34: using guessed type int dword_431D34;
// 431D38: using guessed type int dword_431D38;
// 4D9F08: using guessed type int dword_4D9F08;

//----- (00427220) --------------------------------------------------------
int __cdecl sub_427220(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_432150);
}
// 427050: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00427240) --------------------------------------------------------
int __cdecl sub_427240(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_432168);
}
// 427050: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00427260) --------------------------------------------------------
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &String, String, 0, 0, 0, 0);
  return sub_427220((int)v3, (int)Result);
}
// 427F20: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004272A0) --------------------------------------------------------
int __cdecl sub_4272A0(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_427240((int)v3, a1);
}
// 427F20: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00428F50) --------------------------------------------------------
int __cdecl getch()
{
  int result; // eax
  int v1; // esi
  unsigned __int8 *v2; // eax
  DWORD NumberOfEventsRead; // [esp+10h] [ebp-1Ch] BYREF
  DWORD dwMode; // [esp+14h] [ebp-18h] BYREF
  struct _INPUT_RECORD Buffer; // [esp+18h] [ebp-14h] BYREF

  if ( dword_432780 == -1 )
  {
    result = (int)hConsoleHandle;
    if ( hConsoleHandle != (HANDLE)-1 )
    {
      if ( hConsoleHandle == (HANDLE)-2 )
      {
        __initconin();
        result = (int)hConsoleHandle;
      }
      GetConsoleMode((HANDLE)result, &dwMode);
      SetConsoleMode(hConsoleHandle, 0);
      if ( ReadConsoleInputA(hConsoleHandle, &Buffer, 1u, &NumberOfEventsRead) )
      {
        while ( NumberOfEventsRead )
        {
          if ( Buffer.EventType == 1 && Buffer.Event.KeyEvent.bKeyDown )
          {
            v1 = (unsigned __int8)Buffer.Event.KeyEvent.uChar.AsciiChar;
            if ( Buffer.Event.KeyEvent.uChar.AsciiChar )
              goto LABEL_14;
            v2 = (unsigned __int8 *)_getextendedkeycode(&Buffer.Event);
            if ( v2 )
            {
              v1 = *v2;
              dword_432780 = v2[1];
              goto LABEL_14;
            }
          }
          if ( !ReadConsoleInputA(hConsoleHandle, &Buffer, 1u, &NumberOfEventsRead) )
            break;
        }
      }
      v1 = -1;
LABEL_14:
      SetConsoleMode(hConsoleHandle, dwMode);
      result = v1;
    }
  }
  else
  {
    result = (unsigned __int8)dword_432780;
    dword_432780 = -1;
  }
  return result;
}
// 429150: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 4292D0: using guessed type int __initconin(void);
// 432780: using guessed type int dword_432780;

//----- (00429060) --------------------------------------------------------
int __cdecl console_input_wrapper()
{
  HANDLE v1; // eax
  int v2; // eax
  void *v3; // esp
  int *v4; // edi
  DWORD v5; // eax
  int *i; // esi
  int v7; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+4h] [ebp-Ch] BYREF
  DWORD nLength; // [esp+8h] [ebp-8h] BYREF
  DWORD NumberOfEventsRead; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_432780 != -1 )
    return 1;
  v1 = hConsoleHandle;
  if ( hConsoleHandle == (HANDLE)-2 )
  {
    __initconin();
    v1 = hConsoleHandle;
  }
  if ( v1 != (HANDLE)-1 )
  {
    if ( GetNumberOfConsoleInputEvents(v1, &nLength) )
    {
      if ( nLength )
      {
        v2 = 20 * nLength + 3;
        LOBYTE(v2) = v2 & 0xFC;
        v3 = alloca(v2);
        v4 = &v7;
        if ( &v7 )
        {
          if ( PeekConsoleInputA(hConsoleHandle, (PINPUT_RECORD)&v7, nLength, &NumberOfEventsRead) )
          {
            v5 = NumberOfEventsRead;
            if ( NumberOfEventsRead )
            {
              if ( NumberOfEventsRead <= nLength )
              {
                for ( i = &v8; ; i += 5 )
                {
                  if ( *(_WORD *)v4 == 1 && *i )
                  {
                    if ( *((_BYTE *)i + 10) || _getextendedkeycode(i) )
                      return 1;
                    v5 = NumberOfEventsRead;
                  }
                  --v5;
                  v4 += 5;
                  NumberOfEventsRead = v5;
                  if ( !v5 )
                    return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 4290F5: conditional instruction was optimized away because of '%NumberOfEventsRead.4!=0'
// 429150: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 4292D0: using guessed type int __initconin(void);
// 432780: using guessed type int dword_432780;

//----- (100010E0) --------------------------------------------------------
int __thiscall sub_100010E0(void *this, int a2, int a3)
{
  int result; // eax
  int v6; // edi
  int v7; // ecx

  result = a3 - 1;
  if ( a3 )
  {
    v6 = a3;
    do
    {
      result = *(_DWORD *)this >> 8;
      v7 = result ^ dword_1002122C[*(unsigned __int8 *)a2++ ^ (unsigned __int8)*(_DWORD *)this];
      --v6;
      *(_DWORD *)this = v7;
    }
    while ( v6 );
  }
  return result;
}

//----- (10001120) --------------------------------------------------------
unsigned int __thiscall sub_10001120(void *this, const char *a2)
{
  const char *v2; // edx
  unsigned int v4; // kr04_4
  unsigned int result; // eax
  int v6; // edi
  int v7; // ecx

  v2 = a2;
  v4 = strlen(a2) + 1;
  result = v4 - 1;
  if ( v4 != 1 )
  {
    v6 = v4 - 2 + 1;
    do
    {
      result = *(_DWORD *)this >> 8;
      v7 = result ^ dword_1002122C[*(unsigned __int8 *)v2++ ^ (unsigned __int8)*(_DWORD *)this];
      --v6;
      *(_DWORD *)this = v7;
    }
    while ( v6 );
  }
  return result;
}

//----- (10001240) --------------------------------------------------------
int __thiscall sub_10001240(int this, int a2)
{
  const char *v3; // eax
  _BOOL1 v5; // zf
  const char *v6; // eax

  v3 = (const char *)a2;
  v5 = a2 == 0;
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_1002192C;
  if ( !v5 )
  {
    v6 = *sub_10005140((const char **)&a2, "%s", v3);
    if ( !v6 )
      v6 = byte_10028A9C;
    sub_100052C0((int)&unk_10024084, (int)"D:\\Src\\Inc\\Except.cpp", this, 33, (int)v6, 0);
    sub_100033A0(&a2);
  }
  return this;
}
// 1002192C: using guessed type void *off_1002192C;

//----- (10001320) --------------------------------------------------------
int __thiscall sub_10001320(int a1)
{
  sub_10001240(a1, 0);
  *(_DWORD *)a1 = &off_10021930;
  sub_100052C0((int)aFalse, (int)"D:\\Src\\Inc\\Except.cpp", a1, 51, (int)&loc_100240C7 + 1, 0);
  return a1;
}
// 10021930: using guessed type void *off_10021930;

//----- (10001350) --------------------------------------------------------
int __thiscall ReadsScrty1File(int this, int a2, int a3, int a4, int a5)
{
  sub_10001240(this, 0);
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a4;
  *(_DWORD *)(this + 16) = a5;
  *(_DWORD *)this = &off_10021934;
  if ( a3 )
  {
    strncpy_0((char *)(this + 20), (const char *)a3, 0x103u);
    *(_BYTE *)(this + 279) = 0;
  }
  else
  {
    *(_BYTE *)(this + 20) = 0;
  }
  return this;
}
// 10021934: using guessed type void *off_10021934;

//----- (10001A50) --------------------------------------------------------
int __thiscall sub_10001A50(void *this)
{
  int result; // eax

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this != -1 )
  {
    result = FIX_DLL_KERNEL32_dll_CloseHandle(*(_DWORD *)this);
    *(_DWORD *)this = -1;
  }
  return result;
}
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);

//----- (10001A80) --------------------------------------------------------
int __thiscall ReadScrty1File(void *this, char *FileName, int a3, int a4)
{
  int result; // eax
  int v6; // eax
  char v7[280]; // [esp+8h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_CreateFileA(FileName, 0x80000000, a3, 0, a4, 128, 0);
  *(_DWORD *)this = result;
  if ( result == -1 )
  {
    v6 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetLastError)();
    ReadsScrty1File((int)v7, 0, (int)FileName, 0, v6);
    _CxxThrowException(v7, (_ThrowInfo *)&_TI2_AVfile_exception__);
  }
  return result;
}
// 10021014: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CreateFileA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10022240: using guessed type __TI_flags _TI2_AVfile_exception__;

//----- (10001D90) --------------------------------------------------------
int __thiscall sub_10001D90(void *this)
{
  int result; // eax
  int v3; // eax
  int v4[70]; // [esp+0h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_GetFileSize(*(_DWORD *)this, 0);
  if ( result == -1 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetLastError(v4[0]);
    ReadsScrty1File((int)v4, 5, 0, 0, v3);
    _CxxThrowException(v4, (_ThrowInfo *)&_TI2_AVfile_exception__);
  }
  return result;
}
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 1002102C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileSize)(_DWORD, _DWORD);
// 10022240: using guessed type __TI_flags _TI2_AVfile_exception__;

//----- (10001DE0) --------------------------------------------------------
int __thiscall ReadScrty1FileOffset(void *this, int a2, int a3)
{
  int result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-11Ch] BYREF
  char v8[12]; // [esp+8h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_ReadFile(*(_DWORD *)this, a2, a3, &v7, 0);
  if ( !result )
  {
    v5 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetLastError)();
    ReadsScrty1File((int)v8, 2, 0, 0, v5);
    _CxxThrowException(v8, (_ThrowInfo *)&_TI2_AVfile_exception__);
  }
  if ( v7 != a3 )
  {
    v6 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetLastError)();
    ReadsScrty1File((int)v8, 3, 0, 0, v6);
    _CxxThrowException(v8, (_ThrowInfo *)&_TI2_AVfile_exception__);
  }
  return result;
}
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10021030: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10022240: using guessed type __TI_flags _TI2_AVfile_exception__;

//----- (10001F70) --------------------------------------------------------
bool __thiscall sub_10001F70(void *this)
{
  return FIX_DLL_KERNEL32_dll_DeleteFileA(this) != 0;
}
// 10021038: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_DeleteFileA)(_DWORD);

//----- (10002090) --------------------------------------------------------
int __thiscall sub_10002090(void *this)
{
  __int64 v1; // kr00_8
  __int64 v2; // rax
  _DWORD v4[2]; // [esp+0h] [ebp-10h] BYREF
  _DWORD v5[2]; // [esp+8h] [ebp-8h] BYREF

  FIX_DLL_KERNEL32_dll_GetFileTime(*(_DWORD *)this, 0, 0, v5);
  FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime(v5, v4);
  v1 = *(_QWORD *)v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(*(_QWORD *)v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      LODWORD(v2) = -1;
  }
  else
  {
    LODWORD(v2) = 0;
  }
  return v2;
}
// 10021044: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD);
// 10021048: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileTime)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100024F0) --------------------------------------------------------
char __thiscall sub_100024F0(void *this, int a2, int a3)
{
  int v4; // eax
  int v5; // ebp
  char *v7; // esi
  char *v8; // eax
  int v9; // eax
  int v10; // [esp-10h] [ebp-13Ch]
  char v11[12]; // [esp+4h] [ebp-128h] BYREF
  int v12; // [esp+10h] [ebp-11Ch] BYREF
  char v13[280]; // [esp+14h] [ebp-118h] BYREF

  if ( !FIX_DLL_KERNEL32_dll_ReadFile(*(_DWORD *)this, a2, a3 - 2, &v12, 0) )
  {
    v4 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetLastError)();
    ReadsScrty1File((int)v13, 2, 0, 0, v4);
    _CxxThrowException(v13, (_ThrowInfo *)&_TI2_AVfile_exception__);
  }
  v5 = v12;
  if ( !v12 )
    return 0;
  *(_BYTE *)(v12 + a2) = 0;
  v7 = strchr_0((const char *)a2, 13);
  v8 = strchr_0((const char *)a2, 10);
  if ( (v8 >= v7 || !v8) && v7 || (v7 = v8) != 0 )
  {
    *v7 = 0;
    if ( FIX_DLL_KERNEL32_dll_SetFilePointer(*(_DWORD *)this, &v7[(v8 == v7 + 1) - v5 - a2 + 1], 0, 1) == -1 )
    {
      v9 = FIX_DLL_KERNEL32_dll_GetLastError(v10);
      ReadsScrty1File((int)v11, 5, 0, 0, v9);
      _CxxThrowException(v11, (_ThrowInfo *)&_TI2_AVfile_exception__);
    }
  }
  return 1;
}
// 100025B4: variable 'v10' is possibly undefined
// 10021010: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10021030: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10022240: using guessed type __TI_flags _TI2_AVfile_exception__;

//----- (100027F0) --------------------------------------------------------
_BOOL1 __thiscall sub_100027F0(void *this)
{
  int v1; // eax
  _BOOL1 v2; // bl
  _DWORD v4[100]; // [esp+8h] [ebp-190h] BYREF

  v1 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v4);
  v2 = v1 != -1;
  if ( v1 != -1 )
    FIX_DLL_KERNEL32_dll_FindClose(v1);
  return v2;
}
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (10002830) --------------------------------------------------------
signed int __thiscall sub_10002830(void *this)
{
  __int64 v1; // kr00_8
  int v2; // esi
  _DWORD v4[2]; // [esp+0h] [ebp-19Ch] BYREF
  int v5; // [esp+8h] [ebp-194h]
  _DWORD v6[5]; // [esp+Ch] [ebp-190h] BYREF
  _DWORD v7[95]; // [esp+20h] [ebp-17Ch] BYREF

  v5 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v6);
  if ( v5 == -1 )
    return 0;
  FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime(v7, v4);
  v1 = *(_QWORD *)v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(*(_QWORD *)v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      v2 = -1;
  }
  else
  {
    v2 = 0;
  }
  if ( v5 != -1 )
    FIX_DLL_KERNEL32_dll_FindClose(v5);
  return v2;
}
// 10021044: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD);
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (100028D0) --------------------------------------------------------
int __thiscall sub_100028D0(void *this)
{
  int v1; // eax
  int v2; // esi
  _DWORD v4[100]; // [esp+4h] [ebp-190h] BYREF

  v1 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v4);
  if ( v1 == -1 )
    return 0;
  v2 = v4[8];
  FIX_DLL_KERNEL32_dll_FindClose(v1);
  return v2;
}
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (10002A10) --------------------------------------------------------
unsigned int __thiscall sub_10002A10(void *this, int a2, int a3)
{
  _BYTE *v3; // esi
  unsigned int result; // eax
  _BYTE *v5; // edx
  int v6; // edi
  char v7; // cl
  char v8; // cl
  _BOOL1 v10; // zf

  v3 = this;
  result = 0;
  v5 = this;
  v6 = a2 - (_DWORD)this;
  do
  {
    v7 = v5[v6];
    *v5 = v7;
    if ( !v7 )
      break;
    ++result;
    ++v5;
  }
  while ( result < 0x104 );
  if ( result < 0x103 )
  {
    if ( result )
    {
      v8 = v3[result - 1];
      if ( v8 != 92 && v8 != 47 )
        v3[result++] = 92;
    }
  }
  for ( ; result < 0x104; ++a3 )
  {
    v10 = *(_BYTE *)a3 == 0;
    v3[result] = *(_BYTE *)a3;
    if ( v10 )
      break;
    ++result;
  }
  v3[259] = 0;
  return result;
}

//----- (10002B80) --------------------------------------------------------
void __thiscall sub_10002B80(void *this)
{
  char v1; // dl
  _BYTE *v2; // esi
  _BYTE *v3; // eax

  v1 = *(_BYTE *)this;
  v2 = 0;
  if ( !*(_BYTE *)this )
    goto LABEL_9;
  v3 = this;
  do
  {
    if ( v1 == 92 || *v3 == 47 )
      v2 = v3;
    v1 = *++v3;
  }
  while ( v1 );
  if ( v2 )
    *v2 = 0;
  else
LABEL_9:
    *(_BYTE *)this = 0;
}

//----- (10002CC0) --------------------------------------------------------
int __cdecl sub_10002CC0(int a1)
{
  int result; // eax
  char v3[16]; // [esp+0h] [ebp-10h] BYREF

  result = FIX_DLL_KERNEL32_dll_LocalAlloc(0, a1);
  if ( !result )
  {
    sub_10001320((int)v3);
    _CxxThrowException(v3, (_ThrowInfo *)&unk_10022298);
  }
  return result;
}
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);

//----- (10002D10) --------------------------------------------------------
int __fastcall sub_10002D10(int a1, int a2)
{
  int v4; // eax
  int result; // eax
  int v6[4]; // [esp+0h] [ebp-10h] BYREF

  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    v6[0] = 2;
    result = FIX_DLL_KERNEL32_dll_LocalReAlloc(v4, a2);
  }
  else
  {
    result = FIX_DLL_KERNEL32_dll_LocalAlloc(0, a2);
  }
  *(_DWORD *)a1 = result;
  if ( !result )
  {
    FIX_DLL_KERNEL32_dll_GetLastError(v6[0]);
    sub_10001320((int)v6);
    _CxxThrowException(v6, (_ThrowInfo *)&unk_10022298);
  }
  return result;
}
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD);

//----- (10002D60) --------------------------------------------------------
int __thiscall sub_10002D60(void *this)
{
  return FIX_DLL_KERNEL32_dll_LocalFree(this);
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10002D70) --------------------------------------------------------
int __cdecl sub_10002D70(int a1)
{
  return FIX_DLL_KERNEL32_dll_LocalFree(a1);
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10002E30) --------------------------------------------------------
const char *__fastcall sub_10002E30(void *a1, int a2, int a3, unsigned __int8 a4, int a5)
{
  const char *v5; // eax
  void *v7; // edx
  const char *v8; // esi
  int v9; // ebx
  char *v11; // eax
  int v12; // eax
  char v13; // al

  v5 = (const char *)a3;
  v7 = a1;
  v8 = (const char *)a3;
  if ( a1 )
    *(_BYTE *)a1 = 0;
  v9 = a5 + 1;
  if ( a5 != -1 )
  {
    do
    {
      v8 = v5;
      v5 = strchr_0(v5, (char)a4);
      if ( !v5 )
        break;
      ++v5;
      --v9;
    }
    while ( v9 );
    v7 = a1;
  }
  if ( v9 > 1 )
    return 0;
  while ( *v8 == 32 || *v8 == 9 )
    ++v8;
  if ( v7 )
  {
    if ( v5 )
    {
      v11 = (char *)(v5 - 1);
    }
    else
    {
      v11 = strchr_0(v8, 0);
      v7 = a1;
    }
    v12 = v11 - v8;
    if ( a2 > v12 )
      a2 = v12 + 1;
    memcpy_0(v7, v8, a2 - 1);
    do
    {
      --a2;
      *((_BYTE *)a1 + a2) = 0;
      if ( !a2 )
        break;
      v13 = *((char *)a1 + a2 - 1);
    }
    while ( v13 == 32 || v13 == 9 || a4 == 10 && v13 == 13 );
  }
  return v8;
}

//----- (10003000) --------------------------------------------------------
char *__fastcall strncpyt(void *dst, void *src, int len)
{
  if ( strlen((const char *)src) < len )
    return strcpy((char *)dst, (const char *)src);
  memcpy_0(dst, src, len);
  *((char *)dst + len - 1) = 0;
  return (char *)dst;
}

//----- (10003060) --------------------------------------------------------
char *__fastcall sub_10003060(const char *a1, const void *a2, signed int a3)
{
  signed int v4; // ecx
  size_t v6; // esi
  char *v7; // ebx

  v4 = strlen(a1);
  if ( v4 >= a3 )
    return (char *)a1;
  v6 = a3 - v4;
  v7 = (char *)&a1[v4];
  if ( strlen((const char *)a2) < a3 - v4 )
    return strcpy(v7, (const char *)a2);
  memcpy_0(v7, a2, v6);
  v7[v6 - 1] = 0;
  return v7;
}

//----- (100030E0) --------------------------------------------------------
int __fastcall sub_100030E0(int a1, const char *a2)
{
  int v4; // ebp
  int result; // eax
  char *v6; // edi
  int v7; // edi
  unsigned int v8; // [esp+14h] [ebp-8h]
  unsigned int v9; // [esp+18h] [ebp-4h]

  v9 = 0;
  v8 = strlen(a2);
  v4 = tolower_0(*a2);
  if ( !*(_BYTE *)a1 )
    return 0;
  v6 = (char *)a1;
  if ( a1 )
  {
    while ( _memicmp_0(v6, a2, v8) )
    {
      v6 = strchr_0(v6 + 1, v4);
      if ( !v6 )
        goto LABEL_8;
    }
    v9 = (unsigned int)v6;
  }
LABEL_8:
  v7 = toupper_0(*a2);
  if ( v7 == v4 || !a1 )
  {
LABEL_12:
    a1 = 0;
  }
  else
  {
    while ( _memicmp_0((const void *)a1, a2, v8) )
    {
      a1 = (int)strchr_0((const char *)(a1 + 1), v7);
      if ( !a1 )
        goto LABEL_12;
    }
  }
  result = v9;
  if ( !v9 || v9 >= a1 && a1 )
    result = a1;
  return result;
}

//----- (10003220) --------------------------------------------------------
char __fastcall sub_10003220(int a1, int a2, char a3)
{
  char result; // al

  for ( result = *(_BYTE *)a1; result; ++a1 )
  {
    if ( result == a2 )
      *(_BYTE *)a1 = a3;
    result = *(_BYTE *)(a1 + 1);
  }
  return result;
}

//----- (10003240) --------------------------------------------------------
char *__thiscall sub_10003240(void *this)
{
  char *result; // eax
  char i; // dl

  result = (char *)this;
  for ( i = *(_BYTE *)this; i >= 48; i = *++result )
  {
    if ( i > 57 )
      break;
  }
  return result;
}

//----- (10003260) --------------------------------------------------------
char *__thiscall sub_10003260(void *this)
{
  char *result; // eax

  for ( result = (char *)this; *result == 32 || *result == 9; ++result )
    ;
  return result;
}

//----- (10003280) --------------------------------------------------------
char *__fastcall sub_10003280(int a1)
{
  char *result; // eax

  for ( result = strchr_0((const char *)a1, 0) - 1; (unsigned int)result >= a1; *result-- = 0 )
  {
    if ( *result != 32 && *result != 9 )
      break;
  }
  return result;
}

//----- (100033A0) --------------------------------------------------------
int __thiscall sub_100033A0(void *this)
{
  int result; // eax

  result = FIX_DLL_KERNEL32_dll_LocalFree(*(_DWORD *)this);
  *(_DWORD *)this = 0;
  return result;
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10003E70) --------------------------------------------------------
int sub_10003E70(const char **a1, const char *a2, ...)
{
  int result; // eax
  unsigned int v3; // kr04_4
  const char *v4; // eax
  unsigned int v5; // ecx
  char *v6; // esi
  char *v7; // edi
  unsigned int v8; // edx
  unsigned int v9; // kr08_4
  unsigned int v10; // kr0C_4
  const char *v11; // eax
  int v12; // [esp-Ch] [ebp-820h]
  int v13; // [esp-8h] [ebp-81Ch]
  char v14[4]; // [esp+0h] [ebp-814h] BYREF
  char v15[4]; // [esp+4h] [ebp-810h] BYREF
  char v16[4]; // [esp+8h] [ebp-80Ch] BYREF
  char v17[8]; // [esp+Ch] [ebp-808h] BYREF
  char v18[2048]; // [esp+14h] [ebp-800h] BYREF
  va_list va; // [esp+820h] [ebp+Ch] BYREF

  va_start(va, a2);
  _vsnprintf(v18, 0x800u, a2, va);
  v18[2047] = 0;
  if ( *a1 )
  {
    v9 = strlen(*a1) + 1;
    v10 = strlen(v18) + 1;
    v11 = (const char *)FIX_DLL_KERNEL32_dll_LocalReAlloc(*a1, v10 + v9 - 1);
    *a1 = v11;
    if ( !v11 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError(v12);
      sub_10001320((int)v14, &v18[v10]);
      _CxxThrowException(v14, (_ThrowInfo *)&unk_10022298);
    }
    v11[v10 - 2 + v9] = 0;
    result = 0;
    v6 = v16;
    v8 = strlen(v16) + 1;
    v7 = (char *)&(*a1)[strlen(*a1)];
    v5 = v8;
  }
  else
  {
    if ( !v18 )
    {
      result = FIX_DLL_KERNEL32_dll_LocalFree(v18);
      *a1 = 0;
      return result;
    }
    v3 = strlen(v18) + 1;
    v4 = (const char *)FIX_DLL_KERNEL32_dll_LocalAlloc(0, v3 - 1 + 2);
    *a1 = v4;
    if ( !v4 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError(v13);
      sub_10001320((int)v15, &v18[v3]);
      _CxxThrowException(v15, (_ThrowInfo *)&unk_10022298);
    }
    v4[v3] = 0;
    result = 0;
    v5 = strlen(v17) + 1;
    v6 = v17;
    v7 = (char *)*a1;
    LOBYTE(v8) = v5;
  }
  qmemcpy(v7, v6, 4 * (v5 >> 2) + (v8 & 3));
  return result;
}
// 10003EF2: variable 'v13' is possibly undefined
// 10003F5A: variable 'v12' is possibly undefined
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD);
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10004F40) --------------------------------------------------------
int __fastcall sub_10004F40(const char *a1, va_list a2)
{
  int result; // eax
  char *v5; // ebx
  size_t v6; // ecx
  int v7; // eax
  unsigned int v8; // kr04_4
  _BOOL1 v9; // al
  unsigned int v10; // ebp
  const void **v11; // esi
  int v12; // [esp+10h] [ebp-3F8h] BYREF
  int v13; // [esp+14h] [ebp-3F4h]
  int v14; // [esp+18h] [ebp-3F0h]
  char v15[4]; // [esp+1Ch] [ebp-3ECh] BYREF
  char v16[1000]; // [esp+20h] [ebp-3E8h] BYREF

  result = dword_10029240;
  if ( dword_10029240 )
  {
    v5 = v16;
    v6 = 1000;
    if ( byte_10029244 && byte_100242D8 )
    {
      FIX_DLL_KERNEL32_dll_GetLocalTime(&v12);
      v7 = sprintf_0(v15, "%02d:%02d:%02d ", (unsigned __int16)v13, HIWORD(v13), (unsigned __int16)v14);
      v6 = 1000 - v7;
      v5 = &v15[v7];
    }
    _vsnprintf(v5, v6, a1, a2);
    v16[995] = 0;
    v8 = strlen(v15) + 1;
    v9 = v8 != 1 && *((_BYTE *)&v14 + v8 + 2) == 10;
    byte_100242D8 = v9;
    result = dword_10029240;
    v10 = 0;
    if ( dword_10029240 )
    {
      v11 = (const void **)&unk_100290BC;
      do
      {
        if ( !*v11 || !_memicmp_0(v5, *v11, strlen((const char *)*v11)) )
          ((void (__fastcall *)(char *, const void *))*(v11 - 1))(v15, v11[1]);
        result = dword_10029240;
        ++v10;
        v11 += 3;
      }
      while ( v10 < dword_10029240 );
    }
  }
  return result;
}
// 10021004: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLocalTime)(_DWORD);
// 100242D8: using guessed type char byte_100242D8;
// 10029240: using guessed type int dword_10029240;
// 10029244: using guessed type char byte_10029244;
// 10004F40: using guessed type char var_3EC[4];

//----- (10005120) --------------------------------------------------------
int sub_10005120(int a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  return sub_10004F40((const char *)a1, va);
}

//----- (10005140) --------------------------------------------------------
const char **sub_10005140(const char **a1, const char *a2, ...)
{
  const char *v2; // edx
  _BOOL1 v3; // zf
  unsigned int v4; // kr04_4
  const char *v5; // eax
  unsigned int v6; // ecx
  char *v7; // esi
  char *v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // kr08_4
  unsigned int v11; // kr0C_4
  const char *v12; // eax
  int v14; // [esp-Ch] [ebp-82Ch]
  int v15; // [esp-8h] [ebp-828h]
  char v16[4]; // [esp+0h] [ebp-820h] BYREF
  char v17[4]; // [esp+4h] [ebp-81Ch] BYREF
  char v18[4]; // [esp+8h] [ebp-818h] BYREF
  char v19[8]; // [esp+Ch] [ebp-814h] BYREF
  char v20[2056]; // [esp+14h] [ebp-80Ch] BYREF
  int v21; // [esp+81Ch] [ebp-4h]
  va_list va; // [esp+82Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  *a1 = 0;
  v21 = 0;
  _vsnprintf(v20, 0x800u, a2, va);
  v2 = *a1;
  v3 = *a1 == 0;
  v20[2047] = 0;
  if ( !v3 )
  {
    v10 = strlen(v2) + 1;
    v11 = strlen(v20) + 1;
    v12 = (const char *)FIX_DLL_KERNEL32_dll_LocalReAlloc(v2, v11 + v10 - 1);
    *a1 = v12;
    if ( !v12 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError(v14);
      sub_10001320((int)v16, &v20[v11]);
      _CxxThrowException(v16, (_ThrowInfo *)&unk_10022298);
    }
    v12[v11 - 2 + v10] = 0;
    v7 = v18;
    v9 = strlen(v18) + 1;
    v8 = (char *)&(*a1)[strlen(*a1)];
    v6 = v9;
    goto LABEL_10;
  }
  if ( v20 )
  {
    v4 = strlen(v20) + 1;
    v5 = (const char *)FIX_DLL_KERNEL32_dll_LocalAlloc(0, v4 - 1 + 2);
    *a1 = v5;
    if ( !v5 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError(v15);
      sub_10001320((int)v17, &v20[v4]);
      _CxxThrowException(v17, (_ThrowInfo *)&unk_10022298);
    }
    v5[v4] = 0;
    v6 = strlen(v19) + 1;
    v7 = v19;
    v8 = (char *)*a1;
    LOBYTE(v9) = v6;
LABEL_10:
    qmemcpy(v8, v7, 4 * (v6 >> 2) + (v9 & 3));
    return a1;
  }
  FIX_DLL_KERNEL32_dll_LocalFree(v20);
  *a1 = 0;
  return a1;
}
// 100051E7: variable 'v15' is possibly undefined
// 10005251: variable 'v14' is possibly undefined
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD);
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (100052C0) --------------------------------------------------------
char __userpurge sub_100052C0@<al>(int a1@<ecx>, int a2@<edx>, int esi0@<esi>, int a3, int a4, char a5)
{
  const char *v7; // eax
  char result; // al

  sub_10005140((const char **)&a3, "ASSERTFAILURE(%s) in %s(%u)", (const char *)a1, (const char *)a2, a3);
  if ( a4 )
    sub_10003E70((const char **)&a3, ": %s", (const char *)a4);
  v7 = (const char *)a3;
  if ( !a3 )
    v7 = byte_10028A9C;
  sub_10005120((int)"%s\n", v7);
  if ( a5 )
  {
    _assert(aFalse, "D:\\Src\\Inc\\Misc.cpp", 0x335u);
    result = sub_10016FE0(esi0);
  }
  else
  {
    _assert(aFalse, "D:\\Src\\Inc\\Misc.cpp", 0x343u);
    FIX_DLL_KERNEL32_dll_LocalFree(a3);
    result = 0;
  }
  return result;
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10005390) --------------------------------------------------------
void __fastcall sub_10005390(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // ecx
  unsigned int v6; // esi
  int v7; // ebx
  unsigned int v9; // ecx
  unsigned int v10; // eax
  _BYTE *v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  char v15; // dl
  int v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+1Ch] [ebp+8h]

  v5 = a3;
  v6 = 1790562961 * a4 + 985938188;
  v7 = 0;
  v16 = a1;
  v17 = 0;
  if ( a3 > 1 )
  {
    do
    {
      v9 = v5 - v7;
      v6 = 69069 * v6 + 17009;
      if ( v9 > 0x10001 )
        v10 = v6 / (0xFFFFFFFF / (v9 - 1) + 1);
      else
        v10 = (v9 * HIWORD(v6)) >> 16;
      v11 = (_BYTE *)(a1 + a2 * v10);
      if ( a2 )
      {
        v12 = a1;
        v13 = a2;
        v14 = v12 - (_DWORD)v11;
        do
        {
          v15 = v11[v14];
          v11[v14] = *v11;
          *v11++ = v15;
          --v13;
        }
        while ( v13 );
        a1 = v16;
        v7 = v17;
      }
      v5 = a3;
      ++v7;
      a1 += a2;
      v17 = v7;
      v16 = a1;
    }
    while ( v7 + 1 < a3 );
  }
}

//----- (10005460) --------------------------------------------------------
int __thiscall sub_10005460(int this, int a2)
{
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 408) = 0;
  *(_DWORD *)(this + 416) = 0;
  memset((void *)(this + 8), 0, 0x190u);
  return this;
}

//----- (10005490) --------------------------------------------------------
int __thiscall sub_10005490(int this)
{
  int result; // eax

  result = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 408) = 0;
  *(_DWORD *)(this + 416) = 0;
  memset((void *)(this + 8), 0, 0x190u);
  return result;
}

//----- (100054B0) --------------------------------------------------------
int __thiscall sub_100054B0(void *this, int a2)
{
  unsigned int v3; // ebp
  int result; // eax
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int i; // edx
  int v9; // ecx

  v3 = sub_100082E0();
  result = *((_DWORD *)this + 104);
  if ( result )
  {
    v5 = *(_DWORD *)this / 0x64u;
    v6 = *((_DWORD *)this + 1);
    v7 = v3 / v5 % 0x64;
    if ( v3 - v6 < *(_DWORD *)this )
    {
      for ( i = v6 / v5 % 0x64; i != v7; *((_DWORD *)this + i + 2) = 0 )
      {
        if ( ++i >= 0x64 )
          i = 0;
        *((_DWORD *)this + 102) -= *((_DWORD *)this + i + 2);
      }
    }
    else if ( *((_DWORD *)this + 102) )
    {
      memset((char *)this + 8, 0, 0x190u);
      *((_DWORD *)this + 102) = 0;
    }
    result = a2;
    *((_DWORD *)this + v7 + 2) += a2;
    v9 = *((_DWORD *)this + 102);
    *((_DWORD *)this + 1) = v3;
    *((_DWORD *)this + 102) = a2 + v9;
  }
  else
  {
    *((_DWORD *)this + 104) = 1;
    *((_DWORD *)this + 103) = v3;
  }
  return result;
}

//----- (10005590) --------------------------------------------------------
int __thiscall sub_10005590(int this)
{
  __int64 v2; // rax

  LODWORD(v2) = *(_DWORD *)(this + 416);
  if ( (_DWORD)v2 == 2 )
    goto LABEL_7;
  if ( !(_DWORD)v2 )
    return v2;
  LODWORD(v2) = sub_100082E0() - *(_DWORD *)(this + 412);
  if ( (unsigned int)v2 > *(_DWORD *)this )
  {
    *(_DWORD *)(this + 416) = 2;
LABEL_7:
    sub_100054B0((void *)this, 0);
    LODWORD(v2) = *(_DWORD *)(this + 408);
    return v2;
  }
  if ( (_DWORD)v2 )
    v2 = (__int64)((long double)*(unsigned int *)(this + 408)
                 * (long double)*(unsigned int *)this
                 / (long double)(unsigned int)v2);
  return v2;
}

//----- (10005630) --------------------------------------------------------
int __thiscall sub_10005630(void *this)
{
  sub_100054B0(this, 0);
  return *((_DWORD *)this + 102);
}

//----- (10005650) --------------------------------------------------------
int __thiscall sub_10005650(int this)
{
  int result; // eax

  if ( *(_DWORD *)(this + 416) )
    result = sub_100082E0() - *(_DWORD *)(this + 412);
  else
    result = 0;
  return result;
}

//----- (10005670) --------------------------------------------------------
int __thiscall sub_10005670(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = -1;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  return result;
}

//----- (10005690) --------------------------------------------------------
int __thiscall sub_10005690(void *this)
{
  int result; // eax

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(*(_DWORD *)this);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (100056A0) --------------------------------------------------------
int __thiscall sub_100056A0(void *this)
{
  return j_FIX_DLL_WSOCK32_dll_ord_0008(this);
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);

//----- (100056B0) --------------------------------------------------------
u_long __thiscall sub_100056B0(u_long netlong)
{
  return ntohl_0(netlong);
}

//----- (100056C0) --------------------------------------------------------
int __thiscall sub_100056C0(void *this)
{
  return j_FIX_DLL_WSOCK32_dll_ord_0009(this);
}
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (100056D1) --------------------------------------------------------
// attributes: thunk
int __cdecl sub_100056D1()
{
  return j_FIX_DLL_WSOCK32_dll_ord_000F();
}

//----- (100056E0) --------------------------------------------------------
int __thiscall sub_100056E0(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = -1;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 20) = 0;
  return result;
}

//----- (10005700) --------------------------------------------------------
int __thiscall sub_10005700(int this)
{
  int result; // eax
  int v3; // esi

  result = sub_10002D70(*(_DWORD *)(this + 24));
  v3 = *(_DWORD *)this;
  if ( v3 != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(v3);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10005750) --------------------------------------------------------
char __userpurge sub_10005750@<al>(int a1@<ecx>, int a2@<esi>, int a3, int a4)
{
  int v5; // eax
  int v7; // [esp-10h] [ebp-14h]
  int v8; // [esp-10h] [ebp-14h]
  int v10; // [esp+0h] [ebp-4h] BYREF

  v10 = 1;
  if ( !j_FIX_DLL_WSOCK32_dll_ord_000C(a3, -2147195266, &v10, a2) )
    return 1;
  *(_DWORD *)(a1 + 8) = j_FIX_DLL_WSOCK32_dll_ord_006F(v7);
  *(_DWORD *)(a1 + 4) = 6;
  v5 = j_FIX_DLL_WSOCK32_dll_ord_006F(v8);
  sub_10005120((int)"Socket: %s error %d\n", (const char *)v10, v5);
  return 0;
}
// 10005750: could not find valid save-restore pair for esi
// 10005774: variable 'v7' is possibly undefined
// 10005783: variable 'v8' is possibly undefined
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100057B0) --------------------------------------------------------
int __thiscall sub_100057B0(void *this, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp-14h] [ebp-14h]

  a2 = (unsigned __int8)a2;
  result = j_FIX_DLL_WSOCK32_dll_ord_0015(*(_DWORD *)this, 6, 1, &a2, 4);
  if ( result )
  {
    v3 = j_FIX_DLL_WSOCK32_dll_ord_006F(v4);
    result = sub_10005120((int)"Socket: %s error %d\n", "SetTCPNoDelay", v3);
  }
  return result;
}
// 100057D4: variable 'v4' is possibly undefined
// 100159AE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100057F0) --------------------------------------------------------
char __thiscall sub_100057F0(void *this)
{
  int v2; // eax
  int v3; // eax
  int v5; // [esp-Ch] [ebp-10h]
  int v6; // [esp-Ch] [ebp-10h]

  if ( *(_DWORD *)this != -1 )
    return 1;
  v2 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
  *(_DWORD *)this = v2;
  if ( v2 != -1 )
    return 1;
  *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v5);
  v3 = j_FIX_DLL_WSOCK32_dll_ord_006F(v6);
  sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v3);
  if ( *((_DWORD *)this + 2) == 10024 )
    *((_DWORD *)this + 1) = 3;
  else
    *((_DWORD *)this + 1) = 6;
  return 0;
}
// 1000580A: variable 'v5' is possibly undefined
// 10005812: variable 'v6' is possibly undefined
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);

//----- (10005850) --------------------------------------------------------
int __thiscall sub_10005850(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(this + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  return result;
}

//----- (100058A0) --------------------------------------------------------
char __thiscall sub_100058A0(void *this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // eax
  int v7; // [esp-10h] [ebp-28h]
  int v8; // [esp-10h] [ebp-28h]
  int v9; // [esp-8h] [ebp-20h]
  int v10; // [esp-8h] [ebp-20h]
  _WORD v11[4]; // [esp+0h] [ebp-18h] BYREF
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)this == -1 )
  {
    v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
    *(_DWORD *)this = v3;
    if ( v3 == -1 )
    {
      *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v9);
      v4 = j_FIX_DLL_WSOCK32_dll_ord_006F(v10);
      sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v4);
      if ( *((_DWORD *)this + 2) == 10024 )
      {
        *((_DWORD *)this + 1) = 3;
        return 0;
      }
      goto LABEL_7;
    }
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = j_FIX_DLL_WSOCK32_dll_ord_0008(a2);
  v11[1] = j_FIX_DLL_WSOCK32_dll_ord_0009(0);
  if ( j_FIX_DLL_WSOCK32_dll_ord_0002(*(_DWORD *)this, v11, 16) == -1 )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v7);
    v6 = j_FIX_DLL_WSOCK32_dll_ord_006F(v8);
    sub_10005120((int)"Socket: %s error %d\n", "Bind", v6);
LABEL_7:
    *((_DWORD *)this + 1) = 6;
    return 0;
  }
  return 1;
}
// 100058BD: variable 'v9' is possibly undefined
// 100058C5: variable 'v10' is possibly undefined
// 1000593E: variable 'v7' is possibly undefined
// 10005946: variable 'v8' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);

//----- (10005980) --------------------------------------------------------
char __thiscall sub_10005980(void *this, int a2)
{
  int v3; // eax
  int v4; // eax
  char result; // al
  char *v6; // edi
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  signed int v14; // eax
  _DWORD v15[2]; // [esp-8h] [ebp-44h] BYREF
  void *v16; // [esp+0h] [ebp-3Ch] BYREF
  int v17; // [esp+4h] [ebp-38h]
  int v18; // [esp+8h] [ebp-34h]
  int v19; // [esp+Ch] [ebp-30h]
  char v20; // [esp+24h] [ebp-18h] BYREF
  __int16 v21; // [esp+26h] [ebp-16h]
  int v22[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( *(_DWORD *)this == -1 && (v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0), *(_DWORD *)this = v3, v3 == -1) )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v19);
    v4 = j_FIX_DLL_WSOCK32_dll_ord_006F(v19);
    sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v4);
    if ( *((_DWORD *)this + 2) == 10024 )
      *((_DWORD *)this + 1) = 3;
    else
      *((_DWORD *)this + 1) = 6;
    result = 0;
  }
  else
  {
    v6 = (char *)*((_DWORD *)this + 6);
    *((_DWORD *)this + 3) = *(_DWORD *)a2;
    *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 4);
    if ( !v6 )
      v6 = (char *)this + 12;
    v22[0] = 2;
    v22[1] = 0;
    v22[2] = 0;
    v22[3] = 0;
    v22[0] = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)v6);
    LOWORD(v7) = *((_WORD *)v6 + 2);
    v21 = j_FIX_DLL_WSOCK32_dll_ord_0009(v7);
    v8 = *(_DWORD *)this;
    v19 = 16;
    v18 = (int)&v20;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0004(v8) == -1 )
    {
      *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v17);
      v9 = j_FIX_DLL_WSOCK32_dll_ord_006F(v17);
      sub_10005120((int)"Socket: %s error %d\n", "Connect", v9);
      v10 = *((_DWORD *)this + 2);
      if ( v10 == 10061 || v10 == 10051 )
      {
        if ( *((_DWORD *)this + 6) )
          *((_DWORD *)this + 1) = 4;
        else
          *((_DWORD *)this + 1) = 1;
        result = 0;
      }
      else
      {
        *((_DWORD *)this + 1) = 6;
        result = 0;
      }
    }
    else
    {
      v11 = *(_DWORD *)this;
      v22[0] = 1;
      if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v11, -2147195266, v22, v17) )
      {
        *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v15[0]);
        *((_DWORD *)this + 1) = 6;
        v12 = j_FIX_DLL_WSOCK32_dll_ord_006F(v15[0]);
        sub_10005120((int)"Socket: %s error %d\n", "Connect/ioctlsocket", v12);
        result = 0;
      }
      else if ( *((_DWORD *)this + 6) )
      {
        *((_DWORD *)this + 5) = 1;
        while ( 1 )
        {
          v13 = *((_DWORD *)this + 5);
          v16 = this;
          if ( v13 == 9 || !v13 )
          {
            if ( v15 != (_DWORD *)-16 )
              v18 = 0;
          }
          else if ( v15 != (_DWORD *)-16 )
          {
            if ( v13 == 1 )
            {
              v18 = 6;
            }
            else if ( v13 == 2 || v13 == 4 || v13 == 6 )
            {
              v18 = 2;
            }
            else
            {
              v18 = 1;
            }
          }
          v14 = sub_100065F0((int)&v16, 1u, 0x7530u);
          if ( v14 < 0 || v14 && !sub_100077B0((int)this, v18) )
            break;
          if ( *((_DWORD *)this + 5) == 9 )
            goto LABEL_37;
        }
        *((_DWORD *)this + 5) = 0;
        result = 0;
      }
      else
      {
LABEL_37:
        *((_DWORD *)this + 5) = 9;
        result = 1;
      }
    }
  }
  return result;
}
// 10005A2E: variable 'v7' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159C0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD);

//----- (10005BD0) --------------------------------------------------------
char __thiscall sub_10005BD0(void *this, int a2)
{
  int v3; // eax
  int v4; // eax
  char result; // al
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // ecx
  char *v9; // edi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp-18h] [ebp-3Ch]
  int v15; // [esp-4h] [ebp-28h]
  int v16; // [esp-4h] [ebp-28h]
  int v17; // [esp-4h] [ebp-28h]
  int v18; // [esp-4h] [ebp-28h]
  char v19[2]; // [esp+0h] [ebp-24h] BYREF
  __int16 v20; // [esp+2h] [ebp-22h]
  int v21; // [esp+8h] [ebp-1Ch]
  int v22; // [esp+Ch] [ebp-18h]
  int v23[3]; // [esp+10h] [ebp-14h] BYREF
  _DWORD *v24; // [esp+1Ch] [ebp-8h]

  if ( *(_DWORD *)this == -1 && (v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0), *(_DWORD *)this = v3, v3 == -1) )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v15);
    v4 = j_FIX_DLL_WSOCK32_dll_ord_006F(v16);
    sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v4);
    if ( *((_DWORD *)this + 2) == 10024 )
      *((_DWORD *)this + 1) = 3;
    else
      *((_DWORD *)this + 1) = 6;
    result = 0;
  }
  else
  {
    v6 = *(_DWORD *)this;
    v23[0] = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v6, -2147195266, v23, v21) )
    {
      *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v17);
      *((_DWORD *)this + 1) = 6;
      v7 = j_FIX_DLL_WSOCK32_dll_ord_006F(v18);
      sub_10005120((int)"Socket: %s error %d\n", "AsyncConnect/ioctlsocket", v7);
      result = 0;
    }
    else
    {
      v8 = v24;
      v9 = (char *)*((_DWORD *)this + 6);
      *((_DWORD *)this + 3) = *v24;
      *((_DWORD *)this + 4) = v8[1];
      if ( !v9 )
        v9 = (char *)this + 12;
      v21 = 2;
      v22 = 0;
      v23[0] = 0;
      v23[1] = 0;
      v21 = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)v9);
      LOWORD(v10) = *((_WORD *)v9 + 2);
      v20 = j_FIX_DLL_WSOCK32_dll_ord_0009(v10);
      if ( j_FIX_DLL_WSOCK32_dll_ord_0004(*(_DWORD *)this) != -1
        || (v11 = j_FIX_DLL_WSOCK32_dll_ord_006F(v19), v11 == 10035) )
      {
        *((_DWORD *)this + 5) = 1;
        result = 1;
      }
      else
      {
        *((_DWORD *)this + 2) = v11;
        v12 = j_FIX_DLL_WSOCK32_dll_ord_006F(v14);
        sub_10005120((int)"Socket: %s error %d\n", "AsyncConnect/connect", v12);
        v13 = *((_DWORD *)this + 2);
        if ( v13 == 10061 || v13 == 10051 )
        {
          if ( *((_DWORD *)this + 6) )
            *((_DWORD *)this + 1) = 4;
          else
            *((_DWORD *)this + 1) = 1;
          *((_DWORD *)this + 5) = 0;
          result = 0;
        }
        else
        {
          *((_DWORD *)this + 1) = 6;
          *((_DWORD *)this + 5) = 0;
          result = 0;
        }
      }
    }
  }
  return result;
}
// 10005BD0: could not find valid save-restore pair for edi
// 10005BF2: variable 'v15' is possibly undefined
// 10005BFA: variable 'v16' is possibly undefined
// 10005C58: variable 'v17' is possibly undefined
// 10005C67: variable 'v18' is possibly undefined
// 10005CCE: variable 'v10' is possibly undefined
// 10005D00: variable 'v14' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159C0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD);

//----- (10005DA0) --------------------------------------------------------
_BOOL1 __thiscall sub_10005DA0(int this, int a2)
{
  int v3; // eax
  int v4; // esi
  _BOOL1 result; // al
  int v6; // eax
  int v7; // [esp-Ah] [ebp-24h]
  int v8; // [esp-Ah] [ebp-24h]
  u_long netlong; // [esp+2h] [ebp-18h]
  _DWORD *v10; // [esp+12h] [ebp-8h]

  v3 = *(_DWORD *)(this + 24);
  if ( v3 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(v3 + 288);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 292);
    v4 = *(_DWORD *)(this + 20);
    result = v4 == 9 || v4 == 8;
  }
  else
  {
    v7 = *(_DWORD *)this;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0006() )
    {
      *(_DWORD *)(this + 8) = j_FIX_DLL_WSOCK32_dll_ord_006F(v7);
      *(_DWORD *)(this + 4) = 6;
      v6 = j_FIX_DLL_WSOCK32_dll_ord_006F(v8);
      sub_10005120((int)"Socket: %s error %d\n", "GetLocalAddress", v6);
      result = 0;
    }
    else
    {
      *v10 = ntohl_0(netlong);
      v10[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
      result = 1;
    }
  }
  return result;
}
// 10005E11: variable 'v8' is possibly undefined
// 10005E37: variable 'netlong' is possibly undefined
// 10005E45: variable 'v10' is possibly undefined
// 100159C6: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0006(void);

//----- (10005E60) --------------------------------------------------------
char __thiscall sub_10005E60(void *this, int a2, int a3)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp-1Ch] [ebp-40h]
  int v13; // [esp-1Ch] [ebp-40h]
  int v14; // [esp-14h] [ebp-38h]
  int v15; // [esp-14h] [ebp-38h]
  int v16[3]; // [esp+0h] [ebp-24h] BYREF
  int v17; // [esp+Ch] [ebp-18h]
  int v18[5]; // [esp+10h] [ebp-14h] BYREF

  if ( *(_DWORD *)this == -1 )
  {
    v4 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
    *(_DWORD *)this = v4;
    if ( v4 == -1 )
    {
      *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v16[0]);
      v5 = j_FIX_DLL_WSOCK32_dll_ord_006F(v16[0]);
      sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v5);
      v6 = *((_DWORD *)this + 2);
LABEL_4:
      if ( v6 == 10024 )
      {
        *((_DWORD *)this + 1) = 3;
        return 0;
      }
LABEL_14:
      *((_DWORD *)this + 1) = 6;
      return 0;
    }
  }
  v8 = *(_DWORD *)this;
  v18[0] = 1;
  if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v8, -2147195266, v18, v17) )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v16[0]);
    *((_DWORD *)this + 1) = 6;
    v9 = j_FIX_DLL_WSOCK32_dll_ord_006F(v16[0]);
    sub_10005120((int)"Socket: %s error %d\n", "Listen/ioctlsocket", v9);
    return 0;
  }
  v17 = 0;
  v18[0] = 0;
  v18[1] = 0;
  v16[2] = j_FIX_DLL_WSOCK32_dll_ord_0008(v18[4]);
  HIWORD(v16[0]) = j_FIX_DLL_WSOCK32_dll_ord_0009(v18[2]);
  if ( j_FIX_DLL_WSOCK32_dll_ord_0002(*(_DWORD *)this, v16, 16) == -1 )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v14);
    v10 = j_FIX_DLL_WSOCK32_dll_ord_006F(v15);
    sub_10005120((int)"Socket: %s error %d\n", "Listen/bind", v10);
    if ( *((_DWORD *)this + 2) == 10048 )
    {
      *((_DWORD *)this + 1) = 2;
      return 0;
    }
    goto LABEL_14;
  }
  v12 = *(_DWORD *)this;
  if ( j_FIX_DLL_WSOCK32_dll_ord_000D() == -1 )
  {
    *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v12);
    v11 = j_FIX_DLL_WSOCK32_dll_ord_006F(v13);
    sub_10005120((int)"Socket: %s error %d\n", "Listen/listen", v11);
    v6 = *((_DWORD *)this + 2);
    if ( v6 == 10048 )
    {
      *((_DWORD *)this + 1) = 2;
      return 0;
    }
    goto LABEL_4;
  }
  return 1;
}
// 10005F53: variable 'v14' is possibly undefined
// 10005F5B: variable 'v15' is possibly undefined
// 10005FA4: variable 'v13' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);
// 100159CC: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_000D(void);

//----- (10006000) --------------------------------------------------------
char __thiscall sub_10006000(void *this, int a2)
{
  int v3; // edi
  int v4; // eax
  int v5; // eax
  char result; // al
  int v7; // eax
  int *v8; // esi
  int v9; // [esp-12h] [ebp-38h]
  int v10; // [esp-12h] [ebp-38h]
  int v11; // [esp-6h] [ebp-2Ch]
  int v12; // [esp-6h] [ebp-2Ch]
  int v13; // [esp+6h] [ebp-20h] BYREF
  int v14; // [esp+Eh] [ebp-18h] BYREF
  int *v15; // [esp+12h] [ebp-14h]

  v11 = *(_DWORD *)this;
  v14 = 16;
  v3 = j_FIX_DLL_WSOCK32_dll_ord_0001();
  if ( v3 == -1 )
  {
    v4 = j_FIX_DLL_WSOCK32_dll_ord_006F(v11);
    *((_DWORD *)this + 2) = v4;
    if ( v4 != 10035 )
    {
      v5 = j_FIX_DLL_WSOCK32_dll_ord_006F(v12);
      sub_10005120((int)"Socket: %s error %d\n", "Accept", v5);
    }
    if ( *((_DWORD *)this + 2) == 10024 )
      *((_DWORD *)this + 1) = 3;
    else
      *((_DWORD *)this + 1) = 6;
    result = 0;
  }
  else
  {
    v13 = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v3, -2147195266, &v13, v11) )
    {
      *((_DWORD *)this + 2) = j_FIX_DLL_WSOCK32_dll_ord_006F(v9);
      *((_DWORD *)this + 1) = 6;
      v7 = j_FIX_DLL_WSOCK32_dll_ord_006F(v10);
      sub_10005120((int)"Socket: %s error %d\n", "Accept/ioctlsocket", v7);
      result = 0;
    }
    else
    {
      v8 = v15;
      *v15 = v3;
      v8[5] = 9;
      v8[3] = ntohl_0((u_long)&v14);
      v8[4] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
      result = 1;
    }
  }
  return result;
}
// 10006037: variable 'v12' is possibly undefined
// 10006096: variable 'v9' is possibly undefined
// 100060A5: variable 'v10' is possibly undefined
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);
// 100159D2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0001(void);

//----- (10006100) --------------------------------------------------------
int __thiscall sub_10006100(void *this, int a2, signed int a3)
{
  signed int v3; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp-10h] [ebp-18h]
  int v11; // [esp-10h] [ebp-18h]

  v3 = a3;
  if ( a3 > 2048 )
    v3 = 2048;
  v5 = j_FIX_DLL_WSOCK32_dll_ord_0013(*(_DWORD *)this, a2, v3, 0);
  if ( v5 >= 0 )
    return v5;
  v6 = j_FIX_DLL_WSOCK32_dll_ord_006F(v10);
  *((_DWORD *)this + 2) = v6;
  if ( v6 == 10004 || v6 == 10035 )
    return 0;
  if ( v6 != 10053 && v6 != 10054 )
  {
    v7 = j_FIX_DLL_WSOCK32_dll_ord_006F(v11);
    sub_10005120((int)"Socket: %s error %d\n", "Send", v7);
  }
  v8 = *((_DWORD *)this + 2);
  if ( v8 != 10050 && v8 != 10052 && v8 != 10065 && v8 != 10053 && v8 != 10054 && v8 != 10060 )
  {
    *((_DWORD *)this + 1) = 6;
    return v5;
  }
  result = v5;
  *((_DWORD *)this + 1) = 1;
  return result;
}
// 1000612A: variable 'v10' is possibly undefined
// 1000614E: variable 'v11' is possibly undefined
// 100159D8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0013(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100061C0) --------------------------------------------------------
signed int __thiscall sub_100061C0(void *this, int a2, int a3)
{
  int v4; // eax
  signed int v5; // edi
  signed int result; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // [esp-10h] [ebp-18h]
  int v11; // [esp-10h] [ebp-18h]

  v4 = j_FIX_DLL_WSOCK32_dll_ord_0010(*(_DWORD *)this, a2, a3, 0);
  v5 = v4;
  if ( !v4 )
  {
    *((_DWORD *)this + 1) = 1;
    *((_DWORD *)this + 2) = 0;
    return -1;
  }
  if ( v4 >= 0 )
    return v5;
  v7 = j_FIX_DLL_WSOCK32_dll_ord_006F(v10);
  *((_DWORD *)this + 2) = v7;
  if ( v7 == 10004 || v7 == 10035 )
    return 0;
  if ( v7 != 10053 && v7 != 10054 )
  {
    v8 = j_FIX_DLL_WSOCK32_dll_ord_006F(v11);
    sub_10005120((int)"Socket: %s error %d\n", "Receive", v8);
  }
  v9 = *((_DWORD *)this + 2);
  if ( v9 != 10050 && v9 != 10052 && v9 != 10053 && v9 != 10060 && v9 != 10054 )
  {
    *((_DWORD *)this + 1) = 6;
    return v5;
  }
  result = v5;
  *((_DWORD *)this + 1) = 1;
  return result;
}
// 100061F2: variable 'v10' is possibly undefined
// 10006216: variable 'v11' is possibly undefined
// 100159DE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0010(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006280) --------------------------------------------------------
int __thiscall sub_10006280(int this, void *a2, int a3)
{
  char *v4; // eax
  unsigned __int32 v5; // eax
  int v6; // eax
  int v7; // eax
  char *v9; // [esp-4h] [ebp-Ch]

  *(_DWORD *)(this + 4) = a3;
  v4 = sub_10003260(a2);
  v5 = inet_addr_0(v4);
  *(_DWORD *)this = v5;
  if ( v5 == -1 )
  {
    v9 = sub_10003260(a2);
    v6 = j_FIX_DLL_WSOCK32_dll_ord_0034();
    if ( !v6 )
    {
      v7 = j_FIX_DLL_WSOCK32_dll_ord_006F(v9);
      sub_10005120((int)"Socket: %s error %d\n", "Address/gethostbyname", v7);
      *(_DWORD *)(this + 4) = 0;
      *(_DWORD *)this = 0;
      return this;
    }
    *(_DWORD *)this = ***(_DWORD ***)(v6 + 12);
  }
  *(_DWORD *)this = ntohl_0(*(_DWORD *)this);
  return this;
}
// 100159E4: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0034(void);

//----- (10006300) --------------------------------------------------------
void *__thiscall sub_10006300(void *this, const void *src)
{
  char *v3; // eax
  char *v4; // edi
  signed int *v5; // eax
  void *v6; // ecx
  char v7; // al
  unsigned int v8; // eax
  char *v9; // eax
  unsigned __int32 v10; // eax
  int v11; // eax
  int v12; // eax
  char *v14; // [esp+0h] [ebp-8Ch]
  char dst[4]; // [esp+Ch] [ebp-80h] BYREF
  char v16[124]; // [esp+10h] [ebp-7Ch] BYREF

  strncpyt(dst, (void *)src, 128);
  v3 = strchr_0(dst, 58);
  v4 = v3;
  if ( !v3 )
    goto LABEL_10;
  v5 = (signed int *)sub_10003260(v3 + 1);
  *((_DWORD *)this + 1) = atol_1(v6, v5);
  if ( sub_10003260(v16) == v4 )
    goto LABEL_10;
  v7 = *sub_10003260(v4 + 1);
  if ( v7 < 48 )
    goto LABEL_10;
  if ( v7 > 57 )
    goto LABEL_10;
  v8 = *((_DWORD *)this + 1);
  if ( !v8 || v8 > 0xFFFF )
    goto LABEL_10;
  *v4 = 0;
  sub_10003280((int)v16);
  v9 = sub_10003260(v16);
  v10 = inet_addr_0(v9);
  *(_DWORD *)this = v10;
  if ( v10 == -1 )
  {
    v14 = sub_10003260(v16);
    v11 = j_FIX_DLL_WSOCK32_dll_ord_0034();
    if ( !v11 )
    {
      v12 = j_FIX_DLL_WSOCK32_dll_ord_006F(v14);
      sub_10005120((int)"Socket: %s error %d\n", "Address/gethostbyname", v12);
LABEL_10:
      *((_DWORD *)this + 1) = 0;
      *(_DWORD *)this = 0;
      return this;
    }
    *(_DWORD *)this = ***(_DWORD ***)(v11 + 12);
  }
  *(_DWORD *)this = ntohl_0(*(_DWORD *)this);
  return this;
}
// 10006341: variable 'v6' is possibly undefined
// 100159E4: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0034(void);

//----- (10006410) --------------------------------------------------------
int __thiscall sub_10006410(void *this, int a2)
{
  sprintf_0(
    (char *)a2,
    "%u.%u.%u.%u",
    HIBYTE(*(_DWORD *)this),
    (unsigned __int8)BYTE2(*(_DWORD *)this),
    BYTE1(*(_DWORD *)this),
    (unsigned __int8)*(_DWORD *)this);
  return a2;
}

//----- (10006450) --------------------------------------------------------
int __thiscall sub_10006450(void *this, int a2)
{
  sprintf_0(
    (char *)a2,
    "%u.%u.%u.%u:%u",
    HIBYTE(*(_DWORD *)this),
    (unsigned __int8)BYTE2(*(_DWORD *)this),
    BYTE1(*(_DWORD *)this),
    (unsigned __int8)*(_DWORD *)this,
    *((_DWORD *)this + 1));
  return a2;
}

//----- (10006490) --------------------------------------------------------
int __fastcall sub_10006490(int a1, unsigned int a2)
{
  sprintf_0((char *)a1, "%u.%u.%u.%u", HIBYTE(a2), BYTE2(a2), BYTE1(a2), (unsigned __int8)a2);
  return a1;
}

//----- (100064D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_100064D0(char *a1, signed int **a2)
{
  char *v2; // esi
  void *v4; // ecx
  int v5; // edi
  char v6; // al
  int i; // edi
  char v8; // al
  signed int *v9; // esi
  void *v10; // ecx
  int v11; // edi
  char j; // al
  signed int *v13; // esi
  void *v14; // ecx
  int v15; // edi
  char k; // al
  char v17; // dl
  signed int *v18; // esi
  int v19; // edi
  char l; // al

  v2 = a1;
  if ( *a1 < 48 || *a1 > 57 )
    return 0;
  v5 = atol_1(a1, (signed int *)a1);
  v6 = *v2;
  for ( i = v5 << 24; v6 >= 48; v6 = *++v2 )
  {
    if ( v6 > 57 )
      break;
  }
  v8 = *v2;
  v9 = (signed int *)(v2 + 1);
  if ( v8 != 46 || *(char *)v9 < 48 || *(char *)v9 > 57 )
    return 0;
  v11 = (atol_1(v4, v9) << 16) | i;
  for ( j = *(_BYTE *)v9; j >= 48; v9 = (signed int *)((char *)v9 + 1) )
  {
    if ( j > 57 )
      break;
    j = *((_BYTE *)v9 + 1);
  }
  LOBYTE(v10) = *(_BYTE *)v9;
  v13 = (signed int *)((char *)v9 + 1);
  if ( (_BYTE)v10 != 46 || *(char *)v13 < 48 || *(char *)v13 > 57 )
    return 0;
  v15 = (atol_1(v10, v13) << 8) | v11;
  for ( k = *(_BYTE *)v13; k >= 48; v13 = (signed int *)((char *)v13 + 1) )
  {
    if ( k > 57 )
      break;
    k = *((_BYTE *)v13 + 1);
  }
  v17 = *(_BYTE *)v13;
  v18 = (signed int *)((char *)v13 + 1);
  if ( v17 != 46 || *(char *)v18 < 48 || *(char *)v18 > 57 )
    return 0;
  v19 = atol_1(v14, v18) | v15;
  if ( a2 )
  {
    for ( l = *(_BYTE *)v18; l >= 48; v18 = (signed int *)((char *)v18 + 1) )
    {
      if ( l > 57 )
        break;
      l = *((_BYTE *)v18 + 1);
    }
    *a2 = v18;
  }
  return v19;
}
// 100065B2: positive sp value 10 has been found
// 10006527: variable 'v4' is possibly undefined
// 10006559: variable 'v10' is possibly undefined
// 1000658B: variable 'v14' is possibly undefined

//----- (100065C0) --------------------------------------------------------
_BYTE *__thiscall sub_100065C0(void *this)
{
  _BYTE **v1; // eax
  _BYTE *result; // eax
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[1] = (int)this;
  v3[0] = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)this);
  v1 = (_BYTE **)((int (__cdecl *)(int *, int, int))j_FIX_DLL_WSOCK32_dll_ord_0033)(v3, 4, 2);
  if ( !v1 || (result = *v1) == 0 || !*result )
    result = 0;
  return result;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 100159F0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0033(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100065F0) --------------------------------------------------------
signed int __fastcall sub_100065F0(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  _DWORD *v4; // esi
  signed int result; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // edx
  int **v9; // eax
  int *v10; // ecx
  int v11; // edi
  _BOOL1 v12; // cc
  _DWORD *v13; // ecx
  signed int v14; // edi
  int v15; // eax
  int *v16; // esi
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // [esp-14h] [ebp-303Ch]
  int v21; // [esp-14h] [ebp-303Ch]
  int v22; // [esp-14h] [ebp-303Ch]
  int v23; // [esp-14h] [ebp-303Ch]
  char v24[8]; // [esp+8h] [ebp-3020h] BYREF
  _DWORD *v25; // [esp+10h] [ebp-3018h]
  int v26[2]; // [esp+14h] [ebp-3014h] BYREF
  int v27[1018]; // [esp+1Ch] [ebp-300Ch] BYREF
  char v28[28]; // [esp+1004h] [ebp-2024h] BYREF
  int v29[1016]; // [esp+1020h] [ebp-2008h] BYREF
  char v30[36]; // [esp+2000h] [ebp-1028h] BYREF
  int v31[1025]; // [esp+2024h] [ebp-1004h] BYREF

  v3 = a2;
  v4 = (_DWORD *)a1;
  v25 = (_DWORD *)a1;
  if ( !a2 )
  {
    FIX_DLL_KERNEL32_dll_Sleep(a3);
    return 0;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v27[0] = 0;
  v29[0] = 0;
  v31[0] = 0;
  v9 = (int **)a1;
  v26[0] = v3;
  do
  {
    v10 = v9[2];
    if ( ((unsigned __int8)v10 & 1) != 0 && v6 < 0x400 )
    {
      v27[v6 + 1] = **v9;
      v4 = v25;
      v6 = ++v27[0];
    }
    if ( ((unsigned __int8)v10 & 2) != 0 && v7 < 0x400 )
    {
      v29[v7 + 1] = **v9;
      v4 = v25;
      v7 = ++v29[0];
    }
    if ( ((unsigned __int8)v10 & 4) != 0 && v8 < 0x400 )
    {
      v31[v8 + 1] = **v9;
      v8 = ++v31[0];
    }
    v9 += 3;
    --v26[0];
  }
  while ( v26[0] );
  v26[0] = a3 / 0x3E8;
  v26[1] = 1000 * (a3 % 0x3E8);
  v11 = j_FIX_DLL_WSOCK32_dll_ord_0012(1, v27, v29, v31, v26);
  v12 = v11 <= 0;
  if ( v11 < 0 )
  {
    if ( j_FIX_DLL_WSOCK32_dll_ord_006F(v20) != 10004 && j_FIX_DLL_WSOCK32_dll_ord_006F(v21) != 10035 )
    {
      if ( j_FIX_DLL_WSOCK32_dll_ord_006F(v22) == 10038 )
      {
        if ( v3 == 1 )
        {
          v13 = (_DWORD *)*v4;
          v4[2] = 4;
          sub_10005120((int)"Socket: WSAENOTSOCK bug detected for socket %d\n", *v13);
          result = 1;
        }
        else
        {
          v14 = 0;
          if ( !v3 )
            goto LABEL_26;
          do
          {
            if ( sub_100065F0((int)v4, 1u, 0) <= 0 )
              v4[2] = 0;
            else
              v14 = 1;
            v4 += 3;
            --v3;
          }
          while ( v3 );
          if ( !v14 )
LABEL_26:
            FIX_DLL_KERNEL32_dll_Sleep(a3);
          result = v14;
        }
        return result;
      }
      v15 = j_FIX_DLL_WSOCK32_dll_ord_006F(v23);
      sub_10005120((int)"Socket: %s error %d\n", "Select", v15);
    }
    v12 = v11 <= 0;
  }
  if ( v12 )
    return v11;
  v16 = v4 + 2;
  do
  {
    if ( (*(_BYTE *)v16 & 1) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v16 - 2), v24) )
    {
      v17 = *v16;
      LOBYTE(v17) = *v16 & 0xFE;
      *v16 = v17;
    }
    if ( (*(_BYTE *)v16 & 2) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v16 - 2), v28) )
    {
      v18 = *v16;
      LOBYTE(v18) = *v16 & 0xFD;
      *v16 = v18;
    }
    if ( (*(_BYTE *)v16 & 4) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v16 - 2), v30) )
    {
      v19 = *v16;
      LOBYTE(v19) = *v16 & 0xFB;
      *v16 = v19;
    }
    v16 += 3;
    --v3;
  }
  while ( v3 );
  return 1;
}
// 1000672B: variable 'v20' is possibly undefined
// 1000673B: variable 'v21' is possibly undefined
// 1000674B: variable 'v22' is possibly undefined
// 100067CA: variable 'v23' is possibly undefined
// 100159F6: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0097(_DWORD, _DWORD);
// 100159FC: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021074: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_Sleep)(_DWORD);

//----- (10006880) --------------------------------------------------------
_BOOL1 __thiscall sub_10006880(int this, signed int a2, int a3)
{
  signed int v3; // eax
  int v5; // edx
  int v6; // eax
  _BOOL1 result; // al
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned int v12; // edi
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // [esp-1Ch] [ebp-68h]
  int v18; // [esp-1Ch] [ebp-68h]
  int *v19; // [esp-18h] [ebp-64h]
  int v20[6]; // [esp+0h] [ebp-4Ch] BYREF
  int v21; // [esp+18h] [ebp-34h] BYREF
  int v22; // [esp+20h] [ebp-2Ch]
  int v23; // [esp+28h] [ebp-24h] BYREF
  int v24; // [esp+2Ch] [ebp-20h]

  v3 = a2;
  *(_DWORD *)(this + 12) = *(_DWORD *)a2;
  v5 = *(_DWORD *)(v3 + 4);
  v6 = *(_DWORD *)(this + 86);
  *(_DWORD *)(this + 16) = v5;
  if ( v6 )
  {
    *(_BYTE *)(this + 20) = *(_DWORD *)(this + 12) == 0;
    result = *(_DWORD *)(v6 + 20) == 9;
  }
  else if ( *(_DWORD *)this == -1 && (v8 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 2, 0), *(_DWORD *)this = v8, v8 == -1) )
  {
    *(_DWORD *)(this + 8) = j_FIX_DLL_WSOCK32_dll_ord_006F(v22);
    v9 = j_FIX_DLL_WSOCK32_dll_ord_006F(v22);
    sub_10005120((int)"Socket: %s error %d\n", "CreateSocket", v9);
    if ( *(_DWORD *)(this + 8) == 10024 )
      *(_DWORD *)(this + 4) = 3;
    else
      *(_DWORD *)(this + 4) = 6;
    result = 0;
  }
  else
  {
    v10 = *(_DWORD *)this;
    a2 = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v10, -2147195266, &a2, v24) )
    {
      *(_DWORD *)(this + 8) = j_FIX_DLL_WSOCK32_dll_ord_006F(v22);
      *(_DWORD *)(this + 4) = 6;
      v11 = j_FIX_DLL_WSOCK32_dll_ord_006F(v22);
      sub_10005120((int)"Socket: %s error %d\n", "AsyncConnect/ioctlsocket", v11);
      result = 0;
    }
    else
    {
      v23 = 0x10000;
      v24 = 0x10000;
      j_FIX_DLL_WSOCK32_dll_ord_0015(*(_DWORD *)this, 0xFFFF, 4097, &v23, 4);
      j_FIX_DLL_WSOCK32_dll_ord_0015(*(_DWORD *)this, 0xFFFF, 4098, &v21, 4);
      v12 = (this + 37) & 0xFFFFFFF0;
      *(_DWORD *)v12 = 0;
      *(_DWORD *)(v12 + 4) = 0;
      *(_DWORD *)(v12 + 8) = 0;
      *(_DWORD *)(v12 + 12) = 0;
      *(_WORD *)v12 = 2;
      v13 = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(this + 12));
      *(_DWORD *)(v12 + 4) = v13;
      LOWORD(v13) = *(_WORD *)(this + 16);
      *(_WORD *)(v12 + 2) = j_FIX_DLL_WSOCK32_dll_ord_0009(v13);
      if ( !*(_DWORD *)(this + 12) || (_BYTE)v21 )
      {
        v16 = *(_DWORD *)this;
        v19 = (int *)((this + 37) & 0xFFFFFFF0);
        *(_BYTE *)(this + 20) = 1;
        v17 = v16;
      }
      else
      {
        v14 = *(_DWORD *)this;
        HIWORD(v20[0]) = 0;
        v20[1] = 0;
        v20[2] = 0;
        v19 = v20;
        *(_BYTE *)(this + 20) = 0;
        v20[3] = 0;
        LOWORD(v20[0]) = 2;
        v17 = v14;
      }
      if ( j_FIX_DLL_WSOCK32_dll_ord_0002(v17, v19, 16) >= 0 )
      {
        result = 1;
      }
      else
      {
        v15 = j_FIX_DLL_WSOCK32_dll_ord_006F(v18);
        sub_10005120((int)"Socket: %s error %d\n", "bind", v15);
        result = 0;
      }
    }
  }
  return result;
}
// 10006A21: variable 'v18' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD, _DWORD);
// 100159AE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);

//----- (10006A60) --------------------------------------------------------
int __thiscall sub_10006A60(int this, const void *a2, signed int a3)
{
  int v4; // ecx
  int result; // eax

  v4 = *(_DWORD *)(this + 86);
  if ( v4 )
    result = sub_10007160(v4, a2, a3, this + 12);
  else
    result = j_FIX_DLL_WSOCK32_dll_ord_0014(*(_DWORD *)this, a2, a3, 0, (this + 37) & 0xFFFFFFF0, 16);
  return result;
}
// 10015A02: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006AA0) --------------------------------------------------------
int __thiscall sub_10006AA0(int this, void *a2, int a3, int a4)
{
  int v5; // ecx
  char v7; // al
  int v8; // ebp
  __int16 v9; // [esp+0h] [ebp-102Ah]
  int v10; // [esp+12h] [ebp-1018h] BYREF
  int v11[4]; // [esp+16h] [ebp-1014h] BYREF
  int v12; // [esp+26h] [ebp-1004h] BYREF
  int v13; // [esp+2Ah] [ebp-1000h]

  v5 = *(_DWORD *)(this + 86);
  if ( !v5 )
  {
    if ( a4 )
    {
      v13 = *(_DWORD *)this;
      v12 = 1;
      v11[1] = 1000 * a4;
      v11[0] = 0;
      if ( j_FIX_DLL_WSOCK32_dll_ord_0012(v13 + 1, &v12, 0, 0, v11) <= 0 )
        return 0;
    }
    v7 = *(_BYTE *)(this + 20);
    v10 = 16;
    if ( v7 )
    {
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0011(*(_DWORD *)this, a2, a3, 0, (this + 37) & 0xFFFFFFF0);
      if ( v8 <= 0 )
        return 0;
      *(_DWORD *)(this + 12) = ntohl_0(*(_DWORD *)(((this + 37) & 0xFFFFFFF0) + 4));
      *(_DWORD *)(this + 16) = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
    }
    else
    {
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0011(*(_DWORD *)this, a2, a3, 0, v11);
      if ( *(_WORD *)(((this + 37) & 0xFFFFFFF0) + 2) != v9 || *(int **)(((this + 37) & 0xFFFFFFF0) + 4) != &v10 )
        return 0;
    }
    if ( v8 > 0 )
      return v8;
    return 0;
  }
  if ( *(_BYTE *)(this + 20) )
  {
    *(_DWORD *)(this + 16) = 0;
    *(_DWORD *)(this + 12) = 0;
  }
  return sub_10007240(v5, a2, a3, this + 12, a4);
}
// 10006BD5: variable 'v9' is possibly undefined
// 100159FC: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10015A08: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0011(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006C10) --------------------------------------------------------
int __thiscall sub_10006C10(int this, int a2)
{
  int result; // eax

  *(_BYTE *)(this + 20) = 0;
  *(_BYTE *)(this + 21) = 1;
  memcpy_0((void *)(this + 22), (const void *)(a2 + 22), 0x40u);
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = ntohl_0(*(_DWORD *)(((this + 37) & 0xFFFFFFF0) + 4));
  result = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
  *(_DWORD *)(this + 16) = result;
  *(_DWORD *)(this + 86) = *(_DWORD *)(a2 + 86);
  return result;
}

//----- (10006C80) --------------------------------------------------------
int __thiscall sub_10006C80(int this, int a2)
{
  unsigned int v3; // esi
  int v4; // eax
  int result; // eax

  *(_DWORD *)(this + 12) = *(_DWORD *)a2;
  v3 = (this + 37) & 0xFFFFFFF0;
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)v3 = 0;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_WORD *)v3 = 2;
  v4 = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(this + 12));
  *(_DWORD *)(v3 + 4) = v4;
  LOWORD(v4) = *(_WORD *)(this + 16);
  result = j_FIX_DLL_WSOCK32_dll_ord_0009(v4);
  *(_WORD *)(v3 + 2) = result;
  return result;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (10006CD0) --------------------------------------------------------
int __thiscall sub_10006CD0(int this)
{
  int result; // eax

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this != -1 && !*(_BYTE *)(this + 21) )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(result);
  *(_DWORD *)this = -1;
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10006CF0) --------------------------------------------------------
char __thiscall sub_10006CF0(int this, int a2)
{
  int v3; // eax
  int v4; // ecx
  char result; // al
  int v6; // eax
  int v7; // [esp-Ah] [ebp-24h]
  int v8; // [esp-Ah] [ebp-24h]
  u_long netlong; // [esp+2h] [ebp-18h]
  _DWORD *v10; // [esp+12h] [ebp-8h]

  v3 = *(_DWORD *)(this + 86);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)a2 = *(_DWORD *)(v4 + 288);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 292);
    result = 1;
  }
  else
  {
    v7 = *(_DWORD *)this;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0006() )
    {
      *(_DWORD *)(this + 8) = j_FIX_DLL_WSOCK32_dll_ord_006F(v7);
      *(_DWORD *)(this + 4) = 6;
      v6 = j_FIX_DLL_WSOCK32_dll_ord_006F(v8);
      sub_10005120((int)"Socket: %s error %d\n", "GetLocalAddress", v6);
      result = 0;
    }
    else
    {
      *v10 = ntohl_0(netlong);
      v10[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
      result = 1;
    }
  }
  return result;
}
// 10006D4B: variable 'v8' is possibly undefined
// 10006D71: variable 'netlong' is possibly undefined
// 10006D7A: variable 'v10' is possibly undefined
// 100159C6: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0006(void);

//----- (10006DA0) --------------------------------------------------------
int __thiscall sub_10006DA0(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = -1;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 86) = 0;
  *(_BYTE *)(this + 21) = 0;
  return result;
}

//----- (10006DC0) --------------------------------------------------------
char __thiscall sub_10006DC0(void *this)
{
  char result; // al

  if ( *(_DWORD *)this != -1 && !*((_BYTE *)this + 21) )
    j_FIX_DLL_WSOCK32_dll_ord_0003(*(_DWORD *)this);
  result = *((_BYTE *)this + 21);
  *(_DWORD *)this = -1;
  if ( result )
    *(_DWORD *)this = -1;
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10006DF0) --------------------------------------------------------
int __fastcall sub_10006DF0(int this, _DWORD edx0, signed int a2)
{
  int v4; // eax
  void *v5; // eax
  int v6; // ecx
  int v7; // eax
  int *v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v13; // [esp-Ch] [ebp-40h]
  int v14; // [esp-Ch] [ebp-40h]
  int v15[4]; // [esp+0h] [ebp-34h] BYREF
  u_long netlong; // [esp+10h] [ebp-24h] BYREF
  int v17; // [esp+14h] [ebp-20h]
  int v18; // [esp+30h] [ebp-4h]

  v15[3] = this;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = -1;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 20) = 0;
  v18 = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 32) = 0;
  LOBYTE(v18) = 1;
  v4 = sub_10002CC0(90);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)v4 = -1;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 86) = 0;
    *(_BYTE *)(v4 + 21) = 0;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(this + 28) = v4;
  if ( !*(_DWORD *)(this + 20) )
  {
    sub_10002D70(*(_DWORD *)(this + 24));
    *(_DWORD *)(this + 24) = 0;
    if ( a2 )
    {
      if ( *(_DWORD *)a2 )
      {
        v5 = (void *)sub_10002CC0(301);
        *(_DWORD *)(this + 24) = v5;
        qmemcpy(v5, (const void *)a2, 0x88u);
        *(_DWORD *)(*(_DWORD *)(this + 24) + 284) = 0;
        *(_DWORD *)(*(_DWORD *)(this + 24) + 297) = 3;
      }
    }
  }
  v6 = *(_DWORD *)(this + 28);
  netlong = 1;
  v17 = 1;
  if ( sub_10006880(v6, (signed int)&netlong, 0) )
  {
    v8 = *(int **)(this + 28);
    v9 = *(int *)((char *)v8 + 86);
    if ( v9 )
    {
      v10 = *(_DWORD *)(v9 + 24);
      netlong = *(_DWORD *)(v10 + 288);
      v17 = *(_DWORD *)(v10 + 292);
    }
    else
    {
      v13 = *v8;
      if ( j_FIX_DLL_WSOCK32_dll_ord_0006() )
      {
        v8[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v13);
        v8[1] = 6;
        v11 = j_FIX_DLL_WSOCK32_dll_ord_006F(v14);
        sub_10005120((int)"Socket: %s error %d\n", "GetLocalAddress", v11);
      }
      else
      {
        ntohl_0(netlong);
        v15[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F();
      }
    }
    v15[0] = 0;
    sub_10005BD0((void *)this, (int)v15);
  }
  else
  {
    v7 = *(_DWORD *)(this + 28);
    *(_DWORD *)(this + 4) = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(this + 8) = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(this + 20) = 0;
  }
  return this;
}
// 10006F44: variable 'v14' is possibly undefined
// 100159C6: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_0006(void);

//----- (10006FB0) --------------------------------------------------------
int __thiscall sub_10006FB0(int this)
{
  int v2; // edi
  char v3; // al
  int result; // eax
  int v5; // esi

  v2 = *(_DWORD *)(this + 28);
  if ( v2 )
  {
    if ( *(_DWORD *)v2 != -1 && !*(_BYTE *)(v2 + 21) )
      j_FIX_DLL_WSOCK32_dll_ord_0003(*(_DWORD *)v2);
    v3 = *(_BYTE *)(v2 + 21);
    *(_DWORD *)v2 = -1;
    if ( v3 )
      *(_DWORD *)v2 = -1;
    sub_10002D70(v2);
  }
  sub_10002D60(*(void **)(this + 32));
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 36) = 0;
  result = sub_10002D70(*(_DWORD *)(this + 24));
  v5 = *(_DWORD *)this;
  if ( v5 != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(v5);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10007060) --------------------------------------------------------
char __thiscall sub_10007060(int this)
{
  int v2; // eax
  signed int v3; // eax
  char result; // al
  int v5; // edi
  int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // [esp+0h] [ebp-10h] BYREF
  int v10; // [esp+4h] [ebp-Ch] BYREF
  int v11; // [esp+Ch] [ebp-4h]

  v10 = this;
  v2 = *(_DWORD *)(this + 20);
  if ( v2 == 9 || !v2 )
  {
    if ( &v9 != (int *)-12 )
      v11 = 0;
    v5 = *(_DWORD *)(this + 28);
    if ( v5 && v2 == 9 )
    {
      v6 = *(_DWORD *)(this + 24);
      v7 = (v5 + 37) & 0xFFFFFFF0;
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v6 + 288);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 292);
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 4) = 0;
      *(_DWORD *)(v7 + 8) = 0;
      *(_DWORD *)(v7 + 12) = 0;
      *(_WORD *)v7 = 2;
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(v5 + 12));
      *(_DWORD *)(v7 + 4) = v8;
      LOWORD(v8) = *(_WORD *)(v5 + 16);
      *(_WORD *)(v7 + 2) = j_FIX_DLL_WSOCK32_dll_ord_0009(v8);
    }
    result = 1;
  }
  else
  {
    if ( &v9 != (int *)-12 )
    {
      if ( v2 == 1 )
      {
        v11 = 6;
      }
      else if ( v2 == 2 || v2 == 4 || v2 == 6 )
      {
        v11 = 2;
      }
      else
      {
        v11 = 1;
      }
    }
    v3 = sub_100065F0((int)&v10, 1u, 0);
    if ( v3 < 0 || v3 && !sub_100077B0(this, v11) )
    {
      *(_DWORD *)(this + 20) = 0;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10007060: could not find valid save-restore pair for edi
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (10007160) --------------------------------------------------------
int __thiscall sub_10007160(int this, const void *a2, signed int a3, int a4)
{
  int result; // eax
  signed int v6; // esi
  int v7; // ecx
  int v8; // edx
  char v9; // al
  _DWORD *v10; // eax
  signed int v11; // edx
  int v12; // ecx
  char v13[10]; // [esp+4h] [ebp-800h] BYREF
  char v14[2038]; // [esp+Eh] [ebp-7F6h] BYREF

  result = *(_DWORD *)(this + 28);
  if ( result )
  {
    v6 = a3;
    v13[0] = 0;
    v7 = *(_DWORD *)a4;
    v13[1] = 0;
    v13[2] = 0;
    v13[4] = HIBYTE(v7);
    v13[5] = BYTE2(v7);
    v8 = *(_DWORD *)(a4 + 4);
    v13[6] = BYTE1(v7);
    LOBYTE(v7) = *(_BYTE *)a4;
    v9 = *(_BYTE *)(a4 + 4);
    v13[3] = 1;
    v13[7] = v7;
    v13[8] = BYTE1(v8);
    v13[9] = v9;
    if ( a3 > 2000 )
      v6 = 2000;
    memcpy_0(v14, a2, v6);
    v10 = *(_DWORD **)(this + 28);
    v11 = v6 + 10;
    v12 = *(_DWORD *)((char *)v10 + 86);
    if ( v12 )
      result = sub_10007160(v12, v13, v11, (int)(v10 + 3));
    else
      result = j_FIX_DLL_WSOCK32_dll_ord_0014(*v10, v13, v11, 0, ((unsigned int)v10 + 37) & 0xFFFFFFF0, 16);
  }
  return result;
}
// 10015A02: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007240) --------------------------------------------------------
int __thiscall sub_10007240(int this, void *a2, int a3, int a4, int a5)
{
  int v5; // ebp
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  _DWORD **v9; // eax
  _DWORD *v10; // esi
  int v11; // eax
  int v12; // edi
  int v14; // ebp
  int v15; // ebp
  int v16; // ebx
  int v17; // esi
  int *v18; // edi
  int v19; // ebx
  int *v20; // esi
  int v21; // ebp
  int v22; // ebx
  int v23; // eax
  int v24; // ebp
  int v25; // [esp+10h] [ebp-808h] BYREF
  _DWORD *v26; // [esp+14h] [ebp-804h]
  char v27[10]; // [esp+18h] [ebp-800h] BYREF
  _BYTE v28[2038]; // [esp+22h] [ebp-7F6h] BYREF

  v5 = this;
  v6 = 0;
  v7 = *(_DWORD *)(this + 40);
  v26 = (_DWORD *)this;
  if ( v7 <= 0 )
  {
LABEL_12:
    v14 = *(_DWORD *)(v5 + 28);
    if ( v14 )
    {
      v15 = sub_10006AA0(v14, v27, 2048, a5);
      if ( v15 >= 11 && !v27[2] && v27[3] == 1 )
      {
        v16 = (unsigned __int8)v27[9] | ((unsigned __int8)v27[8] << 8);
        v17 = (unsigned __int8)v27[7] | (((unsigned __int8)v27[6] | (((unsigned __int8)v27[5] | ((unsigned __int8)v27[4] << 8)) << 8)) << 8);
        if ( *(_DWORD *)a4 == v17 && *(_DWORD *)(a4 + 4) == v16 || !*(_DWORD *)a4 )
        {
          v23 = a3;
          v24 = v15 - 10;
          if ( v24 <= a3 )
            v23 = v24;
          memcpy_0(a2, v28, v23);
          *(_DWORD *)a4 = v17;
          *(_DWORD *)(a4 + 4) = v16;
          return v24;
        }
        v18 = (int *)sub_10002CC0(v15 + 3);
        *v18 = v17;
        v18[1] = v16;
        v18[2] = v15 - 10;
        memcpy_0(v18 + 3, v28, v15 - 10);
        v19 = v26[10];
        v20 = v26 + 8;
        if ( v19 >= v26[9] )
        {
          sub_10002D10((int)(v26 + 8), 4 * v19 + 128);
          v26[9] += 32;
        }
        v21 = 4 * v19;
        memcpy_0((void *)(*v20 + 4 * v19 + 4), (const void *)(*v20 + 4 * v19), 4 * (v20[2] + 0x3FFFFFFF * v19));
        v22 = *v20;
        ++v20[2];
        memcpy_0((void *)(v22 + v21), &v25, 4u);
        *(_DWORD *)(*v20 + v21) = v18;
      }
    }
    return 0;
  }
  v8 = *(_DWORD *)a4;
  v25 = v5 + 32;
  v9 = *(_DWORD ***)(v5 + 32);
  while ( 1 )
  {
    v10 = *v9;
    if ( v8 == **v9 )
    {
      if ( *(_DWORD *)(a4 + 4) == v10[1] )
        break;
      v5 = (int)v26;
    }
    if ( !v8 )
      break;
    ++v6;
    ++v9;
    if ( v6 >= v7 )
      goto LABEL_12;
  }
  *(_DWORD *)a4 = *v10;
  v11 = a3;
  *(_DWORD *)(a4 + 4) = v10[1];
  v12 = v10[2];
  if ( v12 <= a3 )
    v11 = v10[2];
  memcpy_0(a2, v10 + 3, v11);
  sub_10002D70((int)v10);
  sub_10008190(v25, v6);
  return v12;
}

//----- (10007470) --------------------------------------------------------
void *__thiscall sub_10007470(void *this)
{
  char v3; // [esp+8h] [ebp-190h] BYREF

  if ( (unsigned int)FIX_DLL_KERNEL32_dll_GetVersion() >= 0x80000000 )
    dword_100243E8 = 64;
  if ( j_FIX_DLL_WSOCK32_dll_ord_0073(2) || (unsigned __int8)&v3 != 2 )
  {
    dword_100243E8 = 64;
    j_FIX_DLL_WSOCK32_dll_ord_0073(257);
  }
  return this;
}
// 10015A0E: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD);
// 100210AC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetVersion)(void);
// 100243E8: using guessed type int dword_100243E8;

//----- (100074E0) --------------------------------------------------------
int __cdecl sub_100074E0()
{
  char v1; // [esp+0h] [ebp-198h]

  if ( (unsigned int)FIX_DLL_KERNEL32_dll_GetVersion() >= 0x80000000 )
    dword_100243E8 = 64;
  if ( j_FIX_DLL_WSOCK32_dll_ord_0073(2) || v1 != 2 )
  {
    dword_100243E8 = 64;
    j_FIX_DLL_WSOCK32_dll_ord_0073(257);
  }
  return atexit(sub_10007540);
}
// 10007512: variable 'v1' is possibly undefined
// 10015A0E: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD);
// 100210AC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetVersion)(void);
// 100243E8: using guessed type int dword_100243E8;

//----- (10007550) --------------------------------------------------------
int __thiscall sub_10007550(int this)
{
  int result; // eax

  LOBYTE(result) = *(_BYTE *)(this + 8);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 137) = ((_BYTE)result != 0) + 1;
  *(_BYTE *)(this + 138) = 0;
  *(_BYTE *)(this + 139) = 2;
  *(_DWORD *)(this + 284) = ((_BYTE)result != 0) + 3;
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  return result;
}

//----- (100075A0) --------------------------------------------------------
unsigned __int8 *__thiscall sub_100075A0(int this)
{
  const char *v2; // esi
  char *v3; // ebx
  unsigned __int8 *result; // eax

  v2 = (const char *)(this + 8);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 137) = strlen((const char *)(this + 8));
  strcpy((char *)(this + 138), v2);
  v3 = (char *)(*(unsigned __int8 *)(this + 137) + this + 138);
  *v3 = strlen((const char *)(this + 72));
  strcpy(v3 + 1, (const char *)(this + 72));
  result = (unsigned __int8 *)&v3[(unsigned __int8)*v3 - this - 135];
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = result;
  return result;
}

//----- (10007650) --------------------------------------------------------
char __thiscall sub_10007650(int this, int a2)
{
  char result; // al

  *(_BYTE *)(this + 137) = *(_BYTE *)(this + 297);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 138) = 0;
  *(_BYTE *)(this + 139) = 1;
  *(_BYTE *)(this + 140) = HIBYTE(*(_DWORD *)a2);
  *(_BYTE *)(this + 141) = BYTE2(*(_DWORD *)a2);
  *(_BYTE *)(this + 142) = BYTE1(*(_DWORD *)a2);
  *(_BYTE *)(this + 143) = *(_BYTE *)a2;
  *(_BYTE *)(this + 144) = BYTE1(*(_DWORD *)(a2 + 4));
  result = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(this + 145) = result;
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = 10;
  return result;
}

//----- (100076D0) --------------------------------------------------------
int __thiscall sub_100076D0(int this, const void *a2, char a3)
{
  int result; // eax
  void *v6; // eax

  result = *(_DWORD *)(this + 20);
  if ( !result )
  {
    result = sub_10002D70(*(_DWORD *)(this + 24));
    *(_DWORD *)(this + 24) = 0;
    if ( a2 )
    {
      if ( *(_DWORD *)a2 )
      {
        v6 = (void *)sub_10002CC0(301);
        *(_DWORD *)(this + 24) = v6;
        qmemcpy(v6, a2, 0x88u);
        *(_DWORD *)(*(_DWORD *)(this + 24) + 284) = 0;
        result = *(_DWORD *)(this + 24);
        *(_DWORD *)(result + 297) = a3 != 0 ? 3 : 1;
      }
    }
  }
  return result;
}

//----- (10007740) --------------------------------------------------------
char __thiscall sub_10007740(int this, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 20);
  if ( v2 == 9 || !v2 )
  {
    if ( a2 )
      *(_DWORD *)a2 = 0;
    LOBYTE(v2) = 0;
  }
  else if ( a2 )
  {
    if ( v2 == 1 )
    {
      *(_DWORD *)a2 = 6;
    }
    else if ( v2 == 2 || v2 == 4 || v2 == 6 )
    {
      *(_DWORD *)a2 = 2;
      LOBYTE(v2) = 1;
    }
    else
    {
      *(_DWORD *)a2 = 1;
      LOBYTE(v2) = 1;
    }
  }
  else
  {
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (100077B0) --------------------------------------------------------
char __thiscall sub_100077B0(int this, char a2)
{
  int v3; // eax
  int v4; // eax
  char result; // al
  int v6; // eax
  char v7; // cl
  int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  signed int v11; // edi
  signed int v12; // eax
  int v13; // esi
  char v14; // al
  char *v15; // ebx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  char v19; // al
  unsigned __int16 v20; // ax
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  unsigned int v25; // esi
  char *v26; // eax
  const char *v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // edi
  unsigned int v31; // esi
  char *v32; // eax
  const char *v33; // eax
  int v34; // eax
  unsigned int v35; // esi
  char *v36; // eax
  const char *v37; // eax
  int v38; // eax
  int v39; // edx
  int v40; // edi
  unsigned int v41; // esi
  char *v42; // eax
  const char *v43; // eax
  int v44; // eax
  unsigned __int8 v45; // bl
  int v46; // edi
  unsigned int v47; // esi
  char *v48; // eax
  const char *v49; // eax
  int v50; // edx
  int v51; // [esp-4h] [ebp-98h]
  int v52; // [esp-4h] [ebp-98h]
  int v53; // [esp-4h] [ebp-98h]
  int v54; // [esp-4h] [ebp-98h]
  int v55; // [esp-4h] [ebp-98h]
  char v56[128]; // [esp+14h] [ebp-80h] BYREF

  v3 = *(_DWORD *)(this + 20);
  if ( v3 == 9 )
    return 1;
  if ( v3 != 1 )
    goto LABEL_8;
  if ( (a2 & 4) != 0 )
  {
    v4 = -(*(_DWORD *)(this + 24) != 0);
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 4) = (v4 & 3) + 1;
    return 0;
  }
  if ( (a2 & 2) == 0 )
    return 1;
  v6 = *(_DWORD *)(this + 24);
  if ( !v6 )
  {
LABEL_98:
    *(_DWORD *)(this + 20) = 9;
    return 1;
  }
  v7 = *(_BYTE *)(v6 + 8);
  *(_BYTE *)(v6 + 136) = 5;
  *(_BYTE *)(v6 + 138) = 0;
  *(_BYTE *)(v6 + 137) = (v7 != 0) + 1;
  *(_BYTE *)(v6 + 139) = 2;
  *(_BYTE *)(v6 + 296) = 0;
  *(_DWORD *)(v6 + 280) = 0;
  *(_DWORD *)(v6 + 284) = (v7 != 0) + 3;
  *(_DWORD *)(this + 20) = 2;
LABEL_8:
  if ( !*(_DWORD *)(this + 24) )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v8 = *(_DWORD *)(this + 24);
              v9 = *(_DWORD *)(v8 + 280);
              v10 = *(_DWORD *)(v8 + 284);
              if ( v9 >= v10 )
                goto LABEL_19;
              v11 = 0;
              if ( *(_BYTE *)(v8 + 296) )
              {
                if ( (a2 & 1) != 0 )
                {
                  v12 = sub_100061C0((void *)this, v9 + v8 + 136, v10 - v9);
                  goto LABEL_17;
                }
              }
              else if ( (a2 & 2) != 0 )
              {
                v12 = sub_10006100((void *)this, v9 + v8 + 136, v10 - v9);
LABEL_17:
                v11 = v12;
                if ( v12 < 0 )
                {
                  *(_DWORD *)(this + 4) = 4;
                  return 0;
                }
                goto LABEL_18;
              }
LABEL_18:
              *(_DWORD *)(*(_DWORD *)(this + 24) + 280) += v11;
              v8 = *(_DWORD *)(this + 24);
              v10 = *(_DWORD *)(v8 + 284);
              if ( *(_DWORD *)(v8 + 280) < v10 )
                return 1;
LABEL_19:
              v13 = *(_DWORD *)(this + 20);
              if ( v13 != 2 )
                break;
              *(_BYTE *)(v8 + 296) = 1;
              *(_DWORD *)(v8 + 280) = 0;
              *(_DWORD *)(v8 + 284) = 2;
              *(_DWORD *)(this + 20) = 3;
            }
            if ( v13 != 3 )
              break;
            v14 = *(_BYTE *)(v8 + 137);
            if ( v14 != 2 || !*(_BYTE *)(v8 + 8) )
            {
              if ( v14 )
              {
                v24 = *(_DWORD *)(this + 24);
                *(_DWORD *)(this + 20) = 0;
                *(_DWORD *)(this + 4) = 4;
                *(_DWORD *)(this + 8) = 256;
                v56[0] = 0;
                if ( !v24 )
                  goto LABEL_55;
                if ( !*(_BYTE *)(v24 + 296) )
                  goto LABEL_55;
                v25 = 0;
                if ( !*(_DWORD *)(v24 + 280) )
                  goto LABEL_55;
                do
                {
                  if ( v25 >= 0x14 )
                    break;
                  v51 = *(unsigned __int8 *)(v24 + v25 + 136);
                  v26 = strchr_0(v56, 0);
                  sprintf_0(v26, "%02x ", v51);
                  v24 = *(_DWORD *)(this + 24);
                  ++v25;
                }
                while ( v25 < *(_DWORD *)(v24 + 280) );
                v27 = ". Reply: ";
                if ( !v56[0] )
LABEL_55:
                  v27 = byte_10028A9C;
                sub_10005120((int)"Socket: Socks error %d%s%s\n", 256, v27, v56);
                *(_DWORD *)(this + 4) = 5;
                return 0;
              }
              v17 = *(_BYTE *)(v8 + 297);
              *(_BYTE *)(v8 + 136) = 5;
              *(_BYTE *)(v8 + 137) = v17;
              *(_BYTE *)(v8 + 138) = 0;
              *(_BYTE *)(v8 + 139) = 1;
              *(_BYTE *)(v8 + 140) = HIBYTE(*(_DWORD *)(this + 12));
              *(_BYTE *)(v8 + 141) = BYTE2(*(_DWORD *)(this + 12));
              *(_BYTE *)(v8 + 142) = BYTE1(*(_DWORD *)(this + 12));
              *(_BYTE *)(v8 + 143) = *(_BYTE *)(this + 12);
              *(_BYTE *)(v8 + 144) = BYTE1(*(_DWORD *)(this + 16));
              *(_BYTE *)(v8 + 145) = *(_BYTE *)(this + 16);
              goto LABEL_32;
            }
            *(_BYTE *)(v8 + 136) = 5;
            *(_BYTE *)(v8 + 137) = strlen((const char *)(v8 + 8));
            strcpy((char *)(v8 + 138), (const char *)(v8 + 8));
            v15 = (char *)(*(unsigned __int8 *)(v8 + 137) + v8 + 138);
            *v15 = strlen((const char *)(v8 + 72));
            strcpy(v15 + 1, (const char *)(v8 + 72));
            v16 = (unsigned __int8)*v15;
            *(_BYTE *)(v8 + 296) = 0;
            *(_DWORD *)(v8 + 280) = 0;
            *(_DWORD *)(v8 + 284) = &v15[v16 - v8 - 135];
            *(_DWORD *)(this + 20) = 4;
          }
          if ( v13 != 4 )
            break;
          *(_BYTE *)(v8 + 296) = 1;
          *(_DWORD *)(v8 + 280) = 0;
          *(_DWORD *)(v8 + 284) = 2;
          *(_DWORD *)(this + 20) = 5;
        }
        if ( v13 != 5 )
          break;
        if ( *(_BYTE *)(v8 + 137) )
        {
          v28 = *(_DWORD *)(this + 24);
          v56[0] = 0;
          v29 = *(unsigned __int8 *)(v28 + 137);
          *(_DWORD *)(this + 20) = 0;
          *(_DWORD *)(this + 4) = 4;
          v30 = v29 + 512;
          *(_DWORD *)(this + 8) = v29 + 512;
          if ( !v28 )
            goto LABEL_63;
          if ( !*(_BYTE *)(v28 + 296) )
            goto LABEL_63;
          v31 = 0;
          if ( !*(_DWORD *)(v28 + 280) )
            goto LABEL_63;
          do
          {
            if ( v31 >= 0x14 )
              break;
            v52 = *(unsigned __int8 *)(v28 + v31 + 136);
            v32 = strchr_0(v56, 0);
            sprintf_0(v32, "%02x ", v52);
            v28 = *(_DWORD *)(this + 24);
            ++v31;
          }
          while ( v31 < *(_DWORD *)(v28 + 280) );
          v33 = ". Reply: ";
          if ( !v56[0] )
LABEL_63:
            v33 = byte_10028A9C;
          sub_10005120((int)"Socket: Socks error %d%s%s\n", v30, v33, v56);
          *(_DWORD *)(this + 4) = 5;
          return 0;
        }
        v18 = *(_BYTE *)(v8 + 297);
        *(_BYTE *)(v8 + 136) = 5;
        *(_BYTE *)(v8 + 137) = v18;
        *(_BYTE *)(v8 + 138) = 0;
        *(_BYTE *)(v8 + 139) = 1;
        *(_BYTE *)(v8 + 140) = HIBYTE(*(_DWORD *)(this + 12));
        *(_BYTE *)(v8 + 141) = BYTE2(*(_DWORD *)(this + 12));
        *(_BYTE *)(v8 + 142) = BYTE1(*(_DWORD *)(this + 12));
        *(_BYTE *)(v8 + 143) = *(_BYTE *)(this + 12);
        *(_BYTE *)(v8 + 144) = BYTE1(*(_DWORD *)(this + 16));
        *(_BYTE *)(v8 + 145) = *(_BYTE *)(this + 16);
LABEL_32:
        *(_BYTE *)(v8 + 296) = 0;
        *(_DWORD *)(v8 + 280) = 0;
        *(_DWORD *)(v8 + 284) = 10;
        *(_DWORD *)(this + 20) = 6;
      }
      if ( v13 != 6 )
        break;
      *(_BYTE *)(v8 + 296) = 1;
      *(_DWORD *)(v8 + 280) = 0;
      *(_DWORD *)(v8 + 284) = 5;
      *(_DWORD *)(this + 20) = 7;
    }
    if ( v13 != 7 && v13 != 8 )
      break;
    if ( v10 == 5 )
    {
      v19 = *(_BYTE *)(v8 + 139);
      switch ( v19 )
      {
        case 1:
          *(_DWORD *)(v8 + 284) = 10;
          break;
        case 3:
          *(_DWORD *)(v8 + 284) = *(unsigned __int8 *)(v8 + 140) + 6;
          break;
        case 4:
          *(_DWORD *)(v8 + 284) = 22;
          break;
        default:
          v38 = *(_DWORD *)(this + 24);
          v56[0] = 0;
          v39 = *(unsigned __int8 *)(v38 + 139);
          *(_DWORD *)(this + 20) = 0;
          *(_DWORD *)(this + 4) = 4;
          v40 = v39 + 768;
          *(_DWORD *)(this + 8) = v39 + 768;
          if ( !v38 )
            goto LABEL_79;
          if ( !*(_BYTE *)(v38 + 296) )
            goto LABEL_79;
          v41 = 0;
          if ( !*(_DWORD *)(v38 + 280) )
            goto LABEL_79;
          do
          {
            if ( v41 >= 0x14 )
              break;
            v54 = *(unsigned __int8 *)(v38 + v41 + 136);
            v42 = strchr_0(v56, 0);
            sprintf_0(v42, "%02x ", v54);
            v38 = *(_DWORD *)(this + 24);
            ++v41;
          }
          while ( v41 < *(_DWORD *)(v38 + 280) );
          v43 = ". Reply: ";
          if ( !v56[0] )
LABEL_79:
            v43 = byte_10028A9C;
          sub_10005120((int)"Socket: Socks error %d%s%s\n", v40, v43, v56);
          return 0;
      }
    }
    else
    {
      if ( *(_BYTE *)(v8 + 137) )
      {
        v44 = *(_DWORD *)(this + 24);
        v56[0] = 0;
        v45 = *(_BYTE *)(v44 + 137);
        *(_DWORD *)(this + 20) = 0;
        *(_DWORD *)(this + 4) = 4;
        v46 = v45 + 512;
        *(_DWORD *)(this + 8) = v46;
        if ( !v44 )
          goto LABEL_87;
        if ( !*(_BYTE *)(v44 + 296) )
          goto LABEL_87;
        v47 = 0;
        if ( !*(_DWORD *)(v44 + 280) )
          goto LABEL_87;
        do
        {
          if ( v47 >= 0x14 )
            break;
          v55 = *(unsigned __int8 *)(v44 + v47 + 136);
          v48 = strchr_0(v56, 0);
          sprintf_0(v48, "%02x ", v55);
          v44 = *(_DWORD *)(this + 24);
          ++v47;
        }
        while ( v47 < *(_DWORD *)(v44 + 280) );
        v49 = ". Reply: ";
        if ( !v56[0] )
LABEL_87:
          v49 = byte_10028A9C;
        sub_10005120((int)"Socket: Socks error %d%s%s\n", v46, v49, v56);
        if ( v45 == 2 )
        {
          *(_DWORD *)(this + 4) = 5;
          result = 0;
        }
        else
        {
          if ( v45 == 3 || v45 == 4 || v45 == 5 || v45 == 6 )
            *(_DWORD *)(this + 4) = 1;
          result = 0;
        }
        return result;
      }
      HIBYTE(v20) = *(_BYTE *)(v8 + 140);
      LOBYTE(v20) = *(_BYTE *)(v8 + 141);
      v21 = *(unsigned __int8 *)(v8 + 143) | ((*(unsigned __int8 *)(v8 + 142) | (v20 << 8)) << 8);
      HIWORD(v22) = 0;
      BYTE1(v22) = *(_BYTE *)(v8 + 144);
      LOBYTE(v22) = *(_BYTE *)(v8 + 145);
      if ( *(_DWORD *)(v8 + 297) != 2 )
      {
        v50 = *(_DWORD *)(this + 24);
        *(_DWORD *)(v50 + 288) = v21;
        *(_DWORD *)(v50 + 292) = v22;
        goto LABEL_98;
      }
      if ( v13 != 7 )
      {
        *(_DWORD *)(this + 12) = v21;
        *(_DWORD *)(this + 16) = v22;
        goto LABEL_98;
      }
      *(_DWORD *)(v8 + 288) = v21;
      *(_DWORD *)(v8 + 292) = v22;
      v23 = *(_DWORD *)(this + 24);
      *(_BYTE *)(v23 + 296) = 1;
      *(_DWORD *)(v23 + 280) = 0;
      *(_DWORD *)(v23 + 284) = 5;
      *(_DWORD *)(this + 20) = 8;
    }
  }
  v34 = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 4) = 4;
  *(_DWORD *)(this + 8) = 1024;
  v56[0] = 0;
  if ( !v34 )
    goto LABEL_71;
  if ( !*(_BYTE *)(v34 + 296) )
    goto LABEL_71;
  v35 = 0;
  if ( !*(_DWORD *)(v34 + 280) )
    goto LABEL_71;
  do
  {
    if ( v35 >= 0x14 )
      break;
    v53 = *(unsigned __int8 *)(v34 + v35 + 136);
    v36 = strchr_0(v56, 0);
    sprintf_0(v36, "%02x ", v53);
    v34 = *(_DWORD *)(this + 24);
    ++v35;
  }
  while ( v35 < *(_DWORD *)(v34 + 280) );
  v37 = ". Reply: ";
  if ( !v56[0] )
LABEL_71:
    v37 = byte_10028A9C;
  sub_10005120((int)"Socket: Socks error %d%s%s\n", 1024, v37, v56);
  return 0;
}
// 100078AC: conditional instruction was optimized away because of 'al.1!=0'

//----- (10008030) --------------------------------------------------------
char __thiscall sub_10008030(int this, int a2)
{
  int v3; // eax
  unsigned int v4; // esi
  char *v5; // eax
  const char *v6; // eax
  int v8; // [esp-4h] [ebp-90h]
  char v9[128]; // [esp+Ch] [ebp-80h] BYREF

  v9[0] = 0;
  v3 = *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 4) = 4;
  *(_DWORD *)(this + 8) = a2;
  if ( !v3 )
    goto LABEL_7;
  if ( !*(_BYTE *)(v3 + 296) )
    goto LABEL_7;
  v4 = 0;
  if ( !*(_DWORD *)(v3 + 280) )
    goto LABEL_7;
  do
  {
    if ( v4 >= 0x14 )
      break;
    v8 = *(unsigned __int8 *)(v3 + v4 + 136);
    v5 = strchr_0(v9, 0);
    sprintf_0(v5, "%02x ", v8);
    v3 = *(_DWORD *)(this + 24);
    ++v4;
  }
  while ( v4 < *(_DWORD *)(v3 + 280) );
  v6 = ". Reply: ";
  if ( !v9[0] )
LABEL_7:
    v6 = byte_10028A9C;
  sub_10005120((int)"Socket: Socks error %d%s%s\n", a2, v6, v9);
  return 0;
}

//----- (100080F0) --------------------------------------------------------
char __thiscall sub_100080F0(int this, int a2)
{
  int v2; // eax
  char result; // al
  int v4[2]; // [esp+0h] [ebp-88h] BYREF
  char v5[128]; // [esp+8h] [ebp-80h] BYREF

  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    v4[1] = 0;
    v4[0] = a2;
    *(_DWORD *)(v2 + 297) = 2;
    result = sub_10005BD0((void *)this, (int)v4);
  }
  else
  {
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 4) = 4;
    *(_DWORD *)(this + 8) = 1280;
    v5[0] = 0;
    sub_10005120((int)"Socket: Socks error %d%s%s\n", 1280, byte_10028A9C, v5);
    result = 0;
  }
  return result;
}

//----- (10008170) --------------------------------------------------------
int __thiscall sub_10008170(void **this)
{
  int result; // eax

  sub_10002D60(*this);
  result = 0;
  *this = 0;
  this[2] = 0;
  this[1] = 0;
  return result;
}

//----- (10008190) --------------------------------------------------------
int __thiscall sub_10008190(int this, int a2)
{
  int result; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD v6[7]; // [esp+0h] [ebp-1Ch] BYREF

  v6[3] = v6;
  memcpy_0(
    (void *)(*(_DWORD *)this + 4 * a2),
    (const void *)(*(_DWORD *)this + 4 * (a2 + 1)),
    4 * (*(_DWORD *)(this + 8) + 0x3FFFFFFF * (a2 + 1)));
  result = *(_DWORD *)(this + 8) - 1;
  *(_DWORD *)(this + 8) = result;
  v4 = result;
  if ( result )
  {
    result = *(_DWORD *)(this + 4);
    if ( result - v4 > 32 )
    {
      v5 = result - 16;
      *(_DWORD *)(this + 4) = v5;
      v6[6] = 0;
      result = sub_10002D10(this, 4 * v5);
    }
  }
  return result;
}

//----- (1000821E) --------------------------------------------------------
int (__stdcall *__cdecl sub_1000821E())(int)
{
  return loc_1000820B;
}
// 1000820B: using guessed type int __stdcall loc_1000820B(int);

//----- (10008230) --------------------------------------------------------
int __cdecl sub_10008230()
{
  long double v0; // fst7
  int result; // eax
  __int64 v2; // [esp+0h] [ebp-18h]
  _DWORD v3[2]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]

  if ( byte_10029268
    && (HIDWORD(v2) = v3, FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency())
    && FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v3[1])
    && v2 > 1000 )
  {
    v0 = (long double)v2;
    byte_10029268 = 1;
    qword_10029250 = *(_QWORD *)v3;
    dbl_10029260 = dbl_10021948 / v0;
    dbl_10029258 = dbl_10021940 / v0;
    result = FIX_DLL_KERNEL32_dll_GetTickCount(v2, v3, v3[0]) - 1000000;
    dword_1002926C = result;
  }
  else
  {
    byte_10029268 = 0;
    result = FIX_DLL_KERNEL32_dll_GetTickCount(v3[0], v3[1], v4) - 1000000;
    dword_1002926C = result;
  }
  return result;
}
// 10008270: variable 'v2' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 100210B4: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency)(void);
// 10021940: using guessed type double dbl_10021940;
// 10021948: using guessed type double dbl_10021948;
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029260: using guessed type double dbl_10029260;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100082E0) --------------------------------------------------------
#error "10008329: call analysis failed (funcsize=24)"

//----- (10008340) --------------------------------------------------------
#error "1000838A: call analysis failed (funcsize=29)"

//----- (100083C0) --------------------------------------------------------
#error "1000840A: call analysis failed (funcsize=29)"

//----- (10008440) --------------------------------------------------------
#error "1000848F: call analysis failed (funcsize=36)"

//----- (100084C0) --------------------------------------------------------
signed __int64 __thiscall sub_100084C0(void *this, double a2)
{
  signed __int64 result; // rax

  result = (__int64)((long double)(*(_QWORD *)&a2 - qword_10029250) * dbl_10029258);
  *((_DWORD *)this + 2) = result;
  return result;
}
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;

//----- (10008500) --------------------------------------------------------
int __thiscall sub_10008500(void *this)
{
  unsigned int v2; // ecx
  __int64 v3; // rax
  _DWORD v5[2]; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v5[1]);
    v2 = v5[1];
    *(_DWORD *)this = v5[0];
    *((_DWORD *)this + 1) = v2;
    *(_QWORD *)v5 = __PAIR64__(v2, v5[0]) - qword_10029250;
    v3 = (__int64)((long double)*(__int64 *)v5 * dbl_10029258);
  }
  else
  {
    LODWORD(v3) = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - dword_1002926C;
  }
  *((_DWORD *)this + 2) = v3;
  return v3;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008570) --------------------------------------------------------
_BOOL1 __thiscall sub_10008570(void *this, int a2)
{
  __int64 v3; // rax
  _DWORD v5[2]; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v5[1]);
    *(_QWORD *)v5 -= qword_10029250;
    v3 = (__int64)((long double)*(__int64 *)v5 * dbl_10029258);
  }
  else
  {
    LODWORD(v3) = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - dword_1002926C;
  }
  return (int)v3 - *((_DWORD *)this + 2) >= a2;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100085E0) --------------------------------------------------------
int __thiscall sub_100085E0(int this, int a2)
{
  _DWORD v4[2]; // [esp+0h] [ebp-Ch] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  if ( !byte_10029268 )
    return a2 + *(_DWORD *)(this + 8) - (((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - dword_1002926C);
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v4[1]);
  *(_QWORD *)v4 -= qword_10029250;
  return (int)retaddr + *(_DWORD *)(this + 8) - (__int64)((long double)*(__int64 *)v4 * dbl_10029258);
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008660) --------------------------------------------------------
int __thiscall sub_10008660(int this)
{
  _DWORD v3[2]; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_10029268 )
    return ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - dword_1002926C - *(_DWORD *)(this + 8);
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v3[1]);
  *(_QWORD *)v3 -= qword_10029250;
  return (__int64)((long double)*(__int64 *)v3 * dbl_10029258) - *(_DWORD *)(this + 8);
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100086D0) --------------------------------------------------------
int __thiscall sub_100086D0(int this, int a2)
{
  return *(_DWORD *)(a2 + 8) - *(_DWORD *)(this + 8);
}

//----- (100086E0) --------------------------------------------------------
long double __thiscall sub_100086E0(int this)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  long double result; // fst7
  int (*v5)(void); // edi
  unsigned int v6; // ecx
  char v7[20]; // [esp+4h] [ebp-14h] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v7[4]);
    v2 = *(_DWORD *)v7;
    v3 = *(_DWORD *)&v7[4];
    *(_QWORD *)v7 -= *(_QWORD *)this;
    result = (long double)*(__int64 *)v7 * dbl_10029258;
    *(_DWORD *)this = v2;
    *(_DWORD *)(this + 4) = v3;
    *(_DWORD *)&v7[4] = (__PAIR64__(v3, v2) - qword_10029250) >> 32;
    *(_DWORD *)(this + 8) = (__int64)((long double)(__int64)(__PAIR64__(v3, v2) - qword_10029250) * dbl_10029258);
  }
  else
  {
    v5 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetTickCount;
    *(_QWORD *)&v7[4] = (unsigned int)(((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)()
                                     - dword_1002926C
                                     - *(_DWORD *)(this + 8));
    *(double *)&v7[12] = (double)*(__int64 *)&v7[4];
    if ( byte_10029268 )
    {
      FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v7[4]);
      v6 = *(_DWORD *)&v7[4];
      *(_DWORD *)this = *(_DWORD *)v7;
      *(_DWORD *)(this + 4) = v6;
      *(_DWORD *)&v7[4] = (__PAIR64__(v6, *(unsigned int *)v7) - qword_10029250) >> 32;
      result = *(double *)&v7[8];
      *(_DWORD *)(this + 8) = (__int64)((long double)(__int64)(__PAIR64__(v6, *(unsigned int *)v7) - qword_10029250)
                                      * dbl_10029258);
    }
    else
    {
      result = *(double *)&v7[12];
      *(_DWORD *)(this + 8) = v5() - dword_1002926C;
    }
  }
  return result;
}
// 100086E0: could not find valid save-restore pair for ebx
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008800) --------------------------------------------------------
_DWORD *__userpurge sub_10008800@<eax>(void **a1@<ecx>, int a2@<ebx>, int a3)
{
  void **v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  int v14; // esi
  int v15; // edi
  int v16; // ecx
  int v17; // edi
  int v18; // ecx
  int v19; // edx
  int v20; // esi
  int v21; // edi
  int v22; // ecx
  int v23; // edx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // edx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // esi
  int v41; // ebx
  int v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // esi
  int v46; // edi
  int v47; // ecx
  int v48; // edx
  int v49; // esi
  int v50; // edi
  int v51; // ecx
  int v52; // ebx
  int v53; // esi
  int v54; // edx
  int v55; // ecx
  int v56; // edi
  int v57; // ebx
  int v58; // edx
  int v59; // ecx
  int v60; // esi
  int v61; // edi
  int v62; // ebx
  int v63; // edi
  int v64; // edx
  int v65; // ecx
  int v66; // esi
  int v67; // edi
  int v68; // edx
  int v69; // ecx
  int v70; // esi
  int v71; // edi
  int v72; // edx
  int v73; // ecx
  int v74; // esi
  int v75; // edi
  int v76; // edx
  int v77; // ecx
  int v78; // esi
  int v79; // ebp
  int v80; // ebx
  int v81; // edi
  int v82; // edx
  int i; // ecx
  _DWORD *result; // eax
  int v85; // ecx
  int v86; // edx
  int v87; // esi
  int v88; // edi
  int v89; // ecx
  int v90; // edi
  int v91; // ecx
  int v92; // edx
  int v93; // esi
  int v94; // edi
  int v95; // ecx
  int v96; // edi
  int v97; // ecx
  int v98; // edx
  int v99; // esi
  int v100; // edi
  int v101; // ecx
  int v102; // edx
  int v103; // esi
  int v104; // edi
  int v105; // ecx
  int v106; // edx
  int v107; // esi
  int v108; // edi
  int v109; // ecx
  int v110; // edx
  int v111; // ecx
  int v112; // edx
  int v113; // esi
  int v114; // edi
  int v115; // ecx
  int v116; // edx
  int v117; // ecx
  int v118; // ebx
  int v119; // edi
  int v120; // esi
  int v121; // edx
  int v122; // ecx
  int v123; // edi
  int v124; // esi
  int v125; // edx
  int v126; // ecx
  int v127; // edi
  int v128; // esi
  int v129; // ebx
  int v130; // ebp
  int v131; // ecx
  int v132; // edx
  int v133; // esi
  int v134; // edi
  int v135; // ecx
  int v136; // edx
  int v137; // esi
  int v138; // ebp
  int v139; // edi
  int v140; // ecx
  int v141; // edx
  int v142; // esi
  int v143; // edi
  int v144; // ecx
  int v145; // edx
  int v146; // esi
  int v147; // edi
  int v148; // ecx
  int v149; // edx
  int v150; // esi
  int v151; // edi
  int v152; // ebx
  int v153; // ecx
  int v154; // esi
  int v155; // edx
  int v156; // ebp
  int v157; // edx
  int v158; // edx
  int j; // ecx
  int v160; // [esp+10h] [ebp-20h]
  int v161; // [esp+10h] [ebp-20h]
  int v162; // [esp+10h] [ebp-20h]
  int v163; // [esp+10h] [ebp-20h]
  int v164; // [esp+10h] [ebp-20h]
  int v166; // [esp+20h] [ebp-10h]
  int v167; // [esp+24h] [ebp-Ch]
  int v168; // [esp+28h] [ebp-8h]
  int v169; // [esp+2Ch] [ebp-4h]

  LOBYTE(a2) = a3;
  BYTE1(a2) = a3;
  v3 = a1;
  v4 = a2 << 16;
  LOWORD(v4) = a2;
  memset32(*a1, v4, 0x14u);
  *(_DWORD *)*a1 ^= a3;
  v5 = *a1;
  v6 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v7 = v6 + __ROL4__((v6 & 0xEFCDAAC9 | ~v6 & 0x98BACD4E) + *((_DWORD *)*v3 + 1) - 107344724, 12);
  v8 = v7 + __ROL4__((v6 & v7 | ~v7 & 0xEFCDAAC9) + *((_DWORD *)*v3 + 2) - 1126481991, 17);
  v9 = __ROL4__((v8 & v7 | v6 & ~v8) + v5[3] - 1319441881, 22);
  v10 = v5[4] + ((v8 + v9) & v8 | v7 & ~(v8 + v9)) + v6 - 177010401;
  v11 = v8 + v9;
  v12 = v11 + __ROL4__(v10, 7);
  v13 = v12 + __ROL4__(v5[5] + (v12 & v11 | v8 & ~v12) + v7 + 1200080794, 12);
  v14 = v13 + __ROL4__(v5[6] + (v12 & v13 | v11 & ~v13) + v8 - 1472706653, 17);
  v15 = __ROL4__(v5[7] + (v14 & v13 | v12 & ~v14) + v11 - 45706063, 22);
  v16 = v5[8] + ((v14 + v15) & v14 | v13 & ~(v14 + v15)) + v12 + 1753258344;
  v17 = v14 + v15;
  v18 = v17 + __ROL4__(v16, 7);
  v19 = v18 + __ROL4__(v5[9] + (v18 & v17 | v14 & ~v18) + v13 - 1958414817, 12);
  v20 = v19 + __ROL4__(v5[10] + (v18 & v19 | v17 & ~v19) + v14 - 7382527, 17);
  v21 = __ROL4__(v5[11] + (v20 & v19 | v18 & ~v20) + v17 - 1987258866, 22);
  v160 = v20 + v21;
  v22 = v20 + v21 + __ROL4__(v5[12] + ((v20 + v21) & v20 | v19 & ~(v20 + v21)) + v18 + 1804605842, 7);
  v23 = v22 + __ROL4__(v5[13] + (v22 & (v20 + v21) | v20 & ~v22) + v19 - 40341469, 12);
  v24 = v23 + __ROL4__(v20 + v5[14] + (v22 & v23 | (v20 + v21) & ~v23) - 1502002626, 17);
  v25 = v24 + __ROL4__(v5[15] + (v24 & v23 | v22 & ~v24) + v160 + 1232341393, 22);
  v26 = v25 + __ROL4__(v5[1] + (v25 & v23 | v24 & ~v23) + v22 - 166648622, 5);
  v27 = v26 + __ROL4__(v5[6] + (v26 & v24 | v25 & ~v24) + v23 - 985615632, 9);
  v28 = v27 + __ROL4__(v5[11] + (v25 & v27 | v26 & ~v25) + v24 + 643714017, 14);
  v29 = v28 + __ROL4__(*v5 + (v26 & v28 | v27 & ~v26) + v25 - 374028774, 20);
  v30 = __ROL4__(v5[5] + (v29 & v27 | v28 & ~v27) + v26 - 702082579, 5);
  v31 = v5[10] + ((v29 + v30) & v28 | v29 & ~v28) + v27 + 39065059;
  v32 = v29 + v30;
  v33 = v32 + __ROL4__(v31, 9);
  v34 = v33 + __ROL4__(v5[15] + (v29 & v33 | v32 & ~v29) + v28 - 660515023, 14);
  v35 = v34 + __ROL4__(v5[4] + (v32 & v34 | v33 & ~v32) + v29 - 405538184, 20);
  v36 = __ROL4__(v5[9] + (v35 & v33 | v34 & ~v33) + v32 + 568642646, 5);
  v37 = v5[14] + ((v35 + v36) & v34 | v35 & ~v34) + v33 - 1019804058;
  v38 = v35 + v36;
  v39 = v38 + __ROL4__(v37, 9);
  v40 = v39 + __ROL4__(v5[3] + (v35 & v39 | v38 & ~v35) + v34 - 187366857, 14);
  v41 = v5[8];
  v42 = v40 + __ROL4__(v41 + (v38 & v40 | v39 & ~v38) + v35 + 1163531613, 20);
  v43 = __ROL4__(v5[13] + (v42 & v39 | v40 & ~v39) + v38 - 1456215883, 5);
  v161 = v42 + v43;
  v44 = v42 + v43 + __ROL4__(v5[2] + ((v42 + v43) & v40 | v42 & ~v40) + v39 - 51404216, 9);
  v45 = v44 + __ROL4__(v40 + v5[7] + (v42 & v44 | (v42 + v43) & ~v42) + 1735327849, 14);
  v46 = v45 + __ROL4__(v5[12] + (v161 & v45 | v44 & ~v161) + v42 - 1926673094, 20);
  v47 = v46 + __ROL4__(v5[5] + (v46 ^ v45 ^ v44) + v161 - 235259662, 4);
  v48 = v47 + __ROL4__(v44 + v41 + (v47 ^ v46 ^ v45) - 2022574287, 11);
  v49 = v48 + __ROL4__(v5[11] + (v47 ^ v46 ^ v48) + v45 + 1832738962, 16);
  v50 = v49 + __ROL4__(v46 + v5[14] + (v47 ^ v49 ^ v48) - 35309124, 23);
  v51 = v50 + __ROL4__(v5[1] + (v50 ^ v49 ^ v48) + v47 - 1531024396, 4);
  v52 = v51 + __ROL4__(v5[4] + (v51 ^ v50 ^ v49) + v48 + 1272889881, 11);
  v53 = v52 + __ROL4__(v5[7] + (v51 ^ v50 ^ v52) + v49 - 155694384, 16);
  v54 = v53 + __ROL4__(v5[10] + (v51 ^ v53 ^ v52) + v50 - 1094730304, 23);
  v55 = v54 + __ROL4__(v51 + v5[13] + (v54 ^ v53 ^ v52) + 680755062, 4);
  v56 = v55 + __ROL4__(*v5 + (v55 ^ v54 ^ v53) + v52 - 358537654, 11);
  v57 = v56 + __ROL4__(v5[3] + (v55 ^ v54 ^ v56) + v53 - 722501323, 16);
  v58 = v57 + __ROL4__(v54 + v5[6] + (v55 ^ v57 ^ v56) + 76029109, 23);
  v59 = v58 + __ROL4__(v5[9] + (v58 ^ v57 ^ v56) + v55 - 640363895, 4);
  v60 = v59 + __ROL4__(v5[12] + (v59 ^ v58 ^ v57) + v56 - 429156267, 11);
  v61 = v5[15] + (v59 ^ v58 ^ v60) + v57 + 530742600;
  v62 = v5[2];
  v63 = v60 + __ROL4__(v61, 16);
  v64 = v63 + __ROL4__(v58 + v62 + (v59 ^ v63 ^ v60) - 995346475, 23);
  v65 = v64 + __ROL4__(v59 + *v5 + (v63 ^ (v64 | ~v60)) - 197909516, 6);
  v66 = v65 + __ROL4__(v60 + v5[7] + (v64 ^ (v65 | ~v63)) + 1126854183, 10);
  v67 = v66 + __ROL4__(v63 + v5[14] + (v65 ^ (v66 | ~v64)) - 1416355305, 15);
  v68 = v67 + __ROL4__(v64 + v5[5] + (v66 ^ (v67 | ~v65)) - 57302647, 21);
  v69 = v68 + __ROL4__(v65 + v5[12] + (v67 ^ (v68 | ~v66)) + 1700092019, 6);
  v70 = v69 + __ROL4__(v66 + v5[3] + (v68 ^ (v69 | ~v67)) - 1894986462, 10);
  v71 = v70 + __ROL4__(v67 + v5[10] + (v69 ^ (v70 | ~v68)) - 168823347, 15);
  v72 = v71 + __ROL4__(v68 + v5[1] + (v70 ^ (v71 | ~v69)) - 2054923167, 21);
  v73 = v72 + __ROL4__(v69 + v5[8] + (v71 ^ (v72 | ~v70)) + 1873117183, 6);
  v74 = v73 + __ROL4__(v70 + v5[15] + (v72 ^ (v73 | ~v71)) - 181606576, 10);
  v75 = v74 + __ROL4__(v71 + v5[6] + (v73 ^ (v74 | ~v72)) - 1560197980, 15);
  v76 = v75 + __ROL4__(v72 + v5[13] + (v74 ^ (v75 | ~v73)) + 1309167633, 21);
  v77 = v76 + __ROL4__(v73 + v5[4] + (v75 ^ (v76 | ~v74)) - 145391822, 6);
  v78 = v77 + __ROL4__(v74 + v5[11] + (v76 ^ (v77 | ~v75)) + 1161491333, 10);
  v79 = v62 + (v77 ^ (v78 | ~v76));
  v166 = v77 + 1731535537;
  v80 = v5[9];
  v81 = v78 + __ROL4__(v75 + v79 + 718766859, 15);
  v169 = v78 + 288511430;
  v168 = v81 - 1732588210;
  v167 = __ROL4__(v80 + (v78 ^ (v81 | ~v77)) + v76 - 346631647, 21) + v81 - 271734071;
  v82 = a3;
  for ( i = 0; i < 20; ++i )
  {
    v5[i] ^= v82 + *(&v166 + (i & 3));
    v5 = *a1;
    v82 = *((_DWORD *)*a1 + i);
  }
  sub_1000BB70();
  *(_DWORD *)*a1 ^= a3;
  result = *a1;
  v85 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v86 = v85 + __ROL4__((v85 & 0xEFCDAAC9 | ~v85 & 0x98BACD4E) + *((_DWORD *)*a1 + 1) - 107344724, 12);
  v87 = v86 + __ROL4__((v85 & v86 | ~v86 & 0xEFCDAAC9) + *((_DWORD *)*a1 + 2) - 1126481991, 17);
  v88 = __ROL4__((v87 & v86 | v85 & ~v87) + *((_DWORD *)*a1 + 3) - 1319441881, 22);
  v89 = *((_DWORD *)*a1 + 4) + ((v87 + v88) & v87 | v86 & ~(v87 + v88)) + v85 - 177010401;
  v90 = v87 + v88;
  v91 = v90 + __ROL4__(v89, 7);
  v92 = v91 + __ROL4__(v86 + (v91 & v90 | v87 & ~v91) + *((_DWORD *)*a1 + 5) + 1200080794, 12);
  v93 = v92 + __ROL4__(v87 + (v91 & v92 | v90 & ~v92) + *((_DWORD *)*a1 + 6) - 1472706653, 17);
  v94 = __ROL4__(*((_DWORD *)*a1 + 7) + (v93 & v92 | v91 & ~v93) + v90 - 45706063, 22);
  v95 = *((_DWORD *)*a1 + 8) + ((v93 + v94) & v93 | v92 & ~(v93 + v94)) + v91 + 1753258344;
  v96 = v93 + v94;
  v97 = v96 + __ROL4__(v95, 7);
  v98 = v97 + __ROL4__(*((_DWORD *)*a1 + 9) + (v97 & v96 | v93 & ~v97) + v92 - 1958414817, 12);
  v99 = v98 + __ROL4__(*((_DWORD *)*a1 + 10) + (v97 & v98 | v96 & ~v98) + v93 - 7382527, 17);
  v100 = __ROL4__(*((_DWORD *)*a1 + 11) + (v99 & v98 | v97 & ~v99) + v96 - 1987258866, 22);
  v162 = v99 + v100;
  v101 = v99 + v100 + __ROL4__(*((_DWORD *)*a1 + 12) + ((v99 + v100) & v99 | v98 & ~(v99 + v100)) + v97 + 1804605842, 7);
  v102 = v101 + __ROL4__(*((_DWORD *)*a1 + 13) + (v101 & (v99 + v100) | v99 & ~v101) + v98 - 40341469, 12);
  v103 = v102 + __ROL4__(v99 + *((_DWORD *)*a1 + 14) + (v101 & v102 | (v99 + v100) & ~v102) - 1502002626, 17);
  v104 = v103 + __ROL4__(*((_DWORD *)*a1 + 15) + (v103 & v102 | v101 & ~v103) + v162 + 1232341393, 22);
  v105 = v104 + __ROL4__(*((_DWORD *)*a1 + 1) + (v104 & v102 | v103 & ~v102) + v101 - 166648622, 5);
  v106 = v105 + __ROL4__(v102 + (v105 & v103 | v104 & ~v103) + *((_DWORD *)*a1 + 6) - 985615632, 9);
  v107 = v106 + __ROL4__(*((_DWORD *)*a1 + 11) + (v104 & v106 | v105 & ~v104) + v103 + 643714017, 14);
  v108 = v107 + __ROL4__(*(_DWORD *)*a1 + (v105 & v107 | v106 & ~v105) + v104 - 374028774, 20);
  v109 = __ROL4__(*((_DWORD *)*a1 + 5) + (v108 & v106 | v107 & ~v106) + v105 - 702082579, 5);
  v110 = *((_DWORD *)*a1 + 10) + ((v108 + v109) & v107 | v108 & ~v107) + v106 + 39065059;
  v111 = v108 + v109;
  v112 = v111 + __ROL4__(v110, 9);
  v113 = v112 + __ROL4__(*((_DWORD *)*a1 + 15) + (v108 & v112 | v111 & ~v108) + v107 - 660515023, 14);
  v114 = v113 + __ROL4__(*((_DWORD *)*a1 + 4) + (v111 & v113 | v112 & ~v111) + v108 - 405538184, 20);
  v115 = __ROL4__(*((_DWORD *)*a1 + 9) + (v114 & v112 | v113 & ~v112) + v111 + 568642646, 5);
  v163 = v114 + v115;
  v116 = v114 + v115 + __ROL4__(*((_DWORD *)*a1 + 14) + ((v114 + v115) & v113 | v114 & ~v113) + v112 - 1019804058, 9);
  v117 = v116 + __ROL4__(*((_DWORD *)*a1 + 3) + v113 + (v114 & v116 | (v114 + v115) & ~v114) - 187366857, 14);
  v118 = *((_DWORD *)*a1 + 8);
  v119 = v117 + __ROL4__(v118 + (v163 & v117 | v116 & ~v163) + v114 + 1163531613, 20);
  v120 = __ROL4__(*((_DWORD *)*a1 + 13) + (v119 & v116 | v117 & ~v116) + v163 - 1456215883, 5);
  v164 = v119 + v120;
  v121 = v119 + v120 + __ROL4__(v116 + ((v119 + v120) & v117 | v119 & ~v117) + *((_DWORD *)*a1 + 2) - 51404216, 9);
  v122 = v121 + __ROL4__(v117 + *((_DWORD *)*a1 + 7) + (v119 & v121 | (v119 + v120) & ~v119) + 1735327849, 14);
  v123 = v122 + __ROL4__(*((_DWORD *)*a1 + 12) + (v164 & v122 | v121 & ~v164) + v119 - 1926673094, 20);
  v124 = v123 + __ROL4__(*((_DWORD *)*a1 + 5) + (v123 ^ v122 ^ v121) + v164 - 235259662, 4);
  v125 = v124 + __ROL4__(v121 + v118 + (v124 ^ v123 ^ v122) - 2022574287, 11);
  v126 = v125 + __ROL4__(*((_DWORD *)*a1 + 11) + (v124 ^ v123 ^ v125) + v122 + 1832738962, 16);
  v127 = v126 + __ROL4__(v123 + *((_DWORD *)*a1 + 14) + (v124 ^ v126 ^ v125) - 35309124, 23);
  v128 = v127 + __ROL4__(*((_DWORD *)*a1 + 1) + (v127 ^ v126 ^ v125) + v124 - 1531024396, 4);
  v129 = v128 + __ROL4__(v125 + (v128 ^ v127 ^ v126) + *((_DWORD *)*a1 + 4) + 1272889881, 11);
  v130 = v129 + __ROL4__(*((_DWORD *)*a1 + 7) + (v128 ^ v127 ^ v129) + v126 - 155694384, 16);
  v131 = v130 + __ROL4__(*((_DWORD *)*a1 + 10) + (v128 ^ v130 ^ v129) + v127 - 1094730304, 23);
  v132 = v131 + __ROL4__(*((_DWORD *)*a1 + 13) + (v131 ^ v130 ^ v129) + v128 + 680755062, 4);
  v133 = v132 + __ROL4__(v129 + (v132 ^ v131 ^ v130) + *(_DWORD *)*a1 - 358537654, 11);
  v134 = v133 + __ROL4__(v130 + (v132 ^ v131 ^ v133) + *((_DWORD *)*a1 + 3) - 722501323, 16);
  v135 = v134 + __ROL4__(v131 + *((_DWORD *)*a1 + 6) + (v132 ^ v134 ^ v133) + 76029109, 23);
  v136 = v135 + __ROL4__(*((_DWORD *)*a1 + 9) + (v135 ^ v134 ^ v133) + v132 - 640363895, 4);
  v137 = v136 + __ROL4__(*((_DWORD *)*a1 + 12) + (v136 ^ v135 ^ v134) + v133 - 429156267, 11);
  v138 = *((_DWORD *)*a1 + 2);
  v139 = v137 + __ROL4__(*((_DWORD *)*a1 + 15) + (v136 ^ v135 ^ v137) + v134 + 530742600, 16);
  v140 = v139 + __ROL4__(v138 + (v136 ^ v139 ^ v137) + v135 - 995346475, 23);
  v141 = v140 + __ROL4__(*(_DWORD *)*a1 + (v139 ^ (v140 | ~v137)) + v136 - 197909516, 6);
  v142 = v141 + __ROL4__(*((_DWORD *)*a1 + 7) + (v140 ^ (v141 | ~v139)) + v137 + 1126854183, 10);
  v143 = v142 + __ROL4__(*((_DWORD *)*a1 + 14) + (v141 ^ (v142 | ~v140)) + v139 - 1416355305, 15);
  v144 = v143 + __ROL4__(*((_DWORD *)*a1 + 5) + (v142 ^ (v143 | ~v141)) + v140 - 57302647, 21);
  v145 = v144 + __ROL4__(*((_DWORD *)*a1 + 12) + (v143 ^ (v144 | ~v142)) + v141 + 1700092019, 6);
  v146 = v145 + __ROL4__(v142 + (v144 ^ (v145 | ~v143)) + *((_DWORD *)*a1 + 3) - 1894986462, 10);
  v147 = v146 + __ROL4__(*((_DWORD *)*a1 + 10) + (v145 ^ (v146 | ~v144)) + v143 - 168823347, 15);
  v148 = v147 + __ROL4__(*((_DWORD *)*a1 + 1) + (v146 ^ (v147 | ~v145)) + v144 - 2054923167, 21);
  v149 = v148 + __ROL4__(*((_DWORD *)*a1 + 8) + (v147 ^ (v148 | ~v146)) + v145 + 1873117183, 6);
  v150 = v149 + __ROL4__(*((_DWORD *)*a1 + 15) + (v148 ^ (v149 | ~v147)) + v146 - 181606576, 10);
  v151 = v150 + __ROL4__(v147 + (v149 ^ (v150 | ~v148)) + *((_DWORD *)*a1 + 6) - 1560197980, 15);
  v152 = v151 + __ROL4__(*((_DWORD *)*a1 + 13) + (v150 ^ (v151 | ~v149)) + v148 + 1309167633, 21);
  v153 = v152 + __ROL4__(*((_DWORD *)*a1 + 4) + (v151 ^ (v152 | ~v150)) + v149 - 145391822, 6);
  v154 = v153 + __ROL4__(*((_DWORD *)*a1 + 11) + (v152 ^ (v153 | ~v151)) + v150 + 1161491333, 10);
  v155 = v151 + (v153 ^ (v154 | ~v152)) + v138 + 718766859;
  v156 = *((_DWORD *)*a1 + 9);
  v157 = v154 + __ROL4__(v155, 15);
  v166 = v153 + 1731535537;
  v169 = v154 + 288511430;
  v167 = __ROL4__(v156 + (v154 ^ (v157 | ~v153)) + v152 - 346631647, 21) + v157 - 271734071;
  v168 = v157 - 1732588210;
  v158 = a3;
  for ( j = 0; j < 20; ++j )
  {
    result[j] ^= v158 + *(&v166 + (j & 3));
    result = *a1;
    v158 = *((_DWORD *)*a1 + j);
  }
  return result;
}

//----- (10009680) --------------------------------------------------------
char __thiscall ContinuumEncrypt(void *this, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // esi
  _DWORD *v8; // ebx
  int v9; // edx
  int *v10; // edx
  unsigned int v11; // edi
  int v12; // ebp
  int *v13; // edx
  int v14; // edi
  int v15; // edx
  int *v16; // esi
  unsigned int v17; // edi
  char v18; // dl
  int v21; // [esp+18h] [ebp+4h]
  unsigned int v22; // [esp+1Ch] [ebp+8h]
  int v23; // [esp+20h] [ebp+Ch]

  v4 = a4;
  v5 = 0;
  v6 = 0;
  v7 = (char *)a2;
  v8 = (_DWORD *)a3;
  if ( a4 > 7 )
  {
    v9 = a3 - a2;
    v21 = a3 - a2;
    v22 = a4 >> 3;
    while ( 1 )
    {
      v5 ^= *v8;
      v6 ^= *(_DWORD *)&v7[v9 + 4];
      v10 = *(int **)this;
      v11 = *(_DWORD *)this + 80;
      if ( *(_DWORD *)this < v11 )
      {
        do
        {
          v12 = *v10;
          v10 += 2;
          v5 = __ROL4__(v5 + v12, v6);
          v6 = __ROL4__(v6 + *(v10 - 1), v5);
        }
        while ( (unsigned int)v10 < v11 );
        v4 = a4;
      }
      *(_DWORD *)v7 = v5;
      *((_DWORD *)v7 + 1) = v6;
      v8 += 2;
      v7 += 8;
      v4 -= 8;
      a4 = v4;
      if ( !--v22 )
        break;
      v9 = v21;
    }
  }
  if ( v4 > 3 )
  {
    v5 ^= *v8;
    v13 = *(int **)this;
    if ( *(_DWORD *)this < (unsigned int)(*(_DWORD *)this + 80) )
    {
      do
      {
        v14 = *v13;
        v13 += 2;
        v5 = __ROL4__(v5 + v14, v6);
        v6 += *(v13 - 1);
      }
      while ( (unsigned int)v13 < *(_DWORD *)this + 80 );
    }
    *(_DWORD *)v7 = v5;
    ++v8;
    v7 += 4;
    v4 -= 4;
  }
  if ( v4 )
  {
    v15 = v7 - (char *)v8;
    v23 = v7 - (char *)v8;
    do
    {
      LOBYTE(v5) = *(_BYTE *)v8 ^ v5;
      v16 = *(int **)this;
      v17 = *(_DWORD *)this + 80;
      if ( *(_DWORD *)this < v17 )
      {
        do
        {
          v18 = *(_BYTE *)v16;
          v16 += 2;
          LOBYTE(v5) = v6 + v18 + v5;
          v6 += *(v16 - 1);
        }
        while ( (unsigned int)v16 < v17 );
        v15 = v23;
      }
      *((_BYTE *)v8 + v15) = v5;
      v8 = (_DWORD *)((char *)v8 + 1);
      --v4;
    }
    while ( v4 );
  }
  return v5;
}

//----- (10009790) --------------------------------------------------------
unsigned int __thiscall ContinuumDecrypt(void *this, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax
  int *v5; // ebx
  int i; // ebp
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // edx
  int v11; // ebx
  unsigned int v12; // ecx
  _BOOL1 v13; // zf
  int v14; // edi
  int v15; // ecx
  unsigned int v16; // edx
  _DWORD *v17; // eax
  int v18; // ebp
  char *v19; // edi
  char v20; // bl
  int v21; // ecx
  unsigned int v22; // esi
  unsigned int v23; // edx
  _BYTE *v24; // eax
  int v25; // ebp
  int v26; // edx
  char v27; // dl
  int v28; // [esp+10h] [ebp-Ch]
  int v30; // [esp+18h] [ebp-4h]
  unsigned int v31; // [esp+20h] [ebp+4h]
  int v32; // [esp+24h] [ebp+8h]
  char *v33; // [esp+24h] [ebp+8h]
  unsigned int v34; // [esp+28h] [ebp+Ch]

  result = a4;
  v5 = (int *)a2;
  i = 0;
  v28 = 0;
  v32 = a2;
  if ( a4 > 7 )
  {
    v30 = a2 - a3;
    v31 = a4 >> 3;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = (_DWORD *)(*(_DWORD *)this + 80);
      if ( (unsigned int)v10 > *(_DWORD *)this )
      {
        do
        {
          v11 = *(v10 - 1);
          v10 -= 2;
          v9 = __ROR4__(v9, v8) - v11;
          v8 = __ROR4__(v8, v9) - *v10;
        }
        while ( (unsigned int)v10 > *(_DWORD *)this );
        v5 = (int *)v32;
      }
      a3 += 8;
      *v5 = v28 ^ v8;
      v5 += 2;
      *(_DWORD *)(v30 + a3 - 4) = i ^ v9;
      i = *(_DWORD *)(a3 - 4);
      v12 = a4 - 8;
      v13 = v31 == 1;
      v28 = *(_DWORD *)(a3 - 8);
      v32 = (int)v5;
      a4 -= 8;
      --v31;
    }
    while ( !v13 );
    result = v12;
  }
  if ( result > 3 )
  {
    v14 = *(_DWORD *)a3;
    v15 = i;
    v16 = *(_DWORD *)this;
    v17 = (_DWORD *)(*(_DWORD *)this + 80);
    if ( *(_DWORD *)this < (unsigned int)v17 )
    {
      do
      {
        v18 = *(_DWORD *)(v16 + 4);
        v16 += 8;
        v15 += v18;
      }
      while ( v16 < (unsigned int)v17 );
    }
    for ( i = v15; (unsigned int)v17 > *(_DWORD *)this; v14 = __ROR4__(v14, v15) - *v17 )
    {
      v15 -= *(v17 - 1);
      v17 -= 2;
    }
    a3 += 4;
    *v5 = v28 ^ v14;
    v28 = *(_DWORD *)(a3 - 4);
    ++v5;
    result = a4 - 4;
  }
  v19 = (char *)a3;
  if ( result )
  {
    v34 = result;
    v33 = (char *)v5 - a3;
    do
    {
      v20 = *v19;
      v21 = i;
      v22 = *(_DWORD *)this;
      v23 = *(_DWORD *)this;
      v24 = (_BYTE *)(*(_DWORD *)this + 80);
      if ( *(_DWORD *)this < (unsigned int)v24 )
      {
        do
        {
          v25 = *(_DWORD *)(v23 + 4);
          v23 += 8;
          v21 += v25;
        }
        while ( v23 < (unsigned int)v24 );
      }
      for ( i = v21; (unsigned int)v24 > v22; v20 -= v21 + *v24 )
      {
        v26 = *((_DWORD *)v24 - 1);
        v24 -= 8;
        v21 -= v26;
      }
      v19[(_DWORD)v33] = v20 ^ v28;
      v27 = *v19++;
      result = v34 - 1;
      v13 = v34 == 1;
      LOBYTE(v28) = v27;
      --v34;
    }
    while ( !v13 );
  }
  return result;
}

//----- (10009920) --------------------------------------------------------
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // edx
  int v21; // esi
  int v22; // edi
  int v23; // ebx
  int v24; // edx
  int v25; // esi
  int v26; // edi
  int v27; // ebx
  int v28; // edx
  int v29; // esi
  int v30; // edi
  int v31; // ebx
  int v32; // ecx
  int v33; // esi
  int v34; // ecx
  int v35; // esi
  int v36; // edi
  int v37; // edx
  int v38; // ebx
  int v39; // ecx
  int v40; // esi
  int v41; // edi
  int v42; // ebx
  int v43; // ecx
  int v44; // esi
  int v45; // edi
  int v46; // ebx
  int v47; // ecx
  int v48; // esi
  int v49; // edi
  int v50; // edx
  int v51; // ecx
  int v52; // esi
  int v53; // edi
  int v54; // edx
  int v55; // ecx
  int v56; // esi
  int v57; // ebp
  int v58; // edi
  int v59; // edx
  int v60; // ecx
  int v61; // esi
  int v62; // edi
  int v63; // edx
  int v64; // ecx
  int v65; // esi
  int v66; // edi
  int v67; // edx
  int v68; // ecx
  int v69; // esi
  int v70; // edi
  int v71; // ebx
  int v72; // edx
  int v73; // esi
  int v74; // ecx
  int v75; // ebp
  int v76; // edi
  int v77; // ecx
  int v78; // edx
  int i; // ecx
  int v80; // [esp+10h] [ebp-20h]
  int v81; // [esp+10h] [ebp-20h]
  int v82; // [esp+10h] [ebp-20h]
  int v84[4]; // [esp+20h] [ebp-10h]

  **(_DWORD **)this ^= a2;
  result = *(_DWORD **)this;
  v3 = __ROL4__(**(_DWORD **)this - 681945657, 7) - 271734071;
  v4 = v3 + __ROL4__((v3 & 0xEFCDAAC9 | ~v3 & 0x98BACD4E) + *(_DWORD *)(*(_DWORD *)this + 4) - 107344724, 12);
  v5 = v4 + __ROL4__((v3 & v4 | ~v4 & 0xEFCDAAC9) + *(_DWORD *)(*(_DWORD *)this + 8) - 1126481991, 17);
  v6 = *(_DWORD *)(*(_DWORD *)this + 16);
  v7 = __ROL4__((v5 & v4 | v3 & ~v5) + *(_DWORD *)(*(_DWORD *)this + 12) - 1319441881, 22);
  v8 = v6 + ((v5 + v7) & v5 | v4 & ~(v5 + v7)) + v3 - 177010401;
  v9 = v5 + v7;
  v10 = v9 + __ROL4__(v8, 7);
  v11 = v10 + __ROL4__(result[5] + (v10 & v9 | v5 & ~v10) + v4 + 1200080794, 12);
  v12 = v11 + __ROL4__(result[6] + (v10 & v11 | v9 & ~v11) + v5 - 1472706653, 17);
  v13 = __ROL4__(result[7] + (v12 & v11 | v10 & ~v12) + v9 - 45706063, 22);
  v14 = result[8] + ((v12 + v13) & v12 | v11 & ~(v12 + v13)) + v10 + 1753258344;
  v15 = v12 + v13;
  v16 = v15 + __ROL4__(v14, 7);
  v17 = v16 + __ROL4__(result[9] + (v16 & v15 | v12 & ~v16) + v11 - 1958414817, 12);
  v18 = v17 + __ROL4__(result[10] + (v16 & v17 | v15 & ~v17) + v12 - 7382527, 17);
  v19 = __ROL4__(result[11] + (v18 & v17 | v16 & ~v18) + v15 - 1987258866, 22);
  v80 = v18 + v19;
  v20 = v18 + v19 + __ROL4__(result[12] + ((v18 + v19) & v18 | v17 & ~(v18 + v19)) + v16 + 1804605842, 7);
  v21 = v20 + __ROL4__(result[13] + (v20 & (v18 + v19) | v18 & ~v20) + v17 - 40341469, 12);
  v22 = v21 + __ROL4__(v18 + result[14] + (v20 & v21 | (v18 + v19) & ~v21) - 1502002626, 17);
  v23 = v22 + __ROL4__(result[15] + (v22 & v21 | v20 & ~v22) + v80 + 1232341393, 22);
  v24 = v23 + __ROL4__(result[1] + (v23 & v21 | v22 & ~v21) + v20 - 166648622, 5);
  v25 = v24 + __ROL4__(result[6] + (v24 & v22 | v23 & ~v22) + v21 - 985615632, 9);
  v26 = v25 + __ROL4__(result[11] + (v23 & v25 | v24 & ~v23) + v22 + 643714017, 14);
  v27 = v26 + __ROL4__(*result + (v24 & v26 | v25 & ~v24) + v23 - 374028774, 20);
  v28 = __ROL4__(result[5] + (v27 & v25 | v26 & ~v25) + v24 - 702082579, 5);
  v81 = v27 + v28;
  v29 = v27 + v28 + __ROL4__(result[10] + ((v27 + v28) & v26 | v27 & ~v26) + v25 + 39065059, 9);
  v30 = v29 + __ROL4__(result[15] + (v27 & v29 | (v27 + v28) & ~v27) + v26 - 660515023, 14);
  v31 = v30 + __ROL4__(result[4] + ((v27 + v28) & v30 | v29 & ~(v27 + v28)) + v27 - 405538184, 20);
  v32 = __ROL4__(result[9] + (v31 & v29 | v30 & ~v29) + v81 + 568642646, 5);
  v33 = result[14] + ((v31 + v32) & v30 | v31 & ~v30) + v29 - 1019804058;
  v34 = v31 + v32;
  v35 = v34 + __ROL4__(v33, 9);
  v36 = v35 + __ROL4__(result[3] + (v31 & v35 | v34 & ~v31) + v30 - 187366857, 14);
  v37 = result[8];
  v38 = v36 + __ROL4__(v37 + (v34 & v36 | v35 & ~v34) + v31 + 1163531613, 20);
  v39 = __ROL4__(result[13] + (v38 & v35 | v36 & ~v35) + v34 - 1456215883, 5);
  v82 = v38 + v39;
  v40 = v38 + v39 + __ROL4__(result[2] + ((v38 + v39) & v36 | v38 & ~v36) + v35 - 51404216, 9);
  v41 = v40 + __ROL4__(v36 + result[7] + (v38 & v40 | (v38 + v39) & ~v38) + 1735327849, 14);
  v42 = v41 + __ROL4__(result[12] + (v82 & v41 | v40 & ~v82) + v38 - 1926673094, 20);
  v43 = v42 + __ROL4__(result[5] + (v42 ^ v41 ^ v40) + v82 - 235259662, 4);
  v44 = v43 + __ROL4__(v40 + v37 + (v43 ^ v42 ^ v41) - 2022574287, 11);
  v45 = v44 + __ROL4__(result[11] + (v43 ^ v42 ^ v44) + v41 + 1832738962, 16);
  v46 = v45 + __ROL4__(v42 + result[14] + (v43 ^ v45 ^ v44) - 35309124, 23);
  v47 = v46 + __ROL4__(result[1] + (v46 ^ v45 ^ v44) + v43 - 1531024396, 4);
  v48 = v47 + __ROL4__(result[4] + (v47 ^ v46 ^ v45) + v44 + 1272889881, 11);
  v49 = v48 + __ROL4__(result[7] + (v47 ^ v46 ^ v48) + v45 - 155694384, 16);
  v50 = v49 + __ROL4__(result[10] + (v47 ^ v49 ^ v48) + v46 - 1094730304, 23);
  v51 = v50 + __ROL4__(v47 + result[13] + (v50 ^ v49 ^ v48) + 680755062, 4);
  v52 = v51 + __ROL4__(*result + (v51 ^ v50 ^ v49) + v48 - 358537654, 11);
  v53 = v52 + __ROL4__(result[3] + (v51 ^ v50 ^ v52) + v49 - 722501323, 16);
  v54 = v53 + __ROL4__(v50 + result[6] + (v51 ^ v53 ^ v52) + 76029109, 23);
  v55 = v54 + __ROL4__(result[9] + (v54 ^ v53 ^ v52) + v51 - 640363895, 4);
  v56 = v55 + __ROL4__(result[12] + (v55 ^ v54 ^ v53) + v52 - 429156267, 11);
  v57 = result[2];
  v58 = v56 + __ROL4__(result[15] + (v55 ^ v54 ^ v56) + v53 + 530742600, 16);
  v59 = v58 + __ROL4__(v57 + (v55 ^ v58 ^ v56) + v54 - 995346475, 23);
  v60 = v59 + __ROL4__(*result + (v58 ^ (v59 | ~v56)) + v55 - 197909516, 6);
  v61 = v60 + __ROL4__(result[7] + (v59 ^ (v60 | ~v58)) + v56 + 1126854183, 10);
  v62 = v61 + __ROL4__(result[14] + (v60 ^ (v61 | ~v59)) + v58 - 1416355305, 15);
  v63 = v62 + __ROL4__(result[5] + (v61 ^ (v62 | ~v60)) + v59 - 57302647, 21);
  v64 = v63 + __ROL4__(result[12] + (v62 ^ (v63 | ~v61)) + v60 + 1700092019, 6);
  v65 = v64 + __ROL4__(result[3] + (v63 ^ (v64 | ~v62)) + v61 - 1894986462, 10);
  v66 = v65 + __ROL4__(result[10] + (v64 ^ (v65 | ~v63)) + v62 - 168823347, 15);
  v67 = v66 + __ROL4__(result[1] + (v65 ^ (v66 | ~v64)) + v63 - 2054923167, 21);
  v68 = v67 + __ROL4__(result[8] + (v66 ^ (v67 | ~v65)) + v64 + 1873117183, 6);
  v69 = v68 + __ROL4__(result[15] + (v67 ^ (v68 | ~v66)) + v65 - 181606576, 10);
  v70 = v69 + __ROL4__(result[6] + (v68 ^ (v69 | ~v67)) + v66 - 1560197980, 15);
  v71 = v70 + __ROL4__(result[13] + (v69 ^ (v70 | ~v68)) + v67 + 1309167633, 21);
  v72 = v71 + __ROL4__(result[4] + (v70 ^ (v71 | ~v69)) + v68 - 145391822, 6);
  v73 = v72 + __ROL4__(result[11] + (v71 ^ (v72 | ~v70)) + v69 + 1161491333, 10);
  v74 = v57 + (v72 ^ (v73 | ~v71));
  v75 = result[9];
  v76 = v73 + __ROL4__(v74 + v70 + 718766859, 15);
  v84[0] = v72 + 1731535537;
  v84[3] = v73 + 288511430;
  v77 = __ROL4__(v75 + (v73 ^ (v76 | ~v72)) + v71 - 346631647, 21) + v76 - 271734071;
  v78 = a2;
  v84[1] = v77;
  v84[2] = v76 - 1732588210;
  for ( i = 0; i < 20; ++i )
  {
    result[i] ^= v78 + v84[i & 3];
    result = *(_DWORD **)this;
    v78 = *(_DWORD *)(*(_DWORD *)this + 4 * i);
  }
  return result;
}

//----- (1000A060) --------------------------------------------------------
size_t __thiscall sub_1000A060(void *this, int a2, const void *a3, size_t a4)
{
  char v5; // cl
  size_t result; // eax
  char v7; // bl
  size_t v8; // ecx
  size_t v9; // esi
  char v10; // cl
  unsigned __int8 v11; // [esp+8h] [ebp-210h]
  char v12; // [esp+Ch] [ebp-20Ch] BYREF
  char v13[523]; // [esp+Dh] [ebp-20Bh] BYREF

  if ( !*(_BYTE *)a3 && ((v5 = *((_BYTE *)a3 + 1), v5 == 1) || v5 == 16 || v5 == 17) )
  {
    memcpy_0((void *)a2, a3, a4);
    result = a4;
  }
  else
  {
    v7 = 0;
    v11 = 0;
    if ( a4 )
    {
      v8 = a4;
      do
      {
        --v8;
        v7 = byte_1002182C[*(unsigned __int8 *)a3 ^ v11];
        v11 = v7;
      }
      while ( v8 );
    }
    memcpy_0(v13, a3, a4);
    v9 = a4 + 1;
    v12 = v7;
    ContinuumEncrypt(this, a2, (int)&v12, a4 + 1);
    if ( !*(_BYTE *)a2 && ((v10 = *(_BYTE *)(a2 + 1), v10 == 1) || v10 == 16 || v10 == 17) || *(_BYTE *)a2 == 0xFF )
    {
      memcpy_0((void *)(a2 + 1), (const void *)a2, v9);
      *(_BYTE *)a2 = -1;
      v9 = a4 + 2;
    }
    result = v9;
  }
  return result;
}

//----- (1000A150) --------------------------------------------------------
unsigned int __thiscall sub_1000A150(void *this, void *a2, int a3, unsigned int a4)
{
  int v4; // edi
  char v5; // bl
  unsigned int v6; // esi
  char v7; // dl
  unsigned int v8; // esi
  char v10; // dl
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  char v14; // cl
  unsigned int v15; // edx
  int *v16; // [esp-8h] [ebp-224h]
  unsigned int v17; // [esp-4h] [ebp-220h]
  unsigned __int8 v18; // [esp+Ch] [ebp-210h]
  unsigned __int8 v19; // [esp+Ch] [ebp-210h]
  char v20; // [esp+10h] [ebp-20Ch] BYREF
  unsigned __int8 v21[523]; // [esp+11h] [ebp-20Bh] BYREF

  v4 = a3;
  if ( !*(_BYTE *)a3 && ((v5 = *(_BYTE *)(a3 + 1), v5 == 1) || v5 == 16 || v5 == 17) )
  {
    v6 = a4;
    v17 = a4;
    v16 = (int *)a3;
  }
  else
  {
    if ( *(_BYTE *)a3 == 0xFF && ((v7 = *(_BYTE *)(a3 + 1)) == 0 || v7 == -1) )
    {
      v4 = a3 + 1;
      v8 = a4 - 1;
    }
    else
    {
      v8 = a4;
    }
    if ( !v8 )
      return 0;
    ContinuumDecrypt(this, (int)&v20, v4, v8);
    v10 = 0;
    v18 = 0;
    v11 = (int *)v21;
    if ( v8 != 1 )
    {
      v12 = v8 - 2 + 1;
      do
      {
        v13 = v18 ^ *(unsigned __int8 *)v11;
        v11 = (int *)((char *)v11 + 1);
        --v12;
        v10 = byte_1002182C[v13];
        v18 = v10;
      }
      while ( v12 );
    }
    if ( v20 != v10 )
    {
      v14 = 0;
      v19 = 0;
      if ( v8 > 1 )
      {
        v15 = v8 - 1;
        do
        {
          --v15;
          v14 = byte_1002182C[v21[0] ^ v19];
          v19 = v14;
        }
        while ( v15 );
      }
      if ( v20 != v14 )
        return 0;
    }
    v6 = v8 - 1;
    v17 = v6;
    v16 = (int *)v21;
  }
  memcpy_0(a2, v16, v17);
  return v6;
}

//----- (1000A270) --------------------------------------------------------
char __thiscall sub_1000A270(int this, int a2)
{
  _BYTE *v2; // ebp
  int v4; // edi
  int i; // esi

  v2 = (_BYTE *)a2;
  if ( !*(_BYTE *)a2 )
    a2 = (int)"$pub";
  v4 = 0;
  if ( !*(_DWORD *)(this + 1036) )
    return 0;
  for ( i = this + 12;
        unknown_libname_69(a2, i) && (!*v2 || unknown_libname_69(i, "$pvt") || !unknown_libname_69(v2, "$login"));
        i += 32 )
  {
    if ( (unsigned int)++v4 >= *(_DWORD *)(this + 1036) )
      return 0;
  }
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000A300) --------------------------------------------------------
bool __thiscall sub_1000A300(int this, int a2)
{
  return *(_DWORD *)(this + 4) == *(_DWORD *)(a2 + 4)
      && *(_DWORD *)(this + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(this + 1036) == *(_DWORD *)(a2 + 1036)
      && *(_BYTE *)(this + 1041) == *(_BYTE *)(a2 + 1041)
      && *(_BYTE *)(this + 1040) == *(_BYTE *)(a2 + 1040)
      && !memcmp((const void *)(this + 12), (const void *)(a2 + 12), 0x400u);
}

//----- (1000A370) --------------------------------------------------------
_DWORD *__thiscall sub_1000A370(int this)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)this;
  *(_DWORD *)(this + 16736) = this + 16740;
  *(_DWORD *)(this + 25732) = 0;
  *(_DWORD *)(this + 25736) = 32;
  `eh vector constructor iterator'(this + 25740, 440, 300, sub_1000A420, sub_1000A440);
  *v1 = &off_10021958;
  v1[4183] = 0;
  v1[39435] = 0;
  v1[39693] = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  v1[39694] = 0;
  v1[39696] = 0;
  v1[39695] = 0;
  v1[39692] = 0;
  return v1;
}
// 100170B8: using guessed type _DWORD __stdcall `eh vector constructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10021958: using guessed type void *off_10021958;

//----- (1000A420) --------------------------------------------------------
int __thiscall sub_1000A420(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 428) = 0;
  *(_DWORD *)(this + 40) = this + 44;
  *(_DWORD *)(this + 432) = 16;
  return result;
}

//----- (1000A440) --------------------------------------------------------
int __thiscall sub_1000A440(int this)
{
  void *v2; // ecx
  int result; // eax

  v2 = *(void **)(this + 40);
  if ( v2 != (void *)(this + 44) )
  {
    result = sub_10002D60(v2);
    *(_DWORD *)(this + 40) = this + 44;
  }
  *(_DWORD *)(this + 428) = 0;
  *(_DWORD *)(this + 432) = 16;
  return result;
}

//----- (1000A470) --------------------------------------------------------
int __thiscall sub_1000A470(void *this, LPCSTR lpFileName)
{
  int v2; // ebp
  void (*v3)(void); // ebx
  int v4; // esi
  unsigned int i; // eax
  char *v6; // esi
  int v7; // esi
  int v8; // ebp
  int v9; // edx
  int v10; // eax
  int (__cdecl *v11)(CHAR *, const char *, int, LPCSTR); // ebp
  int v12; // eax
  int v13; // eax
  int v14; // edx
  unsigned int v15; // eax
  int j; // ebp
  char *v17; // esi
  char *v18; // edi
  char *v19; // edx
  int result; // eax
  char v21; // cl
  int v22; // eax
  unsigned int v23; // edi
  _DWORD *v24; // esi
  _DWORD *v25; // ecx
  _BYTE v26[5]; // [esp+1h] [ebp-43E1h]
  CHAR *v27; // [esp+6h] [ebp-43DCh]
  int v28; // [esp+22h] [ebp-43C0h] BYREF
  int *v29; // [esp+26h] [ebp-43BCh]
  const char *v30; // [esp+2Ah] [ebp-43B8h]
  int v31; // [esp+2Eh] [ebp-43B4h]
  LPCSTR v32; // [esp+32h] [ebp-43B0h] BYREF
  CHAR *v33; // [esp+36h] [ebp-43ACh]
  const char *v34; // [esp+3Ah] [ebp-43A8h] BYREF
  int v35; // [esp+3Eh] [ebp-43A4h]
  LPCSTR v36; // [esp+42h] [ebp-43A0h]
  int v37; // [esp+46h] [ebp-439Ch]
  int v38[2]; // [esp+4Ah] [ebp-4398h] BYREF
  _DWORD v39[2]; // [esp+52h] [ebp-4390h] BYREF
  char *v40; // [esp+5Ah] [ebp-4388h]
  int v41; // [esp+5Eh] [ebp-4384h]
  int v42; // [esp+66h] [ebp-437Ch]
  int v43[2]; // [esp+6Ah] [ebp-4378h] BYREF
  int v44; // [esp+72h] [ebp-4370h] BYREF
  int v45; // [esp+76h] [ebp-436Ch]
  CHAR AppName[16]; // [esp+7Ah] [ebp-4368h] BYREF
  CHAR v47[24]; // [esp+8Ah] [ebp-4358h] BYREF
  CHAR ReturnedString[400]; // [esp+A2h] [ebp-4340h] BYREF
  char v49[8]; // [esp+232h] [ebp-41B0h] BYREF
  char v50; // [esp+23Ah] [ebp-41A8h] BYREF
  char v51[16728]; // [esp+28Ah] [ebp-4158h] BYREF

  v2 = (int)this;
  v43[1] = (int)this;
  v43[0] = FIX_DLL_KERNEL32_dll_GetTickCount(v37, v38[0], v38[1]);
  memset(v51, 0, sizeof(v51));
  v3 = *(void (**)(void))GetPrivateProfileStringA_0;
  v4 = 0;
  v45 = 0;
  GetPrivateProfileStringA_0("Peers", "MyArenas", byte_10028A9C, ReturnedString, 0x1FFu, lpFileName);
  for ( i = *(_DWORD *)(v2 + 158768); i < 0x20; ++v4 )
  {
    if ( !sub_10002E30((void *)(32 * i + v2 + 157744), 32, (int)v47, 0x2Cu, v4) )
      break;
    if ( *(_BYTE *)(32 * *(_DWORD *)(v2 + 158768) + v2 + 157744) )
      ++*(_DWORD *)(v2 + 158768);
    i = *(_DWORD *)(v2 + 158768);
  }
  v6 = 0;
  v42 = 0;
  v40 = v51;
  do
  {
    sprintf_0(AppName, "Peer%d", v6);
    ((void (__stdcall *)(CHAR *, const char *, char *, CHAR *, int, LPCSTR))v3)(
      AppName,
      "Address",
      byte_10028A9C,
      v47,
      511,
      lpFileName);
    sub_10006300(&v44, v47);
    if ( v44 )
    {
      v7 = (int)v40;
      v8 = v41 + 1;
      v36 = lpFileName;
      v40 += 2091;
      v9 = v45;
      *(_DWORD *)(v7 + 4) = v44;
      v10 = v43[0];
      v35 = 0;
      v41 = v8;
      v11 = (int (__cdecl *)(CHAR *, const char *, int, LPCSTR))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
      v34 = "SendOnly";
      v33 = AppName;
      *(_DWORD *)(v7 + 8) = v9;
      *(_DWORD *)(v7 + 1058) = v10;
      *(_BYTE *)(v7 + 2090) = 0;
      v12 = v11(v33, v34, v35, v36);
      v32 = lpFileName;
      v31 = 1;
      v30 = "SendPlayerList";
      v29 = v43;
      *(_BYTE *)(v7 + 1041) = v12 != 0;
      v13 = v11((CHAR *)v29, v30, v31, v32);
      v14 = v39[0];
      *(_WORD *)(v7 + 1042) = 2;
      v28 = v14;
      *(_BYTE *)(v7 + 1040) = v13 != 0;
      *(_DWORD *)(v7 + 1046) = j_FIX_DLL_WSOCK32_dll_ord_0008(v28);
      v27 = (CHAR *)v39;
      *(_WORD *)(v7 + 1044) = j_FIX_DLL_WSOCK32_dll_ord_0009(v39[0]);
      v3();
      v28 = -1;
      sub_10001120(&v28, (const char *)v38);
      *(_DWORD *)v7 = v28;
      ((void (__cdecl *)(const char **, const char *, char *, int *, int, LPCSTR))v3)(
        &v34,
        "Arenas",
        byte_10028A9C,
        v38,
        511,
        lpFileName);
      v15 = *(_DWORD *)(v7 + 1036);
      for ( j = 0; v15 < 0x20; ++j )
      {
        if ( !sub_10002E30((void *)(32 * v15 + v7 + 12), 32, (int)&v32, 0x2Cu, j) )
          break;
        if ( *(_BYTE *)(32 * *(_DWORD *)(v7 + 1036) + v7 + 12) )
          ++*(_DWORD *)(v7 + 1036);
        v15 = *(_DWORD *)(v7 + 1036);
      }
      v6 = byte_10028A9C;
      v2 = 511;
    }
    ++v6;
  }
  while ( (unsigned int)v6 < 8 );
  v26[4] = 0;
  *(_DWORD *)v26 = v27 != *(CHAR **)(v2 + 16732);
  if ( v27 == *(CHAR **)(v2 + 16732) )
  {
    v17 = &v51[-v2 + 936];
    v18 = &v51[-v2 + 941];
    v19 = &v50;
    result = v2 + 12;
    while ( *(_DWORD *)&v26[1] < (unsigned int)v27 )
    {
      if ( *((_DWORD *)v19 - 1) == *(_DWORD *)(result - 4)
        && *(_DWORD *)v19 == *(_DWORD *)result
        && *(_DWORD *)&v17[result] == *(_DWORD *)(result + 1028)
        && v18[result] == *(_BYTE *)(result + 1033)
        && v51[result + 940 - v2] == *(_BYTE *)(result + 1032)
        && !memcmp(&v49[result - v2], (const void *)(result + 4), 0x400u) )
      {
        v21 = v26[0];
      }
      else
      {
        v21 = 1;
        v26[0] = 1;
      }
      result += 2091;
      v19 += 2091;
      ++*(_DWORD *)&v26[1];
      if ( v21 )
        goto LABEL_30;
      v18 = &v51[-v2 + 941];
      v17 = &v51[-v2 + 936];
    }
  }
  else
  {
LABEL_30:
    memcpy_0((void *)(v2 + 4), v49, 0x4158u);
    v22 = *(_DWORD *)(v2 + 157740);
    v23 = 0;
    *(_DWORD *)(v2 + 16732) = v27;
    if ( v22 )
    {
      v24 = (_DWORD *)(v2 + 26168);
      do
      {
        v25 = (_DWORD *)*(v24 - 97);
        if ( v25 != v24 - 96 )
        {
          sub_10002D60(v25);
          *(v24 - 97) = v24 - 96;
        }
        *v24 = 0;
        v24[1] = 16;
        ++v23;
        v24 += 110;
      }
      while ( v23 < *(_DWORD *)(v2 + 157740) );
    }
    result = 0;
    *(_DWORD *)(v2 + 157740) = 0;
    *(_DWORD *)(v2 + 158784) = 0;
  }
  return result;
}
// 1000A7BF: conditional instruction was optimized away because of 'cl.1==0'
// 1000A6E6: variable 'v27' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;

//----- (1000A860) --------------------------------------------------------
char __thiscall sub_1000A860(int this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  unsigned int v7; // edx
  unsigned __int16 *i; // ecx
  int v9; // ecx
  int v10; // esi
  int v11; // ebp

  v6 = 0;
  v7 = *(_DWORD *)(this + 16732);
  if ( v7 )
  {
    for ( i = (unsigned __int16 *)(this + 1048);
          *(_DWORD *)(i + 1) != a4 || *i != a5;
          i = (unsigned __int16 *)((char *)i + 2091) )
    {
      if ( ++v6 >= v7 )
        return v6;
    }
    v6 *= 697;
    v9 = this + 2 * v6;
    v10 = v6 + v9 + 4;
    if ( v6 + v9 != -4 )
    {
      v6 = *(_DWORD *)v10;
      if ( *(_DWORD *)(a2 + 2) == *(_DWORD *)v10 )
      {
        v6 = *(_DWORD *)(a2 + 8);
        if ( *(_DWORD *)(v10 + 4 * (unsigned __int8)v6 + 1062) != v6 )
        {
          *(_DWORD *)(v10 + 4 * (unsigned __int8)v6 + 1062) = v6;
          *(_DWORD *)(v10 + 1058) = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
          LOBYTE(v6) = *(_BYTE *)(v10 + 1041);
          *(_BYTE *)(v10 + 2090) = 0;
          if ( !(_BYTE)v6 )
          {
            LOBYTE(v6) = *(_BYTE *)(a2 + 7);
            switch ( (_BYTE)v6 )
            {
              case 1:
                LOBYTE(v6) = sub_1000AAA0((void *)this, a2 + 12, a3 - 12, v10);
                break;
              case 2:
              case 3:
                v11 = *(unsigned __int8 *)(a2 + 7);
                LOBYTE(v6) = a3 - 12;
                if ( (unsigned int)(a3 - 12) >= 2 )
                {
                  v6 = (int)memchr((const void *)(a2 + 13), 0, a3 - 13);
                  if ( v6 )
                  {
                    if ( v11 == 2 )
                    {
                      LOBYTE(v6) = (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)this + 8))(
                                     this,
                                     a2 + 13,
                                     *(unsigned __int8 *)(a2 + 12));
                    }
                    else if ( v11 == 3 )
                    {
                      LOBYTE(v6) = (*(int (__thiscall **)(int, int))(*(_DWORD *)this + 4))(this, a2 + 13);
                    }
                  }
                }
                break;
              case 4:
                LOBYTE(v6) = a3 - 12;
                if ( (unsigned int)(a3 - 12) >= 2 )
                {
                  *(_DWORD *)(this + 158784) -= *(_DWORD *)(v10 + 2086);
                  LOWORD(v6) = *(_WORD *)(a2 + 12);
                  *(_DWORD *)(v10 + 2086) = (unsigned __int16)v6;
                  *(_DWORD *)(this + 158784) += (unsigned __int16)v6;
                }
                break;
            }
          }
        }
      }
    }
  }
  return v6;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000A9F0) --------------------------------------------------------
void *__thiscall sub_1000A9F0(void *this, int a2, unsigned int a3, int a4, int a5)
{
  void *result; // eax
  int v7; // edi

  result = (void *)a3;
  if ( a3 >= 2 )
  {
    v7 = a2 + 1;
    result = memchr((const void *)(a2 + 1), 0, a3 - 1);
    if ( result )
    {
      result = (void *)a5;
      if ( a5 == 2 )
      {
        result = (void *)(*(int (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 8))(
                           this,
                           v7,
                           *(unsigned __int8 *)a2);
      }
      else if ( a5 == 3 )
      {
        result = (void *)(*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 4))(this, v7);
      }
    }
  }
  return result;
}

//----- (1000AA50) --------------------------------------------------------
int __thiscall sub_1000AA50(int this, int a2, unsigned int a3, int a4)
{
  int result; // eax

  if ( a3 >= 2 )
  {
    HIWORD(result) = 0;
    *(_DWORD *)(this + 158784) -= *(_DWORD *)(a4 + 2086);
    LOWORD(result) = *(_WORD *)a2;
    *(_DWORD *)(a4 + 2086) = *(unsigned __int16 *)a2;
    *(_DWORD *)(this + 158784) += (unsigned __int16)result;
  }
  return result;
}

//----- (1000AAA0) --------------------------------------------------------
char __thiscall sub_1000AAA0(void *this, int a2, int a3, int a4)
{
  int *v4; // ebx
  _DWORD *v5; // edi
  unsigned int v6; // ebp
  char *v7; // eax
  int v8; // edx
  void *v9; // ebx
  char *v10; // esi
  _BYTE *v11; // ebx
  unsigned int v12; // edx
  int v13; // ebp
  unsigned int v14; // eax
  _DWORD *v15; // ecx
  int v16; // eax
  void *v17; // ecx
  int v18; // ecx
  signed int v19; // eax
  char *v20; // edi
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  int v26; // ecx
  void *v27; // esi
  void *v29; // [esp+10h] [ebp-48h] BYREF
  int v30; // [esp+14h] [ebp-44h]
  _DWORD *v31; // [esp+18h] [ebp-40h]
  int v32; // [esp+1Ch] [ebp-3Ch]
  char v33[24]; // [esp+20h] [ebp-38h] BYREF
  char dst[32]; // [esp+38h] [ebp-20h] BYREF
  int v35; // [esp+5Ch] [ebp+4h]
  _DWORD *v36; // [esp+60h] [ebp+8h]

  v4 = (int *)a2;
  v5 = this;
  v31 = this;
  v35 = a2 + a3;
  v6 = v35;
  v7 = (char *)((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  v32 = (int)v7;
  if ( v35 - (int)v4 <= 6 )
    return (char)v7;
  while ( 2 )
  {
    v8 = *v4;
    v9 = v4 + 1;
    v30 = v8;
    v7 = (char *)memchr(v9, 0, v6 - (_DWORD)v9);
    v10 = v7;
    if ( !v7 )
      return (char)v7;
    LOBYTE(v7) = (unsigned __int8)strncpyt(dst, v9, 32);
    v11 = v10 + 1;
    if ( (unsigned int)(v10 + 1) >= v6 )
      return (char)v7;
    v12 = v5[39435];
    v13 = 0;
    v14 = 0;
    v36 = 0;
    if ( !v12 )
      goto LABEL_19;
    v15 = v5 + 6435;
    while ( 1 )
    {
      if ( !*v15 )
      {
        if ( !v13 )
        {
          v36 = v15;
          v13 = (int)v15;
        }
        goto LABEL_14;
      }
      if ( *v15 == a4 && v15[1] == v30 )
        break;
LABEL_14:
      ++v14;
      v15 += 110;
      if ( v14 >= v12 )
        goto LABEL_18;
    }
    v16 = 55 * v14;
    v13 = (int)&v5[2 * v16 + 6435];
    if ( &v5[2 * v16] != (_DWORD *)-25740 )
      goto LABEL_21;
    v13 = (int)v36;
LABEL_18:
    if ( !v13 )
    {
LABEL_19:
      v5[39435] = v12 + 1;
      v13 = (int)&v5[110 * v12 + 6435];
    }
    *(_DWORD *)(v13 + 4) = v30;
    *(_DWORD *)v13 = a4;
LABEL_21:
    v5[39696] -= *(_DWORD *)(v13 + 428);
    strcpy((char *)(v13 + 8), dst);
    v17 = *(void **)(v13 + 40);
    if ( v17 != (void *)(v13 + 44) )
    {
      sub_10002D60(v17);
      *(_DWORD *)(v13 + 40) = v13 + 44;
    }
    v18 = v32;
    v19 = v35 - (_DWORD)v11;
    *(_DWORD *)(v13 + 428) = 0;
    *(_DWORD *)(v13 + 432) = 16;
    for ( *(_DWORD *)(v13 + 436) = v18; v19 > 0; v19 = v35 - (_DWORD)(v20 + 1) )
    {
      if ( !*v11 )
        break;
      v20 = (char *)memchr(v11, 0, v19);
      if ( !v20 )
        break;
      v21 = *(_DWORD *)(v13 + 428);
      v22 = *(_DWORD *)(v13 + 432);
      if ( v21 >= v22 && v21 + 1 > v22 )
      {
        v23 = *(_DWORD *)(v13 + 40);
        v24 = v21 + 16;
        *(_DWORD *)(v13 + 432) = v24;
        if ( v23 == v13 + 44 )
          *(_DWORD *)(v13 + 40) = 0;
        v29 = *(void **)(v13 + 40);
        sub_10002D10((int)&v29, 24 * v24);
        if ( !*(_DWORD *)(v13 + 40) )
          memcpy_0(v29, (const void *)(v13 + 44), 24 * *(_DWORD *)(v13 + 428));
        *(_DWORD *)(v13 + 40) = v29;
      }
      v25 = *(_DWORD *)(v13 + 428);
      v26 = *(_DWORD *)(v13 + 40);
      *(_DWORD *)(v13 + 428) = v25 + 1;
      v27 = (void *)(v26 + 24 * v25);
      memcpy_0(v27, v33, 0x18u);
      strncpyt(v27, v11, 24);
      v11 = v20 + 1;
    }
    v31[39696] += *(_DWORD *)(v13 + 428);
    LOBYTE(v7) = *v11;
    if ( !*v11 )
    {
      v4 = (int *)(v11 + 1);
      if ( v35 - (int)v4 > 6 )
      {
        v6 = v35;
        v5 = v31;
        continue;
      }
    }
    return (char)v7;
  }
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000AD20) --------------------------------------------------------
char __thiscall sub_1000AD20(int this, int a2, int a3, int a4)
{
  const char *v4; // eax
  const char *v5; // ebp
  unsigned int v6; // edi
  int v7; // esi
  int v8; // ebp
  int i; // ebx
  unsigned int v10; // edi
  int v11; // esi
  int v12; // edx
  int v14; // [esp+10h] [ebp-8h]
  const char *v15; // [esp+14h] [ebp-4h]

  v4 = (const char *)a2;
  v14 = this;
  v5 = (const char *)a2;
  if ( !*(_BYTE *)a2 )
    v5 = "$pub";
  v6 = 0;
  if ( *(_DWORD *)(this + 158768) )
  {
    v7 = this + 157744;
    while ( unknown_libname_69(v5, v7)
         && (!*(_BYTE *)a2 || unknown_libname_69(v7, "$pvt") || !unknown_libname_69(a2, "$login")) )
    {
      ++v6;
      v7 += 32;
      if ( v6 >= *(_DWORD *)(v14 + 158768) )
      {
        this = v14;
        v4 = (const char *)a2;
        goto LABEL_11;
      }
    }
    return 0;
  }
LABEL_11:
  v8 = 0;
  if ( !*(_DWORD *)(this + 16732) )
    return 0;
  for ( i = this + 16; ; i += 2091 )
  {
    v15 = v4;
    if ( !*v4 )
      v15 = "$pub";
    v10 = 0;
    if ( *(_DWORD *)(i + 1024) )
      break;
LABEL_23:
    if ( (unsigned int)++v8 >= *(_DWORD *)(this + 16732) )
      return 0;
  }
  v11 = i;
  while ( unknown_libname_69(v15, v11)
       && (!*(_BYTE *)a2 || unknown_libname_69(v11, "$pvt") || !unknown_libname_69(a2, "$login")) )
  {
    ++v10;
    v11 += 32;
    if ( v10 >= *(_DWORD *)(i + 1024) )
    {
      this = v14;
      v4 = (const char *)a2;
      goto LABEL_23;
    }
  }
  v12 = v14 + 1394 * v8;
  *(_DWORD *)a3 = *(_DWORD *)(697 * v8 + v12 + 8);
  *(_DWORD *)a4 = *(_DWORD *)(v12 + 697 * v8 + 12);
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000AEA0) --------------------------------------------------------
unsigned int __thiscall sub_1000AEA0(void *this)
{
  int v2; // edx
  unsigned int result; // eax
  int v4; // ebx
  int v5; // eax
  int *v6; // eax
  int v7; // ebx
  unsigned int v8; // edi
  int v9; // eax
  int v10; // ebx
  char *v11; // esi
  int v12; // eax
  int v13; // edx
  int *v14; // eax
  int v15; // esi
  int v16; // ecx
  int v17; // edi
  int v18; // edx
  int v19; // eax
  char *v20; // ecx
  unsigned int v21; // ecx
  char *v22; // edx
  _BOOL1 v23; // cf
  unsigned int v24; // ecx
  char *v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // edi
  int v29; // ebx
  _DWORD *v30; // esi
  _DWORD *v31; // ecx
  int v32; // eax
  unsigned int v33; // edi
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ebx
  char *v37; // esi
  char *v38; // esi
  int v39; // eax
  unsigned int v40; // edx
  _BOOL1 v41; // zf
  unsigned int v42; // ebx
  char *v43; // edi
  void (__thiscall **v44)(void *, char *, int, int); // edx
  void (__thiscall **v45)(void *, char *, int, int); // eax
  int v46; // [esp+10h] [ebp-628h] BYREF
  int v47; // [esp+14h] [ebp-624h]
  unsigned int v48; // [esp+18h] [ebp-620h] BYREF
  int v49; // [esp+1Ch] [ebp-61Ch]
  int v50; // [esp+20h] [ebp-618h] BYREF
  char v51[2]; // [esp+24h] [ebp-614h] BYREF
  int v52; // [esp+26h] [ebp-612h]
  char v53; // [esp+2Ah] [ebp-60Eh]
  char v54; // [esp+2Bh] [ebp-60Dh]
  int v55; // [esp+2Ch] [ebp-60Ch]
  __int16 v56; // [esp+30h] [ebp-608h]
  char v57[32]; // [esp+44h] [ebp-5F4h] BYREF
  char v58[2]; // [esp+64h] [ebp-5D4h] BYREF
  int v59; // [esp+66h] [ebp-5D2h]
  char v60; // [esp+6Ah] [ebp-5CEh]
  char v61; // [esp+6Bh] [ebp-5CDh]
  int v62; // [esp+6Ch] [ebp-5CCh]
  char v63; // [esp+70h] [ebp-5C8h] BYREF
  char v64[2]; // [esp+636h] [ebp-2h] BYREF

  v2 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  result = *((_DWORD *)this + 39694);
  v4 = 0;
  v46 = v2;
  if ( (!result || (int)(v2 - result) >= 1000) && *((_DWORD *)this + 4183) )
  {
    v5 = *((_DWORD *)this + 6433);
    *((_DWORD *)this + 39694) = v2;
    v49 = 0;
    if ( v5 )
    {
      v47 = 0;
      do
      {
        v6 = (int *)(v4 + *((_DWORD *)this + 4184));
        if ( v2 - *v6 >= 1000 )
        {
          *v6 = v2;
          v7 = *((_DWORD *)this + 4184) + v4;
          v8 = 0;
          v9 = *(_DWORD *)(v7 + 8);
          v10 = v7 + 12;
          v50 = v9;
          if ( *((_DWORD *)this + 4183) )
          {
            v11 = (char *)this + 1046;
            do
            {
              v12 = v50;
              *(_DWORD *)(v10 + 2) = *(_DWORD *)(v11 - 1042);
              (**(void (__thiscall ***)(void *, int, int, char *))this)(this, v10, v12, v11);
              ++v8;
              v11 += 2091;
            }
            while ( v8 < *((_DWORD *)this + 4183) );
          }
          v13 = v47;
          v14 = (int *)(v47 + *((_DWORD *)this + 4184) + 4);
          v15 = *v14 + 1;
          *v14 = v15;
          if ( v15 >= 3 )
          {
            v16 = v13;
            v47 = v13 - 281;
            v17 = *((_DWORD *)this + 4184);
            v50 = v13 + 281;
            v18 = *((_DWORD *)this + 6433);
            --v49;
            memcpy_0((void *)(v17 + v16), (const void *)(v17 + v16 + 281), 281 * v18 - (v16 + 281));
            v19 = *((_DWORD *)this + 6433) - 1;
            *((_DWORD *)this + 6433) = v19;
            if ( v19 )
            {
              if ( (unsigned int)(*((_DWORD *)this + 6434) - v19) > 0x20 )
              {
                v21 = *((_DWORD *)this + 6434) - 16;
                *((_DWORD *)this + 6434) = v21;
                if ( v21 > 0x20 )
                {
                  v48 = *((_DWORD *)this + 4184);
                  sub_10002D10((int)&v48, 281 * v21);
                  *((_DWORD *)this + 4184) = v48;
                }
                else
                {
                  v22 = (char *)*((_DWORD *)this + 4184);
                  if ( v22 != (char *)this + 16740 )
                  {
                    memcpy_0((char *)this + 16740, v22, 281 * v19);
                    sub_10002D60(*((void **)this + 4184));
                    *((_DWORD *)this + 4184) = (char *)this + 16740;
                  }
                  *((_DWORD *)this + 6434) = 32;
                }
              }
            }
            else
            {
              v20 = (char *)*((_DWORD *)this + 4184);
              if ( v20 != (char *)this + 16740 )
              {
                sub_10002D60(v20);
                *((_DWORD *)this + 4184) = (char *)this + 16740;
              }
              *((_DWORD *)this + 6433) = 0;
              *((_DWORD *)this + 6434) = 32;
            }
          }
        }
        v2 = v46;
        v4 = v47 + 281;
        v23 = (unsigned int)++v49 < *((_DWORD *)this + 6433);
        v47 += 281;
      }
      while ( v23 );
    }
    v24 = 0;
    if ( *((_DWORD *)this + 4183) )
    {
      v25 = (char *)this + 2090;
      do
      {
        if ( v2 - *((_DWORD *)v25 - 257) > 60000 )
        {
          v25[4] = 1;
          *((_DWORD *)this + 39696) -= *(_DWORD *)v25;
          *(_DWORD *)v25 = 0;
        }
        ++v24;
        v25 += 2091;
      }
      while ( v24 < *((_DWORD *)this + 4183) );
    }
    v26 = *((_DWORD *)this + 39435);
    v27 = v26 - 1;
    if ( v26 >= 0 )
    {
      v28 = *((_DWORD *)this + 39435);
      v29 = v27 + 2;
      v30 = (char *)this + 440 * v27 + 26168;
      do
      {
        if ( *(v30 - 107) && v2 - v30[2] > 10000 )
        {
          *((_DWORD *)this + 39696) -= *v30;
          v31 = (_DWORD *)*(v30 - 97);
          if ( v31 != v30 - 96 )
          {
            sub_10002D60(v31);
            *(v30 - 97) = v30 - 96;
          }
          *v30 = 0;
          v30[1] = 16;
          *(v30 - 107) = 0;
          v32 = *((_DWORD *)this + 39435);
          if ( v28 == v32 )
            *((_DWORD *)this + 39435) = v32 - 1;
          v2 = v46;
        }
        --v29;
        v30 -= 110;
        --v28;
      }
      while ( v29 );
    }
    v33 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
    v34 = *((_DWORD *)this + 39695);
    v48 = v33;
    if ( v34 >= v33 )
      *((_DWORD *)this + 39695) = 0;
    v35 = *(_DWORD *)this;
    v47 = *((_DWORD *)this + 39695);
    v62 = *((_DWORD *)this + 39693);
    v55 = v62 + 1;
    v60 = -1;
    v53 = -1;
    v58[0] = 0;
    v58[1] = 1;
    v61 = 1;
    v51[0] = 0;
    v51[1] = 1;
    v54 = 4;
    *((_DWORD *)this + 39693) = v62 + 2;
    v56 = (*(int (__thiscall **)(void *))(v35 + 24))(this);
    v36 = 0;
    v37 = &v63;
    while ( v33 )
    {
      if ( (*(unsigned __int8 (__thiscall **)(void *, char *, int *, int *, _DWORD))(*(_DWORD *)this + 16))(
             this,
             v57,
             &v50,
             &v46,
             *((_DWORD *)this + 39695)) )
      {
        if ( v36 && &v37[14 * v50] >= v64 )
          break;
        *(_DWORD *)v37 = v46;
        strcpy(v37 + 4, v57);
        v38 = strchr_0(v37 + 4, 0) + 1;
        v39 = (*(int (__thiscall **)(void *, char *, int, _DWORD))(*(_DWORD *)this + 20))(
                this,
                v38,
                v64 - v38,
                *((_DWORD *)this + 39695));
        v33 = v48;
        v37 = &v38[v39];
        ++v36;
      }
      v40 = (*((_DWORD *)this + 39695) + 1) % v33;
      v41 = v40 == v47;
      *((_DWORD *)this + 39695) = v40;
      if ( v41 || v64 - v37 < 100 )
        break;
    }
    result = *((_DWORD *)this + 4183);
    v42 = 0;
    if ( result )
    {
      v43 = (char *)this + 4;
      do
      {
        if ( v43[1040] && v48 )
        {
          v44 = *(void (__thiscall ***)(void *, char *, int, int))this;
          v59 = *(_DWORD *)v43;
          (*v44)(this, v58, v37 - v58, (int)(v43 + 1042));
        }
        else
        {
          v45 = *(void (__thiscall ***)(void *, char *, int, int))this;
          v52 = *(_DWORD *)v43;
          (*v45)(this, v51, 14, (int)(v43 + 1042));
        }
        result = *((_DWORD *)this + 4183);
        ++v42;
        v43 += 2091;
      }
      while ( v42 < result );
    }
  }
  return result;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 1000AEA0: using guessed type char var_2[2];

//----- (1000B3B0) --------------------------------------------------------
unsigned int __thiscall sub_1000B3B0(int this, int a2, int a3)
{
  unsigned int v4; // ebx
  unsigned int result; // eax
  int v6; // edi

  v4 = 0;
  result = *(_DWORD *)(this + 16732);
  if ( result )
  {
    v6 = this + 1046;
    do
    {
      *(_DWORD *)(a2 + 2) = *(_DWORD *)(v6 - 1042);
      (**(void (__thiscall ***)(int, int, int, int))this)(this, a2, a3, v6);
      result = *(_DWORD *)(this + 16732);
      ++v4;
      v6 += 2091;
    }
    while ( v4 < result );
  }
  return result;
}

//----- (1000B400) --------------------------------------------------------
char *__thiscall sub_1000B400(int this, char a2, const void *src, char a4)
{
  char *result; // eax
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // eax
  int *v13; // esi
  _DWORD *v14; // ebx
  unsigned int v15; // ebp
  int v16; // ecx
  int v17; // esi
  void *v18; // [esp+10h] [ebp-124h] BYREF
  char *v19; // [esp+14h] [ebp-120h]
  char v20[284]; // [esp+18h] [ebp-11Ch] BYREF

  result = *(char **)(this + 16732);
  if ( result )
  {
    v6 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
    v7 = *(_DWORD *)(this + 25736);
    v8 = v6;
    v9 = *(_DWORD *)(this + 25732);
    if ( v9 >= v7 && v9 + 1 > v7 )
    {
      v10 = v9 + 32;
      v11 = *(_DWORD *)(this + 16736);
      *(_DWORD *)(this + 25736) = v10;
      if ( v11 == this + 16740 )
        *(_DWORD *)(this + 16736) = 0;
      v18 = *(void **)(this + 16736);
      sub_10002D10((int)&v18, 281 * v10);
      if ( !*(_DWORD *)(this + 16736) )
        memcpy_0(v18, (const void *)(this + 16740), 281 * *(_DWORD *)(this + 25732));
      *(_DWORD *)(this + 16736) = v18;
    }
    v12 = *(_DWORD *)(this + 25732);
    v13 = (int *)(*(_DWORD *)(this + 16736) + 281 * v12);
    *(_DWORD *)(this + 25732) = v12 + 1;
    memcpy_0(v13, v20, 0x119u);
    *v13 = v8;
    v13[1] = 1;
    v14 = v13 + 3;
    *((_BYTE *)v13 + 13) = 1;
    *((_BYTE *)v13 + 12) = 0;
    *((_BYTE *)v13 + 18) = -1;
    *((_BYTE *)v13 + 19) = a2;
    v13[5] = (*(_DWORD *)(this + 158772))++;
    *((_BYTE *)v13 + 24) = a4;
    strncpyt((char *)v13 + 25, (void *)src, 256);
    v15 = 0;
    result = &strchr_0((const char *)v13 + 25, 0)[-11 - (_DWORD)v13];
    v13[2] = (int)result;
    v16 = *(_DWORD *)(this + 16732);
    v19 = result;
    if ( v16 )
    {
      v17 = this + 1046;
      while ( 1 )
      {
        *(_DWORD *)((char *)v14 + 2) = *(_DWORD *)(v17 - 1042);
        (**(void (__thiscall ***)(int, _DWORD *, char *, int))this)(this, v14, result, v17);
        result = *(char **)(this + 16732);
        ++v15;
        v17 += 2091;
        if ( v15 >= (unsigned int)result )
          break;
        result = v19;
      }
    }
  }
  return result;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000B5B0) --------------------------------------------------------
char __thiscall sub_1000B5B0(void *this, int a2, char *a3, const char *a4)
{
  _DWORD *v4; // edx
  int v5; // ebp
  unsigned int *i; // esi
  unsigned int v7; // ebx
  int v8; // edi
  char result; // al
  char *v10; // ebp
  int v11; // [esp+10h] [ebp-8h]

  v4 = this;
  v11 = strlen(a4);
  if ( v11 > 23 )
    v11 = 23;
  v5 = 0;
  if ( !v4[39435] )
    return 0;
  for ( i = v4 + 6542; ; i += 110 )
  {
    v7 = 0;
    if ( *i )
      break;
LABEL_10:
    if ( (unsigned int)++v5 >= v4[39435] )
      return 0;
  }
  v8 = 0;
  while ( _memicmp_0((const void *)(v8 + *(i - 97)), a4, v11) )
  {
    ++v7;
    v8 += 24;
    if ( v7 >= *i )
    {
      v4 = this;
      goto LABEL_10;
    }
  }
  v10 = (char *)this + 440 * v5;
  if ( *sub_10003240(v10 + 25748) )
    strcpy((char *)a2, v10 + 25748);
  else
    sprintf_0((char *)a2, "Public %s", v10 + 25748);
  result = 1;
  strcpy(a3, (const char *)(*((_DWORD *)v10 + 6445) + 24 * v7));
  return result;
}

//----- (1000B6E0) --------------------------------------------------------
char *__thiscall sub_1000B6E0(int this, int a2, char a3)
{
  char *v3; // edx
  unsigned int v4; // ebx
  int v5; // ebp
  char *v6; // eax
  int v8; // [esp+0h] [ebp-4h]

  v3 = (char *)a2;
  v4 = 0;
  v8 = this;
  if ( *(_DWORD *)(this + 157740) )
  {
    v5 = this + 25748;
    do
    {
      if ( *(_DWORD *)(v5 - 8) && (*(_BYTE *)v5 != 35 || a3) )
      {
        if ( *(_DWORD *)(v5 + 420) )
        {
          strcpy(v3, (const char *)v5);
          v6 = strchr_0(v3, 0) + 1;
          *(_WORD *)v6 = *(_WORD *)(v5 + 420);
          this = v8;
          v3 = v6 + 2;
        }
      }
      ++v4;
      v5 += 440;
    }
    while ( v4 < *(_DWORD *)(this + 157740) );
  }
  return &v3[-a2];
}

//----- (1000B780) --------------------------------------------------------
int __thiscall sub_1000B780(void *this)
{
  char *v2; // ecx
  int result; // eax

  v2 = *(char **)this;
  if ( v2 != (char *)this + 4 )
  {
    result = sub_10002D60(v2);
    *(_DWORD *)this = (char *)this + 4;
  }
  *((_DWORD *)this + 2249) = 0;
  *((_DWORD *)this + 2250) = 32;
  return result;
}

//----- (1000B7B0) --------------------------------------------------------
int __cdecl sub_1000B7B0()
{
  dword_101A9508 = 0;
  dword_101A9504 = 0;
  dword_101A9500 = 0;
  return atexit((void (*)(void))sub_1000B7D0);
}
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (1000B7D0) --------------------------------------------------------
int __cdecl sub_1000B7D0()
{
  int result; // eax

  sub_10002D60((void *)dword_101A9500);
  result = 0;
  dword_101A9500 = 0;
  dword_101A9508 = 0;
  dword_101A9504 = 0;
  return result;
}
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (1000B7F0) --------------------------------------------------------
int __cdecl sub_1000B7F0()
{
  sub_1000B8B0((int)dword_1003E438);
  return atexit((void (*)(void))sub_1000B810);
}

//----- (1000B810) --------------------------------------------------------
int __cdecl sub_1000B810()
{
  int result; // eax
  _DWORD *v1; // ecx

  result = `eh vector destructor iterator'(&dword_1003E438[6435], 440, 300, sub_1000A440);
  v1 = (_DWORD *)dword_1003E438[4184];
  if ( v1 != &dword_1003E438[4185] )
  {
    result = sub_10002D60(v1);
    dword_1003E438[4184] = &dword_1003E438[4185];
  }
  dword_1003E438[6433] = 0;
  dword_1003E438[6434] = 32;
  return result;
}
// 1001713A: using guessed type _DWORD __stdcall `eh vector destructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000B8B0) --------------------------------------------------------
int __thiscall sub_1000B8B0(int this)
{
  sub_1000A370(this);
  *(_DWORD *)this = &off_10021A50;
  return this;
}
// 10021A50: using guessed type int (__stdcall *off_10021A50)(int, int, int);

//----- (1000B8D0) --------------------------------------------------------
int __stdcall sub_1000B8D0(const void *player)
{
  int result; // eax
  _BOOL1 v3; // cc
  char v4[3]; // [esp+Ch] [ebp-110h] BYREF
  __int16 v5; // [esp+Fh] [ebp-10Dh]
  char dst[251]; // [esp+11h] [ebp-10Bh] BYREF
  int buf_sz; // [esp+10Ch] [ebp-10h]
  void *buf; // [esp+110h] [ebp-Ch]
  int v9; // [esp+114h] [ebp-8h]
  int *v10; // [esp+118h] [ebp-4h]
  PLAYER *playera; // [esp+124h] [ebp+8h]

  result = nPlayerArray2;
  v9 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v10 = PlayerArray2;
    do
    {
      playera = (PLAYER *)*v10;
      if ( *v10 )
      {
        if ( *(_DWORD *)(*v10 + 639) )
        {
          v4[0] = 7;
          v4[1] = 7;
          v4[2] = 0;
          v5 = -1;
          strncpyt(dst, (void *)player, 250);
          buf_sz = strlen(dst) + 6;
          buf = v4;
          PlayerSendPacket(playera, v4, buf_sz, 1);
        }
      }
      result = v9 + 1;
      v3 = ++v9 < nPlayerArray2;
      ++v10;
    }
    while ( v3 );
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (1000B9A0) --------------------------------------------------------
int __stdcall sub_1000B9A0(const char *msg, char msg_type)
{
  int result; // eax
  int v3; // edi
  struct PLAYER **v4; // esi

  result = nPlayerArray2;
  v3 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v4 = (struct PLAYER **)PlayerArray2;
    do
    {
      if ( *v4 )
        SendMessage(*v4, msg, msg_type);
      result = nPlayerArray2;
      ++v3;
      ++v4;
    }
    while ( v3 < nPlayerArray2 );
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (1000B9F0) --------------------------------------------------------
LPCSTR __stdcall sub_1000B9F0(int a1, int a2, int a3)
{
  LPCSTR result; // eax

  result = lpFileName;
  if ( lpFileName )
    result = (LPCSTR)j_FIX_DLL_WSOCK32_dll_ord_0014(*((_DWORD *)lpFileName + 6), a1, a2, 0, a3, 16);
  return result;
}
// 10015A02: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000BA20) --------------------------------------------------------
int __cdecl sub_1000BA20()
{
  return nArenas;
}

//----- (1000BA30) --------------------------------------------------------
char __stdcall sub_1000BA30(int a1, int a2, int a3, int a4)
{
  int v4; // ebx

  v4 = ArenaArray[a4];
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(v4 + 64256) )
    strcpy((char *)a1, (const char *)(v4 + 64256));
  else
    sprintf_0((char *)a1, "%d", a4);
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 65292);
  *(_DWORD *)a3 = *(_DWORD *)(v4 + 121261);
  return 1;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000BAB0) --------------------------------------------------------
int __stdcall sub_1000BAB0(char *a1, int a2, int a3)
{
  char *v3; // ebx
  int v4; // ebp
  size_t v5; // kr04_4
  _BOOL1 v6; // cc
  char *v8; // [esp+10h] [ebp-8h]
  char *v10; // [esp+1Ch] [ebp+4h]
  int v11; // [esp+20h] [ebp+8h]

  v3 = a1;
  v4 = ArenaArray[a3];
  v8 = &a1[a2];
  v11 = 0;
  if ( *(int *)(v4 + 65292) > 0 )
  {
    v10 = (char *)(v4 + 64288);
    do
    {
      if ( *(_DWORD *)v10 )
      {
        v5 = strlen((const char *)(*(_DWORD *)v10 + 375)) + 1;
        if ( v8 - v3 < (int)(v5 + 1) )
          break;
        memcpy_0(v3, (const void *)(*(_DWORD *)v10 + 375), v5);
        v3 += v5;
      }
      v6 = ++v11 < *(_DWORD *)(v4 + 65292);
      v10 += 4;
    }
    while ( v6 );
  }
  *v3 = 0;
  return v3 - a1 + 1;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000BB60) --------------------------------------------------------
int __cdecl sub_1000BB60()
{
  return nPlayerArray2;
}
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (1000BB70) --------------------------------------------------------
int __cdecl sub_1000BB70()
{
  return 0;
}

//----- (1000BB80) --------------------------------------------------------
void __thiscall sub_1000BB80(void *this, int a2, const char *a3)
{
  biller_user_command((struct BILLING_SERVER_STRUCT *)this, a2, a3);
}

//----- (1000BBA0) --------------------------------------------------------
signed int __thiscall WriteDataProxyRemoveLater(int this, char *buf, unsigned int buf_sz, BOOL bReliable)
{
  return WriteData((struct CONNECTION *)this, buf, buf_sz, bReliable);
}

//----- (1000BBC0) --------------------------------------------------------
#error "1000BBD5: call analysis failed (funcsize=12)"

//----- (1000BBE0) --------------------------------------------------------
void __thiscall sub_1000BBE0(int this, int a2, int a3, int a4)
{
  GetMapLvlRequest((struct CONNECTION *)this, (char *)a2, a3, a4);
}

//----- (1000BC00) --------------------------------------------------------
void __thiscall sub_1000BC00(int this)
{
  sub_41D6D0(this);
}

//----- (1000BC20) --------------------------------------------------------
void __thiscall biller_player_login(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr)
{
  _BOOL1 v11; // zf
  __int16 v12; // dx
  size_t v13; // esi
  char v14[2]; // [esp+8h] [ebp-158h] BYREF
  int v15; // [esp+Ah] [ebp-156h]
  char dst[32]; // [esp+Eh] [ebp-152h] BYREF
  char v17[32]; // [esp+2Eh] [ebp-132h] BYREF
  int v18; // [esp+4Eh] [ebp-112h]
  int v19; // [esp+52h] [ebp-10Eh]
  int v20; // [esp+56h] [ebp-10Ah]
  char v21; // [esp+5Ah] [ebp-106h]
  char v22; // [esp+5Bh] [ebp-105h]
  __int16 v23; // [esp+5Ch] [ebp-104h]
  char v24[258]; // [esp+5Eh] [ebp-102h] BYREF
  int buf_sza; // [esp+17Ch] [ebp+1Ch]

  if ( buf >= 0 )
  {
    v15 = a4;
    v14[0] = 4;
    v14[1] = buf_sz;
    strncpyt(dst, (void *)playerName, 32);
    strncpyt(v17, (void *)a3, 32);
    v20 = a6;
    v22 = (char)classptr;
    v11 = *(_BYTE *)a9 == 9;
    v19 = a5;
    v12 = *(_WORD *)(a9 + 75);
    v18 = buf;
    v21 = 0;
    v23 = v12;
    if ( v11 )
    {
      buf_sza = 86;
    }
    else
    {
      v13 = *(_DWORD *)(a9 + 77) - 101;
      if ( v13 > 0x100 )
        v13 = 256;
      memcpy_0(v24, (const void *)(a9 + 101), v13);
      buf_sza = v13 + 86;
    }
    WriteData(*((struct CONNECTION **)this + 1), v14, buf_sza, 1);
  }
}

//----- (1000BD10) --------------------------------------------------------
int __thiscall sub_1000BD10(int this, const char *lpszSection, const char *lpszKey, int DefaultVal)
{
  return GetCFGSettingInteger((struct struc_2 *)this, lpszSection, lpszKey, DefaultVal);
}

//----- (1000BD30) --------------------------------------------------------
int __thiscall sub_1000BD30(int this, char *buf, unsigned int buf_sz, BOOL bSendReliable)
{
  return PlayerSendPacket((PLAYER *)this, buf, buf_sz, bSendReliable);
}

//----- (1000BD50) --------------------------------------------------------
void __thiscall sub_1000BD50(void *this, int ship)
{
  int v3; // eax
  struct PLAYER *player; // [esp+4h] [ebp-4h]

  v3 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  *(_DWORD *)((char *)this + 885) = v3;
  *(_DWORD *)((char *)this + 1030) = v3 + 5000;
  SetPlayerShip(player, ship);
}
// 1000BD7C: variable 'player' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000BD90) --------------------------------------------------------
void __thiscall sub_1000BD90(int this, signed int a2)
{
  struct PLAYER *v2; // [esp+4h] [ebp-4h]

  *(_DWORD *)(this + 885) = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  PlayerChangeFrequency(v2, a2);
}
// 1000BDB1: variable 'v2' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000BDC0) --------------------------------------------------------
void __thiscall sub_1000BDC0(int this)
{
  SendResetScoresPacket((PLAYER *)this);
}

//----- (1000BDE0) --------------------------------------------------------
signed int __thiscall sub_1000BDE0(void *this, const char *filename)
{
  char v3[256]; // [esp+0h] [ebp-108h] BYREF
  char *msg; // [esp+100h] [ebp-8h]
  struct PLAYER *v5; // [esp+104h] [ebp-4h]

  v5 = (struct PLAYER *)this;
  sprintf_0(v3, "File sent: %s (please wait...)", filename);
  msg = v3;
  SendMessage(v5, v3, 0);
  return SendFile(&v5->hProcess, (char *)filename);
}

//----- (1000BE30) --------------------------------------------------------
void __thiscall sub_1000BE30(int this, const char *msg, char msg_type)
{
  SendMessage((struct PLAYER *)this, msg, msg_type);
}

//----- (1000BE50) --------------------------------------------------------
void __thiscall sub_1000BE50(int this, const char *reason, char something)
{
  SendArenaMessagePlayer((PLAYER *)this, reason, something);
}

//----- (1000BE70) --------------------------------------------------------
int __thiscall sub_1000BE70(PLAYER *this, const void *src, void *buf, char buf_sz)
{
  char v5[3]; // [esp+4h] [ebp-104h] BYREF
  __int16 v6; // [esp+7h] [ebp-101h]
  char dst[251]; // [esp+9h] [ebp-FFh] BYREF
  PLAYER *player; // [esp+104h] [ebp-4h]

  player = this;
  v5[2] = buf_sz;
  v5[0] = 7;
  v5[1] = (char)buf;
  v6 = -1;
  strncpyt(dst, (void *)src, 250);
  return PlayerSendPacket(player, v5, strlen(dst) + 6, 1);
}

//----- (1000BEF0) --------------------------------------------------------
int __thiscall sub_1000BEF0(PLAYER *this, BYTE *pkt, DWORD pkt_sz)
{
  return PlayerHandleGamePacket(this, pkt, pkt_sz);
}

//----- (1000BF10) --------------------------------------------------------
void __thiscall sub_1000BF10(int this, int a2)
{
  SendAdvertisement((struct PLAYER *)this, a2);
}

//----- (1000BF30) --------------------------------------------------------
int __thiscall sub_1000BF30(PLAYER *this, const void *buf)
{
  char v3; // [esp+4h] [ebp-118h] BYREF
  char v4[256]; // [esp+5h] [ebp-117h] BYREF
  char dst[19]; // [esp+105h] [ebp-17h] BYREF
  PLAYER *player; // [esp+118h] [ebp-4h]

  player = this;
  v3 = 25;
  strncpyt(dst, (void *)buf, 16);
  strncpyt(v4, (void *)buf, 256);
  return PlayerSendPacket(player, &v3, 273, 1);
}

//----- (1000BF90) --------------------------------------------------------
void __thiscall sub_1000BF90(int this, int a2)
{
  __int16 v2; // ax
  __int16 v3; // si
  __int16 v4; // dx
  struct ARENA *v5; // ecx
  char v6; // [esp+4h] [ebp-18h] BYREF
  __int16 v7; // [esp+5h] [ebp-17h]
  int v8; // [esp+7h] [ebp-15h]
  int v9; // [esp+Bh] [ebp-11h]
  __int16 v10; // [esp+Fh] [ebp-Dh]
  __int16 v11; // [esp+11h] [ebp-Bh]
  void *buf; // [esp+14h] [ebp-8h]
  ARENA *arena; // [esp+18h] [ebp-4h]

  *(_DWORD *)(this + 557) = a2;
  v9 = a2;
  v2 = *(_WORD *)(this + 547);
  *(_DWORD *)(this + 553) = 0;
  v3 = *(_WORD *)(this + 20);
  v8 = 0;
  v4 = *(_WORD *)(this + 549);
  v5 = *(struct ARENA **)(this + 28);
  v10 = v2;
  v6 = 9;
  v7 = v3;
  v11 = v4;
  buf = &v6;
  arena = v5;
  ArenaSendPacket(v5, &v6, 15, 1);
}

//----- (1000C000) --------------------------------------------------------
void __thiscall sub_1000C000(void *this, char *reason)
{
  unsigned int v3; // edx
  int v4; // eax
  _BOOL1 v5; // sf
  PLAYER *v6; // [esp+4h] [ebp-4h]

  v3 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() / 0xAu;
  if ( v3 - *(_DWORD *)((char *)this + 655) >= 0x96 )
  {
    *(_DWORD *)((char *)this + 655) = v3;
    *(_DWORD *)((char *)this + 659) = 0;
  }
  else
  {
    v4 = *(_DWORD *)((char *)this + 659) + 1;
    v5 = *(_DWORD *)((char *)this + 659) - 6 < 0;
    *(_DWORD *)((char *)this + 659) = v4;
    if ( !(v5 ^ __OFSUB__(v4, 7) | (v4 == 7)) )
    {
      *(_DWORD *)((char *)this + 789) = 33;
      *((_DWORD *)this + 14) = 1;
      if ( (_BYTE)reason )
      {
        off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)this + 375);
        SendArenaMessagePlayer(v6, "WARNING: You have been disconnected for message flooding", 0);
      }
    }
  }
}
// 1000C082: variable 'v6' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000C0B0) --------------------------------------------------------
char __thiscall sub_1000C0B0(void *this, int a2)
{
  int v3; // eax
  int *i; // edx

  v3 = 0;
  for ( i = (int *)((char *)this + 861); *i >= 0; ++i )
  {
    if ( *i == a2 )
    {
      memcpy_0((char *)this + 4 * v3 + 861, (char *)this + 4 * v3 + 865, 20 - 4 * v3);
      *(_DWORD *)((char *)this + 881) = -1;
      return 0;
    }
    if ( (unsigned int)++v3 >= 6 )
      return 0;
  }
  *(_DWORD *)((char *)this + 4 * v3 + 861) = a2;
  return 1;
}
// 1000C111: conditional instruction was optimized away because of 'eax.4<6u'

//----- (1000C130) --------------------------------------------------------
char __thiscall sub_1000C130(void *this, int a2)
{
  int v3; // eax
  int *i; // edx

  v3 = 0;
  for ( i = (int *)((char *)this + 1295); *i >= 0; ++i )
  {
    if ( *i == a2 )
    {
      memcpy_0((char *)this + 4 * v3 + 1295, (char *)this + 4 * v3 + 1299, 20 - 4 * v3);
      *(_DWORD *)((char *)this + 1315) = -1;
      return 0;
    }
    if ( (unsigned int)++v3 >= 6 )
      return 0;
  }
  *(_DWORD *)((char *)this + 4 * v3 + 1295) = a2;
  return 1;
}
// 1000C191: conditional instruction was optimized away because of 'eax.4<6u'

//----- (1000C1B0) --------------------------------------------------------
char *__thiscall sub_1000C1B0(int this, char a2)
{
  ARENA *v2; // edx
  int v4; // esi
  int v5; // eax
  int *v6; // ecx

  byte_101A939C = 0;
  if ( !this )
    return &byte_101A939C;
  v2 = *(ARENA **)(this + offsetof(PLAYER, lpCurrentArena));
  if ( !v2 )
    return &byte_101A939C;
  if ( v2->name[offsetof(ARENA, field_0)] )
  {
    strcpy(&byte_101A939C, v2->name);
    if ( !a2 && byte_101A939C == '#' )
    {
      strcpy(&byte_101A939C, "(Private arena)");
      return &byte_101A939C;
    }
  }
  else
  {
    v4 = -1;
    v5 = 0;
    if ( nArenas > 0 )
    {
      v6 = ArenaArray;
      do
      {
        if ( (ARENA *)*v6 == v2 )
          v4 = v5;
        ++v5;
        ++v6;
      }
      while ( v5 < nArenas );
    }
    sprintf_0(&byte_101A939C, "Public %d", v4);
  }
  return &byte_101A939C;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000C290) --------------------------------------------------------
char __fastcall find_player_request(PLAYER *requester, char *target_name)
{
  signed int v2; // edi
  PLAYER **v3; // ebx
  PLAYER *v4; // esi
  char result; // al
  char *v6; // eax
  char v7[128]; // [esp+Ch] [ebp-CCh] BYREF
  char v8[32]; // [esp+8Ch] [ebp-4Ch] BYREF
  char v9[32]; // [esp+ACh] [ebp-2Ch] BYREF
  int v10; // [esp+CCh] [ebp-Ch]
  struct PLAYER *v11; // [esp+D0h] [ebp-8h]
  void *msg; // [esp+D4h] [ebp-4h]

  v11 = requester;
  v2 = strlen(target_name);
  msg = target_name;
  if ( v2 > ' ' )
    v2 = 32;
  v10 = 0;
  if ( nPlayerArray2 <= 0 )
  {
LABEL_10:
    if ( sub_1000B5B0(dword_1003E438, (int)v9, v8, target_name) )
    {
      if ( !v11->bIsModerator && v9[0] == '#' )
        strcpy(v9, "(Private arena)");
      sprintf_0(v7, "%s - %s", v8, v9);
      msg = v7;
      SendMessage(v11, v7, 0);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v3 = (PLAYER **)PlayerArray2;
    while ( 1 )
    {
      v4 = *v3;
      if ( *v3 )
      {
        if ( v4->lpCurrentArena && !_memicmp_0(v4->player_name, msg, v2) )
          break;
      }
      ++v3;
      if ( ++v10 >= nPlayerArray2 )
      {
        target_name = (char *)msg;
        goto LABEL_10;
      }
    }
    v6 = sub_1000C1B0((int)v4, v11->bIsModerator != 0);
    sprintf_0(v7, "%s - %s", v4->player_name, v6);
    msg = v7;
    SendMessage(v11, v7, 0);
    result = 1;
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (1000C400) --------------------------------------------------------
int __thiscall sub_1000C400(void *this, int a2, int a3)
{
  int *v3; // esi
  int v4; // ebx
  int i; // ebp

  v3 = (int *)((char *)this + 12 * a2);
  v4 = 0;
  if ( v3[70] <= 0 )
    return 0;
  for ( i = 0; _memicmp_0((const void *)(v3[68] + i + 6), (const void *)a3, strlen((const char *)(v3[68] + i + 6))); i += 38 )
  {
    if ( ++v4 >= v3[70] )
      return 0;
  }
  return v3[68] + 38 * v4;
}

//----- (1000C480) --------------------------------------------------------
int __thiscall sub_1000C480(int this)
{
  const CHAR *v2; // esi
  int v3; // eax
  int (__cdecl *v4)(const char *, const char *, int, const CHAR *); // edi
  unsigned __int32 v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  const CHAR *v9; // eax
  void *v10; // ecx
  int v11; // eax
  char *v12; // eax
  char v13; // cl
  _BOOL1 v14; // zf
  int v15; // eax
  int v16; // edx
  int v17; // edx
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  _DWORD *v21; // ecx
  int v22; // edx
  int v23; // ecx
  _DWORD *v24; // eax
  int j; // eax
  int v26; // eax
  int v27; // edi
  const CHAR *v28; // eax
  char *v29; // edi
  char *v30; // eax
  int v31; // esi
  int v32; // eax
  _DWORD *v33; // edi
  int v34; // esi
  int v35; // eax
  _BYTE *v36; // edi
  void *v37; // ecx
  _DWORD *v38; // ebx
  int v39; // edi
  int result; // eax
  _DWORD v41[3]; // [esp-Ch] [ebp-910h] BYREF
  CHAR ReturnedString[1024]; // [esp+0h] [ebp-904h] BYREF
  char src[1024]; // [esp+400h] [ebp-504h] BYREF
  int v44; // [esp+800h] [ebp-104h] BYREF
  int v45[9]; // [esp+804h] [ebp-100h] BYREF
  _BYTE v46[32]; // [esp+828h] [ebp-DCh] BYREF
  char tmp_str[64]; // [esp+848h] [ebp-BCh] BYREF
  signed int v48[7]; // [esp+888h] [ebp-7Ch] BYREF
  int dst[8]; // [esp+8A4h] [ebp-60h] BYREF
  _BOOL1 v50; // [esp+8C4h] [ebp-40h]
  const CHAR *v51; // [esp+8C8h] [ebp-3Ch]
  int v52; // [esp+8CCh] [ebp-38h] BYREF
  char *v53; // [esp+8D0h] [ebp-34h]
  int v54; // [esp+8D4h] [ebp-30h]
  void *v55; // [esp+8D8h] [ebp-2Ch]
  int v56; // [esp+8DCh] [ebp-28h] BYREF
  _DWORD *v57; // [esp+8E0h] [ebp-24h]
  int i; // [esp+8E4h] [ebp-20h]
  _DWORD *v59; // [esp+8E8h] [ebp-1Ch]
  int k; // [esp+8ECh] [ebp-18h]
  char v61; // [esp+8F2h] [ebp-12h]
  _BOOL1 v62; // [esp+8F3h] [ebp-11h]
  _DWORD *v63; // [esp+8F4h] [ebp-10h]
  int v64; // [esp+900h] [ebp-4h]

  v2 = (const CHAR *)(this + 4);
  v63 = v41;
  v51 = (const CHAR *)(this + 4);
  sub_1000A470(dword_1003E438, (LPCSTR)(this + 4));
  sub_10002D60(*(void **)(this + 272));
  *(_DWORD *)(this + 272) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 276) = 0;
  sub_10002D60(*(void **)(this + 284));
  *(_DWORD *)(this + 284) = 0;
  *(_DWORD *)(this + 292) = 0;
  *(_DWORD *)(this + 288) = 0;
  sub_10002D60(*(void **)(this + 296));
  *(_DWORD *)(this + 296) = 0;
  *(_DWORD *)(this + 304) = 0;
  *(_DWORD *)(this + 300) = 0;
  sub_10002D60(*(void **)(this + 308));
  *(_DWORD *)(this + 308) = 0;
  *(_DWORD *)(this + 316) = 0;
  *(_DWORD *)(this + 312) = 0;
  i = 69069 * *(_DWORD *)(this + 440) + 17009;
  *(_DWORD *)(this + 440) = i;
  v3 = FIX_DLL_KERNEL32_dll_GetTickCount(v41[0], v41[1], v41[2]);
  v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
  *(_DWORD *)(this + 440) = i ^ v3;
  *(_BYTE *)(this + 468) = v4("Validation", "CheckMod", 0, v2) != 0;
  *(_BYTE *)(this + 469) = v4("Validation", "CheckSMod", 0, v2) != 0;
  *(_BYTE *)(this + 470) = v4("Validation", "CheckSysop", 0, v2) != 0;
  *(_BYTE *)(this + 475) = v4("Misc", "CheckWeapons", 0, v2) != 0;
  *(_BYTE *)(this + 477) = v4("Misc", "CheckPrizeDistribution", 0, v2) != 0;
  *(_BYTE *)(this + 476) = v4("Misc", "ForceObsceneCheck", 0, v2) != 0;
  *(_DWORD *)(this + 400) = 10 * v4("Misc", "ShipTypeSwitchResetPeriod", 0, v2);
  *(_DWORD *)(this + 404) = v4("Misc", "CheckFastBombing", 0, v2);
  *(_DWORD *)(this + 408) = 10 * v4("Misc", "FastBombingThreshold", 30, v2);
  *(_DWORD *)(this + 396) = v4("Misc", "TimerDropFlagTerritoryRadius", -1, v2);
  *(_BYTE *)(this + 474) = v4("Misc", "AllowPubScorereset", 0, v2) != 0;
  *(_BYTE *)(this + 473) = v4("Misc", "AllowPvtScorereset", 0, v2) != 0;
  *(_BYTE *)(this + 471) = v4("Misc", "NoAntiInSafe", 0, v2) != 0;
  *(_BYTE *)(this + 472) = v4("Misc", "LockFreqs", 0, v2) != 0;
  *(_BYTE *)(this + 478) = v4("Misc", "AllowVIEClients", 1, v2) != 0;
  *(_BYTE *)(this + 479) = v4("Misc", "NoFlagRewardLimit", 0, v2) != 0;
  *(_BYTE *)(this + 480) = v4("Misc", "TrackFlood", 0, v2) != 0;
  *(_BYTE *)(this + 481) = v4("Misc", "ForceContinuumOnly", 0, v2) != 0;
  *(_BYTE *)(this + 482) = v4("Misc", "AllVips", 0, v2) != 0;
  *(_BYTE *)(this + 483) = v4("Misc", "AllowPrerelease", 1, v2) != 0;
  *(_DWORD *)(this + 428) = v4("Comms", "FlushTime", 0, v2);
  *(_DWORD *)(this + 432) = 1000 * v4("Comms", "BandwithIdleTime", 0, v2);
  *(_DWORD *)(this + 436) = v4("Comms", "SelectTime", 0, v2);
  *(_DWORD *)(this + 444) = v4("Comms", "SyncJitter", 0, v2);
  *(_DWORD *)(this + 456) = v4("Routing", "PosSendRadar", 100, v2);
  *(_DWORD *)(this + 452) = v4("Routing", "PosSendEdge", 30, v2);
  *(_DWORD *)(this + 448) = v4("Routing", "PosSendClose", 20, v2);
  *(_DWORD *)(this + 460) = v4("Routing", "ClosePosPixels", 250, v2);
  *(_DWORD *)(this + 464) = v4("Routing", "QueuePositions", 0, v2);
  GetPrivateProfileStringA_0("Billing", "IP", byte_10028A9C, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 412) = inet_addr_0(tmp_str);
  GetPrivateProfileStringA_0("Misc", "ServerIP", byte_10028A9C, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 416) = inet_addr_0(tmp_str);
  GetPrivateProfileStringA_0("Misc", "BindIP", byte_10028A9C, tmp_str, 0x3Fu, v2);
  v5 = inet_addr_0(tmp_str);
  *(_DWORD *)(this + 420) = v5;
  if ( v5 == -1 )
    *(_DWORD *)(this + 420) = 0;
  GetPrivateProfileStringA_0("Misc", "BotsIP", byte_10028A9C, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 424) = inet_addr_0(tmp_str);
  v6 = v4("Misc", "PositionDataAccess", 0, v2);
  if ( v6 == 2 )
    v52 = 639;
  else
    v52 = v6 != 1 ? 631 : 635;
  v7 = FIX_DLL_KERNEL32_dll_GetCurrentProcessId();
  v59 = (_DWORD *)FIX_DLL_KERNEL32_dll_OpenProcess(2035711, 0, v7);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v59, 4305937, this + 420, 4, 0);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v59, 4240126, &v52, 4, 0);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v59, 4256527, &v52, 4, 0);
  v8 = &unk_10024A24;
  if ( !*(_BYTE *)(this + 479) )
    v8 = &unk_10024A20;
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v59, loc_403507, v8, 2, 0);
  FIX_DLL_KERNEL32_dll_CloseHandle(v59);
  v59 = &unk_1002197C;
  do
  {
    v9 = (const CHAR *)*(v59 - 1);
    ReturnedString[0] = 0;
    GetPrivateProfileStringA_0("Validation", v9, byte_10028A9C, ReturnedString, 0x3FFu, v2);
    for ( i = 0; sub_10002E30(v48, 64, (int)ReturnedString, 0x2Cu, i); ++i )
    {
      v11 = atol_1(v10, v48);
      if ( v11 > 2 )
        v11 = 2;
      v53 = (char *)(2 - v11);
      v61 = 1;
      v62 = 1;
      v12 = sub_10003240(v48);
      v13 = *v12;
      v14 = *v12 == 35;
      v55 = v12;
      if ( v14 )
      {
        v55 = ++v12;
        v62 = 0;
      }
      else if ( v13 == 47 )
      {
        v55 = ++v12;
        v61 = 0;
      }
      if ( *v12 == 42 )
      {
        v15 = this + 12 * *v59;
        v16 = *(_DWORD *)(v15 + 280);
        v56 = 0;
        k = v15;
        if ( v16 <= 0 )
        {
LABEL_25:
          v19 = *(_DWORD *)(this + 12 * *v59 + 280);
          v20 = *(_DWORD *)(this + 12 * *v59 + 276);
          v21 = (_DWORD *)(this + 12 * *v59 + 272);
          v57 = v21;
          k = v19;
          if ( v19 >= v20 )
          {
            sub_10002D10((int)v21, 2 * (v19 + 2 * (9 * v19 + 288) + 32));
            v57[1] += 32;
            v19 = k;
            v21 = v57;
          }
          k = 38 * v19;
          v22 = *v21;
          v23 = v21[2];
          v54 = v22;
          memcpy_0(
            (void *)(v22 + 2 * (v19 + 2 * (9 * v19 + 9) + 1)),
            (const void *)(v22 + 38 * v19),
            38 * v23 - 38 * v19);
          v24 = v57;
          ++v57[2];
          v44 = 0;
          LOWORD(v45[0]) = 0;
          memcpy_0((void *)(*v24 + k), &v44, 0x26u);
          v54 = *v57 + k;
          strncpyt((void *)(v54 + 6), v55, 32);
          v18 = v54;
        }
        else
        {
          v57 = 0;
          while ( _memicmp_0(
                    (char *)v57 + *(_DWORD *)(v15 + 272) + 6,
                    v55,
                    strlen((const char *)v57 + *(_DWORD *)(v15 + 272) + 6)) )
          {
            v17 = *(_DWORD *)(k + 280);
            ++v56;
            v57 = (_DWORD *)((char *)v57 + 38);
            if ( v56 >= v17 )
              goto LABEL_24;
            v15 = k;
          }
          v18 = *(_DWORD *)(k + 272) + 38 * v56;
          if ( !v18 )
          {
LABEL_24:
            v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
            goto LABEL_25;
          }
          v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
        }
        for ( j = (int)v53; j >= 0; --j )
        {
          if ( v61 )
            *(_BYTE *)(v18 + j) |= 1u;
          if ( v62 )
            *(_BYTE *)(v18 + j + 3) |= 1u;
        }
      }
    }
    v59 += 2;
  }
  while ( v59 < dword_1002199C );
  v26 = v4("Misc", "LocalChatPrefix", 0, v2);
  v27 = v26;
  if ( v26 )
  {
    sprintf_0((char *)(this + 332), "$$%08x$", v26);
    sprintf_0((char *)(this + 364), "$$%08x$", v27 + 1);
  }
  sub_10002D60(*(void **)(this + 320));
  *(_DWORD *)(this + 320) = 0;
  *(_DWORD *)(this + 328) = 0;
  *(_DWORD *)(this + 324) = 0;
  for ( k = 0; k < 2; ++k )
  {
    v62 = k == 1;
    v28 = "StaffChat";
    if ( k != 1 )
      v28 = "LocalChat";
    GetPrivateProfileStringA_0("Misc", v28, byte_10028A9C, src, 0x3FFu, v2);
    v29 = src;
    if ( src[0] )
    {
      do
      {
        v30 = strchr_0(v29, 44);
        v53 = v30;
        if ( v30 )
          *v30 = 0;
        v50 = v62;
        strncpyt(dst, v29, 32);
        v32 = *(_DWORD *)(this + 324);
        v33 = (_DWORD *)(this + 320);
        i = *(_DWORD *)(this + 328);
        v31 = i;
        if ( i >= v32 )
        {
          sub_10002D10(this + 320, 33 * (i + 32));
          *(_DWORD *)(this + 324) += 32;
        }
        v34 = i + 32 * v31;
        memcpy_0((void *)(32 * (i + 1) + *v33 + i + 1), (const void *)(*v33 + v34), 33 * *(_DWORD *)(this + 328) - v34);
        ++*(_DWORD *)(this + 328);
        memcpy_0((void *)(*v33 + v34), v45, 0x21u);
        v35 = (int)v53;
        v36 = (_BYTE *)(*v33 + v34);
        qmemcpy(v36, dst, 0x20u);
        v36[32] = v50;
        if ( !v35 )
          break;
        v29 = (char *)(v35 + 1);
      }
      while ( *(_BYTE *)(v35 + 1) );
      v2 = v51;
    }
  }
  v37 = *(void **)(this + 484);
  v38 = (_DWORD *)(this + 484);
  sub_10002D60(v37);
  *v38 = 0;
  v38[2] = 0;
  v38[1] = 0;
  GetPrivateProfileStringA_0("Misc", "AlertCommand", byte_10028A9C, src, 0x3FFu, v2);
  for ( i = 0; sub_10002E30(v46, 32, (int)src, 0x2Cu, i); ++i )
  {
    if ( v46[0] )
    {
      v39 = v38[2];
      if ( v39 >= v38[1] )
      {
        sub_10002D10((int)v38, 32 * (v39 + 32));
        v38[1] += 32;
      }
      memcpy_0((void *)(*v38 + 32 * (v39 + 1)), (const void *)(*v38 + 32 * v39), 32 * (v38[2] + 0x7FFFFFF * v39));
      ++v38[2];
      memcpy_0((void *)(*v38 + 32 * v39), &dst[1], 0x20u);
      qmemcpy((void *)(*v38 + 32 * v39), v46, 0x20u);
    }
  }
  byte_101B3054 = 0;
  result = sub_100028D0("sid.dat");
  if ( result == 128 )
  {
    v64 = 1;
    v56 = -1;
    ReadScrty1File(&v56, "sid.dat", 1, 3);
    ReadScrty1FileOffset(&v56, (int)&unk_10029270, 128);
    byte_101B3054 = 1;
    result = sub_10001A50(&v56);
  }
  return result;
}
// 1000CA1C: variable 'v10' is possibly undefined
// 403507: using guessed type int loc_403507();
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
// 100210C0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteProcessMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210C4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_OpenProcess)(_DWORD, _DWORD, _DWORD);
// 100210C8: using guessed type int (*FIX_DLL_KERNEL32_dll_GetCurrentProcessId)(void);
// 101B3054: using guessed type char byte_101B3054;

//----- (1000CF20) --------------------------------------------------------
int __thiscall sub_1000CF20(void *this, int a2, unsigned __int8 a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ebp
  char *v7; // esi
  int v8; // ecx
  int v9; // ebp
  int *v10; // esi
  int i; // ebx
  int result; // eax
  int v13; // ecx
  int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  char v17; // [esp+28h] [ebp+Ch]

  v4 = 0;
  if ( *(_DWORD *)(a4 + 631) )
    v15 = 2;
  else
    v15 = *(_DWORD *)(a4 + 635) != 0;
  v5 = *(_DWORD *)(a4 + 28);
  if ( !v5 || (v17 = 1, !*(_BYTE *)(v5 + 64256)) )
    v17 = 0;
  v6 = 0;
  v14 = 0;
  v7 = (char *)this + 12 * (v17 != 0) + 24;
  if ( *((int *)v7 + 70) > 0 )
  {
    while ( _memicmp_0(
              (const void *)(*((_DWORD *)v7 + 68) + v4 + 6),
              (const void *)a2,
              strlen((const char *)(*((_DWORD *)v7 + 68) + v4 + 6))) )
    {
      ++v6;
      v4 += 38;
      if ( v6 >= *((_DWORD *)v7 + 70) )
        goto LABEL_14;
    }
    v8 = *((_DWORD *)v7 + 68) + 38 * v6;
    if ( v8 && *(_BYTE *)(v8 + 2 * a3 + a3 + v15) )
      v14 = 1;
  }
LABEL_14:
  v9 = 0;
  v10 = (int *)((char *)this + 12 * (v17 != 0));
  if ( v10[70] <= 0 )
    return v14;
  for ( i = 0;
        _memicmp_0((const void *)(i + v10[68] + 6), (const void *)a2, strlen((const char *)(i + v10[68] + 6)));
        i += 38 )
  {
    if ( ++v9 >= v10[70] )
      return v14;
  }
  v13 = v10[68] + 38 * v9;
  if ( !v13 )
    return v14;
  result = v14;
  if ( *(_BYTE *)(v13 + 2 * a3 + a3 + v15) )
    result = v14 | 2;
  return result;
}

//----- (1000D0B0) --------------------------------------------------------
int __fastcall sub_1000D0B0(int a1, int a2, int a3)
{
  _BYTE *v4; // esi
  int v6; // [esp-8h] [ebp-10h]
  int v7; // [esp+0h] [ebp-8h]

  v4 = (_BYTE *)(a1 + 4);
  v6 = a1 + 4;
  *(_BYTE *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_10021A6C;
  if ( !FIX_DLL_KERNEL32_dll_GetModuleFileNameA(a1, a2) )
    *v4 = 0;
  sub_10002B80(v4);
  sub_10002A10(v4, (int)v4, v7);
  *(_DWORD *)(a1 + 264) = -1;
  *(_DWORD *)(a1 + 268) = FIX_DLL_KERNEL32_dll_GetTickCount(0, v6, 260) - 15000;
  return a1;
}
// 1000D0E3: variable 'v7' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;

//----- (1000D110) --------------------------------------------------------
#error "1000D114: call analysis failed (funcsize=26)"

//----- (1000D170) --------------------------------------------------------
int __thiscall sub_1000D170(int this)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // esi
  void *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  int i; // edi
  int v10; // esi
  int v11; // ecx
  int v12; // ebx
  int v13; // eax
  int *v14; // esi
  int v15; // edi
  int v16; // ebx
  _DWORD *v17; // edi
  int j; // eax
  int k; // eax
  int v21; // [esp+0h] [ebp-11Ch] BYREF
  char v22[16]; // [esp+Ch] [ebp-110h] BYREF
  char v23; // [esp+1Ch] [ebp-100h] BYREF
  char v24[127]; // [esp+1Dh] [ebp-FFh] BYREF
  char v25[32]; // [esp+9Ch] [ebp-80h] BYREF
  void *v26; // [esp+BCh] [ebp-60h]
  int v27; // [esp+C0h] [ebp-5Ch]
  int v28; // [esp+C4h] [ebp-58h]
  char dst[32]; // [esp+C8h] [ebp-54h] BYREF
  void *v30; // [esp+E8h] [ebp-34h]
  int v31; // [esp+ECh] [ebp-30h]
  int v32; // [esp+F0h] [ebp-2Ch]
  int v33[4]; // [esp+F4h] [ebp-28h] BYREF
  int v34; // [esp+104h] [ebp-18h]
  int v35[2]; // [esp+108h] [ebp-14h] BYREF
  int v36; // [esp+118h] [ebp-4h]

  v1 = this;
  v2 = *(_DWORD *)(this + 280);
  v3 = 0;
  v35[1] = (int)&v21;
  v34 = this;
  if ( v2 > 0 )
  {
    v4 = 0;
    do
    {
      sub_10015680((void **)(*(_DWORD *)(v1 + 272) + v4 + 32));
      ++v3;
      v4 += 44;
    }
    while ( v3 < *(_DWORD *)(v1 + 280) );
  }
  sub_10002D60(*(void **)(v1 + 272));
  *(_DWORD *)(v1 + 272) = 0;
  *(_DWORD *)(v1 + 280) = 0;
  *(_DWORD *)(v1 + 276) = 0;
  v36 = 1;
  v35[0] = -1;
  ReadScrty1File(v35, (char *)(v1 + 4), 3, 3);
  while ( sub_100024F0(v35, (int)&v23, 128) )
  {
    v28 = 0;
    v27 = 0;
    v26 = 0;
    LOBYTE(v36) = 2;
    if ( (isalpha_0(v23) || sub_100172AC(v23)) && strlen(&v23) < 0x20 )
    {
      strcpy(v25, &v23);
      sub_10003280((int)v25);
      v5 = (void *)sub_100157A0(v1 + 272, *(_DWORD *)(v1 + 280));
      sub_100156A0(v5, (int)v25);
    }
    else if ( v23 == 43 )
    {
      v32 = 0;
      v31 = 0;
      v30 = 0;
      LOBYTE(v36) = 3;
      v6 = sub_10003260(v24);
      strncpyt(dst, v6, 32);
      sub_10003220((int)dst, 58, 0);
      if ( strchr_0(&v23, 58) )
      {
        v7 = strchr_0(&v23, 58);
        v8 = sub_10003260(v7 + 1);
        strncpyt(v33, v8, 16);
        sub_10003280((int)v33);
        for ( i = 0; i < *(_DWORD *)(v1 + 280); ++i )
        {
          v10 = 44 * i;
          if ( !unknown_libname_69(*(_DWORD *)(v1 + 272) + 44 * i, dst) )
          {
            v11 = *(_DWORD *)(v1 + 272);
            v12 = *(_DWORD *)(v10 + v11 + 40);
            v13 = *(_DWORD *)(v10 + v11 + 36);
            v14 = (int *)(v10 + v11 + 32);
            if ( v12 >= v13 )
            {
              sub_10002D10((int)v14, 16 * (v12 + 32));
              v14[1] += 32;
            }
            v15 = 16 * v12;
            memcpy_0((void *)(*v14 + 16 * (v12 + 1)), (const void *)(*v14 + 16 * v12), 16 * (v14[2] + 0xFFFFFFF * v12));
            v16 = *v14;
            ++v14[2];
            memcpy_0((void *)(v16 + v15), v22, 0x10u);
            v1 = v34;
            v17 = (_DWORD *)(*v14 + v15);
            *v17 = v33[0];
            v17[1] = v33[1];
            v17[2] = v33[2];
            v17[3] = v33[3];
            break;
          }
        }
      }
      LOBYTE(v36) = 2;
      for ( j = 0; j < v32; ++j )
        ;
      sub_10002D60(v30);
      v30 = 0;
      v32 = 0;
      v31 = 0;
    }
    LOBYTE(v36) = 1;
    for ( k = 0; k < v28; ++k )
      ;
    sub_10002D60(v26);
    v26 = 0;
    v28 = 0;
    v27 = 0;
  }
  return sub_10001A50(v35);
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000D470) --------------------------------------------------------
int __thiscall sub_1000D470(int this)
{
  int result; // eax

  sub_10002D60(*(void **)(this + 32));
  result = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 36) = 0;
  return result;
}

//----- (1000D490) --------------------------------------------------------
char __thiscall sub_1000D490(void *this, int a2)
{
  int v3; // eax
  signed int v4; // eax
  int v5; // edi
  int v6; // ebx
  int v8; // ecx
  int v9; // eax
  int v10; // ebx
  int i; // esi

  v3 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  if ( v3 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v3;
    v4 = sub_10002830((char *)this + 4);
    if ( v4 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v4;
      off_10024608("Ext: Re-reading %s\n", (const char *)this + 4);
      (**(void (__thiscall ***)(void *))this)(this);
    }
  }
  v5 = *((_DWORD *)this + 68);
  v6 = 0;
  if ( *((int *)this + 70) > 0 )
  {
    while ( unknown_libname_69(v5, a2 + 375) )
    {
      ++v6;
      v5 += 44;
      if ( v6 >= *((_DWORD *)this + 70) )
        return 0;
    }
    v8 = *(_DWORD *)(v5 + 40);
    if ( !v8 )
      return 1;
    v9 = *(_DWORD *)(a2 + 28);
    if ( v9 )
    {
      v10 = 0;
      if ( v8 > 0 )
      {
        for ( i = 0; unknown_libname_69(v9 + 64256, *(_DWORD *)(v5 + 32) + i); i += 16 )
        {
          v9 = *(_DWORD *)(a2 + 28);
          if ( *(_BYTE *)(v9 + 64256) )
          {
            if ( *(_BYTE *)(i + *(_DWORD *)(v5 + 32)) == 64 )
              break;
          }
          if ( ++v10 >= *(_DWORD *)(v5 + 40) )
            return 0;
        }
        return 1;
      }
    }
  }
  return 0;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000D590) --------------------------------------------------------
char __thiscall sub_1000D590(void *this, int a2)
{
  int v3; // eax
  signed int v4; // eax
  const char *v5; // ebp
  int v6; // ebx

  v3 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  if ( v3 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v3;
    v4 = sub_10002830((char *)this + 4);
    if ( v4 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v4;
      off_10024608("Ext: Re-reading %s\n", (const char *)this + 4);
      (**(void (__thiscall ***)(void *))this)(this);
    }
  }
  v5 = (const char *)*((_DWORD *)this + 68);
  v6 = 0;
  if ( *((int *)this + 70) <= 0 )
    return 0;
  while ( unknown_libname_69(v5, a2) && strcmp(v5, "*!") )
  {
    ++v6;
    v5 += 44;
    if ( v6 >= *((_DWORD *)this + 70) )
      return 0;
  }
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);

//----- (1000D660) --------------------------------------------------------
int __fastcall sub_1000D660(int a1, int a2)
{
  sub_1000D680((int)dword_101B0720, a2, (int)"moderate.txt");
  return atexit((void (*)(void))sub_1000D770);
}

//----- (1000D680) --------------------------------------------------------
int __fastcall sub_1000D680(int a1, int a2, int a3)
{
  _BYTE *v4; // edi
  int (*v5)(void); // ebp
  int v6; // eax
  signed int v7; // eax
  int v9; // [esp-8h] [ebp-28h]
  int v10; // [esp+18h] [ebp-8h]

  v4 = (_BYTE *)(a1 + 4);
  v9 = a1 + 4;
  *(_BYTE *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_10021A6C;
  if ( !FIX_DLL_KERNEL32_dll_GetModuleFileNameA(a1, a2) )
    *v4 = 0;
  sub_10002B80(v4);
  sub_10002A10(v4, (int)v4, v10);
  v5 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetTickCount;
  *(_DWORD *)(a1 + 264) = -1;
  *(_DWORD *)(a1 + 268) = ((int (__cdecl *)(_DWORD, int, int))v5)(0, v9, 260) - 15000;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)a1 = off_10021A70;
  v6 = v5();
  if ( v6 - *(_DWORD *)(a1 + 268) >= 15000 )
  {
    *(_DWORD *)(a1 + 268) = v6;
    v7 = sub_10002830(v4);
    if ( v7 != *(_DWORD *)(a1 + 264) )
    {
      *(_DWORD *)(a1 + 264) = v7;
      off_10024608("Ext: Re-reading %s\n", v4);
      (**(void (__thiscall ***)(int))a1)(a1);
    }
  }
  return a1;
}
// 1000D6CF: variable 'v10' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;
// 10021A70: using guessed type int (*off_10021A70[2])();

//----- (1000D770) --------------------------------------------------------
int __cdecl sub_1000D770()
{
  int v0; // ebx
  int v1; // ebp
  char *v2; // esi
  int result; // eax

  v0 = 0;
  if ( (int)dword_101B0720[70] > 0 )
  {
    v1 = 0;
    do
    {
      v2 = (char *)dword_101B0720[68] + v1 + 32;
      sub_10002D60(*(void **)v2);
      *(_DWORD *)v2 = 0;
      *((_DWORD *)v2 + 2) = 0;
      *((_DWORD *)v2 + 1) = 0;
      ++v0;
      v1 += 44;
    }
    while ( v0 < (int)dword_101B0720[70] );
  }
  result = sub_10002D60(dword_101B0720[68]);
  dword_101B0720[68] = 0;
  dword_101B0720[70] = 0;
  dword_101B0720[69] = 0;
  return result;
}

//----- (1000D7F0) --------------------------------------------------------
int __fastcall sub_1000D7F0(int a1, int a2)
{
  sub_1000D680((int)&unk_1003E318, a2, (int)"smod.txt");
  return atexit(unknown_libname_57);
}

//----- (1000D820) --------------------------------------------------------
int __fastcall sub_1000D820(int a1, int a2)
{
  sub_1000D680((int)&unk_10065080, a2, (int)"sysop.txt");
  return atexit(unknown_libname_58);
}

//----- (1000D850) --------------------------------------------------------
int __fastcall sub_1000D850(int a1, int a2)
{
  sub_1000D680((int)&dword_101A93E0, a2, (int)"vip.txt");
  return atexit(unknown_libname_59);
}
// 101A93E0: using guessed type int dword_101A93E0;

//----- (1000D880) --------------------------------------------------------
int __fastcall sub_1000D880(int a1, int a2)
{
  sub_1000D8A0((int)&dword_101A51A8, a2, (int)"server.ini");
  return atexit((void (*)(void))sub_1000DA00);
}
// 101A51A8: using guessed type int dword_101A51A8;

//----- (1000D8A0) --------------------------------------------------------
int __fastcall sub_1000D8A0(int a1, int a2, int a3)
{
  _BYTE *v4; // edi
  int (*v5)(void); // ebp
  int v6; // ebx
  int v7; // eax
  signed int v8; // eax
  int v10; // [esp-8h] [ebp-28h]
  int v11; // [esp+18h] [ebp-8h]

  v4 = (_BYTE *)(a1 + 4);
  v10 = a1 + 4;
  *(_BYTE *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_10021A6C;
  if ( !FIX_DLL_KERNEL32_dll_GetModuleFileNameA(a1, a2) )
    *v4 = 0;
  sub_10002B80(v4);
  sub_10002A10(v4, (int)v4, v11);
  v5 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetTickCount;
  *(_DWORD *)(a1 + 264) = -1;
  *(_DWORD *)(a1 + 268) = ((int (__cdecl *)(_DWORD, int, int))v5)(0, v10, 260) - 15000;
  `eh vector constructor iterator'(a1 + 272, 12, 4, sub_10015610, sub_10015620);
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 440) = 305419896;
  *(_DWORD *)(a1 + 492) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(_DWORD *)(a1 + 484) = 0;
  *(_DWORD *)a1 = &off_10021A74;
  v6 = v5();
  sprintf_0((char *)(a1 + 332), "$$%08x$", v6);
  sprintf_0((char *)(a1 + 364), "$$%08x$", v6 + 1);
  v7 = v5();
  if ( v7 - *(_DWORD *)(a1 + 268) >= 15000 )
  {
    *(_DWORD *)(a1 + 268) = v7;
    v8 = sub_10002830(v4);
    if ( v8 != *(_DWORD *)(a1 + 264) )
    {
      *(_DWORD *)(a1 + 264) = v8;
      off_10024608("Ext: Re-reading %s\n", v4);
      (**(void (__thiscall ***)(int))a1)(a1);
    }
  }
  return a1;
}
// 1000D8EF: variable 'v11' is possibly undefined
// 100170B8: using guessed type _DWORD __stdcall `eh vector constructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;
// 10021A74: using guessed type int (*off_10021A74)();

//----- (1000DA00) --------------------------------------------------------
int __cdecl sub_1000DA00()
{
  sub_10002D60((void *)*(&dword_101A51A8 + 121));
  *(&dword_101A51A8 + 121) = 0;
  *(&dword_101A51A8 + 123) = 0;
  *(&dword_101A51A8 + 122) = 0;
  sub_10002D60((void *)*(&dword_101A51A8 + 80));
  *(&dword_101A51A8 + 80) = 0;
  *(&dword_101A51A8 + 82) = 0;
  *(&dword_101A51A8 + 81) = 0;
  return `eh vector destructor iterator'(&dword_101A51A8 + 68, 12, 4, sub_10015620);
}
// 1001713A: using guessed type _DWORD __stdcall `eh vector destructor iterator'(_DWORD, _DWORD, _DWORD, _DWORD);
// 101A51A8: using guessed type int dword_101A51A8;

//----- (1000DAB0) --------------------------------------------------------
int __thiscall sub_1000DAB0(int this)
{
  int v1; // ebp
  __int16 *v2; // esi
  char *v3; // edx
  char **v4; // eax
  int v5; // ebp
  int result; // eax
  int v7; // [esp+10h] [ebp-8h]

  v1 = -46 - this;
  v2 = (__int16 *)(this + 46);
  v7 = 8;
  while ( 1 )
  {
    *v2 = 5 * *v2 / 2;
    v2[1] *= 3;
    v2[2] *= 16;
    v2[4] = *(v2 - 1);
    v2[5] = *v2;
    v2[6] = v2[1];
    v2[7] = v2[2];
    v2[8] = v2[3];
    v2[19] = 10;
    v2[20] = 10;
    v2[21] = 10;
    v2[22] = 10;
    v2[25] = 100;
    v2[26] = 999;
    v3 = (char *)v2 + v1;
    v4 = (char **)&unk_1002461C;
    do
    {
      v5 = (int)*v4++;
      *(_WORD *)&v3[this + 18 + v5] = 0;
    }
    while ( v4 < off_10024650 );
    *((_BYTE *)v2 + 66) = 0x80;
    *((_BYTE *)v2 + 67) = 117;
    *((_BYTE *)v2 + 68) = 0x80;
    *((_BYTE *)v2 + 69) = 0x80;
    *((_BYTE *)v2 + 70) = 0x80;
    *((_BYTE *)v2 + 71) = 0x80;
    *((_BYTE *)v2 + 72) = 0x80;
    *((_BYTE *)v2 + 73) = 0x80;
    *(_DWORD *)(v2 + 41) = *(_DWORD *)(v2 + 41) & 0xFFFFFE1F | 2;
    v2 += 72;
    if ( !--v7 )
      break;
    v1 = -46 - this;
  }
  result = 0;
  *(_BYTE *)(this + 1373) = 0x80;
  *(_BYTE *)(this + 1375) = 0x80;
  *(_DWORD *)(this + 1156) = 0;
  *(_DWORD *)(this + 1200) = 0;
  *(_DWORD *)(this + 1196) = 0;
  *(_DWORD *)(this + 1160) = 0;
  *(_WORD *)(this + 1266) = 0;
  return result;
}
// 10024650: using guessed type char *off_10024650[12];

//----- (1000DBE0) --------------------------------------------------------
#error "1000DC11: call analysis failed (funcsize=135)"

//----- (1000DD90) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __stdcall fix_export_0(void *msg, PLAYER *ship, char *buf, struct PLAYER *arena)
{
  char *v4; // edi
  PLAYER *v5; // ebx
  unsigned int v6; // edx
  int v7; // eax
  char *v8; // ebx
  int *v9; // esi
  int v10; // eax
  char v11; // cl
  char *v12; // ebx
  int v13; // eax
  _BOOL1 v14; // cc
  int result; // eax
  char *v16; // esi
  int v17; // ebx
  const char *v18; // esi
  char *v19; // edi
  PLAYER *v20; // ebx
  char *v21; // eax
  int v22; // esi
  int *v23; // ebx
  int v24; // edx
  int v25; // eax
  char v26; // al
  char *v27; // esi
  char *v28; // ebx
  char *v29; // eax
  char *v30; // eax
  int v31; // edi
  int v32; // eax
  int v33; // esi
  _BOOL1 v34; // zf
  char v35; // cl
  const char *v36; // edi
  char *v37; // eax
  char *v38; // esi
  char v39; // al
  PLAYER *v40; // edx
  int v41; // eax
  char *v42; // eax
  unsigned int v43; // kr08_4
  PLAYER *v44; // eax
  int v45; // ecx
  int v46; // esi
  PLAYER *v47; // ebx
  char v48; // al
  char *v49; // eax
  char *v50; // ecx
  char *v51; // eax
  char *v52; // eax
  char *v53; // esi
  char *v54; // eax
  char *v55; // edi
  const void *v56; // edi
  char *v57; // ebx
  const char *v58; // esi
  int v59; // edi
  const char *v60; // eax
  signed int *v61; // eax
  void *v62; // ecx
  int v63; // eax
  int v64; // ecx
  int v65; // eax
  int v66; // eax
  struct ARENA *v67; // eax
  void *v68; // edi
  signed int *v69; // eax
  void *v70; // ecx
  int v71; // eax
  int v72; // esi
  int v73; // edi
  int v74; // ebx
  int v75; // edx
  __int16 v76; // ax
  int v77; // eax
  int v78; // eax
  int v79; // eax
  int v80; // ecx
  int v81; // eax
  int v82; // eax
  int v83; // ecx
  int v84; // ecx
  int v85; // eax
  int v86; // esi
  char *v87; // edi
  signed int *v88; // edi
  u_long v89; // esi
  void *v90; // ecx
  int v91; // ebx
  char *v92; // eax
  unsigned int v93; // ebx
  int v94; // edi
  int *v95; // esi
  void *v96; // ecx
  int v97; // eax
  int v98; // ecx
  int *i; // edx
  signed int *v100; // eax
  void *v101; // ecx
  int v102; // eax
  void *v103; // ecx
  __int16 v104; // ax
  char *v105; // edi
  struct ARENA *v106; // eax
  void *v107; // ecx
  __int16 v108; // ax
  struct ARENA *v109; // ecx
  unsigned int v110; // ebx
  signed int *v111; // esi
  char v112; // al
  char *v113; // edi
  void *v114; // ecx
  char *v115; // eax
  struct ARENA *v116; // edx
  int *v117; // ebx
  int v118; // esi
  const char *v119; // edi
  char *v120; // eax
  char *v121; // esi
  char *v122; // eax
  int v123; // eax
  int v124; // ecx
  int v125; // ebx
  struct PLAYER *v126; // esi
  int v127; // eax
  int v128; // edx
  const char *v129; // esi
  unsigned int v130; // eax
  PLAYER *v131; // ebx
  int v132; // edx
  int v133; // eax
  int v134; // ebx
  unsigned int v135; // esi
  unsigned int v136; // edx
  char *v137; // eax
  int v138; // ecx
  signed int *v139; // eax
  void *v140; // ecx
  int v141; // eax
  int v142; // ecx
  int v143; // esi
  int v144; // edx
  int v145; // ecx
  int v146; // eax
  int v147; // eax
  signed int *v148; // eax
  void *v149; // ecx
  int v150; // eax
  int v151; // eax
  int v152; // ecx
  int v153; // esi
  PLAYER **v154; // eax
  unsigned int v155; // eax
  int *v156; // ecx
  unsigned int v157; // eax
  int v158; // esi
  int *v159; // ecx
  char v160; // bl
  int v161; // edi
  int v162; // edi
  int v163; // ebx
  int v164; // edi
  signed int *v165; // edi
  void *v166; // ecx
  int v167; // esi
  char *v168; // eax
  signed int *v169; // eax
  void *v170; // ecx
  int v171; // eax
  int v172; // esi
  int v173; // ebx
  int v174; // eax
  const char *v175; // [esp-18h] [ebp-94Ch]
  const char *v176; // [esp-14h] [ebp-948h]
  unsigned int v177; // [esp-14h] [ebp-948h]
  int v178; // [esp-10h] [ebp-944h]
  int v179; // [esp-Ch] [ebp-940h]
  int v180; // [esp-8h] [ebp-93Ch]
  int v181; // [esp-4h] [ebp-938h]
  int v182; // [esp+4h] [ebp-930h]
  int v183; // [esp+4h] [ebp-930h]
  int v184; // [esp+8h] [ebp-92Ch]
  int v185; // [esp+Ch] [ebp-928h]
  int v186; // [esp+10h] [ebp-924h]
  char v187[1428]; // [esp+1Ch] [ebp-918h] BYREF
  char v188; // [esp+5B0h] [ebp-384h] BYREF
  char v189[11]; // [esp+5B1h] [ebp-383h] BYREF
  char v190; // [esp+5BCh] [ebp-378h] BYREF
  char v191; // [esp+5BDh] [ebp-377h] BYREF
  char v192[6]; // [esp+5C0h] [ebp-374h] BYREF
  char v193; // [esp+5C6h] [ebp-36Eh] BYREF
  char v194; // [esp+67Fh] [ebp-2B5h] BYREF
  char v195[19]; // [esp+6B1h] [ebp-283h] BYREF
  char v196; // [esp+6C4h] [ebp-270h] BYREF
  char v197; // [esp+6C5h] [ebp-26Fh]
  char v198; // [esp+6C6h] [ebp-26Eh]
  __int16 v199; // [esp+6C7h] [ebp-26Dh]
  char dst[123]; // [esp+6C9h] [ebp-26Bh] BYREF
  char v201[64]; // [esp+744h] [ebp-1F0h] BYREF
  char v202[32]; // [esp+784h] [ebp-1B0h] BYREF
  char v203[32]; // [esp+7A4h] [ebp-190h] BYREF
  char src[256]; // [esp+7C4h] [ebp-170h] BYREF
  int v205; // [esp+8C4h] [ebp-70h]
  int v206; // [esp+8C8h] [ebp-6Ch]
  int v207; // [esp+8CCh] [ebp-68h]
  int v208; // [esp+8D0h] [ebp-64h]
  int v209; // [esp+8D4h] [ebp-60h]
  int v210; // [esp+8D8h] [ebp-5Ch]
  int v211; // [esp+8DCh] [ebp-58h]
  int v212; // [esp+8E0h] [ebp-54h]
  int v213; // [esp+8E4h] [ebp-50h]
  int v214; // [esp+8E8h] [ebp-4Ch]
  int v215; // [esp+8ECh] [ebp-48h]
  int v216; // [esp+8F0h] [ebp-44h]
  int v217; // [esp+8F4h] [ebp-40h]
  int v218; // [esp+8F8h] [ebp-3Ch]
  int v219; // [esp+8FCh] [ebp-38h]
  int v220; // [esp+900h] [ebp-34h]
  int v221; // [esp+904h] [ebp-30h]
  int v222; // [esp+908h] [ebp-2Ch]
  int v223; // [esp+90Ch] [ebp-28h]
  int v224; // [esp+910h] [ebp-24h]
  __int128 v225; // [esp+914h] [ebp-20h] BYREF
  char *v226; // [esp+924h] [ebp-10h]
  _BYTE buf_sz[5]; // [esp+928h] [ebp-Ch] BYREF
  char *player; // [esp+930h] [ebp-4h]
  char *msga; // [esp+93Ch] [ebp+8h]
  char *msgb; // [esp+93Ch] [ebp+8h]
  PLAYER *msgc; // [esp+93Ch] [ebp+8h]
  char *msgd; // [esp+93Ch] [ebp+8h]
  const char *msge; // [esp+93Ch] [ebp+8h]
  const char *msgf; // [esp+93Ch] [ebp+8h]
  char *msgg; // [esp+93Ch] [ebp+8h]
  char msg_3; // [esp+93Fh] [ebp+Bh]

  v4 = sub_10003260(msg);
  msga = v4;
  if ( *v4 != 63 )
  {
    if ( *v4 != 42 )
      return 1;
    if ( ship && !ship->bIsModerator )
    {
      v43 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
      v44 = ship;
      if ( v43 / 0xA - *(_DWORD *)&ship->field_283[12] >= 0x96 )
      {
        *(_DWORD *)&ship->field_283[12] = v43 / 0xA;
        *(_DWORD *)&v44->field_283[16] = 0;
      }
      else
      {
        v45 = *(_DWORD *)&ship->field_283[16] + 1;
        *(_DWORD *)&ship->field_283[16] = v45;
        if ( v45 > 7 )
        {
          v44->dwDisconnectReason = 33;
          *(_DWORD *)&v44->field_2C[12] = 1;
          off_10024608("Ext: Played kicked off for message flooding: %s\n", v44->player_name);
          player = "WARNING: You have been disconnected for message flooding";
          SendArenaMessagePlayer(ship, "WARNING: You have been disconnected for message flooding", 0);
        }
      }
    }
    goto LABEL_103;
  }
  v5 = ship;
  if ( ship && !ship->bIsSysop )
  {
    v6 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() / 0xAu;
    if ( v6 - *(_DWORD *)&v5->field_283[12] >= 0x96 )
    {
      *(_DWORD *)&v5->field_283[12] = v6;
      *(_DWORD *)&v5->field_283[16] = 0;
    }
    else
    {
      v7 = *(_DWORD *)&v5->field_283[16] + 1;
      *(_DWORD *)&v5->field_283[16] = v7;
      if ( v7 > 7 )
      {
        v5->dwDisconnectReason = 33;
        *(_DWORD *)&v5->field_2C[12] = 1;
        off_10024608("Ext: Played kicked off for message flooding: %s\n", v5->player_name);
        player = "WARNING: You have been disconnected for message flooding";
        SendArenaMessagePlayer(ship, "WARNING: You have been disconnected for message flooding", 0);
      }
    }
  }
  if ( !unknown_libname_69(v4, "?arena") && v5 )
  {
    byte_101B083C = 47;
    msgb = 0;
    v8 = byte_101B083D;
    if ( nArenas > 0 )
    {
      v9 = ArenaArray;
      buf = (char *)ArenaArray;
      do
      {
        v10 = *v9;
        if ( *v9 )
        {
          v11 = *(_BYTE *)(v10 + 64256);
          if ( v11 != 35 || ship->bIsModerator || v10 == ship->lpCurrentArena )
          {
            if ( v11 )
            {
              strcpy(v8, (const char *)(v10 + 64256));
              v9 = (int *)buf;
            }
            else
            {
              sprintf_0(v8, "%d", msgb);
            }
            v12 = strchr_0(v8, 0) + 1;
            v13 = *v9;
            if ( *v9 == ship->lpCurrentArena )
              *(_WORD *)v12 = -*(_WORD *)(v13 + 65292);
            else
              *(_WORD *)v12 = *(_WORD *)(v13 + 65292);
            v8 = v12 + 2;
          }
        }
        ++v9;
        v14 = (int)++msgb < nArenas;
        buf = (char *)v9;
      }
      while ( v14 );
    }
    buf = &sub_1000B6E0((int)dword_1003E438, (int)v8, ship->bIsModerator != 0)[v8 - &byte_101B083C];
    PlayerSendPacket(ship, &byte_101B083C, (int)buf, 1);
    return 0;
  }
  v16 = buf;
  if ( (int)buf <= 2 )
    goto LABEL_29;
  if ( v5 )
  {
    if ( isalpha_0(v4[1]) )
    {
      SendMessage(ship, "Send commands as public chat. Command ignored.", 0);
      return 0;
    }
LABEL_29:
    if ( v5 )
    {
      if ( v5->lpCurrentArena )
      {
        if ( v16 == (char *)2 )
        {
          player = 0;
          if ( dword_101A5394 > 0 )
          {
            v17 = 0;
            do
            {
              v18 = (const char *)(v17 + dword_101A538C);
              if ( !_memicmp_0(
                      v4 + 1,
                      (const void *)(v17 + dword_101A538C),
                      strlen((const char *)(v17 + dword_101A538C))) )
              {
                v19 = sub_10003260(&v4[strlen(v18) + 1]);
                if ( *v19 )
                {
                  v20 = ship;
                  v21 = sub_1000C1B0((int)ship, 1);
                  sprintf_0(src, "%s: (%s) (%s): ", v18, v20->player_name, v21);
                  sub_10003060(src, v19, 256);
                  v22 = 0;
                  if ( nPlayerArray2 > 0 )
                  {
                    v23 = PlayerArray2;
                    do
                    {
                      msgc = (PLAYER *)*v23;
                      if ( *v23 && *(_DWORD *)(*v23 + 639) )
                      {
                        v196 = 7;
                        v197 = 7;
                        v198 = 0;
                        v199 = -1;
                        strncpyt(dst, src, 250);
                        arena = (struct PLAYER *)(strlen(dst) + 6);
                        buf = &v196;
                        PlayerSendPacket(msgc, &v196, (int)arena, 1);
                      }
                      ++v22;
                      ++v23;
                    }
                    while ( v22 < nPlayerArray2 );
                  }
                  sub_1000B400((int)dword_1003E438, 3, src, 0);
                  SendMessage(ship, "Message has been sent to online moderators", 0);
                  off_10024608("Ext: %.150s\n", src);
                }
                return 0;
              }
              v17 += 32;
              ++player;
            }
            while ( (int)player < dword_101A5394 );
            v5 = ship;
          }
        }
      }
      if ( !_memicmp_0(v4, "?lag", 4u) )
      {
        sprintf_0(
          src,
          "PING Current:%d ms  Average:%d ms  Low:%d ms  High:%d ms  S2C: %d.%d%%  C2S: %d.%d%%",
          10 * *(__int16 *)&ship->field_117[51],
          10 * *(__int16 *)&ship->field_117[53],
          10 * *(__int16 *)&ship->field_117[55],
          10 * *(__int16 *)&ship->field_117[57],
          (1000 - *(_DWORD *)&ship->field_319[8]) / 10,
          (1000 - *(_DWORD *)&ship->field_319[8]) % 10,
          (1000 - *(_DWORD *)&ship->field_319[12]) / 10,
          (1000 - *(_DWORD *)&ship->field_319[12]) % 10);
        SendMessage(ship, src, 0);
        return 0;
      }
      if ( !_memicmp_0(v4, "?obscene", 8u) )
      {
        v24 = v5->bWaveMessages;
        v5->field_341[180] = 0;
        player = "Obscenity block ON";
        v5->bWaveMessages = v24 == 0;
        if ( v24 )
          player = "Obscenity block OFF";
        SendMessage(ship, player, 0);
      }
      if ( !_memicmp_0(v4, "?getnews", 8u) )
      {
        if ( v5->dwShip == 8 )
        {
          buf = "news.txt";
          sprintf_0(&v196, "File sent: %s (please wait...)", "news.txt");
          SendMessage(ship, &v196, 0);
          SendFile(&ship->hProcess, buf);
        }
        else
        {
          SendMessage(ship, "Must be in spectator mode to get news", 0);
        }
        return 0;
      }
      v25 = v5->lpCurrentArena;
      if ( v25
        && (byte_101A5382 && !*(_BYTE *)(v25 + 64256) || byte_101A5381 && *(_BYTE *)(v25 + 64256))
        && !_memicmp_0(v4, "?scorereset", 0xBu) )
      {
        SendResetScoresPacket(ship);
        SendMessage(ship, "Score reset", 0);
        return 0;
      }
      if ( !_memicmp_0(v4, "?chat", 5u) )
      {
        v26 = v4[5];
        if ( (v26 == 32 || v26 == 61) && FindMeOut1 && dword_101A52F0 )
        {
          memcpy_0(v192, v4, sizeof(v192));
          v27 = v4 + 6;
          v28 = &v193;
          msgd = v4 + 6;
          if ( v4[6] )
          {
            do
            {
              if ( v28 >= &v194 )
                break;
              v29 = strchr_0(v27, 44);
              buf = v29;
              if ( v29 )
                *v29 = 0;
              strncpyt(v203, v27, 32);
              v30 = strrchr_0(v203, 47);
              if ( v30 )
                *v30 = 0;
              sub_10003280((int)v203);
              v31 = 0;
              if ( dword_101A52F0 > 0 )
              {
                v32 = dword_101A52E8;
                v33 = 0;
                while ( 1 )
                {
                  v34 = unknown_libname_69(v33 + v32, v203) == 0;
                  v32 = dword_101A52E8;
                  if ( v34 && (!*(_BYTE *)(v33 + dword_101A52E8 + 32) || ship->bIsModerator) )
                    break;
                  ++v31;
                  v33 += 33;
                  if ( v31 >= dword_101A52F0 )
                    goto LABEL_85;
                }
                v35 = *(_BYTE *)(v31 + 32 * v31 + dword_101A52E8 + 32);
                v36 = (const char *)&unk_101A5314;
                if ( !v35 )
                  v36 = (const char *)&unk_101A52F4;
                strcpy(v28, v36);
                v28 = strchr_0(v28, 0);
LABEL_85:
                v27 = msgd;
              }
              strncpyt(v28, v27, 32);
              v37 = strchr_0(v28, 0);
              v38 = buf;
              v28 = v37;
              if ( !buf )
                break;
              *v37 = 44;
              v39 = v38[1];
              ++v28;
              v27 = v38 + 1;
              msgd = v27;
            }
            while ( v39 );
          }
          v40 = ship;
          *v28 = 0;
          v41 = v40->connection_id;
          buf = v192;
          HIWORD(ship) = HIWORD(FindMeOut1);
          biller_user_command(FindMeOut1, v41, v192);
          return 0;
        }
      }
      if ( !_memicmp_0(v4, "?find", 5u) )
      {
        v42 = sub_10003260(v4 + 5);
        if ( find_player_request(v5, v42) )
          return 0;
      }
    }
  }
  if ( _memicmp_0(v4, "?get", 4u) && _memicmp_0(v4, "?set", 4u) && _memicmp_0(v4, "?recycle", 8u) )
    return 1;
LABEL_103:
  v46 = 0;
  player = 0;
  if ( buf == (char *)5 && (int)arena >= 0 )
  {
    v46 = (int)*(&PlayerArray + (_DWORD)arena);
    player = (char *)v46;
  }
  v47 = ship;
  if ( !(unsigned __int8)((int (__fastcall *)(PLAYER *, char *))sub_1000DBE0)(ship, v4) )
    return 0;
  v48 = sub_1000CF20(&dword_101A51A8, (int)v4, buf == (char *)5, (int)v47);
  if ( (v48 & 2) != 0 )
  {
    v49 = sub_1000C1B0((int)v47, 1);
    off_10024608("Ext: Ignoring %s (%s): %.150s\n", v47->player_name, v49, v4);
    return 0;
  }
  if ( (v48 & 1) != 0 )
  {
    if ( v46 )
    {
      v50 = (char *)(v46 + 375);
      v51 = " to ";
    }
    else
    {
      v50 = byte_10028A9C;
      v51 = byte_10028A9C;
    }
    v176 = v50;
    v175 = v51;
    v52 = sub_1000C1B0((int)v47, 1);
    off_10024608("Ext: %s (%s)%s%s: %.150s\n", v47->player_name, v52, v175, v176, v4);
  }
  if ( v46 && !*(_DWORD *)(v46 + 28) )
    return 0;
  if ( !v47->bIsModerator )
    return 1;
  if ( !v47->bIsSysop )
    goto LABEL_251;
  if ( !_memicmp_0(v4 + 4, "file ", 4u) && *v4 == 42 )
  {
    v53 = sub_10003260(v4 + 9);
    buf = v53;
    sub_10003280((int)v53);
    if ( !*v53 || strchr_0(v53, 92) || strchr_0(v53, 47) || strchr_0(v53, 58) || strchr_0(v53, 42) || strchr_0(v53, 63) )
    {
      SendMessage(ship, "Invalid file name", 0);
      result = 0;
    }
    else
    {
      v54 = strrchr_0(v53, 46);
      v55 = v54;
      if ( !v54
        || unknown_libname_69(v54, ".exe")
        && unknown_libname_69(v55, ".com")
        && unknown_libname_69(v55, ".bat")
        && unknown_libname_69(v55, ".cmd")
        && unknown_libname_69(v55, ".dll")
        && unknown_libname_69(v55, ".pif")
        && unknown_libname_69(v55, ".lnk") )
      {
        v56 = msga + 1;
        if ( _memicmp_0(msga + 1, "put", 3u) )
        {
          if ( _memicmp_0(v56, "get", 3u) )
          {
            if ( !_memicmp_0(v56, "del", 3u) && sub_10001F70(v53) )
            {
              sprintf_0(src, "File deleted: %s", v53);
              SendMessage(ship, src, 0);
            }
            result = 0;
          }
          else
          {
            sprintf_0(v192, "File sent: %s (please wait...)", v53);
            SendMessage(ship, v192, 0);
            SendFile(&ship->hProcess, buf);
            result = 0;
          }
        }
        else
        {
          v188 = 25;
          strncpyt(v195, v53, 16);
          strncpyt(v189, v53, 256);
          PlayerSendPacket(ship, &v188, 273, 1);
          result = 0;
        }
      }
      else
      {
        SendMessage(ship, "Not allowed file type", 0);
        result = 0;
      }
    }
    return result;
  }
  v57 = player;
  if ( !_memicmp_0(v4, "*einfo", 6u) && player )
  {
    v58 = "Continuum";
    if ( *((_DWORD *)player + 6) != 1 )
      v58 = (const char *)&off_100251F4;
    v59 = *((_DWORD *)player + 25);
    v177 = (FIX_DLL_KERNEL32_dll_GetTickCount(*((_DWORD *)player + 662), v179, v180) - *(_DWORD *)(v57 + 1327)) / 0x3E8u;
    v60 = sub_10010A70((int)v57);
    sprintf_0(
      src,
      "%s: UserId: %d  Res: %dx%d  Client: %s %d.%d  Proxy: %s  Idle: %d s  Timer drift: %d\n",
      v57 + offsetof(PLAYER, player_name),
      *(_DWORD *)(v57 + offsetof(PLAYER, dwUserID)),
      *(_DWORD *)(v57 + 619),
      *(_DWORD *)(v57 + 623),
      v58,
      v59 / 100,
      v59 % 100,
      v60,
      v177,
      v178);
    buf = src;
    SendMessage(ship, src, 0);
    v4 = msga;
  }
  if ( !_memicmp_0(v4, "*points", 7u) && v57 )
  {
    v61 = (signed int *)sub_10003260(v4 + 7);
    v63 = atol_1(v62, v61);
    v64 = *(_DWORD *)(v57 + 0x229);
    v65 = *(_DWORD *)(v57 + 0x22D) + v63;
    *(_WORD *)((char *)&v225 + 1) = *((_WORD *)v57 + 10);
    *(_DWORD *)(v57 + 0x229) = 0;
    LOBYTE(v225) = 9;
    *(_DWORD *)((char *)&v225 + 3) = 0;
    HIBYTE(buf) = 1;
    v66 = v64 + v65 < 0 ? 0 : v64 + v65;
    LOWORD(v64) = *(_WORD *)(v57 + 0x225);
    *(_DWORD *)(v57 + 0x22D) = v66;
    *(_DWORD *)((char *)&v225 + 7) = v66;
    *(_WORD *)((char *)&v225 + 11) = *(_WORD *)(v57 + offsetof(PLAYER, score));
    v67 = (struct ARENA *)*((_DWORD *)v57 + 7);
    *(_WORD *)((char *)&v225 + 13) = v64;
    v226 = (char *)&v225;
    arena = (struct PLAYER *)v67;
    ArenaSendPacket(v67, (char *)&v225, 15, HIBYTE(buf));
  }
  if ( !_memicmp_0(v4, "*bandwidth", 0xAu) && v57 )
  {
    v68 = v4 + 10;
    if ( *sub_10003260(v68) )
    {
      v69 = (signed int *)sub_10003260(v68);
      v71 = atol_1(v70, v69);
      if ( v71 > 200 )
        *(_DWORD *)(v57 + 1022) = v71;
    }
    sprintf_0(src, "BANDWIDTH: %d", *(_DWORD *)(v57 + 1022));
    buf = src;
    SendMessage(ship, src, 0);
    v4 = msga;
  }
  if ( !_memicmp_0(v4, "*version", 8u) )
  {
    buf = "1.34.14b (Thu May  6 14:31:45 2004)";
    SendMessage(ship, "1.34.14b (Thu May  6 14:31:45 2004)", 0);
  }
  if ( !_memicmp_0(v4, "*shutdown", 8u) && sub_100027F0("noshutdown") )
    return 0;
  if ( _memicmp_0(v4, "*lag", 4u) )
    goto LABEL_235;
  if ( v57 )
    goto LABEL_235;
  v72 = 0;
  v73 = 0x7FFFFFFF;
  *(_DWORD *)&v203[20] = -1;
  v214 = -1;
  v218 = -1;
  *(_QWORD *)((char *)&v225 + 4) = 0xFFFFFFFFi64;
  v222 = -1;
  v206 = -1;
  v210 = -1;
  v74 = 0x7FFFFFFF;
  *(_DWORD *)&v203[16] = 0x7FFFFFFF;
  *(_DWORD *)&v203[24] = 0;
  v213 = 0x7FFFFFFF;
  v215 = 0;
  v216 = 0;
  v217 = 0x7FFFFFFF;
  v219 = 0;
  v220 = 0;
  LODWORD(v225) = 0x7FFFFFFF;
  HIDWORD(v225) = 0;
  v221 = 0x7FFFFFFF;
  v223 = 0;
  v224 = 0;
  v205 = 0x7FFFFFFF;
  v207 = 0;
  v208 = 0;
  v209 = 0x7FFFFFFF;
  v211 = 0;
  v212 = 0;
  arena = 0;
  if ( nPlayerArray2 <= 0 )
    goto LABEL_235;
  buf = (char *)PlayerArray2;
  do
  {
    v75 = *(_DWORD *)buf;
    v76 = *(_WORD *)(*(_DWORD *)buf + 330);
    if ( !v76 )
      goto LABEL_214;
    if ( v76 >= 0 && v76 <= 200 )
    {
      *(_DWORD *)&v203[24] += v76;
      ++v72;
      if ( v76 < *(int *)&v203[16] )
        *(_DWORD *)&v203[16] = v76;
      if ( v76 > *(int *)&v203[20] )
        *(_DWORD *)&v203[20] = v76;
    }
    v77 = *(__int16 *)(v75 + 332);
    if ( v77 >= 0 && v77 <= 200 )
    {
      ++HIDWORD(v225);
      DWORD2(v225) += v77;
      if ( v77 < (int)v225 )
        LODWORD(v225) = v77;
      if ( v77 > SDWORD1(v225) )
        DWORD1(v225) = v77;
    }
    v78 = *(__int16 *)(v75 + 334);
    if ( v78 >= 0 && v78 <= 200 )
    {
      ++v216;
      v215 += v78;
      if ( v78 < v213 )
        v213 = v78;
      if ( v78 > v214 )
        v214 = v78;
    }
    v79 = *(__int16 *)(v75 + 336);
    if ( v79 >= 0 && v79 <= 200 )
    {
      ++v220;
      v219 += v79;
      if ( v79 < v217 )
        v217 = v79;
      if ( v79 > v218 )
        v218 = v79;
    }
    v80 = *(_DWORD *)(v75 + 801);
    v81 = 1000 - v80;
    if ( 1000 - v80 >= 0 && v81 <= 1000 )
    {
      ++v224;
      v223 += v81;
      if ( v81 < v221 )
        v221 = 1000 - v80;
      if ( v81 > v222 )
        v222 = 1000 - v80;
    }
    v82 = 1000 - *(_DWORD *)(v75 + 805);
    if ( v82 >= 0 && v82 <= 1000 )
    {
      ++v208;
      v207 += v82;
      if ( v82 < v74 )
        v74 = v82;
      if ( v82 > v206 )
        v206 = v82;
    }
    v83 = *(_DWORD *)(v75 + 291);
    if ( v83 > 200 )
    {
      v84 = 1000 - 1000 * *(_DWORD *)(v75 + 295) / v83;
      if ( v84 < 0 || v84 > 1000 )
        goto LABEL_214;
    }
    else
    {
      v84 = 0;
    }
    ++v212;
    v211 += v84;
    if ( v84 < v73 )
      v73 = v84;
    if ( v84 > v210 )
      v210 = v84;
LABEL_214:
    v14 = (int)&arena->hProcess + 1 < nPlayerArray2;
    arena = (struct PLAYER *)((char *)arena + 1);
    buf += 4;
  }
  while ( v14 );
  v209 = v73;
  v205 = v74;
  if ( v72 )
  {
    buf = "             Ave    Min    Max";
    SendMessage(ship, "             Ave    Min    Max", 0);
    buf = (char *)(*(_DWORD *)&v203[24] / v72);
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "Cur ping",
      (double)((long double)(*(_DWORD *)&v203[24] / v72) * dbl_10021A80),
      (double)((long double)*(int *)&v203[16] * dbl_10021A80),
      (double)((long double)*(int *)&v203[20] * dbl_10021A80));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( HIDWORD(v225) )
      buf = (char *)(SDWORD2(v225) / SHIDWORD(v225));
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "Ave ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)(int)v225 * dbl_10021A80),
      (double)((long double)SDWORD1(v225) * dbl_10021A80));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( v216 )
      buf = (char *)(v215 / v216);
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "Min ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)v213 * dbl_10021A80),
      (double)((long double)v214 * dbl_10021A80));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( v220 )
      buf = (char *)(v219 / v220);
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "Max ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)v217 * dbl_10021A80),
      (double)((long double)v218 * dbl_10021A80));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( v224 )
      buf = (char *)(v223 / v224);
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "S2C",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v221 * dbl_10021A78),
      (double)((long double)v222 * dbl_10021A78));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( v208 )
      buf = (char *)(v207 / v208);
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "C2S",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v205 * dbl_10021A78),
      (double)((long double)v206 * dbl_10021A78));
    buf = v201;
    SendMessage(ship, v201, 0);
    if ( v212 )
      buf = (char *)(v211 / v212);
    else
      buf = 0;
    sprintf_0(
      v201,
      "%10s: %6.1f %6.1f %6.1f",
      "S2CWeapons",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v209 * dbl_10021A78),
      (double)((long double)v210 * dbl_10021A78));
    buf = v201;
    SendMessage(ship, v201, 0);
  }
LABEL_235:
  if ( !_memicmp_0(msga, "*rstat", 6u) )
  {
    v85 = ((int (__cdecl *)(int))FIX_DLL_KERNEL32_dll_GetTickCount)(v181);
    v86 = v85 - dword_10029300;
    if ( v85 == dword_10029300 )
      v86 = 1;
    sprintf_0(src, "Timer: %d", v86);
    buf = src;
    SendMessage(ship, src, 0);
    sprintf_0(
      src,
      "Counts:  %5d %5d %5d %5d",
      1000 * dword_101B3040 / v86,
      1000 * dword_101B3044 / v86,
      1000 * dword_101B3048 / v86,
      1000 * dword_101B304C / v86);
    buf = src;
    SendMessage(ship, src, 0);
    sprintf_0(
      src,
      "Trigger: %5d %5d %5d %5d",
      1000 * dword_100292F0[0] / v86,
      1000 * dword_100292F4 / v86,
      1000 * dword_100292F8 / v86,
      1000 * dword_100292FC / v86);
    buf = src;
    SendMessage(ship, src, 0);
  }
  if ( !_memicmp_0(msga, "*tmode ", 7u) && player )
  {
    LOWORD(buf) = 5120;
    BYTE2(buf) = 'A';
    HIBYTE(buf) = atol_1(msga + 7, (signed int *)(msga + 7));
    arena = (struct PLAYER *)&buf;
    PlayerSendPacket((PLAYER *)player, &buf, 4, 1);
  }
  if ( !_memicmp_0(msga, "*sendto ", 8u) )
  {
    if ( player )
    {
      v87 = strchr_0(msga, ',');
      if ( *v87 )
      {
        *v87 = 0;
        v88 = (signed int *)(v87 + 1);
        v89 = inet_addr_0(msga + 8);
        v91 = atol_1(v90, v88);
        buf = strchr_0((const char *)v88, ',');
        if ( v89 != -1 )
        {
          if ( v91 )
          {
            memset(v203, 0, 0x1Cu);
            v203[28] = 0;
            v203[0] = 59;
            *(_DWORD *)&v203[1] = ntohl_0(v89);
            *(_WORD *)&v203[5] = v91;
            if ( buf )
            {
              *(_WORD *)&v203[7] = -3;
              strncpyt(&v203[9], buf + 1, 16);
            }
            else
            {
              *(_WORD *)&v203[7] = -1;
            }
            buf = v203;
            PlayerSendPacket((PLAYER *)player, v203, 29, 1);
          }
        }
      }
    }
  }
LABEL_251:
  if ( !_memicmp_0(msga, "*locate ", 8u) && *sub_10003260(msga + 8) )
  {
    v92 = sub_10003260(msga + 8);
    find_player_request(ship, v92);
    goto LABEL_291;
  }
  if ( !_memicmp_0(msga, "*listban", 8u) )
  {
    v93 = ((int (__cdecl *)(int))FIX_DLL_KERNEL32_dll_GetTickCount)(v182) / 0xAu;
    v94 = 0;
    if ( dword_4399C4 > 0 )
    {
      v95 = dword_4AD73C;
      do
      {
        sprintf_0(src, (const char *)&loc_10025018, *(v95 - 1), (int)(v93 - *v95) / 100, v95[1] / 100);
        SendMessage(ship, src, 0);
        ++v94;
        v95 += 3;
      }
      while ( v94 < dword_4399C4 );
    }
    return 0;
  }
  if ( _memicmp_0(msga, (char *)&loc_1002500A + 2, 0xBu) )
  {
    if ( !_memicmp_0(msga, "*relkills", 9u) )
    {
      v100 = (signed int *)sub_10003260(msga + 9);
      v102 = atol_1(v101, v100);
      *(_DWORD *)&ship->field_341[185] = v102;
      buf = "Reliable kill messages ON";
      if ( !v102 )
        buf = "Reliable kill messages OFF";
      SendMessage(ship, buf, 0);
LABEL_291:
      v105 = player;
LABEL_292:
      if ( ship->bIsSmod )
      {
        if ( !_memicmp_0(msga, "*listmod", 8u) )
        {
          buf = 0;
          if ( nPlayerArray2 > 0 )
          {
            v117 = PlayerArray2;
            do
            {
              v118 = *v117;
              if ( *v117 && *(_DWORD *)(v118 + 28) && *(_DWORD *)(v118 + 639) )
              {
                v119 = "Mod";
                if ( *(_DWORD *)(v118 + 635) )
                  v119 = "SMod";
                if ( *(_DWORD *)(v118 + 631) )
                  v119 = "Sysop";
                v120 = sub_1000C1B0(v118, 1);
                sprintf_0(src, "%s - %s - %s", (const char *)(v118 + 375), v119, v120);
                arena = (struct PLAYER *)src;
                SendMessage(ship, src, 0);
                v105 = player;
              }
              ++v117;
              ++buf;
            }
            while ( (int)buf < nPlayerArray2 );
          }
        }
        v121 = msga;
        if ( !_memicmp_0(msga, "*zone", 5u) )
        {
          v122 = sub_10003260(msga + 5);
          sub_1000B400((int)dword_1003E438, 2, v122, 0);
        }
      }
      else
      {
        v121 = msga;
      }
      if ( !_memicmp_0(v121, "*specall", 8u) )
      {
        v123 = ship->lpCurrentArena;
        if ( v123 )
        {
          v124 = *(_DWORD *)(v123 + 65292);
          buf = 0;
          if ( v124 > 0 )
          {
            v125 = 64288;
            do
            {
              arena = *(struct PLAYER **)(v123 + v125);
              v126 = arena;
              if ( arena && arena->dwShip != 8 && (ship->bIsSysop || !arena->bIsSmod) )
              {
                v127 = FIX_DLL_KERNEL32_dll_GetTickCount(v184, v185, v186);
                *(_DWORD *)&v126->field_341[52] = v127;
                *(_DWORD *)&v126->field_341[197] = v127 + 5000;
                SetPlayerShip(arena, 8);
              }
              v123 = ship->lpCurrentArena;
              v128 = *(_DWORD *)(v123 + 65292);
              v125 += 4;
              ++buf;
            }
            while ( (int)buf < v128 );
          }
        }
      }
      v129 = msga;
      v130 = _memicmp_0(msga, "*flags", 6u);
      v131 = ship;
      if ( !v130 )
      {
        v132 = ship->lpCurrentArena;
        if ( v132 )
        {
          strcpy(src, "UNCARRIED FLAGS:");
          v133 = *(_DWORD *)(v132 + 108190);
          buf = 0;
          if ( v133 > 0 )
          {
            v134 = 0;
            do
            {
              if ( *(int *)(v132 + v134 + 100006) < 0 )
              {
                v135 = *(_DWORD *)(v132 + v134 + 99998);
                if ( v135 < 0x400 )
                {
                  v136 = *(_DWORD *)(v132 + v134 + 100002);
                  if ( v136 < 0x400 && strlen(src) < 0xFA )
                  {
                    v183 = (int)(20 * v136) / 1024 + 1;
                    v137 = strchr_0(src, 0);
                    sprintf_0(v137, " %c%d", (int)(20 * v135) / 1024 + 65, v183);
                  }
                }
              }
              v132 = ship->lpCurrentArena;
              v138 = *(_DWORD *)(v132 + 108190);
              v134 += 16;
              ++buf;
            }
            while ( (int)buf < v138 );
          }
          buf = src;
          SendMessage(ship, src, 0);
          v129 = msga;
          v131 = ship;
          v105 = player;
        }
      }
      if ( v105 && *((_DWORD *)v105 + 7) )
      {
        if ( v131->bIsSysop || v131->bIsSmod && !*(_DWORD *)(v105 + 631) || (msg_3 = 0, !*(_DWORD *)(v105 + 635)) )
          msg_3 = 1;
        if ( _memicmp_0(v129, "*setship ", 9u) )
        {
          if ( _memicmp_0(v129, "*setfreq ", 9u) )
          {
            if ( v131->bIsSysop )
            {
              if ( !_memicmp_0(v129, "*ufo", 4u) )
              {
                v152 = *((_DWORD *)v105 + 15);
                BYTE2(ship) = 37;
                HIBYTE(ship) = v152 == 0;
                *((_DWORD *)v105 + 15) = v152 == 0;
                PlayerSendPacket((PLAYER *)player, (char *)&ship + 2, 2, 1);
                return 0;
              }
              if ( v131->bIsSysop && !_memicmp_0(v129, "*super", 6u) )
              {
                memcpy_0(v187, (const void *)(v131->lpCurrentArena + 108194), sizeof(v187));
                sub_1000DAB0((int)v187);
                ship = (PLAYER *)v187;
                PlayerSendPacket((PLAYER *)player, v187, 1428, 1);
                return 0;
              }
            }
            if ( _memicmp_0(v129, "*watchgreen", 0xBu) )
            {
              v157 = _memicmp_0(v129, "*watchdamage", 0xCu);
              if ( v157 )
              {
                if ( !_memicmp_0(v129, "*lag", 4u) )
                {
                  v161 = *(_DWORD *)(v105 + 291);
                  if ( v161 > 200 )
                    v162 = 1000 - 1000 * *(_DWORD *)(player + 295) / v161;
                  else
                    v162 = 0;
                  sprintf_0(
                    src,
                    "PING Current:%d ms  Average:%d ms  Low:%d ms  High:%d ms  S2C: %d.%d%%  C2S: %d.%d%%  S2CWeapons: %d.%d%%",
                    10 * *((__int16 *)player + 165),
                    10 * *((__int16 *)player + 166),
                    10 * *((__int16 *)player + 167),
                    10 * *((__int16 *)player + 168),
                    (1000 - *(_DWORD *)(player + 801)) / 10,
                    (1000 - *(_DWORD *)(player + 801)) % 10,
                    (1000 - *(_DWORD *)(player + 805)) / 10,
                    (1000 - *(_DWORD *)(player + 805)) % 10,
                    v162 / 10,
                    v162 % 10);
                  SendMessage(ship, src, 0);
                  return 0;
                }
                if ( !_memicmp_0(v129, "*greeninfo", 0xAu) )
                {
                  src[0] = 0;
                  v163 = 1;
                  msgg = player + 897;
                  do
                  {
                    v164 = *((_DWORD *)player + 7);
                    if ( *(_BYTE *)(v163 + v164 + 109593) )
                    {
                      sprintf_0(
                        v202,
                        "%d:%d(%d) ",
                        v163,
                        *(_DWORD *)msgg,
                        *(_DWORD *)msgg
                      - (unsigned int)*(unsigned __int8 *)(v163 + v164 + 109593)
                      * *(_DWORD *)(player + 1009)
                      / *(_DWORD *)(v164 + 111602));
                      strcat(src, v202);
                      if ( !(v163 % 7) )
                      {
                        buf = src;
                        SendMessage(ship, src, 0);
                        src[0] = 0;
                      }
                    }
                    ++v163;
                    msgg += 4;
                  }
                  while ( v163 < 29 );
                  return 1;
                }
                if ( !_memicmp_0(v129, "*warn ", 6u) )
                {
                  sprintf_0(src, "MODERATOR WARNING: %.150s -%s", v129 + 6, v131->player_name);
                  v196 = 7;
                  v197 = 8;
                  v198 = 1;
                  v199 = -1;
                  strncpyt(dst, src, 250);
                  buf = (char *)(strlen(dst) + 6);
                  PlayerSendPacket((PLAYER *)player, &v196, (int)buf, 1);
                  SendMessage(ship, "Player warned", 0);
                  return 1;
                }
                if ( _memicmp_0(v129, "*warpto ", 8u) )
                {
                  if ( !_memicmp_0(v129, "*tinfo", 6u) )
                  {
                    SendMessage(ship, " ServerTime    UserTime        Diff", 0);
                    v172 = *(_DWORD *)(v105 + 1035);
                    v173 = 32;
                    do
                    {
                      v172 &= 0x1Fu;
                      v174 = *(_DWORD *)&v105[4 * v172 + 1167];
                      if ( v174 || *(_DWORD *)&v105[4 * v172 + 1039] )
                      {
                        sprintf_0(
                          src,
                          "%11d %11d %11d",
                          v174,
                          *(_DWORD *)&v105[4 * v172 + 1039],
                          v174 - *(_DWORD *)&v105[4 * v172 + 1039]);
                        SendMessage(ship, src, 0);
                      }
                      LOBYTE(v172) = v172 + 1;
                      --v173;
                    }
                    while ( v173 );
                  }
                }
                else
                {
                  v165 = (signed int *)sub_10003260((void *)(v129 + 8));
                  v167 = atol_1(v166, v165);
                  v168 = sub_10003240(v165);
                  v169 = (signed int *)sub_10003260(v168);
                  v171 = atol_1(v170, v169);
                  if ( v167 > 0 && v171 > 0 )
                  {
                    buf_sz[0] = 50;
                    *(_WORD *)&buf_sz[1] = v167 & 0x3FF;
                    *(_WORD *)&buf_sz[3] = v171 & 0x3FF;
                    ship = (PLAYER *)buf_sz;
                    PlayerSendPacket((PLAYER *)player, buf_sz, 5, 1);
                    return 1;
                  }
                }
              }
              else
              {
                v158 = *(_DWORD *)&v131->field_14;
                v159 = (int *)(v105 + 1295);
                while ( *v159 >= 0 )
                {
                  if ( *v159 == v158 )
                  {
                    memcpy_0(&v105[4 * v157 + 1295], &v105[4 * v157 + 1299], 20 - 4 * v157);
                    *(_DWORD *)(v105 + 1315) = -1;
LABEL_392:
                    v160 = 0;
                    msgf = "Damage logging OFF";
                    goto LABEL_393;
                  }
                  ++v157;
                  ++v159;
                  if ( v157 >= 6 )
                    goto LABEL_392;
                }
                *(_DWORD *)&v105[4 * v157 + 1295] = v158;
                v160 = 1;
                msgf = "Damage logging ON";
LABEL_393:
                SendMessage(ship, msgf, 0);
                if ( v160 )
                {
                  HIWORD(ship) = 311;
                  PlayerSendPacket((PLAYER *)player, (char *)&ship + 2, 2, 1);
                  return 1;
                }
              }
            }
            else
            {
              v153 = 0;
              v154 = &PlayerArray;
              while ( *v154 != v131 )
              {
                ++v154;
                ++v153;
                if ( (int)v154 >= (int)&unk_4D6858 )
                  return 1;
              }
              if ( v153 < 1000 )
              {
                v155 = 0;
                v156 = (int *)(v105 + 861);
                while ( *v156 >= 0 )
                {
                  if ( *v156 == v153 )
                  {
                    memcpy_0(&v105[4 * v155 + 861], &v105[4 * v155 + 865], 20 - 4 * v155);
                    *(_DWORD *)(v105 + 881) = -1;
LABEL_383:
                    msge = "Green logging OFF";
                    goto LABEL_384;
                  }
                  ++v155;
                  ++v156;
                  if ( v155 >= 6 )
                    goto LABEL_383;
                }
                *(_DWORD *)&v105[4 * v155 + 861] = v153;
                msge = "Green logging ON";
LABEL_384:
                SendMessage(ship, msge, 0);
                return 1;
              }
            }
          }
          else
          {
            v148 = (signed int *)sub_10003260((void *)(v129 + 9));
            v150 = atol_1(v149, v148);
            ship = (PLAYER *)v150;
            if ( v150 >= 0 && v150 <= 9999 )
            {
              if ( msg_3 )
              {
                if ( *(_DWORD *)(v105 + 275) == 8 )
                {
                  *(_DWORD *)(v105 + 885) = ((int (__cdecl *)(int, int))FIX_DLL_KERNEL32_dll_GetTickCount)(v185, v186);
                  PlayerChangeFrequency((struct PLAYER *)player, (signed int)ship);
                }
                else
                {
                  *(_DWORD *)(v105 + 279) = v150;
                  ship = *(PLAYER **)(v105 + 275);
                  v151 = ((int (__cdecl *)(int, int))FIX_DLL_KERNEL32_dll_GetTickCount)(v185, v186);
                  *(_DWORD *)(v105 + 885) = v151;
                  *(_DWORD *)(v105 + 1030) = v151 + 5000;
                  SetPlayerShip((struct PLAYER *)player, (signed int)ship);
                }
                result = 1;
              }
              else
              {
                sprintf_0(src, "%s attempted to change your freq to %d", v131->player_name, v150);
                ship = (PLAYER *)src;
                SendMessage((struct PLAYER *)player, src, 0);
                result = 1;
              }
              return result;
            }
          }
        }
        else
        {
          v139 = (signed int *)sub_10003260((void *)(v129 + 9));
          v141 = atol_1(v140, v139);
          v142 = *((_DWORD *)v105 + 7);
          if ( !v142
            || (v143 = *(_DWORD *)(v142 + 121111), v143 > 0)
            && (v144 = *(_DWORD *)(v142 + 121115), v144 > 0)
            && (*(_DWORD *)(v105 + 619) > v143 || *(_DWORD *)(v105 + 623) > v144)
            || (*(_BYTE *)(v142 + 121247) || byte_101A5389) && *((_DWORD *)v105 + 6) != 1 && !*(_DWORD *)(v105 + 1026)
            || (v145 = *(_DWORD *)(v142 + 121256)) != 0 && *(_DWORD *)(v105 + 519) < v145 && FindMeOut1 )
          {
            if ( !v131->bIsSysop )
            {
              v146 = ((int (__cdecl *)(int, int))FIX_DLL_KERNEL32_dll_GetTickCount)(v185, v186);
              *(_DWORD *)(v105 + 885) = v146;
              *(_DWORD *)(v105 + 1030) = v146 + 5000;
              SetPlayerShip((struct PLAYER *)player, 8);
              return 1;
            }
          }
          if ( v141 >= 1 && v141 <= 8 && *(_DWORD *)(v105 + 275) != v141 - 1 )
          {
            if ( msg_3 )
            {
              ship = (PLAYER *)(v141 - 1);
              v147 = ((int (__cdecl *)(int, int))FIX_DLL_KERNEL32_dll_GetTickCount)(v185, v186);
              *(_DWORD *)(v105 + 885) = v147;
              *(_DWORD *)(v105 + 1030) = v147 + 5000;
              SetPlayerShip((struct PLAYER *)player, (signed int)ship);
            }
            else
            {
              sprintf_0(src, "%s attempted to change your ship to %d", v131->player_name, v141);
              ship = (PLAYER *)src;
              SendMessage((struct PLAYER *)player, src, 0);
            }
            return 1;
          }
        }
      }
      return 1;
    }
    if ( _memicmp_0(msga, "*objon ", 7u) )
    {
      if ( _memicmp_0(msga, "*objoff ", 8u) )
      {
        if ( !_memicmp_0(msga, "*objset ", 8u) )
        {
          v190 = 53;
          v110 = 0;
          v111 = (signed int *)sub_10003260(msga + 8);
          v112 = *(_BYTE *)v111;
          if ( *(_BYTE *)v111 )
          {
            v113 = &v191;
            do
            {
              if ( v110 >= 0x80 )
                break;
              v114 = (void *)(*(_WORD *)v113 & 0x7FFF | ((v112 == 45) << 15));
              *(_WORD *)v113 = (_WORD)v114;
              if ( *(_BYTE *)v111 == 45 || *(_BYTE *)v111 == 43 )
                v111 = (signed int *)((char *)v111 + 1);
              *(_WORD *)v113 ^= (*(_WORD *)v113 ^ atol_1(v114, v111)) & 0x7FFF;
              v115 = strchr_0((const char *)v111, 44);
              if ( !v115 )
                break;
              v111 = (signed int *)sub_10003260(v115 + 1);
              v112 = *(_BYTE *)v111;
              ++v110;
              v113 += 2;
            }
            while ( *(_BYTE *)v111 );
            if ( v110 )
            {
              if ( player )
              {
                arena = (struct PLAYER *)(2 * v110 + 1);
                buf = &v190;
                PlayerSendPacket((PLAYER *)player, &v190, (int)arena, 1);
              }
              else
              {
                *(_DWORD *)buf_sz = 2 * v110 + 1;
                v116 = (struct ARENA *)ship->lpCurrentArena;
                HIBYTE(buf) = 1;
                v226 = &v190;
                arena = (struct PLAYER *)v116;
                ArenaSendPacket(v116, &v190, *(int *)buf_sz, 1);
              }
            }
          }
        }
        goto LABEL_291;
      }
      buf_sz[2] |= 0x80u;
      buf_sz[0] = 53;
      v108 = atol_1(v107, (signed int *)msga + 2);
      v105 = player;
      *(_WORD *)&buf_sz[1] ^= (*(_WORD *)&buf_sz[1] ^ v108) & 0x7FFF;
      if ( !player )
      {
        v109 = (struct ARENA *)ship->lpCurrentArena;
        HIBYTE(buf) = 1;
        v226 = buf_sz;
        arena = (struct PLAYER *)v109;
        ArenaSendPacket(v109, buf_sz, 3, 1);
        goto LABEL_292;
      }
    }
    else
    {
      *(_WORD *)&buf_sz[1] &= 0x7FFFu;
      buf_sz[0] = 53;
      v104 = atol_1(v103, (signed int *)(msga + 7));
      v105 = player;
      *(_WORD *)&buf_sz[1] ^= (*(_WORD *)&buf_sz[1] ^ v104) & 0x7FFF;
      if ( !player )
      {
        v106 = (struct ARENA *)ship->lpCurrentArena;
        HIBYTE(buf) = 1;
        v226 = buf_sz;
        arena = (struct PLAYER *)v106;
        ArenaSendPacket(v106, buf_sz, 3, 1);
        goto LABEL_292;
      }
    }
    buf = buf_sz;
    PlayerSendPacket((PLAYER *)player, buf_sz, 3, 1);
    goto LABEL_292;
  }
  v97 = atol_1(v96, (signed int *)(msga + 11));
  v98 = 0;
  if ( dword_4399C4 > 0 )
  {
    for ( i = dword_4AD738; *i != v97; i += 3 )
    {
      if ( ++v98 >= dword_4399C4 )
        return 0;
    }
    memcpy_0(
      (void *)(4 * (3 * v98 + 1226190)),
      (const void *)(4 * (3 * v98 + 1226193)),
      12 * dword_4399C4 - 4 * (3 * v98 + 3));
    --dword_4399C4;
    SendMessage(ship, aBanRem, 0);
  }
  return 0;
}
// 100103C1: positive sp value 1C has been found
// 1000FBDE: conditional instruction was optimized away because of 'ecx.4!=0'
// 1000FF74: conditional instruction was optimized away because of 'eax.4<6u'
// 1001003D: conditional instruction was optimized away because of 'eax.4<6u'
// 1000EA60: variable 'v179' is possibly undefined
// 1000EA60: variable 'v180' is possibly undefined
// 1000EAC9: variable 'v178' is possibly undefined
// 1000EB17: variable 'v62' is possibly undefined
// 1000EBBE: variable 'v70' is possibly undefined
// 1000F1FB: variable 'v181' is possibly undefined
// 1000F3D7: variable 'v90' is possibly undefined
// 1000F4B8: variable 'v182' is possibly undefined
// 1000F56D: variable 'v96' is possibly undefined
// 1000F623: variable 'v101' is possibly undefined
// 1000F67C: variable 'v103' is possibly undefined
// 1000F701: variable 'v107' is possibly undefined
// 1000F9D7: variable 'v184' is possibly undefined
// 1000F9D7: variable 'v185' is possibly undefined
// 1000F9D7: variable 'v186' is possibly undefined
// 1000FBA9: variable 'v140' is possibly undefined
// 1000FD1D: variable 'v149' is possibly undefined
// 10010357: variable 'v166' is possibly undefined
// 10010370: variable 'v170' is possibly undefined
// 4399C4: using guessed type int dword_4399C4;
// 4AD738: using guessed type int dword_4AD738[];
// 4AD73C: using guessed type int dword_4AD73C[];
// 4CA230: using guessed type int PlayerArray2[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 1000DBE0: using guessed type _DWORD sub_1000DBE0();
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10021A78: using guessed type double dbl_10021A78;
// 10021A80: using guessed type double dbl_10021A80;
// 100251F4: using guessed type void *off_100251F4;
// 100292F0: using guessed type int dword_100292F0[];
// 100292F4: using guessed type int dword_100292F4;
// 100292F8: using guessed type int dword_100292F8;
// 100292FC: using guessed type int dword_100292FC;
// 10029300: using guessed type int dword_10029300;
// 101A51A8: using guessed type int dword_101A51A8;
// 101A52E8: using guessed type int dword_101A52E8;
// 101A52F0: using guessed type int dword_101A52F0;
// 101A5381: using guessed type char byte_101A5381;
// 101A5382: using guessed type char byte_101A5382;
// 101A5389: using guessed type char byte_101A5389;
// 101A538C: using guessed type int dword_101A538C;
// 101A5394: using guessed type int dword_101A5394;
// 101B083C: using guessed type char byte_101B083C;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;
// 101B304C: using guessed type int dword_101B304C;

//----- (10010460) --------------------------------------------------------
int __thiscall sub_10010460(int this, int a2, int a3)
{
  int result; // eax

  result = a2;
  if ( a2 >= 0 && a2 <= a3 )
  {
    ++*(_DWORD *)(this + 12);
    *(_DWORD *)(this + 8) += a2;
    if ( a2 < *(_DWORD *)this )
      *(_DWORD *)this = a2;
    if ( a2 > *(_DWORD *)(this + 4) )
      *(_DWORD *)(this + 4) = a2;
  }
  return result;
}

//----- (10010490) --------------------------------------------------------
void __thiscall sub_10010490(int this, int a2, double a3, int msg)
{
  int v4; // esi
  char v5[128]; // [esp+1Ch] [ebp-84h] BYREF
  int v6; // [esp+9Ch] [ebp-4h]

  v4 = *(_DWORD *)(this + 12);
  if ( v4 )
    v6 = *(_DWORD *)(this + 8) / v4;
  else
    v6 = 0;
  sprintf_0(
    v5,
    "%10s: %6.1f %6.1f %6.1f",
    (const char *)msg,
    (double)((long double)v6 * a3),
    (double)((long double)*(int *)this * a3),
    (double)((long double)*(int *)(this + 4) * a3));
  SendMessage((struct PLAYER *)a2, v5, 0);
}

//----- (10010510) --------------------------------------------------------
int __thiscall sub_10010510(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)this = 0x7FFFFFFF;
  *(_DWORD *)(this + 4) = -1;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}

//----- (10010530) --------------------------------------------------------
void __userpurge sub_10010530(int a1@<ecx>, int a2@<ebx>, int a3)
{
  unsigned int v4; // ecx
  _BOOL1 v5; // zf
  const char *v6; // ecx
  const char *v7; // edi
  const char *v8; // edx
  const char *v9; // ecx
  unsigned int v10; // edx
  int v11; // edx
  _BOOL1 v12; // sf
  int v13; // eax
  int v14; // [esp+0h] [ebp-144h]
  char v15[256]; // [esp+4h] [ebp-140h] BYREF
  char v16[64]; // [esp+104h] [ebp-40h] BYREF

  if ( *(int *)(a1 + 275) < 8
    && ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - *(_DWORD *)(a1 + 885) >= 5000 )
  {
    v4 = a3 & 0x1F;
    v5 = v4 == 2;
    if ( v4 > 2 )
    {
      if ( v4 > 4 )
      {
        if ( v4 > 8 )
          sprintf_0(v16, "Unknown weapon %d", a3);
        else
          sprintf_0(v16, (const char *)dword_1002465C[v4]);
      }
      else
      {
        v7 = "bouncing ";
        if ( (a3 & 0x80u) == 0 )
          v7 = byte_10028A9C;
        v8 = "mine";
        if ( (a3 & 0x8000) == 0 )
          v8 = "bomb";
        v5 = v4 == 4;
        v9 = "Prox ";
        if ( !v5 )
          v9 = byte_10028A9C;
        sprintf_0(
          v16,
          "%sL%d %s with %d %sL%d shrap",
          v9,
          (((unsigned int)a3 >> 5) & 3) + 1,
          v8,
          ((unsigned int)a3 >> 10) & 0x1F,
          v7,
          (((unsigned int)a3 >> 8) & 3) + 1);
      }
    }
    else
    {
      v6 = "Bouncing ";
      if ( !v5 )
        v6 = byte_10028A9C;
      sprintf_0(v16, "%sL%d bullet", v6, (((unsigned int)a3 >> 5) & 3) + 1);
    }
    sprintf_0(v15, "Illegal %s weapon: %s", off_10024650[*(_DWORD *)(a1 + 275)], v16);
    sub_100151C0((int)v15, a1);
    v10 = FIX_DLL_KERNEL32_dll_GetTickCount(a2, v14, *(_DWORD *)v15) / 0xAu;
    if ( v10 - *(_DWORD *)(a1 + 655) >= 0x96 )
    {
      *(_DWORD *)(a1 + 655) = v10;
      *(_DWORD *)(a1 + 659) = 0;
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 659) + 1;
      v12 = *(_DWORD *)(a1 + 659) - 6 < 0;
      *(_DWORD *)(a1 + 659) = v11;
      if ( !(v12 ^ __OFSUB__(v11, 7) | (v11 == 7)) )
      {
        *(_DWORD *)(a1 + 789) = 33;
        *(_DWORD *)(a1 + 56) = 1;
      }
    }
    v13 = *(_DWORD *)(a1 + 28);
    if ( !v13 || *(_DWORD *)(v13 + 109802) )
    {
      *(_DWORD *)(a1 + 56) = 1;
      *(_DWORD *)(a1 + 789) = 30;
    }
  }
}
// 10010530: could not find valid save-restore pair for ebx
// 1001065D: variable 'v14' is possibly undefined
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10024650: using guessed type char *off_10024650[12];
// 1002465C: using guessed type int dword_1002465C[];

//----- (100106E0) --------------------------------------------------------
void __thiscall sub_100106E0(int this, char a2)
{
  int (*v3)(void); // edi
  const char *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  _BOOL1 v7; // sf
  int v8; // eax
  char v9[256]; // [esp+8h] [ebp-100h] BYREF

  if ( *(int *)(this + 275) < 8 )
  {
    v3 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetTickCount;
    if ( ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)() - *(_DWORD *)(this + 885) >= 5000 )
    {
      v4 = byte_10028A9C;
      if ( (a2 & 0x40) != 0 )
      {
        v4 = "Ufo";
      }
      else if ( (a2 & 8) != 0 )
      {
        v4 = "AntiWarp";
      }
      else if ( (a2 & 4) != 0 )
      {
        v4 = "XRadar";
      }
      else if ( (a2 & 2) != 0 )
      {
        v4 = "Cloak";
      }
      else if ( (a2 & 1) != 0 )
      {
        v4 = "Stealth";
      }
      sprintf_0(v9, "Illegal %s equipment: %s", off_10024650[*(_DWORD *)(this + 275)], v4);
      sub_100151C0((int)v9, this);
      v5 = v3() / 0xAu;
      if ( v5 - *(_DWORD *)(this + 655) >= 0x96 )
      {
        *(_DWORD *)(this + 655) = v5;
        *(_DWORD *)(this + 659) = 0;
      }
      else
      {
        v6 = *(_DWORD *)(this + 659) + 1;
        v7 = *(_DWORD *)(this + 659) - 6 < 0;
        *(_DWORD *)(this + 659) = v6;
        if ( !(v7 ^ __OFSUB__(v6, 7) | (v6 == 7)) )
        {
          *(_DWORD *)(this + 789) = 33;
          *(_DWORD *)(this + 56) = 1;
        }
      }
      v8 = *(_DWORD *)(this + 28);
      if ( !v8 || *(_DWORD *)(v8 + 109802) )
      {
        *(_DWORD *)(this + 56) = 1;
        *(_DWORD *)(this + 789) = 31;
      }
    }
  }
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10024650: using guessed type char *off_10024650[12];

//----- (10010810) --------------------------------------------------------
int __thiscall sub_10010810(int this, int a2)
{
  int result; // eax

  result = *(_DWORD *)(this + 28);
  if ( !result || *(_DWORD *)(result + 109802) )
  {
    result = a2;
    *(_DWORD *)(this + 56) = 1;
    *(_DWORD *)(this + 789) = a2;
  }
  return result;
}

//----- (10010840) --------------------------------------------------------
_BOOL1 __fastcall sub_10010840(int a1)
{
  char v1; // al
  int v2; // edx

  v1 = 0;
  v2 = 22;
  do
  {
    v1 ^= *(_BYTE *)a1++;
    --v2;
  }
  while ( v2 );
  return v1 == 0;
}

//----- (10010860) --------------------------------------------------------
_BOOL1 __thiscall sub_10010860(int this)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax

  v1 = *(_DWORD *)(this + 28);
  if ( !v1 )
    return 1;
  v2 = *(_DWORD *)(v1 + 121111);
  if ( v2 <= 0 )
    return 1;
  v3 = *(_DWORD *)(v1 + 121115);
  if ( v3 <= 0 )
    return 1;
  return *(_DWORD *)(this + 619) <= v2 && *(_DWORD *)(this + 623) <= v3;
}

//----- (100108A0) --------------------------------------------------------
void __thiscall sub_100108A0(int this)
{
  int v1; // eax
  int v2; // edx
  char v3[256]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v4; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v1 = *(_DWORD *)(this + 28);
  v2 = *(_DWORD *)(v1 + 121111);
  v4 = (struct PLAYER *)this;
  sprintf_0(v3, "Maximum allowed screen resolution is %dx%d in this arena", v2, *(_DWORD *)(v1 + 121115));
  msg = v3;
  SendMessage(v4, v3, 0);
}

//----- (100108F0) --------------------------------------------------------
bool __thiscall sub_100108F0(int this)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  int v4; // eax
  bool result; // eax

  v1 = *(_DWORD *)(this + 28);
  result = 0;
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 121111);
    if ( v2 <= 0
      || (v3 = *(_DWORD *)(v1 + 121115), v3 <= 0)
      || *(_DWORD *)(this + 619) <= v2 && *(_DWORD *)(this + 623) <= v3 )
    {
      if ( !*(_BYTE *)(v1 + 121247) && !byte_101A5389 || *(_DWORD *)(this + 24) == 1 || *(_DWORD *)(this + 1026) )
      {
        v4 = *(_DWORD *)(v1 + 121256);
        if ( !v4 || *(_DWORD *)(this + 519) >= v4 || !FindMeOut1 )
          result = 1;
      }
    }
  }
  return result;
}
// 1001091E: conditional instruction was optimized away because of 'eax.4!=0'
// 101A5389: using guessed type char byte_101A5389;

//----- (10010970) --------------------------------------------------------
void __thiscall sub_10010970(void *this)
{
  char v1[256]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v2; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v2 = (struct PLAYER *)this;
  sprintf_0(v1, "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
  msg = v1;
  SendMessage(v2, v1, 0);
}

//----- (100109B0) --------------------------------------------------------
void __thiscall sub_100109B0(int this)
{
  int v1; // eax
  char v2[256]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v3; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v1 = *(_DWORD *)(this + 28);
  v3 = (struct PLAYER *)this;
  sprintf_0(
    v2,
    "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
    *(_DWORD *)(v1 + 121256) / 3600);
  msg = v2;
  SendMessage(v3, v2, 0);
}

//----- (10010A10) --------------------------------------------------------
char __thiscall sub_10010A10(int this)
{
  const char *v2; // edi
  _BOOL1 v3; // zf
  _BOOL1 v4; // dl
  char *v5; // eax

  v2 = (const char *)(this + 2);
  v3 = isalnum(*(unsigned __int8 *)(this + 2)) == 0;
  *(_BYTE *)(this + 33) = 0;
  v4 = !v3;
  if ( *v2 )
  {
    v5 = (char *)v2;
    do
    {
      if ( (unsigned __int8)*v5 < 0x20u || (unsigned __int8)*v5 > 0x7Eu )
      {
        *v5 = 95;
        v4 = 0;
      }
    }
    while ( *++v5 );
  }
  if ( v4 )
    return 1;
  off_10024608("Ext: Player with invalid name tying to enter: %s\n", v2);
  return 0;
}

//----- (10010A70) --------------------------------------------------------
const char *__thiscall sub_10010A70(int this)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // ecx

  v1 = *(_DWORD *)(this + 100);
  if ( v1 < 37 )
    return "Undetermined";
  if ( v1 > 100 )
    return "Undetermined";
  v2 = *(_DWORD *)(this + 40);
  if ( !v2 )
    return "Undetermined";
  v3 = *(_DWORD *)(this + 1319);
  if ( !v3 )
    return "SOCKS5 proxy";
  v4 = *(_DWORD *)(this + 1323);
  if ( !v4 )
    return "SOCKS5 proxy";
  if ( (v3 & 0xFF000000) == 2130706432 || v3 == *(_DWORD *)v2 )
    return "Using proxy at localhost";
  if ( !dword_101A5348 )
    return "ServerIP is not set in server.ini";
  if ( v3 != dword_101A5348 )
    return "Using custom proxy";
  if ( v4 == *(unsigned __int16 *)(v2 + 4) )
    return "Not using proxy";
  return "Using NAT";
}
// 101A5348: using guessed type int dword_101A5348;

//----- (10010B00) --------------------------------------------------------
// first chance packet handler, eventually calls out to subgames packet handler for game packets (408e90)
void __thiscall fix_04(int this, BYTE *buf, DWORD pkt_sz)
{
  BYTE *v3; // edi
  unsigned int v4; // esi
  unsigned int v6; // ecx
  unsigned int v7; // eax
  int v8; // edx
  int *v9; // eax
  int v10; // eax
  unsigned int v11; // edx
  int v12; // ecx
  BYTE v13; // al
  int v14; // esi
  int v15; // edi
  BYTE *v16; // ecx
  char v17; // al
  int v18; // edx
  char *v19; // edi
  BYTE *v20; // ecx
  char v21; // al
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // edx
  int v25; // eax
  _BOOL1 v26; // sf
  BYTE *v27; // esi
  int v28; // edi
  char v29; // al
  BYTE *v30; // ecx
  int v31; // edx
  BYTE v32; // al
  int v33; // ecx
  int v34; // edx
  int v35; // eax
  int v36; // esi
  int v37; // eax
  unsigned int v38; // edx
  int v39; // eax
  int v40; // ebx
  int v41; // eax
  int v42; // esi
  BYTE v43; // cl
  int v44; // eax
  __int16 v45; // di
  int v46; // esi
  int v47; // eax
  const char *v48; // eax
  int v49; // eax
  int *v50; // edi
  const char *v51; // eax
  int v52; // edx
  int v53; // eax
  long double v54; // fst7
  unsigned int v55; // esi
  unsigned __int8 *v56; // edi
  int *v57; // ebx
  long double v58; // fst7
  long double v59; // fst6
  int v60; // eax
  int v61; // edx
  int v62; // ecx
  int v63; // ecx
  __int16 v64; // ax
  _BOOL1 v65; // zf
  _BOOL1 v66; // al
  char *v67; // esi
  signed __int8 v68; // al
  unsigned int v69; // ecx
  char v70; // dl
  char *v71; // edi
  const char *v72; // esi
  int v73; // ecx
  int v74; // eax
  int v75; // eax
  int v76; // ebx
  int v77; // edx
  char *v78; // esi
  _BOOL1 v79; // dl
  _BYTE *v80; // eax
  unsigned int v82; // ebx
  unsigned int v83; // eax
  int v84; // ecx
  int *v85; // eax
  int v86; // eax
  unsigned int v87; // esi
  int v88; // eax
  signed int v89; // eax
  _BOOL1 v90; // cc
  int v91; // edx
  _BOOL1 v92; // dl
  _BYTE *v93; // eax
  unsigned int v95; // ebx
  int v96; // ecx
  unsigned __int16 v97; // cx
  int v98; // eax
  int v99; // eax
  signed int v100; // eax
  int v101; // eax
  unsigned int v102; // eax
  int v103; // ecx
  int v104; // eax
  int v105; // eax
  char *v106; // ecx
  int v107; // eax
  char *v108; // edx
  struct CONNECTION *v109; // eax
  unsigned int v110; // ebx
  unsigned int v111; // eax
  int v112; // ecx
  int *v113; // eax
  int v114; // eax
  unsigned int v115; // esi
  unsigned int v116; // ebx
  unsigned int v117; // eax
  int v118; // ecx
  int *v119; // eax
  int v120; // eax
  unsigned int v121; // esi
  BYTE v122; // al
  unsigned __int16 v123; // ax
  struct ARENA *v124; // ebx
  int v125; // eax
  int v126; // eax
  int v127; // eax
  BYTE v128; // al
  unsigned int v129; // ecx
  char v130; // al
  char *v131; // edi
  char *v132; // esi
  DWORD v133; // eax
  BYTE *v134; // ecx
  int v135; // eax
  int *v136; // esi
  int v137; // ecx
  BYTE *v138; // edi
  unsigned int i; // ebx
  int v140; // eax
  int v141; // [esp-4h] [ebp-150h]
  int v142; // [esp+0h] [ebp-14Ch]
  int v143; // [esp+4h] [ebp-148h]
  int v144; // [esp+8h] [ebp-144h]
  char v145[128]; // [esp+Ch] [ebp-140h] BYREF
  char v146[28]; // [esp+8Ch] [ebp-C0h] BYREF
  char v147; // [esp+A8h] [ebp-A4h] BYREF
  __int16 v148; // [esp+A9h] [ebp-A3h]
  int v149; // [esp+ABh] [ebp-A1h]
  char v150[13]; // [esp+AFh] [ebp-9Dh] BYREF
  char v151[16]; // [esp+BCh] [ebp-90h] BYREF
  char v152[64]; // [esp+CCh] [ebp-80h] BYREF
  char v153[28]; // [esp+10Ch] [ebp-40h] BYREF
  char v154; // [esp+128h] [ebp-24h]
  char v155; // [esp+12Bh] [ebp-21h]
  _BYTE buf_sz[7]; // [esp+12Ch] [ebp-20h] BYREF
  __int16 v157; // [esp+134h] [ebp-18h] BYREF
  PLAYER *player; // [esp+138h] [ebp-14h]
  char *reason[2]; // [esp+13Ch] [ebp-10h]
  int v160; // [esp+144h] [ebp-8h] BYREF
  int v161; // [esp+148h] [ebp-4h]

  v3 = buf;
  v4 = (char)*buf;
  player = (PLAYER *)this;
  if ( byte_101A5388 && v4 < 0x2E )
  {
    v6 = *(_DWORD *)(this + 755);
    v7 = ((-25033 * (v6 ^ HIWORD(*(_DWORD *)(this + 755)))) >> 5) & 0x7FF;
    v8 = dword_101A5398[2 * v7];
    reason[1] = (char *)v7;
    if ( v8 == v6 )
    {
LABEL_7:
      v9 = (int *)(8 * v7 + 270160796);
      if ( v9 )
      {
        v10 = *v9;
        v11 = dword_10021998[v4] + *(_DWORD *)(v10 + 8);
        *(_DWORD *)(v10 + 8) = v11;
        if ( v11 > 0x1388 )
          *(_DWORD *)(v10 + 8) = 4 * v11;
      }
    }
    else
    {
      while ( 1 )
      {
        if ( !v8 )
        {
          dword_101A9398 = 8 * v7 + 270160792;
          goto LABEL_10;
        }
        v7 = ((_WORD)v7 + 1) & 0x7FF;
        if ( (char *)v7 == reason[1] )
          break;
        v8 = dword_101A5398[2 * v7];
        if ( v8 == v6 )
          goto LABEL_7;
      }
      dword_101A9398 = 0;
    }
  }
LABEL_10:
  v160 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  if ( (v4 == 26 || v4 == 30 || v4 == 3 || v4 == 4) && *(_DWORD *)(this + 275) == 8 )
  {
    v12 = v160;
  }
  else
  {
    v12 = v160;
    *(_DWORD *)(this + 1327) = v160;
  }
  v13 = *v3;
  if ( *v3 != 3 )
  {
    switch ( v13 )
    {
      case 0xFu:
        v38 = FIX_DLL_KERNEL32_dll_GetTickCount(v142, v143, v144) / 0xAu;
        if ( v38 - *(_DWORD *)(this + 655) >= 0x96 )
        {
          *(_DWORD *)(this + 655) = v38;
          *(_DWORD *)(this + 659) = 0;
        }
        else
        {
          v39 = *(_DWORD *)(this + 659) + 1;
          v26 = *(_DWORD *)(this + 659) - 6 < 0;
          *(_DWORD *)(this + 659) = v39;
          if ( !(v26 ^ __OFSUB__(v39, 7) | (v39 == 7)) )
          {
            *(_DWORD *)(this + 789) = 33;
            *(_DWORD *)(this + 56) = 1;
            off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)(this + 375));
            reason[1] = "WARNING: You have been disconnected for message flooding";
            SendArenaMessagePlayer(player, "WARNING: You have been disconnected for message flooding", 0);
          }
        }
        if ( byte_101A5380 )
        {
          if ( !*(_DWORD *)(this + 635) )
          {
            v40 = *(_DWORD *)(this + 28);
            if ( v40 )
            {
              if ( *(_DWORD *)(v40 + 65374) )
                return;
            }
          }
        }
        if ( *(_WORD *)(v3 + 1) > 0x270Fu )
          return;
        break;
      case 0x15u:
        if ( dword_101A5334 >= 0 )
        {
          v41 = *(_DWORD *)(this + 28);
          if ( v41 )
          {
            v42 = *(_DWORD *)(v41 + 109758);
            *(_DWORD *)(v41 + 109758) = dword_101A5334;
            PlayerHandleGamePacket(player, buf, pkt_sz);
            *(_DWORD *)(*(_DWORD *)(this + 28) + 109758) = v42;
            return;
          }
        }
        break;
      case 6u:
        if ( pkt_sz < 6 || !*(_DWORD *)(this + 28) )
          return;
        v3[pkt_sz - 1] = 0;
        v43 = v3[1];
        if ( v43 == 4 || v43 == 5 )
        {
          if ( *(_WORD *)(v3 + 3) >= 0x400u )
            return;
          v44 = (int)*(&PlayerArray + *(unsigned __int16 *)(v3 + 3));
          if ( !v44 || *(_DWORD *)(v44 + 28) != *(_DWORD *)(this + 28) )
            return;
        }
        else
        {
          *(_WORD *)(v3 + 3) = 0;
        }
        if ( !*(_DWORD *)(this + 639) && !*(_DWORD *)(*(_DWORD *)(this + 28) + 109742) && (v3[2] < 0x96u || v43 != 3) )
          v3[2] = 0;
        break;
      case 7u:
        v45 = *(_WORD *)(v3 + 9);
        v46 = abs16(v45);
        if ( v46 < 29 )
        {
          v47 = *(_DWORD *)(this + 28);
          if ( v47 && !*(_BYTE *)(v47 + v46 + 109593) && !*(_DWORD *)(this + 635) && byte_101A5383 )
          {
            v48 = (const char *)L"-";
            if ( v45 >= 0 )
              v48 = byte_10028A9C;
            sprintf_0(v146, "Illegal green: %s%s", v48, (const char *)dword_10024680[v46]);
            sub_100151C0((int)v146, this);
            v49 = *(_DWORD *)(this + 28);
            if ( !v49 || *(_DWORD *)(v49 + 109802) )
            {
              *(_DWORD *)(this + 56) = 1;
              *(_DWORD *)(this + 789) = 32;
            }
          }
          v50 = (int *)(this + 861);
          if ( *(int *)(this + 861) >= 0 )
          {
            v51 = (const char *)L"-";
            if ( *(__int16 *)(buf + 9) >= 0 )
              v51 = byte_10028A9C;
            sprintf_0(v146, "%s picked up %s%s", (const char *)(this + 375), v51, (const char *)dword_10024680[v46]);
            reason[1] = 0;
            do
            {
              if ( *v50 < 0 )
                break;
              v161 = (int)*(&PlayerArray + *v50);
              if ( v161 && *(_DWORD *)(v161 + 639) )
              {
                *(_DWORD *)buf_sz = v146;
                SendMessage((struct PLAYER *)v161, v146, 0);
              }
              ++v50;
              ++reason[1];
            }
            while ( reason[1] < (char *)6 );
          }
          ++*(_DWORD *)(this + 4 * v46 + 893);
          v52 = *(_DWORD *)(this + 1009) + 1;
          *(_DWORD *)(this + 1009) = v52;
          reason[1] = (char *)v52;
          if ( byte_101A5385 )
          {
            if ( (v52 & 0xF) == 0 && v52 > 100 )
            {
              v53 = *(_DWORD *)(this + 28);
              if ( v53 )
              {
                v54 = (long double)(int)reason[1];
                *(_QWORD *)reason = *(unsigned int *)(v53 + 111602);
                v55 = 1;
                v56 = (unsigned __int8 *)(v53 + 109594);
                v57 = (int *)(this + 897);
                v58 = v54 / (long double)*(__int64 *)reason * dbl_10021A88;
                while ( 1 )
                {
                  v161 = *v57;
                  if ( v161 > 10 )
                  {
                    reason[1] = (char *)*v56;
                    v59 = (long double)(int)reason[1] * v58 / (long double)v161;
                    if ( (unsigned int)(__int64)v59 < 0x32 || (unsigned int)(__int64)v59 > 0xC8 )
                      break;
                  }
                  ++v55;
                  ++v56;
                  ++v57;
                  if ( v55 >= 0x1D )
                    goto LABEL_269;
                }
                sprintf_0(
                  v146,
                  "Abnormal green distribution: %s %d%%",
                  (const char *)dword_10024680[v55],
                  (unsigned int)(__int64)v59);
              }
            }
          }
        }
        break;
      case 0x18u:
        v60 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 885) = v12;
        if ( v60 && !*(_DWORD *)(v60 + 65374) )
          *(_DWORD *)(this + 1030) = v12 + 5000;
        if ( v3[1] != 8 && v60 )
        {
          v61 = *(_DWORD *)(v60 + 121111);
          if ( v61 > 0 )
          {
            v62 = *(_DWORD *)(v60 + 121115);
            if ( v62 > 0 && (*(_DWORD *)(this + 619) > v61 || *(_DWORD *)(this + 623) > v62) && !*(_DWORD *)(this + 631) )
            {
              sprintf_0(
                v145,
                "Maximum allowed screen resolution is %dx%d in this arena",
                *(_DWORD *)(v60 + 121111),
                *(_DWORD *)(v60 + 121115));
              buf = (BYTE *)v145;
              SendMessage(player, v145, 0);
              return;
            }
          }
          if ( (*(_BYTE *)(v60 + 121247) || byte_101A5389)
            && *(_DWORD *)(this + 24) != 1
            && !*(_DWORD *)(this + 631)
            && !*(_DWORD *)(this + 1026) )
          {
            sprintf_0(
              v145,
              "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
            buf = (BYTE *)v145;
            SendMessage(player, v145, 0);
            return;
          }
          v63 = *(_DWORD *)(v60 + 121256);
          if ( v63 )
          {
            if ( *(_DWORD *)(this + 519) < v63 && FindMeOut1 && !*(_DWORD *)(this + 635) )
            {
              sprintf_0(
                v145,
                "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
                *(_DWORD *)(v60 + 121256) / 3600);
              buf = (BYTE *)v145;
              SendMessage(player, v145, 0);
              return;
            }
          }
        }
        break;
      case 5u:
        *(_DWORD *)(this + 1030) = v12 + 15000;
        v64 = *(_WORD *)(v3 + 3);
        if ( v64 < 0 || v64 > 10000 )
        {
          sprintf_0(v152, "Illegal death bounty %d, changed to 100", v64);
          sub_100151C0((int)v152, this);
          *(_WORD *)(v3 + 3) = 100;
        }
        break;
      case 1u:
        v65 = pkt_sz == 27;
        v3[25] = 0;
        v66 = !v65 || v3[26];
        v67 = (char *)(v3 + 10);
        *(_BYTE *)(this + 1034) = v66;
        sub_10003280((int)(v3 + 10));
        v68 = v3[10];
        reason[1] = (char *)(v3 + 10);
        if ( v68 )
        {
          v161 = (int)(v3 + 11);
          do
          {
            if ( !isalnum(v68) && (*v67 != 35 || v67 != (char *)(v3 + 10)) )
            {
              v69 = strlen((const char *)v161) + 1;
              v70 = v69;
              v69 >>= 2;
              qmemcpy(reason[1], (const void *)v161, 4 * v69);
              v71 = &reason[1][4 * v69];
              --reason[1];
              qmemcpy(v71, (const void *)(v161 + 4 * v69), v70 & 3);
              v67 = reason[1];
              v3 = buf;
              --v161;
            }
            v68 = *++v67;
            reason[1] = v67;
            ++v161;
          }
          while ( v68 );
        }
        v72 = (const char *)(v3 + 10);
        *(_DWORD *)(this + 1030) = v160 + 15000;
        if ( sub_100027F0(v3 + 10) )
          *v72 = 0;
        v73 = *(_DWORD *)(this + 635);
        if ( v73 || *(_DWORD *)(this + 1026) || *(_DWORD *)(this + 24) != 1 || *(_DWORD *)(this + 100) == dword_101C8060 )
        {
          v74 = *(_DWORD *)(this + 40);
          if ( !v74
            || v73
            || *(_DWORD *)(this + 1026)
            || (v75 = *(_DWORD *)(v74 + 66), v75 == 17)
            || byte_101A5386 && v75 == 1 )
          {
            if ( sub_1000AD20((int)dword_1003E438, (int)v72, (int)buf_sz, (int)&v157)
              || (PlayerHandleGamePacket(player, buf, pkt_sz), (v76 = *(_DWORD *)(this + 28)) != 0)
              && (v72 = (const char *)(v76 + 64256),
                  sub_1000AD20((int)dword_1003E438, v76 + 64256, (int)buf_sz, (int)&v157)) )
            {
              memset(v153, 0, sizeof(v153));
              v154 = 0;
              *(_DWORD *)&v153[1] = *(_DWORD *)buf_sz;
              *(_WORD *)&v153[7] = *((_WORD *)buf + 4);
              *(_WORD *)&v153[5] = v157;
              v153[0] = 59;
              strcpy(&v153[9], v72);
              buf = (BYTE *)v153;
              PlayerSendPacket(player, v153, 29, 1);
            }
          }
          else
          {
            sub_100151C0((int)"Incompatible network protocol attempting to enter game", this);
            *(_DWORD *)(this + 56) = 1;
            *(_DWORD *)(this + 789) = 36;
          }
        }
        else
        {
          sub_100151C0((int)"Incompatible Continuum version attempting to enter game", this);
          *(_DWORD *)(this + 56) = 1;
          *(_DWORD *)(this + 789) = 35;
        }
        return;
      case 9u:
        v77 = v3[2];
        v78 = (char *)(v3 + 2);
        reason[1] = (char *)(v3 + 2);
        v65 = isalnum(v77) == 0;
        v3[33] = 0;
        v79 = !v65;
        if ( v3[2] )
        {
          v80 = v3 + 2;
          do
          {
            if ( *v80 < 0x20u || *v80 > 0x7Eu )
            {
              *v80 = 95;
              v79 = 0;
            }
          }
          while ( *++v80 );
        }
        if ( v79 )
        {
          *(_DWORD *)(v3 + 77) = pkt_sz;
          PlayerHandleGamePacket(player, buf, pkt_sz);
          if ( FindMeOut1 )
          {
            v88 = FIX_DLL_KERNEL32_dll_GetTickCount(v142, v143, v144);
            if ( v88 - dword_101A94EC >= 15000 )
            {
              dword_101A94EC = v88;
              v89 = sub_10002830(byte_101A93E4);
              if ( v89 != dword_101A94E8 )
              {
                dword_101A94E8 = v89;
                off_10024608("Ext: Re-reading %s\n", byte_101A93E4);
                (*(void (__thiscall **)(int *))dword_101A93E0)(&dword_101A93E0);
              }
            }
            buf = (BYTE *)dword_101A94F0;
            pkt_sz = 0;
            if ( dword_101A94F8 > 0 )
            {
              while ( unknown_libname_69(buf, v78) && strcmp((const char *)buf, "*!") )
              {
                v90 = (int)++pkt_sz < dword_101A94F8;
                buf += 44;
                if ( !v90 )
                  return;
                v78 = reason[1];
              }
              *(_DWORD *)(this + 1026) = 1;
            }
          }
          return;
        }
        off_10024608("Ext: Player with invalid name tying to enter: %s\n", (const char *)v3 + 2);
        v82 = *(_DWORD *)(this + 755);
        v83 = ((-25033 * (v82 ^ HIWORD(v82))) >> 5) & 0x7FF;
        v84 = dword_101A5398[2 * v83];
        if ( v84 != v82 )
        {
          while ( v84 )
          {
            v83 = ((_WORD)v83 + 1) & 0x7FF;
            if ( v83 == (((-25033 * (v82 ^ HIWORD(v82))) >> 5) & 0x7FF) )
              goto LABEL_291;
            v84 = dword_101A5398[2 * v83];
            if ( v84 == v82 )
              goto LABEL_205;
          }
          dword_101A9398 = 8 * v83 + 270160792;
          return;
        }
        goto LABEL_205;
      case 0x24u:
        v91 = v3[2];
        reason[1] = (char *)(v3 + 2);
        v65 = isalnum(v91) == 0;
        v3[33] = 0;
        v92 = !v65;
        if ( v3[2] )
        {
          v93 = v3 + 2;
          do
          {
            if ( *v93 < 0x20u || *v93 > 0x7Eu )
            {
              *v93 = 95;
              v92 = 0;
            }
          }
          while ( *++v93 );
        }
        if ( v92 )
        {
          if ( *(_DWORD *)(this + 40) )
          {
            if ( sub_1000AD20((int)dword_1003E438, (int)"$login", (int)&v160, (int)&v157) )
            {
              memset(v153, 0, sizeof(v153));
              v154 = 0;
              v153[0] = 59;
              *(_DWORD *)&v153[1] = v160;
              *(_WORD *)&v153[5] = v157;
              *(_WORD *)&v153[7] = -1;
              buf = (BYTE *)v153;
              PlayerSendPacket(player, v153, 29, 1);
            }
            else
            {
              *(_DWORD *)(this + 1319) = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(v3 + 89));
              LOBYTE(v97) = 0;
              HIBYTE(v97) = *(_WORD *)(v3 + 93);
              *(_DWORD *)(this + 1323) = HIBYTE(*(unsigned __int16 *)(v3 + 93)) | v97;
              if ( byte_101A538A || byte_101A538B && *(unsigned __int16 *)(v3 + 75) > dword_101C8060 )
                *(_DWORD *)(this + 1026) = 1;
              v98 = *(_DWORD *)(this + 1026);
              buf_sz[0] = 52;
              if ( v98 )
                *(_WORD *)&buf_sz[1] = *(_WORD *)(v3 + 75);
              else
                *(_WORD *)&buf_sz[1] = dword_101C8060;
              *(_DWORD *)&buf_sz[3] = dword_4CCAE4;
              v161 = (int)buf_sz;
              PlayerSendPacket(player, buf_sz, 7, 1);
              *(_DWORD *)(v3 + 77) = pkt_sz;
              PlayerHandleGamePacket(player, buf, pkt_sz);
              if ( FindMeOut1 )
              {
                v99 = FIX_DLL_KERNEL32_dll_GetTickCount(v141, v142, v143);
                if ( v99 - dword_101A94EC >= 15000 )
                {
                  dword_101A94EC = v99;
                  v100 = sub_10002830(byte_101A93E4);
                  if ( v100 != dword_101A94E8 )
                  {
                    dword_101A94E8 = v100;
                    off_10024608("Ext: Re-reading %s\n", byte_101A93E4);
                    (*(void (__thiscall **)(int *))dword_101A93E0)(&dword_101A93E0);
                  }
                }
                pkt_sz = dword_101A94F0;
                v161 = 0;
                if ( dword_101A94F8 > 0 )
                {
                  while ( unknown_libname_69(pkt_sz, reason[1]) && strcmp((const char *)pkt_sz, "*!") )
                  {
                    v90 = ++v161 < dword_101A94F8;
                    pkt_sz += 44;
                    if ( !v90 )
                      goto LABEL_255;
                  }
                  *(_DWORD *)(this + 1026) = 1;
LABEL_255:
                  v3 = buf;
                }
              }
              if ( *(_DWORD *)(this + 635) || *(_DWORD *)(*(_DWORD *)(this + 40) + 66) == 17 )
              {
                *(_BYTE *)(this + 1623) = *(_WORD *)(v3 + 75) >= 0x26u;
              }
              else
              {
                sub_100151C0((int)"Invalid login packet received", this);
                *(_DWORD *)(this + 56) = 1;
                *(_DWORD *)(this + 789) = 37;
              }
            }
            return;
          }
        }
        else
        {
          off_10024608("Ext: Player with invalid name tying to enter: %s\n", (const char *)v3 + 2);
        }
        v95 = *(_DWORD *)(this + 755);
        v83 = ((-25033 * (v95 ^ HIWORD(v95))) >> 5) & 0x7FF;
        v96 = dword_101A5398[2 * v83];
        if ( v96 != v95 )
        {
          while ( v96 )
          {
            v83 = ((_WORD)v83 + 1) & 0x7FF;
            if ( v83 == (((-25033 * (v95 ^ HIWORD(v95))) >> 5) & 0x7FF) )
              goto LABEL_291;
            v96 = dword_101A5398[2 * v83];
            if ( v96 == v95 )
              goto LABEL_205;
          }
          dword_101A9398 = 8 * v83 + 270160792;
          return;
        }
LABEL_205:
        v85 = (int *)(8 * v83 + 270160796);
        if ( v85 )
        {
          v86 = *v85;
          v87 = *(_DWORD *)(v86 + 8) + 500;
          *(_DWORD *)(v86 + 8) = v87;
          if ( v87 > 0x1388 )
            *(_DWORD *)(v86 + 8) = 4 * v87;
        }
        return;
      case 0xEu:
        if ( pkt_sz < 4 )
        {
          sub_100151C0((int)"Server crash attempt", this);
          return;
        }
        break;
      case 0x16u:
        if ( !*(_DWORD *)(this + 28) )
          return;
        v3[16] = 0;
        if ( *(_DWORD *)(this + 635) )
          break;
        v101 = sub_100030E0((int)(v3 + 1), ".lvl");
LABEL_268:
        if ( !v101 )
          return;
        break;
      case 0xCu:
        if ( pkt_sz == 3 && *(_WORD *)(v3 + 1) )
        {
          v102 = *(unsigned __int16 *)(v3 + 1) - 1;
          if ( v102 < 0x10 )
          {
            v103 = *(_DWORD *)(this + 28);
            if ( v103 )
            {
              v104 = *(_DWORD *)(v103 + 4 * v102 + 121119);
              if ( v104 >= 0 )
              {
                v105 = 32 * v104;
                v106 = *(char **)(v105 + dword_101A9500 + 28);
                v107 = dword_101A9500 + v105;
                if ( v106 )
                {
                  v108 = *(char **)(v107 + 20);
                  v109 = *(struct CONNECTION **)(this + 40);
                  reason[1] = v108;
                  pkt_sz = (DWORD)v106;
                  HIWORD(buf) = HIWORD(v109);
                  GetMapLvlRequest(v109, v106, (int)v108, 0);
                }
              }
            }
          }
          return;
        }
        break;
      case 0x1Du:
        v101 = *(_DWORD *)(this + 28);
        goto LABEL_268;
      case 0xBu:
        if ( *(_DWORD *)(this + 24) >= 0xAu )
        {
          sub_100151C0((int)"Server crash attempt", this);
          v110 = *(_DWORD *)(this + 755);
          v111 = ((-25033 * (v110 ^ HIWORD(v110))) >> 5) & 0x7FF;
          v112 = dword_101A5398[2 * v111];
          if ( v112 == v110 )
          {
LABEL_287:
            v113 = (int *)(8 * v111 + 270160796);
            if ( v113 )
            {
              v114 = *v113;
              v115 = *(_DWORD *)(v114 + 8) + 500;
              *(_DWORD *)(v114 + 8) = v115;
              if ( v115 > 0x1388 )
                *(_DWORD *)(v114 + 8) = 4 * v115;
            }
          }
          else
          {
            while ( 1 )
            {
              if ( !v112 )
              {
                dword_101A9398 = 8 * v111 + 270160792;
                return;
              }
              v111 = ((_WORD)v111 + 1) & 0x7FF;
              if ( v111 == (((-25033 * (v110 ^ HIWORD(v110))) >> 5) & 0x7FF) )
                break;
              v112 = dword_101A5398[2 * v111];
              if ( v112 == v110 )
                goto LABEL_287;
            }
LABEL_291:
            dword_101A9398 = 0;
          }
          return;
        }
        break;
      case 0x19u:
        if ( pkt_sz != 97 )
        {
          sub_100151C0((int)"Packet tampering (25)", this);
          return;
        }
        v116 = *(_DWORD *)(this + 755);
        v117 = ((-25033 * (v116 ^ HIWORD(v116))) >> 5) & 0x7FF;
        v118 = dword_101A5398[2 * v117];
        if ( v118 == v116 )
        {
LABEL_299:
          v119 = (int *)(8 * v117 + 270160796);
          if ( v119 )
          {
            v120 = *v119;
            v121 = *(_DWORD *)(v120 + 8) + 500;
            *(_DWORD *)(v120 + 8) = v121;
            if ( v121 > 0x1388 )
              *(_DWORD *)(v120 + 8) = 4 * v121;
          }
        }
        else
        {
          while ( 1 )
          {
            if ( !v118 )
            {
              dword_101A9398 = 8 * v117 + 270160792;
              goto LABEL_269;
            }
            v117 = ((_WORD)v117 + 1) & 0x7FF;
            if ( v117 == (((-25033 * (v116 ^ HIWORD(v116))) >> 5) & 0x7FF) )
              break;
            v118 = dword_101A5398[2 * v117];
            if ( v118 == v116 )
              goto LABEL_299;
          }
          dword_101A9398 = 0;
        }
        break;
      case 0xAu:
        if ( *(_DWORD *)(this + 635) )
        {
          if ( pkt_sz >= 4 )
          {
            v122 = v3[3];
            if ( v122 != 16 && v122 != 25 )
            {
              v123 = *(_WORD *)(v3 + 1);
              if ( v123 >= 0x400u )
              {
                if ( v123 == 0xFFFF )
                {
                  v124 = *(struct ARENA **)(this + 28);
                  if ( v124 )
                  {
                    v155 = 1;
                    *(_DWORD *)buf_sz = pkt_sz - 3;
                    v161 = (int)(v3 + 3);
                    reason[1] = (char *)v124;
                    ArenaSendPacket(v124, (char *)v3 + 3, pkt_sz - 3, 1);
                  }
                }
              }
              else
              {
                reason[1] = (char *)*(&PlayerArray + *(unsigned __int16 *)(v3 + 1));
                if ( reason[1] )
                {
                  *(_DWORD *)buf_sz = pkt_sz - 3;
                  v161 = (int)(v3 + 3);
                  PlayerSendPacket((PLAYER *)reason[1], v3 + 3, pkt_sz - 3, 1);
                }
              }
            }
          }
        }
        break;
      case 4u:
        *(_DWORD *)(this + 4 * *(_DWORD *)(this + 1035) + 1039) = *(_DWORD *)(v3 + 1);
        *(_DWORD *)(this + 4 * *(_DWORD *)(this + 1035) + 1167) = v12 / 10;
        *(_DWORD *)(this + 1035) = ((unsigned __int8)*(_DWORD *)(this + 1035) + 1) & 0x1F;
        return;
      case 0x1Au:
        v125 = *(_DWORD *)(this + 28);
        if ( v125 )
        {
          if ( *(_DWORD *)(this + 1026) )
            *(_DWORD *)(v3 + 9) = dword_4CBB28[1009 * *(_DWORD *)(this + 24) + 2 * *(_DWORD *)(v125 + 65332)];
          if ( pkt_sz >= 0x2E )
          {
            v126 = *(_DWORD *)(v3 + 42);
            if ( v126 != *(_DWORD *)(*(_DWORD *)(this + 28) + 121265) )
            {
              if ( v126 )
              {
                sub_100151C0((int)"WARNING: Level checksum mismatch ", this);
                v127 = *(_DWORD *)(this + 28);
                if ( !v127 || *(_DWORD *)(v127 + 109802) )
                {
                  *(_DWORD *)(this + 56) = 1;
                  *(_DWORD *)(this + 789) = 34;
                }
              }
            }
          }
        }
        *(_DWORD *)(this + 2648) = *((__int16 *)v3 + 20);
        break;
      case 0x1Bu:
        v128 = v3[1];
        if ( *(_DWORD *)(this + 1026) && v128 == 27 )
          return;
        switch ( v128 )
        {
          case 1u:
            sub_100151C0((int)"Disconnected due low framerate", this);
            return;
          case 0x3Cu:
            sub_100151C0((int)"Timer synchronization error", this);
            return;
          case 0x3Du:
            v129 = strlen("Process debugger ") + 1;
            v130 = v129;
            v129 >>= 2;
            qmemcpy(v151, "Process debugger ", 4 * v129);
            v132 = &aProcessDebugger[4 * v129];
            v131 = &v151[4 * v129];
            LOBYTE(v129) = v130;
            v133 = pkt_sz;
            v90 = pkt_sz <= 2;
            qmemcpy(v131, v132, v129 & 3);
            if ( !v90 )
            {
              v134 = buf;
              buf[v133 - 1] = 0;
              sub_10003060(v151, v134 + 2, 80);
            }
            sub_100151C0((int)v151, this);
            v135 = *(_DWORD *)(this + 28);
            if ( !v135 || *(_DWORD *)(v135 + 109802) )
            {
              *(_DWORD *)(this + 56) = 1;
              *(_DWORD *)(this + 789) = 33;
            }
            return;
        }
        break;
      default:
        if ( v13 == 50 && pkt_sz >= 0xE && pkt_sz <= 0x5F )
        {
          v136 = (int *)(this + 1295);
          if ( *(int *)(this + 1295) < 0 )
          {
            HIWORD(buf) = 55;
            pkt_sz = (DWORD)&buf + 2;
            PlayerSendPacket(player, (char *)&buf + 2, 2, 1);
          }
          else
          {
            v137 = *(_DWORD *)(v3 + 1);
            v148 = *(_WORD *)(this + 20);
            v147 = 56;
            v149 = v137;
            buf = (BYTE *)(pkt_sz - 5);
            memcpy_0(v150, v3 + 5, pkt_sz - 5);
            v138 = buf;
            for ( i = 0; i < 6; ++i )
            {
              if ( *v136 < 0 )
                break;
              v140 = (int)*(&PlayerArray + *v136);
              buf = (BYTE *)v140;
              if ( v140 && *(_DWORD *)(v140 + 639) )
              {
                reason[1] = (char *)(v138 + 7);
                pkt_sz = (DWORD)&v147;
                PlayerSendPacket((PLAYER *)buf, &v147, (int)(v138 + 7), 1);
              }
              ++v136;
            }
          }
          return;
        }
        break;
    }
LABEL_269:
    PlayerHandleGamePacket(player, buf, pkt_sz);
    return;
  }
  reason[1] = *(char **)(this + 28);
  if ( !reason[1] )
    return;
  v14 = *((unsigned __int16 *)v3 + 10);
  *(_DWORD *)buf_sz = v14 & 0x1F;
  if ( (v14 & 0x1F) == 0 )
    goto LABEL_47;
  if ( !byte_101A5383 )
    goto LABEL_54;
  if ( *(_DWORD *)(this + 635) )
    goto LABEL_47;
  v15 = *(_DWORD *)(this + 275);
  v161 = v14 & 0x7F;
  if ( ((unsigned __int8)(1 << v15) & reason[1][v161 + 120983]) == 0 )
  {
    v16 = buf;
    v17 = 0;
    v18 = 22;
    do
    {
      v17 ^= *v16++;
      --v18;
    }
    while ( v18 );
    if ( !v17 )
    {
LABEL_28:
      sub_10010530(this, this, v14);
      return;
    }
    goto LABEL_47;
  }
  if ( *(_DWORD *)buf_sz != 4 && *(_DWORD *)buf_sz != 3 )
    goto LABEL_47;
  v19 = &reason[1][16 * v15 + 120839];
  if ( (v14 & 0x7C00u) > *(_DWORD *)v19 || (v14 & *((_DWORD *)v19 + 1)) != 0 )
  {
    v20 = buf;
    v21 = 0;
    v22 = 22;
    do
    {
      v21 ^= *v20++;
      --v22;
    }
    while ( v22 );
    if ( !v21 )
      goto LABEL_28;
  }
  if ( !dword_101A533C )
  {
LABEL_47:
    if ( byte_101A5383 )
    {
      v27 = buf;
      v28 = buf[11] & *(_DWORD *)(16 * *(_DWORD *)(this + 275) + *(_DWORD *)(this + 28) + 120847);
      if ( v28 )
      {
        if ( !*(_DWORD *)(this + 635) )
        {
          v29 = 0;
          v30 = buf;
          v31 = 22;
          do
          {
            v29 ^= *v30++;
            --v31;
          }
          while ( v31 );
          if ( !v29 )
          {
            sub_100106E0(this, v28);
            return;
          }
        }
      }
      goto LABEL_55;
    }
LABEL_54:
    v27 = buf;
LABEL_55:
    if ( byte_101A537F )
    {
      v32 = v27[11];
      if ( (v32 & 0x20) != 0 && (v32 & 8) != 0 )
      {
        v27[11] = v32 & 0xF7;
        v27[10] ^= 8u;
      }
    }
    if ( *((__int16 *)v27 + 8) < 0 )
      *((_WORD *)v27 + 8) = 0;
    v33 = *(_DWORD *)(this + 28);
    v34 = *(_DWORD *)(v33 + 121248);
    if ( v34 && *(_DWORD *)(this + 275) != 8 )
    {
      v35 = *(_DWORD *)(this + 1030);
      if ( v35 )
      {
        v36 = v160 - v35;
        if ( v160 - v35 >= *(_DWORD *)(v33 + 121252) )
        {
          if ( (v34 & 1) != 0 )
          {
            sprintf_0(v152, "No data for %d ms", v160 - v35);
            sub_100151C0((int)v152, this);
          }
          if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 121248) & 2) != 0 )
          {
            v37 = FIX_DLL_KERNEL32_dll_GetTickCount(v142, v143, v144);
            *(_DWORD *)(this + 885) = v37;
            *(_DWORD *)(this + 1030) = v37 + 5000;
            SetPlayerShip(player, 8);
            reason[1] = "You have been put in spectator mode due to no data (C2S)";
            SendMessage(player, "You have been put in spectator mode due to no data (C2S)", 0);
            off_10024608("Ext: No data for %d ms, put in spectator mode: %s\n", v36, (const char *)(this + 375));
          }
          if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 121248) & 4) != 0 )
          {
            *(_DWORD *)(this + 56) = 1;
            *(_DWORD *)(this + 789) = 39;
            off_10024608("Ext: No data for %d ms, kicked off: %s\n", v36, (const char *)(this + 375));
          }
        }
      }
      if ( v160 - *(_DWORD *)(this + 1030) > 0 )
        *(_DWORD *)(this + 1030) = v160;
    }
    PlayerHandleGamePacket(player, buf, pkt_sz);
    if ( v160 - *(_DWORD *)(this + 1327) >= dword_101A5358 )
    {
      if ( dword_101A5358 )
        *(_DWORD *)(this + 777) = 1;
    }
    return;
  }
  v23 = v160 - *(_DWORD *)(this + 889);
  if ( v23 >= *((_DWORD *)v19 + 3) )
    goto LABEL_46;
  if ( (dword_101A533C & 1) != 0 )
  {
    sprintf_0(v152, "Possible fastbombing %d", v23 / 10);
    sub_100151C0((int)v152, this);
    v24 = FIX_DLL_KERNEL32_dll_GetTickCount(v142, v143, v144) / 0xAu;
    if ( v24 - *(_DWORD *)(this + 655) >= 0x96 )
    {
      *(_DWORD *)(this + 655) = v24;
      *(_DWORD *)(this + 659) = 0;
    }
    else
    {
      v25 = *(_DWORD *)(this + 659) + 1;
      v26 = *(_DWORD *)(this + 659) - 6 < 0;
      *(_DWORD *)(this + 659) = v25;
      if ( !(v26 ^ __OFSUB__(v25, 7) | (v25 == 7)) )
      {
        *(_DWORD *)(this + 789) = 33;
        *(_DWORD *)(this + 56) = 1;
      }
    }
  }
  if ( (dword_101A533C & 4) != 0 )
  {
    *(_DWORD *)(this + 789) = 34;
    *(_DWORD *)(this + 56) = 1;
  }
  *(_DWORD *)(this + 889) = v160;
  if ( (dword_101A533C & 2) == 0 )
  {
LABEL_46:
    *(_DWORD *)(this + 889) = v160;
    goto LABEL_47;
  }
}
// 100113EE: conditional instruction was optimized away because of 'eax.4!=0'
// 10011459: conditional instruction was optimized away because of 'eax.4!=0'
// 10010D25: variable 'v142' is possibly undefined
// 10010D25: variable 'v143' is possibly undefined
// 10010D25: variable 'v144' is possibly undefined
// 10011B25: variable 'v141' is possibly undefined
// 4CBB28: using guessed type int dword_4CBB28[];
// 4CCAE4: using guessed type int dword_4CCAE4;
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10021998: using guessed type int dword_10021998[];
// 10021A88: using guessed type double dbl_10021A88;
// 10024680: using guessed type int dword_10024680[];
// 100258A0: using guessed type wchar_t asc_100258A0[2];
// 101A5334: using guessed type int dword_101A5334;
// 101A533C: using guessed type int dword_101A533C;
// 101A5358: using guessed type int dword_101A5358;
// 101A537F: using guessed type char byte_101A537F;
// 101A5380: using guessed type char byte_101A5380;
// 101A5383: using guessed type char byte_101A5383;
// 101A5385: using guessed type char byte_101A5385;
// 101A5386: using guessed type char byte_101A5386;
// 101A5388: using guessed type char byte_101A5388;
// 101A5389: using guessed type char byte_101A5389;
// 101A538A: using guessed type char byte_101A538A;
// 101A538B: using guessed type char byte_101A538B;
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;
// 101A93E0: using guessed type int dword_101A93E0;
// 101A94E8: using guessed type int dword_101A94E8;
// 101A94EC: using guessed type int dword_101A94EC;
// 101A94F0: using guessed type int dword_101A94F0;
// 101A94F8: using guessed type int dword_101A94F8;
// 101A9500: using guessed type int dword_101A9500;
// 101C8060: using guessed type int dword_101C8060;
// 10010B00: using guessed type char var_90[16];

//----- (100122C0) --------------------------------------------------------
_DWORD *__thiscall sub_100122C0(int this)
{
  int v1; // ebx
  _DWORD *v2; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // ebp
  _DWORD *v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  _DWORD *v14; // ecx
  _DWORD *result; // eax
  int v16; // esi
  int v17; // edx
  _BOOL1 v18; // [esp+12h] [ebp-Eh]
  _BOOL1 v19; // [esp+13h] [ebp-Dh]
  char v20; // [esp+14h] [ebp-Ch]
  unsigned int v22; // [esp+1Ch] [ebp-4h]

  v1 = this;
  v18 = *(_BYTE *)(this + 109603) != 0;
  v19 = *(_BYTE *)(this + 109609) != 0;
  v2 = (_DWORD *)(this + 109982);
  v3 = 24;
  do
  {
    v4 = v2[1];
    if ( v4 == 10 && *v2 )
    {
      v18 = 1;
    }
    else if ( v4 == 16 && *v2 )
    {
      v19 = 1;
    }
    v2 += 6;
    --v3;
  }
  while ( v3 );
  v5 = 0;
  v22 = 0;
  do
  {
    v6 = v5 & 0x1F;
    v7 = ((v5 >> 5) & 3) + 1;
    v20 = 0;
    v8 = 1;
    v9 = (_DWORD *)(v1 + 108322);
    do
    {
      if ( v6 > 2 )
      {
        if ( v6 > 4 )
        {
          switch ( v6 )
          {
            case 5u:
              if ( *((_BYTE *)v9 - 15) || *((_BYTE *)v9 - 8) )
                goto LABEL_42;
              break;
            case 6u:
              if ( *((_BYTE *)v9 - 13) || *((_BYTE *)v9 - 3) )
                goto LABEL_42;
              break;
            case 7u:
              if ( *((_BYTE *)v9 - 14) || *((_BYTE *)v9 - 7) )
                goto LABEL_42;
              break;
            default:
              if ( v6 == 8 && (*((_BYTE *)v9 - 12) || *((_BYTE *)v9 - 4)) )
                goto LABEL_42;
              break;
          }
        }
        else
        {
          v12 = *v9;
          if ( (*v9 & 0xC00000u) < ((*v9 >> 2) & 0xC00000u) )
            v13 = HIBYTE(v12);
          else
            v13 = v12 >> 22;
          v1 = this;
          if ( v7 <= (v13 & 3) + (*(_BYTE *)(this + 109583) != 0) && (v6 == 3 || v19) )
          {
LABEL_42:
            v20 |= v8;
            goto LABEL_43;
          }
        }
      }
      else
      {
        v10 = *v9;
        if ( (*v9 & 0xC0000u) < ((*v9 >> 2) & 0xC0000u) )
          v11 = v10 >> 20;
        else
          v11 = v10 >> 18;
        v1 = this;
        if ( v7 <= (v11 & 3) + (*(_BYTE *)(this + 109582) != 0) && (v6 == 1 || v18) )
          goto LABEL_42;
      }
LABEL_43:
      v8 *= 2;
      v9 += 36;
    }
    while ( v8 <= 0x80 );
    *(_BYTE *)(v22 + v1 + 120983) = v20;
    v5 = v22 + 1;
    v22 = v5;
  }
  while ( v5 < 0x80 );
  memset((void *)(v1 + 120839), 0, 0x90u);
  v14 = (_DWORD *)(v1 + 108322);
  result = (_DWORD *)(v1 + 120839);
  v16 = 8;
  do
  {
    if ( !v18 )
      result[1] |= 0x80u;
    if ( !*((_BYTE *)v14 - 16) )
      result[1] |= 0x8000u;
    *result = (*v14 & 0x1F) << 10;
    result[2] = 64;
    if ( (*v14 & 0x3000) == 0 )
      result[2] = 65;
    if ( (*v14 & 0xC00) == 0 )
      result[2] |= 2u;
    if ( (*v14 & 0xC000) == 0 )
      result[2] |= 4u;
    if ( (*v14 & 0x30000) == 0 )
      result[2] |= 8u;
    v17 = 10 * *((__int16 *)v14 - 20) - dword_101A5340;
    v14 += 36;
    result[3] = v17;
    result += 4;
    --v16;
  }
  while ( v16 );
  return result;
}
// 101A5340: using guessed type int dword_101A5340;

//----- (10012520) --------------------------------------------------------
unsigned int __thiscall sub_10012520(int this)
{
  int *v2; // ecx
  int v3; // edx
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int result; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edi
  int *v10; // ebx
  int v11; // esi
  int v12; // [esp+10h] [ebp-324h]
  int v13[200]; // [esp+14h] [ebp-320h] BYREF

  memset(v13, 0, sizeof(v13));
  if ( *(int *)(this + 65292) > 0 )
  {
    v2 = (int *)(this + 64288);
    v3 = *(_DWORD *)(this + 65292);
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        if ( *(_DWORD *)(v4 + 275) != 8 )
        {
          v5 = *(_DWORD *)(v4 + 279);
          if ( v5 < 0xC8 )
            ++v13[v5];
        }
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v6 = *(_DWORD *)(this + 109378);
  v12 = 1000000;
  if ( v6 )
    result = sub_100174D1() % v6;
  else
    result = 0;
  v8 = 0;
  v9 = 10000;
  v10 = v13;
  do
  {
    if ( v8 >= *(_DWORD *)(this + 109378) )
      break;
    v11 = *v10;
    if ( *v10 < *(unsigned __int8 *)(this + 109567) )
    {
      if ( v8 >= *(_DWORD *)(this + 109706) )
        v11 += v9;
      if ( v11 < v12 )
      {
        v12 = v11;
        result = v8;
      }
    }
    v9 += 100;
    ++v8;
    ++v10;
  }
  while ( v9 < 0x7530 );
  return result;
}
// 10012520: using guessed type int var_320[200];

//----- (100125F0) --------------------------------------------------------
unsigned int __thiscall sub_100125F0(int ap)
{
  void *v2; // ecx
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  _BYTE *v6; // edx
  unsigned int result; // eax
  _DWORD v8[4]; // [esp+0h] [ebp-28h] BYREF
  int v9; // [esp+10h] [ebp-18h] BYREF
  int v10[2]; // [esp+14h] [ebp-14h] BYREF
  int v11; // [esp+24h] [ebp-4h]

  v2 = *(void **)(ap + 28);
  v10[1] = (int)v8;
  v8[3] = ap;
  if ( v2 )
  {
    sub_10012DA0(v2);
    sub_10002D70(*(_DWORD *)(ap + 28));
    *(_DWORD *)(ap + 28) = 0;
  }
  *(_DWORD *)(ap + 20) = 0;
  *(_DWORD *)(ap + 28) = 0;
  *(_DWORD *)(ap + 24) = 0;
  v11 = 0;
  off_10024608("Ext: Loading level file: %s\n", (const char *)ap);
  v10[0] = -1;
  LOBYTE(v11) = 1;
  ReadScrty1File(v10, (char *)ap, 1, 3);
  v3 = sub_10001D90(v10);
  *(_DWORD *)(ap + 20) = v3 + 17;
  v4 = sub_10002CC0(v3 + 17);
  v5 = v4 + 17;
  *(_DWORD *)(ap + 28) = v4;
  ReadScrty1FileOffset(v10, v4 + 17, v3);
  v9 = -1;
  sub_100010E0(&v9, v5, v3);
  *(_DWORD *)(ap + 16) = ~v9;
  *(_DWORD *)(ap + 24) = sub_10002090(v10);
  sub_10001A50(v10);
  v6 = *(_BYTE **)(ap + 28);
  result = strlen((const char *)ap) + 1;
  qmemcpy(v6 + 1, (const void *)ap, result);
  *v6 = 42;
  return result;
}

//----- (10012750) --------------------------------------------------------
PLAYER *__thiscall CtmPlayerJustConnected(PLAYER *p)
{
  PLAYER *v1; // ebx
  char *v2; // esi
  const CHAR *v3; // ebp
  int v4; // eax
  int (*v5)(void); // esi
  bool v6; // eax
  char *v7; // esi
  int v8; // eax
  signed int *v9; // edi
  void *v10; // ecx
  char *v11; // eax
  signed int *v12; // ebx
  void *v13; // ecx
  int v14; // edi
  char *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  char *v18; // edi
  const char *v19; // ebp
  int v20; // eax
  int v21; // esi
  int v22; // edi
  int v23; // edx
  _DWORD *v24; // esi
  unsigned __int8 *v25; // edx
  unsigned int v26; // ecx
  int v27; // esi
  unsigned __int8 v28; // al
  int v30; // [esp-Ch] [ebp-1D8h]
  const CHAR *v31; // [esp-8h] [ebp-1D4h]
  const char *v32; // [esp-4h] [ebp-1D0h]
  int v33; // [esp+4h] [ebp-1C8h]
  int v34; // [esp+8h] [ebp-1C4h]
  int v35; // [esp+8h] [ebp-1C4h]
  char *v36; // [esp+Ch] [ebp-1C0h]
  unsigned __int8 v37; // [esp+10h] [ebp-1BCh]
  int v38[2]; // [esp+14h] [ebp-1B8h] BYREF
  const char *KeyName; // [esp+1Ch] [ebp-1B0h] BYREF
  const char *v40; // [esp+20h] [ebp-1ACh]
  int v41; // [esp+24h] [ebp-1A8h] BYREF
  const CHAR *v42; // [esp+28h] [ebp-1A4h]
  const char *v43; // [esp+2Ch] [ebp-1A0h]
  const char *v44; // [esp+30h] [ebp-19Ch]
  int v45; // [esp+34h] [ebp-198h]
  const CHAR *v46; // [esp+38h] [ebp-194h]
  int ReturnedString[2]; // [esp+3Ch] [ebp-190h] BYREF
  LPCSTR v48; // [esp+44h] [ebp-188h] BYREF
  LPCSTR v49; // [esp+48h] [ebp-184h]
  LPCSTR v50; // [esp+4Ch] [ebp-180h]
  LPSTR v51; // [esp+50h] [ebp-17Ch]
  DWORD v52; // [esp+54h] [ebp-178h]
  LPCSTR v53; // [esp+58h] [ebp-174h]
  const char *v54; // [esp+5Ch] [ebp-170h]
  const char *v55; // [esp+60h] [ebp-16Ch]
  int v56; // [esp+64h] [ebp-168h]
  const CHAR *v57; // [esp+68h] [ebp-164h]
  int v58; // [esp+7Ch] [ebp-150h]
  int v59; // [esp+80h] [ebp-14Ch]
  int v60; // [esp+84h] [ebp-148h]
  PLAYER *v61; // [esp+8Ch] [ebp-140h]

  v1 = p;
  v2 = &p[90].field_44[152];
  v3 = &p[83].field_18F[124];
  v61 = p;
  off_1002460C(&p[83].field_18F[124], &p[90].field_44[152]);
  if ( !v1[48].field_18F[65] || !dwCustom_ArenaMode )
    *(_DWORD *)&v1[83].field_341[458] = *(_DWORD *)v2;
  v4 = dword_1006507C;
  if ( !dword_1006507C )
  {
    v4 = FIX_DLL_KERNEL32_dll_GetTickCount(v58, v59, v60);
    dword_1006507C = v4;
  }
  v5 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
  *(_DWORD *)&v1[91].field_117[43] = v4;
  ++dword_1006507C;
  v57 = v3;
  v56 = 0;
  v55 = "SaveSpawnScore";
  v54 = "Misc";
  *(_DWORD *)&v1[90].field_44[144] = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(
                                       "Misc",
                                       "MaxPlayers",
                                       dwArena_ArenaMaxPlayers,
                                       v3);
  v6 = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(v54, v55, v56, v57) && v1[48].field_18F[65];
  v53 = v3;
  v52 = 159;
  v51 = &v1[90].field_44[156];
  v50 = byte_10028A9C;
  v49 = "GreetMessage";
  v48 = "Misc";
  *(_DWORD *)&v1[90].field_44[148] = v6;
  GetPrivateProfileStringA_0(v48, v49, v50, v51, v52, v53);
  v49 = v3;
  v48 = 0;
  ReturnedString[1] = (int)"MaxYRes";
  ReturnedString[0] = (int)"Misc";
  *(_DWORD *)&v1[91].field_44[104] = ((int (__cdecl *)(const char *, const char *, _DWORD, const CHAR *))v5)(
                                       "Misc",
                                       "MaxXRes",
                                       0,
                                       v3);
  v46 = v3;
  v45 = 0;
  v44 = "ContinuumOnly";
  v43 = "Misc";
  *(_DWORD *)&v1[91].field_44[108] = v5();
  v42 = v3;
  v41 = 0;
  v40 = "MinUsage";
  KeyName = "Misc";
  v1[91].field_117[29] = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(v43, v44, v45, v46) != 0;
  v38[1] = (int)v3;
  v38[0] = 0;
  *(_DWORD *)&v1[91].field_117[38] = 3600
                                   * ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(
                                       KeyName,
                                       v40,
                                       v41,
                                       v42);
  v34 = (int)v3;
  v32 = "Latency";
  *(_DWORD *)&v1[91].field_117[30] = ((int (__cdecl *)(const char *, const char *))v5)("Latency", "C2SNoDataAction");
  v31 = v3;
  v30 = 0;
  *(_DWORD *)&v1[91].field_117[34] = 10 * v5();
  v1[91].field_117[42] = ((int (__cdecl *)(const char *, const char *))v5)("Misc", "StartInSpec") != 0;
  v7 = &v1[90].player_name[9];
  memset(&v1[90].player_name[9], 0, 0x34Cu);
  v1[90].field_341[395] = 0;
  v8 = 0;
  do
  {
    sprintf_0((char *)&KeyName, "PeriodicMessage%d", v8);
    GetPrivateProfileStringA_0("Misc", (LPCSTR)&KeyName, byte_10028A9C, (LPSTR)ReturnedString, 0xFFu, v3);
    if ( LOBYTE(ReturnedString[0]) )
    {
      v9 = (signed int *)sub_10003260(ReturnedString);
      *(_DWORD *)(v7 + 161) = 60000 * atol_1(v10, v9);
      v11 = sub_10003240(v9);
      v12 = (signed int *)sub_10003260(v11);
      v14 = 60000 * atol_1(v13, v12);
      v15 = sub_10003240(v12);
      v16 = sub_10003260(v15);
      v17 = v16;
      v7[160] = *v16 == 42;
      if ( *v16 == 42 )
      {
        v17 = v16 + 1;
        v7[160] = 1;
      }
      else
      {
        v7[160] = 0;
      }
      *(_DWORD *)(v7 + 165) = v14 - *(_DWORD *)(v7 + 161) + FIX_DLL_KERNEL32_dll_GetTickCount(v30, v31, v32);
      strncpyt(v7, v17, 160);
      if ( *(_DWORD *)(v7 + 161) && *v7 )
        v7 += 169;
      v1 = 0;
    }
    v8 = ++v34;
  }
  while ( v34 < 5 );
  sub_100122C0((int)v1);
  memset(&v1[91].field_44[112], 0xFFu, 0x40u);
  GetPrivateProfileStringA_0("Misc", "LevelFiles", byte_10028A9C, (LPSTR)&v48, 0xFFu, v3);
  v35 = 0;
  if ( sub_10002E30(v38, 16, (int)&v48, 0x2Cu, 0) )
  {
    v18 = &v1[91].field_EA[10];
    v36 = &v1[91].field_EA[10];
    do
    {
      v19 = (const char *)v38;
      v37 = 0;
      if ( LOBYTE(v38[0]) == 43 )
      {
        v37 = 1;
        v19 = (char *)v38 + 1;
      }
      if ( *v19 )
      {
        v20 = dword_101A9508;
        v21 = 0;
        v33 = 0;
        if ( dword_101A9508 <= 0 )
          goto LABEL_30;
        while ( unknown_libname_69(v21 + dword_101A9500, v19) )
        {
          v20 = dword_101A9508;
          v21 += 32;
          if ( ++v33 >= dword_101A9508 )
            goto LABEL_30;
        }
        v20 = dword_101A9508;
        if ( v33 < dword_101A9508 )
        {
          v24 = (_DWORD *)(dword_101A9500 + 32 * v33);
          if ( sub_10002830(v24) != v24[6] )
            sub_100125F0((int)v24);
        }
        else
        {
LABEL_30:
          v22 = v20;
          if ( v20 >= dword_101A9504 )
          {
            sub_10002D10((int)&dword_101A9500, 32 * (v20 + 32));
            dword_101A9504 += 32;
            v20 = dword_101A9508;
          }
          memcpy_0(
            (void *)(dword_101A9500 + 32 * (v22 + 1)),
            (const void *)(32 * v22 + dword_101A9500),
            32 * (v20 + 0x7FFFFFF * v22));
          ++dword_101A9508;
          memcpy_0((void *)(32 * v22 + dword_101A9500), &v41, 0x20u);
          v23 = 32 * v22 + dword_101A9500;
          strcpy((char *)v23, v19);
          *(_DWORD *)(v23 + 20) = 0;
          *(_DWORD *)(v23 + 28) = 0;
          sub_100125F0(v23);
          v18 = v36;
        }
        *((_DWORD *)v18 - 16) = v33;
        *(_DWORD *)v18 = v37;
      }
      ++v35;
      v18 += 4;
      v36 = v18;
    }
    while ( sub_10002E30(v38, 16, (int)&v48, 0x2Cu, v35) );
  }
  v25 = *(unsigned __int8 **)&v1[90].field_44[140];
  v26 = -1;
  v27 = 0x100000;
  do
  {
    v28 = *v25;
    if ( *v25 && (v28 < 161u || v28 == 171) )
      v26 = dword_1002122C[*v25 ^ (unsigned __int8)v26] ^ (v26 >> 8);
    ++v25;
    --v27;
  }
  while ( v27 );
  *(_DWORD *)&v1[91].field_117[47] = v26;
  return v1;
}
// 10012938: variable 'v10' is possibly undefined
// 10012969: variable 'v13' is possibly undefined
// 100129B5: variable 'v30' is possibly undefined
// 100129B5: variable 'v31' is possibly undefined
// 100129B5: variable 'v32' is possibly undefined
// 4393A0: using guessed type int dwArena_ArenaMaxPlayers;
// 4D58B0: using guessed type int dwCustom_ArenaMode;
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
// 1002460C: using guessed type int (__cdecl *off_1002460C)(_DWORD, _DWORD);
// 1006507C: using guessed type int dword_1006507C;
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (10012C40) --------------------------------------------------------
void __thiscall sub_10012C40(void *this, int player)
{
  char *v3; // edi
  unsigned int v4; // ecx
  char v5; // al
  char *v6; // edi
  char *v7; // esi
  int v8; // eax
  int *v9; // ecx
  char *v10; // ebx
  int v11; // edx
  unsigned int v12; // ecx
  char v13; // al
  char *v14; // edi
  const void *v15; // esi
  int v16; // eax
  _BOOL1 v17; // cf
  int v18; // eax
  char v19[428]; // [esp+Ch] [ebp-1BCh] BYREF
  int v20; // [esp+1B8h] [ebp-10h]
  void *buf; // [esp+1BCh] [ebp-Ch]
  int v22; // [esp+1C0h] [ebp-8h]
  int buf_sz; // [esp+1C4h] [ebp-4h]

  memset(v19, 0, 0x1A8u);
  v19[424] = 0;
  v3 = (char *)this + 111086;
  v4 = strlen((const char *)this + 111086) + 1;
  v5 = v4;
  v4 >>= 2;
  qmemcpy(&v19[1], v3, 4 * v4);
  v7 = &v3[4 * v4];
  v6 = &v19[4 * v4 + 1];
  LOBYTE(v4) = v5;
  v8 = *(_DWORD *)((char *)this + 111614);
  qmemcpy(v6, v7, v4 & 3);
  *(_DWORD *)&v19[17] = *(_DWORD *)((char *)this + 111618);
  v9 = (int *)((char *)this + 121119);
  v22 = 25;
  *(_DWORD *)&v19[21] = v8;
  v20 = 0;
  v10 = &v19[41];
  buf_sz = (int)this + 121119;
  do
  {
    if ( *v9 < 0 )
      break;
    v11 = dword_101A9500 + 32 * *v9;
    if ( *(_BYTE *)(player + 1034) || !v9[16] )
    {
      v12 = strlen((const char *)v11) + 1;
      v13 = v12;
      v12 >>= 2;
      buf = v10 - 16;
      qmemcpy(v10 - 16, (const void *)v11, 4 * v12);
      v15 = (const void *)(v11 + 4 * v12);
      v14 = &v10[4 * v12 - 16];
      LOBYTE(v12) = v13;
      v16 = v22;
      qmemcpy(v14, v15, v12 & 3);
      *(_DWORD *)v10 = *(_DWORD *)(v11 + 16);
      v9 = (int *)buf_sz;
      *((_DWORD *)v10 + 1) = *(_DWORD *)(v11 + 20);
      v22 = v16 + 24;
    }
    ++v9;
    v10 += 24;
    v17 = (unsigned int)++v20 < 0x10;
    buf_sz = (int)v9;
  }
  while ( v17 );
  v18 = *(_DWORD *)(player + 100);
  v19[0] = 41;
  if ( v18 < 37 || v18 == 134 )
    buf_sz = 21;
  else
    buf_sz = v22;
  buf = v19;
  PlayerSendPacket((PLAYER *)player, v19, buf_sz, 1);
  if ( dwAdvertise_SendMode == 3 || dwAdvertise_SendMode == 1 )
    SendAdvertisement((struct PLAYER *)player, 1);
}
// 4327A0: using guessed type int dwAdvertise_SendMode;
// 101A9500: using guessed type int dword_101A9500;
// 10012C40: using guessed type char var_1BB[16];

//----- (10012DA0) --------------------------------------------------------
int __thiscall sub_10012DA0(void *this)
{
  int result; // eax
  int v2; // ebx
  int v3; // esi
  void **v4; // edi
  char *v5; // ebp
  _BOOL1 v6; // cc
  unsigned int v7; // [esp+0h] [ebp-10h]
  int *v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+8h] [ebp-8h]

  result = nPlayerArray2;
  v9 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v8 = PlayerArray2;
    do
    {
      v2 = 0;
      if ( *v8 )
      {
        v3 = *(_DWORD *)(*v8 + 40);
        if ( v3 )
        {
          if ( *(_DWORD *)(v3 + 3174) )
          {
            v7 = 0;
            v4 = (void **)(v3 + 3094);
            v5 = (char *)(v3 + 3114);
            do
            {
              if ( *v4 == this )
              {
                memcpy_0(v4, v5, 60 - v2);
                v2 -= 20;
                v5 -= 20;
                --*(_DWORD *)(v3 + 3174);
                --v7;
                v4 -= 5;
              }
              v2 += 20;
              v5 += 20;
              v4 += 5;
              ++v7;
            }
            while ( v7 < *(_DWORD *)(v3 + 3174) );
          }
        }
      }
      result = v9 + 1;
      v6 = ++v9 < nPlayerArray2;
      ++v8;
    }
    while ( v6 );
  }
  return result;
}
// 10012DEB: conditional instruction was optimized away because of 'eax.4!=0'
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;

//----- (10012E80) --------------------------------------------------------
int __stdcall sub_10012E80(void *a1)
{
  sub_10012DA0(a1);
  return off_10024618(a1);
}
// 10024618: using guessed type int (__cdecl *off_10024618)(_DWORD);

//----- (10012EA0) --------------------------------------------------------
// Player.JoinArena()
int __thiscall Fix_44(PLAYER *p)
{
  _BOOL1 v1; // zf
  int result; // eax
  char v3; // [esp+8h] [ebp-20h] BYREF
  __int16 v4; // [esp+9h] [ebp-1Fh]
  char v5[17]; // [esp+Bh] [ebp-1Dh] BYREF
  int buf_sz; // [esp+1Ch] [ebp-Ch]
  void *buf; // [esp+20h] [ebp-8h]
  PLAYER *player; // [esp+24h] [ebp-4h]

  v4 = p->field_14;
  v1 = p->dwClientVersion == 1;
  player = p;
  v3 = 1;
  if ( v1 && *(int *)&p->field_44[32] >= 37 )
  {
    strcpy(v5, (const char *)(p->lpCurrentArena + 64256));
    buf = &v3;
    result = PlayerSendPacket(player, &v3, strlen(v5) + 4, 1);
  }
  else
  {
    buf_sz = (int)&v3;
    result = PlayerSendPacket(player, &v3, 3, 1);
  }
  return result;
}

//----- (10012F40) --------------------------------------------------------
signed int __thiscall Fix_10(PLAYER *this)
{
  int v2; // eax
  int (*v3)(void); // ebx
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // cl
  char *v16; // eax
  int v17; // eax
  int v18; // edi
  __int16 v19; // ax
  int v20; // ecx
  signed int result; // eax
  char v22[256]; // [esp+Ch] [ebp-108h] BYREF
  char *msg; // [esp+10Ch] [ebp-8h]
  PLAYER *player; // [esp+110h] [ebp-4h]

  player = this;
  v2 = unknown_libname_69(this->player_name, "^banned");
  v3 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetTickCount;
  if ( v2 )
  {
    v5 = this->lpCurrentArena;
    if ( v5 )
    {
      v6 = *(_DWORD *)(v5 + 121111);
      if ( v6 <= 0 || (v7 = *(_DWORD *)(v5 + 121115), v7 <= 0) || this->dwXRes <= v6 && this->dwYRes <= v7 )
      {
        if ( (*(_BYTE *)(v5 + 121247) || byte_101A5389) && this->dwClientVersion != 1 )
        {
          v9 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
          *(_DWORD *)&this->field_341[52] = v9;
          *(_DWORD *)&this->field_341[197] = v9 + 5000;
          SetPlayerShip(player, 8);
          sprintf_0(
            v22,
            "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
          msg = v22;
          SendMessage(player, v22, 0);
        }
        else
        {
          v10 = *(_DWORD *)(v5 + 121256);
          if ( v10 && *(_DWORD *)&this->field_18F[120] < v10 && FindMeOut1 )
          {
            v11 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
            *(_DWORD *)&this->field_341[52] = v11;
            *(_DWORD *)&this->field_341[197] = v11 + 5000;
            SetPlayerShip(player, 8);
            sprintf_0(
              v22,
              "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
              *(_DWORD *)(this->lpCurrentArena + 121256) / 3600);
            msg = v22;
            SendMessage(player, v22, 0);
          }
          else if ( *(_BYTE *)(v5 + 121260) )
          {
            v12 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
            *(_DWORD *)&this->field_341[52] = v12;
            *(_DWORD *)&this->field_341[197] = v12 + 5000;
            SetPlayerShip(player, 8);
          }
        }
      }
      else
      {
        v8 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
        *(_DWORD *)&this->field_341[52] = v8;
        *(_DWORD *)&this->field_341[197] = v8 + 5000;
        SetPlayerShip(player, 8);
        sprintf_0(
          v22,
          "Maximum allowed screen resolution is %dx%d in this arena",
          *(_DWORD *)(this->lpCurrentArena + 121111),
          *(_DWORD *)(this->lpCurrentArena + 121115));
        msg = v22;
        SendMessage(player, v22, 0);
      }
    }
  }
  else
  {
    *(_DWORD *)&this->field_2B7[52] = 1;
    this->bIsSilenced = 1;
    v4 = v3();
    *(_DWORD *)&this->field_341[52] = v4;
    *(_DWORD *)&this->field_341[197] = v4 + 5000;
    SetPlayerShip(player, 8);
  }
  if ( this->field_341[180] )
    this->bWaveMessages = 1;
  v13 = v3();
  *(_DWORD *)&this->field_341[52] = v13;
  *(_DWORD *)&this->field_341[56] = v13 - 1000000;
  memset(&this->field_341[28], 0xFFu, 0x18u);
  memset(&this->field_341[462], 0xFFu, 0x18u);
  v14 = this->lpCurrentArena;
  if ( v14 )
  {
    v15 = *(_BYTE *)(v14 + 119834);
    v16 = (char *)(v14 + 119834);
    if ( v15 )
    {
      msg = v16;
      SendMessage(player, v16, 0);
    }
  }
  memset(&this->field_341[60], 0, 0x74u);
  *(_DWORD *)&this->field_341[176] = 0;
  v17 = this->lpCurrentArena;
  if ( v17 )
  {
    *(_DWORD *)&this->field_341[189] = *(_DWORD *)(v17 + 109874);
    v18 = dwMisc_KeepAliveDelay;
    *(_DWORD *)&this->field_341[181] = dwMisc_KeepAliveDelay;
    v19 = *(_WORD *)(v17 + 109544);
    if ( v19 > 200 )
    {
      v20 = v19 - 20;
      if ( v18 > v20 / 3 )
        *(_DWORD *)&this->field_341[181] = v20 / 3;
    }
  }
  *(_DWORD *)&this->field_341[197] = v3() + 15000;
  result = -1;
  *(_DWORD *)&this[1].field_117[11] = 0;
  *(_DWORD *)&this->field_44[16] = -1;
  *(_DWORD *)&this->field_44[12] = -1;
  return result;
}
// 10013033: conditional instruction was optimized away because of 'eax.4!=0'
// 100130A4: conditional instruction was optimized away because of 'eax.4!=0'
// 10013132: conditional instruction was optimized away because of 'eax.4!=0'
// 4B0618: using guessed type int dwMisc_KeepAliveDelay;
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 101A5389: using guessed type char byte_101A5389;

//----- (10013250) --------------------------------------------------------
int __thiscall sub_10013250(int this)
{
  PLAYER *v1; // ebx
  int result; // eax
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  __int16 *v7; // esi
  int v8; // edx
  unsigned __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // di
  __int16 v13; // dx
  int v14; // ebx
  char *v15; // edx
  unsigned __int16 v16; // cx
  int v17; // ecx
  char *v18; // ecx
  __int16 v19; // bx
  int v20; // edx
  unsigned __int16 v21; // cx
  unsigned int v22; // ecx
  int v23; // ecx
  int *v24; // esi
  unsigned __int16 v25; // ax
  unsigned __int16 v26; // ax
  __int16 v27; // cx
  __int16 v28; // di
  _WORD *v29; // ecx
  unsigned __int16 v30; // dx
  __int16 v31; // bx
  unsigned __int16 v32; // dx
  __int16 v33; // bx
  int v34; // edx
  int v35; // ebx
  char *v36; // edx
  unsigned __int16 v37; // cx
  int v38; // ecx
  int v39; // ecx
  unsigned int v40; // ecx
  char v41; // [esp+Ch] [ebp-DCh] BYREF
  char v42[95]; // [esp+Dh] [ebp-DBh] BYREF
  char v43; // [esp+6Ch] [ebp-7Ch] BYREF
  char v44[87]; // [esp+6Dh] [ebp-7Bh] BYREF
  char *v45; // [esp+C4h] [ebp-24h]
  int v46; // [esp+C8h] [ebp-20h]
  int v47; // [esp+CCh] [ebp-1Ch]
  int v48; // [esp+D0h] [ebp-18h]
  char *v49; // [esp+D4h] [ebp-14h]
  PLAYER *player; // [esp+D8h] [ebp-10h]
  void *buf; // [esp+DCh] [ebp-Ch]
  char v52; // [esp+E3h] [ebp-5h]
  int buf_sz; // [esp+E4h] [ebp-4h]

  v1 = (PLAYER *)this;
  result = *(_DWORD *)(this + 1619);
  v3 = 0;
  player = (PLAYER *)this;
  if ( result )
  {
    v4 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
    v5 = *(_DWORD *)&v1[1].field_117[11];
    v6 = v4 / 1024;
    result = 0;
    v52 = v6;
    v47 = 0;
    v48 = 0;
    v46 = 0;
    if ( v5 )
    {
      v49 = v42;
      v45 = v44;
      v7 = &v1[1].field_14;
      while ( 1 )
      {
        if ( *((_BYTE *)v7 - 13) == 5 )
        {
          if ( (v7[3] & 0x1F) != 0 )
          {
            ++*(_DWORD *)&v1->field_117[8];
            v8 = *((unsigned __int8 *)v7 - 14);
            buf = (char *)v7 - 13;
            buf_sz = v8;
            PlayerSendPacket(player, (char *)v7 - 13, v8, 0);
          }
          else if ( (*(_BYTE *)v7 & 0x40) == 0
                 && (v9 = *(__int16 *)((char *)v7 - 9), buf = (void *)v9, v9 <= 0x3FFFu)
                 && (v10 = v7[1], (unsigned __int16)v10 <= 0x3FFFu)
                 && (v11 = *(__int16 *)((char *)v7 - 3), v11 <= 0x1FFF)
                 && v11 >= -8191
                 && (v12 = *(__int16 *)((char *)v7 - 7), v12 <= 0x1FFF)
                 && v12 >= -8191
                 && v1[1].field_117[15]
                 && *((_BYTE *)v7 - 14) == 21
                 && (buf_sz = *(unsigned __int16 *)((char *)v7 - 5), v1[1].field_117[buf_sz + 16] == (_BYTE)v6) )
          {
            v13 = buf_sz;
            if ( (unsigned __int16)buf_sz > 0xFFu || *(_BYTE *)v7 )
            {
              v18 = v49;
              ++v47;
              v49 += 11;
              buf_sz = *(unsigned __int16 *)v18;
              *(_WORD *)v18 = (*(unsigned __int8 *)v7 << 10) | v13 & 0x3FF;
              v19 = *(__int16 *)((char *)v7 - 11);
              buf_sz = *((unsigned __int16 *)v18 + 1);
              v20 = *(__int16 *)((char *)v7 - 3);
              *((_WORD *)v18 + 1) = ((*(_BYTE *)(v7 - 6) & 0x3F) << 10) | (v19 - *((unsigned __int8 *)v7 + 1)) & 0x3FF;
              v1 = player;
              *((_DWORD *)v18 + 1) = (unsigned __int16)buf & 0x3FFF | (((v20 << 14) | v10 & 0x3FFF) << 14);
              v18[10] = v20 >> 6;
              *((_WORD *)v18 + 4) = v12 & 0x3FFF ^ ((unsigned __int16)(v20 >> 4) << 14);
            }
            else
            {
              v14 = v48;
              v15 = v45;
              v45 += 10;
              *v15 = *((_BYTE *)v7 - 5);
              v16 = *(_WORD *)(v15 + 1);
              v48 = v14 + 1;
              LOWORD(v14) = *(__int16 *)((char *)v7 - 11);
              buf_sz = v16;
              v17 = *(__int16 *)((char *)v7 - 3);
              *(_WORD *)(v15 + 1) = ((*(_BYTE *)(v7 - 6) & 0x3F) << 10) | (v14 - *((unsigned __int8 *)v7 + 1)) & 0x3FF;
              v1 = player;
              *(_DWORD *)(v15 + 3) = (unsigned __int16)buf & 0x3FFF | (((v17 << 14) | v10 & 0x3FFF) << 14);
              v15[9] = v17 >> 6;
              *(_WORD *)(v15 + 7) = v12 & 0x3FFF ^ ((unsigned __int16)(v17 >> 4) << 14);
            }
          }
          else
          {
            v21 = *(__int16 *)((char *)v7 - 5);
            buf_sz = (int)v7 - 13;
            v1[1].field_117[v21 + 16] = v6;
            buf = (void *)*((unsigned __int8 *)v7 - 14);
            PlayerSendPacket(player, (void *)buf_sz, (int)buf, 0);
          }
        }
        v22 = *(_DWORD *)&v1[1].field_117[11];
        v7 += 18;
        if ( ++v46 >= v22 )
          break;
        LOBYTE(v6) = v52;
      }
      v3 = v47;
      LOBYTE(v6) = v52;
      result = v48;
    }
    v23 = *(_DWORD *)&v1[1].field_117[11];
    v46 = 0;
    if ( v23 )
    {
      v45 = &v44[10 * result];
      buf = &v42[10 * v3 + v3];
      v24 = &v1[1].connection_id;
      while ( 1 )
      {
        if ( *((_BYTE *)v24 - 9) == 40 )
        {
          if ( (*(_BYTE *)v24 & 0x40) == 0
            && (v25 = *(_WORD *)((char *)v24 - 5), v49 = (char *)v25, v25 <= 0x3FFFu)
            && (v26 = *(_WORD *)((char *)v24 + 3), v26 <= 0x3FFFu)
            && (v27 = *(_WORD *)((char *)v24 + 5), v27 <= 0x1FFF)
            && v27 >= -8191
            && (v28 = *(_WORD *)((char *)v24 + 1), v28 <= 0x1FFF)
            && v28 >= -8191
            && v1[1].field_117[15]
            && *((_BYTE *)v24 - 10) == 16
            && v1[1].field_117[*((unsigned __int8 *)v24 - 1) + 16] == (_BYTE)v6 )
          {
            if ( *(_BYTE *)v24 )
            {
              v29 = buf;
              ++v47;
              v30 = *(_WORD *)buf;
              buf = (char *)buf + 11;
              v31 = *((unsigned __int8 *)v24 - 1);
              buf_sz = v30;
              v32 = v29[1];
              *v29 = (*(unsigned __int8 *)v24 << 10) | v31 & 0x3FF;
              v33 = *(_WORD *)((char *)v24 - 7);
              buf_sz = v32;
              v34 = *(__int16 *)((char *)v24 + 5);
              v29[1] = ((*(_BYTE *)(v24 - 2) & 0x3F) << 10) | (v33 - *((unsigned __int8 *)v24 - 3)) & 0x3FF;
              v1 = player;
              *((_DWORD *)v29 + 1) = (unsigned __int16)v49 & 0x3FFF | (((v34 << 14) | v26 & 0x3FFF) << 14);
              *((_BYTE *)v29 + 10) = v34 >> 6;
              v29[4] = v28 & 0x3FFF ^ ((unsigned __int16)(v34 >> 4) << 14);
            }
            else
            {
              v35 = v48;
              v36 = v45;
              v45 += 10;
              *v36 = *((_BYTE *)v24 - 1);
              v37 = *(_WORD *)(v36 + 1);
              v48 = v35 + 1;
              LOWORD(v35) = *(_WORD *)((char *)v24 - 7);
              buf_sz = v37;
              v38 = *(__int16 *)((char *)v24 + 5);
              *(_WORD *)(v36 + 1) = ((*(_BYTE *)(v24 - 2) & 0x3F) << 10) | (v35 - *((unsigned __int8 *)v24 - 3)) & 0x3FF;
              v1 = player;
              *(_DWORD *)(v36 + 3) = (unsigned __int16)v49 & 0x3FFF | (((v38 << 14) | v26 & 0x3FFF) << 14);
              v36[9] = v38 >> 6;
              *(_WORD *)(v36 + 7) = v28 & 0x3FFF ^ ((unsigned __int16)(v38 >> 4) << 14);
            }
          }
          else
          {
            v39 = *((unsigned __int8 *)v24 - 1);
            buf_sz = (int)v24 - 9;
            v1[1].field_117[v39 + 16] = v6;
            v49 = (char *)*((unsigned __int8 *)v24 - 10);
            PlayerSendPacket(player, (void *)buf_sz, (int)v49, 0);
          }
        }
        v40 = *(_DWORD *)&v1[1].field_117[11];
        v24 += 9;
        if ( ++v46 >= v40 )
          break;
        LOBYTE(v6) = v52;
      }
      v3 = v47;
      result = v48;
    }
    *(_DWORD *)&v1[1].field_117[11] = 0;
    if ( result )
    {
      v43 = 57;
      buf = (void *)(10 * result + 1);
      buf_sz = (int)&v43;
      result = PlayerSendPacket(player, &v43, (int)buf, 0);
    }
    if ( v3 )
    {
      v41 = 58;
      buf = (void *)(11 * v3 + 1);
      buf_sz = (int)&v41;
      result = PlayerSendPacket(player, &v41, (int)buf, 0);
    }
  }
  return result;
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10013250: using guessed type char var_DB[95];
// 10013250: using guessed type char var_7B[87];

//----- (100137F0) --------------------------------------------------------
void __thiscall sub_100137F0(int this)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // esi
  int v8; // ebx
  _BOOL1 v9; // zf
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // cl
  int v12[2]; // [esp+Ch] [ebp-20h]
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h]
  int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+20h] [ebp-Ch]
  int v17; // [esp+24h] [ebp-8h]
  char v18; // [esp+2Bh] [ebp-1h]

  if ( *(_DWORD *)(this + 1619) )
  {
    v2 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
    v3 = *(_DWORD *)(this + 1619);
    v14 = v2;
    v18 = 0;
    LOWORD(v12[0]) = 0;
    BYTE2(v12[0]) = 0;
    v15 = 0;
    if ( v3 )
    {
      v4 = this + 1336;
      v17 = this + 1336;
      v16 = v3;
      do
      {
        v13 = v14 - *(_DWORD *)(v4 - 5);
        if ( v13 >= dword_101A5368[0] )
        {
          if ( *(_BYTE *)v4 == 5 )
            v5 = *(__int16 *)(v4 + 15);
          else
            v5 = *(__int16 *)(v4 + 12);
          v6 = abs32(*(__int16 *)(this + 232) - *(__int16 *)(v4 + 4));
          v7 = abs32(*(__int16 *)(this + 228) - v5);
          v8 = 0;
          if ( v6 >= *(_DWORD *)(this + 619) / 2 + 32 || v7 >= *(_DWORD *)(this + 623) / 2 + 32 )
          {
            v8 = 2;
          }
          else
          {
            if ( v6 > v7 )
              v6 = v7;
            if ( v6 > dword_101A5374 )
              v8 = 1;
          }
          if ( v13 >= dword_101A5368[v8] )
          {
            v18 = 1;
            v15 = v8;
          }
          ++*((_BYTE *)v12 + v8);
          v4 = v17;
        }
        v4 += 36;
        v9 = v16 == 1;
        v17 = v4;
        --v16;
      }
      while ( !v9 );
      if ( v18 )
      {
        v10 = BYTE1(v12[0]);
        v11 = v12[0];
        ++dword_100292F0[v15];
        dword_101B3040 += v11;
        dword_101B3048 += BYTE2(v12[0]);
        dword_101B3044 += v10;
        sub_10013250(this);
        sub_41D6D0(*(_DWORD *)(this + 40));
      }
    }
  }
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100292F0: using guessed type int dword_100292F0[];
// 101A5374: using guessed type int dword_101A5374;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;

//----- (10013980) --------------------------------------------------------
void __thiscall sub_10013980(int this, const void *buf, size_t buf_sz, int a4)
{
  int v4; // esi
  int v5; // eax
  unsigned int v6; // eax

  v4 = this;
  if ( !*(_DWORD *)(this + 777) && *(_DWORD *)(this + 28) )
  {
    v5 = *(unsigned __int8 *)buf;
    if ( (v5 == 5 || v5 == 40) && buf_sz <= 0x1F && (v6 = *(_DWORD *)(this + 1619), v6 < 8) && dword_101A5378 )
    {
      memcpy_0((void *)(this + 36 * v6 + 1336), buf, buf_sz);
      *(_BYTE *)(v4 + 36 * *(_DWORD *)(v4 + 1619) + 1335) = buf_sz;
      *(_DWORD *)(v4 + 36 * (*(_DWORD *)(v4 + 1619))++ + 1331) = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
      sub_100137F0(v4);
    }
    else
    {
      sub_10013250(this);
      PlayerSendPacket((PLAYER *)this, (void *)buf, buf_sz, 0);
      if ( dword_101A5378 )
        sub_41D6D0(*(_DWORD *)(v4 + 40));
      ++dword_100292FC;
    }
  }
}
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100292FC: using guessed type int dword_100292FC;
// 101A5378: using guessed type int dword_101A5378;

//----- (10013A70) --------------------------------------------------------
int __thiscall Fix_PlayerInit(int this)
{
  *(_DWORD *)(this + 1026) = 0;
  *(_DWORD *)(this + 2648) = 0;
  memset((void *)(this + 861), 0xFFu, 24u);
  memset((void *)(this + 1295), 0xFFu, 24u);
  *(_BYTE *)(this + 1013) = byte_101A5384;
  *(_DWORD *)(this + 1014) = dwMisc_KeepAliveDelay;
  *(_DWORD *)(this + 1018) = 0;
  *(_DWORD *)(this + 1035) = 0;
  *(_DWORD *)(this + 1022) = 2500;
  memset((void *)(this + 1039), 0, 128u);
  memset((void *)(this + 1167), 0, 128u);
  *(_DWORD *)(this + 1619) = 0;
  *(_BYTE *)(this + 1623) = 0;
  memset((void *)(this + 1624), 0, 1024u);
  return this;
}
// 4B0618: using guessed type int dwMisc_KeepAliveDelay;
// 101A5384: using guessed type char byte_101A5384;

//----- (10013B10) --------------------------------------------------------
int __cdecl sub_10013B10()
{
  int v0; // esi
  int v1; // edi
  int v2; // edx
  int *v3; // ecx
  int result; // eax
  int v5; // ebx
  _BOOL1 v6; // cc
  struct PLAYER **v7; // edi
  struct PLAYER *v8; // esi
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  const char *v13; // ecx
  int v14; // edi
  char **v15; // esi
  int v16; // edi
  char **v17; // esi
  int v18; // eax
  _BOOL1 v19; // cf
  int i; // ebx
  int v21; // esi
  char v22[256]; // [esp+Ch] [ebp-118h] BYREF
  int v23; // [esp+10Ch] [ebp-18h]
  int *v24; // [esp+110h] [ebp-14h]
  int v25; // [esp+114h] [ebp-10h]
  struct PLAYER *v26; // [esp+118h] [ebp-Ch]
  char *msg; // [esp+11Ch] [ebp-8h]
  const char *v28; // [esp+120h] [ebp-4h]

  v0 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  v1 = 0;
  v25 = v0;
  dword_101A5360 = v0 ^ (69069 * dword_101A5360 + 17009);
  if ( dword_101A5338 && (v0 - dword_101C8064 >= dword_101A5338 || !dword_101C8064) )
  {
    v2 = 0;
    if ( nPlayerArray2 > 0 )
    {
      v3 = PlayerArray2;
      do
      {
        if ( *v3 )
          *(_DWORD *)(*v3 + 751) = 0;
        ++v2;
        ++v3;
      }
      while ( v2 < nPlayerArray2 );
    }
    dword_101C8064 = v0;
  }
  result = dword_101C8068;
  if ( v0 - dword_101C8068 >= 30000 || !dword_101C8068 )
  {
    dword_101C8068 = v0;
    v23 = 0;
    if ( nArenas > 0 )
    {
      v24 = ArenaArray;
      do
      {
        v5 = *v24;
        if ( *v24 )
        {
          if ( *(_DWORD *)(v5 + 121111) || *(_DWORD *)(v5 + 121115) )
          {
            v6 = *(_DWORD *)(v5 + 65292) <= 0;
            v28 = 0;
            if ( !v6 )
            {
              v7 = (struct PLAYER **)(v5 + 64288);
              do
              {
                v8 = *v7;
                v26 = *v7;
                if ( v26 )
                {
                  if ( v25 - *(_DWORD *)&v8->field_341[52] >= 60000 )
                  {
                    v9 = v8->lpCurrentArena;
                    if ( v9 )
                    {
                      v10 = *(_DWORD *)(v9 + 121111);
                      if ( v10 > 0 )
                      {
                        v11 = *(_DWORD *)(v9 + 121115);
                        if ( v11 > 0 && (v8->dwXRes > v10 || v8->dwYRes > v11) && !v8->bIsSysop )
                        {
                          sprintf_0(
                            v22,
                            "Maximum allowed screen resolution is %dx%d in this arena",
                            *(_DWORD *)(v9 + 121111),
                            *(_DWORD *)(v9 + 121115));
                          msg = v22;
                          SendMessage(v26, v22, 0);
                          *(_DWORD *)&v8->field_2C[12] = 1;
                          v8->dwDisconnectReason = 38;
                          off_10024608("Ext: Played kicked off for exceeding res limit: %s\n", v8->player_name);
                        }
                      }
                    }
                  }
                }
                v12 = *(_DWORD *)(v5 + 65292);
                ++v7;
                ++v28;
              }
              while ( (int)v28 < v12 );
              v0 = v25;
            }
          }
          if ( *(_DWORD *)(v5 + 119830) != *(_DWORD *)(v5 + 111598) )
          {
            off_10024608("Ext: Re-reading %s\n", (const char *)(v5 + 110830));
            CtmPlayerJustConnected((PLAYER *)v5);
          }
          v13 = (const char *)(v5 + 119994);
          v28 = (const char *)(v5 + 119994);
          v26 = 0;
          do
          {
            if ( !*v13 )
              break;
            if ( v0 - *(_DWORD *)(v13 + 165) >= *(_DWORD *)(v13 + 161) )
            {
              if ( v13[160] )
              {
                v14 = 0;
                if ( nPlayerArray2 > 0 )
                {
                  v15 = (char **)PlayerArray2;
                  do
                  {
                    msg = *v15;
                    if ( msg )
                    {
                      SendMessage((struct PLAYER *)msg, v28, 0);
                      v13 = v28;
                    }
                    ++v14;
                    ++v15;
                  }
                  while ( v14 < nPlayerArray2 );
                }
              }
              else
              {
                v16 = 0;
                if ( *(int *)(v5 + 65292) > 0 )
                {
                  v17 = (char **)(v5 + 64288);
                  do
                  {
                    msg = *v17;
                    if ( msg )
                    {
                      SendMessage((struct PLAYER *)msg, v28, 0);
                      v13 = v28;
                    }
                    ++v16;
                    ++v17;
                  }
                  while ( v16 < *(_DWORD *)(v5 + 65292) );
                }
              }
              v18 = v25;
              *(_DWORD *)(v13 + 165) = v25;
              v0 = v18;
            }
            v13 += 169;
            v19 = (unsigned int)&v26->hProcess + 1 < 5;
            v26 = (struct PLAYER *)((char *)v26 + 1);
            v28 = v13;
          }
          while ( v19 );
          v1 = 0;
        }
        v6 = ++v23 < nArenas;
        ++v24;
      }
      while ( v6 );
    }
    result = dword_101A9508;
    for ( i = 0; i < dword_101A9508; v1 += 32 )
    {
      v21 = v1 + dword_101A9500;
      if ( sub_10002830((void *)(v1 + dword_101A9500)) != *(_DWORD *)(v21 + 24) )
        sub_100125F0(v21);
      result = dword_101A9508;
      ++i;
    }
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 101A5338: using guessed type int dword_101A5338;
// 101A5360: using guessed type int dword_101A5360;
// 101A9500: using guessed type int dword_101A9500;
// 101A9508: using guessed type int dword_101A9508;
// 101C8064: using guessed type int dword_101C8064;
// 101C8068: using guessed type int dword_101C8068;

//----- (10013E40) --------------------------------------------------------
void __cdecl BillingServerRecievedPacket(char *player, int classptr)
{
  char packetId; // al
  int v3; // edx
  int *i; // ecx
  char v5; // al
  int v6; // ebx
  char *v7; // esi
  unsigned int v8; // kr04_4
  unsigned int v9; // ecx
  int v10; // edi
  char *v11; // esi
  char v12; // dl
  int v13; // edi
  struct ARENA **v14; // esi
  struct ARENA *v15; // eax
  int v16; // edx
  int *v17; // ecx
  int v18; // eax
  int v19; // edi
  PLAYER **v20; // esi
  PLAYER *v21; // eax
  int v22; // ecx
  size_t v23; // esi
  int v24; // edx
  int *v25; // ecx
  _DWORD *v26; // eax
  _BYTE v27[5]; // [esp+Ch] [ebp-10Ch] BYREF
  char v28; // [esp+11h] [ebp-107h]
  char dst[250]; // [esp+12h] [ebp-106h] BYREF
  void *buf; // [esp+10Ch] [ebp-Ch]
  _DWORD buf_sz[2]; // [esp+110h] [ebp-8h] BYREF
  const char *playera; // [esp+120h] [ebp+8h]
  void *classptra; // [esp+124h] [ebp+Ch]

  packetId = *player;
  if ( *player == 9 )
  {
    v3 = 0;
    if ( nPlayerArray2 > 0 )
    {
      for ( i = PlayerArray2; !*i || *(_DWORD *)(*i + 16) != *(_DWORD *)(player + 1); ++i )
      {
        if ( ++v3 >= nPlayerArray2 )
          return;
      }
      v5 = player[5];
      v6 = (int)(player + 5);
      classptra = (void *)v3;
      playera = player + 5;
      if ( v5 == 36 )
      {
        if ( !memcmp((const void *)v6, &unk_101A52F4, 0xBu) )
        {
          v6 += 3;
          playera = (const char *)v6;
          memcpy_0((void *)v6, "(local) ", 8u);
          v3 = (int)classptra;
        }
        if ( !memcmp((const void *)v6, &unk_101A5314, 0xBu) )
        {
          playera = (const char *)(v6 + 3);
          memcpy_0((void *)(v6 + 3), "(staff) ", 8u);
          v3 = (int)classptra;
        }
      }
      SendMessage((struct PLAYER *)PlayerArray2[v3], playera, 0);
    }
  }
  else
  {
    switch ( packetId )
    {
      case '4':                                 // BILLER SERVER SENT USER_MCHANNEL_CHAT
        v7 = &player[4 * (unsigned __int8)player[1] + 2 + (unsigned __int8)player[1]];
        if ( 5 * (unsigned __int8)player[1] + 2 < classptr )
        {
          if ( memchr(v7, 0, classptr + player - v7) )
          {
            v27[0] = 10;
            strncpyt(dst, v7, 250);
            v8 = strlen(dst) + 1;
            v9 = v8 + 6;
            v10 = 0;
            if ( player[1] )
            {
              v11 = player + 6;
              while ( 1 )
              {
                v12 = *v11;
                *(_DWORD *)&v27[1] = *((_DWORD *)v11 - 1);
                v28 = v12;
                off_10024610(v27, v9);
                ++v10;
                v11 += 5;
                if ( v10 >= (unsigned __int8)player[1] )
                  break;
                v9 = v8 + 6;
              }
            }
          }
        }
        break;
      case '1':                                 // BILLING SERVER SENT SCORERESET
        if ( classptr == 9 && *(_DWORD *)(player + 1) == -*(_DWORD *)(player + 5) )
        {
          off_10024608("Ext: Scorereset request received from billing server\n");
          v13 = 0;
          if ( nArenas > 0 )
          {
            v14 = (struct ARENA **)ArenaArray;
            do
            {
              v15 = *v14;
              if ( *v14 && !v15->name[0] )
                ArenaScoreReset(v15, 1);
              ++v13;
              ++v14;
            }
            while ( v13 < nArenas );
          }
          v16 = 0;
          if ( nPlayerArray2 > 0 )
          {
            v17 = PlayerArray2;
            do
            {
              if ( *v17 )
              {
                v18 = *v17 + 589;
                *(_DWORD *)v18 = 0;
                *(_DWORD *)(v18 + 4) = 0;
                *(_DWORD *)(v18 + 8) = 0;
                *(_WORD *)(v18 + 12) = 0;
              }
              ++v16;
              ++v17;
            }
            while ( v16 < nPlayerArray2 );
          }
        }
        break;
      case '2':                                 // BILLING SERVER SENT USER_PACKET
        v19 = 0;
        if ( nPlayerArray2 > 0 )
        {
          v20 = (PLAYER **)PlayerArray2;
          do
          {
            v21 = *v20;
            if ( *v20 )
            {
              v22 = *(_DWORD *)(player + 1);
              if ( v22 == -1 || v21->connection_id == v22 )
              {
                buf_sz[0] = classptr - 5;
                buf = player + 5;
                PlayerSendPacket(v21, player + 5, classptr - 5, 1);
              }
            }
            ++v19;
            ++v20;
          }
          while ( v19 < nPlayerArray2 );
        }
        break;
      case '3':                                 // BILLING SERVER SENT BILLING IDENTITY
        if ( FindMeOut1 )
          *((_DWORD *)FindMeOut1 + 7) = 0;
        v23 = classptr - 1;
        if ( (unsigned int)(classptr - 1) >= 0x200 )
          v23 = 512;
        memcpy_0(&unk_101A9517, player + 1, v23);
        dword_101B0718 = v23 + 7;
        if ( byte_101B3054 && v23 >= 0x80 )
          memcpy_0(&unk_101A9517, &unk_10029270, 0x80u);
        LOBYTE(buf_sz[0]) = 21;
        *(_DWORD *)((char *)buf_sz + 1) = 3;
        WriteData(*((struct CONNECTION **)FindMeOut1 + 1), buf_sz, 5u, 1);
        break;
      default:
        if ( packetId == 1 && player[6] == 94 )
        {
          v24 = 0;
          if ( nPlayerArray2 > 0 )
          {
            v25 = PlayerArray2;
            do
            {
              v26 = (_DWORD *)*v25;
              if ( *v25
                && v26[4] == *(_DWORD *)(player + 2)
                && *(_DWORD *)((char *)v26 + 639)
                && !*(_DWORD *)((char *)v26 + 635) )
              {
                *(_DWORD *)((char *)v26 + 639) = 0;
              }
              ++v24;
              ++v25;
            }
            while ( v24 < nPlayerArray2 );
          }
        }
        off_10024610(player, classptr);
        break;
    }
  }
}
/* Orphan comments:
BILLING SERVER SENT USER_LOGIN
*/
// 4CA230: using guessed type int PlayerArray2[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 10024610: using guessed type int (__cdecl *off_10024610)(_DWORD, _DWORD);
// 101B0718: using guessed type int dword_101B0718;
// 101B3054: using guessed type char byte_101B3054;

//----- (10014200) --------------------------------------------------------
int __stdcall fix_1c(SOCKET s, char *buf, int a3, int flags, struct sockaddr *from, int *fromlen)
{
  int *v6; // eax
  _DWORD *v7; // ecx
  struct sockaddr *v8; // ebx
  char *v9; // esi
  int result; // eax
  char v11; // al
  int v12; // eax
  unsigned int v13; // edx
  int v14; // ecx
  char v15; // al
  char *v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  _DWORD **v19; // eax
  _DWORD *v20; // edi
  unsigned int v21; // eax
  int v22; // ecx
  unsigned int v23; // edx
  unsigned int v24; // eax
  unsigned int i; // esi
  unsigned int v26; // ecx
  int v27; // ecx
  unsigned __int8 v28; // dl
  unsigned int v29; // ecx
  unsigned int v30; // eax
  int v31; // edx
  unsigned int *v32; // eax
  _DWORD *v33; // eax
  int v34; // ecx
  int v35; // esi
  int v36; // edx
  _DWORD *v37; // eax
  _DWORD *v38; // eax
  _DWORD *v39; // esi
  int v40; // edx
  int v41; // ecx
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  int v44; // edi
  int v45; // ecx
  int v46; // edx
  int v47; // ecx
  unsigned int v48; // edi
  unsigned int v49; // ecx
  unsigned __int8 v50; // al
  _BOOL1 v51; // cc
  const char *v52; // ecx
  struct BILLING_SERVER_STRUCT *v53; // eax
  int v54; // ecx
  char *v55; // edi
  char v56; // al
  int v57; // ecx
  unsigned int v58; // esi
  int v59; // eax
  unsigned int v60; // edx
  __int16 v61; // cx
  unsigned int v62; // eax
  int *v63; // ecx
  unsigned int v64; // eax
  int *v65; // ecx
  unsigned int v66; // eax
  int v67; // esi
  int v68; // eax
  unsigned int v69; // ecx
  unsigned int v70; // eax
  char *v71; // ecx
  char *v72; // edi
  void *v73; // edi
  const void *v74; // edx
  char *v75; // edi
  int v76; // [esp-4h] [ebp-8Ch]
  int v77; // [esp-4h] [ebp-8Ch]
  int v78; // [esp-4h] [ebp-8Ch]
  int v79; // [esp+0h] [ebp-88h] BYREF
  int v80; // [esp+4h] [ebp-84h]
  int v81; // [esp+8h] [ebp-80h]
  char v82[64]; // [esp+Ch] [ebp-7Ch] BYREF
  char v83[2]; // [esp+4Ch] [ebp-3Ch] BYREF
  unsigned int v84; // [esp+4Eh] [ebp-3Ah]
  int v85; // [esp+52h] [ebp-36h]
  __int16 v86; // [esp+56h] [ebp-32h]
  char v87[2]; // [esp+58h] [ebp-30h] BYREF
  unsigned int v88; // [esp+5Ah] [ebp-2Eh]
  int v89; // [esp+5Eh] [ebp-2Ah]
  char v90[2]; // [esp+64h] [ebp-24h] BYREF
  unsigned int v91; // [esp+66h] [ebp-22h]
  int v92; // [esp+6Ch] [ebp-1Ch]
  int v93; // [esp+70h] [ebp-18h]
  int v94[2]; // [esp+74h] [ebp-14h] BYREF
  int v95; // [esp+84h] [ebp-4h]

  v94[1] = (int)&v79;
  if ( !byte_101B303C )
  {
    dword_1002930C = 0;
    dword_10029308 = 0;
    memset(dword_101A5398, 0, 0x4000u);
    byte_101B303C = 1;
    dword_10029310 = 20;
    v6 = (int *)&unk_101A9718;
    do
    {
      v7 = (int *)((char *)v6 + dword_10029310);
      *v7 = 0;
      v7[1] = dword_1002930C;
      if ( dword_1002930C )
        *(_DWORD *)(dword_10029310 + dword_1002930C) = v6;
      else
        dword_10029308 = (int)v6;
      dword_1002930C = (int)v6;
      v6 += 7;
    }
    while ( v6 < &dword_101B0718 );
    dword_101C806C = FIX_DLL_KERNEL32_dll_GetTickCount(v79, v80, v81) - 30000;
    dword_101B3050 = 0;
    dword_101A51A0 = 0;
    v95 = 1;
    v94[0] = -1;
    ReadScrty1File(v94, "scrty1", 1, 3);
    ReadScrty1FileOffset(v94, (int)&dword_101C8060, 4);
    ReadScrty1FileOffset(v94, (int)dword_10029318, 86016);
    dword_101A51A0 = 1;
    ReadScrty1FileOffset(v94, (int)dword_101B3060, 86016);
    dword_101B3050 = 1;
    sub_10001A50(v94);
    v95 = -1;
  }
  v8 = from;
  v9 = buf;
  result = recvfrom_0(s, buf, 2048, flags, from, fromlen);
  v93 = result;
  if ( result <= 0 )
    return result;
  while ( 1 )
  {
    if ( result > 7 && !*v9 && v9[1] == 1 && v9[6] == -1 )
    {
      sub_1000A860((int)dword_1003E438, (int)v9, result, *(_DWORD *)&v8->sa_data[2], *(unsigned __int16 *)v8->sa_data);
      goto LABEL_130;
    }
    if ( result > 512 )
      goto LABEL_130;
    LOBYTE(v94[0]) = !*v9 && ((v11 = v9[1], v11 == 1) || v11 == 6 || v11 == 17);
    v12 = FIX_DLL_KERNEL32_dll_GetTickCount(v79, v80, v81);
    v13 = *(_DWORD *)&v8->sa_data[2];
    v14 = v12;
    v92 = v12;
    HIBYTE(from) = 0;
    if ( v13 == dword_101A5344 )
    {
      v15 = *v9;
      if ( *v9 == 4 )
      {
        v16 = "Recycle request from billing server ignored";
      }
      else if ( v15 == 2 )
      {
        v16 = "Shutdown request from billing server ignored";
      }
      else
      {
        if ( v15 )
          goto LABEL_37;
        switch ( v9[1] )
        {
          case 7:
            v16 = "Disconnect request from billing server ignored";
            break;
          case 1:
            v16 = "Client connection request from billing server ignored";
            break;
          case 6:
            v16 = byte_10028A9C;
            break;
          default:
            goto LABEL_37;
        }
      }
      if ( v16 )
      {
        if ( v14 - dword_101C806C > 10000 )
        {
          if ( *v16 )
          {
            dword_101C806C = v14;
            sub_100151C0((int)v16, 0);
          }
        }
        goto LABEL_130;
      }
    }
LABEL_37:
    v17 = ((-25033 * (v13 ^ HIWORD(v13))) >> 5) & 0x7FF;
    v18 = dword_101A5398[2 * v17];
    if ( v18 != v13 )
    {
      while ( 1 )
      {
        if ( !v18 )
        {
          dword_101A9398 = 8 * v17 + 270160792;
          goto LABEL_42;
        }
        v17 = ((_WORD)v17 + 1) & 0x7FF;
        if ( v17 == (((-25033 * (v13 ^ HIWORD(v13))) >> 5) & 0x7FF) )
          break;
        v18 = dword_101A5398[2 * v17];
        if ( v18 == v13 )
          goto LABEL_41;
      }
      dword_101A9398 = 0;
LABEL_42:
      v20 = (_DWORD *)dword_1002930C;
      v21 = ((unsigned int)(-25033 * (*(_DWORD *)dword_1002930C ^ HIWORD(*(_DWORD *)dword_1002930C))) >> 5) & 0x7FF;
      v22 = dword_101A5398[2 * v21];
      if ( v22 == *(_DWORD *)dword_1002930C )
      {
LABEL_51:
        if ( 8 * v21 != -270160796 )
        {
          v23 = (int)(8 * v21 + 270160796 - (_DWORD)dword_101A5398 - 4) >> 3;
          v24 = ((_WORD)v23 + 1) & 0x7FF;
          dword_101A5398[2 * v23] = 0;
          for ( i = dword_101A5398[2 * v24]; i; i = dword_101A5398[2 * v24] )
          {
            v26 = ((-25033 * (i ^ HIWORD(i))) >> 5) & 0x7FF;
            if ( (v26 <= v23 || v26 > v24) && (v23 < v24 || v26 <= v23 && v26 > v24) )
            {
              dword_101A5398[2 * v23] = dword_101A5398[2 * v24];
              dword_101A539C[2 * v23] = dword_101A539C[2 * v24];
              v23 = v24;
              dword_101A5398[2 * v24] = 0;
            }
            v24 = ((_WORD)v24 + 1) & 0x7FF;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          if ( !v22 )
          {
            dword_101A9398 = 8 * v21 + 270160792;
            goto LABEL_60;
          }
          v21 = ((_WORD)v21 + 1) & 0x7FF;
          if ( v21 == (((unsigned int)(-25033 * (*(_DWORD *)dword_1002930C ^ HIWORD(*(_DWORD *)dword_1002930C))) >> 5) & 0x7FF) )
            break;
          v22 = dword_101A5398[2 * v21];
          if ( v22 == *(_DWORD *)dword_1002930C )
            goto LABEL_51;
        }
        dword_101A9398 = 0;
      }
LABEL_60:
      v27 = v92;
      *v20 = *(_DWORD *)&v8->sa_data[2];
      v28 = v94[0];
      *(_DWORD *)(dword_1002930C + 12) = v27;
      *(_DWORD *)(dword_1002930C + 4) = v28;
      *(_DWORD *)(dword_1002930C + 8) = 1;
      *(_DWORD *)(dword_1002930C + 16) = 0;
      v29 = *(_DWORD *)&v8->sa_data[2];
      v30 = ((-25033 * (v29 ^ HIWORD(v29))) >> 5) & 0x7FF;
      v31 = dword_101A5398[2 * v30];
      if ( v31 == v29 )
      {
LABEL_64:
        if ( 8 * v30 == -270160796 )
        {
          v32 = (unsigned int *)dword_101A9398;
LABEL_66:
          if ( v32 )
          {
            *v32 = v29;
            v33 = (_DWORD *)(dword_101A9398 + 4);
LABEL_71:
            *v33 = dword_1002930C;
            v34 = dword_1002930C;
            v35 = dword_10029310;
            v36 = *(_DWORD *)(dword_1002930C + dword_10029310 + 4);
            v37 = (_DWORD *)(dword_1002930C + dword_10029310);
            if ( v36 )
            {
              *(_DWORD *)(dword_10029310 + v36) = *v37;
              v35 = dword_10029310;
            }
            else
            {
              dword_10029308 = *v37;
            }
            if ( *v37 )
            {
              *(_DWORD *)(v35 + *v37 + 4) = v37[1];
              v35 = dword_10029310;
            }
            else
            {
              dword_1002930C = v37[1];
            }
            v38 = (_DWORD *)(v34 + v35);
            v38[1] = 0;
            *v38 = dword_10029308;
            if ( dword_10029308 )
              *(_DWORD *)(dword_10029310 + dword_10029308 + 4) = v34;
            else
              dword_1002930C = v34;
            dword_10029308 = v34;
            goto LABEL_108;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          if ( !v31 )
          {
            v32 = (unsigned int *)(8 * v30 + 270160792);
            dword_101A9398 = (int)v32;
            goto LABEL_66;
          }
          v30 = ((_WORD)v30 + 1) & 0x7FF;
          if ( v30 == (((-25033 * (v29 ^ HIWORD(*(_DWORD *)&v8->sa_data[2]))) >> 5) & 0x7FF) )
            break;
          v31 = dword_101A5398[2 * v30];
          if ( v31 == v29 )
            goto LABEL_64;
        }
        dword_101A9398 = 0;
      }
      v33 = 0;
      goto LABEL_71;
    }
LABEL_41:
    v19 = (_DWORD **)(8 * v17 + 270160796);
    if ( !v19 )
      goto LABEL_42;
    v39 = *v19;
    v40 = dword_10029310;
    v41 = *(_DWORD *)((char *)*v19 + dword_10029310 + 4);
    v42 = (_DWORD *)((char *)*v19 + dword_10029310);
    if ( v41 )
    {
      *(_DWORD *)(dword_10029310 + v41) = *v42;
      v40 = dword_10029310;
    }
    else
    {
      dword_10029308 = *v42;
    }
    if ( *v42 )
    {
      *(_DWORD *)(v40 + *v42 + 4) = v42[1];
      v40 = dword_10029310;
    }
    else
    {
      dword_1002930C = v42[1];
    }
    v43 = (_DWORD *)((char *)v39 + v40);
    v43[1] = 0;
    *v43 = dword_10029308;
    if ( dword_10029308 )
      *(_DWORD *)(dword_10029310 + dword_10029308 + 4) = v39;
    else
      dword_1002930C = (int)v39;
    dword_10029308 = (int)v39;
    v44 = v39[3];
    if ( v92 - v44 >= 60000 )
    {
      v45 = (v92 - v44) / 60000;
      v46 = v39[2] >> v45;
      v39[1] >>= v45;
      v39[2] = v46;
      v39[3] = v44 + 60000 * v45;
    }
    if ( buf[1] != 6 )
      v39[1] += LOBYTE(v94[0]);
    v47 = v39[2] + 1;
    v39[2] = v47;
    v48 = v47;
    v49 = v39[1];
    if ( v49 > 0x1E || v48 > 0x1388 )
    {
      v50 = v8->sa_data[2];
      if ( v50 != 127 && *v39 != dword_101A5350 )
      {
        HIBYTE(from) = dword_101A5344 != *v39;
        if ( (v49 > 0x32 || v48 > 0x1388) && !v39[4] )
        {
          v51 = v49 <= 0x14;
          v52 = "Connection";
          if ( v51 )
            v52 = "Packet";
          sprintf_0(
            v82,
            "WARNING: %s flood from %d.%d.%d.%d",
            v52,
            v50,
            (unsigned __int8)v8->sa_data[3],
            (unsigned __int8)v8->sa_data[4],
            (unsigned __int8)v8->sa_data[5]);
          sub_100151C0((int)v82, 0);
          v39[4] = 1;
        }
      }
    }
    if ( LOBYTE(v94[0]) && dwComms_EncryptMode == 2 && !*(_DWORD *)(buf + 2) || HIBYTE(from) )
      goto LABEL_130;
LABEL_108:
    if ( !LOBYTE(v94[0]) )
      return v93;
    v53 = FindMeOut1;
    if ( FindMeOut1 )
    {
      v54 = *((_DWORD *)FindMeOut1 + 7);
      if ( v54 && (unsigned int)(v92 - v54) > 0x3E8 )
      {
        *((_DWORD *)FindMeOut1 + 7) = 0;
        dword_101B0718 = 7;
      }
      if ( *((_DWORD *)v53 + 7) )
        goto LABEL_130;
    }
    v55 = buf;
    v56 = buf[1];
    if ( v56 == 1 )
    {
      v57 = dword_101A5360;
      v58 = 10 * dword_101B3058;
      *(int *)((char *)&dword_100651A0 + v58) = *(_DWORD *)&v8->sa_data[2];
      v59 = 69069 * v57 + 17009;
      v60 = dword_101B3058 | v59 & 0xFFFE0000;
      word_100651A8[v58 / 2] = HIWORD(v60);
      dword_101A5360 = v59;
      if ( v93 >= 8 )
      {
        v61 = *((_WORD *)v55 + 3);
        if ( v61 == 16 && dword_101A51A0 )
        {
          dword_101A5360 = 69069 * v59 + 17009;
          v62 = (unsigned int)(HIWORD(dword_101A5360) << 10) >> 16;
          v89 = 0;
          v88 = v60;
          v63 = fromlen;
          *(int *)((char *)&dword_100651A4 + v58) = v62;
          v76 = *v63;
          v89 = dword_10029318[21 * v62];
          v87[0] = 0;
          v87[1] = 16;
          j_FIX_DLL_WSOCK32_dll_ord_0014(s, v87, 10, 0, v8, v76);
LABEL_124:
          dword_101B3058 = (dword_101B3058 + 1) & 0x1FFFF;
          goto LABEL_130;
        }
        if ( v61 == 17 && dword_101B3050 )
        {
          dword_101A5360 = 69069 * v59 + 17009;
          v85 = 0;
          v64 = (unsigned int)(HIWORD(dword_101A5360) << 10) >> 16;
          v86 = 0;
          v84 = v60;
          v65 = fromlen;
          *(int *)((char *)&dword_100651A4 + v58) = v64;
          v77 = *v65;
          v85 = dword_101B3060[21 * v64];
          v83[0] = 0;
          v83[1] = 16;
          v86 = 1;
          j_FIX_DLL_WSOCK32_dll_ord_0014(s, v83, 12, 0, v8, v77);
          goto LABEL_124;
        }
      }
      v66 = *(_DWORD *)(v55 + 2);
      *(int *)((char *)&dword_100651A4 + v58) = v66;
      if ( v66 >= 0x400 )
      {
        v91 = v60;
        v78 = *fromlen;
        v90[0] = 0;
        v90[1] = 5;
        j_FIX_DLL_WSOCK32_dll_ord_0014(s, v90, 6, 0, v8, v78);
      }
      goto LABEL_124;
    }
    if ( v56 != 17 || !dword_101A51A0 )
      break;
    v67 = *(_DWORD *)(buf + 2);
    v68 = v67 & 0x1FFFF;
    v69 = 10 * (v67 & 0x1FFFF);
    if ( *(int *)((char *)&dword_100651A0 + v69) == *(_DWORD *)&v8->sa_data[2]
      && word_100651A8[v69 / 2] == HIWORD(v67)
      && *(unsigned int *)((char *)&dword_100651A4 + v69) < 0x400 )
    {
      v71 = buf;
      v51 = v93 < 8;
      buf[1] = 1;
      *(_DWORD *)(v71 + 2) = v67;
      v71[7] = 0;
      if ( !v51 && *((_WORD *)v71 + 3) && dword_101B3050 )
      {
        v72 = buf;
        buf[6] = 17;
        v73 = v72 + 8;
        v74 = (const void *)(84 * *(int *)((char *)&dword_100651A4 + 10 * v68) + 270217316);
      }
      else
      {
        v75 = buf;
        buf[6] = 16;
        v73 = v75 + 8;
        v74 = (const void *)(84 * *(int *)((char *)&dword_100651A4 + 10 * v68) + 268604188);
      }
      memcpy_0(v73, v74, 0x50u);
      unknown_libname_56(v73);
      ContinuumEncryptMD5Step3(&buf, v67);
      return 88;
    }
LABEL_130:
    v9 = buf;
    result = recvfrom_0(s, buf, 2048, flags, v8, fromlen);
    v93 = result;
    if ( result <= 0 )
      return result;
  }
  v70 = 10 * (*(_DWORD *)(buf + 2) & 0x1FFFF);
  if ( *(int *)((char *)&dword_100651A0 + v70) != *(_DWORD *)&v8->sa_data[2]
    || word_100651A8[v70 / 2] != HIWORD(*(_DWORD *)(buf + 2))
    || *(unsigned int *)((char *)&dword_100651A4 + v70) < 0x400 )
  {
    return v93;
  }
  *(int *)((char *)&dword_100651A0 + v70) = 0;
  v55[1] = 1;
  *(_DWORD *)(v55 + 2) = *(int *)((char *)&dword_100651A4 + v70);
  v55[6] = 1;
  v55[7] = 0;
  return 8;
}
// 100143FC: conditional instruction was optimized away because of 'al.1==0'
// 1001440D: conditional instruction was optimized away because of 'al.1==0'
// 439E10: using guessed type int dwComms_EncryptMode;
// 100087F0: using guessed type _DWORD __stdcall unknown_libname_56(_DWORD);
// 10015A02: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 10029308: using guessed type int dword_10029308;
// 1002930C: using guessed type int dword_1002930C;
// 10029310: using guessed type int dword_10029310;
// 100651A0: using guessed type int dword_100651A0;
// 100651A4: using guessed type int dword_100651A4;
// 100651A8: using guessed type __int16 word_100651A8[];
// 101A51A0: using guessed type int dword_101A51A0;
// 101A5344: using guessed type int dword_101A5344;
// 101A5350: using guessed type int dword_101A5350;
// 101A5360: using guessed type int dword_101A5360;
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;
// 101B0718: using guessed type int dword_101B0718;
// 101B303C: using guessed type char byte_101B303C;
// 101B3050: using guessed type int dword_101B3050;
// 101B3058: using guessed type int dword_101B3058;
// 101C8060: using guessed type int dword_101C8060;
// 101C806C: using guessed type int dword_101C806C;

//----- (10014C30) --------------------------------------------------------
int __fastcall sub_10014C30(unsigned int a1, int a2)
{
  int result; // eax
  int v3; // esi
  unsigned int v4; // esi

  result = ((-25033 * (a1 ^ HIWORD(a1))) >> 5) & 0x7FF;
  v3 = dword_101A5398[2 * result];
  if ( v3 == a1 )
  {
LABEL_5:
    result = 8 * result + 270160796;
    if ( result )
    {
      result = *(_DWORD *)result;
      v4 = a2 + *(_DWORD *)(result + 8);
      *(_DWORD *)(result + 8) = v4;
      if ( v4 > 0x1388 )
        *(_DWORD *)(result + 8) = 4 * v4;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( !v3 )
      {
        result = 8 * result + 270160792;
        dword_101A9398 = result;
        return result;
      }
      result = ((_WORD)result + 1) & 0x7FF;
      if ( result == (((-25033 * (a1 ^ HIWORD(a1))) >> 5) & 0x7FF) )
        break;
      v3 = dword_101A5398[2 * result];
      if ( v3 == a1 )
        goto LABEL_5;
    }
    dword_101A9398 = 0;
  }
  return result;
}
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;

//----- (10014CC0) --------------------------------------------------------
int __stdcall sub_10014CC0(int a1, int a2)
{
  int v2; // ecx
  unsigned int v3; // edx
  __int16 v4; // cx
  _BOOL1 v5; // dl
  __int16 v6; // ax
  int v7; // eax
  __int16 v8; // dx
  unsigned int v9; // edx
  unsigned int v10; // edi
  _DWORD *v11; // ebx
  __int16 v12; // ax
  int v13; // ecx
  __int16 v14; // dx
  _BOOL1 v15; // cc
  __int16 v16; // ax
  unsigned int v17; // edx
  const char **v18; // edi
  __int16 *v19; // esi
  char v20; // al
  __int16 v21; // cx
  int result; // eax
  char v23[32]; // [esp+Ch] [ebp-40h] BYREF
  const char *v24; // [esp+2Ch] [ebp-20h]
  const char *v25; // [esp+30h] [ebp-1Ch]
  const char *v26; // [esp+34h] [ebp-18h]
  char *v27; // [esp+38h] [ebp-14h]
  const char *v28; // [esp+3Ch] [ebp-10h]
  char *v29; // [esp+40h] [ebp-Ch]
  char *lpszKey; // [esp+44h] [ebp-8h]
  char *lpszSection; // [esp+48h] [ebp-4h]

  lpszKey = "HideFlags";
  lpszSection = "Spectator";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xFD | (2
                                                  * (GetCFGSettingInteger(
                                                       (struct struc_2 *)a2,
                                                       "Spectator",
                                                       "HideFlags",
                                                       0) & 1));
  lpszKey = "NoXRadar";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xFB | (4
                                                  * (GetCFGSettingInteger(
                                                       (struct struc_2 *)a2,
                                                       "Spectator",
                                                       "NoXRadar",
                                                       0) & 1));
  lpszKey = "ExactDamage";
  *(_BYTE *)(a1 + 1) ^= (GetCFGSettingInteger((struct struc_2 *)a2, "Bullet", "ExactDamage", 0) ^ *(_BYTE *)(a1 + 1)) & 1;
  lpszKey = "SlowFrameRate";
  v2 = GetCFGSettingInteger((struct struc_2 *)a2, "Misc", "SlowFrameRate", 0);
  if ( v2 > 35 )
    v2 = 35;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xC7 | (8 * ((v2 / 5) & 7));
  lpszKey = "MaxTimerDrift";
  if ( (unsigned int)GetCFGSettingInteger((struct struc_2 *)a2, "Misc", "MaxTimerDrift", 15) > 0x23 )
  {
    v3 = 35;
  }
  else
  {
    lpszKey = "MaxTimerDrift";
    v3 = GetCFGSettingInteger((struct struc_2 *)a2, "Misc", "MaxTimerDrift", 15);
  }
  v4 = *(_WORD *)(a1 + 2);
  lpszKey = "NegativeClientSlowPacketTime";
  *(_WORD *)(a1 + 2) = v4 ^ ((unsigned __int8)v4 ^ (unsigned __int8)(v3 / 5 - 1)) & 7;
  *(_BYTE *)(a1 + 1358) = GetCFGSettingInteger((struct struc_2 *)a2, "Latency", lpszKey, 0);
  lpszKey = "DisableWallPass";
  v5 = GetCFGSettingInteger((struct struc_2 *)a2, "Soccer", "DisableWallPass", 0) != 0;
  v6 = *(_WORD *)(a1 + 2);
  lpszKey = "DisableBallKilling";
  *(_WORD *)(a1 + 2) = v6 & 0xFFF7 | (8 * v5);
  v7 = GetCFGSettingInteger((struct struc_2 *)a2, "Soccer", lpszKey, 0);
  v8 = *(_WORD *)(a1 + 2);
  lpszKey = "AntiWarpSettleDelay";
  *(_WORD *)(a1 + 2) = v8 & 0xFFEF | (16 * (v7 != 0));
  v9 = GetCFGSettingInteger((struct struc_2 *)a2, "Misc", lpszKey, 0) / 10;
  if ( v9 >= 0xFF )
    LOBYTE(v9) = -1;
  *(_BYTE *)(a1 + 1392) = v9;
  lpszKey = "DisableScreenshot";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xBF | ((GetCFGSettingInteger(
                                                       (struct struc_2 *)a2,
                                                       "Misc",
                                                       "DisableScreenshot",
                                                       0) != 0) << 6);
  lpszKey = v23;
  v10 = 0;
  v29 = v23;
  lpszSection = "Spawn";
  v27 = v23;
  v28 = "Spawn";
  v11 = (_DWORD *)(a1 + 1236);
  do
  {
    sprintf_0(v23, "Team%d-X", v10);
    v26 = (const char *)GetCFGSettingInteger((struct struc_2 *)a2, "Spawn", lpszKey, 0);
    sprintf_0(v23, "Team%d-Y", v10);
    v25 = (const char *)GetCFGSettingInteger((struct struc_2 *)a2, lpszSection, v29, 0);
    sprintf_0(v23, "Team%d-Radius", v10);
    v24 = (const char *)GetCFGSettingInteger((struct struc_2 *)a2, v28, v27, 0);
    v12 = (__int16)v26;
    if ( (unsigned int)v26 > 0x3FF )
      v12 = 1023;
    v13 = *v11 ^ ((unsigned __int16)v12 ^ (unsigned __int16)*v11) & 0x3FF;
    v14 = (__int16)v25;
    v15 = (unsigned int)v25 <= 0x3FF;
    *v11 = v13;
    if ( !v15 )
      v14 = 1023;
    v16 = (__int16)v24;
    v17 = v13 & 0xFFF003FF | ((v14 & 0x3FF) << 10);
    v15 = (unsigned int)v24 <= 0x1FF;
    *v11 = v17;
    if ( !v15 )
      v16 = 511;
    *v11 = v17 & 0xFFFFF | ((v16 & 0x1FF) << 20);
    ++v10;
    ++v11;
  }
  while ( v10 < 4 );
  v24 = "SeeBombLevel";
  v25 = "DisableFastShooting";
  v26 = "Radius";
  v18 = (const char **)off_100246F8;
  v19 = (__int16 *)(a1 + 32);
  do
  {
    *v19 ^= ((unsigned __int8)GetCFGSettingInteger((struct struc_2 *)a2, *v18, v24, 0) ^ (unsigned __int8)*v19) & 3;
    *v19 = *v19 & 0xFFFB | (4 * (GetCFGSettingInteger((struct struc_2 *)a2, *v18, v25, 0) & 1));
    v20 = GetCFGSettingInteger((struct struc_2 *)a2, *v18, v26, 0);
    v21 = *v19;
    ++v18;
    v19 += 72;
    result = v21 & 0xFC07 | (8 * (v20 & 0x7F));
    *(v19 - 72) = result;
  }
  while ( (int)v18 < (int)FIX_DLL_Cmd );
  return result;
}
// 100246F8: using guessed type char *off_100246F8[8];
// 10024718: using guessed type int FIX_DLL_Cmd[22];

//----- (100150F0) --------------------------------------------------------
size_t __stdcall sub_100150F0(int a1, const void *a2, size_t a3, int a4)
{
  unknown_libname_56(a1 + 70);
  return sub_1000A060(&a1, a4, a2, a3);
}
// 100087F0: using guessed type _DWORD __stdcall unknown_libname_56(_DWORD);

//----- (10015120) --------------------------------------------------------
unsigned int __stdcall sub_10015120(int a1, int a2, unsigned int a3)
{
  unknown_libname_56(a1 + 70);
  return sub_1000A150(&a1, (void *)a2, a2, a3);
}
// 100087F0: using guessed type _DWORD __stdcall unknown_libname_56(_DWORD);

//----- (10015150) --------------------------------------------------------
#error "100151AB: call analysis failed (funcsize=27)"

//----- (100151C0) --------------------------------------------------------
int __cdecl sub_100151C0(int ap, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  int *v5; // eax
  int v6; // eax
  unsigned int v7; // ecx
  time_t v8; // eax
  char *v9; // esi
  int result; // eax
  PLAYER *v11; // eax
  _BOOL1 v12; // cc
  char src[512]; // [esp+Ch] [ebp-30Ch] BYREF
  char v14[3]; // [esp+20Ch] [ebp-10Ch] BYREF
  __int16 v15; // [esp+20Fh] [ebp-109h]
  char dst[251]; // [esp+211h] [ebp-107h] BYREF
  void *buf; // [esp+30Ch] [ebp-Ch]
  PLAYER *player; // [esp+310h] [ebp-8h]
  int buf_sz; // [esp+314h] [ebp-4h]
  PLAYER **v20; // [esp+320h] [ebp+8h]
  int v21; // [esp+324h] [ebp+Ch]

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 + 755);
    v3 = ((-25033 * (v2 ^ HIWORD(v2))) >> 5) & 0x7FF;
    v4 = dword_101A5398[2 * v3];
    if ( v4 == v2 )
    {
LABEL_6:
      v5 = (int *)(8 * v3 + 270160796);
      if ( v5 )
      {
        v6 = *v5;
        v7 = *(_DWORD *)(v6 + 8) + 500;
        *(_DWORD *)(v6 + 8) = v7;
        if ( v7 > 0x1388 )
          *(_DWORD *)(v6 + 8) = 4 * v7;
      }
    }
    else
    {
      while ( 1 )
      {
        if ( !v4 )
        {
          dword_101A9398 = 8 * v3 + 270160792;
          goto LABEL_9;
        }
        v3 = ((_WORD)v3 + 1) & 0x7FF;
        if ( v3 == (((-25033 * (v2 ^ HIWORD(*(_DWORD *)(a2 + 755)))) >> 5) & 0x7FF) )
          break;
        v4 = dword_101A5398[2 * v3];
        if ( v4 == v2 )
          goto LABEL_6;
      }
      dword_101A9398 = 0;
    }
LABEL_9:
    v8 = time_0(0);
    sprintf_0(
      src,
      "%s (%s)(%d)(%d.%d.%d.%d)(sec=%d)",
      (const char *)ap,
      (const char *)(a2 + 675),
      *(_DWORD *)(a2 + 761),
      (unsigned __int8)v2,
      BYTE1(v2),
      BYTE2(v2),
      HIBYTE(v2),
      v8 - *(_DWORD *)(a2 + 765));
    v9 = src;
  }
  else
  {
    v9 = (char *)ap;
  }
  off_10024608("%s\n", v9);
  result = nPlayerArray2;
  v21 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v20 = (PLAYER **)PlayerArray2;
    do
    {
      v11 = *v20;
      player = *v20;
      if ( player && v11->lpCurrentArena )
      {
        if ( v11->bIsSysop )
        {
          v14[0] = 7;
          v14[1] = 8;
          v14[2] = 0;
          v15 = -1;
          strncpyt(dst, v9, 250);
          buf_sz = strlen(dst) + 6;
          buf = v14;
          PlayerSendPacket(player, v14, buf_sz, 1);
        }
      }
      result = v21 + 1;
      v12 = ++v21 < nPlayerArray2;
      ++v20;
    }
    while ( v12 );
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;

//----- (10015390) --------------------------------------------------------
int __cdecl sub_10015390()
{
  int v0; // ebx
  int v1; // edi
  int *v2; // esi
  int result; // eax

  v0 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetTickCount)();
  if ( v0 - dword_101C8070 >= dword_101A5354 || !dword_101C8070 )
  {
    dword_101C8070 = v0;
    SendPacketsToEverybody((struct PACKET_ATTACHMENT *)lpFileName);
  }
  v1 = 0;
  if ( nPlayerArray2 > 0 )
  {
    v2 = PlayerArray2;
    do
    {
      if ( *(_DWORD *)(*v2 + 1619) )
        sub_100137F0(*v2);
      ++v1;
      ++v2;
    }
    while ( v1 < nPlayerArray2 );
  }
  result = dword_10029300;
  if ( v0 - dword_10029300 >= 60000 || !dword_10029300 )
  {
    result = 0;
    dword_100292F0[0] = 0;
    dword_101B3040 = 0;
    dword_100292F4 = 0;
    dword_101B3044 = 0;
    dword_100292F8 = 0;
    dword_101B3048 = 0;
    dword_10029300 = v0;
    dword_100292FC = 0;
    dword_101B304C = 0;
  }
  return result;
}
// 4CA230: using guessed type int PlayerArray2[];
// 4D9DCC: using guessed type int nPlayerArray2;
// 10021084: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetTickCount)(_DWORD, _DWORD, _DWORD);
// 100292F0: using guessed type int dword_100292F0[];
// 100292F4: using guessed type int dword_100292F4;
// 100292F8: using guessed type int dword_100292F8;
// 100292FC: using guessed type int dword_100292FC;
// 10029300: using guessed type int dword_10029300;
// 101A5354: using guessed type int dword_101A5354;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;
// 101B304C: using guessed type int dword_101B304C;
// 101C8070: using guessed type int dword_101C8070;

//----- (10015450) --------------------------------------------------------
int sub_10015450()
{
  int result; // eax
  int v1; // edx
  int v2; // ecx
  int v3[2]; // [esp+0h] [ebp-10Ch] BYREF
  int v4; // [esp+8h] [ebp-104h] BYREF
  int v5[64]; // [esp+Ch] [ebp-100h]

  sub_1000AEA0(dword_1003E438);
  result = dword_10065078 + nPlayerArray2;
  dwZonePopulation = dword_10065078 + nPlayerArray2;
  v1 = dword_101A535C;
  if ( dword_101A535C )
  {
    v4 = 0;
    v2 = 1;
    v5[0] = *((_DWORD *)lpFileName + 6);
    v4 = 1;
    if ( FindMeOut1 && *(_DWORD *)FindMeOut1 )
    {
      v5[1] = *(_DWORD *)(*(_DWORD *)FindMeOut1 + 24);
      v2 = 2;
      v4 = 2;
    }
    if ( lpPingSocket )
    {
      v5[v2] = *(_DWORD *)lpPingSocket;
      ++v4;
    }
    v3[0] = 0;
    v3[1] = 1000 * v1;
    result = j_FIX_DLL_WSOCK32_dll_ord_0012(0, &v4, 0, 0, v3);
  }
  return result;
}
// 100154C7: conditional instruction was optimized away because of 'ecx.4 in (1..2)'
// 4D9DCC: using guessed type int nPlayerArray2;
// 100159FC: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10065078: using guessed type int dword_10065078;
// 101A535C: using guessed type int dword_101A535C;

//----- (10015510) --------------------------------------------------------
#error "1001557A: call analysis failed (funcsize=41)"

//----- (10015590) --------------------------------------------------------
signed int __stdcall sub_10015590(int a1, int a2, int a3)
{
  if ( a2 == 1 )
    sub_10016FAF("-------------------:  Extended version %s\n", (int)"1.34.14b (Thu May  6 14:31:45 2004)");
  return 1;
}

//----- (10015610) --------------------------------------------------------
int __thiscall sub_10015610(int this)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  return result;
}

//----- (10015620) --------------------------------------------------------
int __thiscall sub_10015620(void **this)
{
  int result; // eax

  sub_10002D60(*this);
  result = 0;
  *this = 0;
  this[2] = 0;
  this[1] = 0;
  return result;
}

//----- (10015680) --------------------------------------------------------
int __thiscall sub_10015680(void **this)
{
  int result; // eax

  sub_10002D60(*this);
  result = 0;
  *this = 0;
  this[2] = 0;
  this[1] = 0;
  return result;
}

//----- (100156A0) --------------------------------------------------------
_DWORD *__thiscall sub_100156A0(void *this, int a2)
{
  _DWORD *v2; // edi
  _BYTE *v3; // eax
  int v4; // ecx
  int v5; // esi
  void *v6; // ecx
  int v7; // ebx
  _DWORD *v8; // esi
  _DWORD *v9; // ebp
  int v10; // ebx
  _DWORD *v11; // edx
  void *v13; // [esp-18h] [ebp-3Ch]
  void *v14; // [esp+10h] [ebp-14h]
  int v15[4]; // [esp+14h] [ebp-10h] BYREF
  int v16; // [esp+28h] [ebp+4h]

  v2 = this;
  v14 = this;
  v3 = this;
  v4 = a2 - (_DWORD)this;
  v5 = 32;
  do
  {
    *v3 = v3[v4];
    ++v3;
    --v5;
  }
  while ( v5 );
  v6 = (void *)v2[8];
  v7 = *(_DWORD *)(a2 + 40);
  v8 = v2 + 8;
  v15[0] = *(_DWORD *)(a2 + 32);
  sub_10002D60(v6);
  v2[8] = 0;
  v2[10] = 0;
  v2[9] = 0;
  if ( !v7 )
    return v2;
  v9 = (_DWORD *)v15[0];
  v16 = v7;
  do
  {
    v10 = v2[10];
    if ( v10 >= v2[9] )
    {
      sub_10002D10((int)v8, 16 * (v10 + 32));
      v2[9] += 32;
    }
    memcpy_0((void *)(v2[8] + 16 * (v10 + 1)), (const void *)(16 * v10 + v2[8]), 16 * (v2[10] + 0xFFFFFFF * v10));
    v13 = (void *)(16 * v10 + *v8);
    ++v2[10];
    memcpy_0(v13, v15, 0x10u);
    v11 = (_DWORD *)(16 * v10 + *v8);
    *v11 = *v9;
    v11[1] = v9[1];
    v11[2] = v9[2];
    v11[3] = v9[3];
    v9 += 4;
    --v16;
  }
  while ( v16 );
  return v14;
}

//----- (100157A0) --------------------------------------------------------
int __thiscall sub_100157A0(int this, int a2)
{
  int v3; // eax
  int v4; // ebx
  int v5; // edx
  int v6; // esi
  char v8[32]; // [esp+Ch] [ebp-2Ch] BYREF
  void *v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v3 = *(_DWORD *)(this + 8);
  if ( v3 >= *(_DWORD *)(this + 4) )
  {
    sub_10002D10(this, 4 * (v3 + 2 * (5 * v3 + 160) + 32));
    *(_DWORD *)(this + 4) += 32;
  }
  memcpy_0(
    (void *)(*(_DWORD *)this + 4 * (a2 + 2 * (5 * a2 + 5) + 1)),
    (const void *)(*(_DWORD *)this + 44 * a2),
    44 * *(_DWORD *)(this + 8) - 44 * a2);
  v4 = *(_DWORD *)this;
  v5 = *(_DWORD *)(this + 8) + 1;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  *(_DWORD *)(this + 8) = v5;
  memcpy_0((void *)(v4 + 44 * a2), v8, 0x2Cu);
  v6 = *(_DWORD *)this + 44 * a2;
  sub_10002D60(v9);
  return v6;
}

//----- (10015A20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char *__cdecl strncpy_0(char *a1, const char *a2, size_t a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  char *v5; // esi
  char *v6; // edi
  unsigned int v7; // ecx
  char v8; // al
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // edx
  char *v13; // [esp-4h] [ebp-8h]
  char *v14; // [esp+0h] [ebp-4h]
  unsigned int retaddr; // [esp+4h] [ebp+0h]

  v3 = retaddr;
  if ( !retaddr )
    return v13;
  v4 = retaddr;
  v5 = v14;
  v6 = v13;
  if ( ((unsigned __int8)v14 & 3) == 0 )
  {
    v7 = retaddr >> 2;
    if ( retaddr >> 2 )
      goto LABEL_21;
LABEL_10:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return v13;
    }
    while ( --v4 )
LABEL_17:
      *v6++ = v8;
    return v13;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return v13;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return a1;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
LABEL_9:
    v4 &= 3u;
    if ( v4 )
      goto LABEL_10;
    return v13;
  }
  while ( 1 )
  {
LABEL_21:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto LABEL_20;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto LABEL_30;
    }
LABEL_20:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto LABEL_9;
  }
  *(_DWORD *)v6 = 0;
LABEL_30:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
LABEL_31:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto LABEL_17;
  return a1;
}
// 10015B1D: positive sp value C has been found
// 10015A2D: variable 'v14' is possibly undefined
// 10015A37: variable 'v13' is possibly undefined

//----- (10015B1E) --------------------------------------------------------
void __stdcall _JumpToContinuation(void *a1, struct EHRegistrationNode *a2)
{
  __asm { jmp     eax }
}

//----- (10015BB6) --------------------------------------------------------
int __usercall __CxxFrameHandler_0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4, int a5, int a6, int a7)
{
  return __InternalCxxFrameHandler_0(a2, a3, a4, a5, a6, a7, a1, 0, 0, 0);
}

//----- (10015C06) --------------------------------------------------------
void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, void *a3, int a4, unsigned __int32 a5)
{
  return (void *)unknown_libname_65(a3, a1, a5);
}
// 10017F50: using guessed type _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD);

//----- (10015C5A) --------------------------------------------------------
int __usercall CatchGuardHandler@<eax>(int a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5)
{
  return __InternalCxxFrameHandler_0(
           a1,
           a2,
           (int)a3,
           *((_DWORD *)a4 + 3),
           (int)a5,
           0,
           *((_DWORD *)a4 + 2),
           *((_DWORD *)a4 + 4),
           a4,
           0);
}

//----- (10015D33) --------------------------------------------------------
int __usercall TranslatorGuardHandler@<eax>(int a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a5)
{
  if ( (ExceptionRecord->ExceptionFlags & 0x66) == 0 )
  {
    __InternalCxxFrameHandler_0(
      a1,
      a2,
      (int)ExceptionRecord,
      *((_DWORD *)TargetFrame + 3),
      a5,
      0,
      *((_DWORD *)TargetFrame + 2),
      *((_DWORD *)TargetFrame + 4),
      *((struct EHRegistrationNode **)TargetFrame + 5),
      1);
    if ( !*((_DWORD *)TargetFrame + 9) )
      unknown_libname_60(TargetFrame, ExceptionRecord);
    __asm { jmp     dword ptr [ebx+18h] }
  }
  *((_DWORD *)TargetFrame + 9) = 1;
  return 1;
}
// 10015B67: using guessed type _DWORD __stdcall unknown_libname_60(_DWORD, _DWORD);

//----- (10015DA8) --------------------------------------------------------
const struct _s_TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *a1, int a2, int a3, unsigned int *a4, unsigned int *a5)
{
  unsigned int v7; // esi
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  int v12; // [esp+0h] [ebp-10h]
  int v13; // [esp+4h] [ebp-Ch]
  int v14; // [esp+8h] [ebp-8h]
  unsigned int v15; // [esp+Ch] [ebp-4h]
  unsigned int v16; // [esp+18h] [ebp+8h]

  v7 = *((_DWORD *)a1 + 3);
  v8 = *((_DWORD *)a1 + 4);
  v9 = v7;
  v16 = v7;
  v15 = v7;
  if ( a2 >= 0 )
  {
    do
    {
      if ( v7 == -1 )
        sub_10018002(a3, v8, (int)a1, -1, v12, v13, v14);
      --v7;
      if ( *(_DWORD *)(v8 + 20 * v7 + 4) < a3 && a3 <= *(_DWORD *)(v8 + 20 * v7 + 8) || v7 == -1 )
      {
        --a2;
        v15 = v16;
        v16 = v7;
      }
    }
    while ( a2 >= 0 );
    v9 = v15;
  }
  v10 = v7 + 1;
  *a4 = v10;
  *a5 = v9;
  if ( v9 > *((_DWORD *)a1 + 3) || v10 > v9 )
    sub_10018002((int)a5, v8, (int)a1, v10, v12, v13, v14);
  return (const struct _s_TryBlockMapEntry *)(v8 + 20 * v10);
}
// 10015DCB: variable 'a3' is possibly undefined
// 10015DCB: variable 'v12' is possibly undefined
// 10015DCB: variable 'v13' is possibly undefined
// 10015DCB: variable 'v14' is possibly undefined

//----- (10015E24) --------------------------------------------------------
int __cdecl _global_unwind2_0(PVOID TargetFrame)
{
  return j_FIX_DLL_KERNEL32_dll_RtlUnwind(TargetFrame, loc_10015E3C, 0, 0);
}
// 10015E3C: using guessed type int __cdecl loc_10015E3C(int);
// 1001FB40: using guessed type int __cdecl j_FIX_DLL_KERNEL32_dll_RtlUnwind(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015E44) --------------------------------------------------------
signed int __cdecl _unwind_handler(int a1, int a2, int a3, int a4)
{
  signed int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *(_DWORD *)a4 = a2;
    result = 3;
  }
  return result;
}

//----- (10015E66) --------------------------------------------------------
int __cdecl _local_unwind2_0(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // esi
  unsigned int v6; // [esp-8h] [ebp-1Ch]
  signed int (__cdecl *v7)(int, int, int, int); // [esp-4h] [ebp-18h]

  v7 = _unwind_handler;
  v6 = __readfsdword(0);
  while ( 1 )
  {
    result = a1;
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 == -1 || v4 == a2 )
      break;
    v5 = 3 * v4;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(v3 + 4 * v5);
    if ( !*(_DWORD *)(v3 + 4 * v5 + 4) )
    {
      loc_10015EFA(257);
      (*(void (__cdecl **)(unsigned int, signed int (__cdecl *)(int, int, int, int)))(v3 + 4 * v5 + 8))(v6, v7);
    }
  }
  return result;
}
// 10015EBA: variable 'v6' is possibly undefined
// 10015EBA: variable 'v7' is possibly undefined
// 10015EFA: using guessed type _DWORD __stdcall loc_10015EFA(_DWORD);

//----- (10015ECE) --------------------------------------------------------
int __cdecl _abnormal_termination_0()
{
  int result; // eax
  unsigned int v1; // ecx

  result = 0;
  v1 = __readfsdword(0);
  if ( *(signed int (__cdecl **)(int, int, int, int))(v1 + 4) == _unwind_handler
    && *(_DWORD *)(v1 + 8) == *(_DWORD *)(*(_DWORD *)(v1 + 12) + 12) )
  {
    result = 1;
  }
  return result;
}

//----- (10015EF1) --------------------------------------------------------
int __userpurge sub_10015EF1@<eax>(int result@<eax>, int a2@<ecx>, int a3@<ebp>, int a4)
{
  dword_10025D60[2] = a2;
  dword_10025D60[1] = result;
  dword_10025D60[3] = a3;
  return result;
}

//----- (10015F12) --------------------------------------------------------
void __cdecl _cinit_0()
{
  if ( off_10025DCC )
    off_10025DCC();
  sub_10016018((unsigned int)&unk_10024034, (unsigned int)&unk_10024048);
  sub_10016018((unsigned int)&unk_10024000, (unsigned int)&loc_1002402B + 5);
}
// 10025DCC: using guessed type int (*off_10025DCC)(void);

//----- (10015F3F) --------------------------------------------------------
void __cdecl sub_10015F3F(int a1)
{
  doexit_0(a1, 0, 0);
}

//----- (10015F50) --------------------------------------------------------
void __cdecl sub_10015F50(int a1)
{
  doexit_0(a1, 1, 0);
}

//----- (10015F7F) --------------------------------------------------------
void __cdecl doexit_0(UINT uExitCode, int a2, int a3)
{
  int v3; // eax
  void (**v4)(void); // esi

  if ( dword_101C80BC == 1 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetCurrentProcess(uExitCode);
    FIX_DLL_KERNEL32_dll_TerminateProcess(v3);
  }
  dword_101C80B8 = 1;
  byte_101C80B4 = a3;
  if ( !a2 )
  {
    if ( dword_101C9718 )
    {
      v4 = (void (**)(void))(dword_101C9714 - 4);
      if ( dword_101C9714 - 4 >= (unsigned int)dword_101C9718 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ( (unsigned int)v4 >= dword_101C9718 );
      }
    }
    sub_10016018((unsigned int)&unk_1002404C, (unsigned int)&unk_10024054);
  }
  sub_10016018((unsigned int)&unk_10024058, (unsigned int)&unk_10024060);
  if ( !a3 )
  {
    dword_101C80BC = 1;
    FIX_DLL_KERNEL32_dll_ExitProcess(uExitCode);
  }
}
// 10021148: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ExitProcess)(_DWORD);
// 1002114C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_TerminateProcess)(_DWORD);
// 10021150: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetCurrentProcess)(_DWORD);
// 101C80B4: using guessed type char byte_101C80B4;
// 101C80B8: using guessed type int dword_101C80B8;
// 101C80BC: using guessed type int dword_101C80BC;
// 101C9714: using guessed type int dword_101C9714;
// 101C9718: using guessed type int dword_101C9718;

//----- (10016018) --------------------------------------------------------
void __cdecl sub_10016018(unsigned int a1, unsigned int a2)
{
  while ( a1 < a2 )
  {
    if ( *(_DWORD *)a1 )
      (*(void (**)(void))a1)();
    a1 += 4;
  }
}

//----- (10016163) --------------------------------------------------------
int __cdecl atol_0(const char *String)
{
  int v3; // esi
  const char *v4; // edi
  int v5; // ebp
  int v6; // ebx
  int result; // eax

  while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * *(unsigned __int8 *)String) & 8 : _isctype_0(*(unsigned __int8 *)String, 8) )
    ++String;
  v3 = *(unsigned __int8 *)String;
  v4 = String + 1;
  v5 = v3;
  if ( v3 == 45 || v3 == 43 )
    v3 = *(unsigned __int8 *)v4++;
  v6 = 0;
  while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * v3) & 4 : _isctype_0(v3, 4) )
  {
    v6 = v3 + 10 * v6 - 48;
    v3 = *(unsigned __int8 *)v4++;
  }
  result = v6;
  if ( v5 == 45 )
    result = -v6;
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100161EE) --------------------------------------------------------
int __thiscall atol_1(void *this, signed int *a2)
{
  return atol_0((const char *)a2);
}

//----- (100162C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_100162C0(int a1, int a2)
{
  return a2 - 1;
}
// 100162C4: positive sp value 4 has been found

//----- (100162D0) --------------------------------------------------------
char *__cdecl strchr_0(const char *Str, int Val)
{
  int v2; // edx
  char v3; // cl
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  unsigned int v7; // eax
  char *result; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax

  v2 = (int)Str;
  if ( ((unsigned __int8)Str & 3) != 0 )
  {
    while ( 1 )
    {
      v3 = *(_BYTE *)v2++;
      if ( v3 == (_BYTE)Val )
        break;
      if ( !v3 )
        return 0;
      if ( (v2 & 3) == 0 )
        goto LABEL_5;
    }
    result = (char *)sub_100162C0(v3, v2);
  }
  else
  {
    while ( 1 )
    {
LABEL_5:
      while ( 1 )
      {
        v4 = (((unsigned __int8)Val << 8) | (unsigned __int8)Val | ((((unsigned __int8)Val << 8) | (unsigned __int8)Val) << 16)) ^ *(_DWORD *)v2;
        v5 = *(_DWORD *)v2 + 2130640639;
        v6 = v5 ^ ~*(_DWORD *)v2;
        v2 += 4;
        if ( (((v4 + 2130640639) ^ ~v4) & 0x81010100) != 0 )
          break;
        v7 = v6 & 0x81010100;
        if ( v7 && ((v7 & 0x1010100) != 0 || (v5 & 0x80000000) == 0) )
          return 0;
      }
      v9 = *(_DWORD *)(v2 - 4);
      if ( (_BYTE)v9 == (_BYTE)Val )
        break;
      if ( !(_BYTE)v9 )
        return 0;
      if ( BYTE1(v9) == (_BYTE)Val )
        return (char *)(v2 - 3);
      if ( !BYTE1(v9) )
        return 0;
      v10 = HIWORD(v9);
      if ( (_BYTE)v10 == (_BYTE)Val )
        return (char *)(v2 - 2);
      if ( !(_BYTE)v10 )
        return 0;
      if ( BYTE1(v10) == (_BYTE)Val )
        return (char *)(v2 - 1);
      if ( !BYTE1(v10) )
        return 0;
    }
    result = (char *)(v2 - 4);
  }
  return result;
}

//----- (1001638C) --------------------------------------------------------
int __cdecl vsprintf_0(char *a1, const char *a2, va_list a3)
{
  int v3; // eax
  _BOOL1 v4; // sf
  int v5; // esi
  FILE v7; // [esp+4h] [ebp-20h] BYREF

  v7._base = a1;
  v7._ptr = a1;
  v7._flag = 66;
  v7._cnt = 0x7FFFFFFF;
  v3 = _output_0(&v7, (int)a2, (int)a3);
  v4 = --v7._cnt < 0;
  v5 = v3;
  if ( v4 )
    _flsbuf_0(0, &v7);
  else
    *v7._ptr = 0;
  return v5;
}

//----- (100163DD) --------------------------------------------------------
int (__cdecl *__cdecl sub_100163DD(int a1))(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax

  result = dword_101C8100;
  dword_101C8100 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a1;
  return result;
}
// 101C8100: using guessed type int (__cdecl *dword_101C8100)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100163ED) --------------------------------------------------------
int (*__cdecl sub_100163ED(int (*a1)()))()
{
  int (*result)(); // eax

  result = off_10025DF0[0];
  off_10025DF0[0] = a1;
  return result;
}
// 10025DF0: using guessed type int (*off_10025DF0[2])();

//----- (100163FD) --------------------------------------------------------
int __cdecl sub_100163FD(int a1)
{
  int result; // eax

  result = dword_101C80FC;
  dword_101C80FC = a1;
  return result;
}
// 101C80FC: using guessed type int dword_101C80FC;

//----- (1001640D) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001640D(int (*a1)()))(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax

  result = off_10025DF4;
  off_10025DF4 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))a1;
  return result;
}
// 10025DF4: using guessed type int (__cdecl *off_10025DF4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100164A4) --------------------------------------------------------
char *__thiscall sub_100164A4(void *this)
{
  return (char *)this + 8;
}

//----- (100164A8) --------------------------------------------------------
void *__thiscall sub_100164A8(void *this, int a2)
{
  void *result; // eax

  result = this;
  *(_DWORD *)this = &off_10021A94;
  return result;
}
// 10021A94: using guessed type int (__stdcall *off_10021A94)(char);

//----- (100164B3) --------------------------------------------------------
void *__thiscall sub_100164B3(void *this, int a2)
{
  return this;
}

//----- (100164B8) --------------------------------------------------------
// #API: RaiseException()
// #API: RaiseException()
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _DWORD v2[8]; // [esp+8h] [ebp-20h] BYREF

  qmemcpy(v2, &unk_10021A98, sizeof(v2));
  v2[6] = pExceptionObject;
  v2[7] = pThrowInfo;
  FIX_DLL_KERNEL32_dll_RaiseException(v2[0], v2[1], v2[4], &v2[5]);
}
// 10021154: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_RaiseException)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100165F0) --------------------------------------------------------
#error "10016748: invalid basic block (funcsize=104)"

//----- (1001692D) --------------------------------------------------------
int __cdecl toupper_0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // [esp-4h] [ebp-Ch]
  unsigned __int16 v6; // [esp+4h] [ebp-4h] BYREF

  if ( dword_101C8114 )
  {
    v2 = a1;
    if ( (a1 >= 256
       || ((int)dword_10026004 <= 1 ? (v3 = *(_BYTE *)(dword_10025DF8 + 2 * a1) & 2) : (v3 = _isctype_0(a1, 2)), v3))
      && (*(char *)(dword_10025DF8 + 2 * BYTE1(v2) + 1) >= 0 ? (LOWORD(a1) = (unsigned __int8)v2, v5 = 1) : (LOBYTE(a1) = BYTE1(v2), *(_WORD *)((char *)&a1 + 1) = (unsigned __int8)v2, v5 = 2),
          (v4 = __crtLCMapStringA_0(dword_101C8114, 0x200u, (LPCSTR)&a1, v5, (LPSTR)&v6, 3, 0, 1)) != 0) )
    {
      if ( v4 == 1 )
        result = (unsigned __int8)v6;
      else
        result = v6;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = a1;
    if ( a1 >= 97 && a1 <= 122 )
      result = a1 - 32;
  }
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;
// 101C8114: using guessed type int dword_101C8114;

//----- (10016A01) --------------------------------------------------------
int __cdecl tolower_0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int16 v6; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_101C8114 )
  {
    v2 = a1;
    if ( (a1 >= 256
       || ((int)dword_10026004 <= 1 ? (v3 = *(_BYTE *)(dword_10025DF8 + 2 * a1) & 1) : (v3 = _isctype_0(a1, 1)), v3))
      && (*(char *)(dword_10025DF8 + 2 * BYTE1(v2) + 1) >= 0 ? (LOWORD(a1) = (unsigned __int8)v2, v4 = 1) : (LOBYTE(a1) = BYTE1(v2), *(_WORD *)((char *)&a1 + 1) = (unsigned __int8)v2, v4 = 2),
          (v5 = __crtLCMapStringA_0(dword_101C8114, 0x100u, (LPCSTR)&a1, v4, (LPSTR)&v6, 3, 0, 1)) != 0) )
    {
      if ( v5 == 1 )
        result = (unsigned __int8)v6;
      else
        result = v6;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = a1;
    if ( a1 >= 65 && a1 <= 90 )
      result = a1 + 32;
  }
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;
// 101C8114: using guessed type int dword_101C8114;

//----- (10016B75) --------------------------------------------------------
#error "10016B9E: call analysis failed (funcsize=32)"

//----- (10016FAF) --------------------------------------------------------
int __cdecl sub_10016FAF(unsigned __int8 *a1, int a2)
{
  int v2; // edi
  int v3; // ebx

  v2 = _stbuf_0((int)&stru_10026040);
  v3 = _output_0(&stru_10026040, (int)a1, (int)&a2);
  _ftbuf_0(v2, (int)&stru_10026040);
  return v3;
}

//----- (10016FE0) --------------------------------------------------------
int __usercall sub_10016FE0@<eax>(int a2@<esi>)
{
  _NMSG_WRITE_0(a2, 0xAu);
  raise_0(22);
  sub_10015F50(3);
  return sub_10016FF7();
}

//----- (10016FF7) --------------------------------------------------------
unsigned int __cdecl sub_10016FF7()
{
  unsigned int result; // eax

  _cfltcvt_init_0();
  dword_101C80C4 = _ms_p5_mp_test_fdiv_0();
  result = sub_10019CC7();
  __asm { fnclex }
  return result;
}
// 101C80C4: using guessed type int dword_101C80C4;

//----- (1001700F) --------------------------------------------------------
void *__cdecl _cfltcvt_init_0()
{
  void *result; // eax

  result = &unk_1001A105;
  off_10026334 = (int (__cdecl *)(_DWORD))&unk_10019D9A;
  off_10026330 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))&unk_1001A105;
  dword_10026338 = (int)&unk_10019E00;
  off_1002633C = (int (__cdecl *)(_DWORD))&unk_10019D40;
  dword_10026340 = (int)&unk_10019DE8;
  dword_10026344 = (int)&unk_1001A105;
  return result;
}
// 10026330: using guessed type int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10026334: using guessed type int (__cdecl *off_10026334)(_DWORD);
// 10026338: using guessed type int dword_10026338;
// 1002633C: using guessed type int (__cdecl *off_1002633C)(_DWORD);
// 10026340: using guessed type int dword_10026340;
// 10026344: using guessed type int dword_10026344;

//----- (10017122) --------------------------------------------------------
void __usercall sub_10017122(int a1@<ebp>)
{
  if ( !*(_DWORD *)(a1 - 32) )
    __ArrayUnwind(
      *(void **)(a1 + 8),
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(a1 - 28),
      *(void (__thiscall **)(void *))(a1 + 24));
}
// 100171BA: using guessed type void __stdcall __ArrayUnwind(void *, unsigned int, _DWORD, void (__thiscall *)(void *));

//----- (1001722E) --------------------------------------------------------
int __cdecl isalpha_0(int a1)
{
  int result; // eax

  if ( (int)dword_10026004 <= 1 )
    result = *(_WORD *)(dword_10025DF8 + 2 * a1) & 0x103;
  else
    result = _isctype_0(a1, 259);
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100172AC) --------------------------------------------------------
int __cdecl sub_100172AC(int a1)
{
  if ( (int)dword_10026004 > 1 )
    JUMPOUT(0x100172B5);
  return sub_100172C3(a1);
}
// 100172B3: control flows out of bounds to 100172B5

//----- (100172C3) --------------------------------------------------------
int __cdecl sub_100172C3(int a1)
{
  return *(_BYTE *)(dword_10025DF8 + 2 * a1) & 4;
}
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100174A0) --------------------------------------------------------
char *__cdecl strrchr_0(const char *a1, int a2)
{
  unsigned int v2; // ecx
  const char *v3; // edi
  _BOOL1 v4; // zf
  char *v5; // edi
  char *result; // eax

  v2 = strlen(a1) + 1;
  v3 = &a1[v2 - 1];
  do
  {
    if ( !v2 )
      break;
    v4 = *v3-- == (unsigned __int8)a2;
    --v2;
  }
  while ( !v4 );
  v5 = (char *)(v3 + 1);
  if ( *v5 == (_BYTE)a2 )
    result = v5;
  else
    result = 0;
  return result;
}

//----- (100174D1) --------------------------------------------------------
int __cdecl sub_100174D1()
{
  dword_10025DE0 = 214013 * dword_10025DE0 + 2531011;
  return (dword_10025DE0 >> 16) & 0x7FFF;
}
// 10025DE0: using guessed type int dword_10025DE0;

//----- (100174EF) --------------------------------------------------------
time_t __cdecl time_0(time_t *a1)
{
  int v1; // eax
  int v2; // eax
  time_t result; // eax
  _DWORD v4[38]; // [esp+0h] [ebp-CCh] BYREF
  __int16 v5; // [esp+9Ah] [ebp-32h]
  int v6; // [esp+A8h] [ebp-24h]
  int v7; // [esp+ACh] [ebp-20h] BYREF
  int v8; // [esp+B0h] [ebp-1Ch]
  int v9; // [esp+B4h] [ebp-18h]
  int v10; // [esp+B8h] [ebp-14h]
  int v11; // [esp+BCh] [ebp-10h] BYREF
  unsigned __int16 v12; // [esp+C2h] [ebp-Ah]
  unsigned __int16 v13; // [esp+C4h] [ebp-8h]
  unsigned __int16 v14; // [esp+C6h] [ebp-6h]
  unsigned __int16 v15; // [esp+C8h] [ebp-4h]

  FIX_DLL_KERNEL32_dll_GetLocalTime(&v11);
  FIX_DLL_KERNEL32_dll_GetSystemTime(&v7);
  if ( HIWORD(v9) == word_101C80DA && (_WORD)v9 == word_101C80D8 && HIWORD(v8) == word_101C80D6 && v7 == dword_101C80D0 )
  {
    v1 = dword_101C80C8;
  }
  else
  {
    v2 = FIX_DLL_KERNEL32_dll_GetTimeZoneInformation(v4);
    if ( v2 == -1 )
      v1 = -1;
    else
      v1 = v2 == 2 && v5 && v6;
    dword_101C80D0 = v7;
    *(&dword_101C80D0 + 1) = v8;
    *(&dword_101C80D0 + 2) = v9;
    *(&dword_101C80D0 + 3) = v10;
    dword_101C80C8 = v1;
  }
  result = __loctotime_t_0((unsigned __int16)v11, HIWORD(v11), v12, v13, v14, v15, v1);
  if ( a1 )
    *a1 = result;
  return result;
}
// 10021004: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLocalTime)(_DWORD);
// 10021158: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD);
// 1002115C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetSystemTime)(_DWORD);
// 101C80C8: using guessed type int dword_101C80C8;
// 101C80D0: using guessed type int dword_101C80D0;
// 101C80D6: using guessed type __int16 word_101C80D6;
// 101C80D8: using guessed type __int16 word_101C80D8;
// 101C80DA: using guessed type __int16 word_101C80DA;

//----- (10017683) --------------------------------------------------------
int __stdcall FIX_DLL_start(int a1, int a2, int a3)
{
  _BOOL1 v4; // zf
  signed int v6; // eax
  int v7; // [esp+18h] [ebp+Ch]

  if ( a2 )
  {
    if ( a2 != 1 && a2 != 2 )
      goto LABEL_10;
    if ( dword_101C9708 && !dword_101C9708(a1, a2, a3) )
      return 0;
    v4 = _CRT_INIT(a1, a2, a3) == 0;
  }
  else
  {
    v4 = dword_101C80E0 == 0;
  }
  if ( v4 )
    return 0;
LABEL_10:
  v6 = sub_10015590(a1, a2, a3);
  v7 = v6;
  if ( a2 != 1 )
  {
LABEL_13:
    if ( !a2 || a2 == 3 )
    {
      if ( !_CRT_INIT(a1, a2, a3) )
        v7 = 0;
      if ( v7 )
      {
        if ( dword_101C9708 )
          v7 = dword_101C9708(a1, a2, a3);
      }
    }
    return v7;
  }
  if ( !v6 )
  {
    _CRT_INIT(a1, 0, a3);
    goto LABEL_13;
  }
  return v7;
}
// 100175CB: using guessed type _DWORD __stdcall _CRT_INIT(_DWORD, _DWORD, _DWORD);
// 101C80E0: using guessed type int dword_101C80E0;
// 101C9708: using guessed type int (__stdcall *dword_101C9708)(_DWORD, _DWORD, _DWORD);

//----- (10017720) --------------------------------------------------------
void __cdecl _amsg_exit_0(int rterrnum)
{
  int v1; // esi

  if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
    _FF_MSGBANNER_0(v1);
  _NMSG_WRITE_0(v1, rterrnum);
  off_10025DE4(255);
}
// 10017737: variable 'v1' is possibly undefined
// 10025DE4: using guessed type int (__cdecl *off_10025DE4)(_DWORD);
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;

//----- (10017753) --------------------------------------------------------
int __usercall __InternalCxxFrameHandler_0@<eax>(int a2@<ecx>, int a3@<ebx>, int a4, int a5, int a6, int a7, int a8, int a9, struct EHRegistrationNode *a10, char a11)
{
  int v12; // [esp+0h] [ebp-8h]
  int v13; // [esp+4h] [ebp-4h]
  int savedregs; // [esp+8h] [ebp+0h]

  if ( *(_DWORD *)a8 != 429065504 )
    sub_10018002(a2, a3, 429065504, a8, v12, v13, savedregs);
  if ( (*(_BYTE *)(a4 + 4) & 0x66) != 0 )
  {
    if ( *(_DWORD *)(a8 + 4) )
    {
      if ( !a9 )
        sub_10017A9A(a2, a3, 429065504, a8, a5, a7, a8, -1);
    }
  }
  else if ( *(_DWORD *)(a8 + 12) )
  {
    if ( *(_DWORD *)a4 == -529697949 && *(_DWORD *)(a4 + 20) > 0x19930520u )
    {
      a2 = *(_DWORD *)(*(_DWORD *)(a4 + 28) + 8);
      if ( a2 )
        return ((int (__cdecl *)(int, int, int, int, int, int, struct EHRegistrationNode *, _DWORD))a2)(
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 (unsigned __int8)a11);
    }
    FindHandler(
      (const struct _s_FuncInfo *)a2,
      a3,
      429065504,
      a8,
      (PEXCEPTION_RECORD)a4,
      (struct EHRegistrationNode *)a5,
      (struct _CONTEXT *)a6,
      (void *)a7,
      (const struct _s_FuncInfo *)a8,
      a11,
      a9,
      a10);
  }
  return 1;
}
// 10017764: variable 'v12' is possibly undefined
// 10017764: variable 'v13' is possibly undefined
// 10017764: variable 'savedregs' is possibly undefined
// 10017787: variable 'a2' is possibly undefined

//----- (100177EE) --------------------------------------------------------
int __usercall FindHandler@<eax>(const struct _s_FuncInfo *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a6, struct _CONTEXT *a7, void *a8, const struct _s_FuncInfo *a9, char a10, int a11, PVOID TargetFrame)
{
  int result; // eax
  PEXCEPTION_RECORD v13; // esi
  bool v14; // eax
  int v15; // edi
  const struct _s_TryBlockMapEntry *i; // ebx
  int *v17; // eax
  const struct _s_CatchableType **v18; // edi
  int v19; // [esp-10h] [ebp-28h]
  unsigned int v23; // [esp+0h] [ebp-18h] BYREF
  int v24; // [esp+4h] [ebp-14h]
  int v25; // [esp+8h] [ebp-10h]
  int v26; // [esp+Ch] [ebp-Ch]
  int v27; // [esp+10h] [ebp-8h]
  unsigned int v28; // [esp+14h] [ebp-4h] BYREF
  const struct _s_HandlerType *v29; // [esp+20h] [ebp+8h]

  LOBYTE(v24) = 0;
  v25 = *((_DWORD *)a6 + 2);
  result = v25;
  if ( v25 < -1 || (a1 = a9, v25 >= *((_DWORD *)a9 + 1)) )
    result = sub_10018002((int)a1, a2, a3, a4, v23, v24, v25);
  v13 = ExceptionRecord;
  if ( ExceptionRecord->ExceptionCode != -529697949 )
    goto LABEL_35;
  if ( ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->ExceptionInformation[0] == 429065504
    && !ExceptionRecord->ExceptionInformation[2] )
  {
    v13 = (PEXCEPTION_RECORD)dword_101C80F4;
    if ( !dword_101C80F4 )
      return result;
    a7 = (struct _CONTEXT *)dword_101C80F8;
    LOBYTE(v24) = 1;
    v14 = sub_1001AB9E(dword_101C80F4, 1);
    a1 = (const struct _s_FuncInfo *)v19;
    if ( !v14 )
      sub_10018002(v19, -529697949, 429065504, (int)v13, a3, a4, a2);
    if ( v13->ExceptionCode != -529697949 )
      goto LABEL_35;
    if ( v13->NumberParameters == 3 && v13->ExceptionInformation[0] == 429065504 && !v13->ExceptionInformation[2] )
      sub_10018002((int)a1, -529697949, 429065504, (int)v13, a3, a4, a2);
  }
  if ( v13->ExceptionCode != -529697949 || v13->NumberParameters != 3 || v13->ExceptionInformation[0] != 429065504 )
  {
LABEL_35:
    if ( a10 )
      result = sub_10017F9C((int)a1, -529697949, 429065504, (int)v13, (int)ExceptionRecord, (int)a6, (int)a7);
    else
      result = FindHandlerForForeignException(v13, a6, a7, a8, a9, v25, a11, TargetFrame);
    return result;
  }
  v15 = v25;
  for ( i = _GetRangeOfTrysToCheck(a9, a11, v25, &v28, &v23); ; i = (const struct _s_TryBlockMapEntry *)((char *)i + 20) )
  {
    result = v28;
    if ( v28 >= v23 )
      break;
    if ( *(_DWORD *)i <= v15 && v15 <= *((_DWORD *)i + 1) )
    {
      v29 = (const struct _s_HandlerType *)*((_DWORD *)i + 4);
      v26 = *((_DWORD *)i + 3);
      if ( v26 > 0 )
      {
        while ( 1 )
        {
          v17 = *(int **)(v13->ExceptionInformation[2] + 12);
          v18 = (const struct _s_CatchableType **)(v17 + 1);
          v27 = *v17;
          if ( v27 > 0 )
            break;
LABEL_27:
          --v26;
          v29 = (const struct _s_HandlerType *)((char *)v29 + 16);
          if ( v26 <= 0 )
            goto LABEL_30;
        }
        while ( !TypeMatch(v29, *v18, (const struct _s_ThrowInfo *)v13->ExceptionInformation[2]) )
        {
          --v27;
          ++v18;
          if ( v27 <= 0 )
            goto LABEL_27;
        }
        CatchIt(
          (struct EHExceptionRecord *)v13,
          a6,
          a7,
          a8,
          a9,
          v29,
          *v18,
          i,
          a11,
          (struct EHRegistrationNode *)TargetFrame,
          v24);
      }
LABEL_30:
      v15 = v25;
    }
    ++v28;
  }
  if ( a10 )
    result = unknown_libname_64(v13);
  return result;
}
// 10017861: variable 'v19' is possibly undefined
// 10017882: variable 'a1' is possibly undefined
// 10017882: variable 'a3' is possibly undefined
// 10017882: variable 'a4' is possibly undefined
// 10017882: variable 'a2' is possibly undefined
// 10017A3D: using guessed type _DWORD __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *);
// 10017B4E: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);
// 10017EC3: using guessed type _DWORD __cdecl unknown_libname_64(_DWORD);
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017995) --------------------------------------------------------
unsigned int __cdecl FindHandlerForForeignException(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a2, struct _CONTEXT *a3, void *a4, const struct _s_FuncInfo *a5, int a6, int a7, PVOID TargetFrame)
{
  unsigned int result; // eax
  const struct _s_TryBlockMapEntry *i; // esi
  int v10; // eax
  int v11; // ecx
  unsigned int v12; // [esp+8h] [ebp-8h] BYREF
  unsigned int v13; // [esp+Ch] [ebp-4h] BYREF

  if ( !dword_101C80FC
    || (result = _CallSETranslator(
                   (struct EHExceptionRecord *)ExceptionRecord,
                   a2,
                   a3,
                   a4,
                   a5,
                   a7,
                   (struct EHRegistrationNode *)TargetFrame)) == 0 )
  {
    for ( i = _GetRangeOfTrysToCheck(a5, a7, a6, &v13, &v12); ; i = (const struct _s_TryBlockMapEntry *)((char *)i + 20) )
    {
      result = v13;
      if ( v13 >= v12 )
        break;
      if ( a6 >= *(_DWORD *)i && a6 <= *((_DWORD *)i + 1) )
      {
        v10 = *((_DWORD *)i + 4) + 16 * *((_DWORD *)i + 3);
        v11 = *(_DWORD *)(v10 - 12);
        if ( !v11 || !*(_BYTE *)(v11 + 8) )
          CatchIt(
            (struct EHExceptionRecord *)ExceptionRecord,
            a2,
            a3,
            a4,
            a5,
            (const struct _s_HandlerType *)(v10 - 16),
            0,
            i,
            a7,
            (struct EHRegistrationNode *)TargetFrame,
            1u);
      }
      ++v13;
    }
  }
  return result;
}
// 10015C7F: using guessed type _DWORD __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, _DWORD, struct EHRegistrationNode *);
// 10017B4E: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);
// 101C80FC: using guessed type int dword_101C80FC;

//----- (10017A9A) --------------------------------------------------------
unsigned int __usercall sub_10017A9A@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8, int a9)
{
  unsigned int v9; // eax
  int v10; // esi
  int v11; // eax
  int v12; // [esp-Ch] [ebp-28h] BYREF
  int v13; // [esp-8h] [ebp-24h]
  int v14; // [esp-4h] [ebp-20h]
  int v15; // [esp+0h] [ebp-1Ch]
  int *v16; // [esp+4h] [ebp-18h]
  unsigned int v17; // [esp+Ch] [ebp-10h]
  void *v18; // [esp+10h] [ebp-Ch]
  void *v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h]

  v20 = -1;
  v19 = &unk_10021C28;
  v18 = &unknown_libname_67;
  v9 = __readfsdword(0);
  v17 = v9;
  v14 = a3;
  v13 = a5;
  v12 = a4;
  v16 = &v12;
  v10 = *(_DWORD *)(a6 + 8);
  v15 = v10;
  while ( v10 != a9 )
  {
    if ( v10 <= -1 || v10 >= *(_DWORD *)(a8 + 4) )
      sub_10018002(a2, a6, a8, v10, v12, v13, v14);
    v20 = 0;
    v11 = *(_DWORD *)(*(_DWORD *)(a8 + 8) + 8 * v10 + 4);
    if ( v11 )
      unknown_libname_65(v11, a6, 259);
    v20 = -1;
    v9 = *(_DWORD *)(a8 + 8);
    v10 = *(_DWORD *)(v9 + 8 * v10);
    v15 = v10;
  }
  *(_DWORD *)(a6 + 8) = v10;
  return v9;
}
// 10017A9A: could not find valid save-restore pair for ebx
// 10017A9A: could not find valid save-restore pair for edi
// 10017A9A: could not find valid save-restore pair for esi
// 10017ADB: variable 'a2' is possibly undefined
// 10017F50: using guessed type _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD);

//----- (10017BC9) --------------------------------------------------------
void *__cdecl sub_10017BC9(int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // [esp-Ch] [ebp-38h] BYREF
  void *v10; // [esp+0h] [ebp-2Ch]
  int v11; // [esp+4h] [ebp-28h]
  int v12; // [esp+8h] [ebp-24h]
  int v13; // [esp+Ch] [ebp-20h]
  int v14; // [esp+10h] [ebp-1Ch]
  int *v15; // [esp+14h] [ebp-18h]
  unsigned int v16; // [esp+1Ch] [ebp-10h]
  void *v17; // [esp+20h] [ebp-Ch]
  void *v18; // [esp+24h] [ebp-8h]
  int v19; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v19 = -1;
  v18 = &unk_10021C38;
  v17 = &unknown_libname_67;
  v16 = __readfsdword(0);
  v15 = &v9;
  v10 = (void *)a6;
  v12 = 0;
  v11 = *(_DWORD *)(a3 - 4);
  v14 = dword_101C80F4;
  v13 = dword_101C80F8;
  dword_101C80F4 = a2;
  dword_101C80F8 = a4;
  v19 = 1;
  v10 = _CallCatchBlock2((struct EHRegistrationNode *)a3, (const struct _s_FuncInfo *)a5, (void *)a6, a7, a8);
  v19 = -1;
  sub_10017C8F(0, (int)&savedregs, a2, a3);
  return v10;
}
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017C8F) --------------------------------------------------------
int __usercall sub_10017C8F@<eax>(int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>)
{
  int result; // eax

  *(_DWORD *)(a5 - 4) = *(_DWORD *)(a3 - 40);
  dword_101C80F4 = *(_DWORD *)(a3 - 28);
  result = *(_DWORD *)(a3 - 32);
  dword_101C80F8 = result;
  if ( *(_DWORD *)a4 == -529697949
    && *(_DWORD *)(a4 + 16) == 3
    && *(_DWORD *)(a4 + 20) == 429065504
    && *(_DWORD *)(a3 - 36) == a2
    && *(_DWORD *)(a3 - 44) != a2 )
  {
    _abnormal_termination_0();
    result = unknown_libname_64(a4);
  }
  return result;
}
// 10017EC3: using guessed type _DWORD __cdecl unknown_libname_64(_DWORD);
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017CFF) --------------------------------------------------------
char *__usercall BuildCatchObject@<eax>(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5)
{
  char *result; // eax
  char **v6; // edi
  struct EHExceptionRecord *v7; // esi
  bool v8; // eax
  int v9; // ecx
  bool v10; // eax
  bool v11; // eax
  bool v12; // eax
  bool v13; // eax
  bool v14; // eax
  char *v15; // eax
  bool v16; // eax
  bool v17; // eax
  bool v18; // eax
  int v19; // [esp-18h] [ebp-30h]
  int v20; // [esp-14h] [ebp-2Ch]
  int v21; // [esp-14h] [ebp-2Ch]
  const struct PMD *v22; // [esp-14h] [ebp-2Ch]
  int v23; // [esp-14h] [ebp-2Ch]
  int v24; // [esp-14h] [ebp-2Ch]
  int v25; // [esp-14h] [ebp-2Ch]
  int v26; // [esp-14h] [ebp-2Ch]
  size_t v27; // [esp-14h] [ebp-2Ch]
  int v28; // [esp-14h] [ebp-2Ch]
  int v29; // [esp-14h] [ebp-2Ch]
  int v30; // [esp-14h] [ebp-2Ch]
  int v31[9]; // [esp-10h] [ebp-28h] BYREF
  int v32; // [esp+14h] [ebp-4h]

  v32 = -1;
  v31[8] = (int)&unk_10021C50;
  v31[7] = (int)&unknown_libname_67;
  v31[6] = __readfsdword(0);
  v31[4] = (int)v31;
  result = (char *)*((_DWORD *)a4 + 1);
  if ( !result )
    return result;
  if ( !result[8] )
    return result;
  result = (char *)*((_DWORD *)a4 + 2);
  if ( !result )
    return result;
  v6 = (char **)((char *)a3 + (_DWORD)result + 12);
  v32 = 0;
  if ( (*(_BYTE *)a4 & 8) != 0 )
  {
    v7 = a2;
    v8 = sub_1001AB9E(*((_DWORD *)a2 + 6), 1);
    v9 = v20;
    if ( v8 )
    {
      v10 = sub_1001ABBA((int)v6, 1);
      v9 = v21;
      if ( v10 )
      {
        result = (char *)*((_DWORD *)a2 + 6);
        *v6 = result;
        v22 = (const struct _s_CatchableType *)((char *)a5 + 8);
LABEL_8:
        result = AdjustPointer(result, v22);
        *v6 = result;
        return result;
      }
    }
    return (char *)sub_10018002(v9, (int)a1, (int)v6, (int)v7, v31[0], v31[1], v31[2]);
  }
  v7 = a5;
  if ( (*(_BYTE *)a5 & 1) == 0 )
  {
    a1 = a2;
    v19 = *((_DWORD *)a2 + 6);
    if ( !*((_DWORD *)a5 + 6) )
    {
      v13 = sub_1001AB9E(v19, 1);
      v9 = v25;
      if ( v13 )
      {
        v14 = sub_1001ABBA((int)v6, 1);
        v9 = v26;
        if ( v14 )
        {
          v27 = *((_DWORD *)a5 + 5);
          v15 = AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
          return (char *)memcpy_0(v6, v15, v27);
        }
      }
      return (char *)sub_10018002(v9, (int)a1, (int)v6, (int)v7, v31[0], v31[1], v31[2]);
    }
    v16 = sub_1001AB9E(v19, 1);
    v9 = v28;
    if ( v16 )
    {
      v17 = sub_1001ABBA((int)v6, 1);
      v9 = v29;
      if ( v17 )
      {
        v18 = sub_1001ABD6(*((_DWORD *)a5 + 6));
        v9 = v30;
        if ( v18 )
        {
          if ( (*(_BYTE *)a5 & 4) != 0 )
          {
            AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
            result = (char *)sub_10015B60(v6, *((_DWORD *)a5 + 6));
          }
          else
          {
            AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
            result = (char *)sub_10015B59(v6, *((_DWORD *)a5 + 6));
          }
          return result;
        }
      }
    }
    return (char *)sub_10018002(v9, (int)a1, (int)v6, (int)v7, v31[0], v31[1], v31[2]);
  }
  a1 = a2;
  v11 = sub_1001AB9E(*((_DWORD *)a2 + 6), 1);
  v9 = v23;
  if ( !v11 )
    return (char *)sub_10018002(v9, (int)a1, (int)v6, (int)v7, v31[0], v31[1], v31[2]);
  v12 = sub_1001ABBA((int)v6, 1);
  v9 = v24;
  if ( !v12 )
    return (char *)sub_10018002(v9, (int)a1, (int)v6, (int)v7, v31[0], v31[1], v31[2]);
  result = (char *)memcpy_0(v6, *((const void **)a2 + 6), *((_DWORD *)a5 + 5));
  if ( *((_DWORD *)a5 + 5) == 4 )
  {
    result = *v6;
    if ( *v6 )
    {
      v22 = (const struct _s_CatchableType *)((char *)a5 + 8);
      goto LABEL_8;
    }
  }
  return result;
}
// 10017D66: variable 'v20' is possibly undefined
// 10017D78: variable 'v21' is possibly undefined
// 10017DB2: variable 'v23' is possibly undefined
// 10017DC4: variable 'v24' is possibly undefined
// 10017E0A: variable 'v25' is possibly undefined
// 10017E1C: variable 'v26' is possibly undefined
// 10017E44: variable 'v28' is possibly undefined
// 10017E52: variable 'v29' is possibly undefined
// 10017E5F: variable 'v30' is possibly undefined
// 10015B59: using guessed type _DWORD __cdecl sub_10015B59(_DWORD, _DWORD);
// 10015B60: using guessed type _DWORD __cdecl sub_10015B60(_DWORD, _DWORD);

//----- (10017F2A) --------------------------------------------------------
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2)
{
  int v2; // edx
  char *result; // eax

  v2 = *((_DWORD *)a2 + 1);
  result = (char *)a1 + *(_DWORD *)a2;
  if ( v2 >= 0 )
    result += v2 + *(_DWORD *)(*(_DWORD *)((char *)a1 + v2) + *((_DWORD *)a2 + 2));
  return result;
}

//----- (10017F9C) --------------------------------------------------------
int __usercall sub_10017F9C@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8)
{
  int v9; // [esp-Ch] [ebp-24h] BYREF
  int v10; // [esp-8h] [ebp-20h]
  int v11; // [esp-4h] [ebp-1Ch]
  int *v12; // [esp+0h] [ebp-18h]
  int v13; // [esp+4h] [ebp-14h]
  unsigned int v14; // [esp+8h] [ebp-10h]
  void *v15; // [esp+Ch] [ebp-Ch]
  void *v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]

  v16 = &unk_10021C70;
  v15 = &unknown_libname_67;
  v14 = __readfsdword(0);
  v13 = a2;
  v11 = a3;
  v10 = a5;
  v9 = a4;
  v12 = &v9;
  v17 = 0;
  if ( dword_101C8100 )
  {
    dword_101C8100(v9, v10, v11, v12, v13, v14, v15, v16, 1);
    v17 = 0;
  }
  v17 = -1;
  return sub_10016FE0(a5);
}
// 101C8100: using guessed type int (__cdecl *dword_101C8100)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018002) --------------------------------------------------------
int __usercall sub_10018002@<eax>(int a2@<ecx>, int a3@<ebx>, int a4@<edi>, int a5@<esi>, int a6, int a7, int a8)
{
  int v9; // [esp-Ch] [ebp-24h] BYREF
  int v10; // [esp-8h] [ebp-20h]
  int v11; // [esp-4h] [ebp-1Ch]
  int *v12; // [esp+0h] [ebp-18h]
  int v13; // [esp+4h] [ebp-14h]
  unsigned int v14; // [esp+8h] [ebp-10h]
  void *v15; // [esp+Ch] [ebp-Ch]
  void *v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]

  v16 = &unk_10021C88;
  v15 = &unknown_libname_67;
  v14 = __readfsdword(0);
  v13 = a2;
  v11 = a3;
  v10 = a5;
  v9 = a4;
  v12 = &v9;
  v17 = 0;
  if ( off_10025DF4 )
  {
    off_10025DF4(v9, v10, v11, v12, v13, v14, v15, v16, 1);
    v17 = 0;
  }
  v17 = -1;
  return sub_10017F9C(a2, a3, a4, a5, a6, a7, a8);
}
// 10018053: variable 'a2' is possibly undefined
// 10025DF4: using guessed type int (__cdecl *off_10025DF4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018058) --------------------------------------------------------
int __cdecl _isctype_0(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int result; // eax
  int v5; // [esp-4h] [ebp-8h]
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = v2;
  if ( (unsigned int)(a1 + 1) <= 0x100 )
  {
    v3 = *(unsigned __int16 *)(dword_10025DF8 + 2 * a1);
    return a2 & v3;
  }
  if ( *(char *)(dword_10025DF8 + 2 * BYTE1(a1) + 1) >= 0 )
  {
    LOWORD(v6) = (unsigned __int8)a1;
    v5 = 1;
  }
  else
  {
    LOBYTE(v6) = BYTE1(a1);
    *(_WORD *)((char *)&v6 + 1) = (unsigned __int8)a1;
    v5 = 2;
  }
  result = __crtGetStringTypeA_0(1u, (LPCSTR)&v6, v5, (LPWORD)&a1 + 1, 0, 0, 1);
  if ( result )
  {
    v3 = HIWORD(a1);
    return a2 & v3;
  }
  return result;
}
// 1001805B: variable 'v2' is possibly undefined
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100180CD) --------------------------------------------------------
int __cdecl _flsbuf_0(int a1, FILE *a2)
{
  FILE *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  char *v6; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = a2;
  v3 = a2->_flag;
  v4 = a2->_file;
  if ( (v3 & 0x82) == 0 || (v3 & 0x40) != 0 )
    goto LABEL_24;
  if ( (v3 & 1) == 0 )
    goto LABEL_6;
  a2->_cnt = 0;
  if ( (v3 & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(v3) = v3 | 0x20;
    v2->_flag = v3;
    return -1;
  }
  LOBYTE(v3) = v3 & 0xFE;
  v2->_ptr = v2->_base;
  v2->_flag = v3;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  a2 = 0;
  LOBYTE(v5) = v5 & 0xEF | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (FILE *)&unk_10026040 && v2 != &stru_10026060 || !_isatty_0(v4)) )
    _getbuf_0((int)v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    v6 = v2->_base;
    v7 = v2->_ptr - v6;
    v2->_ptr = v6 + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = &unk_10026350;
      else
        v8 = (_BYTE *)(dword_101C85E0[v4 >> 5] + 8 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        _lseek_0(v4, 0, 2);
    }
    else
    {
      a2 = (FILE *)_write_0(v4, v6, v7);
    }
    *v2->_base = a1;
  }
  else
  {
    v7 = 1;
    a2 = (FILE *)_write_0(v4, &a1, 1u);
  }
  if ( a2 == (FILE *)v7 )
    return (unsigned __int8)a1;
  v2->_flag |= 0x20u;
  return -1;
}
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (100181E2) --------------------------------------------------------
int __cdecl _output_0(FILE *File, int a2, int a3)
{
  int v3; // esi
  char v4; // bl
  char *v5; // edi
  _BOOL1 v6; // zf
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // esi
  int v12; // eax
  int v13; // ecx
  _WORD *i; // eax
  int v15; // edx
  char *v16; // edi
  __int16 v17; // ax
  __int16 *v18; // eax
  int v19; // ecx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // esi
  _BYTE *j; // eax
  int v24; // edx
  _WORD *v25; // eax
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  int v28; // eax
  int v29; // ebx
  unsigned __int64 v30; // kr08_8
  char *v31; // eax
  char *v32; // eax
  char v33; // bl
  int v34; // esi
  wchar_t *v35; // ebx
  int v36; // edi
  wchar_t v37; // ax
  int v38; // eax
  const char *v41; // [esp-4h] [ebp-258h]
  char v42; // [esp+Ch] [ebp-248h] BYREF
  char v43[498]; // [esp+Dh] [ebp-247h] BYREF
  char v44; // [esp+20Bh] [ebp-49h] BYREF
  int v45[2]; // [esp+20Ch] [ebp-48h] BYREF
  __int64 v46; // [esp+214h] [ebp-40h]
  char v47[4]; // [esp+21Ch] [ebp-38h] BYREF
  int v48; // [esp+220h] [ebp-34h]
  int v49; // [esp+224h] [ebp-30h]
  int v50; // [esp+228h] [ebp-2Ch]
  int v51; // [esp+22Ch] [ebp-28h]
  int v52; // [esp+230h] [ebp-24h]
  int v53; // [esp+234h] [ebp-20h]
  int v54; // [esp+238h] [ebp-1Ch]
  char v55[2]; // [esp+23Eh] [ebp-16h] BYREF
  int v56; // [esp+240h] [ebp-14h] BYREF
  int v57; // [esp+244h] [ebp-10h]
  int v58; // [esp+248h] [ebp-Ch]
  char *v59; // [esp+24Ch] [ebp-8h]
  int v60; // [esp+250h] [ebp-4h]
  char *v61; // [esp+260h] [ebp+Ch]

  v3 = 0;
  v4 = *(_BYTE *)a2;
  v5 = (char *)(a2 + 1);
  v6 = *(_BYTE *)a2 == 0;
  v58 = 0;
  v56 = 0;
  v61 = (char *)(a2 + 1);
  if ( !v6 )
  {
    v7 = v57;
    while ( 1 )
    {
      if ( v56 < 0 )
        return v56;
      if ( v4 < 32 || v4 > 120 )
        v8 = 0;
      else
        v8 = byte_10021C80[v4] & 0xF;
      v49 = byte_10021CA0[8 * v8 + v3] >> 4;
      switch ( v49 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v57 = -1;
          v48 = 0;
          v51 = 0;
          v53 = 0;
          v54 = 0;
          v60 = 0;
          v52 = 0;
          goto LABEL_180;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v60 |= 2u;
              break;
            case '#':
              LOBYTE(v60) = v60 | 0x80;
              break;
            case '+':
              v60 |= 1u;
              break;
            case '-':
              v60 |= 4u;
              break;
            case '0':
              v60 |= 8u;
              break;
          }
          goto LABEL_180;
        case 3:
          if ( v4 == 42 )
          {
            v9 = sub_100189C1((int)&a3);
            v53 = v9;
            if ( v9 >= 0 )
              goto LABEL_180;
            v60 |= 4u;
            v10 = -v9;
          }
          else
          {
            v10 = v4 + 10 * v53 - 48;
          }
          v53 = v10;
          goto LABEL_180;
        case 4:
          v57 = 0;
          goto LABEL_180;
        case 5:
          if ( v4 == 42 )
          {
            v57 = sub_100189C1((int)&a3);
            if ( v57 < 0 )
              v57 = -1;
          }
          else
          {
            v57 = v4 + 10 * v7 - 48;
          }
          goto LABEL_180;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v60) |= 0x80u;
                v61 = v5 + 2;
              }
              else
              {
                v49 = 0;
LABEL_42:
                v52 = 0;
                if ( *(char *)(dword_10025DF8 + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char_0(v4, File, (int)&v56);
                  v4 = *v5;
                  v61 = v5 + 1;
                }
                write_char_0(v4, File, (int)&v56);
              }
              break;
            case 'h':
              v60 |= 0x20u;
              break;
            case 'l':
              v60 |= 0x10u;
              break;
            case 'w':
              BYTE1(v60) |= 8u;
              break;
          }
          goto LABEL_180;
        case 7:
          if ( v4 <= 103 )
          {
            if ( v4 >= 101 )
              goto LABEL_65;
            if ( v4 > 88 )
            {
              if ( v4 == 90 )
              {
                v18 = (__int16 *)sub_100189C1((int)&a3);
                if ( v18 )
                {
                  v19 = *((_DWORD *)v18 + 1);
                  if ( v19 )
                  {
                    if ( (v60 & 0x800) != 0 )
                    {
                      v20 = (unsigned int)*v18 >> 1;
                      v59 = (char *)v19;
                      v58 = v20;
                      v52 = 1;
                      goto LABEL_157;
                    }
                    v52 = 0;
                    v59 = (char *)v19;
                    v21 = *v18;
                    goto LABEL_156;
                  }
                }
                v59 = (char *)dword_10026010;
                v41 = (const char *)dword_10026010;
LABEL_96:
                v21 = strlen(v41);
                goto LABEL_156;
              }
              if ( v4 == 99 )
                goto LABEL_69;
              if ( v4 != 100 )
                goto LABEL_157;
LABEL_123:
              v60 |= 0x40u;
LABEL_124:
              v58 = 10;
              goto LABEL_125;
            }
            if ( v4 != 88 )
            {
              if ( v4 != 67 )
              {
                if ( v4 == 69 || v4 == 71 )
                {
                  v48 = 1;
                  v4 += 32;
LABEL_65:
                  v60 |= 0x40u;
                  v16 = &v42;
                  v59 = &v42;
                  if ( v7 >= 0 )
                  {
                    if ( !v7 && v4 == 103 )
                      v57 = 1;
                  }
                  else
                  {
                    v57 = 6;
                  }
                  a3 += 8;
                  v45[0] = *(_DWORD *)(a3 - 8);
                  v45[1] = *(_DWORD *)(a3 - 4);
                  off_10026330(v45, &v42, v4, v57, v48);
                  v22 = v60 & 0x80;
                  if ( (v60 & 0x80) != 0 && !v57 )
                    off_1002633C(&v42);
                  if ( v4 == 103 && !v22 )
                    off_10026334(&v42);
                  if ( v42 == 45 )
                  {
                    BYTE1(v60) |= 1u;
                    v16 = v43;
                    v59 = v43;
                  }
                  v41 = v16;
                  goto LABEL_96;
                }
                if ( v4 != 83 )
                  goto LABEL_157;
                if ( (v60 & 0x830) == 0 )
                  BYTE1(v60) |= 8u;
LABEL_55:
                v11 = v57;
                if ( v57 == -1 )
                  v11 = 0x7FFFFFFF;
                v12 = sub_100189C1((int)&a3);
                v13 = v12;
                v59 = (char *)v12;
                if ( (v60 & 0x810) != 0 )
                {
                  if ( !v12 )
                  {
                    v13 = dword_10026014;
                    v59 = (char *)dword_10026014;
                  }
                  v52 = 1;
                  for ( i = (_WORD *)v13; ; ++i )
                  {
                    v15 = v11--;
                    if ( !v15 || !*i )
                      break;
                  }
                  v21 = ((int)i - v13) >> 1;
                }
                else
                {
                  if ( !v12 )
                  {
                    v13 = dword_10026010;
                    v59 = (char *)dword_10026010;
                  }
                  for ( j = (_BYTE *)v13; ; ++j )
                  {
                    v24 = v11--;
                    if ( !v24 || !*j )
                      break;
                  }
                  v21 = (int)&j[-v13];
                }
LABEL_156:
                v58 = v21;
                goto LABEL_157;
              }
              if ( (v60 & 0x830) == 0 )
                BYTE1(v60) |= 8u;
LABEL_69:
              if ( (v60 & 0x810) != 0 )
              {
                v17 = sub_100189DE((int)&a3);
                v58 = wctomb_0(&v42, v17);
                if ( v58 < 0 )
                  v51 = 1;
              }
              else
              {
                v42 = sub_100189C1((int)&a3);
                v58 = 1;
              }
              v59 = &v42;
              goto LABEL_157;
            }
            goto LABEL_114;
          }
          if ( v4 == 105 )
            goto LABEL_123;
          if ( v4 == 110 )
          {
            v25 = (_WORD *)sub_100189C1((int)&a3);
            if ( (v60 & 0x20) != 0 )
              *v25 = v56;
            else
              *(_DWORD *)v25 = v56;
            v51 = 1;
            goto LABEL_180;
          }
          if ( v4 != 111 )
          {
            if ( v4 != 112 )
            {
              if ( v4 == 115 )
                goto LABEL_55;
              if ( v4 == 117 )
                goto LABEL_124;
              if ( v4 != 120 )
                goto LABEL_157;
              v50 = 39;
              goto LABEL_115;
            }
            v57 = 8;
LABEL_114:
            v50 = 7;
LABEL_115:
            v58 = 16;
            if ( (v60 & 0x80u) != 0 )
            {
              v55[0] = 48;
              v54 = 2;
              v55[1] = v50 + 81;
            }
            goto LABEL_125;
          }
          v58 = 8;
          if ( (v60 & 0x80u) != 0 )
            BYTE1(v60) |= 2u;
LABEL_125:
          if ( (v60 & 0x8000) == 0 )
          {
            if ( (v60 & 0x20) != 0 )
            {
              if ( (v60 & 0x40) != 0 )
                LODWORD(v26) = (__int16)sub_100189C1((int)&a3);
              else
                LODWORD(v26) = (unsigned __int16)sub_100189C1((int)&a3);
            }
            else
            {
              if ( (v60 & 0x40) == 0 )
              {
                v26 = (unsigned int)sub_100189C1((int)&a3);
                goto LABEL_135;
              }
              LODWORD(v26) = sub_100189C1((int)&a3);
            }
            v26 = (int)v26;
          }
          else
          {
            v26 = sub_100189CE((int)&a3);
          }
LABEL_135:
          if ( (v60 & 0x40) != 0 && v26 < 0 )
          {
            HIDWORD(v27) = -(int)v26;
            BYTE1(v60) |= 1u;
            LODWORD(v27) = (unsigned __int64)-v26 >> 32;
          }
          else
          {
            v27 = __PAIR64__(v26, HIDWORD(v26));
          }
          if ( (v60 & 0x8000) == 0 )
            LODWORD(v27) = 0;
          if ( v57 >= 0 )
            v60 &= 0xFFFFFFF7;
          else
            v57 = 1;
          if ( !v27 )
            v54 = 0;
          v59 = &v44;
          while ( 1 )
          {
            v28 = v57--;
            if ( v28 <= 0 && !v27 )
              break;
            v46 = v58;
            v29 = __PAIR64__(v27, HIDWORD(v27)) % v58 + 48;
            v30 = __PAIR64__(v27, HIDWORD(v27)) / v58;
            v27 = __PAIR64__(v30, HIDWORD(v30));
            if ( v29 > 57 )
              LOBYTE(v29) = v50 + v29;
            v31 = v59--;
            *v31 = v29;
          }
          v32 = (char *)(&v44 - v59++);
          v58 = (int)v32;
          if ( (v60 & 0x200) != 0 && (*v59 != 48 || !v32) )
          {
            --v59;
            v21 = (int)(v32 + 1);
            *v59 = 48;
            goto LABEL_156;
          }
LABEL_157:
          if ( v51 )
            goto LABEL_180;
          v33 = v60;
          if ( (v60 & 0x40) == 0 )
            goto LABEL_166;
          if ( (v60 & 0x100) != 0 )
          {
            v55[0] = 45;
LABEL_165:
            v54 = 1;
            goto LABEL_166;
          }
          if ( (v60 & 1) != 0 )
          {
            v55[0] = 43;
            goto LABEL_165;
          }
          if ( (v60 & 2) != 0 )
          {
            v55[0] = 32;
            goto LABEL_165;
          }
LABEL_166:
          v34 = v53 - v54 - v58;
          if ( (v60 & 0xC) == 0 )
            write_multi_char_0(32, v53 - v54 - v58, (int)File, (int)&v56);
          write_string_0((int)v55, v54, File, (int)&v56);
          if ( (v33 & 8) != 0 && (v33 & 4) == 0 )
            write_multi_char_0(48, v34, (int)File, (int)&v56);
          if ( v52 && v58 > 0 )
          {
            v35 = (wchar_t *)v59;
            v36 = v58 - 1;
            do
            {
              v37 = *v35++;
              v38 = wctomb_0(v47, v37);
              if ( v38 <= 0 )
                break;
              write_string_0((int)v47, v38, File, (int)&v56);
            }
            while ( v36-- );
          }
          else
          {
            write_string_0((int)v59, v58, File, (int)&v56);
          }
          if ( (v60 & 4) != 0 )
            write_multi_char_0(32, v34, (int)File, (int)&v56);
LABEL_180:
          v4 = *v61;
          v5 = v61 + 1;
          v6 = *v61++ == 0;
          if ( v6 )
            return v56;
          v7 = v57;
          v3 = v49;
          break;
        default:
          goto LABEL_180;
      }
    }
  }
  return v56;
}
// 10025DF8: using guessed type int dword_10025DF8;
// 10026010: using guessed type int dword_10026010;
// 10026014: using guessed type int dword_10026014;
// 10026330: using guessed type int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10026334: using guessed type int (__cdecl *off_10026334)(_DWORD);
// 1002633C: using guessed type int (__cdecl *off_1002633C)(_DWORD);

//----- (10018923) --------------------------------------------------------
int __cdecl write_char_0(int a1, FILE *File, int a3)
{
  int v4; // eax
  _BOOL1 v5; // zf
  int result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf_0(a1, File);
  }
  else
  {
    *File->_ptr++ = a1;
    v4 = (unsigned __int8)a1;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *(_DWORD *)a3 = -1;
  else
    ++*(_DWORD *)a3;
  return result;
}

//----- (10018958) --------------------------------------------------------
int __cdecl write_multi_char_0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int i; // edi

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    result = write_char_0(a1, (FILE *)a3, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (10018989) --------------------------------------------------------
int __cdecl write_string_0(int a1, int a2, FILE *File, int a4)
{
  int result; // eax
  int i; // ebx
  int v7; // eax

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    v7 = *(char *)a1++;
    result = write_char_0(v7, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (100189C1) --------------------------------------------------------
int __cdecl sub_100189C1(int a1)
{
  *(_DWORD *)a1 += 4;
  return *(_DWORD *)(*(_DWORD *)a1 - 4);
}

//----- (100189CE) --------------------------------------------------------
__int64 __cdecl sub_100189CE(int a1)
{
  *(_DWORD *)a1 += 8;
  return *(_QWORD *)(*(_DWORD *)a1 - 8);
}

//----- (100189DE) --------------------------------------------------------
__int16 __cdecl sub_100189DE(int a1)
{
  *(_DWORD *)a1 += 4;
  return *(_WORD *)(*(_DWORD *)a1 - 4);
}

//----- (100189EC) --------------------------------------------------------
void __cdecl sub_100189EC(unsigned int a1)
{
  int v1; // esi
  unsigned int v2; // eax
  int v3; // eax
  int v4; // [esp-4h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-4h] BYREF

  v1 = a1;
  if ( a1 )
  {
    if ( dword_101C86E8 == 3 )
    {
      v2 = __sbh_find_block_0(a1);
      v4 = v1;
      if ( v2 )
      {
        sub_1001B27A(v2, v1);
        return;
      }
    }
    else
    {
      if ( dword_101C86E8 == 2 )
      {
        v3 = sub_1001C3CC(a1, (int)&v5, (int)&a1);
        if ( v3 )
        {
          sub_1001C423(v5, a1, v3);
          return;
        }
      }
      v4 = v1;
    }
    FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, v4);
  }
}
// 10021164: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10018B48) --------------------------------------------------------
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  LPSTR v17; // [esp-D8h] [ebp-D8h]
  int v18; // [esp-D4h] [ebp-D4h]
  _BYTE v19[48]; // [esp-B0h] [ebp-B0h] BYREF
  _BYTE v20[72]; // [esp-80h] [ebp-80h] BYREF
  _DWORD v21[5]; // [esp-38h] [ebp-38h] BYREF
  _BYTE *v22; // [esp-24h] [ebp-24h]
  _BYTE *v23; // [esp-20h] [ebp-20h]
  int v24; // [esp-1Ch] [ebp-1Ch]
  _BYTE *v25; // [esp-18h] [ebp-18h]
  unsigned int v26; // [esp-10h] [ebp-10h]
  void *v27; // [esp-Ch] [ebp-Ch]
  void *v28; // [esp-8h] [ebp-8h]
  int v29; // [esp-4h] [ebp-4h]

  v29 = -1;
  v28 = &unk_10021D20;
  v27 = &unknown_libname_67;
  v26 = __readfsdword(0);
  v25 = v21;
  if ( dword_101C8108 )
  {
LABEL_6:
    if ( cbMultiByte > 0 )
      cbMultiByte = (int)strncnt_0((int)lpMultiByteStr, cbMultiByte);
    if ( dword_101C8108 == 2 )
      return FIX_DLL_KERNEL32_dll_LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest);
    if ( dword_101C8108 != 1 )
      return 0;
    if ( !CodePage )
      CodePage = dword_101C8124;
    v9 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, a8 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
    v10 = v9;
    v24 = v9;
    if ( !v9 )
      return 0;
    v11 = 2 * v9 + 3;
    LOBYTE(v11) = v11 & 0xFC;
    v12 = alloca(v11);
    v25 = v20;
    v22 = v20;
    v29 = -1;
    if ( !v20 )
      return 0;
    if ( !FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, v22, v10) )
      return 0;
    v13 = FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v10, 0, 0);
    v14 = v13;
    v21[4] = v13;
    if ( !v13 )
      return 0;
    if ( (dwMapFlags & 0x400) != 0 )
    {
      if ( cchDest
        && (v13 > cchDest || !FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v10, lpDestStr, cchDest)) )
      {
        return 0;
      }
    }
    else
    {
      v15 = 2 * v13 + 3;
      LOBYTE(v15) = v15 & 0xFC;
      v16 = alloca(v15);
      v25 = v19;
      v23 = v19;
      v29 = -1;
      if ( !v19 || !FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v24, v19, v14) )
        return 0;
      if ( cchDest )
      {
        v18 = cchDest;
        v17 = lpDestStr;
      }
      else
      {
        v18 = 0;
        v17 = 0;
      }
      v14 = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(CodePage, 544, v19, v14, v17, v18, 0, 0);
      if ( !v14 )
        return 0;
    }
    return v14;
  }
  if ( FIX_DLL_KERNEL32_dll_LCMapStringW(0, 256, &unk_10021D18, 1, 0, 0) )
  {
    dword_101C8108 = 1;
    goto LABEL_6;
  }
  if ( FIX_DLL_KERNEL32_dll_LCMapStringA(0, 256, &unk_10021D14, 1, 0, 0) )
  {
    dword_101C8108 = 2;
    goto LABEL_6;
  }
  return 0;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021174: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021178: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8108: using guessed type int dword_101C8108;

//----- (10018D6C) --------------------------------------------------------
_BYTE *__cdecl strncnt_0(int a1, int a2)
{
  _BYTE *v2; // eax
  int v3; // ecx
  _BYTE *result; // eax

  v2 = (_BYTE *)a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = (_BYTE *)a2;
  else
    result = &v2[-a1];
  return result;
}

//----- (10018D97) --------------------------------------------------------
void *__cdecl sub_10018D97(unsigned int a1, int a2)
{
  void *result; // eax
  unsigned int v3; // esi
  int v4; // edi
  int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // eax
  int v13; // [esp+0h] [ebp-4h] BYREF

  if ( !a1 )
    return sub_10019098(a2);
  v3 = a2;
  if ( !a2 )
  {
    sub_100189EC(a1);
    return 0;
  }
  if ( dword_101C86E8 == 3 )
  {
    while ( 1 )
    {
      v4 = 0;
      if ( v3 <= 0xFFFFFFE0 )
        break;
LABEL_26:
      if ( !dword_101C8280 )
        return (void *)v4;
      if ( !sub_1001C9B1(v3) )
        return 0;
    }
    v5 = __sbh_find_block_0(a1);
    v6 = v5;
    if ( !v5 )
    {
LABEL_22:
      if ( !v3 )
        v3 = 1;
      v3 = (v3 + 15) & 0xFFFFFFF0;
      v4 = FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
LABEL_25:
      if ( v4 )
        return (void *)v4;
      goto LABEL_26;
    }
    if ( v3 > dword_101C85C4 )
      goto LABEL_15;
    v4 = a1;
    if ( __sbh_resize_block_0(v5, a1, v3) )
      goto LABEL_21;
    v4 = (int)__sbh_alloc_block_0(v3);
    if ( v4 )
    {
      v7 = *(_DWORD *)(a1 - 4) - 1;
      if ( v7 >= v3 )
        v7 = v3;
      ((void (__cdecl *)(int, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v7);
      v6 = __sbh_find_block_0(a1);
      sub_1001B27A(v6, a1);
    }
    else
    {
LABEL_15:
      if ( !v3 )
        v3 = 1;
      v3 = (v3 + 15) & 0xFFFFFFF0;
      v4 = FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
      if ( v4 )
      {
        v8 = *(_DWORD *)(a1 - 4) - 1;
        if ( v8 >= v3 )
          v8 = v3;
        ((void (__cdecl *)(int, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v8);
        sub_1001B27A(v6, a1);
      }
    }
LABEL_21:
    if ( v6 )
      goto LABEL_25;
    goto LABEL_22;
  }
  if ( dword_101C86E8 != 2 )
  {
    do
    {
      result = 0;
      if ( v3 <= 0xFFFFFFE0 )
      {
        if ( !v3 )
          v3 = 1;
        v3 = (v3 + 15) & 0xFFFFFFF0;
        result = (void *)FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
        if ( result )
          return result;
      }
      if ( !dword_101C8280 )
        return result;
    }
    while ( sub_1001C9B1(v3) );
    return 0;
  }
  if ( (unsigned int)a2 <= 0xFFFFFFE0 )
    v3 = (a2 + 15) & 0xFFFFFFF0;
  while ( 1 )
  {
    v4 = 0;
    if ( v3 > 0xFFFFFFE0 )
      goto LABEL_49;
    v9 = sub_1001C3CC(a1, (int)&v13, (int)&a2);
    v10 = (unsigned __int8 *)v9;
    if ( !v9 )
    {
      v4 = FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
      goto LABEL_48;
    }
    if ( v3 < dword_10028384 )
    {
      if ( sub_1001C794(v13, a2, v9, v3 >> 4) )
        return (void *)a1;
      v4 = (int)sub_1001C468(v3 >> 4);
      if ( v4 )
        break;
    }
    v4 = FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
    if ( !v4 )
      goto LABEL_49;
    v12 = 16 * *v10;
    if ( v12 >= v3 )
      v12 = v3;
    ((void (__cdecl *)(int, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v12);
    sub_1001C423(v13, a2, (int)v10);
LABEL_48:
    if ( v4 )
      return (void *)v4;
LABEL_49:
    if ( !dword_101C8280 )
      return (void *)v4;
    if ( !sub_1001C9B1(v3) )
      return 0;
  }
  v11 = 16 * *v10;
  if ( v11 >= v3 )
    v11 = v3;
  ((void (__cdecl *)(int, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v11);
  sub_1001C423(v13, a2, (int)v10);
  return (void *)v4;
}
// 10018EE7: conditional instruction was optimized away because of '%arg_4.4 in (1..FFFFFFE0)'
// 10018E45: conditional instruction was optimized away because of 'edi.4!=0'
// 10018F76: conditional instruction was optimized away because of 'edi.4!=0'
// 1002117C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapReAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10028384: using guessed type int dword_10028384;
// 101C8280: using guessed type int dword_101C8280;
// 101C85C4: using guessed type int dword_101C85C4;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10019037) --------------------------------------------------------
int __cdecl sub_10019037(unsigned int a1)
{
  int result; // eax
  unsigned __int8 *v2; // eax
  char v3[4]; // [esp+4h] [ebp-8h] BYREF
  char v4[4]; // [esp+8h] [ebp-4h] BYREF

  if ( dword_101C86E8 == 3 )
  {
    if ( __sbh_find_block_0(a1) )
      result = *(_DWORD *)(a1 - 4) - 9;
    else
      result = FIX_DLL_KERNEL32_dll_HeapSize(dword_101C86E4, 0, a1);
  }
  else if ( dword_101C86E8 == 2 && (v2 = (unsigned __int8 *)sub_1001C3CC(a1, (int)v3, (int)v4)) != 0 )
  {
    result = 16 * *v2;
  }
  else
  {
    result = FIX_DLL_KERNEL32_dll_HeapSize(dword_101C86E4, 0, a1);
  }
  return result;
}
// 10021184: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapSize)(_DWORD, _DWORD, _DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10019098) --------------------------------------------------------
void *__cdecl sub_10019098(int a1)
{
  return _nh_malloc_0(a1, dword_101C8280);
}
// 101C8280: using guessed type int dword_101C8280;

//----- (100190AA) --------------------------------------------------------
void *__cdecl _nh_malloc_0(size_t Size, int a2)
{
  void *result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = sub_100190D6(Size);
    if ( result || !a2 )
      break;
    if ( !sub_1001C9B1(Size) )
      return 0;
  }
  return result;
}

//----- (100190D6) --------------------------------------------------------
void *__cdecl sub_100190D6(int a1)
{
  int v1; // esi
  void *result; // eax
  unsigned int v3; // esi

  v1 = a1;
  if ( dword_101C86E8 == 3 )
  {
    if ( a1 <= (unsigned int)dword_101C85C4 )
    {
      result = __sbh_alloc_block_0(a1);
      if ( result )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_101C86E8 != 2 )
  {
LABEL_12:
    if ( !a1 )
      v1 = 1;
    v3 = (v1 + 15) & 0xFFFFFFF0;
    return (void *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  }
  if ( a1 )
    v3 = (a1 + 15) & 0xFFFFFFF0;
  else
    v3 = 16;
  if ( v3 > dword_10028384 )
    return (void *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  result = sub_1001C468(v3 >> 4);
  if ( !result )
    return (void *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  return result;
}
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10028384: using guessed type int dword_10028384;
// 101C85C4: using guessed type int dword_101C85C4;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001914A) --------------------------------------------------------
int __cdecl fflush_0(FILE *a1)
{
  if ( !a1 )
    return flsall_0(0);
  if ( _flush_0((int)a1) )
    return -1;
  if ( (a1->_flag & 0x4000) != 0 )
    return -(_commit_0(a1->_file) != 0);
  return 0;
}

//----- (10019185) --------------------------------------------------------
signed int __cdecl _flush_0(int a1)
{
  int v1; // ebx
  const void *v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (*(_BYTE *)(a1 + 12) & 3) == 2 && (*(_DWORD *)(a1 + 12) & 0x108) != 0 )
  {
    v2 = *(const void **)(a1 + 8);
    if ( *(_DWORD *)a1 - (int)v2 > 0 )
    {
      v3 = *(_DWORD *)a1 - (_DWORD)v2;
      if ( _write_0(*(_DWORD *)(a1 + 16), v2, v3) == v3 )
      {
        v4 = *(_DWORD *)(a1 + 12);
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          *(_DWORD *)(a1 + 12) = v4;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 12) |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = v5;
  return v1;
}

//----- (100191EA) --------------------------------------------------------
signed int __cdecl flsall_0(int a1)
{
  int v1; // esi
  signed int v2; // ebx
  signed int i; // edi
  FILE *v4; // eax
  int v5; // ecx
  signed int result; // eax

  v1 = 0;
  v2 = 0;
  for ( i = 0; v1 < dword_101C9700; ++v1 )
  {
    v4 = *(FILE **)(dword_101C86EC + 4 * v1);
    if ( v4 )
    {
      v5 = v4->_flag;
      if ( (v5 & 0x83) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( fflush_0(v4) != -1 )
            ++v2;
        }
        else if ( !a1 && (v5 & 2) != 0 && fflush_0(*(FILE **)(dword_101C86EC + 4 * v1)) == -1 )
        {
          i = -1;
        }
      }
    }
  }
  result = v2;
  if ( a1 != 1 )
    result = i;
  return result;
}
// 101C86EC: using guessed type int dword_101C86EC;
// 101C9700: using guessed type int dword_101C9700;

//----- (10019257) --------------------------------------------------------
int fprintf_0(FILE *a1, const char *a2, ...)
{
  int v2; // esi
  int v3; // edi
  va_list va; // [esp+18h] [ebp+10h] BYREF

  va_start(va, a2);
  v2 = _stbuf_0((int)a1);
  v3 = _output_0(a1, (int)a2, (int)va);
  _ftbuf_0(v2, (int)a1);
  return v3;
}

//----- (10019527) --------------------------------------------------------
int __cdecl raise_0(int a1)
{
  int v1; // edi
  void (__cdecl *v3)(int); // esi
  int *v4; // eax
  _DWORD *v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // edx

  v1 = a1;
  switch ( a1 )
  {
    case 2:
      v3 = (void (__cdecl *)(int))dword_101C8130;
      v4 = &dword_101C8130;
      break;
    case 4:
    case 8:
    case 11:
      v5 = siglookup_0(a1);
      v3 = (void (__cdecl *)(int))v5[2];
      v4 = v5 + 2;
      break;
    case 15:
      v3 = (void (__cdecl *)(int))dword_101C813C;
      v4 = &dword_101C813C;
      break;
    case 21:
      v3 = (void (__cdecl *)(int))dword_101C8134;
      v4 = &dword_101C8134;
      break;
    case 22:
      v3 = (void (__cdecl *)(int))dword_101C8138;
      v4 = &dword_101C8138;
      break;
    default:
      return -1;
  }
  if ( v3 == (void (__cdecl *)(int))1 )
    return 0;
  if ( !v3 )
    sub_10015F50(3);
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    v6 = dword_101C8284;
    dword_101C8284 = 0;
    if ( a1 != 8 )
    {
LABEL_29:
      *v4 = 0;
      v3(v1);
      if ( v1 != 11 && v1 != 4 )
        return 0;
      goto LABEL_33;
    }
    v7 = dword_10028414;
    dword_10028414 = 140;
    a1 = v7;
  }
  else
  {
    v6 = a1;
  }
  if ( v1 != 8 )
    goto LABEL_29;
  if ( dword_10028408 < dword_10028408 + dword_1002840C )
  {
    v8 = dword_1002840C;
    v9 = (_DWORD *)(12 * dword_10028408 + 268600216);
    do
    {
      *v9 = 0;
      v9 += 3;
      --v8;
    }
    while ( v8 );
  }
  ((void (__cdecl *)(int, int))v3)(8, dword_10028414);
LABEL_33:
  dword_101C8284 = v6;
  if ( v1 == 8 )
    dword_10028414 = a1;
  return 0;
}
// 1001961C: conditional instruction was optimized away because of 'edi.4!=8'
// 10019617: variable 'v4' is possibly undefined
// 10028408: using guessed type int dword_10028408;
// 1002840C: using guessed type int dword_1002840C;
// 10028414: using guessed type int dword_10028414;
// 101C8130: using guessed type int dword_101C8130;
// 101C8134: using guessed type int dword_101C8134;
// 101C8138: using guessed type int dword_101C8138;
// 101C813C: using guessed type int dword_101C813C;
// 101C8284: using guessed type int dword_101C8284;

//----- (10019654) --------------------------------------------------------
_DWORD *__cdecl siglookup_0(int a1)
{
  _DWORD *result; // eax

  result = &unk_10028390;
  if ( dword_10028394 != a1 )
  {
    do
      result += 3;
    while ( (unsigned int)result < 12 * dword_10028410 + 268600208 && result[1] != a1 );
  }
  if ( (unsigned int)result >= 12 * dword_10028410 + 268600208 || result[1] != a1 )
    result = 0;
  return result;
}
// 10028394: using guessed type int dword_10028394;
// 10028410: using guessed type int dword_10028410;

//----- (10019699) --------------------------------------------------------
int __cdecl __crtMessageBoxA_0()
{
  int v0; // ebx
  int v1; // eax
  int v2; // edi
  int (__cdecl *v3)(int); // esi
  const char *v5; // [esp+0h] [ebp-1Ch]
  int v6; // [esp+4h] [ebp-18h]
  int v7; // [esp+8h] [ebp-14h]

  v0 = 0;
  if ( !dword_101C8144 )
  {
    v1 = FIX_DLL_KERNEL32_dll_LoadLibraryA("user32.dll");
    v2 = v1;
    if ( !v1 )
      return 0;
    v3 = (int (__cdecl *)(int))FIX_DLL_KERNEL32_dll_GetProcAddress;
    dword_101C8144 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_GetProcAddress(
                                                                        v1,
                                                                        "MessageBoxA");
    if ( !dword_101C8144 )
      return 0;
    v5 = "GetActiveWindow";
    dword_101C8148 = (int (*)(void))v3(v2);
    dword_101C814C = (int (__cdecl *)(_DWORD))((int (__cdecl *)(int, const char *))v3)(v2, "GetLastActivePopup");
  }
  if ( dword_101C8148 )
  {
    v0 = dword_101C8148();
    if ( v0 )
    {
      if ( dword_101C814C )
        v0 = dword_101C814C(v0);
    }
  }
  return dword_101C8144(v0, v5, v6, v7);
}
// 10019714: variable 'v5' is possibly undefined
// 10019714: variable 'v6' is possibly undefined
// 10019714: variable 'v7' is possibly undefined
// 1002113C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LoadLibraryA)(_DWORD);
// 10021140: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetProcAddress)(_DWORD, _DWORD);
// 101C8144: using guessed type int (__cdecl *dword_101C8144)(_DWORD, _DWORD, _DWORD, _DWORD);
// 101C8148: using guessed type int (*dword_101C8148)(void);
// 101C814C: using guessed type int (__cdecl *dword_101C814C)(_DWORD);

//----- (10019A40) --------------------------------------------------------
signed int __cdecl _stbuf_0(int a1)
{
  int v1; // eax
  int *v2; // edi
  void *v3; // eax
  int v4; // edi

  if ( !_isatty_0(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( (_UNKNOWN *)a1 == &unk_10026040 )
  {
    v1 = 0;
  }
  else
  {
    if ( (FILE *)a1 != &stru_10026060 )
      return 0;
    v1 = 1;
  }
  ++dword_101C812C;
  if ( (*(_WORD *)(a1 + 12) & 0x10C) != 0 )
    return 0;
  v2 = (int *)(4 * v1 + 270303568);
  if ( dword_101C8150[v1] || (v3 = sub_10019098(4096), (*v2 = (int)v3) != 0) )
  {
    v4 = *v2;
    *(_DWORD *)(a1 + 24) = 4096;
    *(_DWORD *)(a1 + 8) = v4;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)a1 = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
    *(_DWORD *)(a1 + 4) = 2;
  }
  *(_WORD *)(a1 + 12) |= 0x1102u;
  return 1;
}
// 101C812C: using guessed type int dword_101C812C;
// 101C8150: using guessed type int dword_101C8150[];

//----- (10019ACD) --------------------------------------------------------
signed int __cdecl _ftbuf_0(int a1, int a2)
{
  signed int result; // eax

  if ( a1 )
  {
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
    {
      result = _flush_0(a2);
      *(_BYTE *)(a2 + 13) &= 0xEEu;
      *(_DWORD *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  else
  {
    result = a2;
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
      result = _flush_0(a2);
  }
  return result;
}

//----- (10019B0A) --------------------------------------------------------
int *__usercall _FF_MSGBANNER_0@<eax>(int a2@<esi>)
{
  int *result; // eax

  result = (int *)dword_101C80EC;
  if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
  {
    _NMSG_WRITE_0(a2, 0xFCu);
    if ( dword_101C8158 )
      dword_101C8158();
    result = _NMSG_WRITE_0(a2, 0xFFu);
  }
  return result;
}
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C8158: using guessed type int (*dword_101C8158)(void);

//----- (10019B43) --------------------------------------------------------
int *__usercall _NMSG_WRITE_0@<eax>(int a1@<esi>, DWORD NumberOfBytesWritten)
{
  int v2; // ecx
  int *result; // eax
  int v4; // esi
  char *v5; // edi
  const char **v6; // esi
  size_t v7; // eax
  size_t v8; // ecx
  int v9; // eax
  _DWORD v10[10]; // [esp-3Ch] [ebp-1E0h] BYREF
  const char *v11; // [esp-14h] [ebp-1B8h]
  size_t v12; // [esp-10h] [ebp-1B4h]
  void *v13; // [esp-Ch] [ebp-1B0h]
  int v14; // [esp-8h] [ebp-1ACh]
  int v15; // [esp-4h] [ebp-1A8h]
  char v16[260]; // [esp+0h] [ebp-1A4h] BYREF
  char v17[160]; // [esp+104h] [ebp-A0h] BYREF

  v2 = 0;
  result = dword_100262A0;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v2;
  }
  while ( (int)result < (int)&off_10026330 );
  v15 = a1;
  v4 = 2 * v2;
  if ( NumberOfBytesWritten == dword_100262A0[2 * v2] )
  {
    result = (int *)dword_101C80EC;
    if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
    {
      v6 = (const char **)&dword_100262A4[v4];
      v14 = 0;
      v13 = &NumberOfBytesWritten;
      v7 = strlen(*v6);
      v8 = v12;
      v12 = v7;
      v11 = *v6;
      v9 = FIX_DLL_KERNEL32_dll_GetStdHandle(v8);
      result = (int *)FIX_DLL_KERNEL32_dll_WriteFile(v9, -12, v11, v12, &NumberOfBytesWritten);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      v14 = 260;
      v13 = v16;
      v12 = 0;
      if ( !FIX_DLL_KERNEL32_dll_GetModuleFileNameA(v2, NumberOfBytesWritten) )
        strcpy(v16, "<program name unknown>");
      v5 = v16;
      if ( strlen(v16) + 1 > 0x3C )
      {
        v5 = (char *)v10 + strlen(v16) + 1;
        strncpy_0(v5, "...", 3u);
      }
      strcpy(v17, "Runtime Error!\n\nProgram: ");
      strcat(v17, v5);
      strcat(v17, "\n\n");
      strcat(v17, (const char *)dword_100262A4[v4]);
      v10[1] = 73744;
      v10[0] = "Microsoft Visual C++ Runtime Library";
      result = (int *)__crtMessageBoxA_0();
    }
  }
  return result;
}
// 10019B43: could not find valid save-restore pair for esi
// 1002100C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 10021138: using guessed type int (__thiscall *FIX_DLL_KERNEL32_dll_GetStdHandle)(_DWORD);
// 100262A0: using guessed type int dword_100262A0[];
// 100262A4: using guessed type int dword_100262A4[];
// 10026330: using guessed type int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;

//----- (10019CC7) --------------------------------------------------------
unsigned int __cdecl sub_10019CC7()
{
  return sub_1001D070(0x10000, 196608);
}

//----- (10019CD9) --------------------------------------------------------
bool __cdecl _ms_p5_test_fdiv_0()
{
  return dbl_10022018 - dbl_10022018 / dbl_10022020 * dbl_10022020 > (long double)dbl_10021948;
}
// 10021948: using guessed type double dbl_10021948;
// 10022018: using guessed type double dbl_10022018;
// 10022020: using guessed type double dbl_10022020;

//----- (10019D17) --------------------------------------------------------
// #STR: "IsProcessorFeaturePresent", "KERNEL32"
// #API: GetModuleHandleA(), GetProcAddress()
int __cdecl _ms_p5_mp_test_fdiv_0()
{
  int v0; // eax
  int (__cdecl *v1)(_DWORD); // eax
  int result; // eax

  v0 = FIX_DLL_KERNEL32_dll_GetModuleHandleA("KERNEL32");
  if ( v0 && (v1 = (int (__cdecl *)(_DWORD))FIX_DLL_KERNEL32_dll_GetProcAddress(v0, "IsProcessorFeaturePresent")) != 0 )
    result = v1(0);
  else
    result = _ms_p5_test_fdiv_0();
  return result;
}
// 10021134: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD);
// 10021140: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetProcAddress)(_DWORD, _DWORD);

//----- (1001A25C) --------------------------------------------------------
signed int __cdecl __loctotime_t_0(int a1, signed int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // eax
  char v12[4]; // [esp+4h] [ebp-24h] BYREF
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+20h] [ebp-8h]
  int v17; // [esp+30h] [ebp+8h]

  v7 = a1 - 1900;
  if ( a1 - 1900 < 70 || v7 > 138 )
    return -1;
  v8 = a3 + dword_10028534[a2];
  if ( (v7 & 3) == 0 && a2 > 2 )
    ++v8;
  sub_1001D891();
  v16 = v8;
  v15 = a1 - 1900;
  v13 = a4;
  v14 = a2 - 1;
  v9 = dword_10028450 + 60 * (a5 + 60 * (a4 + 24 * (((a1 - 1901) >> 2) + v8 + 365 * (a1 - 1900)))) + a6 + 2085978496;
  v17 = v9;
  if ( a7 == 1 || a7 == -1 && dword_10028454 && (v10 = _isindst(v12), v9 = v17, v10) )
    v9 += dword_10028458;
  return v9;
}
// 1001DB04: using guessed type _DWORD __cdecl _isindst(_DWORD);
// 10028450: using guessed type int dword_10028450;
// 10028454: using guessed type int dword_10028454;
// 10028458: using guessed type int dword_10028458;
// 10028534: using guessed type int dword_10028534[];

//----- (1001A31E) --------------------------------------------------------
char __cdecl sub_1001A31E(int a1)
{
  int v1; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  v1 = FIX_DLL_KERNEL32_dll_GetModuleHandleA(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *(_DWORD *)(v1 + 60);
    if ( v2 )
    {
      v1 += v2;
      *(_BYTE *)a1 = *(_BYTE *)(v1 + 26);
      LOBYTE(v1) = *(_BYTE *)(v1 + 27);
      *(_BYTE *)(a1 + 1) = v1;
    }
  }
  return v1;
}
// 10021134: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD);

//----- (1001A34B) --------------------------------------------------------
int __cdecl sub_1001A34B()
{
  int result; // eax
  char *i; // ecx
  char v2; // al
  int v3; // edx
  int v4; // ecx
  char *v5; // eax
  char *j; // ecx
  char v7; // al
  char *v8; // eax
  const char *v9; // eax
  const char *v10; // ecx
  char Str[4]; // [esp+4h] [ebp-122Ch] BYREF
  char v12[260]; // [esp+1094h] [ebp-19Ch] BYREF
  _DWORD v13[37]; // [esp+1198h] [ebp-98h] BYREF
  char v14[4]; // [esp+122Ch] [ebp-4h] BYREF

  v13[0] = 148;
  if ( FIX_DLL_KERNEL32_dll_GetVersionExA(v13) && v13[4] == 2 && v13[1] >= 5u )
    return 1;
  if ( !FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Str, 4240) )
    goto LABEL_29;
  for ( i = Str; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", Str, 0x16u) )
  {
    v5 = Str;
  }
  else
  {
    FIX_DLL_KERNEL32_dll_GetModuleFileNameA(v4, v3);
    for ( j = v12; *j; ++j )
    {
      v7 = *j;
      if ( *j >= 97 && v7 <= 122 )
        *j = v7 - 32;
    }
    v5 = strstr_0(Str, v12);
  }
  if ( !v5 )
    goto LABEL_29;
  v8 = strchr_0(v5, 44);
  if ( !v8 )
    goto LABEL_29;
  v9 = v8 + 1;
  v10 = v9;
  while ( *v10 )
  {
    if ( *v10 == 59 )
      *v10 = 0;
    else
      ++v10;
  }
  result = strtol(v9, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_1001A31E((int)v14);
    result = 3 - (v14[0] < 6u);
  }
  return result;
}
// 1001A3FF: variable 'v4' is possibly undefined
// 1001A3FF: variable 'v3' is possibly undefined
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 1002112C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetVersionExA)(_DWORD);
// 10021130: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA)(_DWORD, _DWORD, _DWORD);

//----- (1001A493) --------------------------------------------------------
signed int __cdecl sub_1001A493(int a1)
{
  int v1; // eax
  void **v2; // eax

  dword_101C86E4 = FIX_DLL_KERNEL32_dll_HeapCreate(a1 == 0, 4096);
  if ( !dword_101C86E4 )
    return 0;
  v1 = sub_1001A34B();
  dword_101C86E8 = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_1001C170();
  }
  if ( !v2 )
  {
    FIX_DLL_KERNEL32_dll_HeapDestroy(dword_101C86E4);
    return 0;
  }
  return 1;
}
// 1001B207: using guessed type int __cdecl __sbh_heap_init(_DWORD);
// 10021124: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapCreate)(_DWORD, _DWORD);
// 10021128: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001A4F0) --------------------------------------------------------
int __usercall sub_1001A4F0@<eax>(int a1@<ebx>, int a2@<ebp>)
{
  int v2; // ebx
  void (__cdecl *v3)(_DWORD, _DWORD, _DWORD); // ebp
  void (__cdecl *v4)(_DWORD, int, int, int, int); // edi
  _DWORD *v5; // esi
  void **v6; // esi
  void *v7; // eax

  if ( dword_101C86E8 == 3 )
  {
    v2 = 0;
    v3 = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_HeapFree;
    if ( dword_101C85BC > 0 )
    {
      v4 = (void (__cdecl *)(_DWORD, int, int, int, int))FIX_DLL_KERNEL32_dll_VirtualFree;
      v5 = (_DWORD *)(dword_101C85C0 + 12);
      do
      {
        v4(*v5, 0x100000, 0x4000, a2, a1);
        ((void (__cdecl *)(_DWORD, _DWORD, int))v4)(*v5, 0, 0x8000);
        v3(dword_101C86E4, 0, v5[1]);
        v5 += 5;
        ++v2;
      }
      while ( v2 < dword_101C85BC );
    }
    v3(dword_101C86E4, 0, dword_101C85C0);
  }
  else if ( dword_101C86E8 == 2 )
  {
    v6 = &off_10026360;
    do
    {
      v7 = v6[4];
      if ( v7 )
        FIX_DLL_KERNEL32_dll_VirtualFree(v7, 0, 0x8000);
      v6 = (void **)*v6;
    }
    while ( v6 != &off_10026360 );
  }
  return FIX_DLL_KERNEL32_dll_HeapDestroy(dword_101C86E4);
}
// 1001A4F0: could not find valid save-restore pair for ebx
// 1001A4F0: could not find valid save-restore pair for ebp
// 1001A528: variable 'a2' is possibly undefined
// 1001A528: variable 'a1' is possibly undefined
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021128: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD);
// 10021164: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 101C85BC: using guessed type int dword_101C85BC;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001A598) --------------------------------------------------------
int _ioinit_0()
{
  char *v1; // esi
  unsigned int i; // eax
  unsigned int j; // ecx
  int v4; // esi
  _BYTE *v5; // ebp
  unsigned int *v6; // ebx
  _DWORD *v7; // edi
  char *v8; // eax
  int k; // edi
  int v10; // eax
  int l; // ebx
  int v12; // esi
  int v13; // eax
  int v14; // edi
  int v15; // eax
  unsigned int v17; // [esp-4h] [ebp-58h]
  _DWORD v18[7]; // [esp+10h] [ebp-44h] BYREF
  __int16 v19; // [esp+42h] [ebp-12h]
  _DWORD *v20; // [esp+44h] [ebp-10h]

  v1 = (char *)sub_10019098(256);
  if ( !v1 )
    _amsg_exit_0(27);
  dword_101C85E0[0] = (int)v1;
  dword_101C86E0 = 32;
  for ( i = (unsigned int)(v1 + 256); (unsigned int)v1 < i; i = dword_101C85E0[0] + 256 )
  {
    v1[4] = 0;
    *(_DWORD *)v1 = -1;
    v1[5] = 10;
    v1 += 8;
  }
  FIX_DLL_KERNEL32_dll_GetStartupInfoA(v18);
  if ( v19 && v20 )
  {
    v4 = *v20;
    v5 = v20 + 1;
    v6 = (_DWORD *)((char *)v20 + *v20 + 4);
    if ( (int)*v20 >= 2048 )
      v4 = 2048;
    if ( dword_101C86E0 < v4 )
    {
      v7 = &unk_101C85E4;
      while ( 1 )
      {
        v8 = (char *)sub_10019098(256);
        j = v17;
        if ( !v8 )
          break;
        dword_101C86E0 += 32;
        *v7 = v8;
        for ( j = (unsigned int)(v8 + 256); (unsigned int)v8 < j; j = *v7 + 256 )
        {
          v8[4] = 0;
          *(_DWORD *)v8 = -1;
          v8[5] = 10;
          v8 += 8;
        }
        ++v7;
        if ( dword_101C86E0 >= v4 )
          goto LABEL_19;
      }
      v4 = dword_101C86E0;
    }
LABEL_19:
    for ( k = 0; k < v4; ++v6 )
    {
      if ( *v6 != -1 )
      {
        LOBYTE(j) = *v5;
        if ( (*v5 & 1) != 0 && ((j & 8) != 0 || FIX_DLL_KERNEL32_dll_GetFileType(*v6)) )
        {
          v10 = dword_101C85E0[k >> 5] + 8 * (k & 0x1F);
          j = *v6;
          *(_DWORD *)v10 = *v6;
          LOBYTE(j) = *v5;
          *(_BYTE *)(v10 + 4) = *v5;
        }
      }
      ++k;
      ++v5;
    }
  }
  for ( l = 0; l < 3; ++l )
  {
    v12 = dword_101C85E0[0] + 8 * l;
    if ( *(_DWORD *)v12 == -1 )
    {
      *(_BYTE *)(v12 + 4) = -127;
      v13 = FIX_DLL_KERNEL32_dll_GetStdHandle(j);
      v14 = v13;
      if ( v13 == -1
        || (v15 = FIX_DLL_KERNEL32_dll_GetFileType(v13)) == 0
        || (*(_DWORD *)v12 = v14, (unsigned __int8)v15 == 2) )
      {
        *(_BYTE *)(v12 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)v15 == 3 )
      {
        *(_BYTE *)(v12 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v12 + 4) |= 0x80u;
    }
  }
  return FIX_DLL_KERNEL32_dll_SetHandleCount(dword_101C86E0);
}
// 1001A63B: variable 'v17' is possibly undefined
// 1001A6F0: variable 'j' is possibly undefined
// 10021114: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetStartupInfoA)(_DWORD);
// 10021118: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileType)(_DWORD);
// 1002111C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_SetHandleCount)(_DWORD);
// 10021138: using guessed type int (__thiscall *FIX_DLL_KERNEL32_dll_GetStdHandle)(_DWORD);
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001A766) --------------------------------------------------------
void __cdecl _setenvp_0()
{
  char *v0; // esi
  int v1; // edi
  char **v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  char *v6; // eax

  if ( !dword_101C9710 )
    sub_1001E4BC();
  v0 = dword_101C80E4;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = (char **)sub_10019098(4 * v1 + 4);
  dword_101C809C = (int)v2;
  if ( !v2 )
    _amsg_exit_0(9);
  for ( i = dword_101C80E4; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = (char *)sub_10019098(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit_0(9);
      strcpy(*v2++, i);
    }
  }
  sub_100189EC((unsigned int)dword_101C80E4);
  dword_101C80E4 = 0;
  *v2 = 0;
  dword_101C970C = 1;
}
// 101C809C: using guessed type int dword_101C809C;
// 101C970C: using guessed type int dword_101C970C;
// 101C9710: using guessed type int dword_101C9710;

//----- (1001A81F) --------------------------------------------------------
int __fastcall _setargv_0(int a1, int a2)
{
  void *v2; // edi
  void *v3; // esi
  int result; // eax
  int v5; // [esp+Ch] [ebp-8h] BYREF
  int v6; // [esp+10h] [ebp-4h] BYREF

  if ( !dword_101C9710 )
    sub_1001E4BC();
  FIX_DLL_KERNEL32_dll_GetModuleFileNameA(a1, a2);
  dword_101C80AC = (int)&unk_101C816C;
  v2 = &unk_101C816C;
  if ( *(_BYTE *)dword_101C9704 )
    v2 = (void *)dword_101C9704;
  parse_cmdline_0((int)v2, 0, 0, (int)&v6, (int)&v5);
  v3 = sub_10019098(v5 + 4 * v6);
  if ( !v3 )
    _amsg_exit_0(8);
  parse_cmdline_0((int)v2, (int)v3, (int)v3 + 4 * v6, (int)&v6, (int)&v5);
  result = v6 - 1;
  dword_101C8094 = (int)v3;
  dword_101C8090 = v6 - 1;
  return result;
}
// 1001A842: variable 'a1' is possibly undefined
// 1001A842: variable 'a2' is possibly undefined
// 100210CC: using guessed type int (__fastcall *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD);
// 101C8090: using guessed type int dword_101C8090;
// 101C8094: using guessed type int dword_101C8094;
// 101C80AC: using guessed type int dword_101C80AC;
// 101C9704: using guessed type int dword_101C9704;
// 101C9710: using guessed type int dword_101C9710;

//----- (1001A8B8) --------------------------------------------------------
int __cdecl parse_cmdline_0(int a1, int a2, int a3, int a4, int a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  int result; // eax
  int v17; // [esp+14h] [ebp+8h]
  bool v18; // [esp+24h] [ebp+18h]

  *(_DWORD *)a5 = 0;
  v6 = (unsigned __int8 *)a3;
  v7 = (unsigned __int8 **)a2;
  *(_DWORD *)a4 = 1;
  v8 = (unsigned __int8 *)a1;
  if ( a2 )
  {
    *(_DWORD *)a2 = a3;
    v7 = (unsigned __int8 **)(a2 + 4);
    a2 += 4;
  }
  if ( *(_BYTE *)a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_101C84A1[v9] & 4) != 0 )
      {
        ++*(_DWORD *)a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*(_DWORD *)a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*(_DWORD *)a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*(_DWORD *)a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_101C84A1[v10] & 4) != 0 )
      {
        ++*(_DWORD *)a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = (int)v7;
    }
    ++*(_DWORD *)a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = (unsigned __int8 **)a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*(_DWORD *)a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_101C84A1[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*(_DWORD *)a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_101C84A1[v15] & 4) != 0 )
        {
          ++v8;
          ++*(_DWORD *)a5;
        }
        ++*(_DWORD *)a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*(_DWORD *)a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*(_DWORD *)a4;
  return result;
}
// 1001A961: conditional instruction was optimized away because of 'dl.1 in (==9|==20)'

//----- (1001AA6C) --------------------------------------------------------
void *__cdecl __crtGetEnvironmentStringsA_0()
{
  int (*v0)(void); // ebp
  unsigned int v1; // ebx
  int v2; // esi
  int v3; // edi
  _WORD *i; // eax
  int (__cdecl *v5)(_DWORD, _DWORD, int, int); // edi
  int v6; // eax
  void *v7; // eax
  _BYTE *j; // eax
  int v10; // ebp
  void *v11; // eax
  void *v12; // esi
  unsigned int v13; // [esp+0h] [ebp-48h]
  int v14; // [esp+24h] [ebp-24h]

  v0 = FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  if ( dword_101C8270 )
  {
    if ( dword_101C8270 == 1 )
      goto LABEL_7;
    if ( dword_101C8270 != 2 )
      return 0;
  }
  else
  {
    v2 = FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW();
    if ( v2 )
    {
      dword_101C8270 = 1;
LABEL_7:
      if ( v2 || (v2 = v0()) != 0 )
      {
        for ( i = (_WORD *)v2; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        v5 = (int (__cdecl *)(_DWORD, _DWORD, int, int))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
        v6 = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(0, 0, v2, (((int)i - v2) >> 1) + 1, 0, 0, 0, 0);
        if ( v6 )
        {
          v7 = sub_10019098(v6);
          if ( v7 )
          {
            v13 = (unsigned int)v7;
            if ( !v5(0, 0, v2, v14) )
            {
              sub_100189EC(v13);
              v13 = 0;
            }
            v1 = v13;
          }
        }
        FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW(v2);
        return (void *)v1;
      }
      return 0;
    }
    v3 = FIX_DLL_KERNEL32_dll_GetEnvironmentStrings();
    if ( !v3 )
      return 0;
    dword_101C8270 = 2;
  }
  if ( !v3 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetEnvironmentStrings();
    if ( !v3 )
      return 0;
  }
  for ( j = (_BYTE *)v3; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v10 = (int)&j[-v3 + 1];
  v11 = sub_10019098(v10);
  v12 = v11;
  if ( v11 )
    ((void (__cdecl *)(void *, int, int))loc_1001C9D0)(v11, v3, v10);
  else
    v12 = 0;
  FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA(v3);
  return v12;
}
// 1001AB21: variable 'v14' is possibly undefined
// 10021104: using guessed type int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW)(void);
// 10021108: using guessed type int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStrings)(void);
// 1002110C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW)(_DWORD);
// 10021110: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA)(_DWORD);
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8270: using guessed type int dword_101C8270;

//----- (1001AB9E) --------------------------------------------------------
bool __cdecl sub_1001AB9E(int a1, int a2)
{
  return FIX_DLL_KERNEL32_dll_IsBadReadPtr(a1, a2) == 0;
}
// 10021018: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadReadPtr)(_DWORD, _DWORD);

//----- (1001ABBA) --------------------------------------------------------
bool __cdecl sub_1001ABBA(int a1, int a2)
{
  return FIX_DLL_KERNEL32_dll_IsBadWritePtr(a1, a2) == 0;
}
// 10021100: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadWritePtr)(_DWORD, _DWORD);

//----- (1001ABD6) --------------------------------------------------------
bool __cdecl sub_1001ABD6(int a1)
{
  return FIX_DLL_KERNEL32_dll_IsBadCodePtr(a1) == 0;
}
// 100210F8: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadCodePtr)(_DWORD);

//----- (1001ABEE) --------------------------------------------------------
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  _BYTE v15[60]; // [esp-54h] [ebp-70h] BYREF
  _DWORD v16[5]; // [esp-18h] [ebp-34h] BYREF
  int v17; // [esp-4h] [ebp-20h]
  int v18; // [esp+0h] [ebp-1Ch] BYREF
  _BYTE *v19; // [esp+4h] [ebp-18h]
  _DWORD v20[3]; // [esp+Ch] [ebp-10h]
  int v21; // [esp+18h] [ebp-4h]

  v21 = -1;
  v20[2] = &unk_10022090;
  v20[1] = &unknown_libname_67;
  v20[0] = __readfsdword(0);
  v19 = v16;
  v7 = dword_101C8274;
  if ( !dword_101C8274 )
  {
    if ( FIX_DLL_KERNEL32_dll_GetStringTypeW(1, &unk_10021D18, 1, &v18) )
    {
      v7 = 1;
    }
    else
    {
      if ( !FIX_DLL_KERNEL32_dll_GetStringTypeA(0, 1, &unk_10021D14, 1, &v18) )
        return 0;
      v7 = 2;
    }
    dword_101C8274 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = dword_101C8124;
      v10 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, a7 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
      v17 = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        v19 = v15;
        v16[4] = v15;
        memset(v15, 0, v11);
        v21 = -1;
        if ( v15 )
        {
          v14 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, v15, v17);
          if ( v14 )
            return FIX_DLL_KERNEL32_dll_GetStringTypeW(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_101C8114;
  return FIX_DLL_KERNEL32_dll_GetStringTypeA(v8, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType);
}
// 100210F0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeW)(_DWORD, _DWORD, _DWORD, _DWORD);
// 100210F4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8114: using guessed type int dword_101C8114;
// 101C8274: using guessed type int dword_101C8274;

//----- (1001AD37) --------------------------------------------------------
int __cdecl _lseek_0(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  unsigned int v6; // eax
  int v8; // [esp-10h] [ebp-1Ch]

  if ( (unsigned int)a1 < dword_101C86E0
    && (v3 = 8 * (a1 & 0x1F), (*(_BYTE *)(dword_101C85E0[a1 >> 5] + v3 + 4) & 1) != 0) )
  {
    v4 = _get_osfhandle_0(a1);
    if ( v4 == -1 )
    {
      dword_101C8074 = 9;
    }
    else
    {
      v5 = FIX_DLL_KERNEL32_dll_SetFilePointer(v4, a2, 0, a3);
      if ( v5 == -1 )
        v6 = FIX_DLL_KERNEL32_dll_GetLastError(v8);
      else
        v6 = 0;
      if ( !v6 )
      {
        *(_BYTE *)(dword_101C85E0[a1 >> 5] + v3 + 4) &= 0xFDu;
        return v5;
      }
      _dosmaperr_0(v6);
    }
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 1001AD93: variable 'v8' is possibly undefined
// 10021010: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001ADD1) --------------------------------------------------------
int __cdecl _write_0(int a1, const void *a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  int v4; // esi
  char v5; // al
  int v7; // eax
  char *v8; // eax
  char *v9; // ecx
  char v10; // cl
  int v11; // edi
  int v12; // [esp-14h] [ebp-434h]
  int v13; // [esp-14h] [ebp-434h]
  _DWORD v14[254]; // [esp+Ch] [ebp-414h] BYREF
  int v15; // [esp+410h] [ebp-10h]
  int v16; // [esp+414h] [ebp-Ch] BYREF
  int v17; // [esp+418h] [ebp-8h]
  char *v18; // [esp+41Ch] [ebp-4h]
  int v19; // [esp+428h] [ebp+8h]

  if ( (unsigned int)a1 < dword_101C86E0
    && (v3 = (_DWORD *)(4 * (a1 >> 5) + 270304736),
        v4 = 8 * (a1 & 0x1F),
        v5 = *(_BYTE *)(dword_101C85E0[a1 >> 5] + v4 + 4),
        (v5 & 1) != 0) )
  {
    v17 = 0;
    v15 = 0;
    if ( !a3 )
      return 0;
    if ( (v5 & 0x20) != 0 )
      _lseek_0(a1, 0, 2);
    v7 = v4 + dword_101C85E0[a1 >> 5];
    if ( *(char *)(v7 + 4) >= 0 )
    {
      if ( FIX_DLL_KERNEL32_dll_WriteFile(*(_DWORD *)v7, a2, a3, &v16, 0) )
      {
        v19 = 0;
        v17 = v16;
      }
      else
      {
        v19 = FIX_DLL_KERNEL32_dll_GetLastError(v13);
      }
    }
    else
    {
      v18 = (char *)a2;
      v19 = 0;
      while ( 1 )
      {
        v8 = (char *)v14;
        do
        {
          if ( v18 - (_BYTE *)a2 >= a3 )
            break;
          v9 = v18++;
          v10 = *v9;
          if ( v10 == 10 )
          {
            ++v15;
            *v8++ = 13;
          }
          *v8++ = v10;
        }
        while ( v8 - (char *)v14 < 1024 );
        v11 = v8 - (char *)v14;
        if ( !FIX_DLL_KERNEL32_dll_WriteFile(*(_DWORD *)(*v3 + v4), v14, v8 - (char *)v14, &v16, 0) )
          break;
        v17 += v16;
        if ( v16 < v11 || v18 - (_BYTE *)a2 >= a3 )
          goto LABEL_17;
      }
      v19 = FIX_DLL_KERNEL32_dll_GetLastError(v12);
    }
LABEL_17:
    if ( v17 )
      return v17 - v15;
    if ( v19 )
    {
      if ( v19 == 5 )
      {
        dword_101C8074 = 9;
        dword_101C8078 = 5;
      }
      else
      {
        _dosmaperr_0(v19);
      }
    }
    else
    {
      if ( (*(_BYTE *)(*v3 + v4 + 4) & 0x40) != 0 && *(_BYTE *)a2 == 26 )
        return 0;
      dword_101C8074 = 28;
      dword_101C8078 = 0;
    }
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 1001AE4C: conditional instruction was optimized away because of '%arg_8.4!=0'
// 1001AEF6: variable 'v12' is possibly undefined
// 1001AF23: variable 'v13' is possibly undefined
// 1002100C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001AF7E) --------------------------------------------------------
int __cdecl _getbuf_0(int a1)
{
  void *v1; // eax
  int result; // eax

  ++dword_101C812C;
  v1 = sub_10019098(4096);
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 12) |= 8u;
    *(_DWORD *)(a1 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 12) |= 4u;
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = result;
  return result;
}
// 101C812C: using guessed type int dword_101C812C;

//----- (1001AFC2) --------------------------------------------------------
int __cdecl _isatty_0(int a1)
{
  int result; // eax

  if ( (unsigned int)a1 < dword_101C86E0 )
    result = *(_BYTE *)(dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 0x40;
  else
    result = 0;
  return result;
}
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001AFE8) --------------------------------------------------------
int __cdecl wctomb_0(char *a1, wchar_t a2)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( !dword_101C8114 )
    {
      if ( a2 <= 0xFFu )
      {
        *a1 = a2;
        return 1;
      }
      goto LABEL_7;
    }
    a1 = 0;
    result = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(dword_101C8124, 544, &a2, 1, result, dword_10026004, 0, &a1);
    if ( !result || a1 )
    {
LABEL_7:
      dword_101C8074 = 42;
      return -1;
    }
  }
  return result;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8114: using guessed type int dword_101C8114;

//----- (1001B24F) --------------------------------------------------------
unsigned int __cdecl __sbh_find_block_0(int a1)
{
  unsigned int result; // eax

  for ( result = dword_101C85C0; result < dword_101C85C0 + 20 * dword_101C85BC; result += 20 )
  {
    if ( (unsigned int)(a1 - *(_DWORD *)(result + 12)) < 0x100000 )
      return result;
  }
  return 0;
}
// 101C85BC: using guessed type int dword_101C85BC;

//----- (1001B27A) --------------------------------------------------------
unsigned int __cdecl sub_1001B27A(unsigned int a1, int a2)
{
  unsigned int result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  _BOOL1 v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  void (__cdecl *v18)(_DWORD, _DWORD, int); // esi
  _DWORD *v19; // eax
  _DWORD *v20; // [esp+Ch] [ebp-10h]
  int v21; // [esp+10h] [ebp-Ch]
  int v22; // [esp+14h] [ebp-8h]
  int v23; // [esp+18h] [ebp-4h]
  char *v24; // [esp+28h] [ebp+Ch]
  int *v25; // [esp+28h] [ebp+Ch]
  char v26; // [esp+2Bh] [ebp+Fh]

  result = *(_DWORD *)(a1 + 16);
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v20 = (_DWORD *)(516 * v4 + result + 324);
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v23 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v21 = *(int *)((char *)v3 + v5);
    v22 = *(_DWORD *)(a2 - 8);
    v24 = (char *)v3 + v5;
    if ( (v21 & 1) == 0 )
    {
      v7 = (v21 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (_BYTE *)(v7 + result + 4);
          v12 = ~(0x80000000 >> (v7 - 32));
          *(_DWORD *)(result + 4 * v4 + 196) &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            *(_DWORD *)(a1 + 4) &= v12;
        }
        else
        {
          v8 = (_BYTE *)(v7 + result + 4);
          v9 = ~(0x80000000 >> v7);
          *(_DWORD *)(result + 4 * v4 + 68) &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *(_DWORD *)a1 &= v9;
        }
        v5 = v23;
        v6 = v24;
      }
      v5 += v21;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v23 = v5;
      *(_DWORD *)(*((_DWORD *)v24 + 1) + 8) = *((_DWORD *)v24 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v22 & 1) != 0 )
    {
      v14 = a1;
    }
    else
    {
      v25 = (int *)((char *)v3 - v22);
      v14 = (v22 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v23 = v22 + v5;
      v13 = ((v22 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v25[1] == v25[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            *(_DWORD *)(result + 4 * v4 + 196) &= v16;
            v10 = (*(_BYTE *)(v14 + result + 4))-- == 1;
            if ( v10 )
              *(_DWORD *)(a1 + 4) &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            *(_DWORD *)(result + 4 * v4 + 68) &= v15;
            v10 = (*(_BYTE *)(v14 + result + 4))-- == 1;
            if ( v10 )
              *(_DWORD *)a1 &= v15;
          }
        }
        *(_DWORD *)(v25[2] + 4) = v25[1];
        *(_DWORD *)(v25[1] + 8) = v25[2];
      }
      v3 = v25;
    }
    if ( (v22 & 1) != 0 || v14 != v13 )
    {
      v17 = &v20[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v26 = *(_BYTE *)(v13 + result + 4);
        *(_BYTE *)(v13 + result + 4) = v26 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v26 )
            *(_DWORD *)(a1 + 4) |= 0x80000000 >> (v13 - 32);
          *(_DWORD *)(result + 4 * v4 + 196) |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v26 )
            *(_DWORD *)a1 |= 0x80000000 >> v13;
          *(_DWORD *)(result + 4 * v4 + 68) |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v23;
    *(int *)((char *)v3 + v23 - 4) = v23;
    result += 516 * v4 + 324;
    v10 = (*v20)-- == 1;
    if ( v10 )
    {
      if ( dword_101C85B8 )
      {
        v18 = (void (__cdecl *)(_DWORD, _DWORD, int))FIX_DLL_KERNEL32_dll_VirtualFree;
        FIX_DLL_KERNEL32_dll_VirtualFree(*((_DWORD *)dword_101C85B8 + 3) + (dword_101C85AC << 15), 0x8000, 0x4000);
        *((_DWORD *)dword_101C85B8 + 2) |= 0x80000000 >> dword_101C85AC;
        *(_DWORD *)(*((_DWORD *)dword_101C85B8 + 4) + 4 * dword_101C85AC + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_101C85B8 + 4) + 67);
        v19 = dword_101C85B8;
        if ( !*(_BYTE *)(*((_DWORD *)dword_101C85B8 + 4) + 67) )
        {
          *((_DWORD *)dword_101C85B8 + 1) &= 0xFFFFFFFE;
          v19 = dword_101C85B8;
        }
        if ( v19[2] == -1 )
        {
          v18(v19[3], 0, 0x8000);
          FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, *((_DWORD *)dword_101C85B8 + 4));
          memcpy_0(
            dword_101C85B8,
            (char *)dword_101C85B8 + 20,
            20 * dword_101C85BC - (_DWORD)dword_101C85B8 + dword_101C85C0 - 20);
          --dword_101C85BC;
          if ( a1 > (unsigned int)dword_101C85B8 )
            a1 -= 20;
          dword_101C85B0 = dword_101C85C0;
        }
      }
      result = a1;
      dword_101C85AC = v4;
      dword_101C85B8 = (void *)a1;
    }
  }
  return result;
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 101C85AC: using guessed type int dword_101C85AC;
// 101C85B0: using guessed type int dword_101C85B0;
// 101C85BC: using guessed type int dword_101C85BC;

//----- (1001B5A3) --------------------------------------------------------
_DWORD *__cdecl __sbh_alloc_block_0(int a1)
{
  int v1; // ecx
  unsigned int v2; // esi
  _DWORD *i; // ebx
  _BOOL1 v4; // zf
  _BOOL1 v5; // zf
  _BOOL1 v6; // zf
  _DWORD *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int *v14; // edx
  int v15; // ecx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *v18; // edi
  unsigned int v19; // ebx
  _BYTE *v20; // edi
  int v21; // ebx
  _DWORD *v22; // ecx
  char v23; // cl
  _DWORD *v24; // edx
  int v25; // [esp+Ch] [ebp-14h]
  int v26; // [esp+Ch] [ebp-14h]
  signed int v27; // [esp+10h] [ebp-10h]
  unsigned int v28; // [esp+14h] [ebp-Ch]
  _DWORD *v29; // [esp+14h] [ebp-Ch]
  unsigned int v30; // [esp+18h] [ebp-8h]
  int v31; // [esp+18h] [ebp-8h]
  unsigned int v32; // [esp+1Ch] [ebp-4h]
  int v33; // [esp+1Ch] [ebp-4h]
  _DWORD *v34; // [esp+28h] [ebp+8h]

  v32 = dword_101C85C0 + 20 * dword_101C85BC;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v1 = (v27 >> 4) - 33;
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> v1;
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (_DWORD *)dword_101C85B0;
  v34 = (_DWORD *)dword_101C85B0;
  if ( dword_101C85B0 < (unsigned int)(dword_101C85C0 + 20 * dword_101C85BC) )
  {
    do
    {
      v1 = v2 & *i | v30 & i[1];
      if ( v1 )
        break;
      i += 5;
      v34 = i;
    }
    while ( (unsigned int)i < v32 );
  }
  if ( i == (_DWORD *)v32 )
  {
    for ( i = (_DWORD *)dword_101C85C0; ; i += 5 )
    {
      v4 = i == (_DWORD *)dword_101C85B0;
      v34 = i;
      if ( (unsigned int)i >= dword_101C85B0 )
        break;
      v1 = v2 & *i | v30 & i[1];
      if ( v1 )
      {
        v4 = i == (_DWORD *)dword_101C85B0;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == (_DWORD *)v32;
        if ( (unsigned int)i >= v32 )
          break;
        if ( i[2] )
        {
          v5 = i == (_DWORD *)v32;
          break;
        }
        i += 5;
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (_DWORD *)dword_101C85C0; ; i += 5 )
        {
          v6 = i == (_DWORD *)dword_101C85B0;
          v34 = i;
          if ( (unsigned int)i >= dword_101C85B0 )
            break;
          if ( i[2] )
          {
            v6 = i == (_DWORD *)dword_101C85B0;
            break;
          }
        }
        if ( v6 )
        {
          i = (_DWORD *)__sbh_alloc_new_region(v1);
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      *(_DWORD *)i[4] = __sbh_alloc_new_group(i);
      if ( *(_DWORD *)i[4] == -1 )
        return 0;
    }
  }
  dword_101C85B0 = (int)i;
  v8 = (_DWORD *)i[4];
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      v34[1] &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = v14;
    *(_DWORD *)(v14[1] + 8) = v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          i[1] |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && i == dword_101C85B8 && v33 == dword_101C85AC )
    dword_101C85B8 = 0;
  *v8 = v33;
  return v24 + 1;
}
// 1001B8AC: using guessed type int __thiscall __sbh_alloc_new_region(_DWORD);
// 1001B95D: using guessed type _DWORD __cdecl __sbh_alloc_new_group(_DWORD);
// 101C85AC: using guessed type int dword_101C85AC;
// 101C85B0: using guessed type int dword_101C85B0;
// 101C85BC: using guessed type int dword_101C85BC;

//----- (1001BA58) --------------------------------------------------------
signed int __cdecl __sbh_resize_block_0(int a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  int v12; // ebx
  _BOOL1 v13; // zf
  unsigned int v14; // ebx
  _BYTE *v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  char v20; // cl
  int v21; // edx
  int *v22; // eax
  int v24; // ecx
  int *v25; // ebx
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // ebx
  _BYTE *v29; // esi
  int v30; // ebx
  _BYTE *v31; // ecx
  unsigned int v32; // ebx
  unsigned int v33; // ecx
  _DWORD *v34; // eax
  char v35; // cl
  int v36; // [esp+Ch] [ebp-Ch]
  int v37; // [esp+10h] [ebp-8h]
  int v38; // [esp+14h] [ebp-4h]
  int v39; // [esp+14h] [ebp-4h]
  int *v40; // [esp+24h] [ebp+Ch]
  char v41; // [esp+27h] [ebp+Fh]
  int v42; // [esp+28h] [ebp+10h]
  unsigned int v43; // [esp+28h] [ebp+10h]
  int v44; // [esp+28h] [ebp+10h]
  char v45; // [esp+2Bh] [ebp+13h]

  v3 = *(_DWORD *)(a1 + 16);
  v4 = (a3 + 23) & 0xFFFFFFF0;
  v5 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v36 = 516 * v5 + v3 + 324;
  v6 = *(_DWORD *)(a2 - 4) - 1;
  v42 = v6;
  v7 = *(_DWORD *)(v6 + a2 - 4);
  v8 = v6 + a2 - 4;
  v38 = v7;
  if ( v4 <= v6 )
  {
    if ( v4 < v6 )
    {
      v44 = v6 - v4;
      v24 = v4 + 1;
      *(_DWORD *)(a2 - 4) = v4 + 1;
      v25 = (int *)(a2 + v4 - 4);
      v40 = v25;
      v26 = (v44 >> 4) - 1;
      *(v25 - 1) = v24;
      if ( v26 > 0x3F )
        v26 = 63;
      if ( (v38 & 1) == 0 )
      {
        v27 = (v38 >> 4) - 1;
        if ( v27 > 0x3F )
          v27 = 63;
        if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
        {
          if ( v27 >= 0x20 )
          {
            v31 = (_BYTE *)(v27 + v3 + 4);
            v32 = ~(0x80000000 >> (v27 - 32));
            *(_DWORD *)(v3 + 4 * v5 + 196) &= v32;
            v13 = (*v31)-- == 1;
            if ( v13 )
              *(_DWORD *)(a1 + 4) &= v32;
          }
          else
          {
            v28 = 0x80000000 >> v27;
            v29 = (_BYTE *)(v27 + v3 + 4);
            v30 = ~v28;
            *(_DWORD *)(v3 + 4 * v5 + 68) &= v30;
            v13 = (*v29)-- == 1;
            if ( v13 )
              *(_DWORD *)a1 &= v30;
          }
          v25 = v40;
        }
        *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
        *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
        v44 += v38;
        v26 = (v44 >> 4) - 1;
        if ( v26 > 0x3F )
          v26 = 63;
      }
      v33 = v36 + 8 * v26;
      v25[1] = *(_DWORD *)(v33 + 4);
      v25[2] = v33;
      *(_DWORD *)(v33 + 4) = v25;
      *(_DWORD *)(v25[1] + 8) = v25;
      if ( v25[1] == v25[2] )
      {
        v41 = *(_BYTE *)(v26 + v3 + 4);
        *(_BYTE *)(v26 + v3 + 4) = v41 + 1;
        if ( v26 >= 0x20 )
        {
          if ( !v41 )
            *(_DWORD *)(a1 + 4) |= 0x80000000 >> (v26 - 32);
          v34 = (_DWORD *)(v3 + 4 * v5 + 196);
          v35 = v26 - 32;
        }
        else
        {
          if ( !v41 )
            *(_DWORD *)a1 |= 0x80000000 >> v26;
          v34 = (_DWORD *)(v3 + 4 * v5 + 68);
          v35 = v26;
        }
        *v34 |= 0x80000000 >> v35;
      }
      *v25 = v44;
      *(int *)((char *)v25 + v44 - 4) = v44;
    }
  }
  else
  {
    if ( (v7 & 1) != 0 || v4 > v6 + v7 )
      return 0;
    v9 = (v7 >> 4) - 1;
    v37 = v9;
    if ( v9 > 0x3F )
    {
      v9 = 63;
      v37 = 63;
    }
    if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
    {
      if ( v9 >= 0x20 )
      {
        v14 = 0x80000000 >> (v9 - 32);
        v15 = (_BYTE *)(v37 + v3 + 4);
        v16 = ~v14;
        *(_DWORD *)(v3 + 4 * v5 + 196) &= v16;
        v13 = (*v15)-- == 1;
        if ( v13 )
          *(_DWORD *)(a1 + 4) &= v16;
      }
      else
      {
        v10 = 0x80000000 >> v9;
        v11 = (_BYTE *)(v37 + v3 + 4);
        v12 = ~v10;
        *(_DWORD *)(v3 + 4 * v5 + 68) &= v12;
        v13 = (*v11)-- == 1;
        if ( v13 )
          *(_DWORD *)a1 &= v12;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
    v39 = v42 - v4 + v38;
    if ( v39 <= 0 )
    {
      v21 = a2;
    }
    else
    {
      v17 = (v39 >> 4) - 1;
      v18 = a2 + v4 - 4;
      if ( v17 > 0x3F )
        v17 = 63;
      v43 = v36 + 8 * v17;
      *(_DWORD *)(a2 + v4) = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v43;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(a2 + v4) + 8) = a2 + v4 - 4;
      if ( *(_DWORD *)(a2 + v4) == *(_DWORD *)(a2 + v4 - 4 + 8) )
      {
        v45 = *(_BYTE *)(v17 + v3 + 4);
        *(_BYTE *)(v17 + v3 + 4) = v45 + 1;
        if ( v17 >= 0x20 )
        {
          if ( !v45 )
            *(_DWORD *)(a1 + 4) |= 0x80000000 >> (v17 - 32);
          v19 = (_DWORD *)(v3 + 4 * v5 + 196);
          v20 = v17 - 32;
        }
        else
        {
          if ( !v45 )
            *(_DWORD *)a1 |= 0x80000000 >> v17;
          v19 = (_DWORD *)(v3 + 4 * v5 + 68);
          v20 = v17;
        }
        *v19 |= 0x80000000 >> v20;
      }
      v21 = a2;
      v22 = (int *)(a2 + v4 - 4);
      *v22 = v39;
      *(int *)((char *)v22 + v39 - 4) = v39;
    }
    *(_DWORD *)(v21 - 4) = v4 + 1;
    *(_DWORD *)(v21 + v4 - 8) = v4 + 1;
  }
  return 1;
}

//----- (1001C170) --------------------------------------------------------
void **__cdecl sub_1001C170()
{
  void **v0; // esi
  int (__stdcall *v1)(int, int, int, int); // ebp
  int v2; // eax
  _DWORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // edx

  if ( dword_10026370 == -1 )
  {
    v0 = &off_10026360;
  }
  else
  {
    v0 = (void **)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, 8224);
    if ( !v0 )
      return 0;
  }
  v1 = FIX_DLL_KERNEL32_dll_VirtualAlloc;
  v2 = FIX_DLL_KERNEL32_dll_VirtualAlloc(0, dword_400000, 0x2000, 4);
  v3 = (_DWORD *)v2;
  if ( !v2 )
  {
LABEL_19:
    if ( v0 != &off_10026360 )
      FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, v0);
    return 0;
  }
  if ( !v1(v2, 0x10000, 4096, 4) )
  {
    FIX_DLL_KERNEL32_dll_VirtualFree(v3, 0, 0x8000);
    goto LABEL_19;
  }
  if ( v0 == &off_10026360 )
  {
    if ( !off_10026360 )
      off_10026360 = &off_10026360;
    if ( !dword_10026364 )
      dword_10026364 = (int)&off_10026360;
  }
  else
  {
    *v0 = &off_10026360;
    v0[1] = (void *)dword_10026364;
    dword_10026364 = (int)v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = (char *)dword_400000 + (_DWORD)v3;
  v4 = (int *)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = v3;
  v0[2] = v0 + 6;
  v5 = 0;
  do
  {
    v6 = v5++ >= 16 ? -1 : 240;
    *v4 = v6;
    v4[1] = 241;
    v4 += 2;
  }
  while ( v5 < 1024 );
  memset(v3, 0, 0x10000u);
  while ( v3 < (_DWORD *)((char *)v0[4] + 0x10000) )
  {
    *((_BYTE *)v3 + 248) = -1;
    *v3 = v3 + 2;
    v3[1] = 240;
    v3 += 1024;
  }
  return v0;
}
// 100210EC: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10026364: using guessed type int dword_10026364;
// 10026370: using guessed type int dword_10026370;

//----- (1001C2B4) --------------------------------------------------------
void *__cdecl sub_1001C2B4(void **a1)
{
  void *result; // eax

  result = (void *)FIX_DLL_KERNEL32_dll_VirtualFree(a1[4], 0, 0x8000);
  if ( (void **)dword_10028380 == a1 )
  {
    result = a1[1];
    dword_10028380 = (int)result;
  }
  if ( a1 == &off_10026360 )
  {
    dword_10026370 = -1;
  }
  else
  {
    *(_DWORD *)a1[1] = *a1;
    *((_DWORD *)*a1 + 1) = a1[1];
    result = (void *)FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, a1);
  }
  return result;
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10026370: using guessed type int dword_10026370;
// 10028380: using guessed type int dword_10028380;

//----- (1001C30A) --------------------------------------------------------
void __cdecl sub_1001C30A(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+0h] [ebp-4h]

  v1 = (_DWORD *)dword_10026364;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && FIX_DLL_KERNEL32_dll_VirtualFree(v1[4] + i, 4096, 0x4000) )
        {
          *v2 = -1;
          --dword_101C8278;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_1001C2B4((void **)v5);
      }
    }
  }
  while ( v1 != (_DWORD *)dword_10026364 && a1 > 0 );
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10026364: using guessed type int dword_10026364;
// 101C8278: using guessed type int dword_101C8278;

//----- (1001C3CC) --------------------------------------------------------
unsigned int __cdecl sub_1001C3CC(unsigned int a1, int a2, int a3)
{
  void **v3; // ecx

  v3 = &off_10026360;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_10026360 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *(_DWORD *)a2 = v3;
    *(_DWORD *)a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 10026360: using guessed type void *off_10026360;

//----- (1001C423) --------------------------------------------------------
void __cdecl sub_1001C423(int a1, int a2, int a3)
{
  _DWORD *v3; // eax
  _BOOL1 v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += *(unsigned __int8 *)a3;
  *(_BYTE *)a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_101C8278 == 32 )
    sub_1001C30A(16);
}
// 101C8278: using guessed type int dword_101C8278;

//----- (1001C468) --------------------------------------------------------
_BYTE *__cdecl sub_1001C468(unsigned int a1)
{
  _DWORD *v1; // esi
  int v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  _BYTE *result; // eax
  void **v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  int i; // esi
  void **v11; // ecx
  int v12; // eax
  void **v13; // eax
  _BOOL1 v14; // cf
  void **v15; // eax
  _BYTE *v16; // ecx
  unsigned int v17; // [esp+0h] [ebp-8h]
  int v18; // [esp+4h] [ebp-4h]
  int v19; // [esp+4h] [ebp-4h]
  int v20; // [esp+4h] [ebp-4h]

  v1 = (_DWORD *)dword_10028380;
  do
  {
    v2 = v1[4];
    if ( v2 == -1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = v2 + (((char *)v3 - (char *)v1 - 24) >> 3 << 12);
      v18 = v4;
      if ( v3 < v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = (_BYTE *)sub_1001C670(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              dword_10028380 = (int)v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = v1 + 6;
      v17 = v1[2];
      v19 = v1[4];
      if ( (unsigned int)(v1 + 6) < v17 )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = (_BYTE *)sub_1001C670(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < v17 );
      }
    }
    v1 = (_DWORD *)*v1;
  }
  while ( v1 != (_DWORD *)dword_10028380 );
  v7 = &off_10026360;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_10026360 )
    {
      v15 = sub_1001C170();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        dword_10028380 = (int)v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return v16 + 256;
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (int)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( FIX_DLL_KERNEL32_dll_VirtualAlloc(i, v20 << 12, 4096, 4) != i )
    return 0;
  v11 = (void **)v8;
  if ( v20 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *v11 = (void *)240;
      v11[1] = (void *)241;
      v12 += 4096;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  dword_10028380 = (int)v7;
  v13 = v7 + 2054;
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == (void *)-1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = (void *)(v14 ? (unsigned int)v11 : 0);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = (_BYTE *)(i + 256);
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 100210EC: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10028380: using guessed type int dword_10028380;

//----- (1001C670) --------------------------------------------------------
int __cdecl sub_1001C670(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (1001C794) --------------------------------------------------------
signed int __cdecl sub_1001C794(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  _BOOL1 v8; // zf
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = *(unsigned __int8 *)a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *(_BYTE *)a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = (_BYTE *)(a3 + a4);
    if ( a2 + 248 >= a3 + a4 )
    {
      for ( i = (_BYTE *)(v4 + a3); ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *(_BYTE *)a3 = a4;
        if ( a3 <= *(_DWORD *)a2 && (unsigned int)v6 > *(_DWORD *)a2 )
        {
          if ( (unsigned int)v6 >= a2 + 248 )
          {
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)a2 = a2 + 8;
          }
          else
          {
            v9 = 0;
            *(_DWORD *)a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            *(_DWORD *)(a2 + 4) = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (1001C9B1) --------------------------------------------------------
bool __cdecl sub_1001C9B1(int a1)
{
  return dword_101C827C && dword_101C827C(a1);
}
// 101C827C: using guessed type int (__cdecl *dword_101C827C)(_DWORD);

//----- (1001CD05) --------------------------------------------------------
#error "1001CD3B: call analysis failed (funcsize=26)"

//----- (1001CD5C) --------------------------------------------------------
int __cdecl _freebuf_0(_iobuf *stream)
{
  int result; // eax

  result = stream->_flag;
  if ( (result & 0x83) != 0 && (result & 8) != 0 )
  {
    sub_100189EC((unsigned int)stream->_base);
    LOWORD(stream->_flag) &= 0xFBF7u;
    result = 0;
    stream->_ptr = 0;
    stream->_base = 0;
    stream->_cnt = 0;
  }
  return result;
}

//----- (1001D03B) --------------------------------------------------------
unsigned int __cdecl _control87_0(unsigned int a1, unsigned int a2)
{
  int v2; // eax
  unsigned int v3; // esi
  __int16 v5; // [esp+4h] [ebp-4h]

  LOBYTE(v2) = _abstract_cw_0(v5);
  v3 = a2 & a1 | ~a2 & v2;
  _hw_cw_0(v3);
  return v3;
}
// 1001D047: variable 'v5' is possibly undefined
// 1001D053: variable 'v2' is possibly undefined

//----- (1001D070) --------------------------------------------------------
unsigned int __cdecl sub_1001D070(int a1, int a2)
{
  return _control87_0(a1, a2 & 0xFFF7FFFF);
}

//----- (1001D0B0) --------------------------------------------------------
char __cdecl _abstract_cw_0(__int16 a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    result |= 1u;
  return result;
}

//----- (1001D142) --------------------------------------------------------
char __cdecl _hw_cw_0(int a1)
{
  char result; // al

  result = (a1 & 0x10) != 0;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 2) != 0 )
    result |= 0x10u;
  if ( (a1 & 1) != 0 )
    result |= 0x20u;
  if ( (a1 & 0x80000) != 0 )
    result |= 2u;
  return result;
}

//----- (1001D200) --------------------------------------------------------
signed int __cdecl _ZeroTail_0(int a1, signed int a2)
{
  int v2; // esi
  _DWORD *i; // eax

  if ( (~(-1 << (31 - a2 % 32)) & *(_DWORD *)(a1 + 4 * (a2 / 32))) == 0 )
  {
    v2 = a2 / 32 + 1;
    if ( v2 >= 3 )
      return 1;
    for ( i = (_DWORD *)(a1 + 4 * v2); !*i; ++i )
    {
      if ( ++v2 >= 3 )
        return 1;
    }
  }
  return 0;
}

//----- (1001D249) --------------------------------------------------------
signed int __cdecl _IncMan_0(int a1, signed int a2)
{
  signed int result; // eax
  int v3; // esi
  unsigned int *v4; // edi

  result = __addl_0(*(_DWORD *)(a1 + 4 * (a2 / 32)), 1 << (31 - a2 % 32), a1 + 4 * (a2 / 32));
  v3 = a2 / 32 - 1;
  if ( v3 >= 0 )
  {
    v4 = (unsigned int *)(a1 + 4 * v3);
    do
    {
      if ( !result )
        break;
      result = __addl_0(*v4, 1u, (int)v4);
      --v3;
      --v4;
    }
    while ( v3 >= 0 );
  }
  return result;
}

//----- (1001D29F) --------------------------------------------------------
signed int __cdecl _RoundMan_0(int a1, signed int a2)
{
  signed int v2; // edi
  int v4; // edx
  _DWORD *v5; // eax
  char v6; // si
  int v8; // [esp+Ch] [ebp-8h]
  signed int v9; // [esp+10h] [ebp-4h]
  _DWORD *v10; // [esp+20h] [ebp+Ch]

  v2 = a2 - 1;
  v9 = 0;
  v4 = a2 % 32;
  v8 = a2 / 32;
  v5 = (_DWORD *)(a1 + 4 * (a2 / 32));
  v10 = v5;
  v6 = 31 - v4;
  if ( ((1 << (31 - v4)) & *v5) != 0 )
  {
    if ( !_ZeroTail_0(a1, a2 + 1) )
      v9 = _IncMan_0(a1, v2);
    v5 = v10;
  }
  *v5 &= -1 << v6;
  if ( v8 + 1 < 3 )
    memset((void *)(a1 + 4 * (v8 + 1)), 0, 4 * (3 - (v8 + 1)));
  return v9;
}

//----- (1001D888) --------------------------------------------------------
void sub_1001D888()
{
  _amsg_exit_0(2);
}

//----- (1001D891) --------------------------------------------------------
void __cdecl sub_1001D891()
{
  if ( !dword_101C8370 )
  {
    _tzset_0();
    ++dword_101C8370;
  }
}
// 101C8370: using guessed type int dword_101C8370;

//----- (1001D8A6) --------------------------------------------------------
void __cdecl _tzset_0()
{
  int v0; // edi
  char *v1; // eax
  const char *v2; // esi
  int (__stdcall *v3)(_DWORD, int, void *, int, char *, int, _DWORD, int *); // esi
  size_t v4; // eax
  char *v5; // eax
  const char *v6; // esi
  int v7; // ecx
  char v8; // al
  int v9; // eax
  int v10; // [esp+10h] [ebp-4h] BYREF

  v0 = 0;
  dword_101C82B8 = 0;
  dword_100284F8 = -1;
  dword_100284E8 = -1;
  v1 = getenv_0("TZ");
  v2 = v1;
  if ( !v1 )
  {
    if ( FIX_DLL_KERNEL32_dll_GetTimeZoneInformation(&dword_101C82C0) == -1 )
      return;
    dword_10028450 = 60 * dword_101C82C0;
    dword_101C82B8 = 1;
    if ( word_101C8306 )
      dword_10028450 = 60 * dword_101C8314 + 60 * dword_101C82C0;
    if ( word_101C835A && dword_101C8368 )
    {
      dword_10028454 = 1;
      dword_10028458 = 60 * (dword_101C8368 - dword_101C8314);
    }
    else
    {
      dword_10028454 = 0;
      dword_10028458 = 0;
    }
    v3 = (int (__stdcall *)(_DWORD, int, void *, int, char *, int, _DWORD, int *))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
    if ( !FIX_DLL_KERNEL32_dll_WideCharToMultiByte(dword_101C8124, 544, &unk_101C82C4, -1, off_100284DC, 63, 0, &v10)
      || v10 )
    {
      *off_100284DC = 0;
    }
    else
    {
      off_100284DC[63] = 0;
    }
    if ( v3(dword_101C8124, 544, &unk_101C8318, -1, off_100284E0, 63, 0, &v10) && !v10 )
    {
      off_100284E0[63] = 0;
      return;
    }
LABEL_41:
    *off_100284E0 = 0;
    return;
  }
  if ( *v1 && (!dword_101C836C || strcmp(v1, dword_101C836C)) )
  {
    sub_100189EC((unsigned int)dword_101C836C);
    v4 = strlen(v2);
    v5 = (char *)sub_10019098(v4 + 1);
    dword_101C836C = v5;
    if ( v5 )
    {
      strcpy(v5, v2);
      strncpy_0(off_100284DC, v2, 3u);
      v6 = v2 + 3;
      off_100284DC[3] = 0;
      if ( *v6 == 45 )
      {
        ++v6;
        v0 = 1;
      }
      v7 = 3600 * atol_0(v6);
      dword_10028450 = v7;
      while ( 1 )
      {
        v8 = *v6;
        if ( *v6 != 43 && (v8 < 48 || v8 > 57) )
          break;
        ++v6;
      }
      if ( *v6 == 58 )
      {
        v7 = 60 * atol_0(++v6) + dword_10028450;
        dword_10028450 = v7;
        while ( *v6 >= 48 && *v6 <= 57 )
          ++v6;
        if ( *v6 == 58 )
        {
          v7 = atol_0(++v6) + dword_10028450;
          dword_10028450 = v7;
          while ( *v6 >= 48 && *v6 <= 57 )
            ++v6;
        }
      }
      if ( v0 )
        dword_10028450 = -v7;
      v9 = *v6;
      dword_10028454 = v9;
      if ( v9 )
      {
        strncpy_0(off_100284E0, v6, 3u);
        off_100284E0[3] = 0;
        return;
      }
      goto LABEL_41;
    }
  }
}
// 10021158: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD);
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10028450: using guessed type int dword_10028450;
// 10028454: using guessed type int dword_10028454;
// 10028458: using guessed type int dword_10028458;
// 100284E8: using guessed type int dword_100284E8;
// 100284F8: using guessed type int dword_100284F8;
// 101C82B8: using guessed type int dword_101C82B8;
// 101C82C0: using guessed type int dword_101C82C0;
// 101C8306: using guessed type __int16 word_101C8306;
// 101C8314: using guessed type int dword_101C8314;
// 101C835A: using guessed type __int16 word_101C835A;
// 101C8368: using guessed type int dword_101C8368;

//----- (1001DCB0) --------------------------------------------------------
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int result; // eax
  int v19; // eax
  _BOOL1 v20; // sf
  int v21; // ecx
  int v22; // [esp+18h] [ebp+10h]

  if ( a2 == 1 )
  {
    v22 = a3 & 3;
    if ( (a3 & 3) != 0 )
      v12 = dword_10028534[a4];
    else
      v12 = dword_10028500[a4];
    v13 = v12 + 1;
    v14 = (365 * a3 + ((a3 - 1) >> 2) + v12 + 1 - 25563) % 7;
    if ( v14 > a6 )
      v15 = a6 + 7 * a5 - v14 + v13;
    else
      v15 = v13 + a6 + 7 * a5 - v14 - 7;
    if ( a5 == 5 )
    {
      if ( v22 )
        v16 = dword_10028538[a4];
      else
        v16 = dword_10028504[a4];
      if ( v15 > v16 )
        v15 -= 7;
    }
  }
  else
  {
    if ( (a3 & 3) != 0 )
      v17 = dword_10028534[a4];
    else
      v17 = dword_10028500[a4];
    v15 = a7 + v17;
  }
  if ( a1 == 1 )
  {
    dword_100284EC = v15;
    dword_100284E8 = a3;
    result = a11 + 1000 * (a10 + 60 * (a9 + 60 * a8));
    dword_100284F0 = result;
    return result;
  }
  dword_100284FC = v15;
  v19 = 1000 * (a10 + dword_10028458 + 60 * (a9 + 60 * a8));
  v20 = a11 + v19 < 0;
  result = a11 + v19;
  dword_10028500[0] = result;
  if ( v20 )
  {
    result += 86400000;
    v21 = v15 - 1;
    dword_10028500[0] = result;
LABEL_24:
    dword_100284FC = v21;
    goto LABEL_25;
  }
  if ( result >= 86400000 )
  {
    result -= 86400000;
    v21 = v15 + 1;
    dword_10028500[0] = result;
    goto LABEL_24;
  }
LABEL_25:
  dword_100284F8 = a3;
  return result;
}
// 10028458: using guessed type int dword_10028458;
// 100284E8: using guessed type int dword_100284E8;
// 100284EC: using guessed type int dword_100284EC;
// 100284F0: using guessed type int dword_100284F0;
// 100284F8: using guessed type int dword_100284F8;
// 100284FC: using guessed type int dword_100284FC;
// 10028500: using guessed type int dword_10028500[];
// 10028534: using guessed type int dword_10028534[];

//----- (1001E030) --------------------------------------------------------
char *__cdecl strstr_0(const char *a1, const char *a2)
{
  char v2; // dl
  const char *v3; // edi
  char v4; // dh
  const char *v5; // ecx
  char *v6; // esi
  char v7; // al
  char v9; // ah
  char v10; // al
  char v11; // al

  v2 = *a2;
  v3 = a1;
  if ( !*a2 )
    return (char *)a1;
  v4 = a2[1];
  if ( !v4 )
    JUMPOUT(0x100162D6);
LABEL_3:
  v5 = a2;
  v6 = (char *)(v3 + 1);
  if ( *v3 == v2 )
    goto LABEL_9;
  if ( *v3 )
  {
    while ( 2 )
    {
      v7 = *v6++;
      while ( v7 == v2 )
      {
LABEL_9:
        v7 = *v6++;
        if ( v7 == v4 )
        {
          v3 = v6 - 1;
          while ( 1 )
          {
            v9 = v5[2];
            if ( !v9 )
              break;
            v10 = *v6;
            v6 += 2;
            if ( v10 != v9 )
              goto LABEL_3;
            v11 = v5[3];
            if ( !v11 )
              break;
            v5 += 2;
            if ( v11 != *(v6 - 1) )
              goto LABEL_3;
          }
          return (char *)(v3 - 1);
        }
      }
      if ( v7 )
        continue;
      break;
    }
  }
  return 0;
}
// 1001E09E: control flows out of bounds to 100162D6

//----- (1001E0E8) --------------------------------------------------------
int __cdecl _setmbcp_0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  _BOOL1 v5; // cc
  char *v6; // ecx
  unsigned __int8 v7; // dl
  unsigned int j; // eax
  int v9; // esi
  int *v10; // ebx
  int *i; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // eax
  unsigned int v14; // edi
  char v15; // dl
  signed int v16; // eax
  int *v17; // esi
  unsigned int k; // eax
  unsigned int v20; // [esp+Ch] [ebp-18h] BYREF
  char v21; // [esp+12h] [ebp-12h]
  char v22; // [esp+13h] [ebp-11h] BYREF
  unsigned int v23; // [esp+20h] [ebp-4h]
  int v24; // [esp+2Ch] [ebp+8h]

  v1 = getSystemCP_0(a1);
  v2 = v1;
  v24 = v1;
  if ( v1 == dword_101C837C )
    return 0;
  if ( !v1 )
  {
LABEL_30:
    setSBCS_0();
LABEL_31:
    setSBUpLow();
    return 0;
  }
  v3 = 0;
  v4 = &unk_10028578;
  do
  {
    if ( *v4 == v2 )
    {
      memset(&unk_101C84A0, 0, 0x100u);
      v23 = 0;
      v9 = 12 * v3;
      *((_BYTE *)&unk_101C84A0 + 256) = 0;
      v10 = &dword_10028588[12 * v3];
      do
      {
        for ( i = v10; *(_BYTE *)i; i = (int *)((char *)i + 2) )
        {
          v12 = *((_BYTE *)i + 1);
          if ( !v12 )
            break;
          v13 = *(unsigned __int8 *)i;
          v14 = v12;
          if ( v13 <= v12 )
          {
            v15 = byte_10028570[v23];
            do
              byte_101C84A1[v13++] |= v15;
            while ( v13 <= v14 );
          }
        }
        ++v23;
        v10 += 2;
      }
      while ( v23 < 4 );
      dword_101C838C = 1;
      dword_101C837C = v24;
      v16 = CPtoLCID_0(v24);
      v17 = &dword_1002857C[v9];
      dword_101C8380[0] = *v17++;
      dword_101C8380[1] = *v17;
      dword_101C85A4 = v16;
      dword_101C8380[2] = v17[1];
      goto LABEL_31;
    }
    v4 += 12;
    ++v3;
  }
  while ( (int)v4 < (int)&unk_10028668 );
  if ( FIX_DLL_KERNEL32_dll_GetCPInfo(v2, &v20) == 1 )
  {
    v5 = v20 <= 1;
    dword_101C837C = v2;
    memset(&unk_101C84A0, 0, 0x100u);
    *((_BYTE *)&unk_101C84A0 + 256) = 0;
    dword_101C85A4 = 0;
    if ( v5 )
    {
      dword_101C838C = 0;
    }
    else
    {
      if ( v21 )
      {
        v6 = &v22;
        do
        {
          v7 = *v6;
          if ( !*v6 )
            break;
          for ( j = (unsigned __int8)*(v6 - 1); j <= v7; ++j )
            byte_101C84A1[j] |= 4u;
          v6 += 2;
        }
        while ( *(v6 - 1) );
      }
      for ( k = 1; k < 0xFF; ++k )
        byte_101C84A1[k] |= 8u;
      dword_101C85A4 = CPtoLCID_0(v2);
      dword_101C838C = 1;
    }
    dword_101C8380[0] = 0;
    dword_101C8380[1] = 0;
    dword_101C8380[2] = 0;
    goto LABEL_31;
  }
  if ( dword_101C8374 )
    goto LABEL_30;
  return -1;
}
// 1001E327: using guessed type int setSBUpLow(void);
// 100210E4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD);
// 1002857C: using guessed type int dword_1002857C[];
// 10028588: using guessed type int dword_10028588[];
// 101C8374: using guessed type int dword_101C8374;
// 101C838C: using guessed type int dword_101C838C;
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001E281) --------------------------------------------------------
int __cdecl getSystemCP_0(int a1)
{
  int result; // eax

  result = a1;
  dword_101C8374 = 0;
  switch ( a1 )
  {
    case -2:
      dword_101C8374 = 1;
      result = FIX_DLL_KERNEL32_dll_GetOEMCP();
      break;
    case -3:
      dword_101C8374 = 1;
      result = FIX_DLL_KERNEL32_dll_GetACP();
      break;
    case -4:
      result = dword_101C8124;
      dword_101C8374 = 1;
      break;
  }
  return result;
}
// 100210DC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetOEMCP)(void);
// 100210E0: using guessed type int (*FIX_DLL_KERNEL32_dll_GetACP)(void);
// 101C8374: using guessed type int dword_101C8374;

//----- (1001E2CB) --------------------------------------------------------
signed int __cdecl CPtoLCID_0(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}

//----- (1001E2FE) --------------------------------------------------------
int __cdecl setSBCS_0()
{
  int result; // eax

  memset(&unk_101C84A0, 0, 0x100u);
  *((_BYTE *)&unk_101C84A0 + 256) = 0;
  result = 0;
  dword_101C837C = 0;
  dword_101C838C = 0;
  dword_101C85A4 = 0;
  dword_101C8380[0] = 0;
  dword_101C8380[1] = 0;
  dword_101C8380[2] = 0;
  return result;
}
// 101C838C: using guessed type int dword_101C838C;
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001E4BC) --------------------------------------------------------
signed int __cdecl sub_1001E4BC()
{
  signed int result; // eax

  if ( !dword_101C9710 )
  {
    result = _setmbcp_0(-3);
    dword_101C9710 = 1;
  }
  return result;
}
// 101C9710: using guessed type int dword_101C9710;

//----- (1001E4D8) --------------------------------------------------------
_DWORD *__cdecl _dosmaperr_0(unsigned int a1)
{
  int v1; // edx
  _DWORD *result; // eax

  v1 = 0;
  dword_101C8078 = a1;
  result = &unk_10028668;
  do
  {
    if ( a1 == *result )
    {
      result = (_DWORD *)dword_1002866C[2 * v1];
      dword_101C8074 = (int)result;
      return result;
    }
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_100287D0 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || (dword_101C8074 = 8, a1 > 0xCA) )
      dword_101C8074 = 22;
  }
  else
  {
    dword_101C8074 = 13;
  }
  return result;
}
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;

//----- (1001E53F) --------------------------------------------------------
int __cdecl _alloc_osfhnd_0()
{
  int v0; // ebx
  int v1; // edi
  int v2; // esi
  int *v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edx
  char *v6; // eax
  unsigned int v7; // edx

  v0 = -1;
  v1 = 0;
  v2 = 0;
  v3 = dword_101C85E0;
  while ( 1 )
  {
    v4 = *v3;
    if ( !*v3 )
      break;
    v5 = v4 + 256;
    while ( v4 < v5 )
    {
      if ( (*(_BYTE *)(v4 + 4) & 1) == 0 )
      {
        *(_DWORD *)v4 = -1;
        v0 = v2 + ((int)(v4 - *v3) >> 3);
        if ( v0 != -1 )
          return v0;
        break;
      }
      v4 += 8;
    }
    ++v3;
    ++v1;
    v2 += 32;
    if ( (int)v3 >= (int)&dword_101C86E0 )
      return v0;
  }
  v6 = (char *)sub_10019098(256);
  if ( v6 )
  {
    dword_101C86E0 += 32;
    v7 = (unsigned int)(v6 + 256);
    dword_101C85E0[v1] = (int)v6;
    while ( (unsigned int)v6 < v7 )
    {
      v6[4] = 0;
      *(_DWORD *)v6 = -1;
      v6[5] = 10;
      v6 += 8;
      v7 = dword_101C85E0[v1] + 256;
    }
    v0 = 32 * v1;
  }
  return v0;
}
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001E5D4) --------------------------------------------------------
int __usercall _set_osfhnd_0@<eax>(int a1@<ebx>, int a2, HANDLE hHandle)
{
  int v4; // [esp-Ch] [ebp-14h]
  HANDLE v5; // [esp-8h] [ebp-10h]

  if ( (unsigned int)a2 < dword_101C86E0 && *(_DWORD *)(dword_101C85E0[a2 >> 5] + 8 * (a2 & 0x1F)) == -1 )
  {
    if ( dword_101C80F0 == 1 )
    {
      switch ( a2 )
      {
        case 0:
          v5 = hHandle;
          v4 = -10;
          goto LABEL_10;
        case 1:
          v5 = hHandle;
          v4 = -11;
          goto LABEL_10;
        case 2:
          v5 = hHandle;
          v4 = -12;
LABEL_10:
          FIX_DLL_KERNEL32_dll_SetStdHandle(v4, v5, a1);
          break;
      }
    }
    *(_DWORD *)(dword_101C85E0[a2 >> 5] + 8 * (a2 & 0x1F)) = hHandle;
    return 0;
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 1001E5D4: could not find valid save-restore pair for ebx
// 100210D8: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001E64B) --------------------------------------------------------
signed int __cdecl _free_osfhnd_0(signed int a1)
{
  int v1; // eax
  int v3; // [esp-8h] [ebp-10h]

  if ( (unsigned int)a1 < dword_101C86E0 )
  {
    v1 = 8 * (a1 & 0x1F) + dword_101C85E0[a1 >> 5];
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 && *(_DWORD *)v1 != -1 )
    {
      if ( dword_101C80F0 == 1 )
      {
        switch ( a1 )
        {
          case 0:
            v3 = -10;
            goto LABEL_11;
          case 1:
            v3 = -11;
            goto LABEL_11;
          case 2:
            v3 = -12;
LABEL_11:
            ((void (__cdecl *)(int, _DWORD))FIX_DLL_KERNEL32_dll_SetStdHandle)(v3, 0);
            break;
        }
      }
      *(_DWORD *)(dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F)) = -1;
      return 0;
    }
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 100210D8: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001E6C5) --------------------------------------------------------
int __cdecl _get_osfhandle_0(int a1)
{
  int v1; // eax

  if ( (unsigned int)a1 < dword_101C86E0 )
  {
    v1 = dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001E79F) --------------------------------------------------------
int __cdecl fclose_0(FILE *a1)
{
  int v1; // edi
  int v2; // eax
  int result; // eax

  v1 = -1;
  v2 = a1->_flag;
  if ( (v2 & 0x40) != 0 )
  {
    result = -1;
  }
  else
  {
    if ( (v2 & 0x83) != 0 )
    {
      v1 = _flush_0((int)a1);
      _freebuf_0(a1);
      if ( _close_0(a1->_file) >= 0 )
      {
        if ( a1->_tmpfname )
        {
          sub_100189EC((unsigned int)a1->_tmpfname);
          a1->_tmpfname = 0;
        }
      }
      else
      {
        v1 = -1;
      }
    }
    result = v1;
  }
  a1->_flag = 0;
  return result;
}

//----- (1001E7F5) --------------------------------------------------------
signed int __cdecl __addl_0(unsigned int a1, unsigned int a2, int a3)
{
  signed int result; // eax
  unsigned int v4; // ecx

  result = 0;
  v4 = a1 + a2;
  if ( a1 + a2 < a1 || v4 < a2 )
    result = 1;
  *(_DWORD *)a3 = v4;
  return result;
}

//----- (1001E816) --------------------------------------------------------
signed int __cdecl __add_12_0(int a1, int a2)
{
  if ( __addl_0(*(_DWORD *)a1, *(_DWORD *)a2, a1) && __addl_0(*(_DWORD *)(a1 + 4), 1u, a1 + 4) )
    ++*(_DWORD *)(a1 + 8);
  if ( __addl_0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a2 + 4), a1 + 4) )
    ++*(_DWORD *)(a1 + 8);
  return __addl_0(*(_DWORD *)(a1 + 8), *(_DWORD *)(a2 + 8), a1 + 8);
}

//----- (1001E874) --------------------------------------------------------
int __cdecl __shl_12_0(int a1)
{
  int result; // eax
  unsigned int v2; // edi
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)a1;
  *(_DWORD *)a1 *= 2;
  v4 = (v3 >> 31) | (2 * v2);
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = v4;
  *(_DWORD *)(a1 + 8) = (v2 >> 31) | (2 * v5);
  return result;
}

//----- (1001E8A2) --------------------------------------------------------
int __cdecl __shr_12_0(int a1)
{
  int result; // eax
  unsigned int v2; // edx
  int v3; // edi
  int v4; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = *(__int64 *)(a1 + 4) >> 1;
  v4 = (v3 << 31) | (*(_DWORD *)a1 >> 1);
  *(_DWORD *)(a1 + 8) = v2 >> 1;
  *(_DWORD *)a1 = v4;
  return result;
}

//----- (1001E8CF) --------------------------------------------------------
__int16 __cdecl __mtold12_0(int a1, int a2, int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // eax
  __int16 result; // ax
  int v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int v12; // [esp+28h] [ebp+10h]

  v11 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = *(_DWORD *)(a3 + 8);
      __shl_12_0(a3);
      __shl_12_0(a3);
      __add_12_0(a3, (int)&v8);
      __shl_12_0(a3);
      v9 = 0;
      v10 = 0;
      v8 = *(char *)a1;
      __add_12_0(a3, (int)&v8);
      ++a1;
      --v12;
    }
    while ( v12 );
  }
  while ( !*(_DWORD *)(a3 + 8) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 8) = HIWORD(v4);
    v5 = (v4 << 16) | HIWORD(*(_DWORD *)a3);
    v6 = *(_DWORD *)a3 << 16;
    v11 += 65520;
    *(_DWORD *)(a3 + 4) = v5;
    *(_DWORD *)a3 = v6;
  }
  while ( (*(_DWORD *)(a3 + 8) & 0x8000) == 0 )
  {
    __shl_12_0(a3);
    v11 += 0xFFFF;
  }
  result = v11;
  *(_WORD *)(a3 + 10) = v11;
  return result;
}

//----- (1001E996) --------------------------------------------------------
int __cdecl __strgtold12_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // edi
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char *v12; // eax
  char *v14; // eax
  int v15; // eax
  char *v16; // ecx
  int v17; // esi
  int v18; // eax
  _BOOL1 v20; // zf
  int v21; // eax
  int v22; // eax
  signed int v23; // eax
  int v24; // ebx
  int v25; // esi
  __int16 v26; // ax
  __int16 v27; // dx
  __int16 v28; // ax
  int result; // eax
  int v30; // [esp-4h] [ebp-6Ch]
  int v31; // [esp-4h] [ebp-6Ch]
  char v32[11]; // [esp+Ch] [ebp-5Ch] BYREF
  char v33; // [esp+23h] [ebp-45h]
  _WORD v34[3]; // [esp+28h] [ebp-40h] BYREF
  int v35; // [esp+2Eh] [ebp-3Ah]
  int v36; // [esp+32h] [ebp-36h]
  int v37; // [esp+38h] [ebp-30h]
  int v38; // [esp+3Ch] [ebp-2Ch]
  int v39; // [esp+40h] [ebp-28h]
  int v40; // [esp+44h] [ebp-24h]
  int v41; // [esp+48h] [ebp-20h]
  int v42; // [esp+4Ch] [ebp-1Ch]
  int v43; // [esp+50h] [ebp-18h]
  int v44; // [esp+54h] [ebp-14h]
  int v45; // [esp+58h] [ebp-10h]
  char *v46; // [esp+5Ch] [ebp-Ch]
  int v47; // [esp+60h] [ebp-8h]
  unsigned int v48; // [esp+64h] [ebp-4h]

  v7 = (char *)a3;
  v46 = v32;
  v8 = 0;
  v39 = 0;
  v43 = 1;
  v48 = 0;
  v45 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v37 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  while ( 1 )
  {
    v9 = *v7;
    if ( *v7 != ' ' && v9 != '\t' && v9 != '\n' && v9 != '\r' )
      break;
    ++v7;
  }
  while ( 2 )
  {
    v10 = *v7++;
    switch ( v8 )
    {
      case 0:
        if ( v10 >= '1' && v10 <= '9' )
          goto LABEL_10;
        if ( v10 == byte_10026008 )
          goto LABEL_12;
        if ( v10 == '+' )
        {
          v39 = 0;
          v8 = 2;
          continue;
        }
        if ( v10 == '-' )
        {
          v39 = 0x8000;
          v8 = 2;
          continue;
        }
        if ( v10 != 48 )
          goto LABEL_108;
        goto LABEL_35;
      case 1:
        v45 = 1;
        if ( v10 >= '1' && v10 <= '9' )
          goto LABEL_10;
        if ( v10 == byte_10026008 )
          goto LABEL_46;
        if ( v10 == '+' || v10 == '-' )
          goto LABEL_30;
        if ( v10 != '0' )
          goto LABEL_25;
        goto LABEL_35;
      case 2:
        if ( v10 >= '1' && v10 <= '9' )
        {
LABEL_10:
          v30 = 3;
LABEL_80:
          v8 = v30;
LABEL_81:
          --v7;
        }
        else
        {
          if ( v10 == byte_10026008 )
          {
LABEL_12:
            v31 = 5;
            goto LABEL_89;
          }
          if ( v10 != '0' )
          {
LABEL_93:
            v7 = (char *)a3;
            goto LABEL_110;
          }
LABEL_35:
          v8 = 1;
        }
        continue;
      case 3:
        v45 = 1;
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 >= 0x19 )
          {
            ++v47;
          }
          else
          {
            v12 = v46;
            ++v48;
            ++v46;
            *v12 = v10 - '0';
          }
          v10 = *v7++;
        }
        if ( v10 != byte_10026008 )
          goto LABEL_57;
LABEL_46:
        v8 = 4;
        continue;
      case 4:
        v45 = 1;
        v40 = 1;
        if ( !v48 )
        {
          while ( v10 == '0' )
          {
            --v47;
            v10 = *v7++;
          }
        }
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 < 0x19 )
          {
            v14 = v46;
            ++v48;
            ++v46;
            --v47;
            *v14 = v10 - '0';
          }
          v10 = *v7++;
        }
LABEL_57:
        if ( v10 == '+' || v10 == '-' )
        {
LABEL_30:
          --v7;
          v31 = 11;
        }
        else
        {
LABEL_25:
          if ( v10 <= 'C' || v10 > 'E' && (v10 <= 'c' || v10 > 'e') )
          {
LABEL_108:
            --v7;
            goto LABEL_110;
          }
          v31 = 6;
        }
        goto LABEL_89;
      case 5:
        v40 = 1;
        if ( (int)dword_10026004 <= 1 )
          v15 = *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4;
        else
          v15 = _isctype_0((unsigned __int8)v10, 4);
        if ( !v15 )
          goto LABEL_93;
        v8 = 4;
        goto LABEL_81;
      case 6:
        v16 = v7 - 2;
        a3 = (int)(v7 - 2);
        if ( v10 >= '1' && v10 <= '9' )
          goto LABEL_79;
        if ( v10 == '+' )
          goto LABEL_88;
        if ( v10 == '-' )
          goto LABEL_87;
        if ( v10 != 48 )
          goto LABEL_109;
LABEL_70:
        v31 = 8;
        goto LABEL_89;
      case 7:
        if ( v10 >= '1' && v10 <= '9' )
          goto LABEL_79;
        if ( v10 == '0' )
          goto LABEL_70;
        goto LABEL_93;
      case 8:
        v41 = 1;
        while ( v10 == '0' )
          v10 = *v7++;
        if ( v10 < '1' || v10 > '9' )
          goto LABEL_108;
LABEL_79:
        v30 = 9;
        goto LABEL_80;
      case 9:
        v41 = 1;
        v17 = 0;
        while ( 2 )
        {
          if ( (int)dword_10026004 <= 1 )
            v18 = *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4;
          else
            v18 = _isctype_0((unsigned __int8)v10, 4);
          if ( v18 )
          {
            v17 = v10 + 10 * v17 - 48;
            if ( v17 <= 5200 )
            {
              v10 = *v7++;
              continue;
            }
            v17 = 5201;
          }
          break;
        }
        v42 = v17;
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
          v10 = *v7++;
        goto LABEL_108;
      case 11:
        if ( !a7 )
        {
          --v7;
          v8 = '\n';
LABEL_91:
          if ( v8 == '\n' )
            goto LABEL_110;
          continue;
        }
        v16 = v7 - 1;
        a3 = (int)(v7 - 1);
        if ( v10 == '+' )
        {
LABEL_88:
          v31 = 7;
LABEL_89:
          v8 = v31;
          continue;
        }
        if ( v10 == '-' )
        {
LABEL_87:
          v43 = -1;
          v8 = 7;
          continue;
        }
LABEL_109:
        v7 = v16;
LABEL_110:
        v20 = v45 == 0;
        *(_DWORD *)a2 = v7;
        if ( v20 )
        {
          v27 = 0;
          v26 = 0;
          v25 = 0;
          v24 = 0;
          v44 = 4;
        }
        else
        {
          if ( v48 <= 0x18 )
          {
            v21 = (int)v46;
          }
          else
          {
            if ( v33 >= 5 )
              ++v33;
            v48 = 24;
            v21 = (int)(v46 - 1);
            ++v47;
          }
          if ( v48 )
          {
            while ( !*(_BYTE *)--v21 )
            {
              --v48;
              ++v47;
            }
            __mtold12_0((int)v32, v48, (int)v34);
            v22 = v42;
            if ( v43 < 0 )
              v22 = -v42;
            v23 = v47 + v22;
            if ( !v41 )
              v23 += a5;
            if ( !v40 )
              v23 -= a6;
            if ( v23 > 5200 )
            {
              v38 = 1;
              goto LABEL_127;
            }
            if ( v23 >= -5200 )
            {
              __multtenpow12_0((int)v34, v23, a4);
              v27 = v34[0];
              v24 = *(_DWORD *)&v34[1];
              v25 = v35;
              v26 = v36;
            }
            else
            {
              v37 = 1;
LABEL_127:
              v24 = a3;
              v25 = a3;
              v26 = a3;
              v27 = a3;
            }
          }
          else
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
          }
          if ( v38 )
          {
            v24 = 0;
            v26 = 0x7FFF;
            v25 = 0x80000000;
            v27 = 0;
            v44 = 2;
          }
          else if ( v37 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
            v44 = 1;
          }
        }
        v28 = v39 | v26;
        *(_DWORD *)(a1 + 6) = v25;
        *(_DWORD *)(a1 + 2) = v24;
        *(_WORD *)(a1 + 10) = v28;
        result = v44;
        *(_WORD *)a1 = v27;
        return result;
      default:
        goto LABEL_91;
    }
  }
}
// 10025DF8: using guessed type int dword_10025DF8;
// 10026008: using guessed type char byte_10026008;

//----- (1001EEA3) --------------------------------------------------------
signed int __cdecl _I10_OUTPUT_0(__int64 a1, int a2, int a3, char a4, int a5)
{
  int v5; // ebx
  __int16 v6; // cx
  unsigned __int16 v7; // dx
  int v8; // edi
  int v9; // esi
  _BOOL1 v10; // zf
  int v11; // edi
  int v12; // esi
  int v13; // esi
  int v14; // eax
  char v15; // al
  _BYTE *v16; // ecx
  char v17; // cl
  _BYTE *v18; // eax
  _BOOL1 v19; // cc
  _BYTE *v20; // ecx
  char v21; // al
  const char *v23; // [esp-4h] [ebp-2Ch]
  const char *v24; // [esp-4h] [ebp-2Ch]
  char v25[12]; // [esp+Ch] [ebp-1Ch] BYREF
  _BYTE v26[12]; // [esp+18h] [ebp-10h] BYREF
  int v27; // [esp+24h] [ebp-4h]

  v5 = a5;
  v6 = a2 & 0x8000;
  v25[0] = -52;
  v25[1] = -52;
  v25[2] = -52;
  v25[3] = -52;
  v25[4] = -52;
  v25[5] = -52;
  v25[6] = -52;
  v25[7] = -52;
  v25[8] = -52;
  v25[9] = -52;
  v25[10] = -5;
  v25[11] = 63;
  v27 = 1;
  v7 = a2 & 0x7FFF;
  if ( (a2 & 0x8000u) == 0 )
    *(_BYTE *)(a5 + 2) = 32;
  else
    *(_BYTE *)(a5 + 2) = 45;
  v8 = HIDWORD(a1);
  if ( !v7 && !a1 )
    goto LABEL_6;
  if ( v7 == 0x7FFF )
  {
    *(_WORD *)v5 = 1;
    if ( (v8 != 0x80000000 || (_DWORD)a1) && (v8 & 0x40000000) == 0 )
    {
      v23 = "1#SNAN";
LABEL_22:
      strcpy((char *)(v5 + 4), v23);
      *(_BYTE *)(v5 + 3) = 6;
      return 0;
    }
    if ( v6 && v8 == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        v24 = "1#IND";
LABEL_19:
        strcpy((char *)(v5 + 4), v24);
        *(_BYTE *)(v5 + 3) = 5;
        return 0;
      }
    }
    else if ( v8 == 0x80000000 && !(_DWORD)a1 )
    {
      v24 = "1#INF";
      goto LABEL_19;
    }
    v23 = "1#QNAN";
    goto LABEL_22;
  }
  *(_WORD *)v26 = 0;
  *(_WORD *)&v26[10] = v7;
  v9 = (77 * (HIBYTE(v7) + 2 * HIBYTE(HIDWORD(a1))) + 19728 * v7 - 323162868) >> 16;
  *(_QWORD *)&v26[2] = a1;
  __multtenpow12_0((int)v26, -(__int16)v9, 1);
  if ( *(_WORD *)&v26[10] >= 0x3FFFu )
  {
    LOWORD(v9) = v9 + 1;
    __ld12mul_0((int)v26, (int)v25);
  }
  v10 = (a4 & 1) == 0;
  *(_WORD *)v5 = v9;
  if ( v10 )
  {
    v11 = a3;
    goto LABEL_29;
  }
  v11 = (__int16)v9 + a3;
  if ( v11 > 0 )
  {
LABEL_29:
    if ( v11 > 21 )
      v11 = 21;
    v12 = *(unsigned __int16 *)&v26[10] - 16382;
    *(_WORD *)&v26[10] = 0;
    a5 = 8;
    do
    {
      __shl_12_0((int)v26);
      --a5;
    }
    while ( a5 );
    if ( v12 < 0 )
    {
      v13 = (unsigned __int8)-(char)v12;
      if ( v13 > 0 )
      {
        do
        {
          __shr_12_0((int)v26);
          --v13;
        }
        while ( v13 );
      }
    }
    v14 = v5 + 4;
    a5 = v5 + 4;
    if ( v11 + 1 > 0 )
    {
      a3 = v11 + 1;
      do
      {
        a1 = *(_QWORD *)v26;
        a2 = *(_DWORD *)&v26[8];
        __shl_12_0((int)v26);
        __shl_12_0((int)v26);
        __add_12_0((int)v26, (int)&a1);
        __shl_12_0((int)v26);
        v15 = v26[11];
        v16 = (_BYTE *)a5;
        v26[11] = 0;
        ++a5;
        v10 = a3-- == 1;
        *v16 = v15 + 48;
      }
      while ( !v10 );
      v14 = a5;
    }
    v17 = *(_BYTE *)(v14 - 1);
    v18 = (_BYTE *)(v14 - 2);
    v19 = v17 < 53;
    v20 = (_BYTE *)(v5 + 4);
    if ( v19 )
    {
      while ( v18 >= v20 )
      {
        if ( *v18 != 48 )
        {
          if ( v18 >= v20 )
            goto LABEL_47;
          break;
        }
        --v18;
      }
      *(_WORD *)v5 = 0;
      *(_BYTE *)(v5 + 2) = 32;
      *(_BYTE *)(v5 + 3) = 1;
      *v20 = 48;
      goto LABEL_54;
    }
    while ( v18 >= v20 )
    {
      if ( *v18 != 57 )
      {
        if ( v18 >= v20 )
          goto LABEL_46;
        break;
      }
      *v18-- = 48;
    }
    ++v18;
    ++*(_WORD *)v5;
LABEL_46:
    ++*v18;
LABEL_47:
    v21 = (_BYTE)v18 - v5 - 3;
    *(_BYTE *)(v5 + 3) = v21;
    *(_BYTE *)(v21 + v5 + 4) = 0;
    return v27;
  }
LABEL_6:
  *(_WORD *)v5 = 0;
  *(_BYTE *)(v5 + 2) = 32;
  *(_BYTE *)(v5 + 3) = 1;
  *(_BYTE *)(v5 + 4) = 48;
LABEL_54:
  *(_BYTE *)(v5 + 5) = 0;
  return 1;
}

//----- (1001F136) --------------------------------------------------------
char *__cdecl getenv_0(const char *a1)
{
  const char **v1; // esi
  size_t v2; // edi

  v1 = (const char **)dword_101C809C;
  if ( dword_101C970C )
  {
    if ( dword_101C809C || dword_101C80A4 && !__wtomb_environ_0() && (v1 = (const char **)dword_101C809C) != 0 )
    {
      if ( a1 )
      {
        v2 = strlen(a1);
        while ( *v1 )
        {
          if ( strlen(*v1) > v2
            && (*v1)[v2] == 61
            && !_mbsnbicoll_0((const unsigned __int8 *)*v1, (const unsigned __int8 *)a1, v2) )
          {
            return (char *)&(*v1)[v2 + 1];
          }
          ++v1;
        }
      }
    }
  }
  return 0;
}
// 101C809C: using guessed type int dword_101C809C;
// 101C80A4: using guessed type int dword_101C80A4;
// 101C970C: using guessed type int dword_101C970C;

//----- (1001F1B3) --------------------------------------------------------
int __cdecl _close_0(int a1)
{
  int v1; // esi
  int v2; // ebp
  int v3; // eax
  unsigned int v4; // ebp

  if ( (unsigned int)a1 < dword_101C86E0
    && (v1 = 8 * (a1 & 0x1F), (*(_BYTE *)(dword_101C85E0[a1 >> 5] + v1 + 4) & 1) != 0) )
  {
    if ( _get_osfhandle_0(a1) == -1
      || (a1 == 1 || a1 == 2) && (v2 = _get_osfhandle_0(2), _get_osfhandle_0(1) == v2)
      || (v3 = _get_osfhandle_0(a1), FIX_DLL_KERNEL32_dll_CloseHandle(v3)) )
    {
      v4 = 0;
    }
    else
    {
      v4 = ((int (__cdecl *)())FIX_DLL_KERNEL32_dll_GetLastError)();
    }
    _free_osfhnd_0(a1);
    *(_BYTE *)(dword_101C85E0[a1 >> 5] + v1 + 4) = 0;
    if ( !v4 )
      return 0;
    _dosmaperr_0(v4);
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);
// 10021028: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLastError)(_DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001F266) --------------------------------------------------------
int __cdecl __ld12mul_0(int a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // di
  int result; // eax
  int v8; // ecx
  int v9; // edi
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // ebx
  _BYTE v13[12]; // [esp+Ch] [ebp-24h] BYREF
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h]
  int v16; // [esp+20h] [ebp-10h]
  unsigned __int16 *v17; // [esp+24h] [ebp-Ch]
  unsigned __int16 *v18; // [esp+28h] [ebp-8h]
  _WORD *v19; // [esp+2Ch] [ebp-4h]
  int v20; // [esp+38h] [ebp+8h]
  int v21; // [esp+38h] [ebp+8h]
  int i; // [esp+3Ch] [ebp+Ch]

  v4 = *(_WORD *)(a2 + 10);
  v15 = 0;
  *(_DWORD *)v13 = 0;
  *(_DWORD *)&v13[4] = 0;
  *(_DWORD *)&v13[8] = 0;
  v5 = *(_WORD *)(a1 + 10);
  v6 = v5 ^ v4;
  result = v5 & 0x7FFF;
  v8 = v4 & 0x7FFF;
  v9 = v6 & 0x8000;
  v10 = v8 + result;
  v20 = v8 + result;
  if ( (unsigned __int16)result < 0x7FFFu && (unsigned __int16)v8 < 0x7FFFu && v10 <= 0xBFFDu )
  {
    if ( v10 <= 0x3FBFu )
    {
      result = 0;
LABEL_16:
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      return result;
    }
    if ( (_WORD)result || (++v20, (*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0) )
    {
      result = 0;
    }
    else
    {
      result = 0;
      if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
        goto LABEL_45;
    }
    if ( !(_WORD)v8 )
    {
      ++v20;
      if ( (*(_DWORD *)(a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD *)(a2 + 4) && !*(_DWORD *)a2 )
        goto LABEL_16;
    }
    v16 = 0;
    v19 = &v13[4];
    for ( i = 5; i > 0; --i )
    {
      v18 = (unsigned __int16 *)(a1 + 2 * v16);
      v17 = (unsigned __int16 *)(a2 + 8);
      v14 = i;
      do
      {
        if ( __addl_0(*((_DWORD *)v19 - 1), *v17 * *v18, (int)(v19 - 2)) )
          ++*v19;
        ++v18;
        --v17;
        --v14;
      }
      while ( v14 );
      ++v19;
      ++v16;
    }
    v21 = v20 + 49154;
    if ( (__int16)v21 <= 0 )
      goto LABEL_49;
    do
    {
      if ( v13[11] < 0 )
        break;
      __shl_12_0((int)v13);
      v21 += 0xFFFF;
    }
    while ( (__int16)v21 > 0 );
    if ( (__int16)v21 <= 0 )
    {
LABEL_49:
      v21 += 0xFFFF;
      if ( (v21 & 0x8000u) != 0 )
      {
        v11 = -(__int16)v21;
        v21 -= (__int16)v21;
        v12 = v11;
        do
        {
          if ( (v13[0] & 1) != 0 )
            ++v15;
          __shr_12_0((int)v13);
          --v12;
        }
        while ( v12 );
        if ( v15 )
          v13[0] |= 1u;
      }
    }
    if ( *(_WORD *)v13 > 0x8000u || (*(_DWORD *)v13 & 0x1FFFF) == 98304 )
    {
      if ( *(_DWORD *)&v13[2] == -1 )
      {
        *(_DWORD *)&v13[2] = 0;
        if ( *(_DWORD *)&v13[6] == -1 )
        {
          *(_DWORD *)&v13[6] = 0;
          if ( *(_WORD *)&v13[10] == 0xFFFF )
          {
            ++v21;
            *(_WORD *)&v13[10] = 0x8000;
          }
          else
          {
            ++*(_WORD *)&v13[10];
          }
        }
        else
        {
          ++*(_DWORD *)&v13[6];
        }
      }
      else
      {
        ++*(_DWORD *)&v13[2];
      }
    }
    result = v21;
    if ( (unsigned __int16)v21 < 0x7FFFu )
    {
      result = v9 | v21;
      *(_WORD *)a1 = *(_WORD *)&v13[2];
      *(_DWORD *)(a1 + 2) = *(_DWORD *)&v13[4];
      *(_DWORD *)(a1 + 6) = *(_DWORD *)&v13[8];
LABEL_45:
      *(_WORD *)(a1 + 10) = result;
      return result;
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = (_WORD)v9 != 0 ? -32768 : 2147450880;
  return result;
}
// 1001F32F: conditional instruction was optimized away because of '%arg_4.4>=1'

//----- (1001F486) --------------------------------------------------------
void __cdecl __multtenpow12_0(int a1, signed int a2, int a3)
{
  char *v3; // ebx
  char v4; // al
  int v5; // eax
  __int64 *v6; // esi
  _DWORD *v7; // esi
  __int64 v8; // [esp+4h] [ebp-Ch] BYREF
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (char *)&unk_100287D0 - 96;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      a2 = -a2;
      v3 = (char *)&unk_10028930 - 96;
    }
    if ( !a3 )
      *(_WORD *)a1 = 0;
    while ( a2 )
    {
      v4 = a2;
      v3 += 84;
      a2 >>= 3;
      v5 = v4 & 7;
      if ( v5 )
      {
        v6 = (__int64 *)&v3[12 * v5];
        if ( *(_WORD *)v6 >= 0x8000u )
        {
          LODWORD(v8) = *(_DWORD *)v6;
          v7 = (_DWORD *)v6 + 1;
          HIDWORD(v8) = *v7;
          v9 = v7[1];
          --*(_DWORD *)((char *)&v8 + 2);
          v6 = &v8;
        }
        __ld12mul_0(a1, (int)v6);
      }
    }
  }
}

//----- (1001F502) --------------------------------------------------------
int __cdecl _mbsnbicoll_0(const unsigned __int8 *a1, const unsigned __int8 *a2, size_t a3)
{
  int result; // eax
  int v4; // eax

  if ( !a3 )
    return 0;
  v4 = __crtCompareStringA_0(dword_101C85A4, 1, (unsigned __int8 *)a1, a3, (unsigned __int8 *)a2, a3, dword_101C837C);
  if ( v4 )
    result = v4 - 2;
  else
    result = 0x7FFFFFFF;
  return result;
}
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001F541) --------------------------------------------------------
signed int __cdecl __wtomb_environ_0()
{
  _DWORD *v0; // esi
  int v1; // eax
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx
  int v3; // eax
  char *v4; // eax
  char *v6; // [esp+0h] [ebp-44h]

  v0 = (_DWORD *)dword_101C80A4;
  v1 = *(_DWORD *)dword_101C80A4;
  if ( !*(_DWORD *)dword_101C80A4 )
    return 0;
  v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
  while ( 1 )
  {
    v3 = ((int (__cdecl *)(int, _DWORD, int, int, _DWORD, _DWORD, _DWORD, _DWORD))v2)(1, 0, v1, -1, 0, 0, 0, 0);
    if ( !v3 )
      break;
    v4 = (char *)sub_10019098(v3);
    if ( !v4 )
      break;
    v6 = v4;
    if ( !v2(1, 0, *v0, -1) )
      break;
    __crtsetenv_0(v6, 0);
    v1 = v0[1];
    ++v0;
    if ( !v1 )
      return 0;
  }
  return -1;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C80A4: using guessed type int dword_101C80A4;

//----- (1001F5AF) --------------------------------------------------------
int __cdecl __crtCompareStringA_0(int a1, int a2, unsigned __int8 *a3, int a4, unsigned __int8 *a5, int a6, int a7)
{
  int v7; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 v10; // dl
  unsigned __int8 *i; // eax
  unsigned __int8 v12; // dl
  int v13; // eax
  int v14; // eax
  void *v15; // esp
  int (__cdecl *v16)(int, int, unsigned __int8 *, int, _DWORD, _DWORD); // esi
  int v17; // eax
  int v18; // esi
  int v19; // eax
  void *v20; // esp
  _BYTE v21[36]; // [esp-88h] [ebp-C4h] BYREF
  int v22; // [esp-64h] [ebp-A0h]
  _DWORD v23[5]; // [esp-58h] [ebp-94h] BYREF
  int v24; // [esp-44h] [ebp-80h]
  int v25; // [esp-10h] [ebp-4Ch] BYREF
  unsigned int v26; // [esp+0h] [ebp-3Ch] BYREF
  _BYTE v27[2]; // [esp+6h] [ebp-36h] BYREF
  _BYTE *v28; // [esp+14h] [ebp-28h]
  _DWORD v29[2]; // [esp+18h] [ebp-24h]
  int v30; // [esp+20h] [ebp-1Ch]
  _DWORD v31[5]; // [esp+24h] [ebp-18h]
  int v32; // [esp+38h] [ebp-4h]

  v32 = -1;
  v31[4] = &unk_10022100;
  v31[3] = &unknown_libname_67;
  v31[2] = __readfsdword(0);
  v31[0] = &v25;
  if ( !dword_101C8378 )
  {
    if ( FIX_DLL_KERNEL32_dll_CompareStringW(0, 0, &unk_10021D18, 1, &unk_10021D18, 1) )
    {
      dword_101C8378 = 1;
    }
    else
    {
      if ( !FIX_DLL_KERNEL32_dll_CompareStringA(0, 0, &unk_10021D14, 1, &unk_10021D14, 1) )
        return 0;
      dword_101C8378 = 2;
    }
  }
  v7 = a4;
  if ( a4 > 0 )
    v7 = (int)sub_1001F82C((int)a3, a4);
  if ( a6 > 0 )
    a6 = (int)sub_1001F82C((int)a5, a6);
  if ( dword_101C8378 == 2 )
    return FIX_DLL_KERNEL32_dll_CompareStringA(a1, a2, a3, v7, a5, a6);
  if ( dword_101C8378 == 1 )
  {
    if ( !a7 )
      a7 = dword_101C8124;
    if ( !v7 || !a6 )
    {
      if ( v7 == a6 )
        return 2;
      if ( a6 > 1 )
        return 1;
      if ( v7 > 1 )
      {
LABEL_31:
        v23[3] = 3;
        return v24;
      }
      if ( !FIX_DLL_KERNEL32_dll_GetCPInfo(a7, &v26) )
        return 0;
      if ( v7 > 0 )
      {
        if ( v26 >= 2 )
        {
          v9 = v27;
          if ( v27[0] )
          {
            while ( 1 )
            {
              v10 = v9[1];
              if ( !v10 )
                break;
              if ( *a3 >= *v9 && *a3 <= v10 )
                return 2;
              v9 += 2;
              if ( !*v9 )
                goto LABEL_31;
            }
          }
        }
        goto LABEL_31;
      }
      if ( a6 > 0 )
      {
        if ( v26 >= 2 )
        {
          for ( i = v27; *i; i += 2 )
          {
            v12 = i[1];
            if ( !v12 )
              break;
            if ( *a5 >= *i && *a5 <= v12 )
              return 2;
          }
        }
        return 1;
      }
    }
    v13 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 9, a3, v7, 0, 0);
    v30 = v13;
    if ( v13 )
    {
      v14 = 2 * v13 + 3;
      LOBYTE(v14) = v14 & 0xFC;
      v15 = alloca(v14);
      v31[0] = v23;
      v29[0] = v23;
      v32 = -1;
      if ( v23 )
      {
        v22 = v7;
        v16 = (int (__cdecl *)(int, int, unsigned __int8 *, int, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_MultiByteToWideChar;
        if ( FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 1, a3, v22, v29[0], v30) )
        {
          v17 = v16(a7, 9, a5, a6, 0, 0);
          v18 = v17;
          v29[1] = v17;
          if ( v17 )
          {
            v19 = 2 * v17 + 3;
            LOBYTE(v19) = v19 & 0xFC;
            v20 = alloca(v19);
            v31[0] = v21;
            v28 = v21;
            v32 = -1;
            if ( v21 )
            {
              if ( FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 1, a5, a6, v21, v18) )
                return FIX_DLL_KERNEL32_dll_CompareStringW(a1, a2, v29[0], v30, v21, v18);
            }
          }
        }
      }
    }
  }
  return 0;
}
// 100210D0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210D4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210E4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8378: using guessed type int dword_101C8378;

//----- (1001F82C) --------------------------------------------------------
_BYTE *__cdecl sub_1001F82C(int a1, int a2)
{
  _BYTE *v2; // eax
  int v3; // ecx
  _BYTE *result; // eax

  v2 = (_BYTE *)a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = (_BYTE *)a2;
  else
    result = &v2[-a1];
  return result;
}

//----- (1001F857) --------------------------------------------------------
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int a2)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // esi
  _DWORD *v4; // eax
  bool v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  size_t v14; // eax
  char *v15; // eax
  unsigned int v16; // esi
  unsigned int v17; // [esp-4h] [ebp-18h]
  int v18; // [esp-4h] [ebp-18h]
  unsigned __int8 *v19; // [esp+Ch] [ebp-8h]
  unsigned int v20; // [esp+10h] [ebp-4h]

  if ( !lpMultiByteStr )
    return -1;
  v2 = _mbschr_0((const unsigned __int8 *)lpMultiByteStr, 0x3Du);
  v3 = v2;
  v19 = v2;
  if ( !v2 || lpMultiByteStr == (char *)v2 )
    return -1;
  v4 = (_DWORD *)dword_101C809C;
  v5 = v3[1] == 0;
  if ( dword_101C809C == dword_101C80A0 )
  {
    v4 = copy_environ_0((const char *)dword_101C809C);
    dword_101C809C = (int)v4;
  }
  if ( !v4 )
  {
    if ( a2 && dword_101C80A4 )
    {
      if ( __wtomb_environ_0() )
        return -1;
    }
    else
    {
      if ( v5 )
        return 0;
      v7 = sub_10019098(4);
      dword_101C809C = (int)v7;
      if ( !v7 )
        return -1;
      *v7 = 0;
      if ( !dword_101C80A4 )
      {
        v8 = sub_10019098(4);
        dword_101C80A4 = (int)v8;
        if ( !v8 )
          return -1;
        *v8 = 0;
      }
    }
  }
  v9 = (_DWORD *)dword_101C809C;
  v20 = dword_101C809C;
  v10 = findenv_0((unsigned __int8 *)lpMultiByteStr, v3 - (unsigned __int8 *)lpMultiByteStr);
  v11 = v10;
  if ( v10 >= 0 && *v9 )
  {
    if ( !v5 )
    {
      v9[v10] = lpMultiByteStr;
      goto LABEL_31;
    }
    v17 = v9[v10];
    v12 = &v9[v10];
    sub_100189EC(v17);
    while ( *v12 )
    {
      ++v11;
      *v12 = v12[1];
      ++v12;
    }
    v13 = sub_10018D97(v20, 4 * v11);
    if ( !v13 )
    {
LABEL_31:
      if ( a2 )
      {
        v14 = strlen(lpMultiByteStr);
        v15 = (char *)sub_10019098(v14 + 2);
        v16 = (unsigned int)v15;
        if ( v15 )
        {
          strcpy(v15, lpMultiByteStr);
          v19[v16 - (_DWORD)lpMultiByteStr] = 0;
          FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA(v18);
          sub_100189EC(v16);
        }
      }
      return 0;
    }
LABEL_30:
    dword_101C809C = (int)v13;
    goto LABEL_31;
  }
  if ( !v5 )
  {
    if ( v10 < 0 )
      v11 = -v10;
    v13 = sub_10018D97((unsigned int)v9, 4 * v11 + 8);
    if ( !v13 )
      return -1;
    v13[v11] = lpMultiByteStr;
    v13[v11 + 1] = 0;
    goto LABEL_30;
  }
  return 0;
}
// 1001F9CA: variable 'v18' is possibly undefined
// 100210FC: using guessed type int (__thiscall *FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA)(_DWORD);
// 101C809C: using guessed type int dword_101C809C;
// 101C80A0: using guessed type int dword_101C80A0;
// 101C80A4: using guessed type int dword_101C80A4;

//----- (1001F9DE) --------------------------------------------------------
int __cdecl findenv_0(unsigned __int8 *a1, size_t a2)
{
  _DWORD *v2; // esi
  const unsigned __int8 *v3; // eax
  char v4; // al

  v2 = (_DWORD *)dword_101C809C;
  v3 = *(const unsigned __int8 **)dword_101C809C;
  if ( !*(_DWORD *)dword_101C809C )
    return -(((int)v2 - dword_101C809C) >> 2);
  while ( 1 )
  {
    if ( !_mbsnbicoll_0(a1, v3, a2) )
    {
      v4 = *(_BYTE *)(*v2 + a2);
      if ( v4 == 61 || !v4 )
        break;
    }
    v3 = (const unsigned __int8 *)v2[1];
    ++v2;
    if ( !v3 )
      return -(((int)v2 - dword_101C809C) >> 2);
  }
  return ((int)v2 - dword_101C809C) >> 2;
}
// 101C809C: using guessed type int dword_101C809C;

//----- (1001FA36) --------------------------------------------------------
_DWORD *__cdecl copy_environ_0(const char *a1)
{
  int v1; // ecx
  const char *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  _DWORD *v6; // ebp
  const char *v7; // eax
  const char *v8; // ebx

  v1 = 0;
  if ( !a1 )
    return 0;
  v3 = a1 + 4;
  if ( *(_DWORD *)a1 )
  {
    do
    {
      v4 = *(_DWORD *)v3;
      ++v1;
      v3 += 4;
    }
    while ( v4 );
  }
  v5 = sub_10019098(4 * v1 + 4);
  v6 = v5;
  if ( !v5 )
    _amsg_exit_0(9);
  v7 = *(const char **)a1;
  v8 = a1;
  while ( v7 )
  {
    v8 += 4;
    *v5 = _strdup_0(v7);
    v7 = *(const char **)v8;
    ++v5;
  }
  *v5 = 0;
  return v6;
}

//----- (1001FA9D) --------------------------------------------------------
unsigned __int8 *__cdecl _mbschr_0(const unsigned __int8 *a1, unsigned int a2)
{
  const unsigned __int8 *i; // ecx
  unsigned __int16 v4; // ax
  unsigned __int8 v5; // dl

  if ( !dword_101C838C )
    return (unsigned __int8 *)strchr_0((const char *)a1, a2);
  for ( i = a1; ; ++i )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( (byte_101C84A1[(unsigned __int8)v4] & 4) != 0 )
    {
      v5 = *++i;
      if ( !v5 )
        return 0;
      if ( a2 == (v5 | (v4 << 8)) )
        return (unsigned __int8 *)(i - 1);
    }
    else if ( a2 == *i )
    {
      return (unsigned __int8 *)(*i == a2 ? i : 0);
    }
  }
  return (unsigned __int8 *)(*i == a2 ? i : 0);
}
// 101C838C: using guessed type int dword_101C838C;

//----- (1001FB10) --------------------------------------------------------
char *__cdecl _strdup_0(const char *a1)
{
  size_t v1; // eax
  char *v2; // eax
  char *result; // eax

  if ( a1 && (v1 = strlen(a1), (v2 = (char *)sub_10019098(v1 + 1)) != 0) )
    result = strcpy(v2, a1);
  else
    result = 0;
  return result;
}

//----- (1001FC60) --------------------------------------------------------
unsigned int __cdecl _memicmp_0(const void *a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // ebx
  int v11; // [esp-8h] [ebp-14h]
  unsigned int v12; // [esp-4h] [ebp-10h]

  v3 = a3;
  if ( a3 )
  {
    if ( *((_DWORD *)&unk_101C810C + 2) )
    {
      v8 = 0;
      v9 = 0;
      while ( 1 )
      {
        LOBYTE(v8) = *(_BYTE *)a1;
        a1 = (char *)a1 + 1;
        LOBYTE(v9) = *(_BYTE *)a2;
        a2 = (char *)a2 + 1;
        if ( (_BYTE)v8 != (_BYTE)v9 )
        {
          v12 = v3;
          v11 = v8;
          v9 = tolower_0(v9);
          v8 = tolower_0(v11);
          v3 = v12;
          if ( (_BYTE)v8 != (_BYTE)v9 )
            break;
        }
        if ( !--v3 )
          return v3;
      }
      v3 = -1;
      if ( (unsigned __int8)v8 >= (unsigned __int8)v9 )
        v3 = 1;
    }
    else
    {
      while ( 1 )
      {
        v6 = *(_BYTE *)a1;
        a1 = (char *)a1 + 1;
        v7 = *(_BYTE *)a2;
        a2 = (char *)a2 + 1;
        if ( v6 != v7 )
        {
          if ( v6 >= 0x41u && v6 <= 0x5Au )
            v6 += 32;
          if ( v7 >= 0x41u && v7 <= 0x5Au )
            v7 += 32;
          if ( v6 != v7 )
            break;
        }
        if ( !--v3 )
          return v3;
      }
      v3 = -1;
      if ( v6 >= v7 )
        v3 = 1;
    }
  }
  return v3;
}

//----- (1001FD98) --------------------------------------------------------
int __usercall SEH_10001240@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022160, a1, a2, a3, a4, a5, a6);
}

//----- (1001FE28) --------------------------------------------------------
int __usercall SEH_10005140@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022388, a1, a2, a3, a4, a5, a6);
}

//----- (1001FE48) --------------------------------------------------------
int __usercall SEH_100052C0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_100223B0, a1, a2, a3, a4, a5, a6);
}

//----- (1001FE68) --------------------------------------------------------
int __usercall SEH_10005700@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_100223D8, a1, a2, a3, a4, a5, a6);
}

//----- (1001FE93) --------------------------------------------------------
int __usercall SEH_10006DF0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022400, a1, a2, a3, a4, a5, a6);
}

//----- (1001FEBB) --------------------------------------------------------
int __usercall SEH_10006FB0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022430, a1, a2, a3, a4, a5, a6);
}

//----- (1001FED0) --------------------------------------------------------
int __usercall SEH_10008190@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022468, a1, a2, a3, a4, a5, a6);
}

//----- (1001FEEE) --------------------------------------------------------
int __usercall SEH_1000A370@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_100224C0, a1, a2, a3, a4, a5, a6);
}

//----- (1001FF28) --------------------------------------------------------
int __usercall SEH_1000C480@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022510, a1, a2, a3, a4, a5, a6);
}

//----- (1001FF58) --------------------------------------------------------
int __usercall SEH_1000D170@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022570, a1, a2, a3, a4, a5, a6);
}

//----- (1001FF7E) --------------------------------------------------------
int __usercall SEH_1000D680@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_100225E0, a1, a2, a3, a4, a5, a6);
}

//----- (1001FFC4) --------------------------------------------------------
int __usercall SEH_1000D8A0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022608, a1, a2, a3, a4, a5, a6);
}

//----- (10020008) --------------------------------------------------------
int __usercall SEH_100125F0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_10022670, a1, a2, a3, a4, a5, a6);
}

//----- (10020028) --------------------------------------------------------
int __usercall sub_10020028@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6)
{
  return __CxxFrameHandler_0((int)&unk_100226D0, a1, a2, a3, a4, a5, a6);
}

// nfuncs=991 queued=611 decompiled=611 lumina nreq=0 worse=0 better=0
#error "There were 22 decompilation failure(s) on 611 function(s)"
