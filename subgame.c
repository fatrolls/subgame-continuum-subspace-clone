/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

struct_ARENA *__thiscall ServerEntryPoint(struct_ARENA *this, const char *Source);
void __thiscall ShutdownArena(struct ARENA *arenaa);
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team);
void __thiscall PlayerEntering(struct ARENA *arena, struct PLAYER *player);
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player);
bool __thiscall ProcessArena(struct ARENA *arenaa);
int __cdecl PtFuncCompare(int a1, int a2);
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset);
void __thiscall CreateSoccerBall(struct ARENA *arenaa, int PowerBallId);
void __thiscall FlagPositionUpdateSomething(struct ARENA *arenaa, int a2);
void __thiscall CarryFlagsSomething(struct_ARENA *arenaa, int PlayerId, int FlagMode);
void __thiscall ResetFlagGame(struct ARENA *arenaa);
int __thiscall GetNextFrequencyToJoin(struct_ARENA *arena);
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4);
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius);
void __thiscall sub_404980(struct_ARENA *this, struct_PLAYER *a2, __int64 a3);
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4);
void __thiscall LoadArenaSettings(struct ARENA *arenaa);
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this);
int __thiscall GetDeathPrizeGreenId(struct_ARENA *arena);
signed int __thiscall ChangeSettings(struct_ARENA *arenaa, struct_PLAYER *player, const CHAR *a3);
int __thiscall sub_405360(struct_ARENA *this, int buf);
int __thiscall SoccerGameSomething(struct_ARENA *this, int a2);
int __thiscall SoccerGame2(struct_ARENA *arena, int Frequency, int a3, int a4);
void __thiscall GetScore(struct_ARENA *arenaa, struct_PLAYER *player);
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena); // idb
int __thiscall GetTotalPlayingPlayers(struct_ARENA *arena);
void __thiscall SendBillerServerConnectPacket(struct BILLING_SERVER_STRUCT *billingStruct, int HandleBillerPacketFuncAddress, const char *ServerName, int ServerId, int GroupId, int ScoreId, const char *Password, int mainServerStructure, struct CONNECTION *encryption);
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct); // idb
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3);
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText);
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage);
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand);
void __thiscall SendBillerUserLoginPacket(BILLING_SERVER_STRUCT *billingServerStruct, const char *Username, const char *Password, int IPAddress, int MachineId, int Timezone, char IsNewUser, int PlayerId, char Unused0, char isSysop);
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize);
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size);
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len);
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len);
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int a2, int a3, int a4, int len);
int __thiscall GetBillingLastReconnectTime(int this);
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct); // idb
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename); // idb
void __thiscall WriteCfgFile(struct struc_2 *struc2);
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4);
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count);
char *__thiscall sub_4066B0(int this, const char *Str2, const char *a3, const char *Source, char *Dest, size_t Count);
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source);
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source);
void __thiscall sub_406B30(const char *Filename);
int __thiscall sub_406BE0(int this);
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer);
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize);
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key);
bool __cdecl LoadBMPHeader2(const char *Filename);
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll);
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile);
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2);
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile);
int __thiscall ListMachine(int this);
int __thiscall ListMachineByIndex(int this, int listMachineIndex); // idb
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer);
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number);
int __thiscall IsBannedMachineId(struct TEXT_FILE_STRUCT *textFile, char *MachineId);
int __cdecl StrCmpiWrapper(char *Str1, const char **a2);
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src);
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int);
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer);
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName);
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
void __cdecl config_read_helper_3(char *a1);
signed int __cdecl CRC32(char *buffer, int fileSize);
FILE *__cdecl RewriteSameFile(int unused, const char *Filename); // idb
int nullsub_3(void); // weak
void *__cdecl emalloc(int bytes);
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3);
void __stdcall efree(LPVOID ptr);
void __thiscall ConnectSocket(SOCKET *Socket, const char *Hostname, u_short ConnectPort, u_short ListenPort);
int __thiscall sub_408740(SOCKET *this);
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3);
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed); // idb
SOCKET_STRUCT2 *__thiscall ListenOnPort(SOCKET_STRUCT2 *socket, __int16 Port, int callback);
void __thiscall ProcessZonePings(int Socket, int ZonePopulation);
struct_PLAYER *__thiscall CreateNewPlayer(struct_PLAYER *player, struct in_addr in, __int16 a3, NetData *nd);
void __thiscall DisconnectUser(struct_PLAYER *player);
void __thiscall PlayerHandleGamePacket(struct PLAYER *playerr, unsigned __int8 *packet, int packetSize);
void __thiscall GenerateWarning(struct PLAYER *player, int a2);
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr);
signed int __thiscall sub_40CF10(struct_PLAYER *playerr);
void __thiscall sub_40D870(struct_PLAYER *this);
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency);
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship);
void __thiscall sub_40DEA0(struct_PLAYER *this, const void *buf, unsigned int len, int a4);
void __thiscall SendPlayerReliablePacket(struct PLAYER *playerr, const void *buf, unsigned int len, int a4);
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6);
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4);
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend);
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6);
struct_ARENA *__thiscall sub_40E220(struct_PLAYER *playerr, const void *buf, unsigned int len, int a4, int a5, int a6);
int __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, struct_ARENA *a6);
struct_ARENA *__thiscall sub_40E300(void *this, struct_ARENA *PlayerIndex, const void *buf, unsigned int len, int a4, int a6, int a7);
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte);
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2);
void __thiscall SendArenaMessagePlayer(struct_PLAYER *playerr, const char *ChatMessage, char SoundByte);
void __thiscall SendFile(struct_PLAYER *this, char *filename);
struct_ARENA *__thiscall ArenaHandler(int this, int ArenaIndex, const char *ArenaName); // idb
void __thiscall SendWeaponPacket(struct PLAYER *playerr);
void __thiscall SendResetScoresPacket(PLAYER *player);
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player);
bool __thiscall SendPlayerScoreUpdateAll(struct PLAYER *playerr);
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2);
void __cdecl LoadZoneCFGSettings(ARENA_SETTINGS *arenaSettings, SERVERSIDE_ARENA_SETTINGS *a2, const char *a3);
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3);
int __cdecl main(int argc, const char **argv, const char **envp);
signed int __cdecl ServerInitialize();
signed int __cdecl NewConnectionRequest(int addr_in, __int16 Port, int a3); // idb
void __cdecl PlayerHandleGamePacketWrapperSomething(int packet, int packetSize, int a3);
void __cdecl ServerMainLoop();
signed int __cdecl IncreaseRadarValueShowHomeOverFourThousand();
void __cdecl ServerUninitialize();
// void __usercall HandleBillerPacket(struct_ARENA **a1@<edi>, char *buffer, int a2);
void FormatMessageArena(ARENA *arena, const char *Format, ...);
void WriteSubGameLog(const char *Format, ...);
bool __cdecl IsOffensiveName(char *a1);
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2); // idb
void __cdecl SendBillerWarnings(const char *a1, struct PLAYER *player);
// void __usercall ChatProcessor(struct_ARENA **a1@<edi>, struct_PLAYER *player, int a3, signed int arenaPlayerIndex, char *ChatText, char SoundByte);
void __cdecl SomethingWithSendingChatTypes(struct PLAYER *player, int TargetPlayerId, signed int PlayerId, char *ChatText, char SoundByte);
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3);
void __cdecl ReadServerINI();
void __cdecl LoadTemplateSSS();
int __cdecl LoadMapSomething();
void __cdecl LoadAdvertisements();
void __cdecl CleanUpMemory();
int __cdecl LoadWinsock();
int __stdcall j_WSACleanup();
void __thiscall StartServerListener(struct PACKET_ATTACHMENT *packetAttachment, int a2, int a3, int MaxConnections, int ServerListenPort, int OutgoingBufferSize, int IncomingBufferSize, int PacketHistoryMax);
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment);
int __thiscall sub_41A910(int this, int a2);
Encryption_Struct *__thiscall SomethingBillerServer(struct_v9 *this, struct_v9 *name, const char *hostshort, u_short EncryptionRNGSeed, signed int a5, int retstr);
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename);
Packet *__thiscall PlayerReadPackets(struct_v9 *this, int lpdwBytesRead, int a3, int a4);
signed int __thiscall PlayerDoNetworkOps(struct_v9 *this);
void __thiscall PlayerHandlePacket(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, signed int Size, int a5, __int16 a6);
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5);
int __thiscall sub_41B1B0(int this, int a2, int a3);
int __thiscall sub_41B3D0(int this);
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls);
signed int __thiscall sub_41B430(struct_v9 *this, signed int CommsTransportBufferSize); // idb
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment);
signed int __stdcall sub_41B570(int a1);
int __cdecl DifferentCompareFunction(_DWORD connection, int ConnectionsArray);
void __thiscall InitializeEncryption(struct CONNECTION *encryption, struct PACKET_ATTACHMENT *packetAttachment, int a3, int a4, int a5, __int16 a6, signed int ServerKey, int a8, int a9);
void *__thiscall sub_41B7A0(int this);
int __thiscall CheckIfBillingServerIsConnected(int this);
int __thiscall sub_41B960(int this);
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2);
void __thiscall WriteToNetwork(struct CONNECTION *encryption, const char *buf, unsigned int len);
void __thiscall ProcessCorePackets(struct CONNECTION *encryption, char *buffer, int size, int a5);
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection);
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4);
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename);
void __thiscall GetNewsRequest(struct CONNECTION *encryption, char *MemoryPointer, int a3, int a4);
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4);
int __thiscall sub_41C9B0(int this, int a2, int a3);
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart);
int __thiscall sub_41CA10(int this);
void __thiscall SendPacketCluster(struct CONNECTION *encryptionn, const void *buf, unsigned int len);
void __thiscall sub_41CB20(int this);
int __thiscall sub_41CB70(int this, int a2, int a3);
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5);
void __thiscall sub_41CBD0(int this);
char *__cdecl GetIPAddressString(struct in_addr in);
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename);
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize);
// int __cdecl compress(_DWORD, _DWORD, _DWORD, _DWORD);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// struct hostent *__stdcall gethostbyname(const char *name);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// u_long __stdcall htonl(u_long hostlong);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall closesocket(SOCKET s);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen);
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// char *__stdcall inet_ntoa(struct in_addr in);
int __cdecl setRNGSeed(int seedValue); // idb
// int __cdecl rand();
// int printf(const char *Format, ...);
// _DWORD __cdecl time(_DWORD Time); weak
// int sprintf(char *Dest, const char *Format, ...);
// char *__cdecl strrchr(const char *Str, int Ch);
// int __cdecl fclose(FILE *File);
// size_t __cdecl fread(void *DstBuf, size_t ElementSize, size_t Count, FILE *File);
// FILE *__cdecl fopen(const char *Filename, const char *Mode);
// char *__cdecl strncpy(char *Dest, const char *Source, size_t Count);
// size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File);
// void __usercall _alloca_probe(unsigned int a1@<eax>, char a2);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// int __cdecl loc_41D5DC(int Dst, int Src, int Size); weak
// int __cdecl loc_41D6D8(int Dst, int Src, int Size); weak
// int __cdecl loc_41D764(int Dst, int Src, int Size); weak
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// void __cdecl operator delete(void *Memory);
// void *__cdecl operator new(unsigned int); idb
// int __stdcall _JumpToContinuation(int (__stdcall *a1)(void *, struct EHRegistrationNode *), struct EHRegistrationNode *a2);
// int __cdecl sub_41DB60();
// PEXCEPTION_RECORD __userpurge _UnwindNestedFrames@<eax>(int a1@<eax>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
// int __stdcall _ReturnPoint_16567(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); weak
// int __usercall __CxxFrameHandler@<eax>(struct _s_FuncInfo *a1@<eax>, struct EHExceptionRecord *ExceptionRecord, struct EHRegistrationNode *a3, int a4, int a5);
// int __cdecl _CallCatchBlock2(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, void *a3, int a4, unsigned __int32 a5);
// _DWORD __cdecl _local_unwind2(_DWORD);
// int __cdecl _abnormal_termination();
// _DWORD __stdcall _NLG_Notify(_DWORD); weak
// int __cdecl atoi(const char *Str);
// int __cdecl isalpha(int C);
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
// char *__cdecl fgets(char *Buf, int MaxCount, FILE *File);
// int fprintf(FILE *File, const char *Format, ...);
// int __cdecl fseek(FILE *File, __int32 Offset, int Origin);
// _DWORD __cdecl _chsize(_DWORD, _DWORD); weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl toupper(int C);
// int _cinit(void); weak
// void __cdecl exit(int Code);
// void __cdecl _exit(int Code);
// int __cdecl doexit(UINT uExitCode, int, int); idb
// _DWORD __cdecl _initterm(_DWORD, _DWORD); weak
// void *__cdecl malloc(size_t Size);
// void *__cdecl realloc(void *Memory, size_t NewSize);
// void __cdecl free(void *Memory);
// void __stdcall _CxxThrowException(int a1, int a2);
char *__cdecl sub_41E940(int a1);
// int __cdecl _spawnlp(int, char *Str, int); idb
// clock_t __cdecl clock();
int __cdecl CurrentTimeInMilliseconds();
// int __cdecl fflush(FILE *File);
// int __cdecl vsprintf(char *Dest, const char *Format, va_list Args);
// char *__cdecl asctime(const struct tm *Tm);
// struct tm *__cdecl localtime(const time_t *Time);
// double __cdecl difftime(_DWORD Time1, _DWORD);
// char *__cdecl strchr(const char *Str, int Val);
// _DWORD __cdecl _filelength(_DWORD); weak
// void __usercall start(int a1@<eax>);
// _DWORD __cdecl _amsg_exit(_DWORD); weak
// int __cdecl __InternalCxxFrameHandler(struct EHExceptionRecord *ExceptionRecord, struct EHRegistrationNode *, int, int, struct _s_FuncInfo *, int, PVOID TargetFrame, char); idb
// void __usercall CallCatchBlock(int a1@<eax>, int ebx0@<ebx>, int edi0@<edi>, int esi0@<esi>, void *a2, struct EHRegistrationNode *a3, int a4, const struct _s_FuncInfo *a5, void *a6, int a7, unsigned __int32 a8);
// void __usercall loc_421101(int a1@<ebp>);
// int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *); idb
// void __cdecl _DestructExceptionObject(struct EHExceptionRecord *, unsigned __int8); idb
// _DWORD __stdcall unknown_libname_15(_DWORD, _DWORD, _DWORD); weak
void __noreturn sub_4214B0();
void __cdecl j__abort();
void __noreturn sub_421540();
int loc_42157F(); // weak
// int _ioinit(void); weak
// int __cdecl _heap_init(_DWORD, _DWORD, _DWORD); weak
// int __cdecl _spawnvpe(int a1, void *Str, int a3, LPVOID lpEnvironment);
// int __cdecl _spawnve(int, void *Str, int, LPVOID lpEnvironment); idb
// int __cdecl _access(LPCSTR lpFileName, char); idb
// char *__cdecl getenv(const char *VarName);
// _DWORD __cdecl _ftime(_DWORD); weak
BOOL __cdecl DateFunction(int a1);
// _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _XcptFilter(int, struct _EXCEPTION_POINTERS *ExceptionInfo); idb
// int _setenvp(void); weak
// int _setargv(void); weak
// int __crtGetEnvironmentStringsA(void); weak
// int __initmbctable(void); weak
// int __cdecl unknown_libname_18(int, PVOID TargetFrame, int); idb
// void __cdecl abort();
// int __cdecl _mbsrchr(char *Str, int); idb
// _DWORD __cdecl _getpath(_DWORD, _DWORD, _DWORD); weak
// int __cdecl _mbschr(char *Str, int Val); idb
// int __cdecl tolower(int C);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_426670(int a1, int a2);
int __cdecl sub_426690(int a1, int a2);
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String);
int __cdecl sub_4266F0(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// int __cdecl _fileno(FILE *File);
// int __cdecl _strcmpi(const char *Str1, const char *Str2);
// char *__cdecl _strupr(char *String);
int __cdecl getch();
int __cdecl console_input_wrapper();
// _DWORD __cdecl _getextendedkeycode(_DWORD); weak
// int __cdecl _memicmp(const void *Buf1, const void *Buf2, size_t Size);
// int __initconin(void); weak
// void __usercall DeleteOperatorSomething20(int a1@<ebp>);
int sub_42A0CB(); // weak
int qword_42A0F3(); // weak
int unk_42A18F(); // weak
int xmmword_42A1DF(); // weak
// int __stdcall GetObjectA(HGDIOBJ, int, LPVOID);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
// DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);
// BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
// BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// HANDLE __stdcall LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unknown_libname_26; // weak
_UNKNOWN unk_429008; // weak
char algn_429750[2224] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // weak
_UNKNOWN sub_42A03F; // weak
_UNKNOWN unk_42A06B; // weak
const char aO[] = "O";
char aLastusedstamp[14] = { 'L', 'a', 's', 't', 'U', 's', 'e', 'd', 'S', 't', 'a', 'm', 'p', '\0' };
_UNKNOWN unk_42A0A3; // weak
char aSS_cfg[11] = { '%', 's', '\\', '%', 's', '.', 'c', 'f', 'g', '\0', '\0' };
const char aW[] = "w"; // idb
char aPlayerEntering[] = { 'P' }; // idb
char aName[] = { 'N' }; // idb
char aUserid[] = "U"; // idb
char aSoccerGameOver[18] =
{
  'S',
  'o',
  'c',
  'c',
  'e',
  'r',
  ' ',
  'g',
  'a',
  'm',
  'e',
  ' ',
  'o',
  'v',
  'e',
  'r',
  '.',
  '\0'
};
const char aNotice1MinuteR[] = "N"; // idb
char aNoticeGameOver[] = { 'N', 'O' }; // idb
char shipsArray[] =
{
  'S',
  'h',
  'a',
  'r',
  'k',
  '\0',
  '\0',
  '\0',
  'L',
  'a',
  'n',
  'c',
  'a',
  's',
  't',
  'e',
  'r',
  '\0',
  '\0',
  '\0',
  'T',
  'e',
  'r',
  'r',
  'i',
  'e',
  'r',
  '\0',
  'W',
  'e',
  'a',
  's',
  'e',
  'l',
  '\0',
  '\0',
  'L',
  'e',
  'v',
  'i',
  'a',
  't',
  'h',
  'a',
  'n',
  '\0',
  '\0',
  '\0',
  'S',
  'p',
  'i',
  'd',
  'e',
  'r',
  '\0',
  '\0',
  'J',
  'a',
  'v',
  'e',
  'l',
  'i',
  'n',
  '\0',
  'W',
  'a',
  'r',
  'b',
  'i',
  'r',
  'd',
  '\0'
}; // idb
int dword_42A534 = 1; // weak
int dword_42C840 = 1; // weak
char *off_42C848[8] =
{
  (char *)0x42A3B0,
  (char *)0x42A3A8,
  (char *)0x42A3A0,
  (char *)0x42A394,
  (char *)0x42A38C,
  (char *)0x42A384,
  (char *)0x42A378,
  &shipsArray
}; // weak
int RNGSeed = 1; // weak
FILE File = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
int (__cdecl *off_42E734)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_4214B0; // weak
int dword_43099C = 1; // weak
int dword_430A30 = -1; // weak
int dword_430A34 = 0; // weak
int dword_430A38 = 0; // weak
int dword_430A40 = -1; // weak
int dword_430A44 = 0; // weak
int dword_430A48 = 0; // weak
_UNKNOWN unk_430E60; // weak
_UNKNOWN unk_430E78; // weak
int dword_431490 = -1; // weak
HANDLE hConsoleInput = (HANDLE)0xFFFFFFFE; // idb
char *DirectoryNamePassword = NULL;
UINT AdvertiseSendMode = 0u;
char DirectoryIPAddresses[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
};
char FileName2[256];
char *dword_4317B8; // idb
unsigned int dword_4317BC[255]; // idb
int LastTimeServerINIWasEdited;
int dword_431BC0[8]; // weak
UINT MiscDisableSharewareShips;
u_short DirectoryPort;
int RadarValue; // weak
char *buf; // idb
unsigned int len[255]; // idb
struct BILLING_SERVER_STRUCT *BillingConnectionStructPointer; // idb
int ArenaArrayLength; // weak
int ServerIterations; // weak
UINT ArenaMinimumPlayers;
int LastTimeMasterCFGWasEdited; // weak
int bRecycleServer; // weak
Chat_Struct ChatRelatedArray[64];
struct_v9 *Structv9Pointer;
LPVOID dword_437B0C; // idb
UINT ArenaSpawnKeepScores;
UINT dword_437B14;
char FileName[];
int DoubleValue; // weak
UINT BillingAttemptTime;
char buffer[];
UINT CommsMaxQueueToLogin;
UINT logLine;
int bServerIsRunning; // weak
char *dword_437CB0; // idb
unsigned int dword_437CB4[255]; // idb
UINT ArenaMaxPlayers;
UINT CommsPacketHistoryMax;
char SuperModeratorPassword[];
char ModeratorPassword[];
UINT MiscMaxSharewarePlayers;
ARENA_SETTINGS ArenaSettings; // idb
int MachineIdArrayIndex; // weak
char BillingPassword[];
int CRC_32; // idb
int SomeArrayOf256_1[256];
u_short BillingPort;
LPVOID ptr; // idb
UINT MiscLogPoints;
LPCSTR ObscenePointer; // idb
int ScreenValue; // weak
UINT CPUSlowIterationWarningLevel;
UINT MaxArenasMemory;
UINT PermissionMode;
UINT CommsEncryptMode;
LPCSTR ModeratePointer; // idb
char VIPPassword[];
LPCSTR PermitPointer; // idb
struct BMP_FILE_STRUCT *BMPFile; // idb
UINT MiscMaxPlayers;
UINT BillingReconnectTime;
UINT PermissionMinimumSecondsToLogin;
TemplateSSS_Struct TotalTemplateSSSList[1400];
char EnergyPassword[];
UINT PermissionMaxPoints;
struct CONNECTION *BillingServerConnection; // idb
UINT BillingGroupId;
UINT BillingServerId;
KickStruct KickedUsers[1000];
UINT MiscKeepAliveDelay;
UINT AutoPermissionPoints;
char SysopPassword[];
UINT CPUSleepTime;
int SomeArrayOf256_2[256];
char DirectoryDescription[250];
struct_v9 BillingIP;
UINT dword_4C8F38;
int dword_4C8F3C; // weak
struct_PLAYER *playerPointerList[1025];
UINT CPUSleepPerIteration;
char MiscDefaultLevelFile[];
SERVERSIDE_ARENA_SETTINGS ServersideArenaSettings; // idb
char PermissionAutoPermissionMessage[];
int ServerListenPort;
UINT MiscPointUpdateDiff;
char PermissionAutoPermissionIDList[];
UINT BillingLogMessages;
UINT IncreasesRadarValueSomeHow;
GlobalArray_Strct SecurityArray[10];
UINT CustomArenaMode;
struct_PLAYER *PlayerList[1025];
UINT MiscServerLog;
UINT dword_4D55D0;
UINT MiscMaxSharkwareTime;
UINT MiscMenuKickOutDelay;
LPCSTR ReservedPointer; // idb
struct_ARENA *Arenas[200];
UINT PermissionAllowLowBandwidth;
UINT CPUProcessMaxTime;
UINT MaxArenas;
UINT MiscJackpotBroadcastPoints;
UINT MiscRegisterKickShareware;
int NewsTxtFileChecksum; // idb
UINT MiscDisableShareware;
UINT CommsIncomingBufferSize;
int dword_4D5920; // weak
int LastTimeNewsTxtWasEdited; // weak
UINT ArenaDesiredPlayers;
char LogArray[12288]; // idb
int dword_4D8930; // weak
UINT BillingScoreId;
LPVOID MapAllocateMemoryPointer; // idb
UINT CommsOutgoingBufferSize;
char BillingServerName[32];
void *Memory; // idb
SOCKET SmallServerStruct; // idb
int Wave; // weak
CHAR ShutdownArguments; // idb
LPCSTR IDBlockPointer; // idb
struct_v9 *ServerStruct;
UINT AdvertiseDisplayMode;
UINT CurrentPlayerCount;
UINT MiscDisableSharewareScores;
int TotalTemplateSSSEntries; // weak
int OutSize; // idb
UINT CommsTransportBufferSize;
int dword_4D8AF0; // idb
int oldTickCountValue; // weak
int HighestPlayerCountMaybeSomething; // weak
UINT dword_4D8AFC;
UINT dword_4D8B00;
UINT dword_4D8B04;
FILE *PointsFileHandle;
FILE *fileHandle; // idb
int dword_4D8B14; // weak
UINT ChatCounter64Max;
int dword_4D8B38; // weak
int dword_4D8B44; // weak
int timebuffer; // weak
int (__cdecl *dword_4D8BDC)(_DWORD, _DWORD, _DWORD, _DWORD); // idb
int dword_4D8C18; // weak
__int16 word_4D8C64; // weak
__int16 word_4D8C66; // weak
int dword_4D8C68; // weak
int dword_4D8C6C; // weak
int dword_4D8C70; // weak
struct _TIME_ZONE_INFORMATION stru_4D8CB8;


//----- (00401000) --------------------------------------------------------
struct_ARENA *__thiscall ServerEntryPoint(struct_ARENA *this, const char *Source)
{
  int v3; // eax
  DWORD (__stdcall *GetTickCountt)(); // esi
  FILE *file1; // eax
  FILE *filee1; // esi
  int v7; // eax
  unsigned int v8; // eax
  void *v9; // eax
  char *findSlash; // eax
  int v11; // eax
  int LastUsedTimeStamp; // eax
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // edi
  DWORD GetTickCounttt; // eax
  __int64 v18; // rax
  int v19; // eax
  int v20; // ecx
  int *v21; // eax
  const char *v23; // [esp+0h] [ebp-130h]
  const char *v24; // [esp+4h] [ebp-12Ch]
  const char *v25; // [esp+8h] [ebp-128h]
  int v26; // [esp+Ch] [ebp-124h]
  char Filename[32]; // [esp+10h] [ebp-120h] BYREF
  char ServerPath[256]; // [esp+30h] [ebp-100h] BYREF

  this->field_1D40A = 0;
  this->field_10026 = 0;
  this->field_FF30 = 0;
  if ( _strcmpi(Source, sub_42A0CB + 1) )
  {
    strncpy(this->ArenaName, Source, 0x20u);
    this->ArenaName[31] = 0;
  }
  else
  {
    strcpy(this->ArenaName, &algn_429750[2420]);
  }
  v3 = CustomArenaMode > 0 && this->ArenaName[0];
  GetTickCountt = GetTickCount;
  this->bHasScrFile = v3;
  this->NumberOfContents18ByteBlocks = 0;
  this->FileContentsMemoryPointer = 0;
  this->LastSaveStatsTime = GetTickCount() / 10;
  this->playerPointersForSomething[250] = 0;
  this->AllMessagesLocked = 0;
  this->AllMessagesLockedAgainSomething = 0;
  this->PrivateMessagesLocked = 0;
  this->SpecMessageLock = 0;
  if ( this->bHasScrFile )
  {
    strcpy(Filename, this->ArenaName);
    strcat(Filename, MEMORY[0x42A0B8]);
    file1 = fopen(
              Filename,
              "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
              "\x00\x00\x00Player spectating game: %s\n"
              "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: "
              "1 minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00"
              "\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00"
              "\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00"
              "Player kicked off for not returning security packet: %s\n"
              "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00"
              "Parameters resent for arena(%s)\n"
              "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parame"
              "ter.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00"
              "\x00Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no po"
              "ints to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:"
              "%d  Javelins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%"
              "d  Spiders:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
              "\x00\x00\x00%s=%s\n"
              "\x00\x00[%s]\n"
              "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
              "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Res"
              "ize)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
              "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked "
              "off, arena full to demo users: %s\n"
              "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
              "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
              "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
              "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
              "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
              "\x00%s>  MODERATOR LOGGED IN\n"
              "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
              "\x00%s> SYSOP LOGGED IN\n"
              "\x00\x00\x00\x00Connection request from: %s\n"
              "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00"
              "File has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00"
              "\x00File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00"
              "\x00\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol at"
              "tempting to enter game");
    filee1 = file1;
    if ( file1 )
    {
      v7 = _fileno(file1);
      v8 = _filelength(v7);
      this->NumberOfContents18ByteBlocks = v8 / 18;
      v9 = ExpandMemory(0, 18 * (v8 / 18), 1);  // Expand by blocks of 18 only
      this->FileContentsMemoryPointer = v9;
      fread(v9, 18u, this->NumberOfContents18ByteBlocks, filee1);
      fclose(filee1);
    }
    GetTickCountt = GetTickCount;
  }
  memset(this, 0, 64256u);                      // Set's Arena's Memory Big Chunk
  GetModuleFileNameA(0, ServerPath, 0x100u);
  findSlash = strrchr(ServerPath, '\\');
  if ( findSlash )
    *findSlash = 0;
  else
    ServerPath[0] = 0;
  if ( this->bHasScrFile )
  {
    sprintf(
      this->szConfigFile,
      aSS_cfg,
      ServerPath,
      this->ArenaName,
      v23,
      v24,
      v25,
      v26,
      *Filename,
      *&Filename[4],
      *&Filename[8]);
    sprintf(this->szLevelFile1, &unk_42A0A3 + 1, this->ArenaName);
    sprintf(this->szLevelFile2, &unk_42A0A3 + 1, this->ArenaName);
    if ( _access(this->szConfigFile, 0) )
      RewriteSameFile(this->szConfigFile, MEMORY[0x42A098]);
    LOBYTE(v11) = LoadBMPHeader2(this->szLevelFile2);
    if ( !v11 )
    {
      strcpy(this->szLevelFile1, MiscDefaultLevelFile);
      GetTickCountt = GetTickCount;
    }
    LastUsedTimeStamp = time(0);
    sprintf(Filename, MEMORY[0x42A094], LastUsedTimeStamp);
    WritePrivateProfileStringA(aO, aLastusedstamp, Filename, this->szConfigFile);
  }
  else
  {
    sprintf(this->szConfigFile, &unk_42A06B + 1, ServerPath);
    strcpy(this->szLevelFile1, MiscDefaultLevelFile);
    strcpy(this->szLevelFile2, MiscDefaultLevelFile);
    GetTickCountt = GetTickCount;
  }
  printf(&sub_42A03F + 1, this->ArenaName, this->szConfigFile);
  LoadArenaSettings(this);
  SomethingThatLoadsZoneMap(this);
  this->field_1001A = 0;
  this->GetTickCountValue1 = GetTickCountt() / 0xA;
  this->GetTickCountValue2 = GetTickCountt() / 0xA;
  this->TerritoryRewardTimePassed = GetTickCountt() / 0xA;
  this->GetTickCountValue4 = GetTickCountt() / 0xA;
  this->NumOfBricksInArena = 0;
  this->ArenaPlayerCount = 0;
  this->ScoreStructCounter = 0;
  this->ArenaLocked = 0;
  this->ArenaJackpot = 0;
  this->Freq1Score = 0;
  this->Freq2Score = 0;
  this->Freq3Score = 0;
  this->Freq4Score = 0;
  v13 = this->ServersideArenaSettings.RandomFlags;
  this->someCounterBefore = 0;
  this->TotalSoccerBalls = 0;
  if ( v13 && this->ServersideArenaSettings.MaxFlags > 0 )
    v14 = rand() % this->ServersideArenaSettings.MaxFlags + 1;
  else
    v14 = this->ServersideArenaSettings.MaxFlags;
  *this->gap_FF6A = v14;
  this->GetTickCountValue8 = GetTickCountt() / 0xA;
  v15 = rand();
  this->RandomTimesRandom1 = rand() * v15;
  v16 = rand();
  this->RandomTimesRandom2 = rand() * v16;
  GetTickCounttt = GetTickCountt();
  this->field_FF34 = 0;
  this->GetTickCountValue6 = (GetTickCounttt / 0xA) & 0x7FFFFFFF;
  this->field_FF38 = 0;
  this->MapLVLChecksum = 0;
  this->field_FF40 = 0;
  this->GameTimeStart = 0;
  this->GameTimePassed = 0;
  this->field_FF56 = 0;
  this->field_FF20 = 0;
  v18 = 0xCCCCCCCDi64 * GetTickCountt();
  LOBYTE(v18) = this->ArenaName[0];
  this->bRecordPointsToLog = 1;
  this->field_FF4E = HIDWORD(v18) >> 3;
  if ( v18 && !ArenaSpawnKeepScores )
    this->bRecordPointsToLog = 0;
  if ( this->bHasScrFile )
    this->bRecordPointsToLog = 0;
  if ( this->ServersideArenaSettings.FlagMode == 2 )
  {
    v19 = this->someCounterAfter;
    if ( this->someCounterBefore < v19 )
    {
      v20 = 0;
      this->someCounterBefore = v19;
      if ( v19 > 0 )
      {
        v21 = &this->Pointer;                   // Pointer
        do
        {
          *v21 = v21[2906];
          v21[1] = v21[2907];
          v21[3] = -1;
          v21[2] = -1;
          ++v20;
          v21 += 4;
        }
        while ( v20 < this->someCounterAfter );
      }
    }
  }
  ArenaScoreReset(this, 0);
  this->ScoreStructCounter = 0;
  this->GameTimePassedTwo = GetTickCountt() / 0xA;
  this->field_FF20 = 0;
  SoccerGameSomething(this, -1);
  return this;
}
// 40120C: variable 'v23' is possibly undefined
// 40120C: variable 'v24' is possibly undefined
// 40120C: variable 'v25' is possibly undefined
// 40120C: variable 'v26' is possibly undefined
// 401271: variable 'v11' is possibly undefined
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 42A0CB: using guessed type int sub_42A0CB();

//----- (00401590) --------------------------------------------------------
void __thiscall ShutdownArena(struct_ARENA *arenaa)
{
  int v2; // esi
  struct_PLAYER **v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  struct_PLAYER *v7; // ecx
  LPVOID v8; // eax
  LPVOID v9; // eax
  DWORD v10; // kr00_4
  int v11; // eax
  FILE *v12; // eax
  FILE *v13; // esi
  char Filename[32]; // [esp+10h] [ebp-20h] BYREF

  v2 = 0;
  if ( arenaa->ArenaPlayerCount > 0 )
  {
    v3 = arenaa->playerPointersForSomething;
    do
    {
      if ( !arenaa->ServersideArenaSettings.MiscTimedGame )
      {
        if ( arenaa->bHasScrFile )
        {
          v4 = (*v3)->field_15F;
          if ( v4 >= 0 )
          {
            v5 = &(*v3)->CurrentWins;
            v6 = arenaa->FileContentsMemoryPointer + 18 * v4 + 4;
            *v6 = *v5;
            *(v6 + 4) = *(v5 + 4);
            *(v6 + 8) = *(v5 + 8);
            *(v6 + 12) = *(v5 + 12);
          }
        }
      }
      v7 = *v3;
      ++v2;
      ++v3;
      v7->MyArena = 0;
      (*(v3 - 1))->AlreadySentReliablePacket = 1;
    }
    while ( v2 < arenaa->ArenaPlayerCount );
  }
  v8 = arenaa->field_1D40A;
  if ( v8 && v8 != MapAllocateMemoryPointer )
    efree(arenaa->field_1D40A);
  v9 = *&arenaa->dwLastConfigReadTime[12];
  if ( v9 && v9 != dword_437B0C )
    efree(*&arenaa->dwLastConfigReadTime[12]);
  if ( arenaa->FileContentsMemoryPointer )
  {
    v10 = GetTickCount();
    v11 = arenaa->bHasScrFile;
    arenaa->LastSaveStatsTime = v10 / 0xA;
    if ( v11 )
    {
      strcpy(Filename, arenaa->ArenaName);
      strcat(Filename, MEMORY[0x42A0B8]);
      v12 = fopen(Filename, aW);
      v13 = v12;
      if ( v12 )
      {
        fwrite(arenaa->FileContentsMemoryPointer, 0x12u, arenaa->NumberOfContents18ByteBlocks, v12);
        fclose(v13);
      }
    }
    efree(arenaa->FileContentsMemoryPointer);
  }
}

//----- (00401720) --------------------------------------------------------
void __thiscall DropBrick(struct_ARENA *arenaa, int XTiles, int YTiles, __int16 Team)
{
  int v5; // ebp
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  struct_PLAYER **player; // edi
  int v10; // ebx
  struct_PLAYER **playerr; // edi
  signed int Y2Tile; // [esp+10h] [ebp-110h] BYREF
  int Y1Tile; // [esp+14h] [ebp-10Ch] BYREF
  int X2Tile; // [esp+18h] [ebp-108h] BYREF
  int X1Tile; // [esp+1Ch] [ebp-104h] BYREF
  char buf[256]; // [esp+20h] [ebp-100h] BYREF

  if ( arenaa->NumOfBricksInArena < 1024 )
  {
    DoBrickDrop(
      arenaa->field_1D40A,
      XTiles,
      YTiles,
      &X1Tile,
      &Y1Tile,
      &X2Tile,
      &Y2Tile,
      arenaa->ServersideArenaSettings.BrickSpan);
    if ( X1Tile != X2Tile || Y1Tile != Y2Tile )
    {
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].X1Tile = X1Tile;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].field_2 = Y1Tile;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].X2Tile = X2Tile;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].field_6 = Y2Tile;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].Team = Team;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].field_A = arenaa->field_FF40++;
      v5 = 0;
      arenaa->StructToBrick[arenaa->NumOfBricksInArena].BrickTimeStamp = (GetTickCount() / 0xA) & 0x7FFFFFFF;
      v6 = arenaa->NumOfBricksInArena;
      buf[0] = 0x21;                            // 0x21 - Brick Dropped
      *&buf[1] = *&arenaa->StructToBrick[v6].X1Tile;// X1 tiles
      *&buf[5] = *&arenaa->StructToBrick[v6].X2Tile;// X2 tiles
      *&buf[9] = *&arenaa->StructToBrick[v6].Team;// Team
      v7 = arenaa->ServersideArenaSettings.RoutingWallResendCount;
      *&buf[13] = arenaa->StructToBrick[v6].BrickTimeStamp;// Timestamp
      if ( v7 > 0 )
      {
        do
        {
          v8 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            player = arenaa->playerPointersForSomething;
            do
            {
              if ( !(*player)->AlreadySentReliablePacket )
                SendPlayerReliablePacket(*player, buf, 0x11u, 0);
              ++v8;
              ++player;
            }
            while ( v8 < arenaa->ArenaPlayerCount );
          }
          SendPacketsToEverybody(Structv9Pointer);
          ++v5;
        }
        while ( v5 < arenaa->ServersideArenaSettings.RoutingWallResendCount );
      }
      v10 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        playerr = arenaa->playerPointersForSomething;
        do
        {
          if ( !(*playerr)->AlreadySentReliablePacket )
            SendPlayerReliablePacket(*playerr, buf, 0x11u, 1);
          ++v10;
          ++playerr;
        }
        while ( v10 < arenaa->ArenaPlayerCount );
      }
      ++arenaa->NumOfBricksInArena;
    }
  }
}

//----- (00401920) --------------------------------------------------------
void __thiscall PlayerEntering(int arena, struct_PLAYER *player)
{
  int v3; // edx
  int isStaff; // eax
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  _DWORD *i; // ecx
  int v10; // eax
  char *v11; // eax
  int v12; // ecx
  int v13; // eax
  __int16 *v14; // edx
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // edx
  _DWORD *v19; // ecx
  int v20; // eax
  int v21; // esi
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // esi
  char *v28; // ecx
  __int16 *v29; // eax
  int v30; // edx
  __int16 v31; // di
  int FlagId; // edi
  int XTiles; // esi
  __int16 YTiles; // cx
  __int16 OwnerFrequency; // dx
  char *v36; // esi
  int v37; // edx
  int v38; // edi
  char v39; // al
  int v40; // ecx
  int v41; // edx
  _DWORD *v42; // eax
  bool v43; // cc
  int v44; // eax
  int v45; // eax
  __int16 PlayerBannerBitmap; // ax
  unsigned int v47; // eax
  int v48; // edx
  int v49; // eax
  __int16 v50; // dx
  __int16 v51; // cx
  char v52; // al
  __int16 v53; // dx
  __int16 v54; // ax
  int v55; // ecx
  int v56; // edx
  __int16 *v57; // eax
  int v58; // edx
  int v59; // ecx
  char *playerName; // [esp-4h] [ebp-5454h]
  char v61; // [esp+13h] [ebp-543Dh] BYREF
  int *v62; // [esp+14h] [ebp-543Ch]
  int v63; // [esp+18h] [ebp-5438h]
  __int16 *v64; // [esp+1Ch] [ebp-5434h]
  const void *v65; // [esp+20h] [ebp-5430h]
  char buff[9]; // [esp+24h] [ebp-542Ch] BYREF
  unsigned __int8 v67[17]; // [esp+34h] [ebp-541Ch] BYREF
  char v68[3]; // [esp+48h] [ebp-5408h] BYREF
  char Dest[20]; // [esp+4Bh] [ebp-5405h] BYREF
  char v70[20]; // [esp+5Fh] [ebp-53F1h] BYREF
  int v71; // [esp+73h] [ebp-53DDh]
  int v72; // [esp+77h] [ebp-53D9h]
  __int16 v73; // [esp+7Bh] [ebp-53D5h]
  __int16 v74; // [esp+7Dh] [ebp-53D3h]
  __int16 v75; // [esp+7Fh] [ebp-53D1h]
  __int16 v76; // [esp+81h] [ebp-53CFh]
  __int16 v77; // [esp+83h] [ebp-53CDh]
  __int16 v78; // [esp+85h] [ebp-53CBh]
  char v79[21]; // [esp+88h] [ebp-53C8h] BYREF
  unsigned __int8 v80[99]; // [esp+A0h] [ebp-53B0h] BYREF
  char v81[128]; // [esp+104h] [ebp-534Ch] BYREF
  char v82[460]; // [esp+184h] [ebp-52CCh] BYREF
  char buf; // [esp+350h] [ebp-5100h] BYREF
  char v84; // [esp+351h] [ebp-50FFh] BYREF
  unsigned __int8 v85[32]; // [esp+1350h] [ebp-4100h] BYREF

  if ( *(arena + 65570) )
  {
    if ( *(arena + 109622) == -1 && !*(arena + 65292) )
    {
      v3 = player->UserId;
      if ( v3 >= 0 )
      {
        isStaff = 0;
        switch ( CustomArenaMode )
        {
          case 1u:
            goto LABEL_11;
          case 2u:
            if ( player->isModerator )
              goto LABEL_11;
            break;
          case 3u:
            if ( player->isSuperModerator )
              goto LABEL_11;
            break;
          case 4u:
            if ( player->isSysop )
LABEL_11:
              isStaff = 1;
            break;
          default:
            break;
        }
        if ( isStaff )
        {
          *(arena + 109622) = v3;
          strcpy((arena + 110798), player->Name);
          sprintf(buff, MEMORY[0x42A094], player->UserId);
          WritePrivateProfileStringA(aO, aUserid, buff, (arena + 110830));
          WritePrivateProfileStringA(aO, aName, player->Name, (arena + 110830));
        }
      }
    }
  }
  v64 = &player->CurrentWins;
  *(&player->word24B + 2) = *&player->CurrentWins;
  *&player->gap_24F[2] = *&player->GoalCount;
  *&player->gap_24F[6] = *(&player->KillPoints + 2);
  *&player->gap_24F[10] = HIWORD(player->FlagPoints);
  *(arena + 4 * (*(arena + 65292))++ + 64288) = player;
  player->MyArena = arena;
  *player->gap_DC = 0;
  *(&player->Ping + 2) = 0;
  *&player->YPixels = 0;
  *&player->XPixels = 0;
  *player->gap_EC = 0;
  player->field_F0 = 0;
  *player->gap_EC = 10000;
  player->field_B4 = 0;
  player->field_11F = 0;
  player->SecurityWeaponCountTotal = 0;
  player->SecurityWeaponCount = 0;
  player->AttachedToPlayerId = -1;
  player->DebtKills = *(arena + 109666);
  player->KotHDeathCount = 0;
  player->KingCrownKills = 0;
  player->MySoccerReward = 0;
  player->field_15F = -1;
  if ( *(arena + 65570) )
  {
    v5 = player->UserId;
    if ( v5 >= 0 )
    {
      v6 = *(arena + 83602);
      v7 = *(arena + 83606);
      v8 = 0;
      for ( i = v7; v8 < v6; ++v8 )
      {
        if ( *i == v5 )
          break;
        i = (i + 18);
      }
      if ( v8 == v6 )
      {
        v10 = v6 + 1;
        *(arena + 83602) = v10;
        v11 = ExpandMemory(v7, 18 * v10, 0x10000);
        *(arena + 83606) = v11;
        *&v11[18 * v8] = player->UserId;
        v12 = 18 * v8 + *(arena + 83606) + 4;
        *v12 = 0;
        *(v12 + 4) = 0;
        *(v12 + 8) = 0;
        *(v12 + 12) = 0;
      }
      player->field_15F = v8;
      v13 = *(arena + 83606) + 18 * v8 + 4;
      v14 = v64;
      *v64 = *v13;
      *(v14 + 1) = *(v13 + 4);
      *(v14 + 2) = *(v13 + 8);
      v14[6] = *(v13 + 12);
      *&player->PersonalBestWins = *v13;
      *&player->field_235 = *(v13 + 4);
      *&player->Points = *(v13 + 8);
      player->FlagPointsHiWord = *(v13 + 12);
    }
  }
  if ( *(arena + 109754) > 0 )
  {
    v15 = v64;
    v16 = 0;
    player->CurrentLosses = 0;
    player->KillPoints = 0;
    *v15 = 0;
    player->FlagPoints = 0;
    player->GoalCount = 0;
    v17 = player->UserId;
    if ( v17 >= 0 )
    {
      v18 = *(arena + 65594);
      if ( v18 > 0 )
      {
        v19 = (arena + 65598);
        while ( *v19 != v17 )
        {
          ++v16;
          v19 = (v19 + 18);
          if ( v16 >= v18 )
            goto LABEL_30;
        }
        *v15 = *(arena + 18 * v16 + 65602);
        *(v15 + 4) = *(arena + 18 * v16 + 65606);
        *(v15 + 8) = *(arena + 18 * v16 + 65610);
        *(v15 + 12) = *(arena + 18 * v16 + 65614);
      }
LABEL_30:
      if ( v16 == *(arena + 65594) )
      {
        *v15 = 0;
        *(v15 + 4) = 0;
        *(v15 + 8) = 0;
        *(v15 + 12) = 0;
      }
    }
  }
  v20 = *(arena + 109734);
  if ( v20 > 0 && player->CurrentLosses >= v20 )
    player->Ship = 8;
  if ( !player->isModerator )
  {
    v21 = *(arena + 109870);
    if ( v21 > 0 )
    {
      v22 = *(arena + 65292);
      v23 = 0;
      if ( v22 > 0 )
      {
        v24 = arena + 64288;
        do
        {
          if ( *(*v24 + 275) != 8 )
            ++v23;
          v24 += 4;
          --v22;
        }
        while ( v22 );
      }
      if ( v23 > v21 )
        player->Ship = 8;
    }
  }
  if ( player->DemoPlayer )
  {
    v25 = player->Ship;
    if ( v25 == 5 || v25 == 6 || v25 == 4 || v25 == 7 )
      player->Ship = 8;
  }
  if ( *(arena + 65374) )
    player->Ship = 8;
  playerName = player->Name;
  if ( player->Ship == 8 )
  {
    printf(qword_42A0F3 + 1, playerName);
    player->Frequency = *(arena + 109730);
  }
  else
  {
    printf(aPlayerEntering, playerName);
    v26 = GetNextFrequencyToJoin(arena);
    player->Frequency = v26;
    if ( *(arena + 109774) )
      player->Ship = v26 % 8;
  }
  SendPlayerReliablePacket(player, (arena + 108194), 0x594u, 1);
  if ( *(arena + 109746) == 2 )
  {
    v27 = *(arena + 108190);
    buf = 0x22;                                 // 0x22 - Turf Flag Update
    v28 = &v84;
    if ( v27 > 0 )
    {
      v29 = (arena + 100010);
      v30 = v27;
      do
      {
        v31 = *v29;
        v29 += 8;
        *v28 = v31;
        v28 += 2;
        --v30;
      }
      while ( v30 );
    }
    SendPlayerReliablePacket(player, &buf, 2 * v27 + 1, 1);
  }
  else
  {
    FlagId = 0;
    if ( *(arena + 108190) > 0 )
    {
      XTiles = arena + 99998;
      do
      {
        if ( *(XTiles + 8) == -1 && *XTiles >= 0 && *(XTiles + 4) >= 0 )
        {
          YTiles = *(XTiles + 4);
          OwnerFrequency = *(XTiles + 12);
          *&buff[3] = *XTiles;                  // X Tiles
          *&buff[5] = YTiles;                   // Y Tiles
          buff[0] = 0x12;                       // 0x12 - Flag Position
          *&buff[7] = OwnerFrequency;           // Owner Frequency
          *&buff[1] = FlagId;                   // Flag ID
          SendPlayerReliablePacket(player, buff, 9u, 1);
        }
        ++FlagId;
        XTiles += 16;
      }
      while ( FlagId < *(arena + 108190) );
    }
  }
  v63 = 0;
  memset(v81, 0, sizeof(v81));
  v36 = v82;
  if ( *(arena + 65292) > 0 )
  {
    v62 = (arena + 64288);
    do
    {
      v37 = v62;
      *v36 = 3;
      v38 = *v37;
      *(v36 + 51) = *(*v37 + 20);
      *(v36 + 59) = *(v38 + 611);
      v36[2] = *(v38 + 615);
      *(v36 + 53) = *(v38 + 279);
      v36[1] = *(v38 + 275);
      *(v36 + 55) = *(v38 + 547);
      *(v36 + 57) = *(v38 + 549);
      *(v36 + 43) = *(v38 + 553);
      *(v36 + 47) = *(v38 + 557);
      v36[63] = *(v38 + 785) != 0;
      strncpy(v36 + 3, (v38 + 375), 0x14u);
      v36[22] = 0;
      strncpy(v36 + 23, (v38 + 399), 0x14u);
      v39 = *(arena + 109578);
      v36[42] = 0;
      *(v36 + 61) = 0;
      if ( v39 )
      {
        v40 = *(arena + 108190);
        if ( v40 > 0 )
        {
          v41 = *(v36 + 51);
          v42 = (arena + 100006);
          do
          {
            if ( *v42 == v41 )
              ++*(v36 + 61);
            v42 += 4;
            --v40;
          }
          while ( v40 );
        }
      }
      v36 += 64;
      if ( (v36 - v82 + 64) > 0x1CC )
      {
        SendPlayerReliablePacket(player, v82, v36 - v82, 1);
        v36 = v82;
      }
      v43 = ++v63 < *(arena + 65292);
      ++v62;
    }
    while ( v43 );
  }
  if ( v36 != v82 )
    SendPlayerReliablePacket(player, v82, v36 - v82, 1);
  v44 = *(arena + 65292);
  v63 = 0;
  if ( v44 > 0 )
  {
    v62 = (arena + 64288);
    do
    {
      v45 = *v62;
      if ( *(*v62 + 557) + *(*v62 + 553) >= *(arena + 109630) || *(v45 + 48) )
      {
        v65 = (v45 + 423);
        if ( memcmp(v81, (v45 + 423), 0x60u) )
        {
          PlayerBannerBitmap = *(v45 + 20);
          v80[0] = 0x1F;                        // 0x1F - Player Banner Changed
          *&v80[1] = PlayerBannerBitmap;        // Player Banner (Bitmap)
          qmemcpy(&v80[3], v65, 0x60u);
          SendPlayerReliablePacket(player, v80, 0x63u, 1);
        }
      }
      v43 = ++v63 < *(arena + 65292);
      ++v62;
    }
    while ( v43 );
  }
  v47 = 16 * *(arena + 99994);
  v85[0] = 0x21;                                // 0x21 - Brick Dropped
  qmemcpy(&v85[1], (arena + 83610), v47);
  SendPlayerReliablePacket(player, v85, v47 + 1, 1);
  v79[0] = 0x29;                                // 0x29 - Map Information
  strcpy(&v79[1], (arena + 111086));
  *&v79[17] = *(arena + 111618);                // Map Checksum
  SendPlayerReliablePacket(player, v79, 0x15u, 1);
  if ( AdvertiseSendMode == 3 || AdvertiseSendMode == 1 )
    SendAdvertisement(player, 1);
  v61 = 2;                                      // 0x02 - You are now in the game
  SendPlayerReliablePacket(player, &v61, 1u, 1);
  player->XPixels = -9999;
  player->YPixels = -9999;
  v48 = *(arena + 65320);
  v49 = *(arena + 65324);
  *&v67[5] = *(arena + 65316);                  // Door Seed Value
  v67[0] = 0x18;                                // 0x18 - Synchronization Request
  *&v67[1] = v48;                               // Prize Seed Value
  *&v67[9] = v49;                               // Timestamp
  *&v67[13] = 0;                                // Checksum Key
  SendPlayerReliablePacket(player, v67, 0x11u, 1);
  v50 = player->PlayerId;
  v51 = player->Frequency;
  v68[1] = player->Ship;
  v52 = player->AllowAudioByte1;
  v73 = v50;
  v53 = player->AttachedToPlayerId;
  v68[2] = v52;
  v54 = player->CurrentLosses;
  v74 = v51;
  v76 = v54;
  v77 = v53;
  v55 = player->KillPoints;
  v75 = *v64;
  v56 = player->FlagPoints;
  v68[0] = 3;
  v71 = v55;
  v72 = v56;
  v78 = 0;
  strncpy(Dest, player->Name, 0x14u);
  Dest[19] = 0;
  strncpy(v70, player->Squad, 0x14u);
  v70[19] = 0;
  SendEverybodyButYourself(player, v68, 0x40u, 1);
  if ( player->KillPoints + player->FlagPoints >= *(arena + 109630) || player->dword30 )
  {
    if ( memcmp(v81, player->BannerData, 0x60u) )
    {
      *&v80[1] = player->PlayerId;
      v80[0] = 31;
      qmemcpy(&v80[3], player->BannerData, 0x60u);
      SendEverybodyButYourself(player, v80, 0x63u, 1);
    }
  }
  v57 = v64;
  v58 = *(v64 + 1);
  player->dword23F = *v64;
  v59 = *(v57 + 2);
  *&player->dword243 = v58;
  LOWORD(v58) = v57[6];
  *&player->dword247 = v59;
  LOWORD(player->word24B) = v58;
}
// 42A0F3: using guessed type int qword_42A0F3();

//----- (004022D0) --------------------------------------------------------
// Arena.RemovePlayer()
void __thiscall ArenaRemovePlayer(struct_ARENA *arenaa, struct_PLAYER *player)
{
  struct_PLAYER *v2; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  struct_PLAYER **v8; // edi
  int v9; // ecx
  struct_PLAYER **v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  struct_PLAYER **v14; // ecx
  int v15; // eax
  bool v16; // zf
  int UserId; // edi
  int v18; // edx
  int CurrentScoreStructCounter; // eax
  ScoreStruct *v20; // ecx
  __int16 *v21; // edx
  char *v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  struct PLAYER *v26; // eax
  int v27; // edi
  int v28; // eax
  struct_PLAYER **v29; // ebp
  char *v30; // ecx
  __int16 *v31; // ebx

  v2 = player;
  UpdatePowerBallPositionsSomething(player);
  v4 = v2->field_50;
  v5 = v2->field_54;
  v2->MyArena = 0;
  if ( v4 >= 0 && v5 >= 0 && v4 < 8 && v5 < 8 )
  {
    v6 = 251 * (v5 + 8 * v4);
    v7 = 0;
    v8 = &arenaa->PlayerPointers[v6];
    v9 = v8[250];
    if ( v9 > 0 )
    {
      v10 = v8;
      while ( *v10 != v2 )
      {
        ++v7;
        ++v10;
        if ( v7 >= v9 )
          goto LABEL_11;
      }
      v11 = v9 - 1;
      v8[250] = v11;
      v8[v7] = v8[v11];
    }
  }
LABEL_11:
  v12 = arenaa->ArenaPlayerCount;
  v13 = 0;
  if ( v12 > 0 )
  {
    v14 = arenaa->playerPointersForSomething;
    while ( *v14 != v2 )
    {
      ++v13;
      ++v14;
      if ( v13 >= v12 )
        goto LABEL_17;
    }
    arenaa->ArenaPlayerCount = v12 - 1;
    memcpy(
      &arenaa->playerPointersForSomething[v13],
      &arenaa->playerPointersForSomething[v13 + 1],
      4 * (v12 - 1 + 0x3FFFFFFF * v13));
  }
LABEL_17:
  v15 = arenaa->ServersideArenaSettings.MiscTimedGame;
  v16 = v15 == 0;
  if ( v15 > 0 )
  {
    UserId = v2->UserId;
    if ( UserId >= 0 )
    {
      v18 = arenaa->ScoreStructCounter;
      CurrentScoreStructCounter = 0;
      if ( v18 > 0 )
      {
        v20 = arenaa->StructToScore;
        while ( v20->UserId != UserId )
        {
          ++CurrentScoreStructCounter;
          ++v20;
          if ( CurrentScoreStructCounter >= v18 )
            goto LABEL_25;
        }
        v21 = &arenaa->StructToScore[CurrentScoreStructCounter].Wins;
        *v21 = *&v2->CurrentWins;
        *(v21 + 1) = *&v2->GoalCount;
        *(v21 + 2) = *(&v2->KillPoints + 2);
        v21[6] = HIWORD(v2->FlagPoints);
      }
LABEL_25:
      if ( CurrentScoreStructCounter == arenaa->ScoreStructCounter && CurrentScoreStructCounter < 1000 )
      {
        v22 = arenaa + 18 * CurrentScoreStructCounter;
        *(v22 + 65598) = v2->UserId;
        v22 += 65602;
        *v22 = *&v2->CurrentWins;
        *(v22 + 1) = *&v2->GoalCount;
        *(v22 + 2) = *(&v2->KillPoints + 2);
        *(v22 + 6) = HIWORD(v2->FlagPoints);
        ++arenaa->ScoreStructCounter;
      }
    }
    v16 = arenaa->ServersideArenaSettings.MiscTimedGame == 0;
  }
  if ( v16 )
  {
    if ( arenaa->bHasScrFile )
    {
      v23 = v2->field_15F;
      if ( v23 >= 0 )
      {
        v24 = arenaa->FileContentsMemoryPointer + 18 * v23 + 4;
        *v24 = *&v2->CurrentWins;
        *(v24 + 4) = *&v2->GoalCount;
        *(v24 + 8) = *(&v2->KillPoints + 2);
        *(v24 + 12) = HIWORD(v2->FlagPoints);
      }
    }
  }
  if ( v2->isSysop )
  {
    v25 = v2->ArenaPlayerIndex;
    if ( v25 >= 0 )
    {
      v26 = PlayerList[v25];
      LOWORD(player) = 0x1C;                    // 0x1C  Put Player in Spectator Mode
      if ( v26 )
        SendPlayerReliablePacket(v26, &player, 2u, 1);
    }
  }
  if ( CurrentPlayerCount > 0 )
  {
    v27 = 0;
    *(&player + 1) = v2->PlayerId;
    v28 = arenaa->ArenaPlayerCount;
    LOBYTE(player) = 4;                         // 0x04 - Player Leaving
    if ( v28 > 0 )
    {
      v29 = arenaa->playerPointersForSomething;
      do
      {
        if ( !(*v29)->AlreadySentReliablePacket )
          SendPlayerReliablePacket(*v29, &player, 3u, 1);
        ++v27;
        ++v29;
      }
      while ( v27 < arenaa->ArenaPlayerCount );
    }
  }
  CarryFlagsSomething(arenaa, *&v2->PlayerId, 0);
  if ( !arenaa->bRecordPointsToLog )
  {
    v30 = &v2->word24B + 2;
    v31 = &v2->CurrentWins;
    *v31 = *v30;
    *(v31 + 1) = *(v30 + 1);
    *(v31 + 2) = *(v30 + 2);
    v31[6] = *(v30 + 6);
  }
}

//----- (00402560) --------------------------------------------------------
bool __thiscall ProcessArena(struct_ARENA *arenaa)
{
  __int64 v3; // rax
  int v4; // edi
  struct_PLAYER **v5; // esi
  DWORD (__stdcall *GetTickCountt)(); // ebx
  __int64 v7; // rax
  FILE *v8; // eax
  FILE *v9; // esi
  __int64 v10; // rax
  struct_ARENA *v11; // eax
  unsigned int v12; // kr1C_4
  int v13; // edi
  struct_PLAYER *v14; // ebx
  bool v15; // cc
  int v16; // esi
  char *v17; // ecx
  char *v18; // eax
  int v19; // edx
  __int16 v20; // di
  unsigned int v21; // ebx
  int v22; // esi
  struct_PLAYER **v23; // edi
  __int64 v24; // rax
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  struct_PLAYER **v28; // esi
  DWORD v29; // kr04_4
  struct_PLAYER *player; // eax
  int v31; // eax
  int counter; // esi
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  ARENA_SETTINGS *v36; // eax
  signed int Key; // ebx
  int v38; // edx
  int v39; // esi
  int v40; // edi
  struct_PLAYER **v41; // esi
  int v42; // esi
  int v43; // esi
  int Timestamp; // edx
  int v45; // esi
  int PrizeSeed; // ecx
  int v47; // eax
  struct_PLAYER **v48; // edi
  __int64 v49; // rax
  __int64 v50; // rax
  int v51; // eax
  int v52; // esi
  struct_PLAYER **v53; // ebx
  int v54; // edi
  struct_PLAYER **v55; // esi
  struct PLAYER *v56; // eax
  int v57; // ebx
  int v58; // ecx
  int v59; // eax
  int v60; // edi
  struct_PLAYER **v61; // edx
  int v62; // esi
  struct_PLAYER *v63; // eax
  int v64; // ecx
  int v65; // esi
  int v66; // eax
  struct_PLAYER **v67; // ebx
  struct_PLAYER **v68; // ebx
  int v69; // esi
  struct_PLAYER *v70; // eax
  struct_PLAYER **v71; // edi
  int v72; // esi
  struct_PLAYER *v73; // edi
  int v74; // esi
  int v75; // eax
  __int64 v76; // rax
  int v77; // edi
  int *v78; // ebx
  int v79; // esi
  int v80; // edx
  int v81; // eax
  int *v82; // ecx
  int v83; // ecx
  struct_PLAYER **v84; // eax
  bool v85; // zf
  int v86; // edx
  int v87; // eax
  char *v88; // ebx
  int v89; // esi
  int v90; // eax
  int v91; // ecx
  int v92; // ebx
  int v93; // ecx
  int v94; // edi
  int v95; // ecx
  struct PLAYER **v96; // ebx
  struct PLAYER *v97; // eax
  int v98; // esi
  int v99; // edi
  struct_PLAYER **v100; // esi
  int v101; // ebx
  int v102; // eax
  struct_PLAYER *v103; // eax
  int v104; // edi
  int v105; // ecx
  int *v106; // edx
  struct_PLAYER *v107; // eax
  int v108; // edx
  char *v109; // eax
  int j; // ecx
  int v111; // ecx
  int v112; // esi
  struct_PLAYER **v113; // eax
  int v114; // eax
  DWORD v115; // eax
  int v116; // ecx
  int v117; // eax
  int v118; // ebx
  int v119; // esi
  struct_PLAYER **v120; // ecx
  int v121; // edx
  struct_PLAYER *v122; // eax
  int v123; // edi
  struct_PLAYER **v124; // esi
  int v125; // ebx
  struct_PLAYER **v126; // esi
  struct_PLAYER *v127; // eax
  int v128; // edi
  int v129; // eax
  int v130; // ecx
  int v131; // eax
  __int64 v132; // rax
  __int64 v133; // rax
  DWORD v134; // kr10_4
  int v135; // eax
  int v136; // edx
  int *v137; // ebx
  int v138; // edi
  int v139; // esi
  int v140; // eax
  int *v141; // ecx
  struct_PLAYER **v142; // eax
  int v143; // ecx
  int *v144; // ebx
  char *v145; // edi
  int v146; // eax
  int v147; // esi
  int v148; // esi
  int *v149; // eax
  __int16 *v150; // edi
  __int16 v151; // cx
  struct PLAYER **v152; // ebx
  struct PLAYER *v153; // eax
  int v154; // edi
  int v155; // ebx
  struct_PLAYER **v156; // esi
  __int64 v157; // rax
  int v158; // eax
  int v159; // esi
  struct_PLAYER **v160; // edi
  int v161; // eax
  int v162; // esi
  struct_PLAYER **v163; // edi
  int v164; // esi
  struct_PLAYER **v165; // edi
  int v166; // esi
  signed int v167; // eax
  int v168; // esi
  struct_PLAYER **v169; // edi
  DWORD v170; // eax
  struct_PLAYER **v171; // esi
  int v172; // edi
  int v173; // ecx
  char *v174; // edx
  struct_PLAYER *v175; // eax
  int v176; // ebx
  struct_PLAYER **v177; // esi
  struct_PLAYER *v178; // eax
  __int16 *v179; // ecx
  _WORD *v180; // eax
  int v181; // eax
  int v182; // ecx
  int v183; // edx
  int v184; // eax
  int v185; // esi
  struct_PLAYER **v186; // edi
  int v187; // esi
  struct_PLAYER **v188; // edi
  int v189; // esi
  BrickStruct *v190; // ebx
  BrickStruct *v191; // edi
  int v192; // edx
  int *v193; // esi
  __int16 *v194; // ebx
  struct_PLAYER *v195; // eax
  int v196; // esi
  int v197; // eax
  char v198; // dl
  struct_PLAYER **v199; // edi
  struct_ARENA **v200; // [esp+4h] [ebp-27DCh]
  int v201; // [esp+4h] [ebp-27DCh]
  int v202; // [esp+4h] [ebp-27DCh]
  char *v203; // [esp+4h] [ebp-27DCh]
  int v204; // [esp+4h] [ebp-27DCh]
  int v205; // [esp+4h] [ebp-27DCh]
  int *v206; // [esp+8h] [ebp-27D8h]
  int v207; // [esp+8h] [ebp-27D8h]
  int v208; // [esp+8h] [ebp-27D8h]
  int *v209; // [esp+8h] [ebp-27D8h]
  int v210; // [esp+Ch] [ebp-27D4h]
  int KothPoints; // [esp+Ch] [ebp-27D4h]
  int v212; // [esp+Ch] [ebp-27D4h]
  char *v213; // [esp+Ch] [ebp-27D4h]
  int *v214; // [esp+Ch] [ebp-27D4h]
  char *v215; // [esp+Ch] [ebp-27D4h]
  char *v216; // [esp+Ch] [ebp-27D4h]
  int v217; // [esp+10h] [ebp-27D0h]
  int v218; // [esp+10h] [ebp-27D0h]
  int v219; // [esp+10h] [ebp-27D0h]
  int v220; // [esp+10h] [ebp-27D0h]
  char SoundByte; // [esp+14h] [ebp-27CCh]
  int a3a; // [esp+14h] [ebp-27CCh]
  char *a3b; // [esp+14h] [ebp-27CCh]
  char v224[8]; // [esp+18h] [ebp-27C8h] BYREF
  int *i; // [esp+20h] [ebp-27C0h]
  char buff[38]; // [esp+24h] [ebp-27BCh] BYREF
  char buf[1428]; // [esp+4Ch] [ebp-2794h] BYREF
  int v228[384]; // [esp+5E0h] [ebp-2200h]
  int v229[384]; // [esp+BE0h] [ebp-1C00h] BYREF
  int v230[384]; // [esp+11E0h] [ebp-1600h] BYREF
  char v231; // [esp+17E0h] [ebp-1000h] BYREF
  char v232; // [esp+17E1h] [ebp-FFFh] BYREF

  if ( arenaa->field_10026 )
    return 1;
  v3 = (GetTickCount() / 0xA - arenaa->GetTickCountValue2);
  if ( ((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 6000 || arenaa->playerPointersForSomething[250] )
  {
    arenaa->GetTickCountValue2 = GetTickCount() / 0xA;
    if ( IsFileLastWrittenTime(arenaa->szConfigFile, arenaa->dwLastConfigReadTime)
      || arenaa->playerPointersForSomething[250] )
    {
      arenaa->playerPointersForSomething[250] = 0;
      qmemcpy(buf, &arenaa->ArenaSettings, sizeof(buf));
      LoadArenaSettings(arenaa);
      if ( !memcmp(buf, &arenaa->ArenaSettings, 0x594u) )
      {
        GetTickCountt = GetTickCount;
      }
      else
      {
        printf("Parameters resent for arena(%s)\n", arenaa->ArenaName);
        v4 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v5 = arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v5)->AlreadySentReliablePacket )
              SendPlayerReliablePacket(*v5, &arenaa->ArenaSettings, 0x594u, 1);
            ++v4;
            ++v5;
          }
          while ( v4 < arenaa->ArenaPlayerCount );
        }
        GetTickCountt = GetTickCount;
        arenaa->field_FF38 = 0;
        arenaa->MapLVLChecksum = 0;
      }
    }
    else
    {
      GetTickCountt = GetTickCount;
    }
    v7 = (GetTickCountt() / 0xA - arenaa->LastSaveStatsTime);
    if ( ((HIDWORD(v7) ^ v7) - HIDWORD(v7)) > arenaa->ServersideArenaSettings.CustomSaveStatsTime )
    {
      if ( arenaa->FileContentsMemoryPointer )
      {
        arenaa->LastSaveStatsTime = GetTickCountt() / 0xA;
        if ( arenaa->bHasScrFile )
        {
          strcpy(buff, arenaa->ArenaName);
          strcat(buff, MEMORY[0x42A0B8]);
          v8 = fopen(buff, aW);
          v9 = v8;
          if ( v8 )
          {
            fwrite(arenaa->FileContentsMemoryPointer, 0x12u, arenaa->NumberOfContents18ByteBlocks, v8);
            fclose(v9);
          }
        }
      }
    }
    v10 = (GetTickCountt() / 0xA - arenaa->LastCheckArenaEmptyTime);
    if ( ((HIDWORD(v10) ^ v10) - HIDWORD(v10)) > 60000
      && arenaa->ArenaPlayerCount < ArenaMinimumPlayers
      && !arenaa->ArenaName[0] )
    {
      v210 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v200 = Arenas;
        do
        {
          v11 = *v200;
          if ( *v200 == arenaa )
            break;
          if ( v11->ArenaPlayerCount < ArenaDesiredPlayers && !v11->ArenaName[0] )
          {
            buf[0] = 7;
            buf[1] = 0;
            buf[2] = 2;
            *&buf[3] = 0;
            strcpy(&buf[5], "Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.");
            v12 = strlen("Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.") + 1;
            v13 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v14 = arenaa->playerPointersForSomething;
              do
              {
                if ( !*(v14->unknownIthoughtItWasPlayerPointerDupe + 56) )
                  SendPlayerReliablePacket(v14->unknownIthoughtItWasPlayerPointerDupe, buf, v12 - 1 + 6, 1);
                ++v13;
                v14 = (v14 + 4);
              }
              while ( v13 < arenaa->ArenaPlayerCount );
            }
            GetTickCountt = GetTickCount;
            arenaa->LastCheckArenaEmptyTime = GetTickCount() / 0xA;
          }
          v15 = ++v210 < ArenaArrayLength;
          ++v200;
        }
        while ( v15 );
      }
    }
    if ( arenaa->ServersideArenaSettings.FlagMode == 2 )
    {
      v16 = arenaa->someCounterBefore;
      v231 = 34;
      v17 = &v232;
      if ( v16 > 0 )
      {
        v18 = &arenaa->gap_186A2[8];
        v19 = v16;
        do
        {
          v20 = *v18;
          v18 += 16;
          *v17 = v20;
          v17 += 2;
          --v19;
        }
        while ( v19 );
      }
      v21 = 2 * v16 + 1;
      v22 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v23 = arenaa->playerPointersForSomething;
        do
        {
          if ( !(*v23)->AlreadySentReliablePacket )
            SendPlayerReliablePacket(*v23, &v231, v21, 1);
          ++v22;
          ++v23;
        }
        while ( v22 < arenaa->ArenaPlayerCount );
      }
    }
    else
    {
      v24 = (GetTickCountt() / 0xA - arenaa->field_FF4E);
      if ( ((HIDWORD(v24) ^ v24) - HIDWORD(v24)) > 12000 )
      {
        if ( arenaa->someCounterBefore < *arenaa->gap_FF6A )
        {
          do
          {
            *(&arenaa->Pointer + 4 * arenaa->someCounterBefore) = -1;
            *&arenaa->gap_186A2[16 * arenaa->someCounterBefore] = -1;
            *&arenaa->gap_186A2[16 * arenaa->someCounterBefore + 4] = -1;
            *&arenaa->gap_186A2[16 * arenaa->someCounterBefore + 8] = -1;
            v25 = arenaa->someCounterBefore + 1;
            arenaa->someCounterBefore = v25;
          }
          while ( v25 < *arenaa->gap_FF6A );
        }
        v26 = *arenaa->gap_FF6A;
        if ( arenaa->someCounterBefore > v26 )
          arenaa->someCounterBefore = v26;
      }
      FlagPositionUpdateSomething(arenaa, 1);
    }
    v27 = 0;
    if ( arenaa->ArenaPlayerCount > 0 )
    {
      v28 = arenaa->playerPointersForSomething;
      do
      {
        if ( (*v28)->field_B4 )
        {
          v29 = GetTickCount();
          player = *v28;
          if ( (v29 / 0xA - (*v28)->field_B4) > 5000 && !player->isSuperModerator )
          {
            if ( arenaa->ServersideArenaSettings.dwordB4 )
            {
              WriteSubGameLog("Player kicked off for not returning security packet: %s\n", player->PlayerName);
              (*v28)->DisconnectReason = 13;
              (*v28)->AlreadySentReliablePacket = 1;
            }
            if ( GetRelAckDiff((*v28)->encryptionPointer, 0) < 3 )
            {
              sprintf(buf, "WARNING: Security checksum not returned {st=%d,et=%d}", (*v28)->field_B4, v29 / 0xA);
              SendBillerWarnings(buf, *v28);
            }
          }
          (*v28)->field_B4 = 0;
        }
        ++v27;
        ++v28;
      }
      while ( v27 < arenaa->ArenaPlayerCount );
    }
    v31 = arenaa->ServersideArenaSettings.SoccerBallCount;
    if ( arenaa->TotalSoccerBalls != v31 )
    {
      counter = 0;
      arenaa->TotalSoccerBalls = v31;
      while ( counter < arenaa->TotalSoccerBalls )
        CreateSoccerBall(arenaa, counter++);
    }
    v33 = arenaa->field_FF30;
    arenaa->field_FF30 = v33 + 1;
    if ( (v33 & 1) != 0 )
    {
      v34 = rand() % 500;                       // Random Checksum key out of 500 possible keys
      v35 = 0;
      v36 = &arenaa->ArenaSettings;
      arenaa->field_FF34 = v34;
      Key = *&SecurityArray[0].ScrtyData[8 * v34];
      v38 = 357;
      do
      {
        v39 = v36->VersionAndManyBitFields;
        v36 = (v36 + 4);
        v35 += Key ^ v39;
        --v38;
      }
      while ( v38 );
      arenaa->field_FF38 = v35;
      arenaa->MapLVLChecksum = GenerateLVLChecksum(arenaa->field_1D40A, Key);
      if ( Key )
      {
        v40 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v41 = arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v41)->AlreadySentReliablePacket && !*(*v41)->gap_309 )
              (*v41)->field_B4 = GetTickCount() / 0xA;
            ++v40;
            ++v41;
          }
          while ( v40 < arenaa->ArenaPlayerCount );
        }
      }
      v42 = rand();
      arenaa->RandomTimesRandom1 = rand() * v42;
      v43 = rand();
      arenaa->RandomTimesRandom2 = rand() * v43;
      Timestamp = (GetTickCount() / 0xA) & 0x7FFFFFFF;
      v45 = 0;
      arenaa->GetTickCountValue6 = Timestamp;
      PrizeSeed = arenaa->RandomTimesRandom2;
      *&buff[5] = arenaa->RandomTimesRandom1;   // Door Seed Value
      v47 = arenaa->ArenaPlayerCount;
      buff[0] = 0x18;                           // 0x18  Synchronization Request
      *&buff[1] = PrizeSeed;                    // Prize Seed Value
      *&buff[9] = Timestamp;                    // Timestamp
      *&buff[13] = Key;                         // Checksum Key
      if ( v47 > 0 )
      {
        v48 = arenaa->playerPointersForSomething;
        do
        {
          if ( !(*v48)->AlreadySentReliablePacket )
            SendPlayerReliablePacket(*v48, buff, 0x11u, 1);
          ++v45;
          ++v48;
        }
        while ( v45 < arenaa->ArenaPlayerCount );
      }
    }
  }
  v49 = (GetTickCount() / 0xA - *arenaa->gap_FF4A);
  if ( ((HIDWORD(v49) ^ v49) - HIDWORD(v49)) > 200 )
  {
    *arenaa->gap_FF4A = GetTickCount() / 0xA;
    if ( arenaa->ServersideArenaSettings.KingDeathCount > 0 )
    {
      if ( arenaa->GetTickCountValue1 )
      {
        v50 = (GetTickCount() / 0xA - arenaa->GetTickCountValue1);
        if ( ((HIDWORD(v50) ^ v50) - HIDWORD(v50)) > 12000 )
        {
          if ( arenaa->ArenaPlayerCount > 2 )
          {
            arenaa->GetTickCountValue1 = 0;
            *&v224[2] = arenaa->ServersideArenaSettings.KingExpireTime;// Timer Value
            v51 = arenaa->ArenaPlayerCount;
            v52 = 0;
            v224[0] = 0x2C;                     // 0x2C  KotH Game Reset
            *&v224[6] = -1;                     // Player ID
            v224[1] = 1;                        // Adding KoTH Timer
            if ( v51 > 0 )
            {
              v53 = arenaa->playerPointersForSomething;
              do
              {
                if ( !(*v53)->AlreadySentReliablePacket )
                  SendPlayerReliablePacket(*v53, v224, 8u, 1);
                ++v52;
                ++v53;
              }
              while ( v52 < arenaa->ArenaPlayerCount );
            }
            v54 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v55 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*v55, "King of the Hill restarted", 103);
                v56 = *v55;
                ++v54;
                ++v55;
                *(v56 + 785) = arenaa->ServersideArenaSettings.KingDeathCount;
              }
              while ( v54 < arenaa->ArenaPlayerCount );
            }
            arenaa->field_1001A = arenaa->ArenaPlayerCount
                                * arenaa->ArenaPlayerCount
                                * arenaa->ServersideArenaSettings.KingRewardFactor
                                / 1000;
          }
          else
          {
            arenaa->GetTickCountValue1 = GetTickCount() / 0xA;
          }
        }
      }
      else
      {
        v57 = arenaa->ArenaPlayerCount;
        v58 = -1;
        v59 = 0;
        v60 = 1;
        v201 = 0;
        if ( v57 > 0 )
        {
          v61 = arenaa->playerPointersForSomething;
          v62 = arenaa->ArenaPlayerCount;
          do
          {
            v63 = *v61;
            if ( (*v61)->KotHDeathCount > 0 )
            {
              if ( v58 == -1 )
                v58 = v63->Frequency;
              if ( v63->Frequency == v58 )
                ++v201;
              else
                v60 = 0;
            }
            ++v61;
            --v62;
          }
          while ( v62 );
          v59 = v201;
        }
        if ( v60 )
        {
          v64 = v59;
          if ( v59 <= 1 )
            v64 = 1;
          v65 = 0;
          v66 = arenaa->field_1001A / v64;
          v224[0] = 0x2C;                       // 0x2C  KotH Game Reset
          *&v224[6] = -1;                       // Player ID
          v224[1] = 0;                          // Adding KoTH Timer
          KothPoints = v66;
          if ( v57 > 0 )
          {
            v67 = arenaa->playerPointersForSomething;
            do
            {
              if ( !(*v67)->AlreadySentReliablePacket )
                SendPlayerReliablePacket(*v67, v224, 8u, 1);
              ++v65;
              ++v67;
            }
            while ( v65 < arenaa->ArenaPlayerCount );
          }
          SoundByte = 103;
          arenaa->GetTickCountValue1 = GetTickCount() / 0xA;
          v202 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            v68 = arenaa->playerPointersForSomething;
            do
            {
              v69 = 0;
              if ( (*v68)->KotHDeathCount > 0 )
              {
                (*v68)->KotHDeathCount = 0;
                (*v68)->FlagPoints += KothPoints;
                v70 = *v68;
                buff[0] = 9;                    // 0x09  Player Score Update
                *&buff[1] = v70->PlayerId;      // Player ID
                *&buff[3] = v70->KillPoints;    // Flag Points
                *&buff[7] = v70->FlagPoints;    // Kill Points
                *&buff[11] = v70->CurrentWins;  // Wins
                *&buff[13] = v70->CurrentLosses;// Losses
                if ( arenaa->ArenaPlayerCount > 0 )
                {
                  v71 = arenaa->playerPointersForSomething;
                  do
                  {
                    if ( !(*v71)->AlreadySentReliablePacket )
                      SendPlayerReliablePacket(*v71, buff, 0xFu, 1);
                    ++v69;
                    ++v71;
                  }
                  while ( v69 < arenaa->ArenaPlayerCount );
                }
                sprintf(buf, xmmword_42A1DF + 1, (*v68)->Name, KothPoints);
                v72 = 0;
                if ( arenaa->ArenaPlayerCount > 0 )
                {
                  v73 = arenaa->playerPointersForSomething;
                  do
                  {
                    SendMessage(v73->unknownIthoughtItWasPlayerPointerDupe, buf, SoundByte);
                    ++v72;
                    v73 = (v73 + 4);
                  }
                  while ( v72 < arenaa->ArenaPlayerCount );
                }
                SoundByte = 0;
              }
              ++v68;
              ++v202;
            }
            while ( v202 < arenaa->ArenaPlayerCount );
          }
        }
      }
    }
    v74 = arenaa->someCounterBefore;
    if ( v74 <= 0 )
    {
LABEL_295:
      if ( arenaa->GameTimeStart > 0 )
      {
        v157 = (GetTickCount() / 0xA - arenaa->GameTimePassed);
        v158 = arenaa->GameTimeStart - ((HIDWORD(v157) ^ v157) - HIDWORD(v157));
        if ( v158 > 0 )
        {
          if ( v158 >= 6000 || arenaa->field_FF56 >= 2 )
          {
            if ( v158 < 30000 && v158 > 29000 && arenaa->field_FF56 < 1 )
            {
              arenaa->field_FF56 = 1;
              v164 = 0;
              if ( arenaa->ArenaPlayerCount > 0 )
              {
                v165 = arenaa->playerPointersForSomething;
                do
                {
                  SendMessage(*v165, unk_42A18F + 1, 0);
                  ++v164;
                  ++v165;
                }
                while ( v164 < arenaa->ArenaPlayerCount );
              }
            }
          }
          else
          {
            v161 = arenaa->ArenaPlayerCount;
            v162 = 0;
            arenaa->field_FF56 = 2;
            if ( v161 > 0 )
            {
              v163 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*v163, aNotice1MinuteR, 0);
                ++v162;
                ++v163;
              }
              while ( v162 < arenaa->ArenaPlayerCount );
            }
          }
        }
        else
        {
          v159 = 0;
          if ( arenaa->ArenaPlayerCount > 0 )
          {
            v160 = arenaa->playerPointersForSomething;
            do
            {
              SendMessage(*v160, aNoticeGameOver, 5);
              ++v159;
              ++v160;
            }
            while ( v159 < arenaa->ArenaPlayerCount );
          }
          arenaa->GameTimeStart = 0;
          arenaa->field_FF56 = 0;
        }
      }
      if ( arenaa->ServersideArenaSettings.MiscTimedGame > 0 )
      {
        v166 = arenaa->GameTimePassedTwo;
        v167 = arenaa->ServersideArenaSettings.MiscTimedGame - abs32(GetTickCount() / 0xA - v166);
        if ( !v166 )
          v167 = -1;
        if ( v167 > 0 )
        {
          if ( v167 >= 6000 || arenaa->field_FF20 >= 2 )
          {
            if ( v167 < 30000 && arenaa->field_FF20 < 1 )
            {
              arenaa->field_FF20 = 1;
              v187 = 0;
              if ( arenaa->ArenaPlayerCount > 0 )
              {
                v188 = arenaa->playerPointersForSomething;
                do
                {
                  SendMessage(*v188, &algn_429750[2512], 0);
                  ++v187;
                  ++v188;
                }
                while ( v187 < arenaa->ArenaPlayerCount );
              }
            }
          }
          else
          {
            v184 = arenaa->ArenaPlayerCount;
            v185 = 0;
            arenaa->field_FF20 = 2;
            if ( v184 > 0 )
            {
              v186 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*v186, MEMORY[0x42A150], arenaa->ArenaSettings.VictoryMusic != 0 ? 0x64 : 0);
                ++v185;
                ++v186;
              }
              while ( v185 < arenaa->ArenaPlayerCount );
            }
          }
        }
        else
        {
          if ( arenaa->ServersideArenaSettings.SoccerCapturePoints && arenaa->ServersideArenaSettings.SoccerBallCount )
          {
            GetScore(arenaa, 0);
            v168 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v169 = arenaa->playerPointersForSomething;
              do
              {
                SendMessage(*v169, aSoccerGameOver, 103);
                ++v168;
                ++v169;
              }
              while ( v168 < arenaa->ArenaPlayerCount );
            }
            ArenaScoreReset(arenaa, 1);
            arenaa->ScoreStructCounter = 0;
            v170 = GetTickCount();
          }
          else
          {
            v171 = arenaa->playerPointersForSomething;
            qsort(arenaa->playerPointersForSomething, arenaa->ArenaPlayerCount, 4u, PtFuncCompare);
            v172 = arenaa->ArenaPlayerCount;
            buff[0] = 0x24;                     // 0x24  Speed Game Over
            v173 = 0;
            v174 = &buff[28];                   // Player 1 ID
            v216 = &buff[8];                    // Player 1 Score
            do
            {
              if ( v173 >= v172 )
              {
                *v174 = -1;
              }
              else
              {
                v175 = *v171;
                *v174 = (*v171)->PlayerId;
                *v216 = v175->FlagPoints + v175->KillPoints;
              }
              ++v173;
              ++v171;
              v174 += 2;
              v216 += 4;
            }
            while ( v173 < 5 );
            v176 = 0;
            if ( v172 > 0 )
            {
              v177 = arenaa->playerPointersForSomething;
              do
              {
                v178 = *v177;
                *&buff[4] = (*v177)->FlagPoints + (*v177)->KillPoints;// Your Score
                *&buff[2] = v176 + 1;           // Your Rank
                if ( *&v178->PersonalBestPoints2of2 + *&v178->PersonalBestPoints1of2 >= *&buff[4] )// Your Score
                {
                  buff[1] = 0;                  // Best
                }
                else if ( v172 > 10 )
                {
                  v179 = &v178->CurrentWins;
                  buff[1] = 1;                  // Best
                  v180 = &v178->PersonalBestWins;
                  *v180 = *v179;
                  *(v180 + 1) = *(v179 + 1);
                  *(v180 + 2) = *(v179 + 2);
                  v180[6] = v179[6];
                  if ( arenaa->bHasScrFile )
                  {
                    v181 = (*v177)->field_15F;
                    if ( v181 >= 0 )
                    {
                      v182 = &(*v177)->PersonalBestWins;
                      v183 = arenaa->FileContentsMemoryPointer + 18 * v181 + 4;
                      *v183 = *v182;
                      *(v183 + 4) = *(v182 + 4);
                      *(v183 + 8) = *(v182 + 8);
                      *(v183 + 12) = *(v182 + 12);
                    }
                  }
                  else if ( BillingConnectionStructPointer && arenaa->bRecordPointsToLog )
                  {
                    SendBillerUserScorePacket(
                      BillingConnectionStructPointer,
                      (*v177)->BillerPlayerId,
                      &(*v177)->PersonalBestWins,
                      0xEu);
                  }
                }
                SendPlayerReliablePacket(*v177, buff, 0x26u, 1);
                v172 = arenaa->ArenaPlayerCount;
                ++v176;
                ++v177;
              }
              while ( v176 < v172 );
            }
            ArenaScoreReset(arenaa, 0);
            arenaa->ScoreStructCounter = 0;
            v170 = GetTickCount();
          }
          arenaa->GameTimePassedTwo = v170 / 0xA;
          arenaa->field_FF20 = 0;
          SoccerGameSomething(arenaa, -1);
        }
      }
      v205 = 0;
      if ( arenaa->NumOfBricksInArena > 0 )
      {
        v189 = 0;
        v190 = arenaa->StructToBrick;
        v191 = &arenaa->StructToBrick[1];
        v209 = &arenaa->StructToBrick[0].BrickTimeStamp;
        do
        {
          if ( abs32(GetTickCount() / 0xA - *v209) > arenaa->ArenaSettings.BrickTime )
          {
            v192 = arenaa->NumOfBricksInArena - 1;
            arenaa->NumOfBricksInArena = v192;
            memcpy(v190, v191, 16 * (v189 + v192));
            v189 -= 0xFFFFFFF;
            --v191;
            --v205;
            v209 -= 4;
            --v190;
          }
          v189 += 0xFFFFFFF;
          ++v191;
          ++v190;
          v15 = ++v205 < arenaa->NumOfBricksInArena;
          v209 += 4;
        }
        while ( v15 );
      }
      goto LABEL_358;
    }
    v75 = arenaa->ServersideArenaSettings.FlagMode;
    if ( v75 == 2 )
    {
      v76 = (GetTickCount() / 0xA - arenaa->TerritoryRewardTimePassed);
      if ( ((HIDWORD(v76) ^ v76) - HIDWORD(v76)) > arenaa->ServersideArenaSettings.TerritoryRewardDelay )
      {
        arenaa->TerritoryRewardTimePassed = GetTickCount() / 0xA;
        if ( arenaa->ArenaPlayerCount >= 16 )
        {
          v77 = 0;
          a3a = 0;
          if ( arenaa->someCounterBefore > 0 )
          {
            v78 = v229;
            v203 = &arenaa->gap_186A2[8];
            v79 = 0;
            v212 = arenaa->someCounterBefore;
            do
            {
              v80 = *v203;
              if ( *v203 >= 0 )
              {
                v81 = 0;
                if ( v79 > 0 )
                {
                  v82 = v230;
                  while ( *v82 != v80 )
                  {
                    ++v81;
                    ++v82;
                    if ( v81 >= v77 )
                      goto LABEL_140;
                  }
                  ++v228[v81];
                }
LABEL_140:
                if ( v81 == v77 )
                {
                  v83 = arenaa->ArenaPlayerCount;
                  v230[v79] = v80;
                  v228[v79] = 1;
                  *v78 = 0;
                  if ( v83 > 0 )
                  {
                    v84 = arenaa->playerPointersForSomething;
                    do
                    {
                      if ( (*v84)->Frequency == v80 )
                        ++*v78;
                      ++v84;
                      --v83;
                    }
                    while ( v83 );
                    v77 = a3a;
                  }
                  ++v77;
                  ++v79;
                  a3a = v77;
                  ++v78;
                }
              }
              v85 = v212 == 1;
              v203 += 16;
              --v212;
            }
            while ( !v85 );
          }
          v86 = 0;
          v87 = 0;
          i = 0;
          if ( v77 > 0 )
          {
            do
            {
              if ( v229[v87] >= arenaa->ServersideArenaSettings.TerritoryRewardMinimumPlayers
                && v228[v87] >= arenaa->ServersideArenaSettings.TerritoryRewardBaseFlags )
              {
                ++v86;
              }
              ++v87;
            }
            while ( v87 < v77 );
            i = v86;
          }
          if ( v86 > 1 )
          {
            v88 = &buf[1];
            buf[0] = 35;
            v213 = &buf[1];
            v204 = 0;
            if ( v77 > 0 )
            {
              v206 = v230;
              do
              {
                v89 = v229[v204];
                if ( v89 >= arenaa->ServersideArenaSettings.TerritoryRewardMinimumPlayers )
                {
                  v90 = v228[v204];
                  v91 = arenaa->ServersideArenaSettings.TerritoryRewardBaseFlags;
                  if ( v90 >= v91 )
                  {
                    v92 = arenaa->ArenaPlayerCount;
                    v93 = v92 * arenaa->ServersideArenaSettings.TerritoryRewardPoints * (i - 1) * (v90 - v91);
                    v94 = v93 / 50 / v89;
                    if ( v94 > 0 )
                    {
                      *v213 = *v206;
                      v95 = v93 / 50 / v89;
                      if ( v94 >= 30000 )
                        LOWORD(v95) = 30000;
                      *(v213 + 1) = v95;
                      v213 += 4;
                      v217 = 0;
                      if ( v92 > 0 )
                      {
                        v96 = arenaa->playerPointersForSomething;
                        *v224 = *v206;
                        do
                        {
                          v97 = *v96;
                          if ( *(*v96 + 279) == *v224 && *(v97 + 275) != 8 && (*(v97 + 231) & 0x20) == 0 )
                          {
                            v98 = *(v97 + 553) + *(v97 + 557);
                            UpdatePoints(v97, 0, v94);
                            if ( v98 < AutoPermissionPoints
                              && AutoPermissionPoints > 0
                              && *(*v96 + 553) + *(*v96 + 557) >= AutoPermissionPoints )
                            {
                              SendMessage(*v96, PermissionAutoPermissionMessage, 0);
                            }
                          }
                          ++v96;
                          ++v217;
                        }
                        while ( v217 < arenaa->ArenaPlayerCount );
                      }
                    }
                  }
                }
                v15 = ++v204 < a3a;
                ++v206;
              }
              while ( v15 );
              v88 = v213;
            }
            v99 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v100 = arenaa->playerPointersForSomething;
              do
              {
                if ( !(*v100)->AlreadySentReliablePacket )
                  SendPlayerReliablePacket(*v100, buf, v88 - buf, 1);
                ++v99;
                ++v100;
              }
              while ( v99 < arenaa->ArenaPlayerCount );
            }
            dword_4C8F3C = 0;
          }
        }
      }
      goto LABEL_250;
    }
    if ( v75 && v75 != 1 || arenaa->ServersideArenaSettings.FlagReward <= 0 )
    {
LABEL_250:
      if ( arenaa->ServersideArenaSettings.PeriodicRewardDelay > 0 )
      {
        v133 = (GetTickCount() / 0xA - arenaa->GetTickCountValue4);
        if ( ((HIDWORD(v133) ^ v133) - HIDWORD(v133)) > arenaa->ServersideArenaSettings.PeriodicRewardDelay )
        {
          v134 = GetTickCount();
          v135 = arenaa->ServersideArenaSettings.PeriodicRewardMinimumPlayers;
          arenaa->GetTickCountValue4 = v134 / 0xA;
          v136 = arenaa->ArenaPlayerCount;
          if ( v136 > v135 )
          {
            v208 = 0;
            if ( arenaa->someCounterBefore > 0 )
            {
              v137 = v230;
              v214 = v230;
              a3b = &arenaa->gap_186A2[8];
              v138 = 0;
              v218 = arenaa->someCounterBefore;
              do
              {
                v139 = *a3b;
                if ( *a3b >= 0 )
                {
                  v140 = 0;
                  if ( v138 > 0 )
                  {
                    v141 = v229;
                    while ( *v141 != v139 )
                    {
                      ++v140;
                      ++v141;
                      if ( v140 >= v208 )
                        goto LABEL_262;
                    }
                    ++v228[v140];
                  }
LABEL_262:
                  if ( v140 == v208 )
                  {
                    v229[v138] = v139;
                    v228[v138] = 1;
                    *v137 = 0;
                    if ( v136 > 0 )
                    {
                      v142 = arenaa->playerPointersForSomething;
                      v143 = v136;
                      do
                      {
                        v137 = v214;
                        if ( (*v142)->Frequency == v139 )
                          ++*v214;
                        ++v142;
                        --v143;
                      }
                      while ( v143 );
                    }
                    ++v138;
                    ++v137;
                    ++v208;
                    v214 = v137;
                  }
                }
                v85 = v218 == 1;
                a3b += 16;
                --v218;
              }
              while ( !v85 );
            }
            v144 = 0;
            buf[0] = 35;
            v145 = &buf[1];
            for ( i = 0; v144 < v208; i = v144 )
            {
              v146 = arenaa->ServersideArenaSettings.PeriodicRewardPoints;
              v147 = v228[v144];
              if ( v146 <= 0 )
                v148 = -(v136 * v146 * v147);
              else
                v148 = v146 * v147;
              if ( v148 > 0 )
              {
                v149 = &v229[v144];
                *v145 = *v149;
                v150 = (v145 + 2);
                v151 = v148;
                if ( v148 >= 30000 )
                  v151 = 30000;
                *v150 = v151;
                v145 = (v150 + 1);
                v215 = v145;
                v219 = 0;
                if ( v136 > 0 )
                {
                  v152 = arenaa->playerPointersForSomething;
                  *v224 = *v149;
                  do
                  {
                    v153 = *v152;
                    if ( *(*v152 + 279) == *v224 && *(v153 + 275) != 8 && (*(v153 + 231) & 0x20) == 0 )
                    {
                      v154 = *(v153 + 553) + *(v153 + 557);
                      UpdatePoints(v153, 0, v148);
                      if ( v154 < AutoPermissionPoints
                        && AutoPermissionPoints > 0
                        && *(*v152 + 553) + *(*v152 + 557) >= AutoPermissionPoints )
                      {
                        SendMessage(*v152, PermissionAutoPermissionMessage, 0);
                      }
                    }
                    v136 = arenaa->ArenaPlayerCount;
                    ++v152;
                    ++v219;
                  }
                  while ( v219 < v136 );
                  v145 = v215;
                  v144 = i;
                }
              }
              v144 = (v144 + 1);
            }
            v155 = 0;
            if ( arenaa->ArenaPlayerCount > 0 )
            {
              v156 = arenaa->playerPointersForSomething;
              do
              {
                if ( !(*v156)->AlreadySentReliablePacket )
                  SendPlayerReliablePacket(*v156, buf, v145 - buf, 1);
                ++v155;
                ++v156;
              }
              while ( v155 < arenaa->ArenaPlayerCount );
            }
            dword_4C8F3C = 0;
          }
        }
      }
      goto LABEL_295;
    }
    v101 = -1;
    v207 = -1;
    if ( v75 )
    {
      v108 = *&arenaa->gap_186A2[8];
      v109 = &arenaa->gap_186A2[8];
      if ( v108 < 0 || *&arenaa->gap_186A2[4] != -1 )
        goto LABEL_204;
      for ( j = 0; j < v74; ++j )
      {
        if ( *(v109 - 1) != -1 )
          break;
        if ( *v109 != v108 )
          break;
        v109 += 16;
      }
      if ( j != v74 )
        goto LABEL_204;
      v101 = *&arenaa->gap_186A2[8];
    }
    else
    {
      v102 = *&arenaa->gap_186A2[4];
      if ( v102 < 0 )
        goto LABEL_204;
      v103 = PlayerList[v102];
      if ( !v103 )
        goto LABEL_204;
      v104 = v103->Frequency;
      v105 = 1;
      if ( v74 > 1 )
      {
        v106 = &arenaa->gap_186A2[20];
        do
        {
          if ( *v106 < 0 )
            break;
          v107 = PlayerList[*v106];
          if ( !v107 )
            break;
          if ( v107->Frequency != v104 )
            break;
          ++v105;
          v106 += 4;
        }
        while ( v105 < v74 );
      }
      if ( v105 != v74 )
        goto LABEL_204;
      v101 = v104;
    }
    v207 = v101;
LABEL_204:
    if ( v101 >= 0 )
    {
      v111 = arenaa->ArenaPlayerCount;
      v112 = 0;
      if ( v111 > 0 )
      {
        v113 = arenaa->playerPointersForSomething;
        do
        {
          if ( (*v113)->Ship != 8 )
            ++v112;
          ++v113;
          --v111;
        }
        while ( v111 );
      }
      v114 = arenaa->ServersideArenaSettings.RandomFlags;
      arenaa->someCounterBefore = 0;
      if ( v114 && arenaa->ServersideArenaSettings.MaxFlags > 0 )
        *arenaa->gap_FF6A = rand() % arenaa->ServersideArenaSettings.MaxFlags + 1;
      else
        *arenaa->gap_FF6A = arenaa->ServersideArenaSettings.MaxFlags;
      v115 = GetTickCount();
      v116 = arenaa->ServersideArenaSettings.FlagReward * v112 * v112;
      v224[0] = 0x14;                           // 0x14  Flag Victory
      *&v224[1] = v207;                         // Team
      arenaa->GetTickCountValue8 = v115 / 0xA;
      v117 = arenaa->ServersideArenaSettings.FlagRewardMode;
      v118 = arenaa->ArenaJackpot + v116 / 1000;
      arenaa->ArenaJackpot = 0;
      *&v224[3] = v118;                         // Jackpot Points
      if ( v117 == 1 )
      {
        v119 = 0;
        if ( arenaa->ArenaPlayerCount > 0 )
        {
          v120 = arenaa->playerPointersForSomething;
          v121 = arenaa->ArenaPlayerCount;
          do
          {
            v122 = *v120;
            if ( (*v120)->Frequency == v207 && v122->Ship != 8 && (v122->ShipTogglables & 0x20) == 0 )
              ++v119;
            ++v120;
            --v121;
          }
          while ( v121 );
        }
        if ( v119 <= arenaa->ArenaSettings.MaxPerTeam >> 1 )
          v119 = arenaa->ArenaSettings.MaxPerTeam >> 1;
        *&v224[3] = arenaa->ArenaSettings.MaxPerTeam * v118 / v119;// Jackpot Points
      }
      v123 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v124 = arenaa->playerPointersForSomething;
        do
        {
          if ( !(*v124)->AlreadySentReliablePacket )
            SendPlayerReliablePacket(*v124, v224, 7u, 1);
          ++v123;
          ++v124;
        }
        while ( v123 < arenaa->ArenaPlayerCount );
      }
      v125 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v126 = arenaa->playerPointersForSomething;
        do
        {
          v127 = *v126;
          if ( (*v126)->Frequency == v207 && v127->Ship != 8 && (v127->ShipTogglables & 0x20) == 0 )
          {
            v128 = v127->KillPoints + v127->FlagPoints;
            UpdatePoints(v127, 0, *&v224[3]);
            ++(*v126)->GoalCount;
            if ( !arenaa->ServersideArenaSettings.MiscTimedGame )
            {
              if ( arenaa->bHasScrFile )
              {
                v129 = (*v126)->field_15F;
                if ( v129 >= 0 )
                {
                  v130 = &(*v126)->CurrentWins;
                  v131 = arenaa->FileContentsMemoryPointer + 18 * v129 + 4;
                  *v131 = *v130;
                  *(v131 + 4) = *(v130 + 4);
                  *(v131 + 8) = *(v130 + 8);
                  *(v131 + 12) = *(v130 + 12);
                }
              }
              else if ( BillingConnectionStructPointer && arenaa->bRecordPointsToLog )
              {
                SendBillerUserScorePacket(
                  BillingConnectionStructPointer,
                  (*v126)->BillerPlayerId,
                  &(*v126)->CurrentWins,
                  0xEu);
              }
            }
            if ( v128 < AutoPermissionPoints
              && AutoPermissionPoints > 0
              && (*v126)->KillPoints + (*v126)->FlagPoints >= AutoPermissionPoints )
            {
              SendMessage(*v126, PermissionAutoPermissionMessage, 0);
            }
          }
          ++v125;
          ++v126;
        }
        while ( v125 < arenaa->ArenaPlayerCount );
      }
      dword_4C8F3C = 0;
    }
    v132 = (GetTickCount() / 0xA - arenaa->GetTickCountValue8);
    if ( ((HIDWORD(v132) ^ v132) - HIDWORD(v132)) > arenaa->ServersideArenaSettings.FlagResetDelay )
      ResetFlagGame(arenaa);
    goto LABEL_250;
  }
LABEL_358:
  v220 = 0;
  if ( arenaa->TotalSoccerBalls > 0 )
  {
    v193 = arenaa->SoccerBallTimers;
    v194 = &arenaa->SoccerBalls[0].PlayerId;
    i = arenaa->SoccerBallTimers;
    do
    {
      if ( abs32(GetTickCount() / 0xA - *v193) > arenaa->ServersideArenaSettings.SoccerSendTime )
      {
        if ( !*(v194 + 1) && *v194 >= 0 )
        {
          v195 = PlayerList[*v194];
          if ( v195 )
          {
            *(v194 - 4) = v195->XPixels;
            *(v194 - 3) = v195->YPixels;
          }
        }
        *v193 = GetTickCount() / 0xA;
        v196 = 0;
        buff[0] = 0x2E;                         // 0x2E - Power-Ball Position Update
        *&buff[1] = *(v194 - 9);                // Powerball ID
        *&buff[5] = *(v194 - 5);
        *&buff[9] = *(v194 - 1);
        v197 = arenaa->ArenaPlayerCount;
        v198 = *(v194 + 5);
        *&buff[13] = *(v194 + 3);
        buff[15] = v198;
        if ( v197 > 0 )
        {
          v199 = arenaa->playerPointersForSomething;
          do
          {
            if ( !(*v199)->AlreadySentReliablePacket )
              SendPlayerReliablePacket(*v199, buff, 0x10u, 0);
            ++v196;
            ++v199;
          }
          while ( v196 < arenaa->ArenaPlayerCount );
        }
      }
      v193 = i + 1;
      v194 = (v194 + 15);
      v15 = ++v220 < arenaa->TotalSoccerBalls;
      ++i;
    }
    while ( v15 );
  }
  return arenaa->ArenaPlayerCount == 0;
}
// 4033B7: conditional instruction was optimized away because of 'eax.4==1'
// 4033D5: conditional instruction was optimized away because of 'esi.4>=1'
// 42A18F: using guessed type int unk_42A18F();
// 42A1DF: using guessed type int xmmword_42A1DF();
// 431FF4: using guessed type int ArenaArrayLength;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 402560: using guessed type int var_1C00[384];
// 402560: using guessed type int var_1600[384];
// 402560: using guessed type int var_2200[384];

//----- (00403F60) --------------------------------------------------------
int __cdecl PtFuncCompare(int a1, int a2)
{
  return *(*a2 + 553) + *(*a2 + 557) - *(*a1 + 553) - *(*a1 + 557);
}

//----- (00403F90) --------------------------------------------------------
void __thiscall ArenaScoreReset(struct_ARENA *arenaa, int sendScoreReset)
{
  int v3; // eax
  int v4; // ecx
  struct_PLAYER **v5; // eax
  struct_PLAYER *v6; // edx
  int v7; // eax
  int v8; // ebp
  struct_PLAYER **player; // ebx

  v3 = arenaa->ArenaPlayerCount;
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = arenaa->playerPointersForSomething;
    do
    {
      v6 = *v5;
      ++v4;
      ++v5;
      v6->DebtKills = arenaa->ServersideArenaSettings.KillDebtKills;
      (*(v5 - 1))->CurrentLosses = 0;
      (*(v5 - 1))->CurrentWins = 0;
      (*(v5 - 1))->KillPoints = 0;
      (*(v5 - 1))->FlagPoints = 0;
      (*(v5 - 1))->GoalCount = 0;
    }
    while ( v4 < arenaa->ArenaPlayerCount );
  }
  if ( sendScoreReset )
  {
    v7 = arenaa->ArenaPlayerCount;
    v8 = 0;
    LOBYTE(sendScoreReset) = 0x1A;              // 0x1A - Reset Score(s)
    *(&sendScoreReset + 1) = -1;
    if ( v7 > 0 )
    {
      player = arenaa->playerPointersForSomething;
      do
      {
        if ( !(*player)->AlreadySentReliablePacket )
          SendPlayerReliablePacket(*player, &sendScoreReset, 3u, 1);
        ++v8;
        ++player;
      }
      while ( v8 < arenaa->ArenaPlayerCount );
    }
  }
}

//----- (00404050) --------------------------------------------------------
void __thiscall CreateSoccerBall(struct_ARENA *arenaa, int PowerBallId)
{
  int v3; // eax
  __int16 v4; // cx
  int v5; // esi
  __int16 v6; // ax
  int ReturnXTile; // [esp+Ch] [ebp-8h] BYREF
  int ReturnYTile; // [esp+10h] [ebp-4h] BYREF

  v3 = arenaa->ArenaSettings.PrizeMinimumVirtual + arenaa->ArenaSettings.PrizeUpgradeVirtual * arenaa->ArenaPlayerCount;
  if ( v3 >= 1024 )
    v3 = 1024;
  SomethingWithPrizes(arenaa, &ReturnXTile, &ReturnYTile, 512, 512, v3 / 2);
  v4 = 16 * ReturnYTile;
  v5 = arenaa + 12 * PowerBallId + 3 * PowerBallId;
  v6 = 16 * ReturnXTile;
  *(v5 + 65394) = PowerBallId;
  *(v5 + 65395) = v6;
  *(v5 + 65397) = v4;
  *(v5 + 65399) = 0;
  *(v5 + 65401) = 0;
  *(v5 + 65403) = -1;
  *(v5 + 65405) = GetTickCount() / 0xA;
  arenaa->SoccerBallTimers[PowerBallId] = 0;
}

//----- (00404120) --------------------------------------------------------
void __thiscall FlagPositionUpdateSomething(struct_ARENA *arenaa, int a2)
{
  int *v3; // esi
  int v4; // ebx
  int v5; // eax
  BOOL v6; // eax
  int v7; // eax
  __int16 XTiles; // cx
  __int16 YTiles; // dx
  int v10; // eax
  int v11; // ebp
  struct_PLAYER **player; // ebx
  int FlagId; // [esp+4h] [ebp-10h]
  char buf[9]; // [esp+8h] [ebp-Ch] BYREF

  FlagId = 0;
  if ( arenaa->someCounterBefore > 0 )
  {
    v3 = &arenaa->Pointer;
    do
    {
      v4 = *v3;
      v6 = 1;
      if ( *v3 >= 0 )
      {
        v5 = v3[1];
        if ( v5 >= 0 && v4 < 1024 && v5 < 1024 )
          v6 = 0;
      }
      if ( v3[2] == -1 && (a2 || v6) )
      {
        if ( v6 )
        {
          if ( v4 == -1 || !arenaa->ServersideArenaSettings.FlagTerritoryRadius )
          {
            v7 = arenaa->ArenaSettings.PrizeMinimumVirtual
               + arenaa->ArenaSettings.PrizeUpgradeVirtual * arenaa->ArenaPlayerCount;
            if ( v7 >= 1024 )
              v7 = 1024;
            SomethingWithPrizes(arenaa, v3, (v3 + 1), 512, 512, v7 / 2);
          }
          else
          {
            SomethingWithPrizes(
              arenaa,
              v3,
              (v3 + 1),
              abs32(v4),
              abs32(v3[1]),
              arenaa->ServersideArenaSettings.FlagTerritoryRadius);
          }
        }
        XTiles = *v3;
        YTiles = *(v3 + 2);
        *&buf[7] = *(v3 + 6);                   // Owner Frequency
        v10 = arenaa->ArenaPlayerCount;
        *&buf[3] = XTiles;                      // X Tiles
        v11 = 0;
        buf[0] = 0x12;                          // 0x12 - Flag Position
        *&buf[5] = YTiles;                      // Y Tiles
        *&buf[1] = FlagId;                      // Flag ID
        if ( v10 > 0 )
        {
          player = arenaa->playerPointersForSomething;
          do
          {
            if ( !(*player)->AlreadySentReliablePacket )
              SendPlayerReliablePacket(*player, buf, 9u, 1);
            ++v11;
            ++player;
          }
          while ( v11 < arenaa->ArenaPlayerCount );
        }
      }
      v3 += 4;
      ++FlagId;
    }
    while ( FlagId < arenaa->someCounterBefore );
  }
}

//----- (00404280) --------------------------------------------------------
void __thiscall CarryFlagsSomething(struct_ARENA *arenaa, int PlayerId, int FlagMode)
{
  int v3; // ebx
  struct_PLAYER *player; // ecx
  unsigned int v6; // esi
  unsigned int v7; // eax
  int XCoordinate; // ebp
  int YCoordinate; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // edx
  int v14; // eax
  int v15; // edx
  char *v16; // ecx
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = PlayerId;
  if ( PlayerId >= 0 && arenaa->ArenaSettings.CarryFlags )
  {
    player = PlayerList[PlayerId];
    v6 = -1;
    v7 = -1;
    if ( player )
    {
      XCoordinate = player->XPixels / 16;
      YCoordinate = player->YPixels / 16;
      if ( arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid )
      {
        v17 = 0;
        while ( 1 )
        {
          v10 = arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid;
          v11 = 2 * (rand() % v10) - v10;
          if ( v11 + XCoordinate > 1 && v11 + XCoordinate < 1024 )
            break;
          if ( ++v17 >= 50 )
            goto LABEL_11;
        }
        XCoordinate += v11;
LABEL_11:
        v18 = 0;
        while ( 1 )
        {
          v12 = arenaa->ServersideArenaSettings.FlagTerritoryRadiusCentroid;
          v13 = rand() % (2 * v12) - v12;
          if ( v13 + YCoordinate > 1 && v13 + YCoordinate < 1024 )
            break;
          if ( ++v18 >= 50 )
            goto LABEL_17;
        }
        YCoordinate += v13;
      }
LABEL_17:
      v14 = YCoordinate;
      v3 = PlayerId;
      v6 = -abs32(XCoordinate);
      v7 = -abs32(v14);
    }
    v15 = 0;
    if ( arenaa->someCounterBefore > 0 )
    {
      v16 = &arenaa->gap_186A2[4];
      do
      {
        if ( *v16 == v3 )
        {
          if ( !FlagMode )
            *(v16 + 1) = -1;
          *v16 = -1;
          *(v16 - 2) = v6;
          *(v16 - 1) = v7;
        }
        ++v15;
        v16 += 16;
      }
      while ( v15 < arenaa->someCounterBefore );
    }
  }
}

//----- (004043C0) --------------------------------------------------------
// Arena.ResetFlagGame()
void __thiscall ResetFlagGame(struct ARENA *arenaa)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // edi
  char *v7; // ecx
  __int16 *v8; // eax
  int v9; // edx
  __int16 v10; // bp
  unsigned int v11; // ebp
  int v12; // edi
  struct PLAYER **v13; // ebx
  int v14; // eax
  DWORD v15; // kr00_4
  int v16; // eax
  struct PLAYER **v17; // edi
  unsigned __int8 v18[7]; // [esp+10h] [ebp-1008h] BYREF
  char buf; // [esp+18h] [ebp-1000h] BYREF
  char v20; // [esp+19h] [ebp-FFFh] BYREF

  v2 = 0;
  v3 = *(arenaa + 109746);
  *(arenaa + 65382) = 0;
  if ( v3 == 2 )
  {
    v4 = 0;
    if ( *(arenaa + 108190) > 0 )
    {
      v5 = (arenaa + 100010);
      do
      {
        *v5 = -1;
        ++v4;
        v5 += 4;
      }
      while ( v4 < *(arenaa + 108190) );
    }
    v6 = *(arenaa + 108190);
    buf = 0x22;                                 // 0x22 - Turf Flag Update
    v7 = &v20;
    if ( v6 > 0 )
    {
      v8 = (arenaa + 100010);
      v9 = v6;
      do
      {
        v10 = *v8;
        v8 += 8;
        *v7 = v10;
        v7 += 2;
        --v9;
      }
      while ( v9 );
    }
    v11 = 2 * v6 + 1;
    v12 = 0;
    if ( *(arenaa + 16323) > 0 )
    {
      v13 = (arenaa + 64288);
      do
      {
        if ( !*(*v13 + 14) )
          SendPlayerReliablePacket(*v13, &buf, v11, 1);
        ++v12;
        ++v13;
      }
      while ( v12 < *(arenaa + 16323) );
    }
  }
  else
  {
    v14 = *(arenaa + 109710);
    *(arenaa + 108190) = 0;
    if ( v14 && *(arenaa + 109714) > 0 )
      *(arenaa + 65386) = rand() % *(arenaa + 109714) + 1;
    else
      *(arenaa + 65386) = *(arenaa + 109714);
    v15 = GetTickCount();
    v16 = *(arenaa + 16323);
    v18[0] = 0x14;                              // 0x14 - Flag Victory
    *(arenaa + 65346) = v15 / 0xA;
    *&v18[1] = -1;                              // Team
    *&v18[3] = 0;                               // Jackpot Points
    if ( v16 > 0 )
    {
      v17 = (arenaa + 64288);
      do
      {
        if ( !*(*v17 + 14) )
          SendPlayerReliablePacket(*v17, v18, 7u, 1);
        ++v2;
        ++v17;
      }
      while ( v2 < *(arenaa + 16323) );
    }
  }
}

//----- (00404530) --------------------------------------------------------
int __thiscall GetNextFrequencyToJoin(struct_ARENA *arena)
{
  int TotalPlaying; // ebp
  struct_PLAYER **eachPlayer; // edx
  int ArenaPlayerCount; // esi
  int Frequency; // eax
  int CurrentFrequency; // esi
  int *NumPlayersPerFreqArrayy; // edi
  int NumPlayersThisFreq; // ecx
  int TotalPlayingg; // [esp+10h] [ebp-324h]
  int NumPlayersPerFreqArray[200]; // [esp+14h] [ebp-320h] BYREF

  memset(NumPlayersPerFreqArray, 0, sizeof(NumPlayersPerFreqArray));
  TotalPlaying = 0;
  TotalPlayingg = 0;
  if ( arena->ArenaPlayerCount > 0 )
  {
    eachPlayer = arena->playerPointersForSomething;// Obviously Player Pointers but why only 251? If possible 1025 players
    ArenaPlayerCount = arena->ArenaPlayerCount;
    do
    {
      Frequency = (*eachPlayer)->Frequency;
      if ( Frequency >= 0 && (*eachPlayer)->Ship != 8 )
      {
        if ( Frequency < 200 )
          ++NumPlayersPerFreqArray[Frequency];
        ++TotalPlaying;
      }
      ++eachPlayer;
      --ArenaPlayerCount;
    }
    while ( ArenaPlayerCount );
    TotalPlayingg = TotalPlaying;
  }
  CurrentFrequency = 0;
  for ( NumPlayersPerFreqArrayy = NumPlayersPerFreqArray; ; ++NumPlayersPerFreqArrayy )
  {
    if ( CurrentFrequency >= arena->ArenaSettings.MaxFrequency )
      return rand() % arena->ArenaSettings.MaxFrequency;
    NumPlayersThisFreq = *NumPlayersPerFreqArrayy;
    if ( !*NumPlayersPerFreqArrayy
      || NumPlayersThisFreq < arena->ArenaSettings.MaxPerTeam
      && NumPlayersThisFreq <= TotalPlayingg / arena->ServersideArenaSettings.TeamDesiredTeams )
    {
      break;
    }
    if ( ++CurrentFrequency >= 200 )
      return rand() % arena->ArenaSettings.MaxFrequency;
  }
  return CurrentFrequency;
}
// 404530: using guessed type int NumPlayersPerFreqArray[200];

//----- (00404600) --------------------------------------------------------
// Arena.SendPacket()
void __thiscall ArenaSendPacket(struct_ARENA *arenaa, char *buf, int len, int a4)
{
  int v5; // edi
  struct_PLAYER **v6; // esi

  v5 = 0;
  if ( arenaa->ArenaPlayerCount > 0 )
  {
    v6 = arenaa->playerPointersForSomething;
    do
    {
      if ( !(*v6)->AlreadySentReliablePacket )
        SendPlayerReliablePacket(*v6, buf, len, a4);
      ++v5;
      ++v6;
    }
    while ( v5 < arenaa->ArenaPlayerCount );
  }
}

//----- (00404650) --------------------------------------------------------
void __thiscall SomethingWithPrizes(struct_ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius)
{
  int v6; // ebp
  int v7; // ebx
  int v8; // eax
  int v9; // edi
  int v10; // ebp
  struct_ARENA *v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  struct_ARENA *v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ecx
  char *v31; // eax
  int v33; // [esp+14h] [ebp-Ch]
  int v34; // [esp+18h] [ebp-8h]
  int v35; // [esp+2Ch] [ebp+Ch]
  int v36; // [esp+30h] [ebp+10h]
  int v37; // [esp+34h] [ebp+14h]
  int v38; // [esp+34h] [ebp+14h]
  int v39; // [esp+34h] [ebp+14h]
  int v40; // [esp+34h] [ebp+14h]
  int v41; // [esp+34h] [ebp+14h]
  int v42; // [esp+34h] [ebp+14h]

  v6 = 2 * Radius;
  v7 = YStart - Radius;
  v8 = XStart - YStart;
  v34 = 0;
  v33 = 2 * Radius;
  v36 = YStart - Radius;
  v35 = v8;
  while ( 1 )
  {
    v9 = (v7 + v8 < 0 ? 0 : v7 + v8) + rand() % v6;
    v10 = (v7 < 0 ? 0 : v7) + rand() % v6;
    if ( v9 < 0 || v10 < 0 || v9 >= 1024 || v10 >= 1024 )
    {
      v11 = arena;
      v37 = 1;
    }
    else
    {
      v11 = arena;
      v37 = *(arena->field_1D40A + (v10 << 10) + v9);
    }
    v12 = v9 + 1;
    if ( v9 + 1 < 0 || v10 < 0 || v12 >= 1024 || v10 >= 1024 )
      v13 = 1;
    else
      v13 = *(v11->field_1D40A + (v10 << 10) + v12);
    v14 = v13 + v37;
    v15 = v9 - 1;
    if ( v9 - 1 < 0 || v10 < 0 || v15 >= 1024 || v10 >= 1024 )
      v16 = 1;
    else
      v16 = *(v11->field_1D40A + (v10 << 10) + v15);
    v38 = v16 + v14;
    v17 = v10 + 1;
    if ( v9 < 0 || v17 < 0 || v9 >= 1024 || v17 >= 1024 )
      v18 = 1;
    else
      v18 = *(v11->field_1D40A + (v17 << 10) + v9);
    v19 = v18 + v38;
    v20 = v10 - 1;
    if ( v9 < 0 || v20 < 0 || v9 >= 1024 || v20 >= 1024 )
      v21 = 1;
    else
      v21 = *(v11->field_1D40A + (v20 << 10) + v9);
    v39 = v21 + v19;
    if ( v12 < 0 || v17 < 0 || v12 >= 1024 || v17 >= 1024 )
      v22 = 1;
    else
      v22 = *(arena->field_1D40A + (v17 << 10) + v12);
    v40 = v22 + v39;
    if ( v12 < 0 || v20 < 0 || v12 >= 1024 || v20 >= 1024 )
      v23 = 1;
    else
      v23 = *(arena->field_1D40A + (v20 << 10) + v12);
    v24 = v23 + v40;
    v25 = v9 - 1;
    if ( v9 - 1 < 0 || v17 < 0 || v25 >= 1024 || v17 >= 1024 )
      v26 = 1;
    else
      v26 = *(arena->field_1D40A + (v17 << 10) + v25);
    v41 = v26 + v24;
    if ( v25 < 0 || v20 < 0 || v25 >= 1024 || v20 >= 1024 )
    {
      v27 = arena;
      v28 = 1;
    }
    else
    {
      v27 = arena;
      v28 = *(arena->field_1D40A + (v20 << 10) + v25);
    }
    v29 = v27->someCounterBefore;
    v42 = v28 + v41;
    v30 = 0;
    if ( v29 > 0 )
    {
      v31 = v27->gap_186A2;
      while ( *(v31 - 1) != v9 || *v31 != v10 )
      {
        ++v30;
        v31 += 16;
        if ( v30 >= v29 )
          goto LABEL_64;
      }
      ++v42;
    }
LABEL_64:
    if ( !v42 )
      v34 = 1;
    v7 = --v36;
    v33 += 2;
    if ( v34 )
      break;
    v8 = v35;
    v6 = v33;
  }
  *ReturnXTile = v9;
  *ReturnYTile = v10;
}

//----- (00404980) --------------------------------------------------------
void __thiscall sub_404980(struct_ARENA *this, struct_PLAYER *a2, __int64 a3)
{
  int v3; // eax
  char *v4; // esi
  int v5; // ecx
  struct_PLAYER **i; // edx
  int v7; // ecx

  if ( a3 >= 0 && a3 >= 0 && a3 < 8 && SHIDWORD(a3) < 8 )
  {
    v3 = 0;
    v4 = this + 8032 * a3 + 1004 * HIDWORD(a3);
    v5 = *(v4 + 250);
    if ( v5 > 0 )
    {
      for ( i = v4; *i != a2; ++i )
      {
        if ( ++v3 >= v5 )
          return;
      }
      v7 = v5 - 1;
      *(v4 + 250) = v7;
      *&v4[4 * v3] = *&v4[4 * v7];
    }
  }
}

//----- (004049F0) --------------------------------------------------------
void __thiscall AddPlayerToArenaSomething(struct_ARENA *arena, struct_PLAYER *player, signed int a3, signed int a4)
{
  int v4; // eax
  struct_PLAYER **v5; // edx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = a4 + 8 * a3;
    v5 = &arena->PlayerPointers[251 * v4 + 250];
    arena->PlayerPointers[*v5 + 251 * v4] = player;
    *v5 = (*v5 + 1);
  }
}

//----- (00404A50) --------------------------------------------------------
void __thiscall LoadArenaSettings(struct_ARENA *arenaa)
{
  char *v2; // esi
  int v3; // eax
  int v4; // esi

  v2 = arenaa->szConfigFile;
  if ( _strcmpi(arenaa->szConfigFile, FileName2) )
  {
    IsFileLastWrittenTime(v2, arenaa->dwLastConfigReadTime);
    LoadZoneCFGSettings(&arenaa->ArenaSettings, &arenaa->ServersideArenaSettings, v2);
  }
  else
  {
    qmemcpy(&arenaa->ArenaSettings, &ArenaSettings, sizeof(arenaa->ArenaSettings));// Arena Settings
    qmemcpy(&arenaa->ServersideArenaSettings, &ServersideArenaSettings, sizeof(arenaa->ServersideArenaSettings));// Arena Serverside Settings (Never sent to Continuum)
  }
  v3 = 0;
  *&arenaa->dwLastConfigReadTime[8] = (arenaa->ArenaSettings.MapZoomFactor << 14) / 96;
  *&arenaa->dwLastConfigReadTime[4] = 0;
  do
  {
    v4 = arenaa->ArenaSettings.SomeUnknownStuffToo[v3 + 7] + *&arenaa->dwLastConfigReadTime[4];
    ++v3;
    *&arenaa->dwLastConfigReadTime[4] = v4;
  }
  while ( v3 < 29 );
}
/* Orphan comments:
If fail occurs (arena.cfg is missing) uses default server.cfg settings.
Attempt to load arena settings from file
*/

//----- (00404B10) --------------------------------------------------------
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this)
{
  char *v2; // ebx
  int v3; // esi
  struct BMP_FILE_STRUCT *v4; // edi
  int v5; // ebx
  int v6; // eax
  struct BMP_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct BMP_FILE_STRUCT *v9; // esi
  void *v10; // edi
  int v11; // edi
  int v12; // ebx
  int v13; // ecx
  unsigned int v14; // edx
  int tileYCounter; // edi
  int tileXCounter; // esi
  int YCoordinate; // ecx
  int v18; // eax
  _BYTE *v19; // eax
  int v20; // [esp+10h] [ebp-2Ch] BYREF
  int TileValuePointer; // [esp+14h] [ebp-28h] BYREF
  struct BMP_FILE_STRUCT *i; // [esp+18h] [ebp-24h]
  int a4[4]; // [esp+1Ch] [ebp-20h] BYREF
  char v24; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  v2 = this->szLevelFile1;
  if ( _strcmpi(MiscDefaultLevelFile, this->szLevelFile1) )
  {
    a4[0] = 42;
    a4[1] = 0;
    a4[2] = 0;
    a4[3] = 0;
    v24 = 0;
    strcpy(a4 + 1, v2);
    *&this->dwLastConfigReadTime[12] = CompressFile(
                                         v2,
                                         &this->dwLastConfigReadTime[16],
                                         &this->dwLastConfigReadTime[20],
                                         a4,
                                         0x11u,
                                         1,
                                         0);
    v7 = operator new(0x110u);
    i = v7;
    v25 = 0;
    if ( v7 )
    {
      LoadBMPHeader(v7, v2);
      v9 = v8;
      TileValuePointer = v8;
    }
    else
    {
      TileValuePointer = 0;
      v9 = 0;
    }
    v25 = -1;
    this->someCounterAfter = 0;
    v10 = emalloc(0x100000);
    this->field_1D40A = v10;
    memset(v10, 0, 0x100000u);
    v11 = sub_406BE0(v9);
    v12 = 0;
    for ( i = v11; v12 < v11; ++v12 )
    {
      GetTileValue(v9, v12, &v20);
      if ( (v20 & 0xFF000000) == 0xAA000000 )
      {
        v13 = this->someCounterAfter;
        if ( v13 < 510 )
        {
          *&this->dwLastConfigReadTime[16 * v13 + 24] = v20 & 0xFFF;// Y Coord
          *&this->dwLastConfigReadTime[16 * this->someCounterAfter++ + 28] = (v20 >> 12) & 0xFFF;// X Coord
        }
      }
      else
      {
        *((v20 & 0xFFF) + (((v20 >> 12) & 0xFFF) << 10) + this->field_1D40A) = HIBYTE(v20);
        v14 = v20;
        if ( (v20 & 0xFF000000) >= 0xD8000000 )
        {
          for ( tileYCounter = 0; tileYCounter < 7; ++tileYCounter )
          {
            for ( tileXCounter = 0; tileXCounter < 7; ++tileXCounter )
            {
              YCoordinate = tileYCounter + (v14 & 0xFFF);// Y Coord
              v18 = tileXCounter + ((v14 >> 12) & 0xFFF);// X Coord
              if ( YCoordinate < 1024 && v18 < 1024 )
              {
                v19 = (this->field_1D40A + YCoordinate + (v18 << 10));// getLinear Y | X
                if ( !*v19 )
                {
                  *v19 = 240;
                  v14 = v20;
                }
              }
            }
          }
          v11 = i;
          v9 = TileValuePointer;
        }
      }
    }
    if ( v9 )
    {
      sub_406B30(v9);
      operator delete(v9);
    }
  }
  else
  {
    v3 = 0;
    *&this->dwLastConfigReadTime[12] = dword_437B0C;
    *&this->dwLastConfigReadTime[16] = dword_4D8AF0;
    *&this->dwLastConfigReadTime[20] = CRC_32;
    this->field_1D40A = MapAllocateMemoryPointer;
    this->someCounterAfter = 0;
    v4 = BMPFile;
    v5 = sub_406BE0(BMPFile);
    if ( v5 > 0 )
    {
      do
      {
        GetTileValue(v4, v3, &TileValuePointer);
        if ( (TileValuePointer & 0xFF000000) == 0xAA000000 )
        {
          v6 = this->someCounterAfter;
          if ( v6 < 510 )
          {
            *&this->dwLastConfigReadTime[16 * v6 + 24] = TileValuePointer & 0xFFF;// X Coord
            *&this->dwLastConfigReadTime[16 * this->someCounterAfter++ + 28] = (TileValuePointer >> 12) & 0xFFF;// Y Coord
          }
        }
        ++v3;
      }
      while ( v3 < v5 );
    }
  }
}
/* Orphan comments:
Tile Type +1 ?
*/
// 404C9E: variable 'v8' is possibly undefined

//----- (00404E20) --------------------------------------------------------
int __thiscall GetDeathPrizeGreenId(struct_ARENA *arena)
{
  int limitValue; // edx
  int increasingValue; // ecx
  int iterationsBreakAtCounter; // esi
  int result; // eax
  int v6; // edx

  limitValue = rand() % *&arena->dwLastConfigReadTime[4];
  increasingValue = 0;
  iterationsBreakAtCounter = 0;
  while ( 1 )
  {
    if ( arena->ArenaSettings.SomeUnknownStuffToo[iterationsBreakAtCounter + 7] )
    {
      if ( limitValue >= increasingValue )
      {
        increasingValue += arena->ArenaSettings.SomeUnknownStuffToo[iterationsBreakAtCounter + 7];
        if ( limitValue < increasingValue )
          break;
      }
    }
    if ( ++iterationsBreakAtCounter >= 29 )
      return 0;
  }
  v6 = rand() % arena->ArenaSettings.PrizeNegativeFactor;
  result = iterationsBreakAtCounter;
  if ( !v6 )
    result = -iterationsBreakAtCounter;
  return result;
}

//----- (00404E80) --------------------------------------------------------
signed int __thiscall ChangeSettings(struct_ARENA *arenaa, struct_PLAYER *player, const CHAR *a3)
{
  const CHAR *v3; // eax
  CHAR v4; // cl
  CHAR *i; // edx
  CHAR v6; // cl
  CHAR v8; // cl
  const CHAR *v9; // eax
  CHAR *j; // edx
  CHAR v11; // cl
  int v12; // ebp
  int v13; // edi
  int v14; // ebx
  TemplateSSS_Struct *v15; // esi
  char *v16; // esi
  int v17; // [esp+10h] [ebp-514h]
  int v18; // [esp+14h] [ebp-510h]
  int v20; // [esp+1Ch] [ebp-508h]
  int v21; // [esp+20h] [ebp-504h]
  char Str2[256]; // [esp+24h] [ebp-500h] BYREF
  CHAR KeyName[256]; // [esp+124h] [ebp-400h] BYREF
  CHAR Str[256]; // [esp+224h] [ebp-300h] BYREF
  CHAR Str1[256]; // [esp+324h] [ebp-200h] BYREF
  char Dest[256]; // [esp+424h] [ebp-100h] BYREF

  v3 = a3;
  v4 = *a3;
  for ( i = Str1; v4; ++v3 )
  {
    if ( v4 == ':' )
      break;
    *i = v4;
    v4 = v3[1];
    ++i;
  }
  v6 = *v3;
  *i = 0;
  if ( !v6 )
    return 1;
  v8 = v3[1];
  v9 = v3 + 1;
  for ( j = KeyName; v8; ++v9 )
  {
    if ( v8 == ':' )
      break;
    *j = v8;
    v8 = v9[1];
    ++j;
  }
  v11 = *v9;
  *j = 0;
  if ( !v11 )
    return 1;
  v12 = 0;
  strcpy(Str, v9 + 1);
  if ( !player->isSysop )
  {
    strcpy(Str2, Str1);
    if ( !_strcmpi(Str2, &shipsArray[64])
      || !_strcmpi(Str2, &shipsArray[56])
      || !_strcmpi(Str2, &shipsArray[48])
      || !_strcmpi(Str2, &shipsArray[36])
      || !_strcmpi(Str2, &shipsArray[28])
      || !_strcmpi(Str2, &shipsArray[20])
      || !_strcmpi(Str2, &shipsArray[8])
      || !_strcmpi(Str2, shipsArray) )
    {
      strcpy(Str2, "All");
    }
    v18 = 0;
    v20 = 0;
    v17 = atoi(Str);
    v21 = 0;
    if ( TotalTemplateSSSEntries <= 0 )
    {
      v13 = v17;
      v14 = v17;
    }
    else
    {
      v13 = v17;
      v14 = v17;
      v15 = TotalTemplateSSSList;
      while ( 1 )
      {
        if ( (!_strcmpi(v15->SomeString32, Str2) || !_strcmpi(v15->SomeString32, Str1))
          && !_strcmpi(v15->KeyName, KeyName)
          && !v15->SomeChar1a )
        {
          v13 = v15->someInteger;
          v14 = v15->someInteger2;
          v12 = 1;
          v18 = v15->SomeChar1b;
          if ( v13 == -999 || v17 >= v13 && v17 <= v14 )
            break;
        }
        ++v15;
        if ( ++v21 >= TotalTemplateSSSEntries )
          goto LABEL_34;
      }
      v20 = 1;
    }
LABEL_34:
    if ( !v12 )
    {
      sprintf(Dest, "%s:%s is not a valid user parameter.", Str1, KeyName);
      SendMessage(player, Dest, 0);
      return 1;
    }
    if ( !v20 )
    {
      sprintf(Dest, "Valid range for parameter %s:%s is (%d through %d)", Str1, KeyName, v13, v14);
      SendMessage(player, Dest, 0);
      return 1;
    }
    if ( v18 )
    {
      arenaa->field_10026 = 1;
      if ( !_strcmpi(arenaa->szConfigFile, FileName2) )
        bRecycleServer = 1;
    }
  }
  arenaa->playerPointersForSomething[250] = 1;
  v16 = arenaa->szConfigFile;
  if ( !_strcmpi(arenaa->szConfigFile, FileName2) )
    dword_4D5920 = 1;
  if ( _strcmpi(Str1, "All") )
  {
    WritePrivateProfileStringA(Str1, KeyName, Str, v16);
  }
  else
  {
    WritePrivateProfileStringA(&shipsArray[64], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[56], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[48], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[36], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[20], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[28], KeyName, Str, v16);
    WritePrivateProfileStringA(&shipsArray[8], KeyName, Str, v16);
    WritePrivateProfileStringA(shipsArray, KeyName, Str, v16);
  }
  return 0;
}
// 432004: using guessed type int bRecycleServer;
// 4D5920: using guessed type int dword_4D5920;
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;

//----- (00405360) --------------------------------------------------------
int __thiscall sub_405360(struct_ARENA *this, int buf)
{
  ArenaScoreReset(this, buf);
  this->ScoreStructCounter = 0;
  this->GameTimePassedTwo = GetTickCount() / 0xA;
  this->field_FF20 = 0;
  return SoccerGameSomething(this, -1);
}

//----- (004053B0) --------------------------------------------------------
int __thiscall SoccerGameSomething(struct_ARENA *this, int a2)
{
  struct_PLAYER *player; // ebx
  int v4; // eax
  int v5; // eax
  struct_PLAYER **v6; // ecx
  struct_PLAYER *v7; // esi
  int SoccerCapturePoints; // eax
  int result; // eax
  __int16 *v10; // esi
  int v11; // ecx
  int v12; // edi
  struct_PLAYER **v13; // ebx
  int v14; // [esp+10h] [ebp-118h]
  int *v15; // [esp+10h] [ebp-118h]
  int v16; // [esp+14h] [ebp-114h]
  char buf[16]; // [esp+18h] [ebp-110h] BYREF
  char Dest[256]; // [esp+28h] [ebp-100h] BYREF

  if ( a2 >= 0 )
  {
    v14 = 0;
    if ( this->ArenaPlayerCount > 0 )
    {
      player = this->playerPointersForSomething;
      do
      {
        if ( *(player->unknownIthoughtItWasPlayerPointerDupe + 279) == a2
          && *(player->unknownIthoughtItWasPlayerPointerDupe + 216) > 0 )
        {
          sprintf(
            Dest,
            "Soccer game over.  Personal Reward: %d",
            *(player->unknownIthoughtItWasPlayerPointerDupe + 216));
          UpdatePoints(
            player->unknownIthoughtItWasPlayerPointerDupe,
            0,
            *(player->unknownIthoughtItWasPlayerPointerDupe + 216));
        }
        else
        {
          strcpy(Dest, aSoccerGameOver);
        }
        SendMessage(player->unknownIthoughtItWasPlayerPointerDupe, Dest, 103);
        LOBYTE(v4) = SendPlayerScoreUpdateAll(player->unknownIthoughtItWasPlayerPointerDupe);
        if ( !v4 )
          SendPlayerScoreUpdate(player->unknownIthoughtItWasPlayerPointerDupe);
        player = (player + 4);
        ++v14;
      }
      while ( v14 < this->ArenaPlayerCount );
    }
  }
  v5 = 0;
  if ( this->ArenaPlayerCount > 0 )
  {
    v6 = this->playerPointersForSomething;
    do
    {
      v7 = *v6;
      ++v5;
      ++v6;
      v7->MySoccerReward = 0;
    }
    while ( v5 < this->ArenaPlayerCount );
  }
  this->Freq1Score = 0;
  this->Freq2Score = 0;
  this->Freq3Score = 0;
  this->Freq4Score = 0;
  SoccerCapturePoints = this->ServersideArenaSettings.SoccerCapturePoints;
  if ( SoccerCapturePoints > 0 )
  {
    this->Freq1Score = SoccerCapturePoints;
    this->Freq2Score = SoccerCapturePoints;
    this->Freq3Score = SoccerCapturePoints;
    this->Freq4Score = SoccerCapturePoints;
  }
  result = 0;
  v16 = 0;
  if ( this->TotalSoccerBalls > 0 )
  {
    v10 = &this->SoccerBalls[0].YPixels;
    v15 = this->SoccerBallTimers;
    do
    {
      *(v10 - 3) = result;
      *(v10 - 1) = 0;
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      v10[3] = -1;
      *(v10 + 2) = 0;
      *v15 = 0;
      *&buf[1] = *(v10 - 3);
      *&buf[5] = *(v10 + 1);
      *&buf[9] = *(v10 + 5);
      *&buf[13] = *(v10 + 9);
      buf[15] = *(v10 + 11);
      v11 = this->ArenaPlayerCount;
      v12 = 0;
      buf[0] = 0x2E;                            // 0x2E - Power-Ball Position Update
      if ( v11 > 0 )
      {
        v13 = this->playerPointersForSomething;
        do
        {
          if ( !(*v13)->AlreadySentReliablePacket )
            SendPlayerReliablePacket(*v13, buf, 0x10u, 1);
          ++v12;
          ++v13;
        }
        while ( v12 < this->ArenaPlayerCount );
        result = v16;
      }
      ++result;
      v10 = (v10 + 15);
      v16 = result;
      ++v15;
    }
    while ( result < this->TotalSoccerBalls );
  }
  this->TotalSoccerBalls = 0;
  return result;
}
// 405467: variable 'v4' is possibly undefined

//----- (004055D0) --------------------------------------------------------
int __thiscall SoccerGame2(struct_ARENA *arena, int Frequency, int a3, int a4)
{
  int v5; // edi
  int v6; // ebx
  int v7; // ebp
  int SoccerCapturePoints; // eax
  int v9; // eax
  int v10; // edi
  struct_PLAYER **v11; // ebx
  int *i; // ecx
  int v13; // edx
  int v14; // ecx
  int *v15; // ecx

  v5 = -1;
  v6 = -1;
  v7 = 0;
  SoccerCapturePoints = SoccerRelatedMath(arena->ArenaSettings.SoccerMode, a3, a4);
  switch ( arena->ArenaSettings.SoccerMode )
  {
    case 1:
    case 2:
      v7 = 2;
      v5 = Frequency & 1;
      v6 = SoccerCapturePoints;
      break;
    case 3:
    case 5:
      v7 = 4;
      v5 = Frequency & 3;
      v6 = SoccerCapturePoints;
      break;
    case 4:
    case 6:
      v7 = 4;
      v5 = Frequency & 3;
      switch ( Frequency & 3 )
      {
        case 0:
          v6 = 3;
          break;
        case 1:
          v6 = 2;
          break;
        case 2:
          v6 = 1;
          break;
        case 3:
          v6 = 0;
          break;
        default:
          goto LABEL_9;
      }
      break;
    default:
      break;
  }
LABEL_9:
  if ( v5 >= 0 )
  {
    SoccerCapturePoints = arena->ServersideArenaSettings.SoccerCapturePoints;
    if ( SoccerCapturePoints <= 0 )
    {
      if ( SoccerCapturePoints < 0 )
      {
        ++arena->SoccerBallTimers[v5 + 8];
        GetScore(arena, 0);
        SoccerCapturePoints = arena->SoccerBallTimers[v5 + 8];
        if ( SoccerCapturePoints >= -arena->ServersideArenaSettings.SoccerCapturePoints )
        {
          v13 = arena->ServersideArenaSettings.SoccerWinBy;
          v14 = 1;
          if ( v13 > 0 )
          {
            SoccerCapturePoints = 0;
            if ( v7 > 0 )
            {
              v15 = &arena->Freq1Score;
              while ( SoccerCapturePoints == v5 || arena->SoccerBallTimers[v5 + 8] - *v15 >= v13 )
              {
                ++SoccerCapturePoints;
                ++v15;
                if ( SoccerCapturePoints >= v7 )
                {
                  v14 = 1;
                  goto LABEL_33;
                }
              }
              v14 = 0;
            }
          }
LABEL_33:
          if ( v14 )
            return SoccerGameSomething(arena, Frequency);
        }
      }
    }
    else
    {
      v9 = arena->SoccerBallTimers[v6 + 8];
      if ( v9 )
      {
        arena->SoccerBallTimers[v6 + 8] = v9 - 1;
        ++arena->SoccerBallTimers[v5 + 8];
      }
      else
      {
        v10 = 0;
        if ( arena->ArenaPlayerCount > 0 )
        {
          v11 = arena->playerPointersForSomething;
          do
          {
            SendMessage(*v11, "Enemy goal had no points to give.", 0);
            ++v10;
            ++v11;
          }
          while ( v10 < arena->ArenaPlayerCount );
        }
      }
      GetScore(arena, 0);
      SoccerCapturePoints = 0;
      if ( v7 > 0 )
      {
        for ( i = &arena->Freq1Score; *i != arena->ServersideArenaSettings.SoccerCapturePoints * v7; ++i )
        {
          if ( ++SoccerCapturePoints >= v7 )
            return SoccerCapturePoints;
        }
        return SoccerGameSomething(arena, Frequency);
      }
    }
  }
  return SoccerCapturePoints;
}

//----- (004057C0) --------------------------------------------------------
void __thiscall GetScore(struct_ARENA *arenaa, struct_PLAYER *player)
{
  char SoccerMode; // al
  int v4; // ebx
  struct_PLAYER **v5; // esi
  struct_PLAYER *v6; // ecx
  int v7; // [esp-8h] [ebp-214h]
  const char *v8; // [esp-8h] [ebp-214h]
  int v9; // [esp-4h] [ebp-210h]
  char Dest[256]; // [esp+Ch] [ebp-200h] BYREF
  char messageBuffer[256]; // [esp+10Ch] [ebp-100h] BYREF

  if ( arenaa->ServersideArenaSettings.SoccerBallCount > 0 && arenaa->ServersideArenaSettings.SoccerCapturePoints )
  {
    SoccerMode = arenaa->ArenaSettings.SoccerMode;
    if ( SoccerMode == 1 || SoccerMode == 2 )
    {
      v9 = arenaa->Freq2Score;
      v7 = arenaa->Freq1Score;
      if ( arenaa->ServersideArenaSettings.MiscFrequencyShipTypes )
        sprintf(Dest, "SCORE: Warbirds:%d  Javelins:%d", v7, v9);
      else
        sprintf(Dest, "SCORE: Evens:%d  Odds:%d", v7, v9);
    }
    else if ( arenaa->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      sprintf(
        Dest,
        "SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d",
        arenaa->Freq1Score,
        arenaa->Freq2Score,
        arenaa->Freq3Score,
        arenaa->Freq4Score);
    }
    else
    {
      sprintf(
        Dest,
        "SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d",
        arenaa->Freq1Score,
        arenaa->Freq2Score,
        arenaa->Freq3Score,
        arenaa->Freq4Score);
    }
    if ( player )
    {
      if ( player->MySoccerReward <= 0 )
      {
        SendMessage(player, Dest, 0);
      }
      else
      {
        sprintf(messageBuffer, "%s  REWARD:%d", Dest, player->MySoccerReward);
        SendMessage(player, messageBuffer, 0);
      }
    }
    else
    {
      v4 = 0;
      if ( arenaa->ArenaPlayerCount > 0 )
      {
        v5 = arenaa->playerPointersForSomething;
        do
        {
          v6 = *v5;
          if ( (*v5)->MySoccerReward <= 0 )
          {
            v8 = Dest;
          }
          else
          {
            sprintf(messageBuffer, "%s  REWARD:%d", Dest, (*v5)->MySoccerReward);
            v8 = messageBuffer;
            v6 = *v5;
          }
          SendMessage(v6, v8, 0);
          ++v4;
          ++v5;
        }
        while ( v4 < arenaa->ArenaPlayerCount );
      }
    }
  }
}

//----- (00405970) --------------------------------------------------------
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena)
{
  int v1; // edx

  v1 = 117;
  if ( *(arena + 119818) != MapAllocateMemoryPointer )
    v1 = 1317;
  return v1 + ((18 * *(arena + 83602)) >> 10);
}

//----- (004059A0) --------------------------------------------------------
int __thiscall GetTotalPlayingPlayers(struct_ARENA *arena)
{
  int ArenaPlayerCount; // edx
  int result; // eax
  struct_PLAYER **eachPlayer; // ecx

  ArenaPlayerCount = arena->ArenaPlayerCount;
  result = 0;
  if ( ArenaPlayerCount > 0 )
  {
    eachPlayer = arena->playerPointersForSomething;// How could this be like this? this would only hold 251 4 bytes not enough for all players.
    do
    {
      if ( (*eachPlayer)->Ship != 8 )
        ++result;
      ++eachPlayer;                             // This means it really has to go up by 4 bytes the small 251 array.
      --ArenaPlayerCount;
    }
    while ( ArenaPlayerCount );
  }
  return result;
}

//----- (004059D0) --------------------------------------------------------
void __thiscall SendBillerServerConnectPacket(struct BILLING_SERVER_STRUCT *billingStruct, int HandleBillerPacketFuncAddress, const char *ServerName, int ServerId, int GroupId, int ScoreId, const char *Password, int mainServerStructure, struct CONNECTION *encryption)
{
  struct CONNECTION *v10; // ecx
  char buf[173]; // [esp+8h] [ebp-B0h] BYREF

  *billingStruct = mainServerStructure;
  *(billingStruct + 1) = encryption;
  memset(buf, 0, 0xACu);
  buf[172] = 0;
  *(billingStruct + 3) = HandleBillerPacketFuncAddress;
  *(billingStruct + 5) = 0;
  buf[0] = 2;                                   // 0x02 - Billing Server Connect
  strncpy(&buf[13], ServerName, 0x80u);
  buf[140] = 0;
  strncpy(&buf[141], Password, 0x20u);
  *&buf[1] = ServerId;
  v10 = *(billingStruct + 1);
  buf[172] = 0;
  *&buf[5] = GroupId;
  *&buf[9] = ScoreId;
  WriteData(v10, buf, 0xADu, 1);
  *(billingStruct + 4) = GetTickCount() / 0xA;
}

//----- (00405AB0) --------------------------------------------------------
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct)
{
  struct CONNECTION *v2; // ecx
  DWORD StartDelay; // esi
  int result; // eax
  char buf[1]; // [esp+Fh] [ebp-1h] BYREF

  v2 = *(billingServerStruct + 1);
  buf[0] = 3;                                   // 0x03 - Billing Server DisconnectPacket
  WriteData(v2, buf, 1u, 1);
  StartDelay = GetTickCount() / 0xA;
  for ( result = GetRelAckDiff(*(billingServerStruct + 1), 0);
        result > 0;
        result = GetRelAckDiff(*(billingServerStruct + 1), 0) )
  {
    result = abs32(GetTickCount() / 0xA - StartDelay);
    if ( result >= 800 )                        // Process Player Packets for only 800 milliseconds?
      break;
    PlayerDoNetworkOps(*billingServerStruct);
  }
  return result;
}

//----- (00405B30) --------------------------------------------------------
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3)
{
  char buf[101]; // [esp+0h] [ebp-68h] BYREF

  if ( a2 >= 0 )
  {
    *&buf[1] = a2;
    buf[0] = 0x10;                              // 0x10 - Billing User Banner Packet
    qmemcpy(&buf[5], a3, 96u);
    WriteData(*(billingServerStruct + 1), buf, 0x65u, 1);
  }
}

//----- (00405B70) --------------------------------------------------------
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int ConnectionId, int UserDemographics, const char *a3)
{
  struct CONNECTION *v4; // ecx
  char buf[770]; // [esp+0h] [ebp-304h] BYREF

  if ( ConnectionId >= 0 )
  {
    *&buf[1] = ConnectionId;
    buf[0] = 0xD;                               // 0x0D - Billing User Demographics Packet
    qmemcpy(&buf[5], UserDemographics, 764u);
    v4 = *(billingServerStruct + 1);
    buf[769] = *(UserDemographics + 764);
    WriteData(v4, buf, 770u, 1);
  }
}
// 405B70: inconsistent function type and number of purged bytes

//----- (00405BC0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  char *buf; // [esp+10h] [ebp-9h] OVERLAPPED BYREF
  int v5; // [esp+15h] [ebp-4h]
  char v6[2039]; // [esp+19h] [ebp+0h] BYREF

  *(&buf + 1) = a1;
  v5 = a2;
  LOBYTE(buf) = 0xE;                            // 0x0E - Packet Cluster
  strcpy(v6, a3);
  WriteData(*(billingServerStruct + 1), &buf, strlen(a3) + 10, 1);
}
// 405BC0: variables would overlap: ^1C.4 and ^1D.4

//----- (00405C40) --------------------------------------------------------
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int ConnectionId, const char *ChannelName, const char *ChatText)
{
  char buf[256]; // [esp+4h] [ebp-800h] BYREF

  if ( ConnectionId >= 0 )
  {
    *&buf[1] = ConnectionId;
    buf[0] = 0x14;                              // 0x14 - Billing User Channel Chat
    strncpy(&buf[5], ChannelName, 0x20u);
    buf[36] = 0;
    strcpy(&buf[37], ChatText);
    WriteData(*(billingServerStruct + 1), buf, strlen(ChatText) + 38, 1);
  }
}

//----- (00405CD0) --------------------------------------------------------
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage)
{
  char buf; // [esp+4h] [ebp-400h] BYREF
  int v4; // [esp+5h] [ebp-3FFh]
  char v5[1019]; // [esp+9h] [ebp-3FBh] BYREF

  if ( PlayerId >= 0 )
  {
    v4 = PlayerId;
    buf = 0xF;
    strcpy(v5, WarningMessage);
    WriteData(*(billingServerStruct + 1), &buf, strlen(WarningMessage) + 6, 1);
  }
}

//----- (00405D50) --------------------------------------------------------
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand)
{
  char buf[256]; // [esp+4h] [ebp-400h] BYREF

  if ( a2 >= 0 )
  {
    *&buf[1] = a2;
    buf[0] = 0x13;                              // 0x13 - Billing User Command
    strcpy(&buf[5], UserCommand);
    WriteData(*(billingServerStruct + 1), buf, strlen(UserCommand) + 6, 1);
  }
}

//----- (00405DD0) --------------------------------------------------------
void __thiscall SendBillerUserLoginPacket(BILLING_SERVER_STRUCT *billingServerStruct, const char *Username, const char *Password, int IPAddress, int MachineID, int Timezone, char IsNewUser, int ConnectionID, char Unused0, char isSysop)
{
  struct CONNECTION *v11; // ecx
  char buf[84]; // [esp+8h] [ebp-54h] BYREF

  if ( ConnectionID >= 0 )
  {
    buf[0] = 4;                                 // 0x04 - Billing User Login
    strncpy(&buf[6], Username, 0x20u);
    buf[37] = 0;
    strncpy(&buf[38], Password, 0x20u);
    *&buf[2] = IPAddress;
    buf[1] = IsNewUser;
    *&buf[74] = MachineID;
    *&buf[78] = Timezone;
    v11 = *(billingServerStruct + 1);
    buf[69] = 0;                                // Terminate with NULL Password
    *&buf[70] = ConnectionID;
    buf[82] = Unused0;
    buf[83] = isSysop;
    WriteData(v11, buf, 0x54u, 1);
  }
}

//----- (00405E70) --------------------------------------------------------
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int ConnectionId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *HasPlayerScore, unsigned int ExtraSize)
{
  unsigned int Size; // eax
  char buf[1024]; // [esp+0h] [ebp-400h] BYREF

  if ( ConnectionId >= 0 )
  {
    *&buf[1] = ConnectionId;                    // ConnectionId
    *&buf[5] = DisconnectReason;                // Disconnect Reason
    *&buf[7] = Latency;                         // Latency
    *&buf[9] = Ping;                            // Ping
    buf[0] = 5;                                 // 0x05 - Billing User Logoff
    *&buf[13] = C2SPacketLoss;
    *&buf[11] = S2CPacketLoss;
    Size = 15;
    if ( HasPlayerScore )
    {
      qmemcpy(&buf[15], HasPlayerScore, ExtraSize);
      Size = ExtraSize + 15;
    }
    WriteData(*(billingServerStruct + 1), buf, Size, 1);
  }
}

//----- (00405F20) --------------------------------------------------------
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int ConnectionId, const void *Score, unsigned int Size)
{
  char buf[32]; // [esp+0h] [ebp-400h] BYREF

  if ( ConnectionId >= 0 )
  {
    *&buf[1] = ConnectionId;
    buf[0] = 0x11;                              // 0x11 - Billing User Score
    qmemcpy(&buf[5], Score, Size);
    WriteData(*(billingServerStruct + 1), buf, Size + 5, 1);
  }
}

//----- (00405F80) --------------------------------------------------------
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len)
{
  void *v6; // ebx
  unsigned int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = emalloc(lena);
  qmemcpy(v6 + 9, a3, len);
  *(v6 + 5) = a2;
  *v6 = 6;                                      // 0x06 - Billing PlayerName Packet
  *(v6 + 1) = a1;
  qmemcpy(v6 + 9, a3, len);
  WriteData(*(billingServerStruct + 1), v6, lena, 1);
  efree(v6);
}

//----- (00406010) --------------------------------------------------------
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int ConnectionId, int BillingGroupId, const void *a4, unsigned int len)
{
  char *v6; // ebx
  unsigned int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = emalloc(lena);
  qmemcpy(v6 + 9, a4, len);
  *(v6 + 5) = BillingGroupId;
  *v6 = 7;                                      // 0x07 - Billing User Private Chat
  *(v6 + 1) = ConnectionId;
  qmemcpy(v6 + 9, a4, len);
  WriteData(*(billingServerStruct + 1), v6, lena, 1);
  efree(v6);
}

//----- (004060A0) --------------------------------------------------------
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int a2, int a3, int a4, int len)
{
  char *v6; // ebx
  int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = emalloc(lena);
  qmemcpy(v6 + 9, a4, len);
  *(v6 + 5) = a3;
  *v6 = 0x12;                                   // 0x12 - Billing Something with Zone Player *Revoke or *Permit
  *(v6 + 1) = a2;
  qmemcpy(v6 + 9, a4, len);
  WriteData(this[1], v6, lena, 1);
  efree(v6);
}

//----- (00406130) --------------------------------------------------------
int __thiscall GetBillingLastReconnectTime(int this)
{
  return *(*(this + 4) + 58);
}

//----- (00406140) --------------------------------------------------------
signed int __thiscall IsBillingServerDisconnected(BILLING_SERVER_STRUCT *billingServerStruct)
{
  __int64 v2; // rax
  DWORD v3; // eax
  struct CONNECTION *v4; // ecx
  int i; // eax
  void (__cdecl *v6)(int, int); // ecx
  char buf[1]; // [esp+Bh] [ebp-9h] BYREF
  int v9; // [esp+Ch] [ebp-8h] BYREF
  char v10[4]; // [esp+10h] [ebp-4h] BYREF

  if ( CheckIfBillingServerIsConnected(*(billingServerStruct + 1)) != 2
    || GetRelAckDiff(*(billingServerStruct + 1), 0) >= 255 )
  {
    return 1;
  }
  v2 = (GetTickCount() / 0xA - *(billingServerStruct + 4));
  if ( ((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 3000 )
  {
    v3 = GetTickCount();
    v4 = *(billingServerStruct + 1);
    *(billingServerStruct + 4) = v3 / 0xA;
    buf[0] = 1;                                 // 0x01 - Billing Server Ping
    WriteData(v4, buf, 1u, 1);
  }
  for ( i = sub_41B1B0(*billingServerStruct, &v9, v10); i; i = sub_41B1B0(*billingServerStruct, &v9, v10) )
  {
    v6 = *(billingServerStruct + 3);
    if ( v6 )
      v6(i, v9);
  }
  return 0;
}

//----- (00406210) --------------------------------------------------------
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename)
{
  int v3; // esi
  FILE *v4; // eax
  FILE *v5; // edi
  char *v6; // edx
  char v7; // al
  char *v8; // edi
  char *i; // ecx
  char *v10; // eax
  char *v11; // edx
  char j; // cl
  char k; // cl
  char *v14; // eax
  char v15; // cl
  char *l; // edx
  FILE *v18; // [esp+10h] [ebp-204h]
  char Buf; // [esp+14h] [ebp-200h] BYREF
  char v20; // [esp+15h] [ebp-1FFh] BYREF

  strcpy(ConfigSETPointer + 177740, Filename);
  *(ConfigSETPointer + 2432) = 0;
  *(ConfigSETPointer + 44433) = 0;
  *(ConfigSETPointer + 44434) = 0;
  v3 = -1;
  v4 = fopen(ConfigSETPointer + 177740, "rt");
  v5 = v4;
  v18 = v4;
  if ( v4 )
  {
    if ( (v4->_flag & 0x10) == 0 )
    {
      do
      {
        Buf = 0;
        fgets(&Buf, 512, v5);
        if ( Buf == '[' )
        {
          v3 = *(ConfigSETPointer + 2432);
          *(ConfigSETPointer + 2432) = v3 + 1;
          v6 = &v20;
          v7 = v20;
          v8 = ConfigSETPointer + 38 * v3;
          for ( i = v8; v7; ++v6 )
          {
            if ( v7 == ']' )
              break;
            *i = v7;
            v7 = v6[1];
            ++i;
          }
          *i = 0;
          *(v8 + 30) = *(ConfigSETPointer + 44433);
          *(v8 + 34) = 0;
          v5 = v18;
        }
        else if ( isalpha(Buf) && v3 != -1 )
        {
          v10 = &Buf;
          v11 = ConfigSETPointer + 140 * *(ConfigSETPointer + 44433) + 9732;
          for ( j = Buf; j; ++v10 )
          {
            if ( j == '=' )
              break;
            if ( j == ' ' )
              break;
            *v11 = j;
            j = v10[1];
            ++v11;
          }
          *v11 = 0;
          for ( k = *v10; k; k = *++v10 )
          {
            if ( k == '=' )
              break;
          }
          if ( *v10 )
          {
            v14 = v10 + 1;
            v15 = *v14;
            for ( l = ConfigSETPointer + 140 * *(ConfigSETPointer + 44433) + 9772; v15 >= 32; ++v14 )
            {
              *l = v15;
              v15 = v14[1];
              ++l;
            }
            *l = 0;
            config_read_helper_3(ConfigSETPointer + 140 * *(ConfigSETPointer + 44433) + 9772);
            ++*(ConfigSETPointer + 44433);
            ++*(ConfigSETPointer + 38 * v3 + 34);
          }
        }
      }
      while ( (v5->_flag & 0x10) == 0 );
    }
    fclose(v5);
  }
  return ConfigSETPointer;
}

//----- (004063F0) --------------------------------------------------------
void __thiscall WriteCfgFile(struct struc_2 *struc2)
{
  struct struc_2 *v1; // esi
  FILE *v2; // ebp
  _DWORD *v3; // edi
  int v4; // ebx
  const char *v5; // esi
  int v6; // [esp+8h] [ebp-8h]

  v1 = struc2;
  if ( *(struc2 + 44434) )
  {
    v2 = fopen(struc2 + 177740, "wt");
    if ( v2 )
    {
      v6 = 0;
      if ( *(v1 + 2432) > 0 )
      {
        v3 = (v1 + 34);
        do
        {
          if ( *v3 > 0 )
          {
            fprintf(v2, "[%s]\n", v3 - 34);
            v4 = 0;
            if ( *v3 > 0 )
            {
              v5 = v1 + 140 * *(v3 - 1) + 9732;
              do
              {
                fprintf(v2, "%s=%s\n", v5, v5 + 40);
                ++v4;
                v5 += 140;
              }
              while ( v4 < *v3 );
              v1 = struc2;
            }
            fprintf(v2, "\n");
          }
          v3 = (v3 + 38);
          ++v6;
        }
        while ( v6 < *(v1 + 2432) );
      }
      fclose(v2);
    }
  }
}

//----- (004064D0) --------------------------------------------------------
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4)
{
  struct struc_2 *v4; // ebp
  int *v5; // edi
  int v6; // esi
  int v7; // ebx
  const char *v8; // ebp
  int result; // eax
  int v10; // [esp+10h] [ebp-18h]
  char Dest[16]; // [esp+18h] [ebp-10h] BYREF

  v4 = Str1;
  v10 = 0;
  if ( *(Str1 + 2432) <= 0 )
  {
LABEL_10:
    sprintf(Dest, MEMORY[0x42A094], a4);
    FillArenaSettingsStruct(v4, Str2, a3, Dest);
    result = a4;
  }
  else
  {
    v5 = (Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi(v5 - 34, Str2) )
      {
        v6 = *(v5 - 1);
        v7 = 0;
        if ( *v5 > 0 )
          break;
      }
LABEL_9:
      v5 = (v5 + 38);
      if ( ++v10 >= *(v4 + 2432) )
        goto LABEL_10;
    }
    v8 = v4 + 140 * v6 + 9732;
    while ( _strcmpi(v8, a3) )
    {
      ++v7;
      ++v6;
      v8 += 140;
      if ( v7 >= *v5 )
      {
        v4 = Str1;
        goto LABEL_9;
      }
    }
    result = atoi(Str1 + 140 * v6 + 9772);
  }
  return result;
}

//----- (004065C0) --------------------------------------------------------
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count)
{
  struct struc_2 *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  char *v12; // [esp-8h] [ebp-20h]
  size_t v13; // [esp-4h] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-8h]

  v6 = Str1;
  v14 = 0;
  if ( *(Str1 + 2432) <= 0 )
  {
LABEL_10:
    FillArenaSettingsStruct(v6, Str2, a3, Source);
    v11 = Count;
    v13 = Count;
    v12 = Source;
  }
  else
  {
    v7 = (Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi(v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (v7 + 38);
      if ( ++v14 >= *(v6 + 2432) )
        goto LABEL_10;
    }
    v10 = v6 + 140 * v8 + 9732;
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = Str1;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v13 = Count;
    v12 = Str1 + 140 * v8 + 9772;
  }
  strncpy(Dest, v12, v13);
  Dest[v11 - 1] = 0;
}

//----- (004066B0) --------------------------------------------------------
char *__thiscall sub_4066B0(int this, const char *Str2, const char *a3, const char *Source, char *Dest, size_t Count)
{
  int v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  size_t v14; // [esp-4h] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-8h]

  v6 = this;
  v15 = 0;
  if ( *(this + 9728) <= 0 )
  {
LABEL_10:
    v11 = Count;
    v14 = Count;
  }
  else
  {
    v7 = (this + 34);
    while ( 1 )
    {
      if ( !_strcmpi(v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (v7 + 38);
      if ( ++v15 >= *(v6 + 9728) )
        goto LABEL_10;
    }
    v10 = (v6 + 140 * v8 + 9732);
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = this;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v14 = Count;
    Source = (this + 140 * v8 + 9772);
  }
  strncpy(Dest, Source, v14);
  Dest[v11 - 1] = 0;
  return Dest;
}

//----- (00406790) --------------------------------------------------------
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source)
{
  struc_2 *v4; // ebp
  int v5; // esi
  int v6; // eax
  struc_2 *v7; // edi
  int v8; // eax
  char *v9; // esi
  int v10; // ebx
  int v11; // ecx
  char *v12; // esi
  const char *v13; // edi
  char *v14; // ebx
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // [esp+10h] [ebp-Ch]
  char *v18; // [esp+14h] [ebp-8h]
  char *Str2a; // [esp+20h] [ebp+4h]

  v4 = Str1;
  v5 = 0;
  v6 = *(Str1 + 2432);
  *(Str1 + 44434) = 1;
  if ( v6 <= 0 )
  {
LABEL_5:
    strcpy(v4 + 38 * *(v4 + 2432), Str2);
    *(v4 + 38 * *(v4 + 2432) + 30) = *(v4 + 44433);
    *(v4 + 38 * *(v4 + 2432) + 34) = 1;
    v8 = 7 * *(v4 + 44433);
    ++*(v4 + 2432);
    strcpy(v4 + 20 * v8 + 9732, a3);
    v9 = v4 + 140 * *(v4 + 44433) + 9772;
    strncpy(v9, Source, 0x64u);
    v9[99] = 0;
    ++*(v4 + 44433);
  }
  else
  {
    v7 = Str1;
    while ( _strcmpi(v7, Str2) )
    {
      ++v5;
      v7 = (v7 + 38);
      if ( v5 >= *(v4 + 2432) )
        goto LABEL_5;
    }
    v17 = v5;
    v10 = 0;
    v11 = 19 * v5;
    v12 = *(v4 + 38 * v5 + 30);
    Str2a = v12;
    v18 = v4 + 2 * v11;
    if ( *(v18 + 34) <= 0 )
    {
LABEL_12:
      memcpy(v4 + 140 * v12 + 9872, v4 + 140 * v12 + 9732, 140 * *(v4 + 44433) - 140 * v12);
      v14 = v4 + 140 * v12 + 9772;
      strcpy(v4 + 140 * v12 + 9732, a3);
      strncpy(v14, Source, 0x64u);
      v14[99] = 0;
      ++*(v4 + 44433);
      ++*(v18 + 34);
      v15 = 0;
      if ( *(v4 + 2432) > 0 )
      {
        v16 = (v4 + 30);
        do
        {
          if ( *v16 >= Str2a && v15 != v17 )
            ++*v16;
          ++v15;
          v16 = (v16 + 38);
        }
        while ( v15 < *(v4 + 2432) );
      }
    }
    else
    {
      v13 = v4 + 140 * v12 + 9732;
      while ( _strcmpi(v13, a3) )
      {
        ++v10;
        ++v12;
        v13 += 140;
        if ( v10 >= *(v18 + 34) )
        {
          Str2a = v12;
          goto LABEL_12;
        }
      }
      strcpy(v4 + 140 * v12 + 9772, Source);
    }
  }
}

//----- (00406A30) --------------------------------------------------------
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source)
{
  FILE *v3; // eax
  FILE *v4; // edi
  int v5; // eax
  unsigned int v6; // eax
  void *v7; // eax
  size_t v8; // edx
  char DstBuf[6]; // [esp+Ch] [ebp-8h] BYREF

  strncpy(Filename, Source, 0x100u);
  *(Filename + 255) = 0;
  *(Filename + 66) = 0;
  *(Filename + 67) = 0;
  v3 = fopen(
         Filename,
         "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
         "\x00\x00\x00Player spectating game: %s\n"
         "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1 min"
         "ute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00\x00NOTI"
         "CE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00\x00\x00Kin"
         "g of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00Player kicked o"
         "ff for not returning security packet: %s\n"
         "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00Param"
         "eters resent for arena(%s)\n"
         "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parameter.\x00"
         "\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00Spider\x00"
         "\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points to give.\x00\x00"
         "\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d\x00SCORE: "
         "Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d\x00"
         "\x00rt\x00\x00\n"
         "\x00\x00\x00%s=%s\n"
         "\x00\x00[%s]\n"
         "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
         "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resize)\x00"
         "\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
         "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked off, "
         "arena full to demo users: %s\n"
         "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
         "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
         "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
         "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
         "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
         "\x00%s>  MODERATOR LOGGED IN\n"
         "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
         "\x00%s> SYSOP LOGGED IN\n"
         "\x00\x00\x00\x00Connection request from: %s\n"
         "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00File "
         "has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00File "
         "arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00\x00\x00"
         "pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempting to enter game");
  v4 = v3;
  if ( v3 )
  {
    *(Filename + 64) = 0;
    if ( fread(DstBuf, 1u, 6u, v3) == 6 && DstBuf[0] == 'B' && DstBuf[1] == 'M' )// Load BMP Header.
      *(Filename + 64) = *&DstBuf[2];
    fseek(v4, *(Filename + 64), 0);
    v5 = _fileno(v4);
    v6 = (_filelength(v5) - *(Filename + 64)) >> 2;
    *(Filename + 67) = v6;
    v7 = emalloc(4 * v6);
    v8 = *(Filename + 67);
    *(Filename + 66) = v7;
    fread(v7, v8, 4u, v4);
    fclose(v4);
  }
  *(Filename + 65) = 0;
}
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (00406B30) --------------------------------------------------------
void __thiscall sub_406B30(const char *Filename)
{
  FILE *v2; // edi
  int v3; // eax
  void *v4; // esi
  int v5; // [esp-4h] [ebp-Ch]

  if ( *(Filename + 65) )
  {
    if ( *(Filename + 66) )
    {
      v2 = fopen(Filename, "rb+");
      if ( v2 || (v2 = fopen(Filename, aW)) != 0 )
      {
        fseek(v2, *(Filename + 64), 0);
        fwrite(*(Filename + 66), *(Filename + 67), 4u, v2);
        v5 = *(Filename + 64) + 4 * *(Filename + 67);
        v3 = _fileno(v2);
        _chsize(v3, v5);
        fclose(v2);
      }
    }
  }
  v4 = *(Filename + 66);
  if ( v4 )
    efree(v4);
}
// 41E210: using guessed type _DWORD __cdecl _chsize(_DWORD, _DWORD);

//----- (00406BE0) --------------------------------------------------------
int __thiscall sub_406BE0(int this)
{
  return *(this + 268);
}

//----- (00406BF0) --------------------------------------------------------
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi

  v3 = *TileValuePointer ^ (*TileValuePointer ^ *(*(BMPFile + 66) + 4 * TileCounter)) & 0xFFF;
  *TileValuePointer = v3;
  v4 = v3 ^ (v3 ^ *(*(BMPFile + 66) + 4 * TileCounter)) & 0xFFF000;
  *TileValuePointer = v4;
  v5 = *(*(BMPFile + 66) + 4 * TileCounter);
  *TileValuePointer = v5 ^ (v5 ^ v4) & 0xFFFFFF;
}

//----- (00406C50) --------------------------------------------------------
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize)
{
  int v8; // ebx
  char *v9; // esi
  int v10; // ebx
  int i; // edi
  int v12; // edi
  int v13; // ecx
  char *v14; // eax
  int v15; // ecx
  int v16; // esi
  char *v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // eax
  signed int j; // ecx
  int v22; // eax
  signed int v23; // eax
  char *v24; // edi
  char *v25; // ebx

  v8 = XTiles;
  if ( XTiles < 0 )
  {
    v9 = MapAllocatedMemory;
  }
  else
  {
    v9 = MapAllocatedMemory;
    do
    {
      if ( MapAllocatedMemory[1024 * YTiles + v8] )
        break;
      --v8;
    }
    while ( v8 >= 0 );
  }
  v10 = v8 + 1;
  for ( i = XTiles; i < 1024; ++i )
  {
    if ( v9[1024 * YTiles + i] )
      break;
  }
  v12 = i - 1;
  if ( v12 < v10 )
    v12 = v10;
  v13 = YTiles;
  if ( YTiles >= 0 )
  {
    v14 = &v9[1024 * YTiles + XTiles];
    do
    {
      if ( *v14 )
        break;
      --v13;
      v14 -= 1024;
    }
    while ( v13 >= 0 );
  }
  v15 = v13 + 1;
  v16 = YTiles;
  if ( YTiles < 1024 )
  {
    v17 = &MapAllocatedMemory[1024 * YTiles + XTiles];
    do
    {
      if ( *v17 )
        break;
      ++v16;
      v17 += 1024;
    }
    while ( v16 < 1024 );
  }
  v18 = v16 - 1;
  if ( v18 < v15 )
    v18 = v15;
  v19 = BrickSpanSize / 2;
  if ( v12 - v10 >= v18 - v15 )
  {
    if ( v15 <= YTiles - v19 )
      v15 = YTiles - v19;
    v22 = YTiles + v19;
    if ( v18 >= v22 )
      v18 = v22;
    v23 = v18 - v15 + 1;
    if ( v23 < BrickSpanSize )
    {
      v24 = &MapAllocatedMemory[1024 * v15 + XTiles];
      v25 = &MapAllocatedMemory[1024 * v18 + 1024 + XTiles];
      do
      {
        if ( v15 - 1 < 0 || *(v24 - 1024) )
        {
          if ( v18 >= 1023 || *v25 )
            break;
          ++v18;
          v25 += 1024;
        }
        else
        {
          --v15;
          v24 -= 1024;
        }
        ++v23;
      }
      while ( v23 < BrickSpanSize );
    }
    *Y1Tile = v15;
    *Y2Tile = v18;
    *X1Tile = XTiles;
    *X2Tile = XTiles;
  }
  else
  {
    if ( v10 <= XTiles - v19 )
      v10 = XTiles - v19;
    v20 = XTiles + v19;
    if ( v12 >= v20 )
      v12 = v20;
    for ( j = v12 - v10 + 1; j < BrickSpanSize; ++j )
    {
      if ( v10 - 1 < 0 || MapAllocatedMemory[1024 * YTiles - 1 + v10] )
      {
        if ( v12 >= 1023 || MapAllocatedMemory[1024 * YTiles + 1 + v12] )
          break;
        ++v12;
      }
      else
      {
        --v10;
      }
    }
    *X1Tile = v10;
    *X2Tile = v12;
    *Y1Tile = YTiles;
    *Y2Tile = YTiles;
  }
}

//----- (00406E30) --------------------------------------------------------
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key)
{
  signed int v2; // edi
  int v3; // ecx
  int v4; // eax
  char *v5; // esi
  unsigned int v6; // ebx
  char *v7; // edx
  char *v8; // ecx
  char v9; // al
  int mapData; // [esp+8h] [ebp+4h]

  v2 = Key;
  v3 = Key % -4294967264;
  if ( Key % -4294967264 < 1024 )
  {
    v4 = 1024 - Key % 31;
    v5 = &MapData[1024 * v3 + Key % 31];
    mapData = v4;
    v6 = (1055 - v3) >> 5;
    do
    {
      v7 = &v5[v4];
      v8 = v5;
      if ( v5 < &v5[v4] )
      {
        do
        {
          v9 = *v8;
          if ( *v8 && v9 < 0xA1u || v9 == 0xAB )
            Key += *v8 ^ v2;
          v8 += 31;
        }
        while ( v8 < v7 );
        v4 = mapData;
      }
      v5 += 0x8000;
      --v6;
    }
    while ( v6 );
  }
  return Key;
}

//----- (00406ED0) --------------------------------------------------------
bool __cdecl LoadBMPHeader2(const char *Filename)
{
  bool v1; // bl
  FILE *v2; // eax
  FILE *v3; // ebp
  __int32 v4; // edi
  int v5; // eax
  __int32 v6; // eax
  unsigned __int32 v7; // eax
  signed int v8; // esi
  void *v9; // edi
  int *v10; // ecx
  int v11; // eax
  bool result; // al
  char DstBuf[2]; // [esp+8h] [ebp-8h] BYREF
  int v14; // [esp+Ah] [ebp-6h]

  v1 = 1;
  v2 = fopen(
         Filename,
         "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
         "\x00\x00\x00Player spectating game: %s\n"
         "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1 min"
         "ute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00\x00NOTI"
         "CE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00\x00\x00Kin"
         "g of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00Player kicked o"
         "ff for not returning security packet: %s\n"
         "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00Param"
         "eters resent for arena(%s)\n"
         "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parameter.\x00"
         "\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00Spider\x00"
         "\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points to give.\x00\x00"
         "\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d\x00SCORE: "
         "Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d\x00"
         "\x00rt\x00\x00\n"
         "\x00\x00\x00%s=%s\n"
         "\x00\x00[%s]\n"
         "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
         "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resize)\x00"
         "\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
         "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked off, "
         "arena full to demo users: %s\n"
         "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
         "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
         "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
         "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
         "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
         "\x00%s>  MODERATOR LOGGED IN\n"
         "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
         "\x00%s> SYSOP LOGGED IN\n"
         "\x00\x00\x00\x00Connection request from: %s\n"
         "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00File "
         "has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00File "
         "arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00\x00\x00"
         "pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempting to enter game");
  v3 = v2;
  if ( !v2 )
    return 0;
  v4 = 0;
  if ( fread(DstBuf, 1u, 6u, v2) == 6 && DstBuf[0] == 66 && DstBuf[1] == 77 )
    v4 = v14;
  v5 = _fileno(v3);
  v6 = _filelength(v5);
  if ( v4 < v6 && v4 >= 0 && (v7 = v6 - v4, v8 = v7 >> 2, 4 * (v7 >> 2) == v7) && (fseek(v3, v4, 0), v8 > 0) )
  {
    v9 = emalloc(4 * v8);
    fread(v9, v8, 4u, v3);
    v10 = v9;
    do
    {
      v11 = *v10;
      if ( (*v10 & 0xFFFu) > 0x400 || (v11 & 0xFFF000u) > 0x400000 || (v11 & 0xFF000000) == 0 )
        v1 = 0;
      ++v10;
      --v8;
    }
    while ( v8 );
    efree(v9);
    fclose(v3);
    result = v1;
  }
  else
  {
    fclose(v3);
    result = 0;
  }
  return result;
}
// 406F8B: conditional instruction was optimized away because of 'esi.4>=1'
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (00407000) --------------------------------------------------------
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll)
{
  *(textFile + 66) = makeUpperCase;
  *(textFile + 67) = addAll;
  if ( Source )
  {
    strncpy(textFile, Source, 0x100u);
    *(textFile + 255) = 0;
  }
  else
  {
    *textFile = 0;
  }
  *(textFile + 65) = 0;
  *(textFile + 64) = 0;
  LoadTextFile(textFile, 1);
}

//----- (00407060) --------------------------------------------------------
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile)
{
  int i; // edi

  if ( *(textFile + 64) )
  {
    for ( i = 0; i < *(textFile + 65); ++i )
      efree(*(*(textFile + 64) + 4 * i));
    ExpandMemory(*(textFile + 64), 0, 1);
    *(textFile + 64) = 0;
    *(textFile + 65) = 0;
  }
}

//----- (004070D0) --------------------------------------------------------
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2)
{
  int i; // esi
  FILE *v4; // eax
  FILE *v5; // esi
  char *j; // eax
  char Buf[512]; // [esp+10h] [ebp-200h] BYREF

  if ( a2 || !*textFile || IsFileLastWrittenTime(textFile, textFile + 272) )
  {
    if ( *(textFile + 64) )
    {
      for ( i = 0; i < *(textFile + 65); ++i )
        efree(*(*(textFile + 64) + 4 * i));
      ExpandMemory(*(textFile + 64), 0, 1);
      *(textFile + 64) = 0;
      *(textFile + 65) = 0;
    }
    if ( *textFile )
    {
      v4 = fopen(textFile, "rt");
      v5 = v4;
      if ( v4 )
      {
        if ( (v4->_flag & 0x10) == 0 )
        {
          do
          {
            if ( fgets(Buf, 512, v5) )
            {
              for ( j = &Buf[strlen(Buf)]; j != Buf; --j )
              {
                if ( *(j - 1) >= 32 )
                  break;
              }
              *j = 0;
              if ( strlen(Buf) )
                AddLineTextFile(textFile, Buf);
            }
          }
          while ( (v5->_flag & 0x10) == 0 );
        }
        fclose(v5);
      }
    }
  }
}
// 4070D0: using guessed type char Buf[512];

//----- (00407200) --------------------------------------------------------
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile)
{
  FILE *v2; // ebx
  int i; // esi

  if ( *textFile )
  {
    v2 = fopen(textFile, "wt");
    if ( v2 )
    {
      for ( i = 0; i < *(textFile + 65); ++i )
        fprintf(v2, "%s\n", *(*(textFile + 64) + 4 * i));
      fclose(v2);
    }
  }
}

//----- (00407260) --------------------------------------------------------
int __thiscall ListMachine(int this)
{
  return *(this + 260);
}

//----- (00407270) --------------------------------------------------------
int __thiscall ListMachineByIndex(int this, int listMachineIndex)
{
  return *(*(this + 256) + 4 * listMachineIndex);
}

//----- (00407280) --------------------------------------------------------
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer)
{
  int v3; // esi
  int v4; // eax
  char *v5; // eax
  size_t v6; // ecx
  unsigned int FoundPointer; // [esp+10h] [ebp-4h] BYREF
  char *chatMsgBuffer; // [esp+18h] [ebp+4h]

  v3 = 0;
  v4 = BinarySearch(ChatMsgBuffer, *(textFile + 64), *(textFile + 65), 4, StrCmpiWrapper, &FoundPointer);
  if ( !FoundPointer || !*(textFile + 67) )
  {
    if ( v4 )
      v3 = (v4 - *(textFile + 64)) >> 2;
    v5 = ExpandMemory(*(textFile + 64), 4 * *(textFile + 65) + 4, 2048);
    v6 = 4 * (*(textFile + 65) + 0x3FFFFFFF * v3);
    *(textFile + 64) = v5;
    memcpy(&v5[4 * v3 + 4], &v5[4 * v3], v6);
    chatMsgBuffer = emalloc(strlen(ChatMsgBuffer) + 1);
    strcpy(chatMsgBuffer, ChatMsgBuffer);
    *(*(textFile + 64) + 4 * v3) = chatMsgBuffer;
    if ( *(textFile + 66) )
      _strupr(*(*(textFile + 64) + 4 * v3));
    ++*(textFile + 65);
  }
}
/* Orphan comments:
Make more memory for chat message
Copy chat message into memory
*/

//----- (004073A0) --------------------------------------------------------
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number)
{
  int v2; // ecx
  int v3; // esi
  int v4; // ecx

  v3 = v2;
  efree(*(*(v2 + 256) + 4 * textFile));
  v4 = *(v3 + 260) - 1;
  *(v3 + 260) = v4;
  memcpy((4 * textFile + *(v3 + 256)), (*(v3 + 256) + 4 * textFile + 4), 4 * (v4 + 0x3FFFFFFF * textFile));
  *(v3 + 256) = ExpandMemory(*(v3 + 256), 4 * *(v3 + 260), 2048);
}
// 4073A7: variable 'v2' is possibly undefined
// 4073A0: inconsistent function type and number of purged bytes

//----- (00407420) --------------------------------------------------------
int __thiscall IsBannedMachineId(struct TEXT_FILE_STRUCT *textFile, char *MachineId)
{
  int v3; // eax
  int result; // eax

  v3 = BinarySearch(MachineId, *(textFile + 64), *(textFile + 65), 4, StrCmpiWrapper, &MachineId);
  if ( MachineId )
    result = (v3 - *(textFile + 64)) >> 2;
  else
    result = -1;
  return result;
}

//----- (00407470) --------------------------------------------------------
int __cdecl StrCmpiWrapper(char *Str1, const char **a2)
{
  return _strcmpi(Str1, *a2);
}

//----- (00407490) --------------------------------------------------------
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src)
{
  char *v2; // esi
  int v3; // ecx
  char v4; // al
  char *i; // ecx

  *a1 = 0;
  v2 = Src;
  if ( isspace(*Src) == 32 )
  {
    do
      v3 = *++v2;
    while ( isspace(v3) == 32 );
  }
  v4 = *v2;
  for ( i = a1; v4; ++v2 )
  {
    if ( v4 == 44 )
      break;
    *i = v4;
    v4 = v2[1];
    ++i;
  }
  *i = 0;
  if ( *v2 == 44 )
    ++v2;
  strcpy(Src, v2);
  return a1;
}

//----- (00407510) --------------------------------------------------------
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int checkTimestamp)
{
  HANDLE v2; // eax
  void *v3; // esi
  struct _FILETIME LastWriteTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+Ch] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+14h] [ebp-8h] BYREF

  v2 = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
  v3 = v2;
  if ( v2 != -1 )
  {
    GetFileTime(v2, &CreationTime, &LastAccessTime, &LastWriteTime);
    CloseHandle(v3);
    v2 = LastWriteTime.dwLowDateTime;
  }
  if ( *checkTimestamp == v2 )
    return 0;
  *checkTimestamp = v2;
  return 1;
}

//----- (00407580) --------------------------------------------------------
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer)
{
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // edi

  v6 = 0;
  result = 0;
  *FoundPointer = 0;
  if ( !TotalElements )
    return result;
  v8 = Array;
  v9 = Array + ElementSize * (TotalElements - 1);
  if ( Array > v9 )
  {
LABEL_9:
    if ( result > 0 )
      v6 += ElementSize;
    return v6;
  }
  while ( 1 )
  {
    v6 = v8 + ElementSize * ((v9 - v8) / ElementSize / 2);
    result = CompareFunc(ElementToFind, v6);
    if ( result < 0 )
    {
      if ( v6 == Array )
        goto LABEL_9;
      v9 = v6 - ElementSize;
      goto LABEL_8;
    }
    if ( result <= 0 )
      break;
    v8 = v6 + ElementSize;
LABEL_8:
    if ( v8 > v9 )
      goto LABEL_9;
  }
  *FoundPointer = 1;
  if ( v6 == Array )
    return Array;
  while ( 1 )
  {
    v6 -= ElementSize;
    if ( CompareFunc(ElementToFind, v6) )
      break;
    if ( v6 == Array )
      return Array;
  }
  return v6 + ElementSize;
}

//----- (00407630) --------------------------------------------------------
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int defaultWriteIntValue, LPCSTR lpFileName)
{
  unsigned int v4; // esi
  CHAR Dest[12]; // [esp+10h] [ebp-10h] BYREF

  v4 = GetPrivateProfileIntA(lpAppName, lpKeyName, -12345678, lpFileName);
  if ( v4 == -12345678 )
  {
    v4 = defaultWriteIntValue;
    sprintf(Dest, MEMORY[0x42A094], defaultWriteIntValue);
    WritePrivateProfileStringA(lpAppName, lpKeyName, Dest, lpFileName);
  }
  return v4;
}

//----- (00407690) --------------------------------------------------------
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR defaultWriteStringValue, LPSTR buffer, DWORD nSize, LPCSTR lpFileName)
{
  int result; // eax

  GetPrivateProfileStringA(lpAppName, lpKeyName, "1x2y3z4", buffer, nSize, lpFileName);
  result = strcmp(buffer, "1x2y3z4");
  if ( !result )
  {
    strcpy(buffer, defaultWriteStringValue);
    result = WritePrivateProfileStringA(lpAppName, lpKeyName, buffer, lpFileName);
  }
  return result;
}

//----- (00407730) --------------------------------------------------------
void __cdecl config_read_helper_3(char *a1)
{
  char *v1; // ecx
  char *v2; // esi
  char v3; // dl
  char i; // dl
  char v5; // bl

  v1 = a1;
  v2 = a1;
  if ( *a1 == 32 )
  {
    do
      v3 = *++v1;
    while ( v3 == 32 );
  }
  for ( i = *v1; i; ++v1 )
  {
    if ( i != 32 || (v5 = v1[1], v5 != 32) && v5 )
      *v2++ = i;
    i = v1[1];
  }
  *v2 = 0;
}

//----- (00407780) --------------------------------------------------------
signed int __cdecl CRC32(char *buffer, int fileSize)
{
  char *v2; // ecx
  int v3; // eax
  int v5[256]; // [esp+4h] [ebp-400h]

  v5[0] = 0;
  v5[1] = 1996959894;
  v5[2] = -301047508;
  v5[3] = -1727442502;
  v5[4] = 124634137;
  v5[5] = 1886057615;
  v5[6] = -379345611;
  v5[7] = -1637575261;
  v5[8] = 249268274;
  v5[9] = 2044508324;
  v5[10] = -522852066;
  v5[11] = -1747789432;
  v5[12] = 162941995;
  v5[13] = 2125561021;
  v5[14] = -407360249;
  v5[15] = -1866523247;
  v5[16] = 498536548;
  v5[17] = 1789927666;
  v5[18] = -205950648;
  v5[19] = -2067906082;
  v5[20] = 450548861;
  v5[21] = 1843258603;
  v5[22] = -187386543;
  v5[23] = -2083289657;
  v5[24] = 325883990;
  v5[25] = 1684777152;
  v5[26] = -43845254;
  v5[27] = -1973040660;
  v5[28] = 335633487;
  v5[29] = 1661365465;
  v5[30] = -99664541;
  v5[31] = -1928851979;
  v5[32] = 997073096;
  v5[33] = 1281953886;
  v5[34] = -715111964;
  v5[35] = -1570279054;
  v5[36] = 1006888145;
  v5[37] = 1258607687;
  v5[38] = -770865667;
  v5[39] = -1526024853;
  v5[40] = 901097722;
  v5[41] = 1119000684;
  v5[42] = -608450090;
  v5[43] = -1396901568;
  v5[44] = 853044451;
  v5[45] = 1172266101;
  v5[46] = -589951537;
  v5[47] = -1412350631;
  v5[48] = 651767980;
  v5[49] = 1373503546;
  v5[50] = -925412992;
  v5[51] = -1076862698;
  v5[52] = 565507253;
  v5[53] = 1454621731;
  v5[54] = -809855591;
  v5[55] = -1195530993;
  v5[56] = 671266974;
  v5[57] = 1594198024;
  v5[58] = -972236366;
  v5[59] = -1324619484;
  v5[60] = 795835527;
  v5[61] = 1483230225;
  v5[62] = -1050600021;
  v5[63] = -1234817731;
  v5[64] = 1994146192;
  v5[65] = 31158534;
  v5[66] = -1731059524;
  v5[67] = -271249366;
  v5[68] = 1907459465;
  v5[69] = 112637215;
  v5[70] = -1614814043;
  v5[71] = -390540237;
  v5[72] = 2013776290;
  v5[73] = 251722036;
  v5[74] = -1777751922;
  v5[75] = -519137256;
  v5[76] = 2137656763;
  v5[77] = 141376813;
  v5[78] = -1855689577;
  v5[79] = -429695999;
  v5[80] = 1802195444;
  v5[81] = 476864866;
  v5[82] = -2056965928;
  v5[83] = -228458418;
  v5[84] = 1812370925;
  v5[85] = 453092731;
  v5[86] = -2113342271;
  v5[87] = -183516073;
  v5[88] = 1706088902;
  v5[89] = 314042704;
  v5[90] = -1950435094;
  v5[91] = -54949764;
  v5[92] = 1658658271;
  v5[93] = 366619977;
  v5[94] = -1932296973;
  v5[95] = -69972891;
  v5[96] = 1303535960;
  v5[97] = 984961486;
  v5[98] = -1547960204;
  v5[99] = -725929758;
  v5[100] = 1256170817;
  v5[101] = 1037604311;
  v5[102] = -1529756563;
  v5[103] = -740887301;
  v5[104] = 1131014506;
  v5[105] = 879679996;
  v5[106] = -1385723834;
  v5[107] = -631195440;
  v5[108] = 1141124467;
  v5[109] = 855842277;
  v5[110] = -1442165665;
  v5[111] = -586318647;
  v5[112] = 1342533948;
  v5[113] = 654459306;
  v5[114] = -1106571248;
  v5[115] = -921952122;
  v5[116] = 1466479909;
  v5[117] = 544179635;
  v5[118] = -1184443383;
  v5[119] = -832445281;
  v5[120] = 1591671054;
  v5[121] = 702138776;
  v5[122] = -1328506846;
  v5[123] = -942167884;
  v5[124] = 1504918807;
  v5[125] = 783551873;
  v5[126] = -1212326853;
  v5[127] = -1061524307;
  v5[128] = -306674912;
  v5[129] = -1698712650;
  v5[130] = 62317068;
  v5[131] = 1957810842;
  v5[132] = -355121351;
  v5[133] = -1647151185;
  v5[134] = 81470997;
  v5[135] = 1943803523;
  v5[136] = -480048366;
  v5[137] = -1805370492;
  v5[138] = 225274430;
  v5[139] = 2053790376;
  v5[140] = -468791541;
  v5[141] = -1828061283;
  v5[142] = 167816743;
  v5[143] = 2097651377;
  v5[144] = -267414716;
  v5[145] = -2029476910;
  v5[146] = 503444072;
  v5[147] = 1762050814;
  v5[148] = -144550051;
  v5[149] = -2140837941;
  v5[150] = 426522225;
  v5[151] = 1852507879;
  v5[152] = -19653770;
  v5[153] = -1982649376;
  v5[154] = 282753626;
  v5[155] = 1742555852;
  v5[156] = -105259153;
  v5[157] = -1900089351;
  v5[158] = 397917763;
  v5[159] = 1622183637;
  v5[160] = -690576408;
  v5[161] = -1580100738;
  v5[162] = 953729732;
  v5[163] = 1340076626;
  v5[164] = -776247311;
  v5[165] = -1497606297;
  v5[166] = 1068828381;
  v5[167] = 1219638859;
  v5[168] = -670225446;
  v5[169] = -1358292148;
  v5[170] = 906185462;
  v5[171] = 1090812512;
  v5[172] = -547295293;
  v5[173] = -1469587627;
  v5[174] = 829329135;
  v5[175] = 1181335161;
  v5[176] = -882789492;
  v5[177] = -1134132454;
  v5[178] = 628085408;
  v5[179] = 1382605366;
  v5[180] = -871598187;
  v5[181] = -1156888829;
  v5[182] = 570562233;
  v5[183] = 1426400815;
  v5[184] = -977650754;
  v5[185] = -1296233688;
  v5[186] = 733239954;
  v5[187] = 1555261956;
  v5[188] = -1026031705;
  v5[189] = -1244606671;
  v5[190] = 752459403;
  v5[191] = 1541320221;
  v5[192] = -1687895376;
  v5[193] = -328994266;
  v5[194] = 1969922972;
  v5[195] = 40735498;
  v5[196] = -1677130071;
  v5[197] = -351390145;
  v5[198] = 1913087877;
  v5[199] = 83908371;
  v5[200] = -1782625662;
  v5[201] = -491226604;
  v5[202] = 2075208622;
  v5[203] = 213261112;
  v5[204] = -1831694693;
  v5[205] = -438977011;
  v5[206] = 2094854071;
  v5[207] = 198958881;
  v5[208] = -2032938284;
  v5[209] = -237706686;
  v5[210] = 1759359992;
  v5[211] = 534414190;
  v5[212] = -2118248755;
  v5[213] = -155638181;
  v5[214] = 1873836001;
  v5[215] = 414664567;
  v5[216] = -2012718362;
  v5[217] = -15766928;
  v5[218] = 1711684554;
  v5[219] = 285281116;
  v5[220] = -1889165569;
  v5[221] = -127750551;
  v5[222] = 1634467795;
  v5[223] = 376229701;
  v5[224] = -1609899400;
  v5[225] = -686959890;
  v5[226] = 1308918612;
  v5[227] = 956543938;
  v5[228] = -1486412191;
  v5[229] = -799009033;
  v5[230] = 1231636301;
  v5[231] = 1047427035;
  v5[232] = -1362007478;
  v5[233] = -640263460;
  v5[234] = 1088359270;
  v5[235] = 936918000;
  v5[236] = -1447252397;
  v5[237] = -558129467;
  v5[238] = 1202900863;
  v5[239] = 817233897;
  v5[240] = -1111625188;
  v5[241] = -893730166;
  v2 = buffer;
  v3 = -1;
  v5[242] = 1404277552;
  v5[243] = 615818150;
  v5[244] = -1160759803;
  v5[245] = -841546093;
  v5[246] = 1423857449;
  v5[247] = 601450431;
  v5[248] = -1285129682;
  v5[249] = -1000256840;
  v5[250] = 1567103746;
  v5[251] = 711928724;
  v5[252] = -1274298825;
  v5[253] = -1022587231;
  v5[254] = 1510334235;
  for ( v5[255] = 755167117; v2 < &buffer[fileSize]; ++v2 )
    v3 = v5[*v2 ^ v3] ^ (v3 >> 8) & 0xFFFFFF;
  return ~v3;
}

//----- (00408270) --------------------------------------------------------
FILE *__cdecl RewriteSameFile(int unused, const char *Filename)
{
  FILE *result; // eax
  FILE *readFileHandle; // esi
  FILE *writeFileHandle; // edi
  int totalRead; // eax
  char DstBuf[2048]; // [esp+8h] [ebp-800h] BYREF

  result = fopen(
             Filename,
             "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
             "\x00\x00\x00Player spectating game: %s\n"
             "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1"
             " minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00"
             "\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00"
             "\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00"
             "Player kicked off for not returning security packet: %s\n"
             "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00P"
             "arameters resent for arena(%s)\n"
             "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user paramet"
             "er.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00"
             "Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points "
             "to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Ja"
             "velins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spid"
             "ers:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
             "\x00\x00\x00%s=%s\n"
             "\x00\x00[%s]\n"
             "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
             "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resi"
             "ze)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
             "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked o"
             "ff, arena full to demo users: %s\n"
             "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
             "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
             "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
             "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
             "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
             "\x00%s>  MODERATOR LOGGED IN\n"
             "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
             "\x00%s> SYSOP LOGGED IN\n"
             "\x00\x00\x00\x00Connection request from: %s\n"
             "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00F"
             "ile has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00"
             "File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00"
             "\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempt"
             "ing to enter game");
  readFileHandle = result;
  if ( result )
  {
    writeFileHandle = fopen(Filename, Mode);
    if ( writeFileHandle )
    {
      while ( (readFileHandle->_flag & 0x10) == 0 )
      {
        totalRead = fread(DstBuf, 1u, 0x800u, readFileHandle);// Read 2048 bytes from one file
        if ( totalRead > 0 )
          fwrite(DstBuf, 1u, totalRead, writeFileHandle);// Write Whatever you Read into same file???
      }
      fclose(writeFileHandle);
    }
    result = fclose(readFileHandle);
  }
  return result;
}

//----- (00408310) --------------------------------------------------------
// returns ptr to alloced space, with a preceding dword with the allocced size
// 
// uses virtualalloc if sz is >= half a meg
// 
// ex:
// emalloc(DWORD sz)
//    DWORD *buf = malloc(sz + 4);
//    buf[0] = sz + 4;
//    return &buf[1];
// 
void *__cdecl emalloc(int bytes)
{
  _DWORD *v1; // eax
  void *v2; // esi
  char Text[252]; // [esp+8h] [ebp-100h] BYREF

  if ( bytes + 4 <= 0x80000 )
    v1 = malloc(bytes + 4);
  else
    v1 = VirtualAlloc(0, bytes + 4, 0x1000u, 4u);
  if ( v1 )
  {
    *v1 = bytes + 4;
    v2 = v1 + 1;
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
  {
    sprintf(Text, "Out of memory (Alloc:%d)", bytes);
    MessageBoxA(0, Text, "Error", 0x30u);
    exit(1);
  }
  return v2;
}

//----- (004083A0) --------------------------------------------------------
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3)
{
  int v3; // ecx
  int v4; // edi
  _DWORD *v5; // eax
  LPVOID v6; // esi
  LPVOID result; // eax
  char *v8; // eax
  int v9; // esi
  signed int v10; // edi
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  void *v13; // ebp
  unsigned int v14; // ecx
  int *Memory; // [esp+10h] [ebp-104h]
  CHAR Dest[256]; // [esp+14h] [ebp-100h] BYREF

  v3 = a3;
  if ( a2 > 0x80000 )
    v3 = 16 * a3;
  v4 = v3 * ((v3 + a2 - 1) / v3);
  if ( lpAddress )
  {
    if ( v4 )
    {
      v9 = *(lpAddress - 1);
      v10 = v4 + 4;
      Memory = (lpAddress - 4);
      if ( v10 == v9 )
      {
        result = lpAddress;
      }
      else if ( v9 > 0x80000 || v10 > 0x80000 )
      {
        if ( v10 <= 0x80000 )
          v12 = malloc(v10);
        else
          v12 = VirtualAlloc(0, v10, 0x1000u, 4u);
        if ( v12 )
        {
          *v12 = v10;
          v13 = v12 + 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
        {
          sprintf(Dest, "Out of memory (Alloc:%d)", v10 - 4);
          MessageBoxA(0, Dest, "Error", 0x30u);
          exit(1);
        }
        v14 = v9 - 4;
        if ( v9 - 4 >= v10 - 4 )
          v14 = v10 - 4;
        qmemcpy(v13, lpAddress, v14);
        if ( *Memory <= 0x80000 )
          free(Memory);
        else
          VirtualFree(Memory, 0, 0x8000u);
        result = v13;
      }
      else
      {
        v11 = realloc(lpAddress - 4, v10);
        if ( !v11 )
        {
          MessageBoxA(0, "Out of memory (Resize)", "Error", 0x30u);
          exit(1);
        }
        *v11 = v10;
        result = v11 + 1;
      }
    }
    else
    {
      v8 = lpAddress - 4;
      if ( *(lpAddress - 1) <= 0x80000 )
        free(v8);
      else
        VirtualFree(v8, 0, 0x8000u);
      result = 0;
    }
  }
  else
  {
    if ( v4 + 4 <= 0x80000 )
      v5 = malloc(v4 + 4);
    else
      v5 = VirtualAlloc(0, v4 + 4, 0x1000u, 4u);
    if ( v5 )
    {
      *v5 = v4 + 4;
      v6 = v5 + 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
    {
      sprintf(Dest, "Out of memory (Alloc:%d)", v4);
      MessageBoxA(0, Dest, "Error", 0x30u);
      exit(1);
    }
    result = v6;
  }
  return result;
}

//----- (004085C0) --------------------------------------------------------
// see emalloc()
void __stdcall efree(LPVOID ptr)
{
  if ( *(ptr - 1) <= 0x80000 )
    free(ptr - 4);
  else
    VirtualFree(ptr - 4, 0, 0x8000u);           // RELEASE PAGED
}
// 4085C0: inconsistent function type and number of purged bytes

//----- (004085F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall ConnectSocket(SOCKET_STRUCT *Socket, const char *Hostname, u_short Port, u_short ListenPort)
{
  SOCKET v5; // eax
  u_long v6; // eax
  SOCKET v7; // ecx
  unsigned __int32 v8; // edi
  struct hostent *v9; // eax
  DWORD v10; // kr00_4
  SOCKET v11; // eax
  SOCKET v12; // [esp-14h] [ebp-48h]
  SOCKET v13; // [esp-14h] [ebp-48h]
  SOCKET v14; // [esp-14h] [ebp-48h]
  char optval[4]; // [esp+Ch] [ebp-28h] BYREF
  u_long argp; // [esp+10h] [ebp-24h] BYREF
  struct sockaddr name; // [esp+14h] [ebp-20h] BYREF
  struct sockaddr v18; // [esp+24h] [ebp-10h] BYREF

  v5 = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
  Socket->socket = v5;
  argp = 1;
  ioctlsocket(v5, 2147772030, &argp);
  v12 = Socket->socket;
  *optval = -1;
  setsockopt(v12, 6, 1, optval, 4);
  v13 = Socket->socket;
  *optval = 1024;
  setsockopt(v13, 0xFFFF, 4097, optval, 4);
  v14 = Socket->socket;
  *optval = 1024;
  setsockopt(v14, 0xFFFF, 4098, optval, 4);
  name.sa_family = 2;
  *name.sa_data = htons(ListenPort);
  v6 = htonl(0);
  v7 = Socket->socket;
  *&name.sa_data[2] = v6;
  bind(v7, &name, 16);
  v8 = inet_addr(Hostname);
  if ( v8 == -1 )
  {
    v9 = gethostbyname(Hostname);
    if ( v9 )
      v8 = **v9->h_addr_list;
  }
  v18.sa_family = 2;
  *&v18.sa_data[2] = v8;
  *v18.sa_data = htons(Port);
  connect(Socket->socket, &v18, 16);
  Socket->minus1of2 = -1;
  Socket->minus2of2 = -1;
  v10 = GetTickCount();
  v11 = Socket->socket;
  *&ListenPort = v10 / 0xA;
  send(v11, &ListenPort, 4, 0);
}
// 408716: inconsistent variable size for '^54.2(ListenPort)'

//----- (00408740) --------------------------------------------------------
int __thiscall sub_408740(SOCKET *this)
{
  return closesocket(*this);
}

//----- (00408750) --------------------------------------------------------
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3)
{
  DWORD v4; // [esp+Ch] [ebp-404h] BYREF
  char buf[4]; // [esp+10h] [ebp-400h] BYREF
  char v6[1020]; // [esp+14h] [ebp-3FCh] BYREF

  if ( a2 && a3 > 0 )
  {
    *buf = 0;
    qmemcpy(v6, a2, a3);
    send(*this, buf, a3 + 4, 0);
  }
  else
  {
    v4 = GetTickCount() / 0xA;
    send(*this, &v4, 4, 0);
  }
}
// 408750: using guessed type char var_3FC[1020];

//----- (004087D0) --------------------------------------------------------
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed)
{
  int sizeRecieved; // esi
  char buf[512]; // [esp+Ch] [ebp-200h] BYREF

  do
  {
    if ( recv(*Socket, buf, 512, MSG_PEEK) == -1 )
      break;
    sizeRecieved = recv(*Socket, buf, 512, 0);
    if ( sizeRecieved == 8 )
    {
      *(Socket + 4) = *buf;
      *(Socket + 8) = GetTickCount() / 0xA - *&buf[4];
    }
  }
  while ( sizeRecieved != -1 );
  *TimeElapsed = *(Socket + 8);
  return *(Socket + 4);
}

//----- (00408860) --------------------------------------------------------
// PINGSOCKET.PingSocket()
SOCKET_STRUCT2 *__thiscall ListenOnPort(SOCKET_STRUCT2 *socket, __int16 Port, int callback)
{
  SOCKET v4; // eax
  u_long v5; // eax
  SOCKET v6; // ecx
  SOCKET v8; // [esp-14h] [ebp-2Ch]
  SOCKET v9; // [esp-14h] [ebp-2Ch]
  SOCKET v10; // [esp-14h] [ebp-2Ch]
  u_long argp; // [esp+4h] [ebp-14h] BYREF
  struct sockaddr name; // [esp+8h] [ebp-10h] BYREF

  socket->optval = callback;
  v4 = ::socket(2, 2, 0);
  socket->socket = v4;
  argp = 1;
  ioctlsocket(v4, -2147195266, &argp);
  v8 = socket->socket;
  callback = -1;
  setsockopt(v8, 6, IP_OPTIONS, &callback, 4);
  v9 = socket->socket;
  callback = 8192;
  setsockopt(v9, 0xFFFF, 4097, &callback, 4);
  v10 = socket->socket;
  callback = 0x2000;
  setsockopt(v10, 0xFFFF, 4098, &callback, 4);
  name.sa_family = 2;
  *name.sa_data = htons(Port);
  v5 = htonl(0);
  v6 = socket->socket;
  *&name.sa_data[2] = v5;
  bind(v6, &name, 16);
  return socket;
}

//----- (00408930) --------------------------------------------------------
void __thiscall ProcessZonePings(SOCKET_STRUCT2 *Socket, int dwZonePopulation)
{
  int i; // ebp
  unsigned int v4; // eax
  void (__cdecl *v5)(_DWORD, char *, unsigned int); // ecx
  SOCKET v6; // eax
  SOCKET v7; // [esp-18h] [ebp-244h]
  int fromlen; // [esp+10h] [ebp-21Ch] BYREF
  char v9[4]; // [esp+14h] [ebp-218h] BYREF
  int v10; // [esp+18h] [ebp-214h]
  struct sockaddr from; // [esp+1Ch] [ebp-210h] BYREF
  char buf[4]; // [esp+2Ch] [ebp-200h] BYREF
  char v13[508]; // [esp+30h] [ebp-1FCh] BYREF

  for ( i = 0; i < 20; ++i )
  {
    v7 = Socket->socket;
    fromlen = 16;
    v4 = recvfrom(v7, buf, 512, 0, &from, &fromlen);
    if ( v4 == -1 )
      break;
    if ( v4 >= 4 )
    {
      if ( *buf )
      {
        v6 = Socket->socket;
        v10 = *buf;
        *v9 = dwZonePopulation;
        sendto(v6, v9, 8, 0, &from, 16);
      }
      else
      {
        v5 = Socket->optval;
        if ( v5 )
        {
          if ( v4 > 4 )
            v5(*&from.sa_data[2], v13, v4 - 4);
        }
      }
    }
  }
}

//----- (004089E0) --------------------------------------------------------
// Player.Player()
struct_PLAYER *__thiscall CreateNewPlayer(struct_PLAYER *player, struct in_addr in, __int16 a3, NetData *nd)
{
  Encryption_Struct *someStructThatHasPlayerId; // edx
  int playerId; // eax

  player->unknownIthoughtItWasPlayerPointerDupe = 0;
  player->dword4 = 0;
  player->dword8 = 0;
  player->dwordC = 0;
  memset(player->someStringBuffer, 0, sizeof(player->someStringBuffer));
  player->TypedName[0] = 0;
  player->DemoPlayer = 0;
  player->KingCrownKills = 0;
  player->KotHDeathCount = 0;
  player->field_15F = -1;
  player->isEnergyShowing = 0;
  player->field_60 = -1;
  player->field_5C = -1;
  player->field_58 = -1;
  player->IsSilenced = 0;
  player->field_15B = 0;
  player->field_50 = -1;
  player->field_54 = -1;
  player->field_157 = 0;
  player->field_A8 = 0;
  player->field_BC = 0;
  player->field_3C = 0;
  player->field_4C = -1;
  player->field_153 = 0;
  player->BillerPlayerId = dword_42A534++;
  player->field_305 = 0;
  player->SlowModem = 0;
  player->AlreadySentReliablePacket = 0;
  player->KickOffDelayTimer = 0;
  player->field_FD = 0;
  player->encryptionPointer = nd;
  player->MyArena = 0;
  player->field_20 = 0;
  memset(player->field_33D, 0, sizeof(player->field_33D));
  player->PlayerName[0] = 0;
  player->field_11F = 0;
  memset(player->gap_12B, 0, 0x28u);
  player->S2CPacketLossPercentage = 1000;
  player->C2SPacketLossPercentage = 1000;
  player->field_283 = 0;
  player->IPAddressDWORD = in.S_un.S_addr;
  player->Port = a3;
  player->pfile329 = 0;
  player->char32d = 0;
  player->Frequency = -1;
  player->isSysop = 0;
  player->isModerator = 0;
  player->isSuperModerator = 0;
  player->AttachedToPlayerId = -1;
  memset(player->Name, 0, 0xACu);
  player->UserId = -1;
  *&player->CurrentWins = 0;
  *&player->GoalCount = 0;
  *(&player->KillPoints + 2) = 0;
  HIWORD(player->FlagPoints) = 0;
  *&player->PersonalBestWins = 0;
  *&player->field_235 = 0;
  *&player->Points = 0;
  player->FlagPointsHiWord = 0;
  player->ArenaPlayerIndex = -1;
  someStructThatHasPlayerId = player->encryptionPointer;
  player->Ship = 8;
  player->IsSpeced = 0;
  player->TotalShipChanges = 0;
  player->dword30 = 0;
  playerId = someStructThatHasPlayerId->dword2E;
  *&player->PlayerId = playerId;
  PlayerList[playerId] = player;
  player->NoPasswordPacketDelayTimer = GetTickCount() / 0xA;
  player->TotalUsageSeconds2 = time(0);
  player->field_297 = 0;
  player->field_287 = 0;
  *player->gap_28B = 0;
  player->field_29F = 0;
  player->GetTickCountValueDividedByTen2 = GetTickCount() / 0xA;
  player->dword293 = 0;
  player->field_29B = 0;
  player->field_29F = 0;
  player->field_B4 = 0;
  player->C2SCurrentFast = 0;
  player->C2SCurrentSlow = 0;
  player->C2SCurrentTotalFast = 0;
  player->C2SCurrentTotalSlow = 0;
  player->DisconnectReason = 0;
  player->C2SAverageLatencyFirst = 0;
  player->C2SAverageLatencySecond = 0;
  player->field_30D = 0;
  player->LatencyKickOutDelayTimer = 0;
  *player->gap_309 = 1;
  return player;
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 42A534: using guessed type int dword_42A534;

//----- (00408C30) --------------------------------------------------------
void __thiscall DisconnectUser(struct_PLAYER *player)
{
  char *v2; // esi
  char *v3; // ebp
  int v4; // ecx
  int v5; // ebp
  char i; // al
  struct_ARENA *v7; // ecx
  Encryption_Struct *v8; // ecx
  char *v9; // esi
  int v10; // ebp
  BOOL v11; // eax
  int Ping; // [esp+10h] [ebp-B0h] BYREF
  int Latency; // [esp+14h] [ebp-ACh] BYREF
  int MiscTimedGame; // [esp+18h] [ebp-A8h]
  char PlayerName[32]; // [esp+1Ch] [ebp-A4h] BYREF
  char v16; // [esp+3Ch] [ebp-84h]
  char Str[128]; // [esp+40h] [ebp-80h] BYREF

  if ( player->unknownIthoughtItWasPlayerPointerDupe )
  {
    TerminateProcess(player->unknownIthoughtItWasPlayerPointerDupe, 0);
    CloseHandle(player->unknownIthoughtItWasPlayerPointerDupe);
  }
  if ( player->pfile329 )
  {
    fclose(player->pfile329);
    player->pfile329 = 0;
  }
  if ( AutoPermissionPoints > 0 && player->FlagPoints + player->KillPoints >= AutoPermissionPoints )
  {
    v2 = PermissionAutoPermissionIDList;
    while ( *v2 )
    {
      v3 = Str;
      if ( isdigit(*v2) )
      {
        do
        {
          v4 = v2[1];
          *v3++ = *v2++;
        }
        while ( isdigit(v4) );
      }
      *v3 = 0;
      v5 = atoi(Str);
      if ( v5 && BillingConnectionStructPointer )
      {
        PlayerName[0] = 1;
        strncpy(&PlayerName[1], player->Name, 0x20u);
        v16 = 0;
        SendBillerPlayerNamePacketSomething(BillingConnectionStructPointer, -1, v5, PlayerName, 0x21u);
      }
      for ( i = *v2; i; i = *++v2 )
      {
        if ( isdigit(i) )
          break;
      }
    }
  }
  v7 = player->MyArena;
  MiscTimedGame = 0;
  if ( v7 )
  {
    MiscTimedGame = v7->ServersideArenaSettings.MiscTimedGame;
    ArenaRemovePlayer(v7, player);
    player->MyArena = 0;
  }
  sub_41CB70(player->encryptionPointer, &Latency, &Ping);
  v8 = player->encryptionPointer;
  Latency = 1000 - Latency;
  Ping = 1000 - Ping;
  sub_41B7A0(v8);
  v9 = player->field_33D;
  v10 = 4;
  PlayerList[*&player->PlayerId] = 0;
  do
  {
    if ( *v9 )
    {
      efree(*v9);
      *v9 = 0;
    }
    v9 += 8;
    --v10;
  }
  while ( v10 );
  if ( BillingConnectionStructPointer )
  {
    v11 = player->DemoPlayer != 0;
    if ( MiscTimedGame
      || player->FlagPoints + player->KillPoints + player->CurrentWins + player->CurrentLosses <= 5
      && !player->field_30D )
    {
      v11 = 1;
    }
    if ( v11 )
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        player->BillerPlayerId,
        player->DisconnectReason,
        Latency,
        Ping,
        10 * player->CurrentPing,
        10 * player->C2SAverageLatencyFirst / (player->C2SAverageLatencySecond + 1),
        0,
        0);
    else
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        player->BillerPlayerId,
        player->DisconnectReason,               // TODO: This might be WORD not DWORD
        Latency,
        Ping,
        10 * player->CurrentPing,
        10 * player->C2SAverageLatencyFirst / (player->C2SAverageLatencySecond + 1),
        &player->CurrentWins,
        0xEu);
  }
}

//----- (00408E80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall PlayerHandleGamePacket(struct_PLAYER *playerr, unsigned __int8 *packet, int packetSize)
{
  unsigned __int8 *packett; // ebx
  int packetId; // ecx
  struct_ARENA *v6; // ecx
  unsigned __int8 *v7; // esi
  int v8; // eax
  int v9; // eax
  struct_ARENA *v10; // ebp
  int v11; // eax
  int v12; // eax
  struct_ARENA *v13; // esi
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  struct_PLAYER **v17; // eax
  int SoccerReward; // esi
  int temp2; // esi
  struct_ARENA *v20; // eax
  int v21; // ecx
  int v22; // ebx
  int v23; // ebx
  unsigned int v24; // kr08_4
  unsigned int v25; // kr14_4
  bool v26; // cc
  struct_ARENA *v27; // ecx
  __int16 temp3; // ax
  struct_ARENA *v29; // ecx
  struct_ARENA *v30; // ecx
  struct_ARENA *v31; // ebp
  int v32; // eax
  char *v33; // eax
  Arena_Struct *v34; // esi
  int CountPlayersIThink; // edx
  int v36; // ecx
  __int16 *v37; // eax
  struct_ARENA *v38; // ebp
  int v39; // eax
  int v40; // eax
  struct_ARENA *arena; // ecx
  int SettingsUserId; // eax
  unsigned int v43; // esi
  const CHAR *ChangedSetting; // esi
  unsigned int v45; // kr20_4
  CHAR v46; // al
  __int16 XTiles; // ax
  __int16 YTiles; // bx
  struct_ARENA *v49; // eax
  DWORD v50; // eax
  int ArenaSettingsChecksum; // ecx
  ARENA_SETTINGS *v52; // eax
  int v53; // edx
  int v54; // edx
  struct_ARENA *v55; // edx
  int SubSpaceEXECheckSum; // ecx
  int v57; // eax
  int v58; // esi
  char *v59; // eax
  int v60; // edx
  int MapLVLCheckSum; // eax
  int v62; // eax
  int v63; // esi
  struct_ARENA *v64; // ecx
  unsigned int v65; // kr30_4
  struct_ARENA *v66; // eax
  void *v67; // eax
  int SubSpaceVersion; // edx
  int v69; // eax
  char *v70; // ecx
  int v71; // eax
  char *v72; // ecx
  unsigned __int8 PositionPacketChecksum; // dl
  char Checksum; // al
  unsigned __int8 *packettt; // ecx
  int ChecksumCounter; // esi
  int v77; // esi
  int v78; // esi
  Encryption_Struct *v79; // edi
  int v80; // edx
  int v81; // esi
  struct_ARENA *v82; // ecx
  unsigned int v83; // kr38_4
  __int16 XPixels; // cx
  __int64 v85; // rax
  __int64 v86; // rax
  int v87; // eax
  int v88; // edx
  int ArenaPlayerIndex; // eax
  struct_PLAYER *arenaPlayer; // eax
  __int16 v91; // ax
  __int16 v92; // dx
  int AnotherArenaPlayerIndex; // eax
  struct_PLAYER *v94; // eax
  int currentCrownKills; // eax
  __int16 v96; // ax
  struct_ARENA *v97; // ecx
  struct_ARENA *v98; // edx
  __int16 killerPlayerId; // ax
  struct_PLAYER *killerr; // esi
  struct_ARENA *arenaa; // ecx
  __int16 FlagCarrierPlayerId; // ax
  struct_ARENA *v103; // ecx
  int FlagMode; // eax
  __int16 FlagCarrierPlayerIdd; // ax
  struct_ARENA *v106; // ecx
  struct_ARENA *v107; // ecx
  int v108; // eax
  int v109; // eax
  int v110; // eax
  struct_ARENA *v111; // ecx
  struct_ARENA *v112; // eax
  struct_ARENA *v113; // eax
  int newTotalCrownKillsNeededMaybe; // eax
  int newTotalCrownKillsNeededMaybee; // edx
  struct_ARENA *v116; // eax
  int v117; // ecx
  __int16 v118; // cx
  struct_ARENA *v119; // ecx
  struct_ARENA *v120; // eax
  int v121; // eax
  struct_ARENA *v122; // edi
  char *v123; // edx
  int v124; // eax
  __int16 v125; // ax
  struct_ARENA *v126; // ecx
  int v127; // eax
  int MyNewBounty; // ebx
  struct_ARENA *v129; // ecx
  int v130; // edi
  struct_ARENA *v131; // ecx
  int v132; // edi
  int v133; // eax
  int v134; // edi
  int MaxBonuss; // edx
  int MaxBonus; // eax
  int v137; // edi
  int v138; // eax
  int v139; // edx
  char *v140; // ecx
  int v141; // ebx
  char *v142; // eax
  int v143; // eax
  int v144; // ebx
  int v145; // eax
  int v146; // eax
  struct_ARENA *v147; // eax
  int v148; // edx
  int v149; // ecx
  int v150; // esi
  int v151; // eax
  int v152; // edi
  int v153; // ebx
  signed int v154; // edi
  unsigned int v155; // kr40_4
  struct PLAYER *v156; // edi
  struct_ARENA *v157; // ecx
  __int16 v158; // bx
  int v159; // esi
  struct_ARENA *v160; // edi
  __int16 v161; // ax
  __int16 v162; // dx
  struct_ARENA *v163; // ecx
  int v164; // esi
  struct_ARENA *v165; // eax
  int v166; // edi
  struct_PLAYER *v167; // eax
  int v168; // ecx
  int v169; // edx
  int v170; // ecx
  int v171; // ecx
  int v172; // ebx
  struct_PLAYER *v173; // ecx
  struct_PLAYER *playerrr; // esi
  int ArenaPlayerIndexx; // edx
  int v176; // edx
  int v177; // eax
  int v178; // esi
  int AttachedToPlayerId; // edx
  signed int v180; // edi
  __int64 v181; // rax
  __int64 v182; // rax
  int v183; // edx
  int MiscMaxLossesToPlay; // eax
  struct_ARENA *v185; // eax
  __int16 v186; // ax
  __int16 v187; // ax
  int v188; // esi
  Encryption_Struct *v189; // edi
  int v190; // edx
  struct_ARENA *v191; // eax
  __int16 v192; // dx
  __int16 v193; // cx
  int v194; // edx
  __int16 v195; // cx
  int v196; // ebx
  int v197; // edi
  int v198; // esi
  struct_PLAYER *v199; // eax
  struct_ARENA *v200; // eax
  struct_ARENA *v201; // esi
  __int64 v202; // rax
  __int16 v203; // ax
  int v204; // ecx
  int v205; // edx
  int v206; // edi
  char *v207; // eax
  __int16 v208; // ax
  struct_ARENA *v209; // eax
  struct_ARENA *v210; // eax
  int MaxLossesToPlay; // ecx
  int Ship; // ecx
  char Shipp; // al
  struct_ARENA *v214; // eax
  __int16 v215; // cx
  int v216; // edi
  int v217; // esi
  struct_PLAYER *v218; // eax
  struct_ARENA *v219; // ecx
  __int16 v220; // ax
  struct_ARENA *v221; // ecx
  int v222; // eax
  __int16 ArenaPlayerIndexxx; // bx
  int ArenaPlayerIndexxxx; // esi
  struct_PLAYER *v225; // eax
  struct PLAYER *v226; // ecx
  int v227; // ebp
  struct PLAYER *v228; // ecx
  struct_ARENA *v229; // eax
  struct_ARENA *v230; // ecx
  char *v231; // ebp
  int v232; // esi
  struct_ARENA *v233; // eax
  __int16 v234; // dx
  char numberOfPacketChunks; // al
  __int16 arenaPlayerIndex; // bx
  int v237; // ebx
  char *v238; // eax
  __int16 v239; // dx
  unsigned int v240; // kr58_4
  struct_ARENA *v241; // eax
  char v242; // al
  struct_ARENA *v243; // ecx
  struct_ARENA *v244; // eax
  struct_ARENA *v245; // eax
  int v246; // eax
  unsigned int v247; // kr60_4
  char *v248; // edx
  int ArenaPlayerIndexxxxxx; // eax
  struct_PLAYER *v250; // eax
  unsigned int v251; // kr6C_4
  char *v252; // edx
  const char *v253; // edi
  unsigned int v254; // kr78_4
  BOOL v255; // esi
  const char *v256; // edi
  FILE *v257; // eax
  FILE *v258; // esi
  unsigned int v259; // kr88_4
  unsigned int v260; // kr90_4
  __int16 v261; // ax
  struct_PLAYER *v262; // eax
  __int16 MyAttachPlayerId; // dx
  int v264; // eax
  int v265; // ecx
  struct_ARENA *v266; // eax
  int v267; // edi
  int v268; // esi
  struct_PLAYER *v269; // eax
  struct_ARENA *v270; // eax
  int v271; // ecx
  char *v272; // ebx
  int v273; // edi
  char *v274; // esi
  int ConnectType; // ecx
  signed __int8 v276; // al
  int v277; // eax
  char *v278; // eax
  int v279; // eax
  KickStruct *v280; // ecx
  signed int CurrentPlayerCountt; // edx
  signed int v282; // esi
  struct_PLAYER **v283; // eax
  UINT v284; // ecx
  signed int ArenaPlayerIndexxxxx; // ebx
  struct_PLAYER **v286; // eax
  struct_PLAYER *v287; // eax
  unsigned int v288; // krA0_4
  BILLING_SERVER_STRUCT *v289; // ecx
  int v290; // ecx
  int v291; // eax
  int SubspaceEXEChecksum; // ecx
  int isModerator; // eax
  struct_ARENA *v294; // eax
  __int64 v295; // rax
  const char *v296; // [esp-8h] [ebp-6FCh]
  struct_PLAYER *v297; // [esp-4h] [ebp-6F8h]
  char v298; // [esp-4h] [ebp-6F8h]
  const char *v299; // [esp+0h] [ebp-6F4h]
  char buffer[4]; // [esp+10h] [ebp-6E4h] BYREF
  char playerra[256]; // [esp+14h] [ebp-6E0h] BYREF
  const char a1[256]; // [esp+290h] [ebp-464h] BYREF
  char v303[99]; // [esp+390h] [ebp-364h] BYREF
  const char Dest[256]; // [esp+3F4h] [ebp-300h] BYREF
  char *buf; // [esp+4F4h] [ebp-200h] OVERLAPPED BYREF
  char *v306; // [esp+4F9h] [ebp-1FBh] BYREF

  packett = packet;
  packetId = *packet;
  *playerra = packetId;
  switch ( packetId )
  {
    case 1:                                     // 0x01 - Arena login
      if ( playerr->Name[0] )
      {
        if ( playerr->isSuperModerator || sub_41B960(playerr->encryptionPointer) == 1 )
        {
          v242 = packet[1];
          if ( v242 > 8 || v242 < 0 )
          {
            if ( !playerr->isSuperModerator )
            {
              sprintf(a1, "Packet tampering(%d)", *packet);
              SendBillerWarnings(a1, playerr);
              v245 = playerr->MyArena;
              if ( v245 )
              {
                if ( v245->ServersideArenaSettings.dwordB4 )
                {
                  playerr->DisconnectReason = 0x10;// 0x10 - Restricted Zone - Compare against local Subspace.exe to determine if an Update is needed.
                  playerr->AlreadySentReliablePacket = 1;
                }
              }
            }
          }
          else
          {
            v243 = playerr->MyArena;
            if ( v243 )
            {
              ArenaRemovePlayer(v243, playerr);
              playerr->MyArena = 0;
            }
            playerr->ArenaPlayerIndex = -1;
            playerr->Ship = packet[1];
            playerr->AllowAudioByte1 = packet[2];
            playerr->XResolution = *(packet + 2);
            playerr->YResolution = *(packet + 3);
            playerr->AllowAudioByte2 = packet[3];
            if ( playerr->IsSpeced )
              playerr->Ship = 8;
            *playerr->gap_309 = 1;
            *&buffer[1] = playerr->PlayerId;
            buffer[0] = 1;                      // 0x01 - PlayerID Change
            SendPlayerReliablePacket(playerr, buffer, 3u, 1);
            v244 = ArenaHandler(playerr, *(packet + 4), packet + 10);
            playerr->MyArena = v244;
            playerr->field_20 = v244;
            PlayerEntering(v244, playerr);
          }
        }
        else
        {
          SendBillerWarnings("Incompatible network protocol attempting to enter game", playerr);
          playerr->AlreadySentReliablePacket = 1;
        }
      }
      return;
    case 2:                                     // 0x02 - Leave arena
      v230 = playerr->MyArena;
      if ( v230 )
      {
        ArenaRemovePlayer(v230, playerr);
        playerr->MyArena = 0;                   // Reset your arena pointer
      }
      printf("Player leaving game: %s\n", playerr->Name);
      v231 = playerr->field_33D;
      v232 = 4;
      do
      {
        if ( *v231 )
        {
          efree(*v231);
          *v231 = 0;
        }
        v231 += 8;
        --v232;
      }
      while ( v232 );
      return;
    case 3:                                     // 0x03 - Position packet
      *playerr->gap_309 = 0;
      if ( !playerr->MyArena )
        return;
      PositionPacketChecksum = packet[10];      // Checksum BYTE
      Checksum = 0;
      packet[10] = 0;
      packettt = packet;
      ChecksumCounter = 22;
      do
      {
        Checksum ^= *packettt++;
        --ChecksumCounter;
      }
      while ( ChecksumCounter );
      if ( Checksum != PositionPacketChecksum )
      {
        if ( !playerr->isSysop )
        {
          v77 = playerr->field_157 + 1;
          playerr->field_157 = v77;
          if ( v77 >= playerr->MyArena->ServersideArenaSettings.SecurityPacketModificationMax )
          {
            SendBillerWarnings("C2S position packet checksum error", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
        }
        return;
      }
      if ( (packet[11] & 0x40) != 0 && !playerr->field_3C )// Togglables
        return;
      if ( *(packet + 8) > 10000 && !playerr->isSuperModerator && !playerr->field_305 )// Bounty
        goto LABEL_358;
      if ( (packet[20] & 0x1F) != 0 )
        playerr->field_BC = 0;
      v78 = *(packet + 2);
      v79 = playerr->encryptionPointer;
      v80 = ((v79->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v78;// Timestamp
      v81 = v80;
      *&playerra[8] = v80;
      if ( v80 < 0 || v80 > 30000 )
      {
        v81 = 0;
        *&playerra[8] = 0;
      }
      if ( v81 > playerr->MyArena->ServersideArenaSettings.LatencyMaxLatencyForWeapons )
        *(packet + 10) &= 0x7F80u;              // Weapon Info
      if ( v81 < playerr->MyArena->ServersideArenaSettings.LatencyMaxLatencyForKickOut || v81 > 800 || playerr->isSysop )
        playerr->LatencyKickOutDelayTimer = GetTickCount() / 0xA;
      if ( v81 < playerr->MyArena->ServersideArenaSettings.LatencySlowPacketTime || v81 > 800 || playerr->isSysop )
        ++playerr->C2SCurrentFast;
      else
        ++playerr->C2SCurrentSlow;
      if ( playerr->C2SCurrentSlow + playerr->C2SCurrentFast > playerr->MyArena->ServersideArenaSettings.LatencySlowPacketSampleSize )
      {
        playerr->C2SCurrentTotalFast += playerr->C2SCurrentFast;
        playerr->C2SCurrentTotalSlow += playerr->C2SCurrentSlow;
        if ( playerr->Ship != 8 )
        {
          v82 = playerr->MyArena;
          if ( 1000 * playerr->C2SCurrentSlow / (playerr->C2SCurrentSlow + playerr->C2SCurrentFast) > v82->ServersideArenaSettings.LatencySlowPacketKickoutPercent )
          {
            if ( v82 )
            {
              playerra[124] = 7;                // 0x07 - Chat
              playerra[125] = 0;
              playerra[126] = 0;
              *&playerra[127] = -1;
              strcpy(&playerra[129], "You have been put in spectator mode due to high latency (C2S)");
              v83 = strlen("You have been put in spectator mode due to high latency (C2S)") + 1;
              if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                SendPlayerReliablePacket(playerr, &playerra[124], v83 - 1 + 6, 1);
            }
            SetPlayerShip(playerr, 8);
            packett = packet;
            v81 = *&playerra[8];
          }
        }
        playerr->C2SCurrentFast = 0;
        playerr->C2SCurrentSlow = 0;
      }
      if ( v81 < 800 && v81 > 0 )
      {
        playerr->C2SAverageLatencyFirst += v81;
        ++playerr->C2SAverageLatencySecond;
      }
      XPixels = *(packett + 6);                 // X Pixels (0 ... 16384)
      if ( XPixels >= 0 && *(packett + 4) >= 0 && playerr->Ship != 8 )// Y Pixels (0 ... 16384)
      {
        if ( playerr->MyArena->ServersideArenaSettings.PacketLossDisableWeapons && rand() % 1000 < playerr->field_153 )
          *(packett + 10) &= 0x7F80u;
        v85 = *(packett + 6) - playerr->XPixels;// X Pixels (0 ... 16384)
        if ( ((HIDWORD(v85) ^ v85) - HIDWORD(v85)) > 512
          || (v86 = *(packett + 4) - playerr->YPixels,// Y Pixels (0 ... 16384)
              ((HIDWORD(v86) ^ v86) - HIDWORD(v86)) > 512) )
        {
          playerr->field_10F = 1;
        }
        if ( (packett[11] & 0x20) != 0 && (playerr->ShipTogglables & 0x20) == 0 )// Togglables 
          playerr->field_10F = 1;
        qmemcpy(playerr->gap_DC, packet, 0x16u);
        if ( (playerr->field_F0 & 0x1F) == 8 )
        {
          v87 = playerr->field_283;
          v88 = v87;
          if ( v87 >= 3 )
            v88 = 3;
          if ( v88 >= 0 )
          {
            if ( v87 >= 3 )
              LOBYTE(v87) = 3;
          }
          else
          {
            LOBYTE(v87) = 0;
          }
          playerr->field_F0 = (32 * (v87 & 3)) | playerr->field_F0 & 0xFF9F;
        }
        if ( packetSize > 0x16 )
        {
          playerr->EnergyOptional = *(packet + 22);// Energy (Optional)
          playerr->TimerOptional = *(packet + 26);// Timer (Optional)
          playerr->SharpnelMinesBombsBulletsMultifireInformationOptional = *(packet + 15);// Sharpnel & (Mines/Bombs) & (Bullets/Multifire) Information (Optional)
          playerr->field_10B = 1;
        }
        sub_40D870(playerr);
        playerr->field_FD = 1;
        if ( (playerr->field_F0 & 0x1F) != 0 )
          SendWeaponPacket(playerr);
        return;
      }
      ArenaPlayerIndex = playerr->ArenaPlayerIndex;
      if ( ArenaPlayerIndex < 0 )
      {
        if ( XPixels < 0 || *(packett + 4) < 0 )// X Pixel & Y Pixel Checks
        {
          v91 = playerr->XPixels;
          v92 = playerr->YPixels;
          qmemcpy(playerr->gap_DC, packet, 0x16u);
          playerr->XPixels = v91;
          playerr->YPixels = v92;
        }
        else
        {
          qmemcpy(playerr->gap_DC, packet, 0x16u);
        }
      }
      else
      {
        arenaPlayer = PlayerList[ArenaPlayerIndex];
        if ( !arenaPlayer )
          goto LABEL_196;
        playerr->XPixels = arenaPlayer->XPixels;
        playerr->YPixels = arenaPlayer->YPixels;
      }
      sub_40D870(playerr);
LABEL_196:
      AnotherArenaPlayerIndex = playerr->AttachedToPlayerId;
      if ( AnotherArenaPlayerIndex >= 0 )
      {
        v94 = PlayerList[AnotherArenaPlayerIndex];
        if ( v94 )
        {
          playerr->XPixels = v94->XPixels;
          playerr->YPixels = v94->YPixels;
          sub_40D870(playerr);
        }
      }
      return;
    case 5:                                     // 0x05 - Death message
      if ( !playerr->MyArena )
        return;
      UpdatePowerBallPositionsSomething(playerr);
      playerr->KingCrownKills = 0;
      killerPlayerId = *(packet + 1);           // Killer's Player ID
      if ( killerPlayerId <= 1024 && *(packet + 3) <= 20000 && killerPlayerId >= 0 )// 20000 Bounty
      {
        *&playerra[12] = 0;
        *&playerra[16] = PlayerList[killerPlayerId];
        killerr = *&playerra[16];
        if ( *&playerra[16] && *(*&playerra[16] + 28) != playerr->MyArena )
        {
          killerr = 0;
          *&playerra[16] = 0;
        }
        arenaa = playerr->MyArena;
        if ( !arenaa->ServersideArenaSettings.FlagFriendlyTransfer )
        {
          if ( !killerr )
            goto LABEL_223;
          if ( killerr->Frequency == playerr->Frequency )// Check for Team Kills?
          {
            FlagCarrierPlayerId = playerr->PlayerId;
            buffer[0] = 0x16;                   // 0x16 - Drop Flag
            *&buffer[1] = FlagCarrierPlayerId;
            ArenaSendPacket(arenaa, buffer, 3, 1);
            v103 = playerr->MyArena;
            FlagMode = v103->ServersideArenaSettings.FlagMode;
            if ( FlagMode )
            {
              if ( FlagMode == 1 )
              {
                CarryFlagsSomething(v103, *&playerr->PlayerId, 1);
                FlagPositionUpdateSomething(playerr->MyArena, 0);
              }
            }
            else
            {
              CarryFlagsSomething(v103, *&playerr->PlayerId, 0);
            }
          }
        }
        if ( killerr && killerr->Ship == 8 )
        {
          FlagCarrierPlayerIdd = playerr->PlayerId;
          v106 = playerr->MyArena;
          buffer[0] = 0x16;                     // 0x16 - Drop Flag
          *&buffer[1] = FlagCarrierPlayerIdd;
          ArenaSendPacket(v106, buffer, 3, 1);
          v107 = playerr->MyArena;
          v108 = v107->ServersideArenaSettings.FlagMode;
          if ( v108 )
          {
            if ( v108 == 1 )
            {
              CarryFlagsSomething(v107, *&playerr->PlayerId, 1);
              FlagPositionUpdateSomething(playerr->MyArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething(v107, *&playerr->PlayerId, 0);
          }
        }
LABEL_223:
        v109 = playerr->KotHDeathCount;
        if ( v109 <= 0 )
        {
          if ( killerr )
          {
            if ( killerr->KotHDeathCount > 0 )
            {
              v120 = playerr->MyArena;
              if ( v120->ServersideArenaSettings.KingNonCrownAdjustTime > 0
                && *(packet + 3) >= v120->ServersideArenaSettings.KingNonCrownMinimumBounty
                && playerr->Frequency != killerr->Frequency )
              {
                playerra[0] = 0x2D;             // 0x2D - Add KotH time
                *&playerra[1] = v120->ServersideArenaSettings.KingNonCrownAdjustTime;
                SendPlayerReliablePacket(killerr, playerra, 5u, 1);
              }
            }
          }
        }
        else
        {
          v110 = v109 - 1;
          playerr->KotHDeathCount = v110;
          if ( v110 )
          {
            v112 = playerr->MyArena;
            playerra[0] = 0x2B;                 // 0x2B - Set Personal KotH Timer
            *&playerra[1] = v112->ServersideArenaSettings.KingExpireTime;
            SendPlayerReliablePacket(playerr, playerra, 5u, 1);
          }
          else
          {
            *&playerra[6] = playerr->PlayerId;
            v111 = playerr->MyArena;
            *playerra = 0x2C;                   // 0x2C - KotH Game Reset
            *&playerra[2] = 0;
            ArenaSendPacket(v111, playerra, 8, 1);
          }
          if ( killerr )
          {
            if ( killerr->KotHDeathCount <= 0 )
            {
              newTotalCrownKillsNeededMaybe = killerr->KingCrownKills + 1;
              killerr->KingCrownKills = newTotalCrownKillsNeededMaybe;
              newTotalCrownKillsNeededMaybee = newTotalCrownKillsNeededMaybe;
              v116 = playerr->MyArena;
              v117 = v116->ServersideArenaSettings.KingCrownRecoverKills;
              if ( v117 > 0 && newTotalCrownKillsNeededMaybee >= v117 )
              {
                v118 = killerr->PlayerId;
                killerr->KotHDeathCount = v116->ServersideArenaSettings.KingDeathCount;
                *&playerra[6] = v118;
                v119 = playerr->MyArena;
                *playerra = 0x12C;              // 0x2C - KotH Game Reset
                *&playerra[2] = v119->ServersideArenaSettings.KingExpireTime;
                ArenaSendPacket(v119, playerra, 8, 1);
              }
            }
            else
            {
              v113 = playerr->MyArena;
              playerra[0] = 0x2B;               // 0x2B - Set Personal KotH Timer
              *&playerra[1] = v113->ServersideArenaSettings.KingExpireTime;
              SendPlayerReliablePacket(killerr, playerra, 5u, 1);
            }
          }
        }
        playerr->DebtKills = playerr->MyArena->ServersideArenaSettings.KillDebtKills;
        v121 = playerr->field_BC + 1;
        playerr->field_BC = v121;
        if ( v121 > playerr->MyArena->ServersideArenaSettings.SecurityMaxDeathWithoutFiring && !playerr->isModerator )
        {
          WriteSubGameLog("Played kicked off for too many deaths without firing: %s\n", playerr->PlayerName);
          playerr->DisconnectReason = 0xA;      // 0x0A - Server is Full
          playerr->AlreadySentReliablePacket = 1;
        }
        v122 = playerr->MyArena;
        *buffer = 0;
        *&playerra[8] = 0;
        if ( v122->ArenaSettings.CarryFlags && v122->someCounterBefore > 0 )
        {
          v123 = &v122->gap_186A2[4];
          *playerra = v122->someCounterBefore;
          do
          {
            v124 = *v123;
            if ( *v123 == *&playerr->PlayerId )
              ++*buffer;
            if ( v124 == *(packet + 1) )
              ++*&playerra[8];
            v123 += 16;
            --*playerra;
          }
          while ( *playerra );
        }
        if ( v122->ArenaSettings.CarryFlags == 2 && *buffer > 0 && *&playerra[8] > 0 )
        {
          v125 = playerr->PlayerId;
          buffer[0] = 22;
          *&buffer[1] = v125;
          ArenaSendPacket(v122, buffer, 3, 1);
          v126 = playerr->MyArena;
          v127 = v126->ServersideArenaSettings.FlagMode;
          if ( v127 )
          {
            if ( v127 == 1 )
            {
              CarryFlagsSomething(v126, *&playerr->PlayerId, 1);
              FlagPositionUpdateSomething(playerr->MyArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething(v126, *&playerr->PlayerId, 0);
          }
          *buffer = 0;
        }
        if ( *(packet + 1) == *&playerr->PlayerId )// Killer's Player ID
        {
          MyNewBounty = -*(packet + 3);         // Your bounty at time of death
          *&playerra[12] = MyNewBounty;
          printf("%s(%d) killed by self\n", playerr->Name, MyNewBounty);
          FormatMessageArena(playerr->MyArena, "%s(%d) killed by self\n", playerr->Name, MyNewBounty);
          v129 = playerr->MyArena;
          v130 = playerr->field_297 + 1;
          playerr->field_297 = v130;
          if ( v130 > v129->ServersideArenaSettings.SecuritySuicideLimit )
          {
            WriteSubGameLog("Played kicked off for too many suicides: %s\n", playerr->PlayerName);
            playerr->DisconnectReason = 0x13;   // 0x13 - Demo Versions not Allowed
            playerr->AlreadySentReliablePacket = 1;
          }
          CarryFlagsSomething(playerr->MyArena, *&playerr->PlayerId, 0);
LABEL_300:
          *playerra = -1;
          if ( killerr )
          {
            v150 = *&playerra[16];
            v151 = 0;
            v152 = *(*&playerra[16] + 557);
            v153 = *(*&playerra[16] + 553);
            *playerra = *(*&playerra[16] + 279);
            v154 = v153 + v152;
            if ( *&playerra[12] > 0 && *&playerra[8] > 0 )
              v151 = *&playerra[12] * playerr->MyArena->ArenaSettings.FlaggerKillMultiplier;
            UpdatePoints(*&playerra[16], *&playerra[12], v151);
            if ( *(v150 + 553) < 0 )
              *(v150 + 553) = 0;
            if ( v154 < AutoPermissionPoints
              && AutoPermissionPoints > 0
              && *(*&playerra[16] + 553) + *(*&playerra[16] + 557) >= AutoPermissionPoints )
            {
              if ( *(*&playerra[16] + 28) )
              {
                playerra[124] = 7;              // 0x07 - Chat
                playerra[125] = 0;
                playerra[126] = 0;
                *&playerra[127] = -1;
                strcpy(&playerra[129], PermissionAutoPermissionMessage);
                v155 = strlen(PermissionAutoPermissionMessage) + 1;
                v156 = *&playerra[16];
                if ( GetRelAckDiff(*(*&playerra[16] + 40), 0) < 128 )
                  SendPlayerReliablePacket(v156, &playerra[124], v155 - 1 + 6, 1);
              }
            }
          }
          v157 = playerr->MyArena;
          ++playerr->CurrentLosses;
          v158 = *&playerra[12];
          v159 = v157->ArenaJackpot;
          v157->ArenaJackpot = v159 + *&playerra[12] * v157->ServersideArenaSettings.KillJackpotBountyPercent / 1000;
          if ( MiscJackpotBroadcastPoints > 0 )
          {
            v160 = playerr->MyArena;
            *&playerra[8] = v160->ArenaJackpot / MiscJackpotBroadcastPoints;
            if ( v159 / MiscJackpotBroadcastPoints < *&playerra[8] )
            {
              playerra[124] = 2;
              playerra[125] = 0;
              sprintf(
                &playerra[126],
                "Jackpot just passed %d points in %s",
                MiscJackpotBroadcastPoints * (v160->ArenaJackpot / MiscJackpotBroadcastPoints),
                BillingServerName);
              if ( BillingConnectionStructPointer )
                SendBillerUserPrivateChatPacket(
                  BillingConnectionStructPointer,
                  -1,
                  BillingGroupId,
                  &playerra[124],
                  strlen(&playerra[126]) + 3);
            }
          }
          v161 = playerr->PlayerId;
          playerra[56] = 6;                     // 0x06 - Player Death
          *&playerra[60] = v161;
          v162 = *(packet + 1);
          *&playerra[64] = *buffer;
          v163 = playerr->MyArena;
          *&playerra[58] = v162;
          *&playerra[62] = v158;
          v164 = 0;
          playerra[57] = GetDeathPrizeGreenId(v163);
          if ( *&playerra[64] || abs16(*&playerra[62]) > 0xA0u )
          {
            ArenaSendPacket(playerr->MyArena, &playerra[56], 10, 1);
          }
          else
          {
            v165 = playerr->MyArena;
            if ( v165->ServersideArenaSettings.MiscTimedGame )
            {
              if ( v165->ArenaPlayerCount > 0 )
              {
                v166 = 16072;
                do
                {
                  v167 = v165->PlayerPointers[v166];
                  v168 = *&playerr->PlayerId;
                  v170 = 1;
                  if ( v167->AttachedToPlayerId != v168 )
                  {
                    v169 = *&v167->PlayerId;
                    if ( v169 != v168 && v169 != *(packet + 1) )
                      v170 = 0;
                  }
                  SendPlayerReliablePacket(v167, &playerra[56], 0xAu, v170);
                  v165 = playerr->MyArena;
                  ++v164;
                  ++v166;
                }
                while ( v164 < v165->ArenaPlayerCount );
              }
              goto LABEL_348;
            }
            v171 = v165->ArenaPlayerCount;
            *&playerra[8] = 0;
            if ( v171 > 0 )
            {
              v172 = 16072;
              while ( 1 )
              {
                v173 = v165->PlayerPointers[v172];
                playerrr = v173;
                ArenaPlayerIndexx = v173->ArenaPlayerIndex;
                if ( ArenaPlayerIndexx >= 0 )
                  playerrr = PlayerList[ArenaPlayerIndexx];
                if ( !playerrr )
                  goto LABEL_345;
                v176 = playerrr->Frequency;
                if ( v176 != playerr->Frequency && v176 != *playerra )
                  break;
                v177 = *&playerr->PlayerId;
                if ( playerrr->AttachedToPlayerId != v177 )
                {
                  v178 = *&playerrr->PlayerId;
                  if ( v178 != v177 && v178 != *(packet + 1) )
                    goto LABEL_344;
                }
                SendPlayerReliablePacket(v173, &playerra[56], 0xAu, 1);
LABEL_345:
                v165 = playerr->MyArena;
                ++v172;
                v183 = v165->ArenaPlayerCount;
                ++*&playerra[8];
                if ( *&playerra[8] >= v183 )
                  goto LABEL_348;
              }
              AttachedToPlayerId = playerrr->AttachedToPlayerId;
              if ( AttachedToPlayerId >= 0 )
                playerrr = PlayerList[AttachedToPlayerId];
              if ( !playerrr )
                goto LABEL_345;
              v180 = v165->ServersideArenaSettings.RoutingDeathDistance;
              v181 = playerrr->YPixels - playerr->YPixels;
              if ( ((HIDWORD(v181) ^ v181) - HIDWORD(v181)) > v180 )
                goto LABEL_345;
              v182 = playerrr->XPixels - playerr->XPixels;
              if ( ((HIDWORD(v182) ^ v182) - HIDWORD(v182)) > v180 )
                goto LABEL_345;
LABEL_344:
              SendPlayerReliablePacket(v173, &playerra[56], 0xAu, 0);
              goto LABEL_345;
            }
          }
LABEL_348:
          MiscMaxLossesToPlay = playerr->MyArena->ServersideArenaSettings.MiscMaxLossesToPlay;
          if ( MiscMaxLossesToPlay > 0 && playerr->CurrentLosses >= MiscMaxLossesToPlay )
            SetPlayerShip(playerr, 8);
          if ( AdvertiseSendMode == 3 || AdvertiseSendMode == 2 )
            SendAdvertisement(playerr, 0);
          if ( *&playerra[16] )
            SendPlayerScoreUpdateAll(*&playerra[16]);
          SendPlayerScoreUpdateAll(playerr);
          return;
        }
        playerr->field_297 = 0;
        if ( !killerr )
        {
          printf("%s killed by UNKNOWN\n", playerr->Name);
          CarryFlagsSomething(playerr->MyArena, *&playerr->PlayerId, 0);
LABEL_299:
          dword_4D8B14 = *&playerr->PlayerId;
          goto LABEL_300;
        }
        v131 = playerr->MyArena;
        if ( v131->ServersideArenaSettings.KillFixedKillReward < 0 )
        {
          v133 = *killerr->gap_EC;
          v134 = v131->ArenaSettings.MaxBonus;
          if ( v133 >= 0 )
          {
            MaxBonuss = *(packet + 3) - v133;
            if ( MaxBonuss < v134 )
              v134 = *(packet + 3) - v133;
            MaxBonus = -v131->ArenaSettings.MaxPenalty;
            if ( v134 <= MaxBonus || (MaxBonus = v131->ArenaSettings.MaxBonus, MaxBonuss >= MaxBonus) )
              MaxBonuss = MaxBonus;
            v132 = MaxBonuss + *(packet + 3) + v131->ArenaSettings.RewardBase;
          }
          else
          {
            v132 = *(packet + 3);
          }
        }
        else
        {
          v132 = v131->ServersideArenaSettings.KillFixedKillReward;
        }
        v137 = *killerr->gap_EC * v131->ServersideArenaSettings.KillBountyRewardPercent / 100 + v132;
        *playerra = v131->ServersideArenaSettings.KillPointsPerFlag;
        *&playerra[12] = v137;
        if ( *playerra
          && v131->ArenaPlayerCount > v131->ServersideArenaSettings.PeriodicRewardMinimumPlayers
          && *(packet + 3) > v131->ServersideArenaSettings.KillPointsMinimumBounty )
        {
          v138 = v131->someCounterBefore;
          v139 = 0;
          if ( v138 > 0 )
          {
            v140 = &v131->gap_186A2[8];
            do
            {
              if ( *v140 == killerr->Frequency )
                ++v139;
              v140 += 16;
              --v138;
            }
            while ( v138 );
          }
          *&playerra[12] = *playerra * v139 + v137;
        }
        v141 = 0;
        v142 = &killerr->someStringBuffer[4];
        while ( *v142 != playerr->UserId )
        {
          ++v141;
          v142 += 8;
          if ( v141 >= 8 )
          {
            v143 = 0xFFFFFFF;
            goto LABEL_286;
          }
        }
        v295 = (GetTickCount() / 0xA - *&killerr->someStringBuffer[8 * v141]);
        v143 = (HIDWORD(v295) ^ v295) - HIDWORD(v295);
LABEL_286:
        if ( v143 >= playerr->MyArena->ServersideArenaSettings.KillNoRewardKillDelay )
        {
          v144 = playerr->UserId;
          *&killerr->someStringBuffer[8 * killerr->field_A8] = GetTickCount() / 0xA;
          *&killerr->someStringBuffer[8 * killerr->field_A8 + 4] = v144;
          killerr->field_A8 = (killerr->field_A8 + 1) % 8;
          if ( killerr->Frequency != playerr->Frequency )
          {
            v145 = killerr->DebtKills;
            if ( v145 <= 0 )
            {
LABEL_291:
              v146 = *&playerra[12];
              ++killerr->CurrentWins;
              printf("%s(%d) killed by %s\n", playerr->Name, v146, killerr->Name);
              FormatMessageArena(
                playerr->MyArena,
                "%s(%d) killed by %s\n",
                playerr->Name,
                *&playerra[12],
                killerr->Name);
              v147 = playerr->MyArena;
              if ( v147->ArenaSettings.CarryFlags )
              {
                v148 = 0;
                if ( v147->someCounterBefore > 0 )
                {
                  v149 = 0;
                  do
                  {
                    if ( *&v147->gap_186A2[v149 + 4] == *&playerr->PlayerId )
                    {
                      *&v147->gap_186A2[v149 + 4] = *&killerr->PlayerId;
                      *&playerr->MyArena->gap_186A2[v149 + 8] = killerr->Frequency;
                    }
                    v147 = playerr->MyArena;
                    ++v148;
                    v149 += 16;
                  }
                  while ( v148 < v147->someCounterBefore );
                }
              }
              goto LABEL_299;
            }
            killerr->DebtKills = v145 - 1;
          }
        }
        *&playerra[12] = 0;
        goto LABEL_291;
      }
      if ( !playerr->isSuperModerator )
      {
LABEL_358:
        sprintf(a1, "Packet tampering(%d)", *packet);
        SendBillerWarnings(a1, playerr);
        v185 = playerr->MyArena;
        if ( v185 && v185->ServersideArenaSettings.dwordB4 )
          goto LABEL_683;
      }
      return;
    case 6:                                     // 0x06 - Chat message
      if ( playerr->IsSilenced || !playerr->MyArena )
        return;
      v239 = *(packet + 3);
      if ( v239 > 1024 || v239 < 0 )
        goto LABEL_503;
      v240 = strlen(packet + 5) + 1;
      if ( v240 - 1 > 0xFA )
      {
        packetId = *playerra;
LABEL_503:
        if ( !playerr->isSuperModerator )
        {
          sprintf(a1, "Packet tampering(%d)", packetId);
          SendBillerWarnings(a1, playerr);
          v241 = playerr->MyArena;
          if ( v241 )
          {
            if ( v241->ServersideArenaSettings.dwordB4 )
              goto LABEL_683;
          }
        }
      }
      else
      {
        if ( playerr->MyArena->ServersideArenaSettings.MessageBongAllowed || playerr->isModerator )
          v298 = packet[2];
        else
          v298 = 0;
        ChatProcessor(&packet[v240 + 5], playerr, packet[1], v239, packet + 5, v298);
      }
      return;
    case 7:                                     // 0x07 - Take Green / Prize
      if ( playerr->MyArena && playerr->Ship != 8 )
      {
        if ( *(packet + 9) >= 29
          || (v186 = *(packet + 5), v186 < 0)
          || v186 >= 1024
          || (v187 = *(packet + 7), v187 < 0)
          || v187 >= 1024 )
        {
          if ( !playerr->isSuperModerator )
          {
            sprintf(a1, "Packet tampering(%d)", packetId);
            SendBillerWarnings(a1, playerr);
            v200 = playerr->MyArena;
            if ( v200 )
            {
              if ( v200->ServersideArenaSettings.dwordB4 )
                goto LABEL_683;
            }
          }
        }
        else
        {
          v188 = *(packet + 1);
          v189 = playerr->encryptionPointer;
          v190 = ((v189->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v188;
          if ( v190 < 0 || v190 > 30000 )
            v190 = 0;
          v191 = playerr->MyArena;
          if ( v190 <= v191->ServersideArenaSettings.LatencyMaxLatencyForPrizes && *&playerr->gap_F2[1] != *(packet + 1) )
          {
            playerra[56] = 8;                   // 0x08 - Player got a Prize
            *playerr->gap_F2 = *packet;
            *&playerr->gap_F2[4] = *(packet + 1);
            *&playerr->gap_F2[8] = *(packet + 4);
            playerr->gap_F2[10] = packet[10];
            v192 = *(packet + 7);
            *&playerra[61] = *(packet + 5);
            v193 = *(packet + 9);
            *&playerra[63] = v192;
            v194 = *(packet + 1);
            *&playerra[65] = v193;
            v195 = playerr->PlayerId;
            *&playerra[57] = v194;
            *&playerra[67] = v195;
            v196 = v191->ServersideArenaSettings.PrizeS2CTakePrizeReliable;
            if ( v191 )
            {
              v197 = 0;
              if ( v191->ArenaPlayerCount > 0 )
              {
                v198 = 16072;
                do
                {
                  v199 = v191->PlayerPointers[v198];
                  if ( v199 != playerr && !v199->AlreadySentReliablePacket )
                    SendPlayerReliablePacket(v199, &playerra[56], 13u, v196);
                  v191 = playerr->MyArena;
                  ++v197;
                  ++v198;
                }
                while ( v197 < v191->ArenaPlayerCount );
              }
            }
          }
        }
      }
      return;
    case 8:                                     // 0x08 - Spectate request
      if ( playerr->MyArena )
      {
        ArenaPlayerIndexxx = *(packet + 1);
        if ( ArenaPlayerIndexxx == -1 || playerr->Ship == 8 )
        {
          if ( ArenaPlayerIndexxx > 1024 || ArenaPlayerIndexxx < -1 )
          {
            if ( !playerr->isSuperModerator )
            {
              sprintf(a1, "Packet tampering(%d)", packetId);
              SendBillerWarnings(a1, playerr);
              v229 = playerr->MyArena;
              if ( v229 )
              {
                if ( v229->ServersideArenaSettings.dwordB4 )
                  goto LABEL_683;
              }
            }
          }
          else
          {
            ArenaPlayerIndexxxx = playerr->ArenaPlayerIndex;
            playerr->ArenaPlayerIndex = ArenaPlayerIndexxx;
            if ( ArenaPlayerIndexxx >= 0 )
            {
              v225 = PlayerList[ArenaPlayerIndexxx];
              if ( v225 )
              {
                playerr->XPixels = v225->XPixels;
                playerr->YPixels = v225->YPixels;
                sub_40D870(playerr);
              }
            }
            if ( playerr->isSysop )
            {
              buffer[0] = 0x1C;                 // 0x1C - Put player in spectator mode / change extra info flag
              if ( ArenaPlayerIndexxxx >= 0 )
              {
                v226 = PlayerList[ArenaPlayerIndexxxx];
                buffer[1] = 0;                  // Player ID
                if ( v226 )
                  SendPlayerReliablePacket(v226, buffer, 2u, 1);
              }
              v227 = playerr->ArenaPlayerIndex;
              if ( v227 >= 0 )
              {
                v228 = PlayerList[v227];
                buffer[1] = 1;                  // Player ID
                if ( v228 )
                  SendPlayerReliablePacket(v228, buffer, 2u, 1);
              }
            }
          }
        }
        else
        {
          WriteSubGameLog("WARNING: Spectator request from non-spectator ship, ignoring\n");
        }
      }
      return;
    case 9:                                     // 0x09 - Password packet
    case 0x23:                                  // 0x23 - Unknown
      v271 = *(packet + 77);                    // Mem Checksums [0x01BC] or [444]
      *&playerra[8] = 0;
      if ( !v271 )
      {
        playerr->DemoPlayer = 1;
        *&playerra[8] = 1;
      }
      v272 = (packet + 2);
      *&playerra[16] = packet + 2;
      strcpy(playerr->TypedName, packet + 2);
      config_read_helper_3(packet + 2);
      printf("Connection request from: %s\n", packet + 2);
      v273 = 0;
      *&playerra[12] = 0;
      *buffer = packet + 34;
      v274 = strrchr(packet + 34, '*');
      if ( !v274 )
        goto LABEL_605;
      if ( _strcmpi(v274 + 1, SysopPassword) )
      {
        if ( _strcmpi(v274 + 1, SuperModeratorPassword) )
        {
          if ( _strcmpi(v274 + 1, ModeratorPassword) )
          {
            if ( _strcmpi(v274 + 1, VIPPassword) )
              goto LABEL_605;
            v273 = 1;
            *&playerra[12] = 1;
            WriteSubGameLog("%s>  VIP LOGGED IN\n", v272);
          }
          else
          {
            WriteSubGameLog("%s>  MODERATOR LOGGED IN\n", v272);
            v273 = 1;
            *&playerra[12] = 1;
            playerr->isModerator = 1;
          }
        }
        else
        {
          WriteSubGameLog("%s>  SUPER MODERATOR LOGGED IN\n", v272);
          v273 = 1;
          *&playerra[12] = 1;
          playerr->isModerator = 1;
          playerr->isSuperModerator = 1;
        }
      }
      else
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", v272);
        v273 = 1;
        *&playerra[12] = 1;
        playerr->isSysop = 1;
        playerr->isModerator = 1;
        playerr->isSuperModerator = 1;
      }
      *v274 = 0;
LABEL_605:
      if ( !*&playerra[8] && BillingConnectionStructPointer && IsBannedMachineId(ModeratePointer, v272) >= 0 )
      {
        v273 = 1;
        *&playerra[12] = 1;
        playerr->isModerator = 1;
      }
      playerr->Name[0] = 0;
      strncpy(playerr->PlayerName, v272, 0x18u);
      playerr->PlayerName[23] = 0;
      playerr->MachineId = *(packet + 85);
      playerr->TimeZoneBias = *(packet + 71);
      ConnectType = packet[70];
      playerr->ConnectType = ConnectType;
      if ( ConnectType == 1 )
        playerr->SlowModem = 1;
      if ( !PermissionAllowLowBandwidth && !v273 )
      {
        playerra[88] = 0xA;                     // 0x0A - Password response
        playerra[89] = 8;                       // Byte [1] - 8 - Connection too slow.
        *&playerra[90] = 134;                   // Byte [2] - Server version 134 - SubSpace 1.34
        SendPlayerReliablePacket(playerr, &playerra[88], 0x24u, 1);
        WriteSubGameLog("Played kicked off for having slow modem: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      *&playerr->SubspaceVersion = *(packet + 75);
      playerr->SubspaceEXEChecksumIndex = 0;
      v276 = *packet;
      if ( *packet >= 35 && v276 <= 44 )
        playerr->SubspaceEXEChecksumIndex = v276 - 35;
      if ( !SecurityArray[playerr->SubspaceEXEChecksumIndex].SubspaceEXEChecksum )
        goto LABEL_618;
      LOBYTE(v277) = IsOffensiveName(v272);
      if ( v277 && !playerr->isModerator )
      {
        playerra[20] = 0xA;                     // 0x0A - Password Packet Response
        playerra[21] = 12;                      // 0x0C - Offensive Name
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
        WriteSubGameLog("Played kicked off, obscene name: %s\n", v272);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      if ( PermissionMode == 1 && !playerr->isModerator && (*&playerra[8] || IsBannedMachineId(PermitPointer, v272) < 0) )
      {
LABEL_618:
        playerra[20] = 0xA;
        playerra[21] = 5;                       // 0x05 - Permission Only Arena
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
        playerr->KickOffDelayTimer = GetTickCount() / 0xA;
        return;
      }
      v278 = GetIPAddressString(playerr->IPAddressDWORD);
      if ( IsBannedIPAddress(playerr->SubspaceEXEChecksumIndex, v278) )
      {
        playerra[20] = 0xA;                     // 0x0A - Password Packet Response
        playerra[21] = 4;                       // 0x04 - Locked Out of Zone
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
        WriteSubGameLog("Played kicked off, IP block: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      sprintf(&playerra[56], MEMORY[0x42A094], playerr->MachineId);
      if ( IsBannedMachineId(IDBlockPointer, &playerra[56]) >= 0 )
      {
        playerra[20] = 0xA;                     // 0x0A - Password Packet Response
        playerra[21] = 4;                       // 0x04 - Locked Out of Zone
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
        WriteSubGameLog("Played kicked off, ID block: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      v279 = 0;
      if ( MachineIdArrayIndex <= 0 )
        goto LABEL_638;
      v280 = KickedUsers;
      while ( v280->MachineId != playerr->MachineId || playerr->isSysop )
      {
        ++v279;
        ++v280;
        if ( v279 >= MachineIdArrayIndex )
          goto LABEL_638;
      }
      playerra[20] = 0xA;                       // 0x0A - Password Packet Response
      playerra[21] = 5;                         // 0x05 - Permission Only Arena
      *&playerra[22] = 134;                     // Server Version 134 = SubSpace 1.34
      playerra[39] = 0;                         // Registration Form Request (Boolean)
      SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
      playerr->KickOffDelayTimer = GetTickCount() / 0xA;
LABEL_638:
      if ( !playerr->DemoPlayer )
        goto LABEL_649;
      CurrentPlayerCountt = CurrentPlayerCount;
      v282 = 0;
      if ( CurrentPlayerCount > 0 )
      {
        v283 = playerPointerList;
        v284 = CurrentPlayerCount;
        do
        {
          if ( (*v283)->DemoPlayer )
            ++v282;
          ++v283;
          --v284;
        }
        while ( v284 );
      }
      if ( (MiscMaxSharewarePlayers & 0x80000000) == 0 && v282 > MiscMaxSharewarePlayers )
      {
        playerra[20] = 0xA;                     // 0x0A - Password Packet Response
        playerra[21] = (MiscMaxSharewarePlayers == 0) + 0x11;// 0x11 - Demo Version Detected
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
        WriteSubGameLog("Played kicked off, arena full to demo users: %s\n", playerr->PlayerName);
        playerr->AlreadySentReliablePacket = 1;
        return;
      }
      if ( *&playerra[8] )
      {
        memset(playerr->Name, 0, 0xACu);        // TODO: Erases way past the Name LOL
        sprintf(playerr->Name, "~Demo%d", *&playerr->PlayerId);
        strcpy(playerr->PlayerName, playerr->Name);
        playerr->UserId = -1;
        *&playerr->CurrentWins = 0;
        *&playerr->GoalCount = 0;
        *(&playerr->KillPoints + 2) = 0;
        HIWORD(playerr->FlagPoints) = 0;
LABEL_649:
        CurrentPlayerCountt = CurrentPlayerCount;
      }
      if ( CurrentPlayerCountt > MiscMaxPlayers && !*&playerra[12] )
      {
        *&playerra[8] = 0;
        if ( MiscRegisterKickShareware )
        {
          if ( !playerr->DemoPlayer )
          {
            ArenaPlayerIndexxxxx = 0;
            if ( CurrentPlayerCountt > 0 )
            {
              v286 = playerPointerList;
              while ( !(*v286)->DemoPlayer )
              {
                ++ArenaPlayerIndexxxxx;
                ++v286;
                if ( ArenaPlayerIndexxxxx >= CurrentPlayerCountt )
                  goto LABEL_663;
              }
              v287 = playerPointerList[ArenaPlayerIndexxxxx];
              *&playerra[8] = 1;
              *playerra = v287;
              if ( v287->MyArena )
              {
                playerra[124] = 7;
                playerra[125] = 0;
                playerra[126] = 0;
                *&playerra[127] = -1;
                strcpy(&playerra[129], "You have been kicked off to make space for a registered user.");
                v288 = strlen("You have been kicked off to make space for a registered user.") + 1;
                if ( GetRelAckDiff(*(*playerra + 40), 0) < 128 )
                  SendPlayerReliablePacket(*playerra, &playerra[124], v288 - 1 + 6, 1);
              }
              playerPointerList[ArenaPlayerIndexxxxx]->KickOffDelayTimer = GetTickCount() / 0xA;
            }
          }
        }
LABEL_663:
        if ( !*&playerra[8] )
        {
          playerra[20] = 0xA;                   // 0x0A - Password Packet Response
          playerra[21] = 3;                     // 0x03 - Arena is Full
          *&playerra[22] = 134;                 // Server Version 134 = SubSpace 1.34
          playerra[39] = 0;                     // Registration Form Request (Boolean)
          SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
          WriteSubGameLog("Played kicked off, arena full: %s\n", playerr->PlayerName);
          playerr->AlreadySentReliablePacket = 1;
          return;
        }
      }
      v289 = BillingConnectionStructPointer;
      if ( BillingConnectionStructPointer )
      {
        if ( !*&playerra[12] )
        {
          if ( GetRelAckDiff(BillingServerConnection, 0) > CommsMaxQueueToLogin )
          {
            playerra[20] = 0xA;                 // 0x0A - Password Packet Response
            playerra[21] = 0xE;                 // 0x0E - Server Busy, try Later
            *&playerra[22] = 134;               // Server Version 134 = SubSpace 1.34
            playerra[39] = 0;                   // Registration Form Request (Boolean)
            SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
            playerr->AlreadySentReliablePacket = 1;
            return;
          }
          v289 = BillingConnectionStructPointer;
        }
        if ( playerr->DemoPlayer && MiscDisableShareware )
          SendBillerUserLoginPacket(
            v289,
            &DirectoryNamePassword,
            &DirectoryNamePassword,
            playerr->IPAddressDWORD,
            playerr->MachineId,
            playerr->TimeZoneBias,
            packet[1],
            playerr->BillerPlayerId,
            0,
            playerr->isSysop);
        else
          SendBillerUserLoginPacket(
            v289,
            *&playerra[16],
            *buffer,
            playerr->IPAddressDWORD,
            playerr->MachineId,
            playerr->TimeZoneBias,
            packet[1],
            playerr->BillerPlayerId,
            0,
            playerr->isSysop);
      }
      else if ( IsBannedMachineId(ReservedPointer, *&playerra[16]) < 0 || *&playerra[12] )
      {
        memset(playerr->Name, 0, 0xACu);        // TODO: Clears past the Name limit of 32 bytes.
        playerra[20] = 0xA;                     // 0x0A - Password Packet Response
        playerra[21] = 0xD;                     // 0x0D - No Active Biller
        strcpy(playerr->Name, *&playerra[16]);
        *&playerra[22] = 134;                   // Server Version 134 = SubSpace 1.34
        *&playerr->CurrentWins = 0;
        *&playerr->GoalCount = 0;
        *(&playerr->KillPoints + 2) = 0;
        HIWORD(playerr->FlagPoints) = 0;
        v290 = playerr->SubspaceEXEChecksumIndex;
        *&playerra[26] = 0;                     // ? Unknown
        *&playerra[34] = 0;                     // ? Unknown
        v291 = v290;
        playerra[38] = 0;                       // ? Unknown
        playerra[39] = 0;                       // Registration Form Request (Boolean)
        SubspaceEXEChecksum = SecurityArray[v290].SubspaceEXEChecksum;
        *&playerra[40] = *&SecurityArray[v291].ScrtyData[4];// ? Unknown
        isModerator = playerr->isModerator;
        *&playerra[30] = SubspaceEXEChecksum;   // Subspace.exe Checksum
        *&playerra[44] = NewsTxtFileChecksum;   // News.txt Checksum
        if ( isModerator )
        {
          *&playerra[30] = -1;                  // Subspace.exe Checksum
          *&playerra[40] = -1;                  // ? Unknown
        }
        SendPlayerReliablePacket(playerr, &playerra[20], 0x24u, 1);
      }
      else
      {
        playerra[88] = 0xA;                     // 0x0A - Password Packet Response
        playerra[89] = 12;                      // 12 - Offensive name.
        *&playerra[90] = 134;                   // Server Version 134 = SubSpace 1.34
        playerra[107] = 0;
        SendPlayerReliablePacket(playerr, &playerra[88], 0x24u, 1);
        playerr->KickOffDelayTimer = GetTickCount() / 0xA;
      }
      return;
    case 0xB:                                   // 0x0B - SSUpdate.EXE Request
      SubSpaceVersion = *&playerr->SubspaceVersion;
      if ( SubSpaceVersion == 132 && (v69 = playerr->SubspaceEXEChecksumIndex, (v70 = SecurityArray[v69].field_8) != 0) )
      {
        GetMapLvlRequest(playerr->encryptionPointer, v70, SecurityArray[v69].field_14, 0);
      }
      else if ( SubSpaceVersion == 133
             && (v71 = playerr->SubspaceEXEChecksumIndex, (v72 = SecurityArray[v71].field_4) != 0) )
      {
        GetMapLvlRequest(playerr->encryptionPointer, v72, SecurityArray[v71].field_10, 0);
      }
      else
      {
        GetMapLvlRequest(
          playerr->encryptionPointer,
          *&SecurityArray[playerr->SubspaceEXEChecksumIndex].test,
          SecurityArray[playerr->SubspaceEXEChecksumIndex].field_C,
          0);
      }
      return;
    case 0xC:                                   // 0x0C - Map.lvl Request
      v66 = playerr->MyArena;
      if ( v66 )
        GetMapLvlRequest(
          playerr->encryptionPointer,
          *&v66->dwLastConfigReadTime[12],
          *&v66->dwLastConfigReadTime[16],
          0);
      return;
    case 0xD:                                   // 0x0D - News.txt Request
      v67 = emalloc(OutSize);
      qmemcpy(v67, ptr, OutSize);
      GetNewsRequest(playerr->encryptionPointer, v67, OutSize, 0);
      return;
    case 0xE:                                   // 0x0E - Voice Message
      numberOfPacketChunks = packet[1];
      if ( numberOfPacketChunks >= 4 || numberOfPacketChunks < 0 || *(packet + 1) > 1024 )// 4*1024 Max Voice Size is 8192 Bytes
      {
        if ( !playerr->isSuperModerator )
          goto LABEL_589;
      }
      else
      {
        if ( !*&playerr->field_33D[8 * numberOfPacketChunks] )
        {
          packett = packet;
          *&playerr->field_33D[8 * packet[1]] = emalloc(packetSize - 4);
          *&playerr->field_33D[8 * packet[1] + 4] = packetSize - 4;
          qmemcpy(*&playerr->field_33D[8 * packet[1]], packet + 4, packetSize - 4);
        }
        arenaPlayerIndex = *(packett + 1);
        if ( arenaPlayerIndex != -1 && arenaPlayerIndex != -2 && arenaPlayerIndex >= 0 )
        {
          *playerra = PlayerList[arenaPlayerIndex];
          if ( *playerra )
          {
            if ( !sub_41CA10(*(*playerra + 40)) )
            {
              v237 = *&playerr->field_33D[8 * packet[1] + 4] + 3;
              v238 = emalloc(v237);
              *v238 = 12;
              *(v238 + 1) = playerr->PlayerId;
              qmemcpy(v238 + 3, *&playerr->field_33D[8 * packet[1]], *&playerr->field_33D[8 * packet[1] + 4]);
              GetNewsRequest(*(*playerra + 40), v238, v237, 1);
              Wave += v237;
            }
          }
        }
      }
      return;
    case 0xF:                                   // 0x0F - Frequency change
      if ( playerr->MyArena )
        PlayerChangeFrequency(playerr, *(packet + 1));
      return;
    case 0x10:
      if ( !playerr->MyArena || playerr->Ship == 8 )
        return;
      v261 = *(packet + 1);
      if ( v261 > 1024 || v261 < -1 )
      {
        if ( !playerr->isSuperModerator )
        {
LABEL_589:
          sprintf(a1, "Packet tampering(%d)", packetId);
          v297 = playerr;
          goto LABEL_590;
        }
      }
      else
      {
        playerr->AttachedToPlayerId = v261;
        if ( v261 >= 0 )
        {
          v262 = PlayerList[v261];
          if ( v262 )
          {
            if ( v262->Frequency != playerr->Frequency )
            {
              playerr->AttachedToPlayerId = -1;
              return;
            }
            if ( v262->AttachedToPlayerId >= 0 )
            {
              playerr->AttachedToPlayerId = -1;
              return;
            }
            playerr->XPixels = v262->XPixels;
            playerr->YPixels = v262->YPixels;
            sub_40D870(playerr);
          }
        }
        MyAttachPlayerId = playerr->PlayerId;
        v264 = *(packet + 1);
        *&playerra[3] = playerr->AttachedToPlayerId;// Turreter Destination Player ID
        v265 = playerr->AttachedToPlayerId;
        playerra[0] = 0xE;                      // 0x0E - Create Turret Link
        *&playerra[1] = MyAttachPlayerId;       // Turreter Requester Player ID
        if ( v264 == v265 )
        {
          v266 = playerr->MyArena;
          if ( v266 )
          {
            v267 = 0;
            if ( v266->ArenaPlayerCount > 0 )
            {
              v268 = 16072;
              do
              {
                v269 = v266->PlayerPointers[v268];
                if ( v269 != playerr && !v269->AlreadySentReliablePacket )
                  SendPlayerReliablePacket(v269, playerra, 5u, 1);
                v266 = playerr->MyArena;
                ++v267;
                ++v268;
              }
              while ( v267 < v266->ArenaPlayerCount );
            }
          }
        }
        else
        {
          ArenaSendPacket(playerr->MyArena, playerra, 5, 1);
        }
      }
      return;
    case 0x13:                                  // 0x13 - Flag request
      if ( playerr->MyArena )
      {
        if ( playerr->Ship != 8 )
        {
          v201 = playerr->MyArena;
          v202 = (GetTickCount() / 0xA - playerr->field_15B);
          if ( ((HIDWORD(v202) ^ v202) - HIDWORD(v202)) >= v201->ServersideArenaSettings.LatencyNoFlagPenalty )
          {
            v203 = *(packet + 1);
            v204 = v201->someCounterBefore;
            v205 = v203;
            *playerra = v203;
            if ( v203 <= v204 && v203 >= 0 )
            {
              if ( v201->ArenaSettings.CarryFlags != 2 )
                goto LABEL_688;
              v206 = 0;
              if ( v204 > 0 )
              {
                v207 = &v201->gap_186A2[4];
                do
                {
                  if ( *v207 == *&playerr->PlayerId )
                    ++v206;
                  v207 += 16;
                  --v204;
                }
                while ( v204 );
                v205 = *playerra;
              }
              if ( v206 <= 0 )
              {
LABEL_688:
                if ( *&v201->gap_186A2[16 * v205 + 4] == -1 )
                {
                  *&playerra[1] = *(packet + 1);// Flag ID
                  v208 = playerr->PlayerId;
                  playerra[0] = 0x13;           // 0x13 - Flag Claim
                  *&playerra[3] = v208;         // Player ID
                  ArenaSendPacket(v201, playerra, 5, 1);
                  *&playerr->MyArena->gap_186A2[16 * *(packet + 1) + 8] = playerr->Frequency;
                  v209 = playerr->MyArena;
                  if ( v209->ArenaSettings.CarryFlags )
                    *&v209->gap_186A2[16 * *(packet + 1) + 4] = *&playerr->PlayerId;
                }
              }
            }
          }
        }
      }
      return;
    case 0x14:                                  // 0x14 - Drop all attached pilots
      v214 = playerr->MyArena;
      if ( v214 )
      {
        v215 = playerr->PlayerId;
        buffer[0] = 0x15;                       // 0x15 - Destroy Turret Link
        *&buffer[1] = v215;                     // Turret Driver Player ID
        v216 = 0;
        if ( v214->ArenaPlayerCount > 0 )
        {
          v217 = 16072;
          do
          {
            v218 = v214->PlayerPointers[v217];
            if ( v218 != playerr && !v218->AlreadySentReliablePacket )
              SendPlayerReliablePacket(v218, buffer, 3u, 1);
            v214 = playerr->MyArena;
            ++v216;
            ++v217;
          }
          while ( v216 < v214->ArenaPlayerCount );
        }
      }
      return;
    case 0x15:                                  // 0x15 - Drop flags
      v219 = playerr->MyArena;
      if ( v219 && v219->ArenaSettings.CarryFlags )
      {
        v220 = playerr->PlayerId;
        buffer[0] = 0x16;                       //  0x16 - Drop Flag
        *&buffer[1] = v220;                     // Carrier Player ID
        ArenaSendPacket(v219, buffer, 3, 1);
        v221 = playerr->MyArena;
        v222 = v221->ServersideArenaSettings.FlagMode;
        if ( v222 )
        {
          if ( v222 == 1 )
          {
            CarryFlagsSomething(v221, *&playerr->PlayerId, 1);
            FlagPositionUpdateSomething(playerr->MyArena, 0);
          }
        }
        else
        {
          CarryFlagsSomething(v221, *&playerr->PlayerId, 0);
        }
      }
      return;
    case 0x16:                                  // 0x16 - File transfer
      v246 = playerr->field_58;
      if ( v246 < 0 )
      {
        ArenaPlayerIndexxxxxx = playerr->field_60;
        if ( ArenaPlayerIndexxxxxx < 0 )
        {
          v255 = playerr->isSysop != 0;
          v256 = (packet + 1);
          *&playerra[16] = packet + 1;
          if ( !_strcmpi(packet + 1, "moderate.txt") )
            v255 = 1;
          if ( !_strcmpi(packet + 1, "permit.txt") )
            v255 = 1;
          if ( !_strcmpi(packet + 1, playerr->MyArena->szLevelFile2)
            && playerr->UserId == playerr->MyArena->ServersideArenaSettings.OwnerUserId )
          {
            v255 = 1;
          }
          if ( v255 )
          {
            if ( playerr->isSysop || packetSize <= 0x80000 )// 512 KB Max
            {
              v257 = fopen(packet + 1, aW);
              v258 = v257;
              if ( v257 )
              {
                fwrite(packet + 17, packetSize - 17, 1u, v257);
                fclose(v258);
              }
              sprintf(a1, "File received: %s", v256);
              if ( playerr->MyArena )
              {
                playerra[124] = 7;
                playerra[125] = 0;
                playerra[126] = 0;
                *&playerra[127] = -1;
                strcpy(&playerra[129], a1);
                v259 = strlen(a1) + 1;
                if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                  SendPlayerReliablePacket(playerr, &playerra[124], v259 - 1 + 6, 1);
                v256 = *&playerra[16];
              }
              if ( !_strcmpi(v256, playerr->MyArena->szLevelFile2) )
              {
                if ( playerr->MyArena )
                {
                  playerra[124] = 7;
                  playerra[125] = 0;
                  playerra[126] = 0;
                  *&playerra[127] = -1;
                  strcpy(&playerra[129], "Arena is recycling so the change can take effect.");
                  v260 = strlen("Arena is recycling so the change can take effect.") + 1;
                  if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                    SendPlayerReliablePacket(playerr, &playerra[124], v260 - 1 + 6, 1);
                }
                v256 = *&playerra[16];
                playerr->MyArena->field_10026 = 1;
              }
              if ( !_strcmpi(v256, MiscDefaultLevelFile) )
                bRecycleServer = 1;
            }
            else if ( playerr->MyArena )
            {
              playerra[124] = 7;
              playerra[125] = 0;
              playerra[126] = 0;
              *&playerra[127] = -1;
              strcpy(&playerra[129], "File has arrived, but is too big (size limit of 512k)");
              v43 = strlen("File has arrived, but is too big (size limit of 512k)") + 6;
              if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                goto LABEL_553;
            }
          }
        }
        else
        {
          v250 = PlayerList[ArenaPlayerIndexxxxxx];
          *&playerra[8] = v250;
          if ( v250 && v250->UserId == playerr->field_5C )
          {
            *&playerra[16] = packet + 1;
            sprintf(a1, "File arrived at server, forwarding to %s: %s", v250->Name, packet + 1);
            if ( playerr->MyArena )
            {
              playerra[124] = 7;
              playerra[125] = 0;
              playerra[126] = 0;
              *&playerra[127] = -1;
              strcpy(&playerra[129], a1);
              v251 = strlen(a1) + 1;
              if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                SendPlayerReliablePacket(playerr, &playerra[124], v251 - 1 + 6, 1);
            }
            v252 = emalloc(packetSize);
            qmemcpy(v252 + 17, packet + 17, packetSize - 17);
            v253 = *&playerra[16];
            *v252 = 16;
            *playerra = v252 + 1;
            strcpy(v252 + 1, v253);
            GetNewsRequest(*(*&playerra[8] + 40), v252, packetSize, 0);
            playerr->field_60 = -1;
            playerr->field_5C = -1;
          }
          else
          {
            sprintf(a1, "File arrived at server, could not forward: %s", packet + 1);
            if ( playerr->MyArena )
            {
              playerra[124] = 7;                // 0x07 - Chat
              playerra[125] = 0;
              playerra[126] = 0;
              *&playerra[127] = -1;
              strcpy(&playerra[129], a1);
              v254 = strlen(a1) + 1;
              if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                SendPlayerReliablePacket(playerr, &playerra[124], v254 - 1 + 6, 1);
            }
            playerr->field_60 = -1;
            playerr->field_5C = -1;
          }
        }
      }
      else
      {
        *playerra = PlayerList[v246];
        if ( *playerra && *(*playerra + 631) )
        {
          sprintf(a1, "File arrived, forwarding: %s", packet + 1);
          if ( *(*playerra + 28) )
          {
            playerra[124] = 7;
            playerra[125] = 0;
            playerra[126] = 0;
            *&playerra[127] = -1;
            strcpy(&playerra[129], a1);
            v247 = strlen(a1) + 1;
            if ( GetRelAckDiff(*(*playerra + 40), 0) < 128 )
              SendPlayerReliablePacket(*playerra, &playerra[124], v247 - 1 + 6, 1);
          }
          v248 = emalloc(packetSize);
          qmemcpy(v248 + 17, packet + 17, packetSize - 17);
          *v248 = 16;
          *&playerra[8] = v248 + 1;
          strcpy(v248 + 1, "pulled.dat");
          GetNewsRequest(*(*playerra + 40), v248, packetSize, 0);
        }
        playerr->field_58 = -1;
      }
      return;
    case 0x17:                                  // 0x17 - Registration Form Response
      if ( packetSize == 766 && BillingConnectionStructPointer )
        SendBillerUserDemographicsPacket(BillingConnectionStructPointer, playerr->BillerPlayerId, (packet + 1), v299);
      return;
    case 0x18:                                  // 0x18 - Set ship type
      v210 = playerr->MyArena;
      if ( !v210 )
        return;
      MaxLossesToPlay = v210->ServersideArenaSettings.MiscMaxLossesToPlay;
      if ( MaxLossesToPlay > 0 && playerr->CurrentLosses >= MaxLossesToPlay )
        return;
      if ( playerr->IsSpeced )
        return;
      Ship = packet[1];
      if ( Ship == playerr->Ship )
        return;
      if ( Ship == 8 )
        goto LABEL_424;
      if ( !v210->ArenaLocked || playerr->isSuperModerator )
      {
        if ( playerr->DemoPlayer && (Ship == 5 || Ship == 6 || Ship == 4 || Ship == 7) )
        {
          playerra[124] = 7;                    // 0x07 - Chat
          playerra[125] = 0;
          playerra[126] = 0;
          *&playerra[127] = -1;
          strcpy(&playerra[129], "Demo version of SubSpace does not allow the use of that ship type.");
          v43 = strlen("Demo version of SubSpace does not allow the use of that ship type.") + 6;
          if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
            goto LABEL_553;
        }
        else
        {
          sub_41CB70(playerr->encryptionPointer, &playerr->S2CPacketLossPercentage, &playerr->C2SPacketLossPercentage);
          v210 = playerr->MyArena;
          if ( playerr->S2CPacketLossPercentage >= v210->ServersideArenaSettings.PacketLossS2CKickOutPercent
            && playerr->C2SPacketLossPercentage >= v210->ServersideArenaSettings.PacketLossC2SKickOutPercent
            || playerr->isSysop )
          {
LABEL_424:
            playerr->DebtKills = v210->ServersideArenaSettings.KillDebtKills;
            Shipp = packet[1];
            if ( Shipp > 8 || Shipp < 0 )
            {
              if ( !playerr->isSuperModerator )
              {
                sprintf(a1, "Packet tampering(%d)", *packet);
                v297 = playerr;
LABEL_590:
                SendBillerWarnings(a1, v297);
                v270 = playerr->MyArena;
                if ( v270 )
                {
                  if ( v270->ServersideArenaSettings.dwordB4 )
                    goto LABEL_683;
                }
              }
            }
            else
            {
              SetPlayerShip(playerr, Shipp);
            }
          }
          else if ( v210 )
          {
            playerra[124] = 7;                  // 0x07 - Chat
            playerra[125] = 0;
            playerra[126] = 0;
            *&playerra[127] = -1;
            strcpy(&playerra[129], "Packet loss too high for you to enter the game.");
            v43 = strlen("Packet loss too high for you to enter the game.") + 6;
            if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
              goto LABEL_553;
          }
        }
      }
      return;
    case 0x19:                                  // 0x19 - Set personal banner
      qmemcpy(playerr->BannerData, packet + 1, sizeof(playerr->BannerData));
      if ( BillingConnectionStructPointer )
        SendBillerUserBannerPacket(BillingConnectionStructPointer, playerr->BillerPlayerId, packet + 1);
      buffer[0] = 0x1E;                         // 0x1E - Personal Banner Changed
      buffer[1] = 0;                            // Boolean ?Unknown? (0x00)
      SendPlayerReliablePacket(playerr, buffer, 2u, 1);
      v233 = playerr->MyArena;
      if ( v233
        && (playerr->FlagPoints + playerr->KillPoints >= v233->ServersideArenaSettings.MiscBannerPoints
         || playerr->dword30) )
      {
        v234 = playerr->PlayerId;
        v303[0] = 0x1F;                         // 0x1F - Player Banner Changed
        *&v303[1] = v234;                       // PlayerId
        qmemcpy(&v303[3], playerr->BannerData, 0x60u);// Banner Pixels
        ArenaSendPacket(v233, v303, 0x63, 1);
      }
      return;
    case 0x1A:                                  // 0x1A - Security checksum
      if ( playerr->field_B4 )
      {
        v50 = GetTickCount();
        v54 = playerr->field_B4;
        playerr->field_B4 = 0;
        *playerra = v50 / 0xA - v54;
        playerr->SecurityWeaponCountTotal = playerr->field_11F;
        playerr->SecurityWeaponCount = *(packet + 1);// Weapon Count
        qmemcpy(playerr->gap_12B, packet, 0x28u);
        LOBYTE(v50) = packet[39];               // Slow Frame Detected (Boolean)
        if ( v50 )
          goto LABEL_76;
        v55 = playerr->MyArena;
        if ( v55 && !playerr->isSuperModerator && v55->field_FF38 )
        {
          SubSpaceEXECheckSum = *(packet + 9);  // Subspace.EXE Checksum
          v57 = playerr->SubspaceEXEChecksumIndex;
          if ( *&SecurityArray[0].ScrtyData[8 * v55->field_FF34 + 4 + v57 * 4036] != SubSpaceEXECheckSum )
          {
            v58 = 0;
            v59 = &SecurityArray[v57].ScrtyData[4];
            v60 = 500;
            do
            {
              if ( *v59 == SubSpaceEXECheckSum )
                v58 = 1;
              v59 += 8;
              --v60;
            }
            while ( v60 );
            if ( v58 )
              v296 = "WARNING: Code checksum mismatch - [%d] old match";
            else
              v296 = "WARNING: Code checksum mismatch - [%d] no possible match";
            sprintf(a1, v296, *(packet + 9));   // Subspace.EXE Checksum
            SendBillerWarnings(a1, playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          if ( playerr->MyArena->field_FF38 != *(packet + 5) )// Settings Checksum
          {
            sprintf(a1, "WARNING: Parameter checksum mismatch: TimeSinceRequest:%d0 ms", *playerra);
            SendBillerWarnings(a1, playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          MapLVLCheckSum = *(packet + 13);      // Map.LVL Checksum
          if ( MapLVLCheckSum != -12345678 && playerr->MyArena->MapLVLChecksum != MapLVLCheckSum )
          {
            SendBillerWarnings("WARNING: Level checksum mismatch", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          v62 = *(packet + 25);
          v63 = *(packet + 27) + v62;
          v64 = playerr->MyArena;
          if ( v63 > v64->ArenaSettings.ClientSlowPacketSampleSize
            && playerr->Ship != 8
            && 1000 * v62 / v63 > v64->ServersideArenaSettings.LatencyClientSlowPacketKickoutPercent )
          {
            if ( v64 )
            {
              playerra[124] = 7;                // 0x07 - Chat
              playerra[125] = 0;
              playerra[126] = 0;
              *&playerra[127] = -1;
              strcpy(&playerra[129], "You have been put in spectator mode due to high latency (S2C)");
              v65 = strlen("You have been put in spectator mode due to high latency (S2C)") + 1;
              if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
                SendPlayerReliablePacket(playerr, &playerra[124], v65 - 1 + 6, 1);
            }
            SetPlayerShip(playerr, 8);
          }
        }
      }
      return;
    case 0x1B:                                  // 0x1B - Security violation
      GenerateWarning(playerr, packet[1]);
      return;
    case 0x1C:                                  // 0x1C - Drop Brick
      if ( playerr->Ship != 8 )
      {
        XTiles = *(packet + 1);
        if ( XTiles < 0 || XTiles >= 1024 || (YTiles = *(packet + 3), YTiles < 0) || YTiles >= 1024 )
        {
          if ( !playerr->isSuperModerator )
          {
            sprintf(a1, "Packet tampering(%d)", packetId);
            SendBillerWarnings(a1, playerr);
            v49 = playerr->MyArena;
            if ( v49 )
            {
              if ( v49->ServersideArenaSettings.dwordB4 )
                goto LABEL_683;
            }
          }
        }
        else
        {
          DropBrick(playerr->MyArena, XTiles, YTiles, playerr->Frequency);
        }
      }
      return;
    case 0x1D:                                  // 0x1D - Change Certain Arena Settings
      if ( !playerr->isSysop )
      {
        arena = playerr->MyArena;
        SettingsUserId = arena->ServersideArenaSettings.OwnerUserId;
        if ( playerr->UserId != SettingsUserId || SettingsUserId < 0 )
        {
          if ( !arena )
            return;
          playerra[124] = 7;                    // 0x07 - Chat
          playerra[125] = 0;
          playerra[126] = 0;
          *&playerra[127] = -1;
          strcpy(&playerra[129], "Only the owner of this arena can change the settings.");
          v43 = strlen("Only the owner of this arena can change the settings.") + 6;
          if ( GetRelAckDiff(playerr->encryptionPointer, 0) >= 128 )
            return;
LABEL_553:
          SendPlayerReliablePacket(playerr, &playerra[124], v43, 1);
          return;
        }
      }
      ChangedSetting = (packet + 1);
      if ( packet[1] )
      {
        do
        {
          if ( ChangedSetting - packet >= packetSize )
            break;
          ChangeSettings(playerr->MyArena, playerr, ChangedSetting);
          v45 = strlen(ChangedSetting) + 1;
          v46 = ChangedSetting[v45];
          ChangedSetting += v45;
        }
        while ( v46 );
      }
      if ( playerr->MyArena )
      {
        playerra[124] = 7;                      // 0x07 - Chat
        playerra[125] = 0;
        playerra[126] = 0;
        *&playerra[127] = -1;
        strcpy(&playerra[129], "Settings have been successfully changed.");
        v43 = strlen("Settings have been successfully changed.") + 6;
        if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
          goto LABEL_553;
      }
      return;
    case 0x1E:                                  // 0x1E - End Personal KoTH Timer
      currentCrownKills = playerr->KotHDeathCount;
      if ( currentCrownKills > 0 )
      {
        playerr->KotHDeathCount = currentCrownKills - 1;
        playerr->KingCrownKills = 0;
        if ( playerr->KotHDeathCount )
        {
          v98 = playerr->MyArena;
          playerra[0] = 0x2B;                   // 0x2B - Set Personal KotH Timer
          *&playerra[1] = v98->ServersideArenaSettings.KingExpireTime;// New Timer Value
          SendPlayerReliablePacket(playerr, playerra, 5u, 1);
        }
        else
        {
          v96 = playerr->PlayerId;
          *&playerra[2] = 0;                    // Timer Value
          v97 = playerr->MyArena;
          *playerra = 0x2C;                     // 0x2C - KotH Game Reset
          *&playerra[6] = v96;                  // Player ID
          ArenaSendPacket(v97, playerra, 8, 1);
        }
      }
      return;
    case 0x1F:                                  // 0x1F - Fire a Ball
      v6 = playerr->MyArena;
      if ( v6 )
      {
        v7 = packet + 1;
        v8 = v6 + 12 * packet[1] + 3 * packet[1];
        if ( *(v8 + 65403) == *&playerr->PlayerId && !*(v8 + 65405) )
        {
          v9 = v8 + 65394;
          *v9 = *v7;
          *(v9 + 4) = *(packet + 5);
          *(v9 + 8) = *(packet + 9);
          *(v9 + 12) = *(packet + 13);
          *(v9 + 14) = packet[15];
          playerr->MyArena->SoccerBallTimers[*v7] = GetTickCount() / 0xA;
          v10 = playerr->MyArena;
          v11 = *v7;
          playerra[56] = 0x2E;                  // 0x2E  Power-Ball Position Update
          v12 = v10->SoccerBalls + 12 * v11 + 3 * v11;
          *&playerra[57] = *v12;
          *&playerra[61] = *(v12 + 4);
          *&playerra[65] = *(v12 + 8);
          *&playerra[69] = *(v12 + 12);
          playerra[71] = *(v12 + 14);
          ArenaSendPacket(v10, &playerra[56], 0x10, 0);
        }
      }
      return;
    case 0x20:                                  // 0x20 - Ball request
      v34 = playerr->MyArena;
      if ( !v34 || playerr->Ship == 8 )
        return;
      CountPlayersIThink = *(&v34[1].PlayerPointers[23] + 2);
      v36 = 0;
      if ( CountPlayersIThink <= 0 )
        goto LABEL_46;
      v37 = (&v34[1].PlayerPointers[26] + 3);
      while ( *(v37 + 1) || *v37 != *&playerr->PlayerId )
      {
        ++v36;
        v37 = (v37 + 15);
        if ( v36 >= CountPlayersIThink )
        {
LABEL_46:
          if ( *(&v34[1].PlayerPointers[3 * packet[1] + 27] + 3 * packet[1] + 1) == *(packet + 2) )
          {
            if ( v34->ArenaPlayerCount > *(&v34[1].PlayerPointers[11165] + 2) )
              playerr->MySoccerReward += *(&v34[1].PlayerPointers[11163] + 2);
            playerr->MyArena->SoccerBalls[packet[1]].StartTimerDelay = 0;
            playerr->MyArena->SoccerBalls[packet[1]].PlayerId = playerr->PlayerId;
            playerr->MyArena->SoccerBalls[packet[1]].XPixels = playerr->XPixels;
            playerr->MyArena->SoccerBalls[packet[1]].YPixels = playerr->YPixels;
            playerr->MyArena->SoccerBallTimers[packet[1]] = GetTickCount() / 0xA;
            v38 = playerr->MyArena;
            v39 = packet[1];
            playerra[56] = 0x2E;                // 0x2E - Power-Ball Position Update
            v40 = v38->SoccerBalls + 12 * v39 + 3 * v39;
            *&playerra[57] = *v40;
            *&playerra[61] = *(v40 + 4);
            *&playerra[65] = *(v40 + 8);
            *&playerra[69] = *(v40 + 12);
            playerra[71] = *(v40 + 14);
            ArenaSendPacket(v38, &playerra[56], 16, 0);
          }
          return;
        }
      }
      return;
    case 0x21:                                  // 0x21 - Soccer goal scored
      v13 = playerr->MyArena;
      if ( v13 )
      {
        v14 = v13 + 12 * packet[1] + 3 * packet[1];
        if ( *(v14 + 65403) == *&playerr->PlayerId )
        {
          if ( *(v14 + 65405) )
          {
            v15 = v13->ArenaPlayerCount;
            v16 = 0;
            if ( v15 > 0 )
            {
              v17 = v13->playerPointersForSomething;
              do
              {
                if ( (*v17)->Ship != 8 )
                  ++v16;
                ++v17;
                --v15;
              }
              while ( v15 );
            }
            SoccerReward = v13->ServersideArenaSettings.SoccerReward;
            if ( SoccerReward >= 0 )
              temp2 = SoccerReward * v16 * v16 / 1000;
            else
              temp2 = -SoccerReward;
            *&playerra[8] = temp2;
            if ( temp2 )
            {
              sprintf(Dest, "Team Goal! by %s  Reward:%d", playerr->Name, temp2);
              sprintf(a1, "Enemy Goal! by %s  Reward:%d", playerr->Name, temp2);
            }
            else
            {
              sprintf(Dest, "Team Goal! by %s", playerr->Name);
              sprintf(a1, "Enemy Goal! by %s", playerr->Name);
            }
            v20 = playerr->MyArena;
            *&playerra[16] = 0;
            if ( v20->ArenaPlayerCount > 0 )
            {
              v21 = 64288;
              *&playerra[12] = 64288;
              while ( 1 )
              {
                v22 = *(v20->PlayerPointers + v21);
                if ( *(v22 + 279) != playerr->Frequency || *(v22 + 275) == 8 )
                {
                  if ( *(v22 + 28) )
                  {
                    playerra[124] = 7;
                    playerra[125] = 0;
                    playerra[126] = 104;
                    *&playerra[127] = -1;
                    strcpy(&playerra[129], a1);
                    v25 = strlen(a1) + 1;
                    if ( GetRelAckDiff(*(v22 + 40), 0) < 128 )
                      SendPlayerReliablePacket(v22, &playerra[124], v25 - 1 + 6, 1);
                  }
                }
                else
                {
                  *(v22 + 557) += temp2;
                  ++(*(playerr->MyArena->PlayerPointers + v21))->GoalCount;
                  v23 = *(playerr->MyArena->PlayerPointers + v21);
                  if ( *(v23 + 28) )
                  {
                    LOWORD(buf) = 7;            // 0x07 - Chat
                    BYTE2(buf) = 104;
                    *(&buf + 3) = -1;
                    strcpy(&v306, Dest);
                    v24 = strlen(Dest) + 1;
                    if ( GetRelAckDiff(*(v23 + 40), 0) < 128 )
                      SendPlayerReliablePacket(v23, &buf, v24 - 1 + 6, 1);
                  }
                }
                v20 = playerr->MyArena;
                v21 = *&playerra[12] + 4;
                v26 = ++*&playerra[16] < v20->ArenaPlayerCount;
                *&playerra[12] += 4;
                if ( !v26 )
                  break;
                temp2 = *&playerra[8];
              }
              packett = packet;
              temp2 = *&playerra[8];
            }
            v27 = playerr->MyArena;
            if ( v27->ServersideArenaSettings.SoccerCapturePoints )
              SoccerGame2(v27, playerr->Frequency, *(packett + 1), *(packett + 2));
            if ( temp2 )
            {
              temp3 = playerr->Frequency;
              v29 = playerr->MyArena;
              playerra[0] = 0xB;                // 0x0B - Soccer Goal Made
              *&playerra[1] = temp3;
              *&playerra[3] = temp2;
              ArenaSendPacket(v29, playerra, 7, 1);
            }
            v30 = playerr->MyArena;
            if ( v30->TotalSoccerBalls > 0 )
            {
              CreateSoccerBall(v30, packett[1]);
              playerr->MyArena->SoccerBallTimers[packett[1]] = GetTickCount() / 0xA;
              v31 = playerr->MyArena;
              v32 = packett[1];
              playerra[56] = 0x2E;              // 0x2E - Power-Ball Position Update
              v33 = v31->SoccerBalls + 12 * v32 + 3 * v32;
              *&playerra[57] = *v33;
              *&playerra[61] = *(v33 + 1);
              *&playerra[65] = *(v33 + 2);
              *&playerra[69] = *(v33 + 6);
              playerra[71] = v33[14];
              ArenaSendPacket(v31, &playerra[56], 16, 0);
            }
          }
        }
      }
      return;
    case 0x22:                                  // 0x22 - Security Violation Unknown
      if ( playerr->MyArena && !playerr->isSuperModerator )
      {
        v50 = packet[17];
        if ( v50 )
        {
LABEL_76:
          GenerateWarning(playerr, v50);
        }
        else
        {
          if ( *&SecurityArray[playerr->SubspaceEXEChecksumIndex].ScrtyData[4] != *(packet + 9) )
          {
            SendBillerWarnings("WARNING: Code checksum mismatch (unsolicited)", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
          ArenaSettingsChecksum = 0;
          v52 = &playerr->MyArena->ArenaSettings;
          v53 = 357;
          do
          {
            ArenaSettingsChecksum += v52->VersionAndManyBitFields;
            v52 = (v52 + 4);
            --v53;
          }
          while ( v53 );
          if ( ArenaSettingsChecksum != *(packet + 5) )
          {
            SendBillerWarnings("WARNING: Parameter checksum mismatch (unsolicited)", playerr);
            if ( playerr->MyArena->ServersideArenaSettings.dwordB4 )
            {
              playerr->DisconnectReason = 3;    // 0x03 - Arena is Full
              playerr->AlreadySentReliablePacket = 1;
            }
          }
        }
      }
      return;
    default:
      if ( !playerr->isSuperModerator )
      {
        sprintf(a1, "Packet tampering(%d)", packetId);
        SendBillerWarnings(a1, playerr);
        v294 = playerr->MyArena;
        if ( v294 )
        {
          if ( v294->ServersideArenaSettings.dwordB4 )
          {
LABEL_683:
            playerr->DisconnectReason = 0x10;   // 0x10 - Restricted Zone, Compare against local Subspace.exe to determine if an Update is needed.
            playerr->AlreadySentReliablePacket = 1;
          }
        }
      }
      return;
  }
}
/* Orphan comments:
Weapon Info
Player Name 32 Bytes Length
0x0A - Password Packet Response
0x0A - Password Packet Response
0x05 - Permission Only Arena
Server Version 134 = SubSpace 1.34
Registration Form Request (Boolean)
*/
// 40AAF0: conditional instruction was optimized away because of 'esi.4!=0'
// 408E80: variables would overlap: ^518.4 and ^51B.2
// 432004: using guessed type int bRecycleServer;
// 4386D4: using guessed type int MachineIdArrayIndex;
// 4D89C8: using guessed type int Wave;
// 4D8B14: using guessed type int dword_4D8B14;

//----- (0040CB80) --------------------------------------------------------
// Player.GenerateWarning()
void __thiscall GenerateWarning(struct_PLAYER *player, int violationType)
{
  int v3; // edx
  const char *v4; // eax
  struct_ARENA *v5; // ecx
  int v6; // eax
  struct_ARENA *v7; // eax
  char Dest[252]; // [esp+8h] [ebp-100h] BYREF

  if ( !player->isSuperModerator )
  {
    v3 = 1;
    v4 = "Unknown integrity violation";
    switch ( violationType )
    {
      case 0:
        v4 = "Normal integrity";
        goto LABEL_33;
      case 1:
        v4 = "Slow frame detected";
        goto LABEL_33;
      case 2:
        v4 = "Current energy higher than top energy";
        goto LABEL_33;
      case 3:
        v4 = "Top energy higher than max energy";
        goto LABEL_33;
      case 4:
        v4 = "Max energy without getting prizes";
        goto LABEL_33;
      case 5:
        v4 = "Recharge rate higher than max recharge rate";
        goto LABEL_33;
      case 6:
        v4 = "Max recharge rate without getting prizes";
        goto LABEL_33;
      case 7:
        v4 = "Too many burst used";
        goto LABEL_33;
      case 8:
        v4 = "Too many repel used";
        goto LABEL_33;
      case 9:
        v4 = "Too many decoy used";
        goto LABEL_33;
      case 10:
        v4 = "Too many thor used";
        goto LABEL_33;
      case 11:
        v4 = "Too many wall blocks used";
        goto LABEL_33;
      case 12:
        v4 = "Stealth on but never collected";
        goto LABEL_33;
      case 13:
        v4 = "Cloak on but never collected";
        goto LABEL_33;
      case 14:
        v4 = "XRadar on but never collected";
        goto LABEL_33;
      case 15:
        v4 = "AntiWarp on but never collected";
        goto LABEL_33;
      case 16:
        v4 = "Proximity bombs but never collected";
        goto LABEL_33;
      case 17:
        v4 = "Bouncing bullets but never collected";
        goto LABEL_33;
      case 18:
        v4 = "Max guns without getting prizes";
        goto LABEL_33;
      case 19:
        v4 = "Max bombs without getting prizes";
        goto LABEL_33;
      case 20:
        v4 = "Shields or Super on longer than possible";
        goto LABEL_33;
      case 21:
        v3 = 0;
        v4 = "Saved ship weapon limits too high (burst/repel/etc)";
        goto LABEL_33;
      case 22:
        v3 = 0;
        v4 = "Saved ship weapon level too high (guns/bombs)";
        goto LABEL_33;
      case 23:
        v3 = 0;
        v4 = "Login checksum mismatch (program exited)";
        goto LABEL_33;
      case 24:
        v5 = player->MyArena;
        v6 = player->field_157 + 1;
        player->field_157 = v6;
        if ( v6 < v5->ServersideArenaSettings.SecurityPacketModificationMax )
          return;
        v4 = "S2C position packet modified";
LABEL_33:
        if ( !*player->gap_309 || !v3 )
        {
          sprintf(Dest, "WARNING: %s", v4);
          SendBillerWarnings(Dest, player);
          v7 = player->MyArena;
          if ( v7 )
          {
            if ( v7->ServersideArenaSettings.dwordB4 )
            {
              player->DisconnectReason = 3;
              player->AlreadySentReliablePacket = 1;
            }
          }
        }
        break;
      case 25:
        v3 = 0;
        v4 = "Saved ship checksum mismatch";
        goto LABEL_33;
      case 26:
        v4 = "Softice Debugger Running";
        goto LABEL_33;
      case 27:
        v4 = "Data checksum mismatch detected";
        goto LABEL_33;
      case 28:
        v4 = "Parameter mismatch detected";
        goto LABEL_33;
      default:
        goto LABEL_33;
    }
  }
}

//----- (0040CDB0) --------------------------------------------------------
void __thiscall UpdatePowerBallPositionsSomething(struct_PLAYER *playerr)
{
  struct_ARENA *v2; // ecx
  int XPixels; // eax
  int PowerBallId; // ebx
  int CounterBy15; // edi
  struct_ARENA *arena; // ecx
  int v7; // [esp+8h] [ebp-18h]
  int YPixels; // [esp+Ch] [ebp-14h]
  char buf[16]; // [esp+10h] [ebp-10h] BYREF

  v2 = playerr->MyArena;
  if ( v2 )
  {
    XPixels = playerr->XPixels;
    YPixels = playerr->YPixels;
    PowerBallId = 0;
    v7 = XPixels;
    if ( v2->TotalSoccerBalls > 0 )
    {
      CounterBy15 = 0;
      while ( 1 )
      {
        if ( !v2->SoccerBalls[CounterBy15].StartTimerDelay
          && v2->SoccerBalls[CounterBy15].PlayerId == *&playerr->PlayerId )
        {
          if ( XPixels <= 0 || YPixels <= 0 )
          {
            CreateSoccerBall(v2, PowerBallId);
          }
          else
          {
            v2->SoccerBalls[CounterBy15].PowerBallId = PowerBallId;
            playerr->MyArena->SoccerBalls[CounterBy15].XPixels = XPixels;
            *&playerr->MyArena->SoccerBalls[CounterBy15].YPixels = YPixels;
            playerr->MyArena->SoccerBalls[CounterBy15].ZeroTwo = 0;
            playerr->MyArena->SoccerBalls[CounterBy15].PlayerId = playerr->PlayerId;
            playerr->MyArena->SoccerBalls[CounterBy15].StartTimerDelay = GetTickCount() / 0xA;
            playerr->MyArena->SoccerBallTimers[PowerBallId] = GetTickCount() / 0xA;
            arena = playerr->MyArena;
            buf[0] = 0x2E;                      // 0x2E - Power-Ball Position Update
            *&buf[1] = *&arena->SoccerBalls[CounterBy15].PowerBallId;// Powerball Id - [1 byte]
            *&buf[5] = *(&arena->SoccerBalls[CounterBy15].YPixels + 1);
            *&buf[9] = *(&arena->SoccerBalls[CounterBy15].ZeroTwo + 1);
            *&buf[13] = *(&arena->SoccerBalls[CounterBy15].StartTimerDelay + 1);
            buf[15] = HIBYTE(arena->SoccerBalls[CounterBy15].StartTimerDelay);
            ArenaSendPacket(arena, buf, 0x10, 0);
          }
        }
        v2 = playerr->MyArena;
        ++PowerBallId;
        ++CounterBy15;
        if ( PowerBallId >= v2->TotalSoccerBalls )
          break;
        XPixels = v7;
      }
    }
  }
}

//----- (0040CF10) --------------------------------------------------------
signed int __thiscall sub_40CF10(struct_PLAYER *playerr)
{
  signed int result; // eax
  DWORD (__stdcall *GetTickCountt)(); // ebx
  __int64 v4; // rax
  __int64 v5; // rax
  DWORD v6; // eax
  unsigned int v7; // kr08_4
  FILE *v8; // ebx
  unsigned int v9; // kr10_4
  signed int v10; // esi
  __int64 v11; // rax
  struct_ARENA *v12; // esi
  unsigned int v13; // kr28_4
  int *v14; // ebx
  int *v15; // esi
  int v16; // edi
  struct_ARENA *v17; // eax
  unsigned int v18; // kr30_4
  int v19; // eax
  int v20; // esi
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  struct_ARENA *v24; // eax
  int v25; // esi
  unsigned int v26; // [esp-8h] [ebp-524h]
  const char *v27; // [esp-8h] [ebp-524h]
  char *v28; // [esp-4h] [ebp-520h]
  char v29; // [esp+13h] [ebp-509h] BYREF
  int i; // [esp+14h] [ebp-508h]
  DWORD ExitCode; // [esp+18h] [ebp-504h] BYREF
  char v32[256]; // [esp+1Ch] [ebp-500h] BYREF
  char Dest[256]; // [esp+21Ch] [ebp-300h] BYREF
  char buf[256]; // [esp+31Ch] [ebp-200h] BYREF

  if ( playerr->field_287 > 0 )
    HighestPlayerCountMaybeSomething = 1;
  if ( playerr->AlreadySentReliablePacket )
    return 1;
  GetTickCountt = GetTickCount;
  if ( playerr->KickOffDelayTimer )
  {
    v4 = (GetTickCount() / 0xA - playerr->KickOffDelayTimer);
    if ( ((HIDWORD(v4) ^ v4) - HIDWORD(v4)) > 1000 )
    {
      printf("KickOffTime expired: %s\n", playerr->PlayerName);
      return 1;
    }
  }
  if ( !playerr->PlayerName[0] )
  {
    v5 = (GetTickCount() / 0xA - playerr->NoPasswordPacketDelayTimer);
    if ( ((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 300 )
    {
      printf("No password packet delay exceeded\n");
      playerr->DisconnectReason = 17;
      return 1;
    }
  }
  if ( !playerr->MyArena )
  {
    if ( abs32(GetTickCount() / 0xA - playerr->encryptionPointer->MenuKickOutDelayTimer) > MiscMenuKickOutDelay )
    {
      v28 = playerr->PlayerName;
      v27 = "Menu kickout delay exceeded: %s\n";
      goto LABEL_74;
    }
LABEL_72:
    if ( CheckIfBillingServerIsConnected(playerr->encryptionPointer) != 4 )
      return 0;
    v28 = playerr->PlayerName;
    v27 = "Connection status read as terminated: %s\n";
LABEL_74:
    printf(v27, v28);
    result = 1;
    playerr->DisconnectReason = 1;
    return result;
  }
  if ( playerr->unknownIthoughtItWasPlayerPointerDupe
    && GetExitCodeProcess(playerr->unknownIthoughtItWasPlayerPointerDupe, &ExitCode)
    && ExitCode != 259 )
  {
    TerminateProcess(playerr->unknownIthoughtItWasPlayerPointerDupe, 0);
    CloseHandle(playerr->unknownIthoughtItWasPlayerPointerDupe);
    v6 = ExitCode;
    playerr->unknownIthoughtItWasPlayerPointerDupe = 0;
    playerr->dword4 = 0;
    playerr->dword8 = 0;
    playerr->dwordC = 0;
    sprintf(Dest, "SPAWN TERMINATED: %d", v6);
    if ( playerr->MyArena )
    {
      buf[0] = 7;
      buf[1] = 0;
      buf[2] = 0;
      *&buf[3] = -1;
      strcpy(&buf[5], Dest);
      v7 = strlen(Dest) + 1;
      if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
        SendPlayerReliablePacket(playerr, buf, v7 - 1 + 6, 1);
    }
    v8 = fopen("spawn.log", "rt");
    if ( v8 )
    {
      for ( i = 0; i < 40; ++i )
      {
        buf[0] = 0;
        fgets(buf, 256, v8);
        if ( playerr->MyArena )
        {
          v32[0] = 7;                           // 0x07 - Chat
          v32[1] = 0;                           // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
          v32[2] = 0;                           // Sound Byte
          *&v32[3] = -1;                        // Originator ID
          strcpy(&v32[5], buf);
          v9 = strlen(buf) + 1;
          if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
            SendPlayerReliablePacket(playerr, v32, v9 - 1 + 6, 1);
        }
        if ( (v8->_flag & 0x10) != 0 )
          break;
      }
      fclose(v8);
    }
    GetTickCountt = GetTickCount;
  }
  v10 = abs32(GetTickCountt() / 0xA - playerr->encryptionPointer->MenuKickOutDelayTimer);
  if ( v10 > playerr->MyArena->ServersideArenaSettings.LatencyNoFlagDelay )
    playerr->field_15B = GetTickCountt() / 0xA;
  if ( v10 <= playerr->MyArena->ServersideArenaSettings.LatencyKickOutDelay
    || playerr->isSysop && abs32(GetTickCountt() / 0xA - playerr->encryptionPointer->MenuKickOutDelayTimer) <= 6000 )
  {
    if ( playerr->DemoPlayer )
    {
      v11 = (GetTickCountt() / 0xA - playerr->NoPasswordPacketDelayTimer);
      if ( ((HIDWORD(v11) ^ v11) - HIDWORD(v11)) > MiscMaxSharkwareTime )
      {
        WriteSubGameLog("Shareware Timer Expired: %s\n", playerr->PlayerName);
        *&v32[3] = playerr->PlayerId;
        playerr->DisconnectReason = 22;
        v32[0] = 7;                             // 0x07 - Chat
        v32[1] = 0;                             // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
        v32[2] = 0;                             // Sound Byte
        strcpy(
          &v32[5],
          "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.");
        v26 = strlen(
                "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.")
            + 6;
        goto LABEL_82;
      }
    }
    if ( abs32(GetTickCountt() / 0xA - playerr->encryptionPointer->KeepAliveDelayTimer) > MiscKeepAliveDelay )
    {
      v29 = 0x27;                               // 0x27 - Keep-alive
      SendPlayerReliablePacket(playerr, &v29, 1u, 0);
    }
    if ( playerr->Ship != 8 )
    {
      if ( playerr->LatencyKickOutDelayTimer )
      {
        v12 = playerr->MyArena;
        if ( (GetTickCountt() / 0xA - playerr->LatencyKickOutDelayTimer) > v12->ServersideArenaSettings.LatencyKickOutTime
          && !playerr->isSysop )
        {
          if ( v12 )
          {
            v32[0] = 7;                         // 0x07 - Chat
            v32[1] = 0;
            v32[2] = 0;
            *&v32[3] = -1;
            strcpy(&v32[5], "You have been put in spectator mode due to high latency (spike)");
            v13 = strlen("You have been put in spectator mode due to high latency (spike)") + 1;
            if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
              SendPlayerReliablePacket(playerr, v32, v13 - 1 + 6, 1);
          }
          SetPlayerShip(playerr, 8);
        }
      }
    }
    v14 = &playerr->C2SPacketLossPercentage;
    v15 = &playerr->S2CPacketLossPercentage;
    sub_41CB70(playerr->encryptionPointer, &playerr->S2CPacketLossPercentage, &playerr->C2SPacketLossPercentage);
    v16 = 0;
    if ( playerr->Ship == 8 )
      v16 = playerr->MyArena->ServersideArenaSettings.PacketLossSpectatorPercentAdjust;
    v17 = playerr->MyArena;
    if ( (*v15 < v17->ServersideArenaSettings.PacketLossS2CKickOutPercent - v16
       || *v14 < v17->ServersideArenaSettings.PacketLossC2SKickOutPercent - v16
       || *v14 > v17->ServersideArenaSettings.PacketLossC2SNegativeKickOutPercent + v16 + 1000)
      && !playerr->isSysop )
    {
      if ( playerr->Ship == 8 )
      {
        WriteSubGameLog(
          "Packet loss too high S2C:%d%%, C2S:%d%%, kicking out player: %s\n",
          (1000 - *v15) / 10,
          (1000 - *v14) / 10,
          playerr->PlayerName);
        v24 = playerr->MyArena;
        v25 = *v15;
        if ( v25 >= v24->ServersideArenaSettings.PacketLossS2CKickOutPercent - v16 )
        {
          if ( *v14 <= v24->ServersideArenaSettings.PacketLossC2SNegativeKickOutPercent + v16 + 1000 )
            playerr->DisconnectReason = 7;
          else
            playerr->DisconnectReason = 23;
        }
        else
        {
          playerr->DisconnectReason = 6;
        }                                       // Do divsion here by 1000
        sprintf(
          Dest,
          "WARNING: Disconnected because of high packet loss (ServerToYou:%d%%, YouToServer:%d%%)",
          (1000 - v25) / 10,                    // (1000 - v42) / 10
          (1000 - *v14) / 10);
        *&v32[3] = playerr->PlayerId;
        v32[0] = 7;
        v32[1] = 0;
        v32[2] = 0;
        strcpy(&v32[5], Dest);
        v26 = strlen(Dest) + 6;
        goto LABEL_82;
      }
      if ( v17 )
      {
        v32[0] = 7;
        v32[1] = 0;
        v32[2] = 0;
        *&v32[3] = -1;
        strcpy(&v32[5], "You have been put in spectator mode due to high packet loss");
        v18 = strlen("You have been put in spectator mode due to high packet loss") + 1;
        if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
          SendPlayerReliablePacket(playerr, v32, v18 - 1 + 6, 1);
      }
      SetPlayerShip(playerr, 8);
    }
    v19 = *v14;
    if ( *v14 >= 1000 )
      v19 = 1000;
    v20 = playerr->S2CPacketLossPercentage;
    v21 = v19 - v20;
    playerr->field_153 = v21;
    if ( v20 > 900 || playerr->isSysop || v21 < 0 )
      playerr->field_153 = 0;
    if ( v20 < 1000 )
    {
      v22 = playerr->SecurityWeaponCountTotal;
      if ( v22 > 400 && playerr->Ship != 8 )
      {
        v23 = 1000 * playerr->SecurityWeaponCount / v22;
        if ( v20 - v23 > 100
          && v23 < playerr->MyArena->ServersideArenaSettings.SecurityS2CKickOutPercentWeapons
          && !playerr->isSysop )
        {
          sprintf(Dest, "S2C weapon packet loss too high(S2CW=%d%%)(S2C=%d%%)", (1000 - v23) / 10, (1000 - v20) / 10);
          SendBillerWarnings(Dest, playerr);
          playerr->DisconnectReason = 3;
          return 1;
        }
      }
    }
    goto LABEL_72;
  }
  WriteSubGameLog("Kickout delay exceeded: %s\n", playerr->PlayerName);
  playerr->DisconnectReason = 9;
  *&v32[3] = playerr->PlayerId;
  v32[0] = 7;                                   // 0x07 - Chat
  v32[1] = 0;
  v32[2] = 0;
  strcpy(&v32[5], "WARNING: You have been disconnected because server has not been receiving data from you.");
  v26 = strlen("WARNING: You have been disconnected because server has not been receiving data from you.") + 6;
LABEL_82:
  SendPlayerReliablePacket(playerr, v32, v26, 0);
  sub_41CB20(playerr->encryptionPointer);
  return 1;
}
/* Orphan comments:
Chat Message
(1000 - v28) / 10
Do divsion here by 1000
(1000 - v29) / 10
// 0x66666667 / 2^(32+2)
*/
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;

//----- (0040D870) --------------------------------------------------------
void __thiscall sub_40D870(struct_PLAYER *this)
{
  struct_ARENA *v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  __int64 v9; // rax
  int v10; // edi
  int v11; // ebx
  struct_ARENA *v12; // ecx

  v2 = this->MyArena;
  v3 = this->XPixels - *&v2->dwLastConfigReadTime[8];
  this->LooksLikeX1BigOfSomething = v3;
  if ( v3 < 0 )
    this->LooksLikeX1BigOfSomething = 0;
  v4 = 2 * (0x2000 - *&v2->dwLastConfigReadTime[8]);
  if ( this->LooksLikeX1BigOfSomething > v4 )
    this->LooksLikeX1BigOfSomething = v4;
  v5 = this->YPixels - *&v2->dwLastConfigReadTime[8];
  this->LooksLikeYBigOfSomething = v5;
  if ( v5 < 0 )
    this->LooksLikeYBigOfSomething = 0;
  v6 = 2 * (0x2000 - *&v2->dwLastConfigReadTime[8]);
  if ( this->LooksLikeYBigOfSomething > v6 )
    this->LooksLikeYBigOfSomething = v6;
  v7 = this->LooksLikeYBigOfSomething;
  this->LooksLikeXSmallOfSomething = this->LooksLikeX1BigOfSomething + 2 * *&v2->dwLastConfigReadTime[8];
  v8 = v7 + 2 * *&v2->dwLastConfigReadTime[8];
  this->LooksLikeYSmallOfSomething = v8;
  if ( v2 )
  {
    v9 = this->LooksLikeX1BigOfSomething + this->LooksLikeXSmallOfSomething;
    v10 = ((WORD2(v9) & 0xFFF) + v9) >> 12;
    v11 = (v8 + this->LooksLikeYBigOfSomething) / 4096;
    if ( v10 != this->field_50 || v11 != this->field_54 )
    {
      sub_404980(v2, this, *&this->field_50);
      v12 = this->MyArena;
      this->field_50 = v10;
      this->field_54 = v11;
      AddPlayerToArenaSomething(v12, this, v10, v11);
    }
  }
}

//----- (0040D980) --------------------------------------------------------
void __thiscall PlayerChangeFrequency(struct_PLAYER *playerr, signed int NewFrequency)
{
  int NewFrequencyy; // edi
  struct_ARENA *arena; // esi
  struct_PLAYER **v5; // ecx
  int v6; // edx
  int Frequency; // eax
  int CurrentFrequency; // ecx
  signed int DesiredTeams; // eax
  unsigned int v10; // kr08_4
  int ArenaPlayerCount; // ecx
  int NumPlayersOnNewFrequency; // edx
  struct_PLAYER **v13; // eax
  int v14; // ecx
  __int16 v15; // ax
  struct_ARENA *v16; // ecx
  __int16 v17; // dx
  unsigned __int8 v18[6]; // [esp+10h] [ebp-20Ch] BYREF
  unsigned __int8 v19[3]; // [esp+18h] [ebp-204h] BYREF
  int NumPlayersPerFreqArray[64]; // [esp+1Ch] [ebp-200h] BYREF

  NewFrequencyy = NewFrequency;
  arena = playerr->MyArena;
  if ( NewFrequency >= arena->ArenaSettings.MaxFrequency )
    return;
  if ( arena->ServersideArenaSettings.TeamForceEvenTeams > 0 && !playerr->isSuperModerator )
  {
    memset(NumPlayersPerFreqArray, 0, sizeof(NumPlayersPerFreqArray));
    if ( arena->ArenaPlayerCount > 0 )
    {
      v5 = arena->playerPointersForSomething;
      v6 = arena->ArenaPlayerCount;
      do
      {
        Frequency = (*v5)->Frequency;
        if ( Frequency < 64 )
          ++NumPlayersPerFreqArray[Frequency];
        ++v5;
        --v6;
      }
      while ( v6 );
    }
    CurrentFrequency = playerr->Frequency;
    DesiredTeams = arena->ServersideArenaSettings.TeamDesiredTeams;
    if ( CurrentFrequency < DesiredTeams
      && NewFrequency < DesiredTeams
      && DesiredTeams < 64
      && NumPlayersPerFreqArray[CurrentFrequency] + arena->ServersideArenaSettings.TeamForceEvenTeams - 1 <= NumPlayersPerFreqArray[NewFrequency] )
    {
      if ( arena )
      {
        LOWORD(NumPlayersPerFreqArray[0]) = 7;  // 0x07 - Chat
        BYTE2(NumPlayersPerFreqArray[0]) = 0;   // Sound Byte
        *(NumPlayersPerFreqArray + 3) = -1;     // Originator ID
        strcpy(&NumPlayersPerFreqArray[1] + 1, "Changing frequencies would make the teams too uneven.");
        v10 = strlen("Changing frequencies would make the teams too uneven.") + 1;
        if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
          SendPlayerReliablePacket(playerr, NumPlayersPerFreqArray, v10 - 1 + 6, 1);
      }
      return;
    }
    NewFrequencyy = NewFrequency;
  }
  playerr->DebtKills = arena->ServersideArenaSettings.KillDebtKills;
  ArenaPlayerCount = arena->ArenaPlayerCount;
  NumPlayersOnNewFrequency = 0;
  if ( ArenaPlayerCount > 0 )
  {
    v13 = arena->playerPointersForSomething;
    do
    {
      if ( (*v13)->Frequency == NewFrequencyy )
        ++NumPlayersOnNewFrequency;
      ++v13;
      --ArenaPlayerCount;
    }
    while ( ArenaPlayerCount );
  }
  v14 = arena->ArenaSettings.MaxPerTeam;
  if ( arena->ArenaSettings.MaxPerPrivateTeam )
    v14 = arena->ArenaSettings.MaxPerPrivateTeam;
  if ( NumPlayersOnNewFrequency < v14 || playerr->isSysop )
  {
    v15 = playerr->PlayerId;
    playerr->Frequency = NewFrequencyy;
    v18[0] = 0xD;                               // 0x0D - Player Changed Frequency
    *&v18[1] = v15;                             // Player ID
    *&v18[3] = NewFrequencyy;                   // Frequency
    v18[5] = -1;                                // Ship
    if ( arena->ServersideArenaSettings.MiscFrequencyShipTypes && playerr->Ship != 8 )
    {
      playerr->Ship = NewFrequencyy % 8;
      v18[5] = playerr->Ship;                   // Ship
    }
    ArenaSendPacket(arena, v18, 6, 1);
    CarryFlagsSomething(playerr->MyArena, *&playerr->PlayerId, 0);
    UpdatePowerBallPositionsSomething(playerr);
    v16 = playerr->MyArena;
    if ( v16->ServersideArenaSettings.MiscResetScoreOnFrequencyChange )
    {
      v17 = playerr->PlayerId;
      playerr->CurrentLosses = 0;
      playerr->CurrentWins = 0;
      playerr->KillPoints = 0;
      playerr->FlagPoints = 0;
      playerr->GoalCount = 0;
      playerr->field_30D = 1;
      v19[0] = 0x1A;                            // 0x1A - Reset Score(s)
      *&v19[1] = v17;                           // Player ID
      if ( v16 )
        ArenaSendPacket(v16, v19, 3, 1);
    }
  }
}
/* Orphan comments:
Chat Message
Not to screw up the NumPlayersPerFreqArray the packet below has to use a char buffer[256] instead of the int[64] bad decompiler
Chat Type 0x00 - Message in green text [*arena, *zone, ...]
*/

//----- (0040DC00) --------------------------------------------------------
void __thiscall SetPlayerShip(struct_PLAYER *playerr, signed int Ship)
{
  __int16 playerId; // ax
  struct_ARENA *arenaa; // ecx
  __int16 Shipp; // ax
  __int16 v6; // dx
  struct_ARENA *v7; // ecx
  __int16 SpecFreq; // si
  struct_ARENA *arenaPointer; // esi
  unsigned int v10; // kr08_4
  __int16 Frequency; // ax
  struct_ARENA *v12; // ecx
  int TotalShipChanges; // esi
  unsigned __int8 buff2[6]; // [esp+10h] [ebp-210h] BYREF
  unsigned __int8 buff[5]; // [esp+18h] [ebp-208h] BYREF
  char buf[512]; // [esp+20h] [ebp-200h] BYREF

  if ( playerr->AttachedToPlayerId >= 0 )
  {
    playerId = playerr->PlayerId;
    arenaa = playerr->MyArena;
    buff[0] = 0xE;                              // 0x0E - Create Turret Link
    *&buff[3] = -1;
    *&buff[1] = playerId;
    playerr->AttachedToPlayerId = -1;
    ArenaSendPacket(arenaa, buff, 5, 1);
  }
  LOBYTE(Shipp) = Ship;
  v6 = playerr->PlayerId;
  buff2[0] = 0x1D;                              // 0x1D - Player Team and Ship Changed
  *&buff2[2] = v6;
  buff2[1] = Ship;
  if ( Ship == 8 )                              // Spec Ship
  {
    v7 = playerr->MyArena;
    SpecFreq = v7->ServersideArenaSettings.TeamSpectatorFrequency;
    *&buff2[4] = SpecFreq;
LABEL_18:
    playerr->Ship = Shipp;
    playerr->AttachedToPlayerId = -1;
    playerr->ArenaPlayerIndex = -1;
    playerr->Frequency = SpecFreq;
    ArenaSendPacket(v7, buff2, 6, 1);
    CarryFlagsSomething(playerr->MyArena, *&playerr->PlayerId, 0);
    UpdatePowerBallPositionsSomething(playerr);
    v12 = playerr->MyArena;
    TotalShipChanges = playerr->TotalShipChanges + 1;
    playerr->TotalShipChanges = TotalShipChanges;
    if ( TotalShipChanges > v12->ServersideArenaSettings.SecurityMaxShipTypeSwitchCount )
    {
      WriteSubGameLog("Played kicked off for too many ship type changes: %s\n", playerr->PlayerName);
      *&buf[3] = playerr->PlayerId;
      playerr->DisconnectReason = 15;
      playerr->AlreadySentReliablePacket = 1;
      buf[0] = 7;                               // 0x07 - Chat
      buf[1] = 0;
      buf[2] = 0;
      strcpy(&buf[5], "WARNING: You have been disconnected for too many ship type changes.");
      SendPlayerReliablePacket(
        playerr,
        buf,
        strlen("WARNING: You have been disconnected for too many ship type changes.") + 6,
        0);
      sub_41CB20(playerr->encryptionPointer);
    }
    return;
  }
  if ( playerr->Ship != 8 )                     // Any Ship other then Spec
  {
    v7 = playerr->MyArena;
    if ( v7->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      PlayerChangeFrequency(playerr, Ship);
      return;
    }
    SpecFreq = playerr->Frequency;
    *&buff2[4] = SpecFreq;
    goto LABEL_18;
  }
  if ( playerr->isModerator
    || playerr->MyArena->ServersideArenaSettings.MiscMaxPlaying <= 0
    || (arenaPointer = playerr->MyArena,
        GetTotalPlayingPlayers(arenaPointer) <= arenaPointer->ServersideArenaSettings.MiscMaxPlaying) )
  {
    Frequency = GetNextFrequencyToJoin(playerr->MyArena);
    v7 = playerr->MyArena;
    SpecFreq = Frequency;
    *&buff2[4] = Frequency;
    if ( v7->ServersideArenaSettings.MiscFrequencyShipTypes )
    {
      Shipp = Frequency % 8;
      buff2[1] = Shipp;
    }
    else
    {
      LOBYTE(Shipp) = buff2[1];
    }
    goto LABEL_18;
  }
  if ( arenaPointer )
  {
    *&buf[3] = -1;
    buf[0] = 7;                                 // 0x07 - Chat
    buf[1] = 0;
    buf[2] = 0;
    strcpy(&buf[5], "There are too many people playing the game right now, try again later.");
    v10 = strlen("There are too many people playing the game right now, try again later.") + 1;
    if ( GetRelAckDiff(playerr->encryptionPointer, 0) < 128 )
      SendPlayerReliablePacket(playerr, buf, v10 - 1 + 6, 1);
  }
}

//----- (0040DEA0) --------------------------------------------------------
void __thiscall sub_40DEA0(struct_PLAYER *this, const void *buf, unsigned int len, int a4)
{
  struct_ARENA *v5; // eax

  if ( !*this->gap_309 )
  {
    v5 = this->MyArena;
    if ( v5 )
    {
      if ( a4 == 21 && (*(buf + 19) & 0x1F) != 0 )
      {
        ++this->field_11F;
        if ( this->S2CPacketLossPercentage < v5->ServersideArenaSettings.RoutingDoubleSendPercent )
        {
          SendPlayerReliablePacket(this, buf, len, 0);
          ++this->field_11F;
          ++dword_4C8F38;
          sub_41CB20(this->encryptionPointer);
        }
      }
      SendPlayerReliablePacket(this, buf, len, 0);
    }
  }
}

//----- (0040DF30) --------------------------------------------------------
void __thiscall SendPlayerReliablePacket(struct_PLAYER *playerr, const void *buf, unsigned int len, int a4)
{
  struct_ARENA *v5; // eax
  int v6; // eax

  if ( a4
    || !*playerr->gap_309
    && ((v5 = playerr->MyArena) == 0
     || playerr->encryptionPointer->field_A82 <= v5->ServersideArenaSettings.LatencyCutbackWatermark
     || *buf == 5) )
  {
    if ( !WriteData(playerr->encryptionPointer, buf, len, a4) && a4 )
    {
      WriteSubGameLog(
        "Reliable packet lost(%d) to: %s (pending=%d current=%d diff=%d)\n",
        *buf,
        playerr->Name,
        playerr->encryptionPointer->field_262,
        playerr->encryptionPointer->field_25E,
        playerr->encryptionPointer->field_25E - playerr->encryptionPointer->field_262);
      v6 = playerr->isSysop;
      playerr->DisconnectReason = 8;
      playerr->AlreadySentReliablePacket = 1;
      if ( v6 )
        LogReliablePackets(playerr->encryptionPointer, "reliable.txt");
    }
    ++SomeArrayOf256_1[*buf];
    SomeArrayOf256_2[*buf] += len;
  }
}

//----- (0040E000) --------------------------------------------------------
void __thiscall SendToSpectators(struct_PLAYER *player, char *buf, int len, int a4, int a5, int a6)
{
  if ( (!a5 || !player->AllowAudioByte2) && (!a6 || player->Ship == 8) )
    SendPlayerReliablePacket(player, buf, len, a4);
}

//----- (0040E040) --------------------------------------------------------
void __thiscall SendEverybodyButYourself(struct_PLAYER *myPlayer, const void *buf, unsigned int len, int a4)
{
  struct_ARENA *v5; // eax
  int v6; // ebx
  int v7; // edi
  struct_PLAYER *eachPlayer; // eax

  v5 = myPlayer->MyArena;
  if ( v5 )
  {
    v6 = 0;
    if ( v5->ArenaPlayerCount > 0 )
    {
      v7 = 16072;
      do
      {
        eachPlayer = v5->PlayerPointers[v7];
        if ( eachPlayer != myPlayer && !eachPlayer->AlreadySentReliablePacket )
          SendPlayerReliablePacket(eachPlayer, buf, len, a4);
        v5 = myPlayer->MyArena;
        ++v6;
        ++v7;
      }
      while ( v6 < v5->ArenaPlayerCount );
    }
  }
}

//----- (0040E0A0) --------------------------------------------------------
void __thiscall SendReliablePacketToMyFrequency(struct_PLAYER *player, const void *buf, unsigned int len, int IsReliableSend)
{
  struct_ARENA *v5; // eax
  int v6; // ebx
  int v7; // edi
  struct_PLAYER *v8; // eax

  v5 = player->MyArena;
  if ( v5 )
  {
    v6 = 0;
    if ( v5->ArenaPlayerCount > 0 )
    {
      v7 = 16072;
      do
      {
        v8 = v5->PlayerPointers[v7];
        if ( v8 != player && v8->Frequency == player->Frequency )
          SendPlayerReliablePacket(v8, buf, len, IsReliableSend);
        v5 = player->MyArena;
        ++v6;
        ++v7;
      }
      while ( v6 < v5->ArenaPlayerCount );
    }
  }
}

//----- (0040E110) --------------------------------------------------------
void __thiscall SomethingWithAttachedPlayer(struct_PLAYER *playerr, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  struct_ARENA *v7; // eax
  int v8; // ebp
  struct_PLAYER *v9; // ecx
  struct_PLAYER *v10; // esi
  int v11; // edx
  int v12; // edx
  signed int v13; // edi
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // [esp+4h] [ebp-4h]

  v7 = playerr->MyArena;
  if ( v7 )
  {
    v16 = 0;
    if ( v7->ArenaPlayerCount > 0 )
    {
      v8 = 16072;
      do
      {
        v9 = v7->PlayerPointers[v8];
        v10 = v9;
        if ( v9 != playerr )
        {
          v11 = v9->ArenaPlayerIndex;
          if ( v11 >= 0 )
            v10 = PlayerList[v11];
          if ( v10 )
          {
            v12 = v10->AttachedToPlayerId;
            if ( v12 >= 0 )
              v10 = PlayerList[v12];
            if ( v10 )
            {
              if ( v9->isSysop
                || (v13 = v7->ServersideArenaSettings.MessageDistance,
                    v14 = v10->YPixels - playerr->YPixels,
                    ((HIDWORD(v14) ^ v14) - HIDWORD(v14)) <= v13)
                && (v15 = v10->XPixels - playerr->XPixels, ((HIDWORD(v15) ^ v15) - HIDWORD(v15)) <= v13) )
              {
                if ( (!a5 || !v9->AllowAudioByte2) && (!a6 || v9->Ship == 8) )
                  SendPlayerReliablePacket(v9, buf, len, a4);
              }
            }
          }
        }
        v7 = playerr->MyArena;
        ++v8;
        ++v16;
      }
      while ( v16 < v7->ArenaPlayerCount );
    }
  }
}

//----- (0040E220) --------------------------------------------------------
struct_ARENA *__thiscall sub_40E220(struct_PLAYER *playerr, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  struct_ARENA *arena; // eax
  int v8; // ebx
  int v9; // edi
  struct_PLAYER *v10; // ecx

  arena = playerr->MyArena;
  if ( arena )
  {
    v8 = 0;
    if ( arena->ArenaPlayerCount > 0 )
    {
      v9 = 16072;
      do
      {
        v10 = arena->PlayerPointers[v9];
        if ( v10 != playerr
          && v10->Frequency == playerr->Frequency
          && (!a5 || !v10->AllowAudioByte2)
          && (!a6 || v10->Ship == 8) )
        {
          SendPlayerReliablePacket(v10, buf, len, a4);
        }
        arena = playerr->MyArena;
        ++v8;
        ++v9;
      }
      while ( v8 < arena->ArenaPlayerCount );
    }
  }
  return arena;
}

//----- (0040E2B0) --------------------------------------------------------
int __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, struct_ARENA *a6)
{
  int result; // eax
  struct_PLAYER *player; // ecx

  result = ArenaPlayerIndex;
  player = PlayerList[ArenaPlayerIndex];
  if ( player )
  {
    if ( !a5 || (result = player->AllowAudioByte2) == 0 )
    {
      result = a6;
      if ( !a6 || player->Ship == 8 )
        SendPlayerReliablePacket(player, buf, len, a4);
    }
  }
  return result;
}

//----- (0040E300) --------------------------------------------------------
struct_ARENA *__thiscall sub_40E300(void *this, struct_ARENA *PlayerIndex, const void *buf, unsigned int len, int a4, int a6, int a7)
{
  struct_ARENA *result; // eax
  struct_PLAYER *v8; // ebx
  int v9; // edi
  int v10; // esi
  struct_PLAYER *v11; // ecx

  result = PlayerIndex;
  v8 = PlayerList[PlayerIndex];
  if ( v8 )
  {
    result = v8->MyArena;
    if ( result )
    {
      v9 = 0;
      if ( result->ArenaPlayerCount > 0 )
      {
        v10 = 16072;
        do
        {
          v11 = result->PlayerPointers[v10];
          if ( v11 != this
            && v11->Frequency == v8->Frequency
            && (!a6 || !v11->AllowAudioByte2)
            && (!a7 || v11->Ship == 8) )
          {
            SendPlayerReliablePacket(v11, buf, len, a4);
          }
          result = v8->MyArena;
          ++v9;
          ++v10;
        }
        while ( v9 < result->ArenaPlayerCount );
      }
    }
  }
  return result;
}

//----- (0040E3A0) --------------------------------------------------------
// Player.SendMessage()
void __thiscall SendMessage(struct_PLAYER *player, const char *messageBuffer, char SoundByte)
{
  unsigned int v4; // kr08_4
  char buf[512]; // [esp+10h] [ebp-200h] BYREF

  if ( player->MyArena )
  {
    buf[2] = SoundByte;                         // Sound Byte
    buf[0] = 7;                                 // 0x07 - Chat
    buf[1] = 0;                                 // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
    *&buf[3] = -1;                              // Originator ID
    strcpy(&buf[5], messageBuffer);
    v4 = strlen(messageBuffer) + 1;
    if ( GetRelAckDiff(player->encryptionPointer, 0) < 128 )
      SendPlayerReliablePacket(player, buf, v4 - 1 + 6, 1);
  }
}
/* Orphan comments:
Chat Message
*/

//----- (0040E440) --------------------------------------------------------
void __thiscall SendChannelMessage(struct_PLAYER *player, const char *a2)
{
  char buf[512]; // [esp+4h] [ebp-200h] BYREF

  if ( player->MyArena )
  {
    buf[0] = 7;                                 // 0x07 - Chat
    buf[1] = 9;                                 // Chat Type - 0x09 - Channel message
    buf[2] = 0;                                 // Sound Byte
    *&buf[3] = -1;                              // Originator ID
    strcpy(&buf[5], a2);
    SendPlayerReliablePacket(player, buf, strlen(a2) + 6, 1);
  }
}
/* Orphan comments:
Chat Message
*/

//----- (0040E4C0) --------------------------------------------------------
void __thiscall SendArenaMessagePlayer(struct_PLAYER *playerr, const char *ChatMessage, char SoundByte)
{
  __int16 playerId; // cx
  char buf[512]; // [esp+10h] [ebp-5h] BYREF

  playerId = playerr->PlayerId;
  buf[2] = SoundByte;                           // Sound Byte
  *&buf[3] = playerId;                          // Originator ID
  buf[0] = 7;                                   // 0x07 - Chat
  buf[1] = 0;                                   // Chat Type - 0x00 - Message in green text [*arena, *zone, ...]
  strcpy(&buf[5], ChatMessage);
  SendPlayerReliablePacket(playerr, buf, strlen(ChatMessage) + 6, 0);
  sub_41CB20(playerr->encryptionPointer);
}
/* Orphan comments:
Chat Message
*/

//----- (0040E550) --------------------------------------------------------
// Player.SendFile()
void __thiscall SendFile(struct_PLAYER *this, char *filename)
{
  struct_PLAYER *v2; // esi
  FILE *file; // eax
  FILE *filee; // edi
  int fileHandle; // eax
  size_t fileSizee; // ebp
  char *dataPacket; // esi
  char buf[20]; // [esp+10h] [ebp-14h] BYREF

  v2 = this;
  file = fopen(
           filename,
           "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
           "\x00\x00\x00Player spectating game: %s\n"
           "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1 m"
           "inute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00\x00"
           "NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00\x00\x00"
           "King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00Player kic"
           "ked off for not returning security packet: %s\n"
           "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00Par"
           "ameters resent for arena(%s)\n"
           "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parameter"
           ".\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00S"
           "pider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points to "
           "give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Javelin"
           "s:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spiders:%d "
           " Leviathans:%d\x00\x00rt\x00\x00\n"
           "\x00\x00\x00%s=%s\n"
           "\x00\x00[%s]\n"
           "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
           "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resize"
           ")\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
           "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked off"
           ", arena full to demo users: %s\n"
           "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
           "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
           "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
           "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
           "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
           "\x00%s>  MODERATOR LOGGED IN\n"
           "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
           "\x00%s> SYSOP LOGGED IN\n"
           "\x00\x00\x00\x00Connection request from: %s\n"
           "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00Fil"
           "e has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00F"
           "ile arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00\x00"
           "\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempting to enter game");
  filee = file;
  if ( file )
  {
    fileHandle = _fileno(file);
    fileSizee = _filelength(fileHandle);
    dataPacket = emalloc(fileSizee + 17);
    fread(dataPacket + 17, 1u, fileSizee, filee);
    fclose(filee);
    *dataPacket = 16;
    strncpy(dataPacket + 1, filename, 0x10u);
    dataPacket[16] = 0;
    GetNewsRequest(this->encryptionPointer, dataPacket, fileSizee + 17, 0);
  }
  else
  {
    buf[0] = 0x10;                              // 0x10 - File Transfer
    strncpy(&buf[1], filename, 0x10u);
    buf[16] = 0;                                // File Data... is 0 (No idea what this means)
    SendPlayerReliablePacket(v2, buf, 17u, 1);
  }
}
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (0040E620) --------------------------------------------------------
struct_ARENA *__thiscall ArenaHandler(int this, int ArenaIndex, const char *ArenaName)
{
  signed int v3; // ebx
  _DWORD *v4; // edx
  int ArenaArrayLengthh; // ecx
  struct_ARENA *result; // eax
  const char *v7; // ebp
  int Arenass; // ebx
  struct_ARENA *v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // esi
  int v13; // eax
  struct_ARENA *v14; // esi
  struct_ARENA **v15; // edx
  int v16; // edi
  int ArenaIndexx; // esi
  struct_ARENA *v18; // eax
  int arenaCounter; // edi
  struct_ARENA *v20; // esi
  struct_ARENA *newArena; // eax
  struct_ARENA *v22; // eax
  int v23; // esi
  int i; // eax
  struct_ARENA *v25; // edx
  struct_ARENA **j; // esi
  struct_ARENA *v27; // eax
  int ArenaIndexxx; // ecx
  int ArenaIndexCounter; // [esp+24h] [ebp+4h]

  v3 = 0;
  v4 = this;
  if ( ArenaIndex < 0 )
  {
    if ( ArenaIndex == -1 && (v7 = (this + 399), *(this + 399)) )
    {
      ArenaArrayLengthh = ArenaArrayLength;
      ArenaIndexCounter = 0;
      if ( ArenaArrayLength > 0 )
      {
        Arenass = Arenas;
        while ( 1 )
        {
          v9 = *Arenass;
          if ( !*(*Arenass + 64256) )
          {
            v10 = v9->ArenaPlayerCount;
            if ( v10 < ArenaMaxPlayers )
            {
              v11 = 0;
              if ( v10 > 0 )
                break;
            }
          }
LABEL_18:
          Arenass += 4;
          if ( ++ArenaIndexCounter >= ArenaArrayLengthh )
            goto LABEL_54;
        }
        v12 = 16072;
        while ( _strcmpi(v9->PlayerPointers[v12]->Squad, v7) )
        {
          v9 = *Arenass;
          ++v11;
          ++v12;
          if ( v11 >= *(*Arenass + 65292) )
          {
            ArenaArrayLengthh = ArenaArrayLength;
            goto LABEL_18;
          }
        }
        return Arenas[ArenaIndexCounter];
      }
    }
    else if ( ArenaIndex == -2 )
    {
      ArenaArrayLengthh = ArenaArrayLength;
      v13 = 0;
      if ( ArenaArrayLength > 0 )
      {
        v14 = v4[8];
        v15 = Arenas;
        while ( *v15 != v14 )
        {
          ++v13;
          ++v15;
          if ( v13 >= ArenaArrayLength )
            goto LABEL_28;
        }
        v3 = v13;
      }
LABEL_28:
      v16 = 0;
      if ( ArenaArrayLength > 0 )
      {
        ArenaIndexx = v3 + 1;
        do
        {
          v18 = Arenas[ArenaIndexx % ArenaArrayLength];
          if ( !v18->ArenaName[0] && (*(this + 639) || v18->ArenaPlayerCount < ArenaMaxPlayers) )
            return Arenas[ArenaIndexx % ArenaArrayLength];
          ++v16;
          ++ArenaIndexx;
        }
        while ( v16 < ArenaArrayLength );
      }
    }
    else if ( ArenaIndex == -3 )
    {
      ArenaArrayLengthh = ArenaArrayLength;
      arenaCounter = 0;
      if ( ArenaArrayLength > 0 )
      {
        v20 = Arenas;
        while ( 1 )
        {
          v3 += GetArenaMemoryTotal(v20->PlayerPointers[0]);
          if ( !_strcmpi(&v20->PlayerPointers[0][74].UserId + 3, ArenaName) )
            break;
          ArenaArrayLengthh = ArenaArrayLength;
          ++arenaCounter;
          v20 = (v20 + 4);
          if ( arenaCounter >= ArenaArrayLength )
            goto LABEL_46;
        }
        if ( *(this + 639) )
          goto LABEL_68;
        if ( Arenas[arenaCounter]->ArenaPlayerCount < ArenaMaxPlayers )
          return Arenas[arenaCounter];
        ArenaArrayLengthh = ArenaArrayLength;
LABEL_46:
        v4 = this;
      }
      if ( arenaCounter == ArenaArrayLengthh && (*(v4 + 635) || ArenaArrayLengthh < MaxArenas && v3 < MaxArenasMemory) )
      {
        newArena = operator new(0x1D40Eu);
        if ( newArena )
        {
          v22 = ServerEntryPoint(newArena, ArenaName);
LABEL_72:
          ArenaIndexxx = ArenaArrayLength;
          Arenas[ArenaArrayLength] = v22;
          result = Arenas[ArenaIndexxx];
          ArenaArrayLength = ArenaIndexxx + 1;
          return result;
        }
LABEL_71:
        v22 = 0;
        goto LABEL_72;
      }
    }
    else
    {
      ArenaArrayLengthh = ArenaArrayLength;
    }
  }
  else
  {
    ArenaArrayLengthh = ArenaArrayLength;
    if ( ArenaIndex < ArenaArrayLength
      && (*(v4 + 639) || !Arenas[ArenaIndex]->ArenaName[0] && Arenas[ArenaIndex]->ArenaPlayerCount < ArenaMaxPlayers) )
    {
      return Arenas[ArenaIndex];
    }
  }
LABEL_54:
  v23 = -1;
  for ( i = 0; i < ArenaArrayLengthh; ++i )
  {
    v25 = Arenas[i];
    if ( !v25->ArenaName[0] && (v23 == -1 || v25->ArenaPlayerCount < Arenas[v23]->ArenaPlayerCount) )
      v23 = i;
  }
  if ( v23 == -1 || (result = Arenas[v23], result->ArenaPlayerCount >= ArenaMaxPlayers) )
  {
    v27 = operator new(0x1D40Eu);
    if ( v27 )
    {
      v22 = ServerEntryPoint(v27, &DirectoryNamePassword);
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  arenaCounter = 0;
  if ( ArenaArrayLengthh > 0 )
  {
    for ( j = Arenas; (*j)->ArenaName[0] || (*j)->ArenaPlayerCount >= ArenaDesiredPlayers; ++j )
    {
      if ( ++arenaCounter >= ArenaArrayLengthh )
        return result;
    }
LABEL_68:
    result = Arenas[arenaCounter];
  }
  return result;
}
// 40E677: conditional instruction was optimized away because of 'edx.4==0'
// 431FF4: using guessed type int ArenaArrayLength;

//----- (0040E990) --------------------------------------------------------
void __thiscall SendWeaponPacket(struct_PLAYER *playerr)
{
  int v2; // eax
  __int16 v3; // cx
  __int16 v4; // dx
  Encryption_Struct *v5; // edi
  __int16 v6; // ax
  DWORD GetTickCountt; // eax
  int v8; // ebp
  int v9; // edi
  DWORD timestamp; // edx
  Encryption_Struct *v11; // ebp
  int v12; // edx
  int v13; // edi
  Encryption_Struct *v14; // ebp
  int Ping; // edx
  __int16 v16; // cx
  __int16 v17; // ax
  char v18; // al
  char *v19; // ecx
  int v20; // edx
  struct_ARENA *v21; // eax
  int v22; // ecx
  __int16 v23; // dx
  __int16 v24; // ax
  Encryption_Struct *v25; // edi
  __int16 v26; // cx
  DWORD v27; // eax
  int v28; // ebp
  int v29; // edi
  DWORD v30; // edx
  Encryption_Struct *v31; // ebp
  int v32; // edx
  int v33; // edx
  int v34; // edi
  Encryption_Struct *v35; // ebp
  char v36; // al
  char v37; // cl
  __int16 v38; // ax
  __int16 v39; // cx
  Encryption_Struct *v40; // edi
  __int16 v41; // dx
  DWORD v42; // eax
  int v43; // ebp
  int Ping2; // edi
  DWORD v45; // edx
  Encryption_Struct *v46; // ebp
  int v47; // edx
  char v48; // al
  int v49; // edi
  Encryption_Struct *v50; // ebp
  int v51; // edx
  __int16 v52; // dx
  char v53; // al
  __int16 v54; // cx
  __int16 v55; // ax
  int v56; // edx
  __int16 v57; // cx
  char v58; // al
  int *v59; // ecx
  int v60; // eax
  char *v61; // ecx
  __int16 v62; // dx
  int v63; // edx
  int v64; // edi
  __int16 v65; // ax
  bool v66; // cc
  bool v67; // cc
  struct_ARENA *v68; // eax
  int v69; // ebp
  struct_PLAYER *v70; // esi
  int v71; // edx
  int v72; // ecx
  unsigned int v73; // edi
  struct_ARENA *v74; // eax
  int v75; // esi
  int v76; // ecx
  int v77; // ebp
  int v78; // edx
  int v79; // eax
  int v80; // eax
  int v81; // edi
  int v82; // eax
  int v83; // ecx
  struct_PLAYER *v84; // eax
  int v85; // ebp
  int v86; // eax
  int arenaPlayerIndex; // eax
  struct_PLAYER *eachPlayer; // ecx
  int v89; // eax
  __int64 v90; // rax
  unsigned int v91; // esi
  int v92; // eax
  int v93; // ecx
  UINT v94; // eax
  bool v95; // zf
  int len; // [esp+10h] [ebp-DCh]
  int v97; // [esp+14h] [ebp-D8h]
  int v98; // [esp+14h] [ebp-D8h]
  int v99; // [esp+18h] [ebp-D4h]
  int v100; // [esp+18h] [ebp-D4h]
  int v101; // [esp+1Ch] [ebp-D0h]
  int v102; // [esp+1Ch] [ebp-D0h]
  int v103; // [esp+20h] [ebp-CCh]
  int v104; // [esp+20h] [ebp-CCh]
  char buf[15]; // [esp+24h] [ebp-C8h] BYREF
  __int16 v106; // [esp+33h] [ebp-B9h]
  __int16 v107; // [esp+35h] [ebp-B7h]
  int v108; // [esp+37h] [ebp-B5h]
  unsigned int v109; // [esp+3Ch] [ebp-B0h]
  int v110; // [esp+40h] [ebp-ACh]
  int v111; // [esp+44h] [ebp-A8h]
  int v112; // [esp+48h] [ebp-A4h]
  int v113; // [esp+4Ch] [ebp-A0h]
  struct_PLAYER *v114; // [esp+50h] [ebp-9Ch]
  int v115; // [esp+54h] [ebp-98h]
  int v116; // [esp+58h] [ebp-94h]
  struct_PLAYER *v117; // [esp+5Ch] [ebp-90h]
  int v118; // [esp+60h] [ebp-8Ch]
  int v119; // [esp+64h] [ebp-88h]
  int v120; // [esp+68h] [ebp-84h]
  int v121; // [esp+6Ch] [ebp-80h] BYREF
  __int16 v122; // [esp+70h] [ebp-7Ch]
  __int16 v123; // [esp+72h] [ebp-7Ah]
  __int16 v124; // [esp+74h] [ebp-78h]
  __int16 v125; // [esp+76h] [ebp-76h]
  __int16 v126; // [esp+78h] [ebp-74h]
  char v127[3]; // [esp+7Ah] [ebp-72h]
  __int16 v128; // [esp+7Dh] [ebp-6Fh]
  int v129; // [esp+7Fh] [ebp-6Dh]

  v2 = *playerr->gap_28B;
  playerr->field_FD = 0;
  if ( v2 )
  {
    v3 = playerr->YPixels;
    v4 = playerr->XVelocity;
    v5 = playerr->encryptionPointer;
    *&buf[4] = playerr->XPixels;                // X Pixels (0-16384)
    v6 = playerr->YVelocity;
    v106 = v3;
    LOBYTE(v3) = playerr->ShipDirection;
    buf[0] = 5;                                 // 0x05 - Large Position Packet (Weapons Packet)
    *&buf[10] = v4;                             // X Velocity
    *&buf[6] = v6;                              // Y Velocity
    buf[1] = v3;                                // Direction (0-360)
    GetTickCountt = GetTickCount();
    v8 = v5->dwordE;
    v9 = playerr->Ping;
    timestamp = v8 + GetTickCountt / 0xA;
    v11 = playerr->encryptionPointer;
    *&buf[2] = timestamp;
    v12 = ((v11->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v9;
    if ( v12 < 0 || v12 > 30000 )
      v12 = 0;
    if ( v12 <= 255 )
    {
      v13 = playerr->Ping;
      v14 = playerr->encryptionPointer;
      Ping = ((v14->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v13;
      if ( Ping < 0 || Ping > 30000 )
        LOBYTE(Ping) = 0;
      buf[14] = Ping;                           // Ping
    }
    else
    {
      buf[14] = -1;                             // Ping
    }
    v16 = playerr->field_F0;
    *&buf[8] = 1014;                            // Special PlayerId?
    v17 = v16 & 0x1F;
    buf[13] = 0;
    v107 = 0;
    if ( v17 == 3 || v17 == 4 || v17 == 1 || v17 == 2 )
      LOWORD(v108) = v16 ^ (v16 ^ v16 & 0x80 ^ (v16 & 0x1F ^ v108 & 0xFF80) & 0xFC7F) & 0x3FF;
    else
      LOWORD(v108) = 0;
    v18 = 0;
    v19 = buf;
    buf[12] = 0;                                // Checksum
    v20 = 21;
    do
    {
      v18 ^= *v19++;
      --v20;
    }
    while ( v20 );
    buf[12] = v18;                              // Computed Checksum
    if ( !*playerr->gap_309 )
    {
      v21 = playerr->MyArena;
      if ( v21 )
      {
        if ( (v108 & 0x1F) != 0 )
        {
          v22 = playerr->S2CPacketLossPercentage;
          ++playerr->field_11F;
          if ( v22 < v21->ServersideArenaSettings.RoutingDoubleSendPercent )
          {
            SendPlayerReliablePacket(playerr, buf, 0x15u, 0);
            ++playerr->field_11F;
            ++dword_4C8F38;
            sub_41CB20(playerr->encryptionPointer);
          }
        }
        SendPlayerReliablePacket(playerr, buf, 0x15u, 0);
      }
    }
  }
  if ( playerr->Ship < 8 && playerr->MyArena )
  {
    if ( *&playerr->PlayerId > 255 || *playerr->gap_EC > 255 || (playerr->field_F0 & 0x1F) != 0 )
    {
      v38 = playerr->YPixels;
      v39 = playerr->XVelocity;
      v40 = playerr->encryptionPointer;
      v122 = playerr->XPixels;
      v41 = playerr->YVelocity;
      *&v127[1] = v38;
      LOBYTE(v38) = playerr->ShipDirection;
      len = 21;
      LOBYTE(v121) = 5;                         // 0x05 - Large Position Packet (Weapons Packet)
      v125 = v39;
      v123 = v41;
      BYTE1(v121) = v38;
      v42 = GetTickCount();
      v43 = v40->dwordE;
      Ping2 = playerr->Ping;
      v45 = v43 + v42 / 0xA;
      v46 = playerr->encryptionPointer;
      HIWORD(v121) = v45;
      v47 = ((v46->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - Ping2;
      if ( v47 < 0 || v47 > 30000 )
        v47 = 0;
      if ( v47 <= 255 )
      {
        v49 = playerr->Ping;
        v50 = playerr->encryptionPointer;
        v51 = ((v50->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v49;
        if ( v51 < 0 || v51 > 30000 )
          LOBYTE(v51) = 0;
        v48 = v51;
      }
      else
      {
        v48 = -1;
      }
      v52 = playerr->PlayerId;
      v127[0] = v48;
      v53 = playerr->ShipTogglables;
      v54 = *playerr->gap_EC;
      v124 = v52;
      HIBYTE(v126) = v53;
      v55 = playerr->field_F0;
      v128 = v54;
      LOWORD(v129) = (v55 ^ v129) & 0x1F ^ v129;// BitFlags
      LOWORD(v129) = (v55 ^ v129) & 0x60 ^ v129;
      LOWORD(v129) = (v55 ^ v129) & 0x80 ^ v129;
      LOWORD(v129) = (v55 ^ v129) & 0x300 ^ v129;
      LOWORD(v129) = (v55 ^ v129) & 0x7C00 ^ v129;
      v56 = 21;
      v57 = v55 ^ (v55 ^ v129) & 0x7FFF;
      v58 = 0;
      LOWORD(v129) = v57;
      LOBYTE(v126) = 0;
      v59 = &v121;
      do
      {
        v58 ^= *v59;
        v59 = (v59 + 1);
        --v56;
      }
      while ( v56 );
      LOBYTE(v126) = v58;
    }
    else
    {
      v23 = playerr->YPixels;
      v24 = playerr->XVelocity;
      v25 = playerr->encryptionPointer;
      v122 = playerr->XPixels;
      v26 = playerr->YVelocity;
      v126 = v23;
      LOBYTE(v23) = playerr->ShipDirection;
      len = 16;
      LOBYTE(v121) = 0x28;                      // 0x28 - Small Position Packet
      *v127 = v24;
      v125 = v26;
      BYTE1(v121) = v23;
      v27 = GetTickCount();
      v28 = v25->dwordE;
      v29 = playerr->Ping;
      v30 = v28 + v27 / 0xA;
      v31 = playerr->encryptionPointer;
      HIWORD(v121) = v30;
      v32 = ((v31->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v29;
      if ( v32 < 0 || v32 > 30000 )
        v32 = 0;
      if ( v32 <= 255 )
      {
        v34 = playerr->Ping;
        v35 = playerr->encryptionPointer;
        v33 = ((v35->dwordE + GetTickCount() / 0xA) & 0x7FFFFFFF) - v34;
        if ( v33 < 0 || v33 > 30000 )
          LOBYTE(v33) = 0;
      }
      else
      {
        LOBYTE(v33) = -1;
      }
      v36 = playerr->ShipTogglables;
      v37 = playerr->gap_EC[0];
      LOBYTE(v123) = v33;
      LOBYTE(v124) = playerr->PlayerId;
      HIBYTE(v124) = v36;
      HIBYTE(v123) = v37;
    }
    if ( playerr->field_10B )
    {
      v60 = len;
      v61 = &v121 + len;
      *v61 = playerr->EnergyOptional;
      v62 = playerr->SharpnelMinesBombsBulletsMultifireInformationOptional;
      *(v61 + 1) = playerr->TimerOptional;
      *(v61 + 4) = v62;
      v109 = len + 10;
    }
    else
    {
      *(&v121 + len) = *&playerr->gap_EC[2];
      v109 = len + 2;
      v60 = len;
    }
    v63 = 0;
    v64 = 0;
    v103 = 0;
    v97 = 0;
    v99 = 0;
    if ( v60 != 21 )
      goto LABEL_79;
    v65 = v129 & 0x1F;
    if ( v65 == 6 || v65 == 3 && (v129 & 0x8000) != 0 || v65 == 4 && (v129 & 0x8000) != 0 || v65 == 5 || v65 == 8 )
    {
      playerr->field_10F = 1;
    }
    else if ( v65 == 4 || v65 == 3 )
    {
      if ( SBYTE1(v121) < 5 || SBYTE1(v121) > 35 )
        v97 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      if ( SBYTE1(v121) > 5 )
      {
        v66 = SBYTE1(v121) <= 15;
        if ( SBYTE1(v121) >= 15 )
          goto LABEL_71;
        v64 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      }
      v66 = SBYTE1(v121) <= 15;
LABEL_71:
      if ( !v66 )
      {
        v67 = SBYTE1(v121) <= 25;
        if ( SBYTE1(v121) >= 25 )
        {
LABEL_75:
          if ( !v67 && SBYTE1(v121) < 35 )
          {
            v63 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
            v103 = v63;
          }
          goto LABEL_79;
        }
        v99 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBombAdjust;
      }
      v67 = SBYTE1(v121) <= 25;
      goto LABEL_75;
    }
LABEL_79:
    if ( playerr->field_10F )
    {
      v68 = playerr->MyArena;
      v101 = 0;
      if ( v68->ArenaPlayerCount > 0 )
      {
        v69 = 16072;
        do
        {
          v70 = v68->PlayerPointers[v69];
          if ( v70 != playerr )
          {
            v71 = v70->isSysop;
            if ( v71 || !playerr->field_3C || (v72 = playerr->field_4C, v72 < 0) || v72 == *&v70->PlayerId )
            {
              v73 = len;
              if ( v70->isEnergyShowing
                || v70->ArenaPlayerIndex == *&playerr->PlayerId && (v68->ArenaSettings.ExtraPositionData || v71) )
              {
                v73 = v109;
              }
              if ( !*v70->gap_309 )
              {
                v74 = v70->MyArena;
                if ( v74 )
                {
                  if ( len == 21 && (v129 & 0x1F) != 0 )
                  {
                    ++v70->field_11F;
                    if ( v70->S2CPacketLossPercentage < v74->ServersideArenaSettings.RoutingDoubleSendPercent )
                    {
                      SendPlayerReliablePacket(v70, &v121, v73, 0);
                      ++v70->field_11F;
                      ++dword_4C8F38;
                      sub_41CB20(v70->encryptionPointer);
                    }
                  }
                  SendPlayerReliablePacket(v70, &v121, v73, 0);
                }
              }
            }
          }
          v68 = playerr->MyArena;
          ++v69;
          ++v101;
        }
        while ( v101 < v68->ArenaPlayerCount );
      }
    }
    else
    {
      v75 = (playerr->LooksLikeX1BigOfSomething - v63) / 2048;
      if ( v75 < 0 )
        v75 = 0;
      v76 = (v64 + playerr->LooksLikeXSmallOfSomething) / 2048;
      if ( v76 >= 8 )
        v76 = 7;
      v77 = (playerr->LooksLikeYBigOfSomething - v97) / 2048;
      v102 = v77;
      if ( v77 < 0 )
      {
        v102 = 0;
        v77 = 0;
      }
      v112 = (v99 + playerr->LooksLikeYSmallOfSomething) / 2048;
      v78 = v112;
      if ( v112 >= 8 )
      {
        v78 = 7;
        v112 = 7;
      }
      v79 = playerr->XPixels;
      v119 = v79 + v64;
      v116 = v79 - v103;
      v80 = playerr->YPixels;
      v118 = v80 + v99;
      v120 = v80 - v97;
      v104 = 128;
      v100 = 128;
      if ( len == 21 && (v129 & 0x1F) != 0 )
      {
        v104 = playerr->MyArena->ServersideArenaSettings.RoutingCloseEnoughBulletAdjust + 128;
        v100 = v104;
      }
      if ( v75 <= v76 )
      {
        v81 = 1004 * (v77 + 8 * v75);
        v111 = v81;
        v113 = v76 - v75 + 1;
        do
        {
          if ( v77 <= v78 )
          {
            v82 = v81;
            v115 = v81;
            v83 = v78 - v77 + 1;
            v110 = v83;
            do
            {
              v98 = 0;
              v84 = (playerr->MyArena + v82);
              v117 = v84;
              if ( *&v84[1].someStringBuffer[35] > 0 )
              {
                v114 = v84;
                do
                {
                  v85 = v84->unknownIthoughtItWasPlayerPointerDupe;
                  if ( v84->unknownIthoughtItWasPlayerPointerDupe != playerr )
                  {
                    if ( *(v85 + 631) || !playerr->field_3C || (v86 = playerr->field_4C, v86 < 0) || v86 == *(v85 + 20) )
                    {
                      arenaPlayerIndex = *(v85 + 371);
                      eachPlayer = v85;
                      if ( arenaPlayerIndex < 0 || (eachPlayer = PlayerList[arenaPlayerIndex]) != 0 )
                      {
                        v89 = eachPlayer->AttachedToPlayerId;
                        if ( v89 < 0 || (eachPlayer = PlayerList[v89]) != 0 )
                        {
                          if ( abs32(eachPlayer->YPixels - playerr->YPixels) > v100 + *(v85 + 623) / 2
                            || (v90 = eachPlayer->XPixels - playerr->XPixels,
                                ((HIDWORD(v90) ^ v90) - HIDWORD(v90)) > v104 + *(v85 + 619) / 2) )
                          {
                            if ( v119 >= eachPlayer->LooksLikeX1BigOfSomething
                              && v116 <= eachPlayer->LooksLikeXSmallOfSomething
                              && v118 >= eachPlayer->LooksLikeYBigOfSomething
                              && v120 <= eachPlayer->LooksLikeYSmallOfSomething
                              && (len == 21 && (v129 & 0x1Fu) > 2
                               || v98 % playerr->MyArena->ServersideArenaSettings.RoutingRadarFavor == *playerr->gap_11B) )
                            {
                              if ( IncreasesRadarValueSomeHow >= 4000 )
                                IncreaseRadarValueShowHomeOverFourThousand();
                              v94 = 26 * IncreasesRadarValueSomeHow;
                              qmemcpy(&BillingIP.gap_36[26 * IncreasesRadarValueSomeHow + 78], &v121, len);
                              BillingIP.gap_36[v94 + 99] = len;
                              *&BillingIP.gap_36[v94 + 74] = *(v85 + 20);
                              ++IncreasesRadarValueSomeHow;
                            }
                          }
                          else
                          {
                            v91 = len;
                            if ( *(v85 + 68)
                              || *(v85 + 371) == *&playerr->PlayerId
                              && (playerr->MyArena->ArenaSettings.ExtraPositionData || *(v85 + 631)) )
                            {
                              v91 = v109;
                            }
                            if ( !*(v85 + 777) )
                            {
                              v92 = *(v85 + 28);
                              if ( v92 )
                              {
                                if ( len == 21 && (v129 & 0x1F) != 0 )
                                {
                                  v93 = *(v85 + 801);
                                  ++*(v85 + 287);
                                  if ( v93 < *(v92 + 109902) )
                                  {
                                    SendPlayerReliablePacket(v85, &v121, v91, 0);
                                    ++*(v85 + 287);
                                    ++dword_4C8F38;
                                    sub_41CB20(*(v85 + 40));
                                  }
                                }
                                SendPlayerReliablePacket(v85, &v121, v91, 0);
                              }
                            }
                            ++dword_4D55D0;
                          }
                        }
                      }
                    }
                  }
                  v84 = &v114->dword4;
                  v66 = ++v98 < *&v117[1].someStringBuffer[35];
                  v114 = (v114 + 4);
                }
                while ( v66 );
                v77 = v102;
                v78 = v112;
                v81 = v111;
                v83 = v110;
              }
              v82 = v115 + 1004;
              --v83;
              v115 += 1004;
              v110 = v83;
            }
            while ( v83 );
          }
          v81 += 8032;
          v95 = v113 == 1;
          v111 = v81;
          --v113;
        }
        while ( !v95 );
      }
      *playerr->gap_11B = (*playerr->gap_11B + 1) % playerr->MyArena->ServersideArenaSettings.RoutingRadarFavor;
    }
  }
  playerr->field_10F = 0;
  playerr->field_10B = 0;
}
/* Orphan comments:
 Large Position Packet (Weapons Packet) Without Optionals
*/

//----- (0040F4A0) --------------------------------------------------------
void __thiscall SendResetScoresPacket(struct_PLAYER *player)
{
  __int16 playerId; // dx
  struct_ARENA *v2; // ecx
  char buf[4]; // [esp+0h] [ebp-4h] BYREF

  *buf = player;
  playerId = player->PlayerId;
  player->CurrentLosses = 0;
  player->CurrentWins = 0;
  player->KillPoints = 0;
  player->FlagPoints = 0;
  player->GoalCount = 0;
  player->field_30D = 1;
  v2 = player->MyArena;
  buf[0] = 0x1A;                                // 0x1A - Reset Score(s)
  *&buf[1] = playerId;
  if ( v2 )
    ArenaSendPacket(v2, buf, 3, 1);
}

//----- (0040F500) --------------------------------------------------------
void __thiscall SendPlayerScoreUpdate(struct_PLAYER *player)
{
  __int16 v1; // ax
  __int16 v2; // dx
  int v3; // eax
  char buf[15]; // [esp+0h] [ebp-10h] BYREF

  v1 = player->PlayerId;
  *&buf[3] = player->KillPoints;                // Kill Points
  v2 = player->CurrentWins;
  *&buf[1] = v1;                                // Player ID
  v3 = player->FlagPoints;
  *&buf[11] = v2;                               // Wins
  *&buf[7] = v3;                                // Flag Points
  LOWORD(v3) = player->CurrentLosses;
  buf[0] = 9;                                   // 0x09 - Player Score Update
  *&buf[13] = v3;                               // Losses
  SendPlayerReliablePacket(player, buf, 15u, 1);
}

//----- (0040F550) --------------------------------------------------------
bool __thiscall SendPlayerScoreUpdateAll(struct_PLAYER *playerr)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebp
  int v5; // ecx
  struct_ARENA *v6; // eax
  __int16 v7; // dx
  int v8; // ebp
  __int16 v9; // cx
  int v10; // ebp
  int v11; // ebp
  int v12; // edi
  int v13; // ebx
  struct_PLAYER *v14; // eax
  struct_ARENA *v15; // eax
  char buf[15]; // [esp+10h] [ebp-10h] BYREF

  v2 = playerr->KillPoints;
  v3 = *&playerr->field_245;
  v4 = *&playerr->field_249;
  v5 = playerr->FlagPoints;
  if ( v5 + v2 - v3 - v4 <= MiscPointUpdateDiff )
    return 0;
  if ( !dword_4C8F3C )
    return 0;
  v6 = playerr->MyArena;
  if ( !v6 )
    return 0;
  *&buf[3] = v2;                                // Kill Points
  v7 = playerr->CurrentLosses;
  v8 = *&playerr->CurrentWins;
  *&buf[7] = v5;                                // Flag Points
  playerr->dword23F = v8;
  v9 = playerr->CurrentWins;
  v10 = *&playerr->GoalCount;
  buf[0] = 9;                                   // 0x09 - Player Score Update
  *&playerr->dword243 = v10;
  *&buf[11] = v9;                               // Wins
  v11 = *(&playerr->KillPoints + 2);
  *&buf[13] = v7;                               // Losses
  *&playerr->dword247 = v11;
  LOWORD(playerr->word24B) = HIWORD(playerr->FlagPoints);
  *&buf[1] = playerr->PlayerId;                 // Player ID
  v12 = 0;
  if ( v6->ArenaPlayerCount > 0 )
  {
    v13 = 16072;
    do
    {
      v14 = v6->PlayerPointers[v13];
      if ( v14 != playerr && !v14->AlreadySentReliablePacket )
        SendPlayerReliablePacket(v14, buf, 0xFu, 0);
      v6 = playerr->MyArena;
      ++v12;
      ++v13;
    }
    while ( v12 < v6->ArenaPlayerCount );
  }
  SendPlayerReliablePacket(playerr, buf, 0xFu, 1);
  if ( BillingConnectionStructPointer )
  {
    v15 = playerr->MyArena;
    if ( !v15->ServersideArenaSettings.MiscTimedGame )
    {
      if ( v15->bRecordPointsToLog )
      {
        if ( (MiscDisableSharewareScores || MiscDisableShareware) && playerr->DemoPlayer )
          return 1;
        SendBillerUserScorePacket(BillingConnectionStructPointer, playerr->BillerPlayerId, &playerr->CurrentWins, 0xEu);
      }
    }
  }
  return 1;
}
// 4C8F3C: using guessed type int dword_4C8F3C;

//----- (0040F6B0) --------------------------------------------------------
void __thiscall SendAdvertisement(struct_PLAYER *playerr, int a2)
{
  __int64 v3; // rax
  DWORD v4; // kr00_4
  int v5; // eax
  int v6; // edx
  UINT v7; // edx
  UINT v8; // edx

  if ( a2 || (v3 = (GetTickCount() / 0xA - *playerr->gap_24), ((HIDWORD(v3) ^ v3) - HIDWORD(v3)) >= 3000) )
  {
    v4 = GetTickCount();
    v5 = playerr->DemoPlayer;
    *playerr->gap_24 = v4 / 0xA;
    if ( v5 )
    {
      if ( dword_4D8B04 > 0 || dword_4D8AFC > 0 )
      {
        v6 = rand() % (dword_4D8B04 + dword_4D8AFC);
        if ( v6 >= dword_4D8B04 )
        {
          v7 = v6 - dword_4D8B04;
          if ( a2 )
            SendPlayerReliablePacket(playerr, (&buf)[2 * v7], len[2 * v7], 1);
          else
            GetMapLvlRequest(playerr->encryptionPointer, (&buf)[2 * v7], len[2 * v7], 0);
          return;
        }
        if ( a2 )
        {
LABEL_19:
          SendPlayerReliablePacket(playerr, (&dword_437CB0)[2 * v6], dword_437CB4[2 * v6], 1);
          return;
        }
LABEL_20:
        GetMapLvlRequest(playerr->encryptionPointer, (&dword_437CB0)[2 * v6], dword_437CB4[2 * v6], 0);
        return;
      }
    }
    else if ( dword_4D8B04 > 0 || dword_4D8B00 > 0 )
    {
      v6 = rand() % (dword_4D8B04 + dword_4D8B00);
      if ( v6 < dword_4D8B04 )
      {
        if ( a2 )
          goto LABEL_19;
        goto LABEL_20;
      }
      v8 = v6 - dword_4D8B04;
      if ( a2 )
        SendPlayerReliablePacket(playerr, (&dword_4317B8)[2 * v8], dword_4317BC[2 * v8], 1);
      else
        GetMapLvlRequest(playerr->encryptionPointer, (&dword_4317B8)[2 * v8], dword_4317BC[2 * v8], 0);
    }
  }
}

//----- (0040F840) --------------------------------------------------------
void __cdecl LoadZoneCFGSettings(ARENA_SETTINGS *arenaSettings, SERVERSIDE_ARENA_SETTINGS *a2, const char *a3)
{
  struc_2 *v3; // eax
  struct struc_2 *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  const char *v33; // edi
  SHIP_SETTINGS *v34; // esi
  int v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // ecx
  int v39; // eax
  char v40; // al
  int v41; // edx
  char v42; // al
  int v43; // ecx
  char v44; // al
  int v45; // edx
  int v46; // eax
  char *v47; // esi
  int v48; // edi
  int v49; // [esp-4h] [ebp-44h]
  char *Str2[8]; // [esp+14h] [ebp-2Ch]
  int v51; // [esp+3Ch] [ebp-4h]
  char *Filename; // [esp+4Ch] [ebp+Ch]

  v3 = operator new(0x2B74Cu);
  v51 = 0;
  if ( v3 )
    v4 = ReadSettingsSomething(v3, a3);
  else
    v4 = 0;
  v51 = -1;
  if ( arenaSettings )
  {
    memset(arenaSettings, 0, sizeof(ARENA_SETTINGS));
    LOBYTE(arenaSettings->VersionAndManyBitFields) = 15;// version 15 = VIE
    arenaSettings->SomeUnknownStuff = 0;
    v5 = GetCFGSettingInteger(v4, "PrizeWeight", "QuickCharge", 80);
    if ( v5 > 255 )
      LOBYTE(v5) = -1;
    arenaSettings->PrizeWeightQuickCharge = v5;
    v6 = GetCFGSettingInteger(v4, "PrizeWeight", "Energy", 70);
    if ( v6 > 255 )
      LOBYTE(v6) = -1;
    arenaSettings->PrizeWeightEnergy = v6;
    v7 = GetCFGSettingInteger(v4, "PrizeWeight", "Rotation", 60);
    if ( v7 > 255 )
      LOBYTE(v7) = -1;
    arenaSettings->PrizeWeightRotation = v7;
    v8 = GetCFGSettingInteger(v4, "PrizeWeight", "Stealth", 30);
    if ( v8 > 255 )
      LOBYTE(v8) = -1;
    arenaSettings->PrizeWeightStealth = v8;
    v9 = GetCFGSettingInteger(v4, "PrizeWeight", "Cloak", 20);
    if ( v9 > 255 )
      LOBYTE(v9) = -1;
    arenaSettings->PrizeWeightCloak = v9;
    v10 = GetCFGSettingInteger(v4, "PrizeWeight", "AntiWarp", 20);
    if ( v10 > 255 )
      LOBYTE(v10) = -1;
    arenaSettings->PrizeWeightAntiWarp = v10;
    v11 = GetCFGSettingInteger(v4, "PrizeWeight", "XRadar", 20);
    if ( v11 > 255 )
      LOBYTE(v11) = -1;
    arenaSettings->PrizeWeightXRadar = v11;
    v12 = GetCFGSettingInteger(v4, "PrizeWeight", "Warp", 40);
    if ( v12 > 255 )
      LOBYTE(v12) = -1;
    arenaSettings->PrizeWeightWarp = v12;
    v13 = GetCFGSettingInteger(v4, "PrizeWeight", "Gun", 60);
    if ( v13 > 255 )
      LOBYTE(v13) = -1;
    arenaSettings->PrizeWeightGun = v13;
    v14 = GetCFGSettingInteger(v4, "PrizeWeight", "Bomb", 50);
    if ( v14 > 255 )
      LOBYTE(v14) = -1;
    arenaSettings->PrizeWeightBomb = v14;
    v15 = GetCFGSettingInteger(v4, "PrizeWeight", "BouncingBullets", 30);
    if ( v15 > 255 )
      LOBYTE(v15) = -1;
    arenaSettings->PrizeWeightBouncingBullets = v15;
    v16 = GetCFGSettingInteger(v4, "PrizeWeight", "Thruster", 70);
    if ( v16 > 255 )
      LOBYTE(v16) = -1;
    arenaSettings->PrizeWeightThruster = v16;
    v17 = GetCFGSettingInteger(v4, "PrizeWeight", "TopSpeed", 70);
    if ( v17 > 255 )
      LOBYTE(v17) = -1;
    arenaSettings->PrizeWeightTopSpeed = v17;
    v18 = GetCFGSettingInteger(v4, "PrizeWeight", "Recharge", 60);
    if ( v18 > 255 )
      LOBYTE(v18) = -1;
    arenaSettings->PrizeWeightRecharge = v18;
    v19 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiFire", 30);
    if ( v19 > 255 )
      LOBYTE(v19) = -1;
    arenaSettings->PrizeWeightMultiFire = v19;
    v20 = GetCFGSettingInteger(v4, "PrizeWeight", "Proximity", 30);
    if ( v20 > 255 )
      LOBYTE(v20) = -1;
    arenaSettings->PrizeWeightProximity = v20;
    v21 = GetCFGSettingInteger(v4, "PrizeWeight", "Glue", 20);
    if ( v21 > 255 )
      LOBYTE(v21) = -1;
    arenaSettings->PrizeWeightGlue = v21;
    v22 = GetCFGSettingInteger(v4, "PrizeWeight", "AllWeapons", 10);
    if ( v22 > 255 )
      LOBYTE(v22) = -1;
    arenaSettings->PrizeWeightAllWeapons = v22;
    v23 = GetCFGSettingInteger(v4, "PrizeWeight", "Shields", 10);
    if ( v23 > 255 )
      LOBYTE(v23) = -1;
    arenaSettings->PrizeWeightShields = v23;
    v24 = GetCFGSettingInteger(v4, "PrizeWeight", "Shrapnel", 40);
    if ( v24 > 255 )
      LOBYTE(v24) = -1;
    arenaSettings->PrizeWeightShrapnel = v24;
    v25 = GetCFGSettingInteger(v4, "PrizeWeight", "Repel", 40);
    if ( v25 > 255 )
      LOBYTE(v25) = -1;
    arenaSettings->PrizeWeightRepel = v25;
    v26 = GetCFGSettingInteger(v4, "PrizeWeight", "Burst", 30);
    if ( v26 > 255 )
      LOBYTE(v26) = -1;
    arenaSettings->PrizeWeightBurst = v26;
    v27 = GetCFGSettingInteger(v4, "PrizeWeight", "Decoy", 20);
    if ( v27 > 255 )
      LOBYTE(v27) = -1;
    arenaSettings->PrizeWeightDecoy = v27;
    v28 = GetCFGSettingInteger(v4, "PrizeWeight", "Thor", 30);
    if ( v28 > 255 )
      LOBYTE(v28) = -1;
    arenaSettings->PrizeWeightThor = v28;
    v29 = GetCFGSettingInteger(v4, "PrizeWeight", "Portal", 30);
    if ( v29 > 255 )
      LOBYTE(v29) = -1;
    arenaSettings->PrizeWeightPortal = v29;
    v30 = GetCFGSettingInteger(v4, "PrizeWeight", "Brick", 10);
    if ( v30 > 255 )
      LOBYTE(v30) = -1;
    arenaSettings->PrizeWeightBrick = v30;
    v31 = GetCFGSettingInteger(v4, "PrizeWeight", "Rocket", 10);
    if ( v31 > 255 )
      LOBYTE(v31) = -1;
    arenaSettings->PrizeWeightRocket = v31;
    v32 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiPrize", 20);
    if ( v32 > 255 )
      LOBYTE(v32) = -1;
    arenaSettings->PrizeWeightMultiPrize = v32;
    Str2[0] = &shipsArray[64];
    Str2[1] = &shipsArray[56];
    Str2[2] = &shipsArray[48];
    Str2[3] = &shipsArray[36];
    Str2[4] = &shipsArray[20];
    Str2[5] = &shipsArray[28];
    Str2[6] = &shipsArray[8];
    Str2[7] = shipsArray;
    for ( Filename = 0; Filename < 8; ++Filename )
    {
      v33 = Str2[Filename];
      v34 = &arenaSettings->ShipSettings[Filename];
      *&v34->SuperTime = GetCFGSettingInteger(v4, v33, "SuperTime", 6000);
      *&v34->ShieldsTime = GetCFGSettingInteger(v4, v33, "ShieldsTime", 4000);
      v34->Gravity = GetCFGSettingInteger(v4, v33, "Gravity", 1500);
      v34->GravityTopSpeed = GetCFGSettingInteger(v4, v33, "GravityTopSpeed", 100);
      v34->BulletFireEnergy = GetCFGSettingInteger(v4, v33, "BulletFireEnergy", 20);
      v34->MultiFireEnergy = GetCFGSettingInteger(v4, v33, "MultiFireEnergy", 30);
      v34->BombFireEnergy = GetCFGSettingInteger(v4, v33, "BombFireEnergy", 300);
      v34->BombFireEnergyUpgrade = GetCFGSettingInteger(v4, v33, "BombFireEnergyUpgrade", 50);
      v34->MineFireEnergy = GetCFGSettingInteger(v4, v33, "LandmineFireEnergy", 300);
      v34->MineFireEnergyUpgrade = GetCFGSettingInteger(v4, v33, "LandmineFireEnergyUpgrade", 150);
      v34->BulletSpeed = GetCFGSettingInteger(v4, v33, "BulletSpeed", 2000);
      v34->BombSpeed = GetCFGSettingInteger(v4, v33, "BombSpeed", 2000);
      v35 = -(Filename != 4);
      LOBYTE(v35) = v35 & 0xFB;
      v34->BulletFireDelay = GetCFGSettingInteger(v4, v33, "BulletFireDelay", v35 + 30);
      v34->MultiFireDelay = GetCFGSettingInteger(v4, v33, "MultiFireDelay", 50);
      v34->BombFireDelay = GetCFGSettingInteger(v4, v33, "BombFireDelay", 150);
      v34->LandmineFireDelay = GetCFGSettingInteger(v4, v33, "LandmineFireDelay", 125);
      v34->MultiFireAngleBits2 = GetCFGSettingInteger(v4, v33, "MultiFireAngle", 500);
      v36 = -(Filename != 7);
      LOBYTE(v36) = v36 & 0x38;
      v34->CloakEnergy = GetCFGSettingInteger(v4, v33, "CloakEnergy", v36 + 300);
      v34->StealthEnergy = GetCFGSettingInteger(v4, v33, "StealthEnergy", Filename != 7 ? 333 : 300);
      v34->AntiWarpEnergy = GetCFGSettingInteger(v4, v33, "AntiWarpEnergy", 100);
      v34->XRadarEnergy = GetCFGSettingInteger(v4, v33, "XRadarEnergy", 250);
      if ( Filename )
      {
        if ( Filename == 7 )
          v49 = 280;
        else
          v49 = 230;
      }
      else
      {
        v49 = 300;
      }
      arenaSettings->ShipSettings[Filename].MaximumRotation = GetCFGSettingInteger(v4, v33, "MaximumRotation", v49);
      if ( Filename == 7 || (v37 = 17, !Filename) )
        v37 = 19;
      arenaSettings->ShipSettings[Filename].MaximumThrust = GetCFGSettingInteger(v4, v33, "MaximumThrust", v37);
      arenaSettings->ShipSettings[Filename].MaxmimumSpeed = GetCFGSettingInteger(
                                                              v4,
                                                              v33,
                                                              "MaximumSpeed",
                                                              Filename != 1 ? 3250 : 3750);
      arenaSettings->ShipSettings[Filename].MaximumRecharge = GetCFGSettingInteger(v4, v33, "MaximumRecharge", 1150);
      arenaSettings->ShipSettings[Filename].MaximumEnergy = GetCFGSettingInteger(
                                                              v4,
                                                              v33,
                                                              "MaximumEnergy",
                                                              Filename != 7 ? 1700 : 1750);
      arenaSettings->ShipSettings[Filename].InitalRotation = GetCFGSettingInteger(
                                                               v4,
                                                               v33,
                                                               "InitialRotation",
                                                               Filename != 0 ? 200 : 210);
      arenaSettings->ShipSettings[Filename].InitalThrust = GetCFGSettingInteger(
                                                             v4,
                                                             v33,
                                                             "InitialThrust",
                                                             16 - (Filename != 0));
      v38 = -(Filename != 1);
      LOBYTE(v38) = v38 & 0x42;
      arenaSettings->ShipSettings[Filename].InitalSpeed = GetCFGSettingInteger(v4, v33, "InitialSpeed", v38 + 2200);
      arenaSettings->ShipSettings[Filename].InitialRecharge = GetCFGSettingInteger(
                                                                v4,
                                                                v33,
                                                                "InitialRecharge",
                                                                Filename != 2 ? 400 : 500);
      arenaSettings->ShipSettings[Filename].InitialEnergy = GetCFGSettingInteger(v4, v33, "InitialEnergy", 1000);
      arenaSettings->ShipSettings[Filename].UpgradeRotation = GetCFGSettingInteger(v4, v33, "UpgradeRotation", 40);
      arenaSettings->ShipSettings[Filename].UpgradeThrust = GetCFGSettingInteger(v4, v33, "UpgradeThrust", 2);
      arenaSettings->ShipSettings[Filename].UpgradeSpeed = GetCFGSettingInteger(v4, v33, "UpgradeSpeed", 250);
      arenaSettings->ShipSettings[Filename].UpgradeRecharge = GetCFGSettingInteger(v4, v33, "UpgradeRecharge", 166);
      arenaSettings->ShipSettings[Filename].UpgradeEnergy = GetCFGSettingInteger(v4, v33, "UpgradeEnergy", 100);
      arenaSettings->ShipSettings[Filename].AfterburnerEnergy = GetCFGSettingInteger(v4, v33, "AfterburnerEnergy", 1200);
      arenaSettings->ShipSettings[Filename].BombThrust = GetCFGSettingInteger(v4, v33, "BombThrust", 400);
      arenaSettings->ShipSettings[Filename].BurstSpeed = GetCFGSettingInteger(v4, v33, "BurstSpeed", 3000);
      arenaSettings->ShipSettings[Filename].BurstShrapnel = GetCFGSettingInteger(v4, v33, "BurstShrapnel", 24);
      arenaSettings->ShipSettings[Filename].TurretThrustPenalty = GetCFGSettingInteger(
                                                                    v4,
                                                                    v33,
                                                                    "TurretThrustPenalty",
                                                                    1);
      arenaSettings->ShipSettings[Filename].TurretSpeedPenalty = GetCFGSettingInteger(
                                                                   v4,
                                                                   v33,
                                                                   "TurretSpeedPenalty",
                                                                   125);
      arenaSettings->ShipSettings[Filename].TurretLimit = GetCFGSettingInteger(v4, v33, "TurretLimit", 5);
      arenaSettings->ShipSettings[Filename].RocketTime = GetCFGSettingInteger(v4, v33, "RocketTime", 1000);
      arenaSettings->ShipSettings[Filename].InitialBounty = GetCFGSettingInteger(v4, v33, "InitialBounty", 0);
      arenaSettings->ShipSettings[Filename].MaxMines = GetCFGSettingInteger(v4, v33, "MaxMines", 5);
      arenaSettings->ShipSettings[Filename].RepelMax = GetCFGSettingInteger(v4, v33, "RepelMax", 3);
      arenaSettings->ShipSettings[Filename].BurstMax = GetCFGSettingInteger(v4, v33, "BurstMax", 3);
      arenaSettings->ShipSettings[Filename].DecoyMax = GetCFGSettingInteger(v4, v33, "DecoyMax", 3);
      arenaSettings->ShipSettings[Filename].ThorMax = GetCFGSettingInteger(v4, v33, "ThorMax", 3);
      arenaSettings->ShipSettings[Filename].BrickMax = GetCFGSettingInteger(v4, v33, "BrickMax", 3);
      arenaSettings->ShipSettings[Filename].RocketMax = GetCFGSettingInteger(v4, v33, "RocketMax", 3);
      arenaSettings->ShipSettings[Filename].PortalMax = GetCFGSettingInteger(v4, v33, "PortalMax", 3);
      arenaSettings->ShipSettings[Filename].InitialRepel = GetCFGSettingInteger(v4, v33, "InitialRepel", 0);
      arenaSettings->ShipSettings[Filename].InitialBurst = GetCFGSettingInteger(v4, v33, "InitialBurst", 0);
      arenaSettings->ShipSettings[Filename].InitialBrick = GetCFGSettingInteger(v4, v33, "InitialBrick", 0);
      arenaSettings->ShipSettings[Filename].InitialRocket = GetCFGSettingInteger(v4, v33, "InitialRocket", 0);
      arenaSettings->ShipSettings[Filename].InitialThor = GetCFGSettingInteger(v4, v33, "InitialThor", 0);
      arenaSettings->ShipSettings[Filename].InitialDecoy = GetCFGSettingInteger(v4, v33, "InitialDecoy", Filename == 2);
      arenaSettings->ShipSettings[Filename].InitialPortal = GetCFGSettingInteger(v4, v33, "InitialPortal", 0);
      arenaSettings->ShipSettings[Filename].BombBounceCount = GetCFGSettingInteger(
                                                                v4,
                                                                v33,
                                                                "BombBounceCount",
                                                                Filename == 6);
      v39 = Filename == 2 || Filename == 7;
      v40 = GetCFGSettingInteger(v4, v33, "CloakStatus", v39);
      v41 = arenaSettings->ShipSettings[Filename].LotsOfBitFields;
      BYTE1(v41) &= 0xF3u;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = v41 | ((v40 & 3) << 10);
      v42 = GetCFGSettingInteger(v4, v33, "StealthStatus", (Filename == 2) + 1);
      v43 = arenaSettings->ShipSettings[Filename].LotsOfBitFields;
      BYTE1(v43) &= 0xCFu;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((v42 & 3) << 12) | v43;
      v44 = GetCFGSettingInteger(v4, v33, "XRadarStatus", 1);
      v45 = arenaSettings->ShipSettings[Filename].LotsOfBitFields;
      BYTE1(v45) &= 0x3Fu;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((v44 & 3) << 14) | v45;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(v4, v33, "AntiWarpStatus", 1) & 3) << 16) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFFFCFFFF;
      arenaSettings->ShipSettings[Filename].DamageFactor = GetCFGSettingInteger(v4, v33, "DamageFactor", 30);
      arenaSettings->ShipSettings[Filename].PrizeShareLimit = GetCFGSettingInteger(v4, v33, "PrizeShareLimit", 100);
      arenaSettings->ShipSettings[Filename].AttachBounty = GetCFGSettingInteger(v4, v33, "AttachBounty", 12);
      arenaSettings->ShipSettings[Filename].LotsOfBitFields ^= (GetCFGSettingInteger(
                                                                  v4,
                                                                  v33,
                                                                  "ShrapnelMax",
                                                                  Filename != 5 ? 8 : 0) ^ arenaSettings->ShipSettings[Filename].LotsOfBitFields) & 0x1F;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = (32
                                                             * (GetCFGSettingInteger(v4, v33, "ShrapnelRate", 2) & 0x1F)) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFFFFFC1F;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(v4, v33, "MaxGuns", 3) & 3) << 20) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFFCFFFFF;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(
                                                                  v4,
                                                                  v33,
                                                                  "MaxBombs",
                                                                  (Filename == 3) + 2) & 3) << 24) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFCFFFFFF;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(
                                                                  v4,
                                                                  v33,
                                                                  "InitialGuns",
                                                                  (Filename == 4) + 1) & 3) << 18) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFFF3FFFF;
      v46 = Filename == 3 || Filename == 5;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(v4, v33, "InitialBombs", v46) & 3) << 22) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFF3FFFFF;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xF7FFFFFF | ((GetCFGSettingInteger(v4, v33, "EmpBomb", Filename == 5) & 1) << 27);
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(v4, v33, "SeeMines", Filename == 5) & 1) << 28) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xEFFFFFFF;
      arenaSettings->ShipSettings[Filename].LotsOfBitFields = ((GetCFGSettingInteger(
                                                                  v4,
                                                                  v33,
                                                                  "DoubleBarrel",
                                                                  Filename == 4) & 1) << 26) | arenaSettings->ShipSettings[Filename].LotsOfBitFields & 0xFBFFFFFF;
      arenaSettings->ShipSettings[Filename].SoccerBallFriction = GetCFGSettingInteger(v4, v33, "SoccerBallFriction", 12);
      arenaSettings->ShipSettings[Filename].SoccerBallProximity = GetCFGSettingInteger(
                                                                    v4,
                                                                    v33,
                                                                    "SoccerBallProximity",
                                                                    64);
      arenaSettings->ShipSettings[Filename].SoccerThrowTime = GetCFGSettingInteger(v4, v33, "SoccerThrowTime", 1200);
      arenaSettings->ShipSettings[Filename].SoccerBallSpeed = GetCFGSettingInteger(v4, v33, "SoccerBallSpeed", 2500);
    }
    arenaSettings->BulletDamageLevel = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageLevel", 200);
    arenaSettings->BulletDamageUpgrade = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageUpgrade", 100);
    arenaSettings->BulletAliveTime = GetCFGSettingInteger(v4, "Bullet", "BulletAliveTime", 550);
    arenaSettings->BombDamageLevel = 1000 * GetCFGSettingInteger(v4, "Bomb", "BombDamageLevel", 750);
    arenaSettings->BombAliveTime = GetCFGSettingInteger(v4, "Bomb", "BombAliveTime", 6000);
    arenaSettings->BombExplodeDelay = GetCFGSettingInteger(v4, "Bomb", "BombExplodeDelay", 150);
    arenaSettings->BombExplodePixels = GetCFGSettingInteger(v4, "Bomb", "BombExplodePixels", 80);
    arenaSettings->ProximityDistance = GetCFGSettingInteger(v4, "Bomb", "ProximityDistance", 3);
    arenaSettings->JitterTime = GetCFGSettingInteger(v4, "Bomb", "JitterTime", 72);
    arenaSettings->BombSafety = GetCFGSettingInteger(v4, "Bomb", "BombSafety", 1);
    arenaSettings->EBombShutdownTime = GetCFGSettingInteger(v4, "Bomb", "EBombShutdownTime", 400);
    arenaSettings->EBombDamagePercent = GetCFGSettingInteger(v4, "Bomb", "EBombDamagePercent", 1000);
    arenaSettings->BBombDamagePercent = GetCFGSettingInteger(v4, "Bomb", "BBombDamagePercent", 1000);
    arenaSettings->MineAliveTime = GetCFGSettingInteger(v4, "Mine", "MineAliveTime", 12000);
    arenaSettings->TeamMaxMines = GetCFGSettingInteger(v4, "Mine", "TeamMaxMines", 12);
    arenaSettings->ShrapnelSpeed = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelSpeed", 3000);
    arenaSettings->InactiveShrapnelDamage = 1000 * GetCFGSettingInteger(v4, "Shrapnel", "InactiveShrapDamage", 3);
    arenaSettings->ShrapnelDamagePercent = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelDamagePercent", 1000);
    arenaSettings->RandomShrapnel = GetCFGSettingInteger(v4, "Shrapnel", "Random", 1);
    arenaSettings->BurstDamageLevel = 1000 * GetCFGSettingInteger(v4, "Burst", "BurstDamageLevel", 515);
    arenaSettings->AntiwarpPixels = GetCFGSettingInteger(v4, "Toggle", "AntiWarpPixels", 1500);
    arenaSettings->MultiPrizeCount = GetCFGSettingInteger(v4, "Prize", "MultiPrizeCount", 10);
    arenaSettings->PrizeFactor = GetCFGSettingInteger(v4, "Prize", "PrizeFactor", 1000);
    arenaSettings->PrizeDelay = GetCFGSettingInteger(v4, "Prize", "PrizeDelay", 300);
    arenaSettings->PrizeHideCount = GetCFGSettingInteger(v4, "Prize", "PrizeHideCount", 30);
    arenaSettings->PrizeMinimumVirtual = GetCFGSettingInteger(v4, "Prize", "MinimumVirtual", 256);
    arenaSettings->PrizeUpgradeVirtual = GetCFGSettingInteger(v4, "Prize", "UpgradeVirtual", 6);
    arenaSettings->PrizeMaxExist = GetCFGSettingInteger(v4, "Prize", "PrizeMaxExist", 8000);
    arenaSettings->PrizeMinExist = GetCFGSettingInteger(v4, "Prize", "PrizeMinExist", 4000);
    arenaSettings->PrizeNegativeFactor = GetCFGSettingInteger(v4, "Prize", "PrizeNegativeFactor", 300);
    arenaSettings->DeathPrizeTime = GetCFGSettingInteger(v4, "Prize", "DeathPrizeTime", 800);
    arenaSettings->EngineShutdownTime = GetCFGSettingInteger(v4, "Prize", "EngineShutdownTime", 700);
    arenaSettings->TakePrizeReliable = GetCFGSettingInteger(v4, "Prize", "TakePrizeReliable", 0);
    arenaSettings->FlaggerOnRadar = GetCFGSettingInteger(v4, "Flag", "FlaggerOnRadar", 1);
    arenaSettings->FlaggerKillMultiplier = GetCFGSettingInteger(v4, "Flag", "FlaggerKillMultiplier", 2);
    arenaSettings->FlaggerGunUpgrade = GetCFGSettingInteger(v4, "Flag", "FlaggerGunUpgrade", 0);
    arenaSettings->FlaggerBombUpgrade = GetCFGSettingInteger(v4, "Flag", "FlaggerBombUpgrade", 0);
    arenaSettings->FlaggerFireCostPercent = GetCFGSettingInteger(v4, "Flag", "FlaggerFireCostPercent", 1000);
    arenaSettings->FlaggerDamagePercent = GetCFGSettingInteger(v4, "Flag", "FlaggerDamagePercent", 1000);
    arenaSettings->FlaggerBombFireDelay = GetCFGSettingInteger(v4, "Flag", "FlaggerBombFireDelay", 0);
    arenaSettings->FlaggerSpeedAdjustment = GetCFGSettingInteger(v4, "Flag", "FlaggerSpeedAdjustment", 0);
    arenaSettings->FlaggerThrustAdjustment = GetCFGSettingInteger(v4, "Flag", "FlaggerThrustAdjustment", 0);
    arenaSettings->CarryFlags = GetCFGSettingInteger(v4, "Flag", "CarryFlags", 1);
    arenaSettings->FlagDropDelay = GetCFGSettingInteger(v4, "Flag", "FlagDropDelay", 0);
    arenaSettings->FlagDropResetReward = GetCFGSettingInteger(v4, "Flag", "FlagDropResetReward", 0);
    arenaSettings->EnterGameFlaggingDelay = GetCFGSettingInteger(v4, "Flag", "EnterGameFlaggingDelay", 12000);
    arenaSettings->FlagBlankDelay = GetCFGSettingInteger(v4, "Flag", "FlagBlankDelay", 200);
    arenaSettings->NoDataFlagDropDelay = GetCFGSettingInteger(v4, "Flag", "NoDataFlagDropDelay", 500);
    arenaSettings->SoccerBallBounce = GetCFGSettingInteger(v4, "Soccer", "BallBounce", 1);
    arenaSettings->SoccerAllowBombs = GetCFGSettingInteger(v4, "Soccer", "AllowBombs", 1);
    arenaSettings->SoccerAllowGuns = GetCFGSettingInteger(v4, "Soccer", "AllowGuns", 1);
    arenaSettings->SoccerPassDelay = GetCFGSettingInteger(v4, "Soccer", "PassDelay", 20);
    arenaSettings->SoccerMode = GetCFGSettingInteger(v4, "Soccer", "Mode", 1);
    arenaSettings->SoccerBallBlankDelay = GetCFGSettingInteger(v4, "Soccer", "BallBlankDelay", 200);
    arenaSettings->SoccerUseFlagger = GetCFGSettingInteger(v4, "Soccer", "UseFlagger", 0);
    arenaSettings->SoccerBallLocation = GetCFGSettingInteger(v4, "Soccer", "BallLocation", 0);
    arenaSettings->RadarMode = GetCFGSettingInteger(v4, "Radar", "RadarMode", 0);
    arenaSettings->RadarNeutralSize = GetCFGSettingInteger(v4, "Radar", "RadarNeutralSize", 128);
    arenaSettings->MapZoomFactor = GetCFGSettingInteger(v4, "Radar", "MapZoomFactor", 10);
    arenaSettings->MaxFrequency = GetCFGSettingInteger(v4, "Team", "MaxFrequency", 9999);
    arenaSettings->MaxPerTeam = GetCFGSettingInteger(v4, "Team", "MaxPerTeam", 6);
    arenaSettings->MaxPerPrivateTeam = GetCFGSettingInteger(v4, "Team", "MaxPerPrivateTeam", 0);
    arenaSettings->MaxBonus = GetCFGSettingInteger(v4, "Kill", "MaxBonus", 0);
    arenaSettings->MaxPenalty = GetCFGSettingInteger(v4, "Kill", "MaxPenalty", 0);
    arenaSettings->RewardBase = GetCFGSettingInteger(v4, "Kill", "RewardBase", 0);
    arenaSettings->BountyIncreaseForKill = GetCFGSettingInteger(v4, "Kill", "BountyIncreaseForKill", 6);
    arenaSettings->EnterDelay = GetCFGSettingInteger(v4, "Kill", "EnterDelay", 200);
    arenaSettings->RepelSpeed = GetCFGSettingInteger(v4, "Repel", "RepelSpeed", 5000);
    arenaSettings->RepelTime = GetCFGSettingInteger(v4, "Repel", "RepelTime", 225);
    arenaSettings->RepelDistance = GetCFGSettingInteger(v4, "Repel", "RepelDistance", 512);
    arenaSettings->MessageReliable = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    arenaSettings->AllowAudioMessages = GetCFGSettingInteger(v4, "Message", "AllowAudioMessages", 1);
    arenaSettings->WormholeGravityBombs = GetCFGSettingInteger(v4, "Wormhole", "GravityBombs", 1);
    arenaSettings->WormholeSwitchTime = GetCFGSettingInteger(v4, "Wormhole", "SwitchTime", 0);
    arenaSettings->SendRoutePercent = GetCFGSettingInteger(v4, "Latency", "SendRoutePercent", 500);
    arenaSettings->ClientSlowPacketSampleSize = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketSampleSize", 100);
    arenaSettings->BrickTime = GetCFGSettingInteger(v4, "Brick", "BrickTime", 12000);
    arenaSettings->RocketThrust = GetCFGSettingInteger(v4, "Rocket", "RocketThrust", 25);
    arenaSettings->RocketSpeed = GetCFGSettingInteger(v4, "Rocket", "RocketSpeed", 5500);
    arenaSettings->DoorDelay = GetCFGSettingInteger(v4, "Door", "DoorDelay", 400);
    arenaSettings->DoorMode = GetCFGSettingInteger(v4, "Door", "DoorMode", -1);
    arenaSettings->WarpPointDelay = GetCFGSettingInteger(v4, "Misc", "WarpPointDelay", 6000);
    arenaSettings->DecoyAliveTime = GetCFGSettingInteger(v4, "Misc", "DecoyAliveTime", 3000);
    arenaSettings->BounceFactor = GetCFGSettingInteger(v4, "Misc", "BounceFactor", 22);
    arenaSettings->SendPositionDelay = GetCFGSettingInteger(v4, "Misc", "SendPositionDelay", 10);
    arenaSettings->SlowFrameCheck = GetCFGSettingInteger(v4, "Misc", "SlowFrameCheck", 0);
    arenaSettings->AllowSavedShip = GetCFGSettingInteger(v4, "Misc", "AllowSavedShips", 1);
    arenaSettings->SafetyLimit = GetCFGSettingInteger(v4, "Misc", "SafetyLimit", 90000);
    arenaSettings->FrequencyShift = GetCFGSettingInteger(v4, "Misc", "FrequencyShift", 900);
    arenaSettings->HelpTickerDelay = GetCFGSettingInteger(v4, "Misc", "TickerDelay", 1000);
    arenaSettings->ExtraPositionData = GetCFGSettingInteger(v4, "Misc", "ExtraPositionData", 0);
    arenaSettings->WarpRadiusLimit = GetCFGSettingInteger(v4, "Misc", "WarpRadiusLimit", 1024);
    arenaSettings->ActivateAppShutdownTime = GetCFGSettingInteger(v4, "Misc", "ActivateAppShutdownTime", 1500);
    arenaSettings->NearDeathLevel = GetCFGSettingInteger(v4, "Misc", "NearDeathLevel", 0);
    arenaSettings->VictoryMusic = GetCFGSettingInteger(v4, "Misc", "VictoryMusic", 1);
    arenaSettings->ClientSlowPacketTime = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketTime", 40);
    arenaSettings->S2CNoDataKickoutDelay = GetCFGSettingInteger(v4, "Latency", "S2CNoDataKickoutDelay", 500);
  }
  if ( a2 )
  {
    a2->CustomSaveStatsTime = GetCFGSettingInteger(v4, "Custom", "SaveStatsTime", 720000);
    a2->TerritoryRewardDelay = GetCFGSettingInteger(v4, "Territory", "RewardDelay", 60000);
    a2->TerritoryRewardBaseFlags = GetCFGSettingInteger(v4, "Territory", "RewardBaseFlags", 8);
    a2->TerritoryRewardMinimumPlayers = GetCFGSettingInteger(v4, "Territory", "RewardMinimumPlayers", 5);
    a2->TerritoryRewardPoints = GetCFGSettingInteger(v4, "Territory", "RewardPoints", 30);
    a2->PeriodicRewardDelay = GetCFGSettingInteger(v4, "Periodic", "RewardDelay", 0);
    a2->PeriodicRewardMinimumPlayers = GetCFGSettingInteger(v4, "Periodic", "RewardMinimumPlayers", 16);
    a2->PeriodicRewardPoints = GetCFGSettingInteger(v4, "Periodic", "RewardPoints", 50);
    a2->FlagMode = GetCFGSettingInteger(v4, "Flag", "FlagMode", 0);
    a2->FlagResetDelay = GetCFGSettingInteger(v4, "Flag", "FlagResetDelay", 1440000);
    a2->MaxFlags = GetCFGSettingInteger(v4, "Flag", "MaxFlags", 16);
    a2->RandomFlags = GetCFGSettingInteger(v4, "Flag", "RandomFlags", 0);
    a2->FlagReward = GetCFGSettingInteger(v4, "Flag", "FlagReward", 1000);
    a2->FlagRewardMode = GetCFGSettingInteger(v4, "Flag", "FlagRewardMode", 0);
    a2->FlagTerritoryRadius = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadius", 8);
    a2->FlagTerritoryRadiusCentroid = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadiusCentroid", 0);
    a2->FlagFriendlyTransfer = GetCFGSettingInteger(v4, "Flag", "FriendlyTransfer", 1);
    a2->KillPointsPerFlag = GetCFGSettingInteger(v4, "Kill", "KillPointsPerFlag", 0);
    a2->KillPointsMinimumBounty = GetCFGSettingInteger(v4, "Kill", "KillPointsMinimumBounty", 50);
    a2->KillDebtKills = GetCFGSettingInteger(v4, "Kill", "DebtKills", 0);
    a2->KillNoRewardKillDelay = GetCFGSettingInteger(v4, "Kill", "NoRewardKillDelay", 0);
    a2->KillBountyRewardPercent = GetCFGSettingInteger(v4, "Kill", "BountyRewardPercent", 0);
    a2->KillFixedKillReward = GetCFGSettingInteger(v4, "Kill", "FixedKillReward", -1);
    a2->KillJackpotBountyPercent = GetCFGSettingInteger(v4, "Kill", "JackpotBountyPercent", 0);
    a2->TeamForceEvenTeams = GetCFGSettingInteger(v4, "Team", "ForceEvenTeams", 0);
    a2->TeamDesiredTeams = GetCFGSettingInteger(v4, "Team", "DesiredTeams", 2);
    a2->TeamSpectatorFrequency = GetCFGSettingInteger(v4, "Team", "SpectatorFrequency", 8025);
    a2->BrickSpan = GetCFGSettingInteger(v4, "Brick", "BrickSpan", 7);
    a2->MiscFrequencyShipTypes = GetCFGSettingInteger(v4, "Misc", "FrequencyShipTypes", 0);
    a2->MiscBannerPoints = GetCFGSettingInteger(v4, "Misc", "BannerPoints", 5000);
    a2->MiscMaxLossesToPlay = GetCFGSettingInteger(v4, "Misc", "MaxLossesToPlay", 0);
    a2->MiscSpectatorQuiet = GetCFGSettingInteger(v4, "Misc", "SpectatorQuiet", 0);
    a2->MiscTimedGame = GetCFGSettingInteger(v4, "Misc", "TimedGame", 0);
    GetCFGSettingString(
      v4,
      "Misc",
      "SheepMessage",
      "Sheep successfully cloned -- hello Dolly",
      a2->MiscSheepMessage,
      256u);
    a2->MiscResetScoreOnFrequencyChange = GetCFGSettingInteger(v4, "Misc", "ResetScoreOnFrequencyChange", 0);
    a2->MiscMaxPlaying = GetCFGSettingInteger(v4, "Misc", "MaxPlaying", 0);
    a2->MessageBongAllowed = GetCFGSettingInteger(v4, "Message", "BongAllowed", 0);
    a2->MessageQuickMessageLimit = GetCFGSettingInteger(v4, "Message", "QuickMessageLimit", 8);
    a2->MessageReliable = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    a2->MessageTeamReliable = GetCFGSettingInteger(v4, "Message", "MessageTeamReliable", 1);
    a2->MessageDistance = GetCFGSettingInteger(v4, "Message", "MessageDistance", 17000);
    a2->dwordB4 = 1;
    a2->SecurityS2CKickOutPercentWeapons = GetCFGSettingInteger(v4, "Security", "S2CKickOutPercentWeapons", 700);
    a2->SecuritySuicideLimit = GetCFGSettingInteger(v4, "Security", "SuicideLimit", 10);
    a2->SecurityMaxShipTypeSwitchCount = GetCFGSettingInteger(v4, "Security", "MaxShipTypeSwitchCount", 40);
    a2->SecurityPacketModificationMax = GetCFGSettingInteger(v4, "Security", "PacketModificationMax", 3);
    a2->SecurityMaxDeathWithoutFiring = GetCFGSettingInteger(v4, "Security", "MaxDeathWithoutFiring", 5);
    a2->PacketLossC2SKickOutPercent = GetCFGSettingInteger(v4, "PacketLoss", "C2SKickOutPercent", 800);
    a2->PacketLossC2SNegativeKickOutPercent = GetCFGSettingInteger(v4, "PacketLoss", "C2SNegativeKickOutPercent", 50);
    a2->PacketLossS2CKickOutPercent = GetCFGSettingInteger(v4, "PacketLoss", "S2CKickOutPercent", 800);
    a2->PacketLossSpectatorPercentAdjust = GetCFGSettingInteger(v4, "PacketLoss", "SpectatorPercentAdjust", 100);
    a2->PacketLossDisableWeapons = GetCFGSettingInteger(v4, "PacketLoss", "PacketLossDisableWeapons", 1);
    a2->LatencyKickOutDelay = GetCFGSettingInteger(v4, "Latency", "KickOutDelay", 1000);
    a2->LatencyNoFlagDelay = GetCFGSettingInteger(v4, "Latency", "NoFlagDelay", 300);
    a2->LatencyNoFlagPenalty = GetCFGSettingInteger(v4, "Latency", "NoFlagPenalty", 1000);
    a2->LatencySlowPacketKickoutPercent = GetCFGSettingInteger(v4, "Latency", "SlowPacketKickoutPercent", 200);
    a2->LatencyClientSlowPacketKickoutPercent = GetCFGSettingInteger(
                                                  v4,
                                                  "Latency",
                                                  "ClientSlowPacketKickoutPercent",
                                                  200);
    a2->LatencySlowPacketTime = GetCFGSettingInteger(v4, "Latency", "SlowPacketTime", 50);
    a2->LatencySlowPacketSampleSize = GetCFGSettingInteger(v4, "Latency", "SlowPacketSampleSize", 300);
    a2->LatencyMaxLatencyForWeapons = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForWeapons", 45);
    a2->LatencyMaxLatencyForPrizes = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForPrizes", 80);
    a2->LatencyMaxLatencyForKickOut = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForKickOut", 120);
    a2->LatencyKickOutTime = GetCFGSettingInteger(v4, "Latency", "LatencyKickOutTime", 2200);
    a2->LatencyCutbackWatermark = GetCFGSettingInteger(v4, "Latency", "CutbackWatermark", 2400);
    a2->PrizeS2CTakePrizeReliable = GetCFGSettingInteger(v4, "Prize", "S2CTakePrizeReliable", 0);
    a2->RoutingRadarFavor = GetCFGSettingInteger(v4, "Routing", "RadarFavor", 3);
    a2->RoutingCloseEnoughBulletAdjust = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBulletAdjust", 512);
    a2->RoutingCloseEnoughBombAdjust = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBombAdjust", 2048);
    a2->RoutingDeathDistance = GetCFGSettingInteger(v4, "Routing", "DeathDistance", 2800);
    a2->RoutingDoubleSendPercent = GetCFGSettingInteger(v4, "Routing", "DoubleSendPercent", 880);
    a2->RoutingWallResendCount = GetCFGSettingInteger(v4, "Routing", "WallResendCount", 2);
    a2->SoccerBallCount = GetCFGSettingInteger(v4, "Soccer", "BallCount", 0);
    a2->SoccerSendTime = GetCFGSettingInteger(v4, "Soccer", "SendTime", 200);
    a2->SoccerReward = GetCFGSettingInteger(v4, "Soccer", "Reward", 1000);
    a2->SoccerCapturePoints = GetCFGSettingInteger(v4, "Soccer", "CapturePoints", 0);
    a2->SoccerCatchMinimum = GetCFGSettingInteger(v4, "Soccer", "CatchMinimum", 12);
    a2->SoccerCatchPoints = GetCFGSettingInteger(v4, "Soccer", "CatchPoints", 0);
    a2->SoccerWinBy = GetCFGSettingInteger(v4, "Soccer", "WinBy", 0);
    a2->KingDeathCount = GetCFGSettingInteger(v4, "King", "DeathCount", 0);
    a2->KingExpireTime = GetCFGSettingInteger(v4, "King", "ExpireTime", 30000);
    a2->KingRewardFactor = GetCFGSettingInteger(v4, "King", "RewardFactor", 1000);
    a2->KingNonCrownAdjustTime = GetCFGSettingInteger(v4, "King", "NonCrownAdjustTime", 3000);
    a2->KingNonCrownMinimumBounty = GetCFGSettingInteger(v4, "King", "NonCrownMinimumBounty", 100);
    a2->KingCrownRecoverKills = GetCFGSettingInteger(v4, "King", "CrownRecoverKills", 3);
    memset(a2->char158, 0, 576u);
    strcpy(a2->char158, "Recharge");
    a2->dword16C = 1;
    strcpy(a2->char170, "Energy");
    a2->dword184 = 2;
    strcpy(a2->char188, "Rotation");
    a2->dword19C = 3;
    strcpy(a2->char1A0, "Stealth");
    a2->dword1B4 = 4;
    strcpy(a2->char1B8, "Cloak");
    a2->dword1CC = 5;
    strcpy(a2->char1D0, "XRadar");
    a2->dword1E4 = 6;
    strcpy(a2->char1E8, "Gun");
    a2->dword1FC = 8;
    strcpy(a2->char200, "Bomb");
    a2->dword214 = 9;
    strcpy(a2->char218, "Bounce");
    a2->dword22C = 10;
    strcpy(a2->char230, "Thrust");
    a2->dword244 = 11;
    strcpy(a2->char248, "Speed");
    a2->dword25C = 12;
    strcpy(a2->char260, "MultiFire");
    a2->dword274 = 15;
    strcpy(a2->char278, "Prox");
    a2->dword28C = 16;
    strcpy(a2->char290, "Super");
    a2->dword2A4 = 17;
    strcpy(a2->char2A8, "Shield");
    a2->dword2BC = 18;
    strcpy(a2->char2C0, "Shrap");
    a2->dword2D4 = 19;
    strcpy(a2->char2D8, "AntiWarp");
    a2->dword2EC = 20;
    strcpy(a2->char2F0, "Repel");
    a2->dword304 = 21;
    strcpy(a2->char308, "Burst");
    a2->dword31C = 22;
    strcpy(a2->char320, "Decoy");
    a2->dword334 = 23;
    strcpy(a2->char338, "Thor");
    a2->dword34C = 24;
    strcpy(a2->char350, "Brick");
    a2->dword364 = 26;
    strcpy(a2->char368, "Rocket");
    a2->dword37C = 27;
    strcpy(a2->char380, "Portal");
    a2->dword394 = 28;
    v47 = &a2->char158[16];
    v48 = 24;
    do
    {
      *v47 = GetCFGSettingInteger(v4, "Cost", v47 - 16, 0);
      v47 += 24;
      --v48;
    }
    while ( v48 );
    a2->CostPurchaseAnytime = GetCFGSettingInteger(v4, "Cost", "PurchaseAnytime", 0);
    a2->OwnerUserId = GetCFGSettingInteger(v4, aO, aUserid, -1);
    GetCFGSettingString(v4, aO, aName, "None", a2->OwnerName, 0x20u);
  }
  if ( v4 )
  {
    WriteCfgFile(v4);
    operator delete(v4);
  }
}

//----- (00411D70) --------------------------------------------------------
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3)
{
  int result; // eax

  switch ( SoccerMode )
  {
    case 1:
      result = a2 >= 512;
      break;
    case 2:
      result = a3 >= 512;
      break;
    case 3:
    case 4:
      if ( a2 >= 512 )
        result = a3 >= 512 ? 3 : 1;
      else
        result = a3 >= 512 ? 2 : 0;
      break;
    case 5:
    case 6:
      if ( a2 >= a3 )
        result = (a2 >= 1024 - a3) + 2;
      else
        result = a2 >= 1024 - a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00411E30) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *CommandLine; // eax
  char *v4; // eax
  char *v6; // eax
  unsigned int v7; // ecx
  char v8; // al
  char *v9; // edi
  char *v10; // edx
  char *v11; // eax
  unsigned int v12; // kr04_4
  char *v13; // edi
  char *v14; // esi
  char v15; // cl
  char *v16; // edx
  unsigned int v17; // eax
  int v18; // edi
  const char **v19; // esi
  int v20; // [esp+0h] [ebp-70h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-64h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-20h] BYREF
  int *v23; // [esp+60h] [ebp-10h]
  int v24; // [esp+6Ch] [ebp-4h]

  v23 = &v20;
  CommandLine = GetCommandLineA();
  v4 = strstr(CommandLine, "/SPAWN");
  if ( v4 )
    return sub_41E940((v4 + 7));
  GetModuleFileNameA(0, FileName, 0x100u);
  v6 = strrchr(FileName, 92);
  if ( v6 )
  {
    v10 = v6 + 1;
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = v10;
  }
  else
  {
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = FileName;
  }
  qmemcpy(v9, "server.ini", 4 * (v7 >> 2) + (v8 & 3));
  GetModuleFileNameA(0, FileName2, 0x100u);
  v11 = strrchr(FileName2, 92);
  if ( v11 )
  {
    v16 = v11 + 1;
    v17 = strlen(MEMORY[0x42A098]) + 1;
    qmemcpy(v16, MEMORY[0x42A098], 4 * (v17 >> 2));
    v14 = &MEMORY[0x42A098][4 * (v17 >> 2)];
    v13 = &v16[4 * (v17 >> 2)];
    v15 = v17;
  }
  else
  {
    v12 = strlen(MEMORY[0x42A098]) + 1;
    qmemcpy(FileName2, MEMORY[0x42A098], 4 * (v12 >> 2));
    v14 = &MEMORY[0x42A098][4 * (v12 >> 2)];
    v13 = &FileName2[4 * (v12 >> 2)];
    v15 = v12;
  }
  qmemcpy(v13, v14, v15 & 3);
  if ( argc > 1 )
  {
    v18 = argc - 1;
    v19 = argv + 1;
    do
    {
      if ( !_strcmpi(*v19, "/nb") )
        dword_42C840 = 0;
      ++v19;
      --v18;
    }
    while ( v18 );
  }
  ShutdownArguments = 0;
  nullsub_3();
  bServerIsRunning = 0;
  while ( !bServerIsRunning )
  {
    ServerInitialize();
    v24 = 0;
    ServerMainLoop();
    v24 = -1;
    ServerUninitialize();
  }
  nullsub_3();
  if ( ShutdownArguments )
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    StartupInfo.cb = 68;
    StartupInfo.lpTitle = "Spawned Command";
    CreateProcessA(0, &ShutdownArguments, 0, 0, 0, 0x210u, 0, 0, &StartupInfo, &ProcessInformation);
  }
  return 0;
}
// 408300: using guessed type int nullsub_3(void);
// 42C840: using guessed type int dword_42C840;
// 437CA8: using guessed type int bServerIsRunning;

//----- (00412060) --------------------------------------------------------
signed int __cdecl ServerInitialize()
{
  int clockValue; // eax
  int v1; // edi
  struct_ARENA **v2; // esi
  GlobalArray_Strct *v3; // eax
  FILE *file; // eax
  FILE *filee; // esi
  int securityFileSize; // eax
  struct TEXT_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct TEXT_FILE_STRUCT *v9; // eax
  int v10; // eax
  DWORD v11; // esi
  int v12; // ebx
  struct PACKET_ATTACHMENT *ServerBigStruct; // eax
  struct_v9 *ServerBigStructt; // eax
  DWORD GetTickCountDividedByTen; // esi
  int RandomValue; // eax
  struct_v9 *ServerStructt; // ebx
  struct PACKET_ATTACHMENT *ServerStructtt; // eax
  struct_v9 *retPointer; // eax
  int hConsoleHandle; // eax
  struct BILLING_SERVER_STRUCT *v21; // eax
  struct BILLING_SERVER_STRUCT *v22; // eax
  struct_v9 *ServerStructttt; // esi
  SOCKET *SmallServerStructt; // eax
  SOCKET_STRUCT *returnedSmallStruct; // eax
  int v26; // esi
  SOCKET *v27; // eax
  int v28; // eax
  struct TEXT_FILE_STRUCT *ObsceneStructPointer; // eax
  const CHAR *ObsceneStructPointerRet; // eax
  struct TEXT_FILE_STRUCT *IdBlockStructPointer; // eax
  const CHAR *IdBlockStructPointerRet; // eax
  struct TEXT_FILE_STRUCT *PermitStructPointer; // eax
  const CHAR *PermitStructPointerRet; // eax
  struct TEXT_FILE_STRUCT *ModerateStructPointer; // eax
  const CHAR *ModerateStructPointerRet; // eax
  struct TEXT_FILE_STRUCT *ReservedStructPointer; // eax
  const CHAR *ReservedStructPointerRet; // eax
  SOCKET_STRUCT2 *v39; // eax
  SOCKET_STRUCT2 *v40; // eax
  struct PACKET_ATTACHMENT *Structv9; // eax
  struct_v9 *Structv9PointerRet; // eax
  int v44; // [esp+0h] [ebp-43Ch]
  int counter; // [esp+14h] [ebp-428h]
  int ptr; // [esp+18h] [ebp-424h] BYREF
  int a4[4]; // [esp+1Ch] [ebp-420h] BYREF
  char v48; // [esp+2Ch] [ebp-410h]
  CHAR cp[512]; // [esp+30h] [ebp-40Ch] BYREF
  char Buffer[128]; // [esp+230h] [ebp-20Ch] BYREF
  int v51; // [esp+438h] [ebp-4h]

  ShutdownArguments = 0;
  bRecycleServer = 0;
  fileHandle = fopen("subgame.log", "wt");
  WriteSubGameLog("SubSpace Game Server f%d.%02d%c\n", 1, 34, 98);
  if ( fileHandle )
  {
    fclose(fileHandle);
    fileHandle = 0;
  }
  clockValue = clock();
  setRNGSeed(clockValue);
  memset(LogArray, 0, sizeof(LogArray));
  memset(PlayerList, 0, sizeof(PlayerList));    // PlayerList is 4100 bytes. Approximitly 1025 players.
  memset(ChatRelatedArray, 0, sizeof(ChatRelatedArray));
  MachineIdArrayIndex = 0;
  logLine = 0;
  CurrentPlayerCount = 0;
  IncreasesRadarValueSomeHow = 0;
  dword_4D55D0 = 0;
  dword_4C8F38 = 0;
  PointsFileHandle = 0;
  dword_4D8AFC = 0;
  dword_4D8B00 = 0;
  dword_4D8B04 = 0;
  ChatCounter64Max = 0;
  LoadWinsock();
  IsFileLastWrittenTime(FileName, &LastTimeServerINIWasEdited);
  ReadServerINI();
  IsFileLastWrittenTime(FileName2, &LastTimeMasterCFGWasEdited);
  LoadZoneCFGSettings(&ArenaSettings, &ServersideArenaSettings, FileName2);
  v1 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v2 = Arenas;
    do
    {
      if ( !_strcmpi((*v2)->szConfigFile, FileName2) )
        (*v2)->playerPointersForSomething[250] = 1;
      ++v1;
      ++v2;
    }
    while ( v1 < ArenaArrayLength );
  }
  LoadTemplateSSS();
  LoadMapSomething();
  LoadAdvertisements();
  a4[0] = 16;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  counter = 0;
  v48 = 0;
  memset(SecurityArray, 0, sizeof(SecurityArray));
  do
  {
    if ( counter )
    {
      sprintf(Buffer, "version%d\\", counter);
    }
    else if ( _access("version0", 0) == -1 )
    {
      Buffer[0] = 0;
    }
    else
    {
      sprintf(Buffer, "version%d\\", 0);
    }
    v3 = &SecurityArray[counter];
    *&v3->test = 0;
    v3->field_4 = 0;
    v3->field_8 = 0;
    strcpy(cp, Buffer);
    strcat(cp, "Update.exe");
    if ( _access(cp, 0) != -1 )
      *&SecurityArray[counter].test = CompressFile(cp, &SecurityArray[counter].field_C, &ptr, a4, 0x11u, 0, 0);
    strcpy(cp, Buffer);
    strcat(cp, "Update1.exe");
    if ( _access(cp, 0) != -1 )
      SecurityArray[counter].field_4 = CompressFile(cp, &SecurityArray[counter].field_10, &ptr, a4, 0x11u, 0, 0);
    strcpy(cp, Buffer);
    strcat(cp, "Update2.exe");
    if ( _access(cp, 0) != -1 )
      SecurityArray[counter].field_8 = CompressFile(cp, &SecurityArray[counter].field_14, &ptr, a4, 0x11u, 0, 0);
    strcpy(cp, Buffer);
    strcat(cp, "subspace.exe");
    if ( _access(cp, 0) != -1 )
    {
      SecurityArray[counter].SubspaceEXEChecksum = GetSubspaceEXEChecksum(cp, cp);
      _spawnlp(0, cp, cp);
      file = fopen(
               "scrty",
               "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
               "\x00\x00\x00Player spectating game: %s\n"
               "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE:"
               " 1 minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00"
               "\x00\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00"
               "\x00\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00"
               "\x00Player kicked off for not returning security packet: %s\n"
               "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00"
               "Parameters resent for arena(%s)\n"
               "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user param"
               "eter.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00"
               "\x00Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no p"
               "oints to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbird"
               "s:%d  Javelins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelin"
               "s:%d  Spiders:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
               "\x00\x00\x00%s=%s\n"
               "\x00\x00[%s]\n"
               "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
               "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Re"
               "size)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
               "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked"
               " off, arena full to demo users: %s\n"
               "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
               "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
               "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
               "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
               "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
               "\x00%s>  MODERATOR LOGGED IN\n"
               "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
               "\x00%s> SYSOP LOGGED IN\n"
               "\x00\x00\x00\x00Connection request from: %s\n"
               "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00"
               "File has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00"
               "\x00File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s"
               "\x00\x00\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protoc"
               "ol attempting to enter game");
      filee = file;
      if ( file )
      {
        securityFileSize = _fileno(file);
        if ( _filelength(securityFileSize) != 4000 )
        {
          printf("Security file invalid size\n");
          exit(1);
        }
        fread(SecurityArray[counter].ScrtyData, 1u, 4000u, filee);
        fclose(filee);
      }
      strcpy(cp, Buffer);
      strcat(cp, "ipblock.txt");
      v7 = operator new(276u);
      v51 = 0;
      if ( v7 )
        InitializeTextFile(v7, cp, 1, 1);
      else
        v8 = 0;
      SecurityArray[counter].field_FBC = v8;
      strcpy(cp, Buffer);
      v51 = -1;
      strcat(cp, "ipallow.txt");
      v9 = operator new(0x114u);
      v51 = 1;
      if ( v9 )
        InitializeTextFile(v9, cp, 1, 1);
      else
        v10 = 0;
      v51 = -1;
      *&SecurityArray[counter].field_FC0 = v10;
    }
    ++counter;
  }
  while ( counter < 10 );
  ::ptr = CompressFile("news.txt", &OutSize, &NewsTxtFileChecksum, a4, 0x11u, 1, 0);
  SetConsoleTitleA(BillingServerName);
  dword_4C8F3C = 1;
  memset(SomeArrayOf256_1, 0, sizeof(SomeArrayOf256_1));
  memset(SomeArrayOf256_2, 0, sizeof(SomeArrayOf256_2));
  memset(dword_431BC0, 0, sizeof(dword_431BC0));
  RadarValue = 0;
  ScreenValue = 0;
  ServerIterations = 0;
  DoubleValue = 0;
  Wave = 0;
  SmallServerStruct = 0;
  ServerStruct = 0;
  BillingConnectionStructPointer = 0;
  if ( dword_42C840 )
  {
    v11 = GetTickCount() / 0xA;
    v12 = GetTickCount() / 0xA;
    ptr = v12;
    ServerBigStruct = operator new(0x8C5Cu);
    v51 = 2;
    if ( ServerBigStruct )
      StartServerListener(ServerBigStruct, 0, 0, 16, 0, 0x2000, 0x2000, 1);
    else
      ServerBigStructt = 0;
    v51 = -1;
    ServerStruct = ServerBigStructt;
    BillingServerConnection = 0;
    while ( abs32(GetTickCount() / 0xA - v12) < BillingAttemptTime )
    {
      if ( !BillingServerConnection )
      {
        WriteSubGameLog("Attempting to establish link to billing server...\n");
        GetTickCountDividedByTen = GetTickCount() / 0xA;
        RandomValue = rand();
        BillingServerConnection = SomethingBillerServer(
                                    ServerStruct,
                                    &BillingIP,
                                    *&BillingPort,
                                    ((GetTickCountDividedByTen + RandomValue) >> 31)
                                  - (((GetTickCountDividedByTen + RandomValue) >> 31) ^ (GetTickCountDividedByTen
                                                                                       + RandomValue)),
                                    0,
                                    v44);
        v11 = GetTickCount() / 0xA;
      }
      PlayerDoNetworkOps(ServerStruct);
      if ( CheckIfBillingServerIsConnected(BillingServerConnection) == 2 )
        break;
      if ( abs32(GetTickCount() / 0xA - v11) > 2000 )
      {
        sub_41B7A0(BillingServerConnection);
        ServerStructt = ServerStruct;
        BillingServerConnection = 0;
        if ( ServerStruct )
        {
          CleanUpPacketAttachment(ServerStruct);
          operator delete(ServerStructt);
        }
        ServerStructtt = operator new(0x8C5Cu);
        v51 = 3;
        if ( ServerStructtt )
          StartServerListener(ServerStructtt, 0, 0, 16, 0, 0x2000, 0x2000, 1);
        else
          retPointer = 0;
        v12 = ptr;
        v51 = -1;
        ServerStruct = retPointer;
      }
      if ( console_input_wrapper() )
      {
        hConsoleHandle = getch();
        if ( (!hConsoleHandle || hConsoleHandle == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          exit(1);
        }
      }
    }
    if ( CheckIfBillingServerIsConnected(BillingServerConnection) == 2 )
    {
      WriteSubGameLog("Billing server connected.\n");
      v21 = operator new(0x18u);
      v51 = 4;
      if ( v21 )
      {
        SendBillerServerConnectPacket(
          v21,
          HandleBillerPacket,
          BillingServerName,
          BillingServerId,
          BillingGroupId,
          BillingScoreId,
          BillingPassword,
          ServerStruct,
          BillingServerConnection);
        v51 = -1;
        BillingConnectionStructPointer = v22;
      }
      else
      {
        v51 = -1;
        BillingConnectionStructPointer = 0;
      }
    }
    else
    {
      WriteSubGameLog("ERROR: Could not connect to billing server.\n");
      ServerStructttt = ServerStruct;
      BillingConnectionStructPointer = 0;
      if ( ServerStruct )
      {
        CleanUpPacketAttachment(ServerStruct);
        operator delete(ServerStructttt);
      }
      ServerStruct = 0;
      WriteSubGameLog("Starting server in stand-alone mode.\n");
      SmallServerStructt = operator new(12u);
      v51 = 5;
      if ( SmallServerStructt )
        ConnectSocket(SmallServerStructt, &BillingIP, BillingPort + 1, 0);
      else
        returnedSmallStruct = 0;
      v51 = -1;
      SmallServerStruct = returnedSmallStruct;
    }
  }
  if ( strlen(DirectoryIPAddresses) > 4 )
  {
    strcpy(Buffer, DirectoryIPAddresses);
    v26 = dword_431BC0;
    do
    {
      if ( !GetSplitNextDirectoryIP(cp, Buffer) )
        break;
      v27 = operator new(12u);
      v51 = 6;
      if ( v27 )
        ConnectSocket(v27, cp, DirectoryPort, 0);
      else
        v28 = 0;
      *v26 = v28;
      v26 += 4;
      v51 = -1;
    }
    while ( v26 < &MiscDisableSharewareShips );
  }
  ObsceneStructPointer = operator new(276u);
  v51 = 7;
  if ( ObsceneStructPointer )
    InitializeTextFile(ObsceneStructPointer, "obscene.txt", 1, 1);
  else
    ObsceneStructPointerRet = 0;
  v51 = -1;
  ObscenePointer = ObsceneStructPointerRet;
  IdBlockStructPointer = operator new(276u);
  v51 = 8;
  if ( IdBlockStructPointer )
    InitializeTextFile(IdBlockStructPointer, "idblock.txt", 0, 1);
  else
    IdBlockStructPointerRet = 0;
  v51 = -1;
  IDBlockPointer = IdBlockStructPointerRet;
  PermitStructPointer = operator new(276u);
  v51 = 9;
  if ( PermitStructPointer )
    InitializeTextFile(PermitStructPointer, "permit.txt", 0, 1);
  else
    PermitStructPointerRet = 0;
  v51 = -1;
  PermitPointer = PermitStructPointerRet;
  ModerateStructPointer = operator new(276u);
  v51 = 10;
  if ( ModerateStructPointer )
    InitializeTextFile(ModerateStructPointer, "moderate.txt", 0, 1);
  else
    ModerateStructPointerRet = 0;
  v51 = -1;
  ModeratePointer = ModerateStructPointerRet;
  ReservedStructPointer = operator new(276u);
  v51 = 11;
  if ( ReservedStructPointer )
    InitializeTextFile(ReservedStructPointer, "reserved.txt", 0, 1);
  else
    ReservedStructPointerRet = 0;
  v51 = -1;
  ReservedPointer = ReservedStructPointerRet;
  ServerListenPort = GetPrivateProfileIntWrapper("Misc", "Port", 0x17Eu, FileName);
  v39 = operator new(8u);
  v51 = 12;
  if ( v39 )
    v40 = ListenOnPort(v39, ServerListenPort + 1, nullsub_3);
  else
    v40 = 0;
  v51 = -1;
  Memory = v40;
  ArenaArrayLength = 0;
  Structv9 = operator new(0x8C5Cu);
  v51 = 13;
  if ( Structv9 )
    StartServerListener(
      Structv9,
      NewConnectionRequest,
      PlayerHandleGamePacketWrapperSomething,
      1024,
      ServerListenPort,
      CommsOutgoingBufferSize,
      CommsIncomingBufferSize,
      CommsPacketHistoryMax);
  else
    Structv9PointerRet = 0;
  v51 = -1;
  Structv9Pointer = Structv9PointerRet;
  sub_41A910(Structv9PointerRet, CommsEncryptMode);
  return sub_41B430(Structv9Pointer, CommsTransportBufferSize);
}
// 4125C8: variable 'v8' is possibly undefined
// 412663: variable 'v10' is possibly undefined
// 41278C: variable 'ServerBigStructt' is possibly undefined
// 412802: variable 'v44' is possibly undefined
// 4128CF: variable 'retPointer' is possibly undefined
// 4129B9: variable 'v22' is possibly undefined
// 412A5B: variable 'returnedSmallStruct' is possibly undefined
// 412AF4: variable 'v28' is possibly undefined
// 412B48: variable 'ObsceneStructPointerRet' is possibly undefined
// 412B87: variable 'IdBlockStructPointerRet' is possibly undefined
// 412BC6: variable 'PermitStructPointerRet' is possibly undefined
// 412C05: variable 'ModerateStructPointerRet' is possibly undefined
// 412C53: variable 'ReservedStructPointerRet' is possibly undefined
// 412D12: variable 'Structv9PointerRet' is possibly undefined
// 408300: using guessed type int nullsub_3(void);
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 42C840: using guessed type int dword_42C840;
// 431BC0: using guessed type int dword_431BC0[8];
// 431BE8: using guessed type int RadarValue;
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432000: using guessed type int LastTimeMasterCFGWasEdited;
// 432004: using guessed type int bRecycleServer;
// 437C18: using guessed type int DoubleValue;
// 4386D4: using guessed type int MachineIdArrayIndex;
// 438B10: using guessed type int ScreenValue;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4D89C8: using guessed type int Wave;

//----- (00412D50) --------------------------------------------------------
signed int __cdecl NewConnectionRequest(int addr_in, __int16 Port, int a3)
{
  signed int v3; // ebp
  int v4; // edi
  struct_PLAYER **v5; // esi
  struct_PLAYER **v6; // ebx
  struct_PLAYER *newPlayer; // eax
  struct_PLAYER *player; // eax
  int v9; // ecx
  struct_PLAYER *Memory; // [esp+10h] [ebp-10h]

  v3 = 0;
  if ( CurrentPlayerCount > 0 )
  {
    v4 = 0;
    v5 = playerPointerList;
    v6 = &playerPointerList[1];
    do
    {
      if ( (*v5)->IPAddressDWORD == addr_in && (*v5)->Port == Port )
      {
        printf("Connection broken because same ip/port requested another connection\n");
        sub_41CBD0((*v5)->encryptionPointer);
        Memory = *v5;
        if ( *v5 )
        {
          DisconnectUser(*v5);
          operator delete(Memory);
        }
        --CurrentPlayerCount;
        memcpy(v5, v6, 4 * (v4 + CurrentPlayerCount));
        --v3;
        v4 -= 0x3FFFFFFF;
        --v6;
        --v5;
      }
      ++v3;
      v4 += 0x3FFFFFFF;
      ++v6;
      ++v5;
    }
    while ( v3 < CurrentPlayerCount );
  }
  newPlayer = operator new(0x35Du);
  if ( newPlayer )
    player = CreateNewPlayer(newPlayer, addr_in, Port, a3);
  else
    player = 0;
  v9 = CurrentPlayerCount;
  playerPointerList[CurrentPlayerCount] = player;
  CurrentPlayerCount = v9 + 1;
  return 1;
}

//----- (00412E80) --------------------------------------------------------
void __cdecl PlayerHandleGamePacketWrapperSomething(int packet, int packetSize, int a3)
{
  struct PLAYER *player; // ecx

  player = PlayerList[*(a3 + 46)];
  if ( player )
    PlayerHandleGamePacket(player, packet, packetSize);
}

//----- (00412EB0) --------------------------------------------------------
void __cdecl ServerMainLoop()
{
  int (*GetTickCounttt)(void); // ebp
  signed int i; // ebx
  int v2; // eax
  int v3; // edi
  signed int v4; // edi
  struct_PLAYER **v5; // esi
  unsigned int v6; // esi
  signed int v7; // edi
  struct_PLAYER **v8; // esi
  signed int v9; // eax
  signed int arenaCounter; // edi
  char *v11; // esi
  struct_PLAYER *v12; // ecx
  unsigned int GetTickCounttttt; // eax
  int v14; // edi
  struct_PLAYER **v15; // esi
  struct_PLAYER **v16; // ebp
  int v17; // edi
  struct_ARENA **Arenass; // esi
  struct_ARENA **v19; // ebp
  int v20; // eax
  DWORD (__stdcall *GetTickCountt)(); // ebp
  int v22; // ebx
  int counter; // esi
  KickStruct *v24; // ebp
  KickStruct *v25; // edi
  __int64 v26; // rax
  DWORD GetTickCounttttttt; // eax
  void **v28; // esi
  int v29; // edi
  struct_ARENA **v30; // esi
  char *v31; // esi
  struct TEXT_FILE_STRUCT *v32; // ecx
  signed int v33; // edi
  struct_PLAYER **v34; // esi
  DWORD GetTickCountttttt; // eax
  int v36; // esi
  struct_PLAYER *buf; // [esp+10h] [ebp-1F4h]
  struct ARENA *bufa; // [esp+10h] [ebp-1F4h]
  DWORD LastLoopTime; // [esp+10h] [ebp-1F4h]
  DWORD v40; // [esp+14h] [ebp-1F0h]
  unsigned int v41; // [esp+18h] [ebp-1ECh]
  DWORD v42; // [esp+1Ch] [ebp-1E8h]
  unsigned int GetTickCountttt; // [esp+20h] [ebp-1E4h]
  int a4[4]; // [esp+24h] [ebp-1E0h] BYREF
  char v45; // [esp+34h] [ebp-1D0h]
  int v46; // [esp+38h] [ebp-1CCh] BYREF
  int TimeElapsed; // [esp+3Ch] [ebp-1C8h] BYREF
  __int16 a2[226]; // [esp+40h] [ebp-1C4h] BYREF

  GetTickCount();
  GetTickCount();
  v40 = GetTickCount() / 0xA;
  GetTickCount();
  GetTickCount();
  v42 = GetTickCount() / 0xA;
  GetTickCount();
  v41 = 0;
  dword_4D5920 = 0;
  if ( !bServerIsRunning )
  {
    GetTickCounttt = GetTickCount;
    for ( i = 0; ; i = 0 )
    {
      if ( bRecycleServer )
        return;
      GetTickCountttt = GetTickCounttt() / 0xAu;
      if ( console_input_wrapper() )
      {
        v2 = getch();
        if ( (!v2 || v2 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          bServerIsRunning = 1;
          return;
        }
      }
      if ( BillingConnectionStructPointer )
      {
        if ( IsBillingServerDisconnected(BillingConnectionStructPointer) )
        {
          WriteSubGameLog("Connection to billing server broken\n");
          bRecycleServer = 1;
        }
        v3 = GetBillingLastReconnectTime(BillingConnectionStructPointer);
        if ( (GetTickCounttt() / 0xAu - v3) > BillingReconnectTime )
        {
          WriteSubGameLog("Connection to billing server timed out\n");
          bRecycleServer = 1;
        }
        if ( bRecycleServer )
        {
          v4 = 0;
          if ( CurrentPlayerCount > 0 )
          {
            v5 = playerPointerList;
            do
            {
              if ( (*v5)->MyArena )
                SendMessage(*v5, "NOTICE: Server recycling, please log back in shortly.", 1);
              ++v4;
              ++v5;
            }
            while ( v4 < CurrentPlayerCount );
          }
          SendPacketsToEverybody(Structv9Pointer);
        }
      }
      ProcessZonePings(Memory, CurrentPlayerCount);
      v6 = GetTickCounttt() / 0xAu;
      if ( PlayerDoNetworkOps(Structv9Pointer) )
      {
        while ( (GetTickCounttt() / 0xAu - v6) < CPUProcessMaxTime && PlayerDoNetworkOps(Structv9Pointer) )
          ;
      }
      v7 = 0;
      if ( CurrentPlayerCount > 0 )
      {
        v8 = playerPointerList;
        do
        {
          if ( (*v8)->field_FD )
            SendWeaponPacket(*v8);
          ++v7;
          ++v8;
        }
        while ( v7 < CurrentPlayerCount );
      }
      SendPacketsToEverybody(Structv9Pointer);
      v9 = IncreasesRadarValueSomeHow;
      ScreenValue += dword_4D55D0;
      arenaCounter = 0;
      DoubleValue += dword_4C8F38;
      dword_4D55D0 = 0;
      dword_4C8F38 = 0;
      RadarValue += IncreasesRadarValueSomeHow;
      if ( IncreasesRadarValueSomeHow > 0 )
      {
        v11 = &BillingIP.gap_36[99];
        do
        {
          v12 = PlayerList[*(v11 - 25)];
          if ( v12 )
          {
            sub_40DEA0(v12, v11 - 21, *v11, *v11);
            v9 = IncreasesRadarValueSomeHow;
          }
          ++arenaCounter;
          v11 += 26;
        }
        while ( arenaCounter < v9 );
      }
      IncreasesRadarValueSomeHow = 0;
      if ( abs32(GetTickCounttt() / 0xAu - v40) > 30 )
      {
        GetTickCounttttt = GetTickCounttt();
        HighestPlayerCountMaybeSomething = 0;
        v40 = GetTickCounttttt / 0xA;
        if ( CurrentPlayerCount > 0 )
        {
          v14 = 0;
          v15 = playerPointerList;
          v16 = &playerPointerList[1];
          do
          {
            if ( sub_40CF10(*v15) )
            {
              buf = *v15;
              --CurrentPlayerCount;
              memcpy(v15, v16, 4 * (v14 + CurrentPlayerCount));
              if ( buf )
              {
                DisconnectUser(buf);
                operator delete(buf);
              }
              --i;
              v14 -= 0x3FFFFFFF;
              --v16;
              --v15;
            }
            ++i;
            v14 += 0x3FFFFFFF;
            ++v16;
            ++v15;
          }
          while ( i < CurrentPlayerCount );
          i = 0;
        }
        if ( ArenaArrayLength > 0 )
        {
          v17 = 0;
          Arenass = Arenas;
          v19 = &Arenas[1];
          do
          {
            LOBYTE(v20) = ProcessArena(*Arenass);
            if ( v20 )
            {
              if ( (*Arenass)->ArenaName[0] )
                WriteSubGameLog("Private arena dropped: %s\n", (*Arenass)->ArenaName);
              else
                WriteSubGameLog("Arena dropped\n");
              bufa = *Arenass;
              if ( *Arenass )
              {
                ShutdownArena(*Arenass);
                operator delete(bufa);
              }
              --ArenaArrayLength;
              memcpy(Arenass, v19, 4 * (v17 + ArenaArrayLength));
              --i;
              v17 -= 0x3FFFFFFF;
              --v19;
              --Arenass;
            }
            ++i;
            v17 += 0x3FFFFFFF;
            ++v19;
            ++Arenass;
          }
          while ( i < ArenaArrayLength );
        }
      }
      SendPacketsToEverybody(Structv9Pointer);
      ++ServerIterations;
      if ( (GetTickCount() / 0xA - oldTickCountValue) > 6000 )
      {
        GetTickCountt = GetTickCount;
        memset(SomeArrayOf256_1, 0, sizeof(SomeArrayOf256_1));
        v22 = 0;
        memset(SomeArrayOf256_2, 0, sizeof(SomeArrayOf256_2));
        RadarValue = 0;
        ScreenValue = 0;
        ServerIterations = 0;
        DoubleValue = 0;
        Wave = 0;
        oldTickCountValue = GetTickCount() / 0xA;
        sub_41B3D0(Structv9Pointer);
        if ( MachineIdArrayIndex <= 0 )
          goto SKIP_KICKED_USERS;
        counter = 0;
        v24 = KickedUsers;
        v25 = &KickedUsers[1];
        do
        {                                       // Process Kicked Users
          v26 = (GetTickCount() / 0xA - KickedUsers[counter].KickStartTime);
          if ( ((HIDWORD(v26) ^ v26) - HIDWORD(v26)) > KickedUsers[counter].KickDelayMilliseconds )
          {
            --MachineIdArrayIndex;
            memcpy(v24, v25, 12 * MachineIdArrayIndex - counter * 12);
            --v22;
            --counter;
            --v25;
            --v24;
          }
          ++v22;
          ++counter;
          ++v25;
          ++v24;
        }
        while ( v22 < MachineIdArrayIndex );
      }
      GetTickCountt = GetTickCount;
SKIP_KICKED_USERS:
      if ( abs32(GetTickCountt() / 0xA - v41) > 6000 )
      {
        GetTickCounttttttt = GetTickCountt();
        memset(a2, 0, 0x1C0u);
        v41 = GetTickCounttttttt / 0xA;
        a2[224] = 0;
        a2[1] = CurrentPlayerCount;
        a2[2] = BillingConnectionStructPointer != 0;
        *&a2[3] = 134;
        a2[0] = ServerListenPort;
        strncpy(&a2[5], BillingServerName, 0x20u);
        HIBYTE(a2[20]) = 0;
        strncpy(&a2[21], buffer, 0x10u);
        HIBYTE(a2[28]) = 0;
        strncpy(&a2[45], DirectoryDescription, 0xFAu);
        HIBYTE(a2[169]) = 0;
        v28 = dword_431BC0;
        do
        {
          if ( *v28 )
          {
            SendDirectoryServerZoneUpdatePacket(*v28, a2, strlen(&a2[45]) + 91);
            GetSocketRecvLag(*v28, &TimeElapsed);
          }
          ++v28;
        }
        while ( v28 < &MiscDisableSharewareShips );
      }
      if ( abs32(GetTickCountt() / 0xA - v42) > 18000 || dword_4D5920 )
      {
        LastLoopTime = GetTickCountt() / 0xA;
        if ( SmallServerStruct && !BillingConnectionStructPointer )
          SendDirectoryServerZoneUpdatePacket(SmallServerStruct, 0, 0);
        dword_4C8F3C = 1;
        dword_4D5920 = 0;
        v42 = GetTickCountt() / 0xA;
        if ( IsFileLastWrittenTime(FileName, &LastTimeServerINIWasEdited) )
        {
          printf("INI settings different, re-reading\n");
          ReadServerINI();
          sub_41A910(Structv9Pointer, CommsEncryptMode);
          sub_41B430(Structv9Pointer, CommsTransportBufferSize);
        }
        if ( IsFileLastWrittenTime(FileName2, &LastTimeMasterCFGWasEdited) )
        {
          printf("Master CFG settings different, re-reading\n");
          LoadZoneCFGSettings(&ArenaSettings, &ServersideArenaSettings, FileName2);
          v29 = 0;
          if ( ArenaArrayLength > 0 )
          {
            v30 = Arenas;
            do
            {
              if ( !_strcmpi((*v30)->szConfigFile, FileName2) )
                (*v30)->playerPointersForSomething[250] = 1;
              ++v29;
              ++v30;
            }
            while ( v29 < ArenaArrayLength );
          }
        }
        v31 = &SecurityArray[0].field_FC0;
        do
        {
          v32 = *(v31 - 1);
          if ( v32 )
            LoadTextFile(v32, 0);
          if ( *v31 )
            LoadTextFile(*v31, 0);
          v31 += 4036;
        }
        while ( v31 < &PlayerList[1006] );
        LoadTextFile(IDBlockPointer, 0);
        LoadTextFile(ObscenePointer, 0);
        LoadTextFile(PermitPointer, 0);
        LoadTextFile(ModeratePointer, 0);
        LoadTextFile(ReservedPointer, 0);
        a4[0] = 16;
        a4[1] = 0;
        a4[2] = 0;
        a4[3] = 0;
        v45 = 0;
        if ( IsFileLastWrittenTime("news.txt", &LastTimeNewsTxtWasEdited) )
        {
          if ( ptr )
            efree(ptr);
          ptr = CompressFile("news.txt", &OutSize, &NewsTxtFileChecksum, a4, 0x11u, 1, 0);
        }
        if ( SmallServerStruct && !BillingConnectionStructPointer && GetSocketRecvLag(SmallServerStruct, &v46) >= 0 )
        {
          v33 = 0;
          if ( CurrentPlayerCount > 0 )
          {
            v34 = playerPointerList;
            do
            {
              if ( (*v34)->MyArena )
                SendMessage(*v34, "NOTICE: Server recycling in order to restore scores, please log back in.", 1);
              ++v33;
              ++v34;
            }
            while ( v33 < CurrentPlayerCount );
          }
          SendPacketsToEverybody(Structv9Pointer);
          bRecycleServer = 1;
        }
        GetTickCountttttt = GetTickCountt();
        printf("Re-read Settings: %d ms\n", 10 * (GetTickCountttttt / 0xA - LastLoopTime));
        fflush(&File);
      }
      sub_41B570(100);
      v36 = GetTickCountt() / 0xA - GetTickCountttt;
      if ( v36 <= 2 || CPUSleepPerIteration )
        Sleep(CPUSleepTime);
      if ( v36 > CPUSlowIterationWarningLevel )
        WriteSubGameLog("Slow iteration warning: %d ms\n", 10 * v36);
      if ( bServerIsRunning )
        return;
      GetTickCounttt = GetTickCount;
    }
  }
}
// 4131FA: variable 'v20' is possibly undefined
// 431BC0: using guessed type int dword_431BC0[8];
// 431BE8: using guessed type int RadarValue;
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432000: using guessed type int LastTimeMasterCFGWasEdited;
// 432004: using guessed type int bRecycleServer;
// 437C18: using guessed type int DoubleValue;
// 437CA8: using guessed type int bServerIsRunning;
// 4386D4: using guessed type int MachineIdArrayIndex;
// 438B10: using guessed type int ScreenValue;
// 4C8F3C: using guessed type int dword_4C8F3C;
// 4D5920: using guessed type int dword_4D5920;
// 4D5924: using guessed type int LastTimeNewsTxtWasEdited;
// 4D89C8: using guessed type int Wave;
// 4D8AF4: using guessed type int oldTickCountValue;
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;

//----- (004137F0) --------------------------------------------------------
signed int __cdecl IncreaseRadarValueShowHomeOverFourThousand()
{
  signed int result; // eax
  signed int v1; // edi
  char *v2; // esi
  struct_PLAYER *v3; // ecx

  result = IncreasesRadarValueSomeHow;
  v1 = 0;
  RadarValue += IncreasesRadarValueSomeHow;
  if ( IncreasesRadarValueSomeHow > 0 )
  {
    v2 = &BillingIP.gap_36[99];
    do
    {
      v3 = PlayerList[*(v2 - 25)];
      if ( v3 )
      {
        sub_40DEA0(v3, v2 - 21, *v2, *v2);
        result = IncreasesRadarValueSomeHow;
      }
      ++v1;
      v2 += 26;
    }
    while ( v1 < result );
  }
  IncreasesRadarValueSomeHow = 0;
  return result;
}
// 431BE8: using guessed type int RadarValue;

//----- (00413850) --------------------------------------------------------
void __cdecl ServerUninitialize()
{
  UINT v0; // eax
  bool v1; // cc
  struct_PLAYER **v2; // edi
  UINT v3; // ebx
  struct_PLAYER *v4; // esi
  int v5; // ebx
  struct ARENA **v6; // edi
  struct ARENA *v7; // esi
  struct_v9 *v8; // esi
  void *v9; // esi
  void *v10; // esi
  struct BILLING_SERVER_STRUCT *v11; // esi
  struct_v9 *v12; // esi
  SOCKET **v13; // edi
  SOCKET *v14; // esi
  CHAR *v15; // esi
  CHAR *v16; // esi
  CHAR *v17; // esi
  CHAR *v18; // esi
  CHAR *v19; // esi
  TEXT_FILE_STRUCT **v20; // ebx
  void *v21; // esi
  TEXT_FILE_STRUCT *v22; // esi
  LPVOID *v23; // esi
  int v24; // edi
  struct BMP_FILE_STRUCT *v25; // esi

  v0 = CurrentPlayerCount;
  v1 = CurrentPlayerCount <= 0;
  CurrentPlayerCount = 0;
  if ( !v1 )
  {
    v2 = playerPointerList;
    v3 = v0;
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        DisconnectUser(*v2);
        operator delete(v4);
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v5 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v6 = Arenas;
    do
    {
      v7 = *v6;
      if ( *v6 )
      {
        ShutdownArena(*v6);
        operator delete(v7);
      }
      ++v5;
      ++v6;
    }
    while ( v5 < ArenaArrayLength );
  }
  ArenaArrayLength = 0;
  if ( PointsFileHandle )
  {
    fclose(PointsFileHandle);
    PointsFileHandle = 0;
  }
  v8 = Structv9Pointer;
  if ( Structv9Pointer )
  {
    CleanUpPacketAttachment(Structv9Pointer);
    operator delete(v8);
  }
  v9 = Memory;
  if ( Memory )
  {
    sub_408740(Memory);
    operator delete(v9);
  }
  v10 = SmallServerStruct;
  if ( SmallServerStruct )
  {
    sub_408740(SmallServerStruct);
    operator delete(v10);
  }
  v11 = BillingConnectionStructPointer;
  if ( BillingConnectionStructPointer )
  {
    CleanUpBilling(BillingConnectionStructPointer);
    operator delete(v11);
  }
  v12 = ServerStruct;
  if ( ServerStruct )
  {
    CleanUpPacketAttachment(ServerStruct);
    operator delete(v12);
  }
  v13 = dword_431BC0;
  do
  {
    v14 = *v13;
    if ( *v13 )
    {
      sub_408740(*v13);
      operator delete(v14);
    }
    ++v13;
  }
  while ( v13 < &MiscDisableSharewareShips );
  v15 = ObscenePointer;
  if ( ObscenePointer )
  {
    CleanTextFileMemory(ObscenePointer);
    operator delete(v15);
  }
  v16 = PermitPointer;
  if ( PermitPointer )
  {
    CleanTextFileMemory(PermitPointer);
    operator delete(v16);
  }
  v17 = ModeratePointer;
  if ( ModeratePointer )
  {
    CleanTextFileMemory(ModeratePointer);
    operator delete(v17);
  }
  v18 = ReservedPointer;
  if ( ReservedPointer )
  {
    CleanTextFileMemory(ReservedPointer);
    operator delete(v18);
  }
  v19 = IDBlockPointer;
  if ( IDBlockPointer )
  {
    CleanTextFileMemory(IDBlockPointer);
    operator delete(v19);
  }
  if ( ptr )
  {
    efree(ptr);
    ptr = 0;
  }
  v20 = &SecurityArray[0].field_FC0;
  do
  {
    v21 = *(v20 - 1);
    if ( v21 )
    {
      CleanTextFileMemory(*(v20 - 1));
      operator delete(v21);
    }
    v22 = *v20;
    if ( *v20 )
    {
      CleanTextFileMemory(*v20);
      operator delete(v22);
    }
    v23 = (v20 - 1008);
    v24 = 3;
    do
    {
      if ( *v23 )
      {
        efree(*v23);
        *v23 = 0;
      }
      ++v23;
      --v24;
    }
    while ( v24 );
    v20 += 1009;
  }
  while ( v20 < &PlayerList[1006] );
  v25 = BMPFile;
  if ( BMPFile )
  {
    sub_406B30(BMPFile);
    operator delete(v25);
  }
  efree(dword_437B0C);
  efree(MapAllocateMemoryPointer);
  CleanUpMemory();
  j_WSACleanup();
  if ( fileHandle )
    fclose(fileHandle);
  fileHandle = 0;
}
// 431BC0: using guessed type int dword_431BC0[8];
// 431FF4: using guessed type int ArenaArrayLength;

//----- (00413AE0) --------------------------------------------------------
void __usercall HandleBillerPacket(struct_ARENA **a1@<edi>, char *buffer, int a2)
{
  signed int playerCounter; // eax
  struct_PLAYER **playerPointerCounter; // esi
  int v5; // edx
  struct_PLAYER **k; // eax
  int v7; // ecx
  struct_PLAYER **j; // eax
  struct_PLAYER *v9; // esi
  int v10; // ecx
  struct_PLAYER **i; // eax
  struct_PLAYER *v12; // ebp
  char LoginCommand; // al
  __int16 v14; // ax
  __int16 *v15; // ebx
  char *v16; // eax
  struct_PLAYER **v17; // esi
  struct_ARENA *v18; // eax
  int v19; // eax
  int v20; // ecx
  struct_PLAYER *v21; // edi
  bool v22; // cc
  int v23; // ecx
  int v24; // eax
  int SubspaceEXEChecksum; // ecx
  int v26; // edx
  int v27; // eax
  char LoginResponse; // [esp+13h] [ebp-835h] BYREF
  int v29; // [esp+14h] [ebp-834h]
  char *v30; // [esp+18h] [ebp-830h]
  void *Src; // [esp+1Ch] [ebp-82Ch]
  int v32; // [esp+20h] [ebp-828h]
  char buf[256]; // [esp+24h] [ebp-824h] BYREF

  switch ( *buffer )
  {
    case 1:                                     // 0x01 - Player Response
      v10 = 0;
      v29 = a2 - 178;
      v30 = buffer + 178;
      if ( CurrentPlayerCount > 0 )
      {
        for ( i = playerPointerList; ; ++i )
        {
          v12 = *i;
          if ( (*i)->BillerPlayerId == *(buffer + 2) )// PlayerId
            break;
          if ( ++v10 >= CurrentPlayerCount )
            return;
        }
        LoginCommand = buffer[1];               // Login Command Byte
        LoginResponse = 10;
        v32 = 0;
        switch ( LoginCommand )
        {
          case 0:                               // PRMEANING_ENTER
          case 6:                               // PRMEANING_DEMO
            LoginResponse = 0;
            if ( LoginCommand == 6 )            // PRMEANING_DEMO  
              v32 = 1;
            v15 = &v12->CurrentWins;
            qmemcpy(v12->Name, buffer + 6, 172u);// 24+24+96+4+2+2+2+2+2+2+4+4+4
            if ( v29 == 14 )
            {
              v16 = v30;
              *v15 = *v30;
              *&v12->GoalCount = *(v16 + 1);    // 182 - 2 - GoalCount
              *(&v12->KillPoints + 2) = *(v16 + 2);// 184 - 4 - Points
              HIWORD(v12->FlagPoints) = *(v16 + 6);// 188 - 4 - Event Points
            }
            else
            {
              *v15 = 0;
              *&v12->GoalCount = 0;
              *(&v12->KillPoints + 2) = 0;
              HIWORD(v12->FlagPoints) = 0;
            }
            if ( v12->DemoPlayer )
            {
              *v15 = 0;
              *&v12->GoalCount = 0;
              *(&v12->KillPoints + 2) = 0;
              HIWORD(v12->FlagPoints) = 0;
            }
            *&v12->PersonalBestWins = *v15;
            *&v12->field_235 = *&v12->GoalCount;
            *&v12->Points = *(&v12->KillPoints + 2);
            v12->FlagPointsHiWord = HIWORD(v12->FlagPoints);
            if ( !v12->isModerator )
            {
              if ( PermissionMaxPoints && v12->FlagPoints + v12->KillPoints > PermissionMaxPoints )
                LoginResponse = 7;
              if ( v12->UsageTotalSeconds < PermissionMinimumSecondsToLogin )
                LoginResponse = 15;
            }
            v30 = 0;
            if ( CurrentPlayerCount > 0 )
            {
              v29 = 0;
              v17 = playerPointerList;
              Src = &playerPointerList[1];
              do
              {
                if ( *v17 != v12 && !_strcmpi((*v17)->Name, v12->Name) )
                {
                  WriteSubGameLog("Player %s already on, kicking them off (lost connection probably)\n", v12->Name);
                  v18 = v12->MyArena;
                  if ( v18 )
                  {
                    if ( !v18->ServersideArenaSettings.MiscTimedGame )
                    {
                      v19 = &(*v17)->CurrentWins;
                      if ( *v19 + (*v17)->KillPoints + (*v17)->FlagPoints + (*v17)->CurrentLosses > *v15 + v12->FlagPoints + v12->KillPoints + v12->CurrentLosses )
                      {
                        *v15 = *v19;
                        *&v12->GoalCount = *(v19 + 4);
                        *(&v12->KillPoints + 2) = *(v19 + 8);
                        HIWORD(v12->FlagPoints) = *(v19 + 12);
                        v20 = &(*v17)->PersonalBestWins;
                        *&v12->PersonalBestWins = *v20;
                        *&v12->field_235 = *(v20 + 4);
                        *&v12->Points = *(v20 + 8);
                        v12->FlagPointsHiWord = *(v20 + 12);
                      }
                    }
                  }
                  v21 = *v17;
                  if ( *v17 )
                  {
                    DisconnectUser(*v17);
                    operator delete(v21);
                  }
                  --CurrentPlayerCount;
                  memcpy(v17, Src, 4 * (v29 + CurrentPlayerCount));
                  --v30;
                  v29 -= 0x3FFFFFFF;
                  Src = Src - 4;
                  --v17;
                }
                v29 += 0x3FFFFFFF;
                ++v17;
                v22 = ++v30 < CurrentPlayerCount;
                Src = Src + 4;
              }
              while ( v22 );
            }
            if ( PermissionMode == 2 && !v12->isModerator && IsBannedMachineId(PermitPointer, v12->PlayerName) < 0 )
              goto LABEL_71;
            break;
          case 1:                               // PRMEANING_ASK
            LoginResponse = 1;
            break;
          case 2:                               // PRMEANING_BADPW
            LoginResponse = 2;
            v12->DisconnectReason = 18;
            v12->KickOffDelayTimer = GetTickCount() / 0xA;
            break;
          case 3:                               // PRMEANING_IPBLOCK
            LoginResponse = 4;
            WriteSubGameLog("Player kicked off for IP block: %s\n", v12->PlayerName);
            v12->DisconnectReason = 11;
            v12->AlreadySentReliablePacket = 1;
            break;
          case 4:                               // PRMEANING_NONEW
            LoginResponse = 10;
            break;
          case 5:                               // PRMEANING_BADNAME
            LoginResponse = 11;
            break;
          case 7:                               // PRMEANING_BUSY
            LoginResponse = 14;
            break;
          case 8:                               // PRMEANING_REGFORM
            LoginResponse = 16;
            *&v12->CurrentWins = 0;
            *&v12->GoalCount = 0;
            *(&v12->KillPoints + 2) = 0;
            HIWORD(v12->FlagPoints) = 0;
            *&v12->PersonalBestWins = *&v12->CurrentWins;
            *&v12->field_235 = *&v12->GoalCount;
            v14 = HIWORD(v12->FlagPoints);
            *&v12->Points = *(&v12->KillPoints + 2);
            v12->FlagPointsHiWord = v14;
            qmemcpy(v12->Name, buffer + 6, 172u);// 24+24+96+4+2+2+2+2+2+2+4+4+4
            strcpy(v12->Name, v12->PlayerName);
            v12->BillerPlayerId = -1;
            if ( PermissionMode == 2 && !v12->isModerator )
            {
LABEL_71:
              LoginResponse = 6;
              v12->IsSpeced = 1;
            }
            break;
          default:
            break;
        }
        buf[1] = LoginResponse;                 // Login Response
        v23 = v12->SubspaceEXEChecksumIndex;
        *&buf[24] = NewsTxtFileChecksum;        // News.txt Checksum
        buf[19] = v32;                          // Registration Form Request (Boolean)
        buf[0] = 0xA;                           // 0x0A - Password Packet Response
        v24 = v23;
        *&buf[2] = 134;                         // Server Version
        *&buf[6] = 0;                           // ? Unknown
        SubspaceEXEChecksum = SecurityArray[v23].SubspaceEXEChecksum;
        v26 = *&SecurityArray[v24].ScrtyData[4];
        v27 = v12->isModerator;
        *&buf[14] = 0;                          // ? Unknown
        buf[18] = 0;                            // ? Unknown
        *&buf[10] = SubspaceEXEChecksum;        // Subspace.exe Checksum
        *&buf[20] = v26;                        // ? Unknown
        if ( v27 )
        {
          *&buf[10] = -1;
          *&buf[20] = -1;
        }
        SendPlayerReliablePacket(v12, buf, 0x24u, 1);
        if ( !v12->DemoPlayer )
        {
          LoginResponse = 0x31;                 // 0x31 - Post Login Sequence
          SendPlayerReliablePacket(v12, &LoginResponse, 1u, 1);
        }
      }
      break;
    case 2:                                     // 0x02 - Shutdown server packet
      WriteSubGameLog("Shutdown packet received, shutting down server...\n");
      bServerIsRunning = 1;
      break;
    case 3:                                     // 0x03 - Player Private Chat
      if ( buffer[5] == 1 )
      {
        if ( IsBannedMachineId(PermitPointer, buffer + 6) < 0 )
        {
          AddLineTextFile(PermitPointer, buffer + 6);
          WriteTextFileToFile(PermitPointer);
        }
      }
      else if ( buffer[5] == 2 )
      {
        if ( buffer[7] == 58 )
          ChatProcessor(a1, 0, 7, 0, buffer + 7, buffer[6]);
        else
          ChatProcessor(a1, 0, 0, 0, buffer + 7, buffer[6]);
      }
      break;
    case 4:                                     // 0x04 - Zone Recycle
      bRecycleServer = 1;
      break;
    case 8:                                     // 0x08 - Kick Player
      v7 = 0;
      if ( CurrentPlayerCount > 0 )
      {
        for ( j = playerPointerList; ; ++j )
        {
          v9 = *j;
          if ( (*j)->BillerPlayerId == *(buffer + 1) )
            break;
          if ( ++v7 >= CurrentPlayerCount )
            return;
        }
        WriteSubGameLog("Player kicked off by billing server, reason #%d\n", *(buffer + 5));
        v9->DisconnectReason = 21;
        v9->AlreadySentReliablePacket = 1;
      }
      break;
    case 9:                                     // 0x09 - Command Message
      v5 = 0;
      if ( CurrentPlayerCount > 0 )
      {
        for ( k = playerPointerList; (*k)->BillerPlayerId != *(buffer + 1); ++k )
        {
          if ( ++v5 >= CurrentPlayerCount )
            return;
        }
        SendMessage(*k, buffer + 5, 0);
      }
      break;
    case 0xA:                                   // 0x0A - Chat Message
      playerCounter = 0;
      playerPointerCounter = playerPointerList;
      if ( CurrentPlayerCount > 0 )
      {
        while ( (*playerPointerCounter)->BillerPlayerId != *(buffer + 1) )
        {
          ++playerCounter;
          ++playerPointerCounter;
          if ( playerCounter >= CurrentPlayerCount )
            return;
        }
        sprintf(&buf[36], "%d:%s", buffer[5], buffer + 6);
        SendChannelMessage(*playerPointerCounter, &buf[36]);
      }
      break;
    default:
      return;
  }
}
// 413F2A: conditional instruction was optimized away because of 'eax.4==0'
// 432004: using guessed type int bRecycleServer;
// 437CA8: using guessed type int bServerIsRunning;

//----- (004141F0) --------------------------------------------------------
void FormatMessageArena(struct_ARENA *arena, const char *Format, ...)
{
  struct tm *v2; // eax
  char *v3; // eax
  int v4; // edi
  struct_PLAYER **v5; // esi
  FILE *v6; // eax
  char Str[132]; // [esp+Ch] [ebp-484h] BYREF
  char v8[512]; // [esp+90h] [ebp-400h] BYREF
  char Dest[512]; // [esp+290h] [ebp-200h] BYREF
  va_list Args; // [esp+49Ch] [ebp+Ch] BYREF

  va_start(Args, Format);
  time(Str);
  v2 = localtime(Str);
  strcpy(&Str[4], asctime(v2));
  v3 = strstr(&Str[4], " 199");
  if ( v3 || (v3 = strstr(&Str[4], " 200")) != 0 )
    *v3 = 0;
  vsprintf(v8, Format, Args);
  sprintf(Dest, "%s:  %s", &Str[4], v8);
  v4 = 0;
  if ( arena->ArenaPlayerCount > 0 )
  {
    v5 = arena->playerPointersForSomething;
    do
    {
      v6 = (*v5)->pfile329;
      if ( v6 )
        fprintf(v6, "%s", Dest);
      ++v4;
      ++v5;
    }
    while ( v4 < arena->ArenaPlayerCount );
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (00414310) --------------------------------------------------------
void WriteSubGameLog(const char *Format, ...)
{
  FILE *v1; // eax
  struct tm *v2; // eax
  char *v3; // eax
  char *v4; // edx
  char *v5; // eax
  char v6; // cl
  char Str[132]; // [esp+8h] [ebp-484h] BYREF
  char Dest[512]; // [esp+8Ch] [ebp-400h] BYREF
  char v9[512]; // [esp+28Ch] [ebp-200h] BYREF
  va_list Args; // [esp+494h] [ebp+8h] BYREF

  va_start(Args, Format);
  v1 = fileHandle;
  if ( fileHandle )
    goto LABEL_5;
  if ( MiscServerLog )
  {
    v1 = fopen("subgame.log", "at");
    fileHandle = v1;
  }
  if ( v1 )
  {
LABEL_5:
    if ( !MiscServerLog )
    {
      fclose(v1);
      fileHandle = 0;
    }
  }
  time(Str);
  v2 = localtime(Str);
  strcpy(&Str[4], asctime(v2));
  v3 = strstr(&Str[4], " 199");
  if ( v3 || (v3 = strstr(&Str[4], " 200")) != 0 )
    *v3 = 0;
  vsprintf(v9, Format, Args);
  sprintf(Dest, "%s:  %s", &Str[4], v9);
  if ( fileHandle )
    fprintf(fileHandle, "%s", Dest);
  printf("%s", Dest);
  v4 = &LogArray[256 * logLine];
  strcpy(v4, Dest);
  v5 = v4;
  if ( *v4 >= 32 )
  {
    do
      v6 = *++v5;
    while ( v6 >= 32 );
  }
  *v5 = 0;
  logLine = (logLine + 1) % 48;
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (004144C0) --------------------------------------------------------
bool __cdecl IsOffensiveName(char *a1)
{
  char *v1; // esi
  char *v2; // edi
  LPCSTR v4; // ecx
  int v5; // edi
  int v6; // esi
  const char *v7; // eax
  char *v8; // eax
  char Str[400]; // [esp+8h] [ebp-190h] BYREF

  v1 = a1;
  v2 = Str;
  if ( *a1 )
  {
    do
    {
      if ( isalpha(*v1) )
        *v2++ = toupper(*v1);
    }
    while ( *++v1 );
  }
  v4 = ObscenePointer;
  *v2 = 0;
  v5 = ListMachine(v4);
  v6 = 0;
  if ( v5 <= 0 )
  {
    LOBYTE(v8) = 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = ListMachineByIndex(ObscenePointer, v6);
      v8 = strstr(Str, v7);
      if ( v8 )
        break;
      if ( ++v6 >= v5 )
        return v8;
    }
    LOBYTE(v8) = 1;
  }
  return v8;
}

//----- (00414560) --------------------------------------------------------
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2)
{
  int v2; // ebp
  int v3; // ebx
  int v4; // edx
  unsigned int v5; // kr04_4
  signed int v6; // esi
  int v7; // eax
  const char *v8; // edx
  unsigned int v9; // ecx
  int v11; // edx
  unsigned int v12; // kr10_4
  signed int v13; // esi
  int v14; // ebp
  const char *v15; // edx
  unsigned int v16; // ecx
  int v17; // [esp+14h] [ebp-4h]
  int v18; // [esp+14h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+4h]

  v2 = 0;
  v3 = SecurityArrayIndex;
  v4 = *&SecurityArray[SecurityArrayIndex].field_FC0;
  if ( !v4 )
    goto LABEL_17;
  v19 = 1;
  v5 = strlen(a2) + 1;
  v6 = v5 - 1;
  if ( v5 == 1 )
  {
    v19 = 0;
  }
  else
  {
    v7 = ListMachine(v4);
    v17 = v7;
    if ( v7 )
    {
      if ( v7 > 0 )
      {
        while ( 1 )
        {
          v8 = ListMachineByIndex(SecurityArray[v3].field_FBC, v2);
          if ( v6 >= strlen(v8) )
            v9 = strlen(v8);
          else
            v9 = v6;
          if ( !memcmp(a2, v8, v9) )
            v19 = 0;
          if ( ++v2 >= v17 )
            break;
          v6 = v5 - 1;
        }
      }
    }
    else
    {
      v19 = 0;
    }
  }
  if ( v19 )
    return 1;
LABEL_17:
  v11 = SecurityArray[v3].field_FBC;
  if ( !v11 )
    return 0;
  v12 = strlen(a2) + 1;
  v13 = v12 - 1;
  if ( v12 == 1 )
    return 0;
  v14 = 0;
  v18 = ListMachine(v11);
  if ( v18 <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = ListMachineByIndex(SecurityArray[v3].field_FBC, v14);
    v16 = v13 >= strlen(v15) ? strlen(v15) : v13;
    if ( !memcmp(a2, v15, v16) )
      break;
    if ( ++v14 >= v18 )
      return 0;
    v13 = v12 - 1;
  }
  return 1;
}

//----- (004146D0) --------------------------------------------------------
void __cdecl SendBillerWarnings(const char *a1, struct_PLAYER *player)
{
  int v2; // eax
  char *v3; // eax
  signed int v4; // esi
  int v5; // ebx
  struct_PLAYER *v6; // edx
  int v7; // [esp-4h] [ebp-414h]
  int v8; // [esp-4h] [ebp-414h]
  char Args[490]; // [esp+10h] [ebp-400h] BYREF
  char buf[512]; // [esp+210h] [ebp-200h] BYREF

  strcpy(Args, a1);
  if ( player )
  {
    v7 = player->TotalUsageSeconds2;
    v2 = time(0);
    v8 = difftime(v2, v7);
    v3 = GetIPAddressString(player->IPAddressDWORD);
    sprintf(Args, "%s (%s)(%d)(%s)(sec=%d)", a1, player->PlayerName, player->MachineId, v3, v8);
  }
  WriteSubGameLog("%s\n", Args);
  *&buf[3] = -1;                                // Originator ID
  buf[0] = 7;                                   // 0x07 - Chat
  buf[1] = 8;                                   // Chat Type - 0x08 - Red server errors, without a name tag (S2C only)
  buf[2] = 0;                                   // Sound Byte
  strcpy(&buf[5], Args);                        // Chat Message
  v4 = 0;
  if ( CurrentPlayerCount > 0 )
  {
    v5 = playerPointerList;
    do
    {
      v6 = *v5;
      if ( *(*v5 + 28) && v6->isSysop )         // +28 = player->lpCurrentArena (just buggy with DWORD crap in front).
        SendPlayerReliablePacket(v6, buf, strlen(Args) + 6, 1);
      ++v4;
      v5 += 4;
    }
    while ( v4 < CurrentPlayerCount );
  }
  if ( BillingConnectionStructPointer )
  {
    if ( player )
      SendBillerWarningPacket(BillingConnectionStructPointer, player->BillerPlayerId, Args);
    else
      SendBillerWarningPacket(BillingConnectionStructPointer, 0, Args);
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (00414850) --------------------------------------------------------
void __usercall ChatProcessor(struct_ARENA **a1@<edi>, struct_PLAYER *player, int a3, signed int arenaPlayerIndex, char *ChatText, char SoundByte)
{
  struct _EXCEPTION_REGISTRATION_RECORD *v6; // eax
  void *v7; // esp
  char *sentCommand; // ebx
  struct_PLAYER *v9; // ebp
  signed int v10; // edi
  struct_ARENA *v11; // edx
  UINT v12; // ecx
  int v13; // esi
  int v14; // eax
  char v15; // al
  const char *v16; // ebx
  struct BILLING_SERVER_STRUCT *v17; // edx
  struct_PLAYER *v18; // eax
  int v19; // esi
  const char *v20; // ecx
  int v21; // edx
  signed int GetTickCountDifference; // ebx
  struct_ARENA *v23; // eax
  int v24; // esi
  int v25; // edi
  int v26; // eax
  struct_ARENA **v27; // ecx
  int v28; // esi
  int MemoryUsage; // edi
  int v30; // esi
  int v31; // ecx
  int v32; // eax
  char v33; // al
  char *v34; // ebx
  char v35; // al
  char v36; // al
  char *v37; // ebx
  char v38; // al
  char v39; // al
  char *v40; // ebx
  char v41; // al
  struct TEXT_FILE_STRUCT *v42; // ebx
  const char *listMachineBuffer; // edx
  const char *v44; // edi
  int listMachineCount; // edi
  int n; // esi
  const char *bufferr; // eax
  int logCounter; // esi
  const char *shutdownArguments; // ebx
  struct_PLAYER *playerrrr; // eax
  int isSysop; // edx
  BOOL isSYsopp; // ecx
  struct_PLAYER *playerr; // eax
  int isSuperModerator; // edx
  BOOL isSuperModeratorr; // ecx
  char v56; // cl
  char *v57; // eax
  char *ii; // edx
  char v59; // cl
  char v60; // cl
  char *v61; // eax
  char *jj; // edx
  char v63; // cl
  char v64; // cl
  _BYTE *v65; // eax
  char *kk; // edx
  char *v67; // eax
  char v68; // al
  char *v69; // esi
  char *ll; // ecx
  char v71; // al
  char v72; // al
  _BYTE *v73; // esi
  char *mm; // ecx
  CHAR v75; // al
  _BYTE *v76; // esi
  CHAR *nn; // ecx
  char *v78; // ebx
  struct CONNECTION **v79; // edx
  char v80; // al
  char *v81; // ebx
  char v82; // al
  struct_ARENA *v83; // eax
  unsigned int v84; // kr44_4
  signed int v85; // edi
  struct_PLAYER **v86; // ebx
  struct_PLAYER *v87; // ecx
  struct_PLAYER *v88; // esi
  char *IpAddress; // eax
  struct_ARENA *v90; // eax
  int v91; // ecx
  int v92; // eax
  Encryption_Struct *v93; // ecx
  int v94; // edi
  int v95; // edx
  int v96; // edi
  double v97; // st7
  int v98; // eax
  int v99; // ecx
  int v100; // eax
  double v101; // st7
  int v102; // ecx
  int v103; // edx
  int v104; // edi
  int v105; // eax
  int v106; // edi
  int v107; // ecx
  Encryption_Struct *v108; // ecx
  struct_PLAYER *v109; // eax
  int v110; // edx
  char v111; // al
  const char *v112; // edi
  char v113; // al
  char v114; // al
  bool v115; // zf
  __int16 v116; // ax
  struct_PLAYER *v117; // edi
  struct_ARENA *v118; // eax
  int v119; // ecx
  int v120; // edx
  struct_PLAYER *v121; // eax
  struct_ARENA *v122; // eax
  int v123; // ecx
  int v124; // edx
  struct_PLAYER *v125; // eax
  struct_PLAYER *v126; // eax
  char *v127; // eax
  char v128; // al
  char *v129; // edi
  char v130; // al
  struct_ARENA *v131; // eax
  unsigned int v132; // kr58_4
  char v133; // al
  char *v134; // edi
  char v135; // al
  char v136; // al
  char *v137; // edi
  char v138; // al
  struct TEXT_FILE_STRUCT *v139; // eax
  __int16 v140; // ax
  struct_PLAYER *v141; // esi
  int v142; // edx
  char v143; // al
  const char *v144; // edi
  char v145; // al
  struct_PLAYER *playerrrrr; // esi
  int v147; // edx
  struct_PLAYER *v148; // esi
  int v149; // edi
  int v150; // eax
  int v151; // esi
  int v152; // eax
  struct_ARENA *arena; // ecx
  int v154; // edi
  int v155; // esi
  struct_PLAYER *playerrrrrr; // ecx
  signed int v157; // edi
  struct_PLAYER **v158; // esi
  PLAYER *playerrrrrrr; // ecx
  struct_ARENA *v160; // ecx
  FILE *v161; // eax
  const char *v162; // edi
  int v163; // ebx
  int v164; // eax
  FILE *v165; // eax
  struct_ARENA *v166; // eax
  int v167; // esi
  int v168; // edi
  const char *v169; // esi
  int v170; // edx
  int v171; // eax
  int UsageSessionSeconds; // esi
  const char *i; // ebx
  int j; // ebx
  char *v175; // eax
  int v176; // ecx
  const char *v177; // edi
  int v178; // ebx
  int v179; // esi
  struct_ARENA *v180; // edx
  int v181; // eax
  int v182; // esi
  int v183; // edi
  int *v184; // edx
  int v185; // ecx
  struct_ARENA *v186; // eax
  int v187; // edx
  int v188; // ecx
  __int16 v189; // ax
  int v190; // eax
  int v191; // ecx
  int v192; // eax
  int UserIdInArenaSettings; // eax
  struct_ARENA *v194; // ecx
  char *v195; // eax
  char *v196; // edx
  char *v197; // ebx
  struc_2 *v198; // eax
  struct_ARENA **v199; // esi
  char *v200; // esi
  const char **v201; // ebp
  int v202; // eax
  int v203; // eax
  int v204; // eax
  char *v205; // edx
  struct_ARENA *v206; // ecx
  int v207; // ebx
  struct_PLAYER *v208; // ecx
  int v209; // esi
  __int64 v210; // rax
  __int64 v211; // rax
  const char *v212; // edi
  int v213; // edx
  int v214; // ecx
  struct_ARENA **v215; // edx
  char *v216; // ebx
  char *v217; // ebx
  struct_ARENA *v218; // eax
  signed int v219; // ecx
  signed int territoryTimeSecondsLeft; // ecx
  int v221; // ecx
  struct_ARENA *v222; // eax
  CHAR v223; // al
  char *v224; // edi
  CHAR *k; // ecx
  char v226; // al
  char v227; // al
  char *v228; // edi
  char *l; // ecx
  char v230; // al
  char *v231; // edi
  char *v232; // esi
  LPCSTR v234; // ecx
  int v235; // edi
  int v236; // esi
  const char *v237; // eax
  struct_ARENA *v238; // ecx
  int v239; // eax
  int v240; // eax
  __int64 v241; // rax
  __int64 v242; // rax
  __int64 v243; // rax
  const char *v244; // ebx
  Chat_Struct *v245; // edi
  char *v246; // esi
  struct_ARENA *v247; // eax
  struct_ARENA *v248; // eax
  char *v249; // eax
  int v250; // edx
  struct PLAYER *v251; // esi
  bool v252; // cc
  struct_ARENA **v253; // edi
  struct_ARENA *v254; // eax
  int v255; // ebx
  int v256; // esi
  unsigned int v257; // krA0_4
  struct_ARENA **v258; // esi
  int v259; // ebp
  int v260; // edi
  struct_ARENA *v261; // edx
  int IsMessageReliable; // esi
  unsigned int v263; // ecx
  char *v264; // ecx
  char v265; // al
  char *m; // edx
  char v267; // al
  char v268; // al
  const char *ChatTextt; // ecx
  int IsMessageReliablee; // eax
  int v271; // eax
  unsigned int v272; // krB0_4
  signed int v273; // edi
  struct_PLAYER **v274; // ebp
  unsigned __int64 v275; // [esp+0h] [ebp-16090h]
  int v276; // [esp+8h] [ebp-16088h]
  const char *v277; // [esp+8h] [ebp-16088h]
  int v278; // [esp+Ch] [ebp-16084h]
  int v279; // [esp+Ch] [ebp-16084h]
  struct_ARENA **arenaa[8]; // [esp+10h] [ebp-16080h] BYREF
  int TotalPacketClustersCalls; // [esp+30h] [ebp-16060h] BYREF
  int tempValue; // [esp+34h] [ebp-1605Ch] BYREF
  char buf[5]; // [esp+38h] [ebp-16058h] BYREF
  char buferrr; // [esp+3Fh] [ebp-16051h] BYREF
  size_t Size; // [esp+40h] [ebp-16050h] BYREF
  int v286; // [esp+44h] [ebp-1604Ch]
  int TotalPacketRecvLength; // [esp+48h] [ebp-16048h] BYREF
  int TotalPacketSendLength; // [esp+4Ch] [ebp-16044h] BYREF
  char v289; // [esp+50h] [ebp-16040h] BYREF
  __int16 v290; // [esp+51h] [ebp-1603Fh]
  int v291; // [esp+53h] [ebp-1603Dh]
  int v292; // [esp+57h] [ebp-16039h]
  __int16 v293; // [esp+5Bh] [ebp-16035h]
  __int16 v294; // [esp+5Dh] [ebp-16033h]
  int a2; // [esp+60h] [ebp-16030h] BYREF
  char KeyName[32]; // [esp+64h] [ebp-1602Ch] BYREF
  const CHAR buff[256]; // [esp+84h] [ebp-1600Ch] BYREF
  char String[256]; // [esp+184h] [ebp-15F0Ch] BYREF
  char ChannelName[64]; // [esp+284h] [ebp-15E0Ch] BYREF
  CHAR AppName[64]; // [esp+2C4h] [ebp-15DCCh] BYREF
  char a4; // [esp+304h] [ebp-15D8Ch] BYREF
  char v302; // [esp+305h] [ebp-15D8Bh] BYREF
  char v303; // [esp+306h] [ebp-15D8Ah] BYREF
  __int16 v304; // [esp+307h] [ebp-15D89h]
  char v305[251]; // [esp+309h] [ebp-15D87h] BYREF
  char v306; // [esp+404h] [ebp-15C8Ch]
  char v307[15]; // [esp+405h] [ebp-15C8Bh] BYREF
  char v308; // [esp+414h] [ebp-15C7Ch]
  CHAR StartupInfo[68]; // [esp+504h] [ebp-15B8Ch] BYREF
  char v310[3]; // [esp+604h] [ebp-15A8Ch] BYREF
  __int16 v311; // [esp+607h] [ebp-15A89h]
  char Dest[256]; // [esp+609h] [ebp-15A87h] BYREF
  char v313; // [esp+804h] [ebp-1588Ch] BYREF
  char v314; // [esp+805h] [ebp-1588Bh] BYREF
  char v315; // [esp+2804h] [ebp-1388Ch] BYREF
  char Str[16]; // [esp+2805h] [ebp-1388Bh] BYREF
  char v317; // [esp+2815h] [ebp-1387Bh] BYREF
  struct _EXCEPTION_REGISTRATION_RECORD *v318; // [esp+16084h] [ebp-Ch]
  void *v319; // [esp+16088h] [ebp-8h]
  int v320; // [esp+1608Ch] [ebp-4h]
  const char *Buf1a; // [esp+160A0h] [ebp+10h]

  v320 = -1;
  v6 = NtCurrentTeb()->NtTib.ExceptionList;
  v319 = &unknown_libname_26;
  v318 = v6;
  v7 = alloca(0x1605C);
  sentCommand = ChatText;
  v9 = player;
  arenaa[2] = a1;
  if ( player && player->isModerator && *ChatText == 0x38 || strlen(ChatText) > 0xFA )
    return;
  v10 = arenaPlayerIndex;
  SomethingWithSendingChatTypes(player, a3, arenaPlayerIndex, ChatText, SoundByte);
  if ( player )
  {
    v11 = 0;
    if ( arenaPlayerIndex >= 0 && arenaPlayerIndex < 1024 )
      v11 = PlayerList[arenaPlayerIndex];
    v12 = BillingLogMessages;
    if ( BillingLogMessages <= player->Extra2 )
      v12 = player->Extra2;
    if ( v11 && *(&v11->PlayerPointers[135] + 3) )
    {
      if ( v12 )
      {
LABEL_16:
        v13 = -1;
        switch ( a3 )
        {
          case 3:
            v13 = -2;
            break;
          case 4:
            v13 = -3;
            break;
          case 5:
            if ( v11 )
              v13 = *(&v11->PlayerPointers[134] + 3);
            break;
          case 9:
            v13 = -4;
            break;
          default:
            break;
        }
        if ( v12 == 3
          || v12 == 2 && (a3 == 3 || a3 == 4 || a3 == 5 || a3 == 9 || *ChatText == '*')
          || v12 == 1 && (a3 == 5 || *ChatText == '*') )
        {
          v14 = player->UserId;
          if ( v14 >= 0 )
          {
            if ( BillingConnectionStructPointer )
              SendBillerUnknownPacket(BillingConnectionStructPointer, v14, v13, ChatText);
          }
        }
        goto LABEL_35;
      }
      v12 = *ChatText != '*';
    }
    if ( !v12 )
      goto LABEL_35;
    goto LABEL_16;
  }
LABEL_35:
  v15 = *ChatText;
  if ( *ChatText != '*' )
  {
    if ( player )
    {
      arenaa[7] = player->MyArena;
      if ( arenaa[7] )
      {
        if ( v15 == '?' )
        {
          if ( !strcmp(ChatText, "?usage") )
          {
            arenaa[1] = player->TotalUsageSeconds2;
            v171 = time(0);
            UsageSessionSeconds = difftime(v171, arenaa[1]);
            sprintf(
              buff,
              "Session Usage: %5d hours %d minutes",
              UsageSessionSeconds / 3600,
              UsageSessionSeconds / 60 % 60);
            SendMessage(player, buff, 0);
            sprintf(
              buff,
              "  Total Usage: %5d hours %d minutes",
              (player->UsageTotalSeconds + UsageSessionSeconds) / 3600,
              (player->UsageTotalSeconds + UsageSessionSeconds) / 60 % 60);
            SendMessage(player, buff, 0);
            v275 = __PAIR64__(player->AccountCreationDay, player->AccountCreationMonth);
            sprintf(
              buff,
              " First played: %d-%d-%d %d:%d:%d",
              v275,
              HIDWORD(v275),
              player->AccountCreationYear,
              player->AccountCreationHour,
              player->AccountCreationMinute,
              player->AccountCreationSecond);
            SendMessage(player, buff, 0);
            return;
          }
          if ( !strcmp(ChatText, "?sheep") )
          {
            SendMessage(player, arenaa[7] + 110542, 24);
            return;
          }
          if ( !memcmp(ChatText, "?buy", 4u) )
          {
            for ( i = ChatText + 4; *i == ' ' || *i == '='; ++i )
              ;
            Buf1a = i;
            if ( *i )
            {
              if ( player->Ship == 8 )
              {
                SendMessage(player, "Spectators cannot purchase items.", 0);
              }
              else if ( *(arenaa[7] + 109770) || (player->ShipTogglables & 0x20) != 0 )
              {
                v178 = 0;
                v179 = 0;
                while ( _strcmpi(&player->MyArena->ServersideArenaSettings.char158[v179], Buf1a) )
                {
                  v179 += 24;
                  ++v178;
                  if ( v179 >= 576 )
                    goto LABEL_495;
                }
                v180 = player->MyArena;
                v181 = player->FlagPoints;
                v182 = 24 * v178;
                v183 = *&v180->ServersideArenaSettings.char158[24 * v178 + 16];
                v184 = &v180->ServersideArenaSettings.char158[24 * v178 + 16];
                if ( v183 )
                {
                  if ( v183 <= v181 + player->KillPoints )
                  {
                    v185 = *v184;
                    if ( *v184 <= v181 )
                    {
                      arenaa[1] = -v185;
                      arenaa[0] = 0;
                    }
                    else
                    {
                      arenaa[1] = -v181;
                      arenaa[0] = (v181 - v185);
                    }
                    UpdatePoints(player, arenaa[0], arenaa[1]);
                    v186 = player->MyArena;
                    buf[0] = 32;
                    *&buf[3] = *&v186->ServersideArenaSettings.char158[v182 + 20];
                    *&buf[1] = 1;
                    SendPlayerReliablePacket(player, buf, 5u, 1);
                    v187 = player->FlagPoints;
                    v188 = player->KillPoints;
                    v290 = player->PlayerId;
                    v189 = player->CurrentWins;
                    v292 = v187;
                    v291 = v188;
                    LOWORD(v188) = player->CurrentLosses;
                    v293 = v189;
                    v190 = *&player->CurrentWins;
                    v294 = v188;
                    v191 = *&player->GoalCount;
                    player->dword23F = v190;
                    v192 = *(&player->KillPoints + 2);
                    v289 = 9;
                    *&player->dword243 = v191;
                    LOWORD(v191) = HIWORD(player->FlagPoints);
                    *&player->dword247 = v192;
                    LOWORD(player->word24B) = v191;
                    SendPlayerReliablePacket(player, &v289, 0xFu, 1);
                    if ( *&player->MyArena->ServersideArenaSettings.char158[v182 + 16] > 500 )
                      SendEverybodyButYourself(player, &v289, 0xFu, 0);
                  }
                  else
                  {
                    SendMessage(player, "You do not have enough points to purchase that item.", 0);
                  }
                }
                else
                {
                  SendMessage(player, "That item is not available for purchase.", 0);
                }
LABEL_495:
                if ( v178 == 24 )
                  SendMessage(player, "Invalid item specified for purchase.", 0);
              }
              else
              {
                SendMessage(player, "You must be in safe zone to purchase items.", 0);
              }
              return;
            }
            buff[0] = 0;
            for ( j = 0; j < 576; j += 24 )
            {
              v175 = player->MyArena + j;
              v176 = *(v175 + 109982);
              if ( v176 > 0 )
              {
                sprintf(String, "%s=%d", v175 + 109966, v176);
                if ( strlen(String) + strlen(buff) > 0x4B )
                {
                  SendMessage(player, buff, 0);
                  buff[0] = 0;
                }
                v177 = " ";
                if ( !buff[0] )
                  v177 = "PRICE: ";
                strcat(buff, v177);
                strcat(buff, String);
              }
            }
            if ( !buff[0] )
              return;
LABEL_477:
            SendMessage(player, buff, 0);
            return;
          }
          if ( !strcmp(ChatText, "?zone") )
          {
            SendMessage(player, BillingServerName, 0);
            return;
          }
          if ( !strcmp(ChatText, "?userid") )
          {
            sprintf(String, "UserId:%d", player->UserId);
            SendMessage(player, String, 0);
            return;
          }
          if ( !strcmp(ChatText, "?owner") )
          {
            sprintf(String, "Arena Owner:%s", arenaa[7] + 110798);
            SendMessage(player, String, 0);
            return;
          }
          if ( !strcmp(ChatText, "?getsettings") )
          {
            if ( player->isSysop
              || (UserIdInArenaSettings = *(arenaa[7] + 109622), player->UserId == UserIdInArenaSettings)
              && UserIdInArenaSettings >= 0 )
            {
              SendMessage(player, "File being sent, please wait.", 0);
              v194 = player->MyArena;
              v315 = 16;
              v195 = strrchr(v194->szConfigFile, 92);
              if ( v195 )
              {
                strcpy(Str, v195 + 1);
                v196 = strrchr(Str, 46);
                if ( v196 )
                  strcpy(v196, ".set");
                v197 = &v317;
                v198 = operator new(0x2B74Cu);
                *buf = v198;
                v320 = 0;
                if ( v198 )
                {
                  v199 = ReadSettingsSomething(v198, player->MyArena->szConfigFile);
                  arenaa[6] = v199;
                }
                else
                {
                  arenaa[6] = 0;
                  v199 = 0;
                }
                v320 = -1;
                TotalPacketClustersCalls = 0;
                if ( TotalTemplateSSSEntries > 0 )
                {
                  v200 = TotalTemplateSSSList[0].SomeString256;
                  do
                  {
                    if ( !v200[256] || v9->isSysop )
                    {
                      if ( _strcmpi(v200 - 80, "All") )
                      {
                        sub_4066B0(arenaa[6], v200 - 80, v200 - 48, &DirectoryNamePassword, String, 0x100u);
                        v203 = *(v200 - 2);
                        if ( v203 == -999 )
                          sprintf(v197, "%s:%s:%s:::%s\r\n", v200 - 80, v200 - 48, String, v200);
                        else
                          sprintf(v197, "%s:%s:%s:%d:%d:%s\r\n", v200 - 80, v200 - 48, String, v203, *(v200 - 1), v200);
                        v197 += strlen(v197);
                      }
                      else
                      {
                        v201 = off_42C848;
                        do
                        {
                          sub_4066B0(arenaa[6], *v201, v200 - 48, &DirectoryNamePassword, buff, 0x100u);
                          if ( v201 <= off_42C848 )
                          {
                            v202 = *(v200 - 2);
                            if ( v202 == -999 )
                              sprintf(v197, "%s:%s:%s:::%s\r\n", *v201, v200 - 48, buff, v200);
                            else
                              sprintf(v197, "%s:%s:%s:%d:%d:%s\r\n", *v201, v200 - 48, buff, v202, *(v200 - 1), v200);
                          }
                          else
                          {
                            sprintf(v197, "%s:%s:%s:*\r\n", *v201, v200 - 48, buff);
                          }
                          ++v201;
                          v197 += strlen(v197);
                        }
                        while ( v201 < "Spawned Command" );
                      }
                    }
                    v9 = player;
                    v200 += 338;
                    ++TotalPacketClustersCalls;
                  }
                  while ( TotalPacketClustersCalls < TotalTemplateSSSEntries );
                  v199 = arenaa[6];
                }
                SendPlayerReliablePacket(v9, &v315, v197 - &v315, 1);
                if ( v199 )
                {
                  WriteCfgFile(v199);
                  operator delete(v199);
                }
              }
            }
            else
            {
              SendMessage(player, "Only the owner of this arena can view the settings.", 0);
            }
            return;
          }
          if ( !memcmp(ChatText, "?setlevel ", 0xAu) )
          {
            if ( player->isSysop || (v204 = *(arenaa[7] + 109622), player->UserId == v204) && v204 >= 0 )
            {
              a4 = 25;
              strncpy(&v302, ChatText + 10, 0x100u);
              v205 = player->MyArena->szLevelFile2;
              v306 = 0;
              strncpy(v307, v205, 0x10u);
              v308 = 0;
              SendPlayerReliablePacket(player, &a4, 0x111u, 1);
            }
            else
            {
              SendMessage(player, "Only the owner of this arena can change the level.", 0);
            }
            return;
          }
          if ( !strcmp(ChatText, "?recycle") )
          {
            if ( player->isSysop || player->UserId == *(arenaa[7] + 109622) )
              *(arenaa[7] + 65574) = 1;
            else
              SendMessage(player, "Only the owner of this arena can recycle it.", 0);
            return;
          }
          if ( !strcmp(ChatText, "?spec") )
          {
            v206 = arenaa[7];
            buff[0] = 0;
            TotalPacketClustersCalls = 0;
            if ( *(arenaa[7] + 16323) > 0 )
            {
              v207 = 16072;
              do
              {
                v208 = v206->PlayerPointers[v207];
                v209 = 0;
                if ( player->isSuperModerator )
                {
                  if ( v208->Ship == 8 && v208->ArenaPlayerIndex < 0 )
                  {
                    v210 = v208->XPixels - player->XPixels;
                    if ( ((HIDWORD(v210) ^ v210) - HIDWORD(v210)) < 1280 )
                    {
                      v211 = v208->YPixels - player->YPixels;
                      if ( ((HIDWORD(v211) ^ v211) - HIDWORD(v211)) < 1024 )
                        v209 = 1;
                    }
                  }
                }
                if ( (v208->ArenaPlayerIndex == *&player->PlayerId || v209) && (player->isSysop || !v208->isModerator) )
                {
                  if ( v209 )
                    arenaa[0] = "*%s";
                  else
                    arenaa[0] = "%s";
                  sprintf(String, arenaa[0], v208->Name);
                  if ( strlen(String) + strlen(buff) > 0x4B )
                  {
                    SendMessage(player, buff, 0);
                    buff[0] = 0;
                  }
                  v212 = ",";
                  if ( !buff[0] )
                    v212 = "SPEC: ";
                  strcat(buff, v212);
                  strcat(buff, String);
                }
                v206 = player->MyArena;
                ++v207;
                v213 = v206->ArenaPlayerCount;
                ++TotalPacketClustersCalls;
              }
              while ( TotalPacketClustersCalls < v213 );
            }
            if ( !buff[0] )
              return;
            goto LABEL_477;
          }
          if ( !strcmp(ChatText, "?packetloss") )
          {
            sub_41CB70(player->encryptionPointer, &arenaa[6], &tempValue);
            v214 = 1000 - tempValue;
            v115 = arenaa[6] == 1000;
            arenaa[6] = (1000 - arenaa[6]);
            tempValue = 1000 - tempValue;
            if ( !v115 || v214 )
              sprintf(
                buff,
                "PACKET LOSS ServerToYou:%.1f%%  YouToServer:%.1f%%",
                arenaa[6] * unk_429008,
                tempValue * unk_429008);
            else
              sprintf(buff, "PACKET LOSS Unknown, check again in a few minutes.");
            SendMessage(player, buff, 0);
            return;
          }
          if ( !strcmp(ChatText, "?jackpot") )
          {
            sprintf(String, "Current Jackpot: %d", *(arenaa[7] + 65382));
            SendMessage(player, String, 0);
            return;
          }
          if ( !strcmp(ChatText, "?crown") )
          {
            if ( *(arenaa[7] + 109910) <= 0 || *(arenaa[7] + 109930) <= 0 )
            {
              SendMessage(player, "This is not a king of the hill style game or crowns cannot be recovered.", 0);
            }
            else if ( player->KotHDeathCount <= 0 )
            {
              sprintf(String, "Kills needed for crown: %d", *(arenaa[7] + 109930) - player->KingCrownKills);
              SendMessage(player, String, 0);
            }
            else
            {
              SendMessage(player, "You already have a crown.", 0);
            }
            return;
          }
          if ( !strcmp(ChatText, "?score") )
          {
            GetScore(arenaa[7], player);
            return;
          }
          if ( !strcmp(ChatText, "?arena") )
          {
            v215 = 0;
            v313 = 47;
            v216 = &v314;
            TotalPacketClustersCalls = 0;
            if ( ArenaArrayLength > 0 )
            {
              arenaa[6] = Arenas;
              do
              {
                if ( (*arenaa[6])->ArenaName[0] != '#' || player->isModerator || player->MyArena == *arenaa[6] )
                {
                  if ( (*arenaa[6])->ArenaName[0] )
                  {
                    arenaa[1] = (*arenaa[6])->ArenaName;
                    arenaa[0] = "%s";
                  }
                  else
                  {
                    arenaa[1] = v215;
                    arenaa[0] = MEMORY[0x42A094];
                  }
                  sprintf(buff, arenaa[0], arenaa[1]);
                  strcpy(v216, buff);
                  v217 = &v216[strlen(buff) + 1];
                  v218 = *arenaa[6];
                  if ( *arenaa[6] == player->MyArena )
                    *v217 = -LOWORD(v218->ArenaPlayerCount);
                  else
                    *v217 = v218->ArenaPlayerCount;
                  v215 = TotalPacketClustersCalls;
                  v216 = v217 + 2;
                }
                v215 = (v215 + 1);
                TotalPacketClustersCalls = v215;
                ++arenaa[6];
              }
              while ( v215 < ArenaArrayLength );
            }
            SendPlayerReliablePacket(player, &v313, v216 - &v313, 1);
            return;
          }
          if ( !strcmp(ChatText, "?time") )
          {
            if ( *(arenaa[7] + 109754) <= 0 )
            {
              if ( !*(arenaa[7] + 65362) )
              {
                if ( player->isModerator )
                {
                  territoryTimeSecondsLeft = player->MyArena->ServersideArenaSettings.TerritoryRewardDelay
                                           - abs32(GetTickCount() / 0xA - player->MyArena->TerritoryRewardTimePassed);
                  if ( territoryTimeSecondsLeft < 0 )
                    territoryTimeSecondsLeft = 0;
                  sprintf(
                    buff,
                    "Time left to reward: %d minutes %d seconds",
                    territoryTimeSecondsLeft / 6000,
                    territoryTimeSecondsLeft % 6000 / 100);
                  SendMessage(player, buff, 0);
                }
                else
                {
                  SendMessage(player, "This zone does not have a game time limit", 0);
                }
                return;
              }
              v219 = player->MyArena->GameTimeStart - abs32(GetTickCount() / 0xA - player->MyArena->GameTimePassed);
              if ( v219 < 0 )
                v219 = 0;
            }
            else
            {
              v219 = player->MyArena->ServersideArenaSettings.MiscTimedGame
                   - abs32(GetTickCount() / 0xA - player->MyArena->GameTimePassedTwo);
              if ( v219 < 0 )
                v219 = 0;
            }
            sprintf(buff, "Time left: %d minutes %d seconds", v219 / 6000, v219 % 6000 / 100);
            SendMessage(player, buff, 0);
            return;
          }
          if ( !strcmp(ChatText, "?best") )
          {
            if ( *(arenaa[7] + 109754) <= 0 )
            {
              arenaa[1] = player->CurrentLosses;
              arenaa[0] = player->CurrentWins;
              v279 = player->KillPoints + player->FlagPoints;
              v277 = "CURRENT SCORE  Points:%d  Win:%d  Lose:%d";
            }
            else
            {
              arenaa[1] = player->PersonalBestLosses;
              arenaa[0] = player->PersonalBestWins;
              v279 = *&player->PersonalBestPoints1of2 + *&player->PersonalBestPoints2of2;
              v277 = "PERSONAL BEST  Points:%d  Win:%d  Lose:%d";
            }
            sprintf(String, v277, v279, arenaa[0], arenaa[1]);
            SendMessage(player, String, 0);
            return;
          }
          if ( !memcmp(ChatText, "?set ", 5u) || !memcmp(ChatText, "?get ", 5u) )
          {
            v221 = 0;
            if ( player->isSysop
              || (v222 = player->UserId, v222 >= 0) && *(arenaa[7] + 65570) && *(arenaa[7] + 109622) == v222 )
            {
              v221 = 1;
            }
            if ( v221 )
            {
              v223 = ChatText[5];
              v224 = ChatText + 5;
              for ( k = AppName; v223; ++v224 )
              {
                if ( v223 == ':' )
                  break;
                *k = v223;
                v223 = v224[1];
                ++k;
              }
              v226 = *v224;
              *k = 0;
              if ( v226 )
              {
                v227 = v224[1];
                v228 = v224 + 1;
                for ( l = ChannelName; v227; ++v228 )
                {
                  if ( v227 == '=' )
                    break;
                  if ( v227 == ':' )
                    break;
                  *l = v227;
                  v227 = v228[1];
                  ++l;
                }
                v230 = *v228;
                *l = 0;
                if ( v230 )
                  ++v228;
                strcpy(String, v228);
                if ( _memicmp(ChatText, "?set ", 5u)
                  || (sprintf(StartupInfo, "%s:%s:%s", AppName, ChannelName, String),
                      !ChangeSettings(player->MyArena, player, StartupInfo)) )
                {
                  if ( !_strcmpi(AppName, "All") )
                    strcpy(AppName, &shipsArray[64]);
                  GetPrivateProfileStringA(
                    AppName,
                    ChannelName,
                    "InvalidTag",
                    buff,
                    0x80u,
                    player->MyArena->szConfigFile);
                  sprintf(&a4, "%s:%s=%s", AppName, ChannelName, buff);
                  SendMessage(player, &a4, 0);
                }
              }
            }
            else
            {
              SendMessage(player, "You do not have permission to set parameters in this arena.", 0);
            }
            return;
          }
          if ( isalpha(ChatText[1]) )
          {
            if ( BillingConnectionStructPointer )
              biller_user_command(BillingConnectionStructPointer, player->BillerPlayerId, ChatText);
            return;
          }
        }
      }
    }
    v231 = &a4;
    v232 = ChatText;
    if ( *ChatText )
    {
      do
      {
        if ( isalpha(*v232) )
          *v231++ = toupper(*v232);
      }
      while ( *++v232 );
    }
    v234 = ObscenePointer;
    *v231 = 0;
    v235 = ListMachine(v234);
    v236 = 0;
    if ( v235 <= 0 )
    {
LABEL_656:
      arenaa[6] = 0;
    }
    else
    {
      while ( 1 )
      {
        v237 = ListMachineByIndex(ObscenePointer, v236);
        if ( strstr(&a4, v237) )
          break;
        if ( ++v236 >= v235 )
          goto LABEL_656;
      }
      arenaa[6] = 1;
    }
    arenaa[7] = 0;
    if ( player )
    {
      if ( player->Ship == 8 && player->MyArena->ServersideArenaSettings.MiscSpectatorQuiet && !player->isModerator )
        arenaa[7] = 1;
      if ( (GetTickCount() / 0xA - player->GetTickCountValueDividedByTen2) >= 100 )
      {
        player->dword293 = 0;
      }
      else
      {
        v238 = player->MyArena;
        v239 = player->dword293 + 1;
        player->dword293 = v239;
        if ( v239 > v238->ServersideArenaSettings.MessageQuickMessageLimit && !player->isSysop )
        {
          WriteSubGameLog("Played kicked off for message flooding: %s\n", player->PlayerName);
          player->DisconnectReason = 12;
          player->AlreadySentReliablePacket = 1;
          SendArenaMessagePlayer(player, "WARNING: You have been disconnected for message flooding.", 0);
          return;
        }
      }
      player->GetTickCountValueDividedByTen2 = GetTickCount() / 0xA;
    }
    v240 = a3;
    if ( a3 == 1 || a3 == 2 )
    {
      if ( player )
      {
        if ( player->MyArena )
        {
          v241 = (GetTickCount() / 0xA - player->MyArena->GameTimePassedTwo);
          if ( ((HIDWORD(v241) ^ v241) - HIDWORD(v241)) < 600 )
            return;
          v242 = (GetTickCount() / 0xA - player->MyArena->GetTickCountValue8);
          if ( ((HIDWORD(v242) ^ v242) - HIDWORD(v242)) < 500 )
            return;
          v243 = (GetTickCount() / 0xA - player->MyArena->TerritoryRewardTimePassed);
          if ( ((HIDWORD(v243) ^ v243) - HIDWORD(v243)) < 500 )
            return;
        }
      }
      v244 = &DirectoryNamePassword;
      TotalPacketClustersCalls = &DirectoryNamePassword;
      if ( player )
      {
        v244 = player->Name;
        TotalPacketClustersCalls = player->Name;
      }
      if ( *v244 && ChatCounter64Max > 0 )
      {
        if ( !strcmp((364 * ChatCounter64Max + 0x431FC8), v244)
          && !strcmp((364 * ChatCounter64Max + 0x431E9C), ChatText) )
        {
          return;
        }
        v244 = TotalPacketClustersCalls;
      }
      v245 = &ChatRelatedArray[ChatCounter64Max];
      ChatCounter64Max = (ChatCounter64Max + 1) % 64;
      strncpy(v245->PlayerName2, ChatText, 0x12Cu);
      v246 = v245->PlayerName;
      v245->PlayerName2[299] = 0;
      strncpy(v245->PlayerName, v244, 0x20u);
      v245 = (v245 + 332);
      v246[31] = 0;
      strncpy(v245->PlayerName2, "(Everyone)", 0x20u);
      v245->PlayerName2[31] = 0;
      if ( player )
      {
        v247 = player->MyArena;
        if ( v247 )
          FormatMessageArena(v247, "%16.16s>%s\n", v246, ChatText);
      }
      v240 = a3;
    }
    v310[0] = 7;
    v310[1] = v240;
    v310[2] = SoundByte;
    if ( v240 == 7 )
    {
      if ( !player
        || (v248 = player->MyArena) == 0
        || player->isModerator
        || v248->SpecMessageLock && player->Ship != 8
        || !v248->PrivateMessagesLocked )
      {
        v311 = 0;
        v249 = strchr(ChatText + 1, 58);
        *buf = v249;
        if ( v249 )
        {
          v250 = v249 - ChatText - 1;
          Size = v250;
          qmemcpy(buff, ChatText + 1, v250);
          v251 = 0;
          v252 = ArenaArrayLength <= 0;
          buff[v250] = 0;
          tempValue = 0;
          TotalPacketClustersCalls = 0;
          if ( !v252 )
          {
            v253 = Arenas;
            do
            {
              v254 = *v253;
              v255 = 0;
              if ( (*v253)->ArenaPlayerCount > 0 )
              {
                v256 = 16072;
                while ( _strcmpi(buff, v254->PlayerPointers[v256]->Name) )
                {
                  if ( !tempValue && player && !_memicmp(buff, (*v253)->PlayerPointers[v256]->Name, Size) )
                    tempValue = (*v253)->PlayerPointers[v256];
                  v254 = *v253;
                  ++v255;
                  ++v256;
                  if ( v255 >= (*v253)->ArenaPlayerCount )
                    goto LABEL_706;
                }
                tempValue = (*v253)->playerPointersForSomething[v255];
              }
LABEL_706:
              ++v253;
              ++TotalPacketClustersCalls;
            }
            while ( TotalPacketClustersCalls < ArenaArrayLength );
            v250 = Size;
            v249 = *buf;
            v251 = tempValue;
          }
          if ( v251 )
          {
            if ( player )
              sprintf(Dest, "(%s)>%s", player->Name, v249 + 1);
            else
              sprintf(Dest, "%s", v249 + 1);
            SendToSpectators(v251, v310, strlen(Dest) + 6, 1, arenaa[6], arenaa[7]);
          }
          else if ( player )
          {
            a4 = 2;
            v302 = SoundByte;
            sprintf(&v303, ":%s:(%s)>%s", buff, player->Name, v249 + 1);
            if ( BillingConnectionStructPointer )
              SendBillerUserPrivateChatPacket(
                BillingConnectionStructPointer,
                -1,
                BillingGroupId,
                &a4,
                strlen(&v303) + 3);
          }
          else if ( buff[0] == '#' && v250 > 2 && buff[1] != ' ' )
          {
            sprintf(Dest, "%s", v249 + 1);
            v257 = strlen(Dest) + 1;
            TotalPacketClustersCalls = 0;
            if ( ArenaArrayLength > 0 )
            {
              v258 = Arenas;
              do
              {
                v259 = 0;
                if ( (*v258)->ArenaPlayerCount > 0 )
                {
                  v260 = 16072;
                  do
                  {
                    if ( !_strcmpi(&buff[1], (*v258)->PlayerPointers[v260]->Squad) )
                      SendToSpectators((*v258)->PlayerPointers[v260], v310, v257 - 1 + 6, 1, arenaa[6], arenaa[7]);
                    ++v259;
                    ++v260;
                  }
                  while ( v259 < (*v258)->ArenaPlayerCount );
                }
                ++v258;
                ++TotalPacketClustersCalls;
              }
              while ( TotalPacketClustersCalls < ArenaArrayLength );
            }
          }
        }
      }
    }
    else if ( player && (v261 = player->MyArena) != 0 )
    {
      v311 = player->PlayerId;
      *buf = strcpy(Dest, ChatText);
      IsMessageReliable = v261->ServersideArenaSettings.MessageReliable;
      v263 = strlen(ChatText) + 6;
      if ( v261->ArenaPlayerCount < 20 )
        IsMessageReliable = 1;
      switch ( a3 )
      {
        case 1:
        case 2:
          if ( player->isModerator || v261->SpecMessageLock && player->Ship != 8 || !v261->AllMessagesLocked )
            SomethingWithAttachedPlayer(player, v310, v263, IsMessageReliable, arenaa[6], arenaa[7]);
          break;
        case 3:
          if ( player->isModerator
            || v261->SpecMessageLock && player->Ship != 8
            || !v261->AllMessagesLockedAgainSomething )
          {
            IsMessageReliablee = v261->ServersideArenaSettings.MessageTeamReliable || IsMessageReliable;
            sub_40E220(player, v310, v263, IsMessageReliablee, arenaa[6], arenaa[7]);
          }
          break;
        case 4:
          if ( player->isModerator
            || v261->SpecMessageLock && player->Ship != 8
            || !v261->AllMessagesLockedAgainSomething )
          {
            v271 = v261->ServersideArenaSettings.MessageTeamReliable || IsMessageReliable;
            sub_40E300(player, arenaPlayerIndex, v310, v263, v271, arenaa[6], arenaa[7]);
          }
          break;
        case 5:
          if ( player->isModerator || v261->SpecMessageLock && player->Ship != 8 || !v261->PrivateMessagesLocked )
            SomethingWithAudioByteAndShip8(arenaPlayerIndex, v310, v263, 1, arenaa[6], arenaa[7]);
          break;
        case 9:
          if ( player->isModerator || v261->SpecMessageLock && player->Ship != 8 || !v261->PrivateMessagesLocked )
          {
            if ( BillingConnectionStructPointer )
            {
              if ( *ChatText == ';' || isdigit(*ChatText) && ChatText[1] == ';' )
              {
                v264 = ChatText;
                if ( *ChatText == ';' )
                  v264 = ChatText + 1;
                v265 = *v264;
                for ( m = ChannelName; v265; ++v264 )
                {
                  if ( v265 == ';' )
                    break;
                  if ( v265 == ':' )
                    break;
                  *m = v265;
                  v265 = v264[1];
                  ++m;
                }
                v267 = *v264;
                *m = 0;
                if ( v267 )
                {
                  v268 = v264[1];
                  ChatTextt = v264 + 1;
                  if ( v268 )
                  {
                    if ( ChannelName[0] )
                      SendBillerUserChannelChatPacket(
                        BillingConnectionStructPointer,
                        player->BillerPlayerId,
                        ChannelName,
                        ChatTextt);
                  }
                }
              }
              else
              {
                SendBillerUserChannelChatPacket(
                  BillingConnectionStructPointer,
                  player->BillerPlayerId,
                  &DirectoryNamePassword,
                  ChatText);
              }
            }
            else
            {
              SendMessage(player, "Chat channels not available at this time.", 0);
            }
          }
          break;
        default:
          return;
      }
    }
    else
    {
      v303 = SoundByte;
      a4 = 7;
      v302 = 0;
      v304 = 0;
      strcpy(v305, ChatText);
      v272 = strlen(ChatText) + 1;
      v273 = 0;
      if ( CurrentPlayerCount > 0 )
      {
        v274 = playerPointerList;
        do
        {
          if ( (*v274)->MyArena )
            SendPlayerReliablePacket(*v274, &a4, v272 - 1 + 6, 1);
          ++v273;
          ++v274;
        }
        while ( v273 < CurrentPlayerCount );
      }
    }
    return;
  }
  if ( !player )
    goto LABEL_41;
  if ( !player->isModerator )
    goto LABEL_443;
  sentCommand = ChatText;
  v10 = arenaPlayerIndex;
  if ( !player->isSuperModerator )
    goto LABEL_294;
  if ( player->isSysop )
  {
LABEL_41:
    if ( !_memicmp(sentCommand, "**", 2u) && player )
    {
      v16 = sentCommand + 2;
      v302 = SoundByte;
      a4 = 2;
      v17 = BillingConnectionStructPointer;
      strcpy(&v303, v16);
      if ( v17 )
        SendBillerUserPrivateChatPacket(v17, player->BillerPlayerId, BillingGroupId, &a4, strlen(v16) + 3);
      return;
    }
    if ( _memicmp(sentCommand, "*energy", 7u) || !player )
    {
      if ( !_memicmp(sentCommand, "*stat", 5u) && player )
      {
        GetTickCountDifference = GetTickCount() / 0xA - oldTickCountValue;
        tempValue = GetTickCountDifference;
        if ( GetTickCountDifference <= 0 )
        {
          GetTickCountDifference = 1;
          tempValue = 1;
        }
        v23 = player->MyArena;
        arenaa[6] = 0;
        if ( v23->ArenaPlayerCount > 0 )
        {
          v24 = 0;
          v25 = 16072;
          do
          {
            v26 = GetRelAckDiff(v23->PlayerPointers[v25++]->encryptionPointer, 0);
            v27 = (arenaa[6] + v26);
            v23 = player->MyArena;
            arenaa[6] = v27;
            ++v24;
          }
          while ( v24 < v23->ArenaPlayerCount );
          arenaa[6] = (10 * arenaa[6] / player->MyArena->ArenaPlayerCount);
        }
        GetPacketStatistics(
          Structv9Pointer,
          &TotalPacketSendLength,
          &arenaa[7],
          &TotalPacketRecvLength,
          &Size,
          &TotalPacketClustersCalls);
        sprintf(
          String,
          "Send:%d(%d)  Recv:%d(%d)  RelOut:%.1f  Multi:%.1f\n",
          100 * TotalPacketSendLength / GetTickCountDifference,
          100 * arenaa[7] / GetTickCountDifference,
          100 * TotalPacketRecvLength / GetTickCountDifference,
          (100 * Size) / GetTickCountDifference,
          arenaa[6] * unk_429008,
          TotalPacketClustersCalls * 100.0 / tempValue);
        SendMessage(player, String, 0);
        v28 = 0;
        if ( BillingServerConnection )
          v28 = GetRelAckDiff(BillingServerConnection, 0);
        sprintf(
          String,
          "Iterations:%d  Players:%d  BillingRelOut:%d  Wave:%d\n",
          100 * ServerIterations / GetTickCountDifference,
          CurrentPlayerCount,
          v28,
          100 * Wave / GetTickCountDifference);
        SendMessage(player, String, 0);
        sprintf(
          String,
          "Screen:%d  Radar:%d  Double:%d  Timer:%d\n",
          100 * ScreenValue / GetTickCountDifference,
          100 * RadarValue / GetTickCountDifference,
          100 * DoubleValue / GetTickCountDifference,
          GetTickCountDifference / 100);
        SendMessage(player, String, 0);
        MemoryUsage = 0;
        v30 = 0;
        if ( ArenaArrayLength > 0 )
        {
          tempValue = Arenas;
          do
          {
            MemoryUsage += GetArenaMemoryTotal(*tempValue);
            ++v30;
            tempValue += 4;
          }
          while ( v30 < ArenaArrayLength );
        }
        sprintf(String, "MemoryUsage:%dk\n", MemoryUsage);
        SendMessage(player, String, 0);
        v31 = 0;
        String[0] = 0;
        tempValue = 0;
        do
        {
          v32 = SomeArrayOf256_1[v31];
          if ( v32 )
          {
            sprintf(
              AppName,
              "%d:%d(%d)  ",
              v31,
              100 * SomeArrayOf256_2[v31] / GetTickCountDifference,
              100 * v32 / GetTickCountDifference);
            if ( strlen(AppName) + strlen(String) > 0x4B )
            {
              SendMessage(player, String, 0);
              String[0] = 0;
            }
            strcat(String, AppName);
            v31 = tempValue;
          }
          tempValue = ++v31;
        }
        while ( v31 < 256 );
        if ( String[0] )
          SendMessage(player, String, 0);
        goto LABEL_172;
      }
      if ( !_memicmp(sentCommand, "*addword", 8u) )
      {
        v33 = sentCommand[8];
        v34 = sentCommand + 8;
        ChatText = v34;
        if ( v33 == ' ' )
        {
          do
            v35 = *++v34;
          while ( v35 == ' ' );
          ChatText = v34;
        }
        if ( *v34 )
        {
          AddLineTextFile(ObscenePointer, v34);
          WriteTextFileToFile(ObscenePointer);
          if ( player )
          {
            sprintf(buff, "Obscene Word Added: %s", v34);
            SendMessage(player, buff, 0);
          }
        }
        goto LABEL_172;
      }
      if ( _memicmp(sentCommand, "*addmachine", 0xBu) )
      {
        if ( !_memicmp(sentCommand, "*removemachine", 0xEu) )
        {
          v39 = sentCommand[14];
          v40 = sentCommand + 14;
          ChatText = v40;
          if ( v39 == ' ' )
          {
            do
              v41 = *++v40;
            while ( v41 == ' ' );
            ChatText = v40;
          }
          if ( *v40 )
          {
            v42 = 0;
            tempValue = ListMachine(IDBlockPointer);
            if ( tempValue > 0 )
            {
              do
              {
                listMachineBuffer = ListMachineByIndex(IDBlockPointer, v42);
                v44 = ChatText;
                if ( strlen(ChatText) >= strlen(listMachineBuffer) )
                  v44 = listMachineBuffer;
                if ( !memcmp(ChatText, listMachineBuffer, strlen(v44)) )
                {
                  ListMachineSomething(v42, arenaa[2]);
                  --tempValue;
                }
                else
                {
                  v42 = (v42 + 1);
                }
              }
              while ( v42 < tempValue );
            }
            WriteTextFileToFile(IDBlockPointer);
            if ( player )
              SendMessage(player, "MachineId Block Removed", 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(sentCommand, "*listmachine", 12u) && player )
        {
          listMachineCount = ListMachine(IDBlockPointer);
          for ( n = 0; n < listMachineCount; ++n )
          {
            bufferr = ListMachineByIndex(IDBlockPointer, n);
            SendMessage(player, bufferr, 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(sentCommand, "*log", 4u) && player )
        {
          for ( logCounter = 0; logCounter < 48; ++logCounter )
          {
            if ( LogArray[256 * ((logCounter + logLine) % 48)] )
              SendMessage(player, &LogArray[256 * ((logCounter + logLine) % 48)], 0);
          }
          goto LABEL_172;
        }
        if ( !_memicmp(sentCommand, "*shutdown", 9u) )
        {
          if ( player )
            SendMessage(player, "Shutting down server...", 0);
          printf("Shutting down server...\n");
          shutdownArguments = sentCommand + 9;
          bRecycleServer = 1;
          bServerIsRunning = 1;
          ShutdownArguments = 0;
          ChatText = shutdownArguments;
          if ( *shutdownArguments == ' ' )
            ChatText = ++shutdownArguments;
          if ( *shutdownArguments )
            strcpy(&ShutdownArguments, shutdownArguments);
          goto LABEL_172;
        }
        if ( !_memicmp(sentCommand, "*sysop", 6u) )
        {
          if ( a3 == 5 )
          {
            playerrrr = PlayerList[v10];
            if ( playerrrr )
            {
              isSysop = playerrrr->isSysop;
              isSYsopp = isSysop == 0;
              playerrrr->isSysop = isSYsopp;
              playerrrr->isSuperModerator = isSYsopp;
              playerrrr->isModerator = isSYsopp;
              if ( isSysop )
                SendMessage(player, "Player Sysop Mode OFF", 0);
              else
                SendMessage(player, "Player Sysop Mode ON", 0);
            }
          }
          goto LABEL_172;
        }
        if ( !_memicmp(sentCommand, "*smoderator", 0xBu) )
        {
          if ( a3 == 5 )
          {
            playerr = PlayerList[v10];
            if ( playerr )
            {
              isSuperModerator = playerr->isSuperModerator;
              isSuperModeratorr = isSuperModerator == 0;
              playerr->isSuperModerator = isSuperModeratorr;
              playerr->isModerator = isSuperModeratorr;
              if ( isSuperModerator )
                SendMessage(player, "Player Super Moderator Mode OFF", 0);
              else
                SendMessage(player, "Player Super Moderator Mode ON", 0);
            }
          }
          goto LABEL_172;
        }
        if ( _memicmp(sentCommand, "*s*", 3u) && _memicmp(sentCommand, "*g*", 3u) )
        {
          if ( !_memicmp(sentCommand, "*set ", 5u) )
          {
            v56 = sentCommand[5];
            v57 = sentCommand + 5;
            for ( ii = ChannelName; v56; ++v57 )
            {
              if ( v56 == ':' )
                break;
              *ii = v56;
              v56 = v57[1];
              ++ii;
            }
            v59 = *v57;
            *ii = 0;
            if ( !v59 )
              return;
            v60 = v57[1];
            v61 = v57 + 1;
            for ( jj = KeyName; v60; ++v61 )
            {
              if ( v60 == ':' )
                break;
              *jj = v60;
              v60 = v61[1];
              ++jj;
            }
            v63 = *v61;
            *jj = 0;
            if ( !v63 )
              return;
            v64 = v61[1];
            v65 = v61 + 1;
            for ( kk = String; v64; ++v65 )
            {
              *kk = v64;
              v64 = v65[1];
              ++kk;
            }
            *kk = 0;
            GetModuleFileNameA(0, StartupInfo, 0x100u);
            v67 = strrchr(StartupInfo, 92);
            if ( v67 )
              *v67 = 0;
            else
              StartupInfo[0] = 0;
            sprintf(buff, &unk_42A06B + 1, StartupInfo);
            if ( _strcmpi(ChannelName, "All") )
            {
              WritePrivateProfileStringA(ChannelName, KeyName, String, buff);
            }
            else
            {
              WritePrivateProfileStringA(&shipsArray[64], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[56], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[48], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[36], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[28], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[20], KeyName, String, buff);
              WritePrivateProfileStringA(&shipsArray[8], KeyName, String, buff);
              WritePrivateProfileStringA(shipsArray, KeyName, String, buff);
            }
            if ( player )
              SendMessage(player, "Change complete", 0);
          }
          goto LABEL_172;
        }
        v68 = sentCommand[3];
        v69 = sentCommand + 3;
        for ( ll = ChannelName; v68; ++v69 )
        {
          if ( v68 == 58 )
            break;
          *ll = v68;
          v68 = v69[1];
          ++ll;
        }
        v71 = *v69;
        *ll = 0;
        if ( !v71 )
          return;
        v72 = v69[1];
        v73 = v69 + 1;
        for ( mm = KeyName; v72; ++v73 )
        {
          if ( v72 == 58 )
            break;
          *mm = v72;
          v72 = v73[1];
          ++mm;
        }
        *mm = 0;
        if ( !_memicmp(sentCommand, "*s*", 3u) )
        {
          if ( !*v73 )
            return;
          v75 = v73[1];
          v76 = v73 + 1;
          for ( nn = AppName; v75; ++v76 )
          {
            *nn = v75;
            v75 = v76[1];
            ++nn;
          }
          *nn = 0;
          WritePrivateProfileStringA(ChannelName, KeyName, AppName, FileName);
          dword_4D5920 = 1;
        }
        if ( !player )
          goto LABEL_172;
        GetPrivateProfileStringA(ChannelName, KeyName, "InvalidTag", StartupInfo, 0x40u, FileName);
        sprintf(String, "%s:%s:%s", ChannelName, KeyName, StartupInfo);
        v20 = String;
      }
      else
      {
        v36 = sentCommand[11];
        v37 = sentCommand + 11;
        ChatText = v37;
        if ( v36 == ' ' )
        {
          do
            v38 = *++v37;
          while ( v38 == ' ' );
          ChatText = v37;
        }
        if ( !*v37 )
          goto LABEL_172;
        AddLineTextFile(IDBlockPointer, v37);
        WriteTextFileToFile(IDBlockPointer);
        if ( !player )
          goto LABEL_172;
        sprintf(buff, "MachineId Block Added: %s", v37);
        v20 = buff;
      }
      goto LABEL_171;
    }
    if ( a3 != 5 )
    {
      if ( player->MyArena )
      {
        v21 = player->isEnergyShowing;
        player->isEnergyShowing = v21 == 0;
        if ( v21 )
          SendMessage(player, "Showing Energy OFF", 0);
        else
          SendMessage(player, "Showing Energy ON", 0);
      }
      goto LABEL_172;
    }
    v18 = PlayerList[v10];
    if ( v18 )
    {
      v19 = v18->isEnergyShowing;
      v18->isEnergyShowing = v19 == 0;
      if ( v19 )
        arenaa[0] = "Showing Energy OFF for %s";
      else
        arenaa[0] = "Showing Energy ON for %s";
      sprintf(buff, arenaa[0], v18->Name);
      v20 = buff;
LABEL_171:
      SendMessage(player, v20, 0);
      goto LABEL_172;
    }
  }
LABEL_172:
  if ( !_memicmp(ChatText, "*szone", 6u) && player )
  {
    v78 = ChatText + 6;
    if ( ChatText[6] == ' ' )
      v78 = ChatText + 7;
    if ( *v78 == '_' )
      *v78 = ' ';
    if ( player->isSysop || *v78 != '*' || !_memicmp(v78, "*permit", 7u) || !_memicmp(v78, "*revoke", 7u) )
    {
      v302 = SoundByte;
      a4 = 2;
      v79 = BillingConnectionStructPointer;
      strcpy(&v303, v78);
      if ( v79 )
        SendBillerZoneRevokePermitPacket(v79, player->BillerPlayerId, BillingScoreId, &a4, strlen(v78) + 3);
    }
    return;
  }
  if ( _memicmp(ChatText, "*zone", 5u) )
  {
    if ( _memicmp(ChatText, "*where", 6u) || !player )
    {
      if ( _memicmp(ChatText, "*info", 5u) || !player )
      {
        if ( _memicmp(ChatText, "*getlist", 8u) || !player )
        {
          if ( _memicmp(ChatText, "*putlist", 8u) || !player )
          {
            if ( _memicmp(ChatText, "*getmodlist", 0xBu) || !player )
            {
              if ( _memicmp(ChatText, "*putmodlist", 0xBu) || !player )
              {
                if ( _memicmp(ChatText, "*recycle", 8u) )
                {
                  if ( _memicmp(ChatText, "*moderator", 0xAu) )
                  {
                    if ( _memicmp(ChatText, "*restart", 8u) || !player )
                    {
                      if ( _memicmp(ChatText, "*prize", 6u) )
                      {
                        if ( !_memicmp(ChatText, "*trace", 6u) && player )
                        {
                          if ( player->unknownIthoughtItWasPlayerPointerDupe
                            && GetExitCodeProcess(player->unknownIthoughtItWasPlayerPointerDupe, buf) )
                          {
                            if ( *buf == 259 )
                              TerminateProcess(player->unknownIthoughtItWasPlayerPointerDupe, 0);
                            CloseHandle(player->unknownIthoughtItWasPlayerPointerDupe);
                            player->unknownIthoughtItWasPlayerPointerDupe = 0;
                            player->dword4 = 0;
                            player->dword8 = 0;
                            player->dwordC = 0;
                          }
                          if ( a3 == 5 )
                          {
                            v126 = PlayerList[arenaPlayerIndex];
                            if ( v126 )
                            {
                              v127 = GetIPAddressString(v126->IPAddressDWORD);
                              sprintf(buff, "SUBGAME /SPAWN tracert %s > spawn.log", v127);
                              memset(StartupInfo, 0, sizeof(StartupInfo));
                              *StartupInfo = 68;
                              *&StartupInfo[12] = "Spawned TRACERT";
                              CreateProcessA(0, buff, 0, 0, 0, 0x20u, 0, 0, StartupInfo, player);
                              SendMessage(player, "SPAWN STARTED", 0);
                            }
                          }
                        }
                      }
                      else
                      {
                        v111 = ChatText[6];
                        v112 = ChatText + 6;
                        ChatText += 6;
                        if ( v111 == 32 )
                        {
                          do
                            v113 = *++v112;
                          while ( v113 == 32 );
                          ChatText = v112;
                        }
                        v114 = *v112;
                        v115 = *v112 == 35;
                        buf[0] = 32;
                        *&buf[3] = 0;
                        *&buf[1] = 1;
                        if ( v115 )
                        {
                          *&buf[3] = atoi(v112 + 1);
                        }
                        else if ( isdigit(v114) )
                        {
                          *&buf[1] = atoi(v112);
                        }
                        if ( !player->isSysop )
                        {
                          v116 = *&buf[1];
                          strcpy(&buf[1], "d");
                          if ( v116 <= 100 )
                            *&buf[1] = v116;
                        }
                        if ( player )
                          SendMessage(player, "Granting prize(s)", 0);
                        if ( a3 == 5 )
                        {
                          v117 = PlayerList[arenaPlayerIndex];
                          if ( v117 )
                          {
                            SendPlayerReliablePacket(v117, buf, 5u, 1);
                            v117->field_305 = 1;
                          }
                        }
                        else if ( a3 == 3 )
                        {
                          SendReliablePacketToMyFrequency(player, buf, 5u, 1);
                          SendPlayerReliablePacket(player, buf, 5u, 1);
                          v118 = player->MyArena;
                          v119 = 0;
                          if ( v118->ArenaPlayerCount > 0 )
                          {
                            v120 = 16072;
                            do
                            {
                              v121 = v118->PlayerPointers[v120];
                              ++v119;
                              ++v120;
                              v121->field_305 = 1;
                              v118 = player->MyArena;
                            }
                            while ( v119 < v118->ArenaPlayerCount );
                          }
                        }
                        else
                        {
                          ArenaSendPacket(player->MyArena, buf, 5, 1);
                          v122 = player->MyArena;
                          v123 = 0;
                          if ( v122->ArenaPlayerCount > 0 )
                          {
                            v124 = 16072;
                            do
                            {
                              v125 = v122->PlayerPointers[v124];
                              ++v123;
                              ++v124;
                              v125->field_305 = 1;
                              v122 = player->MyArena;
                            }
                            while ( v123 < v122->ArenaPlayerCount );
                          }
                        }
                      }
                    }
                    else
                    {
                      player->MyArena->GameTimePassedTwo = 0;
                    }
                  }
                  else if ( a3 == 5 )
                  {
                    v109 = PlayerList[arenaPlayerIndex];
                    if ( v109 )
                    {
                      v110 = v109->isModerator;
                      v109->isModerator = v110 == 0;
                      if ( v110 )
                        SendMessage(player, "Player Moderator Mode OFF", 0);
                      else
                        SendMessage(player, "Player Moderator Mode ON", 0);
                    }
                  }
                }
                else
                {
                  if ( player )
                    SendMessage(player, "Recycling Server", 0);
                  bRecycleServer = 1;
                }
              }
              else
              {
                a4 = 25;
                strncpy(v307, "moderate.txt", 0x10u);
                v308 = 0;
                strncpy(&v302, "moderate.txt", 0x100u);
                v306 = 0;
                SendPlayerReliablePacket(player, &a4, 0x111u, 1);
              }
            }
            else
            {
              SendMessage(player, "File sent: moderate.txt (please wait...)", 0);
              SendFile(player, "moderate.txt");
            }
          }
          else
          {
            a4 = 25;
            strncpy(&v302, "permit.txt", 0x100u);
            v306 = 0;
            strncpy(v307, "permit.txt", 0x10u);
            v308 = 0;
            SendPlayerReliablePacket(player, &a4, 0x111u, 1);
          }
        }
        else
        {
          SendMessage(player, "File sent: permit.txt (please wait...)", 0);
          SendFile(player, "permit.txt");
        }
      }
      else if ( a3 == 5 )
      {
        v88 = PlayerList[arenaPlayerIndex];
        if ( v88 )
        {
          arenaa[1] = (v88->DemoPlayer != 0);
          v278 = v88->Frequency;
          v276 = v88->TimeZoneBias;
          IpAddress = GetIPAddressString(v88->IPAddressDWORD);
          sprintf(
            buff,
            "IP:%s  TimeZoneBias:%d  Freq:%d  TypedName:%s  Demo:%d",
            IpAddress,
            v276,
            v278,
            v88->TypedName,
            arenaa[1]);
          if ( player->isSysop )
            sprintf(&buff[strlen(buff)], "  MachineId:%d", v88->MachineId);
          SendMessage(player, buff, 0);
          v90 = player->MyArena;
          if ( v90->ServersideArenaSettings.KingDeathCount > 0 )
          {
            sprintf(
              buff,
              "DeathsLeft:%d  KillsNeeded:%d",
              v88->KotHDeathCount,
              v90->ServersideArenaSettings.KingCrownRecoverKills - v88->KingCrownKills);
            SendMessage(player, buff, 0);
          }
          sprintf(
            buff,
            "Ping:%dms  LowPing:%dms  HighPing:%dms  AvePing:%dms",
            10 * v88->CurrentPing,
            10 * v88->LowPing,
            10 * v88->HighPing,
            10 * v88->AveragePing);
          SendMessage(player, buff, 0);
          sprintf(
            buff,
            "S2CAveLatency:%dms  C2SAveLatency:%dms",
            v88->S2CAverageLatency,
            10 * v88->C2SAverageLatencyFirst / (v88->C2SAverageLatencySecond + 1));
          v91 = v88->SecurityWeaponCountTotal;
          v92 = 1000;
          if ( v91 > 200 )
            v92 = 1000 * v88->SecurityWeaponCount / v91;
          TotalPacketClustersCalls = 1000 - v92;
          sub_41CB70(v88->encryptionPointer, &arenaa[7], &tempValue);
          arenaa[7] = (1000 - arenaa[7]);
          v93 = v88->encryptionPointer;
          tempValue = 1000 - tempValue;
          v94 = GetRelAckDiff(v93, &TotalPacketSendLength);
          sprintf(buff, "LOSS: S2C:%.1f%%  C2S:%.1f%%", arenaa[7] * unk_429008, tempValue * unk_429008);
          if ( player->isSysop )
            sprintf(
              &buff[strlen(buff)],
              "  S2CWeapons:%.1f%%  S2C_RelOut:%d(%d)",
              TotalPacketClustersCalls * unk_429008,
              v94,
              TotalPacketSendLength);
          SendMessage(player, buff, 0);
          if ( player->isSuperModerator )
          {
            GetPacketCountInfoSomething(
              v88->encryptionPointer,
              &a2,
              &TotalPacketClustersCalls,
              &Size,
              &TotalPacketRecvLength);
            sprintf(buff, "S2C:%d-->%d  C2S:%d-->%d", a2, TotalPacketRecvLength, Size, TotalPacketClustersCalls);
            SendMessage(player, buff, 0);
            v95 = v88->C2SCurrentFast;
            v96 = v88->C2SCurrentSlow;
            v97 = 0.0;
            arenaa[6] = 0;
            v286 = v96;
            *buf = v96 + v95;
            if ( v96 + v95 > 0 )
              *&arenaa[6] = v286 * 100.0 / *buf;
            v98 = v88->C2SCurrentTotalSlow;
            v99 = v88->C2SCurrentTotalFast;
            *buf = v98;
            v286 = v99 + v98;
            if ( v99 + v98 > 0 )
              v97 = *buf * 100.0 / v286;
            sprintf(
              buff,
              "C2S CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v96,
              v95,
              *&arenaa[6],
              v98,
              v99,
              v97);
            SendMessage(player, buff, 0);
            v100 = *&v88->gap_12B[25];
            v101 = 0.0;
            v102 = *&v88->gap_12B[27];
            arenaa[6] = 0;
            *buf = v100;
            v286 = v102 + v100;
            if ( v102 + v100 > 0 )
              *&arenaa[6] = *buf * 100.0 / v286;
            v103 = *&v88->gap_12B[21];
            v104 = *&v88->gap_12B[17];
            *buf = v104;
            v286 = v104 + v103;
            if ( v104 + v103 > 0 )
              v101 = *buf * 100.0 / v286;
            sprintf(
              buff,
              "S2C CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v100,
              v102,
              *&arenaa[6],
              v104,
              v103,
              v101);
            SendMessage(player, buff, 0);
          }
          arenaa[1] = v88->TotalUsageSeconds2;
          v105 = time(0);
          v106 = difftime(v105, arenaa[1]);
          sprintf(String, "TIME: Session:%5d:%02d:00", v106 / 3600, v106 / 60 % 60);
          if ( player->isSysop )
          {
            v107 = v106 + v88->UsageTotalSeconds;
            sprintf(
              &String[strlen(String)],
              "  Total:%5d:%02d:00  Created: %d-%d-%d %02d:%02d:%02d",
              v107 / 3600,
              v107 / 60 % 60,
              v88->AccountCreationMonth,
              v88->AccountCreationDay,
              v88->AccountCreationYear,
              v88->AccountCreationHour,
              v88->AccountCreationMinute,
              v88->AccountCreationSecond);
          }
          SendMessage(player, String, 0);
          if ( player->isSysop )
          {
            if ( player->MyArena->ServersideArenaSettings.MiscTimedGame > 0 )
            {
              sprintf(
                buff,
                "BEST SCORE Points:%d  Win:%d  Lose:%d",
                *&v88->PersonalBestPoints1of2 + *&v88->PersonalBestPoints2of2,
                v88->PersonalBestWins,
                v88->PersonalBestLosses);
              SendMessage(player, buff, 0);
            }
            v108 = v88->encryptionPointer;
            arenaa[6] = 0;
            TotalPacketClustersCalls = 0;
            TotalPacketRecvLength = 0;
            Size = 0;
            sub_41C9B0(v108, &arenaa[6], &TotalPacketClustersCalls);
            GetASyncS2CInfoSomething(v88->encryptionPointer, &TotalPacketRecvLength, &Size);
            if ( arenaa[6] > 0 || TotalPacketRecvLength > 0 )
            {
              sprintf(
                buff,
                "Async C2S:%d of %d  S2C:%d of %d",
                TotalPacketClustersCalls,
                arenaa[6],
                Size,
                TotalPacketRecvLength);
              SendMessage(player, buff, 0);
            }
          }
        }
      }
    }
    else if ( a3 == 5 )
    {
      v87 = PlayerList[arenaPlayerIndex];
      if ( v87 )
      {
        sprintf(
          AppName,
          "%s: %c%d",
          v87->PlayerName,
          10 * (v87->XPixels / 16) / 512 + 65,
          10 * (v87->YPixels / 16) / 512 + 1);
        SendMessage(player, AppName, 0);
      }
    }
  }
  else
  {
    v80 = ChatText[5];
    v81 = ChatText + 5;
    ChatText += 5;
    if ( v80 == ' ' )
    {
      do
        v82 = *++v81;
      while ( v82 == ' ' );
      ChatText = v81;
    }
    if ( player )
    {
      v83 = player->MyArena;
      if ( v83 )
        FormatMessageArena(v83, "%s\n", v81);
    }
    if ( *v81 == '_' )
      *v81 = ' ';
    v303 = SoundByte;
    a4 = 7;
    v302 = 0;
    v304 = -1;
    strcpy(v305, v81);
    v84 = strlen(v81) + 1;
    v85 = 0;
    if ( CurrentPlayerCount > 0 )
    {
      v86 = playerPointerList;
      do
      {
        if ( (*v86)->MyArena )
          SendPlayerReliablePacket(*v86, &a4, v84 - 1 + 6, 1);
        ++v85;
        ++v86;
      }
      while ( v85 < CurrentPlayerCount );
    }
  }
LABEL_294:
  if ( _memicmp(ChatText, "*arena", 6u) )
  {
    if ( !_memicmp(ChatText, "*permit", 7u) )
    {
      v133 = ChatText[7];
      v134 = ChatText + 7;
      ChatText += 7;
      if ( v133 == 32 )
      {
        do
          v135 = *++v134;
        while ( v135 == ' ' );
        ChatText = v134;
      }
      if ( *v134 )
      {
        AddLineTextFile(PermitPointer, v134);
        WriteTextFileToFile(PermitPointer);
        if ( !player )
          return;
        sprintf(buff, "Permission Added: %s", v134);
        SendMessage(player, buff, 0);
      }
      goto LABEL_443;
    }
    if ( _memicmp(ChatText, "*revoke", 7u) )
    {
      if ( _memicmp(ChatText, "*banner", 7u) || !player )
      {
        if ( _memicmp(ChatText, "*shutup", 7u) || !player )
        {
          if ( _memicmp(ChatText, "*lock", 5u) || !player )
          {
            if ( _memicmp(ChatText, "*timer", 6u) || !player )
            {
              if ( _memicmp(ChatText, "*spec", 5u) || !player )
              {
                if ( _memicmp(ChatText, "*kill", 5u) || !player )
                {
                  if ( _memicmp(ChatText, "*flagreset", 0xAu) )
                  {
                    if ( _memicmp(ChatText, "*shipreset", 0xAu) )
                    {
                      if ( _memicmp(ChatText, "*scorereset", 0xBu) )
                      {
                        if ( _memicmp(ChatText, "*timereset", 0xAu) )
                        {
                          if ( _memicmp(ChatText, "*beginlog", 9u) || !player )
                          {
                            if ( !_memicmp(ChatText, "*endlog", 7u) )
                            {
                              if ( !player )
                                return;
                              v165 = player->pfile329;
                              if ( v165 )
                              {
                                fprintf(v165, "Name               Win  Lose  Points\n");
                                fprintf(player->pfile329, "---------------- ----- ----- -------\n");
                                v166 = player->MyArena;
                                if ( v166 )
                                {
                                  v167 = 0;
                                  if ( v166->ArenaPlayerCount > 0 )
                                  {
                                    v168 = 16072;
                                    do
                                    {
                                      fprintf(
                                        player->pfile329,
                                        "%-16.16s %5d %5d %7d\n",
                                        v166->PlayerPointers[v168]->Name,
                                        v166->PlayerPointers[v168]->CurrentWins,
                                        v166->PlayerPointers[v168]->CurrentLosses,
                                        v166->PlayerPointers[v168]->FlagPoints + v166->PlayerPointers[v168]->KillPoints);
                                      v166 = player->MyArena;
                                      ++v167;
                                      ++v168;
                                    }
                                    while ( v167 < v166->ArenaPlayerCount );
                                  }
                                }
                                fprintf(player->pfile329, "\nLOG FINISHED\n");
                                fclose(player->pfile329);
                                player->pfile329 = 0;
                                sprintf(String, "Logging session closed, sending file: %s", &player->char32d);
                                SendMessage(player, String, 0);
                                SendFile(player, &player->char32d);
                              }
                            }
                          }
                          else
                          {
                            v161 = player->pfile329;
                            v162 = ChatText + 9;
                            ChatText += 9;
                            if ( v161 )
                              fclose(v161);
                            v163 = rand();
                            v164 = rand();
                            sprintf(&player->char32d, "SS%d.log", v164 + v163);
                            player->pfile329 = fopen(&player->char32d, "wt");
                            sprintf(String, "Logging session to: %s", &player->char32d);
                            SendMessage(player, String, 0);
                            fprintf(player->pfile329, "LOG STARTED:%s\n", v162);
                          }
                        }
                        else
                        {
                          if ( !player )
                            return;
                          v160 = player->MyArena;
                          if ( v160 )
                          {
                            if ( v160->ServersideArenaSettings.MiscTimedGame <= 0 )
                              SendMessage(player, "Invalid command, this is not a timed game", 0);
                            else
                              sub_405360(v160, 1);
                          }
                        }
                      }
                      else if ( a3 == 5 )
                      {
                        if ( player )
                          SendMessage(player, "Player score reset", 0);
                        playerrrrrrr = PlayerList[arenaPlayerIndex];
                        if ( playerrrrrrr )
                          SendResetScoresPacket(playerrrrrrr);
                      }
                      else
                      {
                        if ( !player )
                          return;
                        ArenaScoreReset(player->MyArena, 1);
                      }
                    }
                    else
                    {
                      buferrr = 27;
                      if ( a3 == 5 )
                      {
                        if ( player )
                          SendMessage(player, "Player ship reset", 0);
                        playerrrrrr = PlayerList[arenaPlayerIndex];
                        if ( playerrrrrr )
                          SendPlayerReliablePacket(playerrrrrr, &buferrr, 1u, 1);
                      }
                      else if ( player )
                      {
                        SendMessage(player, "All ships reset", 0);
                        ArenaSendPacket(player->MyArena, &buferrr, 1, 1);
                      }
                      else
                      {
                        v157 = 0;
                        if ( CurrentPlayerCount > 0 )
                        {
                          v158 = playerPointerList;
                          do
                          {
                            if ( (*v158)->MyArena )
                              SendPlayerReliablePacket(*v158, &buferrr, 1u, 1);
                            ++v157;
                            ++v158;
                          }
                          while ( v157 < CurrentPlayerCount );
                        }
                      }
                    }
                  }
                  else if ( player )
                  {
                    SendMessage(player, "Flag game being reset", 0);
                    arena = player->MyArena;
                    if ( arena )
                      ResetFlagGame(arena);
                  }
                  else
                  {
                    v154 = 0;
                    if ( ArenaArrayLength > 0 )
                    {
                      v155 = Arenas;
                      do
                      {
                        ResetFlagGame(*v155);
                        ++v154;
                        v155 += 4;
                      }
                      while ( v154 < ArenaArrayLength );
                    }
                  }
                }
                else if ( a3 == 5 )
                {
                  v148 = PlayerList[arenaPlayerIndex];
                  if ( v148 )
                  {
                    if ( player->isSysop || !v148->isSuperModerator )
                    {
                      v148->DisconnectReason = 4;
                      v148->AlreadySentReliablePacket = 1;
                      WriteSubGameLog("Player kicked off by moderator: %s\n", v148->Name);
                      SendMessage(player, "Player kicked off", 0);
                      if ( ChatText[5] == ' ' )
                      {
                        v149 = atoi(ChatText + 6);
                        if ( v149 > 0 )
                        {
                          v150 = MachineIdArrayIndex;
                          if ( MachineIdArrayIndex < 1000 )
                          {
                            KickedUsers[MachineIdArrayIndex].MachineId = v148->MachineId;
                            v151 = v150;
                            KickedUsers[v151].KickStartTime = GetTickCount() / 0xA;
                            v152 = MachineIdArrayIndex + 1;
                            KickedUsers[v151].KickDelayMilliseconds = 6000 * v149;// 6000 is probably milliseconds so 6 second kick minimum
                            MachineIdArrayIndex = v152;
                          }
                        }
                      }
                    }
                    else
                    {
                      SendMessage(v148, "Moderator attempted to kick you off", 0);
                    }
                  }
                }
              }
              else if ( a3 == 5 )
              {
                playerrrrr = PlayerList[arenaPlayerIndex];
                if ( playerrrrr )
                {
                  if ( player->isSysop || !playerrrrr->isSuperModerator )
                  {
                    if ( playerrrrr->Ship != 8 )
                      SetPlayerShip(playerrrrr, 8);
                    v147 = playerrrrr->IsSpeced;
                    playerrrrr->IsSpeced = v147 == 0;
                    if ( v147 )
                      SendMessage(player, "Player free to enter arena", 0);
                    else
                      SendMessage(player, "Player locked in spectator mode", 0);
                  }
                }
              }
            }
            else
            {
              v143 = ChatText[6];
              v144 = ChatText + 6;
              ChatText += 6;
              if ( v143 == ' ' )
              {
                do
                  v145 = *++v144;
                while ( v145 == ' ' );
                ChatText = v144;
              }
              if ( *v144 )
              {
                player->MyArena->GameTimeStart = 6000 * atoi(v144);
                player->MyArena->GameTimePassed = GetTickCount() / 0xA;
                player->MyArena->field_FF56 = 0;
              }
            }
          }
          else if ( player->MyArena )
          {
            if ( _memicmp(ChatText, "*lockpublic", 11u) )
            {
              if ( _memicmp(ChatText, "*lockteam", 9u) )
              {
                if ( _memicmp(ChatText, "*lockprivate", 12u) )
                {
                  if ( _memicmp(ChatText, "*lockall", 8u) )
                  {
                    if ( _memicmp(ChatText, "*lockspec", 9u) )
                    {
                      if ( !ChatText[5] )
                      {
                        player->MyArena->ArenaLocked = player->MyArena->ArenaLocked == 0;
                        if ( player->MyArena->ArenaLocked )
                          SendMessage(player, "Arena LOCKED", 0);
                        else
                          SendMessage(player, "Arena UNLOCKED", 0);
                      }
                    }
                    else
                    {
                      player->MyArena->SpecMessageLock = player->MyArena->SpecMessageLock == 0;
                      if ( player->MyArena->SpecMessageLock )
                        SendMessage(player, "Message lock applies to spectators only.", 0);
                      else
                        SendMessage(player, "Message lock applies to everybody.", 0);
                    }
                  }
                  else
                  {
                    player->MyArena->AllMessagesLocked = player->MyArena->AllMessagesLocked == 0;
                    player->MyArena->AllMessagesLockedAgainSomething = player->MyArena->AllMessagesLocked;
                    if ( player->MyArena->AllMessagesLocked )
                      SendMessage(player, "All Messages LOCKED", 0);
                    else
                      SendMessage(player, "All Messages UNLOCKED", 0);
                  }
                }
                else
                {
                  player->MyArena->PrivateMessagesLocked = player->MyArena->PrivateMessagesLocked == 0;
                  if ( player->MyArena->PrivateMessagesLocked )
                    SendMessage(player, "Private Messages LOCKED", 0);
                  else
                    SendMessage(player, "Private Messages UNLOCKED", 0);
                }
              }
              else
              {
                player->MyArena->AllMessagesLocked = player->MyArena->AllMessagesLocked == 0;
                if ( player->MyArena->AllMessagesLocked )
                  SendMessage(player, "Team Messages LOCKED", 0);
                else
                  SendMessage(player, "Team Messages UNLOCKED", 0);
              }
            }
            else
            {
              player->MyArena->AllMessagesLocked = player->MyArena->AllMessagesLocked == 0;
              if ( player->MyArena->AllMessagesLocked )
                SendMessage(player, "Public Messages LOCKED", 0);
              else
                SendMessage(player, "Public Messages UNLOCKED", 0);
            }
          }
        }
        else if ( a3 == 5 )
        {
          v141 = PlayerList[arenaPlayerIndex];
          if ( v141 )
          {
            if ( v141->isSysop || v141->isSuperModerator && !player->isSysop )
            {
              sprintf(String, "%s tried to shut you up", player->Name);
              SendMessage(v141, String, 0);
            }
            else
            {
              v142 = v141->IsSilenced;
              v141->IsSilenced = v142 == 0;     // IsSilenced != IsSilenced
              if ( v142 )
                arenaa[0] = "%s can now speak";
              else
                arenaa[0] = "%s has been silenced";
              sprintf(String, arenaa[0], v141->Name);
              SendMessage(player, String, 0);
            }
          }
        }
      }
      else
      {
        player->dword30 = 1;
        v140 = player->PlayerId;
        String[0] = 31;
        *&String[1] = v140;
        qmemcpy(&String[3], player->BannerData, 0x60u);
        ArenaSendPacket(player->MyArena, String, 99, 1);
      }
      goto LABEL_443;
    }
    v136 = ChatText[7];
    v137 = ChatText + 7;
    ChatText += 7;
    if ( v136 == 32 )
    {
      do
        v138 = *++v137;
      while ( v138 == 32 );
      ChatText = v137;
    }
    if ( *v137 )
    {
      if ( !strcmp(v137, "*") )
      {
        CleanTextFileMemory(PermitPointer);
      }
      else
      {
        v139 = IsBannedMachineId(PermitPointer, v137);
        if ( v139 >= 0 )
          ListMachineSomething(v139, arenaa[2]);
      }
      WriteTextFileToFile(PermitPointer);
      if ( !player )
        return;
      SendMessage(player, "Permission revoked", 0);
    }
LABEL_443:
    if ( player )
    {
      v169 = ChatText + 1;
      if ( !_strcmpi(ChatText + 1, SysopPassword) )
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", player->Name);
        player->isSysop = 1;
        player->isModerator = 1;
        player->isSuperModerator = 1;
      }
      if ( !_strcmpi(v169, SuperModeratorPassword) )
      {
        WriteSubGameLog("%s> SUPER MODERATOR LOGGED IN\n", player->Name);
        player->isModerator = 1;
        player->isSuperModerator = 1;
      }
      if ( !_strcmpi(v169, ModeratorPassword) )
      {
        WriteSubGameLog("%s> MODERATOR LOGGED IN\n", player->Name);
        player->isModerator = 1;
      }
      if ( !_strcmpi(v169, EnergyPassword) )
      {
        WriteSubGameLog("%s> ENERGY VIEWING TURNED ON/OFF\n", player->Name);
        if ( player->MyArena )
        {
          v170 = player->isEnergyShowing;
          player->isEnergyShowing = v170 == 0;
          if ( v170 )
            SendMessage(player, "Showing Energy OFF", 0);
          else
            SendMessage(player, "Showing Energy ON", 0);
        }
      }
    }
    return;
  }
  v128 = ChatText[6];
  v129 = ChatText + 6;
  ChatText += 6;
  if ( v128 == ' ' )
  {
    do
      v130 = *++v129;
    while ( v130 == ' ' );
    ChatText = v129;
  }
  if ( *v129 == '_' )
    *v129 = ' ';
  if ( player )
  {
    v131 = player->MyArena;
    if ( v131 )
      FormatMessageArena(v131, "%s\n", v129);
  }
  v303 = SoundByte;
  a4 = 7;
  v302 = 0;
  v304 = -1;
  strcpy(v305, ChatText);
  v132 = strlen(ChatText) + 1;
  if ( player )
  {
    ArenaSendPacket(player->MyArena, &a4, v132 + 5, 1);
    goto LABEL_443;
  }
}
// 414850: could not find valid save-restore pair for edi
// 4149DE: conditional instruction was optimized away because of 'ebp.4!=0'
// 4149F0: conditional instruction was optimized away because of 'ebp.4!=0'
// 414BA9: conditional instruction was optimized away because of 'ecx.4>=1'
// 416F2F: conditional instruction was optimized away because of 'eax.4!=0'
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);
// 42C848: using guessed type char *off_42C848[8];
// 431BE8: using guessed type int RadarValue;
// 431FF4: using guessed type int ArenaArrayLength;
// 431FF8: using guessed type int ServerIterations;
// 432004: using guessed type int bRecycleServer;
// 437C18: using guessed type int DoubleValue;
// 437CA8: using guessed type int bServerIsRunning;
// 4386D4: using guessed type int MachineIdArrayIndex;
// 438B10: using guessed type int ScreenValue;
// 4D5920: using guessed type int dword_4D5920;
// 4D89C8: using guessed type int Wave;
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;
// 4D8AF4: using guessed type int oldTickCountValue;

//----- (00418F20) --------------------------------------------------------
void __cdecl SomethingWithSendingChatTypes(struct_PLAYER *player, int TargetPlayerId, signed int PlayerId, char *ChatText, char SoundByte)
{
  signed int PlayerIdd; // edx
  struct_PLAYER *checkPlayer; // ecx
  struct_PLAYER *anotherPlayer; // esi
  struct_PLAYER **eachPlayerr; // ebp
  struct_PLAYER *eachPlayer; // eax
  const char *v10; // edi
  struct_PLAYER *v11; // ecx
  const char *v12; // [esp-8h] [ebp-424h]
  char *v13; // [esp-4h] [ebp-420h]
  struct_PLAYER *playerr; // [esp+10h] [ebp-40Ch]
  int v15; // [esp+14h] [ebp-408h]
  int PlayerCountCounter; // [esp+18h] [ebp-404h]
  char Dest[512]; // [esp+1Ch] [ebp-400h] BYREF
  char buf[512]; // [esp+21Ch] [ebp-200h] BYREF

  if ( HighestPlayerCountMaybeSomething )
  {
    PlayerIdd = PlayerId;
    v15 = -1;
    playerr = 0;
    if ( PlayerId >= 0 && PlayerId < 1024 )
      playerr = PlayerList[PlayerId];
    if ( TargetPlayerId == 3 && (checkPlayer = player) != 0 )
    {
      v15 = player->Frequency;
      anotherPlayer = playerr;
    }
    else
    {
      anotherPlayer = playerr;
      if ( TargetPlayerId == 4 && playerr )
        v15 = playerr->Frequency;
      checkPlayer = player;
    }
    PlayerCountCounter = 0;
    if ( CurrentPlayerCount > 0 )
    {
      eachPlayerr = playerPointerList;
      while ( 1 )
      {
        eachPlayer = *eachPlayerr;
        if ( (*eachPlayerr)->MyArena )
        {
          if ( eachPlayer->field_287 > 0 )
          {
            Dest[0] = 0;
            if ( (TargetPlayerId != 5 || *&eachPlayer->PlayerId != PlayerIdd) && checkPlayer != eachPlayer )
            {
              if ( checkPlayer )
              {
                sprintf(Dest, "%s> %s ", checkPlayer->Name, ChatText);
                switch ( TargetPlayerId )
                {
                  case 3:
                    v13 = v15;
                    v12 = "(TEAM:%d)";
                    goto LABEL_26;
                  case 4:
                    sprintf(&Dest[strlen(Dest)], "(ENEMYTEAM:%d)", v15);
                    goto LABEL_31;
                  case 5:
                    if ( anotherPlayer )
                    {
                      v13 = anotherPlayer->Name;
                      v12 = "(TO:%s)";
LABEL_26:
                      sprintf(&Dest[strlen(Dest)], v12, v13);
                    }
                    else
                    {
                      v10 = "(TO:----)";
LABEL_30:
                      strcat(Dest, v10);
                    }
LABEL_31:
                    v11 = *eachPlayerr;
                    if ( player->MyArena == (*eachPlayerr)->MyArena )
                    {
                      if ( v11->Frequency == v15
                        || (TargetPlayerId == 1 || TargetPlayerId == 2) && *ChatText != '*' && *ChatText != '?'
                        || TargetPlayerId != 5 && v11->field_287 < 2 )
                      {
                        goto LABEL_46;
                      }
                    }
                    else
                    {
                      if ( v11->field_287 < 3 )
                        goto LABEL_46;
                      strcat(Dest, "(SPAWN)");
                    }
                    break;
                  case 7:
                    v10 = "(FIND)";
                    goto LABEL_30;
                  case 9:
                    v10 = "(CHAT)";
                    goto LABEL_30;
                  default:
                    goto LABEL_31;
                }
              }
              else
              {
                if ( eachPlayer->field_287 < 4 )
                  goto LABEL_46;
                sprintf(Dest, "*> %s ", ChatText);
              }
              if ( Dest[0] )
              {
                buf[2] = SoundByte;
                buf[0] = 7;                     // 0x07 - Chat
                buf[1] = 6;                     // Chat Type - 0x06 - Red warning message [MODERATOR WARNING: Whatever -Whoever]
                *&buf[3] = -1;
                strcpy(&buf[5], Dest);
                SendPlayerReliablePacket(*eachPlayerr, buf, strlen(Dest) + 6, 1);
              }
            }
          }
        }
LABEL_46:
        ++eachPlayerr;
        if ( ++PlayerCountCounter >= CurrentPlayerCount )
          return;
        anotherPlayer = playerr;
        PlayerIdd = PlayerId;
        checkPlayer = player;
      }
    }
  }
}
// 4D8AF8: using guessed type int HighestPlayerCountMaybeSomething;

//----- (00419270) --------------------------------------------------------
// updates the points a player has, logging if necessary
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3)
{
  int v3; // ecx
  FILE *v4; // eax
  int v5; // ecx
  int Str[4]; // [esp+Ch] [ebp-10h] BYREF

  v3 = a3 + *(player + 557);
  *(player + 553) += a2;
  *(player + 557) = v3;
  if ( MiscLogPoints && BillingConnectionStructPointer )
  {
    v4 = PointsFileHandle;
    if ( !PointsFileHandle )
    {
      v4 = fopen("points.log", "ab");
      PointsFileHandle = v4;
    }
    v5 = *(player + 7);
    if ( v5 && *(v5 + 65378) )
    {
      if ( v4 )
      {
        Str[0] = *(player + 539);
        Str[1] = a2;
        Str[2] = a3;
        Str[3] = time(0);
        fwrite(Str, 0x10u, 1u, PointsFileHandle);
      }
    }
  }
  else if ( PointsFileHandle )
  {
    fclose(PointsFileHandle);
    PointsFileHandle = 0;
  }
}
// 41CF20: using guessed type _DWORD __cdecl time(_DWORD Time);

//----- (00419350) --------------------------------------------------------
void __cdecl ReadServerINI()
{
  DWORD v0; // edi
  int v1; // eax
  DWORD v2; // edi
  int v3; // eax
  DWORD v4; // edi
  int v5; // eax
  DWORD v6; // edi
  int v7; // eax
  DWORD v8; // esi
  int v9; // eax
  int ServerIdRandomValue; // eax
  char Dest[16]; // [esp+Ch] [ebp-10h] BYREF

  CustomArenaMode = GetPrivateProfileIntWrapper("Custom", "ArenaMode", 0, FileName);
  ArenaMaxPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMaxPlayers", 0x3Cu, FileName);
  ArenaDesiredPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaDesiredPlayers", 0x28u, FileName);
  ArenaMinimumPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMinimumPlayers", 0xFu, FileName);
  ArenaSpawnKeepScores = GetPrivateProfileIntWrapper("Arena", "SpawnKeepScores", 0, FileName);
  MaxArenas = GetPrivateProfileIntWrapper("Arena", "MaxArenas", 0x64u, FileName);
  MaxArenasMemory = GetPrivateProfileIntWrapper("Arena", "MaxArenasMemory", 0xFA00u, FileName);
  CommsMaxQueueToLogin = GetPrivateProfileIntWrapper("Comms", "MaxQueueToLogin", 0x10u, FileName);
  CommsPacketHistoryMax = GetPrivateProfileIntWrapper("Comms", "PacketHistoryMax", 0x7D0u, FileName);
  CommsIncomingBufferSize = GetPrivateProfileIntWrapper("Comms", "IncomingBufferSize", 0x20000u, FileName);
  CommsOutgoingBufferSize = GetPrivateProfileIntWrapper("Comms", "OutgoingBufferSize", 0x20000u, FileName);
  CommsTransportBufferSize = GetPrivateProfileIntWrapper("Comms", "TransportBufferSize", 0xA0u, FileName);
  MiscDisableShareware = 1;
  MiscDisableSharewareShips = 1;
  MiscDisableSharewareScores = 1;
  CommsEncryptMode = 1;
  dword_437B14 = 1;
  BillingLogMessages = 0;
  MiscRegisterKickShareware = 1;
  MiscMaxSharewarePlayers = GetPrivateProfileIntWrapper("Misc", "MaxSharewarePlayers", 0xFFFFFFFF, FileName);
  MiscMaxSharkwareTime = GetPrivateProfileIntWrapper("Misc", "MaxSharewareTime", 90000u, FileName);
  MiscMaxPlayers = GetPrivateProfileIntWrapper("Misc", "MaxPlayers", 120u, FileName);
  MiscMenuKickOutDelay = GetPrivateProfileIntWrapper("Misc", "MenuKickOutDelay", 12000u, FileName);
  MiscLogPoints = GetPrivateProfileIntWrapper("Misc", "LogPoints", 0, FileName);
  MiscPointUpdateDiff = GetPrivateProfileIntWrapper("Misc", "PointUpdateDiff", 500u, FileName);
  MiscJackpotBroadcastPoints = GetPrivateProfileIntWrapper("Misc", "JackpotBroadcastPoints", 0, FileName);
  MiscServerLog = GetPrivateProfileIntWrapper("Misc", "ServerLog", 0, FileName);
  MiscKeepAliveDelay = GetPrivateProfileIntWrapper("Misc", "KeepAliveDelay", 400u, FileName);
  GetPrivateProfileStringWrapper("Misc", "DefaultLevelFile", "changeme.lvl", MiscDefaultLevelFile, 0x100u, FileName);
  CPUProcessMaxTime = GetPrivateProfileIntWrapper("CPU", "ProcessMaxTime", 4u, FileName);
  CPUSleepPerIteration = GetPrivateProfileIntWrapper("CPU", "SleepPerIteration", 0, FileName);
  CPUSleepTime = GetPrivateProfileIntWrapper("CPU", "SleepTime", 0, FileName);
  CPUSlowIterationWarningLevel = GetPrivateProfileIntWrapper("CPU", "SlowIterationWarningLevel", 100u, FileName);
  PermissionAllowLowBandwidth = GetPrivateProfileIntWrapper("Permission", "AllowLowBandwidth", 1u, FileName);
  PermissionMinimumSecondsToLogin = GetPrivateProfileIntWrapper("Permission", "MinimumSecondsToLogin", 0, FileName);
  PermissionMaxPoints = GetPrivateProfileIntWrapper("Permission", "PermissionMaxPoints", 0, FileName);
  PermissionMode = GetPrivateProfileIntWrapper("Permission", "PermissionMode", 0, FileName);
  AutoPermissionPoints = GetPrivateProfileIntWrapper("Permission", "AutoPermissionPoints", 0, FileName);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionIDList",
    "0",
    PermissionAutoPermissionIDList,
    0x200u,
    FileName);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionMessage",
    "Congratulations",
    PermissionAutoPermissionMessage,
    0x100u,
    FileName);
  v0 = GetTickCount() / 0xA;
  v1 = rand();
  sprintf(Dest, MEMORY[0x42A094], abs32(v0 + v1));
  GetPrivateProfileStringWrapper("Password", "SysopPassword", Dest, SysopPassword, 0x40u, FileName);
  v2 = GetTickCount() / 0xA;
  v3 = rand();
  sprintf(Dest, MEMORY[0x42A094], abs32(v2 + v3));
  GetPrivateProfileStringWrapper("Password", "EnergyPassword", Dest, EnergyPassword, 0x40u, FileName);
  v4 = GetTickCount() / 0xA;
  v5 = rand();
  sprintf(Dest, MEMORY[0x42A094], abs32(v4 + v5));
  GetPrivateProfileStringWrapper("Password", "ModeratorPassword", Dest, ModeratorPassword, 0x40u, FileName);
  v6 = GetTickCount() / 0xA;
  v7 = rand();
  sprintf(Dest, MEMORY[0x42A094], abs32(v6 + v7));
  GetPrivateProfileStringWrapper("Password", "SuperModeratorPassword", Dest, SuperModeratorPassword, 0x40u, FileName);
  v8 = GetTickCount() / 0xA;
  v9 = rand();
  sprintf(Dest, MEMORY[0x42A094], abs32(v8 + v9));
  GetPrivateProfileStringWrapper("Password", "VIPPassword", Dest, VIPPassword, 0x40u, FileName);
  GetPrivateProfileStringWrapper("Billing", "IP", "127.0.0.1", &BillingIP, 0x80u, FileName);
  GetPrivateProfileStringWrapper("Billing", "Password", "money", BillingPassword, 0x20u, FileName);
  GetPrivateProfileStringWrapper("Billing", "ServerName", "Unknown", BillingServerName, 0x80u, FileName);
  *&BillingPort = GetPrivateProfileIntWrapper("Billing", "Port", 900u, FileName);
  ServerIdRandomValue = rand();
  BillingServerId = GetPrivateProfileIntWrapper("Billing", "ServerId", ServerIdRandomValue, FileName);
  BillingGroupId = GetPrivateProfileIntWrapper("Billing", "GroupId", 1u, FileName);
  BillingScoreId = GetPrivateProfileIntWrapper("Billing", "ScoreId", 0, FileName);
  BillingReconnectTime = GetPrivateProfileIntWrapper("Billing", "ReconnectTime", 0x2EE0u, FileName);
  BillingAttemptTime = GetPrivateProfileIntWrapper("Billing", "AttemptTime", 0x2710u, FileName);
  AdvertiseSendMode = GetPrivateProfileIntWrapper("Advertise", "SendMode", 0, FileName);
  AdvertiseDisplayMode = GetPrivateProfileIntWrapper("Advertise", "DisplayMode", 2u, FileName);
  dword_4D8930 = GetPrivateProfileIntWrapper("Advertise", "Duration", 0x2EE0u, FileName);
  GetPrivateProfileStringWrapper("Directory", "IP", "sscentral.vie.com", DirectoryIPAddresses, 0x200u, FileName);
  GetPrivateProfileStringWrapper("Directory", "Description", "None", DirectoryDescription, 0x100u, FileName);
  GetPrivateProfileStringWrapper("Directory", "NamePassword", &DirectoryNamePassword, buffer, 0x80u, FileName);
  *&DirectoryPort = GetPrivateProfileIntWrapper("Directory", "Port", 4991u, FileName);
}
// 4D8930: using guessed type int dword_4D8930;

//----- (00419B60) --------------------------------------------------------
void __cdecl LoadTemplateSSS()
{
  FILE *v0; // eax
  FILE *v1; // edi
  char *v2; // eax
  char v3; // cl
  char *i; // edx
  char v5; // cl
  char *j; // edx
  char v7; // cl
  char *k; // edx
  char v9; // cl
  char *l; // edx
  char v11; // dl
  char *m; // ecx
  int v13; // eax
  TemplateSSS_Struct *v14; // esi
  char *v15; // esi
  char *v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int intValue; // eax
  char v21; // [esp+8h] [ebp-888h]
  char v22; // [esp+Ch] [ebp-884h]
  char v23[64]; // [esp+10h] [ebp-880h] BYREF
  char Source[64]; // [esp+50h] [ebp-840h] BYREF
  char v25[256]; // [esp+90h] [ebp-800h] BYREF
  char Str[256]; // [esp+190h] [ebp-700h] BYREF
  char v27[512]; // [esp+290h] [ebp-600h] BYREF
  char Buf[1024]; // [esp+490h] [ebp-400h] BYREF

  TotalTemplateSSSEntries = 0;
  v0 = fopen("template.sss", "rt");
  v1 = v0;
  if ( v0 )
  {
    if ( (v0->_flag & 0x10) == 0 )
    {
      do
      {
        if ( fgets(Buf, 1024, v1) && (isalpha(Buf[0]) || Buf[0] == '*' || Buf[0] == '+') )
        {
          Source[0] = 0;
          v23[0] = 0;
          Str[0] = 0;
          v25[0] = 0;
          v27[0] = 0;
          v2 = Buf;
          v21 = 0;
          if ( Buf[0] == '*' )
          {
            v21 = 1;
            v2 = &Buf[1];
          }
          v22 = 1;
          if ( *v2 == '+' )                     // Fake Settings?
          {
            v22 = 0;
            ++v2;
          }
          v3 = *v2;
          for ( i = Source; v3 != ':'; ++v2 )
          {
            if ( !v3 )
              break;
            *i = v3;
            v3 = v2[1];
            ++i;
          }
          *i = 0;
          if ( v2 )
            ++v2;
          v5 = *v2;
          for ( j = v23; v5 != ':'; ++v2 )
          {
            if ( !v5 )
              break;
            *j = v5;
            v5 = v2[1];
            ++j;
          }
          *j = 0;
          if ( v2 )
            ++v2;
          v7 = *v2;
          for ( k = Str; v7 != ':'; ++v2 )
          {
            if ( !v7 )
              break;
            *k = v7;
            v7 = v2[1];
            ++k;
          }
          *k = 0;
          if ( v2 )
            ++v2;
          v9 = *v2;
          for ( l = v25; v9 != ':'; ++v2 )
          {
            if ( !v9 )
              break;
            *l = v9;
            v9 = v2[1];
            ++l;
          }
          *l = 0;
          if ( v2 )
            ++v2;
          v11 = *v2;
          for ( m = v27; v11 >= ' '; ++v2 )
          {
            *m = v11;
            v11 = v2[1];
            ++m;
          }
          *m = 0;
          v13 = TotalTemplateSSSEntries;
          TotalTemplateSSSList[v13].SomeChar1a = v21;
          TotalTemplateSSSList[v13].SomeChar1b = v22;
          v14 = &TotalTemplateSSSList[v13];
          strncpy(TotalTemplateSSSList[v13].SomeString32, Source, 0x20u);
          v14->SomeString32[31] = 0;
          v15 = TotalTemplateSSSList[TotalTemplateSSSEntries].KeyName;
          strncpy(v15, v23, 0x28u);
          v15[39] = 0;
          v16 = TotalTemplateSSSList[TotalTemplateSSSEntries].SomeString256;
          strncpy(v16, v27, 0x100u);
          v16[255] = 0;
          v17 = TotalTemplateSSSEntries;
          v18 = TotalTemplateSSSEntries;
          if ( Str[0] )
          {
            v19 = atoi(Str);
            v17 = TotalTemplateSSSEntries;
            TotalTemplateSSSList[v18].someInteger = v19;
          }
          else
          {
            TotalTemplateSSSList[TotalTemplateSSSEntries].someInteger = -999;
          }
          if ( v25[0] )
          {
            intValue = atoi(v25);
            v17 = TotalTemplateSSSEntries;
            TotalTemplateSSSList[TotalTemplateSSSEntries].someInteger2 = intValue;
          }
          else
          {
            TotalTemplateSSSList[v18].someInteger2 = -999;
          }
          TotalTemplateSSSEntries = v17 + 1;
        }
      }
      while ( (v1->_flag & 0x10) == 0 );
    }
    fclose(v1);
  }
  printf("Template.sss read, %d entries found\n", TotalTemplateSSSEntries);
}
// 4D8AE4: using guessed type int TotalTemplateSSSEntries;

//----- (00419E50) --------------------------------------------------------
int __cdecl LoadMapSomething()
{
  int v0; // ebx
  struct BMP_FILE_STRUCT *v1; // eax
  struct BMP_FILE_STRUCT *v2; // eax
  int yTilePosition; // eax
  int v4; // ebp
  unsigned int v5; // edx
  int xCounter; // edi
  int yCounter; // esi
  int xTilePosition; // ecx
  int TileValuePointer; // [esp+10h] [ebp-24h] BYREF
  int a4[4]; // [esp+14h] [ebp-20h] BYREF
  char v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+30h] [ebp-4h]

  v0 = 0;
  if ( _access(MiscDefaultLevelFile, 0) )
  {
    printf(
      "Could not find specified level file (%s), make sure a level file with this name is in the server directory.",
      MiscDefaultLevelFile);
    exit(1);
  }
  a4[0] = 42;
  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  v11 = 0;
  strcpy(a4 + 1, MiscDefaultLevelFile);
  dword_437B0C = CompressFile(MiscDefaultLevelFile, &dword_4D8AF0, &CRC_32, a4, 0x11u, 1, 0);
  v1 = operator new(0x110u);
  TileValuePointer = v1;
  v12 = 0;
  if ( v1 )
    LoadBMPHeader(v1, MiscDefaultLevelFile);
  else
    v2 = 0;
  v12 = -1;
  BMPFile = v2;
  MapAllocateMemoryPointer = emalloc(0x100000);
  memset(MapAllocateMemoryPointer, 0, 0x100000u);
  yTilePosition = sub_406BE0(BMPFile);
  v4 = yTilePosition;
  if ( yTilePosition > 0 )
  {
    do
    {
      GetTileValue(BMPFile, v0, &TileValuePointer);
      yTilePosition = TileValuePointer;
      if ( (TileValuePointer & 0xFF000000) != 0xAA000000 )
      {
        *(MapAllocateMemoryPointer + 1024 * ((TileValuePointer >> 12) & 0xFFF) + (TileValuePointer & 0xFFF)) = HIBYTE(TileValuePointer);
        v5 = TileValuePointer;
        yTilePosition = TileValuePointer & 0xFF000000;
        if ( (TileValuePointer & 0xFF000000) >= 0xD8000000 )
        {
          for ( xCounter = 0; xCounter < 7; ++xCounter )
          {
            for ( yCounter = 0; yCounter < 7; ++yCounter )
            {
              xTilePosition = xCounter + (v5 & 0xFFF);
              yTilePosition = yCounter + ((v5 >> 12) & 0xFFF);
              if ( xTilePosition < 1024 && yTilePosition < 1024 )
              {
                yTilePosition = MapAllocateMemoryPointer + 1024 * yTilePosition + xTilePosition;
                if ( !*yTilePosition )
                {
                  *yTilePosition = -16;
                  v5 = TileValuePointer;
                }
              }
            }
          }
        }
      }
      ++v0;
    }
    while ( v0 < v4 );
  }
  return yTilePosition;
}
// 419F37: variable 'v2' is possibly undefined

//----- (0041A040) --------------------------------------------------------
void __cdecl LoadAdvertisements()
{
  int bothAdvertCounter; // esi
  HANDLE v1; // ebx
  int v2; // esi
  size_t v3; // edi
  int v4; // ebp
  char *v5; // ebx
  FILE *v6; // eax
  int v7; // esi
  bool v8; // zf
  UINT v9; // eax
  UINT v10; // eax
  int SharewareAdvertCounter; // esi
  HANDLE v12; // ebx
  int v13; // esi
  size_t v14; // edi
  int v15; // ebp
  char *v16; // ebx
  FILE *v17; // eax
  int v18; // esi
  UINT v19; // eax
  UINT v20; // eax
  int RegisteredAdvertCounter; // esi
  HANDLE v22; // ebx
  int v23; // esi
  size_t v24; // edi
  int v25; // ebp
  char *v26; // ebx
  FILE *v27; // eax
  int v28; // esi
  UINT v29; // eax
  UINT v30; // eax
  unsigned int v31; // [esp+10h] [ebp-8C0h]
  unsigned int v32; // [esp+10h] [ebp-8C0h]
  unsigned int v33; // [esp+10h] [ebp-8C0h]
  FILE *File; // [esp+14h] [ebp-8BCh]
  FILE *Filea; // [esp+14h] [ebp-8BCh]
  FILE *Fileb; // [esp+14h] [ebp-8BCh]
  FILE *v37; // [esp+18h] [ebp-8B8h]
  FILE *v38; // [esp+18h] [ebp-8B8h]
  FILE *v39; // [esp+18h] [ebp-8B8h]
  int v40; // [esp+1Ch] [ebp-8B4h]
  int v41; // [esp+1Ch] [ebp-8B4h]
  int v42; // [esp+1Ch] [ebp-8B4h]
  int v43; // [esp+20h] [ebp-8B0h]
  int v44; // [esp+20h] [ebp-8B0h]
  int v45; // [esp+20h] [ebp-8B0h]
  size_t v46; // [esp+24h] [ebp-8ACh]
  size_t v47; // [esp+24h] [ebp-8ACh]
  size_t v48; // [esp+24h] [ebp-8ACh]
  char DstBuf[14]; // [esp+28h] [ebp-8A8h] BYREF
  char pv[4]; // [esp+38h] [ebp-898h] BYREF
  unsigned int v51; // [esp+3Ch] [ebp-894h]
  int v52; // [esp+40h] [ebp-890h]
  const CHAR FileName[256]; // [esp+50h] [ebp-880h] BYREF

  bothAdvertCounter = 0;
  dword_4D8AFC = 0;
  dword_4D8B00 = 0;
  dword_4D8B04 = 0;
  v43 = 0;
  do
  {
    sprintf(FileName, "b_ad%d.bmp", bothAdvertCounter);
    if ( _access(FileName, 0) )
    {
      v10 = dword_4D8B04;
    }
    else
    {
      v1 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v1, 24, pv);
      v2 = v52;
      v31 = v51;
      v3 = 4 * ((v51 + 3) / 4);
      v46 = v3;
      DeleteObject(v1);
      v4 = v31 * v2 + 10;
      v5 = emalloc(v4);
      *v5 = 48;
      v5[1] = AdvertiseDisplayMode;
      *(v5 + 1) = v31;
      *(v5 + 2) = v2;
      *(v5 + 6) = dword_4D8930;
      v6 = fopen(
             FileName,
             "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
             "\x00\x00\x00Player spectating game: %s\n"
             "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1"
             " minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00"
             "\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00"
             "\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00"
             "Player kicked off for not returning security packet: %s\n"
             "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00P"
             "arameters resent for arena(%s)\n"
             "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user paramet"
             "er.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00"
             "Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points "
             "to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Ja"
             "velins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spid"
             "ers:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
             "\x00\x00\x00%s=%s\n"
             "\x00\x00[%s]\n"
             "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
             "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resi"
             "ze)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
             "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked o"
             "ff, arena full to demo users: %s\n"
             "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
             "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
             "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
             "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
             "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
             "\x00%s>  MODERATOR LOGGED IN\n"
             "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
             "\x00%s> SYSOP LOGGED IN\n"
             "\x00\x00\x00\x00Connection request from: %s\n"
             "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00F"
             "ile has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00"
             "File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00"
             "\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempt"
             "ing to enter game");
      File = v6;
      if ( v6 )
      {
        fread(DstBuf, 1u, 0xEu, v6);
        fseek(File, *&DstBuf[10], 0);
        v7 = v2 - 1;
        if ( v7 >= 0 )
        {
          v37 = &v5[v31 * v7 + 10];
          v40 = v7 + 1;
          while ( 1 )
          {
            fread(&FileName[128], 1u, v3, File);
            qmemcpy(v37, &FileName[128], v31);
            v8 = v40 == 1;
            v37 = (v37 - v31);
            --v40;
            if ( v8 )
              break;
            v3 = v46;
          }
        }
        fclose(File);
      }
      v9 = dword_4D8B04;
      bothAdvertCounter = v43;
      dword_437CB4[2 * dword_4D8B04] = v4;
      (&dword_437CB0)[2 * v9] = v5;
      v10 = v9 + 1;
      dword_4D8B04 = v10;
    }
    v43 = ++bothAdvertCounter;
  }
  while ( bothAdvertCounter < 128 );
  printf("%d both advertisements found\n", v10);
  SharewareAdvertCounter = 0;
  v44 = 0;
  do
  {
    sprintf(FileName, "s_ad%d.bmp", SharewareAdvertCounter);
    if ( _access(FileName, 0) )
    {
      v20 = dword_4D8AFC;
    }
    else
    {
      v12 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v12, 24, pv);
      v13 = v52;
      v32 = v51;
      v14 = 4 * ((v51 + 3) / 4);
      v47 = v14;
      DeleteObject(v12);
      v15 = v32 * v13 + 10;
      v16 = emalloc(v15);
      *v16 = 48;
      v16[1] = AdvertiseDisplayMode;
      *(v16 + 1) = v32;
      *(v16 + 2) = v13;
      *(v16 + 6) = dword_4D8930;
      v17 = fopen(
              FileName,
              "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
              "\x00\x00\x00Player spectating game: %s\n"
              "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: "
              "1 minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00"
              "\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00"
              "\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00"
              "Player kicked off for not returning security packet: %s\n"
              "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00"
              "Parameters resent for arena(%s)\n"
              "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parame"
              "ter.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00"
              "\x00Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no po"
              "ints to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:"
              "%d  Javelins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%"
              "d  Spiders:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
              "\x00\x00\x00%s=%s\n"
              "\x00\x00[%s]\n"
              "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
              "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Res"
              "ize)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
              "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked "
              "off, arena full to demo users: %s\n"
              "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
              "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
              "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
              "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
              "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
              "\x00%s>  MODERATOR LOGGED IN\n"
              "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
              "\x00%s> SYSOP LOGGED IN\n"
              "\x00\x00\x00\x00Connection request from: %s\n"
              "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00"
              "File has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00"
              "\x00File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00"
              "\x00\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol at"
              "tempting to enter game");
      v38 = v17;
      if ( v17 )
      {
        fread(DstBuf, 1u, 0xEu, v17);
        fseek(v38, *&DstBuf[10], 0);
        v18 = v13 - 1;
        if ( v18 >= 0 )
        {
          Filea = &v16[v32 * v18 + 10];
          v41 = v18 + 1;
          while ( 1 )
          {
            fread(&FileName[128], 1u, v14, v38);
            qmemcpy(Filea, &FileName[128], v32);
            v8 = v41 == 1;
            Filea = (Filea - v32);
            --v41;
            if ( v8 )
              break;
            v14 = v47;
          }
        }
        fclose(v38);
      }
      v19 = dword_4D8AFC;
      SharewareAdvertCounter = v44;
      len[2 * dword_4D8AFC] = v15;
      (&buf)[2 * v19] = v16;
      v20 = v19 + 1;
      dword_4D8AFC = v20;
    }
    v44 = ++SharewareAdvertCounter;
  }
  while ( SharewareAdvertCounter < 128 );
  printf("%d shareware advertisements found\n", v20);
  RegisteredAdvertCounter = 0;
  v45 = 0;
  do
  {
    sprintf(FileName, "r_ad%d.bmp", RegisteredAdvertCounter);
    if ( _access(FileName, 0) )
    {
      v30 = dword_4D8B00;
    }
    else
    {
      v22 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v22, 24, pv);
      v23 = v52;
      v33 = v51;
      v24 = 4 * ((v51 + 3) / 4);
      v48 = v24;
      DeleteObject(v22);
      v25 = v33 * v23 + 10;
      v26 = emalloc(v25);
      *v26 = 48;
      v26[1] = AdvertiseDisplayMode;
      *(v26 + 1) = v33;
      *(v26 + 2) = v23;
      *(v26 + 6) = dword_4D8930;
      v27 = fopen(
              FileName,
              "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
              "\x00\x00\x00Player spectating game: %s\n"
              "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: "
              "1 minute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00"
              "\x00NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00"
              "\x00\x00King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00"
              "Player kicked off for not returning security packet: %s\n"
              "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00"
              "Parameters resent for arena(%s)\n"
              "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parame"
              "ter.\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00"
              "\x00Spider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no po"
              "ints to give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:"
              "%d  Javelins:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%"
              "d  Spiders:%d  Leviathans:%d\x00\x00rt\x00\x00\n"
              "\x00\x00\x00%s=%s\n"
              "\x00\x00[%s]\n"
              "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
              "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Res"
              "ize)\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
              "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked "
              "off, arena full to demo users: %s\n"
              "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
              "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
              "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
              "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
              "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
              "\x00%s>  MODERATOR LOGGED IN\n"
              "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
              "\x00%s> SYSOP LOGGED IN\n"
              "\x00\x00\x00\x00Connection request from: %s\n"
              "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00"
              "File has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00"
              "\x00File arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00"
              "\x00\x00\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol at"
              "tempting to enter game");
      v39 = v27;
      if ( v27 )
      {
        fread(DstBuf, 1u, 0xEu, v27);
        fseek(v39, *&DstBuf[10], 0);
        v28 = v23 - 1;
        if ( v28 >= 0 )
        {
          Fileb = &v26[v33 * v28 + 10];
          v42 = v28 + 1;
          while ( 1 )
          {
            fread(&FileName[128], 1u, v24, v39);
            qmemcpy(Fileb, &FileName[128], v33);
            v8 = v42 == 1;
            Fileb = (Fileb - v33);
            --v42;
            if ( v8 )
              break;
            v24 = v48;
          }
        }
        fclose(v39);
      }
      v29 = dword_4D8B00;
      RegisteredAdvertCounter = v45;
      dword_4317BC[2 * dword_4D8B00] = v25;
      (&dword_4317B8)[2 * v29] = v26;
      v30 = v29 + 1;
      dword_4D8B00 = v30;
    }
    v45 = ++RegisteredAdvertCounter;
  }
  while ( RegisteredAdvertCounter < 128 );
  printf("%d registered advertisements found\n", v30);
}
// 4D8930: using guessed type int dword_4D8930;

//----- (0041A580) --------------------------------------------------------
void __cdecl CleanUpMemory()
{
  signed int v0; // esi
  LPVOID *v1; // edi
  signed int v2; // edi
  LPVOID *v3; // esi
  signed int v4; // edi
  LPVOID *v5; // esi

  v0 = 0;
  if ( dword_4D8B00 > 0 )
  {
    v1 = &dword_4317B8;
    do
    {
      if ( *v1 )
        efree(*v1);
      ++v0;
      v1 += 2;
    }
    while ( v0 < dword_4D8B00 );
  }
  v2 = 0;
  dword_4D8B00 = 0;
  if ( dword_4D8AFC > 0 )
  {
    v3 = &buf;
    do
    {
      if ( *v3 )
        efree(*v3);
      ++v2;
      v3 += 2;
    }
    while ( v2 < dword_4D8AFC );
  }
  v4 = 0;
  dword_4D8AFC = 0;
  if ( dword_4D8B04 > 0 )
  {
    v5 = &dword_437CB0;
    do
    {
      if ( *v5 )
        efree(*v5);
      ++v4;
      v5 += 2;
    }
    while ( v4 < dword_4D8B04 );
  }
  dword_4D8B04 = 0;
}

//----- (0041A630) --------------------------------------------------------
int __cdecl LoadWinsock()
{
  struct WSAData WSAData; // [esp+0h] [ebp-190h] BYREF

  return WSAStartup(0x101u, &WSAData);
}

//----- (0041A660) --------------------------------------------------------
void __thiscall StartServerListener(struct_v9 *packetAttachment, int a2, int a3, int MaxConnections, int ServerListenPort, int OutgoingBufferSize, int IncomingBufferSize, int PacketHistoryMax)
{
  int someKindOfCounterMaxValue; // eax
  void *memory; // edi
  int tempValue2; // eax
  int v12; // edi
  char *v13; // eax
  _DWORD *v14; // ecx
  int v15; // edx
  void *v16; // edi
  int v17; // ecx
  int v18; // eax
  SOCKET v19; // eax
  u_short Port; // cx
  SOCKET v21; // [esp-14h] [ebp-34h]
  SOCKET v22; // [esp-14h] [ebp-34h]
  SOCKET v23; // [esp-14h] [ebp-34h]
  u_long argp; // [esp+Ch] [ebp-14h] BYREF
  struct sockaddr name; // [esp+10h] [ebp-10h] BYREF

  someKindOfCounterMaxValue = PacketHistoryMax;
  if ( PacketHistoryMax < 1 )
    someKindOfCounterMaxValue = 1;
  packetAttachment->PacketHistoryMax = someKindOfCounterMaxValue;
  packetAttachment->PacketCurrentHistory = 0;
  memory = emalloc(540 * someKindOfCounterMaxValue);
  tempValue2 = packetAttachment->PacketHistoryMax;
  packetAttachment->recievePacketBuffer = memory;
  memset(memory, 0, 4 * ((540 * tempValue2) >> 2));
  packetAttachment->dword0 = a2;
  packetAttachment->dword20 = 0;
  packetAttachment->CommsTransportBufferSizeLimited = 0;
  packetAttachment->dword4 = a3;
  packetAttachment->allocateMemorySize = MaxConnections;
  *&packetAttachment->Port = ServerListenPort;
  packetAttachment->TickCountDividedBy10 = GetTickCount() / 0xA;
  packetAttachment->dword24 = 500;
  packetAttachment->dword8C3C = 0;
  packetAttachment->dword8C40 = 0;
  packetAttachment->dword8C44 = 0;
  packetAttachment->dword8C48 = 0;
  packetAttachment->dword10 = 0;
  memset(&packetAttachment->char34, 0, 0x8C00u);
  v12 = packetAttachment->allocateMemorySize;
  packetAttachment->SomeCounter = 0;
  packetAttachment->dword8C34 = 0;
  v13 = operator new(3190 * v12);
  if ( v13 )
  {
    if ( v12 - 1 >= 0 )
    {
      v14 = v13 + 50;
      v15 = v12;
      do
      {
        *v14 = 0;
        v14 = (v14 + 3190);
        --v15;
      }
      while ( v15 );
    }
    v16 = v13;
  }
  else
  {
    v16 = 0;
  }
  v17 = packetAttachment->allocateMemorySize;
  packetAttachment->SomePointer = v16;
  memset(v16, 0, 3190 * v17);
  v18 = packetAttachment->allocateMemorySize;
  packetAttachment->dword8C58 = 0;
  packetAttachment->memory2 = emalloc(4 * v18);
  v19 = socket(2, 2, 0);
  packetAttachment->Socket = v19;
  argp = 1;
  ioctlsocket(v19, 2147772030, &argp);
  v21 = packetAttachment->Socket;
  PacketHistoryMax = -1;
  setsockopt(v21, 6, IP_OPTIONS, &PacketHistoryMax, 4);
  v22 = packetAttachment->Socket;
  PacketHistoryMax = OutgoingBufferSize;
  setsockopt(v22, 0xFFFF, 4097, &PacketHistoryMax, 4);
  v23 = packetAttachment->Socket;
  PacketHistoryMax = IncomingBufferSize;
  setsockopt(v23, 0xFFFF, 4098, &PacketHistoryMax, 4);
  Port = packetAttachment->Port;
  name.sa_family = 2;
  *name.sa_data = htons(Port);
  *&name.sa_data[2] = htonl(0);
  bind(packetAttachment->Socket, &name, 16);
}

//----- (0041A870) --------------------------------------------------------
void __thiscall CleanUpPacketAttachment(struct_v9 *packetAttachment)
{
  int v2; // ebx
  int i; // esi
  int v4; // ebx
  LPVOID *v5; // esi

  v2 = 0;
  for ( i = packetAttachment->SomePointer; v2 < packetAttachment->allocateMemorySize; i += 3190 )
  {
    if ( *(i + 50) )
      sub_41B7A0(i);
    ++v2;
  }
  closesocket(packetAttachment->Socket);
  operator delete(packetAttachment->SomePointer);
  v4 = 0;
  if ( packetAttachment->SomeCounter > 0 )
  {
    v5 = &packetAttachment->gap_36[126];
    do
    {
      if ( *v5 )
      {
        efree(*v5);
        *v5 = 0;
      }
      ++v4;
      v5 += 35;
    }
    while ( v4 < packetAttachment->SomeCounter );
  }
  efree(packetAttachment->memory2);
  efree(packetAttachment->recievePacketBuffer);
}

//----- (0041A910) --------------------------------------------------------
int __thiscall sub_41A910(int this, int a2)
{
  int result; // eax

  result = a2;
  *(this + 32) = a2;
  return result;
}

//----- (0041A920) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
Encryption_Struct *__thiscall SomethingBillerServer(struct_v9 *this, struct_v9 *name, const char *hostshort, u_short EncryptionRNGSeed, signed int a5, int retstr)
{
  struct_v9 *v6; // edi
  int v8; // ebp
  struct hostent *v9; // eax
  int v10; // ecx
  int v11; // edi
  _DWORD *v12; // eax
  Encryption_Struct *v13; // ebx
  __int16 v14; // ax
  int v15; // eax
  int v16; // edi
  int v17; // ecx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v22; // [esp-10h] [ebp-2Ch]
  signed int EncryptionRNGSeedd; // [esp-Ch] [ebp-28h]
  int v24; // [esp-4h] [ebp-20h]
  int ElementToFind; // [esp+10h] [ebp-Ch] BYREF
  __int16 v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+16h] [ebp-6h]

  v6 = name;
  v8 = inet_addr(name);
  if ( v8 == -1 )
  {
    v9 = gethostbyname(v6);
    if ( !v9 )
      return 0;
    v8 = **v9->h_addr_list;
  }
  v10 = this->allocateMemorySize;
  v11 = 0;
  if ( v10 <= 0 )
  {
LABEL_8:
    v11 = -1;
  }
  else
  {
    v12 = (this->SomePointer + 50);
    while ( *v12 )
    {
      ++v11;
      v12 = (v12 + 3190);
      if ( v11 >= v10 )
        goto LABEL_8;
    }
  }
  if ( v11 == -1 )
    return 0;
  v24 = a5;
  v13 = (this->SomePointer + 3190 * v11);
  EncryptionRNGSeedd = EncryptionRNGSeed;
  v14 = htons(hostshort);
  InitializeEncryption(v13, this, 1, v11, v8, v14, EncryptionRNGSeedd, 1, v24);
  v15 = this->dword8C58;
  v16 = 0;
  if ( v15 )
  {
    v17 = v13->ConnectionStatus;
    v26 = v13->word4;
    ElementToFind = v17;
    v22 = v15;
    v18 = this->memory2;
    v27 = v13->dword2E;
    v19 = BinarySearch(&ElementToFind, v18, v22, 4, DifferentCompareFunction, &name);
    v20 = this->memory2;
    v16 = (v19 - v20) >> 2;
    memcpy((v20 + 4 * v16 + 4), (v20 + 4 * v16), 4 * (this->dword8C58 + 0x3FFFFFFF * v16));
  }
  *(this->memory2 + 4 * v16) = v13;
  ++this->dword8C58;
  return v13;
}
// 41A999: inconsistent variable size for '^48.2(EncryptionRNGSeed)'
// 41A920: inconsistent function type and number of purged bytes

//----- (0041AA50) --------------------------------------------------------
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename)
{
  FILE *v3; // eax
  int v4; // ecx
  char *v5; // ebp
  int v6; // edx
  int v7; // ecx
  int v8; // esi
  int v9; // edi
  struct in_addr *v10; // ebp
  char *v11; // eax
  FILE *File; // [esp+4h] [ebp-4h]
  char *Filenamea; // [esp+Ch] [ebp+4h]

  v3 = fopen(Filename, "wt");
  File = v3;
  if ( v3 )
  {
    v4 = *(packetAttachment + 11);
    v5 = 0;
    Filenamea = 0;
    if ( v4 > 0 )
    {
      do
      {
        v6 = &v5[*(packetAttachment + 12)] % v4;
        v7 = *(packetAttachment + 10);
        v8 = 540 * v6;
        v9 = *(v7 + 540 * v6 + 536);
        if ( v9 > 0 )
        {
          v10 = (v7 + 540 * v6);
          v11 = inet_ntoa(v10[133]);
          fprintf(File, "%16s,%5d %3d: ", v11, *(*(packetAttachment + 10) + v8 + 538), v9);
          do
          {
            fprintf(File, "%02x ", v10->S_un.S_un_b.s_b1);
            v10 = (v10 + 1);
            --v9;
          }
          while ( v9 );
          fprintf(File, "\n");
          v5 = Filenamea;
        }
        v4 = *(packetAttachment + 11);
        Filenamea = ++v5;
      }
      while ( v5 < v4 );
      v3 = File;
    }
    fclose(v3);
  }
}

//----- (0041AB30) --------------------------------------------------------
Packet *__thiscall PlayerReadPackets(struct_v9 *this, int lpdwBytesRead, int a3, int a4)
{
  int v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  Packet *result; // eax
  int fromlen; // [esp+8h] [ebp-14h] BYREF
  struct sockaddr from; // [esp+Ch] [ebp-10h] BYREF

  v5 = this->PacketCurrentHistory;
  v6 = this->recievePacketBuffer;
  fromlen = 16;
  v7 = 540 * v5;
  v8 = recvfrom(this->Socket, (540 * v5 + v6), 512, 0, &from, &fromlen);
  v9 = v8;
  if ( v8 == -1 )
    return 0;
  *(this->recievePacketBuffer + v7 + 536) = v8;
  v10 = this->recievePacketBuffer;
  this->PacketCurrentHistory = (this->PacketCurrentHistory + 1) % this->PacketHistoryMax;
  *(v10 + v7 + 532) = *&from.sa_data[2];
  *(this->recievePacketBuffer + v7 + 538) = *from.sa_data;
  *a3 = *&from.sa_data[2];
  *a4 = *from.sa_data;
  *lpdwBytesRead = v9;
  v11 = this->dword8C48;
  this->dword8C44 += v9;
  result = (v7 + this->recievePacketBuffer);
  this->dword8C48 = v11 + 1;
  return result;
}

//----- (0041AC00) --------------------------------------------------------
// send/recv packets
signed int __thiscall PlayerDoNetworkOps(struct_v9 *this)
{
  __int64 v2; // rax
  DWORD v3; // kr00_4
  int v4; // eax
  int v5; // esi
  __int64 v6; // rax
  DWORD GetTickCountt; // kr04_4
  int v8; // eax
  int v9; // ebx
  Encryption_Struct *v10; // esi
  int v11; // eax
  Packet *v12; // eax
  int *v14; // [esp-8h] [ebp-20h]
  unsigned int v15; // [esp-4h] [ebp-1Ch]
  __int16 a6[2]; // [esp+Ch] [ebp-Ch] BYREF
  int a5; // [esp+10h] [ebp-8h] BYREF
  signed int Size; // [esp+14h] [ebp-4h] BYREF

  v2 = (GetTickCount() / 0xA - this->TickCountDividedBy10Two);
  if ( ((HIDWORD(v2) ^ v2) - HIDWORD(v2)) > 10 )
  {
    v3 = GetTickCount();
    v4 = this->dword8C58;
    v5 = 0;
    this->TickCountDividedBy10Two = v3 / 10;
    if ( v4 > 0 )
    {
      do
        SendBiDirectionalCorePackets(*(this->memory2 + 4 * v5++));
      while ( v5 < this->dword8C58 );
    }
  }
  if ( this->CommsTransportBufferSizeLimited > 0 )
  {
    v6 = (GetTickCount() / 0xA - this->TickCountDividedBy10);
    if ( ((HIDWORD(v6) ^ v6) - HIDWORD(v6)) >= 100 )
    {
      GetTickCountt = GetTickCount();
      v8 = this->dword8C58;
      v9 = 0;
      this->TickCountDividedBy10 = GetTickCountt / 0xA;
      if ( v8 > 0 )
      {
        do
        {
          v10 = *(this->memory2 + 4 * v9);
          v11 = v10->field_C12 - v10 - 2706;
          if ( v11 > 2 )
          {
            if ( BYTE2(v10->field_A92) + 3 == v11 )
            {
              v15 = v10->field_C12 - v10 - 2709;
              v14 = (&v10->field_A92 + 3);
            }
            else
            {
              v15 = v10->field_C12 - v10 - 2706;
              v14 = &v10->field_A92;
            }
            WriteToNetwork(v10, v14, v15);
            v10->field_C12 = &v10->field_A92;
          }
          ++v9;
        }
        while ( v9 < this->dword8C58 );
      }
    }
  }
  v12 = PlayerReadPackets(this, &Size, &a5, a6);
  if ( !v12 )
    return 0;
  PlayerHandlePacket(this, &v12->byte0, Size, a5, a6[0]);
  return 1;
}

//----- (0041AD60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __thiscall PlayerHandlePacket(struct PACKET_ATTACHMENT *packetAttachment, Packet *buffer, signed int Size, int a5, __int16 a6)
{
  int v6; // eax
  int *v7; // eax
  int v8; // ebp
  Packet *packet; // ebx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  _DWORD *v16; // eax
  int v17; // edi
  int v18; // eax
  int v19; // ebp
  int v20; // ecx
  unsigned int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  DWORD GetTickCountt; // kr00_4
  int v28; // eax
  int v29; // ecx
  int Sizee; // ecx
  Packet *v31; // eax
  Packet *v32; // esi
  int v33; // edx
  int v34; // edi
  int v35; // ecx
  int v36; // ebx
  Packet *v37; // eax
  Packet *v38; // esi
  int v39; // edx
  int v40; // edi
  int v41; // ecx
  int v42; // ebx
  unsigned int v43; // [esp-14h] [ebp-38h]
  int v44; // [esp-10h] [ebp-34h]
  char buf[6]; // [esp+10h] [ebp-14h] BYREF
  int ElementToFind; // [esp+18h] [ebp-Ch] BYREF
  __int16 v47; // [esp+1Ch] [ebp-8h]
  int v48; // [esp+1Eh] [ebp-6h]
  int v49; // [esp+28h] [ebp+4h]

  ElementToFind = a5;
  v6 = *(packetAttachment + 8982);
  v47 = a6;
  v43 = *(packetAttachment + 8981);
  v48 = -1;
  v7 = BinarySearch(&ElementToFind, v43, v6, 4, DifferentCompareFunction, buf);
  if ( *buf )
    v8 = *v7;
  else
    v8 = 0;
  packet = buffer;
  if ( buffer->byte0 || buffer->EncryptionCommand != 1 )
  {
    if ( !v8 )
      return;
    GetTickCountt = GetTickCount();
    v28 = *(v8 + 62);
    v29 = *(v8 + 2670) + 1;
    *(v8 + 58) = GetTickCountt / 0xA;
    *(v8 + 2670) = v29;
    Sizee = Size;
    if ( v28 <= 0 )
      goto LABEL_44;
    if ( buffer->byte0 )
    {
      v37 = &buffer->EncryptionCommand;
      v38 = (&buffer->EncryptionCommand + 4 * ((Size + 2) >> 2));
      v39 = *(v8 + 62);
      if ( &buffer->EncryptionCommand == v38 )
      {
LABEL_44:
        ProcessCorePackets(v8, &packet->byte0, Sizee, 0);
        return;
      }
      v40 = v8 + 70 - v37;
      do
      {
        v41 = *&v37->byte0;
        v42 = v39 ^ *(&v37->byte0 + v40);
        v37 = (v37 + 4);
        v37[-1].dwordA = v41 ^ v42;
        v39 = v41;
      }
      while ( v37 != v38 );
    }
    else
    {
      if ( buffer->EncryptionCommand == 2 )
        goto LABEL_44;
      if ( Size < 2 )
        return;
      v31 = &buffer->EncryptSeedOrSizeDWORD;
      v32 = (&buffer->EncryptSeedOrSizeDWORD + ((Size + 1) >> 2));
      v33 = *(v8 + 62);
      if ( &buffer->EncryptSeedOrSizeDWORD == v32 )
        goto LABEL_44;
      v34 = v8 + 70 - v31;
      do
      {
        v35 = *&v31->byte0;
        v36 = v33 ^ *(&v31->byte0 + v34);
        v31 = (v31 + 4);
        v31[-1].dwordA = v35 ^ v36;
        v33 = v35;
      }
      while ( v31 != v32 );
    }
    packet = buffer;
    Sizee = Size;
    goto LABEL_44;
  }
  v49 = 0;
  if ( Size >= 8 )
    v49 = *&packet->char6;
  if ( v49 != 1 )
    goto LABEL_9;
  v11 = *(packetAttachment + 8);
  if ( v11 )
  {
    v12 = v11 - 1;
    if ( !v12 )
    {
      v10 = abs32(packet->EncryptSeedOrSizeDWORD);
      goto LABEL_15;
    }
    if ( v12 == 1 )
    {
LABEL_9:
      v10 = -abs32(packet->EncryptSeedOrSizeDWORD);
LABEL_15:
      packet->EncryptSeedOrSizeDWORD = v10;
    }
  }
  if ( v8 && (v13 = packet->EncryptSeedOrSizeDWORD, *(v8 + 62) == v13) )
  {
    buf[0] = 0;
    buf[1] = 2;
    *&buf[2] = v13;
    WriteToNetwork(v8, buf, 6u);
  }
  else
  {
    v14 = *(packetAttachment + 3);
    v15 = 0;
    if ( v14 <= 0 )
    {
LABEL_23:
      v15 = -1;
    }
    else
    {
      v16 = (*(packetAttachment + 5) + 50);
      while ( *v16 )
      {
        ++v15;
        v16 = (v16 + 3190);
        if ( v15 >= v14 )
          goto LABEL_23;
      }
    }
    if ( v15 != -1 && *packetAttachment )
    {
      v17 = *(packetAttachment + 5) + 3190 * v15;
      InitializeEncryption(v17, packetAttachment, 3, v15, a5, a6, packet->EncryptSeedOrSizeDWORD, v49, 0);
      *(v17 + 2670) = 1;
      v18 = *(packetAttachment + 8982);
      v19 = 0;
      if ( v18 )
      {
        v20 = *v17;
        v47 = *(v17 + 4);
        ElementToFind = v20;
        v44 = v18;
        v21 = *(packetAttachment + 8981);
        v48 = *(v17 + 46);
        v22 = BinarySearch(&ElementToFind, v21, v44, 4, DifferentCompareFunction, &Size);
        v23 = *(packetAttachment + 8981);
        v19 = (v22 - v23) >> 2;
        memcpy((v23 + 4 * v19 + 4), (v23 + 4 * v19), 4 * (*(packetAttachment + 8982) + 0x3FFFFFFF * v19));
      }
      v24 = a6;
      v25 = a5;
      *(*(packetAttachment + 8981) + 4 * v19) = v17;
      ++*(packetAttachment + 8982);
      if ( (*packetAttachment)(v25, v24, v17) )
      {
        *(v17 + 50) = 2;
        buf[1] = 2;
        v26 = packet->EncryptSeedOrSizeDWORD;
        buf[0] = 0;
        *&buf[2] = v26;
        WriteToNetwork(v17, buf, 6u);
      }
      else
      {
        sub_41B7A0(v17);
      }
    }
  }
}
// 41AFE8: conditional instruction was optimized away because of 'al.1==0'
// 41AF3C: inconsistent variable size for '^54.2(a6)'

//----- (0041B070) --------------------------------------------------------
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, Packet *buffer, int packetLength, Encryption_Struct *encryption, int a5)
{
  void (__cdecl *v6)(Packet *, int, Encryption_Struct *); // eax
  Packet *v7; // ebp
  int v8; // ecx
  Packet *v9; // esi
  char *v10; // edi

  v6 = *(packetAttachment + 1);
  if ( v6 )
  {
    v7 = buffer;
    v6(buffer, packetLength, encryption);
  }
  else
  {
    *(packetAttachment + 35 * *(packetAttachment + 8974) + 46) = packetLength;
    *(packetAttachment + 35 * *(packetAttachment + 8974) + 47) = encryption;
    if ( a5 )
    {
      v7 = buffer;
      a5 = 0;
      *(packetAttachment + 35 * *(packetAttachment + 8974) + 45) = buffer;
    }
    else
    {
      v7 = buffer;
      if ( packetLength >= 0x80 )
      {
        *(packetAttachment + 35 * *(packetAttachment + 8974) + 45) = emalloc(packetLength);
        v8 = packetLength;
        v9 = buffer;
        v10 = *(packetAttachment + 35 * *(packetAttachment + 8974) + 45);
      }
      else
      {
        v8 = packetLength;
        v9 = buffer;
        *(packetAttachment + 35 * *(packetAttachment + 8974) + 45) = 0;
        v10 = packetAttachment + 140 * *(packetAttachment + 8974) + 52;
      }
      qmemcpy(v10, v9, v8);
    }
    ++*(packetAttachment + 8974);
  }
  if ( a5 )
    efree(v7);
}

//----- (0041B1B0) --------------------------------------------------------
int __thiscall sub_41B1B0(int this, int a2, int a3)
{
  int v4; // ecx
  __int64 v5; // rax
  DWORD v6; // kr00_4
  int v7; // eax
  int v8; // edi
  __int64 v9; // rax
  DWORD v10; // kr04_4
  int v11; // eax
  int v12; // ebx
  int v13; // edi
  int v14; // eax
  Packet *v15; // eax
  int v16; // ecx
  int result; // eax
  int v18; // ecx
  const char *v19; // [esp-8h] [ebp-20h]
  unsigned int v20; // [esp-4h] [ebp-1Ch]
  __int16 a6[2]; // [esp+Ch] [ebp-Ch] BYREF
  int a5; // [esp+10h] [ebp-8h] BYREF
  signed int Size; // [esp+14h] [ebp-4h] BYREF

  v4 = *(this + 35892);
  if ( v4 > 0 && *(this + 140 * v4 + 40) )
  {
    efree(*(this + 140 * v4 + 40));
    *(this + 140 * *(this + 35892) + 40) = 0;
  }
  if ( *(this + 35896) == *(this + 35892) )
  {
    *(this + 35892) = 0;
    *(this + 35896) = 0;
    v5 = (GetTickCount() / 0xA - *(this + 28));
    if ( ((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 10 )
    {
      v6 = GetTickCount();
      v7 = *(this + 35928);
      v8 = 0;
      *(this + 28) = v6 / 0xA;
      if ( v7 > 0 )
      {
        do
          SendBiDirectionalCorePackets(*(*(this + 35924) + 4 * v8++));
        while ( v8 < *(this + 35928) );
      }
    }
    if ( *(this + 35920) > 0 )
    {
      v9 = (GetTickCount() / 0xA - *(this + 35916));
      if ( ((HIDWORD(v9) ^ v9) - HIDWORD(v9)) >= 100 )
      {
        v10 = GetTickCount();
        v11 = *(this + 35928);
        v12 = 0;
        *(this + 35916) = v10 / 0xA;
        if ( v11 > 0 )
        {
          do
          {
            v13 = *(*(this + 35924) + 4 * v12);
            v14 = *(v13 + 3090) - v13 - 2706;
            if ( v14 > 2 )
            {
              if ( *(v13 + 2708) + 3 == v14 )
              {
                v20 = *(v13 + 3090) - v13 - 2709;
                v19 = (v13 + 2709);
              }
              else
              {
                v20 = *(v13 + 3090) - v13 - 2706;
                v19 = (v13 + 2706);
              }
              WriteToNetwork(v13, v19, v20);
              *(v13 + 3090) = v13 + 2706;
            }
            ++v12;
          }
          while ( v12 < *(this + 35928) );
        }
      }
    }
    v15 = PlayerReadPackets(this, &Size, &a5, a6);
    if ( v15 )
      PlayerHandlePacket(this, &v15->byte0, Size, a5, a6[0]);
  }
  v16 = *(this + 35892);
  if ( *(this + 35896) == v16 )
    return 0;
  v18 = this + 140 * v16;
  result = *(v18 + 180);
  if ( !result )
    result = v18 + 52;
  *a2 = *(v18 + 184);
  *a3 = *(this + 140 * (*(this + 35892))++ + 188);
  return result;
}

//----- (0041B3D0) --------------------------------------------------------
int __thiscall sub_41B3D0(int this)
{
  int result; // eax

  result = 0;
  *(this + 35900) = 0;
  *(this + 35904) = 0;
  *(this + 35908) = 0;
  *(this + 35912) = 0;
  *(this + 16) = 0;
  return result;
}

//----- (0041B3F0) --------------------------------------------------------
void __thiscall GetPacketStatistics(struct_v9 *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls)
{
  *TotalPacketSendLength = packetAttachment->dword8C3C;
  *TotalPacketRecvLength = packetAttachment->dword8C44;
  *TotalPacketSendCalls = packetAttachment->dword8C40;
  *TotalPacketRecvCalls = packetAttachment->dword8C48;
  *TotalPacketClustersCalls = packetAttachment->dword10;
}

//----- (0041B430) --------------------------------------------------------
signed int __thiscall sub_41B430(struct_v9 *this, signed int CommsTransportBufferSize)
{
  DWORD v3; // kr00_4
  int v4; // eax
  int v5; // edi
  int v6; // esi
  int v7; // eax
  signed int result; // eax
  const char *v9; // [esp-8h] [ebp-14h]
  unsigned int v10; // [esp-4h] [ebp-10h]

  v3 = GetTickCount();
  v4 = this->dword8C58;
  v5 = 0;
  this->TickCountDividedBy10 = v3 / 0xA;
  if ( v4 > 0 )
  {
    do
    {
      v6 = *(this->memory2 + 4 * v5);
      v7 = *(v6 + 3090) - v6 - 2706;
      if ( v7 > 2 )
      {
        if ( *(v6 + 2708) + 3 == v7 )
        {
          v10 = *(v6 + 3090) - v6 - 2709;
          v9 = (v6 + 2709);
        }
        else
        {
          v10 = *(v6 + 3090) - v6 - 2706;
          v9 = (v6 + 2706);
        }
        WriteToNetwork(v6, v9, v10);
        *(v6 + 3090) = v6 + 2706;
      }
      ++v5;
    }
    while ( v5 < this->dword8C58 );
  }
  result = CommsTransportBufferSize;
  if ( CommsTransportBufferSize >= 384 )
    result = 384;
  this->CommsTransportBufferSizeLimited = result;
  return result;
}

//----- (0041B4E0) --------------------------------------------------------
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment)
{
  DWORD v2; // kr00_4
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // eax
  const char *v7; // [esp-Ch] [ebp-14h]
  unsigned int v8; // [esp-8h] [ebp-10h]

  v2 = GetTickCount();
  v3 = *(packetAttachment + 8982);
  v4 = 0;
  *(packetAttachment + 8979) = v2 / 0xA;
  if ( v3 > 0 )
  {
    do
    {
      v5 = *(*(packetAttachment + 8981) + 4 * v4);
      v6 = *(v5 + 3090) - v5 - 2706;
      if ( v6 > 2 )
      {
        if ( *(v5 + 2708) + 3 == v6 )
        {
          v8 = *(v5 + 3090) - v5 - 2709;
          v7 = (v5 + 2709);
        }
        else
        {
          v8 = *(v5 + 3090) - v5 - 2706;
          v7 = (v5 + 2706);
        }
        WriteToNetwork(v5, v7, v8);
        *(v5 + 3090) = v5 + 2706;
      }
      ++v4;
    }
    while ( v4 < *(packetAttachment + 8982) );
  }
}

//----- (0041B570) --------------------------------------------------------
signed int __stdcall sub_41B570(int a1)
{
  return 1;
}

//----- (0041B580) --------------------------------------------------------
int __cdecl DifferentCompareFunction(int connection, int ConnectionsArray)
{
  unsigned int *v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  int v5; // edx

  v2 = *ConnectionsArray;
  v3 = **ConnectionsArray;
  if ( *connection > v3 )
    return 1;
  if ( *connection < v3 )
    return -1;
  v5 = *(connection + 6);
  result = *(connection + 4) - *(v2 + 2);
  if ( v5 != -1 && !result )
    result = v5 - *(v2 + 46);
  return result;
}

//----- (0041B5D0) --------------------------------------------------------
void __thiscall InitializeEncryption(Encryption_Struct *encryption, struct_v9 *packetAttachment, int a3, int a4, int a5, __int16 a6, signed int ServerKey, int a8, int a9)
{
  signed int ServerKeyy; // edi
  char *SSEncryptionTablee; // ebp
  int v12; // [esp+24h] [ebp+14h]

  ServerKeyy = ServerKey;
  encryption->dword42 = a8;
  encryption->dword2A = packetAttachment;
  encryption->dword32 = a3;
  encryption->dword2E = a4;
  encryption->ConnectionStatus = a5;
  encryption->word4 = a6;
  encryption->dword6 = a9;
  encryption->dwordA = 9999999;
  encryption->dwordE = 0;
  encryption->dword12 = 0;
  encryption->dword16 = 0;
  encryption->dword1A = 0;
  encryption->dword1E = 0;
  encryption->dword22 = 0;
  encryption->dword26 = 0;
  encryption->ServerKey = ServerKey;
  SSEncryptionTablee = encryption->SSEncryptionTable;
  v12 = 260;
  do
  {
    ServerKeyy = 16807 * (ServerKeyy % 127773) - 2836 * (ServerKeyy / 127773) + 123;
    if ( ServerKeyy <= 0 )
      ServerKeyy += 0x7FFFFFFF;
    *SSEncryptionTablee = ServerKeyy;
    SSEncryptionTablee += 2;
    --v12;
  }
  while ( v12 );
  encryption->KeepAliveDelayTimer = 0;
  encryption->MenuKickOutDelayTimer = GetTickCount() / 0xA;
  encryption->KeepAliveDelayTimer = GetTickCount() / 0xA;
  encryption->field_24E = 0;
  encryption->field_252 = 0;
  encryption->field_A82 = 0;
  encryption->field_A86 = 0;
  encryption->field_A8A = 0;
  encryption->field_A8E = GetTickCount() / 0xA;
  encryption->field_256 = 0;
  encryption->field_25A = 0;
  encryption->field_25E = 0;
  encryption->field_266 = 0;
  encryption->field_262 = 0;
  memset(encryption->field_26A, 0, sizeof(encryption->field_26A));
  memset(encryption->PacketPointers, 0, sizeof(encryption->PacketPointers));
  encryption->field_A7A = 1000;
  encryption->field_A7E = 1000;
  encryption->field_A6A = 0;
  encryption->field_A6E = 0;
  encryption->field_A72 = 0;
  encryption->field_A76 = 0;
  encryption->field_C12 = &encryption->field_A92;
  memset(encryption->field_C16, 0, sizeof(encryption->field_C16));
  encryption->field_C66 = 0;
  encryption->field_C6A = 0;
  encryption->field_C6E = 0;
  encryption->field_C72 = 0;
}

//----- (0041B7A0) --------------------------------------------------------
void *__thiscall sub_41B7A0(int this)
{
  int v2; // eax
  int v3; // ebp
  int v4; // esi
  void *v5; // eax
  LPVOID *v6; // esi
  int v7; // ebp
  int v8; // esi
  __int16 v9; // dx
  int v10; // eax
  int v11; // edx
  void *result; // eax
  int v13; // ecx
  int v14; // esi
  const char *v15; // [esp-8h] [ebp-28h]
  unsigned int v16; // [esp-4h] [ebp-24h]
  char buf[4]; // [esp+10h] [ebp-10h] BYREF
  int ElementToFind; // [esp+14h] [ebp-Ch] BYREF
  __int16 v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ah] [ebp-6h]

  v2 = *(this + 3090) - this - 2706;
  if ( v2 > 2 )
  {
    if ( *(this + 2708) + 3 == v2 )
    {
      v16 = *(this + 3090) - this - 2709;
      v15 = (this + 2709);
    }
    else
    {
      v16 = *(this + 3090) - this - 2706;
      v15 = (this + 2706);
    }
    WriteToNetwork(this, v15, v16);
    *(this + 3090) = this + 2706;
  }
  if ( *(this + 50) == 2 )
  {
    buf[0] = 0;
    buf[1] = 7;
    WriteToNetwork(this, buf, 2u);
  }
  v3 = 0;
  if ( *(this + 3174) > 0 )
  {
    v4 = this + 3094;
    do
    {
      if ( *(v4 + 12) )
        efree(*v4);
      ++v3;
      v4 += 20;
    }
    while ( v3 < *(this + 3174) );
  }
  v5 = *(this + 3178);
  *(this + 3174) = 0;
  if ( v5 )
    efree(v5);
  *(this + 3178) = 0;
  *(this + 3182) = 0;
  *(this + 3186) = 0;
  v6 = (this + 618);
  v7 = 256;
  do
  {
    if ( v6[256] )
    {
      efree(v6[256]);
      v6[256] = 0;
    }
    if ( *v6 )
    {
      efree(*v6);
      *v6 = 0;
    }
    ++v6;
    --v7;
  }
  while ( v7 );
  if ( *(this + 594) )
  {
    efree(*(this + 594));
    *(this + 594) = 0;
  }
  v8 = *(this + 42);
  v9 = *(this + 4);
  v10 = *(this + 46);
  ElementToFind = *this;
  v19 = v9;
  v11 = *(v8 + 35928);
  v20 = v10;
  result = BinarySearch(&ElementToFind, *(v8 + 35924), v11, 4, DifferentCompareFunction, buf);
  if ( *buf )
  {
    v13 = *(v8 + 35928) - 1;
    *(v8 + 35928) = v13;
    v14 = *(v8 + 35924);
    result = memcpy(
               (v14 + 4 * ((result - v14) >> 2)),
               (v14 + 4 * ((result - v14) >> 2) + 4),
               4 * (v13 + 0x3FFFFFFF * ((result - v14) >> 2)));
  }
  *(this + 50) = 0;
  return result;
}

//----- (0041B950) --------------------------------------------------------
int __thiscall CheckIfBillingServerIsConnected(int this)
{
  return *(this + 50);
}

//----- (0041B960) --------------------------------------------------------
int __thiscall sub_41B960(int this)
{
  return *(this + 66);
}

//----- (0041B970) --------------------------------------------------------
// NetworkData.GetRelAckDiff()
int __thiscall GetRelAckDiff(Encryption_Struct *encryption, int a2)
{
  if ( a2 )
    *a2 = encryption->field_266;
  return encryption->field_25E - encryption->field_262;
}

//----- (0041B9A0) --------------------------------------------------------
void __thiscall WriteToNetwork(Encryption_Struct *encryption, const char *buf, unsigned int len)
{
  int v4; // edx
  char *v5; // ebp
  char v6; // al
  char *v7; // ecx
  char *v8; // esi
  int v9; // eax
  int v10; // eax
  char *v11; // ecx
  char *v12; // esi
  int v13; // eax
  int v14; // eax
  DWORD v15; // kr00_4
  int v16; // ecx
  int v17; // eax
  __int64 v18; // rax
  int v19; // ecx
  int v20; // edi
  int v21; // edx
  _DWORD *v22; // edi
  __int16 v23; // cx
  int v24; // eax
  SOCKET v25; // [esp-24h] [ebp-43Ch]
  char v26; // [esp+7h] [ebp-411h]
  struct sockaddr to; // [esp+8h] [ebp-410h] BYREF
  char v28; // [esp+18h] [ebp-400h] BYREF
  char v29; // [esp+19h] [ebp-3FFh] BYREF
  char v30[1022]; // [esp+1Ah] [ebp-3FEh] BYREF

  if ( encryption->dword32 != 4 )
  {
    v4 = encryption->ServerKey;
    v5 = buf;
    if ( v4 > 0 )
    {
      v26 = *buf;
      if ( *buf || (v6 = buf[1], v6 != 1) && v6 != 2 )
      {
        qmemcpy(&v28, buf, len);
        if ( v26 )
        {
          v11 = &v29;
          v12 = &v29 + 4 * ((len + 2) >> 2);
          if ( &v29 != v12 )
          {
            do
            {
              v13 = *v11 ^ *&v11[encryption->SSEncryptionTable - &v29];
              v11 += 4;
              v14 = v4 ^ v13;
              *(v11 - 1) = v14;
              v4 = v14;
            }
            while ( v11 != v12 );
          }
        }
        else
        {
          v7 = v30;
          v8 = &v30[4 * ((len + 1) >> 2)];
          if ( v30 != v8 )
          {
            do
            {
              v9 = *v7 ^ *&v7[encryption->SSEncryptionTable - v30];
              v7 += 4;
              v10 = v4 ^ v9;
              *(v7 - 1) = v10;
              v4 = v10;
            }
            while ( v7 != v8 );
          }
        }
        v5 = &v28;
      }
    }
    v15 = GetTickCount();
    v16 = encryption->field_A6A;
    v17 = encryption->field_A86;
    encryption->KeepAliveDelayTimer = v15 / 0xA;
    encryption->field_A6A = v16 + 1;
    encryption->field_A86 = len + v17;
    v18 = (encryption->field_A8E - GetTickCount() / 0xA);
    v19 = (HIDWORD(v18) ^ v18) - HIDWORD(v18);
    if ( v19 >= 100 )
    {
      v20 = encryption->field_A86;
      v21 = encryption->field_A8A;
      encryption->field_A8A = v20;
      encryption->field_A82 = 100 * (v20 - v21) / v19;
      encryption->field_A8E = GetTickCount() / 0xA;
    }
    v22 = encryption->dword2A;
    v23 = encryption->word4;
    *&to.sa_data[2] = encryption->ConnectionStatus;
    v25 = v22[6];
    to.sa_family = 2;
    *to.sa_data = v23;
    sendto(v25, v5, len, 0, &to, 16);
    v24 = v22[8976] + 1;
    v22[8975] += len;
    v22[8976] = v24;
  }
}
// 41B9A0: using guessed type char var_3FE[1022];

//----- (0041BB70) --------------------------------------------------------
void __thiscall ProcessCorePackets(Encryption_Struct *encryptionStruct, Packet *packet, int Size, int a5)
{
  int v5; // ecx
  Packet *v6; // esi
  int v7; // edi
  int EncryptSeed; // esi
  char *v9; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int i; // esi
  int v22; // eax
  int v23; // ebx
  __int16 v24; // di
  _WORD *v25; // eax
  DWORD v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rax
  int v32; // eax
  int v33; // ecx
  int v34; // ecx
  int v35; // edi
  char *v36; // esi
  void *v37; // eax
  int v38; // edi
  char *v39; // esi
  void *v40; // eax
  int v41; // ebx
  char *v42; // eax
  int v43; // eax
  int v44; // ecx
  int v45; // esi
  int v46; // eax
  unsigned __int8 *v47; // esi
  unsigned __int8 *v48; // ebx
  int v49; // edx
  char *v50; // esi
  int v51; // edi
  void *v52; // [esp-Ch] [ebp-28h]
  int v53; // [esp-8h] [ebp-24h]
  char buf[10]; // [esp+10h] [ebp-Ch] BYREF

  v5 = encryptionStruct->dword32;
  if ( v5 == 4 )
  {
LABEL_12:
    v6 = packet;
    goto RETURN_FREE_MEMORY;
  }
  v6 = packet;
  if ( !packet->byte0 )
  {
    v7 = Size;
    if ( Size <= 1 )
      goto RETURN_FREE_MEMORY;
    switch ( packet->EncryptionCommand )
    {
      case 2:                                   // Initialize Seed For Modded-RNG Encryption
        if ( v5 != 1 )
          goto RETURN_FREE_MEMORY;
        EncryptSeed = packet->EncryptSeedOrSizeDWORD;
        if ( abs32(encryptionStruct->ServerKey) == abs32(EncryptSeed) )
        {
          encryptionStruct->ServerKey = EncryptSeed;
          v9 = encryptionStruct->SSEncryptionTable;
          v10 = 260;
          do
          {
            EncryptSeed = 16807 * (EncryptSeed % 127773) - 2836 * (EncryptSeed / 127773) + 123;
            if ( EncryptSeed <= 0 )
              EncryptSeed += 0x7FFFFFFF;
            *v9 = EncryptSeed;
            v9 += 2;
            --v10;
          }
          while ( v10 );
          encryptionStruct->dword32 = 2;
        }
        goto LABEL_12;
      case 3:
        if ( Size < 6 )
          goto RETURN_FREE_MEMORY;
        v16 = packet->EncryptSeedOrSizeDWORD;
        buf[0] = 0;
        buf[1] = 4;
        *&buf[2] = v16;
        SendPacketCluster(encryptionStruct, buf, 6u);
        v17 = packet->EncryptSeedOrSizeDWORD;
        if ( v17 > encryptionStruct->field_25A )
          encryptionStruct->field_25A = v17;
        v18 = packet->EncryptSeedOrSizeDWORD;
        v19 = encryptionStruct->field_256;
        if ( v19 > v18 )
          goto RETURN_FREE_MEMORY;
        if ( v19 == v18 )
        {
          ProcessCorePackets(encryptionStruct, &packet->char6, v7 - 6, 0);
          v20 = encryptionStruct->field_256 + 1;
          encryptionStruct->field_256 = v20;
          for ( i = ((v20 >> 31) ^ abs32(v20)) - (v20 >> 31);
                encryptionStruct->field_26A[i];
                i = ((v22 >> 31) ^ abs32(v22)) - (v22 >> 31) )
          {
            ProcessCorePackets(
              encryptionStruct,
              (encryptionStruct->field_26A[i] + 2),
              *encryptionStruct->field_26A[i],
              0);
            efree(encryptionStruct->field_26A[i]);
            encryptionStruct->field_26A[i] = 0;
            v22 = encryptionStruct->field_256 + 1;
            encryptionStruct->field_256 = v22;
          }
        }
        else
        {
          v23 = ((v18 >> 31) ^ abs32(v18)) - (v18 >> 31);
          if ( !encryptionStruct->field_26A[v23] )
          {
            v24 = v7 - 6;
            v25 = emalloc(v24 + 2);
            encryptionStruct->field_26A[v23] = v25;
            *v25 = v24;
            qmemcpy((encryptionStruct->field_26A[v23] + 2), &packet->char6, v24);
          }
        }
        goto LABEL_12;
      case 4:
        if ( Size < 6 )
          goto RETURN_FREE_MEMORY;
        v11 = packet->EncryptSeedOrSizeDWORD;
        if ( encryptionStruct->field_262 > v11 || v11 >= encryptionStruct->field_25E )
          goto RETURN_FREE_MEMORY;
        v12 = ((v11 >> 31) ^ abs32(v11)) - (v11 >> 31);
        v13 = encryptionStruct->PacketPointers[v12];
        if ( v13 )
        {
          encryptionStruct->field_266 -= *(v13 + 4);
          efree(encryptionStruct->PacketPointers[v12]);
          encryptionStruct->PacketPointers[v12] = 0;
          v14 = encryptionStruct->field_25E;
          if ( encryptionStruct->field_262 < v14 )
          {
            do
            {
              v15 = encryptionStruct->field_262;
              if ( encryptionStruct->PacketPointers[((v15 >> 31) ^ abs32(v15)) - (v15 >> 31)] )
                break;
              encryptionStruct->field_262 = v15 + 1;
            }
            while ( v15 + 1 < v14 );
          }
        }
        goto LABEL_12;
      case 5:
        v32 = packet->EncryptSeedOrSizeDWORD;
        buf[0] = 0;
        buf[1] = 6;
        *&buf[2] = v32;
        *&buf[6] = GetTickCount() / 0xA;
        WriteToNetwork(encryptionStruct, buf, 0xAu);
        encryptionStruct->field_A72 = *&packet->char6;
        encryptionStruct->field_A76 = packet->dwordA;
        if ( v7 > 6 )
        {
          v33 = encryptionStruct->field_A6A;
          if ( v33 <= 300 )
            encryptionStruct->field_A7A = 1000;
          else
            encryptionStruct->field_A7A = 1000 * packet->dwordA / v33;
          v34 = *&packet->char6;
          if ( v34 <= 300 )
            encryptionStruct->field_A7E = 1000;
          else
            encryptionStruct->field_A7E = 1000 * encryptionStruct->field_A6E / v34;
        }
        goto RETURN_FREE_MEMORY;
      case 6:
        v26 = GetTickCount() / 0xA;
        v27 = encryptionStruct->dword1E;
        v28 = v26 - packet->EncryptSeedOrSizeDWORD;
        ++encryptionStruct->dword1A;
        v29 = encryptionStruct->dword22;
        encryptionStruct->dword1E = v28 + v27;
        if ( !v29 || v28 < v29 )
          encryptionStruct->dword22 = v28;
        if ( v28 > encryptionStruct->dword26 )
          encryptionStruct->dword26 = v28;
        if ( v28 <= encryptionStruct->dwordA + 1
          || (v30 = (GetTickCount() / 0xA - encryptionStruct->dword16), ((HIDWORD(v30) ^ v30) - HIDWORD(v30)) > 12000) )
        {
          if ( v28 < 2 * encryptionStruct->dwordA
            || (v31 = (GetTickCount() / 0xA - encryptionStruct->dword16), ((HIDWORD(v31) ^ v31) - HIDWORD(v31)) > 60000) )
          {
            encryptionStruct->dwordE = *&packet->char6 + v28 * (1000 - *(encryptionStruct->dword2A + 36)) / 1000 - v26;
            encryptionStruct->dword16 = GetTickCount() / 0xA;
            encryptionStruct->dwordA = v28;
          }
        }
        goto LABEL_12;
      case 7:
        goto LABEL_78;
      case 8:
      case 9:
        v41 = encryptionStruct->field_24E;
        v53 = Size + v41 - 2;
        v52 = encryptionStruct->field_252;
        encryptionStruct->field_24E = v53;
        v42 = ExpandMemory(v52, v53, 1);
        encryptionStruct->field_252 = v42;
        qmemcpy(&v42[v41], &packet->EncryptSeedOrSizeDWORD, v7 - 2);
        if ( packet->EncryptionCommand == 9 )
        {
          ProcessCorePackets(encryptionStruct, encryptionStruct->field_252, encryptionStruct->field_24E, 1);
          encryptionStruct->field_252 = 0;
          encryptionStruct->field_24E = 0;
        }
        goto LABEL_12;
      case 0xA:
        if ( Size < 6 )
          goto RETURN_FREE_MEMORY;
        v43 = packet->EncryptSeedOrSizeDWORD;
        if ( v43 < 0 || v43 >= 0x1400000 )      // 20 Megabytes (if it's in bytes)
        {
LABEL_78:
          encryptionStruct->dword32 = 4;
          goto RETURN_FREE_MEMORY;
        }
        v44 = encryptionStruct->field_C6A;
        encryptionStruct->field_C6E = v43;
        if ( !v44 )
        {
          encryptionStruct->field_C6A = emalloc(v43);
          encryptionStruct->field_C72 = 0;
        }
        qmemcpy((encryptionStruct->field_C6A + encryptionStruct->field_C72), &packet->char6, v7 - 6);
        v45 = v7 - 6 + encryptionStruct->field_C72;
        v46 = encryptionStruct->field_C6E;
        encryptionStruct->field_C72 = v45;
        if ( v45 == v46 )
        {
          ProcessCorePackets(encryptionStruct, encryptionStruct->field_C6A, v46, 1);
          encryptionStruct->field_C72 = 0;
          encryptionStruct->field_C6E = 0;
          encryptionStruct->field_C6A = 0;
        }
        break;
      case 0xB:
        v35 = 0;
        if ( encryptionStruct->field_C66 > 0 )
        {
          v36 = encryptionStruct->field_C16;
          do
          {
            if ( *(v36 + 3) )
              efree(*v36);
            ++v35;
            v36 += 20;
          }
          while ( v35 < encryptionStruct->field_C66 );
          v6 = packet;
        }
        v37 = encryptionStruct->field_C6A;
        encryptionStruct->field_C66 = 0;
        if ( v37 )
          efree(v37);
        encryptionStruct->field_C6A = 0;
        encryptionStruct->field_C6E = 0;
        encryptionStruct->field_C72 = 0;
        LOWORD(Size) = 3072;
        WriteData(encryptionStruct, &Size, 2u, 1);
        goto RETURN_FREE_MEMORY;
      case 0xC:
        v38 = 0;
        if ( encryptionStruct->field_C66 > 0 )
        {
          v39 = encryptionStruct->field_C16;
          do
          {
            if ( *(v39 + 3) )
              efree(*v39);
            ++v38;
            v39 += 20;
          }
          while ( v38 < encryptionStruct->field_C66 );
          v6 = packet;
        }
        v40 = encryptionStruct->field_C6A;
        encryptionStruct->field_C66 = 0;
        if ( v40 )
          efree(v40);
        encryptionStruct->field_C6A = 0;
        encryptionStruct->field_C6E = 0;
        encryptionStruct->field_C72 = 0;
        goto RETURN_FREE_MEMORY;
      case 0xE:
        v47 = &packet->EncryptSeedOrSizeDWORD;
        v48 = &packet->byte0 + Size;
        if ( &packet->EncryptSeedOrSizeDWORD < (packet + Size) )
        {
          do
          {
            v49 = *v47;
            v50 = (v47 + 1);
            v51 = v49;
            ProcessCorePackets(encryptionStruct, v50, v49, 0);
            v47 = &v50[v51];
          }
          while ( v47 < v48 );
        }
        goto LABEL_12;
      default:
        goto RETURN_FREE_MEMORY;
    }
    goto LABEL_12;
  }
  ProcessRegularPackets(encryptionStruct->dword2A, &packet->byte0, Size, encryptionStruct, a5);
  a5 = 0;
RETURN_FREE_MEMORY:
  if ( a5 )
    efree(v6);
}

//----- (0041C2B0) --------------------------------------------------------
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // edx
  __int64 v5; // rax
  int v6; // eax
  DWORD v7; // kr00_4
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int Size; // ebx
  int v12; // ecx
  unsigned int v13; // eax
  int v14; // eax
  signed int v15; // ebx
  DWORD v16; // esi
  int v17; // ecx
  signed int v18; // edi
  int v19; // ebx
  int i; // edi
  int v21; // ecx
  char buf[6]; // [esp+10h] [ebp-210h] BYREF
  int v23; // [esp+16h] [ebp-20Ah]
  int v24; // [esp+1Ah] [ebp-206h]
  char buff[486]; // [esp+20h] [ebp-200h] BYREF

  v2 = *&connection[4].usControl;
  if ( v2 == 1 )
  {
    v3 = (GetTickCount() / 0xA - *&connection[4].usTransform);
    if ( ((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 100 )
    {
      v4 = *&connection[5].usControl;
      buf[0] = 0;
      buf[1] = 1;
      *&buf[2] = v4;
      LOWORD(v23) = 1;
      WriteToNetwork(connection, buf, 8u);
    }
  }
  else if ( v2 == 2 )
  {
    if ( *&connection->usTransform )
    {
      if ( (v5 = (GetTickCount() / 0xA - *&connection[1].usTransform), v6 = (HIDWORD(v5) ^ v5) - HIDWORD(v5), v6 > 2000)
        || v6 > 500 && *(&connection->lScale + 2) > 300
        || v6 > 50 && *(&connection->lScale + 2) > 1000 )
      {
        *&connection[1].usTransform = GetTickCount() / 0xA;
        buf[0] = 0;
        buf[1] = 5;
        v7 = GetTickCount();
        v8 = *&connection[222].usTransform;
        *&buf[2] = v7 / 0xA;
        v23 = *&connection[222].usControl + 1;
        v24 = v8;
        WriteToNetwork(connection, buf, 0xEu);
      }
    }
    while ( *&connection[264].usTransform > 0 )
    {
      v9 = *&connection[51].usControl;
      if ( v9 >= 2048
        || *&connection[50].usTransform - *(&connection[50].lScale + 2) >= 128
        || *&connection[259].usControl && v9 > 256 )
      {
        break;
      }
      v10 = *&connection[258].usTransform;
      *&buff[2] = *&connection[258].usControl;
      buff[0] = 0;                              // 0x00 - Billing Unknown Packet
      buff[1] = 10;
      Size = 480;
      if ( *&buff[2] - v10 <= 480 )
        Size = *&buff[2] - v10;
      qmemcpy(&buff[6], (*&connection[258].usTransform + *(&connection[257].lScale + 2)), Size);
      WriteData(connection, buff, Size + 6, 1);
      v12 = *&connection[258].usControl;
      v13 = Size + *&connection[258].usTransform;
      *&connection[258].usTransform = v13;
      if ( v13 == v12 )
      {
        if ( *(&connection[258].lScale + 2) )
          efree(*(&connection[257].lScale + 2));
        v14 = *&connection[264].usTransform - 1;
        *&connection[264].usTransform = v14;
        memcpy(&connection[257].lScale + 2, &connection[259].usTransform, 20 * v14);
      }
    }
    if ( *(&connection[50].lScale + 2) < *&connection[50].usTransform )
    {
      *buf = 0;
      v15 = 90;
      v16 = GetTickCount() / 0xA;
      v17 = *(&connection[136].lScale
            + 4
            * (((*(&connection[50].lScale + 2) >> 31) ^ abs32(*(&connection[50].lScale + 2)))
             - (*(&connection[50].lScale + 2) >> 31))
            + 2);
      v18 = *(v17 + 4);
      if ( v18 > 256 )
        v15 = 170;
      if ( abs32(v16 - *v17) <= v15 )
      {
        v19 = *buf;
      }
      else
      {
        *v17 = v16;
        SendPacketCluster(connection, (v17 + 6), v18);
        v19 = 1;
      }
      for ( i = *(&connection[50].lScale + 2) + 1; i < *&connection[50].usTransform; ++i )
      {
        if ( v19 >= 3 )
          break;
        v21 = *(&connection[136].lScale + 4 * (((i >> 31) ^ abs32(i)) - (i >> 31)) + 2);
        if ( v21 )
        {
          if ( abs32(v16 - *v21) > 200 )
          {
            *v21 = v16;
            SendPacketCluster(connection, (v21 + 6), *(v21 + 4));
          }
          ++v19;
        }
      }
    }
  }
}

//----- (0041C5E0) --------------------------------------------------------
// NetworkData.WriteData()
int __thiscall WriteData(Encryption_Struct *encryption, const void *buf, unsigned int len, int a4)
{
  unsigned int v4; // edi
  signed int v6; // esi
  unsigned int v7; // ebp
  int v9; // esi
  DWORD *v10; // eax
  DWORD *v11; // ebp
  DWORD v12; // edx
  _WORD *v13; // ebp
  char *v14; // ebp
  int v15; // edx
  signed int i; // [esp+10h] [ebp-1FCh]
  unsigned int v17; // [esp+10h] [ebp-1FCh]
  BOOL v18; // [esp+14h] [ebp-1F8h]
  char v19[2]; // [esp+18h] [ebp-1F4h] BYREF
  char v20[498]; // [esp+1Ah] [ebp-1F2h] BYREF

  v4 = len;
  if ( len > 496 )
  {
    v6 = 0;
    for ( i = 0; ; v6 = i )
    {
      v7 = v4 - v6;
      if ( (v4 - v6) >= 480 )
        v7 = 480;
      v19[1] = (v7 == v4 - v6) + 8;
      v19[0] = 0;
      qmemcpy(v20, buf + v6, v7);
      if ( !WriteData(encryption, v19, v7 + 2, 1) )
        break;
      i += v7;
      if ( i >= len )
        return 1;
      v4 = len;
    }
    return 0;
  }
  if ( a4 )
  {
    if ( encryption->field_25E - encryption->field_262 >= 255 )
      return 0;
    v18 = encryption->field_266 < 4096;
    v17 = len + 6;
    v9 = ((encryption->field_25E >> 31) ^ abs32(encryption->field_25E)) - (encryption->field_25E >> 31);
    v10 = emalloc(len + 12);
    encryption->PacketPointers[v9] = v10;
    v11 = v10;
    if ( v18 )
      v12 = GetTickCount() / 0xA;
    else
      v12 = 0;
    *v11 = v12;
    v13 = v11 + 1;
    *v13 = v17;
    v14 = (v13 + 1);
    *v14 = 0;
    v14[1] = 3;
    *(v14 + 2) = encryption->field_25E;
    qmemcpy(v14 + 6, buf, len);
    v15 = encryption->field_25E + 1;
    encryption->field_266 += v17;
    encryption->field_25E = v15;
    if ( v18 )
      SendPacketCluster(encryption, v14, v17);
  }
  else
  {
    SendPacketCluster(encryption, buf, len);
  }
  return 1;
}
// 41C607: conditional instruction was optimized away because of '%len.4>=1F1'

//----- (0041C7C0) --------------------------------------------------------
// Player.LogReliablePackets()
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename)
{
  struct CONNECTION *v2; // edi
  FILE *v3; // ebx
  int i; // ebp
  int v5; // esi
  int v6; // edi
  unsigned __int8 *v7; // esi

  v2 = encryption;
  v3 = fopen(Filename, "wt");
  if ( v3 )
  {
    for ( i = *(&v2[50].lScale + 2); i < *&v2[50].usTransform; ++i )
    {
      v5 = *(&v2[136].lScale + 4 * (((i >> 31) ^ abs32(i)) - (i >> 31)) + 2);
      if ( v5 )
      {
        v6 = *(v5 + 4);
        fprintf(v3, "%10d %4d: ", *v5, v6);
        v7 = (v5 + 6);
        if ( v6 > 0 )
        {
          do
          {
            fprintf(v3, "%02x ", *v7++);
            --v6;
          }
          while ( v6 );
        }
        fprintf(v3, "\n");
        v2 = encryption;
      }
      else
      {
        fprintf(v3, "Acknowledged\n");
      }
    }
    fclose(v3);
  }
}

//----- (0041C890) --------------------------------------------------------
void __thiscall GetNewsRequest(struct CONNECTION *encryption, char *MemoryPointer, int a3, int a4)
{
  int v4; // eax

  v4 = *&encryption[264].usTransform;
  if ( v4 < 4 )
  {
    *(&encryption[257].lScale + 20 * v4 + 2) = MemoryPointer;
    *(&encryption[258].usControl + 5 * *&encryption[264].usTransform) = a3;
    *(&encryption[258].usTransform + 5 * *&encryption[264].usTransform) = 0;
    *(&encryption[258].lScale + 20 * *&encryption[264].usTransform + 2) = 1;
    *(&encryption[259].usControl + 5 * (*&encryption[264].usTransform)++) = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041C920) --------------------------------------------------------
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4)
{
  int v4; // eax

  v4 = *&encryption[264].usTransform;
  if ( v4 < 4 )
  {
    *(&encryption[257].lScale + 20 * v4 + 2) = a2;
    *(&encryption[258].usControl + 5 * *&encryption[264].usTransform) = a3;
    *(&encryption[258].usTransform + 5 * *&encryption[264].usTransform) = 0;
    *(&encryption[258].lScale + 20 * *&encryption[264].usTransform + 2) = 0;
    *(&encryption[259].usControl + 5 * (*&encryption[264].usTransform)++) = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041C9B0) --------------------------------------------------------
int __thiscall sub_41C9B0(int this, int a2, int a3)
{
  int result; // eax

  *a2 = *(this + 3182);
  result = *(this + 3186);
  *a3 = result;
  return result;
}

//----- (0041C9D0) --------------------------------------------------------
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart)
{
  if ( *&encryption[264].usTransform <= 0 )
  {
    *ASyncS2CEnd = 0;
    *ASyncS2CStart = 0;
  }
  else
  {
    *ASyncS2CEnd = *&encryption[258].usControl;
    *ASyncS2CStart = *&encryption[258].usTransform;
  }
}

//----- (0041CA10) --------------------------------------------------------
int __thiscall sub_41CA10(int this)
{
  return *(this + 3174);
}

//----- (0041CA20) --------------------------------------------------------
// NetworkData.something()
void __thiscall SendPacketCluster(Encryption_Struct *encryption, const void *buf, unsigned int len)
{
  signed int v4; // ecx
  int v5; // eax
  _BYTE *v6; // ecx
  void *v7; // ecx
  int *packetBuffer; // [esp-8h] [ebp-18h]
  unsigned int length; // [esp-4h] [ebp-14h]

  if ( len > 255 || (v4 = *(encryption->dword2A + 35920), (len + 3) > v4) )
  {
    WriteToNetwork(encryption, buf, len);
  }
  else
  {
    v5 = encryption->field_C12 - encryption - 2706;
    if ( (v5 + len + 1) > v4 )
    {
      if ( v5 > 2 && BYTE2(encryption->field_A92) + 3 == v5 )
      {
        length = encryption->field_C12 - encryption - 2709;
        packetBuffer = (&encryption->field_A92 + 3);
      }
      else
      {
        length = encryption->field_C12 - encryption - 2706;
        packetBuffer = &encryption->field_A92;
      }
      WriteToNetwork(encryption, packetBuffer, length);
      v5 = 0;
      encryption->field_C12 = &encryption->field_A92;
    }
    if ( v5 )
    {
      ++*(encryption->dword2A + 16);
    }
    else
    {
      *encryption->field_C12 = 0;
      v6 = (encryption->field_C12 + 1);
      encryption->field_C12 = v6;
      *v6 = 14;
      ++encryption->field_C12;
    }
    *encryption->field_C12 = len;
    v7 = (encryption->field_C12 + 1);
    encryption->field_C12 = v7;
    qmemcpy(v7, buf, len);
    encryption->field_C12 += len;
  }
}

//----- (0041CB20) --------------------------------------------------------
void __thiscall sub_41CB20(int this)
{
  int v2; // eax
  const char *v3; // [esp-8h] [ebp-Ch]
  unsigned int v4; // [esp-4h] [ebp-8h]

  v2 = *(this + 3090) - this - 2706;
  if ( v2 > 2 )
  {
    if ( *(this + 2708) + 3 == v2 )
    {
      v4 = *(this + 3090) - this - 2709;
      v3 = (this + 2709);
    }
    else
    {
      v4 = *(this + 3090) - this - 2706;
      v3 = (this + 2706);
    }
    WriteToNetwork(this, v3, v4);
    *(this + 3090) = this + 2706;
  }
}

//----- (0041CB70) --------------------------------------------------------
int __thiscall sub_41CB70(int this, int a2, int a3)
{
  int result; // eax

  *a2 = *(this + 2682);
  result = *(this + 2686);
  *a3 = result;
  return result;
}

//----- (0041CB90) --------------------------------------------------------
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5)
{
  *a2 = *&this[222].usControl;
  *a3 = *&this[222].usTransform;
  *a4 = *(&this[222].lScale + 2);
  *a5 = *&this[223].usControl;
}

//----- (0041CBD0) --------------------------------------------------------
void __thiscall sub_41CBD0(int this)
{
  *(this + 50) = 4;
}

//----- (0041CBE0) --------------------------------------------------------
char *__cdecl GetIPAddressString(struct in_addr in)
{
  return inet_ntoa(in);
}

//----- (0041CBF0) --------------------------------------------------------
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename)
{
  char *v2; // eax
  int OutSize; // [esp+0h] [ebp-4h] BYREF

  OutSize = this;
  v2 = CompressFile(Filename, &OutSize, &Filename, 0, 0, 0, 0);
  if ( v2 )
    efree(v2);
  return Filename;
}
// 41CBF0: inconsistent function type and number of purged bytes

//----- (0041CC30) --------------------------------------------------------
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *NewsTxtFileChecksum, const void *unknown, unsigned int bytes, int DoFileCompression, int FileSize)
{
  void *v7; // ebx
  FILE *file; // eax
  FILE *filee; // edi
  char *result; // eax
  int fileHandle; // eax
  size_t fileSize; // ebx
  void *buffer; // esi
  void *compresedBuffer; // edi
  void *v15; // ebp
  void *v16; // [esp+0h] [ebp-14h]
  _DWORD *v18; // [esp+Ch] [ebp-8h]
  void *ptr; // [esp+10h] [ebp-4h]
  const void *retaddr; // [esp+14h] [ebp+0h]

  file = fopen(
           Filename,
           "rb\x00\x00unnamed\x00server\x00\x00wb\x00\x00Player entering game: %s\n"
           "\x00\x00\x00Player spectating game: %s\n"
           "\x00Name\x00\x00\x00\x00UserId\x00\x00NOTICE: 5 minutes remaining in current game.\x00\x00\x00\x00NOTICE: 1 m"
           "inute remaining in current game.\x00Soccer game over.\x00\x00\x00NOTICE: 5 minutes remaining.\x00\x00\x00\x00"
           "NOTICE: 1 minute remaining.\x00NOTICE: Game over\x00\x00\x00King of the Hill: %s given %d points\x00\x00\x00\x00"
           "King of the Hill restarted\x00\x00WARNING: Security checksum not returned {st=%d,et=%d}\x00\x00\x00Player kic"
           "ked off for not returning security packet: %s\n"
           "\x00\x00\x00\x00Long range scanners indicate enemy activity in another quadrant, type ?GO to warp.\x00\x00Par"
           "ameters resent for arena(%s)\n"
           "\x00\x00\x00\x00Valid range for parameter %s:%s is (%d through %d)\x00\x00%s:%s is not a valid user parameter"
           ".\x00\x00\x00\x00All\x00Shark\x00\x00\x00Lancaster\x00\x00\x00Terrier\x00Weasel\x00\x00Leviathan\x00\x00\x00S"
           "pider\x00\x00Javelin\x00Warbird\x00Soccer game over.  Personal Reward: %d\x00\x00Enemy goal had no points to "
           "give.\x00\x00\x00%s  REWARD:%d\x00\x00\x00SCORE: Evens:%d  Odds:%d\x00\x00\x00\x00SCORE: Warbirds:%d  Javelin"
           "s:%d\x00SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d\x00\x00\x00SCORE: Warbirds:%d  Javelins:%d  Spiders:%d "
           " Leviathans:%d\x00\x00rt\x00\x00\n"
           "\x00\x00\x00%s=%s\n"
           "\x00\x00[%s]\n"
           "\x00\x00\x00wt\x00\x00rb+\x00%s\n"
           "\x000123456789ABCDEF1x2y3z4\x00Error\x00\x00\x00Out of memory (Alloc:%d)\x00\x00\x00\x00Out of memory (Resize"
           ")\x00\x00\x01\x00\x00\x00Played kicked off, arena full: %s\n"
           "\x00\x00You have been kicked off to make space for a registered user.\x00\x00\x00~Demo%d\x00Played kicked off"
           ", arena full to demo users: %s\n"
           "\x00\x00\x00\x00Played kicked off, ID block: %s\n"
           "\x00\x00\x00\x00Played kicked off, IP block: %s\n"
           "\x00\x00\x00\x00Played kicked off, obscene name: %s\n"
           "\x00\x00\x00\x00Played kicked off for having slow modem: %s\n"
           "\x00\x00\x00\x00%s>  VIP LOGGED IN\n"
           "\x00%s>  MODERATOR LOGGED IN\n"
           "\x00\x00\x00%s>  SUPER MODERATOR LOGGED IN\n"
           "\x00%s> SYSOP LOGGED IN\n"
           "\x00\x00\x00\x00Connection request from: %s\n"
           "\x00\x00\x00\x00Arena is recycling so the change can take effect.\x00\x00\x00File received: %s\x00\x00\x00Fil"
           "e has arrived, but is too big (size limit of 512k)\x00\x00\x00permit.txt\x00\x00moderate.txt\x00\x00\x00\x00F"
           "ile arrived at server, could not forward: %s\x00\x00\x00File arrived at server, forwarding to %s: %s\x00\x00\x00"
           "\x00pulled.dat\x00\x00File arrived, forwarding: %s\x00\x00\x00\x00Incompatible network protocol attempting to enter game");
  filee = file;
  if ( file )
  {
    v16 = v7;
    fileHandle = _fileno(file);
    fileSize = _filelength(fileHandle);
    buffer = emalloc(fileSize);
    fread(buffer, fileSize, 1u, filee);
    fclose(filee);
    if ( FileSize )
      *FileSize = fileSize;
    if ( NewsTxtFileChecksum )
      *NewsTxtFileChecksum = CRC32(buffer, fileSize);
    if ( DoFileCompression )
    {
      FileSize = (4 * fileSize) / 3 + 12;
      compresedBuffer = ExpandMemory(0, FileSize, 1);
      if ( compress(compresedBuffer, &FileSize, buffer, fileSize) )
      {
        efree(compresedBuffer);                 // Why Clear memory after compress? Maybe this is failure
        ptr = 0;
      }
      else
      {
        ptr = ExpandMemory(compresedBuffer, NewsTxtFileChecksum, 1);
      }
      *v18 = &Filename[NewsTxtFileChecksum];
      v15 = emalloc(&Filename[NewsTxtFileChecksum]);
      if ( retaddr )
        qmemcpy(v15, retaddr, Filename);
      qmemcpy(&Filename[v15], ptr, NewsTxtFileChecksum);
      efree(ptr);
    }
    else
    {
      *OutSize = fileSize + bytes;
      v15 = emalloc(fileSize + bytes);
      if ( unknown )
        qmemcpy(v15, unknown, bytes);
      qmemcpy(v15 + bytes, buffer, fileSize);
    }
    efree(v16);
    result = v15;
  }
  else
  {
    if ( NewsTxtFileChecksum )
      *NewsTxtFileChecksum = 0;
    if ( FileSize )
      *FileSize = 0;
    *OutSize = bytes;
    result = emalloc(bytes);
    if ( unknown )
      qmemcpy(result, unknown, bytes);
  }
  return result;
}
// 41CC30: could not find valid save-restore pair for ebx
// 41CC30: could not find valid save-restore pair for ebp
// 41CC99: variable 'v7' is possibly undefined
// 41CD73: variable 'NewsTxtFileChecksum' is possibly undefined
// 41CD77: variable 'v18' is possibly undefined
// 41F1B0: using guessed type _DWORD __cdecl _filelength(_DWORD);

//----- (0041CEA0) --------------------------------------------------------
int __cdecl setRNGSeed(int seedValue)
{
  int result; // eax

  result = seedValue;
  RNGSeed = seedValue;
  return result;
}
// 42E458: using guessed type int RNGSeed;

//----- (0041E940) --------------------------------------------------------
char *__cdecl sub_41E940(int a1)
{
  char *result; // eax
  char *v2; // eax
  int v3[4]; // [esp+0h] [ebp-10h] BYREF

  result = getenv("COMSPEC");
  v3[0] = result;
  if ( a1 )
  {
    v3[1] = 4362316;
    v3[2] = a1;
    v3[3] = 0;
    if ( !result || (result = _spawnve(0, result, v3, 0), result == -1) && (dword_4D8B38 == 2 || dword_4D8B38 == 13) )
    {
      v2 = "command.com";
      if ( (dword_4D8B44 & 0x8000) == 0 )
        v2 = "cmd.exe";
      v3[0] = v2;
      result = _spawnvpe(0, v2, v3, 0);
    }
  }
  else if ( result )
  {
    result = (_access(result, 0) == 0);
  }
  return result;
}
// 4D8B38: using guessed type int dword_4D8B38;
// 4D8B44: using guessed type int dword_4D8B44;

//----- (0041EA60) --------------------------------------------------------
int __cdecl CurrentTimeInMilliseconds()
{
  return _ftime(&timebuffer);
}
// 422E90: using guessed type _DWORD __cdecl _ftime(_DWORD);
// 4D8B88: using guessed type int timebuffer;

//----- (004214B0) --------------------------------------------------------
void __noreturn sub_4214B0()
{
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int ms_exc; // [esp+Ch] [ebp-18h]

  if ( dword_4D8BDC )
    dword_4D8BDC(v4, v5, v6, ms_exc);
  abort();
}
// 4214ED: variable 'v4' is possibly undefined
// 4214ED: variable 'v5' is possibly undefined
// 4214ED: variable 'v6' is possibly undefined
// 4214ED: variable 'ms_exc' is possibly undefined

//----- (00421540) --------------------------------------------------------
void __noreturn sub_421540()
{
  if ( off_42E734 )
    (off_42E734)();
  sub_4214B0();
}
// 42E734: using guessed type int (__cdecl *off_42E734)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00423390) --------------------------------------------------------
BOOL __cdecl DateFunction(int a1)
{
  BOOL result; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp-28h] [ebp-30h]
  int v6; // [esp-24h] [ebp-2Ch]
  int v7; // [esp-20h] [ebp-28h]
  int v8; // [esp-1Ch] [ebp-24h]
  int v9; // [esp-18h] [ebp-20h]
  int v10; // [esp-14h] [ebp-1Ch]

  if ( !dword_43099C )
    return 0;
  v2 = *(a1 + 20);
  if ( v2 != dword_430A30 || v2 != dword_430A40 )
  {
    if ( dword_4D8C18 )
    {
      if ( LOWORD(stru_4D8CB8.Bias) )
      {
        v10 = stru_4D8CB8.StandardName[1];
        v9 = 0;
        v8 = 0;
        v7 = HIWORD(stru_4D8CB8.Bias);
        v6 = *(a1 + 20);
        v5 = 0;
      }
      else
      {
        v10 = 0;
        v9 = stru_4D8CB8.StandardName[0];
        v8 = stru_4D8CB8.StandardName[1];
        v7 = HIWORD(stru_4D8CB8.Bias);
        v6 = *(a1 + 20);
        v5 = 1;
      }
      cvtdate(
        1,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        stru_4D8CB8.StandardName[2],
        stru_4D8CB8.StandardName[3],
        stru_4D8CB8.StandardName[4],
        stru_4D8CB8.StandardName[5]);
      if ( word_4D8C64 )
        cvtdate(
          0,
          0,
          *(a1 + 20),
          word_4D8C66,
          0,
          0,
          HIWORD(dword_4D8C68),
          dword_4D8C6C,
          HIWORD(dword_4D8C6C),
          dword_4D8C70,
          HIWORD(dword_4D8C70));
      else
        cvtdate(
          0,
          1,
          *(a1 + 20),
          word_4D8C66,
          HIWORD(dword_4D8C68),
          dword_4D8C68,
          0,
          dword_4D8C6C,
          HIWORD(dword_4D8C6C),
          dword_4D8C70,
          HIWORD(dword_4D8C70));
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate(0, 1, *(a1 + 20), 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = *(a1 + 28);
  if ( dword_430A34 < dword_430A44 )
  {
    if ( v3 >= dword_430A34 && v3 <= dword_430A44 )
    {
      if ( v3 > dword_430A34 && v3 < dword_430A44 )
        return 1;
      goto LABEL_25;
    }
    return 0;
  }
  if ( v3 < dword_430A44 || v3 > dword_430A34 )
    return 1;
  if ( v3 > dword_430A44 && v3 < dword_430A34 )
    return 0;
LABEL_25:
  v4 = 1000 * (*a1 + 60 * (*(a1 + 4) + 60 * *(a1 + 8)));
  if ( v3 == dword_430A34 )
    result = v4 >= dword_430A38;
  else
    result = v4 < dword_430A48;
  return result;
}
// 423600: using guessed type _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 43099C: using guessed type int dword_43099C;
// 430A30: using guessed type int dword_430A30;
// 430A34: using guessed type int dword_430A34;
// 430A38: using guessed type int dword_430A38;
// 430A40: using guessed type int dword_430A40;
// 430A44: using guessed type int dword_430A44;
// 430A48: using guessed type int dword_430A48;
// 4D8C18: using guessed type int dword_4D8C18;
// 4D8C64: using guessed type __int16 word_4D8C64;
// 4D8C66: using guessed type __int16 word_4D8C66;
// 4D8C68: using guessed type int dword_4D8C68;
// 4D8C6C: using guessed type int dword_4D8C6C;
// 4D8C70: using guessed type int dword_4D8C70;

//----- (00426670) --------------------------------------------------------
int __cdecl sub_426670(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_430E60);
}
// 4264A0: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00426690) --------------------------------------------------------
int __cdecl sub_426690(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_430E78);
}
// 4264A0: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (004266B0) --------------------------------------------------------
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *String)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &String, String, 0, 0, 0, 0);
  return sub_426670(v3, Result);
}
// 427370: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004266F0) --------------------------------------------------------
int __cdecl sub_4266F0(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_426690(v3, a1);
}
// 427370: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004283A0) --------------------------------------------------------
int __cdecl getch()
{
  int result; // eax
  int v1; // esi
  unsigned __int8 *v2; // eax
  DWORD NumberOfEventsRead; // [esp+10h] [ebp-1Ch] BYREF
  DWORD Mode; // [esp+14h] [ebp-18h] BYREF
  struct _INPUT_RECORD Buffer; // [esp+18h] [ebp-14h] BYREF

  if ( dword_431490 == -1 )
  {
    result = hConsoleInput;
    if ( hConsoleInput != -1 )
    {
      if ( hConsoleInput == -2 )
      {
        __initconin();
        result = hConsoleInput;
      }
      GetConsoleMode(result, &Mode);
      SetConsoleMode(hConsoleInput, 0);
      if ( ReadConsoleInputA(hConsoleInput, &Buffer, 1u, &NumberOfEventsRead) )
      {
        while ( NumberOfEventsRead )
        {
          if ( Buffer.EventType == 1 && Buffer.Event.KeyEvent.bKeyDown )
          {
            v1 = Buffer.Event.KeyEvent.uChar.AsciiChar;
            if ( Buffer.Event.KeyEvent.uChar.AsciiChar )
              goto LABEL_14;
            v2 = _getextendedkeycode(&Buffer.Event);
            if ( v2 )
            {
              v1 = *v2;
              dword_431490 = v2[1];
              goto LABEL_14;
            }
          }
          if ( !ReadConsoleInputA(hConsoleInput, &Buffer, 1u, &NumberOfEventsRead) )
            break;
        }
      }
      v1 = -1;
LABEL_14:
      SetConsoleMode(hConsoleInput, Mode);
      result = v1;
    }
  }
  else
  {
    result = dword_431490;
    dword_431490 = -1;
  }
  return result;
}
// 4285A0: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 428720: using guessed type int __initconin(void);
// 431490: using guessed type int dword_431490;

//----- (004284B0) --------------------------------------------------------
int __cdecl console_input_wrapper()
{
  HANDLE v1; // eax
  int v2; // eax
  void *v3; // esp
  int *v4; // edi
  DWORD v5; // eax
  int *i; // esi
  int v7; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+4h] [ebp-Ch] BYREF
  DWORD NumberOfEvents; // [esp+8h] [ebp-8h] BYREF
  DWORD NumberOfEventsRead; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_431490 != -1 )
    return 1;
  v1 = hConsoleInput;
  if ( hConsoleInput == -2 )
  {
    __initconin();
    v1 = hConsoleInput;
  }
  if ( v1 != -1 )
  {
    if ( GetNumberOfConsoleInputEvents(v1, &NumberOfEvents) )
    {
      if ( NumberOfEvents )
      {
        v2 = 20 * NumberOfEvents + 3;
        LOBYTE(v2) = v2 & 0xFC;
        v3 = alloca(v2);
        v4 = &v7;
        if ( &v7 )
        {
          if ( PeekConsoleInputA(hConsoleInput, &v7, NumberOfEvents, &NumberOfEventsRead) )
          {
            v5 = NumberOfEventsRead;
            if ( NumberOfEventsRead )
            {
              if ( NumberOfEventsRead <= NumberOfEvents )
              {
                for ( i = &v8; ; i += 5 )
                {
                  if ( *v4 == 1 && *i )
                  {
                    if ( *(i + 10) || _getextendedkeycode(i) )
                      return 1;
                    v5 = NumberOfEventsRead;
                  }
                  --v5;
                  v4 += 5;
                  NumberOfEventsRead = v5;
                  if ( !v5 )
                    return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 428545: conditional instruction was optimized away because of '%NumberOfEventsRead.4!=0'
// 4285A0: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 428720: using guessed type int __initconin(void);
// 431490: using guessed type int dword_431490;

//----- (004288F0) --------------------------------------------------------
void __usercall DeleteOperatorSomething20(int a1@<ebp>)
{
  operator delete(*(a1 - 36));
}

//----- (0042A0CB) --------------------------------------------------------
#error "42A0CB: cannot convert to microcode (funcsize=0)"

// nfuncs=447 queued=188 decompiled=188 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 188 function(s)"
