/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __fastcall sub_401000(int a1, unsigned int a2, unsigned int *a3, unsigned int a4);
_DWORD *__fastcall sub_401170(unsigned int a1, _DWORD *a2, int a3, unsigned int *a4);
_DWORD *__fastcall sub_4013A0(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, unsigned int a5);
_DWORD *__fastcall sub_401520(unsigned int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int *a5);
int nullsub_1(); // weak
unsigned int __thiscall sub_401A70(int *this, unsigned __int8 *a2, int a3);
unsigned int __thiscall sub_401AB0(int *this, unsigned __int8 *a2);
int __thiscall sub_401AF0(_DWORD *this, int a2);
// int __userpurge sub_401B90@<eax>(int a1@<ebp>, int a2, int a3);
// _DWORD *__userpurge sub_401BC0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4);
_DWORD *__thiscall sub_401BF0(_DWORD *this, char a2);
void __thiscall sub_401C10(_DWORD *this);
std::locale::facet *__thiscall std::locale::facet::`scalar deleting destructor'(std::locale::facet *this, char a2);
_DWORD *__thiscall sub_401C40(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_401C70(_DWORD *this, int a2);
char __fastcall sub_401C90(int a1, _DWORD *a2);
int __thiscall sub_401E00(_DWORD *this, char a2);
// int __userpurge sub_401ED0@<eax>(int a1@<ebp>, int a2, _DWORD *a3);
_DWORD *__thiscall sub_402030(_DWORD *this, int a2);
int __thiscall sub_4020F0(_DWORD *this);
void *__thiscall sub_402100(void *this, char a2);
int __thiscall sub_402120(_BYTE *this);
// int __userpurge sub_402200@<eax>(int *a1@<ecx>, int a2@<edi>, _BYTE *a3);
void __thiscall sub_402350(int this, int *a2, int *a3, int a4);
bool __thiscall sub_4024A0(_DWORD *this, char a2);
char __thiscall sub_4024F0(_DWORD *this);
int __thiscall sub_402590(_DWORD *this, int a2, int a3, int a4, char a5, int a6);
char __thiscall sub_402AD0(char *this, int a2, int a3, int a4, int a5, int a6, int a7, unsigned __int8 (__fastcall *a8)(int, int, int, int), int a9);
char __thiscall sub_402F90(_DWORD *this, char a2);
void __thiscall sub_4031C0(int this);
// char __usercall sub_403220@<al>(int *a1@<ecx>, int a2@<ebx>, int a3@<edi>);
int __thiscall sub_403340(unsigned int *this, int *a2);
int __thiscall sub_403570(_DWORD *this);
char __thiscall sub_4035F0(int this);
void __thiscall sub_403620(unsigned int *this);
int __thiscall sub_403700(_DWORD *this);
int __thiscall sub_403770(_DWORD *this, int *a2);
char *__thiscall sub_403880(_DWORD *this, void *a2, int a3);
void __thiscall sub_4038D0(_DWORD *this, char *a2);
_DWORD *__thiscall sub_403C70(_DWORD *this, int a2, void *a3, int a4, int a5, int a6, char a7);
void *__thiscall sub_403E10(void *this, char a2);
int __thiscall sub_403E30(void *this);
_DWORD *__thiscall sub_403F00(_DWORD *this, int a2, int a3, char a4, int a5);
int __thiscall sub_404130(_DWORD *this, int a2);
int __thiscall sub_404220(_BYTE *this);
int __thiscall sub_4042C0(int this);
void __thiscall sub_4043D0(_DWORD *this, int a2);
int nullsub_2(const char *, ...); // weak
_DWORD *__thiscall sub_404A90(_DWORD *this);
BOOL __thiscall CxFile::PutC(CxFile *this, unsigned __int8 a2);
void __thiscall CxMemFile::~CxMemFile(CxMemFile *__hidden this); // idb
char __thiscall CxMemFile::Close(CxMemFile *this);
// void __usercall sub_404B70(int a1@<ecx>, int a2@<ebp>);
void __thiscall sub_404B80(_DWORD *this, int a2, int a3, int a4, char a5);
void __thiscall sub_404D10(_DWORD *this, int a2, int a3, int a4, int a5, char a6);
void __thiscall sub_404DD0(_DWORD *this, int a2, int a3, int a4, char a5, int a6, int a7);
void __thiscall sub_404E20(_DWORD *this, int a2, int a3, int a4, char a5);
char __fastcall sub_404E60(int a1, int a2);
char __fastcall sub_404F40(int a1, int a2, unsigned __int16 a3, _BYTE *a4);
_DWORD *__thiscall sub_405030(_DWORD *this, int a2, int a3, int a4, char a5);
_DWORD *__thiscall sub_4050A0(_DWORD *this, char a2);
int __stdcall sub_4050F9(int); // weak
int __thiscall sub_405160(_DWORD *this);
int __thiscall sub_405190(_DWORD *this, char a2);
char __thiscall sub_4052C0(int this);
int __thiscall sub_405330(int this);
int __thiscall sub_405350(int this, unsigned int a2, unsigned int a3);
int __thiscall sub_405410(int this);
int __thiscall sub_405550(int this, int a2);
int __thiscall sub_405680(int this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_4057B0(int this);
int __thiscall sub_4057F0(int this, int a2, int a3, char a4);
int __thiscall sub_405930(int this, int a2, int a3, int a4, int a5, int a6, int a7, char a8);
int __thiscall sub_405A90(int this, int a2);
int __thiscall sub_405BC0(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_405D00(int this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_405EF0(_DWORD *this, int a2);
_DWORD *__thiscall sub_405F40(_DWORD *this, char a2);
int __thiscall sub_405FA0(int this);
char __thiscall sub_405FE0(_BYTE *this, int a2, unsigned int a3, int a4, char a5);
int __thiscall sub_4061A0(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_406230(int this, int a2, void *a3, unsigned int a4, char a5);
_DWORD *__thiscall sub_406320(_DWORD *this, char a2);
int __thiscall sub_4063A0(int this, int a2, int a3);
int __thiscall sub_406480(int this, int a2, _BYTE *a3, int a4);
int __thiscall sub_406520(_DWORD *this);
// int __userpurge sub_4065E0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char __thiscall sub_4066D0(_DWORD *this, int a2, char a3);
int __thiscall sub_406750(_DWORD *this);
int __thiscall sub_406790(int (__thiscall ***this)(void *), int a2, int a3, int a4, int a5);
int __thiscall sub_406930(_DWORD *this);
int __thiscall sub_406A10(_DWORD *this, char a2);
// void __userpurge sub_406A60(int *a1@<ecx>, int a2@<ebx>, _BYTE *a3, int a4);
int __thiscall sub_406D50(_DWORD *this, _DWORD *a2, _DWORD *a3, int *a4, unsigned int a5);
char *__thiscall sub_406EE0(_DWORD *this, char *Destination, int a3);
// _DWORD *__userpurge sub_406F10@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, const char *a3);
char *__thiscall sub_406FB0(void *this, char *Destination, int a3);
// _DWORD *__usercall sub_406FF0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
void __thiscall sub_407050(_DWORD *this);
_DWORD *__thiscall sub_407060(_DWORD *this, char a2);
void __thiscall sub_407080(_DWORD *this);
void *__thiscall sub_407090(void *this, int a2, char *Source, int a4, int a5);
_DWORD *__thiscall sub_4070F0(_DWORD *this, char a2);
void __thiscall sub_407110(_DWORD *this);
char *__thiscall sub_4071B0(int this, char *Destination, int a3);
int __fastcall sub_4072A0(char *Str, int a2);
int sub_4073D0(int a1, char *Format, ...);
_DWORD *__thiscall sub_407500(_DWORD *this, char a2);
void __thiscall sub_407520(_DWORD *this);
char *__thiscall sub_407530(const char *this, char *Destination, int a3);
char __thiscall sub_407560(void *this, char a2);
// int __usercall sub_4075C0@<eax>(int a1@<ebx>, int a2@<esi>, int a3, int *a4, int a5, char a6, int a7, int a8, char a9, char a10);
int __thiscall sub_407790(int *this);
int __thiscall sub_4077D0(int *this);
bool __thiscall sub_4077F0(int *this, int a2);
char __thiscall sub_407820(_DWORD *this);
int __thiscall sub_407850(char *this);
char *__thiscall sub_4078F0(char *this);
int __thiscall sub_407900(_DWORD *this);
int __thiscall sub_407910(_DWORD *this);
unsigned int __thiscall sub_407960(_BYTE *this, int a2, _BYTE *a3);
_BYTE *__thiscall sub_4079D0(_BYTE *this, int a2);
_BYTE *__thiscall sub_407A40(_BYTE *this);
void __thiscall sub_407A70(_BYTE *this);
unsigned int __thiscall sub_407AA0(char *this, char *a2);
int __thiscall sub_407B20(char *this);
int __fastcall sub_407B80(char *a1, unsigned __int8 *a2);
int sub_407C03(); // weak
// int __userpurge sub_407E80@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5);
_DWORD *__thiscall sub_407F30(_DWORD *this, _DWORD *a2);
// int __userpurge sub_407F70@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5);
// int __userpurge sub_408020@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5);
// int __userpurge sub_4080D0@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5);
int __thiscall sub_408180(_DWORD *this, int a2);
int __thiscall sub_4081D0(_DWORD *this, int a2);
int __thiscall sub_408220(_DWORD *this, int a2);
int __thiscall sub_408270(_DWORD *this);
int __thiscall ReadScrty1FileOffset(_DWORD *this, int a2, int a3);
int __thiscall sub_408570(_DWORD *this, int a2, int a3);
char __thiscall sub_4085E0(_DWORD *this, char *Str, int a3);
int __thiscall sub_4086E0(_DWORD *this, int a2, int a3);
int __thiscall sub_408740(_DWORD *this, const char *a2);
int __thiscall sub_4087F0(int *this);
BOOL __thiscall sub_408820(void *this);
BOOL __thiscall sub_408840(char *Source);
bool __thiscall sub_408AA0(void *this);
int __thiscall sub_408AE0(void *this);
// int __usercall sub_408BE0@<eax>(int *a1@<ebp>, _DWORD *a2@<edi>, int a3@<esi>);
// int *__userpurge sub_409050@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3);
void __thiscall sub_4090C0(_DWORD *this);
__int16 __thiscall sub_409160(unsigned int *this, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int sub_409351(); // weak
// __int16 __userpurge sub_4093E0@<ax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4, unsigned int a5, int a6);
_DWORD *__thiscall sub_4095B0(_DWORD *this, int a2);
int __thiscall sub_4095E0(int *this, unsigned int a2, int a3);
// int __userpurge sub_4097D0@<eax>(int *a1@<ecx>, int a2@<ebp>, unsigned int a3, _BYTE *a4, int a5, int a6);
int __thiscall sub_4099A0(int this, int a2);
int __thiscall sub_409B30(int *this, void (__thiscall ***a2)(_DWORD, _DWORD), int a3, int a4, char *a5);
// int __userpurge sub_409CD0@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5, char *a6);
int __thiscall sub_409D90(int *this);
int *__thiscall sub_409DA0(int *this, char a2);
int __thiscall sub_409E30(_DWORD *this, char *a2, int a3, int a4);
int __thiscall sub_409F20(int *this);
int *__thiscall sub_409F30(int *this, char a2);
// void __userpurge sub_409F90(int a1@<ecx>, int a2@<ebp>, int a3, char *a4, int a5, int a6, char a7, int a8);
// int __userpurge sub_40A220@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4);
// _DWORD *__userpurge sub_40A4C0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, char *a3);
int __thiscall sub_40A520(_DWORD *this, int a2);
int __thiscall sub_40A540(_DWORD *this, int a2);
unsigned int __thiscall sub_40A590(_DWORD *this, unsigned int a2, int a3);
signed int __thiscall sub_40A630(_DWORD *this, unsigned int a2, int a3);
// _DWORD *__userpurge sub_40A6A0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, char *a3);
int __thiscall sub_40A700(_DWORD *this);
int __thiscall sub_40A710(_DWORD *this, int a2);
int __thiscall sub_40A720(_DWORD *this, int a2, int a3);
BOOL __stdcall sub_40A740(int a1);
int __thiscall sub_40A7D0(int *this, int a2, int a3, int a4, char *a5);
int __thiscall sub_40AA10(int *this, int *a2, int a3);
_DWORD *__thiscall sub_40ABE0(_DWORD *this);
void __thiscall sub_40AC80(int this, double a2, double a3);
void __thiscall sub_40ACD0(int *this);
void __thiscall sub_40ADE0(_DWORD *this);
int __thiscall sub_40AE10(_DWORD *this);
unsigned int __thiscall sub_40AE50(int *this, int *a2, unsigned int a3);
int __thiscall sub_40AF00(int *this, int *a2);
_DWORD *__thiscall sub_40B070(_DWORD *this, int *a2);
// int __usercall sub_40B720@<eax>(int a1@<ebp>, size_t a2);
_DWORD *__thiscall sub_40B760(_DWORD *this, int a2);
// void *__usercall sub_40B780@<eax>(size_t a1@<edx>, void **a2@<ecx>, int a3@<ebp>);
void __thiscall sub_40B7D0(void *this);
void __cdecl sub_40B7E0(unsigned int a1);
char *__fastcall sub_40B8B0(_BYTE *a1, int a2, char *Str, char a4, int a5);
int __stdcall sub_40BA10(int); // weak
char *__fastcall strncpyt(void *dst, void *src, int len);
char *__fastcall sub_40BAE0(const char *a1, char *a2, signed int a3);
char *__fastcall sub_40BB60(char *Buf1, const char *Buf2);
char __fastcall sub_40BCB0(char *a1, int a2, char a3);
char *__thiscall sub_40BCD0(char *this);
_BYTE *__thiscall sub_40BCF0(_BYTE *this);
char *__fastcall sub_40BD10(char *Str);
void __thiscall sub_40BE30(unsigned int *this);
void __thiscall sub_40C1B0(const char **this, int a2, char *a3);
void sub_40C890(const char **a1, char *Format, ...);
// void __userpurge sub_40C9D0(int a1@<ecx>, int a2@<ebp>, size_t a3);
// unsigned int __userpurge sub_40CA40@<eax>(unsigned int *a1@<ecx>, int a2@<ebp>, _BYTE *a3, unsigned int a4);
int __thiscall sub_40CAD0(unsigned int *this, int a2, _BYTE *a3, unsigned int a4);
// void __userpurge sub_40CB70(unsigned int *a1@<ecx>, int a2@<ebp>, signed int a3, int a4);
// int __userpurge sub_40CFE0@<eax>(unsigned int *a1@<ecx>, int a2@<ebp>, char *a3, unsigned __int8 a4);
int sub_40D450();
char __thiscall sub_40D480(char *this);
int __thiscall sub_40D650(const char *this);
int __thiscall sub_40D7E0(const char *this);
int __thiscall sub_40D810(char *Format);
int __cdecl sub_40DA80(char *a1);
int sub_40DAA0(const char *, ...); // weak
void __noreturn sub_40DAC0(char *Format, ...);
const char **sub_40DB50(const char **a1, const char *Format, ...);
// char __usercall sub_40DCC0@<al>(int a1@<ebp>, const char *a2, unsigned int a3, const char *a4, char a5);
void __fastcall sub_40DD92(int a1, int a2, unsigned int a3, int a4);
int __thiscall sub_40DE60(int *this);
// int __userpurge sub_40E2E0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
void __thiscall sub_40E440(int *this);
char __thiscall sub_40E950(int *this, int *a2);
int __thiscall sub_40EED0(_DWORD *this, int a2, int a3);
int *__thiscall sub_40F0D0(int *this, void *src);
int __fastcall sub_40F3C0(int **a1, int a2, unsigned int a3);
bool __thiscall sub_40F700(int *this, int a2, char a3, int a4);
// int __userpurge sub_40F920@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
int __stdcall nullsub_4(int); // weak
char __thiscall sub_40F990(_DWORD *this, int a2, int a3);
int __thiscall sub_40FB20(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __stdcall sub_40FCDC(int); // weak
int __thiscall sub_40FD30(_DWORD *this, _DWORD *a2);
int __thiscall sub_40FD80(int *this);
char __thiscall sub_40FDA0(int *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_40FE60(_DWORD *this);
char __thiscall sub_40FE80(_BYTE *this);
// int __thiscall byte_410001(_DWORD, _DWORD, _DWORD, _DWORD);
char __thiscall sub_410990(_DWORD *this, char a2);
int *__thiscall sub_411370(int *this);
int __thiscall sub_4113A0(_DWORD *this);
bool __thiscall sub_4113B0(int *this, int a2);
// BOOL __usercall sub_411400@<eax>(int a1@<ecx>, int a2@<edx>, int a3@<ebp>, int a4@<esi>);
// void __usercall sub_4114C0(const char *a1@<ecx>, int a2@<ebp>);
_DWORD *__thiscall sub_4115B0(_DWORD *this);
int __thiscall sub_411640(const char *this);
void __thiscall sub_411750(char *this, char *a2, const char *a3);
int __thiscall sub_411920(_DWORD **this, _DWORD *a2);
// int __usercall sub_411B40@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3@<esi>);
_DWORD *__thiscall sub_411CB0(_DWORD *this);
// unsigned int __userpurge sub_411CD0@<eax>(unsigned int a1@<ecx>, int a2@<ebp>, char a3);
// int __usercall sub_411D50@<eax>(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_411DC0(int this, char *a2, int a3);
int __stdcall sub_411E30(int a1);
// int __usercall sub_411EB0@<eax>(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_411F20(_DWORD *this, int a2);
int __thiscall sub_412000(void *this);
void *sub_4120C0();
int sub_412170();
int __thiscall sub_412390(_DWORD *this);
bool __thiscall sub_412400(_DWORD *this, int a2);
int __thiscall sub_4124F0(_DWORD *this);
double __thiscall sub_412570(unsigned int *this);
int __cdecl sub_412680(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4);
int __cdecl sub_4126C0(int a1, int a2, int a3, int a4);
int __thiscall sub_412700(_DWORD *this);
_BYTE *__fastcall sub_412910(_BYTE *a1, unsigned __int8 *a2);
_BYTE *__thiscall sub_412950(_BYTE *this);
_BYTE *__thiscall sub_412B10(_BYTE *this, char a2);
int __thiscall sub_412B30(_BYTE *this);
char __thiscall sub_412C50(int this);
int __thiscall sub_412D60(_DWORD *this);
int __fastcall sub_412FA0(int a1, int a2, int a3, int a4, char a5);
_BYTE *__thiscall sub_4132D0(_BYTE *this, char a2);
int __stdcall sub_413300(char a1);
int __stdcall sub_413370(int (*a1)(void));
char __stdcall sub_4133C0(int a1);
int __thiscall sub_4133D0(void *this);
int __thiscall sub_4134A0(_BYTE *this);
char __thiscall sub_413B40(int this);
int __thiscall sub_413C40(int this, int a2, int a3);
void __thiscall sub_413D20(_BYTE *this);
int __thiscall sub_413D30(int this);
_DWORD *__thiscall sub_413D50(_DWORD *this, char a2);
void __thiscall sub_413DA0(_DWORD *this);
char __thiscall sub_413EB0(char *this, int a2, int a3, int a4, char a5, char a6);
char __thiscall sub_414030(int *this, int *a2, int *a3, int a4, unsigned __int8 *a5, char a6, int a7, int a8, int a9);
int *__thiscall sub_414630(_DWORD *this, int *a2);
void __thiscall sub_4146A0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, const char *a7, int a8, int a9, char a10, char a11);
int __thiscall sub_4147E0(_DWORD **this, int a2, int a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
int *__thiscall sub_414880(_DWORD *this, unsigned __int8 *a2, unsigned int a3, int a4);
_WORD *__thiscall sub_414B30(_WORD *this);
int __thiscall sub_414BC0(int this);
int __thiscall sub_414C90(_DWORD *this);
int __cdecl sub_414CD0(int *a1, int *a2);
int __cdecl CompareFunction(const void *, const void *); // idb
int __cdecl sub_414D70(int *a1, int *a2);
int __stdcall sub_414E80(int a1);
void __thiscall sub_414E90(int this);
int __cdecl sub_414EC0(const void *, const void *); // idb
int __cdecl sub_414F60(const void *, const void *); // idb
_DWORD *__thiscall sub_414F80(_DWORD *this, int a2);
// void __usercall sub_415030(int a1@<ecx>, int a2@<ebp>);
_DWORD *__thiscall sub_415040(_DWORD *this);
int sub_415130(int a1, int a2, int a3, char *Format, ...);
char __thiscall sub_4151D0(_DWORD *this, _BYTE *a2, int a3, int a4, int a5, int a6);
_DWORD *__thiscall sub_415950(_DWORD *this);
char __thiscall sub_415A40(char *this, __int16 a2, __int16 a3, char a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8, char a9, __int16 a10);
int __thiscall sub_415F40(int this, int a2);
int __thiscall sub_415FE0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int nullsub_5(); // weak
unsigned int __thiscall sub_4163D0(_DWORD *this);
int __thiscall sub_416430(int this, int a2, int a3);
int __thiscall sub_4167C0(_DWORD *this);
int __thiscall sub_4167D0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, char a12, int a13, int a14, int a15);
int __thiscall sub_416CA0(int this, int a2, int a3);
_DWORD *__thiscall sub_416F60(_DWORD *this, int a2);
char __thiscall sub_416FC0(_DWORD *this, int a2, int *a3, int *a4, int *a5, char a6);
__int16 __thiscall sub_417610(char *this, unsigned __int16 a2, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9, int a10, int a11, int a12);
// int __userpurge start@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
int __thiscall sub_417A00(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9, int a10, int a11, int a12, int a13, char a14);
char __thiscall sub_417AA0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int *a8);
char __cdecl sub_417EB0(int a1, int a2, _BYTE *a3, char a4);
// unsigned int __usercall sub_417F70@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>);
int __thiscall sub_418060(int this, int a2, int a3, int a4);
_DWORD *__thiscall sub_418410(_DWORD *this);
char __thiscall sub_418420(int *this, _DWORD *a2);
_DWORD *__thiscall sub_418440(_DWORD *this, _DWORD *a2);
int __thiscall sub_418460(_DWORD *this);
char __thiscall sub_418470(char *this);
char *__thiscall sub_4185D0(char *this, char a2);
_BYTE *__thiscall sub_4185F0(_BYTE *this);
void __thiscall sub_418620(int this);
int __thiscall sub_418650(_BYTE *this);
int __thiscall sub_418670(_BYTE *this);
char *__thiscall sub_418690(char *this);
// unsigned int __userpurge sub_4186A0@<eax>(unsigned int a1@<ecx>, int a2@<ebp>, char a3);
// char __usercall sub_4187E0@<al>(int a1@<ecx>, int a2@<ebp>);
_DWORD *__thiscall sub_418C40(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11, int a12, int a13);
_DWORD *__thiscall sub_418CC0(_DWORD *this, int a2);
_DWORD *__thiscall sub_418D50(_DWORD *this, char a2);
int __thiscall sub_418D70(_DWORD *this);
int sub_418EA0();
int __stdcall sub_418ED0(int a1, int a2, int a3, int a4);
int __stdcall sub_418F00(int a1, int a2, int a3);
int __stdcall sub_418F50(int a1, int a2, __int16 a3, int a4);
int __stdcall sub_418FE0(int a1, int a2, __int16 a3, int a4);
int __cdecl sub_419040(int a1);
int __thiscall sub_419090(_DWORD); // weak
// int __userpurge sub_4190A0@<eax>(int a1@<ebx>, int a2, int a3, __int16 a4, int a5);
int __stdcall sub_4191E0(int a1, int a2, int a3, int a4);
int __stdcall sub_419200(int a1, int a2, char *a3, int a4);
_DWORD *__thiscall sub_4192D0(_DWORD *this, int a2, const char *a3, int a4, int a5);
char *__thiscall sub_419420(char *this, char a2);
char __fastcall sub_419450(int a1);
int __thiscall sub_4195D0(_DWORD *this, int a2);
// _DWORD *__usercall sub_419650@<eax>(int a1@<ebp>, const char *a2, int a3);
int sub_4197D0();
// char __usercall sub_419870@<al>(int a1@<ebp>, int a2, unsigned __int16 a3, int a4, int a5);
// int __usercall sub_419920@<eax>(int a1@<ebp>, _DWORD *a2, _WORD *a3, int a4, int a5);
_DWORD *__thiscall sub_4199D0(_DWORD *this);
int __fastcall sub_419BD0(int a1, int a2);
_DWORD sub_419C50(); // weak
_DWORD sub_419CE0(); // weak
_DWORD sub_419E60(); // weak
_DWORD sub_419E90(); // weak
// int __usercall sub_419EC0@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, int a3@<ebx>);
int sub_419F20(void); // weak
void __fastcall sub_419F50(int a1, int a2);
_DWORD sub_41A0F0(); // weak
_DWORD sub_41A160(); // weak
_DWORD sub_41A2D0(); // weak
void __thiscall sub_41A450(_DWORD *this);
_DWORD sub_41A4E0(); // weak
int __fastcall sub_41A5A9(int a1, int a2);
_DWORD sub_41A5C0(); // weak
void __fastcall sub_41A620(_DWORD *a1, unsigned __int8 a2);
_DWORD sub_41A890(); // weak
_DWORD sub_41A8C0(); // weak
int sub_41A999(); // weak
void __thiscall sub_41A9B0(_DWORD *this);
_DWORD sub_41AAC0(); // weak
_DWORD sub_41AAF0(); // weak
_DWORD sub_41AB20(); // weak
// int __usercall sub_41B19E@<eax>(int a1@<ebp>);
// int __usercall sub_41B9E4@<eax>(int a1@<ebp>);
// int __usercall sub_41C13D@<eax>(int a1@<ebp>);
// int __usercall sub_41C555@<eax>(int a1@<ebp>);
// int __usercall sub_41C96B@<eax>(int a1@<ebp>);
// int __usercall sub_41CD85@<eax>(int a1@<ebp>);
// int __usercall sub_41D6A7@<eax>(int a1@<ebp>);
// int __usercall sub_41E110@<eax>(int a1@<ebp>);
// int __usercall sub_41E6AB@<eax>(int a1@<ebp>);
// int __usercall sub_41F294@<eax>(int a1@<ebp>);
// int __usercall sub_41F8E2@<eax>(int a1@<ebp>);
// int __usercall sub_41FFB4@<eax>(int a1@<ebp>);
// int __usercall sub_42068C@<eax>(int a1@<ebp>);
// int __usercall sub_420D29@<eax>(int a1@<ebp>);
// int __usercall sub_4214FD@<eax>(int a1@<ebp>);
// int __usercall sub_421C6A@<eax>(int a1@<ebp>);
char *__thiscall sub_421C80(char *this, int a2);
int __cdecl sub_421E20(const void *, const void *); // idb
int __thiscall sub_421E80(_DWORD *this, int a2);
void __thiscall sub_421ED0(void *this);
void *__thiscall sub_421F80(void *this, char a2);
int __thiscall sub_421FD0(int *this);
int __thiscall sub_422000(_DWORD *this, int a2);
// int __usercall sub_422120@<eax>(unsigned int a1@<eax>, int a2@<ecx>);
_WORD *__thiscall sub_422570(_WORD *this, __int16 a2);
void __thiscall sub_422580(int this, char a2);
int __thiscall sub_422680(_DWORD *this, int a2, int a3);
void __stdcall sub_422950(int a1, int a2, int a3);
// _WORD *__userpurge sub_4229D1@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4@<edi>, int *a5@<esi>, int a6, int a7, int a8);
int __fastcall sub_423F90(int *a1, int a2);
int __thiscall sub_424200(_DWORD *this, int a2);
char __thiscall sub_424280(int this, _DWORD *a2);
int sub_424910(); // weak
int __thiscall sub_424930(_DWORD *this, int a2);
int __thiscall sub_424A60(_WORD *this, int a2);
char __thiscall sub_424AF0(int this, _DWORD *a2);
char __thiscall sub_424F10(_DWORD *this, unsigned int a2, unsigned __int8 *a3);
int __thiscall sub_4256D0(int *this, int a2);
char __thiscall sub_4257F0(_DWORD *this, char *String2);
char __thiscall sub_425840(_BYTE *this, int a2);
int __thiscall sub_4258A0(_DWORD *this);
int __thiscall sub_425E50(int this, int a2);
_DWORD *__thiscall sub_425ED0(char *this);
char __fastcall sub_426120(char *Str);
void *__thiscall sub_4268F0(void *this, char a2);
int __thiscall sub_426910(int this);
_DWORD *__thiscall sub_426A50(_DWORD *this);
int __thiscall sub_426A90(_DWORD *this, int a2);
int __thiscall sub_426AF0(int *this);
int __thiscall sub_426B20(_DWORD *this);
char __thiscall sub_426BA0(int this, char a2);
int __thiscall sub_4273C0(_DWORD *this);
int __thiscall sub_427420(int this);
int __thiscall sub_427BD0(int this, char *a2, int a3, int a4);
int __thiscall sub_427CF0(int (__thiscall ***this)(void *, _DWORD), unsigned int a2);
int __thiscall sub_427FA0(_DWORD *this);
int __thiscall sub_428020(_DWORD *this);
int __thiscall sub_428690(_DWORD *this, int a2);
int __thiscall sub_428860(_DWORD *this);
int __thiscall sub_428910(char *this, void *src, char *Str, char a4);
int __stdcall sub_428CF0(int a1);
int __thiscall sub_428F60(_DWORD *this, int a2);
int *__thiscall sub_428FA0(_DWORD *this, int a2, int a3);
char __thiscall sub_429000(int this, int *a2);
int __thiscall sub_4292F0(_DWORD *this);
int __thiscall sub_429340(char *this, _BYTE *a2);
int __thiscall sub_4293A0(int this, _DWORD *a2);
bool __thiscall sub_4296E0(int this);
int __thiscall sub_429C40(_DWORD *this);
int nullsub_7(); // weak
int __thiscall sub_429D20(int *this, _DWORD *a2, char *Format);
int __thiscall sub_42A180(_BYTE *this, int a2);
int __thiscall sub_42A5A0(_DWORD *this);
int __thiscall sub_42A5B0(_DWORD *this, _DWORD *a2, int a3, int a4);
int __thiscall sub_42A6C0(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_42A790(_DWORD *this);
int __thiscall sub_42A9A0(_DWORD *this, int a2, int a3, unsigned int a4);
int __thiscall sub_42AF60(_DWORD *this, int a2);
int sub_42B000(); // weak
unsigned int __thiscall sub_42B020(_DWORD *this, unsigned int a2, int a3, int a4);
// unsigned int __userpurge sub_42B760@<eax>(_BYTE *a1@<ebx>, int a2@<ebp>, int a3, int a4, int a5);
bool __thiscall sub_42BA70(_DWORD *this);
int __thiscall sub_42BAD0(_DWORD *this, int a2, int a3, int a4);
// void __usercall sub_42BB87(int a1@<edx>, char a2@<cl>, int a3@<esi>);
int __thiscall sub_42BB90(_DWORD *this, int a2);
int __thiscall sub_42BBD0(int *this);
// void __usercall sub_42BD80(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_42BD90(_DWORD *this, int *a2, int a3, int a4, char a5, char a6);
int __thiscall sub_42BED0(_DWORD *this, char *a2, int a3, int a4);
BOOL __thiscall sub_42C050(_DWORD *this);
void __thiscall sub_42C0A0(_DWORD *this, int a2);
// int __userpurge sub_42C1A0@<eax>(int *a1@<ecx>, int a2@<ebx>, int a3, int a4);
int __thiscall sub_42C310(char *this);
char __thiscall sub_42C690(int this, int *a2);
int __thiscall sub_42D030(int this);
int __thiscall sub_42D0B0(_DWORD *this);
int __thiscall sub_42D0D0(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_42E180(_DWORD *this, int a2);
_DWORD *__thiscall sub_42E450(_DWORD *this, _DWORD *a2);
int *__thiscall sub_42E490(int *this, _DWORD *a2);
int __thiscall sub_42E6F0(_DWORD *this);
void __thiscall sub_42E7F0(int this, int a2, int a3, int a4, int a5, int a6);
void __thiscall sub_42E920(int *this);
int __thiscall sub_42EAD0(_DWORD *this, int a2, int a3);
char __thiscall sub_42EBF0(_DWORD *this, int a2, int a3);
int __thiscall sub_42EE90(_DWORD *this, int a2, int a3);
void __thiscall sub_42EF10(_DWORD *this, int a2, int a3);
void __thiscall sub_42F0C0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7);
void __thiscall sub_42F140(int this, int a2, int a3);
int __thiscall sub_42F3E0(int this, int a2, int a3);
int __thiscall sub_42F470(char *this, char a2, int a3);
_DWORD *__thiscall sub_42F4C0(_DWORD *this, _DWORD *a2);
int __thiscall sub_42F730(_DWORD *this);
char __thiscall sub_42F7B0(char *this);
bool __thiscall sub_42F9F0(_DWORD *this, int a2);
char __thiscall sub_42FAB0(char *this, int a2, char a3, char a4, char a5);
int __thiscall sub_4311E0(char *this, void *a2, int a3, char a4);
int __thiscall sub_4312D0(int this);
int __thiscall sub_4313D0(_DWORD *this, int a2);
unsigned int __stdcall sub_4316A0(int a1, int a2, int a3, _DWORD *a4);
int sub_431700();
int __thiscall sub_431830(_DWORD *this, unsigned int a2);
int __thiscall sub_431940(char *this, int a2, int a3);
int __thiscall sub_432030(_DWORD *this);
int nullsub_8(); // weak
char __thiscall sub_432050(int this, _DWORD *a2);
int sub_432100(); // weak
int __thiscall sub_432120(char *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6, __int16 a7);
int __thiscall sub_432840(char *this);
void __thiscall sub_4328F0(_DWORD *this, int a2);
int __thiscall sub_4329E0(_BYTE *this, int a2);
int __stdcall sub_432CF0(int a1);
int __thiscall sub_432DF0(_DWORD *this, int a2);
int __thiscall sub_432E80(_DWORD *this);
void __thiscall sub_432F80(_DWORD *this, int a2);
_DWORD *__thiscall sub_433270(_DWORD *this, int a2);
void __thiscall sub_433290(_DWORD *this);
int __thiscall sub_4335F0(_DWORD *this, char *Buffer, int a3, int a4);
void __thiscall sub_433A70(unsigned int *this, int a2);
void __thiscall sub_433BA0(int this, char a2);
int __thiscall sub_433C00(int *this);
char __thiscall sub_433C70(int *this, int a2, char a3);
int __thiscall sub_4343D0(char *this, __int16 a2);
int __thiscall sub_4344F0(_DWORD *this, int a2, int a3);
int __thiscall sub_434540(char *this, void *a2, char a3, __int16 a4, char a5);
int __thiscall sub_4345D0(_DWORD *this, int a2);
int __fastcall sub_434670(int *a1, unsigned int a2);
int __thiscall sub_435330(int *this, int a2);
int sub_435430(); // weak
int sub_435450();
// char __userpurge sub_4354F0@<al>(int *a1@<ecx>, int a2@<ebp>, char *a3);
BOOL __thiscall sub_4355D0(_DWORD *this);
int __thiscall sub_435600(_DWORD *this, int a2);
int __fastcall sub_435640(int a1, int a2, int a3);
int __thiscall sub_435680(char *this, int a2);
int __thiscall sub_435750(_DWORD *this, int a2, int a3, int a4);
char __thiscall sub_435AC0(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_435D90(void (__thiscall ***this)(void *, _DWORD));
BOOL __thiscall sub_436440(_BYTE *this, int a2);
int __thiscall sub_436610(char *this, int *a2, int a3);
char __thiscall sub_4366D0(int this);
int __thiscall sub_4367D0(_DWORD *this, _DWORD *a2);
unsigned int __thiscall sub_4368C0(_DWORD *this, const char *a2);
unsigned int __thiscall sub_4368E0(unsigned int *this, unsigned int a2, int *a3, unsigned int a4);
// unsigned int __userpurge sub_436A20@<eax>(int a1@<ecx>, int a2@<ebp>, _BYTE *a3, int a4, int a5);
int __thiscall sub_436A70(_BYTE *this, _DWORD *a2);
int __thiscall sub_436C50(int *this, _BYTE *a2);
int __thiscall sub_436E60(char *this, void *a2, int a3);
void __thiscall sub_436FB0(_DWORD *this, int a2, int a3, int a4, int a5);
void __thiscall sub_437160(int this);
int __thiscall sub_437370(int this, int a2, int a3, int a4, int a5, char a6, int a7);
int __thiscall sub_437670(_DWORD *this);
char __thiscall sub_437870(_DWORD *this, char *a2);
int __thiscall sub_437C10(_DWORD *this);
char __thiscall sub_437CB0(int this);
char __thiscall sub_437D00(char *this, int a2);
void __thiscall sub_438570(_DWORD *this, _BYTE *a2, int a3);
int __thiscall sub_438890(int this, int a2);
void __thiscall sub_438950(int this);
unsigned int __thiscall sub_439260(char *this, void *a2);
int __thiscall sub_439340(_DWORD *this, char a2);
int __thiscall sub_4393E0(_DWORD *this);
int __thiscall sub_4394A0(const char *this, _BYTE *a2, int a3, int a4);
char __thiscall sub_439570(char *this, _DWORD *a2);
int sub_439A30();
unsigned __int8 __thiscall sub_439F30(int this, _BYTE *a2, _BYTE *a3);
unsigned int __thiscall sub_439FF0(unsigned int *this, int a2, unsigned int a3);
char __thiscall sub_43A140(_DWORD *this, char *Buf2, void *a3);
int __thiscall sub_43A1D0(_DWORD *this, int a2);
int __thiscall sub_43A250(_DWORD *this, _DWORD *a2, __int16 a3, int a4);
int sub_43A500(); // weak
unsigned int __thiscall sub_43A520(_DWORD *this, int a2);
void __thiscall sub_43A5E0(_DWORD **this, int a2);
int __thiscall sub_43A780(_DWORD *this, int a2);
void __thiscall sub_43A830(_DWORD *this, int a2);
int __thiscall sub_43A910(char *this, char a2);
char __thiscall sub_43A950(_DWORD *this, int a2);
int __thiscall sub_43AA00(_DWORD *this);
int __thiscall sub_43AB40(_DWORD *this, int a2, int a3, int a4, int a5, int a6, char a7, int a8, int a9);
__int16 __thiscall sub_43AE70(int this);
int __thiscall sub_43B120(_DWORD *this, int a2, int a3);
char __thiscall sub_43B8F0(char *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __thiscall sub_43B980(_DWORD *this);
char __thiscall sub_43B9B0(_DWORD *this);
int __thiscall sub_43BAD0(void *this, int a2, int a3);
int __thiscall sub_43BB80(int this);
char __thiscall sub_43BCF0(_DWORD *this, char *String2);
int __thiscall sub_43BDB0(char *this, __int16 a2, __int16 a3);
char __thiscall sub_43BE10(_DWORD *this, int a2, int a3, int a4);
bool __thiscall sub_43C5D0(_DWORD *this, _DWORD *a2, int a3);
int nullsub_9(); // weak
int __thiscall sub_43C790(_DWORD *this, int a2, int a3);
int __fastcall sub_43C7E0(int a1, _BYTE *a2, int a3);
int __thiscall sub_43C920(int this, int a2, int a3);
void __thiscall sub_43CB60(_DWORD *this, int a2, int a3, int a4, int a5);
int __stdcall sub_43CB90(_BYTE *a1);
int __thiscall sub_43CC40(_DWORD *this, int a2);
int sub_43D3A0(); // weak
int __thiscall sub_43D540(_DWORD *this, _BYTE *a2, int a3);
unsigned int __thiscall sub_43D610(int *this, _BYTE *a2, signed int a3, char a4);
int __thiscall sub_43D680(_DWORD *this, int a2);
int __thiscall sub_43D750(void *this, unsigned int a2);
void __thiscall sub_43DA10(_DWORD *this, unsigned __int8 *a2, int a3, int a4);
// int __userpurge sub_43DA70@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4, int a5, _DWORD *a6);
int __thiscall sub_43DC80(int *this, unsigned int a2, unsigned int a3, int a4);
int sub_43E460(); // weak
void __fastcall sub_43E490(int a1, _BYTE *a2);
int __thiscall sub_43E580(_DWORD *this, char *a2, int a3, int a4);
int __thiscall sub_43E620(_DWORD *this, _DWORD *a2);
int __thiscall sub_43E6A0(_DWORD *this);
int __thiscall sub_43E7F0(char *this);
void __thiscall sub_43E850(char *this);
bool __thiscall sub_43EBD0(_DWORD *this);
char __thiscall sub_43ECA0(int this, _DWORD *a2);
int __thiscall sub_43ED80(_DWORD *this, int a2);
int sub_43EE60(); // weak
void __thiscall sub_43EE80(int this, char a2);
int __thiscall sub_43F130(_DWORD *this, int a2, int a3);
int __thiscall sub_43F9C0(_DWORD *this);
int __thiscall sub_43FB00(int this, int a2);
int __thiscall sub_440150(_DWORD *this, char a2);
unsigned int __thiscall sub_4401E0(_DWORD *this);
int __thiscall sub_440260(_DWORD *this, int a2);
// BOOL __usercall sub_440440@<eax>(int a1@<ebx>);
int __thiscall sub_440530(int this, int a2);
int __thiscall sub_4405D0(_DWORD *this, int a2);
int __thiscall sub_440680(char *this, __int16 a2);
void __thiscall sub_4406E0(_DWORD *this, int a2, int a3, int a4, int a5);
int __thiscall sub_440740(_DWORD *this, _DWORD *a2, int a3, int a4);
void __thiscall __noreturn sub_440910(char *this);
void __thiscall sub_441120(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_441270(_DWORD *this);
int __thiscall sub_4413D0(_DWORD *this, char a2);
int __thiscall sub_441550(_DWORD *this, int a2, int a3);
int __thiscall sub_4416C0(_DWORD *this, int a2, int a3);
void __thiscall sub_441740(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_441840(int this);
int __thiscall sub_4419A0(_DWORD *this, _DWORD *a2, int a3, int a4, int a5);
int __thiscall sub_441AE0(int *this, int a2);
int __thiscall sub_441B30(int this, int a2);
char __thiscall sub_441BC0(int *this, unsigned int a2);
void __thiscall sub_441D00(_DWORD *this, int a2, int a3, char a4);
_DWORD *__thiscall sub_441E20(_DWORD *this, int a2, int a3);
int __thiscall sub_441F60(_DWORD *this, int a2);
char __thiscall sub_442040(_DWORD *this);
int __thiscall sub_442120(int this, _DWORD *a2);
int __thiscall sub_4424E0(_DWORD *this, int a2);
char __thiscall sub_442590(_DWORD *this, char *a2, unsigned int a3);
unsigned int __thiscall sub_442900(_DWORD *this, char a2);
int __thiscall sub_442930(_DWORD *this);
int __thiscall sub_4429C0(_DWORD *this, char a2);
int __thiscall sub_442AD0(void *this, _BYTE *a2, char a3);
int sub_442CF0(); // weak
int __thiscall sub_442D10(int this);
void __thiscall sub_442EB0(int this);
int __thiscall sub_442ED0(_DWORD *this, int a2, unsigned int a3);
int __thiscall sub_442F90(_DWORD *this, char *Buffer, int a3, int a4);
unsigned __int8 __thiscall sub_442FE0(_DWORD *this, int a2, int a3, const char *a4, int a5, int a6, char a7);
unsigned int __thiscall sub_4431A0(unsigned int *this, char *a2, unsigned __int8 *a3, unsigned int a4);
int __thiscall sub_443290(int this);
// int __usercall sub_443490@<eax>(int a1@<ecx>, int a2@<edi>);
// _DWORD *__userpurge sub_4435D0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, void *a4, int a5, int a6, int a7);
int __thiscall sub_443670(int this, void *a2);
void __thiscall sub_443A10(_DWORD *this, int a2, unsigned __int8 *a3, unsigned __int8 *a4);
int __thiscall sub_443B50(_DWORD *this);
int __thiscall sub_443C30(_DWORD *this, int a2);
int __thiscall sub_443CE0(void *this, _BYTE *a2, int a3);
int __thiscall sub_443D00(_DWORD *this, _DWORD *a2);
int __thiscall sub_443DD0(int *this);
int __stdcall sub_443FA7(int, int); // weak
int __thiscall sub_4444C0(_DWORD *this);
int __thiscall sub_4446B0(int *this, __int16 *a2, int a3);
int __thiscall sub_444890(int this);
// int __userpurge sub_4448B0@<eax>(int *a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, const char *a6);
void __thiscall sub_444BD0(_DWORD *this, int a2, int a3, int a4, char a5);
int __thiscall sub_4451E0(int this, int a2, int a3);
char __thiscall sub_445310(_DWORD *this);
_DWORD *__thiscall sub_445560(int this, _DWORD *a2);
int __thiscall sub_4455F0(int this, int a2, int a3);
int sub_445900(); // weak
int __thiscall sub_445920(_DWORD *this, __int16 a2, int a3);
unsigned int sub_4459B0();
char __thiscall sub_445B60(_DWORD *this, int a2, int a3);
int sub_445D10(); // weak
void __thiscall sub_445D70(_DWORD *this, unsigned int a2);
int __thiscall sub_445DF0(_DWORD *this);
// char __userpurge sub_445E20@<al>(__int64 a1@<edx:eax>, int *a2@<ecx>, int a3);
int __thiscall sub_4462D0(int this);
int __thiscall sub_446B30(_DWORD *this, int a2, unsigned __int8 a3);
int __thiscall sub_447860(_DWORD *this, char a2, int a3);
int __thiscall sub_447900(char *this, char a2, char *a3);
int __thiscall sub_4479B0(_DWORD *this, int a2, int a3);
int __thiscall sub_447A60(_DWORD *this, _BYTE *a2, int a3, int a4);
int __thiscall sub_447AE0(_DWORD *this, int a2, int a3);
char __thiscall sub_447BC0(_BYTE *this);
int __thiscall sub_447C00(_DWORD *this, char a2, char a3);
int __thiscall sub_447D20(_DWORD *this);
_BYTE *__thiscall sub_447E30(_BYTE *this, char a2);
int __thiscall sub_447E40(int this);
int __thiscall sub_447E60(unsigned __int16 *this);
void __thiscall sub_447E70(int this, int a2, int a3, char a4);
int __thiscall sub_447EE0(_DWORD *this, int a2);
int __thiscall sub_447F80(char *this, __int16 a2);
bool __thiscall sub_447FD0(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_448040(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_4481D0(_DWORD *this, int a2, int a3);
void __thiscall sub_4482E0(char *this, _BYTE *Buf1, _DWORD *a3, int a4);
_DWORD *__thiscall sub_449C80(int this, int a2);
int __stdcall sub_44A1C4(int, int); // weak
int __thiscall sub_44A360(_DWORD *this, int a2);
void __thiscall sub_44A3D0(int this, int a2, int a3);
int __thiscall sub_44A510(int this);
int __thiscall sub_44A530(int this);
// int __userpurge sub_44A540@<eax>(int *a1@<ecx>, int a2@<ebp>, void *a3, int a4);
int __thiscall sub_44B3A0(_DWORD *this, int a2, int a3);
bool __thiscall sub_44B530(int this, int a2);
void __thiscall sub_44BB30(char *this, int a2, char a3, int a4);
int __thiscall sub_44BC40(int this);
int __thiscall sub_44BCA0(_DWORD *this);
char __thiscall sub_44BD10(_DWORD *this, int a2, unsigned __int8 *a3, int a4);
char __thiscall sub_44BEB0(char *this);
int sub_44BFD0(); // weak
int __thiscall sub_44BFF0(_DWORD *this, int a2, int a3);
int __thiscall sub_44C0A0(int this, char **a2, int a3);
int __thiscall sub_44C3C0(_DWORD *this, int a2, int a3);
char __thiscall sub_44C8D0(char *this, unsigned int a2);
unsigned int __thiscall sub_44C970(_DWORD *this);
int __thiscall sub_44D8A0(char *this, __int16 a2, __int16 a3);
int __thiscall sub_44D900(int *this, int a2, int a3, int a4);
int __stdcall sub_44DA30(int a1, int a2, int a3);
_DWORD *__thiscall sub_44DA70(_DWORD *this);
int __stdcall sub_44DAC0(int a1);
unsigned int __thiscall sub_44EC40(_DWORD *this, int a2, unsigned int a3);
int __thiscall sub_44ED70(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6);
int __stdcall sub_44F4D4(int); // weak
int __stdcall sub_44F508(int); // weak
_DWORD __stdcall sub_44FB80(_DWORD); // weak
int __thiscall sub_44FBA0(char *this, __int16 a2, __int16 a3, __int16 a4);
int __thiscall sub_44FC30(void **this);
char __thiscall sub_44FEF0(void *this, char a2);
int __thiscall sub_44FFD0(char *this, char a2, __int16 a3, __int16 a4);
char __thiscall sub_450030(int this, _DWORD *a2, int a3, int a4, int a5, int a6);
int __thiscall sub_450080(_DWORD *this, int *a2, unsigned __int8 a3, _DWORD *a4);
int __thiscall sub_450700(_DWORD *this, int a2);
int __thiscall sub_4508D0(int this, int a2, int a3);
int __thiscall sub_450AF0(_DWORD *this, int *a2);
int __thiscall sub_4516F0(_DWORD *this, int a2, int a3, int a4, int a5);
char __thiscall sub_4518A0(_DWORD *this);
int __thiscall sub_451B40(_DWORD *this, int a2, int a3);
void __thiscall sub_452010(int this, _DWORD *a2);
int __thiscall sub_4520E0(int this, int a2);
int sub_4522D0();
BOOL __thiscall sub_452350(_DWORD *this, int a2);
void __thiscall sub_4523A0(void **this, _BYTE *a2, signed int a3, char a4);
char __thiscall sub_4525C0(_DWORD *this, int a2, int a3, unsigned __int8 *a4);
int __thiscall sub_452700(void *this, int *a2, int a3);
char __thiscall sub_452740(int this, int a2);
int __thiscall sub_452B10(_DWORD *this, char *Format);
// int __userpurge sub_453560@<eax>(int a1@<ecx>, int a2@<ebx>, int a3);
char __thiscall sub_453750(_DWORD *this, int a2, int a3);
char __thiscall sub_4538F0(int this, _DWORD *a2);
int __thiscall sub_453D60(_DWORD *this);
int __thiscall sub_453E10(_DWORD *this);
int __thiscall sub_454100(_DWORD *this);
int __thiscall sub_454360(int this);
int __thiscall sub_454390(_DWORD *this, int a2);
bool __thiscall sub_454430(_DWORD *this, char a2);
int __thiscall sub_454BE0(int *this, int a2, int a3, char a4);
int __thiscall sub_454C30(_DWORD *this, unsigned int a2);
BOOL __thiscall sub_454CB0(_DWORD *this);
int __thiscall sub_454CD0(_DWORD *this);
_DWORD *__thiscall sub_454CE0(_DWORD *this, int *a2);
void __thiscall CVecCtrlMob::MoveContext::FlyContext::FlyContext(CVecCtrlMob::MoveContext::FlyContext *this, SECPOINT *e, TSecType<int> *d, TSecType<long> *a, TSecType<long> *c);
void __thiscall sub_454F80(_DWORD *this, unsigned int a2);
int __thiscall sub_455080(_DWORD *this);
int __thiscall sub_455180(unsigned int *this);
int __fastcall sub_455280(_DWORD *a1, int a2);
int __fastcall sub_4552A0(_DWORD *a1, int a2);
__int64 __fastcall sub_4552B0(_DWORD *a1, _DWORD *a2);
// int __userpurge sub_4552D0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
int __thiscall sub_455390(int this);
int __thiscall sub_4553B0(int this);
int __thiscall sub_4553D0(int this);
int __thiscall sub_4553F0(int this);
int __thiscall sub_455410(int this);
int __thiscall sub_455430(int this);
// void __usercall sub_455450(int a1@<ecx>, int a2@<ebp>);
int __thiscall sub_455490(int this);
// void __usercall sub_4554B0(int a1@<ecx>, int a2@<ebp>);
// int __userpurge sub_4554C0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
// int __userpurge sub_455580@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
// int __userpurge sub_455620@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
unsigned int __thiscall sub_4556D0(int this, const void *a2, int a3, int a4, _DWORD *a5);
unsigned int __thiscall sub_4557C0(int this, const void *a2, int a3, int a4, _DWORD *a5);
int __thiscall sub_4558A0(_DWORD *this);
int __thiscall sub_4558C0(_DWORD *this);
int __thiscall sub_4558E0(_DWORD *this);
int __thiscall sub_455910(unsigned __int8 *this);
int __fastcall sub_455940(int a1, unsigned int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_457D50(_DWORD *this, int a2);
// _DWORD *__userpurge sub_457D60@<eax>(void **a1@<ecx>, int a2@<ebx>, unsigned int a3);
int __thiscall sub_458BE0(_DWORD *this, int a2);
char __thiscall ContinuumEncrypt(unsigned int *this, char *a2, _DWORD *a3, unsigned int a4);
unsigned int __thiscall ContinuumDecrypt(unsigned int *this, int *a2, int *a3, unsigned int a4);
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2);
int __stdcall sub_4599A8(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_4599AE(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall sub_459A2C(_DWORD, _DWORD); // weak
int __stdcall sub_459A50(_DWORD, _DWORD, _DWORD); // weak
CxFile *__thiscall CxFile::CxFile(CxFile *__hidden this); // idb
void __thiscall CxFile::~CxFile(CxFile *__hidden this); // idb
CxFile *__thiscall CxFile::CxFile(CxFile *__hidden this, const struct CxFile *); // idb
void *__thiscall CxFile::operator=(void *this, int a2);
char *__thiscall sub_459AB0(char *this, char a2);
CxMemFile *__thiscall CxMemFile::CxMemFile(CxMemFile *this, unsigned __int8 *a2, unsigned int a3);
bool __thiscall CxMemFile::Open(CxMemFile *__hidden this); // idb
unsigned __int8 *__thiscall CxMemFile::GetBuffer(CxMemFile *__hidden this); // idb
CxMemFile *__thiscall CxMemFile::CxMemFile(CxMemFile *__hidden this, const struct CxMemFile *); // idb
int __thiscall CxMemFile::operator=(int this, int a2);
void __thiscall CxMemFile::`default constructor closure'(CxMemFile *__hidden this); // idb
CxMemFile *__thiscall sub_459C10(CxMemFile *this, char a2);
unsigned int __thiscall CxMemFile::Read(CxMemFile *__hidden this, void *, unsigned int, unsigned int); // idb
unsigned int __thiscall CxMemFile::Write(CxMemFile *__hidden this, const void *, unsigned int, unsigned int); // idb
char __thiscall CxMemFile::Seek(CxMemFile *this, int a2, int a3);
int __thiscall CxMemFile::Tell(CxMemFile *__hidden this); // idb
int __thiscall CxMemFile::Size(CxMemFile *__hidden this); // idb
bool __thiscall CxMemFile::Flush(CxMemFile *__hidden this); // idb
bool __thiscall CxMemFile::Eof(CxMemFile *__hidden this); // idb
int __thiscall CxMemFile::Error(CxMemFile *__hidden this); // idb
char __thiscall CxMemFile::PutC(CxMemFile *this, unsigned __int8 a2);
int __thiscall CxMemFile::GetC(CxMemFile *__hidden this); // idb
void __thiscall CxMemFile::Alloc(CxMemFile *__hidden this, unsigned int); // idb
void __thiscall CxMemFile::Free(CxMemFile *__hidden this); // idb
CxIOFile *__thiscall CxIOFile::CxIOFile(CxIOFile *this, struct _iobuf *a2);
void __thiscall CxIOFile::~CxIOFile(CxIOFile *__hidden this); // idb
bool __thiscall CxIOFile::Open(CxIOFile *__hidden this, const char *, const char *); // idb
bool __thiscall CxIOFile::Close(CxIOFile *__hidden this); // idb
FILE *__thiscall CxIOFile::Read(CxIOFile *this, void *a2, unsigned int a3, unsigned int a4);
FILE *__thiscall CxIOFile::Write(CxIOFile *this, const void *a2, unsigned int a3, unsigned int a4);
bool __thiscall CxIOFile::Seek(CxIOFile *__hidden this, int, int); // idb
int __thiscall CxIOFile::Tell(CxIOFile *__hidden this); // idb
int __thiscall CxIOFile::Size(CxIOFile *__hidden this); // idb
bool __thiscall CxIOFile::Flush(CxIOFile *__hidden this); // idb
int __thiscall CxIOFile::Eof(CxIOFile *this);
int __thiscall CxIOFile::Error(CxIOFile *__hidden this); // idb
bool __thiscall CxIOFile::PutC(CxIOFile *__hidden this, unsigned __int8); // idb
int __thiscall CxIOFile::GetC(CxIOFile *__hidden this); // idb
CxIOFile *__thiscall CxIOFile::CxIOFile(CxIOFile *__hidden this, const struct CxIOFile *); // idb
int __thiscall CxIOFile::operator=(int this, int a2);
void __thiscall CxIOFile::`default constructor closure'(CxIOFile *__hidden this); // idb
CxIOFile *__thiscall sub_45A250(CxIOFile *this, char a2);
void *__thiscall CxImage::GetDIB(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetHeight(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetWidth(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetEffWidth(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetNumColors(CxImage *__hidden this); // idb
unsigned __int16 __thiscall CxImage::GetBpp(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetType(CxImage *__hidden this); // idb
char *__thiscall CxImage::GetLastError(CxImage *__hidden this); // idb
unsigned int __thiscall CxImage::GetFrameDelay(CxImage *__hidden this); // idb
void __thiscall CxImage::SetFrameDelay(CxImage *__hidden this, unsigned int); // idb
void __thiscall CxImage::GetOffset(CxImage *__hidden this, int *, int *); // idb
void __thiscall CxImage::SetOffset(CxImage *__hidden this, int, int); // idb
unsigned __int8 __thiscall CxImage::GetJpegQuality(CxImage *__hidden this); // idb
void __thiscall CxImage::SetJpegQuality(CxImage *__hidden this, unsigned __int8); // idb
int __thiscall CxImage::GetXDPI(CxImage *__hidden this); // idb
int __thiscall CxImage::GetYDPI(CxImage *__hidden this); // idb
int __thiscall CxImage::GetProgress(CxImage *__hidden this); // idb
int __thiscall CxImage::GetEscape(CxImage *__hidden this); // idb
void __thiscall CxImage::SetProgress(CxImage *__hidden this, int); // idb
void __thiscall CxImage::SetEscape(CxImage *__hidden this, int); // idb
int __thiscall CxImage::GetTransIndex(CxImage *__hidden this); // idb
void __thiscall CxImage::SetTransIndex(CxImage *__hidden this, int); // idb
void __thiscall CxImage::SetTransColor(CxImage *__hidden this, struct tagRGBQUAD); // idb
BOOL __thiscall CxImage::IsTransparent(CxImage *this);
unsigned int __thiscall CxImage::GetEncodeOption(CxImage *__hidden this); // idb
void __thiscall CxImage::SetEncodeOption(CxImage *__hidden this, unsigned int); // idb
BOOL __thiscall CxImage::IsIndexed(CxImage *this);
BOOL __thiscall CxImage::IsValid(CxImage *this);
bool __thiscall CxImage::IsEnabled(CxImage *__hidden this); // idb
void __thiscall CxImage::Enable(CxImage *__hidden this, bool); // idb
int __thiscall CxImage::GetNumFrames(CxImage *__hidden this); // idb
int __thiscall CxImage::GetFrame(CxImage *__hidden this); // idb
void __thiscall CxImage::SetFrame(CxImage *__hidden this, int); // idb
void __thiscall CxImage::`default constructor closure'(CxImage *__hidden this); // idb
void __thiscall CxImage::`copy constructor closure'(CxImage *__hidden this, const struct CxImage *); // idb
void __thiscall CxImage::Startup(CxImage *__hidden this, unsigned int); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, unsigned int); // idb
unsigned int __thiscall sub_45A820(unsigned int this, char a2);
void __thiscall CxImage::~CxImage(CxImage *__hidden this); // idb
void __thiscall CxImage::Destroy(CxImage *__hidden this); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, unsigned int, unsigned int, int, int); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, const struct CxImage *, bool, bool, bool); // idb
void __thiscall CxImage::Copy(CxImage *__hidden this, const struct CxImage *, bool, bool, bool); // idb
void __thiscall CxImage::CopyInfo(CxImage *__hidden this, const struct CxImage *); // idb
CxImage *__thiscall CxImage::operator=(CxImage *this, struct CxImage *a2);
void *__thiscall CxImage::Create(CxImage *__hidden this, unsigned int, unsigned int, int, int); // idb
unsigned __int8 *__thiscall CxImage::GetBits(CxImage *__hidden this); // idb
int __thiscall CxImage::GetSize(CxImage *__hidden this); // idb
BOOL __thiscall CxImage::IsInside(CxImage *this, int a2, int a3);
// void __userpurge CxImage::Clear(CxImage *this@<ecx>, int a2@<ebx>, unsigned __int8 a3);
void __thiscall CxImage::Transfer(CxImage *__hidden this, struct CxImage *); // idb
void __thiscall CxImage::Ghost(CxImage *__hidden this, struct CxImage *); // idb
void __thiscall CxImage::Bitfield2RGB(CxImage *__hidden this, unsigned __int8 *, unsigned __int16, unsigned __int16, unsigned __int16, unsigned __int8); // idb
bool __thiscall CxImage::CreateFromARGB(CxImage *__hidden this, unsigned int, unsigned int, unsigned __int8 *); // idb
int __cdecl CxImage::CompareColors(const void *, const void *); // idb
struct tagRGBQUAD __thiscall CxImage::GetTransColor(CxImage *this, _DWORD *a2);
// int __usercall CxImage::GetColorType@<eax>(CxImage *this@<ecx>, int a2@<eax>);
void __thiscall CxImage::SetXDPI(CxImage *__hidden this, int); // idb
void __thiscall CxImage::SetYDPI(CxImage *__hidden this, int); // idb
char *__thiscall CxImage::GetVersion(CxImage *this);
int __thiscall CxImage::GetPaletteSize(CxImage *this);
void __thiscall CxImage::SetPaletteIndex(CxImage *__hidden this, unsigned __int8, char, char, char, unsigned __int8); // idb
void __thiscall CxImage::SetPaletteIndex(CxImage *__hidden this, unsigned __int8, struct tagRGBQUAD); // idb
void __thiscall CxImage::SetPaletteIndex(CxImage *__hidden this, unsigned __int8, unsigned int); // idb
struct tagRGBQUAD *__thiscall CxImage::GetPalette(CxImage *__hidden this); // idb
struct tagRGBQUAD __thiscall CxImage::GetPaletteColor(CxImage *this, _DWORD *a2, unsigned __int8 a3);
unsigned __int8 __thiscall CxImage::GetPixelIndex(CxImage *__hidden this, int, int); // idb
struct tagRGBQUAD __thiscall CxImage::GetPixelColor(CxImage *this, int a2, int a3, int a4);
int __thiscall CxImage::GetPixelGray(CxImage *this, int a2, int a3);
void __thiscall CxImage::SetPixelIndex(CxImage *__hidden this, int, int, unsigned __int8); // idb
void __thiscall CxImage::SetPixelColor(CxImage *__hidden this, int, int, struct tagRGBQUAD); // idb
void __thiscall CxImage::SetPixelColor(CxImage *__hidden this, int, int, struct tagRGBQUAD, bool); // idb
char __thiscall CxImage::GetNearestIndex(CxImage *this, struct tagRGBQUAD a2);
void __thiscall CxImage::RGBtoBGR(CxImage *__hidden this, unsigned __int8 *, int); // idb
struct tagRGBQUAD __thiscall CxImage::RGBtoRGBQUAD(CxImage *this, unsigned int a2, int a3);
int __thiscall CxImage::RGBQUADtoRGB(CxImage *this, struct tagRGBQUAD a2);
char __thiscall CxImage::GetRGB(CxImage *this, int a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5);
void __thiscall CxImage::SetPalette(CxImage *__hidden this, unsigned int, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *); // idb
void __thiscall CxImage::SetPalette(CxImage *__hidden this, struct rgb_color *, unsigned int); // idb
void __thiscall CxImage::SetPalette(CxImage *__hidden this, struct tagRGBQUAD *, unsigned int); // idb
void __thiscall CxImage::SetGrayPalette(CxImage *__hidden this); // idb
void __thiscall CxImage::BlendPalette(CxImage *__hidden this, unsigned int, int); // idb
char __thiscall CxImage::IsGrayScale(CxImage *this);
void __thiscall CxImage::SwapIndex(CxImage *__hidden this, unsigned __int8, unsigned __int8); // idb
void __thiscall CxImage::SetStdPalette(CxImage *__hidden this); // idb
CxImageGIF *__thiscall CxImageGIF::CxImageGIF(CxImageGIF *__hidden this); // idb
char __thiscall CxImageGIF::Decode(CxImageGIF *this, struct _iobuf *a2);
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct _iobuf *a2);
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct _iobuf *a2, struct CxImage **a3, int a4, bool a5);
CxImageGIF *__thiscall CxImageGIF::CxImageGIF(CxImageGIF *__hidden this, const struct CxImageGIF *); // idb
int __thiscall CxImageGIF::operator=(int this, struct CxImage *a2);
void __thiscall CxImageGIF::~CxImageGIF(CxImageGIF *__hidden this); // idb
CxImageGIF *__thiscall sub_45E670(CxImageGIF *this, char a2);
char __thiscall CxImage::Load(CxImage *this, const char *a2, unsigned int a3);
char __thiscall CxImage::Load(CxImage *this, const unsigned __int16 *a2, unsigned int a3);
char __thiscall CxImage::LoadResource(CxImage *this, HRSRC a2, unsigned int a3, HINSTANCE a4);
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, const char *, unsigned int); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, struct _iobuf *, unsigned int); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, struct CxFile *, unsigned int); // idb
CxImage *__thiscall CxImage::CxImage(CxImage *__hidden this, unsigned __int8 *, unsigned int, unsigned int); // idb
char __thiscall CxImage::Decode(CxImage *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4);
char __thiscall CxImage::Decode(CxImage *this, struct _iobuf *a2, unsigned int a3);
char __thiscall CxImage::Decode(CxImage *this, struct CxFile *a2, unsigned int a3);
CxImage *__thiscall sub_45F280(CxImage *this, char a2);
void __thiscall CxImage::~CxImage(CxImage *__hidden this); // idb
CxImage *__thiscall sub_45F2B0(CxImage *this, char a2);
void __thiscall CxImage::~CxImage(CxImage *__hidden this); // idb
CxImage *__thiscall sub_45F2E0(CxImage *this, char a2);
void __thiscall CxImage::~CxImage(CxImage *__hidden this); // idb
CxImage *__thiscall sub_45F310(CxImage *this, char a2);
void __thiscall CxImage::~CxImage(CxImage *__hidden this); // idb
char __thiscall CxImageGIF::Decode(CxImageGIF *this, struct CxFile *a2);
bool __thiscall CxImageGIF::DecodeExtension(CxImageGIF *__hidden this, struct CxFile *); // idb
int __thiscall CxImageGIF::get_byte(CxImageGIF *__hidden this, struct CxFile *); // idb
int __thiscall CxImageGIF::out_line(CxImageGIF *__hidden this, struct CImageIterator *, unsigned __int8 *, int); // idb
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct CxFile *a2);
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct CxFile *a2, struct CxImage **a3, int a4, bool a5);
void __thiscall CxImageGIF::EncodeHeader(CxImageGIF *__hidden this, struct CxFile *); // idb
void __thiscall CxImageGIF::EncodeExtension(CxImageGIF *__hidden this, struct CxFile *); // idb
void __thiscall CxImageGIF::EncodeLoopExtension(CxImageGIF *__hidden this, struct CxFile *); // idb
void __thiscall CxImageGIF::EncodeBody(CxImageGIF *__hidden this, struct CxFile *, bool); // idb
void __thiscall CxImageGIF::EncodeComment(CxImageGIF *__hidden this, struct CxFile *); // idb
char __thiscall CxImageGIF::EncodeRGB(CxImageGIF *this, struct CxFile *a2);
int __thiscall CxImageGIF::GifNextPixel(CxImageGIF *__hidden this); // idb
void __thiscall CxImageGIF::Putword(CxImageGIF *__hidden this, int, struct CxFile *); // idb
void __thiscall CxImageGIF::compressNONE(CxImageGIF *__hidden this, int, struct CxFile *); // idb
void __thiscall CxImageGIF::compressLZW(CxImageGIF *__hidden this, int, struct CxFile *); // idb
void __fastcall CxImageGIF::output(CxImageGIF *this, int a2, __int16 a3);
void __thiscall CxImageGIF::cl_hash(CxImageGIF *__hidden this, int); // idb
void __thiscall CxImageGIF::char_out(CxImageGIF *__hidden this, int); // idb
void __thiscall CxImageGIF::flush_char(CxImageGIF *__hidden this); // idb
__int16 __thiscall CxImageGIF::init_exp(CxImageGIF *__hidden this, __int16); // idb
__int16 __thiscall CxImageGIF::get_next_code(CxImageGIF *__hidden this, struct CxFile *); // idb
__int16 __thiscall CxImageGIF::decoder(CxImageGIF *this, struct CxFile *a2, struct CImageIterator *a3, int a4, int *a5);
int __thiscall CxImageGIF::get_num_frames(CxImageGIF *__hidden this, struct CxFile *, struct CxImageGIF::tag_TabCol *); // idb
void __thiscall CxImageGIF::SetDisposalMethod(CxImageGIF *__hidden this, int); // idb
int __thiscall CxImageGIF::GetDisposalMethod(CxImageGIF *__hidden this); // idb
void __thiscall CxImageGIF::SetLoops(CxImageGIF *__hidden this, int); // idb
int __thiscall CxImageGIF::GetLoops(CxImageGIF *__hidden this); // idb
void __thiscall CxImageGIF::SetComment(CxImageGIF *__hidden this, const char *); // idb
void __thiscall CxImageGIF::GetComment(CxImageGIF *__hidden this, char *); // idb
void __thiscall CxImageGIF::GifMix(CxImageGIF *__hidden this, struct CxImage *, int, int); // idb
void __thiscall CxImageGIF::rle_clear(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_flush(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_output_plain(CxImageGIF *__hidden this, int, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_flush_fromclear(CxImageGIF *__hidden this, int, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_reset_out_clear(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_flush_withtable(CxImageGIF *__hidden this, unsigned int, struct CxImageGIF::tag_RLE *); // idb
int __thiscall CxImageGIF::rle_compute_triangle_count(CxImageGIF *this, unsigned int a2, unsigned int a3);
unsigned int __thiscall CxImageGIF::rle_isqrt(CxImageGIF *__hidden this, unsigned int); // idb
void __thiscall CxImageGIF::rle_flush_clearorrep(CxImageGIF *__hidden this, int, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_write_block(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_block_out(CxImageGIF *__hidden this, char, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_block_flush(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_output(CxImageGIF *__hidden this, int, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::rle_output_flush(CxImageGIF *__hidden this, struct CxImageGIF::tag_RLE *); // idb
void __thiscall CxImageGIF::compressRLE(CxImageGIF *__hidden this, int, struct CxFile *); // idb
char __thiscall sub_462FD0(CxImage *this, int a2);
char __thiscall sub_463510(CxImage *this, int a2);
int __stdcall sub_463AB0(void *a1, unsigned __int8 *a2, char *pExceptionObject, int i, __int16 a5);
char __stdcall sub_463B80(_BYTE *a1, _BYTE *a2, __int16 a3, char *pExceptionObject, __int16 a5);
char __stdcall sub_463CF0(int a1, unsigned __int8 *a2, _BYTE *a3, int a4);
int __stdcall sub_463D80(char *a1, int a2, int a3);
// char __userpurge sub_463F70@<al>(CxImage *a1@<ecx>, char a2@<bl>, int a3@<esi>, int a4);
int __cdecl sub_464570(int a1, int a2, int a3);
// void __userpurge __noreturn sub_4645A0(jmp_buf Buf, char *Source);
// char __userpurge sub_4645D0@<al>(CxImage *a1@<ecx>, char a2@<bl>, int a3@<edi>, int a4);
int __cdecl sub_4649E0(int a1, int a2, int a3);
int __cdecl sub_464A10(int a1);
// char __userpurge sub_464A40@<al>(CxImage *a1@<ecx>, int a2@<ebx>, int a3);
_DWORD *__cdecl sub_464F20(int a1);
char __cdecl sub_464F40(_DWORD *a1);
int __cdecl sub_464F90(_DWORD *a1);
int __cdecl sub_464FF0(int a1);
char __cdecl sub_465010(_DWORD *a1);
int __cdecl sub_465090(_DWORD *a1, int a2);
int nullsub_10(); // weak
void __stdcall __noreturn sub_465160(int *a1);
// char __userpurge sub_465190@<al>(char *a1@<ecx>, int a2@<ebx>, int a3);
char __thiscall sub_4654D0(CxImage *this, int a2);
char __stdcall sub_465D50(int a1, int *a2);
char __thiscall CxImage::GrayScale(CxImage *this);
char __thiscall CxImage::Flip(CxImage *this);
char __thiscall CxImage::Mirror(CxImage *this);
char __thiscall CxImage::RotateLeft(CxImage *this, struct CxImage *a2);
char __thiscall CxImage::RotateRight(CxImage *this, struct CxImage *a2);
int __cdecl sub_4668F0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 *a4);
char __cdecl sub_466990(int a1, int *a2, int a3, int a4, int a5);
char __cdecl sub_466A40(int a1, int *a2, int a3, int a4);
int __cdecl sub_466A60(_DWORD *a1);
int __cdecl sub_466AB0(_DWORD *a1);
int __cdecl sub_466B00(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_466C10(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_466C30(unsigned __int8 **a1, int a2);
int __cdecl z_deflateInit_(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_467220(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8);
int __cdecl sub_467520(_DWORD *a1);
int __cdecl sub_467670(int a1, int a2);
int __cdecl sub_467920(int a1, __int16 a2);
_DWORD *__cdecl sub_467950(int a1);
char __cdecl sub_4679D0(int a1);
int __cdecl sub_467C30(int a1);
int __cdecl sub_467CD0(int *a1, int a2);
int __cdecl sub_467E30(int a1);
unsigned int __cdecl sub_467F60(int a1, void *a2, unsigned int a3);
unsigned int __cdecl sub_468310(_DWORD *a1, int a2);
int (__cdecl *__cdecl sub_4688B0(_DWORD *a1, int a2, _DWORD *a3))(_DWORD, _DWORD, _DWORD);
int __cdecl sub_468930(int a1, int a2, int a3);
int __cdecl sub_4689D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_4696E0(_DWORD *a1, int a2);
int __cdecl sub_469720(int a1, const void *a2, unsigned int a3);
BOOL __cdecl sub_469760(_DWORD *a1);
int __cdecl sub_469770(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
BOOL __cdecl sub_4698D0(int a1, int a2, int a3);
void __cdecl sub_4698F0(int a1, unsigned int a2);
_WORD *__cdecl sub_469900(int a1);
int nullsub_11(void); // weak
_WORD *__cdecl sub_469980(int a1);
_BYTE *__cdecl sub_4699F0(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_469A90(int a1);
_WORD *__cdecl sub_469CF0(int a1, _BYTE *a2, int a3, int a4);
unsigned int __cdecl sub_469EE0(_DWORD *a1, int *a2);
int __cdecl sub_46A120(int a1, int a2, int a3);
__int16 __cdecl sub_46A200(_DWORD *a1, int *a2);
unsigned int __cdecl sub_46A430(_WORD *a1, int a2, int a3);
int __cdecl sub_46A4B0(int a1);
int __cdecl sub_46A520(_WORD *a1, int a2, int a3);
int __cdecl sub_46A610(int a1, int a2, int a3, int a4);
int __cdecl sub_46A880(int a1, unsigned int a2, int a3);
int __cdecl sub_46AEB0(int a1, int a2, int a3);
BOOL __cdecl sub_46B2F0(int a1);
unsigned int __cdecl sub_46B370(unsigned int a1, int a2);
int __cdecl sub_46B390(int a1);
int __cdecl sub_46B420(int a1);
_BYTE *__cdecl sub_46B4A0(_DWORD *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_46B540(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_46B580(_DWORD *a1, int a2, int a3);
int __cdecl sub_46BD30(int a1, int a2);
int __cdecl sub_46BD50(int *a1, unsigned int *a2, int *a3, int a4, int a5);
int __cdecl sub_46BE00(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, int *a6, unsigned int *a7, int a8, unsigned int *a9, unsigned int *a10);
int __cdecl sub_46C2C0(unsigned int a1, unsigned int a2, int *a3, unsigned int *a4, unsigned int *a5, int *a6, int *a7, int a8, int a9);
int __cdecl sub_46C450(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_46C480(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_46C5C0(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6);
int __thiscall type_info::~type_info(type_info *this);
type_info *__thiscall sub_46C9ED(type_info *this, char a2);
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
unsigned int __cdecl sub_46CAB0(unsigned int a1, _BYTE *a2, unsigned int a3);
void __stdcall _JumpToContinuation(void *, struct EHRegistrationNode *); // idb
int __cdecl sub_46CE19(int a1, int a2);
int __cdecl sub_46CE20(int a1, int a2);
int __cdecl sub_46CE27(int a1, int a2);
// struct _EXCEPTION_REGISTRATION_RECORD *__userpurge unknown_libname_60@<eax>(struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>, int a2, int a3);
// _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall __CxxLongjmpUnwind(int); weak
void __cdecl _CallCatchBlock2(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, void *a3, int a4, unsigned __int32 a5);
// int __usercall CatchGuardHandler@<eax>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5);
int __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, int, struct EHRegistrationNode *); // idb
// int __usercall TranslatorGuardHandler@<eax>(struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a4);
TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *a1, int a2, int a3, unsigned int *a4, unsigned int *a5);
int __cdecl _global_unwind2(PVOID TargetFrame); // idb
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4);
// int __usercall _local_unwind2@<eax>(int a1@<ebp>, int a2, int a3);
int __cdecl _abnormal_termination();
void __stdcall sub_46D1B9(int a1);
// int __userpurge sub_46D1C2@<eax>(int result@<eax>, int a2@<ebp>, int a3);
unsigned int sub_46D1DA();
char *(__cdecl *_cfltcvt_init())(int a1, int a2, int a3, size_t Size, int a5);
void sub_46D263();
unsigned int __stdcall `eh vector destructor iterator'(char *a1, unsigned int a2, int a3, int (__thiscall *a4)(char *));
int __stdcall __ArrayUnwind(char *a1, unsigned int a2, int a3, int (*a4)(void));
char __cdecl sub_46D34A(_DWORD **a1);
void __cdecl sub_46D360(unsigned int a1);
int __stdcall `eh vector constructor iterator'(char *a1, unsigned int a2, int a3, void (__thiscall *a4)(void *), void (__thiscall *a5)(void *));
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
int *__cdecl _dosmaperr(unsigned int a1);
int *sub_46D641();
int *sub_46D64A();
char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
int __cdecl atol_0(const char *String);
int __cdecl sub_46D80E(char *String);
char *__cdecl strchr(const char *Str, int Val);
int __cdecl vsprintf_0(char *const Buffer, const char *const Format, va_list ArgList);
int __cdecl sub_46D9FD(size_t a1);
int __cdecl _nh_malloc_0(size_t Size, int); // idb
int __cdecl sub_46DA3B(unsigned int a1);
int __cdecl sub_46DB69(int a1);
void *__cdecl sub_46DC4A(void *Src, size_t a2);
int __cdecl toupper(int C);
int __cdecl toupper_0(int C);
int __cdecl tolower(int C);
int __cdecl tolower_0(int C);
void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
int sprintf_0(char *const Buffer, const char *const Format, ...);
int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
_onexit_t __cdecl _onexit(_onexit_t Func);
int __cdecl sub_46E3C5(_onexit_t Func);
int sub_46E406(char *a1, ...);
void _cinit_0();
int __cdecl sub_46E4AC(int a1);
int __cdecl sub_46E4BD(int a1);
int __cdecl sub_46E4EC(int a1, int a2, int a3);
int sub_46E591();
int sub_46E59A();
void __cdecl sub_46E5A3(void (**a1)(void), unsigned int a2);
__time32_t __cdecl time_0(__time32_t *const Time);
int __cdecl isdigit(int C);
int __cdecl isspace(int C);
int __cdecl isalnum(int C);
int sub_46E8F9(); // weak
char *__cdecl strstr(const char *Str, const char *SubStr);
int *__cdecl sub_46E980(int a1);
int __cdecl rand();
long double __cdecl _ceil_default(long double x);
char *__cdecl strrchr(const char *Str, int Ch);
void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
char *__cdecl shortsort(char *a1, char *a2, int a3, int (__cdecl *a4)(char *));
char *__cdecl swap(char *a1, char *a2, int a3);
struct tm *__cdecl localtime(const __time32_t *const Time);
int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten); // idb
int __cdecl sub_46EF45(DWORD a1);
int __cdecl fclose(FILE *Stream);
int __cdecl _fclose_lk(_iobuf *str); // idb
FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag);
FILE *__cdecl sub_46F017(char *FileName, char *Mode);
size_t __cdecl sub_46F02A(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl sub_46F141(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
int __cdecl fseek(FILE *Stream, int Offset, int Origin);
int __cdecl _fseek_lk(int, int Offset, int Origin); // idb
int __cdecl sub_46F333(FILE *Stream);
int __cdecl _ftell_lk(int a1);
int __cdecl fflush(FILE *Stream);
int __cdecl _fflush_lk(int a1);
int __cdecl _flush_0(_DWORD *a1);
int sub_46F56F();
int __cdecl flsall(int a1);
int __cdecl fputc(int Character, FILE *Stream);
int __cdecl fgetc(FILE *Stream);
int __cdecl sub_46F698(FILE *Stream);
_DWORD *__cdecl sub_46F6A3(int a1, unsigned __int16 *a2, int a3);
_DWORD *__cdecl sub_46F6D4(int a1, unsigned __int16 *a2);
void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// int __usercall _setjmp3@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, _DWORD *a5, int a6, struct _EXCEPTION_REGISTRATION_RECORD *a7, int a8, ...);
int __cdecl sub_46F7DF(int a1, int a2);
BOOL __cdecl sub_46F804(int a1, int a2);
int _mtinitlocks();
int _mtdeletelocks_0();
int __cdecl _lock(int a1);
int __cdecl sub_46FA37(int a1);
int __cdecl strcmp(const char *Str1, const char *Str2);
char __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *a1);
// int __usercall __InternalCxxFrameHandler_0@<eax>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6, struct _s_FuncInfo *a7, int a8, int a9, unsigned __int8 a10);
// char __usercall FindHandler@<al>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, struct _s_HandlerType *a5, int a6, int a7, int a8, struct _s_FuncInfo *a9, char a10, int a11, int a12);
int __cdecl FindHandlerForForeignException(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, struct _s_FuncInfo *, int, int, struct EHRegistrationNode *); // idb
BOOL __cdecl TypeMatch(const struct _s_HandlerType *a1, const struct _s_CatchableType *a2, const struct _s_ThrowInfo *a3);
void __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4);
char __cdecl sub_46FF4B(_DWORD **a1);
void __cdecl CatchIt(struct EHExceptionRecord *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, int a4, const struct _s_FuncInfo *a5, struct EHExceptionRecord *a6, const struct _s_CatchableType *a7, const struct _s_TryBlockMapEntry *a8, int a9, struct EHRegistrationNode *a10);
void *__cdecl CallCatchBlock(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, const struct _s_FuncInfo *, void *, int, unsigned int); // idb
BOOL __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1);
// void __usercall BuildCatchObject(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5);
int __cdecl sub_4702E5(int a1);
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2);
void __stdcall _CallSettingFrame(int a1, int a2, int a3);
int _mtinit();
int __cdecl sub_47042E(int a1);
int *_getptd();
char sub_470554();
// char __usercall sub_4705CD@<al>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
unsigned int sub_470623();
BOOL _ms_p5_test_fdiv();
int __cdecl _ms_p5_mp_test_fdiv();
char __cdecl _forcdecpt(char *a1);
char *__cdecl sub_4706F6(char *a1);
BOOL __cdecl sub_470744(double *a1);
char **__cdecl _fassign(int a1, char **a2, char *a3);
int __cdecl _cftoe(int a1, int a2, int a3, int a4);
_BYTE *__cdecl _cftoe2(_BYTE *a1, int a2, int a3, int a4, char a5);
size_t __cdecl _cftof(char *Src, size_t Size, size_t a3);
char *__cdecl _cftof2(char *Src, size_t Size, int a3, char a4);
char *__cdecl _cftog(char *Src, int Size, int a3, int a4);
char *__cdecl _cfltcvt(int a1, int a2, int a3, size_t Size, int a5);
void __cdecl _shift(char *Src, int a2);
int __cdecl _except_handler3(int, PVOID TargetFrame, int); // idb
char __cdecl sub_470BA4(int a1);
unsigned int sub_470BD1();
int __cdecl sub_470D19(int a1);
int __cdecl __sbh_heap_init(int a1);
unsigned int __cdecl __sbh_find_block_0(int a1);
_DWORD *__cdecl sub_470F63(_DWORD *a1, int a2);
_DWORD *__cdecl __sbh_alloc_block_0(int a1);
tagHeader *__cdecl __sbh_alloc_new_region();
int __cdecl __sbh_alloc_new_group(_DWORD *a1);
int __cdecl __sbh_resize_block_0(_DWORD *a1, int a2, int a3);
void **sub_471E59();
void **__cdecl sub_471F9D(int a1);
void __cdecl sub_471FF3(int a1);
unsigned int __cdecl sub_4720B5(unsigned int a1, void ***a2, unsigned int *a3);
void __cdecl sub_47210C(int a1, int a2, _BYTE *a3);
int __cdecl sub_472151(unsigned int a1);
int __cdecl sub_472359(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_47247D(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4);
int __cdecl _isctype_0(int C, int Type);
int __cdecl _flsbuf(int Ch, FILE *File);
int __cdecl sub_472811(FILE *a1, char *a2, int a3);
int __cdecl write_char_0(int, FILE *File, int); // idb
int __cdecl write_multi_char_0(int a1, int a2, FILE *a3, _DWORD *a4);
int __cdecl write_string_0(int, int, FILE *File, int); // idb
int __cdecl sub_472FF0(_DWORD *a1);
__int64 __cdecl sub_472FFD(_DWORD *a1);
__int16 __cdecl sub_47300D(_DWORD *a1);
BOOL __cdecl sub_473045(int a1);
void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
char *__cdecl _setlocale_set_cat(int a1, char *Str);
char *_setlocale_get_all();
char *__cdecl _expandlocale(char *Str, char *Dest, void *Dst, int a4);
int sub_4738C7();
char *__cdecl _strcats(char *Dest, int a2);
int __cdecl __lc_strtolc(void *Dst, char *Str); // idb
char *__cdecl __lc_lctostr(char *Dest, char *Source);
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int); // idb
_BYTE *__cdecl strncnt_0(_BYTE *a1, _BYTE *a2);
int __cdecl sub_473C5D(unsigned int a1);
void __cdecl _lock_file(FILE *Stream);
int __cdecl _lock_file2(int a1, int a2);
int __cdecl sub_473E59(unsigned int a1);
int __cdecl sub_473E88(int a1, int a2);
int __cdecl _stbuf_0(int a1);
int __cdecl _ftbuf(int a1, int a2);
int __cdecl __loctotime_t_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
double __cdecl _handle_qnan1(double a1, int a2);
double __cdecl _handle_qnan2(double a1, double a2, int a3);
double __cdecl _except1(DWORD dwExceptionCode, int a2, int a3, int a4, double a5, int a6);
double __cdecl sub_474170(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// double __usercall sub_474173@<st0>(int a1@<ebp>);
// ULONG_PTR __usercall _raise_exc@<eax>(__int16 a1@<fpstat>, ULONG_PTR Arguments, int a3, DWORD dwExceptionCode, int a5, int a6, int a7);
BOOL __cdecl _handle_exc(char a1, double *a2, __int16 a3);
double __cdecl _umatherr(int a1, int a2, int a3, int a4, int a5, int a6, double a7);
void __cdecl _set_errno_from_matherr(int matherrtype); // idb
char *__cdecl _get_fname(int a1);
int __cdecl _errcode(char a1);
double __cdecl sub_4747E1(double a1);
double __cdecl _set_exp(double a1, int a2);
int __cdecl _sptype(int a1, int a2);
double __cdecl _decomp(double a1, int a2);
// int __usercall sub_47499B@<eax>(__int16 a1@<fpstat>);
// int __usercall sub_4749A9@<eax>(__int16 a1@<fpstat>);
int __fastcall _ctrlfp(__int16 a1);
void _set_statfp();
int __tzset();
char *_tzset_lk();
int __cdecl _isindst(_DWORD *a1);
int __cdecl _isindst_0(_DWORD *a1);
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
struct tm *__cdecl gmtime(const __time32_t *const Time);
int __cdecl _XcptFilter(int, struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
_DWORD *__cdecl xcptlookup(int a1, _DWORD *a2);
_BYTE *_wincmdln();
void _setenvp_0();
int _setargv_0();
_DWORD *__cdecl parse_cmdline_0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5);
void *__crtGetEnvironmentStringsA_0();
int _ioinit();
int *_FF_MSGBANNER_0();
int *__cdecl _NMSG_WRITE_0(DWORD NumberOfBytesWritten);
int __cdecl _close(int FileHandle);
int __cdecl _close_lk(int FileHandle); // idb
void __cdecl _freebuf_0(_iobuf *stream); // idb
_DWORD *__cdecl _openfile(char *FileName, _BYTE *a2, int ShareFlag, _DWORD *a4);
_DWORD *_getstream();
int __cdecl _filbuf(FILE *File);
int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount);
unsigned int __cdecl _read_lk(int a1, LPVOID lpBuffer, DWORD nNumberOfBytesToRead);
int __cdecl sub_476145(int a1, const void *a2, DWORD a3);
int __cdecl _write_lk(int FileHandle, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); // idb
int __cdecl sub_476335(int a1, LONG a2, DWORD a3);
int __cdecl _lseek_lk(int FileHandle, LONG lDistanceToMove, DWORD dwMoveMethod); // idb
int __cdecl _commit(int FileHandle);
_DWORD *__cdecl sub_4764A0(int a1, unsigned __int16 *a2, int a3, _DWORD *a4);
int __stdcall sub_476616(int a1);
void *__cdecl memset(void *, int Val, size_t Size);
BOOL __cdecl sub_4766D8(int a1, int a2);
BOOL __cdecl sub_4766F4(int a1, int a2);
BOOL __cdecl sub_476710(int a1);
unsigned int __cdecl _control87_0(unsigned int NewValue, unsigned int Mask);
unsigned int __cdecl sub_47679B(unsigned int NewValue, int a2);
char __cdecl _abstract_cw_0(char a1);
char __cdecl _hw_cw_0(int a1);
char __cdecl _abstract_sw(char a1);
int __cdecl _ZeroTail_0(int a1, int a2);
int __cdecl _IncMan_0(int a1, int a2);
int __cdecl _RoundMan_0(int a1, int a2);
_DWORD *__cdecl sub_476A57(int a1, _DWORD *a2);
int __cdecl sub_476A72(_DWORD *a1);
int __cdecl sub_476A7E(_DWORD *a1);
int *__cdecl _ShrMan(int *a1, int a2);
int __cdecl _ld12cvt(unsigned __int16 *a1, _DWORD *a2, int *a3);
int __cdecl sub_476C92(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_476CA8(unsigned __int16 *a1, _DWORD *a2);
int __cdecl _ld12told(unsigned __int16 *a1, int a2);
int __cdecl sub_476D38(_DWORD *a1, char *a2);
int __cdecl sub_476D93(_DWORD *a1, char *a2);
char *__cdecl _fptostr(void *Dst, int a2, int a3);
_DWORD *__cdecl _fltout2(int a1, int a2, int a3, char *Dest);
// int __usercall __dtold@<eax>(unsigned int a1@<eax>, int a2, int *a3);
void sub_476F50();
char *__cdecl strcat(char *Destination, const char *Source);
size_t __cdecl strlen(const char *Str);
unsigned int __cdecl sub_4770C4(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
unsigned int __cdecl strtoxl(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); // idb
int __cdecl _getbuf_0(_DWORD *a1);
int __cdecl _isatty(int FileHandle);
int __cdecl wctomb(char *MbCh, wchar_t WCh);
int __cdecl _wctomb_lk(LPSTR UsedDefaultChar, unsigned __int16 WideCharStr);
int __init_time();
int __cdecl _get_lc_time(int a1);
void __cdecl _free_lc_time(__lc_time_data *lc_time); // idb
int __init_numeric();
char __cdecl fix_grouping(char *a1);
int __init_monetary();
int __cdecl _get_lc_lconv(int a1);
char __cdecl sub_477FBD(char *a1);
void __cdecl _free_lc_lconv(unsigned int *a1);
int LC_MONETARY();
int sub_478287();
size_t __cdecl strcspn(const char *Str, const char *Control);
char *__cdecl strpbrk(const char *Str, const char *Control);
int __cdecl __get_qualified_locale(char *a1, _WORD *a2, int a3);
int __cdecl TranslateName(int a1, int a2, const char **a3);
int GetLcidFromLangCountry();
BOOL __stdcall LangCountryEnumProc(LPSTR); // idb
int GetLcidFromLanguage();
BOOL __stdcall LanguageEnumProc(LPSTR); // idb
int GetLcidFromCountry();
unsigned int __stdcall CountryEnumProc(LPSTR a1);
int sub_47893A();
int __cdecl ProcessCodePage(char *Str1); // idb
int __cdecl sub_4789BA(__int16 a1);
BOOL __cdecl TestDefaultLanguage(int a1, int a2);
BOOL IsThisWindowsNT();
int __stdcall crtGetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR Dest, int cchData); // idb
int __cdecl LcidFromHexString(char *a1);
int __cdecl GetPrimaryLen(char *a1);
int sub_478C32();
char *__cdecl sub_478C35(char *VarName);
char *__cdecl getenv_0(const char *VarName);
int __cdecl sub_478D67(unsigned __int8 a1);
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3);
int __cdecl _setmbcp(int CodePage);
int __cdecl getSystemCP_0(int a1);
int __cdecl CPtoLCID_0(int a1);
int setSBCS_0();
unsigned int setSBUpLow();
int sub_4791C9();
int __cdecl __crtMessageBoxA_0(int a1, int a2, int a3);
int _alloc_osfhnd();
int __cdecl _set_osfhnd(int, HANDLE hHandle); // idb
int __cdecl _free_osfhnd(int a1);
intptr_t __cdecl _get_osfhandle(int FileHandle);
int __cdecl _lock_fhandle(int a1);
int __cdecl _unlock_fhandle(int a1);
int _sopen(const char *FileName, int OpenFlag, int ShareFlag, ...);
int __cdecl sub_4798F3(int a1, __int16 a2, int a3, char a4);
BOOL __stdcall ctrlevent_capture(DWORD); // idb
int __cdecl raise(int Signal);
unsigned int __cdecl siglookup(int a1, unsigned int a2);
int *sub_479F6F();
int __cdecl __addl_0(unsigned int a1, unsigned int a2, unsigned int *a3);
int __cdecl __add_12_0(unsigned int *a1, unsigned int *a2);
_DWORD *__cdecl __shl_12(_DWORD *a1);
int *__cdecl __shr_12(int *a1);
__int16 __cdecl __mtold12_0(char *a1, int a2, int a3);
int __cdecl __strgtold12_0(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl _I10_OUTPUT_0(__int64 a1, int a2, int a3, char a4, int a5);
int __cdecl sub_47AC2A(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int *a4, int a5);
void __cdecl _expandtime(char a1, int *a2, char **a3, unsigned int *a4, int a5);
void __cdecl _store_str(_BYTE *a1, _DWORD *a2, _DWORD *a3);
char *__cdecl _store_num(int a1, unsigned int a2, char **a3, unsigned int *a4);
char *__cdecl _store_number(int a1, char **a2, _DWORD *a3);
void __cdecl _store_winword(void *String1, int a2, int a3, int a4, int a5);
int __cdecl __getlocaleinfo(int, LCID Locale, LCTYPE LCType, int); // idb
int __cdecl __crtGetStringTypeW(DWORD dwInfoType, LPCWSTR lpWideCharStr, int cchWideChar, LPWORD Dst, UINT CodePage, LCID Locale); // idb
char *__cdecl _itoa(int Value, char *Buffer, int Radix);
char __cdecl xtoa(unsigned int a1, char *a2, unsigned int a3, int a4);
char *__stdcall x64toa(__int64 a1, char *a2, unsigned int a3, int a4);
int __cdecl _strcmpi(const char *String1, const char *String2);
int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
int __cdecl _mbsnbicoll_0(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
int __wtomb_environ_0();
// int __usercall _chsize_lk@<eax>(int a1@<edi>, int FileHandle, LONG lDistanceToMove);
int __cdecl __ld12mul_0(int a1, int a2);
void __cdecl __multtenpow12_0(_WORD *a1, int a2, int a3);
int __cdecl __crtGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpWideCharStr, int cchWideChar, UINT CodePage); // idb
int __cdecl __crtGetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpMultiByteStr, int cbMultiByte, UINT CodePage); // idb
int __cdecl __crtCompareStringA_0(LCID Locale, DWORD dwCmpFlags, PCNZCH lpMultiByteStr, int cbMultiByte, PCNZCH lpString2, int cchCount2, UINT CodePage); // idb
_BYTE *__cdecl sub_47C4B6(_BYTE *a1, _BYTE *a2);
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int); // idb
int __cdecl findenv_0(PCNZCH lpMultiByteStr, int cchCount2); // idb
char **__cdecl copy_environ_0(_DWORD *a1);
int __cdecl _setmode_lk(int a1, int a2);
unsigned __int8 *__cdecl _mbschr(const unsigned __int8 *Str, unsigned int C);
char *__cdecl _strdup_0(const char *Source);
int __stdcall sub_47C8B6(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// char __usercall png_create_write_struct@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6);
// char __usercall sub_47CA40@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int (__cdecl *a8)(char *, size_t), void (__cdecl *a9)(char *, unsigned int));
int __cdecl sub_47CC80(int *a1, char *a2, unsigned int a3, unsigned int a4);
int __cdecl sub_47CD60(_DWORD **a1, _BYTE *a2, unsigned int a3);
char __cdecl sub_47CEB0(int a1, _DWORD *a2);
unsigned int __cdecl sub_47D270(int a1, int a2);
// char *__usercall sub_47D2E0@<eax>(int a1@<ebx>, int a2, char *a3, char *a4);
int __cdecl sub_47D800(int a1, char **a2);
void __cdecl sub_47D860(int a1, _DWORD *a2);
void __cdecl sub_47DB30(unsigned int *a1, unsigned int *a2, unsigned int *a3);
int __cdecl sub_47DBF0(int a1, int a2, int a3);
int __cdecl sub_47E000(int a1);
int __cdecl sub_47E010(int a1);
int __cdecl sub_47E030(int a1);
int __cdecl sub_47E050(int a1);
int __cdecl sub_47E070(int a1, int a2);
int __cdecl sub_47E0A0(int a1);
int __cdecl sub_47E0D0(int a1, unsigned __int8 a2, int a3);
int __cdecl sub_47E130(int a1);
int __cdecl sub_47E140(int a1);
int __cdecl sub_47E150(int a1);
char __cdecl sub_47E160(int a1, char *a2);
void __cdecl sub_47E1F0(int a1, char *a2);
unsigned __int8 *__cdecl sub_47E220(unsigned __int8 *a1, unsigned __int8 *a2);
char __cdecl sub_47E270(int a1, char *a2, char a3);
char __cdecl sub_47E480(int *a1, char *a2);
int __cdecl sub_47E630(int, int, int, int, double); // idb
int __cdecl sub_47E6E0(int a1);
int __cdecl sub_47E6F0(int a1);
int __cdecl sub_47EFD0(int a1);
int __cdecl sub_47F010(int a1);
int __cdecl sub_47F060(int a1, int a2, int a3, int a4);
char __cdecl sub_47F140(int a1);
unsigned int __cdecl sub_47FBD0(int a1, int a2);
void __cdecl sub_47FD60(int a1);
char __cdecl sub_4801B0(int *a1, int a2);
char __cdecl sub_4802E0(int *a1, _BYTE *a2, unsigned __int8 *a3);
void __cdecl sub_4804C0(int a1, char *a2);
char *__cdecl sub_480510(char *a1, int a2);
char *__cdecl sub_480610(char *a1, int a2);
char __cdecl sub_4806E0(int a1, int a2, unsigned int a3, char a4);
void __cdecl sub_480950(int *a1, int a2);
int __cdecl sub_480A90(int a1, int *a2, _BYTE *a3);
// void __usercall sub_481270(int a1@<edx>, int *a2, unsigned __int8 *a3, _WORD *a4, _BYTE *a5, _WORD *a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13);
char __cdecl sub_482270(int *a1, unsigned __int8 *a2, int a3, int a4, char a5);
char __cdecl sub_482660(int *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_482890(int *a1, int a2, _WORD *a3);
char __cdecl sub_482C20(int *a1, _BYTE *a2, int a3, int a4);
void __cdecl sub_482D40(int a1);
char __cdecl sub_4833A0(int *a1, int a2);
int __cdecl sub_483470(int a1, int a2, int a3);
int __cdecl sub_483490(int a1, int a2);
int __cdecl sub_483790(int a1, int a2, _DWORD *a3);
int __cdecl sub_483DE0(int a1, int a2, _DWORD *a3);
void __cdecl __noreturn sub_484040(int *a1, const char *a2);
int __cdecl sub_4840E0(int a1, _BYTE *a2);
void __cdecl __noreturn sub_484130(int *a1, const void *a2);
_BYTE *__cdecl sub_484160(int a1, int a2, const void *a3);
int __cdecl sub_4841F0(int a1, const void *a2);
void __cdecl __noreturn sub_484220(jmp_buf Buf, const char *a2);
int __cdecl sub_4842B0(int a1, const char *a2);
_DWORD *__cdecl sub_484330(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_484380(int *a1, int a2, int a3);
size_t __cdecl sub_4843B0(int a1, void *a2, size_t a3);
int __cdecl sub_4843F0(_DWORD *a1, int a2, int a3);
int __cdecl sub_484480(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_484520(int *a1, int a2, int a3);
void __cdecl sub_4845A0(int a1, unsigned int a2);
int __cdecl sub_4845C0(int a1);
int __cdecl sub_4845E0(int a1, unsigned __int8 *a2, unsigned int a3);
void *__cdecl sub_484630(void *a1);
int __cdecl sub_4846C0(unsigned int *a1, unsigned int a2);
void __cdecl sub_484760(int a1, int a2, int a3, int a4);
int __cdecl sub_484B20(int a1, int a2);
int __cdecl sub_484C80(int a1, _DWORD *a2);
int __cdecl sub_484D00(int a1);
__int16 __cdecl sub_484D40(int *a1, int a2);
unsigned int __cdecl sub_484F20(int *a1, int a2);
int __cdecl sub_485200(int a1, int a2);
char __cdecl sub_485360(int a1, char *a2);
// char __usercall sub_4853C0@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6);
// char __usercall sub_4853F0@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int (__cdecl *a8)(char *, size_t), int a9);
void __cdecl sub_4855A0(int *a1, char *a2, unsigned int a3, unsigned int a4);
void __cdecl sub_485680(_DWORD **a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_485790(int a1, const void **a2);
char __cdecl sub_4857F0(int a1, const void *a2);
int (__cdecl *__cdecl sub_485A70(int a1))(int);
int __cdecl sub_485B50(int a1, int a2, int a3);
// void __usercall sub_485B55(int a1@<eax>, _DWORD *a2, unsigned int *a3);
int __cdecl sub_485BF0(_DWORD *a1);
void __cdecl sub_485F10(int a1, int a2, int a3, double *a4, double *a5);
int __cdecl sub_486330(int a1, int a2, int a3);
void __cdecl sub_486370(int a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
char __cdecl sub_486630(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void __cdecl sub_486880(int a1, int a2, double a3);
void __cdecl sub_486900(int a1, int a2, int a3);
void __cdecl sub_486980(int *a1, int a2, int a3);
void __cdecl sub_486A30(int *a1, int a2, unsigned int a3, unsigned int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_486C50(int a1, int a2, int a3, int a4, char a5);
void __cdecl sub_486C80(int *a1, int a2, const char *a3, int a4, int a5, char a6, int a7, const char *a8, int a9);
int __cdecl sub_486E30(int a1, int a2, char a3, int a4, int a5, int a6, int a7);
int __cdecl sub_486E80(int a1, int a2, int a3, int a4, char a5);
void __cdecl sub_486EB0(int a1, int a2, const void *a3, int a4);
int __cdecl sub_486F60(int a1, int a2, int a3);
int __cdecl sub_486F90(int a1, int a2, char a3);
void __cdecl sub_486FC0(int a1, int a2, char a3);
void __cdecl sub_487090(int *a1, int a2, const char *a3, char a4, const void *a5, size_t a6);
int __cdecl sub_4871C0(int *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_4873F0(int a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_487430(int *a1, int a2, const void *a3, unsigned int a4, int a5);
char __cdecl sub_4874E0(int *a1, int a2, int a3, int a4);
void __cdecl sub_487660(int a1, int a2, int a3, int a4);
int __cdecl sub_487AD0(int *a1, int a2, int a3);
size_t __cdecl sub_487B00(int a1, void *a2, size_t a3);
int (__cdecl *__cdecl sub_487B40(int a1))(int);
int __cdecl sub_487B60(int a1);
int __cdecl sub_487B80(_DWORD *a1, int a2, int a3, int a4);
void *__cdecl sub_487BF0(int a1);
void *__cdecl sub_487C10(int a1, int (__cdecl *a2)(char *, size_t), int a3);
void __cdecl sub_487C90(unsigned int a1);
void __cdecl sub_487CB0(unsigned int a1, void (__cdecl *a2)(char *, unsigned int), int a3);
int __cdecl sub_487D00(int *a1, size_t a2);
int __cdecl sub_487D60(int *a1, size_t a2);
void __cdecl sub_487DA0(int a1, unsigned int a2);
void __cdecl sub_487DD0(int a1, unsigned int a2);
int __cdecl sub_487DF0(int *a1, size_t a2);
void *__cdecl sub_487E20(int a1, void *a2, const void *a3, unsigned int a4);
// char *__usercall sub_487E50@<eax>(int a1@<ebx>, int a2, char *a3, char a4, unsigned int a5);
_DWORD *__cdecl sub_487E90(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_487ED0(unsigned __int8 *a1);
int __cdecl sub_487F00(unsigned __int8 *a1);
// int __usercall sub_487F30@<eax>(int a1@<eax>, unsigned __int8 *a2);
int __cdecl sub_487F50(int *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_487F80(int a1, unsigned int a2);
BOOL __cdecl sub_488030(int a1);
char *__cdecl sub_4880A0(int a1, int a2, char *a3, int a4, unsigned int a5, unsigned int *a6);
void __cdecl sub_488470(int a1, int a2, int a3);
char __cdecl sub_4885E0(int a1, int a2, signed int a3);
int __cdecl sub_488780(int *a1, int a2, unsigned int a3);
void __cdecl sub_4887D0(int *a1, int a2, signed int a3);
int __cdecl sub_488920(int a1, int a2, unsigned int a3);
int __cdecl sub_488A90(int *a1, int a2, unsigned int a3);
void __cdecl sub_488F90(int *a1, int a2, unsigned int a3);
void __cdecl sub_4891A0(int *a1, int a2, unsigned int a3);
void __cdecl sub_489360(int *a1, int a2, unsigned int a3);
void __cdecl sub_489560(int a1, int a2, unsigned int a3);
int __cdecl sub_4897A0(int a1, int a2, unsigned int a3);
void __cdecl sub_4899A0(int a1, int a2, signed int a3);
int __cdecl sub_489AF0(int *a1, int a2, unsigned int a3);
int __cdecl sub_489BE0(int *a1, int a2, unsigned int a3);
void __cdecl sub_489CD0(int *a1, int a2, unsigned int a3);
void __cdecl sub_489F40(int *a1, int a2, unsigned int a3);
void __cdecl sub_48A110(int a1, _DWORD *a2, unsigned int a3);
void __cdecl sub_48A200(int a1, _DWORD *a2, unsigned int a3);
void __cdecl sub_48A320(int a1, _DWORD *a2, unsigned int a3);
int __cdecl sub_48A480(int a1, int a2, size_t a3);
unsigned __int8 __cdecl sub_48A5F0(int *a1, unsigned __int8 *a2);
char __cdecl sub_48A660(int a1, char *a2, int a3);
int __cdecl sub_48A980(int a1);
char __cdecl sub_48ADB0(int a1, int a2, _BYTE *a3, unsigned __int8 *a4, int a5);
// char *__usercall sub_48AF90@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_48B240(int a1);
int __cdecl png_save_uint_32(_BYTE *a1, int a2);
int __cdecl sub_48B4E0(_BYTE *a1, int a2);
int __cdecl sub_48B510(_BYTE *a1, int a2);
int __cdecl sub_48B530(int *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_48B560(int *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_48B5B0(int *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_48B5E0(int *a1);
char __cdecl sub_48B610(int a1);
int __cdecl sub_48B680(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_48BA00(int a1, int a2, unsigned int a3);
int __cdecl sub_48BAC0(int *a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_48BAF0(int *a1);
int __cdecl sub_48BB20(int, double); // idb
int __cdecl sub_48BB90(int *a1, int a2);
void __cdecl sub_48BBD0(int *a1, unsigned __int8 *a2, int a3, int a4, int a5);
int __cdecl sub_48BCB0(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_48BF70(int a1, int a2);
void __cdecl sub_48C030(int *a1, unsigned int a2);
int __cdecl sub_48C1B0(int a1, _BYTE *a2, int a3);
int __cdecl sub_48C270(int, double, double, double, double, double, double, double, double); // idb
int __cdecl sub_48C770(int a1, unsigned __int8 *a2, unsigned __int16 *a3, signed int a4, int a5);
int __cdecl sub_48C8D0(int a1, unsigned __int8 *a2, int a3);
int __cdecl sub_48CA10(int a1, unsigned __int16 *a2, int a3);
unsigned int __cdecl sub_48CA90(int *a1, const char *a2, unsigned int *a3);
void __cdecl sub_48CC40(int *a1, unsigned __int8 *a2, const char *a3);
void __cdecl sub_48CCF0(int *a1, unsigned __int8 *a2, const char *a3, int a4, int a5);
int __cdecl sub_48CE00(int *a1, int a2, int a3, int a4);
int __cdecl sub_48CE60(int *a1, const char *a2, int a3, int a4, int a5, int a6, char *a7, unsigned __int8 **a8);
int __cdecl sub_48CFD0(int *a1, char a2, double a3, double a4);
int __cdecl sub_48D090(int *a1, int a2, int a3, int a4);
int __cdecl sub_48D0F0(int *a1, _BYTE *a2);
unsigned int __cdecl sub_48D190(int a1);
char __cdecl sub_48D330(int a1);
unsigned int __cdecl sub_48D4F0(int a1, _BYTE *a2, int a3);
char __cdecl sub_48D780(int a1, int a2);
int (__cdecl *__cdecl sub_48E340(int a1, int a2))(int);
void __cdecl sub_48E420(int a1);
unsigned int __cdecl sub_48E580(int *a1, _BYTE *a2, int a3);
int __cdecl sub_48E690(int a1, _BYTE *a2, unsigned __int8 *a3);
char *__cdecl sub_48E920(char *a1, char *a2);
_BYTE *__cdecl sub_48EA30(_BYTE *a1, _BYTE *a2);
char __cdecl sub_48EB40(int *a1, int a2);
int __cdecl sub_48EC10(_DWORD *a1, int a2, int a3);
int __cdecl sub_48ECF0(int a1);
int __cdecl sub_48ED10(_DWORD *a1, char a2);
int __cdecl sub_48ED80(_DWORD *a1);
int __cdecl sub_48EE40(int a1);
char __cdecl sub_48F080(int a1);
char __cdecl sub_48F140(int a1);
char __cdecl sub_48F220(int a1);
_DWORD *__cdecl sub_48F2F0(_DWORD *a1, int a2, int a3);
char __cdecl sub_48F560(_DWORD *a1, int a2);
char __cdecl sub_48F660(_DWORD *a1);
int __cdecl sub_48F770(int a1);
char __cdecl sub_48F7E0(int a1);
int __cdecl sub_48F920(int a1, _BYTE *a2, unsigned int a3, int a4);
int __cdecl sub_48FBB0(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4);
char __cdecl sub_48FC90(_DWORD *a1);
int __cdecl sub_48FD30(_DWORD *a1);
char __cdecl sub_490080(int a1);
char __cdecl sub_490140(int a1, char a2, char a3);
char __cdecl sub_490470(_DWORD *a1);
char __cdecl sub_490780(_DWORD *a1);
char __cdecl sub_490AF0(_DWORD *a1);
char __cdecl sub_490D80(_DWORD *a1);
char __cdecl sub_490E70(_DWORD *a1);
char __cdecl sub_490F10(_DWORD *a1);
int __cdecl sub_490FA0(_DWORD *a1);
char __cdecl sub_4910B0(int a1);
int (__cdecl **__cdecl jpeg_std_error(int (__cdecl **a1)(int a1)))(int a1);
int __cdecl sub_4913E0(int a1);
int __cdecl sub_491400(int a1);
int __cdecl sub_491430(int *a1, int a2);
int __cdecl sub_491470(int a1, char *Buffer);
int __cdecl sub_491520(int *a1);
_DWORD *__cdecl sub_491540(_DWORD *a1, int a2, int a3);
int __cdecl sub_491610(int a1);
int __cdecl sub_491630(int a1, char a2);
char __cdecl sub_491680(_DWORD *a1);
int __cdecl sub_4918E0(_DWORD *a1, char a2);
_DWORD *__cdecl sub_491960(_DWORD *a1, int a2, unsigned int a3);
int __cdecl sub_491B00(_DWORD *a1, int a2, _DWORD *a3, int a4, char a5);
int __cdecl jpeg_set_linear_quality(_DWORD *a1, int a2, char a3);
int __cdecl sub_491C20(int a1);
int __cdecl sub_491C60(_DWORD *a1, int a2, char a3);
_DWORD *__cdecl sub_491C80(int a1);
int __cdecl sub_491D80(int *a1);
int __cdecl sub_491DE0(int a1, int *a2, int a3, const void *a4);
_DWORD *__cdecl sub_491E80(_DWORD *a1);
_DWORD *__cdecl sub_491F00(int a1, int a2);
_DWORD *__cdecl sub_4923B0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__cdecl sub_4923F0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
int *__cdecl sub_492440(int *a1, int a2, int a3, int a4);
int __cdecl sub_4924B0(int a1);
_DWORD *__cdecl sub_492500(int a1);
int __cdecl sub_492540(int *a1);
int __cdecl sub_4926F0(int a1);
int sub_4927A0(); // weak
int __cdecl sub_4927C0(_DWORD *a1);
char __cdecl sub_492880(int a1);
int sub_492A70(); // weak
const char *__cdecl sub_492AB0(_DWORD *a1);
int __cdecl sub_492BF0(_DWORD *a1, int a2, unsigned int a3);
int __cdecl sub_492D20(int a1, int a2);
_DWORD *__cdecl sub_492D40(_DWORD *a1, int a2, unsigned int a3);
int __cdecl sub_492DF0(_DWORD *a1, int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_492EA0(_DWORD *a1, int a2, int a3, signed int a4);
int __cdecl sub_492F50(_DWORD *a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_492FC0(_DWORD *a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_493030(_DWORD *a1);
int __cdecl sub_4931B0(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
int __cdecl sub_493300(int a1, int a2, char a3);
int __cdecl sub_4933A0(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
int __cdecl sub_4934F0(int a1, int a2, char a3);
_DWORD *__cdecl sub_493590(_DWORD *a1, int a2);
int sub_493690(); // weak
char __cdecl sub_4936D0(int a1);
int __cdecl sub_493710(int a1);
int __cdecl sub_493730(int a1);
int __cdecl sub_493750(int a1);
char __cdecl sub_493770(int a1);
char __cdecl sub_493990(int a1);
int __cdecl sub_493A90(int a1);
int __cdecl sub_493AD0(int a1);
int __cdecl sub_493CB0(int a1);
char __cdecl sub_493D30(int a1);
int __cdecl sub_493E90(int a1);
int __cdecl sub_493EC0(int a1, int a2);
int __cdecl sub_493ED0(int a1, int a2);
const void **__cdecl sub_493EF0(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_493F40(const void *a1, void *a2, int a3);
int __cdecl sub_493F70(void *a1, unsigned int a2);
char (__cdecl **__cdecl sub_493F90(int a1))(int a1);
int __cdecl sub_493FF0(_DWORD *a1, char a2, unsigned int a3);
int __cdecl sub_494030(_DWORD *a1, char a2);
int __cdecl sub_494050(_DWORD *a1, char a2);
int __cdecl sub_494090(_DWORD *a1, __int16 a2);
int __cdecl sub_4940C0(_DWORD *a1, char a2);
char __cdecl sub_4940E0(int a1);
int __cdecl sub_494130(int a1);
int __cdecl sub_4941E0(_DWORD *a1);
int __cdecl sub_494280(int a1);
int __cdecl sub_494380(_DWORD *a1, int a2);
int __cdecl sub_494460(_DWORD *a1, char a2);
int __cdecl sub_494520(int a1);
char __cdecl sub_494600(_DWORD *a1, int a2, char a3);
int __cdecl nullsub_12(_DWORD); // weak
int __cdecl sub_4946D0(_DWORD *a1);
int __cdecl sub_494700(int a1);
int sub_4947E0(); // weak
int __cdecl sub_494800(int a1);
int __cdecl sub_494880(int a1);
int __cdecl sub_494940(int a1, size_t a2);
void __cdecl sub_494950(int a1, unsigned int a2);
int __cdecl sub_494960(int a1, size_t a2);
void __cdecl sub_494970(int a1, unsigned int a2);
int __cdecl sub_494980(int a1, int a2, int a3);
int __cdecl sub_494990(int a1);
int sub_4949B0();
int __cdecl nullsub_13(_DWORD); // weak
int __cdecl sub_4949D0(int a1, char a2);
int __cdecl sub_494AA0(int a1);
int sub_494B50(); // weak
_DWORD *__cdecl sub_494BD0(_DWORD *a1);
unsigned int __cdecl sub_494D20(_DWORD *a1, int a2, int a3, int a4);
unsigned int __cdecl sub_494D90(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4);
int __cdecl sub_494ED0(_DWORD *a1);
_DWORD *__cdecl sub_494FE0(_DWORD *a1);
int __cdecl sub_495080(int a1, int a2, int a3, int a4);
int __cdecl sub_4950B0(int a1, char a2);
_DWORD *__cdecl sub_4951C0(_DWORD *a1);
_DWORD *__cdecl sub_4951E0(_DWORD *a1);
char __cdecl sub_495240(int a1);
int __cdecl sub_495290(_DWORD *a1, int a2);
int sub_4954E0();
int __cdecl sub_4954F0(_DWORD *a1);
int __cdecl sub_495710(int a1, _DWORD *a2);
char __cdecl sub_4958C0(int a1);
int __cdecl sub_4959E0(_DWORD *a1, int *a2);
unsigned __int8 __cdecl sub_496060(int (__cdecl ***a1)(_DWORD, _DWORD, _DWORD), unsigned __int8 a2, int a3, int a4);
char __cdecl sub_496340(unsigned __int8 **a1, int a2, int a3, int a4);
int __cdecl sub_496460(int a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_496550(int a1);
int __cdecl sub_496590(_DWORD *a1);
char __cdecl sub_4966E0(_DWORD *a1, _WORD **a2);
char __cdecl sub_496B20(_DWORD *a1);
void __cdecl sub_496BF0(int a1);
int __cdecl sub_496C60(int *a1);
char __cdecl sub_496EE0(_DWORD *a1, _WORD **a2);
char __cdecl sub_497110(_DWORD *a1);
char __cdecl sub_4971A0(_DWORD *a1, int *a2);
char __cdecl sub_497400(_DWORD *a1, _WORD **a2);
char __cdecl sub_497500(_DWORD *a1, int *a2);
int (__cdecl **__cdecl sub_497950(int a1))(int *a1);
int __cdecl sub_4979D0(int *a1);
char __cdecl sub_497C10(int a1, char a2);
int sub_497CA0(); // weak
int __cdecl sub_497DA0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7);
unsigned int __cdecl sub_497E20(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6);
unsigned int __cdecl sub_497ED0(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7);
int __cdecl sub_497F80(int a1);
int __cdecl sub_498180(_DWORD *a1);
_DWORD *__cdecl sub_4981A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7);
_DWORD *__cdecl sub_4982A0(int a1, int a2, int a3, _DWORD *a4);
_DWORD *__cdecl sub_4982B0(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_4982C0(int a1, int a2, char **a3, int *a4);
int __cdecl sub_4983E0(int a1, int a2, int a3, _BYTE ***a4);
int sub_498440(); // weak
int __cdecl sub_4984D0(int a1, int a2, int a3, _BYTE ***a4);
int __cdecl sub_4985A0(int a1, int a2, int a3, int *a4);
char __cdecl sub_498700(int a1);
int __cdecl sub_4988D0(int a1);
int __cdecl sub_498990(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_498AC0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5);
const void **__cdecl sub_498B50(int a1, int *a2, int a3, int a4, int a5);
int __cdecl sub_498B80(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_498BF0(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int nullsub_14(); // weak
int __cdecl sub_498D70(int a1);
int __cdecl sub_498E00(int a1);
int sub_498EC0(); // weak
char __cdecl sub_498EE0(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7);
int __cdecl sub_498FB0(int a1, int a2, int *a3, int a4, int a5, _DWORD *a6);
_BYTE *__cdecl sub_498FF0(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4);
char __cdecl sub_499150(_DWORD *a1, _DWORD *a2, int a3, int a4);
_DWORD *__cdecl sub_499360(int a1);
_DWORD *__cdecl sub_499490(int a1);
char __cdecl sub_499530(_DWORD *a1, char a2);
int __cdecl sub_499650(int a1, unsigned __int8 **a2, int a3, int a4);
_DWORD *__cdecl sub_4996D0(int a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_4997A0(int a1, int a2, int a3, int a4);
int __cdecl sub_4998C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_499AB0(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7);
int __cdecl sub_499C10(_DWORD *a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_499EF0(int a1);
int __cdecl sub_499F20(int a1, int a2);
int __cdecl sub_499FB0(int a1, int *a2);
int __cdecl sub_49A400(int a1, int a2, int a3, int a4);
int *__cdecl sub_49A540(int a1, int a2);
int *__cdecl sub_49A580(int a1, int a2);
int __cdecl sub_49A5B0(int a1, int *a2, int a3);
int nullsub_15(); // weak
int __cdecl sub_49A750(int a1);
int __cdecl sub_49A760(_DWORD *a1);
int __cdecl sub_49A800(_DWORD *a1);
int __cdecl sub_49A960(_DWORD *a1, void *a2);
int __cdecl sub_49AA50(int a1, int a2, int a3, int a4);
int __cdecl sub_49AA70(_DWORD *a1);
int __cdecl sub_49ABB0(int a1, int a2, int a3, int a4);
int __cdecl sub_49ABD0(_DWORD *a1);
int __cdecl sub_49AC10(_DWORD *a1);
int __cdecl sub_49AD00(int a1);
int __cdecl sub_49AD60(int a1, int a2);
int __cdecl sub_49ADD0(_DWORD *a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_49AE90(int a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_49AF50(_DWORD *a1, int a2, void **a3, int a4);
int __cdecl sub_49B080(int a1, int a2, _BYTE **a3, int a4);
int __cdecl sub_49B1B0(_DWORD *a1, int a2, void **a3, int a4);
int nullsub_16(); // weak
int __cdecl sub_49B390(int a1);
int (__cdecl **__cdecl sub_49B3B0(int a1, char a2))(int a1, int a2);
int __cdecl sub_49B440(int a1, int a2);
char __cdecl sub_49B490(_DWORD *a1, int a2, unsigned int *a3, int a4);
int __cdecl sub_49B540(int a1, char a2);
int __cdecl sub_49B610(_DWORD *a1, int a2);
_DWORD *__cdecl sub_49B6C0(_DWORD *a1);
char __cdecl sub_49B710(_DWORD *a1, int a2);
char __cdecl sub_49B970(_DWORD *a1, _DWORD *a2);
char __cdecl sub_49BBC0(_DWORD *a1);
int __cdecl sub_49BDB0(int (__cdecl ***a1)(_DWORD, _DWORD, _DWORD), char a2, int a3, int *a4);
int __cdecl sub_49BFC0(int a1, int a2, int *a3);
_DWORD *__cdecl sub_49C1F0(int a1);
int __cdecl sub_49C230(int a1, char a2);
char __cdecl sub_49C3A0(_DWORD *a1, __int16 **a2);
char __cdecl sub_49C4D0(int a1, __int16 *a2, int a3, int a4, int a5);
char __cdecl sub_49C660(int a1, int a2, int a3);
char __cdecl sub_49C730(_DWORD *a1);
char __cdecl sub_49C760(_DWORD *a1, char a2);
char __cdecl sub_49C7F0(int a1);
int __cdecl sub_49C820(_DWORD *a1);
int sub_49C8A0(); // weak
int __cdecl sub_49C980(int a1, __int16 *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_49CA60(int a1);
int (__cdecl **__cdecl sub_49CB50(int a1))(int a1, char a2);
int __cdecl sub_49CB90(int a1, char a2);
char __cdecl sub_49CD10(int a1, __int16 **a2);
char __cdecl sub_49CE70(int a1, int a2, int a3);
int __cdecl sub_49CF50(_DWORD *a1);
char __cdecl sub_49CF90(int a1, int a2, int a3);
int __cdecl sub_49CFE0(int a1, char a2);
int __cdecl sub_49D090(int a1);
char __cdecl sub_49D0B0(int a1);
char __cdecl sub_49D130(int a1, char *a2, int a3);
char __cdecl sub_49D170(int a1, int *a2);
char __cdecl sub_49D350(int a1, __int16 **a2);
char __cdecl sub_49D410(int a1, int *a2);
int __cdecl sub_49D640(int a1);
int __cdecl sub_49D680(_DWORD *a1);
_DWORD *__cdecl sub_49D760(int a1);
int __cdecl sub_49D800(int *a1);
int __cdecl sub_49D9D0(int a1, int a2, int a3, _WORD *a4, int a5, int a6, int a7);
int __cdecl sub_49DB70(int a1, int a2, int a3, _WORD *a4, int a5, int a6, int a7);
_DWORD *__cdecl sub_49DD30(int a1, char a2);
int sub_49DDE0(); // weak
unsigned int *__cdecl sub_49DE30(_DWORD *a1, int a2, int *a3, unsigned int *a4, int *a5, unsigned int *a6, unsigned int a7);
const void **__cdecl sub_49DFB0(int a1, unsigned int a2, int a3, int a4);
unsigned int __cdecl sub_49DFF0(unsigned int *a1, int a2, unsigned int *a3, unsigned int a4, int a5, unsigned int *a6, unsigned int a7);
int __cdecl sub_49E1C0(int a1);
char __cdecl sub_49E2F0(int a1);
int nullsub_17(); // weak
int __cdecl sub_49E480(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_49E510(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
// void __usercall sub_49E640(int a1@<ebx>, _DWORD *a2, int a3, int a4, int a5);
int sub_49E6A0(); // weak
// int __usercall sub_49E6F0@<eax>(int a1@<ebx>, int a2, int a3, unsigned __int8 **a4, int a5);
int __cdecl sub_49E7A0(int a1, int a2, unsigned __int8 **a3, _DWORD *a4);
unsigned __int8 **__cdecl sub_49E880(int *a1, int a2, int a3, _BYTE **a4);
_DWORD *__cdecl sub_49EB70(int *a1, int a2, int a3, _BYTE **a4);
int __cdecl sub_49ED10(int a1);
int *__cdecl sub_49EF50(int a1);
int __cdecl sub_49F030(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_49F160(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_49F210(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_49F380(int a1, _BYTE **a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_49F3F0(int); // weak
// int __usercall sub_49F3F4@<eax>(int a1@<eax>, int a2, _DWORD *a3, _DWORD *a4, int a5, int a6);
int nullsub_18(); // weak
int __cdecl sub_49F4A0(int a1, char a2);
int __cdecl sub_49F560(_DWORD *a1);
int __cdecl sub_49F730(int a1);
int sub_49FAE0(); // weak
_DWORD *__cdecl sub_49FC80(_DWORD *a1);
int __cdecl sub_49FD80(int *a1);
int __cdecl sub_49FF50(int a1);
int __cdecl sub_49FF80(int a1);
int __cdecl sub_4A0000(int a1, int a2, __int16 *a3, _DWORD *a4, int a5);
int __cdecl sub_4A05F0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5);
int __cdecl sub_4A0AB0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5);
int __cdecl sub_4A0EF0(int a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl sub_4A12A0(int a1, int a2, int a3, _DWORD *a4, int a5);
char __cdecl sub_4A14D0(int a1, int a2, _WORD *a3, _DWORD *a4, int a5);
int *__cdecl sub_4A1510(int a1);
_DWORD *__cdecl sub_4A1910(int a1);
float *__cdecl sub_4A1B60(int a1);
int __cdecl sub_4A1DE0(int a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl _memicmp(const void *Buf1, const void *Buf2, size_t Size);
char *__cdecl _strlwr(char *String);
// double __usercall sub_4A2150@<st0>(double@<st0>); weak
_DWORD __cdecl sub_4A2172(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall test_whether_TOS_is_int(double a1@<st0>);
int fprintf(FILE *const Stream, const char *const Format, ...);
double __cdecl sub_4A23A9(char *Str, _DWORD *a2);
int sscanf(const char *const Buffer, const char *const Format, ...);
// int __usercall _ffexpm1@<eax>(char a1@<ch>, int _EBP@<ebp>);
// double __usercall isintTOS@<st0>(double result@<st0>);
// void __usercall sub_4A2859(int a1@<ebp>);
double __cdecl sub_4A2870(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// double __usercall _startOneArgErrorHandling@<st0>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, double a4@<st0>, __int16 a5, int a6, int a7, int a8);
// double __usercall sub_4A28D0@<st0>(double a1@<st0>);
void sub_4A28E5();
double __fastcall _fload_withFB(int a1, _DWORD *a2);
_DWORD _check_range_exit(); // weak
int __cdecl _powhlp(double, double, int); // idb
int __cdecl _d_inttype(double); // idb
int __cdecl _fltin2(int a1, char *a2);
int __cdecl _input(FILE *File, int, int); // idb
int __cdecl _hextodec_0(int C); // idb
int __cdecl sub_4A36CF(FILE *File);
int __cdecl sub_4A36E9(int Character, FILE *Stream);
int __cdecl _whiteout_0(int, FILE *File); // idb
double __cdecl fdiv_main_routine(_TBYTE a1, _TBYTE a2);
void __cdecl sub_4A38BE();
void __cdecl sub_4A38DA();
void __cdecl sub_4A38EA();
void __cdecl sub_4A38FE();
void __cdecl sub_4A390E();
void __cdecl sub_4A3933();
void __cdecl sub_4A3AE6();
void __cdecl sub_4A3AFA();
void __cdecl sub_4A3B1F();
// void __usercall __spoils<edx,ecx,st0> sub_4A3F21(double a1@<st1>, double a2@<st0>);
// unsigned int __usercall _fprem_common@<eax>(char a1@<dl>, __int128 a2, int a3, int a4, __int128 a5);
// unsigned int __usercall __spoils<ecx,st0> _adj_fprem@<eax>(double a1@<st1>, double a2@<st0>);
// unsigned int __usercall _fprem1_common@<eax>(char a1@<dl>, __int128 a2, int a3, int a4, __int128 a5);
// unsigned int __usercall __spoils<ecx,st0> _adj_fprem1@<eax>(double a1@<st1>, double a2@<st0>);
void __cdecl _87except(int a1, int a2, __int16 *a3);
double __cdecl _copysign(double Number, double Sign);
int __cdecl _fpclass(double X);
size_t __cdecl wcstombs(char *Dest, const wchar_t *Source, size_t MaxCount);
unsigned int __cdecl _mbtowc_lk(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a3);
// int __usercall sub_4A4B60@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
int __cdecl ungetc_0(int Character, FILE *Stream);
double __cdecl ldexp(double a1, double Sign);
// int __usercall sub_4A54A0@<eax>(int a1@<ebp>);
// void __usercall sub_4A54AE(int a1@<ebp>);
// int __usercall sub_4A54BC@<eax>(int a1@<ebp>);
int __cdecl sub_4A5780(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5790(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57A0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57B0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57C0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57D0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57E0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A57F0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5800(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5810(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5820(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5830(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5840(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5850(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5860(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5870(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5880(int a1, int a2, int a3, int a4);
int __cdecl sub_4A5890(int a1, int a2, int a3, int a4);
int __cdecl sub_4A58A0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A58B0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A58C0(int a1, int a2, int a3, int a4);
int __cdecl sub_4A58D0(int a1, int a2, int a3, int a4);
void sub_4C801E();
void sub_4C803A();
int sub_4C8200();
// void __usercall sub_4C8207(int a1@<edx>, int a2@<ebp>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401008; // weak
_UNKNOWN loc_401649; // weak
_UNKNOWN loc_4018C0; // weak
_UNKNOWN loc_401A1C; // weak
_UNKNOWN loc_401AFC; // weak
_UNKNOWN loc_401B53; // weak
_UNKNOWN loc_401E44; // weak
_UNKNOWN loc_401ED3; // weak
_UNKNOWN loc_401F04; // weak
void *off_401FFA = (void *)0x423764; // weak
_UNKNOWN loc_40205C; // weak
_UNKNOWN loc_402125; // weak
_UNKNOWN loc_40231D; // weak
_UNKNOWN loc_40259B; // weak
char byte_402ACE[2] = { '\x90', '\x90' }; // weak
_UNKNOWN loc_402C9E; // weak
_UNKNOWN loc_402D8A; // weak
_UNKNOWN loc_402F68; // weak
_UNKNOWN loc_4031C7; // weak
_UNKNOWN loc_403248; // weak
_UNKNOWN loc_403A5E; // weak
_UNKNOWN loc_40467F; // weak
_UNKNOWN loc_4048D4; // weak
_UNKNOWN loc_404AE3; // weak
_UNKNOWN loc_404C62; // weak
_UNKNOWN loc_404D97; // weak
_UNKNOWN loc_404E33; // weak
_UNKNOWN loc_404ED1; // weak
_UNKNOWN loc_40500A; // weak
_UNKNOWN loc_405146; // weak
_UNKNOWN loc_405197; // weak
char byte_405328[8] = { '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_405419; // weak
_UNKNOWN loc_40546A; // weak
_UNKNOWN loc_40550A; // weak
_UNKNOWN loc_4055AF; // weak
_UNKNOWN loc_4056F6; // weak
_UNKNOWN loc_405DD8; // weak
_UNKNOWN loc_4062EA; // weak
char byte_40639C[4] = { '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_4064FD; // weak
_UNKNOWN loc_406553; // weak
_UNKNOWN loc_4065AE; // weak
_UNKNOWN loc_4066BB; // weak
_UNKNOWN loc_4067C8; // weak
_UNKNOWN loc_406DD4; // weak
_UNKNOWN loc_406EED; // weak
_UNKNOWN loc_407005; // weak
_UNKNOWN loc_407237; // weak
char byte_407298[8] = { '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_407531; // weak
_UNKNOWN loc_407A15; // weak
_UNKNOWN loc_407D29; // weak
_UNKNOWN loc_408000; // weak
_UNKNOWN loc_408047; // weak
char byte_408174[12] =
{
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90',
  '\x90'
}; // weak
_UNKNOWN loc_408435; // weak
_UNKNOWN loc_40849C; // weak
_UNKNOWN loc_408EBD; // weak
_UNKNOWN loc_4095D2; // weak
_UNKNOWN locret_40A109; // weak
_UNKNOWN loc_40EF90; // weak
_UNKNOWN loc_40F443; // weak
_UNKNOWN loc_40F899; // weak
_UNKNOWN loc_40F9D9; // weak
int dword_40FA88[21] =
{
  2089484300,
  -768400348,
  136598665,
  608487270,
  -1962933752,
  609519879,
  609519884,
  1418285072,
  369039396,
  4879280,
  72321894,
  203703433,
  269877073,
  -1962915212,
  -1927535540,
  1711809620,
  170149001,
  539247755,
  -1957556118,
  1342204438,
  369054289
}; // weak
int *off_40FADC = &dword_4A73C4; // weak
_UNKNOWN loc_40FB36; // weak
char byte_40FC98[8] = { '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_410E54; // weak
_UNKNOWN loc_411533; // weak
_UNKNOWN loc_411783; // weak
_UNKNOWN loc_412463; // weak
_UNKNOWN loc_413444; // weak
_UNKNOWN loc_413491; // weak
_UNKNOWN loc_4137CF; // weak
_UNKNOWN loc_414998; // weak
_UNKNOWN loc_414D61; // weak
_UNKNOWN loc_414EA2; // weak
_UNKNOWN loc_4151D1; // weak
_UNKNOWN loc_415317; // weak
_UNKNOWN loc_415649; // weak
_UNKNOWN loc_415A1F; // weak
_UNKNOWN loc_416DB8; // weak
_UNKNOWN loc_418544; // weak
__int16 word_418752 = 14478; // weak
int dword_4196D0[48] =
{
  41316,
  -9830400,
  1247235688,
  -56537088,
  1677741082,
  9609,
  -327090176,
  140,
  -1800369322,
  -2063596761,
  -1961855754,
  1768876238,
  -396951553,
  -57128,
  -1962621821,
  1276836877,
  -1803434240,
  807,
  -1962934272,
  1276836885,
  -1735750400,
  -402652377,
  -39340,
  1276837025,
  -2134483456,
  206836,
  612666112,
  156,
  1819590789,
  -1608217461,
  -1962934272,
  10757268,
  1284046848,
  1080690724,
  270814349,
  136594569,
  -14476312,
  613714943,
  168,
  1284325482,
  166219812,
  1795161891,
  530769964,
  -997982209,
  608471300,
  -943684352,
  9708676,
  0
}; // weak
_UNKNOWN loc_41C821; // weak
_UNKNOWN loc_41CB17; // weak
int dword_41EAC8[62] =
{
  1166617896,
  810978272,
  1442827915,
  1244313824,
  1159790667,
  -1207796756,
  1079413504,
  -215446643,
  -785163970,
  -1995702397,
  913653846,
  1111183544,
  -1803539200,
  -524681216,
  -1956319363,
  -788535219,
  33937655,
  -1173863099,
  282165872,
  -1553013,
  98105296,
  872565716,
  -1948236407,
  -3241005,
  -8134571,
  -1204390644,
  4334784,
  8228909,
  529316352,
  1300966446,
  -137297944,
  -547617320,
  -340131610,
  -1962135086,
  -788535219,
  1929763063,
  -1994837806,
  -745807803,
  1442827915,
  1145474016,
  425196986,
  63974174,
  134185946,
  1977900425,
  -795822025,
  -1070792639,
  -1174405075,
  286101871,
  -1553013,
  98105296,
  85765224,
  52842938,
  -397571119,
  -654847745,
  -1993417467,
  -532313843,
  -1959504245,
  -531234866,
  1097664696,
  -331013888,
  12059259,
  -1960032629
}; // weak
_UNKNOWN loc_41F595; // weak
_UNKNOWN loc_421520; // weak
_UNKNOWN loc_422533; // weak
_UNKNOWN loc_422656; // weak
_UNKNOWN loc_422879; // weak
_UNKNOWN loc_42290D; // weak
_UNKNOWN loc_422A6E; // weak
_UNKNOWN loc_422C83; // weak
_UNKNOWN loc_422CD4; // weak
_UNKNOWN loc_42305F; // weak
_UNKNOWN loc_4233BF; // weak
_UNKNOWN loc_4233E8; // weak
_UNKNOWN loc_423724; // weak
_UNKNOWN loc_423AC3; // weak
_UNKNOWN loc_423E79; // weak
_UNKNOWN loc_424EB7; // weak
_UNKNOWN loc_425091; // weak
_UNKNOWN loc_425F7D; // weak
_UNKNOWN loc_426113; // weak
_UNKNOWN loc_4264CB; // weak
_UNKNOWN loc_4264D8; // weak
int dword_42686C[5] = { -49011, -956273921, 719941, -504889344, -1191182836 }; // weak
_UNKNOWN loc_426895; // weak
_UNKNOWN loc_426908; // weak
_UNKNOWN loc_428CD4; // weak
_UNKNOWN loc_428F9C; // weak
_UNKNOWN loc_42AEC1; // weak
_UNKNOWN loc_42B003; // weak
_UNKNOWN loc_42B3A1; // weak
_UNKNOWN loc_42B3C4; // weak
_UNKNOWN loc_42B60A; // weak
_UNKNOWN loc_42B761; // weak
_UNKNOWN loc_42B7DE; // weak
_UNKNOWN loc_42B9B1; // weak
_UNKNOWN loc_42BAA7; // weak
_UNKNOWN loc_42C104; // weak
_UNKNOWN loc_42ECEE; // weak
_UNKNOWN loc_42EFC6; // weak
_UNKNOWN loc_4330BF; // weak
_UNKNOWN loc_43540C; // weak
_UNKNOWN loc_4354FE; // weak
_UNKNOWN loc_435BE3; // weak
_UNKNOWN loc_436511; // weak
_UNKNOWN loc_436927; // weak
_UNKNOWN loc_43907E; // weak
_UNKNOWN loc_4395BC; // weak
_UNKNOWN loc_43C257; // weak
_UNKNOWN loc_43CAF8; // weak
_UNKNOWN loc_43D738; // weak
_UNKNOWN loc_43D7F8; // weak
_UNKNOWN loc_43D90E; // weak
_UNKNOWN loc_43D9EF; // weak
_UNKNOWN loc_43DA24; // weak
_UNKNOWN loc_43DA58; // weak
_UNKNOWN loc_43DAA0; // weak
_UNKNOWN loc_43DF91; // weak
_UNKNOWN loc_43E2DC; // weak
_UNKNOWN loc_43E96F; // weak
_UNKNOWN loc_43ECBA; // weak
_UNKNOWN locret_43EDD1; // weak
_UNKNOWN loc_43F7BC; // weak
_UNKNOWN loc_43FD44; // weak
_UNKNOWN loc_4401B3; // weak
_UNKNOWN loc_4403ED; // weak
_UNKNOWN loc_4416E5; // weak
_UNKNOWN loc_441DA2; // weak
_UNKNOWN loc_442E90; // weak
_UNKNOWN loc_443562; // weak
_UNKNOWN loc_4448D0; // weak
_UNKNOWN loc_445982; // weak
_UNKNOWN loc_445B68; // weak
_UNKNOWN loc_4479DF; // weak
_UNKNOWN loc_449CFA; // weak
_UNKNOWN loc_449E2B; // weak
_UNKNOWN loc_44A090; // weak
_UNKNOWN loc_44A427; // weak
_UNKNOWN loc_44A689; // weak
_UNKNOWN loc_44DA63; // weak
_UNKNOWN loc_44DDEF; // weak
_UNKNOWN loc_44DE1B; // weak
_UNKNOWN loc_44E13B; // weak
_UNKNOWN loc_44E19A; // weak
_UNKNOWN loc_44E314; // weak
_UNKNOWN loc_44E4C0; // weak
_UNKNOWN loc_44E503; // weak
_UNKNOWN loc_44E807; // weak
_UNKNOWN loc_44E868; // weak
_UNKNOWN loc_44EB73; // weak
_UNKNOWN loc_44EB94; // weak
_UNKNOWN loc_44EC9F; // weak
_UNKNOWN loc_44EDC0; // weak
_UNKNOWN loc_44F148; // weak
int (__stdcall **off_44F154)(int, int) = &off_4AC414; // weak
_UNKNOWN loc_44F774; // weak
_UNKNOWN loc_44FC13; // weak
_UNKNOWN loc_44FF40; // weak
_UNKNOWN loc_451210; // weak
_UNKNOWN loc_45235E; // weak
_UNKNOWN loc_452604; // weak
_UNKNOWN loc_453549; // weak
_UNKNOWN loc_4541F4; // weak
_UNKNOWN loc_454481; // weak
_UNKNOWN loc_45551B; // weak
_UNKNOWN loc_4565C8; // weak
_UNKNOWN loc_45685E; // weak
_UNKNOWN loc_457E5D; // weak
_UNKNOWN loc_458B69; // weak
_UNKNOWN loc_458F55; // weak
_UNKNOWN loc_45DD83; // weak
_UNKNOWN loc_45E6EC; // weak
_UNKNOWN loc_45E9A1; // weak
_UNKNOWN loc_460F9D; // weak
_UNKNOWN loc_461259; // weak
_UNKNOWN loc_461514; // weak
_UNKNOWN loc_4629A9; // weak
_UNKNOWN loc_464126; // weak
_UNKNOWN loc_46428A; // weak
_UNKNOWN loc_464550; // weak
_UNKNOWN loc_464C42; // weak
_UNKNOWN loc_465FCD; // weak
_UNKNOWN loc_468029; // weak
_UNKNOWN loc_46CE56; // weak
_UNKNOWN loc_46CFCE; // weak
_UNKNOWN loc_46D104; // weak
_UNKNOWN loc_46E326; // weak
_UNKNOWN loc_46EBE4; // weak
_UNKNOWN loc_46EECF; // weak
_UNKNOWN loc_47092F; // weak
_UNKNOWN loc_47137C; // weak
_UNKNOWN loc_472243; // weak
_UNKNOWN loc_47388D; // weak
_UNKNOWN loc_4780C7; // weak
_UNKNOWN loc_4789E8; // weak
_UNKNOWN loc_47B33D; // weak
_UNKNOWN loc_47B7DB; // weak
_UNKNOWN loc_47BC7A; // weak
_UNKNOWN loc_47D6C8; // weak
_UNKNOWN loc_47F2D2; // weak
char *off_485E8A = "Can't add Paeth filter after starting"; // weak
_UNKNOWN loc_488397; // weak
_UNKNOWN loc_48C4CE; // weak
_UNKNOWN loc_48C9BB; // weak
_UNKNOWN loc_48CB5F; // weak
_UNKNOWN loc_48D1F5; // weak
_UNKNOWN loc_48D6E6; // weak
_UNKNOWN loc_48DBD7; // weak
_UNKNOWN loc_48E0CF; // weak
_UNKNOWN loc_48E5C4; // weak
_UNKNOWN loc_48E912; // weak
_UNKNOWN loc_48EC63; // weak
_UNKNOWN loc_48EFB3; // weak
_UNKNOWN loc_48F301; // weak
char byte_48F658[8] = { '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_48F9A8; // weak
_UNKNOWN loc_48FCFB; // weak
char byte_48FF74[254] =
{
  '\0',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x05',
  '\x06',
  '\x03',
  '\a',
  '\x03',
  '\x03',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\t',
  '\n',
  '\v',
  '\a',
  '\f',
  '\x0F',
  '\x0F',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0E'
}; // weak
_UNKNOWN loc_4903A4; // weak
_UNKNOWN loc_4906F8; // weak
_UNKNOWN loc_490A4E; // weak
_UNKNOWN loc_490F4C; // weak
_UNKNOWN loc_4912A2; // weak
_UNKNOWN loc_4915FC; // weak
char byte_491957[9] = { '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90', '\x90' }; // weak
_UNKNOWN loc_491CAE; // weak
_UNKNOWN loc_492007; // weak
_UNKNOWN loc_492362; // weak
_UNKNOWN loc_49286A; // weak
_UNKNOWN loc_492A19; // weak
_UNKNOWN loc_492F22; // weak
_UNKNOWN loc_4930D0; // weak
_UNKNOWN loc_49342D; // weak
_UNKNOWN loc_49378B; // weak
_UNKNOWN loc_493AE9; // weak
_UNKNOWN loc_493E48; // weak
_UNKNOWN loc_4941A9; // weak
_UNKNOWN loc_494506; // weak
_UNKNOWN loc_494869; // weak
_UNKNOWN loc_494F2A; // weak
_UNKNOWN loc_4950D8; // weak
_UNKNOWN loc_49543E; // weak
_UNKNOWN loc_4957A2; // weak
_UNKNOWN loc_495953; // weak
_UNKNOWN loc_495B07; // weak
_UNKNOWN loc_495E6B; // weak
_UNKNOWN loc_4961CD; // weak
_UNKNOWN loc_496535; // weak
_UNKNOWN loc_49689D; // weak
_UNKNOWN loc_496A53; // weak
_UNKNOWN loc_496C06; // weak
_UNKNOWN loc_496F6E; // weak
_UNKNOWN loc_4972D6; // weak
_UNKNOWN loc_49748C; // weak
_UNKNOWN loc_4979AB; // weak
_UNKNOWN loc_497D13; // weak
_UNKNOWN loc_49807E; // weak
_UNKNOWN loc_4983EC; // weak
_UNKNOWN loc_498AC1; // weak
_UNKNOWN loc_49919E; // weak
_UNKNOWN loc_4996C5; // weak
_UNKNOWN loc_49987B; // weak
_UNKNOWN loc_499BEC; // weak
_UNKNOWN loc_49A112; // weak
_UNKNOWN loc_49A2CE; // weak
_UNKNOWN loc_49A9B1; // weak
_UNKNOWN loc_49AEE0; // weak
_UNKNOWN loc_49BE6E; // weak
_UNKNOWN loc_49C025; // weak
_UNKNOWN loc_49C718; // weak
_UNKNOWN loc_49CA8F; // weak
_UNKNOWN loc_49F9A2; // weak
_UNKNOWN loc_4A1075; // weak
_UNKNOWN loc_4A43B7; // weak
_UNKNOWN loc_4A626E; // weak
_UNKNOWN loc_4A62A7; // weak
_UNKNOWN loc_4A62EB; // weak
char byte_4A6AF7; // weak
char byte_4A6FF1[3]; // weak
int (__stdcall *dword_4A7000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x758B4823; // weak
int (__stdcall *dword_4A7004)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x758B483B; // weak
int (__stdcall *dword_4A7008)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x758CA219; // weak
int (__stdcall *dword_4A700C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x758ACEB1; // weak
int (__cdecl *dword_4A7010)(_DWORD) = (int (__cdecl *)(_DWORD))0x758B405E; // weak
int (__cdecl *dword_4A7014)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x758B408E; // weak
int (__stdcall *dword_4A7018)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x758ACC69; // weak
int (__stdcall *dword_4A701C)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x758CA46A; // weak
int (__stdcall *dword_4A7020)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x758B13E3; // weak
int (__stdcall *dword_4A7024)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x758CA434; // weak
int (__stdcall *dword_4A7028)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x758ACB7D; // weak
int (__stdcall *dword_4A702C)(_DWORD) = (int (__stdcall *)(_DWORD))0x758B45CD; // weak
int (__cdecl *dword_4A7030)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x758B4016; // weak
int (__cdecl *dword_4A7034)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x758B4550; // weak
int (__cdecl *dword_4A7038)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x758B44FD; // weak
int (__cdecl *dword_4A703C)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x758C7167; // weak
int (__cdecl *dword_4A7040)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x758B40A6; // weak
int (*dword_4A7048)(void) = (int (*)(void))0x6D1B1739; // weak
int dword_4A7064 = 1980938881; // weak
int (__stdcall *dword_4A7068)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x7612B99A; // weak
int (__stdcall *dword_4A706C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x76126FDC; // weak
int (__stdcall *dword_4A7070)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x76125F48; // weak
int (__stdcall *dword_4A7074)(_DWORD) = (int (__stdcall *)(_DWORD))0x761254F4; // weak
int (__stdcall *dword_4A7078)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x76124F70; // weak
int (__stdcall *dword_4A707C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x76125EA5; // weak
int (__stdcall *dword_4A7080)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x76126000; // weak
int (__stdcall *dword_4A7084)(_DWORD) = (int (__stdcall *)(_DWORD))0x761258B3; // weak
int (__stdcall *dword_4A7088)(_DWORD) = (int (__stdcall *)(_DWORD))0x76125689; // weak
int (*dword_4A708C)(void) = (int (*)(void))0x76124EB8; // weak
int (__stdcall *dword_4A7094)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA27EC; // weak
int (*dword_4A7098)(void) = (int (*)(void))0x75BA110C; // weak
int (__stdcall *dword_4A70A4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BBB748; // weak
int (*dword_4A70A8)(void) = (int (*)(void))0x75BA44D6; // weak
int (__stdcall *dword_4A70AC)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA4B6B; // weak
int (*dword_4A70B0)(void) = (int (*)(void))0x75BA1430; // weak
int (__stdcall *dword_4A70B4)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA111E; // weak
int (__stdcall *dword_4A70B8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA7A47; // weak
int (__stdcall *dword_4A70CC)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA1701; // weak
int (__stdcall *dword_4A70D0)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA2654; // weak
int (__stdcall *dword_4A70D4)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA24D7; // weak
int (__stdcall *dword_4A70D8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA1222; // weak
int (__stdcall *dword_4A70DC)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA48D7; // weak
int (__stdcall *dword_4A70E0)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75C1AEC4; // weak
int (__stdcall *dword_4A70E4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA278F; // weak
int (__stdcall *dword_4A70E8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BBDA40; // weak
int (__stdcall *dword_4A70EC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BBD034; // weak
int (__stdcall *dword_4A70F0)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA1962; // weak
int (*dword_4A70F4)(void) = (int (*)(void))0x75BA11F8; // weak
int (__cdecl *dword_4A70F8)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x75BA1072; // weak
int (__cdecl *dword_4A70FC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA50A1; // weak
int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA1491; // weak
int (__stdcall *dword_4A7104)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA17E5; // weak
int (__cdecl *dword_4A7108)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x75BC28D8; // weak
int (__cdecl *dword_4A710C)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BA8B85; // weak
int (__stdcall *dword_4A7110)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA1802; // weak
int (__stdcall *dword_4A7114)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BB1874; // weak
int (__stdcall *dword_4A7118)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA18CD; // weak
int (__stdcall *dword_4A711C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA5EF6; // weak
int (__cdecl *dword_4A7120)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x75BA5A06; // weak
int (__stdcall *dword_4A7124)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA48CA; // weak
int (__stdcall *dword_4A7128)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BC2C7A; // weak
int (__stdcall *dword_4A712C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA5B6A; // weak
int (__stdcall *dword_4A7130)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA51D6; // weak
int (__stdcall *dword_4A7134)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BBD044; // weak
int (__stdcall *dword_4A7138)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BBD107; // weak
int (__stdcall *dword_4A713C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BC6F43; // weak
int (__stdcall *dword_4A7140)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA3BB8; // weak
int (__stdcall *dword_4A7144)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA3C48; // weak
int (__stdcall *dword_4A7148)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA3C30; // weak
int (__stdcall *dword_4A7150)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA4074; // weak
int (__cdecl *dword_4A7154)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA24E4; // weak
int (__stdcall *dword_4A7158)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA5E34; // weak
int (*dword_4A715C)(void) = (int (*)(void))0x75BA1778; // weak
int (*dword_4A7160)(void) = (int (*)(void))0x75BA3D93; // weak
int (__stdcall *dword_4A7164)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BC29E8; // weak
int (__stdcall *dword_4A7168)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BBD645; // weak
int (__stdcall *dword_4A716C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA4502; // weak
int (__stdcall *dword_4A7170)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BBCEAE; // weak
int (__stdcall *dword_4A7174)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA5089; // weak
int (__stdcall *dword_4A7178)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA1922; // weak
int (__stdcall *dword_4A717C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BC83C6; // weak
int (__stdcall *dword_4A7180)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BC2CA4; // weak
int (__stdcall *dword_4A7184)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA2540; // weak
int (__stdcall *dword_4A7188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA50B3; // weak
int (__cdecl *dword_4A718C)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BACB69; // weak
int (*dword_4A7190)(void) = (int (*)(void))0x75BA50E3; // weak
int (*dword_4A7194)(void) = (int (*)(void))0x75BAE3A1; // weak
int (__stdcall *dword_4A7198)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA50CB; // weak
int (__stdcall *dword_4A719C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BAE389; // weak
int (__stdcall *dword_4A71A0)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BC788F; // weak
int (__stdcall *dword_4A71A4)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x77DE46B0; // weak
int (__stdcall *dword_4A71A8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA1795; // weak
int (__stdcall *dword_4A71AC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BCC7F1; // weak
int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA190A; // weak
int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA16E9; // weak
int (__stdcall *dword_4A71B8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BCBC94; // weak
int (__stdcall *dword_4A71BC)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA1832; // weak
int (__stdcall *dword_4A71C0)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA184A; // weak
int (__stdcall *dword_4A71C4)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA492D; // weak
int (__stdcall *dword_4A71C8)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA25C6; // weak
int (__stdcall *dword_4A71CC)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA2528; // weak
int (__stdcall *dword_4A71D0)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA3423; // weak
int (__stdcall *dword_4A71D4)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA11A9; // weak
int (__stdcall *dword_4A71E0)(_DWORD) = (int (__stdcall *)(_DWORD))0x77DD22B0; // weak
int (__stdcall *dword_4A71E4)(_DWORD) = (int (__stdcall *)(_DWORD))0x77DD22F0; // weak
int dword_4A71E8 = 2011053453; // weak
int (__stdcall *dword_4A71EC)(_DWORD) = (int (__stdcall *)(_DWORD))0x77DE42F0; // weak
int (*dword_4A71F0)(void) = (int (*)(void))0x75BA0E00; // weak
int (__stdcall *dword_4A71F4)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA1245; // weak
int (__cdecl *dword_4A71F8)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BA5A1E; // weak
int (__stdcall *dword_4A71FC)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BBD862; // weak
int (__stdcall *dword_4A7200)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA7A28; // weak
int (__stdcall *dword_4A7204)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA13E0; // weak
int (__stdcall *dword_4A7208)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BAE371; // weak
int (__stdcall *dword_4A720C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA13D0; // weak
int (__stdcall *dword_4A7210)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77DEC7A0; // weak
int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x77DDE0E6; // weak
int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BA14A9; // weak
int (*dword_4A7220)(void) = (int (*)(void))0x75BA16A1; // weak
int (__cdecl *dword_4A7224)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BA17C8; // weak
int (__cdecl *dword_4A7228)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BA281B; // weak
int (__cdecl *dword_4A722C)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x75BA1136; // weak
int dword_4A7244 = 1975304142; // weak
int (__stdcall *dword_4A7248)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75C24DDF; // weak
int (__stdcall *dword_4A7254)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BBCE96; // weak
int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA3FE5; // weak
int (__stdcall *dword_4A725C)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA194A; // weak
int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA11C0; // weak
int (__stdcall *dword_4A7268)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BAE2DE; // weak
int (__stdcall *dword_4A726C)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BCBFE6; // weak
int (__stdcall *dword_4A7270)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BAE30E; // weak
int (__stdcall *dword_4A7274)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA44B1; // weak
int (__cdecl *dword_4A7278)(_DWORD) = (int (__cdecl *)(_DWORD))0x75BA48AD; // weak
int (__stdcall *dword_4A727C)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA14DB; // weak
int (__stdcall *dword_4A7280)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BCBB1B; // weak
int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA5DB6; // weak
int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x75BA17AD; // weak
int (__stdcall *dword_4A728C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA1282; // weak
int (__stdcall *dword_4A7290)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA11E0; // weak
int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA5A2E; // weak
int (__stdcall *dword_4A7298)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x75BA51EE; // weak
int (__stdcall *dword_4A729C)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA13F0; // weak
int (__stdcall *dword_4A72A0)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x75BBE8CB; // weak
int (__stdcall *dword_4A72A4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA5294; // weak
int (__stdcall *dword_4A72A8)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA52A1; // weak
int (__stdcall *dword_4A72AC)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x75BA5A51; // weak
int (*dword_4A72B0)(void) = (int (*)(void))0x75BCBC49; // weak
int (__stdcall *dword_4A72B4)(_DWORD) = (int (__stdcall *)(_DWORD))0x75BA10FF; // weak
int (__stdcall *dword_4A72BC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x76CE8790; // weak
int (__stdcall *dword_4A72C4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77707D2F; // weak
int (__stdcall *dword_4A72C8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77710E13; // weak
int (__stdcall *dword_4A72CC)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77715B89; // weak
int (*dword_4A72D0)(void) = (int (*)(void))0x77712942; // weak
int (__stdcall *dword_4A72D4)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x777171E0; // weak
int (__stdcall *dword_4A72D8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x77708E4E; // weak
int (__stdcall *dword_4A72DC)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x777162B2; // weak
int (__stdcall *dword_4A72E0)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77716114; // weak
int (__stdcall *dword_4A72E4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x7770D166; // weak
int (__stdcall *dword_4A72E8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77710C7A; // weak
int (__cdecl *dword_4A72EC)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x777194D8; // weak
int (__stdcall *dword_4A72F4)(_DWORD) = (int (__stdcall *)(_DWORD))0x7775FDAE; // weak
int (__stdcall *dword_4A72F8)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x7771247E; // weak
int (__stdcall *dword_4A72FC)(_DWORD) = (int (__stdcall *)(_DWORD))0x7771872B; // weak
int (__stdcall *dword_4A7300)(_DWORD) = (int (__stdcall *)(_DWORD))0x7772D592; // weak
int (__stdcall *dword_4A7304)(_DWORD) = (int (__stdcall *)(_DWORD))0x77713710; // weak
int (__stdcall *dword_4A7308)(_DWORD) = (int (__stdcall *)(_DWORD))0x77713AFE; // weak
int (__stdcall *dword_4A730C)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x7770FFFE; // weak
int (*dword_4A7310)(void) = (int (*)(void))0x77713A02; // weak
int (__cdecl *dword_4A7314)(_DWORD) = (int (__cdecl *)(_DWORD))0x77711230; // weak
int (__stdcall *dword_4A7318)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77717355; // weak
int (__stdcall *dword_4A731C)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x7771CC3E; // weak
int (__stdcall *dword_4A7320)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x777298FC; // weak
int (__stdcall *dword_4A7324)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x777079FB; // weak
int (__stdcall *dword_4A7328)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x777079DB; // weak
int (__stdcall *dword_4A732C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x7772A072; // weak
int (__stdcall *dword_4A7330)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x777139C9; // weak
int (__stdcall *dword_4A7334)(_DWORD) = (int (__stdcall *)(_DWORD))0x77749FA4; // weak
int (__cdecl *dword_4A7338)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x7770DB0B; // weak
int (*dword_4A733C)(void) = (int (*)(void))0x7770DAE5; // weak
int dword_4A7340 = 2003890145; // weak
int dword_4A7344 = 2004030075; // weak
int (__stdcall *dword_4A7348)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x7774CBA4; // weak
int (__stdcall *dword_4A734C)(_DWORD) = (int (__stdcall *)(_DWORD))0x77715026; // weak
int (__stdcall *dword_4A7350)(_DWORD) = (int (__stdcall *)(_DWORD))0x77711F9D; // weak
int (__stdcall *dword_4A7354)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x777171FE; // weak
int (__stdcall *dword_4A7358)(_DWORD) = (int (__stdcall *)(_DWORD))0x7771392D; // weak
int (__stdcall *dword_4A735C)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77718F4C; // weak
int (__stdcall *dword_4A7360)(_DWORD) = (int (__stdcall *)(_DWORD))0x77719E8B; // weak
int dword_4A7364 = 2003913660; // weak
int (*dword_4A7368)(void) = (int (*)(void))0x77719E4D; // weak
int (*dword_4A736C)(void) = (int (*)(void))0x77767D51; // weak
int (__stdcall *dword_4A7370)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77748E6F; // weak
int (__stdcall *dword_4A7374)(_DWORD) = (int (__stdcall *)(_DWORD))0x77714713; // weak
int (__stdcall *dword_4A7378)(_DWORD) = (int (__stdcall *)(_DWORD))0x7771C79E; // weak
int (__stdcall *dword_4A737C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x77717044; // weak
int (__stdcall *dword_4A7380)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77707BD3; // weak
int (__stdcall *dword_4A7384)(_DWORD) = (int (__stdcall *)(_DWORD))0x77707809; // weak
int (__stdcall *dword_4A7388)(_DWORD) = (int (__stdcall *)(_DWORD))0x77707BBB; // weak
int (__stdcall *dword_4A738C)(_DWORD) = (int (__stdcall *)(_DWORD))0x77712797; // weak
int (*dword_4A7390)(void) = (int (*)(void))0x7771541E; // weak
int (__stdcall *dword_4A7394)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x7770D23E; // weak
int (__stdcall *dword_4A7398)(_DWORD) = (int (__stdcall *)(_DWORD))0x77709A55; // weak
int (__stdcall *dword_4A739C)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77DECD12; // weak
int (__stdcall *dword_4A73A4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x70472D1D; // weak
int (__stdcall *dword_4A73AC)(_DWORD) = (int (__stdcall *)(_DWORD))0x77853918; // weak
int (__stdcall *dword_4A73B0)(_DWORD) = (int (__stdcall *)(_DWORD))0x77852D57; // weak
int (__stdcall *dword_4A73B4)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x77852D57; // weak
int (__stdcall *dword_4A73C0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x704A1808; // weak
int (__stdcall *dword_4A73C4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x778534B5; // weak
int (__stdcall *dword_4A73C8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x7785669F; // weak
int (__cdecl *dword_4A73D4)(_DWORD) = (int (__cdecl *)(_DWORD))0x7785311B; // weak
int (*dword_4A73D8)(void) = (int (*)(void))0x7786771B; // weak
int (__stdcall *dword_4A73E0)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x77856C19; // weak
int (__stdcall *dword_4A73EC)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x778530AF; // weak
int (__stdcall *dword_4A73F4)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x778568F5; // weak
int (__stdcall *dword_4A73F8)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x77854582; // weak
int (__stdcall *dword_4A73FC)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x77853EB8; // weak
int (__stdcall *dword_4A7400)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x704A18E0; // weak
int (__stdcall *dword_4A7404)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x77853084; // weak
int (*dword_4A7408)(void) = (int (*)(void))0x778537AD; // weak
int (__cdecl *dword_4A740C)(_DWORD) = (int (__cdecl *)(_DWORD))0x77852D8B; // weak
int (__stdcall *dword_4A7410)(_DWORD) = (int (__stdcall *)(_DWORD))0x77852D8B; // weak
int dword_4A743C[] = { 0 }; // weak
_UNKNOWN unk_4A7440; // weak
char byte_4A7A3C[236] =
{
  '\0',
  '^',
  '',
  '',
  'a',
  '?',
  '',
  '',
  '',
  '',
  '~',
  ' ',
  '',
  '',
  '\x1F',
  'A',
  '\x9D',
  '',
  '!',
  '\x7F',
  '',
  '',
  '@',
  '\x1E',
  '_',
  '\x01',
  '',
  '',
  '>',
  '`',
  '',
  '',
  '#',
  '}',
  '',
  '',
  'B',
  '\x1C',
  '',
  '',
  '',
  '',
  ']',
  '\x03',
  '',
  '',
  '<',
  'b',
  '',
  '',
  '\x02',
  '\\',
  '',
  '\x81',
  'c',
  '=',
  '|',
  '\"',
  '',
  '',
  '\x1D',
  'C',
  '',
  '\xFF',
  'F',
  '\x18',
  '',
  '',
  '\'',
  'y',
  '',
  '',
  '',
  '',
  '8',
  'f',
  '',
  '',
  'Y',
  '\a',
  '',
  '',
  'g',
  '9',
  '',
  '',
  '\x06',
  'X',
  '\x19',
  'G',
  '',
  '',
  'x',
  '&',
  '',
  '',
  'e',
  ';',
  '',
  '',
  '\x04',
  'Z',
  '',
  '',
  '',
  '',
  '\x1B',
  'E',
  '',
  '',
  'z',
  '$',
  '',
  '',
  'D',
  '\x1A',
  '',
  '',
  '%',
  '{',
  ':',
  'd',
  '',
  '',
  '[',
  '\x05',
  '',
  '',
  '',
  '',
  '0',
  'n',
  '',
  '',
  'Q',
  '\x0F',
  'N',
  '\x10',
  '',
  '',
  '/',
  'q',
  '',
  '',
  '\x11',
  'O',
  '',
  '',
  'p',
  '.',
  '',
  '',
  '',
  '\x8D',
  'o',
  '1',
  '',
  '',
  '\x0E',
  'P',
  '',
  '',
  '\x13',
  'M',
  '',
  '\x90',
  'r',
  ',',
  'm',
  '3',
  '',
  '\x8F',
  '\f',
  'R',
  '',
  '',
  '2',
  'l',
  '',
  '',
  'S',
  '\r',
  '',
  '',
  '',
  '',
  'L',
  '\x12',
  '',
  '',
  '-',
  's',
  '',
  '',
  'v',
  '(',
  '',
  '',
  '\x17',
  'I',
  '\b',
  'V',
  '',
  '',
  'i',
  '7',
  '',
  '',
  'W',
  '\t',
  '',
  '',
  '6',
  'h',
  '',
  '',
  '',
  '',
  ')',
  'w',
  '',
  '',
  'H',
  '\x16',
  '',
  '',
  'U',
  '\v',
  '',
  '',
  '4',
  'j',
  '+',
  'u',
  '',
  ''
}; // idb
int dword_4A7B28[21] =
{
  -1460267958,
  -1765266828,
  -139900139,
  1410001078,
  896240087,
  3,
  2,
  1,
  0,
  0,
  3,
  2,
  1,
  0,
  1,
  3,
  2,
  0,
  1,
  2,
  3
}; // idb
int (__stdcall *off_4A7B7C)(char) = &sub_401BF0; // weak
void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int) = &std::locale::facet::`scalar deleting destructor'; // weak
char aDirectdrawSetc_0[34] = "DirectDraw::SetClipper failed %x\n"; // weak
char aDirectdrawSetc_1[27] = "DirectDraw::SetClipper %s\n"; // weak
int (*off_4A7BE0)() = &sub_402120; // weak
char aDirectdrawDMod[28] = "DirectDraw: %d modes found\n"; // weak
char aDirectdrawEnum[24] = "DirectDraw: Enum modes\n"; // weak
char aDirectdrawCrea_0[41] = "DirectDraw: Creating Direct draw object\n"; // weak
char aDirectdrawSetp[42] = "DirectDraw: SetPalette backbuf failed %x\n"; // weak
char aDirectdrawSetp_0[34] = "DirectDraw: SetPalette failed %x\n"; // weak
char aDirectdrawCrea[26] = "DirectDraw::CreatePalette"; // weak
char aDirectdrawClea[38] = "DirectDraw: ClearSurface failed (%x)\n"; // weak
char aDirectdrawSurf[31] = "DirectDraw: Surfaces restored\n"; // weak
char aDirectdrawVide[50] = "DirectDraw: Video mode %dx%d %d bits; %d bytes%s\n"; // weak
char byte_4A7DB0[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  ';',
  ' ',
  'F',
  'l',
  'i',
  'p',
  'p',
  'i',
  'n',
  'g',
  '\0',
  '\0'
}; // idb
int (__stdcall *off_4A7DC0)(char) = &sub_405190; // weak
char aDirectdrawSetd[27] = "DirectDraw::SetDisplayMode"; // weak
char aDirectdrawSetc[45] = "DirectDraw: SetCooperativeLevel failed (%x)\n"; // weak
char aDirectdrawQuer[32] = "DirectDraw: Query IDirectDraw2\n"; // weak
char aNoModes[9] = "No modes"; // weak
char aDirectdrawSetm[34] = "DirectDraw: SetMode(%d,%d,%d,%d)\n"; // weak
double dbl_4A8240 =  10.0; // weak
char aDirectdrawRepa[21] = "DirectDraw: Repaint\n"; // weak
int (__stdcall *off_4A8328)(char) = &sub_405190; // weak
char aNoPalette[12] = "No palette\n"; // weak
void *CxFile::`vftable' = &sub_459AB0; // weak
void *CxMemFile::`vftable' = &sub_459C10; // weak
char aSpriteReloadCr[32] = "Sprite: Reload CRC mismatch %s\n"; // weak
char aSpriteSprite[15] = "Sprite::Sprite"; // weak
_UNKNOWN unk_4A84B6; // weak
int (*off_4A8580)() = &sub_405FA0; // weak
unsigned __int16 word_4A858E[101] =
{
  64u,
  26948u,
  25970u,
  29795u,
  28499u,
  28277u,
  14948u,
  20768u,
  25973u,
  31090u,
  28233u,
  25972u,
  26226u,
  25441u,
  8293u,
  17459u,
  26956u,
  29811u,
  28261u,
  29285u,
  26144u,
  26977u,
  25964u,
  8292u,
  9512u,
  10616u,
  10u,
  26948u,
  25970u,
  29795u,
  28499u,
  28277u,
  14948u,
  17184u,
  25970u,
  29793u,
  21349u,
  30063u,
  25710u,
  30018u,
  26214u,
  29285u,
  10272u,
  29296u,
  28009u,
  29281u,
  10617u,
  26144u,
  26977u,
  25964u,
  8292u,
  9512u,
  10616u,
  10u,
  0u,
  26948u,
  25970u,
  29795u,
  28499u,
  28277u,
  14948u,
  21280u,
  29797u,
  28483u,
  28783u,
  29285u,
  29793u,
  30313u,
  19557u,
  30309u,
  27749u,
  26144u,
  26977u,
  25964u,
  8292u,
  9512u,
  10616u,
  10u,
  0u,
  26948u,
  25970u,
  29795u,
  28499u,
  28277u,
  14948u,
  17440u,
  29289u,
  25445u,
  21364u,
  30063u,
  25710u,
  29251u,
  24933u,
  25972u,
  26144u,
  26977u,
  25964u,
  8292u,
  9512u,
  10616u,
  10u
}; // idb
int (*off_4A8658)() = &sub_406930; // weak
double dbl_4A8680 =  3183.098861837907; // weak
char aDirectsoundRel[27] = "DirectSound: Reloading %s\n"; // weak
char aData[5] = "data"; // weak
char aFmt[5] = "fmt "; // weak
char aWave[5] = "WAVE"; // weak
char aRiff[5] = "RIFF"; // weak
char aUnknownError[14] = "Unknown error"; // weak
char aTxtNull[10] = "txt==NULL"; // weak
char aCSrcIncExceptC[22] = "C:\\SRC\\Inc\\Except.cpp"; // weak
char Source[] = "Not enough memory"; // idb
int (__stdcall *off_4A87AC)(char) = &sub_407060; // weak
char aFalse[6] = "false"; // weak
char aMemoryError[13] = "Memory error"; // weak
int (__stdcall *off_4A87CC)(char) = &sub_4070F0; // weak
char aFile[5] = "file"; // weak
char aUnknownFileErr[19] = "Unknown file error"; // weak
char aFileWriteError[17] = "File write error"; // weak
char aDiskFull[10] = "Disk full"; // weak
char aFileReadError[16] = "File read error"; // weak
char aUnableToCreate[18] = "Unable to create "; // weak
char aUnableToOpen[] = "Unable to open "; // idb
char aDioxxuc[] = "dioxXuc"; // idb
char Str[] = "-+0 #"; // idb
int (__stdcall *off_4A8854)(char) = &sub_407500; // weak
char aError[6] = "Error"; // weak
char aExceptionS[15] = "EXCEPTION: %s\n"; // weak
char aStackDump_0[21] = "    Stack Dump      "; // weak
char aGetlocaltime[15] = "GetLocalTime  "; // weak
char aBottomstackdum[21] = "    BottomStackDump "; // weak
char aContextrecord[17] = "ContextRecord   "; // weak
char aExceptionrecor[17] = "ExceptionRecord "; // weak
char aExceptionLog[14] = "exception.log"; // weak
char aHandleHandle1[19] = "Handle==(HANDLE)-1"; // weak
char aCSrcIncWinFile[24] = "C:\\SRC\\Inc\\win\\File.cpp"; // weak
char aAsyncFileQueue[25] = "Async file queue is full"; // weak
char aImageCreateNot[43] = "IMAGE::Create: not implemented bit depth 4"; // weak
char aImageFillNotIm[41] = "IMAGE::Fill: Not implemented bit depth 4"; // weak
char aImageConvert32[162] = "IMAGE::Convert32BitToX: Bit depths 4 & 8 are not supported because heckbert class is not included. To enable bit depths 4 & 8 define DIMENSIONS=4 in project file"; // weak
char aImageLoadFaile[40] = "IMAGE::Load failed. Unknown file format"; // weak
int (__stdcall *off_4A8B9C[2])(int) = { &sub_40A520, &sub_40A540 }; // weak
char aImageWriteFail[41] = "IMAGE::Write failed. Unknown file format"; // weak
int (*off_4A8BDC)() = &sub_40A700; // weak
char aImageReadFaile[40] = "IMAGE::Read failed: Buffer is too small"; // weak
char aImageGetrgbUns[38] = "IMAGE::GetRgb unsupported bit depth 4"; // weak
char aImageCropNotIm[41] = "IMAGE::Crop: not implemented bit depth 4"; // weak
double dbl_4A8C90 =  2.220446049250313e-16; // weak
int dword_4A8C98[11] = { 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
char aD[3] = "%d"; // weak
char aHooksSizeofHoo[35] = "Hooks<(sizeof(Hook)/sizeof(*Hook))"; // weak
char aCSrcIncMiscCpp[20] = "C:\\SRC\\Inc\\Misc.cpp"; // weak
char Format[] = "\r\nLogging started (%s) %02d-%02d-%04d %d:%02d:%02d\r\n"; // idb
char aS_1[] = "%s\n"; // idb
char a08x_0[] = " %08x"; // idb
char a08x[] = "%08x:"; // idb
char asc_4A8DE0[2] = "\n"; // weak
char aStackDump[13] = "Stack dump:\n"; // weak
char asc_4A8DF8[3] = ".."; // weak
char aSocketSErrorD[21] = "Socket: %s error %d\n"; // weak
char aListenListen[14] = "Listen/listen"; // weak
char aSocketSelectEr[39] = "Socket: Select error %d for socket %d\n"; // weak
char aSocksUdpsock[15] = "Socks->UdpSock"; // weak
char aFd1[7] = "Fd==-1"; // weak
char aCSrcIncSocketC[22] = "C:\\SRC\\Inc\\Socket.cpp"; // weak
char aSocketSocksErr[28] = "Socket: Socks error %d%s%s\n"; // weak
char a02x[] = "%02x "; // idb
char aCreatemutexFai[19] = "CreateMutex failed"; // weak
char aMutexAcquirePo[48] = "Mutex::Acquire: possible deadlock in thread %u\n"; // weak
char aWWaitObject0WW[36] = "w==WAIT_OBJECT_0 || w==WAIT_TIMEOUT"; // weak
char aCSrcIncWinTask[27] = "C:\\SRC\\Inc\\win\\Tasking.cpp"; // weak
char aReleasemutexHa[27] = "ReleaseMutex(Handle)==TRUE"; // weak
char aCreateeventFai[19] = "CreateEvent failed"; // weak
char aHead0_0[8] = "Head==0"; // weak
char aHead0[8] = "Head!=0"; // weak
char aTail0_0[8] = "Tail==0"; // weak
char aTail0[8] = "Tail!=0"; // weak
int (*off_4A9110)() = &sub_46D263; // weak
char aThreadSThreadS[27] = "Thread: %s thread stopped\n"; // weak
char aThreadSThreadD[56] = "Thread: %s thread didn't exit gracefully. Terminating.\n"; // weak
char aThreadSUThread[32] = "Thread: %s (%u) thread started\n"; // weak
char aCreateSThreadF[24] = "Create %s thread failed"; // weak
char aUnnamed[8] = "unnamed"; // weak
double dbl_4A91B8 =  0.0; // weak
double dbl_4A91C0 =  1000.0; // weak
double dbl_4A91C8 =  1.0; // weak
int dword_4A91D8 = 1044851090; // weak
char byte_4A91DC[24] =
{
  '',
  '\x1F',
  '',
  '\t',
  '',
  ')',
  '',
  '\x18',
  '',
  '\x15',
  '',
  '\x05',
  '',
  '\0',
  '',
  '\r',
  '',
  '\r',
  '',
  '\x1F',
  '',
  'l',
  '\0',
  '\0'
}; // idb
int dword_4A91F4 = 2139973798; // weak
char byte_4A91F8[20] =
{
  'g',
  '^',
  'C',
  'C',
  's',
  '@',
  'E',
  'B',
  'h',
  'C',
  'c',
  'N',
  'r',
  'D',
  'i',
  'C',
  'u',
  'l',
  '\x06',
  '\0'
}; // idb
unsigned __int8 byte_4A920C[16] =
{
  170u,
  147u,
  212u,
  164u,
  201u,
  165u,
  201u,
  166u,
  193u,
  229u,
  154u,
  248u,
  204u,
  186u,
  196u,
  214u
}; // idb
int dword_4A921C = -444072879; // weak
char byte_4A9220[] = { '3' }; // weak
int dword_4A9228 = 501484785; // weak
char byte_4A922C[4] = { '\x1F', '\x19', '\\', '\0' }; // idb
int dword_4A9230[] = { -1443843983 }; // weak
char byte_4A9234[12] = { '0', '\x90', '\x02', '', '\x17', '\x90', '(', '', '7', '', 't', '\0' }; // idb
unsigned __int8 byte_4A9240[16] =
{
  68u,
  180u,
  185u,
  166u,
  127u,
  178u,
  99u,
  159u,
  120u,
  131u,
  99u,
  157u,
  12u,
  0u,
  0u,
  0u
}; // idb
int (*off_4A9250)() = &sub_412C50; // weak
unsigned __int8 byte_4A9258[16] =
{
  242u,
  152u,
  157u,
  170u,
  193u,
  178u,
  209u,
  182u,
  129u,
  239u,
  156u,
  185u,
  222u,
  177u,
  178u,
  0u
}; // idb
_UNKNOWN unk_4A9268; // weak
_UNKNOWN unk_4A9468; // weak
char *off_4A95D8 = "over1.bm2"; // weak
char *off_4A9678 = "shrtfont.bm2"; // weak
char *off_4A9698 = "shrtfontf.bm2"; // weak
char byte_4A9778[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01'
}; // idb
char byte_4A9878[16] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
char *off_4A9978 = "bg01.bm2"; // weak
int dword_4A9984 = 2; // weak
char *off_4A9C18 = "explode2.bm2"; // weak
int dword_4A9C24[53] =
{
  132,
  0,
  0,
  0,
  0,
  4898400,
  5,
  2,
  50,
  0,
  0,
  0,
  0,
  4898388,
  5,
  2,
  60,
  0,
  0,
  0,
  0,
  4898372,
  7,
  1,
  49,
  0,
  0,
  0,
  0,
  4898356,
  6,
  6,
  102,
  0,
  0,
  0,
  0,
  4898340,
  6,
  1,
  18,
  0,
  0,
  0,
  0,
  4898328,
  6,
  3,
  48,
  0,
  0,
  0,
  0
}; // idb
char *off_4A9CF8 = "mines.bm2"; // weak
char *off_4A9D78 = "shield.bm2"; // weak
char *off_4A9E18 = "junkwb.bm2"; // weak
char *off_4A9F18 = "ship1.bm2"; // weak
char *off_4AA118 = "wbroll.bm2"; // weak
_UNKNOWN unk_4AA218; // weak
_UNKNOWN unk_4AA220; // weak
_UNKNOWN unk_4AA470; // weak
_UNKNOWN unk_4AA498; // weak
int dword_4AA4C0[] = { 3 }; // weak
int dword_4AA4C4[] = { 19 }; // weak
int dword_4AA4C8[] = { 0 }; // weak
int (__stdcall *off_4AA4CC)(int, int) = &sub_442ED0; // weak
_UNKNOWN unk_4AA4F4; // weak
_UNKNOWN unk_4AA4F8; // weak
int (__stdcall *off_4AA4FC)(int, int) = &sub_43BAD0; // weak
_UNKNOWN unk_4AA500; // weak
int (__stdcall *off_4AA7DC)(int, int) = &sub_428FA0; // weak
_DWORD dword_4AA7F4[35] =
{
  7,
  0,
  4430304,
  3,
  2048,
  0,
  4360304,
  3,
  2048,
  0,
  4527248,
  2,
  2,
  0,
  4414720,
  16,
  97,
  0,
  4527536,
  11,
  513,
  1,
  4498480,
  12,
  513,
  1,
  4488528,
  29,
  29,
  0,
  4408352,
  2,
  8192,
  1,
  4422480
}; // idb
int dword_4AA880 = 0; // weak
int dword_4AA884 = 0; // weak
char *off_4AA89C = "explode1.wa2"; // weak
_UNKNOWN unk_4AAC68; // weak
_UNKNOWN unk_4AADF8; // weak
char *off_4AAE78[7] = { "wa2", "wav", "bm2", "bmp", "gif", "png", "jpg" }; // weak
char *off_4AAE80[5] = { "bm2", "bmp", "gif", "png", "jpg" }; // weak
_UNKNOWN unk_4AAE94; // weak
int dword_4AAF14[] = { 1 }; // weak
int dword_4AAF1C[] = { 3 }; // weak
int dword_4AAF20[4] = { 4, 4, 3, 5 }; // idb
int dword_4AAF30 = 0; // weak
int dword_4AAF34 = 0; // weak
void *off_4AAF40 = &unk_4AB924; // weak
int dword_4AB008[] = { 0 }; // weak
_UNKNOWN unk_4AB010; // weak
int dword_4AB050 = 0; // weak
int dword_4AB054 = 0; // weak
int dword_4AB058 = 8000; // weak
int dword_4AB05C = 8000; // weak
char *off_4AB060[30] =
{
  "KB_LEFT",
  "KB_RIGHT",
  "KB_FORWARD",
  "KB_REVERSE",
  "KB_AFTERBURNERS",
  "KB_BOMB",
  "KB_BULLET",
  "KB_MINE",
  "KB_THOR",
  "KB_MULTI",
  "KB_ANTIWARP",
  "KB_STEALTH",
  "KB_CLOAK",
  "KB_XRADAR",
  "KB_REPEL",
  "KB_BURST",
  "KB_WARP",
  "KB_PORTAL",
  "KB_DECOY",
  "KB_ROCKET",
  "KB_BRICK",
  "KB_ATTACH",
  "KB_CYCLE",
  "KB_PREV",
  "KB_NEXT",
  "KB_PREVPAGE",
  "KB_NEXTPAGE",
  "KB_PLAY",
  "KB_MESSAGE",
  "KB_VIEWMAP"
}; // weak
int dword_4AB0D8[] = { 0 }; // weak
int dword_4AB150[11] = { 1, 2, 2, 4, 2, 1, 1, 1, 3, 6, 0 }; // idb
int dword_4AB17C[23] =
{
  -1,
  -2,
  -3,
  -4,
  -5,
  -6,
  -8,
  -9,
  -10,
  -15,
  -11,
  -12,
  -16,
  -19,
  -20,
  -21,
  -22,
  -23,
  -24,
  -26,
  -27,
  -28,
  0
}; // idb
_UNKNOWN unk_4AB1D8; // weak
int dword_4AB200[] = { 0 }; // weak
_UNKNOWN unk_4AB220; // weak
int dword_4AB260 = 30; // weak
_DWORD dword_4AB29C[13] =
{
  2109772,
  1634887763,
  1818586736,
  0,
  1919903828,
  0,
  1936880962,
  116,
  2020569680,
  1651339074,
  0,
  1651339074,
  0
}; // idb
char aBullet[7] = "Bullet"; // weak
char aIgnore[7] = "ignore"; // weak
char aEnter[6] = "enter"; // weak
char aTickname[9] = "tickname"; // weak
char aFardownRight[14] = "FarDown-Right"; // weak
char aLowerleftCorne[17] = "LowerLeft Corner"; // weak
char aKbReverse[11] = "KB_REVERSE"; // weak
char aKbForward[11] = "KB_FORWARD"; // weak
_DWORD dword_4AB8D0[21] =
{
  2012218763,
  16386,
  1991671263,
  5327924,
  1908867958,
  18117,
  2040164749,
  1364214092,
  35,
  954420176,
  3707,
  -1773297929,
  -1241202930,
  97,
  -1657278917,
  44003,
  1637771558,
  1492992763,
  9723643,
  -513305863,
  55052
}; // idb
char aGif[4] = "gif"; // weak
char aBallbncWa2[12] = "ballbnc.wa2"; // weak
char aWerollBm2[11] = "weroll.bm2"; // weak
char aJvrollBm2[11] = "jvroll.bm2"; // weak
char aShip3Bm2[10] = "ship3.bm2"; // weak
char aJunkjvBm2[11] = "junkjv.bm2"; // weak
char aWarppntBm2[12] = "warppnt.bm2"; // weak
char aStar06Bm2[11] = "star06.bm2"; // weak
char aBg14Bm2[9] = "bg14.bm2"; // weak
char aBg06Bm2[9] = "bg06.bm2"; // weak
char aBg03Bm2[9] = "bg03.bm2"; // weak
int (__stdcall *off_4AC038)(int) = &sub_44DAC0; // weak
int dword_4AC0CC = 289611105; // weak
char byte_4AC0D0[20] =
{
  '\t',
  '\x1C',
  '\x1F',
  ':',
  '\x0F',
  '?',
  '\x1D',
  '=',
  '\b',
  '\b',
  '\b',
  '=',
  '\t',
  '=',
  '\x14',
  ',',
  'z',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_4AC0E4 = 112265311; // weak
char byte_4AC0E8[12] = { '', '\x1F', '', '\b', '', '~', '', 'c', '', '\x01', '', 'M' }; // idb
char aTmp[4] = "tmp"; // weak
int dword_4AC0FC = -1857910774; // weak
char byte_4AC100[12] = { '', '', '', '', '', '', '', '', '', '', '\0', '\0' }; // idb
int (*off_4AC10C)() = &sub_402120; // weak
int (__stdcall *off_4AC248)(int) = &sub_436440; // weak
int (__stdcall *off_4AC268)(int, int, int) = &sub_44DA30; // weak
int (__stdcall *off_4AC2B4)(int, int, int) = &nullsub_19; // weak
int (__stdcall *off_4AC2E0)(int) = &sub_436C50; // weak
char aIgnoreTxt[11] = "ignore.txt"; // weak
int (__stdcall *off_4AC31C)(void *Buf2, void *) = &sub_43A140; // weak
char asc_4AC334[] = "> "; // idb
char SubStr[] = ")>"; // idb
int (__stdcall *off_4AC33C[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (*off_4AC354)() = &sub_43EBD0; // weak
int (__stdcall *off_4AC35C)(int, int) = &sub_453750; // weak
int (*off_4AC36C)() = &sub_4167C0; // weak
int (__stdcall *off_4AC370[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (__stdcall *off_4AC414[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (*off_4AC428[2])() = { &sub_4167C0, &sub_4167C0 }; // weak
int (*off_4AC42C)() = &sub_4167C0; // weak
int (__stdcall *off_4AC430[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (__stdcall *off_4AC484[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (__stdcall *off_4AC49C)(int, int) = &sub_453750; // weak
double dbl_4AC4A0 = -0.0001570796326794897; // weak
double dbl_4AC4A8 =  714.2857142857143; // weak
double dbl_4AC4B0 =  1.570796326794897; // weak
double dbl_4AC4B8 = -0.1570796326794897; // weak
int (__stdcall *off_4AC4C0[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
int (__stdcall *off_4AC4E8)(int, int, int) = &sub_43DA10; // weak
int (__stdcall *off_4AC6CC)(int) = &sub_437870; // weak
int (__stdcall *off_4AC6D4)(int, int, int) = &nullsub_19; // weak
int (__stdcall *off_4AC6F8)(int) = &sub_437870; // weak
int (__stdcall *off_4AC700[2])(int, int, int) = { &nullsub_19, &sub_447A60 }; // weak
int (__stdcall *off_4AC728)(int, int, int) = &nullsub_19; // weak
int (*off_4AC74C)() = &sub_46D263; // weak
int (__stdcall *off_4AC760)(_DWORD, _DWORD) = &sub_424F10; // weak
int (__stdcall *off_4AC7A0)(int, int, int) = &nullsub_19; // weak
int (*off_4AC7C0)() = &sub_405FA0; // weak
char aLicense[8] = "LICENSE"; // weak
int (__stdcall *off_4AC800)(int, int, int) = &sub_436A20; // weak
int (*off_4AC854)() = &sub_4312D0; // weak
int (*off_4AC868[3])() = { &sub_46D263, &sub_46D263, &sub_46D263 }; // weak
char aSocksErrorD08x[53] = "SOCKS error %d (%08x)  \r\nCheck proxy configuration  "; // weak
double dbl_4AC8B0 =  0.001; // weak
int (__stdcall *off_4AC8B8)(int) = &sub_450AF0; // weak
char aC256s[12] = "%c %.256s\r\n"; // weak
double dbl_4AC920 =  0.1570796326794897; // weak
int (*off_4ACC2C)() = &sub_437CB0; // weak
char aContshmem[10] = "ContShMem"; // weak
unsigned __int8 byte_4ACCAC[16] =
{
  6u,
  225u,
  84u,
  215u,
  133u,
  192u,
  147u,
  198u,
  131u,
  195u,
  216u,
  200u,
  153u,
  195u,
  246u,
  0u
}; // idb
unsigned __int8 byte_4ACCBC[12] = { 181u, 250u, 169u, 219u, 198u, 221u, 214u, 216u, 207u, 208u, 196u, 191u }; // idb
_UNKNOWN unk_4ACCC8; // weak
char aScrty1[7] = "scrty1"; // weak
char aScrty[6] = "scrty"; // weak
char aContinuumHasBe[188] = "Continuum has been damaged by CIH virus. Your computer is currently infected or was infected in the past. Please use anti-virus software to check your system and then re-install Continuum"; // weak
char aWallDRcktDSSS[24] = "Wall:%d  Rckt:%d %s%s%s"; // weak
char aBrstDReplDPrtl[26] = "Brst:%d  Repl:%d  Prtl:%d"; // weak
char aDD[6] = "%d.%d"; // weak
char aArena[7] = "?arena"; // weak
char aGetsettings[13] = "?getsettings"; // weak
char aLowDHighD[17] = "Low:%d   High:%d"; // weak
char aBadStatusCrc[21] = "Bad status crc!!!!!\n"; // weak
int (__stdcall *off_4AD124[2])(int, int) = { &sub_453750, &sub_42EAD0 }; // weak
char asc_4AD170[] = "::"; // idb
char aWarp[6] = "Warp!"; // weak
char aMultifireLost[16] = "MultiFire lost."; // weak
char aThorSHammerLos[20] = "Thor's hammer lost."; // weak
char aAntiwarpLost[15] = "AntiWarp lost."; // weak
int dword_4AD5A4 = 2021030361; // weak
char byte_4AD5A8[] = { '' }; // weak
_UNKNOWN unk_4AD5B4; // weak
_UNKNOWN unk_4AD5E8; // weak
unsigned __int8 byte_4AD640[28] =
{
  183u,
  59u,
  219u,
  44u,
  119u,
  25u,
  123u,
  13u,
  102u,
  27u,
  96u,
  27u,
  118u,
  49u,
  96u,
  25u,
  115u,
  16u,
  123u,
  4u,
  115u,
  10u,
  123u,
  17u,
  124u,
  126u,
  0u,
  0u
}; // idb
char aXaOeaiotaradew[20] = "XEITRDWE "; // weak
_UNKNOWN unk_4AD670; // weak
_UNKNOWN unk_4AD6A0; // weak
double dbl_4AD6D0 = -1000.0; // weak
char a3d[21] = "-----------------%3d"; // weak
char a04d3d[21] = "%04d-------------%3d"; // weak
double dbl_4AD770 =  0.5; // weak
char aSpddetGGGDDDD[30] = "SpdDet: %g %g %g %d %d %d %d\n"; // weak
char aSToCenter[13] = "%s to center"; // weak
char aSOff[7] = "%s OFF"; // weak
char aLogFileOpenS[18] = "Log file open: %s"; // weak
char aLogs[5] = "logs"; // weak
char aSessionLog[12] = "session.log"; // weak
char asc_4AD87C[2] = "*"; // weak
char aConnectionToSe[26] = "Connection to server lost"; // weak
char aContinuumupdat[20] = "ContinuumUpdate.exe"; // weak
char aDamagedBundleF[20] = "Damaged bundle file"; // weak
double dbl_4ADB78 =  6366.197723675814; // weak
char aScreenshotFunc[61] = "Screenshot functionality is available only in spectator mode"; // weak
char aFailedToLoadS[19] = "Failed to load %s\n"; // weak
char aStaskoutDD[17] = "STaskout %d->%d\n"; // weak
char aRiched32Dll[13] = "riched32.dll"; // weak
char aS_4[5] = "%-*s"; // weak
char aYouAreAlreadyI[38] = "You are already in that type of ship."; // weak
char aSEnteredArena[17] = "%s entered arena"; // weak
char aD_2[5] = "%d%%"; // weak
char a040[5] = "0.40"; // weak
char aFailedToLoadDy[48] = "Failed to load dynamic link library menures.dll"; // weak
char a4040s[13] = "    %-40.40s"; // weak
int dword_4ADF50 = 943135029; // weak
char byte_4ADF54[] = { 'd' }; // weak
int dword_4ADF58 = 38741070; // weak
char byte_4ADF5C[4] = { 'Z', '=', '`', '\0' }; // idb
char aSSS_0[10] = "%s:%s> %s"; // weak
char a1[2] = "1"; // weak
char aVictoryMusicVo[25] = "Victory music volume: %d"; // weak
char aFlags[8] = "FLAGS: "; // weak
char asc_4ADFF4[2] = ","; // weak
char aUncarriedFlags[20] = "UNCARRIED FLAGS: %d"; // weak
char asc_4AE034[3] = "\r\n"; // weak
char aMac[4] = "mac"; // weak
char aMessageNameLen[24] = "Message Name Length: %d"; // weak
char aW[] = "%W%"; // idb
char aFailedToLoadGr[32] = "Failed to load graphics file %s"; // weak
char aColorsBm2[11] = "colors.bm2"; // weak
char aGradientBm2[13] = "gradient.bm2"; // weak
char aSpectateBm2[13] = "spectate.bm2"; // weak
char aRadarhBm2[11] = "radarh.bm2"; // weak
char aRadarvBm2[11] = "radarv.bm2"; // weak
char aLedBm2[8] = "led.bm2"; // weak
char aHlthbarBm2[12] = "hlthbar.bm2"; // weak
char aEngyfontBm2[13] = "engyfont.bm2"; // weak
char aDispBm2[9] = "disp.bm2"; // weak
char aIcondoorBm2[13] = "icondoor.bm2"; // weak
char aIconsBm2[10] = "icons.bm2"; // weak
char aSsshieldBm2[13] = "ssshield.bm2"; // weak
char aPowerbBm2[11] = "powerb.bm2"; // weak
char aTurret2Bm2[12] = "turret2.bm2"; // weak
char aTurretBm2[11] = "turret.bm2"; // weak
char aKingBm2[9] = "king.bm2"; // weak
char aDamageBm2[11] = "damage.bm2"; // weak
char aSparkBm2[10] = "spark.bm2"; // weak
char aRocketBm2[11] = "rocket.bm2"; // weak
char aExhaustBm2[12] = "exhaust.bm2"; // weak
char aTrailBm2[10] = "trail.bm2"; // weak
char aWallBm2[9] = "wall.bm2"; // weak
char aGoalBm2[9] = "goal.bm2"; // weak
char aFlagBm2[9] = "flag.bm2"; // weak
char aPrizesBm2[11] = "prizes.bm2"; // weak
char aTilesBm2[10] = "tiles.bm2"; // weak
int dword_4AE358 = 635191354; // weak
int dword_4AE390 = 919425989; // weak
int dword_4AE3B8 = -1016473877; // weak
char byte_4AE3BC[12] = { 'S', '', '|', '', '4', '', '<', '', 'u', '', '\0', '\0' }; // idb
int dword_4AE3C8 = -1583307810; // weak
char byte_4AE3CC[8] = { '', '', '', '', '', '\0', '\0', '\0' }; // idb
char aTeamVictory[14] = "Team Victory!"; // weak
char aFlagGameReset[17] = "Flag game reset."; // weak
char aSDD[10] = "%s %d %d\n"; // weak
char aEnteringArena[15] = "Entering arena"; // weak
char aAntiwarpEngage[24] = "AntiWarp engaged by: %s"; // weak
_UNKNOWN unk_4AE5A0; // weak
_UNKNOWN unk_4AE5B0; // weak
_UNKNOWN unk_4AE5C0; // weak
char aCximage551[13] = "CxImage 5.51"; // weak
void *CxIOFile::`vftable' = &sub_45A250; // weak
void *CxImage::`vftable' = &sub_45A820; // weak
double dbl_4AE618 =  39.37007874015748; // weak
void *CxImageGIF::`vftable' = &sub_45E670; // weak
int (__stdcall *off_4AE624[4])(char) = { &sub_45F310, &sub_45F2B0, &sub_45F280, &sub_45F2E0 }; // weak
int (__stdcall *off_4AE628[3])(char) = { &sub_45F2B0, &sub_45F280, &sub_45F2E0 }; // weak
int (__stdcall *off_4AE62C[2])(char) = { &sub_45F280, &sub_45F2E0 }; // weak
int (__stdcall *off_4AE630)(char) = &sub_45F2E0; // weak
int dword_4AE634[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // idb
double dbl_4AE678 =  0.0254; // weak
__int16 word_4AE6C0[] = { 0 }; // weak
__int16 word_4AE6C2[] = { 0 }; // weak
__int16 word_4AE6C4[] = { 0 }; // weak
__int16 word_4AE6C6[] = { 0 }; // weak
int (__cdecl *funcs_467804[28])(int, int) =
{
  &sub_467CD0,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008,
  &loc_467FE0,
  (int (__cdecl *)(int, int))0x50004,
  (int (__cdecl *)(int, int))0x80010,
  &loc_467FE0,
  (int (__cdecl *)(int, int))0x60004,
  (int (__cdecl *)(int, int))0x200020,
  &loc_467FE0,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x100010,
  &loc_468480,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x200020,
  &loc_468480,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x800080,
  &loc_468480,
  (int (__cdecl *)(int, int))0x200008,
  (int (__cdecl *)(int, int))0x1000080,
  &loc_468480,
  (int (__cdecl *)(int, int))0x800020,
  (int (__cdecl *)(int, int))0x4000102,
  &loc_468480,
  (int (__cdecl *)(int, int))0x1020020,
  (int (__cdecl *)(int, int))0x10000102,
  &loc_468480
}; // idb
int dword_4AE738[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // idb
int dword_4AE784[29] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0
}; // idb
int dword_4AE7F8[49] =
{
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  3,
  7
}; // idb
char byte_4AE8BC[20] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '\0'
}; // idb
_UNKNOWN unk_4AE8D0; // weak
__int16 word_4AECD0 = 0; // weak
__int16 word_4AECD2 = 7; // weak
_UNKNOWN unk_4AED50; // weak
char byte_4AEDC8[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F'
}; // idb
char byte_4AEEC8[] = { '\0' }; // weak
char byte_4AEFC8[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1C'
}; // idb
int dword_4AF0C8[29] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0
}; // idb
int dword_4AF13C[42] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576,
  1718511904,
  1702125932,
  825110816,
  1126183982,
  1920561263,
  1952999273,
  960049440,
  808594741,
  1293955632,
  543912545,
  1701602369,
  8306
}; // idb
_UNKNOWN unk_4AF1E4; // weak
_UNKNOWN unk_4AF260; // weak
_UNKNOWN unk_4AF2DC; // weak
_UNKNOWN unk_4AF354; // weak
int (__stdcall *off_4AF3D0)(char) = &sub_46C9ED; // weak
_UNKNOWN unk_4AF3D8; // weak
_SCOPETABLE_ENTRY stru_4AF4F8[2] = { { -1, NULL, &loc_47061E }, { 0, &loc_47060A, &loc_47060E } }; // weak
double dbl_4AF510 =  4195835.0; // weak
double dbl_4AF518 =  3145727.0; // weak
char aIsprocessorfea[26] = "IsProcessorFeaturePresent"; // weak
char aKernel32[9] = "KERNEL32"; // weak
char Str1[] = "__GLOBAL_HEAP_SELECTED"; // idb
char aMsvcrtHeapSele[21] = "__MSVCRT_HEAP_SELECT"; // weak
char byte_4AF580[92] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // idb
char asc_4AF634[] = ";"; // idb
char Control[] = "_.,"; // idb
_UNKNOWN unk_4AF648; // weak
_UNKNOWN unk_4AF64C; // weak
char aSqrt[5] = "sqrt"; // weak
char VarName[] = "TZ"; // idb
char aR6027NotEnough[53] = "R6027\r\n- not enough space for lowio initialization\r\n"; // weak
char aMicrosoftVisua[37] = "Microsoft Visual C++ Runtime Library"; // weak
char asc_4AFA24[] = "\n\n"; // idb
char aRuntimeErrorPr[26] = "Runtime Error!\n\nProgram: "; // weak
char asc_4AFA44[] = "..."; // idb
char aProgramNameUnk[23] = "<program name unknown>"; // weak
char aDominicanRepub[19] = "Dominican Republic"; // weak
char aCostaRica[11] = "Costa Rica"; // weak
char aSweden[7] = "Sweden"; // weak
char aSouthAfrica[13] = "south africa"; // weak
char aSlovak[7] = "slovak"; // weak
char aPrChina[9] = "pr-china"; // weak
char aAmerica[8] = "america"; // weak
char aUs[3] = "us"; // weak
char aSpanishModern[15] = "spanish-modern"; // weak
char aSpanishGuatema[18] = "spanish-guatemala"; // weak
char aAmericanEnglis[17] = "american-english"; // weak
char off_4B00FC[] = { 'O', 'C', 'P', '\0' }; // idb
char off_4B0100[] = { 'A', 'C', 'P', '\0' }; // idb
char aGetlastactivep[19] = "GetLastActivePopup"; // weak
char aGetactivewindo[16] = "GetActiveWindow"; // weak
char aMessageboxa[12] = "MessageBoxA"; // weak
char aUser32Dll[11] = "user32.dll"; // weak
char a1Qnan[7] = "1#QNAN"; // weak
char aApr[4] = "Apr"; // weak
char aSat[4] = "Sat"; // weak
char aAP[] = "a/p"; // idb
char String2[] = "am/pm"; // idb
double dbl_4B02E0 =  0.05; // weak
double dbl_4B02E8 =  100000.0; // weak
double dbl_4B02F0 =  255.0; // weak
double dbl_4B02F8 =  0.00392156862745098; // weak
double dbl_4B0300 =  65535.0; // weak
double dbl_4B0308 =  0.00001525902189669642; // weak
double dbl_4B0310 =  0.00390625; // weak
char byte_4B0324[16] =
{
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F'
}; // idb
char a125_0[6] = "1.2.5"; // weak
char aIhdr[5] = "IHDR"; // weak
char aIdat[5] = "IDAT"; // weak
char aIend[5] = "IEND"; // weak
char aPlte[5] = "PLTE"; // weak
char aBkgd[5] = "bKGD"; // weak
char aChrm[5] = "cHRM"; // weak
char aGama[5] = "gAMA"; // weak
char aHist[5] = "hIST"; // weak
char aIccp[5] = "iCCP"; // weak
char aOffs[5] = "oFFs"; // weak
char aPcal[5] = "pCAL"; // weak
char aScal[5] = "sCAL"; // weak
char aPhys[5] = "pHYs"; // weak
char aSbit[5] = "sBIT"; // weak
char aSplt[5] = "sPLT"; // weak
char aSrgb[5] = "sRGB"; // weak
char aText[5] = "tEXt"; // weak
char aTime[5] = "tIME"; // weak
char aTrns[5] = "tRNS"; // weak
char aZtxt[5] = "zTXt"; // weak
int dword_4B03F8[7] = { 0, 4, 0, 2, 0, 1, 0 }; // idb
int dword_4B0414[7] = { 8, 8, 4, 4, 2, 2, 1 }; // idb
int dword_4B0430[] = { 0 }; // weak
int dword_4B044C[7] = { 8, 8, 8, 4, 4, 2, 2 }; // idb
int dword_4B0468[7] = { 128, 8, 136, 34, 170, 85, 255 }; // idb
int dword_4B0484[] = { 255 }; // weak
int dword_4B0488 = 15; // weak
int dword_4B048C = 255; // weak
int dword_4B0490 = 51; // weak
int dword_4B0494 = 255; // weak
int dword_4B0498 = 85; // weak
double dbl_4B04D0 =  8.0; // weak
double dbl_4B04D8 =  256.0; // weak
double dbl_4B04E0 =  21474.83; // weak
double dbl_4B04E8 =  0.00001; // weak
double dbl_4B04F0 =  2.147483647e9; // weak
float flt_4B04F8 =  0.0000099999997; // weak
double dbl_4B0500 =  0.8; // weak
char *off_4B0508[124] =
{
  "Bogus message code %d",
  "Sorry, there are legal restrictions on arithmetic coding",
  "ALIGN_TYPE is wrong, please fix",
  "MAX_ALLOC_CHUNK is wrong, please fix",
  "Bogus buffer control mode",
  "Invalid component ID %d in SOS",
  "DCT coefficient out of range",
  "IDCT output block size %d not supported",
  "Bogus Huffman table definition",
  "Bogus input colorspace",
  "Bogus JPEG colorspace",
  "Bogus marker length",
  "Wrong JPEG library version: library is %d, caller expects %d",
  "Sampling factors too large for interleaved scan",
  "Invalid memory pool code %d",
  "Unsupported JPEG data precision %d",
  "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d",
  "Invalid progressive parameters at scan script entry %d",
  "Bogus sampling factors",
  "Invalid scan script at entry %d",
  "Improper call to JPEG library in state %d",
  "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u",
  "Bogus virtual array access",
  "Buffer passed to JPEG library is too small",
  "Suspension not allowed here",
  "CCIR601 sampling not implemented yet",
  "Too many color components: %d, max %d",
  "Unsupported color conversion request",
  "Bogus DAC index %d",
  "Bogus DAC value 0x%x",
  "Bogus DHT index %d",
  "Bogus DQT index %d",
  "Empty JPEG image (DNL not supported)",
  "Read from EMS failed",
  "Write to EMS failed",
  "Didn't expect more than one scan",
  "Input file read error",
  "Output file write error --- out of disk space?",
  "Fractional sampling not implemented yet",
  "Huffman code size table overflow",
  "Missing Huffman code table entry",
  "Maximum supported image dimension is %u pixels",
  "Empty input file",
  "Premature end of input file",
  "Cannot transcode due to multiple use of quantization table %d",
  "Scan script does not transmit all data",
  "Invalid color quantization mode change",
  "Not implemented yet",
  "Requested feature was omitted at compile time",
  "Backing store not supported",
  "Huffman table 0x%02x was not defined",
  "JPEG datastream contains no image",
  "Quantization table 0x%02x was not defined",
  "Not a JPEG file: starts with 0x%02x 0x%02x",
  "Insufficient memory (case %d)",
  "Cannot quantize more than %d color components",
  "Cannot quantize to fewer than %d colors",
  "Cannot quantize to more than %d colors",
  "Invalid JPEG file structure: two SOF markers",
  "Invalid JPEG file structure: missing SOS marker",
  "Unsupported JPEG process: SOF type 0x%02x",
  "Invalid JPEG file structure: two SOI markers",
  "Invalid JPEG file structure: SOS before SOF",
  "Failed to create temporary file %s",
  "Read failed on temporary file",
  "Seek failed on temporary file",
  "Write failed on temporary file --- out of disk space?",
  "Application transferred too few scanlines",
  "Unsupported marker type 0x%02x",
  "Virtual array controller messed up",
  "Image too wide for this implementation",
  "Read from XMS failed",
  "Write to XMS failed",
  "Copyright (C) 1998, Thomas G. Lane",
  "6b  27-Mar-1998",
  "Caution: quantization tables are too coarse for baseline JPEG",
  "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d",
  "Unknown APP0 marker (not JFIF), length %u",
  "Unknown APP14 marker (not Adobe), length %u",
  "Define Arithmetic Table 0x%02x: 0x%02x",
  "Define Huffman Table 0x%02x",
  "Define Quantization Table %d  precision %d",
  "Define Restart Interval %u",
  "Freed EMS handle %u",
  "Obtained EMS handle %u",
  "End Of Image",
  "        %3d %3d %3d %3d %3d %3d %3d %3d",
  "JFIF APP0 marker: version %d.%02d, density %dx%d  %d",
  "Warning: thumbnail image size does not match data length %u",
  "JFIF extension marker: type 0x%02x, length %u",
  "    with %d x %d thumbnail image",
  "Miscellaneous marker 0x%02x, length %u",
  "Unexpected marker 0x%02x",
  "        %4u %4u %4u %4u %4u %4u %4u %4u",
  "Quantizing to %d = %d*%d*%d colors",
  "Quantizing to %d colors",
  "Selected %d colors for quantization",
  "At marker 0x%02x, recovery action %d",
  "RST%d",
  "Smoothing not supported with nonstandard sampling ratios",
  "Start Of Frame 0x%02x: width=%u, height=%u, components=%d",
  "    Component %d: %dhx%dv q=%d",
  "Start of Image",
  "Start Of Scan: %d components",
  "    Component %d: dc=%d ac=%d",
  "  Ss=%d, Se=%d, Ah=%d, Al=%d",
  "Closed temporary file %s",
  "Opened temporary file %s",
  "JFIF extension marker: JPEG-compressed thumbnail image, length %u",
  "JFIF extension marker: palette thumbnail image, length %u",
  "JFIF extension marker: RGB thumbnail image, length %u",
  "Unrecognized component IDs %d %d %d, assuming YCbCr",
  "Freed XMS handle %u",
  "Obtained XMS handle %u",
  "Unknown Adobe color transform code %d",
  "Inconsistent progression sequence for component %d coefficient %d",
  "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x",
  "Corrupt JPEG data: premature end of data segment",
  "Corrupt JPEG data: bad Huffman code",
  "Warning: unknown JFIF revision number %d.%02d",
  "Premature end of JPEG file",
  "Corrupt JPEG data: found marker 0x%02x instead of RST%d",
  "Invalid SOS parameters for sequential JPEG",
  "Application transferred too many scanlines"
}; // weak
_DWORD dword_4B06FC[64] =
{
  16,
  11,
  10,
  16,
  24,
  40,
  51,
  61,
  12,
  12,
  14,
  19,
  26,
  58,
  60,
  55,
  14,
  13,
  16,
  24,
  40,
  57,
  69,
  56,
  14,
  17,
  22,
  29,
  51,
  87,
  80,
  62,
  18,
  22,
  37,
  56,
  68,
  109,
  103,
  77,
  24,
  35,
  55,
  64,
  81,
  104,
  113,
  92,
  49,
  64,
  78,
  87,
  103,
  121,
  120,
  101,
  72,
  92,
  95,
  98,
  112,
  100,
  103,
  99
}; // idb
_DWORD dword_4B07FC[64] =
{
  17,
  18,
  24,
  47,
  99,
  99,
  99,
  99,
  18,
  21,
  26,
  66,
  99,
  99,
  99,
  99,
  24,
  26,
  56,
  99,
  99,
  99,
  99,
  99,
  47,
  66,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99
}; // idb
_UNKNOWN unk_4B08FC; // weak
_UNKNOWN unk_4B0910; // weak
_UNKNOWN unk_4B091C; // weak
_UNKNOWN unk_4B0930; // weak
_UNKNOWN unk_4B093C; // weak
_UNKNOWN unk_4B0950; // weak
_UNKNOWN unk_4B09F4; // weak
_UNKNOWN unk_4B0A08; // weak
int dword_4B0AAC[] = { 1600 }; // weak
int dword_4B0AB4[] = { 0 }; // weak
int dword_4B0ABC[] = { 0 }; // weak
_UNKNOWN unk_4B0AC0; // weak
_UNKNOWN unk_4B0BBC; // weak
int dword_4B0BFC[16] = { 0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384 }; // idb
int dword_4B0C3C[16] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767
}; // idb
int dword_4B0C7C[16] = { 0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384 }; // idb
int dword_4B0CBC[17] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767,
  0
}; // idb
_UNKNOWN unk_4B0D00; // weak
_UNKNOWN unk_4B0D80; // weak
_UNKNOWN unk_4B0DC0; // weak
_UNKNOWN unk_4B0EC0; // weak
_UNKNOWN unk_4B0ED0; // weak
_UNKNOWN unk_4B0F50; // weak
float flt_4B0F90 =  16384.5; // weak
float flt_4B0F94 =  1.0823922; // weak
float flt_4B0F98 =  2.613126; // weak
float flt_4B0F9C =  1.847759; // weak
float flt_4B0FA0 =  1.4142135; // weak
float flt_4B0FA4 =  1.306563; // weak
float flt_4B0FA8 =  0.54119611; // weak
float flt_4B0FAC =  0.38268343; // weak
float flt_4B0FB0 =  0.70710677; // weak
int dword_4B0FB4[259] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  0,
  0,
  0
}; // idb
double dbl_4B1408 =  2.0; // weak
_ThrowInfo _TI2_AVDDRAW_EXCEPION__ = { 0u, &sub_401C10, NULL, &_CTA2_AVDDRAW_EXCEPION__ }; // idb
_ThrowInfo _TI1H = { 0u, NULL, NULL, &_CTA1H }; // idb
_ThrowInfo _TI2_AVfile_exception__ = { 0u, &sub_407110, NULL, &_CTA2_AVfile_exception__ }; // idb
_ThrowInfo _TI1_AVbase_exception__ = { 0u, &sub_407050, NULL, &_CTA1_AVbase_exception__ }; // idb
_ThrowInfo _TI2_AVtext_exception__ = { 0u, &sub_407520, NULL, &_CTA2_AVtext_exception__ }; // idb
_ThrowInfo _TI2_AVmemory_exception__ = { 0u, &sub_407080, NULL, &_CTA2_AVmemory_exception__ }; // idb
_ThrowInfo _TI1I = { 0u, NULL, NULL, &_CTA1I }; // idb
_ThrowInfo PA.deinit = { 0u, NULL, NULL, &_CTA2PAD }; // idb
FuncInfoV1 stru_4B3C68 = { 429065504, 2, &stru_4B3C88, 1, &stru_4B3C98, 0, NULL }; // weak
FuncInfoV1 stru_4B3CC0 = { 429065504, 2, &stru_4B3CE0, 1, &stru_4B3CF0, 0, NULL }; // weak
FuncInfoV1 stru_4B3D18 = { 429065504, 1, &stru_4B3D38, 0, NULL, 0, NULL }; // weak
FuncInfoV1 stru_4B3D40 = { 429065504, 1, &stru_4B3D60, 0, NULL, 0, NULL }; // weak
FuncInfoV1 stru_4B3E68 = { 429065504, 1, &stru_4B3E88, 0, NULL, 0, NULL }; // weak
void *off_4B3E90 = &unk_4B4224; // weak
void (*off_4B8000[6])(void) = { NULL, &sub_408BD0, &sub_40D420, &sub_40D430, &sub_4106B0, &sub_418E80 }; // idb
_UNKNOWN unk_4B8018; // weak
void (*off_4B801C[5])(void) = { NULL, &sub_46E3D7, &sub_473D4B, &sub_4791C9, &sub_46FB3A }; // idb
_UNKNOWN unk_4B8030; // weak
void (*off_4B8034[2])(void) = { NULL, &sub_473DF3 }; // idb
_UNKNOWN unk_4B803C; // weak
void (*off_4B8040[2])(void) = { NULL, &sub_46FB4B }; // idb
_UNKNOWN unk_4B8048; // weak
_DWORD dword_4B809C = 27; // idb
int dword_4B80C0 = 0; // weak
int (__thiscall *off_4B80C4)(_DWORD, _DWORD) = &sub_40A740; // weak
int (__stdcall *off_4B80C8)(int, int, int, int) = &sub_40A7D0; // weak
int (__thiscall *off_4B80CC)(_DWORD, _DWORD, _DWORD) = &sub_40AA10; // weak
char byte_4B80F0 = '\x01'; // weak
_UNKNOWN unk_4B8120; // weak
_DWORD dword_4B8160 = 188; // idb
_UNKNOWN off_4B8164; // weak
char *off_4B8168[16] =
{
  "   TEP*P*C ",
  "   %3d       ",
  "   %3d       ",
  "   %3d         Points",
  "   %3d     Point Sort",
  "   %3d      Team Sort",
  "   %3d          Squad        W    L    R    Ave",
  " Freq    Points   Win  Lose  Flag",
  " %-12.12s",
  " %-12.12s",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s   %-10.10s %4d %4d %4d %3d.%d",
  " %-4d %9d %5d %5d %5d",
  " ---- %9d %5d %5d %5d"
}; // weak
char *off_4B816C[15] =
{
  "   %3d       ",
  "   %3d       ",
  "   %3d         Points",
  "   %3d     Point Sort",
  "   %3d      Team Sort",
  "   %3d          Squad        W    L    R    Ave",
  " Freq    Points   Win  Lose  Flag",
  " %-12.12s",
  " %-12.12s",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s   %-10.10s %4d %4d %4d %3d.%d",
  " %-4d %9d %5d %5d %5d",
  " ---- %9d %5d %5d %5d"
}; // weak
char *off_4B8188[8] =
{
  " %-12.12s",
  " %-12.12s",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s  %*d",
  " %-12.12s   %-10.10s %4d %4d %4d %3d.%d",
  " %-4d %9d %5d %5d %5d",
  " ---- %9d %5d %5d %5d"
}; // weak
char *off_4B81A0[2] = { " %-4d %9d %5d %5d %5d", " ---- %9d %5d %5d %5d" }; // weak
char *off_4B81A4 = " ---- %9d %5d %5d %5d"; // weak
int dword_4B81A8 = -1; // weak
int dword_4B81AC = -1; // weak
char *off_4B81B0 = "WGBRYPbp"; // idb
void *off_4B81B4 = &unk_4AB564; // weak
char *off_4B81B8[40] =
{
  "UpperLeft Corner",
  "FarUp-Left",
  "FarUp",
  "FarUp-Right",
  "UpperRight Corner",
  "Up-FarLeft",
  "Up-Left",
  "Up",
  "Up-Right",
  "Up-FarRight",
  "FarLeft",
  "Left",
  "Center",
  "Right",
  "FarRight",
  "Down-FarLeft",
  "Down-Left",
  "Down",
  "Down-Right",
  "Down-FarRight",
  "LowerLeft Corner",
  "FarDown-Left",
  "FarDown",
  "FarDown-Right",
  "LowerRight Corner",
  "area",
  "coord",
  "freq",
  "squad",
  "flags",
  "killer",
  "killed",
  "energy",
  "bounty",
  "redflags",
  "tickname",
  "selfname",
  "redbounty",
  "redname",
  "red"
}; // weak
char *off_4B821C[15] =
{
  "area",
  "coord",
  "freq",
  "squad",
  "flags",
  "killer",
  "killed",
  "energy",
  "bounty",
  "redflags",
  "tickname",
  "selfname",
  "redbounty",
  "redname",
  "red"
}; // weak
_UNKNOWN unk_4B825C; // weak
_UNKNOWN unk_4B8358; // weak
char aI[3] = ".I"; // weak
char aRb[3] = "rb"; // weak
wchar_t aRb_0[3] = L"rb"; // weak
char aUnableToLoadRe[25] = "Unable to load resource!"; // weak
char aDecodeUnknownO[32] = "Decode: Unknown or wrong format"; // weak
char aCanTOpenGifFor[27] = "Can't open GIF for writing"; // weak
char Str2[] = "GIF8"; // idb
char aMultipageGifNo[26] = "multipage GIF, no images!"; // weak
char aBadImagePointe[18] = "Bad image pointer"; // weak
char aNetscape20[12] = "NETSCAPE2.0"; // weak
char aInvalidFilePoi[21] = "invalid file pointer"; // weak
char aGif89a[7] = "GIF89a"; // weak
char aWriteErrorInGi[24] = "Write Error in GIF file"; // weak
char aBadColorMapSig[24] = "bad color map signature"; // weak
char aCorruptedPcx[14] = "corrupted PCX"; // weak
char aRepeatCountSpa[32] = "repeat count spans end of image"; // weak
char aCancelled[10] = "Cancelled"; // weak
char aCanTHandleImag[43] = "Can't handle image with more than 4 planes"; // weak
char aPcxFileHasUnkn[37] = "PCX file has unknown encoding scheme"; // weak
char aErrorNotAPcxFi[22] = "Error: Not a PCX file"; // weak
char aCanTReadPcxIma[21] = "Can't read PCX image"; // weak
char aCannotWritePcx[24] = "cannot write PCX header"; // weak
char aCanTHandleMore_0[39] = "Can't handle more than 1 bit per pixel"; // weak
char aCanTHandleMore[32] = "Can't handle more than 4 planes"; // weak
char aCanTHandlePack[51] = "Can't handle packed pixels with more than 1 plane."; // weak
char aFailedToInitia[40] = "Failed to initialize PNG info structure"; // weak
char aFailedToCreate[31] = "Failed to create PNG structure"; // weak
char a125[6] = "1.2.5"; // weak
char aReadError[11] = "Read Error"; // weak
char aErrorSavingPng[22] = "Error saving PNG file"; // weak
char aWriteError[12] = "Write Error"; // weak
char aFlushError[12] = "Flush Error"; // weak
char aJpegCanSaveOnl[43] = "JPEG can save only RGB or GreyScale images"; // weak
char aCompressionTyp[31] = "compression type not supported"; // weak
char aCanTAllocateMe_0[22] = "can't allocate memory"; // weak
char aUnknownCompres[20] = "unknown compression"; // weak
char aCanTAllocateMe[22] = "Can't allocate memory"; // weak
char aErrorReadingBm[23] = "Error reading BMP info"; // weak
char aNotABmp[10] = "Not a BMP"; // weak
char a114[6] = "1.1.4"; // weak
char aNeedDictionary[16] = "need dictionary"; // weak
char aIncorrectDataC[21] = "incorrect data check"; // weak
char aIncorrectHeade[23] = "incorrect header check"; // weak
char aInvalidWindowS[20] = "invalid window size"; // weak
char aUnknownCompres_0[27] = "unknown compression method"; // weak
char *off_4B88C0 = "1.1.4"; // weak
char aInvalidBitLeng[26] = "invalid bit length repeat"; // weak
char aTooManyLengthO[36] = "too many length or distance symbols"; // weak
char aInvalidStoredB[29] = "invalid stored block lengths"; // weak
char aInvalidBlockTy[19] = "invalid block type"; // weak
char *off_4B8948[5] =
{
  "stream error",
  "data error",
  "insufficient memory",
  "buffer error",
  "incompatible version"
}; // weak
char *off_4B8950[3] = { "insufficient memory", "buffer error", "incompatible version" }; // weak
char *off_4B8954[2] = { "buffer error", "incompatible version" }; // weak
void *off_4B89D0 = &unk_4AE8D0; // weak
void *off_4B89E8 = &unk_4AED50; // weak
_UNKNOWN unk_4B8A00; // weak
char aInvalidDistanc[22] = "invalid distance code"; // weak
char aInvalidLiteral[28] = "invalid literal/length code"; // weak
int dword_4B8A48 = 9; // weak
int dword_4B8A4C = 5; // weak
_UNKNOWN unk_4B8A50; // weak
_UNKNOWN unk_4B9A50; // weak
char aIncompleteDyna[36] = "incomplete dynamic bit lengths tree"; // weak
char aOversubscribed[40] = "oversubscribed dynamic bit lengths tree"; // weak
char aIncompleteLite[31] = "incomplete literal/length tree"; // weak
char aOversubscribed_1[35] = "oversubscribed literal/length tree"; // weak
char aEmptyDistanceT[33] = "empty distance tree with lengths"; // weak
char aIncompleteDist[25] = "incomplete distance tree"; // weak
char aOversubscribed_0[29] = "oversubscribed distance tree"; // weak
int dword_4B9C40[20] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  0,
  0,
  0
}; // idb
_DWORD dword_4B9CB0[6] = { 429065504, 4280587, 2, 1636728, 39029, 39027 }; // idb
int (*off_4B9CC8)(void) = &sub_46D1DA; // weak
_UNKNOWN unk_4B9CE0; // weak
int dword_4B9CE4[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // idb
_UNKNOWN unk_4B9E48; // weak
int (__cdecl *off_4B9E60)(_DWORD) = &sub_46E4BD; // weak
int dword_4B9E64 = 2; // weak
int dword_4B9E68[] = { 0 }; // weak
void *off_4B9E6C = &unk_4C1B88; // weak
void *off_4B9E8C = &unk_4C1BB8; // weak
void *off_4B9E9C = &unk_4C1BD0; // weak
void *off_4B9EAC = &unk_4C1BA0; // weak
_UNKNOWN unk_4B9F28; // weak
_DWORD dword_4B9F40 = 26; // idb
int (__cdecl *off_4B9F44)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_470554; // weak
int (__cdecl *off_4B9F48)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &_cfltcvt; // weak
int (__cdecl *off_4B9F4C)(_DWORD) = &sub_4706F6; // weak
int (__cdecl *off_4B9F50)(_DWORD, _DWORD, _DWORD) = &_fassign; // weak
int (__cdecl *off_4B9F54)(_DWORD) = &_forcdecpt; // weak
int (__cdecl *off_4B9F58)(int) = &sub_470744; // weak
int (__cdecl *off_4B9F5C)(int, int, int, int, int) = &_cfltcvt; // weak
void *off_4B9F68 = &off_4B9F68; // weak
void **off_4B9F6C = &off_4B9F68; // weak
int dword_4B9F78 = -1; // weak
void **off_4BBF88 = &off_4B9F68; // weak
int dword_4BBF8C = 480; // weak
__int16 *off_4BBF90[2] = { &word_4BBF9A, &word_4BBF9A }; // weak
__int16 *off_4BBF94 = &word_4BBF9A; // weak
__int16 word_4BBF9A[] = { 32 }; // weak
size_t dword_4BC19C = 1u; // idb
char byte_4BC1A0 = '.'; // weak
int dword_4BC1A4 = 1; // weak
char *off_4BC1A8 = "(null)"; // weak
wchar_t *off_4BC1AC = L"(null)"; // weak
_UNKNOWN unk_4BC1B0; // weak
char aC_0[2] = "C"; // idb
char aC[2] = "C"; // idb
char *Destination = NULL; // idb
int (*funcs_4736AC)() = &sub_4738C7; // weak
void *off_4BC2D0 = &unk_4BC1B0; // weak
void *off_4BC2DC = &unk_4BC1B0; // weak
void *off_4BC300 = &unk_4BC1B0; // weak
void *off_4BC308 = &unk_4C2240; // weak
FILE stru_4BC328 = { NULL, 0, NULL, 2, -1, 0, 0, NULL }; // idb
FILE Stream = { NULL, 0, NULL, 2, -1, 0, 0, NULL }; // idb
FILE stru_4BC568 = { NULL, 0, NULL, 0, 0, 0, 0, NULL }; // idb
_UNKNOWN unk_4BC588; // weak
char *off_4BC58C = "exp"; // weak
double dbl_4BC660 = +Inf; // weak
double dbl_4BC668 = NaN; // weak
double dbl_4BC670 =  1.797693134862316e308; // weak
double dbl_4BC680 = -0.0; // weak
int dword_4BC6A0 = 18000; // weak
int dword_4BC6A4 = 1; // weak
int dword_4BC6A8 = -3600; // weak
char *off_4BC72C = "Eastern Standard Time"; // idb
char *off_4BC730 = "Eastern Daylight Time"; // idb
int dword_4BC738 = -1; // weak
int dword_4BC73C = 0; // weak
int dword_4BC740 = 0; // weak
int dword_4BC748 = -1; // weak
int dword_4BC74C = 0; // weak
int dword_4BC750 = 0; // weak
_UNKNOWN unk_4BC758; // weak
int dword_4BC7D0 = 3; // weak
int dword_4BC7D4 = 7; // weak
int dword_4BC7DC = 10; // weak
_UNKNOWN unk_4BC7E0; // weak
int dword_4BC808[] = { 2 }; // weak
char *off_4BC80C = "R6002\r\n- floating point not loaded\r\n"; // weak
_UNKNOWN unk_4BC898; // weak
int dword_4BC8A0[6] = { 1024, -1023, 53, 11, 64, 1023 }; // idb
int dword_4BC8B8[6] = { 128, -127, 24, 8, 32, 127 }; // idb
int dword_4BC8D0[] = { 1034 }; // weak
char a040a[5] = "040a"; // weak
char *off_4BC8DC = "Spanish - Traditional Sort"; // weak
char (*off_4BC8E0)[3] = &byte_505345; // weak
char *off_4BC8E4 = "Spain"; // weak
char (*off_4BC8E8)[3] = &byte_505345; // weak
_UNKNOWN unk_4BC8EC; // weak
char a1252[5] = "1252"; // weak
_UNKNOWN unk_4BCD74; // weak
char *off_4BCD88 = "america"; // weak
char *off_4BCE40 = "american"; // weak
int dword_4BD044[] = { 5590597 }; // weak
int dword_4BD048[11] = { -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304 }; // idb
int dword_4BD078[] = { 365 }; // weak
int dword_4BD07C[13] = { -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364 }; // idb
int dword_4BD0B0 = 9876; // weak
char byte_4BD0B8[8] = { '\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_4BD0C0; // weak
_UNKNOWN unk_4BD0C4; // weak
_UNKNOWN unk_4BD0D0; // weak
char **off_4BD1B0 = &off_4BD1B8; // weak
char *off_4BD1B8[43] =
{
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat",
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
  "AM",
  "PM",
  "M/d/yy",
  "dddd, MMMM dd, yyyy",
  "H:mm:ss"
}; // weak
_UNKNOWN unk_4BD268; // weak
void *off_4BD270 = &unk_4BD268; // weak
void *off_4BD274 = &unk_4C1EC0; // weak
void *off_4BD278 = &unk_4C1EC0; // weak
void **off_4BD2A0 = &off_4BD270; // weak
_UNKNOWN unk_4BD2B0; // weak
_UNKNOWN unk_4BD410; // weak
char aUnknownZlibErr[19] = "Unknown zlib error"; // weak
char aZlibVersionErr[19] = "zlib version error"; // weak
char aZlibMemoryErro[18] = "zlib memory error"; // weak
char aIncompatibleLi[55] = "Incompatible libpng version in application and library"; // weak
char aTheInfoStructA[67] = "The info struct allocated by application for reading is too small."; // weak
char aThePngStructAl[70] = "The png struct allocated by the application for reading is too small."; // weak
char aZlibVersion[13] = "zlib version"; // weak
char aZlibMemory[12] = "zlib memory"; // weak
char aApplicationUse[70] = "Application uses deprecated png_read_init() and should be recompiled."; // weak
char aMissingPlteBef[25] = "Missing PLTE before IDAT"; // weak
char aMissingIhdrBef[25] = "Missing IHDR before IDAT"; // weak
char aInvalidChunkLe[22] = "Invalid chunk length."; // weak
char aPngFileCorrupt[39] = "PNG file corrupted by ASCII conversion"; // weak
char aNotAPngFile[15] = "Not a PNG file"; // weak
char aIgnoringExtraP[71] = "Ignoring extra png_read_update_info() call; row buffer not reallocated"; // weak
char aExtraCompresse[22] = "Extra compressed data"; // weak
char aDecompressionE[20] = "Decompression error"; // weak
char aNotEnoughImage[22] = "Not enough image data"; // weak
char aInvalidAttempt[33] = "Invalid attempt to read row data"; // weak
char aTooManyIdatSFo[22] = "Too many IDAT's found"; // weak
_UNKNOWN unk_4BD8A4; // weak
_UNKNOWN unk_4BD9A4; // weak
_UNKNOWN unk_4BDAA4; // weak
int dword_4BDBA4[8] = { 16, 33, 66, 132, 272, 584, 1360, 4080 }; // idb
char aApplicationMus[49] = "Application must supply a known background gamma"; // weak
_BYTE byte_4BDC24[12] = { 105, 103, 110, 111, 114, 105, 110, 103, 32, 111, 117, 116 }; // idb
char aPngDoDitherRet[34] = "png_do_dither returned rowbytes=0"; // weak
char aPngDoRgbToGray[39] = "png_do_rgb_to_gray found nongray pixel"; // weak
char aCallToNullRead[27] = "Call to NULL read function"; // weak
char aSameStructureR[50] = "same structure.  Resetting write_data_fn to NULL."; // weak
char aItSAnErrorToSe[65] = "It's an error to set both read_data_fn and write_data_fn in the "; // weak
char aMngFeaturesAre[50] = "MNG features are not allowed in a PNG datastream\n"; // weak
char aUnableToWriteI[36] = "Unable to write international text\n"; // weak
char aValidPaletteRe[44] = "Valid palette required for paletted images\n"; // weak
char aNoIdatsWritten[27] = "No IDATs written into file"; // weak
char aTheInfoStructA_0[71] = "The info struct allocated by the application for writing is too small."; // weak
char aThePngStructAl_0[70] = "The png struct allocated by the application for writing is too small."; // weak
char aApplicationUse_0[71] = "Application uses deprecated png_write_init() and should be recompiled."; // weak
char aPngWriteInfoWa[54] = "png_write_info was never called before png_write_row."; // weak
char aZlibError[11] = "zlib error"; // weak
char aUnknownFilterH[32] = "Unknown filter heuristic method"; // weak
char aIgnoringAttemp_0[52] = "Ignoring attempt to set negative chromaticity value"; // weak
char aIgnoringAttemp[62] = "Ignoring attempt to set chromaticity value exceeding 21474.83"; // weak
char aSettingGamma0[16] = "Setting gamma=0"; // weak
char aLimitingGammaT[27] = "Limiting gamma to 21474.83"; // weak
char aSettingNegativ[31] = "Setting negative gamma to zero"; // weak
char aInsufficientMe[41] = "Insufficient memory for hIST chunk data."; // weak
char aPaletteSize0Hi[41] = "Palette size 0, hIST allocation skipped."; // weak
char aWidthTooLargeT[63] = "Width too large to process image data; rowbytes will overflow."; // weak
char aInvalidFilterM[30] = "Invalid filter method in IHDR"; // weak
char aUnknownFilterM[30] = "Unknown filter method in IHDR"; // weak
char aUnknownCompres_1[35] = "Unknown compression method in IHDR"; // weak
char aUnknownInterla[33] = "Unknown interlace method in IHDR"; // weak
char aInvalidColorTy_0[49] = "Invalid color type/bit depth combination in IHDR"; // weak
char aInvalidColorTy[27] = "Invalid color type in IHDR"; // weak
char aInvalidBitDept[26] = "Invalid bit depth in IHDR"; // weak
char aInvalidImageSi[27] = "Invalid image size in IHDR"; // weak
char aImageWidthOrHe[38] = "Image width or height is zero in IHDR"; // weak
char aInsufficientMe_3[40] = "Insufficient memory for pCAL parameter."; // weak
char aInsufficientMe_2[37] = "Insufficient memory for pCAL params."; // weak
char aInsufficientMe_1[36] = "Insufficient memory for pCAL units."; // weak
char aInsufficientMe_0[38] = "Insufficient memory for pCAL purpose."; // weak
char aUnableToMalloc[25] = "Unable to malloc palette"; // weak
char aItxtChunkNotSu[26] = "iTXt chunk not supported."; // weak
char aNoMemoryForSpl[29] = "No memory for sPLT palettes."; // weak
char aOutOfMemoryWhi_0[46] = "Out of memory while processing unknown chunk."; // weak
char aCallToNullWrit[28] = "Call to NULL write function"; // weak
char aTheSameStructu[53] = "the same structure.  Resetting read_data_fn to NULL."; // weak
char aAttemptedToSet[56] = "Attempted to set both read_data_fn and write_data_fn in"; // weak
char aOutOfMemory[15] = "Out of Memory!"; // weak
char aOutOfMemory_0[14] = "Out of Memory"; // weak
char aErrorDecodingC[31] = "Error decoding compressed text"; // weak
char aCrcError[10] = "CRC error"; // weak
char aNotEnoughMemor_2[28] = "Not enough memory for text."; // weak
char aNotEnoughMemor_1[38] = "Not enough memory to decompress chunk"; // weak
char aNotEnoughMemor_0[40] = "Not enough memory to decompress chunk.."; // weak
char aNotEnoughMemor[39] = "Not enough memory to decompress chunk."; // weak
char aInvalidIhdrChu[19] = "Invalid IHDR chunk"; // weak
char aOutOfPlaceIhdr[18] = "Out of place IHDR"; // weak
char aTruncatingInco_0[44] = "Truncating incorrect info tRNS chunk length"; // weak
char aTruncatingInco[39] = "Truncating incorrect tRNS chunk length"; // weak
char aInvalidPalette[22] = "Invalid palette chunk"; // weak
char aIgnoringPlteCh[37] = "Ignoring PLTE chunk in grayscale PNG"; // weak
char aDuplicatePlteC[21] = "Duplicate PLTE chunk"; // weak
char aInvalidPlteAft[24] = "Invalid PLTE after IDAT"; // weak
char aMissingIhdrBef_0[25] = "Missing IHDR before PLTE"; // weak
char aIncorrectIendC[28] = "Incorrect IEND chunk length"; // weak
char aNoImageInFile[17] = "No image in file"; // weak
char aIgnoringIncorr[56] = "Ignoring incorrect gAMA value when sRGB is also present"; // weak
char aIgnoringGamaCh[33] = "Ignoring gAMA chunk with gamma=0"; // weak
char aDuplicateGamaC[21] = "Duplicate gAMA chunk"; // weak
char aOutOfPlaceGama[24] = "Out of place gAMA chunk"; // weak
char aInvalidGamaAft[24] = "Invalid gAMA after IDAT"; // weak
char aIncorrectGamaC[28] = "Incorrect gAMA chunk length"; // weak
char aMissingIhdrBef_1[25] = "Missing IHDR before gAMA"; // weak
char aDuplicateSbitC[21] = "Duplicate sBIT chunk"; // weak
char aOutOfPlaceSbit[24] = "Out of place sBIT chunk"; // weak
char aInvalidSbitAft[24] = "Invalid sBIT after IDAT"; // weak
char aIncorrectSbitC[28] = "Incorrect sBIT chunk length"; // weak
char aMissingIhdrBef_2[25] = "Missing IHDR before sBIT"; // weak
char aInvalidChrmWhi[25] = "Invalid cHRM white point"; // weak
char aInvalidChrmRed[23] = "Invalid cHRM red point"; // weak
char aInvalidChrmGre[25] = "Invalid cHRM green point"; // weak
char aInvalidChrmBlu[24] = "Invalid cHRM blue point"; // weak
char aIgnoringIncorr_0[56] = "Ignoring incorrect cHRM value when sRGB is also present"; // weak
char aDuplicateChrmC[21] = "Duplicate cHRM chunk"; // weak
char aMissingPlteBef_0[25] = "Missing PLTE before cHRM"; // weak
char aInvalidChrmAft[24] = "Invalid cHRM after IDAT"; // weak
char aIncorrectChrmC[28] = "Incorrect cHRM chunk length"; // weak
char aMissingIhdrBef_3[25] = "Missing IHDR before cHRM"; // weak
char aUnknownSrgbInt[20] = "Unknown sRGB intent"; // weak
char aDuplicateSrgbC[21] = "Duplicate sRGB chunk"; // weak
char aOutOfPlaceSrgb[24] = "Out of place sRGB chunk"; // weak
char aInvalidSrgbAft[24] = "Invalid sRGB after IDAT"; // weak
char aIncorrectSrgbC[28] = "Incorrect sRGB chunk length"; // weak
char aMissingIhdrBef_4[25] = "Missing IHDR before sRGB"; // weak
char aProfileSizeFie[43] = "Profile size field missing from iCCP chunk"; // weak
char aIgnoringTrunca[34] = "Ignoring truncated iCCP profile.\n"; // weak
char aIgnoringNonzer[48] = "Ignoring nonzero compression type in iCCP chunk"; // weak
char aMalformedIccpC[21] = "Malformed iCCP chunk"; // weak
char aDuplicateIccpC[21] = "Duplicate iCCP chunk"; // weak
char aOutOfPlaceIccp[24] = "Out of place iCCP chunk"; // weak
char aInvalidIccpAft[24] = "Invalid iCCP after IDAT"; // weak
char aMissingIhdrBef_5[25] = "Missing IHDR before iCCP"; // weak
char aSpltChunkHasBa[26] = "sPLT chunk has bad length"; // weak
char aMalformedSpltC[21] = "malformed sPLT chunk"; // weak
char aInvalidSpltAft[24] = "Invalid sPLT after IDAT"; // weak
char aMissingIhdrBef_6[25] = "Missing IHDR before sPLT"; // weak
char aTrnsChunkNotAl[42] = "tRNS chunk not allowed with alpha channel"; // weak
char aZeroLengthTrns[23] = "Zero length tRNS chunk"; // weak
char aIncorrectTrnsC[28] = "Incorrect tRNS chunk length"; // weak
char aDuplicateTrnsC[21] = "Duplicate tRNS chunk"; // weak
char aInvalidTrnsAft[24] = "Invalid tRNS after IDAT"; // weak
char aMissingPlteBef_1[25] = "Missing PLTE before tRNS"; // weak
char aMissingIhdrBef_7[25] = "Missing IHDR before tRNS"; // weak
char aIncorrectBkgdC_0[33] = "Incorrect bKGD chunk index value"; // weak
char aIncorrectBkgdC[28] = "Incorrect bKGD chunk length"; // weak
char aDuplicateBkgdC[21] = "Duplicate bKGD chunk"; // weak
char aMissingPlteBef_2[25] = "Missing PLTE before bKGD"; // weak
char aInvalidBkgdAft[24] = "Invalid bKGD after IDAT"; // weak
char aMissingIhdrBef_8[25] = "Missing IHDR before bKGD"; // weak
char aDuplicateHistC[21] = "Duplicate hIST chunk"; // weak
char aMissingPlteBef_3[25] = "Missing PLTE before hIST"; // weak
char aInvalidHistAft[24] = "Invalid hIST after IDAT"; // weak
char aIncorrectHistC[28] = "Incorrect hIST chunk length"; // weak
char aMissingIhdrBef_9[25] = "Missing IHDR before hIST"; // weak
char aDuplicatePhysC[21] = "Duplicate pHYs chunk"; // weak
char aInvalidPhysAft[24] = "Invalid pHYs after IDAT"; // weak
char aIncorrectPhysC[28] = "Incorrect pHYs chunk length"; // weak
char aMissingIhdrBef_10[25] = "Missing IHDR before pHYs"; // weak
char aDuplicateOffsC[21] = "Duplicate oFFs chunk"; // weak
char aInvalidOffsAft[24] = "Invalid oFFs after IDAT"; // weak
char aIncorrectOffsC[28] = "Incorrect oFFs chunk length"; // weak
char aMissingIhdrBef_11[25] = "Missing IHDR before oFFs"; // weak
char aNoMemoryForPca_0[27] = "No memory for pCAL params."; // weak
char aUnrecognizedEq[42] = "Unrecognized equation type for pCAL chunk"; // weak
char aInvalidPcalPar[42] = "Invalid pCAL parameters for equation type"; // weak
char aInvalidPcalDat[18] = "Invalid pCAL data"; // weak
char aDuplicatePcalC[21] = "Duplicate pCAL chunk"; // weak
char aInvalidPcalAft[24] = "Invalid pCAL after IDAT"; // weak
char aNoMemoryForPca[28] = "No memory for pCAL purpose."; // weak
char aMissingIhdrBef_12[25] = "Missing IHDR before pCAL"; // weak
char aInvalidScalDat[18] = "Invalid sCAL data"; // weak
char aMalformedHeigh[38] = "malformed height string in sCAL chunk"; // weak
char aMalformedWidth[37] = "malformed width string in sCAL chunk"; // weak
char aDuplicateScalC[21] = "Duplicate sCAL chunk"; // weak
char aInvalidScalAft[24] = "Invalid sCAL after IDAT"; // weak
char aOutOfMemoryWhi[42] = "Out of memory while processing sCAL chunk"; // weak
char aMissingIhdrBef_13[25] = "Missing IHDR before sCAL"; // weak
char aDuplicateTimeC[21] = "Duplicate tIME chunk"; // weak
char aIncorrectTimeC[28] = "Incorrect tIME chunk length"; // weak
char aOutOfPlaceTime[24] = "Out of place tIME chunk"; // weak
char aInsufficientMe_4[43] = "Insufficient memory to process text chunk."; // weak
char aNotEnoughMemor_3[41] = "Not enough memory to process text chunk."; // weak
char aNoMemoryToProc[33] = "No memory to process text chunk."; // weak
char aMissingIhdrBef_14[25] = "Missing IHDR before tEXt"; // weak
char aInsufficientMe_5[41] = "Insufficient memory to store zTXt chunk."; // weak
char aNotEnoughMemor_4[41] = "Not enough memory to process zTXt chunk."; // weak
char aUnknownCompres_2[39] = "Unknown compression type in zTXt chunk"; // weak
char aZeroLengthZtxt[23] = "Zero length zTXt chunk"; // weak
char aOutOfMemoryPro[37] = "Out of memory processing zTXt chunk."; // weak
char aMissingIhdrBef_15[25] = "Missing IHDR before zTXt"; // weak
char aUnknownCritica[23] = "unknown critical chunk"; // weak
char aInvalidChunkTy[19] = "invalid chunk type"; // weak
char aIgnoringBadAda[34] = "Ignoring bad adaptive filter type"; // weak
char aExtraCompressi[23] = "Extra compression data"; // weak
char aExtraCompresse_0[23] = "Extra compressed data."; // weak
char aDecompressionE_0[20] = "Decompression Error"; // weak
char aInvalidInterla[33] = "Invalid interlace type specified"; // weak
char aInvalidFilterT[30] = "Invalid filter type specified"; // weak
char aInvalidCompres[35] = "Invalid compression type specified"; // weak
char aInvalidImageCo[35] = "Invalid image color type specified"; // weak
char aInvalidBitDept_4[33] = "Invalid bit depth for RGBA image"; // weak
char aInvalidBitDept_3[44] = "Invalid bit depth for grayscale+alpha image"; // weak
char aInvalidBitDept_2[37] = "Invalid bit depth for paletted image"; // weak
char aInvalidBitDept_1[32] = "Invalid bit depth for RGB image"; // weak
char aInvalidBitDept_0[38] = "Invalid bit depth for grayscale image"; // weak
char aIgnoringReques[56] = "Ignoring request to write a PLTE chunk in grayscale PNG"; // weak
char aInvalidNumberO[36] = "Invalid number of colors in palette"; // weak
char aInvalidSrgbRen[40] = "Invalid sRGB rendering intent specified"; // weak
char aEmptyKeywordIn[28] = "Empty keyword in iCCP chunk"; // weak
char aUnknownCompres_3[39] = "Unknown compression type in iCCP chunk"; // weak
char aEmptyKeywordIn_0[28] = "Empty keyword in sPLT chunk"; // weak
char aInvalidSbitDep[29] = "Invalid sBIT depth specified"; // weak
char aInvalidChrmWhi_0[35] = "Invalid cHRM white point specified"; // weak
char aInvalidChrmRed_0[33] = "Invalid cHRM red point specified"; // weak
char aInvalidChrmGre_0[35] = "Invalid cHRM green point specified"; // weak
char aInvalidChrmBlu_0[34] = "Invalid cHRM blue point specified"; // weak
char aCanTWriteTrnsW[39] = "Can't write tRNS with an alpha channel"; // weak
char aIgnoringAttemp_2[64] = "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8"; // weak
char aIgnoringAttemp_1[64] = "Ignoring attempt to write tRNS chunk out-of-range for bit_depth"; // weak
char aInvalidNumberO_0[47] = "Invalid number of transparent colors specified"; // weak
char aIgnoringAttemp_4[64] = "Ignoring attempt to write bKGD chunk out-of-range for bit_depth"; // weak
char aIgnoringAttemp_3[64] = "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8"; // weak
char aInvalidBackgro[33] = "Invalid background palette index"; // weak
char aInvalidNumberO_1[46] = "Invalid number of histogram entries specified"; // weak
char aZeroLengthKeyw_0[20] = "zero length keyword"; // weak
char aKeywordLengthM[41] = "keyword length must be 1 - 79 characters"; // weak
char aZeroLengthKeyw[20] = "Zero length keyword"; // weak
char aExtraInteriorS[43] = "extra interior spaces removed from keyword"; // weak
char aLeadingSpacesR[36] = "leading spaces removed from keyword"; // weak
char aTrailingSpaces[37] = "trailing spaces removed from keyword"; // weak
char aEmptyKeywordIn_1[28] = "Empty keyword in tEXt chunk"; // weak
char aEmptyKeywordIn_2[28] = "Empty keyword in zTXt chunk"; // weak
char aUnrecognizedUn[38] = "Unrecognized unit type for oFFs chunk"; // weak
char aUnrecognizedUn_0[38] = "Unrecognized unit type for pHYs chunk"; // weak
char aInvalidTimeSpe[38] = "Invalid time specified for tIME chunk"; // weak
char aJpegmem[8] = "JPEGMEM"; // weak
double dbl_4C0FF0 =  0.5; // weak
double dbl_4C1032 =  0.5; // weak
double dbl_4C1090 = +Inf; // weak
char asc_4C1098[6] = " \t-\r]"; // weak
char asc_4C10A0[2] = "]"; // weak
char byte_4C10B0[16] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0'
}; // idb
float flt_4C10C0 =  0.9375; // weak
float flt_4C10C4 =  1.0625; // weak
float flt_4C10C8 =  9.223372e18; // weak
char byte_4C10CC[24] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '?'
}; // idb
double dbl_4C10E4 =  1.844674407370955e19; // weak
double dbl_4C10FC =  0.5; // weak
int (__fastcall *dword_4C1214)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int (__fastcall *dword_4C1218)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4C1820 = 0; // weak
int dword_4C1824 = 0; // weak
_UNKNOWN dword_4C1828; // weak
int dword_4C1830 = -1; // weak
int dword_4C1838[] = { 0 }; // weak
int dword_4C183C[] = { 0 }; // weak
int dword_4C1840[] = { 0 }; // weak
int dword_4C1844[] = { 0 }; // weak
_BYTE byte_4C1848[496] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_DWORD dword_4C1A38 = 4194304; // idb
int dword_4C1A40 = 0; // weak
char byte_4C1A44 = '\x01'; // weak
int dword_4C1A48 = 0; // weak
int dword_4C1A4C = 0; // weak
int dword_4C1A54 = 0; // weak
int dword_4C1A58 = 0; // weak
__int64 qword_4C1A60 = 0i64; // weak
double dbl_4C1A68 =  0.0; // weak
double dbl_4C1A70 =  0.0; // weak
char byte_4C1A78 = '\0'; // weak
void *off_4C1A7C = (void *)0x47A294; // weak
char byte_4C1A80 = '\0'; // weak
int dword_4C1A88 = 0; // weak
int dword_4C1A8C = 0; // weak
int dword_4C1A90 = 0; // weak
int dword_4C1A94 = 0; // weak
_DWORD dword_4C1A98 = 0; // idb
char byte_4C1A9C = '\0'; // weak
int dword_4C1AA0 = 0; // weak
int dword_4C1AA4 = 0; // weak
int dword_4C1AA8 = 0; // weak
int dword_4C1AAC = 0; // weak
char byte_4C1AB4 = '\0'; // weak
int dword_4C1AB8 = 0; // weak
int dword_4C1ABC = 0; // weak
int dword_4C1AC0 = 0; // weak
int dword_4C1AC4 = 0; // weak
int dword_4C1AC8 = 0; // weak
int dword_4C1AD0 = 65524; // weak
_DWORD dword_4C1AD4 = 2752512; // idb
char byte_4C1AD8 = '\x01'; // weak
_DWORD dword_4C1ADC = 252; // idb
char byte_4C1AE0 = '\0'; // weak
int dword_4C1AE4 = -44967854; // weak
int dword_4C1AE8 = 0; // weak
int dword_4C1AEC = 0; // weak
int dword_4C1AF0 = 0; // weak
int dword_4C1AF4 = 0; // weak
char byte_4C1AF8 = '\0'; // weak
int dword_4C1AFC = 46968784; // weak
int dword_4C1B00 = 0; // weak
int dword_4C1B04 = 0; // weak
int dword_4C1B08 = 0; // weak
int dword_4C1B0C = 0; // weak
int dword_4C1B14 = 0; // weak
int dword_4C1B18 = 0; // weak
int dword_4C1B2C = 1; // weak
int dword_4C1B30 = 36049888; // weak
int dword_4C1B38 = 36049944; // weak
int dword_4C1B3C = 0; // weak
int dword_4C1B40 = 0; // weak
char *off_4C1B48 = "F:\\Games\\Continuum\\Continuum.exe"; // weak
char byte_4C1B50 = '\0'; // weak
int dword_4C1B54 = 0; // weak
int dword_4C1B58 = 0; // weak
int dword_4C1B60 = 0; // weak
int dword_4C1B68 = 788452; // weak
__int16 word_4C1B6E = 30; // weak
int dword_4C1B70 = 1572865; // weak
char *dword_4C1B78 = NULL; // idb
int dword_4C1B80 = 0; // weak
int (__stdcall *dword_4C1BE8)(_DWORD) = NULL; // weak
int dword_4C1BEC = 0; // weak
int dword_4C1BF0 = 0; // weak
int (__cdecl *dword_4C1BF4)(_DWORD) = NULL; // weak
_WORD word_4C1BF8[2] = { 0, 0 }; // idb
__int16 word_4C1BFC = 0; // weak
int dword_4C1C00 = 0; // weak
_DWORD dword_4C1C04[2] = { 0, 0 }; // idb
int dword_4C1C0C = 0; // weak
int dword_4C1C10 = 0; // weak
int dword_4C1C14 = 0; // weak
int dword_4C1C18 = 0; // weak
_DWORD dword_4C1C1C = 0; // idb
int dword_4C1C20 = 0; // weak
int dword_4C1C24 = 1; // weak
int dword_4C1C28 = 0; // weak
int dword_4C1C2C[3] = { 0, 0, 0 }; // idb
int dword_4C1C38 = 1; // weak
int dword_4C1C40 = 300; // weak
wchar_t aEasternStandar[22] = L"Eastern Standard Time"; // weak
__int16 word_4C1C84 = 0; // weak
__int16 word_4C1C86 = 11; // weak
__int16 word_4C1C88 = 0; // weak
__int16 word_4C1C8A = 1; // weak
__int16 word_4C1C8C = 2; // weak
__int16 word_4C1C8E = 0; // weak
__int16 word_4C1C90 = 0; // weak
__int16 word_4C1C92 = 0; // weak
int dword_4C1C94 = 0; // weak
wchar_t aEasternDayligh[22] = L"Eastern Daylight Time"; // weak
__int16 word_4C1CD8 = 0; // weak
__int16 word_4C1CDA = 3; // weak
__int16 word_4C1CDC = 0; // weak
__int16 word_4C1CDE = 2; // weak
__int16 word_4C1CE0 = 2; // weak
__int16 word_4C1CE2 = 0; // weak
__int16 word_4C1CE4 = 0; // weak
__int16 word_4C1CE6 = 0; // weak
int dword_4C1CE8 = -60; // weak
char *dword_4C1CEC = NULL; // idb
int dword_4C1CF0 = 1; // weak
_UNKNOWN unk_4C1CF8; // weak
char aFGamesContinuu[33] = "F:\\Games\\Continuum\\Continuum.exe"; // weak
int dword_4C1E20 = 1; // weak
int (*dword_4C1E24)(void) = NULL; // weak
int dword_4C1E28 = 1; // weak
int dword_4C1E2C = 0; // weak
int dword_4C1E30 = 0; // weak
int dword_4C1E34 = 0; // weak
int dword_4C1E38 = 0; // weak
int dword_4C1E3C = 0; // weak
int dword_4C1E40 = 0; // weak
int dword_4C1E44 = 0; // weak
__int16 word_4C1E54 = 0; // weak
__int16 word_4C1E5C = 0; // weak
__int16 word_4C1E62 = 0; // weak
__int16 word_4C1E66 = 0; // weak
__int16 word_4C1E68 = 0; // weak
_DWORD dword_4C1E6C = 0; // idb
int dword_4C1E70 = 0; // weak
size_t MaxCount = 0u; // idb
int dword_4C1E78 = 0; // weak
char *dword_4C1E7C = NULL; // idb
char *String1 = NULL; // idb
int dword_4C1E84 = 0; // weak
_DWORD dword_4C1E88 = 0; // idb
int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4C1E90 = 1; // weak
int (__stdcall *dword_4C1E94)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (*dword_4C1E98)(void) = NULL; // weak
int (__stdcall *dword_4C1E9C)(_DWORD) = NULL; // weak
int dword_4C1EA0 = 0; // weak
int dword_4C1EA4 = 0; // weak
int dword_4C1EA8 = 0; // weak
int dword_4C1EAC = 0; // weak
int dword_4C1EB0 = 0; // weak
WCHAR word_4C1EB8[4] = { 0u, 0u, 0u, 0u }; // idb
_UNKNOWN unk_4C1EC0; // weak
int dword_4C1EC4 = 0; // weak
int dword_4C1EC8 = 0; // weak
int dword_4C1ECC = 0; // weak
int dword_4C1ED0 = 0; // weak
int dword_4C1ED4 = 1; // weak
int dword_4C1ED8 = 0; // weak
int dword_4C1EDC = 0; // weak
_DWORD dword_4C1EE0 = 1252; // idb
_DWORD dword_4C1EF0[3] = { 0, 0, 0 }; // idb
int dword_4C1EFC = 0; // weak
char byte_4C1F00[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'h',
  'i',
  'j',
  'k',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '\0',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '\0',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
}; // idb
_UNKNOWN unk_4C2000; // weak
char byte_4C2001[259] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x10',
  '\0',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  ' ',
  '\0',
  ' ',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\0',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  '\0',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  ' ',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_4C2104 = 0; // weak
int dword_4C2120[] = { 36046936 }; // weak
_UNKNOWN unk_4C2124; // weak
_UNKNOWN dword_4C2220; // weak
int dword_4C2224 = 37019704; // weak
int dword_4C3240 = 512; // weak
int dword_4C3244 = 0; // weak
int dword_4C3248 = 0; // weak
int dword_4C324C = 0; // weak
int dword_4C3250 = 0; // weak
int dword_4C3254 = 0; // weak
int dword_4C325C = 0; // weak
int dword_4C3260 = 0; // weak
_DWORD dword_4C3264 = 0; // idb
int dword_4C3268 = 0; // weak
_DWORD dword_4C326C = 36044800; // idb
int dword_4C3270 = 1; // weak
int dword_4C3278 = 3093088; // weak
int dword_4C327C = 1; // weak
int dword_4C3280 = 1; // weak
int dword_4C3284 = 36069116; // weak
int dword_4C3288 = 36069104; // weak
_UNKNOWN loc_4C9012; // weak
int dword_5189D8[512] =
{
  -896524790,
  -2001588083,
  -139445164,
  -2126396840,
  -805092530,
  1655079025,
  -436265864,
  -1098976478,
  -1714357923,
  1109540129,
  -1315761740,
  1603659081,
  -1086637830,
  -1408543125,
  -1725738825,
  -1974061179,
  -1838910946,
  -1406847797,
  -1893321274,
  656412689,
  -1893198780,
  -1565190126,
  2080511028,
  1048078677,
  -141361141,
  833418493,
  -2127403062,
  -223616444,
  1344460350,
  -904305613,
  2048472120,
  874914667,
  900866357,
  882981942,
  605291063,
  1164278072,
  -1000998768,
  1508709498,
  271987350,
  398186975,
  509810815,
  324304404,
  -1835903593,
  608831558,
  2021255202,
  2123599764,
  -1826431324,
  149809020,
  1720862352,
  -1978510890,
  99503627,
  -364693318,
  1346046964,
  1534868423,
  -2124551739,
  -1462293708,
  1736214306,
  -1830256012,
  1314698381,
  570944323,
  -1011310573,
  -1262820935,
  452589337,
  -1859641823,
  -1943463532,
  87976782,
  -1023800454,
  1743858864,
  965368869,
  1389495388,
  682373791,
  -1608242127,
  305168778,
  1049643400,
  55702446,
  1085870535,
  1955438867,
  1406309866,
  64268955,
  -1894796864,
  771013715,
  -310366753,
  -1496098775,
  -1249752328,
  2120076919,
  743354753,
  1259203168,
  1263857918,
  -1564414956,
  -2072952201,
  445935203,
  336750508,
  -1707993513,
  622737675,
  -2056558738,
  739800360,
  981806882,
  -919390749,
  51072011,
  1566446273,
  1613281425,
  21359965,
  -65972902,
  1518263553,
  -1542253301,
  -963448201,
  -334032559,
  -435452986,
  2022264079,
  -1866339217,
  -1457414819,
  -1203546345,
  550357909,
  1897987789,
  126554646,
  531137111,
  -598067242,
  -1216060982,
  -880132976,
  294672,
  1232378155,
  -1105507308,
  1258994716,
  1965070642,
  838671915,
  -1672324409,
  1248418842,
  173830560,
  701276751,
  722785552,
  163943163,
  -2060138388,
  921384372,
  1572361229,
  709085736,
  -1255675084,
  -705815356,
  -924147115,
  157107202,
  55580781,
  -1815105213,
  1715442190,
  -524323740,
  670990806,
  -1887499332,
  -1521972650,
  1435242305,
  7820605,
  40401283,
  1888319612,
  -1822555044,
  1963454258,
  -61952038,
  -1026968110,
  327205672,
  -1258402278,
  377554087,
  144919611,
  1703150115,
  335826700,
  102834962,
  136647705,
  176756744,
  388852578,
  224264041,
  550089004,
  1808165649,
  403285730,
  -1399680139,
  -385304463,
  -1139034815,
  -473881451,
  -838909934,
  625278492,
  -1694223661,
  288554517,
  1101049996,
  -1692099941,
  1904380357,
  -621391506,
  1079779548,
  -1986429323,
  1428291344,
  1678296007,
  1146046590,
  689195263,
  698442786,
  -548388510,
  646552399,
  1982540868,
  1658961373,
  1519610228,
  1512794408,
  508251205,
  1230392105,
  -1039946088,
  486233444,
  -1703473501,
  -95266422,
  -602385979,
  412961964,
  1250512712,
  -1536456307,
  1327956346,
  -755979969,
  1274639510,
  1309352338,
  827843152,
  244585548,
  -108967999,
  1977315438,
  -664650489,
  -1188858857,
  -1389545996,
  -870823291,
  -1652155237,
  73503221,
  999843182,
  1995066270,
  1404126720,
  -521662574,
  1844242213,
  1580008186,
  1588835011,
  1082216350,
  2055769360,
  1976654113,
  272326382,
  1247971331,
  -527873755,
  -1032225655,
  -192493630,
  -1232346588,
  821174413,
  1113460879,
  1770634627,
  1927000590,
  -714992623,
  -103457059,
  -1546196720,
  372474132,
  -746024567,
  310143569,
  -2021125556,
  1380989754,
  -1875372929,
  -1528210272,
  580164756,
  -901619060,
  1653258770,
  -1235144640,
  -1377681644,
  -1941858956,
  1766276941,
  1228386494,
  1555643653,
  -2095352576,
  1920143097,
  1537259892,
  782075828,
  -309530942,
  92147680,
  149831131,
  201537314,
  -1531359117,
  -1873980358,
  697059576,
  187828084,
  -1887781371,
  211877624,
  1754564873,
  -1654894835,
  -277077165,
  2135289716,
  323693073,
  -1045999094,
  -1823500678,
  -55373054,
  1317252243,
  406408172,
  1234257129,
  2045199069,
  537044855,
  -576671006,
  -1053829945,
  377188199,
  -1785464725,
  -267436639,
  543330196,
  1659664721,
  -953941638,
  1760497594,
  -1047213837,
  746959319,
  1077452993,
  -232630896,
  942858064,
  273682918,
  -1031187408,
  41875314,
  -2092901885,
  1703477995,
  678517335,
  1233029768,
  -27811967,
  630197551,
  -1951900552,
  293464852,
  -2077578588,
  -911085182,
  456249517,
  1929802719,
  2029720623,
  1200438299,
  -231160246,
  1344557647,
  -1135891998,
  -703847128,
  -1853201669,
  1578940262,
  348425480,
  -419670392,
  214175123,
  -1326410720,
  -1535064070,
  -195053047,
  -1845521542,
  1160113088,
  -748862001,
  673833705,
  1989682106,
  891030609,
  1172302205,
  -1421404483,
  1242637958,
  -907340776,
  2035968552,
  1110157856,
  -2047438331,
  315314320,
  826154857,
  1913799075,
  168105590,
  201397128,
  1196245059,
  1242604196,
  -420803367,
  -1521978860,
  947128711,
  306022795,
  317505665,
  179392649,
  756697835,
  682369293,
  -123050691,
  -948631538,
  -743819383,
  141985598,
  1974202923,
  1109408665,
  -1860919078,
  -533886888,
  1980003474,
  -2098262296,
  810090917,
  -590023993,
  -1315922065,
  1849127112,
  1523581715,
  298600738,
  -346144058,
  61869399,
  -397337517,
  2147458233,
  -1844507221,
  1092795930,
  -1864282608,
  -1576504753,
  -1977191968,
  1138888574,
  653742416,
  -1631745512,
  1572184607,
  -2064928517,
  -1822425460,
  1972642704,
  207498742,
  750986508,
  343705824,
  -1964044088,
  -1994912641,
  -124614012,
  -500346914,
  -1209045939,
  1494287408,
  860930900,
  398969144,
  200479712,
  1891767355,
  1879836584,
  537923718,
  1216941077,
  -2123626904,
  1881178900,
  374015240,
  -931433425,
  114784449,
  1418207243,
  1894100850,
  -1736057670,
  1595926540,
  -2019679197,
  -793665484,
  1582039037,
  -923784978,
  -1383509603,
  1347589600,
  206276280,
  1753685756,
  -1085639512,
  268292313,
  -591101696,
  -612543326,
  832975360,
  -10384931,
  -1150503036,
  2122561600,
  1283195752,
  1443965447,
  1076454408,
  959362299,
  363751666,
  1530952887,
  -1432562459,
  -1867480750,
  372995853,
  -32997516,
  -1970421409,
  2027789035,
  -1021694668,
  -902071266,
  832902043,
  722173893,
  1048975546,
  -766999106,
  2010597975,
  152131644,
  1921845898,
  215523549,
  -114951808,
  1664485168,
  -193652666,
  1362375705,
  739389448,
  608708644,
  88875153,
  -283623393,
  -264076310,
  -844042432,
  -1171718844,
  1937424983,
  1249430133,
  -30987053,
  -1567168430,
  -580973542,
  166326363,
  1822560656,
  341723630,
  -1961850049,
  -1491830008,
  1581396178,
  1149724924,
  1430203240,
  1514565282,
  1619535065,
  351725603,
  -80785761,
  607860743,
  1209562180,
  -916501498,
  804540424,
  -1923816337,
  -111312509,
  417984600,
  -1390179010,
  1626431816,
  877053712,
  -1002442624,
  -1369172978,
  -1555044897,
  552997648,
  -1498275607,
  1418334392,
  -802065001,
  -1922744130,
  1739606095,
  -2013003111,
  816545936,
  -294302068,
  1750452408,
  -260431843,
  935715984,
  -668855919,
  -1425239032,
  -514970225,
  -1520721826,
  1007651090,
  170011749,
  -2128741274,
  776202599,
  -339463730,
  1938665256
}; // weak


//----- (00401000) --------------------------------------------------------
int __fastcall sub_401000(int a1, unsigned int a2, unsigned int *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned __int64 v6; // rax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  int v9; // edx
  int v10; // kr08_4
  bool v11; // cf

  v4 = 0;
  HIDWORD(v6) = 0;
  if ( (a4 & 1) == 0 )
    goto LABEL_3;
  v7 = *a3;
  v4 = 1;
  v8 = 0;
  while ( 1 )
  {
    v6 = a2 * (unsigned __int64)v7;
    HIDWORD(v6) = (*(unsigned int *)(a1 + 4 * v4 - 4) + v6 + v8) >> 32;
    *(_DWORD *)(a1 + 4 * v4 - 4) += v6 + v8;
    if ( v4 >= a4 )
      break;
LABEL_3:
    LODWORD(v6) = a3[v4 + 1];
    v10 = a2 * a3[v4] + HIDWORD(v6);
    v9 = (a2 * (unsigned __int64)a3[v4] + HIDWORD(v6)) >> 32;
    v11 = __CFADD__(v10, *(_DWORD *)(a1 + 4 * v4));
    *(_DWORD *)(a1 + 4 * v4) += v10;
    v8 = v11 + v9;
    v4 += 2;
  }
  *(_DWORD *)(a1 + 4 * v4) = HIDWORD(v6);
  return v6;
}

//----- (00401170) --------------------------------------------------------
_DWORD *__fastcall sub_401170(unsigned int a1, _DWORD *a2, int a3, unsigned int *a4)
{
  unsigned int v4; // eax
  unsigned __int64 v5; // rtt
  unsigned int *v6; // esi
  unsigned int *v7; // edi
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned __int64 v10; // rax
  __int64 v11; // rax
  int v12; // edx
  unsigned int v13; // eax
  unsigned __int64 v14; // rax
  bool v15; // cf
  unsigned int v16; // esi
  unsigned int *v17; // eax
  unsigned int v18; // ecx
  int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // edx
  unsigned int v22; // eax
  unsigned int v23; // eax
  signed int v24; // edx
  unsigned int v25; // edx
  _DWORD *result; // eax
  unsigned int *v28; // [esp+4h] [ebp-18h]
  unsigned int v29; // [esp+Ch] [ebp-10h]
  unsigned int v30; // [esp+10h] [ebp-Ch]
  unsigned int v31; // [esp+14h] [ebp-8h]
  int v32; // [esp+18h] [ebp-4h]

  v30 = a1;
  v4 = a4[a1 - 1];
  v29 = 0;
  if ( v4 == -1 )
  {
    v31 = 0;
  }
  else
  {
    v31 = v4 + 1;
    LODWORD(v5) = 0;
    HIDWORD(v5) = -(v4 + 1);
    v29 = v5 / (v4 + 1);
  }
  v32 = a3 + 4 * a1 - 4;
  while ( 1 )
  {
    v28 = (unsigned int *)(v32 + 4 * a1);
    v6 = (unsigned int *)v32;
    v7 = a4;
    v8 = *v28;
    if ( v31 )
    {
      v9 = ((v29 * (unsigned __int64)*v28) >> 32) + v8;
      v10 = v31 * (unsigned __int64)v9 - *(_QWORD *)(v28 - 1);
      LODWORD(v11) = *(v28 - 1) - v31 * v9;
      for ( HIDWORD(v11) = -((*(v28 - 1) != v31 * v9) + HIDWORD(v10)); HIDWORD(v11); v11 -= v31 )
        ++v9;
      v8 = v9 - (((unsigned int)v11 < v31) - 1);
    }
    v12 = 0;
    do
    {
      v13 = *v7;
      ++v6;
      ++v7;
      v14 = (unsigned int)v12 + v8 * (unsigned __int64)v13;
      v15 = *(v6 - 1) < (unsigned int)v14;
      *(v6 - 1) -= v14;
      v12 = v15 + HIDWORD(v14);
    }
    while ( v6 < v28 );
    *v6 -= v12;
    while ( 1 )
    {
      if ( !*v28 )
      {
        v16 = v30 - 1;
        if ( v30 )
          break;
      }
LABEL_19:
      v20 = 0;
      v21 = 0;
      do
      {
        v22 = *(_DWORD *)(v32 + 4 * v20);
        v15 = v22 < v21;
        v23 = v22 - v21;
        v21 = (v23 < a4[v20]) + v15;
        *(_DWORD *)(v32 + 4 * v20) = v23 - a4[v20];
        ++v20;
      }
      while ( v20 < v30 );
      *(_DWORD *)(v32 + 4 * v20) -= v21;
    }
    v17 = &a4[v16];
    while ( 1 )
    {
      v18 = *(unsigned int *)((char *)v17 + v32 - (_DWORD)a4);
      if ( v18 < *v17 )
        break;
      if ( v18 <= *v17 )
      {
        v19 = v16--;
        --v17;
        if ( v19 )
          continue;
      }
      goto LABEL_19;
    }
    v24 = (v32 - a3) & 0xFFFFFFFC;
    v32 -= 4;
    if ( v24 <= 0 )
      break;
    a1 = v30;
  }
  v25 = v30;
  result = a2;
  do
  {
    *result = *(_DWORD *)((char *)result + a3 - (_DWORD)a2);
    ++result;
    --v25;
  }
  while ( v25 );
  return result;
}
// 4012A3: conditional instruction was optimized away because of '%var_C.4!=0'

//----- (004013A0) --------------------------------------------------------
_DWORD *__fastcall sub_4013A0(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, unsigned int a5)
{
  unsigned int v5; // ebx
  _DWORD *v6; // edx
  _QWORD *v7; // esi
  unsigned int *v8; // edi
  _DWORD *v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // ecx
  int v14; // edx
  unsigned int v15; // kr10_4
  bool v16; // cf
  int v17; // ebx
  unsigned int v18; // ecx
  unsigned __int64 v19; // kr30_8
  unsigned __int64 v20; // kr40_8
  _DWORD *v23; // [esp+10h] [ebp-20h]
  _DWORD *v24; // [esp+14h] [ebp-1Ch]
  unsigned int v25; // [esp+1Ch] [ebp-14h]
  unsigned int v26; // [esp+20h] [ebp-10h]
  unsigned int *v27; // [esp+24h] [ebp-Ch]
  _DWORD *v28; // [esp+28h] [ebp-8h]
  int v29; // [esp+2Ch] [ebp-4h]

  v5 = a5;
  v6 = a1;
  v23 = a1;
  if ( a5 )
  {
    v7 = (_QWORD *)a3;
    v8 = a1;
    do
    {
      *v7 = *v8 * (unsigned __int64)*v8;
      ++v8;
      ++v7;
      --v5;
    }
    while ( v5 );
    v6 = a1;
    v5 = a5;
  }
  memset(a4, 0, 8 * v5 - 8);
  v29 = 1;
  if ( v5 > 1 )
  {
    v9 = v6 + 1;
    v28 = v6 + 1;
    v27 = a4;
    while ( 1 )
    {
      v24 = v9;
      v26 = *(v9 - 1);
      v25 = v5 - v29;
      v10 = 0;
      v11 = 0;
      if ( (v25 & 1) != 0 )
      {
        v12 = *v9;
        v10 = 1;
        v13 = 0;
        goto LABEL_11;
      }
      do
      {
        v12 = v24[v10 + 1];
        v15 = v26 * v24[v10] + v11;
        v14 = (v26 * (unsigned __int64)(unsigned int)v24[v10] + v11) >> 32;
        v16 = __CFADD__(v15, v27[v10]);
        v27[v10] += v15;
        v13 = v16 + v14;
        v10 += 2;
LABEL_11:
        v11 = (v27[v10 - 1] + v26 * (unsigned __int64)v12 + v13) >> 32;
        v27[v10 - 1] += v26 * v12 + v13;
      }
      while ( v10 < v25 );
      v27[v10] = v11;
      v16 = ++v29 < a5;
      ++v28;
      v27 += 2;
      if ( !v16 )
        break;
      v9 = v28;
      v5 = a5;
    }
  }
  v17 = 0;
  v18 = 0;
  while ( ++v17 < a5 )
  {
    v19 = a4[2 * v17 - 2] + a4[2 * v17 - 2] + v18 + (unsigned __int64)*(unsigned int *)(a3 + 8 * v17 - 4);
    *(_DWORD *)(a3 + 8 * v17 - 4) = v19;
    v20 = a4[2 * v17 - 1] + a4[2 * v17 - 1] + HIDWORD(v19) + (unsigned __int64)*(unsigned int *)(a3 + 8 * v17);
    v18 = HIDWORD(v20);
    *(_DWORD *)(a3 + 8 * v17) = v20;
  }
  *(_DWORD *)(a3 + 8 * v17 - 4) += v18;
  return sub_401170(a5, v23, a3, a2);
}

//----- (00401520) --------------------------------------------------------
_DWORD *__fastcall sub_401520(unsigned int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int *a5)
{
  unsigned int v5; // ebx
  int v6; // eax
  _DWORD *result; // eax
  int v8; // edx
  unsigned int v9; // esi
  char *v10; // eax
  int v11; // ecx
  unsigned int v12; // ebx
  char *v13; // edi
  unsigned int v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // ecx
  int v17; // edx
  unsigned int v18; // kr10_4
  bool v19; // cf
  bool v20; // zf
  _DWORD *v21; // esi
  char *v22; // eax
  int v23; // ecx
  unsigned int v24; // ebx
  char *v25; // edi
  unsigned int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // ecx
  int v29; // edx
  unsigned int v30; // kr28_4
  unsigned int v31; // edi
  unsigned int v32; // eax
  int v33; // ecx
  int v34; // edx
  int v35; // ecx
  int v36; // edi
  _DWORD *v37; // eax
  int v38; // ecx
  unsigned int v39; // ebx
  _DWORD *v40; // edi
  unsigned int v41; // edx
  unsigned int v42; // eax
  unsigned int v43; // ecx
  int v44; // edx
  unsigned int v45; // kr40_4
  int v46; // edi
  unsigned int v47; // [esp+10h] [ebp-34h]
  int v48; // [esp+10h] [ebp-34h]
  unsigned int v49; // [esp+14h] [ebp-30h]
  unsigned int v50; // [esp+14h] [ebp-30h]
  unsigned int v51; // [esp+14h] [ebp-30h]
  unsigned int v52; // [esp+18h] [ebp-2Ch]
  unsigned int *v53; // [esp+1Ch] [ebp-28h]
  unsigned int v54; // [esp+20h] [ebp-24h]
  unsigned int v55; // [esp+20h] [ebp-24h]
  unsigned int v56; // [esp+20h] [ebp-24h]
  char *v57; // [esp+24h] [ebp-20h]
  unsigned int v58; // [esp+28h] [ebp-1Ch]
  char *v59; // [esp+28h] [ebp-1Ch]
  _DWORD *v60; // [esp+28h] [ebp-1Ch]
  unsigned int v61; // [esp+2Ch] [ebp-18h]
  char *v62; // [esp+2Ch] [ebp-18h]
  unsigned int v63; // [esp+2Ch] [ebp-18h]
  unsigned int *v64; // [esp+30h] [ebp-14h]
  _DWORD *v65; // [esp+34h] [ebp-10h]
  int v66; // [esp+34h] [ebp-10h]
  _DWORD *v67; // [esp+38h] [ebp-Ch]

  v5 = a1;
  v6 = 32 * a1;
  v61 = 32 * a1;
  if ( 32 * a1 )
  {
    while ( ((a4[(unsigned int)(v6 - 1) >> 5] >> ((v6 - 1) & 0x1F)) & 1) == 0 )
    {
      v61 = v6 - 1;
      if ( v6 == 1 )
        break;
      --v6;
    }
  }
  result = a3;
  v49 = 4 * a1;
  qmemcpy(a3, a2, 4 * ((4 * a1) >> 2));
  v8 = (int)&a3[16 * a1];
  v67 = (_DWORD *)v8;
  v64 = &a3[18 * a1];
  if ( v61 >= 0x3C )
  {
    v65 = &a3[15 * a1];
    qmemcpy(v65, a2, v49);
    sub_4013A0(v65, a5, v8, v64, a1);
    v57 = (char *)a3;
    if ( a3 >= v65 )
    {
      v21 = &a3[16 * v5];
    }
    else
    {
      v47 = 8 * v5;
      do
      {
        v21 = v67;
        memset(v67, 0, v47);
        if ( v5 )
        {
          v22 = (char *)v67;
          v23 = v57 - (char *)v67;
          v59 = (char *)v67;
          v52 = v5;
          while ( 1 )
          {
            v55 = *(_DWORD *)&v22[v23];
            v24 = 0;
            v25 = v22;
            v26 = 0;
            if ( (a1 & 1) != 0 )
            {
              v27 = *v65;
              v24 = 1;
              v28 = 0;
              goto LABEL_34;
            }
            do
            {
              v27 = v65[v24 + 1];
              v30 = v55 * v65[v24] + v26;
              v29 = (v55 * (unsigned __int64)(unsigned int)v65[v24] + v26) >> 32;
              v19 = __CFADD__(v30, *(_DWORD *)&v25[4 * v24]);
              *(_DWORD *)&v25[4 * v24] += v30;
              v28 = v19 + v29;
              v24 += 2;
LABEL_34:
              v26 = (*(unsigned int *)&v25[4 * v24 - 4] + v55 * (unsigned __int64)v27 + v28) >> 32;
              *(_DWORD *)&v25[4 * v24 - 4] += v55 * v27 + v28;
            }
            while ( v24 < a1 );
            *(_DWORD *)&v25[4 * v24] = v26;
            v20 = v52 == 1;
            v59 += 4;
            --v52;
            if ( v20 )
              break;
            v22 = v59;
            v23 = v57 - (char *)v67;
          }
          v5 = a1;
          v21 = v67;
        }
        v57 += v49;
        sub_401170(v5, v57, (int)v21, a5);
      }
      while ( v57 < (char *)v65 );
    }
    v31 = v61 - 1;
    do
    {
      sub_4013A0(a2, a5, (int)v21, v64, v5);
      v63 = --v31;
      result = (_DWORD *)(a4[v31 >> 5] >> (v31 & 0x1F));
      if ( ((unsigned __int8)result & 1) != 0 )
      {
        v32 = 1;
        v33 = 1;
        v66 = 1;
        v50 = 1;
        while ( v31 )
        {
          v63 = v31 - 1;
          v66 = ((a4[v63 >> 5] >> (v63 & 0x1F)) & 1) + 2 * v32;
          v32 = v66;
          v33 = ++v50;
          if ( v50 >= 5 )
            break;
          --v31;
        }
        v34 = 0;
        v48 = 0;
        if ( (v32 & 1) == 0 )
        {
          do
          {
            v32 >>= 1;
            ++v34;
            --v33;
          }
          while ( (v32 & 1) == 0 );
          v48 = v34;
          v66 = v32;
        }
        v35 = v33 - 1;
        if ( v35 )
        {
          v36 = v35;
          do
          {
            sub_4013A0(a2, a5, (int)v21, v64, v5);
            --v36;
          }
          while ( v36 );
          v32 = v66;
        }
        v53 = &a3[v5 * (v32 >> 1)];
        memset(v21, 0, 4 * ((8 * v5) >> 2));
        if ( v5 )
        {
          v37 = v21;
          v38 = (char *)a2 - (char *)v21;
          v60 = v21;
          v56 = v5;
          while ( 1 )
          {
            v51 = *(_DWORD *)((char *)v37 + v38);
            v39 = 0;
            v40 = v37;
            v41 = 0;
            if ( (a1 & 1) != 0 )
            {
              v42 = *v53;
              v39 = 1;
              v43 = 0;
              goto LABEL_59;
            }
            do
            {
              v42 = v53[v39 + 1];
              v45 = v51 * v53[v39] + v41;
              v44 = (v51 * (unsigned __int64)v53[v39] + v41) >> 32;
              v19 = __CFADD__(v45, v40[v39]);
              v40[v39] += v45;
              v43 = v19 + v44;
              v39 += 2;
LABEL_59:
              v41 = ((unsigned int)v40[v39 - 1] + v51 * (unsigned __int64)v42 + v43) >> 32;
              v40[v39 - 1] += v51 * v42 + v43;
            }
            while ( v39 < a1 );
            v40[v39] = v41;
            v20 = v56 == 1;
            ++v60;
            --v56;
            if ( v20 )
              break;
            v38 = (char *)a2 - (char *)v21;
            v37 = v60;
          }
          v5 = a1;
          v21 = v67;
        }
        sub_401170(v5, a2, (int)v21, a5);
        result = (_DWORD *)(v48 - 1);
        if ( v48 )
        {
          v46 = v48;
          do
          {
            result = sub_4013A0(a2, a5, (int)v21, v64, v5);
            --v46;
          }
          while ( v46 );
        }
        v31 = v63;
      }
    }
    while ( v31 );
  }
  else if ( v61 )
  {
    v9 = v61 - 1;
    if ( v61 != 1 )
    {
      while ( 1 )
      {
        sub_4013A0(a2, a5, v8, v64, v5);
        result = a4;
        --v9;
        if ( ((a4[v9 >> 5] >> (v9 & 0x1F)) & 1) != 0 )
        {
          memset(v67, 0, 4 * ((8 * v5) >> 2));
          if ( v5 )
          {
            v10 = (char *)v67;
            v11 = (char *)a2 - (char *)v67;
            v62 = (char *)v67;
            v54 = v5;
            while ( 1 )
            {
              v58 = *(_DWORD *)&v10[v11];
              v12 = 0;
              v13 = v10;
              v14 = 0;
              if ( (a1 & 1) != 0 )
              {
                v15 = *a3;
                v12 = 1;
                v16 = 0;
                goto LABEL_20;
              }
              do
              {
                v15 = a3[v12 + 1];
                v18 = v58 * a3[v12] + v14;
                v17 = (v58 * (unsigned __int64)(unsigned int)a3[v12] + v14) >> 32;
                v19 = __CFADD__(v18, *(_DWORD *)&v13[4 * v12]);
                *(_DWORD *)&v13[4 * v12] += v18;
                v16 = v19 + v17;
                v12 += 2;
LABEL_20:
                v14 = (*(unsigned int *)&v13[4 * v12 - 4] + v58 * (unsigned __int64)v15 + v16) >> 32;
                *(_DWORD *)&v13[4 * v12 - 4] += v58 * v15 + v16;
              }
              while ( v12 < a1 );
              *(_DWORD *)&v13[4 * v12] = v14;
              v20 = v54 == 1;
              v62 += 4;
              --v54;
              if ( v20 )
                break;
              v10 = v62;
              v11 = (char *)a2 - (char *)v67;
            }
            v5 = a1;
          }
          result = sub_401170(v5, a2, (int)v67, a5);
        }
        if ( !v9 )
          break;
        v8 = (int)v67;
      }
    }
  }
  else
  {
    result = a2;
    *a2 = 1;
    if ( a1 > 1 )
    {
      result = 0;
      memset(a2 + 1, 0, 4 * (a1 - 1));
    }
  }
  return result;
}
// 4017FA: conditional instruction was optimized away because of '%var_18.4>=3Cu'

//----- (00401A70) --------------------------------------------------------
unsigned int __thiscall sub_401A70(int *this, unsigned __int8 *a2, int a3)
{
  unsigned int result; // eax
  int v6; // edi
  int v7; // ecx

  result = a3 - 1;
  if ( a3 )
  {
    v6 = a3;
    do
    {
      result = (unsigned int)*this >> 8;
      v7 = result ^ dword_4A743C[*a2++ ^ (unsigned __int8)*this];
      --v6;
      *this = v7;
    }
    while ( v6 );
  }
  return result;
}
// 4A743C: using guessed type int dword_4A743C[];

//----- (00401AB0) --------------------------------------------------------
unsigned int __thiscall sub_401AB0(int *this, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 i; // dl
  unsigned int result; // eax

  v2 = a2;
  for ( i = *a2; *v2; i = *v2 )
  {
    result = (unsigned int)*this >> 8;
    ++v2;
    *this = result ^ dword_4A743C[i ^ (unsigned __int8)*this];
  }
  return result;
}
// 4A743C: using guessed type int dword_4A743C[];

//----- (00401AF0) --------------------------------------------------------
int __thiscall sub_401AF0(_DWORD *this, int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // esi
  unsigned int v4; // edx
  int result; // eax

  v2 = (*this >> 8) ^ dword_4A743C[(unsigned __int8)a2 ^ (unsigned __int8)*this];
  *this = v2;
  v3 = (v2 >> 8) ^ dword_4A743C[BYTE1(a2) ^ (unsigned __int8)v2];
  *this = v3;
  v4 = (v3 >> 8) ^ dword_4A743C[BYTE2(a2) ^ (unsigned __int8)v3];
  *this = v4;
  result = (v4 >> 8) ^ dword_4A743C[(unsigned __int8)v4 ^ HIBYTE(a2)];
  *this = result;
  return result;
}
// 4A743C: using guessed type int dword_4A743C[];

//----- (00401B90) --------------------------------------------------------
int __userpurge sub_401B90@<eax>(int a1@<ebp>, int a2, int a3)
{
  int result; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = a2;
  if ( a2 )
  {
    sub_401BC0(pExceptionObject, a1, a2, a3);
    _CxxThrowException(pExceptionObject, &_TI2_AVDDRAW_EXCEPION__);
  }
  return result;
}

//----- (00401BC0) --------------------------------------------------------
_DWORD *__userpurge sub_401BC0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4)
{
  sub_406F10(a1, a2, 0);
  a1[3] = a3;
  *a1 = &off_4A7B7C;
  a1[2] = a4;
  return a1;
}
// 4A7B7C: using guessed type int (__stdcall *off_4A7B7C)(char);

//----- (00401BF0) --------------------------------------------------------
_DWORD *__thiscall sub_401BF0(_DWORD *this, char a2)
{
  sub_401C10(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00401C10) --------------------------------------------------------
void __thiscall sub_401C10(_DWORD *this)
{
  *this = &off_4A7B84;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00401C20) --------------------------------------------------------
std::locale::facet *__thiscall std::locale::facet::`scalar deleting destructor'(std::locale::facet *this, char a2)
{
  *(_DWORD *)this = &off_4A7B84;
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00401C40) --------------------------------------------------------
_DWORD *__thiscall sub_401C40(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = this;
  v3 = a2[1];
  *this = &off_4A7B84;
  this[1] = v3;
  this[2] = a2[2];
  this[3] = a2[3];
  *this = &off_4A7B7C;
  return result;
}
// 4A7B7C: using guessed type int (__stdcall *off_4A7B7C)(char);
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00401C70) --------------------------------------------------------
_DWORD *__thiscall sub_401C70(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = this;
  v3 = *(_DWORD *)(a2 + 4);
  *this = &off_4A7B84;
  this[1] = v3;
  return result;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00401C90) --------------------------------------------------------
char __fastcall sub_401C90(int a1, _DWORD *a2)
{
  int v3; // eax
  char result; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v10; // eax

  *(_BYTE *)(a1 + 16) = 0;
  v3 = a2[1];
  if ( (v3 & 0x20) != 0 )
  {
    result = 1;
    *(_DWORD *)(a1 + 8) = 8;
    *(_DWORD *)(a1 + 12) = 1;
    return result;
  }
  if ( (v3 & 0x40) != 0 )
  {
    v5 = a2[3];
    if ( v5 == 15 || v5 == 16 )
    {
      *(_DWORD *)(a1 + 12) = 2;
      v10 = a2[4];
      if ( v10 == 31744 && a2[5] == 992 && a2[6] == 31 )
      {
        *(_DWORD *)(a1 + 8) = 15;
        return 1;
      }
      if ( v10 == 31 && a2[5] == 992 && a2[6] == 31744 )
      {
        result = 1;
        *(_BYTE *)(a1 + 16) = 1;
        *(_DWORD *)(a1 + 8) = 15;
        return result;
      }
      if ( v10 == 63488 && a2[5] == 2016 && a2[6] == 31 )
      {
        *(_DWORD *)(a1 + 8) = 16;
        return 1;
      }
      if ( v10 == 31 && a2[5] == 2016 && a2[6] == 63488 )
      {
        result = 1;
        *(_BYTE *)(a1 + 16) = 1;
        *(_DWORD *)(a1 + 8) = 16;
        return result;
      }
    }
    else if ( v5 == 24 || v5 == 32 )
    {
      v6 = *((__int16 *)a2 + 6);
      *(_DWORD *)(a1 + 8) = 24;
      *(_DWORD *)(a1 + 12) = v6 / 8;
      v7 = a2[4];
      if ( v7 != 16711680 && v7 != -1 || (v8 = a2[5], v8 != 65280) && v8 != -1 || (v9 = a2[6], v9 != 255) && v9 != -1 )
      {
        if ( v7 == 255 && a2[5] == 65280 && a2[6] == 16711680 )
        {
          result = 1;
          *(_BYTE *)(a1 + 16) = 1;
          return result;
        }
        return 0;
      }
      return 1;
    }
  }
  return 0;
}

//----- (00401E00) --------------------------------------------------------
int __thiscall sub_401E00(_DWORD *this, char a2)
{
  int result; // eax
  char v4; // bl
  int v5; // ecx
  int v6; // ecx

  result = this[14];
  if ( result )
  {
    if ( *((_BYTE *)this + 1140) )
    {
      v4 = a2;
    }
    else
    {
      v4 = 1;
      a2 = 1;
    }
    result = this[16];
    if ( result )
    {
      if ( *((_BYTE *)this + 90) != v4 )
      {
        sub_40DA80(aDirectdrawSetc_1);
        (*(void (__thiscall **)(_DWORD *))(*this + 24))(this);
        if ( v4 )
        {
          (*(void (__thiscall **)(_DWORD *))(*this + 40))(this);
          v5 = this[20];
        }
        else
        {
          v5 = 0;
        }
        if ( (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this[16] + 112))(this[16], v5) )
          sub_40DA80(aDirectdrawSetc_0);
        result = -2032508141;
        v6 = 44;
        do
          result ^= *(_DWORD *)&aCSrcIncMiscCpp[4 * v6-- - 439136];
        while ( v6 );
        *((_BYTE *)this + result + 136594) = a2;
      }
    }
  }
  return result;
}

//----- (00401ED0) --------------------------------------------------------
int __userpurge sub_401ED0@<eax>(int a1@<ebp>, int a2, _DWORD *a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // edi
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // edi
  void **v9; // esi
  int v10; // ebx
  int v12[5]; // [esp+10h] [ebp-28h] BYREF
  char v13[20]; // [esp+24h] [ebp-14h] BYREF

  if ( sub_401C90((int)v12, (_DWORD *)(a2 + 72)) )
  {
    v3 = *(unsigned __int16 *)(a2 + 12);
    v4 = *(unsigned __int16 *)(a2 + 8);
    v5 = a3[11];
    v6 = 0;
    v12[0] = (unsigned __int16)v3;
    v12[1] = (unsigned __int16)v4;
    if ( v5 <= 0 )
    {
LABEL_8:
      v8 = a3[11];
      v9 = (void **)(a3 + 9);
      if ( v8 >= a3[10] )
      {
        if ( v8 >= 8 )
          v10 = v8 >= 32 ? 32 : 8;
        else
          v10 = 4;
        sub_40B780(20 * (v8 + v10), v9, a1);
        a3[10] += v10;
      }
      sub_46CAB0(a3[9] + 4 * (5 * v8 + 5), (_BYTE *)(a3[9] + 20 * v8), 20 * a3[11]++ - 20 * v8);
      sub_46CAB0((unsigned int)*v9 + 20 * v8, v13, 0x14u);
      qmemcpy((char *)*v9 + 20 * v8, v12, 0x14u);
    }
    else
    {
      v7 = (_DWORD *)a3[9];
      a1 = v12[3];
      while ( *v7 != v3 || v7[1] != v4 || v7[3] != v12[3] )
      {
        ++v6;
        v7 += 5;
        if ( v6 >= v5 )
          goto LABEL_8;
      }
    }
  }
  return 1;
}

//----- (00402030) --------------------------------------------------------
_DWORD *__thiscall sub_402030(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ebx

  this[11] = 0;
  this[10] = 0;
  this[9] = 0;
  sub_412390(this + 286);
  *this = &off_4A7BE0;
  this[301] = a2;
  *((_BYTE *)this + 52) = 0;
  *((_BYTE *)this + 51) = 0;
  this[299] = 100;
  this[14] = 0;
  this[15] = 0;
  this[19] = 0;
  this[18] = 0;
  this[17] = 0;
  this[16] = 0;
  this[20] = 0;
  v3 = 0;
  v4 = (_DWORD *)((char *)&loc_42290D + 3);
  do
    v3 -= *v4++;
  while ( v4 < (_DWORD *)&loc_422CD4 + 1 );
  *(_DWORD *)((char *)this + v3 + 1326203387) = 0;
  this[298] = 0;
  *((_BYTE *)this + 89) = 0;
  *((_BYTE *)this + 88) = 0;
  memset(this + 24, 0, 0x400u);
  return this;
}
// 4A7BE0: using guessed type int (*off_4A7BE0)();

//----- (004020F0) --------------------------------------------------------
int __thiscall sub_4020F0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[17], 0, 0);
}

//----- (00402100) --------------------------------------------------------
void *__thiscall sub_402100(void *this, char a2)
{
  sub_4031C0((int)this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00402120) --------------------------------------------------------
int __thiscall sub_402120(_BYTE *this)
{
  int v2; // eax
  int v3; // ecx
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int result; // eax

  v2 = -1287310540;
  v3 = 178;
  do
    v2 ^= *(_DWORD *)&aBg03Bm2[4 * v3-- - 537224];
  while ( v3 );
  this[v2 + 207826] = 0;
  (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 56))(this);
  sub_40DA80(aDirectdrawCrea_0);
  v4 = *(_DWORD *)this;
  v5 = sub_4599A8(0, this + 56, 0, 4881544);
  (*(void (__thiscall **)(_BYTE *, int))(v4 + 48))(this, v5);
  sub_40DA80(aDirectdrawEnum);
  v6 = *(_DWORD *)this;
  v7 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _BYTE *, int (__userpurge *)@<eax>(int@<ebp>, int, _DWORD *), int))(**((_DWORD **)this + 14) + 32))(
         *((_DWORD *)this + 14),
         0,
         0,
         this,
         sub_401ED0,
         4881488);
  (*(void (__thiscall **)(_BYTE *, int))(v6 + 48))(this, v7);
  sub_40DA80(aDirectdrawDMod);
  result = -1;
  *((_DWORD *)this + 296) = -1;
  *((_DWORD *)this + 2) = -1;
  return result;
}
// 4599A8: using guessed type int __stdcall sub_4599A8(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402200) --------------------------------------------------------
int __userpurge sub_402200@<eax>(int *a1@<ecx>, int a2@<edi>, _BYTE *a3)
{
  int result; // eax
  int v5; // ecx
  char *v6; // eax
  int *v7; // ecx
  int v8; // edx
  int v9; // edi
  int v10; // ebx
  int *v11; // ebx
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // eax
  int v16; // edi
  char v18; // [esp+8h] [ebp-404h] BYREF
  char v19; // [esp+9h] [ebp-403h] BYREF
  int v20; // [esp+408h] [ebp-4h]
  int i; // [esp+414h] [ebp+8h]

  if ( a3 )
    sub_46CAB0((unsigned int)(a1 + 24), a3, 0x400u);
  result = -16886489;
  v5 = 87;
  do
    result ^= *(_DWORD *)&aCreateSThreadF[4 * v5-- - 628664];
  while ( v5 );
  if ( *(int *)((char *)a1 + result + 237896) == 8 )
  {
    v6 = &v19;
    v7 = a1 + 24;
    v8 = 256;
    do
    {
      v9 = *v7;
      v6 += 4;
      v10 = *v7++;
      *(v6 - 5) = BYTE2(v10);
      *(v6 - 4) = BYTE1(v9);
      *(v6 - 3) = *((_BYTE *)v7 - 4);
      *(v6 - 2) = 0;
      --v8;
    }
    while ( v8 );
    v11 = a1 + 18;
    if ( !a1[18] )
    {
      v12 = a1[15];
      if ( !v12 )
        v12 = a1[14];
      v13 = *a1;
      v14 = (*(int (__stdcall **)(int, int, char *, int *, _DWORD, char *))(*(_DWORD *)v12 + 20))(
              v12,
              76,
              &v18,
              a1 + 18,
              0,
              aDirectdrawCrea);
      (*(void (__thiscall **)(int *, int))(v13 + 48))(a1, v14);
      if ( !a1[19] )
      {
        v15 = *v11;
        *v11 = 0;
        a1[19] = v15;
      }
    }
    result = 0;
    for ( i = 0; i < 2; ++i )
    {
      if ( result )
        v16 = *v11;
      else
        v16 = a1[19];
      if ( v16 )
      {
        if ( (*(int (__stdcall **)(int, int, int))(*(_DWORD *)a1[16] + 124))(a1[16], v16, a2) )
        {
          v20 = 9078527;
          sub_40DA80(aDirectdrawSetp_0);
        }
        a2 = v16;
        if ( (*(int (__stdcall **)(int))(*(_DWORD *)a1[17] + 124))(a1[17]) )
        {
          v20 = 9078563;
          sub_40DA80(aDirectdrawSetp);
        }
      }
      result = i + 1;
    }
  }
  return result;
}
// 402200: could not find valid save-restore pair for edi

//----- (00402350) --------------------------------------------------------
void __thiscall sub_402350(int this, int *a2, int *a3, int a4)
{
  int *v4; // esi
  int v7; // edx
  int v8; // ecx
  int v9; // esi
  bool v10; // cc
  int v11; // edi
  char v12; // al
  void (__stdcall *v13)(_DWORD, int *); // edi
  int v14; // edx
  int v15; // eax
  int v16[25]; // [esp+Ch] [ebp-78h] BYREF
  int v17; // [esp+70h] [ebp-14h] BYREF
  int v18; // [esp+74h] [ebp-10h]
  int v19[2]; // [esp+78h] [ebp-Ch] BYREF
  int v20; // [esp+80h] [ebp-4h]
  int v21; // [esp+90h] [ebp+Ch]

  v4 = a2;
  if ( a2 )
  {
    v7 = *(_DWORD *)(this + 8);
    v8 = *(_DWORD *)(this + 12);
    v17 = 0;
    v18 = 0;
    if ( a3 )
    {
      if ( v7 <= 0 )
        return;
      if ( v8 > 0 )
      {
        v9 = *a3;
        v10 = *a3 < a3[2];
        v21 = a3[2];
        if ( !v10 )
          return;
        v11 = a3[1];
        v20 = a3[3];
        if ( v11 >= v20 )
          return;
        if ( v9 > 0 )
          v17 = v9;
        if ( v11 > 0 )
          v18 = v11;
        if ( v7 > v21 )
          v7 = v21;
        if ( v8 > v20 )
          v8 = v20;
        if ( v7 < v9 )
          v7 = v9;
        if ( v8 < v11 )
          v8 = v11;
        if ( v17 > v21 )
          v17 = v21;
        if ( v18 > v20 )
          v18 = v20;
        v4 = a2;
      }
    }
    if ( v17 < v7 && v18 < v8 )
    {
      v12 = *(_BYTE *)(this + 1140);
      v19[0] = v7;
      v19[1] = v8;
      if ( !v12 && v4 == *(int **)(this + 64) )
      {
        v13 = (void (__stdcall *)(_DWORD, int *))dword_4A72F8;
        dword_4A72F8(*(_DWORD *)(this + 92), &v17);
        v13(*(_DWORD *)(this + 92), v19);
      }
      v14 = *v4;
      memset(v16, 0, sizeof(v16));
      v16[20] = a4;
      v16[0] = 100;
      v15 = (*(int (__stdcall **)(int *, int *, _DWORD, _DWORD, int, int *))(v14 + 20))(v4, &v17, 0, 0, 16778240, v16);
      if ( v15 && v15 != -2005532222 && v15 != -2005532242 )
        sub_40DA80(aDirectdrawClea);
    }
  }
}
// 4A72F8: using guessed type int (__stdcall *dword_4A72F8)(_DWORD, _DWORD);

//----- (004024A0) --------------------------------------------------------
bool __thiscall sub_4024A0(_DWORD *this, char a2)
{
  int v3; // eax

  if ( !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)this[16] + 96))(this[16]) )
  {
    v3 = this[17];
    if ( !v3 || !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 96))(this[17]) )
      return 0;
  }
  if ( a2 )
    return (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 44))(this) == 0;
  return 1;
}

//----- (004024F0) --------------------------------------------------------
char __thiscall sub_4024F0(_DWORD *this)
{
  int v2; // eax
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ebx

  v2 = this[16];
  *((_BYTE *)this + 48) = 1;
  if ( (*(int (__stdcall **)(int))(*(_DWORD *)v2 + 108))(v2) )
    return 0;
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[16], 0, 0);
  if ( !*((_BYTE *)this + 49) )
  {
    v4 = this[17];
    if ( v4 )
    {
      if ( (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v4 + 108))(this[17]) )
        return 0;
    }
  }
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[17], 0, 0);
  v5 = 0;
  v6 = &loc_43540C;
  do
    v5 -= *v6++;
  while ( v6 < (_DWORD *)((char *)&loc_4354FE + 6) );
  *((_BYTE *)this + v5 + 1721068673) = 0;
  sub_40DA80(aDirectdrawSurf);
  return 1;
}

//----- (00402590) --------------------------------------------------------
int __thiscall sub_402590(_DWORD *this, int a2, int a3, int a4, char a5, int a6)
{
  int v7; // eax
  int v8; // ecx
  int v9; // edi
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // eax
  char v17; // al
  int i; // edi
  int v19; // eax
  int v20; // edi
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v26; // eax
  int v27; // edi
  int v28; // eax
  int v29; // edi
  int v30; // eax
  int v31; // edi
  int v32; // eax
  int v33; // edi
  int v34; // eax
  int v35; // edi
  char v36; // al
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v43; // [esp+Ch] [ebp-94h] BYREF
  int v44; // [esp+10h] [ebp-90h]
  int v45; // [esp+14h] [ebp-8Ch]
  int v46; // [esp+18h] [ebp-88h]
  int v47; // [esp+20h] [ebp-80h]
  int v48; // [esp+74h] [ebp-2Ch]
  int v49; // [esp+78h] [ebp-28h] BYREF
  int v50; // [esp+98h] [ebp-8h]
  int v51; // [esp+9Ch] [ebp-4h] BYREF
  int savedregs; // [esp+A0h] [ebp+0h] BYREF
  int v53; // [esp+B8h] [ebp+18h]

  *((_BYTE *)this + 48) = 1;
  *((_BYTE *)this + 1142) = 1;
  v7 = -1990128310;
  v8 = 240;
  do
    v7 ^= *(_DWORD *)&asc_4A8DF8[4 * v8-- - 514648];
  while ( v8 );
  *(_DWORD *)((char *)this + v7 + 398724) = 0;
  if ( a6 )
  {
    sub_40DA80(aDirectdrawQuer);
    v50 = 9081295;
    v9 = *this;
    v10 = (**(int (__stdcall ***)(_DWORD, void *, int, int))this[14])(this[14], &unk_4AE5A0, (int)(this + 15), 4882296);
    (*(void (__thiscall **)(_DWORD *, int))(v9 + 48))(this, v10);
    v11 = (*(int (__stdcall **)(_DWORD, _DWORD, int))(*(_DWORD *)this[15] + 80))(this[15], this[23], a5 != 0 ? 17 : 8);
  }
  else
  {
    v11 = (*(int (__stdcall **)(_DWORD, _DWORD, int))(*(_DWORD *)this[14] + 80))(this[14], this[23], a5 != 0 ? 17 : 8);
  }
  v12 = v11;
  if ( v11 )
  {
    v50 = 9081739;
    sub_40DA80(aDirectdrawSetc);
  }
  if ( !a5 )
  {
    v22 = this[15];
    v43 = 108;
    v44 = 1;
    v48 = 512;
    if ( v22 )
    {
      v23 = 9083279 - ((_DWORD)&loc_401AFC + 3);
      v24 = this[15];
    }
    else
    {
      v23 = 9083368 - ((_DWORD)&loc_401B53 + 5);
      v24 = this[14];
    }
    v25 = *this;
    v26 = (*(int (__stdcall **)(int, int *, _DWORD *, _DWORD, int))(*(_DWORD *)v24 + 24))(v24, &v43, this + 16, 0, v23);
    (*(void (__thiscall **)(_DWORD *, int))(v25 + 48))(this, v26);
    *((_BYTE *)this + 49) = 0;
LABEL_30:
    if ( *((_BYTE *)this + 49) )
      goto LABEL_37;
    goto LABEL_31;
  }
  v13 = this[15];
  if ( v13 )
  {
    if ( (*(int (__stdcall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)v13 + 84))(v13, a2, a3, 8 * a4, a6, 0) )
    {
      v53 = *this;
      v14 = (*(int (__stdcall **)(_DWORD, int, int, int, _DWORD, _DWORD, char *))(*(_DWORD *)this[15] + 84))(
              this[15],
              a2,
              a3,
              8 * a4,
              0,
              0,
              aDirectdrawSetd);
      (*(void (__thiscall **)(_DWORD *, int))(v53 + 48))(this, v14);
    }
  }
  else
  {
    v15 = *this;
    v16 = (*(int (__stdcall **)(_DWORD, int, int, int, char *))(*(_DWORD *)this[14] + 84))(
            this[14],
            a2,
            a3,
            8 * a4,
            aDirectdrawSetd);
    (*(void (__thiscall **)(_DWORD *, int))(v15 + 48))(this, v16);
  }
  v17 = *((_BYTE *)this + 51);
  *((_BYTE *)this + 88) = 1;
  for ( i = v17 || *((_BYTE *)this + 52); i < 2; ++i )
  {
    v43 = 108;
    if ( i )
    {
      *((_BYTE *)this + 49) = 0;
      v44 = 1;
      v48 = 512;
      v47 = 0;
    }
    else
    {
      *((_BYTE *)this + 49) = 1;
      v44 = 33;
      v48 = 16920;
      v47 = 1;
    }
    v19 = this[15];
    if ( !v19 )
      v19 = this[14];
    v12 = (*(int (__stdcall **)(int, int *, _DWORD *, _DWORD))(*(_DWORD *)v19 + 24))(v19, &v43, this + 16, 0);
    if ( !v12 )
      break;
    sub_40DA80((char *)(9082808 - (_DWORD)&loc_4018C0));
  }
  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 48))(this, v12, 4882140);
  if ( *((_BYTE *)this + 49) )
  {
    v51 = 4;
    v20 = *this;
    v21 = (*(int (__stdcall **)(_DWORD, int *, _DWORD *, int))(*(_DWORD *)this[16] + 48))(
            this[16],
            &v51,
            this + 17,
            9083001 - (_DWORD)nullsub_1);
    (*(void (__thiscall **)(_DWORD *, int))(v20 + 48))(this, v21);
    goto LABEL_30;
  }
LABEL_31:
  v27 = *((unsigned __int8 *)this + 52);
  if ( (unsigned int)v27 < 2 )
  {
    do
    {
      v45 = a3;
      v28 = this[15];
      v43 = 108;
      v44 = 7;
      v46 = a2;
      v48 = v27 != 0 ? 2112 : 16448;
      if ( !v28 )
        v28 = this[14];
      v12 = (*(int (__stdcall **)(int, int *, _DWORD *, _DWORD))(*(_DWORD *)v28 + 24))(v28, &v43, this + 17, 0);
      if ( !v12 )
        break;
      ++v27;
    }
    while ( v27 < 2 );
  }
  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 48))(this, v12, 9084076 - (_DWORD)&loc_401E44);
LABEL_37:
  v29 = *this;
  v30 = sub_4599AE(0, this + 20, 0, 9084197 - ((_DWORD)&loc_401ED3 + 2));
  (*(void (__thiscall **)(_DWORD *, int))(v29 + 48))(this, v30);
  v31 = *this;
  v32 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this[20] + 32))(
          this[20],
          0,
          this[23],
          9084217 - ((_DWORD)&loc_401F04 + 1));
  (*(void (__thiscall **)(_DWORD *, int))(v31 + 48))(this, v32);
  v49 = 32;
  v33 = *this;
  v34 = (*(int (__stdcall **)(_DWORD, int *, int))(*(_DWORD *)this[17] + 84))(
          this[17],
          &v49,
          9084426 - (_DWORD)&off_401FFA);
  (*(void (__thiscall **)(_DWORD *, int))(v33 + 48))(this, v34);
  sub_40DA80((char *)(9084476 - (_DWORD)&loc_40205C));
  v35 = *this;
  v36 = sub_401C90((int)(this + 280), &v49);
  (*(void (__thiscall **)(_DWORD *, bool, int))(v35 + 48))(this, v36 == 0, 9084657 - (_DWORD)&loc_402125);
  this[280] = a2;
  this[281] = a3;
  v37 = 1083849375;
  v38 = 228;
  do
    v37 ^= *(_DWORD *)&aD[4 * v38-- - 368452];
  while ( v38 );
  *(_DWORD *)((char *)this + v37 + 577432) = a2;
  v39 = this[282];
  this[3] = a3;
  v40 = *((unsigned __int8 *)this + 1136);
  this[4] = this[283];
  this[5] = v39;
  this[6] = v40;
  if ( !a5 )
    (*(void (__thiscall **)(_DWORD *, int))(*this + 28))(this, 1);
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[16], 0, 0);
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[17], 0, 0);
  v41 = sub_40B720((int)&savedregs, 0x2Cu);
  if ( v41 )
  {
    *(_DWORD *)(v41 + 4) = this;
    *(_DWORD *)v41 = &off_4A7DC0;
    *(_DWORD *)(v41 + 8) = this[17];
    *(_DWORD *)(v41 + 36) = this[2];
    *(_DWORD *)(v41 + 40) = this[3];
    *(_DWORD *)(v41 + 28) = 0;
    *(_DWORD *)(v41 + 16) = 0;
    *(_DWORD *)(v41 + 24) = this[4];
    *(_BYTE *)(v41 + 32) = 0;
  }
  else
  {
    v41 = 0;
  }
  this[300] = v41;
  return sub_40DA80((char *)(9085719 - (_DWORD)&loc_40259B));
}
// 4019C5: using guessed type int nullsub_1();
// 401FFA: using guessed type void *off_401FFA;
// 4599AE: using guessed type int __stdcall sub_4599AE(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);

//----- (00402AD0) --------------------------------------------------------
char __thiscall sub_402AD0(char *this, int a2, int a3, int a4, int a5, int a6, int a7, unsigned __int8 (__fastcall *a8)(int, int, int, int), int a9)
{
  int *v10; // edi
  int v11; // eax
  int v12; // eax
  int (__stdcall *v13)(int); // ebx
  int v14; // ebx
  int v15; // eax
  signed int v16; // ecx
  bool v17; // cc
  int v18; // eax
  int v19; // eax
  int v20; // eax
  void (__stdcall *v21)(int, _DWORD, _DWORD, _DWORD, int, int, int); // ebx
  int v22; // eax
  int v23; // edx
  int *v24; // eax
  int v25; // edx
  int (__stdcall *v26)(_DWORD, int); // ebx
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v32; // [esp-8h] [ebp-B0h]
  int v33; // [esp-8h] [ebp-B0h]
  int v34; // [esp+0h] [ebp-A8h] BYREF
  int v35; // [esp+4h] [ebp-A4h]
  int v36[11]; // [esp+Ch] [ebp-9Ch] BYREF
  int pExceptionObject[6]; // [esp+3Ch] [ebp-6Ch] BYREF
  int v38; // [esp+54h] [ebp-54h]
  int v39[2]; // [esp+58h] [ebp-50h] BYREF
  char *v40; // [esp+60h] [ebp-48h]
  int v41; // [esp+64h] [ebp-44h]
  int i; // [esp+68h] [ebp-40h]
  int v43; // [esp+6Ch] [ebp-3Ch]
  int v44; // [esp+70h] [ebp-38h]
  int v45; // [esp+74h] [ebp-34h]
  int v46; // [esp+78h] [ebp-30h]
  int v47; // [esp+7Ch] [ebp-2Ch] BYREF
  int v48; // [esp+80h] [ebp-28h]
  int v49; // [esp+84h] [ebp-24h]
  int v50; // [esp+88h] [ebp-20h]
  int v51; // [esp+8Ch] [ebp-1Ch]
  int v52; // [esp+90h] [ebp-18h]
  char v53; // [esp+97h] [ebp-11h]
  int *v54; // [esp+98h] [ebp-10h]
  int v55; // [esp+A4h] [ebp-4h]
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  pExceptionObject[5] = (int)this;
  v10 = (int *)(this + 92);
  v54 = &v34;
  pExceptionObject[4] = (int)(this + 92);
  *((_DWORD *)this + 23) = a2;
  v11 = *((_DWORD *)this + 14);
  if ( v11 )
  {
    if ( !*((_DWORD *)this + 16)
      || a3 != *((_DWORD *)this + 2)
      || a4 != *((_DWORD *)this + 3)
      || (LOBYTE(v11) = a6, (_BYTE)a6 != this[1140])
      || a5 != *((_DWORD *)this + 4) && (_BYTE)a6 )
    {
      if ( *((_DWORD *)this + 296) != a3
        || *((_DWORD *)this + 297) != a4
        || (LOBYTE(v11) = a6, (_BYTE)a6 != this[1141])
        || a5 != *((_DWORD *)this + 298) && (_BYTE)a6 )
      {
        (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 12))(this, 0);
        *((_DWORD *)this + 296) = a3;
        *((_DWORD *)this + 297) = a4;
        *((_DWORD *)this + 298) = a5;
        v12 = 0;
        v13 = (int (__stdcall *)(int))&loc_44F148;
        do
        {
          v12 -= *(_DWORD *)v13;
          v13 = (int (__stdcall *)(int))((char *)v13 + 4);
        }
        while ( (unsigned int)v13 < (unsigned int)sub_44F508 );
        this[v12 - 1995082816] = a6;
        sub_40DA80(aDirectdrawSetm);
        v14 = 0;
        this[90] = 0;
        sub_406F10(v39, (int)&savedregs, 0);
        v39[0] = (int)&off_4A7B7C;
        v41 = 0;
        v40 = aNoModes;
        v55 = 0;
        v53 = 0;
        for ( i = 0; ; ++i )
        {
          v44 = a3;
          v46 = a4;
          v43 = a5;
          v52 = -1;
          if ( (_BYTE)a6 )
          {
            if ( !i )
              goto LABEL_32;
            v15 = *((_DWORD *)this + 11);
            v38 = -1000000;
            v45 = 0;
            if ( v15 > 0 )
            {
              v51 = 0;
              do
              {
                if ( !a8 || a8(a9, v14 + *((_DWORD *)this + 9), v34, v35) )
                {
                  v16 = dword_4A7B28[4 * a5 + *(_DWORD *)(*((_DWORD *)this + 9) + v14 + 12)]
                      - abs32(*(_DWORD *)(*((_DWORD *)this + 9) + v14) - a3)
                      - abs32(*(_DWORD *)(*((_DWORD *)this + 9) + v14 + 4) - a4);
                  if ( v16 > v38 )
                  {
                    v38 = v16;
                    v52 = v45;
                  }
                }
                v14 = v51 + 20;
                v17 = ++v45 < *((_DWORD *)this + 11);
                v51 += 20;
              }
              while ( v17 );
              if ( v52 >= 0 )
              {
                v24 = (int *)(*((_DWORD *)this + 9) + 20 * v52);
                v44 = *v24;
                v25 = v24[3];
                v46 = v24[1];
                v43 = v25;
LABEL_32:
                dword_4A72D4(*v10, -16, -2046820352);
                v26 = dword_4A72C4;
                v27 = dword_4A72C4(1, 52);
                v28 = v26(0, v27);
                dword_4A72D8(*v10, 0, 0, 0, v28);
                goto LABEL_28;
              }
            }
            LOBYTE(a6) = 0;
            v53 = 1;
          }
          v32 = *v10;
          v47 = 0;
          v48 = 0;
          v49 = a3;
          v50 = a4;
          v18 = dword_4A72E4(v32, -20);
          v19 = dword_4A72E0(*v10, v18, v34, v35);
          dword_4A72DC(&v47, 113901568, v19 != 0);
          v35 = 22;
          v20 = *v10;
          v34 = v50 - v48;
          v21 = (void (__stdcall *)(int, _DWORD, _DWORD, _DWORD, int, int, int))dword_4A72D8;
          dword_4A72D8(v20, 0, 0, 0, v49 - v47);
          dword_4A72D4(*v10, -16, 113901568);
          v21(*v10, 0, 0, 0, v49 - v47, v50 - v48, 54);
          v22 = *v10;
          v35 = (int)v36;
          v34 = v22;
          v36[0] = 44;
          dword_4A72D0();
          v36[9] = v49 + v36[7] - v47;
          v33 = *v10;
          v36[10] = v50 + v36[8] - v48;
          dword_4A72CC(v33, v36);
LABEL_28:
          dword_4A72C8(*v10, 5);
          this[1140] = a6;
          v23 = *(_DWORD *)this;
          LOBYTE(v55) = 1;
          (*(void (__thiscall **)(char *, int, int, int, int, int))(v23 + 52))(this, v44, v46, v43, a6, a7);
          LOBYTE(v11) = (_BYTE)a8;
          if ( !a8 )
            return v11;
          LOBYTE(v11) = ((int (__fastcall *)(int, char *))a8)(a9, this + 1120);
          if ( (_BYTE)v11 )
            return v11;
          v55 = 0;
          if ( (_BYTE)a6 )
          {
            if ( v52 >= 0 )
            {
              sub_46CAB0(
                *((_DWORD *)this + 9) + 20 * v52,
                (_BYTE *)(*((_DWORD *)this + 9) + 4 * (5 * v52 + 5)),
                20 * *((_DWORD *)this + 11) - 4 * (5 * v52 + 5));
              v29 = *((_DWORD *)this + 11) - 1;
              *((_DWORD *)this + 11) = v29;
              if ( v29 )
              {
                if ( *((_DWORD *)this + 10) - v29 > 32 )
                {
                  v30 = *((_DWORD *)this + 10) - 16;
                  *((_DWORD *)this + 10) = v30;
                  sub_40B780(20 * v30, (void **)this + 9, (int)&savedregs);
                }
              }
            }
          }
          if ( v53 )
          {
            pExceptionObject[1] = v39[1];
            pExceptionObject[2] = (int)v40;
            pExceptionObject[3] = v41;
            pExceptionObject[0] = (int)&off_4A7B7C;
            _CxxThrowException(pExceptionObject, &_TI2_AVDDRAW_EXCEPION__);
          }
          if ( !(_BYTE)a6 )
            LOBYTE(a6) = 1;
          v14 = 0;
        }
      }
    }
  }
  return v11;
}
// 44F508: using guessed type int __stdcall sub_44F508(int);
// 4A72C4: using guessed type int (__stdcall *dword_4A72C4)(_DWORD, _DWORD);
// 4A72C8: using guessed type int (__stdcall *dword_4A72C8)(_DWORD, _DWORD);
// 4A72CC: using guessed type int (__stdcall *dword_4A72CC)(_DWORD, _DWORD);
// 4A72D0: using guessed type int (*dword_4A72D0)(void);
// 4A72D4: using guessed type int (__stdcall *dword_4A72D4)(_DWORD, _DWORD, _DWORD);
// 4A72D8: using guessed type int (__stdcall *dword_4A72D8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A72DC: using guessed type int (__stdcall *dword_4A72DC)(_DWORD, _DWORD, _DWORD);
// 4A72E0: using guessed type int (__stdcall *dword_4A72E0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A72E4: using guessed type int (__stdcall *dword_4A72E4)(_DWORD, _DWORD);
// 4A7B7C: using guessed type int (__stdcall *off_4A7B7C)(char);

//----- (00402F90) --------------------------------------------------------
char __thiscall sub_402F90(_DWORD *this, char a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax

  v3 = this[14];
  this[296] = -1;
  if ( v3 )
  {
    sub_40DA80((char *)(9095139 - (_DWORD)&loc_40467F));
    (*(void (__thiscall **)(_DWORD *))(*this + 64))(this);
    (*(void (__thiscall **)(_DWORD *))(*this + 24))(this);
    v4 = this[300];
    if ( v4 )
      (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 8))(v4, 1);
    v5 = 1988494927;
    v6 = 247;
    do
      v5 ^= *(_DWORD *)&aImageReadFaile[4 * v6-- - 612268];
    while ( v6 );
    *(_DWORD *)((char *)this + v5 + 845592) = 0;
    if ( *((_BYTE *)this + 88) )
    {
      sub_40DA80((char *)(9095704 - (_DWORD)&loc_4048D4));
      v7 = this[15];
      if ( v7 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 76))(this[15]);
      else
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[14] + 76))(this[14]);
    }
    if ( this[20] )
    {
      sub_40DA80((char *)(9096201 - ((_DWORD)&loc_404AE3 + 2)));
      v8 = this[16];
      if ( v8 )
        (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)v8 + 112))(v8, 0);
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[20] + 8))(this[20]);
    }
    v9 = this[18];
    if ( v9 && v9 != this[19] )
    {
      sub_40DA80((char *)(9096552 - ((_DWORD)&loc_404C62 + 2)));
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[18] + 8))(this[18]);
    }
    if ( this[19] )
    {
      sub_40DA80((char *)(9096821 - ((_DWORD)&loc_404D97 + 2)));
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[19] + 8))(this[19]);
    }
    if ( this[17] )
    {
      sub_40DA80((char *)(9097097 - (_DWORD)&loc_404ED1));
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[17] + 8))(this[17]);
    }
    if ( this[16] )
    {
      sub_40DA80((char *)(9097371 - ((_DWORD)&loc_40500A + 1)));
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[16] + 8))(this[16]);
    }
    if ( this[14] )
    {
      sub_40DA80((char *)(9097640 - ((_DWORD)&loc_405146 + 2)));
      v10 = this[15];
      if ( !v10 )
        v10 = this[14];
      (*(void (__stdcall **)(int, _DWORD, int))(*(_DWORD *)v10 + 80))(v10, this[23], 8);
    }
    LOBYTE(v3) = a2;
    *((_BYTE *)this + 88) = 0;
    this[19] = 0;
    this[18] = 0;
    this[17] = 0;
    this[16] = 0;
    this[20] = 0;
    if ( a2 )
    {
      if ( this[15] )
      {
        sub_40DA80((char *)(9098317 - (_DWORD)&loc_405419));
        LOBYTE(v3) = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this[15] + 8))(this[15]);
        this[15] = 0;
      }
      if ( this[14] )
      {
        sub_40DA80((char *)(9098680 - ((_DWORD)&loc_4055AF + 1)));
        LOBYTE(v3) = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this[14] + 8))(this[14]);
        this[14] = 0;
      }
    }
  }
  return v3;
}

//----- (004031C0) --------------------------------------------------------
void __thiscall sub_4031C0(int this)
{
  *(_DWORD *)this = &off_4A7BE0;
  sub_402F90((_DWORD *)this, 1);
  sub_40B7D0(*(void **)(this + 36));
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 40) = 0;
}
// 4A7BE0: using guessed type int (*off_4A7BE0)();

//----- (00403220) --------------------------------------------------------
char __usercall sub_403220@<al>(int *a1@<ecx>, int a2@<ebx>, int a3@<edi>)
{
  int v4; // eax
  void (__stdcall *v5)(int, char *); // edi
  void (__stdcall *v6)(int); // ebx
  int i; // edi
  int v8; // eax
  char v10[8]; // [esp+4h] [ebp-14h] BYREF
  char v11[8]; // [esp+Ch] [ebp-Ch] BYREF
  int v12; // [esp+14h] [ebp-4h]

  LOBYTE(v4) = *((_BYTE *)a1 + 49);
  if ( (_BYTE)v4 )
  {
    v4 = a1[21];
    if ( v4 )
    {
      v12 = 9102500;
      sub_40DA80((char *)(9102500 - ((_DWORD)&loc_4062EA + 2)));
      (*(void (__thiscall **)(int *, int, int))(*a1 + 64))(a1, a3, a2);
      dword_4A72E8(a1[23], v10);
      v5 = (void (__stdcall *)(int, char *))dword_4A72F8;
      dword_4A72F8(a1[23], v10);
      v5(a1[23], v11);
      if ( (*(int (__stdcall **)(int, char *, int, _DWORD, int, _DWORD))(*(_DWORD *)a1[17] + 20))(
             a1[17],
             v10,
             a1[16],
             0,
             0x1000000,
             0) )
      {
        v12 = 9103085;
        sub_40DA80((char *)(9103085 - ((_DWORD)&loc_406553 + 2)));
      }
      v6 = (void (__stdcall *)(int))dword_4A72B4;
      for ( i = 0; i < 1000; ++i )
      {
        if ( (*(int (__stdcall **)(int, int))(*(_DWORD *)a1[17] + 52))(a1[17], 2) != -2005532132 )
          break;
        v6(1);
      }
      if ( (*(int (__stdcall **)(int))(*(_DWORD *)a1[16] + 44))(a1[16]) )
      {
        v12 = 9103680;
        sub_40DA80((char *)(9103680 - (_DWORD)&loc_4067C8));
        LOBYTE(v4) = (*(int (__thiscall **)(int *))(*a1 + 24))(a1);
      }
      else
      {
        v8 = *a1;
        a1[21] = 0;
        LOBYTE(v4) = (*(int (__thiscall **)(int *))(v8 + 24))(a1);
      }
    }
  }
  return v4;
}
// 403220: could not find valid save-restore pair for ebx
// 403220: could not find valid save-restore pair for edi
// 4A72B4: using guessed type int (__stdcall *dword_4A72B4)(_DWORD);
// 4A72E8: using guessed type int (__stdcall *dword_4A72E8)(_DWORD, _DWORD);
// 4A72F8: using guessed type int (__stdcall *dword_4A72F8)(_DWORD, _DWORD);

//----- (00403340) --------------------------------------------------------
int __thiscall sub_403340(unsigned int *this, int *a2)
{
  __int64 v3; // rax
  int v5; // edi
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // ecx
  void (__stdcall *v11)(unsigned int, int *); // edi
  int v12; // eax
  int v14; // [esp+4h] [ebp-24h] BYREF
  int v15; // [esp+8h] [ebp-20h]
  int v16; // [esp+Ch] [ebp-1Ch]
  int v17; // [esp+10h] [ebp-18h]
  int v18; // [esp+14h] [ebp-14h] BYREF
  int v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+1Ch] [ebp-Ch] BYREF
  int v21; // [esp+20h] [ebp-8h]
  int v22; // [esp+24h] [ebp-4h]

  LODWORD(v3) = this[14];
  if ( (_DWORD)v3 )
  {
    (*(void (__thiscall **)(unsigned int *))(*this + 64))(this);
    this[291] = (__int64)(sub_412570(this + 286) * dbl_4A8240);
    if ( this[17] )
    {
      v22 = 0;
      while ( 1 )
      {
        if ( !*((_BYTE *)this + 49) || *((_BYTE *)this + 90) )
        {
          if ( a2 )
          {
            v6 = *a2;
            v7 = a2[2];
            v8 = a2[1];
            v9 = a2[3];
            v18 = v6;
            v20 = v7;
            v19 = v8;
          }
          else
          {
            v7 = this[2];
            v9 = this[3];
            v8 = 0;
            v6 = 0;
            v19 = 0;
            v18 = 0;
            v20 = v7;
          }
          v21 = v9;
          v17 = v9;
          v15 = v8;
          v10 = this[23];
          v16 = v7;
          v11 = (void (__stdcall *)(unsigned int, int *))dword_4A72F8;
          v14 = v6;
          dword_4A72F8(v10, &v18);
          v11(this[23], &v20);
          if ( v19 >= v21 || v18 >= v20 || v15 >= v17 || v14 >= v16 )
          {
            v12 = (*(int (__stdcall **)(unsigned int))(*(_DWORD *)this[16] + 96))(this[16]);
          }
          else
          {
            v5 = (*(int (__stdcall **)(unsigned int, int *, unsigned int, int *, int, _DWORD))(*(_DWORD *)this[16] + 20))(
                   this[16],
                   &v18,
                   this[17],
                   &v14,
                   512,
                   0);
            if ( !v5 )
              goto LABEL_20;
            v12 = (*(int (__stdcall **)(unsigned int, int *, unsigned int, int *, int, _DWORD))(*(_DWORD *)this[16] + 20))(
                    this[16],
                    &v18,
                    this[17],
                    &v14,
                    16777728,
                    0);
          }
          v5 = v12;
        }
        else
        {
          if ( !(*(int (__stdcall **)(unsigned int, _DWORD, _DWORD))(*(_DWORD *)this[16] + 44))(this[16], 0, 0)
            || (v5 = (*(int (__stdcall **)(unsigned int, _DWORD, int))(*(_DWORD *)this[16] + 44))(this[16], 0, 1)) == 0 )
          {
            this[21] ^= 1u;
            goto LABEL_30;
          }
          sub_40DA80((char *)(9105665 - (_DWORD)&loc_406EED));
        }
LABEL_20:
        if ( v5 != -2005532222 )
        {
          if ( v5 )
          {
            if ( v5 == -2005532242 )
              *((_BYTE *)this + 48) = 1;
            else
              sub_40DA80((char *)(9108473 - ((_DWORD)&loc_407A15 + 4)));
          }
          goto LABEL_30;
        }
        (*(void (__thiscall **)(unsigned int *))(*this + 44))(this);
        a2 = 0;
        if ( ++v22 >= 2 )
          goto LABEL_30;
      }
    }
    if ( (*(int (__stdcall **)(unsigned int))(*(_DWORD *)this[16] + 96))(this[16]) == -2005532222 )
      (*(void (__thiscall **)(unsigned int *))(*this + 44))(this);
LABEL_30:
    v3 = (__int64)(sub_412570(this + 286) * dbl_4A8240);
    this[290] = v3;
  }
  return v3;
}
// 4A72F8: using guessed type int (__stdcall *dword_4A72F8)(_DWORD, _DWORD);
// 4A8240: using guessed type double dbl_4A8240;

//----- (00403570) --------------------------------------------------------
int __thiscall sub_403570(_DWORD *this)
{
  int result; // eax
  int v3; // ecx

  result = 925356096;
  v3 = 39;
  do
    result ^= *(_DWORD *)&aUnknownError[4 * v3-- - 532216];
  while ( v3 );
  if ( !*((_BYTE *)this + result + 1142702) )
  {
    result = this[14];
    if ( result )
    {
      sub_40DA80((char *)(9110460 - (_DWORD)byte_408174));
      (*(void (__thiscall **)(_DWORD *))(*this + 64))(this);
      if ( this[17] )
        result = (*(int (__thiscall **)(_DWORD *, _DWORD))(*this + 16))(this, 0);
      else
        result = (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 68))(this, this[16], 0, 0);
    }
  }
  return result;
}

//----- (004035F0) --------------------------------------------------------
char __thiscall sub_4035F0(int this)
{
  char result; // al
  int v3; // eax

  result = *(_BYTE *)(this + 89);
  if ( result )
  {
    v3 = *(_DWORD *)(this + 68);
    if ( !v3 )
      v3 = *(_DWORD *)(this + 64);
    result = (*(int (__stdcall **)(int, _DWORD))(*(_DWORD *)v3 + 128))(v3, *(_DWORD *)(this + 28));
    *(_BYTE *)(this + 89) = 0;
    *(_DWORD *)(this + 28) = 0;
  }
  return result;
}

//----- (00403620) --------------------------------------------------------
void __thiscall sub_403620(unsigned int *this)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // [esp+Ch] [ebp-70h] BYREF
  char v8; // [esp+10h] [ebp-6Ch]
  unsigned int v9; // [esp+1Ch] [ebp-60h]
  int v10; // [esp+30h] [ebp-4Ch]
  int v11; // [esp+78h] [ebp-4h]

  v2 = 0;
  if ( this[14] )
  {
    (*(void (__thiscall **)(unsigned int *))(*this + 64))(this);
    this[292] = (__int64)(sub_412570(this + 286) * dbl_4A8240);
    this[7] = 0;
    do
    {
      v3 = this[17];
      v7 = 108;
      v4 = (*(int (__stdcall **)(unsigned int, _DWORD, int *, int, _DWORD))(*(_DWORD *)v3 + 100))(v3, 0, &v7, 1, 0);
      v5 = v4;
      if ( !v4 )
        break;
      if ( v4 == -2005532222 )
        (*(void (__thiscall **)(unsigned int *))(*this + 44))(this);
      ++v2;
    }
    while ( v2 < 2 );
    if ( v2 == 2 )
    {
      if ( v5 == -2005532222 || v5 == -2005532242 )
      {
        *((_BYTE *)this + 48) = 1;
      }
      else
      {
        v11 = 9113886;
        sub_40DA80((char *)(9113886 - ((_DWORD)&loc_408EBD + 1)));
      }
    }
    else
    {
      if ( (v8 & 8) != 0 )
        this[8] = v9;
      else
        this[8] = this[2] * this[4];
      v6 = v10;
      *((_BYTE *)this + 89) = 1;
      this[7] = v6;
      *((_BYTE *)this + 1142) = 0;
    }
  }
}
// 4A8240: using guessed type double dbl_4A8240;

//----- (00403700) --------------------------------------------------------
int __thiscall sub_403700(_DWORD *this)
{
  int (__stdcall *v1)(int); // ebx
  int i; // esi
  int result; // eax

  v1 = dword_4A72B4;
  for ( i = 0; i < 1000; ++i )
  {
    result = this[16];
    if ( !result )
      break;
    if ( (*(int (__stdcall **)(int, int))(*(_DWORD *)result + 72))(result, 2) != -2005532132 )
    {
      result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this[16] + 52))(this[16], 2);
      if ( result != -2005532132 )
        break;
    }
    sub_40DA80((char *)(9115751 - ((_DWORD)&loc_4095D2 + 5)));
    result = v1(1);
  }
  return result;
}
// 4A72B4: using guessed type int (__stdcall *dword_4A72B4)(_DWORD);

//----- (00403770) --------------------------------------------------------
int __thiscall sub_403770(_DWORD *this, int *a2)
{
  int result; // eax
  int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  unsigned int v11; // ebx
  unsigned int v12; // eax
  int v13; // [esp+0h] [ebp-4h]
  int v14; // [esp+8h] [ebp+4h]

  result = this[299];
  if ( result != 100 )
  {
    if ( result >= 60 )
    {
      if ( result > 200 )
        result = 200;
    }
    else
    {
      result = 60;
    }
    v4 = (result << 8) / 100;
    v14 = 256;
    do
    {
      v13 = *a2;
      v5 = v4 * HIBYTE(*a2);
      LOBYTE(v5) = 0;
      if ( v5 < 0xFF00 )
        v6 = (unsigned int)(v4 * HIBYTE(*a2)) >> 8;
      else
        v6 = 255;
      v7 = v4 * BYTE2(v13);
      LOBYTE(v7) = 0;
      if ( v7 < 0xFF00 )
        v8 = (v4 * (unsigned int)BYTE2(v13)) >> 8;
      else
        v8 = 255;
      v9 = v4 * BYTE1(v13);
      LOBYTE(v9) = 0;
      if ( v9 < 0xFF00 )
        v10 = (v4 * (unsigned int)BYTE1(v13)) >> 8;
      else
        v10 = 255;
      v11 = v4 * (unsigned __int8)*a2;
      LOBYTE(v11) = 0;
      if ( v11 < 0xFF00 )
        v12 = (v4 * (unsigned int)(unsigned __int8)*a2) >> 8;
      else
        v12 = 255;
      *a2++ = v12 | ((v10 | ((v8 | (v6 << 8)) << 8)) << 8);
      result = v14 - 1;
      v14 = result;
    }
    while ( result );
  }
  return result;
}

//----- (00403880) --------------------------------------------------------
char *__thiscall sub_403880(_DWORD *this, void *a2, int a3)
{
  char v4[256]; // [esp+0h] [ebp-104h] BYREF
  int v5; // [esp+100h] [ebp-4h]

  v5 = 9118654;
  dword_4A72EC(v4, 9118654 - ((_DWORD)&locret_40A109 + 1), this[2], this[3]);
  return strncpyt(a2, v4, a3);
}
// 4A72EC: using guessed type int (__cdecl *dword_4A72EC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004038D0) --------------------------------------------------------
void __thiscall sub_4038D0(_DWORD *this, char *a2)
{
  int *v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  _DWORD *v10; // ebx
  int v11; // edi
  int (__stdcall *v12)(int, int, _DWORD, _DWORD, int, _DWORD *, _DWORD); // edi
  int v13; // eax
  int v14; // eax
  unsigned __int16 v15; // cx
  int v16; // eax
  unsigned int v17; // edi
  int v18; // [esp-1Ch] [ebp-98h]
  int v19; // [esp-8h] [ebp-84h]
  int v20; // [esp-4h] [ebp-80h]
  int v21; // [esp+0h] [ebp-7Ch] BYREF
  int v22; // [esp+Ch] [ebp-70h] BYREF
  int v23; // [esp+10h] [ebp-6Ch]
  _DWORD v24[2]; // [esp+14h] [ebp-68h] BYREF
  __int16 v25; // [esp+1Ch] [ebp-60h] BYREF
  int v26; // [esp+1Eh] [ebp-5Eh]
  __int16 v27; // [esp+22h] [ebp-5Ah]
  __int16 v28; // [esp+24h] [ebp-58h]
  int v29; // [esp+26h] [ebp-56h]
  _DWORD *v30; // [esp+30h] [ebp-4Ch]
  int v31; // [esp+34h] [ebp-48h] BYREF
  int v32; // [esp+38h] [ebp-44h] BYREF
  int v33; // [esp+3Ch] [ebp-40h] BYREF
  int v34; // [esp+40h] [ebp-3Ch]
  int v35; // [esp+44h] [ebp-38h] BYREF
  int v36; // [esp+48h] [ebp-34h] BYREF
  int v37; // [esp+4Ch] [ebp-30h] BYREF
  int pExceptionObject; // [esp+50h] [ebp-2Ch] BYREF
  _DWORD *v39; // [esp+54h] [ebp-28h]
  int v40; // [esp+58h] [ebp-24h]
  int v41; // [esp+5Ch] [ebp-20h]
  int v42; // [esp+60h] [ebp-1Ch]
  int v43; // [esp+64h] [ebp-18h] BYREF
  int v44[2]; // [esp+68h] [ebp-14h] BYREF
  int v45; // [esp+78h] [ebp-4h]
  int savedregs; // [esp+7Ch] [ebp+0h] BYREF

  v44[1] = (int)&v21;
  v3 = (int *)this[16];
  v30 = this;
  if ( v3 )
  {
    v43 = 0;
    v4 = *v3;
    v42 = 0;
    v41 = 0;
    v39 = 0;
    v40 = 0;
    v45 = 0;
    if ( (*(int (__stdcall **)(int *, int *))(v4 + 68))(v3, &v43) < 0 )
    {
      pExceptionObject = 1;
      _CxxThrowException(&pExceptionObject, &_TI1H);
    }
    v42 = dword_4A7070(v43, this[2], this[3]);
    if ( !v42 )
    {
      v37 = 2;
      _CxxThrowException(&v37, &_TI1H);
    }
    v5 = dword_4A7074(v43);
    v6 = v5;
    v41 = v5;
    if ( !v5 )
    {
      v36 = 3;
      _CxxThrowException(&v36, &_TI1H);
    }
    v7 = dword_4A7078(v5, v42);
    v24[0] = this[2];
    v8 = this[23];
    v34 = v7;
    v9 = this[3];
    v23 = 0;
    v22 = 0;
    v24[1] = v9;
    dword_4A72F8(v8, &v22);
    dword_4A72F8(this[23], v24);
    dword_4A707C(v6, 0, 0, this[2], this[3], v43, v22, v23, 13369376);
    (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)this[16] + 104))(this[16], v43);
    v43 = 0;
    v10 = (_DWORD *)sub_40B720((int)&savedregs, 0x428u);
    v39 = v10;
    if ( !v10 )
    {
      v35 = 4;
      _CxxThrowException(&v35, &_TI1H);
    }
    memset(v10, 0, 0x28u);
    v11 = v41;
    v20 = v34;
    v19 = v41;
    *v10 = 40;
    dword_4A7078(v19, v20);
    v18 = v11;
    v12 = (int (__stdcall *)(int, int, _DWORD, _DWORD, int, _DWORD *, _DWORD))dword_4A7080;
    if ( !dword_4A7080(v18, v42, 0, this[3], 0, v10, 0) )
    {
      v33 = 5;
      _CxxThrowException(&v33, &_TI1H);
    }
    v13 = sub_40B720((int)&savedregs, v10[5]);
    v40 = v13;
    if ( !v13 )
    {
      v32 = 6;
      _CxxThrowException(&v32, &_TI1H);
    }
    if ( !v12(v41, v42, 0, this[3], v13, v10, 0) )
    {
      v31 = 7;
      _CxxThrowException(&v31, &_TI1H);
    }
    v44[0] = -1;
    LOBYTE(v45) = 1;
    sub_4080D0(v44, (int)&savedregs, a2, 0, 2);
    v25 = 19778;
    v28 = 0;
    v27 = 0;
    sub_4086E0(v44, (int)&v25, 14);
    sub_4086E0(v44, (int)v10, 40);
    v14 = 3;
    if ( v10[4] != 3 )
    {
      v15 = *((_WORD *)v10 + 7);
      if ( v15 > 8u )
        v14 = 0;
      else
        v14 = 1 << v15;
    }
    if ( v10[8] )
      v14 = v10[8];
    if ( v14 )
      sub_4086E0(v44, (int)(v10 + 10), 4 * v14);
    v16 = sub_4081D0(v44, 0);
    v17 = v40;
    v29 = v16;
    sub_4086E0(v44, v40, v10[5]);
    v26 = sub_4081D0(v44, 0);
    sub_408180(v44, 0);
    sub_4086E0(v44, (int)&v25, 14);
    sub_4087F0(v44);
    LOBYTE(v45) = 0;
    sub_4087F0(v44);
    v45 = -1;
    if ( v43 )
      (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)this[16] + 104))(this[16], v43);
    if ( v41 )
      dword_4A7084(v41);
    if ( v42 )
      dword_4A7088(v42);
    sub_40B7E0((unsigned int)v10);
    if ( v17 )
      sub_40B7E0(v17);
  }
}
// 403C31: conditional instruction was optimized away because of 'ebx.4!=0'
// 4A7070: using guessed type int (__stdcall *dword_4A7070)(_DWORD, _DWORD, _DWORD);
// 4A7074: using guessed type int (__stdcall *dword_4A7074)(_DWORD);
// 4A7078: using guessed type int (__stdcall *dword_4A7078)(_DWORD, _DWORD);
// 4A707C: using guessed type int (__stdcall *dword_4A707C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7080: using guessed type int (__stdcall *dword_4A7080)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7084: using guessed type int (__stdcall *dword_4A7084)(_DWORD);
// 4A7088: using guessed type int (__stdcall *dword_4A7088)(_DWORD);
// 4A72F8: using guessed type int (__stdcall *dword_4A72F8)(_DWORD, _DWORD);

//----- (00403C70) --------------------------------------------------------
_DWORD *__thiscall sub_403C70(_DWORD *this, int a2, void *a3, int a4, int a5, int a6, char a7)
{
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx

  this[1] = a2;
  *this = &off_4A7DC0;
  this[2] = 0;
  v8 = 1276311235;
  v9 = 240;
  do
    v8 ^= *(_DWORD *)&aConnectionToSe[4 * v9-- - 387012];
  while ( v9 );
  *(_DWORD *)((char *)this + v8 + 72680) = 0;
  this[10] = 0;
  this[149] = 0;
  this[148] = 0;
  this[147] = 0;
  this[157] = a6;
  this[158] = a5 * a4;
  *this = &off_4A8328;
  memset(this + 11, 0, 0x220u);
  strncpyt(this + 11, a3, 256);
  this[78] = 1;
  this[77] = 1;
  this[150] = 1;
  this[151] = 0;
  v10 = -2012333657;
  v11 = 234;
  do
    v10 ^= *(_DWORD *)&aDirectdrawEnum[4 * v11-- - 366516];
  while ( v11 );
  *(_DWORD *)((char *)this + v10 + 792096) = a4;
  *((_BYTE *)this + 640) = 0;
  this[156] = a5;
  *((_BYTE *)this + 35) = a7;
  this[154] = 1;
  this[153] = 1;
  v12 = 765960367;
  v13 = 227;
  do
    v12 ^= *(_DWORD *)&aBg14Bm2[4 * v13-- - 560760];
  while ( v13 );
  sub_4043D0((_DWORD *)((char *)this + v12 + 849436), 1);
  (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
  sub_40DA80((char *)(9141127 - ((_DWORD)&loc_40F899 + 2)));
  return this;
}
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);
// 4A8328: using guessed type int (__stdcall *off_4A8328)(char);

//----- (00403E10) --------------------------------------------------------
void *__thiscall sub_403E10(void *this, char a2)
{
  sub_403E30(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00403E30) --------------------------------------------------------
int __thiscall sub_403E30(void *this)
{
  int result; // eax
  int v3; // ecx

  sub_40B7D0(*((void **)this + 147));
  *((_DWORD *)this + 147) = 0;
  *((_DWORD *)this + 149) = 0;
  *((_DWORD *)this + 148) = 0;
  result = *((_DWORD *)this + 2);
  *(_DWORD *)this = &off_4A7DC0;
  if ( result )
  {
    v3 = *((_DWORD *)this + 1);
    if ( result != *(_DWORD *)(v3 + 68) )
    {
      if ( *(_DWORD *)(v3 + 56) )
        result = (*(int (__stdcall **)(int))(*(_DWORD *)result + 8))(result);
    }
  }
  *((_DWORD *)this + 2) = 0;
  return result;
}
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);

//----- (00403F00) --------------------------------------------------------
_DWORD *__thiscall sub_403F00(_DWORD *this, int a2, int a3, char a4, int a5)
{
  int v6; // eax
  char *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  _DWORD *v15; // ebx

  this[1] = a2;
  *this = &off_4A7DC0;
  this[2] = 0;
  v6 = 0;
  v7 = byte_40FC98;
  do
  {
    v6 -= *(_DWORD *)v7;
    v7 += 4;
  }
  while ( v7 < (char *)sub_40FD30 );
  *(_DWORD *)((char *)this + v6 - 1726415735) = 0;
  this[10] = 0;
  this[149] = 0;
  this[148] = 0;
  this[147] = 0;
  this[157] = *(_DWORD *)(a3 + 12);
  this[158] = *(_DWORD *)(a3 + 4) * *(_DWORD *)(a3 + 8);
  *this = &off_4A8328;
  memset(this + 11, 0, 0x220u);
  strncpyt(this + 11, *(void **)a3, 256);
  v8 = *(_DWORD *)(a3 + 24);
  if ( !v8 )
    v8 = 1;
  this[77] = v8;
  v9 = *(_DWORD *)(a3 + 28);
  if ( !v9 )
    v9 = 1;
  this[78] = v9;
  this[75] = *(_DWORD *)(a3 + 16);
  this[76] = *(_DWORD *)(a3 + 20);
  this[150] = 1;
  this[151] = 0;
  if ( a5 )
  {
    strncpyt(this + 79, *(void **)a5, 256);
    v10 = *(_DWORD *)(a5 + 24);
    if ( !v10 )
      v10 = 1;
    this[145] = v10;
    v11 = *(_DWORD *)(a5 + 28);
    if ( !v11 )
      v11 = 1;
    this[146] = v11;
    this[143] = *(_DWORD *)(a5 + 16);
    this[144] = *(_DWORD *)(a5 + 20);
    this[150] = 2;
  }
  v12 = -1520108833;
  v13 = 38;
  do
    v12 ^= (unsigned int)*(&dword_4A7300 + v13-- - 155035);
  while ( v13 );
  *(_DWORD *)((char *)this + v12 + 819144) = *(_DWORD *)(a3 + 4);
  this[156] = *(_DWORD *)(a3 + 8);
  *((_BYTE *)this + 35) = a4;
  *((_BYTE *)this + 640) = 0;
  this[154] = 1;
  this[153] = 1;
  v14 = 0;
  v15 = (_DWORD *)((char *)&loc_42305F + 1);
  do
    v14 -= *v15++;
  while ( v15 < (_DWORD *)&loc_4233E8 + 1 );
  sub_4043D0((_DWORD *)((char *)this + v14 + 46648639), 1);
  (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
  sub_40DA80((char *)(9141127 - ((_DWORD)&loc_40F899 + 2)));
  return this;
}
// 4A7300: using guessed type int (__stdcall *dword_4A7300)(_DWORD);
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);
// 4A8328: using guessed type int (__stdcall *off_4A8328)(char);

//----- (00404130) --------------------------------------------------------
int __thiscall sub_404130(_DWORD *this, int a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // ebx

  v3 = this + 11;
  strncpyt(this + 11, *(void **)a2, 256);
  v4 = *(_DWORD *)(a2 + 24);
  if ( !v4 )
    v4 = 1;
  v3[66] = v4;
  v5 = *(_DWORD *)(a2 + 28);
  if ( !v5 )
    v5 = 1;
  v3[67] = v5;
  v3[64] = *(_DWORD *)(a2 + 16);
  v3[65] = *(_DWORD *)(a2 + 20);
  this[157] = *(_DWORD *)(a2 + 12);
  this[158] = *(_DWORD *)(a2 + 8) * *(_DWORD *)(a2 + 4);
  v6 = 0;
  v7 = &loc_44E4C0;
  do
    v6 -= *v7++;
  while ( v7 < (_DWORD *)&loc_44E868 );
  *(_DWORD *)((char *)this + v6 + 877498051) = *(_DWORD *)(a2 + 4);
  this[156] = *(_DWORD *)(a2 + 8);
  sub_4043D0(this, 1);
  return sub_40DA80((char *)(9140099 - (_DWORD)&loc_40F443));
}

//----- (00404220) --------------------------------------------------------
int __thiscall sub_404220(_BYTE *this)
{
  int v2; // eax
  int v3; // ecx

  this[640] = 0;
  *((_DWORD *)this + 154) = 1;
  *((_DWORD *)this + 153) = 1;
  v2 = -1212692541;
  v3 = 62;
  do
    v2 ^= *(_DWORD *)&aCostaRica[4 * v3-- - 501500];
  while ( v3 );
  sub_4043D0(&this[v2 + 849436], 1);
  (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 16))(this);
  return sub_40DA80((char *)(9141127 - ((_DWORD)&loc_40F899 + 2)));
}

//----- (004042C0) --------------------------------------------------------
int __thiscall sub_4042C0(int this)
{
  int v2; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // ebp
  int result; // eax
  _DWORD *v8; // ecx
  int i; // edi
  int j; // edx
  int v11; // eax
  int v12; // eax
  int v13; // [esp+Ch] [ebp-14h]
  char v14[16]; // [esp+10h] [ebp-10h] BYREF

  v2 = *(_DWORD *)(this + 596);
  v3 = *(_DWORD *)(this + 624) * *(_DWORD *)(this + 620);
  v4 = this + 588;
  if ( v3 != v2 )
  {
    if ( v3 )
    {
      if ( v2 >= v3 )
      {
        if ( v2 > v3 )
          sub_40B780(16 * v3, (void **)(this + 588), 0);
      }
      else
      {
        sub_40B780(16 * v3, (void **)(this + 588), 0);
        v5 = *(_DWORD *)(v4 + 8);
        if ( v5 < v3 )
        {
          v6 = 16 * v5;
          v13 = v3 - v5;
          do
          {
            sub_46CAB0(v6 + *(_DWORD *)v4, v14, 0x10u);
            v6 += 16;
            --v13;
          }
          while ( v13 );
        }
      }
    }
    else
    {
      sub_40B7D0(*(void **)v4);
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 8) = 0;
      *(_DWORD *)(v4 + 4) = 0;
    }
    *(_DWORD *)(v4 + 4) = v3;
    *(_DWORD *)(v4 + 8) = v3;
  }
  result = *(_DWORD *)(this + 624);
  v8 = *(_DWORD **)v4;
  for ( i = 0; i < result; ++i )
  {
    for ( j = 0; j < *(_DWORD *)(this + 620); *(v8 - 1) = *(_DWORD *)(this + 616) + v12 )
    {
      v8 += 4;
      v11 = j * *(_DWORD *)(this + 612);
      *(v8 - 4) = v11;
      *(v8 - 2) = v11 + *(_DWORD *)(this + 612);
      v12 = *(_DWORD *)(this + 616) * i;
      *(v8 - 3) = v12;
      ++j;
    }
    result = *(_DWORD *)(this + 624);
  }
  return result;
}

//----- (004043D0) --------------------------------------------------------
void __thiscall sub_4043D0(_DWORD *this, int a2)
{
  int v3; // eax
  bool v4; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // eax
  int v12; // ecx
  int v13; // ecx
  _DWORD *v14; // edi
  int v15; // edx
  unsigned int v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ebx
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  void (__thiscall **v23)(void *, int); // edx
  int v24; // edx
  int v25; // eax
  struct tagRGBQUAD *v26; // ebx
  int v27; // eax
  unsigned int v28; // ebx
  unsigned __int8 *v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // eax
  int v34; // eax
  int v35; // eax
  unsigned __int8 *v36; // [esp-8h] [ebp-67Ch]
  int v37; // [esp-8h] [ebp-67Ch]
  unsigned __int8 *v38; // [esp-8h] [ebp-67Ch]
  int v39; // [esp-4h] [ebp-678h]
  int v40; // [esp-4h] [ebp-678h]
  struct tagRGBQUAD v41[256]; // [esp+Ch] [ebp-668h] BYREF
  int v42[9]; // [esp+40Ch] [ebp-268h] BYREF
  int v43; // [esp+430h] [ebp-244h]
  char v44[4]; // [esp+478h] [ebp-1FCh] BYREF
  int v45; // [esp+47Ch] [ebp-1F8h]
  unsigned int v46; // [esp+484h] [ebp-1F0h]
  unsigned int v47; // [esp+488h] [ebp-1ECh]
  char v48[16]; // [esp+608h] [ebp-6Ch] BYREF
  int v49[2]; // [esp+618h] [ebp-5Ch]
  char v50; // [esp+620h] [ebp-54h]
  char v51[16]; // [esp+624h] [ebp-50h] BYREF
  unsigned int v52; // [esp+634h] [ebp-40h]
  char v53; // [esp+63Ch] [ebp-38h]
  void **v54; // [esp+640h] [ebp-34h] BYREF
  unsigned int v55; // [esp+644h] [ebp-30h]
  int v56; // [esp+648h] [ebp-2Ch]
  bool v57; // [esp+64Ch] [ebp-28h]
  int v58; // [esp+650h] [ebp-24h]
  int v59; // [esp+654h] [ebp-20h]
  int v60[2]; // [esp+658h] [ebp-1Ch] BYREF
  int v61; // [esp+660h] [ebp-14h] BYREF
  int v62; // [esp+664h] [ebp-10h] BYREF
  int v63; // [esp+670h] [ebp-4h]

  v4 = 1;
  if ( !(_BYTE)a2 )
  {
    v3 = this[2];
    if ( !v3 || !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 96))(this[2]) )
      v4 = 0;
  }
  if ( this[2] )
  {
    if ( !v4
      && (*(int (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this[1] + 1204) + 24))(
           *(_DWORD *)(this[1] + 1204),
           &this[68 * this[151] + 11]) == this[152] )
    {
      v5 = this[2];
      if ( (!v5 || !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 96))(this[2]))
        && (this[151] != 1
         || !(*(int (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this[1] + 1204) + 24))(
               *(_DWORD *)(this[1] + 1204),
               this + 11)) )
      {
        if ( sub_4052C0((int)this) )
        {
          v39 = this[5];
          v36 = (unsigned __int8 *)(this[10] / 2 * v39 + this[4]);
          v62 = -1;
          this[7] = v36;
          sub_401A70(&v62, v36, v39);
          sub_405330((int)this);
          v6 = v62;
        }
        else
        {
          v6 = 0;
        }
        if ( v6 == this[3] )
          return;
        *((_BYTE *)this + 32) = 1;
        v62 = 9144740;
        sub_40DA80(aSpriteReloadCr);
      }
    }
  }
  v7 = this[2];
  if ( v7 && (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 108))(this[2]) )
    return;
  CxImage::CxImage((CxImage *)v44, 0);
  v63 = 0;
  while ( 1 )
  {
    `eh vector constructor iterator'(
      v48,
      0x1Cu,
      2,
      (void (__thiscall *)(void *))sub_404A90,
      (void (__thiscall *)(void *))sub_404B70);
    v8 = *(_DWORD *)(this[1] + 1204);
    LOBYTE(v63) = 1;
    (*(void (__thiscall **)(int, char *, _DWORD *))(*(_DWORD *)v8 + 28))(v8, v48, this + 11);
    if ( this[150] > 1u )
      (*(void (__thiscall **)(_DWORD, char *, _DWORD *))(**(_DWORD **)(this[1] + 1204) + 28))(
        *(_DWORD *)(this[1] + 1204),
        v51,
        this + 79);
    if ( !v50 )
    {
      if ( !v53 )
      {
        v62 = 9146901;
        sub_40DA80((char *)(9146901 - ((_DWORD)&loc_410E54 + 1)));
        v17 = *this;
        *((_BYTE *)this + 640) = 0;
        (*(void (__thiscall **)(_DWORD *))(v17 + 4))(this);
        LOBYTE(v63) = 0;
        `eh vector destructor iterator'(v48, 0x1Cu, 2, (int (__thiscall *)(char *))sub_404B70);
        goto LABEL_75;
      }
LABEL_25:
      v9 = 1;
      goto LABEL_26;
    }
    if ( v53 && v52 > v49[0] )
      goto LABEL_25;
    v9 = 0;
LABEL_26:
    v10 = 17 * v9;
    v11 = 28 * v9;
    this[151] = v9;
    v54 = &CxMemFile::`vftable';
    v12 = v49[7 * v9 + 1];
    v58 = 0;
    this[152] = v12;
    v13 = *(_DWORD *)&v48[v11 + 12];
    v14 = &this[4 * v10 + 11];
    v15 = v49[v11 / 4];
    v16 = *(_DWORD *)&v48[v11 + 8];
    v62 = (int)v14;
    v55 = v16;
    this[159] = v15;
    v59 = v13;
    v56 = v13;
    v57 = v16 == 0;
    LOBYTE(v63) = 2;
    if ( CxImage::Decode((CxImage *)v44, (struct CxFile *)&v54, 0) )
      break;
    v61 = 9148732;
    sub_40DA80((char *)(9148732 - ((_DWORD)&loc_411533 + 1)));
    (*(void (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this[1] + 1204) + 32))(
      *(_DWORD *)(this[1] + 1204),
      this + 11);
    v54 = &CxMemFile::`vftable';
    if ( v55 )
    {
      if ( v57 )
      {
        sub_46D360(v55);
        v55 = 0;
        v56 = 0;
      }
    }
    v54 = &CxFile::`vftable';
    LOBYTE(v63) = 0;
    `eh vector destructor iterator'(v48, 0x1Cu, 2, (int (__thiscall *)(char *))sub_404B70);
  }
  v54 = &CxMemFile::`vftable';
  if ( v55 && v57 )
  {
    sub_46D360(v55);
    v55 = 0;
    v56 = 0;
  }
  v54 = &CxFile::`vftable';
  LOBYTE(v63) = 0;
  `eh vector destructor iterator'(v48, 0x1Cu, 2, (int (__thiscall *)(char *))sub_404B70);
  v18 = this[155];
  this[153] = v46 / (v18 * v14[66]);
  v19 = v14[67];
  v61 = this[156];
  v20 = this[153];
  this[154] = v47 / (v61 * v19);
  if ( v20 < 1 )
    this[153] = 1;
  if ( (int)this[154] < 1 )
    this[154] = 1;
  v21 = this[153] * v18;
  v22 = this[154] * v61;
  if ( !this[2] || v21 != this[9] || v22 != this[10] )
  {
    v23 = (void (__thiscall **)(void *, int))*this;
    this[9] = v21;
    this[10] = v22;
    LOBYTE(v22) = *((_BYTE *)this + 35);
    (*v23)(this, v22);
    if ( !this[2] )
    {
      v24 = *this;
      *((_BYTE *)this + 640) = 0;
      (*(void (__thiscall **)(_DWORD *))(v24 + 4))(this);
      goto LABEL_75;
    }
    (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
  }
  if ( *(_DWORD *)(this[1] + 76) )
    (*(void (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)this[2] + 124))(this[2], *(_DWORD *)(this[1] + 76));
  if ( (*(int (__stdcall **)(_DWORD, int *))(*(_DWORD *)this[2] + 68))(this[2], &a2) )
  {
    v62 = 9152507;
    sub_40DA80((char *)(9152507 - (_DWORD)&loc_412463));
    v25 = *this;
    *((_BYTE *)this + 640) = 0;
    (*(void (__thiscall **)(_DWORD *))(v25 + 4))(this);
    goto LABEL_75;
  }
  if ( *(_DWORD *)(this[1] + 1196) != 100 )
  {
    v26 = CxImage::GetPalette((CxImage *)v44);
    if ( v26 )
    {
      memset(v41, 0, sizeof(v41));
      if ( (unsigned int)CxImage::GetPaletteSize((CxImage *)v44) > 0x400 )
        v27 = 1024;
      else
        v27 = CxImage::GetPaletteSize((CxImage *)v44);
      sub_46CAB0((unsigned int)v41, v26, v27);
      (*(void (__thiscall **)(_DWORD, struct tagRGBQUAD *))(*(_DWORD *)this[1] + 60))(this[1], v41);
      CxImage::SetPalette((CxImage *)v44, v41, 0x100u);
      v14 = (_DWORD *)v62;
    }
    else
    {
      nullsub_2(aNoPalette);
    }
  }
  v28 = v47 - this[154] * this[156] * (v14[65] + 1);
  v37 = v45;
  v61 = v47;
  v29 = CxImage::GetBits((CxImage *)v44);
  v61 = dword_4A706C(
          a2,
          0,
          0,
          this[153] * this[155],
          this[154] * this[156],
          this[9] * v14[64],
          v28,
          0,
          v61,
          v29,
          v37,
          0);
  (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)this[2] + 104))(this[2], a2);
  v60[0] = 0;
  v60[1] = 0;
  v30 = -1685295445;
  v31 = 210;
  do
    v30 ^= dword_4AB29C[v31-- - 130768];
  while ( v31 );
  (*(void (__stdcall **)(_DWORD, int, int *))(**(_DWORD **)((char *)this + v30 + 947976) + 116))(
    *(_DWORD *)((char *)this + v30 + 947976),
    8,
    v60);
  if ( !v61 )
  {
    v62 = 9156604;
    sub_40DA80((char *)(9156604 - ((_DWORD)&loc_413491 + 3)));
    v32 = *this;
    *((_BYTE *)this + 640) = 0;
    (*(void (__thiscall **)(_DWORD *))(v32 + 4))(this);
    goto LABEL_75;
  }
  if ( this[4] )
  {
LABEL_71:
    v40 = this[5];
    v38 = (unsigned __int8 *)(this[10] / 2 * v40 + this[4]);
    v61 = -1;
    this[7] = v38;
    sub_401A70(&v61, v38, v40);
    if ( this[4] )
    {
      (*(void (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)this[2] + 128))(this[2], this[4]);
      this[4] = 0;
    }
    v34 = v61;
  }
  else
  {
    v42[0] = 108;
    do
      v33 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int, _DWORD))(*(_DWORD *)this[2] + 100))(this[2], 0, v42, 1, 0);
    while ( v33 == -2005532132 );
    if ( v33 == -2005532222 )
    {
      *((_BYTE *)this + 32) = 1;
      goto LABEL_68;
    }
    if ( !v33 )
    {
      v35 = v43;
      this[7] = v43;
      this[4] = v35;
      this[5] = v42[4];
      goto LABEL_71;
    }
LABEL_68:
    v34 = 0;
  }
  this[3] = v34;
  *((_BYTE *)this + 640) = 1;
LABEL_75:
  v63 = -1;
  CxImage::~CxImage((CxImage *)v44);
}
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 4A706C: using guessed type int (__stdcall *dword_4A706C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A83D8: using guessed type void *CxFile::`vftable';
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (00404A90) --------------------------------------------------------
_DWORD *__thiscall sub_404A90(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[1] = 0;
  *((_BYTE *)this + 24) = 0;
  return result;
}

//----- (00404AA0) --------------------------------------------------------
BOOL __thiscall CxFile::PutC(CxFile *this, unsigned __int8 a2)
{
  return (*(int (__thiscall **)(CxFile *, unsigned __int8 *, int, int))(*(_DWORD *)this + 12))(this, &a2, 1, 1) == 1;
}

//----- (00404AE0) --------------------------------------------------------
void __thiscall CxMemFile::~CxMemFile(CxMemFile *this)
{
  unsigned int v2; // eax

  v2 = *((_DWORD *)this + 1);
  *(_DWORD *)this = &CxMemFile::`vftable';
  if ( v2 && *((_BYTE *)this + 12) )
  {
    sub_46D360(v2);
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 2) = 0;
  }
  *(_DWORD *)this = &CxFile::`vftable';
}
// 4A83D8: using guessed type void *CxFile::`vftable';
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (00404B20) --------------------------------------------------------
char __thiscall CxMemFile::Close(CxMemFile *this)
{
  unsigned int v2; // eax

  v2 = *((_DWORD *)this + 1);
  if ( v2 && *((_BYTE *)this + 12) )
  {
    sub_46D360(v2);
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 2) = 0;
  }
  return 1;
}

//----- (00404B70) --------------------------------------------------------
void __usercall sub_404B70(int a1@<ecx>, int a2@<ebp>)
{
  sub_40C9D0(a1, a2, 0);
}

//----- (00404B80) --------------------------------------------------------
void __thiscall sub_404B80(_DWORD *this, int a2, int a3, int a4, char a5)
{
  int v6; // ecx
  int v7; // eax
  int v8; // ebp
  int v9; // edx
  int v10; // eax
  int v11; // eax
  int *v12; // edi
  int v13; // ebx
  int v14; // edx
  int v15; // edi
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // [esp+10h] [ebp-20h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h] BYREF
  int v24; // [esp+24h] [ebp-Ch]
  int v25; // [esp+28h] [ebp-8h]
  int v26; // [esp+2Ch] [ebp-4h]

  if ( this[2] )
  {
    v6 = a2;
    v7 = a3;
    v8 = a2 + this[153];
    v9 = a3 + this[154];
    v19 = a2;
    v20 = a3;
    v21 = v8;
    v22 = v9;
    while ( 1 )
    {
      if ( v6 >= 0 && v7 >= 0 )
      {
        v10 = this[1];
        if ( v8 <= *(_DWORD *)(v10 + 8) && v9 <= *(_DWORD *)(v10 + 12) )
        {
          v11 = (*(int (__stdcall **)(_DWORD, int *, _DWORD, int, int, _DWORD))(**(_DWORD **)(v10 + 68) + 20))(
                  *(_DWORD *)(v10 + 68),
                  &v19,
                  this[2],
                  16 * a4 + this[147],
                  a5 != 0 ? 0x8000 : 0,
                  0);
          goto LABEL_20;
        }
        v7 = a3;
      }
      v12 = (int *)(16 * a4 + this[147]);
      v13 = *v12;
      v23 = *v12;
      v24 = v12[1];
      v14 = v12[2];
      v25 = v14;
      v15 = v12[3];
      v26 = v15;
      if ( v6 < 0 )
      {
        v13 -= v6;
        v19 = 0;
        v23 = v13;
      }
      if ( v7 < 0 )
      {
        v20 = 0;
        v24 -= v7;
      }
      v16 = this[1];
      v17 = *(_DWORD *)(v16 + 8);
      if ( v8 > v17 )
      {
        v14 += v17 - v8;
        v25 = v14;
        v21 = *(_DWORD *)(v16 + 8);
      }
      v18 = *(_DWORD *)(v16 + 12);
      if ( v22 > v18 )
      {
        v15 += v18 - v22;
        v26 = v15;
        v22 = *(_DWORD *)(v16 + 12);
      }
      if ( v14 - v13 <= 0 || v15 - v24 <= 0 )
        return;
      v11 = (*(int (__stdcall **)(_DWORD, int *, _DWORD, int *, int, _DWORD))(**(_DWORD **)(v16 + 68) + 20))(
              *(_DWORD *)(v16 + 68),
              &v19,
              this[2],
              &v23,
              a5 != 0 ? 0x8000 : 0,
              0);
LABEL_20:
      if ( v11 == -2005532222 )
      {
        sub_4043D0(this, 1);
        return;
      }
      if ( v11 != -2005532132 )
        return;
      nullsub_2("Sprite::Draw %x\n", -2005532132);
      v8 = v21;
      v6 = a2;
      v9 = v22;
      v7 = a3;
    }
  }
}
// 404A80: using guessed type int nullsub_2(const char *, ...);

//----- (00404D10) --------------------------------------------------------
void __thiscall sub_404D10(_DWORD *this, int a2, int a3, int a4, int a5, char a6)
{
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // [esp-4h] [ebp-2Ch]
  int v13[4]; // [esp+18h] [ebp-10h] BYREF

  if ( this[2] )
  {
    v7 = this[153];
    v13[0] = a3;
    v8 = a4 + this[154];
    v13[1] = a4;
    v12 = 16 * a5 + this[147];
    v9 = this[2];
    v13[3] = v8;
    v10 = *(_DWORD *)(a2 + 8);
    v13[2] = a3 + v7;
    v11 = (*(int (__stdcall **)(int, int *, int, int, int, _DWORD))(*(_DWORD *)v10 + 20))(
            v10,
            v13,
            v9,
            v12,
            a6 != 0 ? 0x8000 : 0,
            0);
    if ( v11 == -2005532222 )
    {
LABEL_5:
      sub_4043D0(this, 1);
      *(_BYTE *)(a2 + 32) = 1;
    }
    else
    {
      while ( v11 == -2005532132 )
      {
        v11 = (*(int (__stdcall **)(_DWORD, int *, _DWORD, int, int, _DWORD))(**(_DWORD **)(a2 + 8) + 20))(
                *(_DWORD *)(a2 + 8),
                v13,
                this[2],
                16 * a5 + this[147],
                a6 != 0 ? 0x8000 : 0,
                0);
        if ( v11 == -2005532222 )
          goto LABEL_5;
      }
    }
  }
}

//----- (00404DD0) --------------------------------------------------------
void __thiscall sub_404DD0(_DWORD *this, int a2, int a3, int a4, char a5, int a6, int a7)
{
  int v7; // edi
  int v8; // eax
  int v9; // esi

  v7 = a6;
  v8 = 0;
  if ( !a6 )
    v7 = this[158];
  v9 = this[157];
  if ( v9 )
    v8 = v7 * (a4 % v9) / v9;
  sub_404B80(this, a2, a3, a7 + v8, a5);
}

//----- (00404E20) --------------------------------------------------------
void __thiscall sub_404E20(_DWORD *this, int a2, int a3, int a4, char a5)
{
  sub_404B80(this, a2 - this[153] / 2, a3 - this[154] / 2, a4, a5);
}

//----- (00404E60) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __fastcall sub_404E60(int a1, int a2)
{
  unsigned int v3; // eax
  char result; // al
  _DWORD v5[7]; // [esp-10h] [ebp-68h] BYREF
  int v6[3]; // [esp+Ch] [ebp-4Ch] BYREF
  int v7; // [esp+18h] [ebp-40h]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  unsigned int v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  _DWORD v14[4]; // [esp+34h] [ebp-24h] BYREF
  int v15[2]; // [esp+44h] [ebp-14h] BYREF
  int v16; // [esp+54h] [ebp-4h]

  v15[1] = (int)v5;
  v16 = 1;
  v15[0] = -1;
  sub_407E80(a2, 1, 3);
  ReadScrty1FileOffset(v15, (int)v14, 14);
  ReadScrty1FileOffset(v15, (int)v6, 40);
  if ( LOWORD(v14[0]) == 19778 && v6[0] >= 0x28u && HIWORD(v7) == 8 )
  {
    v3 = v12;
    if ( !v12 || v12 > 0x100 )
      v3 = 256;
    ReadScrty1FileOffset(v15, a1, 4 * v3);
    LOBYTE(v16) = 0;
    ((void (__thiscall *)(int *))sub_4087F0)(v15);
    result = 1;
  }
  else
  {
    LOBYTE(v16) = 0;
    ((void (__thiscall *)(int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, int, int, int, int, int, int, int, unsigned int, int, _DWORD, _DWORD, _DWORD, _DWORD))sub_4087F0)(
      v15,
      v5[0],
      v5[1],
      v5[2],
      v5[3],
      v5[4],
      v5[5],
      v5[6],
      v6[0],
      v6[1],
      v6[2],
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14[0],
      v14[1],
      v14[2],
      v14[3]);
    result = 0;
  }
  return result;
}
// 404F2D: positive sp value 10 has been found
// 407E80: using guessed type _DWORD __stdcall sub_407E80(_DWORD, _DWORD, _DWORD);
// 4087F0: using guessed type _DWORD sub_4087F0();

//----- (00404F40) --------------------------------------------------------
char __fastcall sub_404F40(int a1, int a2, unsigned __int16 a3, _BYTE *a4)
{
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // esi
  unsigned int v11; // eax
  char v12[260]; // [esp+Ch] [ebp-10Ch] BYREF
  int v13; // [esp+110h] [ebp-8h]
  int v14; // [esp+114h] [ebp-4h]

  v14 = a1;
  v13 = 9171522;
  sub_407960(v12, 9171522 - ((_DWORD)&loc_416DB8 + 2), a4);
  if ( sub_404E60(a1, (int)v12) )
    return 1;
  if ( sub_404E60(a1, (int)a4) )
    return 1;
  v7 = dword_4A72A0(a2, a3, 2);
  v8 = v7;
  if ( !v7 )
    return 0;
  v9 = dword_4A72A4(a2, v7);
  if ( !v9 )
    return 0;
  v10 = dword_4A72A8(v9);
  if ( !v10 )
    return 0;
  dword_4A72AC(a2, v8);
  if ( *(_WORD *)(v10 + 14) != 8 )
    return 0;
  v11 = *(_DWORD *)(v10 + 32);
  if ( v11 >= 0x100 )
    v11 = 256;
  sub_46CAB0(v14, (_BYTE *)(v10 + 40), 4 * v11);
  return 1;
}
// 4A72A0: using guessed type int (__stdcall *dword_4A72A0)(_DWORD, _DWORD, _DWORD);
// 4A72A4: using guessed type int (__stdcall *dword_4A72A4)(_DWORD, _DWORD);
// 4A72A8: using guessed type int (__stdcall *dword_4A72A8)(_DWORD);
// 4A72AC: using guessed type int (__stdcall *dword_4A72AC)(_DWORD, _DWORD);

//----- (00405030) --------------------------------------------------------
_DWORD *__thiscall sub_405030(_DWORD *this, int a2, int a3, int a4, char a5)
{
  int v6; // eax
  int v7; // ecx
  int v8; // ecx

  this[1] = a2;
  *this = &off_4A7DC0;
  this[2] = 0;
  v6 = -554471084;
  v7 = 199;
  do
    v6 ^= *(_DWORD *)&aSbit[4 * v7-- - 470152];
  while ( v7 );
  *(_DWORD *)((char *)this + v6 + 72680) = a3;
  v8 = this[9];
  this[10] = a4;
  if ( v8 && a4 )
    sub_405190(this, a5);
  return this;
}
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);

//----- (004050A0) --------------------------------------------------------
_DWORD *__thiscall sub_4050A0(_DWORD *this, char a2)
{
  int v3; // eax
  int v4; // ecx

  v3 = this[2];
  *this = &off_4A7DC0;
  if ( v3 )
  {
    v4 = this[1];
    if ( v3 != *(_DWORD *)(v4 + 68) )
    {
      if ( *(_DWORD *)(v4 + 56) )
        (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
    }
  }
  this[2] = 0;
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}
// 4A7DC0: using guessed type int (__stdcall *off_4A7DC0)(char);

//----- (00405160) --------------------------------------------------------
int __thiscall sub_405160(_DWORD *this)
{
  int result; // eax
  int v3; // ecx

  result = this[2];
  if ( result )
  {
    v3 = this[1];
    if ( result != *(_DWORD *)(v3 + 68) )
    {
      if ( *(_DWORD *)(v3 + 56) )
        result = (*(int (__stdcall **)(int))(*(_DWORD *)result + 8))(result);
    }
  }
  this[2] = 0;
  return result;
}

//----- (00405190) --------------------------------------------------------
int __thiscall sub_405190(_DWORD *this, char a2)
{
  int v3; // eax
  _DWORD *v4; // ebx
  int result; // eax
  int i; // ebx
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13[27]; // [esp+8h] [ebp-74h] BYREF
  int v14[2]; // [esp+74h] [ebp-8h] BYREF

  (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
  this[4] = 0;
  *((_BYTE *)this + 32) = 1;
  v3 = 0;
  v4 = &unk_4AA470;
  do
    v3 -= *v4++;
  while ( v4 < dword_4AA7F4 );
  *(_DWORD *)((char *)this + v3 + 199663566) = *(_DWORD *)(this[1] + 16);
  result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)this[1] + 76))(this[1], 0);
  if ( !(_BYTE)result )
  {
    for ( i = a2 || *(_BYTE *)(this[1] + 52); i < 2; ++i )
    {
      v7 = this[9];
      memset(v13, 0, sizeof(v13));
      v8 = this[10];
      v13[0] = 108;
      v13[1] = 7;
      v13[3] = v7;
      v13[26] = i != 0 ? 2112 : 16448;
      v9 = this[1];
      v13[2] = v8;
      v10 = *(_DWORD *)(v9 + 60);
      if ( v10 )
        v11 = (*(int (__stdcall **)(int, int *, _DWORD *, _DWORD))(*(_DWORD *)v10 + 24))(v10, v13, this + 2, 0);
      else
        v11 = (*(int (__stdcall **)(_DWORD, int *, _DWORD *, _DWORD))(**(_DWORD **)(v9 + 56) + 24))(
                *(_DWORD *)(v9 + 56),
                v13,
                this + 2,
                0);
      *((_BYTE *)this + 35) = i != 0;
      if ( !v11 )
        break;
      if ( i )
        (*(void (__thiscall **)(_DWORD, int, char *))(*(_DWORD *)this[1] + 48))(this[1], v11, aSpriteSprite);
    }
    v12 = this[2];
    v14[0] = 0;
    v14[1] = 0;
    (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v12 + 116))(v12, 8, v14);
    result = *(_DWORD *)(this[1] + 76);
    if ( result )
      result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this[2] + 124))(this[2], result);
  }
  return result;
}

//----- (004052C0) --------------------------------------------------------
char __thiscall sub_4052C0(int this)
{
  int v2; // eax
  int v4; // eax
  int v5[9]; // [esp+4h] [ebp-6Ch] BYREF
  int v6; // [esp+28h] [ebp-48h]

  if ( !*(_DWORD *)(this + 16) )
  {
    v5[0] = 108;
    do
      v2 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int, _DWORD))(**(_DWORD **)(this + 8) + 100))(
             *(_DWORD *)(this + 8),
             0,
             v5,
             1,
             0);
    while ( v2 == -2005532132 );
    if ( v2 == -2005532222 )
    {
      *(_BYTE *)(this + 32) = 1;
      return 0;
    }
    if ( v2 )
      return 0;
    v4 = v6;
    *(_DWORD *)(this + 28) = v6;
    *(_DWORD *)(this + 16) = v4;
    *(_DWORD *)(this + 20) = v5[4];
  }
  return 1;
}

//----- (00405330) --------------------------------------------------------
int __thiscall sub_405330(int this)
{
  int v2; // ecx
  int result; // eax

  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
  {
    result = (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(this + 8) + 128))(*(_DWORD *)(this + 8), v2);
    *(_DWORD *)(this + 16) = 0;
  }
  return result;
}

//----- (00405350) --------------------------------------------------------
int __thiscall sub_405350(int this, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // ebx
  unsigned int v5; // edi
  int v6; // eax
  int v8; // eax
  _BYTE *v9; // [esp-8h] [ebp-80h]
  unsigned int v10; // [esp-4h] [ebp-7Ch]
  int v11[9]; // [esp+Ch] [ebp-6Ch] BYREF
  int v12; // [esp+30h] [ebp-48h]

  if ( !*(_DWORD *)(this + 8) )
    return -1;
  v4 = a2;
  if ( a2 >= *(_DWORD *)(this + 36) )
    return -1;
  v5 = a3;
  if ( a3 >= *(_DWORD *)(this + 40) )
    return -1;
  if ( !*(_DWORD *)(this + 16) )
  {
    v11[0] = 108;
    do
      v6 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int, _DWORD))(**(_DWORD **)(this + 8) + 100))(
             *(_DWORD *)(this + 8),
             0,
             v11,
             1,
             0);
    while ( v6 == -2005532132 );
    if ( v6 == -2005532222 )
    {
      *(_BYTE *)(this + 32) = 1;
      return -1;
    }
    if ( v6 )
      return -1;
    v8 = v12;
    *(_DWORD *)(this + 28) = v12;
    *(_DWORD *)(this + 16) = v8;
    *(_DWORD *)(this + 20) = v11[4];
  }
  v10 = *(_DWORD *)(this + 24);
  v9 = (_BYTE *)(*(_DWORD *)(this + 16) + v4 * v10 + v5 * *(_DWORD *)(this + 20));
  a2 = 0;
  sub_46CAB0((unsigned int)&a2, v9, v10);
  return a2;
}

//----- (00405410) --------------------------------------------------------
int __thiscall sub_405410(int this)
{
  int v2; // eax
  int v4; // eax
  unsigned __int8 *v5; // [esp+10h] [ebp-7Ch]
  int v6; // [esp+14h] [ebp-78h]
  int v7; // [esp+1Ch] [ebp-70h] BYREF
  int v8[9]; // [esp+20h] [ebp-6Ch] BYREF
  int v9; // [esp+44h] [ebp-48h]

  if ( !*(_DWORD *)(this + 16) )
  {
    v8[0] = 108;
    do
      v2 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int, _DWORD))(**(_DWORD **)(this + 8) + 100))(
             *(_DWORD *)(this + 8),
             0,
             v8,
             1,
             0);
    while ( v2 == -2005532132 );
    if ( v2 == -2005532222 )
    {
      *(_BYTE *)(this + 32) = 1;
      return 0;
    }
    if ( v2 )
      return 0;
    v4 = v9;
    *(_DWORD *)(this + 28) = v9;
    *(_DWORD *)(this + 16) = v4;
    *(_DWORD *)(this + 20) = v8[4];
  }
  v6 = *(_DWORD *)(this + 20);
  v5 = (unsigned __int8 *)(*(_DWORD *)(this + 16) + v6 * (*(_DWORD *)(this + 40) / 2));
  v7 = -1;
  *(_DWORD *)(this + 28) = v5;
  sub_401A70(&v7, v5, v6);
  if ( *(_DWORD *)(this + 16) )
  {
    (*(void (__stdcall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 8) + 128))(
      *(_DWORD *)(this + 8),
      *(_DWORD *)(this + 16));
    *(_DWORD *)(this + 16) = 0;
  }
  return v7;
}

//----- (00405550) --------------------------------------------------------
int __thiscall sub_405550(int this, int a2)
{
  int v3; // edx
  int v4; // ebx
  int result; // eax
  int v6; // ebp
  int v7; // ecx
  int v8; // eax
  int v9; // [esp+10h] [ebp-74h] BYREF
  int v10; // [esp+14h] [ebp-70h]
  int v11; // [esp+18h] [ebp-6Ch]
  int v12; // [esp+1Ch] [ebp-68h]
  int v13[25]; // [esp+20h] [ebp-64h] BYREF

  v3 = *(_DWORD *)(this + 36);
  v4 = 0;
  result = *(_DWORD *)(this + 8);
  v6 = *(_DWORD *)(this + 40);
  v9 = 0;
  v10 = 0;
  v11 = v3;
  v12 = v6;
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
    {
      (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)result + 128))(result, *(_DWORD *)(this + 16));
      v3 = v11;
      v6 = v12;
      *(_DWORD *)(this + 16) = 0;
      v4 = v9;
    }
    memset(v13, 0, sizeof(v13));
    v7 = *(_DWORD *)(this + 40);
    v13[20] = a2;
    v8 = *(_DWORD *)(this + 36);
    v13[0] = 100;
    if ( v4 < v3 && v10 < v6 )
    {
      if ( v8 <= 0 || v7 <= 0 )
      {
        v12 = 0;
        v11 = 0;
        v10 = 0;
        v9 = 0;
      }
      else
      {
        if ( v4 < 0 )
        {
          v4 = 0;
          v9 = 0;
        }
        if ( v10 < 0 )
          v10 = 0;
        if ( v3 > v8 )
        {
          v3 = v8;
          v11 = v8;
        }
        if ( v6 > v7 )
        {
          v6 = v7;
          v12 = v7;
        }
        if ( v3 < 0 )
          v11 = 0;
        if ( v6 < 0 )
          v12 = 0;
        if ( v4 > v8 )
          v9 = v8;
        if ( v10 > v7 )
          v10 = v7;
      }
    }
    result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int, int *))(**(_DWORD **)(this + 8) + 20))(
               *(_DWORD *)(this + 8),
               &v9,
               0,
               0,
               16778240,
               v13);
    if ( result == -2005532222 )
      *(_BYTE *)(this + 32) = 1;
  }
  return result;
}

//----- (00405680) --------------------------------------------------------
int __thiscall sub_405680(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int v8; // edx
  int v9; // edi
  int v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13[25]; // [esp+8h] [ebp-64h] BYREF

  result = *(_DWORD *)(this + 8);
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
    {
      (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)result + 128))(result, *(_DWORD *)(this + 16));
      *(_DWORD *)(this + 16) = 0;
    }
    v8 = *(_DWORD *)(this + 40);
    memset(v13, 0, sizeof(v13));
    v9 = a2;
    v10 = a4;
    v13[20] = a6;
    v11 = *(_DWORD *)(this + 36);
    v13[0] = 100;
    if ( a2 < a4 )
    {
      v12 = a5;
      if ( a3 < a5 )
      {
        if ( v11 <= 0 || v8 <= 0 )
        {
          a5 = 0;
          a4 = 0;
          a3 = 0;
          a2 = 0;
        }
        else
        {
          if ( a2 < 0 )
          {
            v9 = 0;
            a2 = 0;
          }
          if ( a3 < 0 )
            a3 = 0;
          if ( a4 > v11 )
          {
            v10 = v11;
            a4 = v11;
          }
          if ( a5 > v8 )
          {
            v12 = v8;
            a5 = v8;
          }
          if ( v10 < 0 )
            a4 = 0;
          if ( v12 < 0 )
            a5 = 0;
          if ( v9 > v11 )
            a2 = v11;
          if ( a3 > v8 )
            a3 = v8;
        }
      }
    }
    result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int, int *))(**(_DWORD **)(this + 8) + 20))(
               *(_DWORD *)(this + 8),
               &a2,
               0,
               0,
               16778240,
               v13);
    if ( result == -2005532222 )
      *(_BYTE *)(this + 32) = 1;
  }
  return result;
}

//----- (004057B0) --------------------------------------------------------
char __thiscall sub_4057B0(int this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 8);
  if ( !v2 )
    return 0;
  if ( (*(int (__stdcall **)(int))(*(_DWORD *)v2 + 96))(v2) )
    *(_BYTE *)(this + 32) = 1;
  if ( !*(_BYTE *)(this + 32) )
    return 0;
  if ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 8) + 108))(*(_DWORD *)(this + 8)) )
    return 0;
  *(_BYTE *)(this + 32) = 0;
  return 1;
}

//----- (004057F0) --------------------------------------------------------
int __thiscall sub_4057F0(int this, int a2, int a3, char a4)
{
  int v5; // ecx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // ebx
  int v10; // edx
  int v11; // edi
  int v12; // eax
  int result; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // ecx
  int v18; // [esp+18h] [ebp-20h] BYREF
  int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  int v22; // [esp+28h] [ebp-10h] BYREF
  int v23; // [esp+2Ch] [ebp-Ch]
  int v24; // [esp+30h] [ebp-8h]
  int v25; // [esp+34h] [ebp-4h]

  v5 = *(_DWORD *)(this + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(this + 8) + 128))(*(_DWORD *)(this + 8), v5);
    *(_DWORD *)(this + 16) = 0;
  }
  v6 = a2;
  v7 = *(_DWORD *)(this + 36);
  v8 = a3;
  v9 = *(_DWORD *)(this + 40);
  v18 = a2;
  v10 = v7 + a2;
  v11 = v9 + a3;
  v19 = a3;
  v20 = v10;
  v21 = v9 + a3;
  while ( 1 )
  {
    if ( v6 < 0 || v8 < 0 || (v12 = *(_DWORD *)(this + 4), v10 > *(_DWORD *)(v12 + 8)) || v11 > *(_DWORD *)(v12 + 12) )
    {
      v24 = *(_DWORD *)(this + 36);
      v14 = *(_DWORD *)(this + 40);
      v22 = 0;
      v23 = 0;
      v25 = v14;
      if ( v6 < 0 )
      {
        v22 = -v6;
        v18 = 0;
      }
      if ( a3 < 0 )
      {
        v23 = -a3;
        v19 = 0;
      }
      v15 = *(_DWORD *)(this + 4);
      v16 = *(_DWORD *)(v15 + 8);
      if ( v10 > v16 )
      {
        v24 += v16 - v10;
        v20 = *(_DWORD *)(v15 + 8);
      }
      v17 = *(_DWORD *)(v15 + 12);
      if ( v11 > v17 )
      {
        v25 += v17 - v11;
        v21 = *(_DWORD *)(v15 + 12);
      }
      result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, int *, int, _DWORD))(**(_DWORD **)(v15 + 68) + 20))(
                 *(_DWORD *)(v15 + 68),
                 &v18,
                 *(_DWORD *)(this + 8),
                 &v22,
                 a4 != 0 ? 0x8000 : 0,
                 0);
    }
    else
    {
      result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int, _DWORD))(**(_DWORD **)(v12 + 68) + 20))(
                 *(_DWORD *)(v12 + 68),
                 &v18,
                 *(_DWORD *)(this + 8),
                 0,
                 a4 != 0 ? 0x8000 : 0,
                 0);
    }
    if ( result == -2005532222 )
      break;
    if ( result != -2005532132 )
      return result;
    v11 = v21;
    v10 = v20;
    v6 = a2;
    v8 = a3;
  }
  *(_BYTE *)(this + 32) = 1;
  return result;
}

//----- (00405930) --------------------------------------------------------
int __thiscall sub_405930(int this, int a2, int a3, int a4, int a5, int a6, int a7, char a8)
{
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // esi
  int v13; // ecx
  int v14; // esi
  int v15; // eax
  int result; // eax
  int v17; // [esp+10h] [ebp-20h] BYREF
  int v18; // [esp+14h] [ebp-1Ch]
  int v19; // [esp+18h] [ebp-18h]
  int v20; // [esp+1Ch] [ebp-14h]
  int v21; // [esp+20h] [ebp-10h] BYREF
  int v22; // [esp+24h] [ebp-Ch]
  int v23; // [esp+28h] [ebp-8h]
  int v24; // [esp+2Ch] [ebp-4h]

  v9 = *(_DWORD *)(this + 16);
  if ( v9 )
  {
    (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(this + 8) + 128))(*(_DWORD *)(this + 8), v9);
    *(_DWORD *)(this + 16) = 0;
  }
  v22 = a3;
  v21 = a2;
  v10 = a2 + a6 - a4;
  v18 = a5;
  v11 = a3 + a7 - a5;
  v20 = a7;
  v23 = v10;
  v24 = v11;
  v17 = a4;
  v19 = a6;
  while ( 1 )
  {
    if ( a2 < 0 )
    {
      v21 = 0;
      v17 -= a2;
      v12 = a3;
    }
    else
    {
      v12 = a3;
      if ( a3 < 0 )
        goto LABEL_11;
      v13 = *(_DWORD *)(this + 4);
      if ( v10 <= *(_DWORD *)(v13 + 8) && v11 <= *(_DWORD *)(v13 + 12) )
        goto LABEL_16;
    }
    if ( v12 < 0 )
    {
LABEL_11:
      v22 = 0;
      v18 -= v12;
    }
    v13 = *(_DWORD *)(this + 4);
    v14 = *(_DWORD *)(v13 + 8);
    if ( v10 > v14 )
    {
      v19 += v14 - v10;
      v23 = *(_DWORD *)(v13 + 8);
    }
    v15 = *(_DWORD *)(v13 + 12);
    if ( v11 > v15 )
    {
      v20 += v15 - v11;
      v24 = *(_DWORD *)(v13 + 12);
    }
LABEL_16:
    result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, int *, int, _DWORD))(**(_DWORD **)(v13 + 68) + 20))(
               *(_DWORD *)(v13 + 68),
               &v21,
               *(_DWORD *)(this + 8),
               &v17,
               a8 != 0 ? 0x8000 : 0,
               0);
    if ( result == -2005532222 )
      break;
    if ( result != -2005532132 )
      return result;
    v11 = v24;
    v10 = v23;
  }
  *(_BYTE *)(this + 32) = 1;
  return result;
}

//----- (00405A90) --------------------------------------------------------
int __thiscall sub_405A90(int this, int a2)
{
  int result; // eax
  int v4; // edi
  int v5; // eax
  void (__stdcall *v6)(int, _DWORD, _DWORD, int); // ebp
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // [esp+6Ch] [ebp-74h] BYREF
  int v11; // [esp+70h] [ebp-70h]
  int v12[9]; // [esp+74h] [ebp-6Ch] BYREF
  int v13; // [esp+98h] [ebp-48h]

  result = *(_DWORD *)(this + 8);
  if ( !result )
    return result;
  if ( *(_DWORD *)(this + 16) )
  {
    (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)result + 128))(result, *(_DWORD *)(this + 16));
    *(_DWORD *)(this + 16) = 0;
  }
  v4 = -1;
  v5 = (*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(this + 8) + 68))(*(_DWORD *)(this + 8), &v10);
  v6 = (void (__stdcall *)(int, _DWORD, _DWORD, int))dword_4A7064;
  if ( !v5 )
  {
    v4 = dword_4A7068(v10, 0, 0);
    v6(v10, 0, 0, a2);
    (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(this + 8) + 104))(*(_DWORD *)(this + 8), v10);
  }
  v7 = *(_DWORD *)(this + 16);
  v11 = 0;
  if ( v7 )
    goto LABEL_13;
  v12[0] = 108;
  do
    v8 = (*(int (__stdcall **)(_DWORD, _DWORD, int *, int, _DWORD))(**(_DWORD **)(this + 8) + 100))(
           *(_DWORD *)(this + 8),
           0,
           v12,
           1,
           0);
  while ( v8 == -2005532132 );
  if ( v8 != -2005532222 )
  {
    if ( v8 )
      goto LABEL_14;
    v9 = v13;
    *(_DWORD *)(this + 28) = v13;
    *(_DWORD *)(this + 16) = v9;
    *(_DWORD *)(this + 20) = v12[4];
LABEL_13:
    v11 = **(_DWORD **)(this + 16);
    goto LABEL_14;
  }
  *(_BYTE *)(this + 32) = 1;
LABEL_14:
  if ( *(_DWORD *)(this + 16) )
  {
    (*(void (__stdcall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 8) + 128))(
      *(_DWORD *)(this + 8),
      *(_DWORD *)(this + 16));
    *(_DWORD *)(this + 16) = 0;
  }
  if ( v4 != -1 && !(*(int (__stdcall **)(_DWORD, int *))(**(_DWORD **)(this + 8) + 68))(*(_DWORD *)(this + 8), &v10) )
  {
    v6(v10, 0, 0, v4);
    (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(this + 8) + 104))(*(_DWORD *)(this + 8), v10);
  }
  return v11;
}
// 4A7064: using guessed type int dword_4A7064;
// 4A7068: using guessed type int (__stdcall *dword_4A7068)(_DWORD, _DWORD, _DWORD);

//----- (00405BC0) --------------------------------------------------------
int __thiscall sub_405BC0(int this, int a2, int a3, int a4, int a5)
{
  int v5; // edx
  int v7; // ebx
  int result; // eax
  int v9; // ebp
  int v10; // ecx
  int v11; // eax
  int v12; // [esp+10h] [ebp-74h] BYREF
  int v13; // [esp+14h] [ebp-70h]
  int v14; // [esp+18h] [ebp-6Ch]
  int v15; // [esp+1Ch] [ebp-68h]
  int v16[25]; // [esp+20h] [ebp-64h] BYREF

  v5 = a3;
  v7 = a2;
  result = *(_DWORD *)(this + 8);
  v12 = a2;
  v9 = a4 + 1;
  v13 = a4;
  v14 = a3;
  v15 = a4 + 1;
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
    {
      (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)result + 128))(result, *(_DWORD *)(this + 16));
      v5 = v14;
      v9 = v15;
      v7 = v12;
      *(_DWORD *)(this + 16) = 0;
    }
    memset(v16, 0, sizeof(v16));
    v10 = *(_DWORD *)(this + 40);
    v16[20] = a5;
    v11 = *(_DWORD *)(this + 36);
    v16[0] = 100;
    if ( v7 < v5 && v13 < v9 )
    {
      if ( v11 <= 0 || v10 <= 0 )
      {
        v15 = 0;
        v14 = 0;
        v13 = 0;
        v12 = 0;
      }
      else
      {
        if ( v7 < 0 )
        {
          v7 = 0;
          v12 = 0;
        }
        if ( v13 < 0 )
          v13 = 0;
        if ( v5 > v11 )
        {
          v5 = v11;
          v14 = v11;
        }
        if ( v9 > v10 )
        {
          v9 = v10;
          v15 = v10;
        }
        if ( v5 < 0 )
          v14 = 0;
        if ( v9 < 0 )
          v15 = 0;
        if ( v7 > v11 )
          v12 = v11;
        if ( v13 > v10 )
          v13 = v10;
      }
    }
    result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int, int *))(**(_DWORD **)(this + 8) + 20))(
               *(_DWORD *)(this + 8),
               &v12,
               0,
               0,
               16778240,
               v16);
    if ( result == -2005532222 )
      *(_BYTE *)(this + 32) = 1;
  }
  return result;
}

//----- (00405D00) --------------------------------------------------------
int __thiscall sub_405D00(int this, int a2, int a3, int a4, int a5)
{
  int v6; // edx
  int v7; // ebx
  int result; // eax
  int v9; // ebp
  int v10; // ecx
  int v11; // eax
  int v12; // [esp+10h] [ebp-74h] BYREF
  int v13; // [esp+14h] [ebp-70h]
  int v14; // [esp+18h] [ebp-6Ch]
  int v15; // [esp+1Ch] [ebp-68h]
  int v16[25]; // [esp+20h] [ebp-64h] BYREF

  v6 = a4 + 1;
  v7 = a4;
  result = *(_DWORD *)(this + 8);
  v9 = a3;
  v12 = a4;
  v13 = a2;
  v14 = a4 + 1;
  v15 = a3;
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
    {
      (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)result + 128))(result, *(_DWORD *)(this + 16));
      v6 = v14;
      v9 = v15;
      v7 = v12;
      *(_DWORD *)(this + 16) = 0;
    }
    memset(v16, 0, sizeof(v16));
    v10 = *(_DWORD *)(this + 40);
    v16[20] = a5;
    v11 = *(_DWORD *)(this + 36);
    v16[0] = 100;
    if ( v7 < v6 && v13 < v9 )
    {
      if ( v11 <= 0 || v10 <= 0 )
      {
        v15 = 0;
        v14 = 0;
        v13 = 0;
        v12 = 0;
      }
      else
      {
        if ( v7 < 0 )
        {
          v7 = 0;
          v12 = 0;
        }
        if ( v13 < 0 )
          v13 = 0;
        if ( v6 > v11 )
        {
          v6 = v11;
          v14 = v11;
        }
        if ( v9 > v10 )
        {
          v9 = v10;
          v15 = v10;
        }
        if ( v6 < 0 )
          v14 = 0;
        if ( v9 < 0 )
          v15 = 0;
        if ( v7 > v11 )
          v12 = v11;
        if ( v13 > v10 )
          v13 = v10;
      }
    }
    result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int, int *))(**(_DWORD **)(this + 8) + 20))(
               *(_DWORD *)(this + 8),
               &v12,
               0,
               0,
               16778240,
               v16);
    if ( result == -2005532222 )
      *(_BYTE *)(this + 32) = 1;
  }
  return result;
}

//----- (00405EF0) --------------------------------------------------------
_DWORD *__thiscall sub_405EF0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[12] = a2;
  *this = &off_4A8580;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 16;
  this[5] = 500;
  this[8] = 0;
  this[7] = 0;
  this[10] = 0;
  this[9] = 0;
  *((_BYTE *)this + 24) = 0;
  *((_BYTE *)this + 25) = 0;
  *((_BYTE *)this + 52) = 1;
  this[11] = 0;
  return result;
}
// 4A8580: using guessed type int (*off_4A8580)();

//----- (00405F40) --------------------------------------------------------
_DWORD *__thiscall sub_405F40(_DWORD *this, char a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax

  v3 = this[3];
  *this = &off_4A8580;
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  v4 = this[2];
  if ( v4 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v4 + 8))(this[2]);
  v5 = this[1];
  if ( v5 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(this[1]);
  *((_BYTE *)this + 24) = 0;
  this[3] = 0;
  this[2] = 0;
  this[1] = 0;
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}
// 4A8580: using guessed type int (*off_4A8580)();

//----- (00405FA0) --------------------------------------------------------
int __thiscall sub_405FA0(int this)
{
  int v2; // eax
  int v3; // eax
  int result; // eax

  v2 = *(_DWORD *)(this + 12);
  if ( v2 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
  v3 = *(_DWORD *)(this + 8);
  if ( v3 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 8))(*(_DWORD *)(this + 8));
  result = *(_DWORD *)(this + 4);
  if ( result )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)result + 8))(*(_DWORD *)(this + 4));
  *(_BYTE *)(this + 24) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00405FE0) --------------------------------------------------------
char __thiscall sub_405FE0(_BYTE *this, int a2, unsigned int a3, int a4, char a5)
{
  _DWORD *v6; // esi
  char result; // al
  char v8; // cl
  _DWORD *v9; // ebx
  int v10; // eax
  _DWORD *v11; // esi
  unsigned __int16 *v12; // esi
  int v13; // [esp+Ch] [ebp-14h] BYREF
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+18h] [ebp-8h]
  int v17; // [esp+1Ch] [ebp-4h]

  v6 = this + 4;
  if ( sub_459A50(0, this + 4, 0) )
  {
    sub_40DA80((char *)&word_4A858E[79]);
    result = 0;
  }
  else
  {
    this[25] = a5;
    if ( (*(int (__stdcall **)(_DWORD, int, int))(*(_DWORD *)*v6 + 24))(*v6, a2, (a3 != 0) + 1) )
      sub_40DA80((char *)&word_4A858E[55]);
    v8 = this[25];
    v13 = 0;
    v9 = this + 8;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = *v6;
    v14 = v8 != 0 ? 17 : 1;
    v13 = 20;
    if ( (*(int (__stdcall **)(int, int *, _BYTE *, _DWORD))(*(_DWORD *)v10 + 12))(v10, &v13, this + 8, 0) )
    {
      sub_40DA80((char *)&word_4A858E[27]);
      (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v6 + 8))(*v6);
      *v6 = 0;
      result = 0;
    }
    else
    {
      if ( this[25] )
      {
        v11 = this + 12;
        if ( (**(int (__stdcall ***)(_DWORD, void *, int))*v9)(*v9, &unk_4AE5B0, (int)(this + 12)) )
        {
          sub_40DA80((char *)&word_4A858E[1]);
          this[25] = 0;
        }
        else
        {
          (*(void (__stdcall **)(_DWORD, _DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)*v11 + 52))(
            *v11,
            0,
            -1082130432,
            0,
            0,
            0,
            0,
            0);
          (*(void (__stdcall **)(_DWORD, int, _DWORD))(*(_DWORD *)*v11 + 44))(*v11, 1036831949, 0);
          (*(void (__stdcall **)(_DWORD, int, _DWORD))(*(_DWORD *)*v11 + 60))(*v11, 1053609165, 0);
          (*(void (__stdcall **)(_DWORD, int, _DWORD))(*(_DWORD *)*v11 + 48))(*v11, 0x40000000, 0);
        }
      }
      if ( a3 )
      {
        v12 = (unsigned __int16 *)&unk_4A84B6;
        do
        {
          if ( *(_DWORD *)(v12 - 5) <= a3
            && *v12 <= a4
            && !(*(int (__stdcall **)(_DWORD, unsigned __int16 *))(*(_DWORD *)*v9 + 56))(*v9, v12 - 7) )
          {
            break;
          }
          v12 += 9;
        }
        while ( v12 < word_4A858E );
      }
      result = 1;
      this[24] = 1;
    }
  }
  return result;
}
// 459A50: using guessed type int __stdcall sub_459A50(_DWORD, _DWORD, _DWORD);

//----- (004061A0) --------------------------------------------------------
int __thiscall sub_4061A0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax
  double v7; // st7
  float v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+14h] [ebp-14h]
  float v10; // [esp+18h] [ebp-10h]
  float v11; // [esp+18h] [ebp-10h]

  *(_DWORD *)(this + 28) = a2;
  *(_DWORD *)(this + 36) = a4;
  *(_DWORD *)(this + 32) = a3;
  *(_DWORD *)(this + 40) = a5;
  result = sub_412170();
  if ( *(_BYTE *)(this + 24) && *(_BYTE *)(this + 25) && result - *(_DWORD *)(this + 44) >= 20 )
  {
    v7 = (double)*(int *)(this + 32);
    *(_DWORD *)(this + 44) = result;
    v10 = v7;
    v8 = (float)*(int *)(this + 28);
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, int))(**(_DWORD **)(this + 12) + 56))(
      *(_DWORD *)(this + 12),
      LODWORD(v8),
      LODWORD(v10),
      0,
      1);
    v11 = (float)*(int *)(this + 40);
    v9 = (float)*(int *)(this + 36);
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, int))(**(_DWORD **)(this + 12) + 64))(
      *(_DWORD *)(this + 12),
      LODWORD(v9),
      LODWORD(v11),
      0,
      1);
    result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 12) + 68))(*(_DWORD *)(this + 12));
  }
  return result;
}

//----- (00406230) --------------------------------------------------------
int __thiscall sub_406230(int this, int a2, void *a3, unsigned int a4, char a5)
{
  bool v6; // al
  int v7; // eax

  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_4A8658;
  strncpyt((void *)(this + 8), a3, 128);
  v6 = a5 && *(_BYTE *)(a2 + 25);
  *(_BYTE *)(this + 356) = v6;
  *(_DWORD *)(this + 328) = 0;
  memset((void *)(this + 136), 0, 0x40u);
  memset((void *)(this + 200), 0, 0x40u);
  memset((void *)(this + 264), 0, 0x40u);
  *(_DWORD *)(this + 348) = 0;
  if ( *(_BYTE *)(a2 + 24) )
  {
    *(_DWORD *)(this + 340) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(this + 344) = *(_DWORD *)(a2 + 20);
    v7 = a4;
    if ( a4 >= 0x10 )
    {
      v7 = 16;
    }
    else if ( a4 <= 1 )
    {
      v7 = 1;
    }
    *(_DWORD *)(this + 328) = v7;
    *(_DWORD *)(this + 332) = 0;
    memset((void *)(this + 136), 0, 0x40u);
    memset((void *)(this + 200), 0, 0x40u);
    sub_406A60((int *)this, a2, 0, 0);
  }
  return this;
}
// 4A8658: using guessed type int (*off_4A8658)();

//----- (00406320) --------------------------------------------------------
_DWORD *__thiscall sub_406320(_DWORD *this, char a2)
{
  int v3; // eax
  void *v4; // edi
  _DWORD *v5; // esi
  int v6; // ebp
  int v7; // eax

  v3 = this[1];
  *this = &off_4A8658;
  if ( *(_BYTE *)(v3 + 24) )
  {
    v4 = this + 34;
    v5 = this + 34;
    v6 = 16;
    do
    {
      v7 = v5[16];
      if ( v7 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(v5[16]);
      if ( *v5 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v5 + 8))(*v5);
      ++v5;
      --v6;
    }
    while ( v6 );
    memset(v4, 0, 0x40u);
    memset(this + 50, 0, 0x40u);
  }
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}
// 4A8658: using guessed type int (*off_4A8658)();

//----- (004063A0) --------------------------------------------------------
int __thiscall sub_4063A0(int this, int a2, int a3)
{
  bool v4; // al
  int v5; // eax
  int v6; // eax
  unsigned int v7; // eax

  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_4A8658;
  strncpyt((void *)(this + 8), *(void **)a3, 128);
  v4 = *(_BYTE *)(a3 + 8) && *(_BYTE *)(a2 + 25);
  *(_BYTE *)(this + 356) = v4;
  *(_DWORD *)(this + 328) = 0;
  *(_DWORD *)(this + 332) = 0;
  memset((void *)(this + 136), 0, 0x40u);
  memset((void *)(this + 200), 0, 0x40u);
  memset((void *)(this + 264), 0, 0x40u);
  *(_DWORD *)(this + 348) = 0;
  if ( *(_BYTE *)(a2 + 24) )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( !v5 )
      v5 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(this + 340) = v5;
    v6 = *(_DWORD *)(a3 + 16);
    if ( !v6 )
      v6 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(this + 344) = v6;
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 >= 0x10 )
    {
      v7 = 16;
    }
    else if ( v7 <= 1 )
    {
      v7 = 1;
    }
    *(_DWORD *)(this + 328) = v7;
    sub_406A60((int *)this, a3, 0, 0);
  }
  return this;
}
// 40645D: conditional instruction was optimized away because of 'eax.4 in (2..F)'
// 4A8658: using guessed type int (*off_4A8658)();

//----- (00406480) --------------------------------------------------------
int __thiscall sub_406480(int this, int a2, _BYTE *a3, int a4)
{
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_4A8658;
  *(_BYTE *)(this + 8) = 0;
  *(_BYTE *)(this + 356) = 0;
  *(_DWORD *)(this + 328) = 0;
  *(_DWORD *)(this + 332) = 0;
  memset((void *)(this + 136), 0, 0x40u);
  memset((void *)(this + 200), 0, 0x40u);
  memset((void *)(this + 264), 0, 0x40u);
  *(_DWORD *)(this + 348) = 0;
  if ( *(_BYTE *)(a2 + 24) )
  {
    *(_DWORD *)(this + 340) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(this + 344) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(this + 328) = 1;
    sub_406A60((int *)this, 0, a3, a4);
  }
  return this;
}
// 4A8658: using guessed type int (*off_4A8658)();

//----- (00406520) --------------------------------------------------------
int __thiscall sub_406520(_DWORD *this)
{
  int result; // eax
  void *v3; // edi
  _DWORD *v4; // esi
  int v5; // ebx
  int v6; // eax

  result = this[1];
  if ( *(_BYTE *)(result + 24) )
  {
    v3 = this + 34;
    v4 = this + 34;
    v5 = 16;
    do
    {
      v6 = v4[16];
      if ( v6 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v6 + 8))(v4[16]);
      if ( *v4 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v4 + 8))(*v4);
      ++v4;
      --v5;
    }
    while ( v5 );
    result = 0;
    memset(v3, 0, 0x40u);
    memset(this + 50, 0, 0x40u);
  }
  return result;
}

//----- (004065E0) --------------------------------------------------------
int __userpurge sub_4065E0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int result; // eax
  int v11; // edi
  int v12; // eax
  int v13; // eax
  int v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+1Ch] [ebp-4h]

  result = *(_DWORD *)(a1 + 4);
  if ( *(_BYTE *)(result + 24) )
  {
    if ( *(_BYTE *)(result + 52) )
    {
      result = (**(int (__thiscall ***)(int))a1)(a1);
      v11 = result;
      if ( result >= 0 )
      {
        v12 = *(_DWORD *)(a1 + 4 * result + 200);
        if ( v12 )
          (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)v12 + 72))(v12, 2, 0);
        *(_DWORD *)(a1 + 4 * v11 + 264) = a3;
        v13 = a3 + *(_DWORD *)(a1 + 348);
        if ( v13 <= 0 )
        {
          if ( v13 < -10000 )
            v13 = -10000;
        }
        else
        {
          v13 = 0;
        }
        (*(void (__stdcall **)(_DWORD, int, int, int, int))(**(_DWORD **)(a1 + 4 * v11 + 136) + 60))(
          *(_DWORD *)(a1 + 4 * v11 + 136),
          v13,
          a2,
          v14,
          v15);
        (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(a1 + 4 * v11 + 136) + 64))(
          *(_DWORD *)(a1 + 4 * v11 + 136),
          a7);
        (*(void (__stdcall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 4 * v11 + 136) + 52))(
          *(_DWORD *)(a1 + 4 * v11 + 136),
          0);
        (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(a1 + 4 * v11 + 136) + 68))(
          *(_DWORD *)(a1 + 4 * v11 + 136),
          *(_DWORD *)(a1 + 336) + a9 / 10000);
        result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v11 + 136) + 48))(*(_DWORD *)(a1 + 4 * v11 + 136));
      }
    }
  }
  return result;
}
// 406655: variable 'v14' is possibly undefined
// 406655: variable 'v15' is possibly undefined

//----- (004066D0) --------------------------------------------------------
char __thiscall sub_4066D0(_DWORD *this, int a2, char a3)
{
  int v3; // eax
  int v5; // ebx
  _DWORD *v6; // edi
  int v7; // eax

  LOBYTE(v3) = a2;
  if ( a2 != this[87] )
  {
    if ( *(_BYTE *)(this[1] + 24) )
    {
      this[87] = a2;
      LOBYTE(v3) = a3;
      if ( a3 )
      {
        v3 = this[82];
        v5 = 0;
        if ( v3 > 0 )
        {
          v6 = this + 34;
          do
          {
            if ( *v6 )
            {
              v7 = this[87] + v6[32];
              if ( v7 <= 0 )
              {
                if ( v7 < -10000 )
                  v7 = -10000;
              }
              else
              {
                v7 = 0;
              }
              (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)*v6 + 60))(*v6, v7);
            }
            v3 = this[82];
            ++v5;
            ++v6;
          }
          while ( v5 < v3 );
        }
      }
    }
  }
  return v3;
}

//----- (00406750) --------------------------------------------------------
int __thiscall sub_406750(_DWORD *this)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // edi

  result = this[1];
  if ( *(_BYTE *)(result + 24) )
  {
    result = this[82];
    v3 = 0;
    if ( result > 0 )
    {
      v4 = this + 34;
      do
      {
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v4 + 72))(*v4);
        result = this[82];
        ++v3;
        ++v4;
      }
      while ( v3 < result );
    }
  }
  return result;
}

//----- (00406790) --------------------------------------------------------
int __thiscall sub_406790(int (__thiscall ***this)(void *), int a2, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // edi
  int v8; // ebp
  int (__thiscall **v9)(void *); // eax
  int v10; // eax
  int v11; // ecx
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  float v15; // [esp+14h] [ebp-20h]
  float v16; // [esp+14h] [ebp-20h]
  float v17; // [esp+18h] [ebp-1Ch]
  float v18; // [esp+18h] [ebp-1Ch]
  int v19; // [esp+40h] [ebp+Ch]

  result = (int)this[1];
  if ( *(_BYTE *)(result + 24) )
  {
    if ( *(_BYTE *)(result + 52) )
    {
      result = (**this)(this);
      v7 = result;
      v8 = 0;
      if ( result >= 0 )
      {
        v9 = this[result + 50];
        if ( v9 )
        {
          v17 = (float)a3;
          v15 = (float)a2;
          (*((void (__stdcall **)(int (__thiscall **)(void *), _DWORD, _DWORD, _DWORD, int))*v9 + 19))(
            v9,
            LODWORD(v15),
            LODWORD(v17),
            0,
            1);
          v18 = (float)a5;
          v16 = (float)a4;
          (*((void (__stdcall **)(int (__thiscall **)(void *), _DWORD, _DWORD, _DWORD, int))*this[v7 + 50] + 20))(
            this[v7 + 50],
            LODWORD(v16),
            LODWORD(v18),
            0,
            1);
          (*((void (__stdcall **)(int (__thiscall **)(void *), _DWORD, _DWORD))*this[v7 + 50] + 18))(
            this[v7 + 50],
            0,
            0);
          this[v7 + 66] = 0;
          v10 = (int)this[87];
          if ( v10 <= 0 )
          {
            if ( v10 < -10000 )
              v10 = -10000;
            (*((void (__stdcall **)(int (__thiscall **)(void *), int))*this[v7 + 34] + 15))(this[v7 + 34], v10);
          }
          else
          {
            (*((void (__stdcall **)(int (__thiscall **)(void *), _DWORD))*this[v7 + 34] + 15))(this[v7 + 34], 0);
          }
LABEL_20:
          (*((void (__stdcall **)(int (__thiscall **)(void *), _DWORD))*this[v7 + 34] + 13))(this[v7 + 34], 0);
          return (*((int (__stdcall **)(int (__thiscall **)(void *), _DWORD, _DWORD, _DWORD))*this[v7 + 34] + 12))(
                   this[v7 + 34],
                   0,
                   0,
                   0);
        }
        v19 = a2 - (_DWORD)this[1][7];
        v11 = abs32(a3 - (_DWORD)this[1][8]);
        result = abs32(v19);
        v12 = result;
        if ( result < v11 )
          v12 = v11;
        if ( v12 <= (int)this[86] )
        {
          if ( v12 > (int)this[85] )
            v8 = (__int64)(atan2((double)v19, (double)v11) * dbl_4A8680);
          v13 = -1 * v12;
          this[v7 + 66] = (int (__thiscall **)(void *))(v13 * 4);
          v14 = (int)&this[87][v13];
          if ( v14 <= 0 )
          {
            if ( v14 < -10000 )
              v14 = -10000;
          }
          else
          {
            v14 = 0;
          }
          (*((void (__stdcall **)(int (__thiscall **)(void *), int))*this[v7 + 34] + 15))(this[v7 + 34], v14);
          (*((void (__stdcall **)(int (__thiscall **)(void *), int))*this[v7 + 34] + 16))(this[v7 + 34], v8);
          goto LABEL_20;
        }
      }
    }
  }
  return result;
}
// 4A8680: using guessed type double dbl_4A8680;

//----- (00406930) --------------------------------------------------------
int __thiscall sub_406930(_DWORD *this)
{
  int result; // eax
  int v3; // [esp-4h] [ebp-10h]
  int v4; // [esp+0h] [ebp-Ch]
  char v5[4]; // [esp+8h] [ebp-4h] BYREF

  if ( !*(_BYTE *)(this[1] + 24) )
    return -1;
  if ( !this[82] )
    return -1;
  v3 = this[this[83] + 34];
  if ( (*(int (__stdcall **)(int, char *))(*(_DWORD *)v3 + 36))(v3, v5) || (v5[0] & 4) != 0 )
    return -1;
  if ( (v5[0] & 2) != 0 )
  {
    if ( *((_BYTE *)this + 8) )
    {
      v4 = this[this[83] + 34];
      (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 80))(v4);
      (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD))(*this + 8))(this, 0, 0);
    }
  }
  result = this[83];
  this[83] = (result + 1) % this[82];
  return result;
}

//----- (00406A10) --------------------------------------------------------
int __thiscall sub_406A10(_DWORD *this, char a2)
{
  int result; // eax

  result = 0;
  if ( a2 )
    goto LABEL_5;
  if ( *((_BYTE *)this + 8) )
    result = (*(int (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this[1] + 48) + 24))(
               *(_DWORD *)(this[1] + 48),
               this + 2);
  if ( result != this[88] )
  {
LABEL_5:
    (*(void (__thiscall **)(_DWORD *))(*this + 28))(this);
    result = (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD))(*this + 8))(this, 0, 0);
  }
  return result;
}

//----- (00406A60) --------------------------------------------------------
void __userpurge sub_406A60(int *a1@<ecx>, int a2@<ebx>, _BYTE *a3, int a4)
{
  int v5; // eax
  char v6; // dl
  int v7; // edx
  int v8; // ebx
  int *v9; // edi
  unsigned int v10; // edx
  unsigned int v11; // ecx
  int v12; // ebx
  _DWORD *v13; // edi
  int v14; // eax
  float v15; // [esp+68h] [ebp-78h]
  float v16; // [esp+68h] [ebp-78h]
  int v18[6]; // [esp+78h] [ebp-68h] BYREF
  char v19; // [esp+90h] [ebp-50h]
  int v20[5]; // [esp+94h] [ebp-4Ch] BYREF
  char v21[20]; // [esp+A8h] [ebp-38h] BYREF
  int v22; // [esp+BCh] [ebp-24h]
  int v23; // [esp+C0h] [ebp-20h]
  unsigned int v24; // [esp+C4h] [ebp-1Ch] BYREF
  unsigned int v25; // [esp+C8h] [ebp-18h] BYREF
  unsigned int v26; // [esp+CCh] [ebp-14h] BYREF
  unsigned int v27; // [esp+D0h] [ebp-10h] BYREF
  int v28; // [esp+DCh] [ebp-4h]
  int savedregs; // [esp+E0h] [ebp+0h] BYREF

  if ( *(_BYTE *)(a1[1] + 24) && a1[82] )
  {
    v22 = 9084666;
    sub_40DA80(aDirectsoundRel);
    (*(void (__thiscall **)(int *))(*a1 + 16))(a1);
    v18[0] = 0;
    v18[1] = 0;
    v19 = 0;
    v5 = *a1;
    v28 = 0;
    (*(void (__thiscall **)(int *, int *, _BYTE **, int *, char *))(v5 + 12))(a1, v18, &a3, &a4, v21);
    if ( a4 )
    {
      if ( !a1[34] )
      {
        v6 = *((_BYTE *)a1 + 356);
        v20[2] = a4;
        v20[0] = 20;
        v20[3] = 0;
        v20[1] = v6 != 0 ? 146 : 226;
        v7 = a1[1];
        v20[4] = (int)v21;
        if ( (*(int (__stdcall **)(_DWORD, int *, int *, _DWORD))(**(_DWORD **)(v7 + 4) + 12))(
               *(_DWORD *)(v7 + 4),
               v20,
               a1 + 34,
               0) )
        {
          a1[82] = 0;
          v22 = 9085500;
          sub_40DA80((char *)(9085500 - ((_DWORD)&loc_401B53 + 5)));
        }
        else
        {
          v8 = 1;
          if ( a1[82] > 1 )
          {
            v9 = a1 + 35;
            while ( !(*(int (__stdcall **)(_DWORD, int, int *))(**(_DWORD **)(a1[1] + 4) + 20))(
                       *(_DWORD *)(a1[1] + 4),
                       a1[34],
                       v9) )
            {
              ++v8;
              ++v9;
              if ( v8 >= a1[82] )
                goto LABEL_14;
            }
            v22 = 9085636;
            sub_40DA80((char *)(9085636 - (_DWORD)sub_401C10));
            a1[v8 + 34] = 0;
          }
LABEL_14:
          a1[82] = v8;
        }
      }
      if ( a1[82] )
      {
        if ( (*(int (__stdcall **)(int, _DWORD, int, unsigned int *, unsigned int *, unsigned int *, unsigned int *, _DWORD, int))(*(_DWORD *)a1[34] + 44))(
               a1[34],
               0,
               a4,
               &v25,
               &v27,
               &v24,
               &v26,
               0,
               a2) )
        {
          v22 = 9086301;
          sub_40DA80((char *)(9086301 - ((_DWORD)&loc_401ED3 + 2)));
        }
        else
        {
          v10 = v27;
          if ( v27 )
          {
            sub_46CAB0(v25, a3, v27);
            v10 = v27;
          }
          v11 = v26;
          if ( v26 )
          {
            sub_46CAB0(v24, &a3[v10], v26);
            v11 = v26;
            v10 = v27;
          }
          (*(void (__stdcall **)(int, unsigned int, unsigned int, unsigned int, unsigned int))(*(_DWORD *)a1[34] + 76))(
            a1[34],
            v25,
            v10,
            v24,
            v11);
        }
        if ( *((_BYTE *)a1 + 356) )
        {
          v12 = 0;
          if ( a1[82] > 0 )
          {
            v13 = a1 + 50;
            do
            {
              if ( !*v13 )
                (**(void (__stdcall ***)(_DWORD, void *, _DWORD *))*(v13 - 16))(*(v13 - 16), &unk_4AE5C0, v13);
              if ( *v13 )
              {
                v15 = (float)a1[85];
                (*(void (__stdcall **)(_DWORD, _DWORD, int))(*(_DWORD *)*v13 + 68))(*v13, LODWORD(v15), 1);
                v16 = (float)a1[86];
                (*(void (__stdcall **)(_DWORD, _DWORD, int))(*(_DWORD *)*v13 + 64))(*v13, LODWORD(v16), 1);
              }
              ++v12;
              ++v13;
            }
            while ( v12 < a1[82] );
          }
        }
        v14 = a1[34];
        a1[84] = 8000;
        if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v14 + 32))(v14) )
          a1[84] = v23;
      }
      v28 = -1;
      sub_40C9D0((int)v18, (int)&savedregs, 0);
    }
    else
    {
      a1[82] = 0;
      v28 = -1;
      sub_40C9D0((int)v18, (int)&savedregs, 0);
    }
  }
}
// 406A60: could not find valid save-restore pair for ebx

//----- (00406D50) --------------------------------------------------------
int __thiscall sub_406D50(_DWORD *this, _DWORD *a2, _DWORD *a3, int *a4, unsigned int a5)
{
  _DWORD *v5; // ebp
  int v6; // ebx
  _BYTE *v7; // edi
  int result; // eax
  int v9; // ebx
  _BYTE *v10; // edi
  int v11; // ebp
  _BYTE *i; // esi
  _BYTE *v13; // edi
  unsigned int v14; // ebx
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // esi
  int v19; // [esp+10h] [ebp-8h]

  v5 = this;
  v19 = 0;
  while ( 1 )
  {
    v6 = *a4;
    if ( !*a4 )
      break;
    v7 = (_BYTE *)*a3;
    *a4 = 0;
    *a3 = 0;
LABEL_7:
    if ( !_memicmp(v7, aRiff, 4u) && !_memicmp(v7 + 8, aWave, 4u) )
    {
      v9 = v6 - 12;
      v10 = v7 + 12;
      v11 = 0;
      for ( i = v10; v9 >= 8; i = v10 )
      {
        v13 = v10 + 8;
        v14 = v9 - 8;
        if ( *((_DWORD *)i + 1) > 0x2000000u )
          break;
        nullsub_2("Wav chunk %4.4s\n", i);
        if ( !_memicmp(i, aFmt, 4u) )
        {
          v15 = *((_DWORD *)i + 1);
          if ( v15 <= v14 )
          {
            if ( v15 < 0x10 || *(_WORD *)v13 != 1 )
              break;
            *(_DWORD *)a5 = 0;
            *(_DWORD *)(a5 + 4) = 0;
            *(_DWORD *)(a5 + 8) = 0;
            *(_DWORD *)(a5 + 12) = 0;
            *(_WORD *)(a5 + 16) = 0;
            sub_46CAB0(a5, v13, 0x10u);
            ++v11;
          }
        }
        if ( !_memicmp(i, aData, 4u) )
        {
          v16 = *((_DWORD *)i + 1);
          if ( v16 <= v14 )
          {
            if ( ++v11 == 2 )
            {
              *a3 = v13;
              result = v19;
              *a4 = *((_DWORD *)i + 1);
              this[88] = v19;
              return result;
            }
            v17 = v16 + 3;
            LOBYTE(v17) = v17 & 0xFC;
            *((_DWORD *)i + 1) = v17;
          }
        }
        v18 = *((_DWORD *)i + 1);
        v9 = v14 - v18;
        v10 = &v13[v18];
      }
      v5 = this;
    }
    (*(void (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(v5[1] + 48) + 32))(*(_DWORD *)(v5[1] + 48), v5 + 2);
  }
  result = (int)(v5 + 2);
  if ( *((_BYTE *)v5 + 8) )
  {
    result = (*(int (__thiscall **)(_DWORD, _DWORD *, _DWORD *))(**(_DWORD **)(v5[1] + 48) + 28))(
               *(_DWORD *)(v5[1] + 48),
               a2,
               v5 + 2);
    if ( (_BYTE)result )
    {
      v7 = (_BYTE *)a2[2];
      v6 = a2[3];
      v19 = a2[5];
      goto LABEL_7;
    }
  }
  return result;
}
// 404A80: using guessed type int nullsub_2(const char *, ...);

//----- (00406EE0) --------------------------------------------------------
char *__thiscall sub_406EE0(_DWORD *this, char *Destination, int a3)
{
  const char *v3; // eax
  char *result; // eax

  v3 = (const char *)this[1];
  if ( !v3 )
    v3 = aUnknownError;
  result = strncpy(Destination, v3, a3 - 1);
  Destination[a3 - 1] = 0;
  return result;
}

//----- (00406F10) --------------------------------------------------------
_DWORD *__userpurge sub_406F10@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, const char *a3)
{
  const char *v3; // eax
  bool v5; // zf
  const char *v6; // eax

  v3 = a3;
  v5 = a3 == 0;
  a1[1] = a3;
  *a1 = &off_4A7B84;
  if ( !v5 )
  {
    v6 = *sub_40DB50(&a3, "%s", v3);
    if ( !v6 )
      v6 = (const char *)&unk_4A7DB0;
    sub_40DCC0(a2, aTxtNull, (unsigned int)aCSrcIncExceptC, (const char *)0x26, (char)v6);
    sub_40BE30((unsigned int *)&a3);
  }
  return a1;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00406FB0) --------------------------------------------------------
char *__thiscall sub_406FB0(void *this, char *Destination, int a3)
{
  char *result; // eax

  if ( dword_4C1214 )
    return (char *)dword_4C1214(this, Destination, a3);
  result = strncpy(Destination, Source, a3 - 1);
  Destination[a3 - 1] = 0;
  return result;
}
// 4C1214: using guessed type int (__fastcall *dword_4C1214)(_DWORD, _DWORD, _DWORD);

//----- (00406FF0) --------------------------------------------------------
_DWORD *__usercall sub_406FF0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>)
{
  a1[1] = 0;
  *a1 = &off_4A87AC;
  sub_40DCC0(a2, aFalse, (unsigned int)aCSrcIncExceptC, (const char *)0x38, (char)aMemoryError);
  return a1;
}
// 4A87AC: using guessed type int (__stdcall *off_4A87AC)(char);

//----- (00407050) --------------------------------------------------------
void __thiscall sub_407050(_DWORD *this)
{
  *this = &off_4A7B84;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00407060) --------------------------------------------------------
_DWORD *__thiscall sub_407060(_DWORD *this, char a2)
{
  sub_407080(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00407080) --------------------------------------------------------
void __thiscall sub_407080(_DWORD *this)
{
  *this = &off_4A7B84;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00407090) --------------------------------------------------------
void *__thiscall sub_407090(void *this, int a2, char *Source, int a4, int a5)
{
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 3) = a4;
  *((_DWORD *)this + 4) = a5;
  *(_DWORD *)this = &off_4A87CC;
  if ( Source )
  {
    strncpy((char *)this + 20, Source, 0x103u);
    *((_BYTE *)this + 279) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 0;
  }
  return this;
}
// 4A87CC: using guessed type int (__stdcall *off_4A87CC)(char);

//----- (004070F0) --------------------------------------------------------
_DWORD *__thiscall sub_4070F0(_DWORD *this, char a2)
{
  sub_407110(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00407110) --------------------------------------------------------
void __thiscall sub_407110(_DWORD *this)
{
  *this = &off_4A7B84;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (004071B0) --------------------------------------------------------
char *__thiscall sub_4071B0(int this, char *Destination, int a3)
{
  char *result; // eax
  const char *v5; // eax
  int v6; // eax
  const char *v7; // edx

  if ( dword_4C1218 )
    return (char *)dword_4C1218(this, Destination, a3);
  switch ( *(_DWORD *)(this + 8) )
  {
    case 0:
      v5 = aUnableToOpen;
      break;
    case 1:
      v5 = aUnableToCreate;
      break;
    case 2:
    case 3:
      v5 = aFileReadError;
      break;
    case 4:
      v6 = *(_DWORD *)(this + 16) & 0xFFF;
      if ( v6 == 39 || v6 == 112 || *sub_46D641() == 28 )
        v5 = aDiskFull;
      else
        v5 = aFileWriteError;
      break;
    default:
      v5 = aUnknownFileErr;
      break;
  }
  strncpy(Destination, v5, a3 - 1);
  Destination[a3 - 1] = 0;
  result = *(char **)(this + 8);
  if ( !result || result == (char *)1 )
  {
    v7 = (const char *)(this + 20);
    if ( !*(_BYTE *)(this + 20) )
      v7 = aFile;
    result = strncat(Destination, v7, a3 - (strlen(Destination) + 1));
    Destination[a3 - 1] = 0;
  }
  return result;
}
// 4C1218: using guessed type int (__fastcall *dword_4C1218)(_DWORD, _DWORD, _DWORD);

//----- (004072A0) --------------------------------------------------------
int __fastcall sub_4072A0(char *Str, int a2)
{
  char *v4; // esi
  int v5; // ebp
  char v6; // al
  char *v7; // esi
  int v8; // ecx
  int v9; // ebx
  char i; // al
  int v11; // edi
  char v12; // al
  const char *v13; // edi
  unsigned int v14; // kr08_4
  unsigned int v16; // [esp+10h] [ebp-4h]

  v16 = strlen(Str);
  v4 = strchr(Str, 37);
  if ( !v4 )
    return v16;
  v5 = a2 - 4;
  while ( 1 )
  {
    v6 = v4[1];
    v7 = v4 + 1;
    if ( v6 != 37 )
      break;
    ++v7;
LABEL_28:
    v4 = strchr(v7, 37);
    if ( !v4 )
      return v16;
  }
  if ( strchr(::Str, v6) )
  {
    do
    {
      if ( !*v7 )
        break;
      v8 = *++v7;
    }
    while ( strchr(::Str, v8) );
  }
  if ( *v7 < 48 || *v7 > 57 )
  {
    v9 = 0;
    v11 = 20;
  }
  else
  {
    v9 = sub_46D80E(v7);
    for ( i = *v7; i >= 48; i = *++v7 )
    {
      if ( i > 57 )
        break;
    }
    if ( v9 > 20 )
      v11 = v9;
    else
      v11 = 20;
  }
  if ( strchr(aDioxxuc, *v7) && *v7 )
  {
    v5 += 4;
LABEL_27:
    v16 += v11;
    goto LABEL_28;
  }
  v12 = *v7;
  if ( *v7 == 103 || v12 == 102 )
  {
    v5 += 8;
    goto LABEL_27;
  }
  if ( v12 == 115 )
  {
    v13 = *(const char **)(v5 + 4);
    v5 += 4;
    v14 = strlen(v13) + 1;
    if ( v9 < (int)(v14 - 1) )
      v11 = v14 - 1;
    else
      v11 = v9;
    goto LABEL_27;
  }
  return -1;
}

//----- (004073D0) --------------------------------------------------------
int sub_4073D0(int a1, char *Format, ...)
{
  int v2; // eax
  int v3; // ebx
  char *v4; // eax
  const char *v5; // ebp
  const char *v6; // edi
  void *v7; // eax
  unsigned int v9; // [esp+10h] [ebp-10h] BYREF
  int v10; // [esp+1Ch] [ebp-4h]
  va_list va; // [esp+2Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  *(_DWORD *)(a1 + 4) = 0;
  v10 = 1;
  *(_DWORD *)a1 = &off_4A8854;
  v2 = sub_4072A0(Format, (int)va);
  v3 = v2;
  if ( v2 < 299 )
  {
    if ( v2 >= 0 )
    {
      v6 = (const char *)(a1 + 8);
      vsprintf_0((char *const)(a1 + 8), Format, va);
LABEL_6:
      if ( v3 >= 0 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  else
  {
    v4 = (char *)sub_46D9FD(v2 + 1);
    v5 = v4;
    if ( v4 )
    {
      vsprintf_0(v4, Format, va);
      v6 = (const char *)(a1 + 8);
      strncpy((char *)(a1 + 8), v5, 0x12Bu);
      *(_BYTE *)(a1 + 307) = 0;
      sub_46D360((unsigned int)v5);
      goto LABEL_6;
    }
  }
LABEL_7:
  v6 = (const char *)(a1 + 8);
  strncpy((char *)(a1 + 8), Format, 0x12Bu);
LABEL_8:
  *(_BYTE *)(a1 + 307) = 0;
  v7 = *(void **)sub_40DB50(&v9, "%s", v6);
  LOBYTE(v10) = 2;
  if ( !v7 )
    v7 = &unk_4A7DB0;
  sub_40DCC0(aFalse, aCSrcIncExceptC, 169, v7, 0);
  LOBYTE(v10) = 1;
  sub_40BE30(&v9);
  return a1;
}
// 40DB50: using guessed type _DWORD sub_40DB50(_DWORD, const char *Format, ...);
// 40DCC0: using guessed type _DWORD __cdecl sub_40DCC0(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4A8854: using guessed type int (__stdcall *off_4A8854)(char);

//----- (00407500) --------------------------------------------------------
_DWORD *__thiscall sub_407500(_DWORD *this, char a2)
{
  sub_407520(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00407520) --------------------------------------------------------
void __thiscall sub_407520(_DWORD *this)
{
  *this = &off_4A7B84;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);

//----- (00407530) --------------------------------------------------------
char *__thiscall sub_407530(const char *this, char *Destination, int a3)
{
  char *result; // eax

  result = strncpy(Destination, this + 8, a3 - 1);
  Destination[a3 - 1] = 0;
  return result;
}

//----- (00407560) --------------------------------------------------------
char __thiscall sub_407560(void *this, char a2)
{
  char result; // al
  int v3; // eax
  char v4[512]; // [esp+8h] [ebp-200h] BYREF

  (*(void (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 4))(this, v4, 512);
  result = v4[0];
  if ( v4[0] )
  {
    sub_40DA80(aExceptionS);
    result = a2;
    if ( !a2 )
    {
      v3 = dword_4A7330(v4, aError, 65584);
      result = dword_4A72F4(v3);
    }
  }
  return result;
}
// 4A72F4: using guessed type int (__stdcall *dword_4A72F4)(_DWORD);
// 4A7330: using guessed type int (__stdcall *dword_4A7330)(_DWORD, _DWORD, _DWORD);

//----- (004075C0) --------------------------------------------------------
int __usercall sub_4075C0@<eax>(int a1@<ebx>, int a2@<esi>, int a3, int *a4, int a5, char a6, int a7, int a8, char a9, char a10)
{
  int *v10; // ebp
  int result; // eax
  int v12; // edi
  int v13; // esi
  void (__stdcall *v14)(int, char *, int, char *, _DWORD); // ebx
  bool v15; // zf
  _DWORD *v16; // eax
  unsigned int v17; // ebp
  int v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // ebp
  unsigned int v21; // esi
  unsigned int v22; // esi
  unsigned int v23; // [esp+E0h] [ebp-1Ch]
  unsigned int v24; // [esp+E4h] [ebp-18h]
  char *v25; // [esp+E8h] [ebp-14h]
  int v26; // [esp+ECh] [ebp-10h] BYREF
  int v27; // [esp+F0h] [ebp-Ch]
  char v28[8]; // [esp+F4h] [ebp-8h] BYREF

  v10 = a4;
  result = dword_4A7280(a4, 8);
  if ( !result )
  {
    result = dword_4A7284(aExceptionLog, -1073741824, 3, 0, 4, 128, 0);
    v12 = result;
    if ( result != -1 )
    {
      dword_4A7288(result, 0, 0, 2, a2, a1);
      v13 = *v10;
      v14 = (void (__stdcall *)(int, char *, int, char *, _DWORD))dword_4A728C;
      v15 = *v10 == 0;
      v27 = 16;
      if ( !v15 )
      {
        do
        {
          if ( dword_4A7280(v13, 80) )
            break;
          v15 = v27-- == 0;
          if ( v15 )
            break;
          v14(v12, aExceptionrecor, 16, &a6, 0);
          v14(v12, (char *)v13, 80, &a6, 0);
          v13 = *(_DWORD *)(v13 + 8);
        }
        while ( v13 );
      }
      if ( !dword_4A7280(v10[1], 716) )
      {
        v14(v12, aContextrecord, 16, &a6, 0);
        v14(v12, (char *)v10[1], 716, &a6, 0);
      }
      v16 = (_DWORD *)v10[1];
      if ( (*v16 & 0x10001) == 0 || (v17 = v16[49], v18 = dword_4A7290(dword_4B809C), v19 = v17 - v18, v17 == v18) )
      {
LABEL_13:
        v20 = dword_4A7290(dword_4B809C);
        v27 = 0;
        v21 = v20;
        do
        {
          v21 -= 4;
          v27 += 4;
        }
        while ( !dword_4A7280(v21, 4) && v27 < 32772 );
        v22 = v21 + 4;
        if ( v22 >= v20 )
          goto LABEL_19;
        ((void (__stdcall *)(int, char *, int, char *, _DWORD, unsigned int, unsigned int, char *, int))v14)(
          v12,
          aBottomstackdum,
          20,
          &a6,
          0,
          v23,
          v24,
          v25,
          v26);
        v26 = 0;
        v25 = &a10;
        v24 = v20 - v22;
        v23 = v22;
      }
      else
      {
        while ( dword_4A7280(v17, v19) )
        {
          v19 >>= 1;
          if ( !v19 )
            goto LABEL_13;
        }
        ((void (__stdcall *)(int, char *, int, char *, _DWORD, unsigned int, unsigned int, char *, int))v14)(
          v12,
          aStackDump_0,
          20,
          &a6,
          0,
          v23,
          v24,
          v25,
          v26);
        v26 = 0;
        v25 = &a10;
        v24 = v19;
        v23 = v17;
      }
      ((void (__stdcall *)(int))v14)(v12);
LABEL_19:
      dword_4A7294(v28, v23, v24, v25);
      ((void (__cdecl *)(int, char *, int, char *, _DWORD, int))v14)(v12, aGetlocaltime, 16, &a9, 0, v26);
      v14(v12, (char *)&v26, 16, (char *)&a4, 0);
      return dword_4A729C(v12);
    }
  }
  return result;
}
// 407727: variable 'v23' is possibly undefined
// 407727: variable 'v24' is possibly undefined
// 407727: variable 'v25' is possibly undefined
// 4A7280: using guessed type int (__stdcall *dword_4A7280)(_DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int dword_4A728C;
// 4A7290: using guessed type int (__stdcall *dword_4A7290)(_DWORD);
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4B809C: using guessed type int dword_4B809C;

//----- (00407790) --------------------------------------------------------
int __thiscall sub_407790(int *this)
{
  int *v2; // [esp+0h] [ebp-4h] BYREF

  v2 = this;
  if ( dword_4B809C == -1 )
    dword_4B809C = dword_4A7278(v2);
  v2 = (int *)&v2;
  dword_4A727C(dword_4B809C, &v2);
  return sub_46DB69((int)sub_4075C0);
}
// 4A7278: using guessed type int (__cdecl *dword_4A7278)(_DWORD);
// 4A727C: using guessed type int (__stdcall *dword_4A727C)(_DWORD, _DWORD);

//----- (004077D0) --------------------------------------------------------
int __thiscall sub_4077D0(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
    result = dword_4A7274(*this);
  *this = -1;
  return result;
}
// 4A7274: using guessed type int (__stdcall *dword_4A7274)(_DWORD);

//----- (004077F0) --------------------------------------------------------
bool __thiscall sub_4077F0(int *this, int a2)
{
  int v3; // eax

  v3 = dword_4A7270(a2, this + 1);
  *this = v3;
  return v3 != -1;
}
// 4A7270: using guessed type int (__stdcall *dword_4A7270)(_DWORD, _DWORD);

//----- (00407820) --------------------------------------------------------
char __thiscall sub_407820(_DWORD *this)
{
  if ( dword_4A726C(*this, this + 1) )
    return 1;
  if ( *this != -1 )
    dword_4A7274(*this);
  *this = -1;
  return 0;
}
// 4A726C: using guessed type int (__stdcall *dword_4A726C)(_DWORD, _DWORD);
// 4A7274: using guessed type int (__stdcall *dword_4A7274)(_DWORD);

//----- (00407850) --------------------------------------------------------
int __thiscall sub_407850(char *this)
{
  __int64 v1; // kr00_8
  __int64 v2; // rax
  __int64 v4; // [esp+8h] [ebp-8h] BYREF

  dword_4A7268(this + 24, &v4);
  v1 = v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      LODWORD(v2) = -1;
  }
  else
  {
    LODWORD(v2) = 0;
  }
  return v2;
}
// 4A7268: using guessed type int (__stdcall *dword_4A7268)(_DWORD, _DWORD);

//----- (004078F0) --------------------------------------------------------
char *__thiscall sub_4078F0(char *this)
{
  return this + 48;
}

//----- (00407900) --------------------------------------------------------
int __thiscall sub_407900(_DWORD *this)
{
  return this[1];
}

//----- (00407910) --------------------------------------------------------
int __thiscall sub_407910(_DWORD *this)
{
  return this[9];
}

//----- (00407960) --------------------------------------------------------
unsigned int __thiscall sub_407960(_BYTE *this, int a2, _BYTE *a3)
{
  _BYTE *v3; // esi
  unsigned int result; // eax
  _BYTE *v5; // edx
  int v6; // edi
  char v7; // cl
  char v8; // cl
  bool v10; // zf

  v3 = this;
  result = 0;
  v5 = this;
  v6 = a2 - (_DWORD)this;
  do
  {
    v7 = v5[v6];
    *v5 = v7;
    if ( !v7 )
      break;
    ++result;
    ++v5;
  }
  while ( result < 0x104 );
  if ( result < 0x103 )
  {
    if ( result )
    {
      v8 = v3[result - 1];
      if ( v8 != 92 && v8 != 47 )
        v3[result++] = 92;
    }
  }
  for ( ; result < 0x104; ++a3 )
  {
    v10 = *a3 == 0;
    v3[result] = *a3;
    if ( v10 )
      break;
    ++result;
  }
  v3[259] = 0;
  return result;
}

//----- (004079D0) --------------------------------------------------------
_BYTE *__thiscall sub_4079D0(_BYTE *this, int a2)
{
  unsigned int v2; // edi
  _BYTE *result; // eax
  char v4; // dl

  v2 = 0;
  result = this;
  do
  {
    v4 = result[a2 - (_DWORD)this];
    *result = v4;
    if ( !v4 )
      break;
    ++v2;
    ++result;
  }
  while ( v2 < 0x104 );
  this[259] = 0;
  return result;
}

//----- (00407A40) --------------------------------------------------------
_BYTE *__thiscall sub_407A40(_BYTE *this)
{
  _BYTE *result; // eax
  _BYTE *v2; // esi
  char v3; // bl
  _BYTE *v4; // edx

  result = this;
  v2 = 0;
  v3 = *this;
  if ( *this )
  {
    v4 = this;
    do
    {
      if ( v3 == 92 || *v4 == 47 )
        v2 = v4;
      v3 = *++v4;
    }
    while ( v3 );
    if ( v2 )
      result = v2 + 1;
  }
  return result;
}

//----- (00407A70) --------------------------------------------------------
void __thiscall sub_407A70(_BYTE *this)
{
  char v1; // dl
  _BYTE *v2; // esi
  _BYTE *v3; // eax

  v1 = *this;
  v2 = 0;
  if ( !*this )
    goto LABEL_9;
  v3 = this;
  do
  {
    if ( v1 == 92 || *v3 == 47 )
      v2 = v3;
    v1 = *++v3;
  }
  while ( v1 );
  if ( v2 )
    *v2 = 0;
  else
LABEL_9:
    *this = 0;
}

//----- (00407AA0) --------------------------------------------------------
unsigned int __thiscall sub_407AA0(char *this, char *a2)
{
  char v2; // dl
  unsigned int result; // eax
  unsigned int v4; // esi
  char *v5; // esi
  bool v6; // zf

  v2 = *this;
  result = -1;
  v4 = 0;
  if ( !*this )
    goto LABEL_9;
  do
  {
    if ( v2 == 92 || v2 == 47 )
    {
      result = -1;
    }
    else if ( v2 == 46 )
    {
      result = v4;
    }
    v2 = this[++v4];
  }
  while ( v2 );
  if ( result == -1 )
LABEL_9:
    result = v4;
  v5 = a2;
  this[result] = 0;
  if ( a2 && *a2 )
  {
    if ( result < 0x103 )
      this[result++] = 46;
    if ( *a2 == 46 )
      v5 = a2 + 1;
    for ( ; result < 0x104; ++v5 )
    {
      v6 = *v5 == 0;
      this[result] = *v5;
      if ( v6 )
        break;
      ++result;
    }
    this[259] = 0;
  }
  return result;
}

//----- (00407B20) --------------------------------------------------------
int __thiscall sub_407B20(char *this)
{
  char v1; // al
  int v2; // esi
  int v3; // edx
  int result; // eax

  v1 = *this;
  v2 = -1;
  v3 = 0;
  if ( !*this )
    goto LABEL_9;
  do
  {
    if ( v1 == 92 || v1 == 47 )
    {
      v2 = -1;
    }
    else if ( v1 == 46 )
    {
      v2 = v3;
    }
    v1 = this[++v3];
  }
  while ( v1 );
  if ( v2 != -1 )
    result = (int)&this[v2 + 1];
  else
LABEL_9:
    result = (int)&this[v3];
  return result;
}

//----- (00407B80) --------------------------------------------------------
int __fastcall sub_407B80(char *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // bl
  int result; // eax

  v2 = *a2;
  for ( result = *a1 - *a2; !result; result = *a1 - v2 )
  {
    if ( !v2 )
      break;
    v2 = a2[1];
    ++a1;
    ++a2;
  }
  return result;
}

//----- (00407E80) --------------------------------------------------------
int __userpurge sub_407E80@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5)
{
  int result; // eax
  int v7; // eax
  char pExceptionObject[280]; // [esp+20h] [ebp-118h] BYREF

  if ( *a1 != -1 && !sub_40DCC0(a2, aHandleHandle1, (unsigned int)aCSrcIncWinFile, (const char *)0x38, 0) && *a1 != -1 )
  {
    dword_4A729C(*a1);
    *a1 = -1;
  }
  result = dword_4A7284(a3, 0x80000000, a4, 0, a5, 128, 0);
  *a1 = result;
  if ( result == -1 )
  {
    v7 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(pExceptionObject, 0, a3, 0, v7);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00407F30) --------------------------------------------------------
_DWORD *__thiscall sub_407F30(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = this;
  v3 = a2[1];
  *this = &off_4A7B84;
  this[1] = v3;
  this[2] = a2[2];
  this[3] = a2[3];
  this[4] = a2[4];
  qmemcpy(this + 5, a2 + 5, 0x104u);
  *this = &off_4A87CC;
  return result;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);
// 4A87CC: using guessed type int (__stdcall *off_4A87CC)(char);

//----- (00407F70) --------------------------------------------------------
int __userpurge sub_407F70@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5)
{
  int result; // eax
  int v7; // eax
  char v8[4]; // [esp+20h] [ebp-118h] BYREF

  if ( *a1 != -1 && !sub_40DCC0(a2, aHandleHandle1, (unsigned int)aCSrcIncWinFile, (const char *)0x40, 0) && *a1 != -1 )
  {
    dword_4A729C(*a1);
    *a1 = -1;
  }
  result = dword_4A7284(a3, 0x40000000, a4, 0, a5, 128, 0);
  *a1 = result;
  if ( result == -1 )
  {
    v7 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(v8, 0, a3, 0, v7);
    _CxxThrowException(v8, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00408020) --------------------------------------------------------
int __userpurge sub_408020@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5)
{
  int result; // eax
  int v7; // eax
  char pExceptionObject[280]; // [esp+20h] [ebp-118h] BYREF

  if ( *a1 != -1 && !sub_40DCC0(a2, aHandleHandle1, (unsigned int)aCSrcIncWinFile, (const char *)0x48, 0) && *a1 != -1 )
  {
    dword_4A729C(*a1);
    *a1 = -1;
  }
  result = dword_4A7284(a3, -1073741824, a4, 0, a5, 128, 0);
  *a1 = result;
  if ( result == -1 )
  {
    v7 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(pExceptionObject, 0, a3, 0, v7);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (004080D0) --------------------------------------------------------
int __userpurge sub_4080D0@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5)
{
  int result; // eax
  int v7; // eax
  char pExceptionObject[280]; // [esp+20h] [ebp-118h] BYREF

  if ( *a1 != -1 && !sub_40DCC0(a2, aHandleHandle1, (unsigned int)aCSrcIncWinFile, (const char *)0x51, 0) && *a1 != -1 )
  {
    dword_4A729C(*a1);
    *a1 = -1;
  }
  result = dword_4A7284(a3, -1073741824, a4, 0, a5, 128, 0);
  *a1 = result;
  if ( result == -1 )
  {
    v7 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(pExceptionObject, 1, a3, 0, v7);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00408180) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_408180(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp+8h] [ebp-120h]
  int v5; // [esp+Ch] [ebp-11Ch]
  _DWORD pExceptionObject[70]; // [esp+10h] [ebp-118h] BYREF

  result = dword_4A7288(*this, pExceptionObject[69], 0, 0, v4, v5);
  if ( result == -1 )
  {
    v3 = dword_4A7260(pExceptionObject[0], pExceptionObject[1], pExceptionObject[2], pExceptionObject[3]);
    sub_407090(pExceptionObject, 5, 0, 0, v3);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4081C8: positive sp value 8 has been found
// 408192: variable 'v4' is possibly undefined
// 408192: variable 'v5' is possibly undefined
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004081D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_4081D0(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp+8h] [ebp-120h]
  int v5; // [esp+Ch] [ebp-11Ch]
  _DWORD pExceptionObject[70]; // [esp+10h] [ebp-118h] BYREF

  result = dword_4A7288(*this, pExceptionObject[69], 0, 1, v4, v5);
  if ( result == -1 )
  {
    v3 = dword_4A7260(pExceptionObject[0], pExceptionObject[1], pExceptionObject[2], pExceptionObject[3]);
    sub_407090(pExceptionObject, 5, 0, 0, v3);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 408218: positive sp value 8 has been found
// 4081E2: variable 'v4' is possibly undefined
// 4081E2: variable 'v5' is possibly undefined
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00408220) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_408220(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp+8h] [ebp-120h]
  int v5; // [esp+Ch] [ebp-11Ch]
  _DWORD pExceptionObject[70]; // [esp+10h] [ebp-118h] BYREF

  result = dword_4A7288(*this, pExceptionObject[69], 0, 2, v4, v5);
  if ( result == -1 )
  {
    v3 = dword_4A7260(pExceptionObject[0], pExceptionObject[1], pExceptionObject[2], pExceptionObject[3]);
    sub_407090(pExceptionObject, 5, 0, 0, v3);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 408268: positive sp value 8 has been found
// 408232: variable 'v4' is possibly undefined
// 408232: variable 'v5' is possibly undefined
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00408270) --------------------------------------------------------
int __thiscall sub_408270(_DWORD *this)
{
  int result; // eax
  int v2; // eax
  _DWORD pExceptionObject[70]; // [esp+8h] [ebp-118h] BYREF

  result = dword_4A725C(*this, 0);
  if ( result == -1 )
  {
    v2 = dword_4A7260(pExceptionObject[0], pExceptionObject[1], pExceptionObject[2], pExceptionObject[3]);
    sub_407090(pExceptionObject, 5, 0, 0, v2);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A725C: using guessed type int (__stdcall *dword_4A725C)(_DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004084E0) --------------------------------------------------------
int __thiscall ReadScrty1FileOffset(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+14h] [ebp-11Ch] BYREF
  char pExceptionObject[268]; // [esp+18h] [ebp-118h] BYREF

  result = dword_4A7258(*this, a2, a3, &v6, 0);
  if ( !result )
  {
    v4 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(pExceptionObject, 2, 0, 0, v4);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  if ( v6 != a3 )
  {
    v5 = ((int (__cdecl *)())dword_4A7260)();
    sub_407090(pExceptionObject, 3, 0, 0, v5);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7258: using guessed type int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00408570) --------------------------------------------------------
int __thiscall sub_408570(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v5; // [esp+14h] [ebp-11Ch] BYREF
  _DWORD pExceptionObject[70]; // [esp+18h] [ebp-118h] BYREF

  if ( dword_4A7258(*this, a2, a3, &v5, 0) )
    return v5;
  v3 = dword_4A7260(v5, pExceptionObject[0], pExceptionObject[1], pExceptionObject[2]);
  if ( v3 != 38 )
  {
    sub_407090(pExceptionObject, 2, 0, 0, v3);
    _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
  }
  return 0;
}
// 4A7258: using guessed type int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004085E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __thiscall sub_4085E0(_DWORD *this, char *Str, int a3)
{
  const char *v4; // edi
  int v5; // eax
  int v6; // ebp
  char *v8; // esi
  char *v9; // eax
  int v10; // eax
  int v11; // [esp+8h] [ebp-134h]
  int v12; // [esp+Ch] [ebp-130h]
  int v13; // [esp+18h] [ebp-124h] BYREF
  int v14; // [esp+1Ch] [ebp-120h] BYREF
  char pExceptionObject[8]; // [esp+24h] [ebp-118h] BYREF
  const char *v16; // [esp+138h] [ebp-4h]
  char *retaddr; // [esp+13Ch] [ebp+0h]

  v4 = v16;
  if ( !dword_4A7258(*this, v16, retaddr - 2, &v13, 0) )
  {
    v5 = ((int (__cdecl *)())dword_4A7260)();
    if ( v5 != 38 )
    {
      sub_407090(&v14, 2, 0, 0, v5);
      _CxxThrowException(&v14, &_TI2_AVfile_exception__);
    }
    return 0;
  }
  v6 = v13;
  if ( !v13 )
    return 0;
  v4[v13] = 0;
  v8 = strchr(v4, 13);
  v9 = strchr(v4, 10);
  if ( (v9 >= v8 || !v9) && v8 || (v8 = v9) != 0 )
  {
    *v8 = 0;
    if ( dword_4A7288(*this, &v8[(v9 == v8 + 1) - v6 - (_DWORD)v4 + 1], 0, 1, v11, v12) == -1 )
    {
      v10 = ((int (__cdecl *)())dword_4A7260)();
      sub_407090(pExceptionObject, 5, 0, 0, v10);
      _CxxThrowException(pExceptionObject, &_TI2_AVfile_exception__);
    }
  }
  return 1;
}
// 4086DA: positive sp value 8 has been found
// 40869E: variable 'v11' is possibly undefined
// 40869E: variable 'v12' is possibly undefined
// 4A7258: using guessed type int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004086E0) --------------------------------------------------------
int __thiscall sub_4086E0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  char *v5; // [esp+8h] [ebp-128h] BYREF
  int v6; // [esp+Ch] [ebp-124h]
  char v7; // [esp+14h] [ebp-11Ch] BYREF

  v6 = 0;
  v5 = &v7;
  result = dword_4A728C(*this);
  if ( !result )
  {
    v4 = dword_4A7260(a2, a3, v5, v6);
    sub_407090(&v5, 4, 0, 0, v4);
    _CxxThrowException(&v5, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int (__stdcall *dword_4A728C)(_DWORD);

//----- (00408740) --------------------------------------------------------
int __thiscall sub_408740(_DWORD *this, const char *a2)
{
  unsigned int v3; // kr04_4
  int result; // eax
  int v5; // eax
  char v6[12]; // [esp+8h] [ebp-128h] BYREF
  char v7[4]; // [esp+14h] [ebp-11Ch] BYREF

  v3 = strlen(a2) + 1;
  result = dword_4A728C(*this);
  if ( !result || v3 != 1 )
  {
    v5 = dword_4A7260(a2, v3 - 1, v7, 0);
    sub_407090(v6, 4, 0, 0, v5);
    _CxxThrowException(v6, &_TI2_AVfile_exception__);
  }
  return result;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int (__stdcall *dword_4A728C)(_DWORD);

//----- (004087F0) --------------------------------------------------------
int __thiscall sub_4087F0(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
  {
    result = dword_4A729C(*this);
    *this = -1;
  }
  return result;
}
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00408820) --------------------------------------------------------
BOOL __thiscall sub_408820(void *this)
{
  return dword_4A7158(this) != 0;
}
// 4A7158: using guessed type int (__stdcall *dword_4A7158)(_DWORD);

//----- (00408840) --------------------------------------------------------
BOOL __thiscall sub_408840(char *Source)
{
  char *i; // eax
  char *v2; // eax
  char *v3; // eax
  void (__stdcall *v4)(char *, _DWORD); // edi
  char *j; // esi
  char Destination[260]; // [esp+8h] [ebp-104h] BYREF

  strncpy(Destination, Source, 0x103u);
  Destination[259] = 0;
  for ( i = strchr(Destination, 47); i; i = strchr(i, 47) )
    *i = 92;
  v2 = strchr(Destination, 0);
  if ( v2 - Destination > 0 && *(v2 - 1) == 92 )
    *(v2 - 1) = 0;
  v3 = strchr(Destination, 92);
  v4 = (void (__stdcall *)(char *, _DWORD))dword_4A7244;
  for ( j = v3; j; j = strchr(j + 1, 92) )
  {
    *j = 0;
    v4(Destination, 0);
    *j = 92;
  }
  return ((int (__stdcall *)(char *, _DWORD))v4)(Destination, 0) != 0;
}
// 4A7244: using guessed type int dword_4A7244;

//----- (00408AA0) --------------------------------------------------------
bool __thiscall sub_408AA0(void *this)
{
  int v1; // eax
  bool v2; // bl
  _DWORD v4[100]; // [esp+Ch] [ebp-190h] BYREF

  v1 = dword_4A7270(this, v4);
  v2 = v1 != -1;
  if ( v1 != -1 )
    dword_4A7274(v1);
  return v2;
}
// 4A7270: using guessed type int (__stdcall *dword_4A7270)(_DWORD, _DWORD);
// 4A7274: using guessed type int (__stdcall *dword_4A7274)(_DWORD);

//----- (00408AE0) --------------------------------------------------------
int __thiscall sub_408AE0(void *this)
{
  __int64 v1; // kr00_8
  int v2; // esi
  __int64 v4; // [esp+10h] [ebp-19Ch] BYREF
  int v5; // [esp+18h] [ebp-194h]
  _DWORD v6[5]; // [esp+1Ch] [ebp-190h] BYREF
  _DWORD v7[95]; // [esp+30h] [ebp-17Ch] BYREF

  v5 = dword_4A7270(this, v6);
  if ( v5 == -1 )
    return 0;
  dword_4A7268(v7, &v4);
  v1 = v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      v2 = -1;
  }
  else
  {
    v2 = 0;
  }
  if ( v5 != -1 )
    dword_4A7274(v5);
  return v2;
}
// 4A7268: using guessed type int (__stdcall *dword_4A7268)(_DWORD, _DWORD);
// 4A7270: using guessed type int (__stdcall *dword_4A7270)(_DWORD, _DWORD);
// 4A7274: using guessed type int (__stdcall *dword_4A7274)(_DWORD);

//----- (00408BE0) --------------------------------------------------------
int __usercall sub_408BE0@<eax>(int *a1@<ebp>, _DWORD *a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  int result; // eax
  void (__stdcall *v5)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD *, int); // ebx
  int (__cdecl *v6)(int, _DWORD, int); // ebp
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  _DWORD v15[6]; // [esp+28h] [ebp-28h] BYREF
  int v16; // [esp+40h] [ebp-10h]
  int v17; // [esp+44h] [ebp-Ch]

  v3 = dword_4A7224(1);
  dword_4A7228(v3);
  result = dword_4A722C(dword_4C1828, -1);
  if ( !result )
  {
    v5 = (void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD *, int))dword_4A7288;
    v6 = (int (__cdecl *)(int, _DWORD, int))dword_4A728C;
    do
    {
      while ( dword_4C1820 != dword_4C1824 )
      {
        qmemcpy(v15, (const void *)(24 * dword_4C1820 + 4985376), sizeof(v15));
        v7 = v15[1];
        v5(v15[1], v15[2], 0, 0, a2, a3);
        if ( v17 == 1 )
        {
          v8 = v16;
          a3 = 0;
          a2 = &v15[1];
          if ( !v6(v7, v15[5], v16) || v8 )
          {
            v9 = 8 * dword_4A7260();
            LOBYTE(v9) = v9 | 4;
            *a1 = v9;
          }
          else
          {
            *a1 = 0;
          }
        }
        else if ( v17 )
        {
          *(_DWORD *)v15[2] = 5;
        }
        else
        {
          v10 = v16;
          if ( dword_4A7258(v7, v15[5], v16, &v15[1], 0) )
          {
            *(_DWORD *)v15[2] = v10 != v15[1] ? 3 : 0;
          }
          else
          {
            v11 = 8 * dword_4A7260();
            LOBYTE(v11) = v11 | 2;
            *(_DWORD *)v15[2] = v11;
          }
        }
        if ( dword_4C1820 != dword_4C1824 )
          dword_4C1820 = (dword_4C1820 + 1) % 64;
      }
      result = dword_4A722C(dword_4C1828, -1);
    }
    while ( !result );
  }
  return result;
}
// 408BE0: could not find valid save-restore pair for ebx
// 408BE0: could not find valid save-restore pair for ebp
// 408BE0: could not find valid save-restore pair for edi
// 408BE0: could not find valid save-restore pair for esi
// 408C53: variable 'a2' is possibly undefined
// 408C53: variable 'a3' is possibly undefined
// 4A7224: using guessed type int (__cdecl *dword_4A7224)(_DWORD);
// 4A7228: using guessed type int (__cdecl *dword_4A7228)(_DWORD);
// 4A722C: using guessed type int (__cdecl *dword_4A722C)(_DWORD, _DWORD);
// 4A7258: using guessed type int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (*dword_4A7260)(void);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int dword_4A728C;
// 4C1820: using guessed type int dword_4C1820;
// 4C1824: using guessed type int dword_4C1824;
// 4C1828: using guessed type int dword_4C1828;

//----- (00409050) --------------------------------------------------------
int *__userpurge sub_409050@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3)
{
  a1[4] = 0;
  a1[5] = 0;
  a1[1] = 0;
  *a1 = 0;
  a1[2] = 0;
  sub_409CD0(a1, a2, a3, 0, 0, 0);
  return a1;
}

//----- (004090C0) --------------------------------------------------------
void __thiscall sub_4090C0(_DWORD *this)
{
  if ( this[4] )
    sub_40B7E0(this[4]);
  if ( this[5] )
    sub_40B7E0(this[5]);
  this[4] = 0;
  this[5] = 0;
  this[1] = 0;
  *this = 0;
  this[2] = 0;
}

//----- (00409160) --------------------------------------------------------
__int16 __thiscall sub_409160(unsigned int *this, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v6; // edi
  unsigned int v7; // eax
  _DWORD *v8; // eax
  int v10; // [esp+0h] [ebp-28h] BYREF
  int pExceptionObject[7]; // [esp+Ch] [ebp-1Ch] BYREF
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v6 = 0;
  pExceptionObject[3] = (int)&v10;
  v7 = this[4];
  pExceptionObject[2] = (int)this;
  pExceptionObject[6] = 0;
  if ( v7 )
    sub_40B7E0(v7);
  if ( this[5] )
    sub_40B7E0(this[5]);
  this[4] = 0;
  this[5] = 0;
  this[1] = 0;
  *this = 0;
  this[2] = 0;
  if ( a4 == 4 )
  {
    sub_406F10(pExceptionObject, (int)&savedregs, aImageCreateNot);
    _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
  }
  this[2] = a4;
  *this = a2;
  this[1] = a3;
  v8 = (_DWORD *)sub_40B720((int)&savedregs, a3 * a2 * ((int)(a4 + 7) >> 3));
  this[4] = (unsigned int)v8;
  while ( v6 < (int)this[1] )
    LOWORD(v8) = sub_4093E0(this, (int)&savedregs, 0, v6++, *this, a5);
  if ( this[2] == 8 )
  {
    v8 = (_DWORD *)sub_40B720((int)&savedregs, 0x400u);
    this[5] = (unsigned int)v8;
    *v8 = 0;
    *(_DWORD *)this[5] = 0xFFFFFF;
  }
  return (__int16)v8;
}

//----- (004093E0) --------------------------------------------------------
__int16 __userpurge sub_4093E0@<ax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4, unsigned int a5, int a6)
{
  int v6; // edx
  int v7; // eax
  int v8; // edi
  int v9; // ebx
  char *v10; // edi
  _WORD *v11; // eax
  char *v12; // edi
  int v13; // edx
  char *v14; // edi
  int i; // ecx
  unsigned int v16; // ecx
  _BYTE *v17; // eax
  void *v18; // edi
  _DWORD pExceptionObject[2]; // [esp+0h] [ebp-13Ch] BYREF
  char v21[308]; // [esp+8h] [ebp-134h] BYREF

  v6 = a1[2];
  if ( v6 == 4 )
    v7 = (*a1 + 1) >> 1;
  else
    v7 = *a1 * ((v6 + 7) >> 3);
  v8 = a1[4] + a4 * v7;
  switch ( v6 )
  {
    case 4:
      sub_406F10(pExceptionObject, a2, aImageFillNotIm);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    case 8:
      HIWORD(v9) = HIWORD(a3);
      v10 = (char *)(a3 + v8);
      LOWORD(v11) = a5 - 1;
      if ( a5 )
      {
        LOBYTE(v9) = a6;
        BYTE1(v9) = a6;
        v11 = (_WORD *)(v9 << 16);
        LOWORD(v11) = v9;
        memset32(v10, (int)v11, a5 >> 2);
        memset(&v10[4 * (a5 >> 2)], a6, a5 & 3);
      }
      break;
    case 15:
    case 16:
      v12 = (char *)(v8 + 2 * a3);
      LOWORD(v11) = a5 - 1;
      if ( a5 )
      {
        LOWORD(v6) = a6;
        v13 = v6 << 16;
        LOWORD(v13) = a6;
        LOWORD(v11) = a6;
        memset32(v12, v13, a5 >> 1);
        v14 = &v12[4 * (a5 >> 1)];
        for ( i = a5 & 1; i; --i )
        {
          *(_WORD *)v14 = a6;
          v14 += 2;
        }
      }
      break;
    case 24:
      v11 = (_WORD *)(a3 + v8 + 2 * a3);
      if ( a5 )
      {
        v16 = a5;
        do
        {
          *v11 = a6;
          v17 = v11 + 1;
          *v17 = BYTE2(a6);
          v11 = v17 + 1;
          --v16;
        }
        while ( v16 );
      }
      break;
    case 32:
      v18 = (void *)(v8 + 4 * a3);
      LOWORD(v11) = a5 - 1;
      if ( a5 )
      {
        LOWORD(v11) = a6;
        memset32(v18, a6, a5);
      }
      break;
    default:
      sub_4073D0((int)v21, "IMAGE::Create: unsupported bit depth %d", v6);
      _CxxThrowException(v21, &_TI2_AVtext_exception__);
  }
  return (__int16)v11;
}

//----- (004095B0) --------------------------------------------------------
_DWORD *__thiscall sub_4095B0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[1] = *(_DWORD *)(a2 + 4);
  *this = &off_4A7B84;
  qmemcpy(this + 2, (const void *)(a2 + 8), 0x12Cu);
  *this = &off_4A8854;
  return result;
}
// 4A7B84: using guessed type void *(__thiscall *off_4A7B84)(std::locale::facet *__hidden this, unsigned int);
// 4A8854: using guessed type int (__stdcall *off_4A8854)(char);

//----- (004095E0) --------------------------------------------------------
int __thiscall sub_4095E0(int *this, unsigned int a2, int a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int result; // eax
  int v8; // edx
  unsigned int v9; // ebp
  int v10; // esi
  int v12; // edx
  unsigned int v13; // esi
  int v15; // edx
  int v16; // ecx
  unsigned int v17; // esi
  __int16 *v18; // edx
  int v19; // ecx
  __int16 v20; // ax
  int v21; // edi
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // esi
  __int16 *v25; // edx
  int v26; // ecx
  __int16 v27; // ax
  int v28; // edi
  int v29; // edx
  int v30; // ecx
  int *v31; // esi
  int v32; // ecx

  v4 = this[2];
  v5 = *this;
  if ( v4 == 4 )
    v6 = (v5 + 1) >> 1;
  else
    v6 = v5 * ((v4 + 7) >> 3);
  result = this[4] + a3 * v6;
  switch ( v4 )
  {
    case 4:
      v8 = v5 - 1;
      if ( v5 )
      {
        v9 = a2 + 4 * v8;
        do
        {
          if ( (v8 & 1) != 0 )
            v10 = *(unsigned __int8 *)((v8 >> 1) + result) >> 4;
          else
            v10 = *(_BYTE *)((v8 >> 1) + result) & 0xF;
          v9 -= 4;
          *(_DWORD *)(v9 + 4) = *(_DWORD *)(this[5] + 4 * v10);
        }
        while ( v8-- );
      }
      break;
    case 8:
      v12 = v5 - 1;
      if ( v5 )
      {
        v13 = a2 + 4 * v12;
        do
        {
          v13 -= 4;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(this[5] + 4 * *(unsigned __int8 *)(v12 + result));
        }
        while ( v12-- );
      }
      break;
    case 15:
      v15 = v5;
      v16 = v5 - 1;
      if ( v15 )
      {
        v17 = a2 + 4 * v16;
        v18 = (__int16 *)(result + 2 * v16);
        v19 = v16 + 1;
        do
        {
          v17 -= 4;
          v20 = *v18--;
          v21 = v20 & 0x3E0 | (8 * (v20 & 0x7C00));
          result = v20 & 0x1F;
          *(_DWORD *)(v17 + 4) = 8 * (result | (8 * v21));
          --v19;
        }
        while ( v19 );
      }
      break;
    case 16:
      v22 = v5;
      v23 = v5 - 1;
      if ( v22 )
      {
        v24 = a2 + 4 * v23;
        v25 = (__int16 *)(result + 2 * v23);
        v26 = v23 + 1;
        do
        {
          v24 -= 4;
          v27 = *v25--;
          v28 = v27 & 0x7E0 | (8 * (v27 & 0xF800));
          result = v27 & 0x1F;
          *(_DWORD *)(v24 + 4) = 8 * (result | (4 * v28));
          --v26;
        }
        while ( v26 );
      }
      break;
    case 24:
      v29 = v5;
      v30 = v5 - 1;
      if ( v29 )
      {
        v31 = (int *)(a2 + 4 * v30);
        result += 2 * v30 + v30;
        v32 = v30 + 1;
        do
        {
          --v32;
          *v31 = *(unsigned __int16 *)result | (*(unsigned __int8 *)(result + 2) << 16);
          result -= 3;
          --v31;
        }
        while ( v32 );
      }
      break;
    case 32:
      result = sub_46CAB0(a2, (_BYTE *)result, 4 * v5);
      break;
    default:
      return result;
  }
  return result;
}

//----- (004097D0) --------------------------------------------------------
int __userpurge sub_4097D0@<eax>(int *a1@<ecx>, int a2@<ebp>, unsigned int a3, _BYTE *a4, int a5, int a6)
{
  int v6; // ecx
  int result; // eax
  _WORD *v8; // esi
  unsigned int *v9; // edx
  unsigned int v10; // eax
  int v11; // edi
  __int16 v12; // bx
  _WORD *v13; // esi
  unsigned int *v14; // edx
  int v15; // ecx
  unsigned int v16; // eax
  int v17; // edi
  __int16 v18; // bx
  int v19; // edx
  int v20; // esi
  _BYTE *v21; // ecx
  __int16 v22; // dx
  _DWORD pExceptionObject[2]; // [esp+Ch] [ebp-13Ch] BYREF
  char v24[308]; // [esp+14h] [ebp-134h] BYREF

  switch ( a5 )
  {
    case 4:
    case 8:
      sub_406F10(pExceptionObject, a2, aImageConvert32);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    case 15:
      v6 = *a1;
      result = v6 - 1;
      if ( v6 )
      {
        v8 = (_WORD *)(a3 + 2 * result);
        v9 = (unsigned int *)&a4[4 * result];
        do
        {
          v10 = *v9--;
          v11 = (v10 >> 6) & 0x3E0;
          v12 = (unsigned __int8)v10 >> 3;
          result = (v10 >> 9) & 0x7C00;
          --v6;
          *v8-- = result | v12 | v11;
        }
        while ( v6 );
      }
      break;
    case 16:
      result = *a1 - 1;
      if ( *a1 )
      {
        v13 = (_WORD *)(a3 + 2 * result);
        v14 = (unsigned int *)&a4[4 * result];
        v15 = *a1;
        do
        {
          v16 = *v14--;
          v17 = (v16 >> 5) & 0x7E0;
          v18 = (unsigned __int8)v16 >> 3;
          result = (v16 >> 8) & 0xF800;
          --v15;
          *v13-- = result | v18 | v17;
        }
        while ( v15 );
      }
      break;
    case 24:
      result = *a1;
      v19 = *a1 - 1;
      if ( *a1 )
      {
        v20 = *a1;
        result = a3 + 2 * v19 + v19;
        v21 = &a4[4 * v19];
        do
        {
          v22 = *(_WORD *)v21;
          v21 -= 4;
          *(_WORD *)result = v22;
          *(_BYTE *)(result + 2) = BYTE2(*((_DWORD *)v21 + 1));
          --v20;
          result -= 3;
        }
        while ( v20 );
      }
      break;
    case 32:
      result = sub_46CAB0(a3, a4, 4 * *a1);
      break;
    default:
      sub_4073D0((int)v24, "IMAGE::Convert32BitToX: Unsupported bit depth %d", a5);
      _CxxThrowException(v24, &_TI2_AVtext_exception__);
  }
  return result;
}

//----- (004099A0) --------------------------------------------------------
int __thiscall sub_4099A0(int this, int a2)
{
  int result; // eax
  void **v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // ebx
  int v8; // eax
  _BYTE *v9; // edi
  int i; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  _DWORD v14[4]; // [esp+0h] [ebp-2Ch] BYREF
  char v15[4]; // [esp+10h] [ebp-1Ch] BYREF
  int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  _DWORD *v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v18 = v14;
  result = *(_DWORD *)(this + 16);
  v4 = (void **)(this + 16);
  if ( result )
  {
    result = *(_DWORD *)(this + 8);
    if ( result != a2 )
    {
      v5 = *(_DWORD *)this;
      if ( result == 4 )
        v6 = (v5 + 1) >> 1;
      else
        v6 = v5 * ((result + 7) >> 3);
      v17 = v6;
      if ( a2 == 4 )
        v7 = (v5 + 1) >> 1;
      else
        v7 = v5 * ((a2 + 7) >> 3);
      if ( v6 < v7 )
        sub_40B780(v7 * *(_DWORD *)(this + 4) + 1, v4, (int)&savedregs);
      v8 = *(_DWORD *)this;
      v16 = 0;
      v14[3] = 0;
      v19 = 0;
      v9 = (_BYTE *)sub_40B720((int)&savedregs, 4 * v8);
      if ( v17 >= v7 )
      {
        v13 = 0;
        v17 = 0;
        while ( v13 < *(_DWORD *)(this + 4) )
        {
          sub_4095E0((int *)this, (unsigned int)v9, v13);
          sub_4097D0((int *)this, (int)&savedregs, *(_DWORD *)(this + 16) + v7 * v17, v9, a2, (int)v15);
          v13 = ++v17;
        }
        sub_40B780(v7 * *(_DWORD *)(this + 4) + 1, (void **)(this + 16), (int)&savedregs);
      }
      else
      {
        for ( i = *(_DWORD *)(this + 4); ; i = v17 )
        {
          v11 = i;
          v12 = i - 1;
          v17 = v12;
          if ( !v11 )
            break;
          sub_4095E0((int *)this, (unsigned int)v9, v12);
          sub_4097D0((int *)this, (int)&savedregs, *(_DWORD *)(this + 16) + v7 * v17, v9, a2, (int)v15);
        }
      }
      sub_40B7E0(*(_DWORD *)(this + 20));
      result = a2;
      *(_DWORD *)(this + 20) = v16;
      *(_DWORD *)(this + 8) = a2;
    }
  }
  return result;
}

//----- (00409B30) --------------------------------------------------------
int __thiscall sub_409B30(int *this, void (__thiscall ***a2)(_DWORD, _DWORD), int a3, int a4, char *a5)
{
  int v6; // edi
  unsigned int v7; // eax
  void (__thiscall **v8)(_DWORD, _DWORD); // edx
  int v10; // [esp+0h] [ebp-34h] BYREF
  _DWORD pExceptionObject[2]; // [esp+14h] [ebp-20h] BYREF
  int i; // [esp+1Ch] [ebp-18h]
  int *v13; // [esp+20h] [ebp-14h]
  int *v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+30h] [ebp-4h]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v6 = 0;
  v14 = &v10;
  v7 = this[4];
  v13 = this;
  if ( v7 )
    sub_40B7E0(v7);
  if ( this[5] )
    sub_40B7E0(this[5]);
  this[4] = 0;
  this[5] = 0;
  this[1] = 0;
  *this = 0;
  this[2] = 0;
  for ( i = 0; ; i = 1 )
  {
    if ( v6 )
    {
      sub_406F10(pExceptionObject, (int)&savedregs, aImageLoadFaile);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    }
    v15 = 0;
    if ( (unsigned __int8)off_4B80C4(this, a2) )
      break;
    v8 = *a2;
    v15 = -1;
    (*v8)(a2, 0);
    v6 = 1;
  }
  v15 = -1;
  (**a2)(a2, 0);
  v15 = 2;
  return ((int (__thiscall *)(int *, int, int, int, char *))off_4B80C8)(this, (int)a2, a3, a4, a5);
}
// 409BB4: conditional instruction was optimized away because of 'edi.4==0'
// 4B80C4: using guessed type int (__thiscall *off_4B80C4)(_DWORD, _DWORD);
// 4B80C8: using guessed type int (__stdcall *off_4B80C8)(int, int, int, int);

//----- (00409CD0) --------------------------------------------------------
int __userpurge sub_409CD0@<eax>(int *a1@<ecx>, int a2@<ebp>, char *a3, int a4, int a5, char *a6)
{
  int (__stdcall **v8)(int); // [esp+4h] [ebp-9Ch] BYREF
  int v9[35]; // [esp+8h] [ebp-98h] BYREF
  int v10; // [esp+9Ch] [ebp-4h]

  v9[0] = -1;
  v10 = 0;
  v9[34] = 0;
  v9[33] = 0;
  v8 = off_4A8B9C;
  sub_407E80(v9, a2, a3, 1, 3);
  v10 = 1;
  sub_409B30(a1, (void (__thiscall ***)(_DWORD, _DWORD))&v8, a4, a5, a6);
  v10 = -1;
  v8 = off_4A8B9C;
  return sub_4087F0(v9);
}
// 4A8B9C: using guessed type int (__stdcall *off_4A8B9C[2])(int);

//----- (00409D90) --------------------------------------------------------
int __thiscall sub_409D90(int *this)
{
  *this = (int)off_4A8B9C;
  return sub_4087F0(this + 1);
}
// 4A8B9C: using guessed type int (__stdcall *off_4A8B9C[2])(int);

//----- (00409DA0) --------------------------------------------------------
int *__thiscall sub_409DA0(int *this, char a2)
{
  sub_409D90(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00409E30) --------------------------------------------------------
int __thiscall sub_409E30(_DWORD *this, char *a2, int a3, int a4)
{
  int result; // eax
  int v6; // eax
  int i; // eax
  int v8; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD pExceptionObject[2]; // [esp+Ch] [ebp-20h] BYREF
  int (**v10)(); // [esp+14h] [ebp-18h] BYREF
  int v11[2]; // [esp+18h] [ebp-14h] BYREF
  int v12; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v11[1] = (int)&v8;
  result = this[4];
  if ( result )
  {
    v11[0] = -1;
    v12 = 0;
    v10 = &off_4A8BDC;
    sub_4080D0(v11, (int)&savedregs, a2, 0, 2);
    v6 = this[4];
    v12 = 2;
    if ( v6 )
    {
      for ( i = 0; ; i = 1 )
      {
        if ( i )
        {
          sub_406F10(pExceptionObject, (int)&savedregs, aImageWriteFail);
          _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
        }
        if ( dword_4B80C0 == a3 )
          break;
      }
      off_4B80CC(this, &v10, a4);
    }
    v12 = -1;
    v10 = &off_4A8BDC;
    result = sub_4087F0(v11);
  }
  return result;
}
// 409EB2: conditional instruction was optimized away because of 'eax.4==0'
// 4A8BDC: using guessed type int (*off_4A8BDC)();
// 4B80C0: using guessed type int dword_4B80C0;
// 4B80CC: using guessed type int (__thiscall *off_4B80CC)(_DWORD, _DWORD, _DWORD);

//----- (00409F20) --------------------------------------------------------
int __thiscall sub_409F20(int *this)
{
  *this = (int)&off_4A8BDC;
  return sub_4087F0(this + 1);
}
// 4A8BDC: using guessed type int (*off_4A8BDC)();

//----- (00409F30) --------------------------------------------------------
int *__thiscall sub_409F30(int *this, char a2)
{
  sub_409F20(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00409F90) --------------------------------------------------------
void __userpurge sub_409F90(int a1@<ecx>, int a2@<ebp>, int a3, char *a4, int a5, int a6, char a7, int a8)
{
  int v9; // ecx
  int v10; // ebx
  int v11; // eax
  char *v12; // edx
  char *v13; // esi

  v9 = *(_DWORD *)(a1 + 8);
  if ( v9 <= 8 )
  {
    v10 = a5;
    if ( a5 > 1 << v9 )
      v10 = 1 << v9;
    if ( a7 )
    {
      v11 = sub_40B720(a2, 4 * (1 << v9));
      *(_DWORD *)(a1 + 20) = v11;
      v12 = (char *)v11;
    }
    else
    {
      v12 = a4;
    }
    if ( v12 )
    {
      memset(v12, 0, 4 << *(_DWORD *)(a1 + 8));
      if ( a6 == 3 )
      {
        if ( v10 > 0 )
        {
          v13 = &v12[4 * a8];
          do
          {
            (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)a3 + 8))(a3, v13, 3);
            v13 += 4;
            --v10;
          }
          while ( v10 );
        }
      }
      else
      {
        (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)a3 + 8))(a3, v12, 4 * v10);
      }
    }
    else
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)a3 + 4))(a3, a6 * v10);
    }
  }
}

//----- (0040A220) --------------------------------------------------------
int __userpurge sub_40A220@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  __int16 v6; // cx
  __int16 v7; // cx
  _DWORD pExceptionObject[2]; // [esp+4h] [ebp-8h] BYREF

  v4 = a3 + a4 * *a1;
  switch ( a1[2] )
  {
    case 4:
      sub_406F10(pExceptionObject, a2, aImageGetrgbUns);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    case 8:
      result = *(_DWORD *)(a1[5] + 4 * *(unsigned __int8 *)(a1[4] + v4));
      break;
    case 0xF:
      v6 = *(_WORD *)(a1[4] + 2 * v4);
      result = 8 * (v6 & 0x1F | (8 * (v6 & 0x3E0 | (8 * (v6 & 0x7C00)))));
      break;
    case 0x10:
      v7 = *(_WORD *)(a1[4] + 2 * v4);
      result = 8 * (v7 & 0x1F | (4 * (v7 & 0x7E0 | (8 * (v7 & 0xF800)))));
      break;
    case 0x18:
      result = *(_DWORD *)(3 * v4 + a1[4]) & 0xFFFFFF;
      break;
    case 0x20:
      result = *(_DWORD *)(a1[4] + 4 * v4);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0040A4C0) --------------------------------------------------------
_DWORD *__userpurge sub_40A4C0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, char *a3)
{
  int *v4; // ecx

  v4 = a1 + 1;
  *v4 = -1;
  a1[35] = 0;
  a1[34] = 0;
  *a1 = off_4A8B9C;
  sub_407E80(v4, a2, a3, 1, 3);
  return a1;
}
// 4A8B9C: using guessed type int (__stdcall *off_4A8B9C[2])(int);

//----- (0040A520) --------------------------------------------------------
int __thiscall sub_40A520(_DWORD *this, int a2)
{
  this[35] = 0;
  this[34] = 0;
  return sub_408180(this + 1, a2);
}

//----- (0040A540) --------------------------------------------------------
int __thiscall sub_40A540(_DWORD *this, int a2)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx

  result = a2;
  v4 = this[34];
  v5 = this[35] - v4;
  if ( a2 < 0 || a2 >= v5 )
  {
    result = sub_4081D0(this + 1, a2 - v5);
    this[35] = 0;
    this[34] = 0;
  }
  else
  {
    this[34] = a2 + v4;
  }
  return result;
}

//----- (0040A590) --------------------------------------------------------
unsigned int __thiscall sub_40A590(_DWORD *this, unsigned int a2, int a3)
{
  unsigned int result; // eax
  int v5; // ebx
  signed int v6; // edi
  int v7; // ebp

  if ( this[34] >= this[35] )
  {
    this[34] = 0;
    this[35] = sub_408570(this + 1, (int)(this + 2), 128);
  }
  result = this[34];
  v5 = a3;
  v6 = this[35] - result;
  if ( a3 <= v6 )
    v6 = a3;
  if ( v6 )
  {
    result = sub_46CAB0(a2, (_BYTE *)this + result + 8, v6);
    v7 = v6 + a2;
    this[34] += v6;
    v5 = a3 - v6;
  }
  else
  {
    v7 = a2;
  }
  if ( v5 )
    result = ReadScrty1FileOffset(this + 1, v7, v5);
  return result;
}

//----- (0040A630) --------------------------------------------------------
signed int __thiscall sub_40A630(_DWORD *this, unsigned int a2, int a3)
{
  int v3; // ebx
  int v5; // eax
  signed int v6; // esi
  int v7; // ebp
  signed int result; // eax

  v3 = a3;
  v5 = this[34];
  v6 = this[35] - v5;
  if ( a3 <= v6 )
    v6 = a3;
  if ( v6 )
  {
    sub_46CAB0(a2, (_BYTE *)this + v5 + 8, v6);
    v7 = v6 + a2;
    this[34] += v6;
    v3 = a3 - v6;
  }
  else
  {
    v7 = a2;
  }
  if ( v3 )
    result = v6 + sub_408570(this + 1, v7, v3);
  else
    result = v6;
  return result;
}

//----- (0040A6A0) --------------------------------------------------------
_DWORD *__userpurge sub_40A6A0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, char *a3)
{
  int *v4; // ecx

  v4 = a1 + 1;
  *v4 = -1;
  *a1 = &off_4A8BDC;
  sub_4080D0(v4, a2, a3, 0, 2);
  return a1;
}
// 4A8BDC: using guessed type int (*off_4A8BDC)();

//----- (0040A700) --------------------------------------------------------
int __thiscall sub_40A700(_DWORD *this)
{
  return sub_4081D0(this + 1, 0);
}

//----- (0040A710) --------------------------------------------------------
int __thiscall sub_40A710(_DWORD *this, int a2)
{
  return sub_408180(this + 1, a2);
}

//----- (0040A720) --------------------------------------------------------
int __thiscall sub_40A720(_DWORD *this, int a2, int a3)
{
  return sub_4086E0(this + 1, a2, a3);
}

//----- (0040A740) --------------------------------------------------------
BOOL __stdcall sub_40A740(int a1)
{
  int v2[4]; // [esp+10h] [ebp-38h] BYREF
  int v3[3]; // [esp+20h] [ebp-28h] BYREF
  __int16 v4; // [esp+2Ch] [ebp-1Ch]
  __int16 v5; // [esp+2Eh] [ebp-1Ah]
  int v6; // [esp+30h] [ebp-18h]

  (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)a1 + 8))(a1, v2, 14);
  (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)a1 + 8))(a1, v3, 40);
  return LOWORD(v2[0]) == 19778
      && v3[0] >= 0x28u
      && v3[1]
      && v3[2]
      && v4 == 1
      && !v6
      && (v5 == 4 || v5 == 8 || v5 == 16 || v5 == 24 || v5 == 32);
}

//----- (0040A7D0) --------------------------------------------------------
int __thiscall sub_40A7D0(int *this, int a2, int a3, int a4, char *a5)
{
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  bool v10; // sf
  int v11; // eax
  char *v12; // edi
  int v13; // ecx
  int v14; // edx
  char *v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // edi
  int v21; // edi
  int v22; // eax
  int result; // eax
  bool v24; // cc
  int v25; // ecx
  int v26; // ebx
  _DWORD pExceptionObject[2]; // [esp+10h] [ebp-40h] BYREF
  char v28[8]; // [esp+18h] [ebp-38h] BYREF
  _WORD v29[3]; // [esp+20h] [ebp-30h]
  int v30; // [esp+26h] [ebp-2Ah] BYREF
  int v31; // [esp+2Ch] [ebp-24h]
  int v32; // [esp+30h] [ebp-20h]
  int v33; // [esp+34h] [ebp-1Ch]
  int v34; // [esp+48h] [ebp-8h]
  char v35; // [esp+54h] [ebp+4h]
  int v36; // [esp+54h] [ebp+4h]
  int v37; // [esp+58h] [ebp+8h]

  (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)a2 + 8))(a2, v28, 14);
  (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)a2 + 8))(a2, (char *)&v30 + 2, 40);
  if ( HIWORD(v33) == 16 )
    v7 = 15;
  else
    v7 = HIWORD(v33);
  v8 = v32;
  v9 = v31;
  v10 = v32 < 0;
  this[2] = v7;
  *this = v9;
  this[1] = v8;
  v35 = 1;
  if ( v10 )
  {
    this[1] = -v8;
    v35 = 0;
  }
  v11 = v34;
  if ( !v34 )
    v11 = 1 << v7;
  v12 = a5;
  sub_409F90((int)this, a2, a2, a5, v11, 4, a3 == 0, 0);
  v13 = this[2];
  if ( v13 <= 8 && (a5 || this[5]) )
  {
    if ( !a3 )
      v12 = (char *)this[5];
    v14 = 0;
    if ( 1 << v13 > 0 )
    {
      v15 = v12;
      do
      {
        v16 = *(_DWORD *)v15;
        v15 += 4;
        ++v14;
        *((_DWORD *)v15 - 1) = v16 & 0xFFFFFF;
      }
      while ( v14 < 1 << this[2] );
    }
  }
  v17 = this[2];
  if ( a3 )
  {
    if ( v17 == 4 )
      v22 = (*this + 1) >> 1;
    else
      v22 = *this * ((v17 + 7) >> 3);
    if ( a4 < v22 * this[1] )
    {
      sub_406F10(pExceptionObject, a2, aImageReadFaile);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    }
  }
  else
  {
    if ( v17 == 4 )
      v18 = (*this + 1) >> 1;
    else
      v18 = *this * ((v17 + 7) >> 3);
    v19 = sub_40B720(a2, v18 * this[1]);
    this[4] = v19;
    a3 = v19;
  }
  v20 = this[2];
  if ( v20 == 4 )
    v21 = (*this + 1) >> 1;
  else
    v21 = *this * ((v20 + 7) >> 3);
  (**(void (__thiscall ***)(int, _DWORD))a2)(a2, *(_DWORD *)&v29[1]);
  if ( v35 )
  {
    v25 = this[1];
    result = v25 - 1;
    if ( v25 )
    {
      v26 = a3 + v21 * result;
      v37 = this[1];
      do
      {
        (*(void (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 8))(a2, v26, v21);
        if ( (v21 & 3) != 0 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a2 + 4))(a2, 4 - (v21 & 3));
        result = v37 - 1;
        v26 -= v21;
        --v37;
      }
      while ( v37 );
    }
  }
  else
  {
    result = this[1];
    v36 = 0;
    if ( result > 0 )
    {
      do
      {
        (*(void (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 8))(a2, a3, v21);
        if ( (v21 & 3) != 0 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a2 + 4))(a2, 4 - (v21 & 3));
        result = v36 + 1;
        v24 = ++v36 < this[1];
        a3 += v21;
      }
      while ( v24 );
    }
  }
  return result;
}

//----- (0040AA10) --------------------------------------------------------
int __thiscall sub_40AA10(int *this, int *a2, int a3)
{
  int v4; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // ebp
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // ebx
  _WORD *v17; // ebp
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v22; // [esp+24h] [ebp-4Ch]
  int v23; // [esp+28h] [ebp-48h]
  int v24; // [esp+2Ch] [ebp-44h] BYREF
  int v25; // [esp+30h] [ebp-40h] BYREF
  int v26; // [esp+34h] [ebp-3Ch]
  __int64 v27; // [esp+38h] [ebp-38h] BYREF
  _BYTE v28[6]; // [esp+40h] [ebp-30h]
  int v29[3]; // [esp+48h] [ebp-28h] BYREF
  int v30; // [esp+54h] [ebp-1Ch]
  int v31; // [esp+58h] [ebp-18h]
  int v32; // [esp+5Ch] [ebp-14h]
  int v33; // [esp+60h] [ebp-10h]
  int v34; // [esp+64h] [ebp-Ch]
  int v35; // [esp+68h] [ebp-8h]
  int v36; // [esp+6Ch] [ebp-4h]
  int v37; // [esp+74h] [ebp+4h]

  v27 = 0i64;
  v4 = *a2;
  *(_DWORD *)v28 = 0;
  *(_WORD *)&v28[4] = 0;
  LOWORD(v27) = 19778;
  (*(void (__thiscall **)(int *, int))(v4 + 4))(a2, 14);
  v6 = this[1];
  v29[1] = *this;
  v7 = this[2];
  v29[0] = 40;
  v29[2] = v6;
  v30 = 1048577;
  if ( v7 != 15 )
    HIWORD(v30) = v7;
  v8 = *a2;
  v34 = 100;
  v33 = 100;
  v31 = 0;
  v32 = 0;
  v36 = 0;
  v35 = 0;
  (*(void (__thiscall **)(int *, int *, int))(v8 + 8))(a2, v29, 40);
  v9 = this[2];
  if ( v9 <= 8 )
    (*(void (__thiscall **)(int *, int, int))(*a2 + 8))(a2, this[5], 4 << v9);
  *(_DWORD *)&v28[2] = (*(int (__thiscall **)(int *))*a2)(a2);
  v10 = this[2];
  v25 = 0;
  if ( v10 == 4 )
  {
    v11 = (*this + 1) >> 1;
    v37 = v11;
  }
  else
  {
    v37 = *this * ((v10 + 7) >> 3);
    v11 = v37;
  }
  v12 = this[1];
  v13 = v12 - 1;
  v22 = v12 - 1;
  if ( v12 )
  {
    v14 = v11 * v13;
    v23 = v11 * v13;
    v26 = -v11;
    while ( this[2] == 16 )
    {
      v15 = *this;
      v16 = 0;
      if ( *this > 0 )
      {
        v17 = (_WORD *)(this[4] + 2 * v13 * *this);
        do
        {
          LOWORD(v15) = *v17;
          v18 = *v17 & 0x1F | (v15 >> 1) & 0x7FE0;
          v19 = *a2;
          v24 = v18;
          (*(void (__thiscall **)(int *, int *, int))(v19 + 8))(a2, &v24, 2);
          v15 = *this;
          ++v16;
          ++v17;
        }
        while ( v16 < *this );
        v13 = v22;
        goto LABEL_16;
      }
LABEL_17:
      if ( (v11 & 3) != 0 )
      {
        (*(void (__thiscall **)(int *, int *, int))(*a2 + 8))(a2, &v25, 4 - (v11 & 3));
        v11 = v37;
      }
      v20 = v13--;
      v14 = v26 + v23;
      v22 = v13;
      v23 += v26;
      if ( !v20 )
        goto LABEL_20;
    }
    (*(void (__thiscall **)(int *, int, int))(*a2 + 8))(a2, v14 + this[4], v11);
LABEL_16:
    v11 = v37;
    goto LABEL_17;
  }
LABEL_20:
  *(_DWORD *)((char *)&v27 + 2) = (*(int (__thiscall **)(int *))*a2)(a2);
  (*(void (__thiscall **)(int *, _DWORD))(*a2 + 4))(a2, 0);
  return (*(int (__thiscall **)(int *, __int64 *, int))(*a2 + 8))(a2, &v27, 14);
}

//----- (0040ABE0) --------------------------------------------------------
_DWORD *__thiscall sub_40ABE0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[10] = 0;
  this[8] = 0;
  this[6] = 0;
  this[4] = 0;
  this[2] = 0;
  this[20] = 0;
  this[18] = 0;
  this[16] = 0;
  this[14] = 0;
  this[12] = 0;
  *this = 0;
  this[11] = 0;
  this[9] = 0;
  this[7] = 0;
  this[5] = 0;
  this[3] = 0;
  this[21] = 0;
  this[19] = 0;
  this[17] = 0;
  this[15] = 0;
  this[13] = 0;
  return result;
}

//----- (0040AC80) --------------------------------------------------------
void __thiscall sub_40AC80(int this, double a2, double a3)
{
  double v3; // st6

  v3 = a2 + *(double *)(this + 8);
  ++*(_DWORD *)this;
  *(double *)(this + 8) = v3;
  *(double *)(this + 16) = a3 + *(double *)(this + 16);
  *(double *)(this + 24) = a2 * a2 + *(double *)(this + 24);
  *(double *)(this + 32) = a3 * a3 + *(double *)(this + 32);
  *(double *)(this + 40) = a2 * a3 + *(double *)(this + 40);
  sub_40ACD0((int *)this);
}

//----- (0040ACD0) --------------------------------------------------------
void __thiscall sub_40ACD0(int *this)
{
  int v1; // edx
  double v2; // st7
  double v3; // st6
  double v4; // st7
  long double v5; // st6
  double v6; // [esp+0h] [ebp-10h]
  double v7; // [esp+8h] [ebp-8h]

  v1 = *this;
  if ( *this > 2 )
  {
    v6 = (double)*this;
    v7 = v6 * *((double *)this + 3) - *((double *)this + 1) * *((double *)this + 1);
    if ( fabs(v7) <= dbl_4A8C90 )
    {
      this[20] = 0;
      this[18] = 0;
      this[16] = 0;
      this[14] = 0;
      this[12] = 0;
      this[21] = 0;
      this[19] = 0;
      this[17] = 0;
      this[15] = 0;
      this[13] = 0;
    }
    else
    {
      v2 = *((double *)this + 2) * *((double *)this + 1);
      v3 = (v6 * *((double *)this + 5) - v2) / v7;
      *((double *)this + 7) = v3;
      *((double *)this + 6) = (*((double *)this + 2) - v3 * *((double *)this + 1)) / v6;
      v4 = (*((double *)this + 5) - v2 / v6) * v3;
      v5 = *((double *)this + 4) - *((double *)this + 2) * *((double *)this + 2) / v6;
      if ( fabs(v5) <= dbl_4A8C90 )
      {
        this[20] = 0;
        this[18] = 0;
        this[16] = 0;
        this[21] = 0;
        this[19] = 0;
        this[17] = 0;
      }
      else
      {
        *((long double *)this + 8) = v4 / v5;
        *((long double *)this + 9) = sqrt(v4 / v5);
        *((long double *)this + 10) = sqrt((v5 - v4) / (double)(v1 - 2));
      }
    }
  }
}
// 4A8C90: using guessed type double dbl_4A8C90;

//----- (0040ADE0) --------------------------------------------------------
void __thiscall sub_40ADE0(_DWORD *this)
{
  this[20] = 0;
  *this = 1732584193;
  this[1] = -271733879;
  this[2] = -1732584194;
  this[3] = 271733878;
}

//----- (0040AE10) --------------------------------------------------------
int __thiscall sub_40AE10(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[20] = 0;
  *this = 1732584193;
  this[1] = -271733879;
  this[2] = -1732584194;
  this[3] = 271733878;
  memset(this + 4, 0, 0x40u);
  return result;
}

//----- (0040AE50) --------------------------------------------------------
unsigned int __thiscall sub_40AE50(int *this, int *a2, unsigned int a3)
{
  int *v4; // esi
  int v5; // edx
  unsigned int result; // eax
  unsigned int v7; // ebp
  unsigned int v8; // ecx
  unsigned int v9; // edi

  v4 = a2;
  v5 = this[20] & 0x3F;
  if ( !v5 )
  {
    v7 = a3;
    goto LABEL_7;
  }
  result = 64 - v5;
  if ( 64 - v5 > a3 )
    result = a3;
  v7 = a3 - result;
  qmemcpy((char *)this + v5 + 16, a2, result);
  v8 = result + this[20];
  this[20] = v8;
  v4 = (int *)((char *)a2 + result);
  if ( (v8 & 0x3F) == 0 )
  {
    sub_40B070(this, this + 4);
LABEL_7:
    if ( v7 >= 0x40 )
    {
      v9 = v7 >> 6;
      do
      {
        sub_40B070(this, v4);
        v4 += 16;
        v7 -= 64;
        --v9;
        this[20] += 64;
      }
      while ( v9 );
    }
    result = v7 + this[20];
    this[20] = result;
    qmemcpy(this + 4, v4, v7);
  }
  return result;
}

//----- (0040AF00) --------------------------------------------------------
int __thiscall sub_40AF00(int *this, int *a2)
{
  int v3; // eax
  unsigned int v4; // ecx
  int v5; // eax
  int result; // eax
  __int64 v7; // [esp+8h] [ebp-8h] BYREF

  v3 = this[20];
  v4 = v3 & 0x3F;
  v7 = 8i64 * (unsigned int)v3;
  v5 = 56;
  if ( v4 >= 0x38 )
    v5 = 120;
  sub_40AE50(this, dword_4A8C98, v5 - v4);
  sub_40AE50(this, (int *)&v7, 8u);
  *a2 = *this;
  a2[1] = this[1];
  a2[2] = this[2];
  result = 0;
  a2[3] = this[3];
  this[20] = 0;
  *this = 1732584193;
  this[1] = -271733879;
  this[2] = -1732584194;
  this[3] = 271733878;
  memset(this + 4, 0, 0x40u);
  return result;
}

//----- (0040B070) --------------------------------------------------------
_DWORD *__thiscall sub_40B070(_DWORD *this, int *a2)
{
  int v2; // ebx
  int v3; // esi
  int v5; // edi
  int v6; // edx
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // ebx
  int v14; // edx
  int v15; // esi
  int v16; // edi
  int v17; // ebx
  int v18; // edx
  int v19; // esi
  int v20; // edi
  int v21; // ebx
  int v22; // edx
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // edx
  int v27; // ecx
  int v28; // esi
  int v29; // edi
  int v30; // edx
  int v31; // ecx
  int v32; // esi
  int v33; // edi
  int v34; // edx
  int v35; // ecx
  int v36; // esi
  int v37; // edi
  int v38; // edx
  int v39; // ebx
  int v40; // esi
  int v41; // ecx
  int v42; // edx
  int v43; // edi
  int v44; // esi
  int v45; // ecx
  int v46; // edx
  int v47; // edi
  int v48; // ebx
  int v49; // ecx
  int v50; // edx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // edx
  int v55; // esi
  int v56; // edi
  int v57; // ecx
  int v58; // edx
  int v59; // esi
  int v60; // edi
  int v61; // ecx
  int v62; // edx
  int v63; // eax
  int v64; // esi
  int v65; // ecx
  int v66; // edx
  int v67; // edi
  int v68; // esi
  _DWORD *result; // eax
  int v70; // ebx
  int v71; // edx
  int v72; // ecx
  int v73; // ecx
  int v74; // [esp+10h] [ebp-40h]
  int v75; // [esp+14h] [ebp-3Ch]
  int v76; // [esp+18h] [ebp-38h]
  int v77; // [esp+1Ch] [ebp-34h]
  int v78; // [esp+20h] [ebp-30h]
  int v79; // [esp+24h] [ebp-2Ch]
  int v80; // [esp+28h] [ebp-28h]
  int v81; // [esp+2Ch] [ebp-24h]
  int v82; // [esp+30h] [ebp-20h]
  int v83; // [esp+34h] [ebp-1Ch]
  int v84; // [esp+38h] [ebp-18h]
  int v85; // [esp+3Ch] [ebp-14h]
  int v86; // [esp+40h] [ebp-10h]
  int v87; // [esp+44h] [ebp-Ch]
  int v88; // [esp+48h] [ebp-8h]
  int v90; // [esp+54h] [ebp+4h]

  v2 = this[1];
  v3 = this[3];
  v5 = this[2];
  v90 = *a2;
  v78 = a2[1];
  v6 = v2 + __ROL4__(v90 + *this + (v3 ^ v2 & (v5 ^ v3)) - 680876936, 7);
  v86 = a2[2];
  v7 = v6 + __ROL4__(v3 + v78 + (v5 ^ v6 & (v2 ^ v5)) - 389564586, 12);
  v76 = a2[3];
  v8 = v7 + __ROL4__(v5 + v86 + (v2 ^ v7 & (v6 ^ v2)) + 606105819, 17);
  v82 = a2[4];
  v9 = v8 + __ROL4__(v2 + v76 + (v6 ^ v8 & (v6 ^ v7)) - 1044525330, 22);
  v75 = a2[5];
  v10 = v9 + __ROL4__(v6 + v82 + (v7 ^ v9 & (v8 ^ v7)) - 176418897, 7);
  v80 = a2[6];
  v11 = v10 + __ROL4__(v7 + v75 + (v8 ^ v10 & (v9 ^ v8)) + 1200080426, 12);
  v12 = v11 + __ROL4__(v8 + v80 + (v9 ^ v11 & (v10 ^ v9)) - 1473231341, 17);
  v74 = a2[7];
  v79 = a2[8];
  v13 = v12 + __ROL4__(v9 + v74 + (v10 ^ v12 & (v10 ^ v11)) - 45705983, 22);
  v84 = a2[9];
  v14 = v13 + __ROL4__(v10 + v79 + (v11 ^ v13 & (v12 ^ v11)) + 1770035416, 7);
  v77 = a2[10];
  v15 = v14 + __ROL4__(v11 + v84 + (v12 ^ v14 & (v13 ^ v12)) - 1958414417, 12);
  v83 = a2[11];
  v16 = v15 + __ROL4__(v12 + v77 + (v13 ^ v15 & (v14 ^ v13)) - 42063, 17);
  v85 = a2[12];
  v17 = v16 + __ROL4__(v13 + v83 + (v14 ^ v16 & (v14 ^ v15)) - 1990404162, 22);
  v81 = a2[13];
  v18 = v17 + __ROL4__(v14 + v85 + (v15 ^ v17 & (v16 ^ v15)) + 1804603682, 7);
  v19 = v18 + __ROL4__(v15 + v81 + (v16 ^ v18 & (v17 ^ v16)) - 40341101, 12);
  v87 = a2[14];
  v88 = a2[15];
  v20 = v19 + __ROL4__(v87 + (v17 ^ v19 & (v18 ^ v17)) + v16 - 1502002290, 17);
  v21 = v20 + __ROL4__(v88 + (v18 ^ v20 & (v18 ^ v19)) + v17 + 1236535329, 22);
  v22 = v21 + __ROL4__(v78 + (v20 ^ v19 & (v21 ^ v20)) + v18 - 165796510, 5);
  v23 = v22 + __ROL4__(v80 + (v21 ^ v20 & (v22 ^ v21)) + v19 - 1069501632, 9);
  v24 = v23 + __ROL4__(v83 + (v22 ^ v21 & (v22 ^ v23)) + v20 + 643717713, 14);
  v25 = v24 + __ROL4__(v90 + (v23 ^ v22 & (v24 ^ v23)) + v21 - 373897302, 20);
  v26 = v25 + __ROL4__(v75 + (v24 ^ v23 & (v25 ^ v24)) + v22 - 701558691, 5);
  v27 = v26 + __ROL4__(v77 + (v25 ^ v24 & (v26 ^ v25)) + v23 + 38016083, 9);
  v28 = v27 + __ROL4__(v88 + (v26 ^ v25 & (v26 ^ v27)) + v24 - 660478335, 14);
  v29 = v28 + __ROL4__(v82 + (v27 ^ v26 & (v28 ^ v27)) + v25 - 405537848, 20);
  v30 = v29 + __ROL4__(v84 + (v28 ^ v27 & (v29 ^ v28)) + v26 + 568446438, 5);
  v31 = v30 + __ROL4__(v87 + (v29 ^ v28 & (v30 ^ v29)) + v27 - 1019803690, 9);
  v32 = v31 + __ROL4__(v76 + (v30 ^ v29 & (v30 ^ v31)) + v28 - 187363961, 14);
  v33 = v32 + __ROL4__(v79 + (v31 ^ v30 & (v32 ^ v31)) + v29 + 1163531501, 20);
  v34 = v33 + __ROL4__(v81 + (v32 ^ v31 & (v33 ^ v32)) + v30 - 1444681467, 5);
  v35 = v34 + __ROL4__(v86 + (v33 ^ v32 & (v34 ^ v33)) + v31 - 51403784, 9);
  v36 = v35 + __ROL4__(v74 + (v34 ^ v33 & (v34 ^ v35)) + v32 + 1735328473, 14);
  v37 = v36 + __ROL4__(v85 + (v35 ^ v34 & (v36 ^ v35)) + v33 - 1926607734, 20);
  v38 = v37 + __ROL4__(v75 + (v37 ^ v36 ^ v35) + v34 - 378558, 4);
  v39 = v38 + __ROL4__(v79 + (v38 ^ v37 ^ v36) + v35 - 2022574463, 11);
  v40 = v39 + __ROL4__(v83 + (v38 ^ v37 ^ v39) + v36 + 1839030562, 16);
  v41 = v40 + __ROL4__(v87 + (v38 ^ v40 ^ v39) + v37 - 35309556, 23);
  v42 = v41 + __ROL4__(v78 + (v41 ^ v40 ^ v39) + v38 - 1530992060, 4);
  v43 = v42 + __ROL4__(v82 + (v42 ^ v41 ^ v40) + v39 + 1272893353, 11);
  v44 = v43 + __ROL4__(v74 + (v42 ^ v41 ^ v43) + v40 - 155497632, 16);
  v45 = v44 + __ROL4__(v77 + (v42 ^ v44 ^ v43) + v41 - 1094730640, 23);
  v46 = v45 + __ROL4__(v81 + (v45 ^ v44 ^ v43) + v42 + 681279174, 4);
  v47 = v46 + __ROL4__(v90 + (v46 ^ v45 ^ v44) + v43 - 358537222, 11);
  v48 = v47 + __ROL4__(v76 + (v46 ^ v45 ^ v47) + v44 - 722521979, 16);
  v49 = v48 + __ROL4__(v80 + (v46 ^ v48 ^ v47) + v45 + 76029189, 23);
  v50 = v49 + __ROL4__(v84 + (v49 ^ v48 ^ v47) + v46 - 640364487, 4);
  v51 = v50 + __ROL4__(v85 + (v50 ^ v49 ^ v48) + v47 - 421815835, 11);
  v52 = v51 + __ROL4__(v88 + (v50 ^ v49 ^ v51) + v48 + 530742520, 16);
  v53 = v52 + __ROL4__(v49 + v86 + (v50 ^ v52 ^ v51) - 995338651, 23);
  v54 = v53 + __ROL4__(v50 + v90 + (v52 ^ (v53 | ~v51)) - 198630844, 6);
  v55 = v54 + __ROL4__(v51 + v74 + (v53 ^ (v54 | ~v52)) + 1126891415, 10);
  v56 = v55 + __ROL4__(v52 + v87 + (v54 ^ (v55 | ~v53)) - 1416354905, 15);
  v57 = v56 + __ROL4__(v53 + v75 + (v55 ^ (v56 | ~v54)) - 57434055, 21);
  v58 = v57 + __ROL4__(v54 + v85 + (v56 ^ (v57 | ~v55)) + 1700485571, 6);
  v59 = v58 + __ROL4__(v76 + (v57 ^ (v58 | ~v56)) + v55 - 1894986606, 10);
  v60 = v59 + __ROL4__(v77 + (v58 ^ (v59 | ~v57)) + v56 - 1051523, 15);
  v61 = v60 + __ROL4__(v78 + (v59 ^ (v60 | ~v58)) + v57 - 2054922799, 21);
  v62 = v61 + __ROL4__(v79 + (v60 ^ (v61 | ~v59)) + v58 + 1873313359, 6);
  v63 = v62 + __ROL4__(v88 + (v61 ^ (v62 | ~v60)) + v59 - 30611744, 10);
  v64 = v63 + __ROL4__(v80 + (v62 ^ (v63 | ~v61)) + v60 - 1560198380, 15);
  v65 = v64 + __ROL4__(v81 + (v63 ^ (v64 | ~v62)) + v61 + 1309151649, 21);
  v66 = v65 + __ROL4__(v82 + (v64 ^ (v65 | ~v63)) + v62 - 145523070, 6);
  v67 = v66 + __ROL4__(v83 + (v65 ^ (v66 | ~v64)) + v63 - 1120210379, 10);
  v68 = v67 + __ROL4__(v86 + (v66 ^ (v67 | ~v65)) + v64 + 718787259, 15);
  result = this;
  v70 = v66 + *this;
  v71 = v68 + __ROL4__(v84 + (v67 ^ (v68 | ~v66)) + v65 - 343485551, 21) + this[1];
  v72 = v68 + this[2];
  *this = v70;
  this[2] = v72;
  v73 = this[3];
  this[1] = v71;
  this[3] = v67 + v73;
  return result;
}

//----- (0040B720) --------------------------------------------------------
int __usercall sub_40B720@<eax>(int a1@<ebp>, size_t a2)
{
  size_t v2; // eax
  int result; // eax
  _DWORD pExceptionObject[2]; // [esp+0h] [ebp-8h] BYREF

  v2 = a2;
  if ( !a2 )
    v2 = 1;
  result = sub_46D9FD(v2);
  if ( !result )
  {
    sub_406FF0(pExceptionObject, a1);
    _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
  }
  return result;
}

//----- (0040B760) --------------------------------------------------------
_DWORD *__thiscall sub_40B760(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = this;
  v3 = *(_DWORD *)(a2 + 4);
  *this = &off_4A87AC;
  this[1] = v3;
  return result;
}
// 4A87AC: using guessed type int (__stdcall *off_4A87AC)(char);

//----- (0040B780) --------------------------------------------------------
void *__usercall sub_40B780@<eax>(size_t a1@<edx>, void **a2@<ecx>, int a3@<ebp>)
{
  void *result; // eax
  _DWORD pExceptionObject[2]; // [esp+4h] [ebp-8h] BYREF

  if ( *a2 )
    result = sub_46DC4A(*a2, a1);
  else
    result = (void *)sub_46D9FD(a1);
  *a2 = result;
  if ( !result )
  {
    sub_406FF0(pExceptionObject, a3);
    _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
  }
  return result;
}

//----- (0040B7D0) --------------------------------------------------------
void __thiscall sub_40B7D0(void *this)
{
  sub_46D360((unsigned int)this);
}

//----- (0040B7E0) --------------------------------------------------------
void __cdecl sub_40B7E0(unsigned int a1)
{
  sub_46D360(a1);
}

//----- (0040B8B0) --------------------------------------------------------
char *__fastcall sub_40B8B0(_BYTE *a1, int a2, char *Str, char a4, int a5)
{
  char *v5; // eax
  unsigned int v7; // edx
  char *v8; // esi
  int v9; // ebx
  char *v11; // eax
  int v12; // eax
  char v13; // al

  v5 = Str;
  v7 = (unsigned int)a1;
  v8 = Str;
  if ( a1 )
    *a1 = 0;
  v9 = a5 + 1;
  if ( a5 != -1 )
  {
    do
    {
      v8 = v5;
      v5 = strchr(v5, a4);
      if ( !v5 )
        break;
      ++v5;
      --v9;
    }
    while ( v9 );
    v7 = (unsigned int)a1;
  }
  if ( v9 > 1 )
    return 0;
  while ( *v8 == 32 || *v8 == 9 )
    ++v8;
  if ( v7 )
  {
    if ( v5 )
    {
      v11 = v5 - 1;
    }
    else
    {
      v11 = strchr(v8, 0);
      v7 = (unsigned int)a1;
    }
    v12 = v11 - v8;
    if ( a2 > v12 )
      a2 = v12 + 1;
    sub_46CAB0(v7, v8, a2 - 1);
    do
    {
      a1[--a2] = 0;
      if ( !a2 )
        break;
      v13 = a1[a2 - 1];
    }
    while ( v13 == 32 || v13 == 9 || a4 == 10 && v13 == 13 );
  }
  return v8;
}

//----- (0040BA80) --------------------------------------------------------
char *__fastcall strncpyt(void *dst, void *src, int len)
{
  if ( strlen((const char *)src) < len )
    return strcpy((char *)dst, (const char *)src);
  sub_46CAB0((unsigned int)dst, src, len);
  *((char *)dst + len - 1) = 0;
  return (char *)dst;
}

//----- (0040BAE0) --------------------------------------------------------
char *__fastcall sub_40BAE0(const char *a1, char *a2, signed int a3)
{
  signed int v4; // ecx
  unsigned int v6; // esi
  char *v7; // ebx

  v4 = strlen(a1);
  if ( v4 >= a3 )
    return (char *)a1;
  v6 = a3 - v4;
  v7 = (char *)&a1[v4];
  if ( strlen(a2) < a3 - v4 )
    return strcpy(v7, a2);
  sub_46CAB0((unsigned int)v7, a2, v6);
  v7[v6 - 1] = 0;
  return v7;
}

//----- (0040BB60) --------------------------------------------------------
char *__fastcall sub_40BB60(char *Buf1, const char *Buf2)
{
  int v4; // ebp
  char *result; // eax
  char *v6; // edi
  int v7; // edi
  unsigned int Size; // [esp+14h] [ebp-8h]
  unsigned int v9; // [esp+18h] [ebp-4h]

  v9 = 0;
  Size = strlen(Buf2);
  v4 = tolower(*Buf2);
  if ( !*Buf1 )
    return 0;
  v6 = Buf1;
  if ( Buf1 )
  {
    while ( _memicmp(v6, Buf2, Size) )
    {
      v6 = strchr(v6 + 1, v4);
      if ( !v6 )
        goto LABEL_8;
    }
    v9 = (unsigned int)v6;
  }
LABEL_8:
  v7 = toupper(*Buf2);
  if ( v7 == v4 || !Buf1 )
  {
LABEL_12:
    Buf1 = 0;
  }
  else
  {
    while ( _memicmp(Buf1, Buf2, Size) )
    {
      Buf1 = strchr(Buf1 + 1, v7);
      if ( !Buf1 )
        goto LABEL_12;
    }
  }
  result = (char *)v9;
  if ( !v9 || v9 >= (unsigned int)Buf1 && Buf1 )
    result = Buf1;
  return result;
}

//----- (0040BCB0) --------------------------------------------------------
char __fastcall sub_40BCB0(char *a1, int a2, char a3)
{
  char result; // al

  for ( result = *a1; result; ++a1 )
  {
    if ( result == a2 )
      *a1 = a3;
    result = a1[1];
  }
  return result;
}

//----- (0040BCD0) --------------------------------------------------------
char *__thiscall sub_40BCD0(char *this)
{
  char *result; // eax
  char i; // dl

  result = this;
  for ( i = *this; i >= 48; i = *++result )
  {
    if ( i > 57 )
      break;
  }
  return result;
}

//----- (0040BCF0) --------------------------------------------------------
_BYTE *__thiscall sub_40BCF0(_BYTE *this)
{
  _BYTE *result; // eax

  for ( result = this; *result == 32 || *result == 9; ++result )
    ;
  return result;
}

//----- (0040BD10) --------------------------------------------------------
char *__fastcall sub_40BD10(char *Str)
{
  char *result; // eax

  for ( result = strchr(Str, 0) - 1; result >= Str; *result-- = 0 )
  {
    if ( *result != 32 && *result != 9 )
      break;
  }
  return result;
}

//----- (0040BE30) --------------------------------------------------------
void __thiscall sub_40BE30(unsigned int *this)
{
  sub_46D360(*this);
  *this = 0;
}

//----- (0040C1B0) --------------------------------------------------------
void __thiscall sub_40C1B0(const char **this, int a2, char *a3)
{
  char *v4; // edx
  unsigned int v5; // kr08_4
  int v6; // eax
  unsigned int v7; // kr0C_4
  unsigned int v8; // esi
  unsigned int v9; // kr10_4
  unsigned int v10; // kr14_4
  const char *v11; // eax
  unsigned int v12; // kr1C_4
  unsigned int v13; // edi
  const char *v14; // eax
  _DWORD pExceptionObject[2]; // [esp+10h] [ebp-8h] BYREF

  v4 = (char *)*this;
  if ( *this )
  {
    v7 = strlen(*this) + 1;
    v8 = v7 - 1;
    if ( a2 < (int)(v7 - 1) )
    {
      v12 = strlen(a3) + 1;
      v13 = v12 - 1;
      v14 = (const char *)sub_46DC4A(v4, v12 + v8);
      *this = v14;
      if ( !v14 )
      {
        sub_406FF0(pExceptionObject, a2);
        _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
      }
      v14[v13 + v8] = 0;
      sub_46CAB0((unsigned int)&(*this)[v13 + a2], &(*this)[a2], v7 - a2);
      sub_46CAB0((unsigned int)&(*this)[a2], a3, v13);
    }
    else
    {
      v9 = strlen(v4) + 1;
      v10 = strlen(a3) + 1;
      v11 = (const char *)sub_46DC4A(v4, v10 + v9 - 1);
      *this = v11;
      if ( !v11 )
      {
        sub_406FF0(pExceptionObject, (int)a3);
        _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
      }
      v11[v10 - 2 + v9] = 0;
      strcat((char *)*this, a3);
    }
  }
  else if ( a3 )
  {
    v5 = strlen(a3) + 1;
    v6 = sub_46D9FD(v5 - 1 + 2);
    *this = (const char *)v6;
    if ( !v6 )
    {
      sub_406FF0(pExceptionObject, (int)a3);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v6 + v5) = 0;
    strcpy((char *)*this, a3);
  }
  else
  {
    sub_46D360(0);
    *this = 0;
  }
}

//----- (0040C890) --------------------------------------------------------
void sub_40C890(const char **a1, char *Format, ...)
{
  unsigned int v2; // kr04_4
  int v3; // eax
  unsigned int v4; // ecx
  char *v5; // edi
  unsigned int v6; // edx
  unsigned int v7; // kr08_4
  unsigned int v8; // kr0C_4
  const char *v9; // eax
  char pExceptionObject[8]; // [esp+Ch] [ebp-808h] BYREF
  char Buffer[2048]; // [esp+14h] [ebp-800h] BYREF
  va_list va; // [esp+820h] [ebp+Ch] BYREF

  va_start(va, Format);
  Buffer[2047] = 0;
  _vsnprintf(Buffer, 0x7FFu, Format, va);
  if ( *a1 )
  {
    v7 = strlen(*a1) + 1;
    v8 = strlen(Buffer) + 1;
    v9 = (const char *)sub_46DC4A((void *)*a1, v8 + v7 - 1);
    *a1 = v9;
    if ( !v9 )
    {
      sub_406FF0(pExceptionObject);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
    v9[v8 - 2 + v7] = 0;
    v6 = strlen(Buffer) + 1;
    v5 = (char *)&(*a1)[strlen(*a1)];
    v4 = v6;
  }
  else
  {
    if ( !Buffer )
    {
      sub_46D360((unsigned int)Buffer);
      *a1 = 0;
      return;
    }
    v2 = strlen(Buffer) + 1;
    v3 = sub_46D9FD(v2 - 1 + 2);
    *a1 = (const char *)v3;
    if ( !v3 )
    {
      sub_406FF0(pExceptionObject);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v3 + v2) = 0;
    v4 = strlen(Buffer) + 1;
    v5 = (char *)*a1;
    LOBYTE(v6) = v4;
  }
  qmemcpy(v5, Buffer, 4 * (v4 >> 2) + (v6 & 3));
}
// 406FF0: using guessed type int __thiscall sub_406FF0(_DWORD);

//----- (0040C9D0) --------------------------------------------------------
void __userpurge sub_40C9D0(int a1@<ecx>, int a2@<ebp>, size_t a3)
{
  void *v4; // eax
  void *v5; // eax
  _DWORD pExceptionObject[2]; // [esp+8h] [ebp-8h] BYREF

  v4 = *(void **)a1;
  if ( a3 )
  {
    if ( v4 )
      v5 = sub_46DC4A(v4, a3);
    else
      v5 = (void *)sub_46D9FD(a3);
    *(_DWORD *)a1 = v5;
    if ( !v5 )
    {
      sub_406FF0(pExceptionObject, a2);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
  }
  else
  {
    sub_46D360((unsigned int)v4);
    *(_DWORD *)a1 = 0;
  }
  *(_DWORD *)(a1 + 4) = a3;
}

//----- (0040CA40) --------------------------------------------------------
unsigned int __userpurge sub_40CA40@<eax>(unsigned int *a1@<ecx>, int a2@<ebp>, _BYTE *a3, unsigned int a4)
{
  unsigned int v5; // eax
  bool v6; // zf
  size_t v7; // edi
  void *v8; // eax
  void *v10; // eax
  unsigned int v11; // [esp-Ch] [ebp-20h]
  _DWORD pExceptionObject[2]; // [esp+Ch] [ebp-8h] BYREF

  v5 = a1[1];
  v6 = v5 + a4 == 0;
  v7 = v5 + a4;
  v8 = (void *)*a1;
  if ( v6 )
  {
    sub_46D360(*a1);
    *a1 = 0;
  }
  else
  {
    if ( v8 )
      v10 = sub_46DC4A(v8, v7);
    else
      v10 = (void *)sub_46D9FD(v7);
    *a1 = (unsigned int)v10;
    if ( !v10 )
    {
      sub_406FF0(pExceptionObject, a2);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
  }
  v11 = v7 + *a1 - a4;
  a1[1] = v7;
  sub_46CAB0(v11, a3, a4);
  return a1[1] - a4;
}

//----- (0040CAD0) --------------------------------------------------------
int __thiscall sub_40CAD0(unsigned int *this, int a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v5; // eax
  bool v6; // zf
  size_t v7; // esi
  void *v8; // eax
  unsigned int v9; // edx
  void *v11; // eax
  _DWORD pExceptionObject[2]; // [esp+Ch] [ebp-8h] BYREF

  v5 = this[1];
  v6 = v5 + a4 == 0;
  v7 = v5 + a4;
  v8 = (void *)*this;
  if ( v6 )
  {
    sub_46D360(*this);
    *this = 0;
  }
  else
  {
    if ( v8 )
      v11 = sub_46DC4A(v8, v7);
    else
      v11 = (void *)sub_46D9FD(v7);
    *this = (unsigned int)v11;
    if ( !v11 )
    {
      sub_406FF0(pExceptionObject, a4);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
  }
  v9 = *this;
  this[1] = v7;
  sub_46CAB0(a4 + v9 + a2, (_BYTE *)(v9 + a2), v7 - a2 - a4);
  sub_46CAB0(a2 + *this, a3, a4);
  return a2;
}

//----- (0040CB70) --------------------------------------------------------
void __userpurge sub_40CB70(unsigned int *a1@<ecx>, int a2@<ebp>, signed int a3, int a4)
{
  size_t v5; // edi
  signed int v6; // eax
  void *v7; // eax
  void *v8; // eax
  void *v9; // eax
  int pExceptionObject; // [esp+2Eh] [ebp-8h] BYREF

  v5 = a3;
  v6 = a1[1];
  if ( a3 < v6 )
  {
    if ( a3 + a4 < v6 )
    {
      sub_46CAB0(a3 + *a1, (_BYTE *)(a3 + *a1 + a4), v6 - a3 - a4);
      v8 = (void *)*a1;
      v5 = a1[1] - a4;
      if ( v5 )
      {
        if ( v8 )
          v9 = sub_46DC4A(v8, v5);
        else
          v9 = (void *)sub_46D9FD(v5);
        *a1 = (unsigned int)v9;
        if ( !v9 )
        {
          sub_406FF0(&pExceptionObject, a2);
          _CxxThrowException(&pExceptionObject, &_TI2_AVmemory_exception__);
        }
        goto LABEL_6;
      }
      sub_46D360(*a1);
    }
    else
    {
      if ( a3 )
      {
        if ( *a1 )
          v7 = sub_46DC4A((void *)*a1, a3);
        else
          v7 = (void *)sub_46D9FD(a3);
        *a1 = (unsigned int)v7;
        if ( !v7 )
        {
          sub_406FF0(&pExceptionObject, a2);
          _CxxThrowException(&pExceptionObject, &_TI2_AVmemory_exception__);
        }
        goto LABEL_6;
      }
      sub_46D360(*a1);
    }
    *a1 = 0;
LABEL_6:
    a1[1] = v5;
  }
}

//----- (0040CFE0) --------------------------------------------------------
int __userpurge sub_40CFE0@<eax>(unsigned int *a1@<ecx>, int a2@<ebp>, char *a3, unsigned __int8 a4)
{
  int v5; // ebp
  void *v6; // eax
  int v7; // edi
  void *v9; // eax
  int v10; // [esp-8h] [ebp-30h]
  size_t v11; // [esp-4h] [ebp-2Ch]
  int v12; // [esp+10h] [ebp-18h] BYREF
  _DWORD pExceptionObject[2]; // [esp+14h] [ebp-14h] BYREF
  int v14; // [esp+24h] [ebp-4h]

  v12 = -1;
  v14 = 0;
  sub_407E80(&v12, a2, a3, 1, 3);
  v5 = sub_408270(&v12);
  v6 = (void *)*a1;
  v7 = v5 + a4;
  if ( v7 )
  {
    v11 = v5 + a4;
    if ( v6 )
      v9 = sub_46DC4A(v6, v11);
    else
      v9 = (void *)sub_46D9FD(v11);
    *a1 = (unsigned int)v9;
    if ( !v9 )
    {
      sub_406FF0(pExceptionObject, v5);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
  }
  else
  {
    sub_46D360(*a1);
    *a1 = 0;
  }
  v10 = *a1;
  a1[1] = v7;
  ReadScrty1FileOffset(&v12, v10, v5);
  if ( a4 )
    *(_BYTE *)(*a1 + v5) = 0;
  v14 = -1;
  return sub_4087F0(&v12);
}

//----- (0040D450) --------------------------------------------------------
int sub_40D450()
{
  return sub_4087F0(&dword_4C1830);
}
// 4C1830: using guessed type int dword_4C1830;

//----- (0040D480) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __thiscall sub_40D480(char *this)
{
  int v2; // eax
  int (__thiscall **v3)(const char *); // ecx
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v8; // [esp-10h] [ebp-D0h] BYREF
  char Buffer[128]; // [esp+Ch] [ebp-B4h] BYREF
  char v10[16]; // [esp+8Ch] [ebp-34h] BYREF
  int v11; // [esp+9Ch] [ebp-24h] BYREF
  unsigned __int16 v12; // [esp+A2h] [ebp-1Eh]
  int v13; // [esp+A4h] [ebp-1Ch]
  int v14; // [esp+A8h] [ebp-18h]
  int v15; // [esp+ACh] [ebp-14h] BYREF
  int v16[4]; // [esp+B0h] [ebp-10h] BYREF

  v2 = dword_4C1A40 - 1;
  v16[0] = (int)&v8;
  if ( dword_4C1A40 )
  {
    v3 = (int (__thiscall **)(const char *))&dword_4C1838[4 * v2];
    while ( *v3 != sub_40D650 )
    {
      v4 = v2--;
      v3 -= 4;
      if ( !v4 )
        goto LABEL_7;
    }
    sub_46CAB0((unsigned int)&dword_4C1838[4 * v2], &byte_4C1848[16 * v2], 16 * (dword_4C1A40 + 0xFFFFFFF * (v2 + 1)));
    --dword_4C1A40;
  }
LABEL_7:
  sub_4087F0(&dword_4C1830);
  v16[3] = 0;
  sub_408020(&dword_4C1830, (int)v16, this, 1, 4);
  sub_408220(&dword_4C1830, 0);
  v15 = 16;
  ((void (*)(void))dword_4A70A4)();
  dword_4A7294(&v11, v10, &v15, v8);
  sprintf_0(
    Buffer,
    "\r\nLogging started (%s) %02d-%02d-%04d %d:%02d:%02d\r\n",
    v10,
    v12,
    HIWORD(v11),
    (unsigned __int16)v11,
    (unsigned __int16)v13,
    HIWORD(v13),
    (unsigned __int16)v14);
  sub_408740(&dword_4C1830, Buffer);
  if ( (unsigned int)dword_4C1A40 < 0x20
    || (v8 = 0, sub_40DCC0((int)v16, aHooksSizeofHoo, (unsigned int)aCSrcIncMiscCpp, (const char *)0x37C, 0)) )
  {
    v5 = 4 * dword_4C1A40;
    v6 = dword_4C1A40 + 1;
    dword_4C1838[v5] = (int)sub_40D650;
    dword_4C183C[v5] = 0;
    dword_4C1840[v5] = 0;
    dword_4C1844[v5] = -1;
    dword_4C1A40 = v6;
  }
  return 1;
}
// 40D63D: positive sp value 10 has been found
// 4A70A4: using guessed type int dword_4A70A4;
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C1830: using guessed type int dword_4C1830;
// 4C1838: using guessed type int dword_4C1838[];
// 4C183C: using guessed type int dword_4C183C[];
// 4C1840: using guessed type int dword_4C1840[];
// 4C1844: using guessed type int dword_4C1844[];
// 4C1A40: using guessed type int dword_4C1A40;

//----- (0040D650) --------------------------------------------------------
int __thiscall sub_40D650(const char *this)
{
  char *v1; // edx
  unsigned int v2; // kr04_4
  unsigned int v3; // ecx
  int v4; // esi
  _BYTE v6[12]; // [esp+0h] [ebp-41Ch] BYREF
  char v7[1024]; // [esp+Ch] [ebp-410h] BYREF
  _BYTE *v8; // [esp+40Ch] [ebp-10h]
  int v9; // [esp+418h] [ebp-4h]

  v1 = (char *)this;
  v8 = v6;
  v2 = strlen(this) + 1;
  v3 = v2 - 1;
  v4 = v2 - 1;
  if ( v2 != 1 && v1[v3 - 1] == 10 && v3 < 0x3FE )
  {
    sub_46CAB0((unsigned int)v7, v1, v2);
    v6[v4 + 11] = 13;
    v7[v4] = 10;
    v7[v4 + 1] = 0;
    v4 = v2;
    v1 = v7;
  }
  v9 = 0;
  return sub_4086E0(&dword_4C1830, (int)v1, v4);
}
// 4C1830: using guessed type int dword_4C1830;

//----- (0040D7E0) --------------------------------------------------------
int __thiscall sub_40D7E0(const char *this)
{
  return sub_46E406("%s", this);
}

//----- (0040D810) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_40D810(char *Format)
{
  int result; // eax
  char *v3; // ebp
  int v4; // edi
  int v5; // eax
  char v6; // al
  char v7; // al
  char *v8; // esi
  char *v9; // ecx
  char i; // al
  int v11; // eax
  char *v12; // ecx
  char j; // al
  va_list v14; // edx
  unsigned int v15; // kr04_4
  bool v16; // al
  unsigned int v17; // ebx
  int *v18; // esi
  int v19; // [esp-Ch] [ebp-41Ch]
  int v20; // [esp-8h] [ebp-418h]
  int v21; // [esp-4h] [ebp-414h]
  int v22; // [esp+Ch] [ebp-404h] BYREF
  int v23; // [esp+10h] [ebp-400h]
  va_list ArgList; // [esp+14h] [ebp-3FCh]
  int v25; // [esp+1Ch] [ebp-3F4h] BYREF
  va_list v26; // [esp+20h] [ebp-3F0h]
  unsigned __int16 v27; // [esp+24h] [ebp-3ECh]
  char v28; // [esp+27h] [ebp-3E9h]
  char Buffer[1000]; // [esp+28h] [ebp-3E8h] BYREF

  result = dword_4C1A40;
  if ( dword_4C1A40 )
  {
    v3 = (char *)&v25;
    v4 = 1000;
    if ( byte_4C1A44 && byte_4B80F0 )
    {
      dword_4A7294(&v22, v19, v20, v21);
      v5 = sprintf_0(Buffer, "%02d:%02d:%02d ", (unsigned __int16)v26, HIWORD(v26), v27);
      v4 = 1000 - v5;
      v3 = &Buffer[v5];
    }
    v6 = *Format;
    v23 = 1;
    if ( v6 == 60 )
    {
      v7 = Format[1];
      v8 = Format + 1;
      if ( v7 >= 48 && v7 <= 57 )
      {
        v9 = Format + 1;
        for ( i = *v8; i >= 48; i = *++v9 )
        {
          if ( i > 57 )
            break;
        }
        if ( *v9 == 62 )
        {
          v11 = sub_46D80E(Format + 1);
          v12 = Format + 1;
          v23 = v11;
          for ( j = *v8; j >= 48; j = *++v12 )
          {
            if ( j > 57 )
              break;
          }
          Format = v12 + 1;
        }
      }
    }
    if ( v4 )
    {
      v14 = ArgList;
      v3[v4 - 1] = 0;
      _vsnprintf(v3, v4 - 1, Format, v14);
    }
    v15 = strlen(Buffer) + 1;
    if ( v15 - 1 >= 0x3E7 )
      Buffer[998] = 10;
    v16 = v15 != 1 && *(&v28 + v15 - 1) == 10;
    byte_4B80F0 = v16;
    result = dword_4C1A40;
    v17 = 0;
    if ( dword_4C1A40 )
    {
      v18 = &dword_4C183C;
      do
      {
        if ( (!*v18 || !_memicmp(v3, (const void *)*v18, strlen((const char *)*v18))) && (v18[2] & v23) != 0 )
          ((void (__fastcall *)(char *, int))*(v18 - 1))(Buffer, v18[1]);
        result = dword_4C1A40;
        ++v17;
        v18 += 4;
      }
      while ( v17 < dword_4C1A40 );
    }
  }
  return result;
}
// 40D992: positive sp value C has been found
// 40D84D: variable 'v19' is possibly undefined
// 40D84D: variable 'v20' is possibly undefined
// 40D84D: variable 'v21' is possibly undefined
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4B80F0: using guessed type char byte_4B80F0;
// 4C183C: using guessed type int dword_4C183C;
// 4C1A40: using guessed type int dword_4C1A40;
// 4C1A44: using guessed type char byte_4C1A44;

//----- (0040DA80) --------------------------------------------------------
int __cdecl sub_40DA80(char *a1)
{
  return sub_40D810(a1);
}

//----- (0040DAA0) --------------------------------------------------------
#error "40DAB5: call analysis failed (funcsize=10)"

//----- (0040DAC0) --------------------------------------------------------
void __noreturn sub_40DAC0(char *Format, ...)
{
  char pExceptionObject[308]; // [esp+0h] [ebp-934h] BYREF
  char Buffer[2048]; // [esp+134h] [ebp-800h] BYREF
  va_list va; // [esp+93Ch] [ebp+8h] BYREF

  va_start(va, Format);
  Buffer[2047] = 0;
  _vsnprintf(Buffer, 0x7FFu, Format, va);
  sub_40DA80(aS_1);
  if ( dword_4C1A48 )
  {
    sub_40DE60((int *)dword_4C1A48);
    dword_4C1A48 = 0;
  }
  sub_4073D0((int)pExceptionObject, "%s", Buffer);
  _CxxThrowException(pExceptionObject, &_TI2_AVtext_exception__);
}
// 4C1A48: using guessed type int dword_4C1A48;

//----- (0040DB50) --------------------------------------------------------
const char **sub_40DB50(const char **a1, const char *Format, ...)
{
  unsigned int v2; // kr04_4
  int v3; // eax
  unsigned int v4; // ecx
  char *v5; // edi
  unsigned int v6; // edx
  unsigned int v7; // kr08_4
  unsigned int v8; // kr0C_4
  const char *v9; // eax
  _DWORD pExceptionObject[2]; // [esp+Ch] [ebp-814h] BYREF
  char Buffer[2048]; // [esp+14h] [ebp-80Ch] BYREF
  int v13; // [esp+81Ch] [ebp-4h]
  va_list ArgList; // [esp+82Ch] [ebp+Ch] BYREF

  va_start(ArgList, Format);
  *a1 = 0;
  v13 = 0;
  Buffer[2047] = 0;
  _vsnprintf(Buffer, 0x7FFu, Format, ArgList);
  if ( *a1 )
  {
    v7 = strlen(*a1) + 1;
    v8 = strlen(Buffer) + 1;
    v9 = (const char *)sub_46DC4A((void *)*a1, v8 + v7 - 1);
    *a1 = v9;
    if ( !v9 )
    {
      sub_406FF0(pExceptionObject, (int)a1);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
    v9[v8 - 2 + v7] = 0;
    v6 = strlen(Buffer) + 1;
    v5 = (char *)&(*a1)[strlen(*a1)];
    v4 = v6;
    goto LABEL_10;
  }
  if ( Buffer )
  {
    v2 = strlen(Buffer) + 1;
    v3 = sub_46D9FD(v2 - 1 + 2);
    *a1 = (const char *)v3;
    if ( !v3 )
    {
      sub_406FF0(pExceptionObject, (int)a1);
      _CxxThrowException(pExceptionObject, &_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v3 + v2) = 0;
    v4 = strlen(Buffer) + 1;
    v5 = (char *)*a1;
    LOBYTE(v6) = v4;
LABEL_10:
    qmemcpy(v5, Buffer, 4 * (v4 >> 2) + (v6 & 3));
    return a1;
  }
  sub_46D360((unsigned int)Buffer);
  *a1 = 0;
  return a1;
}

//----- (0040DCC0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_40DCC0@<al>(int a1@<ebp>, const char *a2, unsigned int a3, const char *a4, char a5)
{
  const char *v5; // eax
  _DWORD v7[2]; // [esp-8h] [ebp-8h] BYREF
  const char *retaddr; // [esp+0h] [ebp+0h]

  if ( a5 )
  {
    v7[0] = v7[1];
    if ( dword_4C1A4C )
      ((void (__cdecl *)(_DWORD))dword_4C1A4C)(v7[0]);
  }
  v7[0] = a1;
  sub_40DB50(&a3, "ASSERTFAILURE(%s) in %s(%u)", retaddr, a2, a3);
  if ( a4 )
    sub_40C890((const char **)&a3, ": %s", a4);
  if ( a5 )
  {
    dword_4C1A48 = (int)v7;
    v5 = (const char *)a3;
    if ( !a3 )
      v5 = (const char *)&unk_4A7DB0;
    sub_40DAC0("%s", v5);
  }
  sub_40DA80(aS_1);
  sub_46D360(a3);
  return 0;
}
// 40DCC8: positive sp value 4 has been found
// 40DCC0: could not find valid save-restore pair for ebp
// 40DB50: using guessed type _DWORD sub_40DB50(_DWORD, const char *Format, ...);
// 4C1A48: using guessed type int dword_4C1A48;
// 4C1A4C: using guessed type int dword_4C1A4C;

//----- (0040DD92) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40DD92(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // ecx
  unsigned int v6; // esi
  int v7; // ebx
  unsigned int v9; // ecx
  unsigned int v10; // eax
  _BYTE *v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  char v15; // dl
  int v16; // [esp+8h] [ebp-4h]
  int v17; // [esp+14h] [ebp+8h]

  v5 = a3;
  v6 = 1790562961 * a4 + 985938188;
  v7 = 0;
  v16 = a1;
  v17 = 0;
  if ( a3 > 1 )
  {
    do
    {
      v9 = v5 - v7;
      v6 = 69069 * v6 + 17009;
      if ( v9 > 0x10001 )
        v10 = v6 / (0xFFFFFFFF / (v9 - 1) + 1);
      else
        v10 = (v9 * HIWORD(v6)) >> 16;
      v11 = (_BYTE *)(a1 + a2 * v10);
      if ( a2 )
      {
        v12 = a1;
        v13 = a2;
        v14 = v12 - (_DWORD)v11;
        do
        {
          v15 = v11[v14];
          v11[v14] = *v11;
          *v11++ = v15;
          --v13;
        }
        while ( v13 );
        a1 = v16;
        v7 = v17;
      }
      v5 = a3;
      ++v7;
      a1 += a2;
      v17 = v7;
      v16 = a1;
    }
    while ( v7 + 1 < a3 );
  }
}
// 40DE53: positive sp value 8 has been found
// 40DD92: could not find valid save-restore pair for ebx

//----- (0040DE60) --------------------------------------------------------
int __thiscall sub_40DE60(int *this)
{
  char *v2; // ebp
  int (__stdcall *v3)(int *, int); // esi
  int result; // eax
  int v5; // eax
  unsigned int v6; // [esp+14h] [ebp-58h]
  char Buffer[84]; // [esp+18h] [ebp-54h] BYREF

  v2 = Buffer;
  sub_40DA80(aStackDump);
  v3 = (int (__stdcall *)(int *, int))dword_4A7280;
  v6 = 0;
  result = dword_4A7280(this, 4);
  if ( !result )
  {
    do
    {
      if ( v6 >= 0x1000 )
        break;
      if ( !v3(this, 12) )
      {
        result = 7707;
        if ( *this == 7707 && this[1] == 7707 && this[2] == 7707 )
          break;
      }
      if ( (v6 & 7) == 0 )
      {
        if ( v2 > Buffer )
        {
          strcpy(v2, asc_4A8DE0);
          sub_40DA80(Buffer);
          v3 = (int (__stdcall *)(int *, int))dword_4A7280;
          v2 = Buffer;
        }
        sprintf_0(v2, "%08x:", this);
        v2 += strlen(v2);
      }
      v5 = *this++;
      sprintf_0(v2, " %08x", v5);
      v2 += strlen(v2);
      ++v6;
      result = v3(this, 4);
    }
    while ( !result );
    if ( v2 > Buffer )
    {
      strcpy(v2, asc_4A8DE0);
      result = sub_40DA80(Buffer);
    }
  }
  return result;
}
// 4A7280: using guessed type int (__stdcall *dword_4A7280)(_DWORD, _DWORD);

//----- (0040E2E0) --------------------------------------------------------
int __userpurge sub_40E2E0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax
  int v5; // esi
  void *v6; // ebx
  int v7; // esi
  int v9[101]; // [esp+Ch] [ebp-194h] BYREF

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 >= *(_DWORD *)(a1 + 4) )
  {
    if ( v4 >= 8 )
      v5 = v4 >= 32 ? 32 : 8;
    else
      v5 = 4;
    sub_40B780(404 * (v5 + v4), (void **)a1, a2);
    *(_DWORD *)(a1 + 4) += v5;
  }
  sub_46CAB0(
    *(_DWORD *)a1 + 4 * (a3 + 20 * (5 * a3 + 5) + 1),
    (_BYTE *)(*(_DWORD *)a1 + 404 * a3),
    404 * *(_DWORD *)(a1 + 8) - 404 * a3);
  v6 = *(void **)a1;
  ++*(_DWORD *)(a1 + 8);
  v9[0] = -1;
  sub_46CAB0((unsigned int)v6 + 404 * a3, v9, 0x194u);
  v7 = *(_DWORD *)a1 + 404 * a3;
  sub_4077D0(v9);
  return v7;
}

//----- (0040E440) --------------------------------------------------------
void __thiscall sub_40E440(int *this)
{
  int v2; // esi

  sub_40B7E0(this[6]);
  v2 = *this;
  if ( v2 != -1 )
    dword_4A73AC(v2);
}
// 4A73AC: using guessed type int (__stdcall *dword_4A73AC)(_DWORD);

//----- (0040E950) --------------------------------------------------------
char __thiscall sub_40E950(int *this, int *a2)
{
  int v3; // eax
  void (*v4)(void); // edi
  char result; // al
  void (*v6)(void); // edi
  _DWORD *v7; // edi
  int v8; // ecx
  void (*v9)(void); // edi
  int v10; // eax
  int v11; // eax
  int v12; // [esp-8h] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-14h] BYREF
  int v14; // [esp+14h] [ebp-10h] BYREF
  int v15; // [esp+18h] [ebp-Ch]
  int v16; // [esp+1Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp-4h]

  if ( *this == -1 && (v3 = dword_4A73FC(2, 1, 0), *this = v3, v3 == -1) )
  {
    v4 = (void (*)(void))dword_4A7408;
    this[2] = dword_4A7408();
    v4();
    sub_40DA80(aSocketSErrorD);
    if ( this[2] == 10024 )
      this[1] = 3;
    else
      this[1] = 6;
    result = 0;
  }
  else
  {
    v12 = *this;
    v13 = 1;
    if ( dword_4A7404(v12, -2147195266, &v13) )
    {
      v6 = (void (*)(void))dword_4A7408;
      this[2] = dword_4A7408();
      this[1] = 6;
      v6();
      sub_40DA80(aSocketSErrorD);
      result = 0;
    }
    else
    {
      v7 = (_DWORD *)this[6];
      this[3] = *a2;
      this[4] = a2[1];
      if ( !v7 )
        v7 = this + 3;
      v14 = 2;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v15 = dword_4A73B0(*v7);
      LOWORD(v8) = *((_WORD *)v7 + 2);
      HIWORD(v14) = dword_4A7410(v8);
      if ( dword_4A73F4(*this, &v14, 16) != -1
        || (v9 = (void (*)(void))dword_4A7408, v10 = dword_4A7408(), v10 == 10035) )
      {
        this[5] = 1;
        result = 1;
      }
      else
      {
        this[2] = v10;
        v9();
        sub_40DA80(aSocketSErrorD);
        v11 = this[2];
        if ( v11 == 10061 || v11 == 10051 )
        {
          if ( this[6] )
            this[1] = 4;
          else
            this[1] = 1;
          this[5] = 0;
          result = 0;
        }
        else
        {
          this[1] = 6;
          this[5] = 0;
          result = 0;
        }
      }
    }
  }
  return result;
}
// 40EA54: variable 'v8' is possibly undefined
// 4A73B0: using guessed type int (__stdcall *dword_4A73B0)(_DWORD);
// 4A73F4: using guessed type int (__stdcall *dword_4A73F4)(_DWORD, _DWORD, _DWORD);
// 4A73FC: using guessed type int (__stdcall *dword_4A73FC)(_DWORD, _DWORD, _DWORD);
// 4A7404: using guessed type int (__stdcall *dword_4A7404)(_DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);
// 4A7410: using guessed type int (__stdcall *dword_4A7410)(_DWORD);

//----- (0040EED0) --------------------------------------------------------
int __thiscall sub_40EED0(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v5; // ebx
  void (*v6)(void); // edi
  int v7; // eax
  int v8; // eax

  v3 = a3;
  if ( a3 > 2048 )
    v3 = 2048;
  v5 = dword_4A73E0(*this, a2, v3, 0);
  if ( v5 >= 0 )
    return v5;
  v6 = (void (*)(void))dword_4A7408;
  v7 = dword_4A7408();
  this[2] = v7;
  if ( v7 == 10004 || v7 == 10035 )
    return 0;
  if ( v7 != 10053 && v7 != 10054 )
  {
    v6();
    sub_40DA80(aSocketSErrorD);
  }
  v8 = this[2];
  if ( v8 != 10050 && v8 != 10052 && v8 != 10065 && v8 != 10053 && v8 != 10054 && v8 != 10060 )
  {
    this[1] = 6;
    return v5;
  }
  this[1] = 1;
  return v5;
}
// 4A73E0: using guessed type int (__stdcall *dword_4A73E0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);

//----- (0040F0D0) --------------------------------------------------------
int *__thiscall sub_40F0D0(int *this, void *src)
{
  char *v3; // eax
  char *v4; // edi
  char *v5; // eax
  char v6; // al
  unsigned int v7; // eax
  _BYTE *v8; // eax
  int v9; // eax
  int v10; // eax
  _BYTE *v12; // [esp-8h] [ebp-94h]
  char v13[4]; // [esp+8h] [ebp-84h] BYREF
  char Str[128]; // [esp+Ch] [ebp-80h] BYREF

  strncpyt(Str, src, 128);
  v3 = strchr(Str, 58);
  v4 = v3;
  if ( !v3 )
    goto LABEL_10;
  v5 = sub_40BCF0(v3 + 1);
  this[1] = sub_46D80E(v5);
  if ( sub_40BCF0(Str) == v4 )
    goto LABEL_10;
  v6 = *sub_40BCF0(v4 + 1);
  if ( v6 < 48 )
    goto LABEL_10;
  if ( v6 > 57 )
    goto LABEL_10;
  v7 = this[1];
  if ( !v7 || v7 > 0xFFFF )
    goto LABEL_10;
  *v4 = 0;
  sub_40BD10(Str);
  v8 = sub_40BCF0(Str);
  v9 = dword_4A73D4(v8);
  *this = v9;
  if ( v9 == -1 )
  {
    v12 = sub_40BCF0(v13);
    v10 = dword_4A73D8();
    if ( !v10 )
    {
      dword_4A7408();
      sub_40DA80(aSocketSErrorD);
LABEL_10:
      this[1] = 0;
      *this = 0;
      return this;
    }
    *this = ***(_DWORD ***)(v10 + 12);
  }
  *this = dword_4A73B4(*this, v12);
  return this;
}
// 40F1BF: variable 'v12' is possibly undefined
// 4A73B4: using guessed type int (__stdcall *dword_4A73B4)(_DWORD, _DWORD);
// 4A73D4: using guessed type int (__cdecl *dword_4A73D4)(_DWORD);
// 4A73D8: using guessed type int (*dword_4A73D8)(void);
// 4A7408: using guessed type int (*dword_4A7408)(void);

//----- (0040F3C0) --------------------------------------------------------
int __fastcall sub_40F3C0(int **a1, int a2, unsigned int a3)
{
  unsigned int v3; // edi
  unsigned int v5; // ebp
  int **v6; // esi
  int *v7; // ebx
  unsigned int v8; // eax
  int *v9; // ecx
  unsigned int v10; // eax
  int *v11; // ecx
  unsigned int v12; // eax
  int *v13; // ecx
  unsigned int v14; // ebp
  int v15; // esi
  bool v16; // cc
  int (*v17)(void); // edi
  int v18; // esi
  int v19; // edi
  char v20; // bl
  int v21; // ebp
  _DWORD *v22; // esi
  int *v23; // esi
  int v24; // edi
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int **v28; // [esp+14h] [ebp-301Ch]
  _DWORD v30[2]; // [esp+1Ch] [ebp-3014h] BYREF
  unsigned int v31; // [esp+24h] [ebp-300Ch] BYREF
  int v32[1024]; // [esp+28h] [ebp-3008h] BYREF
  int v33; // [esp+1028h] [ebp-2008h] BYREF
  int v34[1024]; // [esp+102Ch] [ebp-2004h] BYREF
  int v35; // [esp+202Ch] [ebp-1004h] BYREF
  int v36[1024]; // [esp+2030h] [ebp-1000h] BYREF

  v28 = a1;
  v3 = 0;
  if ( !a2 )
  {
    dword_4A72B4(a3);
    return 0;
  }
  v5 = 0;
  v31 = 0;
  v33 = 0;
  v35 = 0;
  v6 = a1;
  v30[0] = a2;
  do
  {
    v7 = v6[2];
    if ( ((unsigned __int8)v7 & 1) != 0 )
    {
      v8 = 0;
      if ( v31 )
      {
        v9 = v32;
        do
        {
          if ( *v9 == **v6 )
            break;
          ++v8;
          ++v9;
        }
        while ( v8 < v31 );
      }
      if ( v8 == v31 && v31 < 0x400 )
      {
        v32[v8] = **v6;
        ++v31;
      }
    }
    if ( ((unsigned __int8)v7 & 2) != 0 )
    {
      v10 = 0;
      if ( v5 )
      {
        v11 = v34;
        do
        {
          if ( *v11 == **v6 )
            break;
          ++v10;
          ++v11;
        }
        while ( v10 < v5 );
      }
      if ( v10 == v5 && v5 < 0x400 )
      {
        v34[v10] = **v6;
        v5 = ++v33;
      }
    }
    if ( ((unsigned __int8)v7 & 4) != 0 )
    {
      v12 = 0;
      if ( v3 )
      {
        v13 = v36;
        do
        {
          if ( *v13 == **v6 )
            break;
          ++v12;
          ++v13;
        }
        while ( v12 < v3 );
      }
      if ( v12 == v3 && v3 < 0x400 )
      {
        v36[v12] = **v6;
        v3 = ++v35;
      }
    }
    v6 += 3;
    --v30[0];
  }
  while ( v30[0] );
  v14 = a3;
  v30[0] = a3 / 0x3E8;
  v30[1] = 1000 * (a3 % 0x3E8);
  v15 = dword_4A73C8(1, &v31, &v33, &v35, v30);
  v16 = v15 <= 0;
  if ( v15 < 0 )
  {
    v17 = dword_4A7408;
    if ( dword_4A7408() != 10004 && v17() != 10035 )
    {
      v18 = dword_4A7098();
      if ( v18 - dword_4C1A54 >= 2000 )
        dword_4C1A58 = 0;
      if ( a2 == 1 )
      {
        if ( dword_4C1A58 < 20 )
        {
          ((void (__cdecl *)(int))v17)(**v28);
          sub_40DA80(aSocketSelectEr);
          dword_4C1A54 = v18;
          ++dword_4C1A58;
        }
        v28[2] = (int *)4;
        return 1;
      }
      v19 = 0;
      v20 = 1;
      if ( a2 )
      {
        v21 = a2;
        v22 = v28 + 2;
        do
        {
          if ( (int)sub_40F3C0(0) <= 0 )
          {
            *v22 = 0;
          }
          else
          {
            v19 = 1;
            if ( *v22 != 4 )
              v20 = 0;
          }
          v22 += 3;
          --v21;
        }
        while ( v21 );
        if ( !v20 )
          return v19;
        v14 = a3;
      }
      dword_4A72B4(v14);
      return v19;
    }
    v16 = v15 <= 0;
  }
  if ( v16 )
    return v15;
  v23 = (int *)(v28 + 2);
  v24 = a2;
  do
  {
    if ( (*(_BYTE *)v23 & 1) != 0 && !sub_459A2C(*(_DWORD *)*(v23 - 2), &v31) )
    {
      v25 = *v23;
      LOBYTE(v25) = *v23 & 0xFE;
      *v23 = v25;
    }
    if ( (*(_BYTE *)v23 & 2) != 0 && !sub_459A2C(*(_DWORD *)*(v23 - 2), &v33) )
    {
      v26 = *v23;
      LOBYTE(v26) = *v23 & 0xFD;
      *v23 = v26;
    }
    if ( (*(_BYTE *)v23 & 4) != 0 && !sub_459A2C(*(_DWORD *)*(v23 - 2), &v35) )
    {
      v27 = *v23;
      LOBYTE(v27) = *v23 & 0xFB;
      *v23 = v27;
    }
    v23 += 3;
    --v24;
  }
  while ( v24 );
  return 1;
}
// 459A2C: using guessed type int __stdcall sub_459A2C(_DWORD, _DWORD);
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A72B4: using guessed type int (__stdcall *dword_4A72B4)(_DWORD);
// 4A73C8: using guessed type int (__stdcall *dword_4A73C8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);
// 4C1A54: using guessed type int dword_4C1A54;
// 4C1A58: using guessed type int dword_4C1A58;

//----- (0040F700) --------------------------------------------------------
bool __thiscall sub_40F700(int *this, int a2, char a3, int a4)
{
  int v4; // eax
  int v6; // edx
  int v7; // eax
  int v9; // eax
  void (*v10)(void); // edi
  void (*v11)(void); // edi
  void (__stdcall *v12)(int, int, int, int *, int); // edi
  unsigned int v13; // edi
  int v14; // eax
  int v15; // eax
  int v16; // [esp+18h] [ebp-28h]
  int v17; // [esp+18h] [ebp-28h]
  int v18; // [esp+2Ch] [ebp-14h] BYREF
  int v19[4]; // [esp+30h] [ebp-10h] BYREF

  v4 = a2;
  this[3] = *(_DWORD *)a2;
  v6 = *(_DWORD *)(v4 + 4);
  v7 = this[22];
  this[4] = v6;
  if ( v7 )
  {
    *((_BYTE *)this + 20) = this[3] == 0;
    return *(_DWORD *)(v7 + 20) == 9;
  }
  if ( *this != -1 || (v9 = dword_4A73FC(2, 2, 0), *this = v9, v9 != -1) )
  {
    if ( !(_BYTE)a4 )
    {
      v16 = *this;
      a4 = 1;
      if ( dword_4A7404(v16, -2147195266, &a4) )
      {
        v11 = (void (*)(void))dword_4A7408;
        this[2] = dword_4A7408();
        this[1] = 6;
        v11();
        sub_40DA80(aSocketSErrorD);
        return 0;
      }
    }
    v12 = (void (__stdcall *)(int, int, int, int *, int))dword_4A7400;
    a2 = 0x10000;
    v18 = 0x10000;
    dword_4A7400(*this, 0xFFFF, 4097, &a2, 4);
    v12(*this, 0xFFFF, 4098, &v18, 4);
    v13 = ((unsigned int)this + 37) & 0xFFFFFFF0;
    *(_DWORD *)v13 = 0;
    *(_DWORD *)(v13 + 4) = 0;
    *(_DWORD *)(v13 + 8) = 0;
    *(_DWORD *)(v13 + 12) = 0;
    *(_WORD *)v13 = 2;
    v14 = dword_4A73B0(this[3]);
    *(_DWORD *)(v13 + 4) = v14;
    LOWORD(v14) = *((_WORD *)this + 8);
    *(_WORD *)(v13 + 2) = dword_4A7410(v14);
    if ( !this[3] || a3 )
    {
      v17 = *this;
      *((_BYTE *)this + 20) = 1;
      if ( dword_4A73F8(v17, ((unsigned int)this + 37) & 0xFFFFFFF0, 16) < 0 )
        goto LABEL_15;
    }
    else
    {
      v15 = *this;
      HIWORD(v19[0]) = 0;
      v19[1] = 0;
      v19[2] = 0;
      *((_BYTE *)this + 20) = 0;
      v19[3] = 0;
      LOWORD(v19[0]) = 2;
      if ( dword_4A73F8(v15, v19, 16) < 0 )
      {
LABEL_15:
        dword_4A7408();
        sub_40DA80(aSocketSErrorD);
        return 0;
      }
    }
    return 1;
  }
  v10 = (void (*)(void))dword_4A7408;
  this[2] = dword_4A7408();
  v10();
  sub_40DA80(aSocketSErrorD);
  if ( this[2] == 10024 )
    this[1] = 3;
  else
    this[1] = 6;
  return 0;
}
// 4A73F8: invalid function type has been ignored
// 4A73B0: using guessed type int (__stdcall *dword_4A73B0)(_DWORD);
// 4A73F8: using guessed type int (__stdcall *dword_4A73F8)(_DWORD, _DWORD, _DWORD);
// 4A73FC: using guessed type int (__stdcall *dword_4A73FC)(_DWORD, _DWORD, _DWORD);
// 4A7400: using guessed type int (__stdcall *dword_4A7400)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7404: using guessed type int (__stdcall *dword_4A7404)(_DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);
// 4A7410: using guessed type int (__stdcall *dword_4A7410)(_DWORD);

//----- (0040F920) --------------------------------------------------------
int __userpurge sub_40F920@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax

  *(_DWORD *)(a1 + 88) = a3;
  if ( *(_DWORD *)a1 != -1 )
    sub_40DCC0(a2, aFd1, (unsigned int)aCSrcIncSocketC, (const char *)0x38D, 0);
  v4 = *(_DWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 21) = 1;
  if ( v4
    && (*(_DWORD *)(v4 + 28) || sub_40DCC0(a2, aSocksUdpsock, (unsigned int)aCSrcIncSocketC, (const char *)0x38F, 0)) )
  {
    *(_DWORD *)a1 = **(_DWORD **)(*(_DWORD *)(a1 + 88) + 28);
  }
  return nullsub_4(a3);
}
// 40F988: using guessed type int __stdcall nullsub_4(int);

//----- (0040F990) --------------------------------------------------------
char __thiscall sub_40F990(_DWORD *this, int a2, int a3)
{
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  char result; // al
  int (*v8)(void); // edi

  v4 = this[22];
  if ( !v4 )
  {
    if ( dword_4A73C4(*this, a2, a3, 0, ((unsigned int)this + 37) & 0xFFFFFFF0, 16) < 0 )
    {
      v8 = dword_4A7408;
      this[1] = 6;
      this[2] = v8();
      v8();
      sub_40DA80(aSocketSErrorD);
      return 0;
    }
    return 1;
  }
  if ( ((unsigned __int8 (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD))((char *)&byte_410001 + 687))(
         v4,
         a2,
         a3,
         this + 3) )
  {
    return 1;
  }
  v5 = this[22];
  this[1] = 6;
  v6 = *(_DWORD *)(v5 + 28);
  if ( v6 )
  {
    this[2] = *(_DWORD *)(v6 + 8);
    result = 0;
  }
  else
  {
    result = 0;
    this[2] = 0;
  }
  return result;
}
// 4A73C4: using guessed type int (__stdcall *dword_4A73C4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);

//----- (0040FB20) --------------------------------------------------------
int __thiscall sub_40FB20(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  char v7; // al
  unsigned int v8; // edi
  int v9; // esi
  _DWORD *v10; // ebx
  int v11; // ecx
  unsigned __int16 v12; // ax
  int v13; // eax
  __int16 v14; // cx
  int v15; // edx
  int v16; // [esp+6h] [ebp-1024h]
  int v17; // [esp+12h] [ebp-1018h] BYREF
  int v18; // [esp+16h] [ebp-1014h] BYREF
  int v19; // [esp+1Ah] [ebp-1010h]
  int v20; // [esp+26h] [ebp-1004h] BYREF
  int v21; // [esp+2Ah] [ebp-1000h]

  if ( !this[22] )
  {
    if ( a5 )
    {
      v21 = *this;
      v20 = 1;
      v19 = 1000 * (_DWORD)a5;
      v18 = 0;
      if ( dword_4A73C8(v21 + 1, &v20, 0, 0, &v18) <= 0 )
        return 0;
    }
    v7 = *((_BYTE *)this + 20);
    v8 = ((unsigned int)this + 37) & 0xFFFFFFF0;
    v17 = 16;
    if ( v7 )
    {
      v9 = dword_4A73C0(*this, a2, a3, 0, ((unsigned int)this + 37) & 0xFFFFFFF0, &v17);
      if ( v9 > 0 )
      {
        v10 = a5;
        *a5 = dword_4A73B4(*(_DWORD *)(v8 + 4), v16);
        LOWORD(v11) = *(_WORD *)(v8 + 2);
        v12 = dword_4A740C(v11);
LABEL_15:
        v10[1] = v12;
        return v9;
      }
    }
    else
    {
      v13 = dword_4A73C0(*this, a2, a3, 0, &v18, &v17);
      v14 = *(_WORD *)((((unsigned int)this + 37) & 0xFFFFFFF0) + 2);
      v9 = v13;
      if ( v14 == HIWORD(v18) && *(_DWORD *)(v8 + 4) == v19 && v13 > 0 )
      {
        v10 = a5;
        *a5 = dword_4A73B4(*(_DWORD *)(v8 + 4), v16);
        LOWORD(v15) = *(_WORD *)(v8 + 2);
        v12 = dword_4A740C(v15);
        goto LABEL_15;
      }
    }
    return 0;
  }
  if ( *((_BYTE *)this + 20) )
  {
    a4[1] = 0;
    *a4 = 0;
  }
  return ((int (__thiscall *)(_DWORD, int, int, _DWORD *, _DWORD *))((char *)&byte_410001 + 863))(
           this[22],
           a2,
           a3,
           a4,
           a5);
}
// 40FC08: variable 'v16' is possibly undefined
// 40FC1C: variable 'v11' is possibly undefined
// 40FC7A: variable 'v15' is possibly undefined
// 410001: using guessed type int __thiscall byte_410001(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A73B4: using guessed type int (__stdcall *dword_4A73B4)(_DWORD, _DWORD);
// 4A73C0: using guessed type int (__stdcall *dword_4A73C0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A73C8: using guessed type int (__stdcall *dword_4A73C8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A740C: using guessed type int (__cdecl *dword_4A740C)(_DWORD);

//----- (0040FD30) --------------------------------------------------------
int __thiscall sub_40FD30(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // esi
  int v4; // eax
  int result; // eax

  this[3] = *a2;
  v3 = ((unsigned int)this + 37) & 0xFFFFFFF0;
  this[4] = a2[1];
  *(_DWORD *)v3 = 0;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_WORD *)v3 = 2;
  v4 = dword_4A73B0(this[3]);
  *(_DWORD *)(v3 + 4) = v4;
  LOWORD(v4) = *((_WORD *)this + 8);
  result = dword_4A7410(v4);
  *(_WORD *)(v3 + 2) = result;
  return result;
}
// 4A73B0: using guessed type int (__stdcall *dword_4A73B0)(_DWORD);
// 4A7410: using guessed type int (__stdcall *dword_4A7410)(_DWORD);

//----- (0040FD80) --------------------------------------------------------
int __thiscall sub_40FD80(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 && !*((_BYTE *)this + 21) )
    result = dword_4A73AC(result);
  *this = -1;
  return result;
}
// 4A73AC: using guessed type int (__stdcall *dword_4A73AC)(_DWORD);

//----- (0040FDA0) --------------------------------------------------------
char __thiscall sub_40FDA0(int *this, _DWORD *a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  char result; // al
  void (*v7)(void); // edi
  int v8; // eax
  int v9; // esi
  int v10; // [esp-2h] [ebp-20h]
  int v11; // [esp+Ah] [ebp-14h]
  char v12[4]; // [esp+Eh] [ebp-10h] BYREF
  _DWORD v13[3]; // [esp+12h] [ebp-Ch]

  v4 = this[22];
  if ( !v4 || (_BYTE)a3 )
  {
    v10 = *this;
    a3 = 16;
    if ( dword_4A73EC(v10, v12, &a3) )
    {
      v7 = (void (*)(void))dword_4A7408;
      this[2] = dword_4A7408();
      this[1] = 6;
      v7();
      sub_40DA80(aSocketSErrorD);
      result = 0;
    }
    else
    {
      v8 = dword_4A73B4(v13[0], v11);
      v9 = a3;
      *(_DWORD *)a3 = v8;
      *(_DWORD *)(v9 + 4) = (unsigned __int16)dword_4A740C(*(_DWORD *)((char *)v13 + 2));
      result = 1;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v4 + 24);
    *a2 = *(_DWORD *)(v5 + 288);
    a2[1] = *(_DWORD *)(v5 + 292);
    result = 1;
  }
  return result;
}
// 40FE2C: variable 'v11' is possibly undefined
// 4A73B4: using guessed type int (__stdcall *dword_4A73B4)(_DWORD, _DWORD);
// 4A73EC: using guessed type int (__stdcall *dword_4A73EC)(_DWORD, _DWORD, _DWORD);
// 4A7408: using guessed type int (*dword_4A7408)(void);
// 4A740C: using guessed type int (__cdecl *dword_4A740C)(_DWORD);

//----- (0040FE60) --------------------------------------------------------
_DWORD *__thiscall sub_40FE60(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[3] = 0;
  *this = -1;
  this[1] = 0;
  this[2] = 0;
  this[22] = 0;
  *((_BYTE *)this + 21) = 0;
  return result;
}

//----- (0040FE80) --------------------------------------------------------
char __thiscall sub_40FE80(_BYTE *this)
{
  char result; // al

  if ( *(_DWORD *)this != -1 && !this[21] )
    dword_4A73AC(*(_DWORD *)this);
  result = this[21];
  *(_DWORD *)this = -1;
  if ( result )
    *(_DWORD *)this = -1;
  return result;
}
// 4A73AC: using guessed type int (__stdcall *dword_4A73AC)(_DWORD);

//----- (00410990) --------------------------------------------------------
char __thiscall sub_410990(_DWORD *this, char a2)
{
  int v3; // eax
  int v4; // eax
  char result; // al
  int v6; // eax
  char v7; // cl
  int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  char v14; // al
  char *v15; // ebx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  char v19; // al
  unsigned __int16 v20; // ax
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  unsigned int i; // esi
  char *v26; // eax
  int v27; // eax
  int v28; // edx
  unsigned int j; // esi
  char *v30; // eax
  int v31; // eax
  unsigned int m; // esi
  char *v33; // eax
  int v34; // eax
  int v35; // edx
  unsigned int k; // esi
  char *v37; // eax
  int v38; // eax
  unsigned __int8 v39; // bl
  unsigned int l; // esi
  char *v41; // eax
  int v42; // edx
  int v43; // [esp-4h] [ebp-98h]
  int v44; // [esp-4h] [ebp-98h]
  int v45; // [esp-4h] [ebp-98h]
  int v46; // [esp-4h] [ebp-98h]
  int v47; // [esp-4h] [ebp-98h]
  char Str[128]; // [esp+14h] [ebp-80h] BYREF

  v3 = this[5];
  if ( v3 == 9 )
    return 1;
  if ( v3 == 1 )
  {
    if ( (a2 & 4) != 0 )
    {
      v4 = -(this[6] != 0);
      this[2] = 0;
      this[1] = (v4 & 3) + 1;
      return 0;
    }
    if ( (a2 & 2) == 0 )
      return 1;
    v6 = this[6];
    if ( !v6 )
      goto LABEL_88;
    v7 = *(_BYTE *)(v6 + 8);
    *(_BYTE *)(v6 + 136) = 5;
    *(_BYTE *)(v6 + 138) = 0;
    *(_BYTE *)(v6 + 137) = (v7 != 0) + 1;
    *(_BYTE *)(v6 + 139) = 2;
    *(_BYTE *)(v6 + 296) = 0;
    *(_DWORD *)(v6 + 280) = 0;
    *(_DWORD *)(v6 + 284) = (v7 != 0) + 3;
    this[5] = 2;
  }
  if ( !this[6] )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v8 = this[6];
              v9 = *(_DWORD *)(v8 + 280);
              v10 = *(_DWORD *)(v8 + 284);
              if ( v9 >= v10 )
                goto LABEL_19;
              v11 = 0;
              if ( *(_BYTE *)(v8 + 296) )
              {
                if ( (a2 & 1) != 0 )
                {
                  v12 = ((int (__thiscall *)(_DWORD *, unsigned int, unsigned int))loc_40EF90)(
                          this,
                          v9 + v8 + 136,
                          v10 - v9);
                  goto LABEL_17;
                }
              }
              else if ( (a2 & 2) != 0 )
              {
                v12 = sub_40EED0(this, v9 + v8 + 136, v10 - v9);
LABEL_17:
                v11 = v12;
                if ( v12 < 0 )
                {
                  this[1] = 4;
                  return 0;
                }
                goto LABEL_18;
              }
LABEL_18:
              *(_DWORD *)(this[6] + 280) += v11;
              v8 = this[6];
              v10 = *(_DWORD *)(v8 + 284);
              if ( *(_DWORD *)(v8 + 280) < v10 )
                return 1;
LABEL_19:
              v13 = this[5];
              if ( v13 != 2 )
                break;
              *(_BYTE *)(v8 + 296) = 1;
              *(_DWORD *)(v8 + 280) = 0;
              *(_DWORD *)(v8 + 284) = 2;
              this[5] = 3;
            }
            if ( v13 != 3 )
              break;
            v14 = *(_BYTE *)(v8 + 137);
            if ( v14 != 2 || !*(_BYTE *)(v8 + 8) )
            {
              if ( !v14 )
              {
                v17 = *(_BYTE *)(v8 + 300);
                *(_BYTE *)(v8 + 136) = 5;
                *(_BYTE *)(v8 + 137) = v17;
                *(_BYTE *)(v8 + 138) = 0;
                *(_BYTE *)(v8 + 139) = 1;
                *(_BYTE *)(v8 + 140) = HIBYTE(this[3]);
                *(_BYTE *)(v8 + 141) = BYTE2(this[3]);
                *(_BYTE *)(v8 + 142) = BYTE1(this[3]);
                *(_BYTE *)(v8 + 143) = *((_BYTE *)this + 12);
                *(_BYTE *)(v8 + 144) = BYTE1(this[4]);
                *(_BYTE *)(v8 + 145) = *((_BYTE *)this + 16);
                goto LABEL_32;
              }
              v24 = this[6];
              this[5] = 0;
              this[1] = 4;
              this[2] = 256;
              Str[0] = 0;
              if ( v24 )
              {
                if ( *(_BYTE *)(v24 + 296) )
                {
                  for ( i = 0; i < *(_DWORD *)(v24 + 280); ++i )
                  {
                    if ( i >= 0x14 )
                      break;
                    v43 = *(unsigned __int8 *)(v24 + i + 136);
                    v26 = strchr(Str, 0);
                    sprintf_0(v26, "%02x ", v43);
                    v24 = this[6];
                  }
                }
              }
LABEL_54:
              sub_40DA80(aSocketSocksErr);
              this[1] = 5;
              return 0;
            }
            *(_BYTE *)(v8 + 136) = 1;
            *(_BYTE *)(v8 + 137) = strlen((const char *)(v8 + 8));
            strcpy((char *)(v8 + 138), (const char *)(v8 + 8));
            v15 = (char *)(*(unsigned __int8 *)(v8 + 137) + v8 + 138);
            *v15 = strlen((const char *)(v8 + 72));
            strcpy(v15 + 1, (const char *)(v8 + 72));
            v16 = (unsigned __int8)*v15;
            *(_BYTE *)(v8 + 296) = 0;
            *(_DWORD *)(v8 + 280) = 0;
            *(_DWORD *)(v8 + 284) = &v15[v16 - v8 - 135];
            this[5] = 4;
          }
          if ( v13 != 4 )
            break;
          *(_BYTE *)(v8 + 296) = 1;
          *(_DWORD *)(v8 + 280) = 0;
          *(_DWORD *)(v8 + 284) = 2;
          this[5] = 5;
        }
        if ( v13 != 5 )
          break;
        if ( *(_BYTE *)(v8 + 137) )
        {
          v27 = this[6];
          Str[0] = 0;
          v28 = *(unsigned __int8 *)(v27 + 137);
          this[5] = 0;
          this[1] = 4;
          this[2] = v28 + 512;
          if ( v27 )
          {
            if ( *(_BYTE *)(v27 + 296) )
            {
              for ( j = 0; j < *(_DWORD *)(v27 + 280); ++j )
              {
                if ( j >= 0x14 )
                  break;
                v44 = *(unsigned __int8 *)(v27 + j + 136);
                v30 = strchr(Str, 0);
                sprintf_0(v30, "%02x ", v44);
                v27 = this[6];
              }
            }
          }
          goto LABEL_54;
        }
        v18 = *(_BYTE *)(v8 + 300);
        *(_BYTE *)(v8 + 136) = 5;
        *(_BYTE *)(v8 + 137) = v18;
        *(_BYTE *)(v8 + 138) = 0;
        *(_BYTE *)(v8 + 139) = 1;
        *(_BYTE *)(v8 + 140) = HIBYTE(this[3]);
        *(_BYTE *)(v8 + 141) = BYTE2(this[3]);
        *(_BYTE *)(v8 + 142) = BYTE1(this[3]);
        *(_BYTE *)(v8 + 143) = *((_BYTE *)this + 12);
        *(_BYTE *)(v8 + 144) = BYTE1(this[4]);
        *(_BYTE *)(v8 + 145) = *((_BYTE *)this + 16);
LABEL_32:
        *(_BYTE *)(v8 + 296) = 0;
        *(_DWORD *)(v8 + 280) = 0;
        *(_DWORD *)(v8 + 284) = 10;
        this[5] = 6;
      }
      if ( v13 != 6 )
        break;
      *(_BYTE *)(v8 + 296) = 1;
      *(_DWORD *)(v8 + 280) = 0;
      *(_DWORD *)(v8 + 284) = 5;
      this[5] = 7;
    }
    if ( v13 != 7 && v13 != 8 )
      break;
    if ( v10 == 5 )
    {
      v19 = *(_BYTE *)(v8 + 139);
      switch ( v19 )
      {
        case 1:
          *(_DWORD *)(v8 + 284) = 10;
          break;
        case 3:
          *(_DWORD *)(v8 + 284) = *(unsigned __int8 *)(v8 + 140) + 6;
          break;
        case 4:
          *(_DWORD *)(v8 + 284) = 22;
          break;
        default:
          v34 = this[6];
          Str[0] = 0;
          v35 = *(unsigned __int8 *)(v34 + 139);
          this[5] = 0;
          this[1] = 4;
          this[2] = v35 + 768;
          if ( v34 )
          {
            if ( *(_BYTE *)(v34 + 296) )
            {
              for ( k = 0; k < *(_DWORD *)(v34 + 280); ++k )
              {
                if ( k >= 0x14 )
                  break;
                v46 = *(unsigned __int8 *)(v34 + k + 136);
                v37 = strchr(Str, 0);
                sprintf_0(v37, "%02x ", v46);
                v34 = this[6];
              }
            }
          }
          goto LABEL_66;
      }
    }
    else
    {
      if ( *(_BYTE *)(v8 + 137) )
      {
        v38 = this[6];
        Str[0] = 0;
        v39 = *(_BYTE *)(v38 + 137);
        this[5] = 0;
        this[1] = 4;
        this[2] = v39 + 512;
        if ( v38 )
        {
          if ( *(_BYTE *)(v38 + 296) )
          {
            for ( l = 0; l < *(_DWORD *)(v38 + 280); ++l )
            {
              if ( l >= 0x14 )
                break;
              v47 = *(unsigned __int8 *)(v38 + l + 136);
              v41 = strchr(Str, 0);
              sprintf_0(v41, "%02x ", v47);
              v38 = this[6];
            }
          }
        }
        sub_40DA80(aSocketSocksErr);
        if ( v39 == 2 )
        {
          this[1] = 5;
          result = 0;
        }
        else
        {
          if ( v39 == 3 || v39 == 4 || v39 == 5 || v39 == 6 )
            this[1] = 1;
          result = 0;
        }
        return result;
      }
      HIBYTE(v20) = *(_BYTE *)(v8 + 140);
      LOBYTE(v20) = *(_BYTE *)(v8 + 141);
      v21 = *(unsigned __int8 *)(v8 + 143) | ((*(unsigned __int8 *)(v8 + 142) | (v20 << 8)) << 8);
      HIWORD(v22) = 0;
      BYTE1(v22) = *(_BYTE *)(v8 + 144);
      LOBYTE(v22) = *(_BYTE *)(v8 + 145);
      if ( *(_DWORD *)(v8 + 300) != 2 )
      {
        v42 = this[6];
        *(_DWORD *)(v42 + 288) = v21;
        *(_DWORD *)(v42 + 292) = v22;
LABEL_88:
        this[5] = 9;
        return 1;
      }
      if ( v13 != 7 )
      {
        this[3] = v21;
        this[4] = v22;
        goto LABEL_88;
      }
      *(_DWORD *)(v8 + 288) = v21;
      *(_DWORD *)(v8 + 292) = v22;
      v23 = this[6];
      *(_BYTE *)(v23 + 296) = 1;
      *(_DWORD *)(v23 + 280) = 0;
      *(_DWORD *)(v23 + 284) = 5;
      this[5] = 8;
    }
  }
  v31 = this[6];
  this[5] = 0;
  this[1] = 4;
  this[2] = 1024;
  Str[0] = 0;
  if ( v31 )
  {
    if ( *(_BYTE *)(v31 + 296) )
    {
      for ( m = 0; m < *(_DWORD *)(v31 + 280); ++m )
      {
        if ( m >= 0x14 )
          break;
        v45 = *(unsigned __int8 *)(v31 + m + 136);
        v33 = strchr(Str, 0);
        sprintf_0(v33, "%02x ", v45);
        v31 = this[6];
      }
    }
  }
LABEL_66:
  sub_40DA80(aSocketSocksErr);
  return 0;
}
// 410A8C: conditional instruction was optimized away because of 'al.1!=0'

//----- (00411370) --------------------------------------------------------
int *__thiscall sub_411370(int *this)
{
  int v2; // eax

  v2 = dword_4A70AC(0, 0, 0);
  *this = v2;
  if ( !v2 )
    sub_40DAA0(aCreatemutexFai);
  return this;
}
// 40DAA0: using guessed type int sub_40DAA0(const char *, ...);
// 4A70AC: using guessed type int (__stdcall *dword_4A70AC)(_DWORD, _DWORD, _DWORD);

//----- (004113A0) --------------------------------------------------------
int __thiscall sub_4113A0(_DWORD *this)
{
  return dword_4A729C(*this);
}
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (004113B0) --------------------------------------------------------
bool __thiscall sub_4113B0(int *this, int a2)
{
  void (*v3)(void); // edi
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  if ( a2 >= 0 )
    return sub_411400(*this, a2, (int)&savedregs, (int)this);
  v3 = (void (*)(void))dword_4A70B0;
  while ( !sub_411400(*this, 30000, (int)&savedregs, (int)this) )
  {
    v3();
    sub_40DA80(aMutexAcquirePo);
  }
  return 1;
}
// 4A70B0: using guessed type int (*dword_4A70B0)(void);

//----- (00411400) --------------------------------------------------------
BOOL __usercall sub_411400@<eax>(int a1@<ecx>, int a2@<edx>, int a3@<ebp>, int a4@<esi>)
{
  int v4; // eax
  int v5; // esi
  const char *v6; // eax
  int v7; // eax
  int v9; // [esp-4h] [ebp-1Ch]
  const char *v10; // [esp+0h] [ebp-18h] BYREF
  int v11; // [esp+4h] [ebp-14h]
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]

  v12 = a1;
  if ( a2 < 0 )
    a2 = -1;
  v11 = a4;
  v4 = dword_4A722C(a1, a2);
  v5 = v4;
  if ( v4 && v4 != 258 )
  {
    v6 = *sub_40DB50(&v10, "WaitForSingleObject %u", v4);
    v13 = 0;
    if ( !v6 )
      v6 = (const char *)&unk_4A7DB0;
    sub_40DCC0(a3, aWWaitObject0WW, (unsigned int)aCSrcIncWinTask, (const char *)0xB, (char)v6);
    v13 = -1;
    sub_40BE30((unsigned int *)&v10);
  }
  if ( v5 == -1 )
  {
    v7 = dword_4A7260(v9, v10, v11, v12);
    sub_40DAA0("WaitForSingleObject failed %x", v7);
  }
  return v5 == 0;
}
// 411400: could not find valid save-restore pair for esi
// 411487: variable 'v9' is possibly undefined
// 40DAA0: using guessed type int sub_40DAA0(const char *, ...);
// 4A722C: using guessed type int (__cdecl *dword_4A722C)(_DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004114C0) --------------------------------------------------------
void __usercall sub_4114C0(const char *a1@<ecx>, int a2@<ebp>)
{
  int v2; // eax
  const char *v3; // eax
  const char *v4[3]; // [esp+4h] [ebp-10h] BYREF
  int v5; // [esp+10h] [ebp-4h]

  v4[0] = a1;
  if ( dword_4A70B4(*(_DWORD *)a1) != 1 )
  {
    v2 = dword_4A7260(v4[0], v4[1], v4[2], v5);
    v3 = *sub_40DB50(v4, "Err=%u", v2);
    v5 = 0;
    if ( !v3 )
      v3 = byte_4A7DB0;
    sub_40DCC0(a2, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v3);
    v5 = -1;
    sub_40BE30((unsigned int *)v4);
  }
}
// 4A70B4: using guessed type int (__stdcall *dword_4A70B4)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004115B0) --------------------------------------------------------
_DWORD *__thiscall sub_4115B0(_DWORD *this)
{
  int v2; // eax
  int v3; // eax

  v2 = dword_4A70AC(0, 0, 0);
  this[2] = v2;
  if ( !v2 )
    sub_40DAA0(aCreatemutexFai);
  v3 = dword_4A7094(0, 0, 0, 0);
  this[3] = v3;
  if ( !v3 )
    sub_40DAA0(aCreateeventFai);
  this[1] = 0;
  *this = 0;
  return this;
}
// 40DAA0: using guessed type int __cdecl sub_40DAA0(_DWORD);
// 4A7094: using guessed type int (__stdcall *dword_4A7094)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A70AC: using guessed type int (__stdcall *dword_4A70AC)(_DWORD, _DWORD, _DWORD);

//----- (00411640) --------------------------------------------------------
int __thiscall sub_411640(const char *this)
{
  const char *v1; // ebx
  void (*v2)(void); // esi
  int *v3; // edi
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int v6; // edx
  int v7; // eax
  const char *v8; // eax
  int (__stdcall *v9)(int); // esi
  const char *v12; // [esp+10h] [ebp-10h] BYREF
  int v13; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v1 = this;
  v2 = (void (*)(void))dword_4A70B0;
  v3 = (int *)(this + 8);
  v13 = 1;
  v12 = this + 8;
  while ( !sub_411400(*v3, 30000, (int)&savedregs, (int)v2) )
  {
    v2();
    sub_40DA80(aMutexAcquirePo);
  }
  v4 = *(_DWORD **)v1;
  LOBYTE(v13) = 2;
  if ( v4 )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      sub_40B7E0((unsigned int)v4 - ((v4[1] + 3) & 0xFFFFFFFC));
      v4 = v5;
    }
    while ( v5 );
  }
  v6 = *v3;
  LOBYTE(v13) = 1;
  if ( dword_4A70B4(v6) != 1 )
  {
    v7 = ((int (__cdecl *)())dword_4A7260)();
    v8 = *sub_40DB50(&v12, "Err=%u", v7);
    LOBYTE(v13) = 3;
    if ( !v8 )
      v8 = (const char *)&unk_4A7DB0;
    sub_40DCC0((int)&savedregs, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v8);
    LOBYTE(v13) = 1;
    sub_40BE30((unsigned int *)&v12);
  }
  v9 = dword_4A729C;
  dword_4A729C(*((_DWORD *)v1 + 3));
  return v9(*v3);
}
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70B4: using guessed type int (__stdcall *dword_4A70B4)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00411750) --------------------------------------------------------
void __thiscall sub_411750(char *this, char *a2, const char *a3)
{
  const char *v3; // edi
  unsigned int v5; // esi
  int v6; // eax
  unsigned int v7; // esi
  _DWORD *v8; // edi
  int v9; // eax
  int v10; // esi
  const char *v11; // eax
  int v12; // eax
  _DWORD *v13; // eax
  const char *v14; // eax
  int v15; // edx
  int v16; // eax
  const char *v17; // eax
  int v18; // [esp-Ch] [ebp-28h]
  int v19; // [esp-8h] [ebp-24h]
  int v20; // [esp-4h] [ebp-20h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v3 = a3;
  v5 = (unsigned int)(a3 + 3) & 0xFFFFFFFC;
  v6 = sub_40B720((int)&savedregs, v5 + 8);
  v7 = v6 + v5;
  a3 = (const char *)v7;
  sub_46CAB0(v6, a2, (unsigned int)v3);
  *(_DWORD *)(v7 + 4) = v3;
  v8 = this + 8;
  *(_DWORD *)v7 = 0;
  while ( 1 )
  {
    v9 = dword_4A722C(*v8, 30000);
    v10 = v9;
    if ( v9 && v9 != 258 )
    {
      v11 = *sub_40DB50((const char **)&a2, "WaitForSingleObject %u", v9);
      if ( !v11 )
        v11 = (const char *)&unk_4A7DB0;
      sub_40DCC0((int)&savedregs, aWWaitObject0WW, (unsigned int)aCSrcIncWinTask, (const char *)0xB, (char)v11);
      sub_40BE30((unsigned int *)&a2);
    }
    if ( v10 == -1 )
    {
      v12 = ((int (__cdecl *)(int, int))dword_4A7260)(v19, v20);
      sub_40DAA0("WaitForSingleObject failed %x", v12);
    }
    if ( !v10 )
      break;
    dword_4A70B0();
    sub_40DA80(aMutexAcquirePo);
  }
  v13 = *(_DWORD **)this;
  if ( *((_DWORD *)this + 1) )
  {
    if ( !v13 )
      sub_40DCC0((int)&savedregs, aHead0, (unsigned int)aCSrcIncWinTask, (const char *)0x7D, 0);
    v14 = a3;
    **((_DWORD **)this + 1) = a3;
  }
  else
  {
    if ( v13 )
      sub_40DCC0((int)&savedregs, aHead0_0, (unsigned int)aCSrcIncWinTask, (const char *)0x81, 0);
    v14 = a3;
    *(_DWORD *)this = a3;
  }
  v15 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 1) = v14;
  v18 = v15;
  dword_4A7220();
  if ( dword_4A70B4(*v8) != 1 )
  {
    v16 = ((int (__cdecl *)(int, int, int))dword_4A7260)(v18, v19, v20);
    v17 = *sub_40DB50(&a3, "Err=%u", v16);
    if ( !v17 )
      v17 = (const char *)&unk_4A7DB0;
    sub_40DCC0((int)&savedregs, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v17);
    sub_40BE30((unsigned int *)&a3);
  }
}
// 41180D: variable 'v19' is possibly undefined
// 41180D: variable 'v20' is possibly undefined
// 40DAA0: using guessed type int sub_40DAA0(const char *, ...);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70B4: using guessed type int (__stdcall *dword_4A70B4)(_DWORD);
// 4A7220: using guessed type int (*dword_4A7220)(void);
// 4A722C: using guessed type int (__cdecl *dword_4A722C)(_DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411920) --------------------------------------------------------
int __thiscall sub_411920(_DWORD **this, _DWORD *a2)
{
  void (*v2)(void); // ebx
  int *v4; // edi
  bool v5; // zf
  _DWORD *v6; // eax
  _DWORD **v7; // eax
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  const char *v12; // eax
  int result; // eax
  int v14; // eax
  const char *v15; // eax
  int v16; // [esp-4h] [ebp-20h]
  const char *v17; // [esp+Ch] [ebp-10h] BYREF
  int v18; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v2 = (void (*)(void))dword_4A70B0;
  v4 = (int *)(this + 2);
  v17 = (const char *)(this + 2);
  while ( !sub_411400(*v4, 30000, (int)&savedregs, (int)this) )
  {
    v2();
    sub_40DA80(aMutexAcquirePo);
  }
  v5 = *this == 0;
  v6 = this[1];
  v18 = 0;
  if ( v5 )
  {
    if ( v6 )
      sub_40DCC0((int)&savedregs, aTail0_0, (unsigned int)aCSrcIncWinTask, (const char *)0x91, 0);
    v18 = -1;
    *a2 = 0;
    if ( dword_4A70B4(*v4) != 1 )
    {
      v14 = ((int (__cdecl *)())dword_4A7260)();
      v15 = *sub_40DB50(&v17, "Err=%u", v14);
      v18 = 2;
      if ( !v15 )
        v15 = (const char *)&unk_4A7DB0;
      sub_40DCC0((int)&savedregs, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v15);
      v18 = -1;
      sub_40BE30((unsigned int *)&v17);
    }
    result = 0;
  }
  else
  {
    if ( !v6 )
      sub_40DCC0((int)&savedregs, aTail0, (unsigned int)aCSrcIncWinTask, (const char *)0x8A, 0);
    v7 = (_DWORD **)*this;
    v8 = (_DWORD *)**this;
    *this = v8;
    if ( !v8 )
      this[1] = 0;
    *a2 = v7[1];
    v16 = *v4;
    v9 = (int)v7 - (((unsigned int)v7[1] + 3) & 0xFFFFFFFC);
    v18 = -1;
    v10 = v9;
    if ( dword_4A70B4(v16) != 1 )
    {
      v11 = ((int (__cdecl *)())dword_4A7260)();
      v12 = *sub_40DB50((const char **)&a2, "Err=%u", v11);
      v18 = 1;
      if ( !v12 )
        v12 = (const char *)&unk_4A7DB0;
      sub_40DCC0((int)&savedregs, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v12);
      v18 = -1;
      sub_40BE30((unsigned int *)&a2);
    }
    result = v10;
  }
  return result;
}
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70B4: using guessed type int (__stdcall *dword_4A70B4)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411B40) --------------------------------------------------------
int __usercall sub_411B40@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int (*v5)(void); // edi
  int v6; // eax
  int v7; // esi
  const char *v8; // eax
  int v9; // eax
  _DWORD *v10; // eax
  int v11; // eax
  const char *v12; // eax
  int v13; // [esp-10h] [ebp-2Ch]
  const char *v16; // [esp+4h] [ebp-18h] BYREF
  const char *v17; // [esp+8h] [ebp-14h] BYREF
  int v18; // [esp+Ch] [ebp-10h]
  int v19; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  if ( !*a1 )
    return 0;
  v5 = (int (*)(void))dword_4A722C;
  v18 = 0;
  while ( 1 )
  {
    v13 = a1[2];
    v6 = v5();
    v7 = v6;
    if ( v6 && v6 != 258 )
    {
      v8 = *sub_40DB50(&v17, "WaitForSingleObject %u", v6);
      v19 = 0;
      if ( !v8 )
        v8 = (const char *)&unk_4A7DB0;
      sub_40DCC0((int)&savedregs, aWWaitObject0WW, (unsigned int)aCSrcIncWinTask, (const char *)0xB, (char)v8);
      v19 = -1;
      sub_40BE30((unsigned int *)&v17);
    }
    if ( v7 == -1 )
    {
      v9 = dword_4A7260(v13, 30000, a2, a3);
      sub_40DAA0("WaitForSingleObject failed %x", v9);
    }
    if ( !v7 )
      break;
    dword_4A70B0();
    sub_40DA80(aMutexAcquirePo);
  }
  v10 = (_DWORD *)*a1;
  if ( *a1 )
  {
    do
    {
      v10 = (_DWORD *)*v10;
      ++v18;
    }
    while ( v10 );
  }
  if ( dword_4A70B4(a1[2]) != 1 )
  {
    v11 = ((int (__cdecl *)(int, int))dword_4A7260)(a2, a3);
    v12 = *sub_40DB50(&v16, "Err=%u", v11);
    v19 = 2;
    if ( !v12 )
      v12 = (const char *)&unk_4A7DB0;
    sub_40DCC0((int)&savedregs, aReleasemutexHa, (unsigned int)aCSrcIncWinTask, (const char *)0x49, (char)v12);
    v19 = -1;
    sub_40BE30((unsigned int *)&v16);
  }
  return v18;
}
// 411B40: could not find valid save-restore pair for edi
// 411B40: could not find valid save-restore pair for esi
// 40DAA0: using guessed type int sub_40DAA0(const char *, ...);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70B4: using guessed type int (__stdcall *dword_4A70B4)(_DWORD);
// 4A722C: using guessed type int (__cdecl *dword_4A722C)(_DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411CB0) --------------------------------------------------------
_DWORD *__thiscall sub_411CB0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_4A9110;
  this[2] = 0;
  this[3] = 10000;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 17) = 0;
  this[1] = 0;
  return result;
}
// 4A9110: using guessed type int (*off_4A9110)();

//----- (00411CD0) --------------------------------------------------------
unsigned int __userpurge sub_411CD0@<eax>(unsigned int a1@<ecx>, int a2@<ebp>, char a3)
{
  int v4; // ecx
  int v5; // edx

  *(_DWORD *)a1 = &off_4A9110;
  *(_BYTE *)(a1 + 16) = 1;
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 )
  {
    v5 = *(_DWORD *)(a1 + 12);
    if ( v5 >= 0 )
    {
      sub_411400(v4, v5, a2, a1);
      if ( *(_BYTE *)(a1 + 17) )
      {
        sub_40DA80(aThreadSThreadD);
        dword_4A70B8(*(_DWORD *)(a1 + 4), 0);
      }
    }
    dword_4A729C(*(_DWORD *)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 17) = 0;
    sub_40DA80(aThreadSThreadS);
  }
  if ( (a3 & 1) != 0 )
    sub_40B7E0(a1);
  return a1;
}
// 4A70B8: using guessed type int (__stdcall *dword_4A70B8)(_DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A9110: using guessed type int (*off_4A9110)();

//----- (00411D50) --------------------------------------------------------
int __usercall sub_411D50@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v3; // ecx
  int v4; // edx
  int result; // eax

  *(_DWORD *)a1 = &off_4A9110;
  *(_BYTE *)(a1 + 16) = 1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 >= 0 )
    {
      sub_411400(v3, v4, a2, a1);
      if ( *(_BYTE *)(a1 + 17) )
      {
        sub_40DA80(aThreadSThreadD);
        dword_4A70B8(*(_DWORD *)(a1 + 4), 0);
      }
    }
    dword_4A729C(*(_DWORD *)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 17) = 0;
    result = sub_40DA80(aThreadSThreadS);
  }
  return result;
}
// 4A70B8: using guessed type int (__stdcall *dword_4A70B8)(_DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A9110: using guessed type int (*off_4A9110)();

//----- (00411DC0) --------------------------------------------------------
int __thiscall sub_411DC0(int this, char *a2, int a3)
{
  char *v3; // eax
  int v5; // eax

  v3 = a2;
  if ( !a2 )
    v3 = aUnnamed;
  *(_DWORD *)(this + 8) = v3;
  *(_BYTE *)(this + 16) = 0;
  *(_BYTE *)(this + 17) = 1;
  v5 = dword_4A7154(0, 0, sub_411E30, this, 0, &a2);
  *(_DWORD *)(this + 4) = v5;
  if ( !v5 )
    sub_40DAA0("Create %s thread failed", *(const char **)(this + 8));
  return sub_40DA80(aThreadSUThread);
}
// 40DAA0: using guessed type int sub_40DAA0(const char *, ...);
// 4A7154: using guessed type int (__cdecl *dword_4A7154)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00411E30) --------------------------------------------------------
int __stdcall sub_411E30(int a1)
{
  void (__thiscall **v1)(int, int, int, int); // eax
  int v3; // [esp-4h] [ebp-24h]
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  *(_BYTE *)(a1 + 17) = 1;
  v1 = *(void (__thiscall ***)(int, int, int, int))a1;
  v4[7] = 0;
  (*v1)(a1, 7707, 7707, 7707);
  *(_BYTE *)(a1 + 17) = 0;
  return v3;
}
// 411E8F: variable 'v3' is possibly undefined

//----- (00411EB0) --------------------------------------------------------
int __usercall sub_411EB0@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int v3; // ecx
  int v4; // edx
  int result; // eax

  *(_BYTE *)(a1 + 16) = 1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 >= 0 )
    {
      sub_411400(v3, v4, a2, a1);
      if ( *(_BYTE *)(a1 + 17) )
      {
        sub_40DA80(aThreadSThreadD);
        dword_4A70B8(*(_DWORD *)(a1 + 4), 0);
      }
    }
    dword_4A729C(*(_DWORD *)(a1 + 4));
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + 17) = 0;
    result = sub_40DA80(aThreadSThreadS);
  }
  return result;
}
// 4A70B8: using guessed type int (__stdcall *dword_4A70B8)(_DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00411F20) --------------------------------------------------------
int __thiscall sub_411F20(_DWORD *this, int a2)
{
  return dword_4A7228(this[1]);
}
// 4A7228: using guessed type int (__cdecl *dword_4A7228)(_DWORD);

//----- (00412000) --------------------------------------------------------
int __thiscall sub_412000(void *this)
{
  return dword_4A72B4(this);
}
// 4A72B4: using guessed type int (__stdcall *dword_4A72B4)(_DWORD);

//----- (004120C0) --------------------------------------------------------
void *sub_4120C0()
{
  double v0; // st7
  void *result; // eax
  __int64 v2; // [esp+8h] [ebp-10h] BYREF
  int v3[2]; // [esp+10h] [ebp-8h] BYREF

  if ( byte_4C1A78 && dword_4A70D0(&v2) && dword_4A70CC(v3) && v2 > 1000 )
  {
    v0 = (double)v2;
    byte_4C1A78 = 1;
    dword_4C1A60 = v3[0];
    dword_4C1A64 = v3[1];
    dbl_4C1A70 = dbl_4A91C8 / v0;
    dbl_4C1A68 = dbl_4A91C0 / v0;
    result = (void *)(dword_4A7098() - 1000000);
    off_4C1A7C = result;
  }
  else
  {
    byte_4C1A78 = 0;
    result = (void *)(dword_4A7098() - 1000000);
    off_4C1A7C = result;
  }
  return result;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70D0: using guessed type int (__stdcall *dword_4A70D0)(_DWORD);
// 4A91C0: using guessed type double dbl_4A91C0;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4C1A60: using guessed type int dword_4C1A60;
// 4C1A64: using guessed type int dword_4C1A64;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A70: using guessed type double dbl_4C1A70;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (00412170) --------------------------------------------------------
int sub_412170()
{
  __int64 v0; // rax
  _DWORD v2[3]; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_4C1A78 )
  {
    dword_4A70CC(&v2[1]);
    v0 = (__int64)((double)(*(_QWORD *)&v2[1] - qword_4C1A60) * dbl_4C1A68);
  }
  else
  {
    LODWORD(v0) = dword_4A7098() - (_DWORD)off_4C1A7C;
  }
  return v0;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4C1A60: using guessed type __int64 qword_4C1A60;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (00412390) --------------------------------------------------------
int __thiscall sub_412390(_DWORD *this)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  __int64 v4; // rax
  unsigned __int64 v6; // [esp+4h] [ebp-8h] BYREF

  if ( byte_4C1A78 )
  {
    dword_4A70CC(&v6);
    v3 = HIDWORD(v6);
    v2 = v6;
    *this = v6;
    this[1] = v3;
    v6 = __PAIR64__(v3, v2) - qword_4C1A60;
    v4 = (__int64)((double)(__int64)(__PAIR64__(v3, v2) - qword_4C1A60) * dbl_4C1A68);
  }
  else
  {
    LODWORD(v4) = dword_4A7098() - (_DWORD)off_4C1A7C;
  }
  this[2] = v4;
  return v4;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4C1A60: using guessed type __int64 qword_4C1A60;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (00412400) --------------------------------------------------------
bool __thiscall sub_412400(_DWORD *this, int a2)
{
  __int64 v3; // rax
  _DWORD v5[3]; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_4C1A78 )
  {
    dword_4A70CC(&v5[1]);
    *(_QWORD *)&v5[1] -= qword_4C1A60;
    v3 = (__int64)((double)*(__int64 *)&v5[1] * dbl_4C1A68);
  }
  else
  {
    LODWORD(v3) = dword_4A7098() - (_DWORD)off_4C1A7C;
  }
  return (int)v3 - this[2] >= a2;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4C1A60: using guessed type __int64 qword_4C1A60;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (004124F0) --------------------------------------------------------
int __thiscall sub_4124F0(_DWORD *this)
{
  _DWORD v3[3]; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_4C1A78 )
    return dword_4A7098() - (_DWORD)off_4C1A7C - this[2];
  dword_4A70CC(&v3[1]);
  *(_QWORD *)&v3[1] -= qword_4C1A60;
  return (__int64)((double)*(__int64 *)&v3[1] * dbl_4C1A68) - this[2];
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4C1A60: using guessed type __int64 qword_4C1A60;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (00412570) --------------------------------------------------------
double __thiscall sub_412570(unsigned int *this)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  double result; // st7
  int (*v5)(void); // edi
  unsigned int v6; // eax
  unsigned int v7; // ecx
  _DWORD v8[3]; // [esp+4h] [ebp-14h] BYREF
  double v9; // [esp+10h] [ebp-8h]

  if ( byte_4C1A78 )
  {
    dword_4A70CC(&v8[1]);
    v2 = v8[1];
    v3 = v8[2];
    *(_QWORD *)&v8[1] -= *(_QWORD *)this;
    result = (double)*(__int64 *)&v8[1] * dbl_4C1A68;
    *this = v2;
    this[1] = v3;
    *(_QWORD *)&v8[1] = __PAIR64__(v3, v2) - qword_4C1A60;
    this[2] = (__int64)((double)(__int64)(__PAIR64__(v3, v2) - qword_4C1A60) * dbl_4C1A68);
  }
  else
  {
    v5 = dword_4A7098;
    *(_QWORD *)&v8[1] = dword_4A7098() - (_DWORD)off_4C1A7C - this[2];
    v9 = (double)*(__int64 *)&v8[1];
    if ( byte_4C1A78 )
    {
      dword_4A70CC(&v8[1]);
      v6 = v8[1];
      v7 = v8[2];
      *this = v8[1];
      this[1] = v7;
      *(_QWORD *)&v8[1] = __PAIR64__(v7, v6) - qword_4C1A60;
      result = v9;
      this[2] = (__int64)((double)(__int64)(__PAIR64__(v7, v6) - qword_4C1A60) * dbl_4C1A68);
    }
    else
    {
      result = v9;
      this[2] = v5() - (_DWORD)off_4C1A7C;
    }
  }
  return result;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4C1A60: using guessed type __int64 qword_4C1A60;
// 4C1A68: using guessed type double dbl_4C1A68;
// 4C1A78: using guessed type char byte_4C1A78;
// 4C1A7C: using guessed type void *off_4C1A7C;

//----- (00412680) --------------------------------------------------------
int __cdecl sub_412680(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int result; // eax

  if ( sub_4668F0(a1, (unsigned __int8 **)&a2, a3, a4) )
    result = -1;
  else
    result = a2;
  return result;
}

//----- (004126C0) --------------------------------------------------------
int __cdecl sub_4126C0(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  LOBYTE(v4) = sub_466A40(a1, &a2, a3, a4);
  if ( v4 )
    result = -1;
  else
    result = a2;
  return result;
}
// 4126E6: variable 'v4' is possibly undefined

//----- (00412700) --------------------------------------------------------
int __thiscall sub_412700(_DWORD *this)
{
  int v1; // ebx
  int v2; // eax
  int v3; // esi
  int v4; // edx
  char v5; // cl
  char v6; // cl
  int v7; // eax
  int v8; // esi
  int v9; // edx
  char v10; // cl
  char v11; // cl
  void (__stdcall *v12)(_DWORD, int *, int *); // esi
  int v14[3296]; // [esp+Ch] [ebp-37F4h] BYREF
  int v15[263]; // [esp+338Ch] [ebp-474h] BYREF
  _BYTE v16[64]; // [esp+37A8h] [ebp-58h] BYREF
  void (__stdcall *v17)(_DWORD, int *, int *); // [esp+37E8h] [ebp-18h]
  int v18; // [esp+37ECh] [ebp-14h] BYREF
  _DWORD *v19; // [esp+37F0h] [ebp-10h]
  int v20; // [esp+37F4h] [ebp-Ch] BYREF
  int v21; // [esp+37F8h] [ebp-8h] BYREF
  int v22; // [esp+37FCh] [ebp-4h] BYREF

  v19 = this;
  sub_412910(v16, byte_4A920C);
  v1 = dword_4A70DC(v16);
  memset(v16, 0, sizeof(v16));
  v2 = BYTE1(dword_4A91F4) ^ 0x45;
  v3 = BYTE2(dword_4A91F4) ^ (unsigned __int8)dword_4A91F4;
  v16[0] = v2 ^ HIBYTE(dword_4A91F4);
  if ( (unsigned __int8)v2 != HIBYTE(dword_4A91F4) )
  {
    v4 = 0;
    do
    {
      v5 = byte_4A91F8[v4++];
      v2 ^= v3;
      v6 = v2 ^ v5;
      v16[v4] = v6;
    }
    while ( v6 );
  }
  v20 = dword_4A70D8(v1, v16);
  memset(v16, 0, sizeof(v16));
  v7 = BYTE1(dword_4A91D8) ^ 0x45;
  v8 = BYTE2(dword_4A91D8) ^ (unsigned __int8)dword_4A91D8;
  v16[0] = v7 ^ HIBYTE(dword_4A91D8);
  if ( (unsigned __int8)v7 != HIBYTE(dword_4A91D8) )
  {
    v9 = 0;
    do
    {
      v10 = byte_4A91DC[v9++];
      v7 ^= v8;
      v11 = v7 ^ v10;
      v16[v9] = v11;
    }
    while ( v11 );
  }
  v12 = (void (__stdcall *)(_DWORD, int *, int *))dword_4A70D8(v1, v16);
  v17 = v12;
  memset(v16, 0, sizeof(v16));
  if ( v1 )
  {
    if ( v20 )
    {
      if ( v12 )
      {
        memset(v14, 0, sizeof(v14));
        v21 = 13184;
        v22 = 32;
        v14[0] = 412;
        ((void (__stdcall *)(int *, int *, int *))v20)(v14, &v21, &v22);
        if ( v22 )
        {
          memset(v15, 0, sizeof(v15));
          v15[0] = 1052;
          strcpy((char *)&v15[1], (const char *)&v14[2]);
          v18 = 0;
          v17(0, v15, &v18);
          if ( HIBYTE(v15[129]) )
          {
            v20 = -1;
            sub_401AB0(&v20, (unsigned __int8 *)&v15[129] + 3);
            v19[7] = v20;
          }
          if ( LOBYTE(v15[194]) && LOBYTE(v15[194]) != 42 )
          {
            v20 = -1;
            sub_401AB0(&v20, (unsigned __int8 *)&v15[129] + 3);
            v19[10] = v20;
          }
        }
      }
    }
  }
  return dword_4A70D4(v1);
}
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A91D8: using guessed type int dword_4A91D8;
// 4A91F4: using guessed type int dword_4A91F4;

//----- (00412910) --------------------------------------------------------
_BYTE *__fastcall sub_412910(_BYTE *a1, unsigned __int8 *a2)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // esi
  _BYTE *v6; // edx
  int v7; // esi
  int v8; // ebx
  bool v9; // zf
  _BYTE *v10; // edi
  char v11; // cl
  char v12; // cl

  v3 = a2[1];
  v4 = *a2;
  v5 = a2[2];
  v6 = a2 + 3;
  v7 = v4 ^ v5;
  v8 = v3 ^ 0x45;
  v9 = (unsigned __int8)v8 == *v6;
  v10 = a1;
  *a1 = v8 ^ *v6;
  if ( !v9 )
  {
    do
    {
      v11 = v6[1];
      ++v10;
      ++v6;
      v8 ^= v7;
      v12 = v8 ^ v11;
      *v10 = v12;
    }
    while ( v12 );
  }
  return a1;
}

//----- (00412950) --------------------------------------------------------
_BYTE *__thiscall sub_412950(_BYTE *this)
{
  int v2; // eax
  int v3; // edi
  int v4; // edx
  char v5; // cl
  char v6; // cl
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  char v10; // dl
  char v11; // dl
  int v12; // eax
  int v13; // edi
  int v14; // edx
  char v15; // cl
  char v16; // cl
  _BYTE *result; // eax
  _BYTE v18[64]; // [esp+8h] [ebp-80h] BYREF
  _BYTE v19[64]; // [esp+48h] [ebp-40h] BYREF

  *(_DWORD *)this = &off_4A9250;
  this[17] = 0;
  this[16] = 0;
  *((_DWORD *)this + 3) = -1;
  sub_412910(v18, byte_4A9258);
  *((_DWORD *)this + 2) = dword_4A70DC(v18);
  memset(v18, 0, sizeof(v18));
  sub_412910(v18, byte_4A9240);
  *((_DWORD *)this + 1) = dword_4A70D8(*((_DWORD *)this + 2), v18);
  memset(v18, 0, sizeof(v18));
  if ( *((_DWORD *)this + 1) )
  {
    this[17] = 1;
    result = this;
  }
  else
  {
    this[16] = 1;
    v2 = BYTE1(dword_4A9230) ^ 0x45;
    v3 = BYTE2(dword_4A9230) ^ (unsigned __int8)dword_4A9230;
    v19[0] = v2 ^ HIBYTE(dword_4A9230);
    if ( (unsigned __int8)v2 != HIBYTE(dword_4A9230) )
    {
      v4 = 0;
      do
      {
        v5 = byte_4A9234[v4++];
        v2 ^= v3;
        v6 = v2 ^ v5;
        v19[v4] = v6;
      }
      while ( v6 );
    }
    v7 = BYTE1(dword_4A9228) ^ 0x45;
    v8 = BYTE2(dword_4A9228) ^ (unsigned __int8)dword_4A9228;
    v18[0] = v7 ^ HIBYTE(dword_4A9228);
    if ( (unsigned __int8)v7 != HIBYTE(dword_4A9228) )
    {
      v9 = 0;
      do
      {
        v10 = byte_4A922C[v9++];
        v7 ^= v8;
        v11 = v7 ^ v10;
        v18[v9] = v11;
      }
      while ( v11 );
    }
    dword_4A70E0(1, v18, v19);
    memset(v18, 0, sizeof(v18));
    memset(v19, 0, sizeof(v19));
    v12 = BYTE1(dword_4A921C) ^ 0x45;
    v13 = BYTE2(dword_4A921C) ^ (unsigned __int8)dword_4A921C;
    v18[0] = v12 ^ HIBYTE(dword_4A921C);
    if ( (unsigned __int8)v12 != HIBYTE(dword_4A921C) )
    {
      v14 = 0;
      do
      {
        v15 = byte_4A9220[v14++];
        v12 ^= v13;
        v16 = v12 ^ v15;
        v18[v14] = v16;
      }
      while ( v16 );
    }
    *((_DWORD *)this + 3) = dword_4A7284(v18, 0, 0, 0, 3, 128, 0);
    memset(v18, 0, sizeof(v18));
    ((void (__cdecl *)())dword_4A7260)();
    this[17] = *((_DWORD *)this + 3) != -1;
    result = this;
  }
  return result;
}
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A70E0: using guessed type int (__stdcall *dword_4A70E0)(_DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A921C: using guessed type int dword_4A921C;
// 4A9228: using guessed type int dword_4A9228;
// 4A9230: using guessed type int dword_4A9230;
// 4A9250: using guessed type int (*off_4A9250)();

//----- (00412B10) --------------------------------------------------------
_BYTE *__thiscall sub_412B10(_BYTE *this, char a2)
{
  sub_412B30(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00412B30) --------------------------------------------------------
int __thiscall sub_412B30(_BYTE *this)
{
  char v2; // al
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  char v6; // bl
  char v7; // bl
  int v8; // edi
  int v9; // eax
  int v10; // ecx
  char v11; // dl
  char v12; // dl
  char v14[64]; // [esp+4h] [ebp-80h] BYREF
  char v15[64]; // [esp+44h] [ebp-40h] BYREF

  v2 = this[16];
  *(_DWORD *)this = &off_4A9250;
  if ( v2 )
  {
    dword_4A729C(*((_DWORD *)this + 3));
    v3 = BYTE2(dword_4A9230) ^ (unsigned __int8)dword_4A9230;
    v4 = BYTE1(dword_4A9230) ^ 0x45;
    v15[0] = v4 ^ HIBYTE(dword_4A9230);
    if ( (unsigned __int8)v4 != HIBYTE(dword_4A9230) )
    {
      v5 = 0;
      do
      {
        v6 = byte_4A9234[v5++];
        v4 ^= v3;
        v7 = v4 ^ v6;
        v15[v5] = v7;
      }
      while ( v7 );
    }
    v8 = BYTE2(dword_4A9228) ^ (unsigned __int8)dword_4A9228;
    v9 = BYTE1(dword_4A9228) ^ 0x45;
    v14[0] = v9 ^ HIBYTE(dword_4A9228);
    if ( (unsigned __int8)v9 != HIBYTE(dword_4A9228) )
    {
      v10 = 0;
      do
      {
        v11 = byte_4A922C[v10++];
        v9 ^= v8;
        v12 = v9 ^ v11;
        v14[v10] = v12;
      }
      while ( v12 );
    }
    dword_4A70E0(7, v14, v15);
    memset(v14, 0, sizeof(v14));
    memset(v15, 0, sizeof(v15));
  }
  return dword_4A70D4(*((_DWORD *)this + 2));
}
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A70E0: using guessed type int (__stdcall *dword_4A70E0)(_DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A9228: using guessed type int dword_4A9228;
// 4A9230: using guessed type int dword_4A9230;
// 4A9250: using guessed type int (*off_4A9250)();

//----- (00412C50) --------------------------------------------------------
char __thiscall sub_412C50(int this)
{
  int v2; // ebx
  char v3; // al
  int v4; // eax
  unsigned int v5; // eax
  int v7; // [esp+10h] [ebp-22Ch] BYREF
  int v8; // [esp+14h] [ebp-228h] BYREF
  _DWORD v9[9]; // [esp+18h] [ebp-224h] BYREF
  int v10; // [esp+3Ch] [ebp-200h] BYREF
  int v11; // [esp+40h] [ebp-1FCh]
  unsigned int v12; // [esp+48h] [ebp-1F4h]
  unsigned int v13; // [esp+4Ch] [ebp-1F0h]
  char v14[492]; // [esp+50h] [ebp-1ECh] BYREF

  v2 = 0;
  while ( 1 )
  {
    v7 = 512;
    memset(v9, 0, sizeof(v9));
    v3 = *(_BYTE *)(this + 16);
    v8 = 36;
    v9[0] = 512;
    v9[1] = v2;
    v9[2] = 512;
    v9[3] = 256;
    v9[4] = 1;
    if ( v3 )
      v4 = dword_4A70E4(*(_DWORD *)(this + 12), 1179651, v9, 36, &v10, 512, &v7, 0) == 0;
    else
      v4 = (*(int (__stdcall **)(int, _DWORD, _DWORD *, int *, int *, int *))(this + 4))(6, 0, v9, &v8, &v10, &v7);
    if ( v4 )
      return 0;
    if ( v11 == 6 || v11 == 9 || v11 == 15 )
    {
      v5 = v13;
      if ( v13 )
      {
        if ( v12 > 0x249F0 )
          break;
      }
    }
    if ( ++v2 >= 64 )
      return 0;
  }
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  if ( v5 >= 8 )
    v5 = 8;
  *(_DWORD *)(this + 20) = v5;
  sub_46CAB0(this + 24, v14, v5);
  return 1;
}
// 4A70E4: using guessed type int (__stdcall *dword_4A70E4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00412D60) --------------------------------------------------------
int __thiscall sub_412D60(_DWORD *this)
{
  char v2; // al
  char v3; // al
  bool v4; // zf
  int v5; // eax
  int v6; // esi
  int v7; // ecx
  char v8; // dl
  char v9; // dl
  int v10; // eax
  int v11; // esi
  int v12; // ecx
  char v13; // dl
  char v14; // dl
  _BYTE v16[64]; // [esp+8h] [ebp-B0h] BYREF
  _BYTE v17[64]; // [esp+48h] [ebp-70h] BYREF
  int v18[3]; // [esp+88h] [ebp-30h] BYREF
  int v19; // [esp+94h] [ebp-24h]
  char v20; // [esp+98h] [ebp-20h]
  char v21; // [esp+99h] [ebp-1Fh]
  int v22; // [esp+9Ch] [ebp-1Ch]
  unsigned __int8 v23[8]; // [esp+A0h] [ebp-18h] BYREF
  int v24[4]; // [esp+A8h] [ebp-10h] BYREF

  sub_412950(v18);
  v24[3] = 0;
  if ( v21 )
  {
    if ( sub_412C50((int)v18) )
    {
      v24[0] = -1;
      sub_401A70(v24, v23, v22);
      v4 = v20 == 0;
      this[4] = v24[0];
      v18[0] = (int)&off_4A9250;
      if ( !v4 )
      {
        dword_4A729C(v19);
        v5 = BYTE1(dword_4A9230) ^ 0x45;
        v6 = BYTE2(dword_4A9230) ^ (unsigned __int8)dword_4A9230;
        v17[0] = v5 ^ HIBYTE(dword_4A9230);
        if ( (unsigned __int8)v5 != HIBYTE(dword_4A9230) )
        {
          v7 = 0;
          do
          {
            v8 = byte_4A9234[v7++];
            v5 ^= v6;
            v9 = v5 ^ v8;
            v17[v7] = v9;
          }
          while ( v9 );
        }
        v10 = BYTE1(dword_4A9228) ^ 0x45;
        v11 = BYTE2(dword_4A9228) ^ (unsigned __int8)dword_4A9228;
        v16[0] = v10 ^ HIBYTE(dword_4A9228);
        if ( (unsigned __int8)v10 != HIBYTE(dword_4A9228) )
        {
          v12 = 0;
          do
          {
            v13 = byte_4A922C[v12++];
            v10 ^= v11;
            v14 = v10 ^ v13;
            v16[v12] = v14;
          }
          while ( v14 );
        }
        dword_4A70E0(7, v16, v17);
        memset(v16, 0, sizeof(v16));
        memset(v17, 0, sizeof(v17));
      }
    }
    else
    {
      v3 = v20;
      this[4] = 0;
      v18[0] = (int)&off_4A9250;
      if ( v3 )
      {
        dword_4A729C(v19);
        sub_412910(v16, (unsigned __int8 *)&dword_4A9230);
        sub_412910(v17, (unsigned __int8 *)&dword_4A9228);
        dword_4A70E0(7, v17, v16);
        memset(v17, 0, sizeof(v17));
        memset(v16, 0, sizeof(v16));
      }
    }
  }
  else
  {
    v2 = v20;
    this[4] = 0;
    v18[0] = (int)&off_4A9250;
    if ( v2 )
    {
      dword_4A729C(v19);
      sub_412910(v16, (unsigned __int8 *)&dword_4A9230);
      sub_412910(v17, (unsigned __int8 *)&dword_4A9228);
      dword_4A70E0(7, v17, v16);
      memset(v17, 0, sizeof(v17));
      memset(v16, 0, sizeof(v16));
    }
  }
  return dword_4A70D4(v18[2]);
}
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A70E0: using guessed type int (__stdcall *dword_4A70E0)(_DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A9228: using guessed type int dword_4A9228;
// 4A9230: using guessed type int dword_4A9230;
// 4A9250: using guessed type int (*off_4A9250)();

//----- (00412FA0) --------------------------------------------------------
int __fastcall sub_412FA0(int a1, int a2, int a3, int a4, char a5)
{
  int v5; // esi
  int result; // eax
  int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // esi
  int v10; // edx
  int v11; // edi
  int v12; // esi
  int v13; // eax
  _DWORD *v14; // ecx
  _DWORD *v15; // edx
  int v16; // eax
  _DWORD *v17; // esi
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // esi
  int v21; // edx
  bool v22; // al
  int v23; // [esp+64h] [ebp-220h] BYREF
  int v24; // [esp+68h] [ebp-21Ch] BYREF
  int v25; // [esp+6Ch] [ebp-218h] BYREF
  int v26; // [esp+70h] [ebp-214h] BYREF
  int v27; // [esp+74h] [ebp-210h]
  int v28; // [esp+78h] [ebp-20Ch] BYREF
  int v29; // [esp+7Ch] [ebp-208h]
  int v30; // [esp+80h] [ebp-204h] BYREF
  char String[256]; // [esp+84h] [ebp-200h] BYREF
  _DWORD v32[64]; // [esp+184h] [ebp-100h] BYREF

  v5 = a1;
  v29 = a2;
  v27 = a1;
  v25 = 0;
  v28 = 256;
  v26 = 256;
  for ( result = dword_4A700C(a1, 0, String, &v28, 0, &v23, v32, &v26);
        result != 259;
        result = dword_4A700C(v27, v25, String, &v28, 0, &v23, v32, &v26) )
  {
    if ( !result )
    {
      _strlwr(String);
      v30 = -1;
      sub_401AB0(&v30, (unsigned __int8 *)String);
      v7 = ~v30;
      v8 = ((-25033 * (~v30 ^ ((unsigned int)~v30 >> 16))) >> 9) & 0x7F;
      v9 = v8;
      v10 = *(_DWORD *)(a4 + 20 * v8);
      if ( v10 == ~v30 )
      {
LABEL_7:
        v11 = a4 + 20 * v8 + 4;
      }
      else
      {
        while ( 1 )
        {
          if ( !v10 )
          {
            v11 = 0;
            *(_DWORD *)(a4 + 2560) = a4 + 20 * v8;
            goto LABEL_8;
          }
          v8 = ((_BYTE)v8 + 1) & 0x7F;
          if ( v8 == v9 )
            break;
          v10 = *(_DWORD *)(a4 + 20 * v8);
          if ( v10 == v7 )
            goto LABEL_7;
        }
        *(_DWORD *)(a4 + 2560) = 0;
        v11 = 0;
      }
LABEL_8:
      if ( v7 )
      {
        if ( v11 )
        {
          if ( !*(_DWORD *)(v11 + 4) )
          {
            v12 = 0;
            v13 = v29 - 1;
            if ( v29 - 1 >= 0 )
            {
              v14 = (_DWORD *)(a3 + 4 * v13);
              v15 = (_DWORD *)(v11 + 8);
              while ( v12 < 2 )
              {
                if ( *v15 == *v14 )
                {
                  ++v12;
                  ++v15;
                }
                --v13;
                --v14;
                if ( v13 < 0 )
                {
                  if ( v12 < 2 )
                    goto LABEL_24;
                  break;
                }
              }
              if ( v23 == 4 )
              {
                v16 = v32[0];
              }
              else
              {
                v24 = -1;
                sub_401A70(&v24, (unsigned __int8 *)v32, v26);
                v16 = v24;
              }
              *(_DWORD *)(v11 + 4) = v16;
            }
          }
        }
      }
    }
LABEL_24:
    v5 = v27;
    ++v25;
    v28 = 256;
    v26 = 256;
  }
  if ( v29 <= 30 )
  {
    v24 = 0;
    for ( result = dword_4A7008(v5, 0, String, 256); !result; result = dword_4A7008(v27, ++v24, String, 256) )
    {
      _strlwr(String);
      v23 = -1;
      sub_401AB0(&v23, (unsigned __int8 *)String);
      v17 = 0;
      v18 = ~v23;
      *(_DWORD *)(a3 + 4 * v29) = ~v23;
      if ( a5 )
        goto LABEL_45;
      v19 = ((-25033 * (v18 ^ HIWORD(v18))) >> 9) & 0x7F;
      v20 = v19;
      v21 = *(_DWORD *)(a4 + 20 * v19);
      if ( v21 != v18 )
      {
        while ( 1 )
        {
          if ( !v21 )
          {
            *(_DWORD *)(a4 + 2560) = a4 + 20 * v19;
            goto LABEL_42;
          }
          v19 = ((_BYTE)v19 + 1) & 0x7F;
          if ( v19 == v20 )
            break;
          v21 = *(_DWORD *)(a4 + 20 * v19);
          if ( v21 == v18 )
            goto LABEL_32;
        }
        *(_DWORD *)(a4 + 2560) = 0;
        continue;
      }
LABEL_32:
      v17 = (_DWORD *)(a4 + 20 * v19 + 4);
      if ( a4 + 20 * v19 != -4 )
      {
LABEL_45:
        if ( !dword_4A7004(v27, String, 0, 131097, &v25) )
        {
          v22 = a5 || v17 && *v17;
          sub_412FA0(a3, a4, v22);
          dword_4A702C(v25);
        }
      }
LABEL_42:
      ;
    }
  }
  return result;
}
// 4A7004: using guessed type int (__stdcall *dword_4A7004)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7008: using guessed type int (__stdcall *dword_4A7008)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A700C: using guessed type int (__stdcall *dword_4A700C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A702C: using guessed type int (__stdcall *dword_4A702C)(_DWORD);

//----- (004132D0) --------------------------------------------------------
_BYTE *__thiscall sub_4132D0(_BYTE *this, char a2)
{
  char v3; // al

  v3 = this[76];
  *(_DWORD *)this = &off_4AC038;
  if ( v3 )
    sub_413B40((int)this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}
// 4AC038: using guessed type int (__stdcall *off_4AC038)(int);

//----- (00413300) --------------------------------------------------------
int __stdcall sub_413300(char a1)
{
  int v1; // eax
  int v2; // esi
  char v4[4]; // [esp+Ch] [ebp-4h] BYREF

  v1 = dword_4A70F4();
  v2 = dword_4A70F0(48, 0, v1);
  if ( a1 )
    dword_4A70EC(v2, sub_401000, &loc_401008, 0x20000, v4);
  else
    dword_4A70E8(v2, sub_401000, &loc_401008, 0x20000, v4);
  return dword_4A729C(v2);
}
// 4A70E8: using guessed type int (__stdcall *dword_4A70E8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A70EC: using guessed type int (__stdcall *dword_4A70EC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A70F0: using guessed type int (__stdcall *dword_4A70F0)(_DWORD, _DWORD, _DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);

//----- (00413370) --------------------------------------------------------
int __stdcall sub_413370(int (*a1)(void))
{
  while ( !a1() )
    dword_4A72B4(300);
  return sub_46E4AC((int)a1);
}
// 4A72B4: using guessed type int (__stdcall *dword_4A72B4)(_DWORD);

//----- (004133C0) --------------------------------------------------------
char __stdcall sub_4133C0(int a1)
{
  return 0;
}

//----- (004133D0) --------------------------------------------------------
int __thiscall sub_4133D0(void *this)
{
  int result; // eax
  int (__stdcall *v2)(int); // edi
  int v3; // esi
  int v4; // eax
  int v5; // [esp+0h] [ebp-Ch]
  int pExceptionObject; // [esp+8h] [ebp-4h] BYREF

  dword_4A70AC(0, 0, 4899008);
  result = ((int (__cdecl *)())dword_4A7260)();
  if ( result == 183 )
  {
    pExceptionObject = 9098925;
    v2 = (int (__stdcall *)(int))dword_4A730C;
    v3 = dword_4A730C(4898996, 0);
    if ( !v3 )
    {
      ((void (__stdcall *)(int, _DWORD, int))v2)(9098981 - (_DWORD)&loc_401649, 0, v5);
      pExceptionObject = 9099052;
      v3 = v2(4898960);
      if ( !v3 )
      {
        pExceptionObject = 1212;
        _CxxThrowException(&pExceptionObject, &_TI1H);
      }
    }
    if ( dword_4A7308(v3) )
      dword_4A72C8(v3, 10);
    dword_4A7304(v3);
    v4 = dword_4A7300(v3);
    if ( v3 != v4 )
      dword_4A72FC(v4);
    result = sub_46E4AC(0);
  }
  return result;
}
// 413432: variable 'v5' is possibly undefined
// 4A70AC: using guessed type int (__stdcall *dword_4A70AC)(_DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A72C8: using guessed type int (__stdcall *dword_4A72C8)(_DWORD, _DWORD);
// 4A72FC: using guessed type int (__stdcall *dword_4A72FC)(_DWORD);
// 4A7300: using guessed type int (__stdcall *dword_4A7300)(_DWORD);
// 4A7304: using guessed type int (__stdcall *dword_4A7304)(_DWORD);
// 4A7308: using guessed type int (__stdcall *dword_4A7308)(_DWORD);
// 4A730C: using guessed type int (__stdcall *dword_4A730C)(_DWORD, _DWORD);

//----- (004134A0) --------------------------------------------------------
int __thiscall sub_4134A0(_BYTE *this)
{
  char v2; // al
  __time32_t v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // edx
  unsigned int v14; // esi
  char *v15; // eax
  int v16; // edi
  int v17; // eax
  int (__stdcall *v18)(int, _DWORD *, int, int *, void *); // edi
  int v19; // eax
  int result; // eax
  int v21; // eax
  int v22; // eax
  void (__stdcall *v23)(_DWORD); // esi
  int v24; // eax
  int v25; // eax
  int v26; // edi
  int v27; // esi
  char v28; // dl
  char v29; // dl
  int v30; // eax
  int v31; // esi
  int v32; // edi
  char v33; // dl
  char v34; // dl
  int v35; // esi
  int v36; // eax
  int v37; // [esp+0h] [ebp-4BCh] BYREF
  _DWORD v38[128]; // [esp+Ch] [ebp-4B0h] BYREF
  char v39[128]; // [esp+20Ch] [ebp-2B0h] BYREF
  int v40[17]; // [esp+28Ch] [ebp-230h] BYREF
  char Str[4]; // [esp+2D0h] [ebp-1ECh] BYREF
  _DWORD v42[64]; // [esp+2D4h] [ebp-1E8h] BYREF
  _BYTE v43[64]; // [esp+3D4h] [ebp-E8h] BYREF
  _DWORD v44[4]; // [esp+414h] [ebp-A8h] BYREF
  _DWORD v45[16]; // [esp+424h] [ebp-98h] BYREF
  int v46[3]; // [esp+464h] [ebp-58h] BYREF
  int v47; // [esp+470h] [ebp-4Ch] BYREF
  int v48; // [esp+474h] [ebp-48h] BYREF
  int v49; // [esp+478h] [ebp-44h] BYREF
  int v50; // [esp+47Ch] [ebp-40h] BYREF
  int pExceptionObject; // [esp+480h] [ebp-3Ch] BYREF
  int v52[2]; // [esp+484h] [ebp-38h] BYREF
  int v53; // [esp+48Ch] [ebp-30h] BYREF
  int v54; // [esp+490h] [ebp-2Ch]
  int v55; // [esp+494h] [ebp-28h] BYREF
  int v56; // [esp+498h] [ebp-24h] BYREF
  int v57; // [esp+49Ch] [ebp-20h] BYREF
  int v58; // [esp+4A0h] [ebp-1Ch] BYREF
  int v59; // [esp+4A4h] [ebp-18h]
  int v60[2]; // [esp+4A8h] [ebp-14h] BYREF
  int v61; // [esp+4B8h] [ebp-4h]
  int savedregs; // [esp+4BCh] [ebp+0h] BYREF

  v2 = this[77];
  v60[1] = (int)&v37;
  v52[1] = (int)this;
  if ( v2 )
  {
    v21 = dword_4A70F4();
    v22 = dword_4A70F0(32, 0, v21);
    if ( v22 )
    {
      v23 = (void (__stdcall *)(_DWORD))dword_4A729C;
      dword_4A729C(v22);
      v58 = 0;
      LOWORD(v59) = 256;
      if ( !dword_4A7030(&v58, 1, 0, 0, 0, 0, 0, 0, 0, 0, &v56) )
      {
        v53 = 335;
        _CxxThrowException(&v53, &_TI1H);
      }
      dword_4A7034(&v45[11], 1);
      dword_4A7038(v39, 128, 2);
      dword_4A703C(v39, 2, 786488, v56);
      dword_4A7040(v39, 2, 2035711, v56);
      dword_4A7014(&v45[11], 1, v39, 0);
      dword_4A7010(v56);
      v46[2] = 0;
      memset(v40, 0, sizeof(v40));
      v40[0] = 68;
      v46[0] = 12;
      v46[1] = (int)&v45[11];
      dword_4A7100(0, v42, 256);
      v24 = dword_4A70FC(v46, 0, 0, 32, 0, 0, v40, v44);
      if ( !dword_4A70F8(v42, v24) )
      {
        v47 = 362;
        _CxxThrowException(&v47, &_TI1H);
      }
      v23(v44[0]);
      sub_46E4AC(0);
    }
    this[76] = 1;
    v25 = BYTE1(dword_4AC0E4) ^ 0x45;
    v26 = BYTE2(dword_4AC0E4) ^ (unsigned __int8)dword_4AC0E4;
    LOBYTE(v45[0]) = HIBYTE(dword_4AC0E4) ^ BYTE1(dword_4AC0E4) ^ 0x45;
    if ( LOBYTE(v45[0]) )
    {
      v27 = 0;
      do
      {
        v28 = byte_4AC0E8[v27++];
        v25 ^= v26;
        v29 = v25 ^ v28;
        *((_BYTE *)v45 + v27) = v29;
      }
      while ( v29 );
    }
    v59 = dword_4A70DC(v45);
    memset(v45, 0, sizeof(v45));
    v30 = BYTE1(dword_4AC0CC) ^ 0x45;
    v31 = BYTE2(dword_4AC0CC) ^ (unsigned __int8)dword_4AC0CC;
    v43[0] = HIBYTE(dword_4AC0CC) ^ v30;
    if ( HIBYTE(dword_4AC0CC) != (unsigned __int8)v30 )
    {
      v32 = 0;
      do
      {
        v33 = byte_4AC0D0[v32++];
        v30 ^= v31;
        v34 = v30 ^ v33;
        v43[v32] = v34;
      }
      while ( v34 );
    }
    v35 = dword_4A70D8(v59, v43);
    memset(v43, 0, sizeof(v43));
    v36 = dword_4A7154(0, 0, sub_413370, v35, 0, v60);
    dword_4A729C(v36);
    result = (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 76))(this);
  }
  else
  {
    (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 76))(this);
    sub_412910(v45, (unsigned __int8 *)&dword_4AC0FC);
    v54 = dword_4A7284(v45, 0, 0, 0, 1, 128, 0);
    memset(v45, 0, sizeof(v45));
    if ( v54 == -1 )
    {
      pExceptionObject = 275;
      _CxxThrowException(&pExceptionObject, &_TI1H);
    }
    dword_4A70CC(&v55);
    dword_4A710C(&v45[8]);
    dword_4A7314(&v58);
    v3 = time_0(0);
    v4 = dword_4A70B0() ^ v3;
    v5 = dword_4A7310() ^ v4;
    v6 = dword_4A7098() ^ v5;
    v7 = dword_4A70F4();
    v8 = v56;
    v9 = v45[15] ^ ((v58 ^ (2 * v59)) << 16) ^ v7 ^ v6;
    v10 = v55;
    v11 = v45[11] ^ v45[13] ^ v9;
    this[60] = 80;
    this[61] = 67;
    v12 = v10 ^ v8 ^ v11;
    v13 = 0;
    this[66] = 0;
    v60[0] = 0;
    while ( v13 < 3 )
    {
      Str[0] = 0;
      this[62] = ((25 * ((unsigned int)(69069 * v12 + 17009) >> 16)) >> 16) + 65;
      this[63] = ((25 * ((unsigned int)(69069 * (69069 * v12 + 17009) + 17009) >> 16)) >> 16) + 65;
      this[64] = ((25 * ((unsigned int)(69069 * (69069 * (69069 * v12 + 17009) + 17009) + 17009) >> 16)) >> 16) + 65;
      v14 = 69069 * (69069 * (69069 * (69069 * v12 + 17009) + 17009) + 17009) + 17009;
      this[65] = ((unsigned int)(25 * HIWORD(v14)) >> 16) + 65;
      if ( v13 < 2 )
        dword_4A7108(260, Str);
      sub_407960(Str, (int)Str, aTmp);
      v12 = 69069 * v14 + 17009;
      v59 = v12;
      v15 = strchr(Str, 0);
      sprintf_0(v15, "%x", v12);
      v61 = 1;
      v57 = -1;
      sub_4080D0(&v57, (int)&savedregs, Str, 0, 2);
      (*(void (__thiscall **)(_BYTE *, _DWORD *, void *, int))(*(_DWORD *)this + 84))(this, v38, &unk_4A9268, 512);
      sub_4086E0(&v57, (int)v38, 512);
      (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 84))(this);
      sub_408180(&v57, 4096);
      sub_4086E0(&v57, (int)v38, 366);
      sub_4087F0(&v57);
      v56 = 0;
      v16 = dword_4A70E4(v54, 1, Str, strlen(Str) + 1, 0, 0, &v56, 0);
      sub_408820(Str);
      if ( !v16 )
      {
        v49 = 310;
        _CxxThrowException(&v49, &_TI1H);
      }
      this[76] = 1;
      v17 = dword_4A7104(304157217);
      v18 = (int (__stdcall *)(int, _DWORD *, int, int *, void *))dword_4A70EC;
      if ( !dword_4A70EC(v17, v38, 1, &v56, v38) )
      {
        v52[0] = 313;
        _CxxThrowException(v52, &_TI1H);
      }
      v38[0] = -485113291;
      v19 = dword_4A7104(this);
      if ( !v18(v19, v38, 4, &v56, &unk_4A9468) )
      {
        v48 = 316;
        _CxxThrowException(&v48, &_TI1H);
      }
      if ( v38[0] != -485113291 )
      {
        v50 = 318;
        _CxxThrowException(&v50, &_TI1H);
      }
      LOBYTE(v61) = 0;
      sub_4087F0(&v57);
      v61 = -1;
      v13 = ++v60[0];
    }
    result = dword_4A729C(v54);
  }
  return result;
}
// 4A7010: using guessed type int (__cdecl *dword_4A7010)(_DWORD);
// 4A7014: using guessed type int (__cdecl *dword_4A7014)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7030: using guessed type int (__cdecl *dword_4A7030)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7034: using guessed type int (__cdecl *dword_4A7034)(_DWORD, _DWORD);
// 4A7038: using guessed type int (__cdecl *dword_4A7038)(_DWORD, _DWORD, _DWORD);
// 4A703C: using guessed type int (__cdecl *dword_4A703C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7040: using guessed type int (__cdecl *dword_4A7040)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A70E4: using guessed type int (__stdcall *dword_4A70E4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A70EC: using guessed type int (__stdcall *dword_4A70EC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A70F0: using guessed type int (__stdcall *dword_4A70F0)(_DWORD, _DWORD, _DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A70F8: using guessed type int (__cdecl *dword_4A70F8)(_DWORD, _DWORD);
// 4A70FC: using guessed type int (__cdecl *dword_4A70FC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4A7104: using guessed type int (__stdcall *dword_4A7104)(_DWORD);
// 4A7108: using guessed type int (__cdecl *dword_4A7108)(_DWORD, _DWORD);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7154: using guessed type int (__cdecl *dword_4A7154)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A7310: using guessed type int (*dword_4A7310)(void);
// 4A7314: using guessed type int (__cdecl *dword_4A7314)(_DWORD);
// 4AC0CC: using guessed type int dword_4AC0CC;
// 4AC0E4: using guessed type int dword_4AC0E4;
// 4AC0FC: using guessed type int dword_4AC0FC;

//----- (00413B40) --------------------------------------------------------
char __thiscall sub_413B40(int this)
{
  char result; // al
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  char v6; // dl
  char v7; // dl
  int v8; // ebx
  int v9; // ecx
  _BYTE *v10; // edi
  bool v11; // zf
  _BYTE v12[64]; // [esp+Ch] [ebp-58h] BYREF
  int v13; // [esp+4Ch] [ebp-18h] BYREF
  char v14[8]; // [esp+50h] [ebp-14h] BYREF
  int v15; // [esp+58h] [ebp-Ch]
  char *v16; // [esp+5Ch] [ebp-8h]
  int v17; // [esp+60h] [ebp-4h] BYREF

  v15 = this;
  result = *(_BYTE *)(this + 77);
  if ( result )
    goto LABEL_10;
  v3 = BYTE1(dword_4AC0FC) ^ 0x45;
  v4 = BYTE2(dword_4AC0FC) ^ (unsigned __int8)dword_4AC0FC;
  v12[0] = v3 ^ HIBYTE(dword_4AC0FC);
  if ( (unsigned __int8)v3 != HIBYTE(dword_4AC0FC) )
  {
    v5 = 0;
    do
    {
      v6 = byte_4AC100[v5++];
      v3 ^= v4;
      v7 = v3 ^ v6;
      v12[v5] = v7;
    }
    while ( v7 );
  }
  v8 = dword_4A7284(v12, 0, 0, 0, 1, 128, 0);
  result = 0;
  memset(v12, 0, sizeof(v12));
  v9 = -1;
  v17 = 0;
  if ( v8 == -1 )
  {
LABEL_10:
    *(_BYTE *)(this + 76) = 0;
  }
  else
  {
    v13 = -1;
    v10 = (_BYTE *)(this + 60);
    do
    {
      if ( !v9 )
        break;
      v11 = *v10++ == 0;
      --v9;
    }
    while ( !v11 );
    v16 = v14;
    qmemcpy(v14, &v10[v9 + 1], ~v9);
    dword_4A70E4(v8, 2, &v13, strlen((const char *)(this + 60)) + 5, 0, 0, &v17, 0);
    dword_4A729C(v8);
    result = v15;
    *(_BYTE *)(v15 + 76) = 0;
  }
  return result;
}
// 4A70E4: using guessed type int (__stdcall *dword_4A70E4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4AC0FC: using guessed type int dword_4AC0FC;

//----- (00413C40) --------------------------------------------------------
int __thiscall sub_413C40(int this, int a2, int a3)
{
  _DWORD *v4; // ecx
  int v5; // ebx
  int v6; // edi
  _DWORD *i; // eax
  int v8; // eax
  int v9; // ecx
  int result; // eax

  sub_402030((_DWORD *)this, a2);
  *(_DWORD *)(this + 1208) = a3;
  *(_DWORD *)this = &off_4AC10C;
  *(_BYTE *)(this + 10180) = 0;
  v4 = &unk_4AA220;
  v5 = 40;
  do
  {
    v6 = 0;
    for ( i = (_DWORD *)(this + *(v4 - 2)); v6 < *v4; ++i )
    {
      *i = 0;
      ++v6;
    }
    v4 += 4;
    --v5;
  }
  while ( v5 );
  memset((void *)(this + 11588), 0, 0x20u);
  *(_DWORD *)(this + 11620) = 0;
  v8 = 1693502488;
  v9 = 56;
  do
    v8 ^= *(_DWORD *)&aListenListen[4 * v9-- - 398752];
  while ( v9 );
  *(_DWORD *)(v8 + this + 70270256) = 0;
  *(_DWORD *)(this + 19828) = 0;
  *(_DWORD *)(this + 19876) = -1;
  *(_DWORD *)(this + 10196) = 1;
  memset((void *)(this + 3012), 0, 0x1C00u);
  *(_DWORD *)(this + 10200) = 0;
  memset((void *)(this + 75232), 0xFFu, 0x80u);
  *(_DWORD *)(this + 75236) = 0;
  result = this;
  *(_DWORD *)(this + 75232) = 0;
  return result;
}
// 4AC10C: using guessed type int (*off_4AC10C)();

//----- (00413D20) --------------------------------------------------------
void __thiscall sub_413D20(_BYTE *this)
{
  this[10181] = 1;
}

//----- (00413D30) --------------------------------------------------------
int __thiscall sub_413D30(int this)
{
  int v1; // eax

  if ( *(_BYTE *)(this + 75368) )
    v1 = *(_DWORD *)(this + 19848);
  else
    v1 = *(_DWORD *)(this + 8);
  return v1 - 8;
}

//----- (00413D50) --------------------------------------------------------
_DWORD *__thiscall sub_413D50(_DWORD *this, char a2)
{
  sub_413DA0(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00413DA0) --------------------------------------------------------
void __thiscall sub_413DA0(_DWORD *this)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  _DWORD *v5; // esi
  int v6; // edi
  _DWORD *v7; // esi
  int v8; // edi
  _DWORD *v9; // edi
  _DWORD *v10; // esi
  int i; // ebx
  int v12; // [esp+18h] [ebp-14h]

  *this = &off_4AC10C;
  v2 = this[4957];
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 8))(v2, 1);
  v3 = this[4956];
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 8))(v3, 1);
  v4 = this[2905];
  if ( v4 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 8))(v4, 1);
  v5 = this + 2897;
  v6 = 8;
  do
  {
    if ( *v5 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v5 + 8))(*v5, 1);
    ++v5;
    --v6;
  }
  while ( v6 );
  v7 = this + 753;
  v8 = 128;
  do
  {
    if ( *v7 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v7 + 8))(*v7, 1);
    v7 += 14;
    --v8;
  }
  while ( v8 );
  v9 = &unk_4AA220;
  v12 = 40;
  do
  {
    v10 = (_DWORD *)((char *)this + *(v9 - 2));
    for ( i = 0; i < *v9; ++v10 )
    {
      if ( *v10 )
        (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v10 + 8))(*v10, 1);
      ++i;
    }
    v9 += 4;
    --v12;
  }
  while ( v12 );
  sub_4031C0((int)this);
}
// 4AC10C: using guessed type int (*off_4AC10C)();

//----- (00413EB0) --------------------------------------------------------
char __thiscall sub_413EB0(char *this, int a2, int a3, int a4, char a5, char a6)
{
  int v7; // edx
  int v8; // ecx
  unsigned int v9; // esi
  int *v10; // ebp
  bool v11; // al
  int *v12; // esi
  int v13; // ebp
  int v14; // edx
  char result; // al
  int i; // ebp
  int v17; // ebx
  int j; // esi

  if ( this[10181] )
    (*(void (__thiscall **)(char *))(*(_DWORD *)this + 112))(this);
  ++*((_DWORD *)this + 2549);
  *((_DWORD *)this + 2546) = a2;
  *((_DWORD *)this + 2547) = a3;
  v7 = *((_DWORD *)this + 2546) - *((_DWORD *)this + 2) / 2;
  v8 = *((_DWORD *)this + 2547) - *((_DWORD *)this + 3) / 2;
  *((_DWORD *)this + 2548) = a4;
  *((_DWORD *)this + 4970) = v7;
  *((_DWORD *)this + 4971) = v8;
  *((_DWORD *)this + 5132) = 0;
  if ( a5 )
    (*(void (__thiscall **)(char *))(*(_DWORD *)this + 132))(this);
  v9 = 0;
  v10 = (int *)(this + 11588);
  do
  {
    v11 = !*v10 || sub_4057B0(*v10) || this[48];
    this[v9++ + 11624] = v11;
    ++v10;
  }
  while ( v9 < 8 );
  v12 = (int *)(this + 3012);
  v13 = 128;
  do
  {
    if ( sub_4057B0(*v12) || this[48] )
    {
      v12[9] = -1;
      v12[8] = -1;
    }
    v12 += 14;
    --v13;
  }
  while ( v13 );
  if ( this[48] )
  {
    *((_DWORD *)this + 2550) = *((_DWORD *)this + 2548) + 100;
  }
  else if ( *((_DWORD *)this + 2550) )
  {
    v14 = *(_DWORD *)this;
    *((_DWORD *)this + 2550) = 0;
    (*(void (__thiscall **)(char *, _DWORD))(v14 + 8))(this, 0);
  }
  result = a6;
  this[48] = 0;
  if ( a6 )
  {
    for ( i = 116; i < 372; i += 16 )
    {
      v17 = i - 116;
      for ( j = 116; j < 372; j += 16 )
        result = sub_405680(*((_DWORD *)this + 300), j - 16, i - 16, j, i, v17++);
    }
  }
  return result;
}

//----- (00414030) --------------------------------------------------------
char __thiscall sub_414030(int *this, int *a2, int *a3, int a4, unsigned __int8 *a5, char a6, int a7, int a8, int a9)
{
  int *v9; // edi
  int v10; // eax
  char v11; // bl
  int *v12; // esi
  _DWORD *v13; // ecx
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  _DWORD *v19; // ebx
  int v20; // ebx
  int v21; // edi
  int v22; // ecx
  unsigned int v23; // edx
  int v24; // ebx
  unsigned __int8 v25; // al
  unsigned int v26; // edx
  int v27; // ecx
  int v28; // esi
  int v29; // ecx
  int v30; // eax
  bool v31; // al
  int v32; // ecx
  int v33; // ebx
  int v34; // eax
  int v35; // edi
  int v36; // ecx
  int v37; // esi
  int v38; // eax
  unsigned __int8 v39; // cl
  int v40; // ecx
  int v41; // edi
  int v42; // eax
  bool v43; // al
  bool v44; // cc
  int v45; // esi
  int v47; // [esp+Ch] [ebp-18h] BYREF
  int v48; // [esp+10h] [ebp-14h]
  int *v49; // [esp+14h] [ebp-10h]
  int v50; // [esp+20h] [ebp-4h]
  int savedregs; // [esp+24h] [ebp+0h] BYREF
  unsigned __int8 *v52; // [esp+30h] [ebp+Ch]
  int v53; // [esp+30h] [ebp+Ch]
  unsigned __int8 *v54; // [esp+38h] [ebp+14h]
  int v55; // [esp+3Ch] [ebp+18h]
  unsigned int v56; // [esp+3Ch] [ebp+18h]

  v9 = this;
  v49 = this;
  v10 = this[18841] + (this[18840] << 16);
  if ( *a3 == v10 )
  {
    v11 = a6;
  }
  else
  {
    *a3 = v10;
    v11 = 1;
  }
  v12 = a2;
  v13 = (_DWORD *)*a2;
  if ( *a2 && v13[9] != a4 )
  {
    if ( v13 )
      (*(void (__thiscall **)(_DWORD *, int))(*v13 + 8))(v13, 1);
    *a2 = 0;
  }
  if ( !*a2 )
  {
    v14 = (_DWORD *)sub_40B720((int)&savedregs, 0x2Cu);
    v50 = 0;
    if ( v14 )
      v15 = sub_405030(v14, (int)v9, a4, a4, a8);
    else
      v15 = 0;
    v50 = -1;
    *a2 = (int)v15;
  }
  LOBYTE(v16) = sub_4057B0(*a2);
  if ( (_BYTE)v16 || v11 )
  {
    if ( (_BYTE)a7 )
    {
      v18 = 0;
      v19 = &loc_43540C;
      do
        v18 -= *v19++;
      while ( v19 < (_DWORD *)((char *)&loc_4354FE + 6) );
      v17 = *(int *)((char *)v9 + v18 + 1721119815);
    }
    else
    {
      v17 = v9[13702];
    }
    sub_405550(*a2, v17);
    if ( (_BYTE)a9 )
    {
      v20 = a4;
      v21 = 19;
      do
      {
        sub_405BC0(*a2, 0, a4, v20 / 20, v49[13703]);
        sub_405D00(*a2, 0, a4, v20 / 20, v49[13703]);
        v20 += a4;
        --v21;
      }
      while ( v21 );
      v9 = v49;
      v12 = a2;
    }
    LOBYTE(v16) = sub_4052C0(*v12);
    if ( (_BYTE)v16 )
    {
      v22 = a4;
      if ( a4 <= 1024 )
      {
        v55 = 0;
        a8 = 0;
        a9 = 1024;
        v52 = a5;
        while ( 1 )
        {
          v54 = v52;
          v23 = 0;
          v24 = 0;
          *(_DWORD *)(*v12 + 28) = *(_DWORD *)(*v12 + 16) + *(_DWORD *)(*v12 + 20) * (a8 / 1024);
          v48 = 0;
          a7 = 0;
          do
          {
            v25 = *v54;
            if ( !*v54 )
              goto LABEL_56;
            v26 = v23 >> 10;
            if ( v25 == 0xAB )
            {
              v27 = *v12;
              a7 = v9[13705];
              sub_46CAB0(*(_DWORD *)(v27 + 28) + v26 * *(_DWORD *)(v27 + 24), &a7, *(_DWORD *)(v27 + 24));
            }
            else if ( v25 == 0xAC )
            {
              v28 = v9[18840];
              v29 = v9[18841];
              switch ( v28 )
              {
                case 1:
                  v30 = v24 >= 512;
                  break;
                case 2:
                  v24 = a7;
                  v30 = v55 >= 512;
                  break;
                case 3:
                case 4:
                  if ( v24 >= 512 )
                  {
                    v24 = a7;
                    v30 = v55 < 512 ? 1 : 3;
                  }
                  else
                  {
                    v24 = a7;
                    v30 = v55 < 512 ? 0 : 2;
                  }
                  break;
                case 5:
                case 6:
                  v9 = v49;
                  if ( v24 >= v55 )
                    v30 = (v24 >= a9) + 2;
                  else
                    v30 = v24 >= a9;
                  break;
                default:
                  v30 = 0;
                  break;
              }
              switch ( v28 )
              {
                case 0:
                  v31 = 1;
                  break;
                case 1:
                case 2:
                  v31 = (v29 & 1) != v30;
                  break;
                case 3:
                case 5:
                  v31 = (v29 & 3) != v30;
                  break;
                case 4:
                case 6:
                  v31 = (v29 & 3) == v30;
                  break;
                default:
                  v31 = 0;
                  break;
              }
              a7 = v9[22 - v31 + 13686];
              sub_46CAB0(*(_DWORD *)(*a2 + 28) + v26 * *(_DWORD *)(*a2 + 24), &a7, *(_DWORD *)(*a2 + 24));
            }
            else if ( v25 < 0xA2u || v25 > 0xAAu )
            {
              if ( v25 > 0xF1u )
                goto LABEL_56;
              v32 = *v12;
              a7 = v9[13704];
              sub_46CAB0(*(_DWORD *)(v32 + 28) + v26 * *(_DWORD *)(v32 + 24), &a7, *(_DWORD *)(v32 + 24));
            }
            else
            {
              a7 = v9[13706];
              sub_46CAB0(*(_DWORD *)(*v12 + 28) + v26 * *(_DWORD *)(*v12 + 24), &a7, *(_DWORD *)(*v12 + 24));
            }
            v12 = a2;
LABEL_56:
            ++v24;
            ++v54;
            v23 = a4 + v48;
            a7 = v24;
            v48 += a4;
          }
          while ( v24 < 1024 );
          ++v55;
          v52 += 1024;
          a8 += a4;
          if ( --a9 <= 0 )
            goto LABEL_92;
        }
      }
      a7 = 0;
      a9 = 0;
      while ( 1 )
      {
        v33 = a9 / v22;
        v34 = *a2;
        v53 = a9 / v22;
        v35 = (int)&a5[1024 * (a9 / v22)];
        v36 = *(_DWORD *)(*a2 + 16) + a7 * *(_DWORD *)(*a2 + 20);
        v37 = 0;
        v48 = v35;
        *(_DWORD *)(v34 + 28) = v36;
        v56 = 0;
        do
        {
          v38 = v56 / a4;
          v39 = *(_BYTE *)(v56 / a4 + v35);
          if ( v39 )
          {
            if ( v39 == 0xAB )
            {
              v40 = *a2;
              a8 = v49[13705];
              sub_46CAB0(*(_DWORD *)(v40 + 28) + v37 * *(_DWORD *)(v40 + 24), &a8, *(_DWORD *)(v40 + 24));
            }
            else if ( v39 == 0xAC )
            {
              v41 = v49[18840];
              switch ( v41 )
              {
                case 1:
                  v42 = v38 >= 512;
                  break;
                case 2:
                  v42 = v33 >= 512;
                  break;
                case 3:
                case 4:
                  if ( v38 >= 512 )
                    v42 = v33 < 512 ? 1 : 3;
                  else
                    v42 = v33 < 512 ? 0 : 2;
                  break;
                case 5:
                case 6:
                  if ( v38 >= v33 )
                    v42 = (v38 >= 1024 - v33) + 2;
                  else
                    v42 = v38 >= 1024 - v33;
                  v33 = v53;
                  break;
                default:
                  v42 = 0;
                  break;
              }
              switch ( v41 )
              {
                case 0:
                  v43 = 1;
                  break;
                case 1:
                case 2:
                  v43 = (v49[18841] & 1) != v42;
                  break;
                case 3:
                case 5:
                  v43 = (v49[18841] & 3) != v42;
                  break;
                case 4:
                case 6:
                  v43 = (v49[18841] & 3) == v42;
                  break;
                default:
                  v43 = 0;
                  break;
              }
              a8 = v49[22 - v43 + 13686];
              sub_46CAB0(*(_DWORD *)(*a2 + 28) + v37 * *(_DWORD *)(*a2 + 24), &a8, *(_DWORD *)(*a2 + 24));
              v35 = v48;
            }
            else if ( v39 < 0xA2u || v39 > 0xAAu )
            {
              if ( v39 <= 0xF1u )
              {
                v47 = v49[13704];
                sub_46CAB0(*(_DWORD *)(*a2 + 28) + v37 * *(_DWORD *)(*a2 + 24), &v47, *(_DWORD *)(*a2 + 24));
              }
            }
            else
            {
              a8 = v49[13706];
              sub_46CAB0(*(_DWORD *)(*a2 + 28) + v37 * *(_DWORD *)(*a2 + 24), &a8, *(_DWORD *)(*a2 + 24));
            }
          }
          ++v37;
          v56 += 1024;
        }
        while ( v37 < a4 );
        v44 = ++a7 < a4;
        a9 += 1024;
        if ( !v44 )
          break;
        v22 = a4;
      }
      v12 = a2;
LABEL_92:
      v45 = *v12;
      v16 = sub_405410(v45);
      *(_DWORD *)(v45 + 12) = v16;
    }
  }
  return v16;
}
// 4143A1: conditional instruction was optimized away because of '%arg_8.4>=401'

//----- (00414630) --------------------------------------------------------
int *__thiscall sub_414630(_DWORD *this, int *a2)
{
  _DWORD *v2; // edi
  int v3; // ecx
  int v4; // ebx
  int v5; // esi
  int v6; // eax

  v2 = this + 4958;
  v3 = this[4966];
  v4 = (v2[1] << 14) / v3;
  v5 = (v2[2] << 14) / v3;
  v6 = (v2[3] << 14) / v3;
  *a2 = (*v2 << 14) / v3;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = v6;
  return a2;
}

//----- (004146A0) --------------------------------------------------------
void __thiscall sub_4146A0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, const char *a7, int a8, int a9, char a10, char a11)
{
  int v12; // edi
  int v13; // ebp
  int v14; // ecx
  int v15; // ebx
  int v16; // eax
  int v17; // ecx
  int v18; // ebp
  int v19; // edi
  int v20; // ebx
  int v21; // edi

  v12 = this[3] / 2 + a4 - this[2547];
  v13 = a3 - this[2546] + this[2] / 2;
  v14 = this[a2 + 2842];
  if ( a5 >= 0 )
    v15 = a5 + *(_DWORD *)(v14 + 612) / 2 - 4;
  else
    v15 = 4 - *(_DWORD *)(v14 + 612) / 2 + a5;
  v16 = *(_DWORD *)(v14 + 616);
  v17 = a6 * this[18807];
  v18 = v15 + v13;
  v19 = v16 / 2 + v12;
  v20 = v17 + v19 - 4;
  if ( a9 >= 0 )
  {
    (*(void (__thiscall **)(_DWORD *, int, int, int))(*this + 260))(this, v18, v17 + v19 - 4, a9);
    v18 += 16;
  }
  (*(void (__thiscall **)(_DWORD *, int, int, const char *, int, int, int))(*this + 236))(this, v18, v20, a7, a8, -1, 1);
  v21 = this[18806] * strlen(a7) + v18 + 4;
  if ( a10 )
  {
    sub_404DD0((_DWORD *)this[2880], v21, v20 - 6, this[2548], 1, 0, 0);
    v21 += *(_DWORD *)(this[2880] + 612) + 4;
  }
  if ( a11 )
    sub_404DD0((_DWORD *)this[2879], v21, v20 - (*(_DWORD *)(this[2879] + 616) - this[18807]) / 2, this[2548], 1, 0, 0);
}

//----- (004147E0) --------------------------------------------------------
int __thiscall sub_4147E0(_DWORD **this, int a2, int a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v9; // edx
  int result; // eax

  if ( a5 )
    a6 = 0;
  v9 = a5 + 3 * a7 + 2 * a6;
  if ( a4 + 2 * v9 - 1 >= 0 )
    sub_404B80(this[2894], a2 - 2, ((int)this[18807] - this[2894][154]) / 2 + a3 + 1, a4 + 2 * v9 - 1, 1);
  result = a8;
  if ( a8 >= 0 )
    result = ((int (__thiscall *)(_DWORD **, int, int, int))(*this)[65])(
               this,
               (int)&this[18806][3 * (_DWORD)this[18806]] + a2 + 1,
               a3,
               a8);
  return result;
}

//----- (00414880) --------------------------------------------------------
int *__thiscall sub_414880(_DWORD *this, unsigned __int8 *a2, unsigned int a3, int a4)
{
  _DWORD *v5; // esi
  int v6; // edx
  int *v7; // ebx
  int *result; // eax
  int v9; // ecx
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // edx
  int v15; // esi
  unsigned int v16; // eax
  unsigned int v17; // ebp
  int v18; // ebp
  unsigned int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v23; // [esp+14h] [ebp-14h] BYREF
  int v24[2]; // [esp+18h] [ebp-10h]
  int v25[2]; // [esp+20h] [ebp-8h]
  int v26; // [esp+30h] [ebp+8h]
  int v27; // [esp+30h] [ebp+8h]
  unsigned int v28; // [esp+34h] [ebp+Ch]

  v5 = this;
  v23 = -1;
  sub_401A70(&v23, a2, a3);
  v6 = 1000000;
  v7 = 0;
  v26 = 1000000;
  v25[0] = 0;
  result = v5 + 753;
  v24[0] = 127;
  do
  {
    if ( result[1] == v23 && result[9] == a4 && result[2] == a3 )
    {
      if ( !memcmp(result + 3, a2, a3) )
      {
        result[8] = this[2549];
        return result;
      }
      v5 = this;
      v6 = v26;
    }
    if ( result[8] < v5[2549] - 1 && !v7 )
      v7 = result;
    v9 = result[2];
    if ( v9 <= v6 )
    {
      v6 = result[2];
      v25[0] = (int)result;
      v26 = v9;
    }
    result += 14;
  }
  while ( v24[0]-- != 0 );
  if ( !v7 )
  {
    if ( (int)(a3 - 5) <= v6 )
      return 0;
    v7 = (int *)v25[0];
  }
  result = (int *)*v7;
  v27 = *v7;
  if ( *v7 )
  {
    v7[1] = v23;
    v7[2] = a3;
    v7[8] = v5[2549];
    v7[9] = a4;
    sub_46CAB0((unsigned int)(v7 + 3), a2, a3);
    v11 = v5[18806];
    v12 = v5[18807];
    v13 = a3 * v11;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = v13;
    v7[13] = v12;
    sub_405680(v27, 0, 0, v13, v12, 0);
    if ( *(_BYTE *)(v27 + 35) )
    {
      v14 = this[2554];
      v25[0] = this[2552];
    }
    else
    {
      v14 = this[2553];
      v25[0] = this[2551];
    }
    v25[1] = v14;
    v15 = 0;
    v16 = a3;
    v17 = a3 - 1;
    v24[0] = 96 * a4;
    v24[1] = 72 * a4;
    if ( v16 )
    {
      v28 = v17 + 1;
      do
      {
        v18 = *a2;
        v19 = (unsigned __int8)byte_4A9878[v18];
        if ( v19 < 0x80 )
        {
          v20 = (unsigned __int8)byte_4A9778[v18];
          v21 = v25[v20];
          if ( *(_BYTE *)(v21 + 640) )
            sub_404D10((_DWORD *)v21, v27, v15, 0, v19 + v24[v20], 1);
        }
        ++a2;
        v15 += this[18806];
        --v28;
      }
      while ( v28 );
    }
    result = v7;
  }
  return result;
}

//----- (00414B30) --------------------------------------------------------
_WORD *__thiscall sub_414B30(_WORD *this)
{
  int *v1; // eax
  int v2; // esi

  memset(this + 2, 0, 0x34u);
  memset(this + 28, 0, 0x1Cu);
  this[42] = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 89) = 0;
  *((_DWORD *)this + 90) = 0;
  *((_BYTE *)this + 97) = 0;
  *((_BYTE *)this + 98) = 0;
  *(_DWORD *)this = &off_4AC248;
  *((_DWORD *)this + 211) = 0;
  *((_DWORD *)this + 210) = 0;
  memset(this + 450, 0, 0xD0u);
  memset(this + 424, 0, 0x34u);
  v1 = (int *)&unk_4AA498;
  do
  {
    v2 = *v1++;
    *((_BYTE *)this + v2 + 848) = 1;
  }
  while ( v1 < &dword_4AA4C0 );
  return this;
}
// 4AA4C0: using guessed type int dword_4AA4C0;
// 4AC248: using guessed type int (__stdcall *off_4AC248)(int);

//----- (00414BC0) --------------------------------------------------------
int __thiscall sub_414BC0(int this)
{
  int result; // eax

  result = 0;
  *(_DWORD *)(this + 836) = 0;
  *(_DWORD *)(this + 832) = 0;
  memset((void *)(this + 4), 0, 0x34u);
  memset((void *)(this + 56), 0, 0x1Cu);
  *(_WORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 356) = 0;
  return result;
}

//----- (00414C90) --------------------------------------------------------
int __thiscall sub_414C90(_DWORD *this)
{
  int result; // eax

  if ( !*((_BYTE *)this + 96) || this[25] )
    result = (*(int (__thiscall **)(_DWORD *, int))(*this + 40))(this, this[25] + 1);
  else
    result = (*(int (__thiscall **)(_DWORD *, int))(*this + 40))(this, this[25] + 2);
  return result;
}

//----- (00414CD0) --------------------------------------------------------
int __cdecl sub_414CD0(int *a1, int *a2)
{
  int v2; // ecx
  int v3; // edi
  int result; // eax
  int v5; // esi

  v2 = *a1;
  v3 = *a2;
  result = *(unsigned __int8 *)(*a2 + 156) - *(unsigned __int8 *)(*a1 + 156);
  if ( !result )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 12) + 2168) + 88);
    result = (v5 == *(_DWORD *)(v3 + 88)) - (v5 == *(_DWORD *)(v2 + 88));
    if ( !result )
      result = _strcmpi((const char *)(v2 + 109), (const char *)(v3 + 109));
  }
  return result;
}

//----- (00414D30) --------------------------------------------------------
int __cdecl CompareFunction(const void *a1, const void *a2)
{
  int result; // eax

  result = *(_DWORD *)(*(_DWORD *)a2 + 160)
         + *(_DWORD *)(*(_DWORD *)a2 + 164)
         - *(_DWORD *)(*(_DWORD *)a1 + 164)
         - *(_DWORD *)(*(_DWORD *)a1 + 160);
  if ( !result )
    result = _strcmpi((const char *)(*(_DWORD *)a1 + 109), (const char *)(*(_DWORD *)a2 + 109));
  return result;
}

//----- (00414D70) --------------------------------------------------------
int __cdecl sub_414D70(int *a1, int *a2)
{
  int v2; // esi
  int v3; // edx
  int result; // eax
  int v5; // ebp
  int v6; // edi
  int v7; // ecx

  v2 = *a1;
  v3 = *a2;
  result = *(unsigned __int8 *)(*a2 + 156) - *(unsigned __int8 *)(*a1 + 156);
  if ( !result )
  {
    v5 = *(_DWORD *)(v3 + 88);
    v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 12) + 2168) + 88);
    v7 = *(_DWORD *)(v2 + 88);
    result = (v6 == v5) - (v6 == v7);
    if ( (v6 == v5) == (v6 == v7) )
    {
      result = v7 - v5;
      if ( v7 == v5 )
        result = _strcmpi((const char *)(v2 + 109), (const char *)(v3 + 109));
    }
  }
  return result;
}

//----- (00414E80) --------------------------------------------------------
int __stdcall sub_414E80(int a1)
{
  return 1;
}

//----- (00414E90) --------------------------------------------------------
void __thiscall sub_414E90(int this)
{
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 80) = 0;
  sub_40B7D0(*(void **)(this + 104));
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 108) = 0;
}

//----- (00414EC0) --------------------------------------------------------
int __cdecl sub_414EC0(const void *a1, const void *a2)
{
  char *v2; // edi
  char *v3; // esi
  int v4; // ebx
  int v5; // ebp
  int v6; // kr00_4
  int result; // eax

  v2 = (char *)a1 + 4;
  v3 = (char *)a2 + 4;
  if ( *sub_40BCD0((char *)a1 + 4) )
    v4 = 1000;
  else
    v4 = sub_46D80E(v2);
  if ( *sub_40BCD0(v3) )
    v5 = 1000;
  else
    v5 = sub_46D80E(v3);
  if ( *v2 == 35 )
    v4 += 1000;
  if ( *v3 == 35 )
    v5 += 1000;
  v6 = strcmp((const char *)a1 + 4, v3);
  if ( v6 )
    result = v4 + -(v6 < 0) - ((v6 < 0) - 1) - v5;
  else
    result = v4 - v5;
  return result;
}

//----- (00414F60) --------------------------------------------------------
int __cdecl sub_414F60(const void *a1, const void *a2)
{
  return _strcmpi((const char *)a1 + 96, (const char *)a2 + 96);
}

//----- (00414F80) --------------------------------------------------------
_DWORD *__thiscall sub_414F80(_DWORD *this, int a2)
{
  this[72] = 0;
  this[71] = 0;
  this[70] = 0;
  this[137] = a2;
  this[139] = 0;
  this[140] = 0;
  sub_415040(this + 141);
  this[146] = -1;
  *this = &off_4AC2E0;
  *((_BYTE *)this + 580) = 0;
  *((_BYTE *)this + 552) = 0;
  *((_BYTE *)this + 292) = 0;
  this[68] = 0;
  this[66] = 0;
  *((_BYTE *)this + 8) = 0;
  this[69] = 0;
  this[67] = 0;
  return this;
}
// 4AC2E0: using guessed type int (__stdcall *off_4AC2E0)(int);

//----- (00415030) --------------------------------------------------------
void __usercall sub_415030(int a1@<ecx>, int a2@<ebp>)
{
  sub_40C9D0(a1, a2, 0);
}

//----- (00415040) --------------------------------------------------------
_DWORD *__thiscall sub_415040(_DWORD *this)
{
  int v2; // eax
  int *v3; // ebx
  int v5; // [esp+0h] [ebp-A8h] BYREF
  char v6[128]; // [esp+Ch] [ebp-9Ch] BYREF
  _DWORD *v7; // [esp+8Ch] [ebp-1Ch]
  int v8; // [esp+90h] [ebp-18h]
  int v9[2]; // [esp+94h] [ebp-14h] BYREF
  int v10; // [esp+A4h] [ebp-4h]
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  v9[1] = (int)&v5;
  v7 = this;
  this[3] = 0;
  this[2] = 0;
  this[1] = 0;
  v10 = 0;
  *this = &off_4AC31C;
  v9[0] = -1;
  LOBYTE(v10) = 2;
  v8 = 9234500;
  sub_407E80(v9, (int)&savedregs, (char *)(9234500 - ((_DWORD)&loc_422533 + 1)), 1, 3);
  while ( sub_4085E0(v9, v6, 128) )
  {
    if ( isalnum(v6[0]) )
    {
      v2 = 0;
      v3 = dword_42686C;
      do
        v2 -= *v3++;
      while ( v3 < (int *)&loc_426908 );
      (*(void (__thiscall **)(int, char *))(*(_DWORD *)((char *)this + v2 - 1368936036) + 8))(
        (int)this + v2 - 1368936036,
        v6);
    }
  }
  v10 = 0;
  sub_4087F0(v9);
  return this;
}
// 42686C: using guessed type int dword_42686C[5];
// 4AC31C: using guessed type int (__stdcall *off_4AC31C)(void *Buf2, void *);

//----- (00415130) --------------------------------------------------------
int sub_415130(int a1, int a2, int a3, char *Format, ...)
{
  unsigned int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  unsigned int v8; // edi
  int result; // eax
  va_list va; // [esp+24h] [ebp+18h] BYREF

  va_start(va, Format);
  v4 = 0;
  v5 = a1 + 1880;
  while ( *(_DWORD *)(v5 + 64) > *(_DWORD *)(a1 + 23104) && *(_BYTE *)v5 )
  {
    ++v4;
    v5 += 72;
    if ( v4 >= 4 )
    {
      v4 = 0;
      break;
    }
  }
  vsprintf_0((char *const)(72 * v4 + a1 + 1880), Format, va);
  *(_DWORD *)(a1 + 8 * (9 * v4 + 243)) = *(_DWORD *)(a1 + 23104) + a2;
  v6 = 1114089039;
  v7 = 240;
  do
    v6 ^= *(_DWORD *)&::Format[4 * v7-- - 367644];
  while ( v7 );
  v8 = v6 + 72 * v4;
  result = a1;
  *(_DWORD *)(v8 + a1 + 242504428) = a3;
  return result;
}
// 41515F: conditional instruction was optimized away because of 'esi.4<4u'

//----- (004151D0) --------------------------------------------------------
char __thiscall sub_4151D0(_DWORD *this, _BYTE *a2, int a3, int a4, int a5, int a6)
{
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // edi
  char *v20; // eax
  unsigned int v21; // eax
  char *v22; // esi
  char *v23; // eax
  unsigned int v24; // esi
  int v25; // esi
  unsigned int i; // esi
  int v27; // eax
  _DWORD *v28; // ebx
  int v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // esi
  int v34; // edx
  _DWORD *v35; // edi
  int v36; // edi
  _DWORD *v37; // esi
  int v38; // ecx
  int v39; // edi
  int v40; // edx
  int v41; // eax
  _DWORD *v42; // ebx
  char v44[292]; // [esp+Ch] [ebp-37Ch] BYREF
  char Buffer[300]; // [esp+130h] [ebp-258h] BYREF
  char Str[292]; // [esp+25Ch] [ebp-12Ch] BYREF
  int v47; // [esp+380h] [ebp-8h]
  _DWORD *v48; // [esp+384h] [ebp-4h]
  int savedregs; // [esp+388h] [ebp+0h] BYREF

  v7 = a3;
  v48 = this;
  if ( a3 == 1 && *(_BYTE *)(this[66] + 8061) )
  {
    v8 = a4;
    if ( a4 != *(_DWORD *)(this[137] + 7504) )
      return v8;
  }
  else
  {
    v8 = a4;
  }
  if ( *((_BYTE *)this + 552) && (a3 == 2 || a3 == 1) && v8 != *(_DWORD *)(this[137] + 7504) )
    return v8;
  v9 = 0;
  v47 = 0;
  if ( a3 && a3 != 8 && a3 != 7 && (a3 != 9 || v8 == *(_DWORD *)(this[137] + 7504)) && v8 >= 0 )
  {
    v8 = *(_DWORD *)(this[137] + 4 * v8 + 113620);
    v47 = v8;
    v9 = v8;
  }
  v10 = a5;
  if ( !a5 )
    goto LABEL_38;
  if ( a5 < 150 )
    goto LABEL_24;
  v8 = this[66];
  if ( *(_BYTE *)(v8 + 8064) )
    goto LABEL_38;
  if ( !v9 || a3 != 3 )
  {
LABEL_24:
    switch ( v10 )
    {
      case 'd':
        v11 = *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 312);
        (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v11 + 20))(v11, 0, 0, 1, 0);
        v8 = this[137];
        *(_DWORD *)(v8 + 120564) = 8000;
        break;
      case 'e':
        v12 = *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 312);
        LOBYTE(v8) = (*(int (__thiscall **)(int))(*(_DWORD *)v12 + 28))(v12);
        *(_DWORD *)(this[137] + 120564) = 0;
        break;
      case 'f':
        v13 = *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 312);
        LOBYTE(v8) = (*(int (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v13 + 20))(v13, 0, 0, 0, 0);
        break;
      case 'g':
        v14 = *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 316);
        LOBYTE(v8) = (*(int (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v14 + 20))(v14, 0, 0, 0, 0);
        break;
      case 'h':
        v15 = *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 320);
        LOBYTE(v8) = (*(int (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v15 + 20))(v15, 0, 0, 0, 0);
        break;
      default:
        v16 = 767152651;
        v17 = 227;
        do
          v16 ^= *(_DWORD *)&aContinuumupdat[4 * v17-- - 567496];
        while ( v17 );
        v18 = *(_DWORD *)(*(_DWORD *)((char *)v48 + v16 + 1214180) + 120076);
        LOBYTE(v8) = (*(int (__thiscall **)(int, int))(*(_DWORD *)v18 + 24))(v18, v10);
        this = v48;
        v9 = v47;
        break;
    }
    v7 = a3;
LABEL_38:
    if ( !v7 && !*a2 )
      return v8;
    goto LABEL_40;
  }
  if ( *(_DWORD *)(this[137] + 23104) - *(_DWORD *)(v9 + 104) >= 500 )
  {
    *(_DWORD *)(v9 + 104) = *(_DWORD *)(this[137] + 23104);
    goto LABEL_24;
  }
LABEL_40:
  strncpyt(Str, a2, 256);
  v19 = a3;
  Str[256] = 0;
  *(_DWORD *)&Str[288] = a3;
  if ( v9 )
  {
    strcpy(&Str[256], (const char *)(v9 + 109));
    v25 = v47;
    LOBYTE(v8) = *(_BYTE *)(v47 + 141);
    if ( (_BYTE)v8 )
      return v8;
    if ( !*(_BYTE *)(v47 + 156) && a3 == 5 )
      *(_DWORD *)(v47 + 152) = *(_DWORD *)(this[137] + 23104);
    if ( *(_BYTE *)(this[66] + 8060) && !*(_BYTE *)(v25 + 156) )
    {
      a5 = -1;
      sub_401AB0(&a5, (unsigned __int8 *)Str);
      LOBYTE(v8) = a5;
      if ( *(_DWORD *)(v25 + 144) == a5 && *(_DWORD *)(this[137] + 23104) - *(_DWORD *)(v25 + 148) < 500 )
        return v8;
      *(_DWORD *)(v25 + 144) = a5;
    }
    v19 = a3;
    *(_DWORD *)(v25 + 148) = *(_DWORD *)(this[137] + 23104);
  }
  else if ( a3 == 7 )
  {
    if ( Str[0] == 40 )
    {
      LOBYTE(v8) = (*(int (__thiscall **)(_DWORD *, char *, char *))this[141])(this + 141, &Str[1], SubStr);
      if ( (_BYTE)v8 )
        return v8;
      v20 = strstr(Str, SubStr);
      if ( v20 )
      {
        v21 = v20 - Str;
        if ( v21 < 0x20 )
          strncpyt(&Str[256], &Str[1], v21);
      }
    }
  }
  else if ( a3 == 9 )
  {
    LOBYTE(v8) = (*(int (__thiscall **)(_DWORD *, char *, char *))this[141])(this + 141, &Str[2], asc_4AC334);
    if ( (_BYTE)v8 )
      return v8;
    v22 = sub_40BB60(Str, asc_4AC334);
    if ( v22 )
    {
      while ( 1 )
      {
        v23 = strstr(v22 + 2, asc_4AC334);
        if ( !v23 )
          break;
        v22 = v23;
      }
      v24 = v22 - &Str[1];
      if ( v24 < 0x20 )
        strncpyt(&Str[256], &Str[2], v24);
    }
  }
  HIBYTE(a5) = 0;
  if ( !(_BYTE)a6
    && (v19 == 7 || v19 == 5 && a4 != *(_DWORD *)(this[137] + 7504))
    && _strcmpi(&Str[256], (const char *)(*(_DWORD *)(this[137] + 2168) + 109)) )
  {
    if ( *(_BYTE *)(this[66] + 8063) )
    {
      (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(*(_DWORD *)(this[137] + 120076)
                                                                                   + 292)
                                                                     + 20))(
        *(_DWORD *)(*(_DWORD *)(this[137] + 120076) + 292),
        0,
        0,
        0,
        0);
      if ( *(_BYTE *)(this[137] + 7652) )
        sub_435450();
    }
    if ( Str[256] )
    {
      for ( i = 0; i < 0x78; i += 24 )
      {
        if ( !_strcmpi((const char *)(i + this[66] + 8284), &Str[256]) )
          sub_46CAB0(i + this[66] + 8284, (_BYTE *)(i + this[66] + 8308), 96 - i);
      }
      sub_46CAB0(this[66] + 8308, (_BYTE *)(this[66] + 8284), 0x60u);
      strcpy((char *)(this[66] + 8284), &Str[256]);
      v27 = 0;
      v28 = (_DWORD *)((char *)&loc_44E13B + 1);
      do
        v27 -= *v28++;
      while ( v28 < (_DWORD *)((char *)&loc_44E503 + 1) );
      v29 = (int)v48;
      *(_DWORD *)((char *)v48 + v27 - 184532033) = -1;
      if ( !*(_BYTE *)(v29 + 8)
        || (v30 = *(_DWORD *)(v29 + 548), HIBYTE(a5) = 1, *(_DWORD *)(v30 + 23104) - *(_DWORD *)(v29 + 276) <= 200) )
      {
        HIBYTE(a5) = 0;
      }
      this = v48;
    }
  }
  if ( (int)this[72] > 1023 )
  {
    v31 = 1040824702;
    v32 = 233;
    do
      v31 ^= (unsigned int)*(&dword_4A7088 + v32-- - 134963);
    while ( v32 );
    v33 = 64;
    v34 = *(_DWORD *)((char *)v48 + v31 + 1269780);
    v35 = (_DWORD *)((char *)v48 + v31 + 1269780);
    if ( v34 < 64 )
      v33 = *(_DWORD *)((char *)v48 + v31 + 1269780);
    sub_46CAB0(
      *(_DWORD *)((char *)v48 + v31 + 1269772),
      (_BYTE *)(*(_DWORD *)((char *)v48 + v31 + 1269772) + 292 * v33),
      292 * v34 - 292 * v33);
    this = v48;
    *v35 -= v33;
  }
  v36 = this[72];
  v37 = this + 70;
  if ( v36 >= this[71] )
  {
    if ( v36 >= 8 )
      a6 = v36 >= 32 ? 32 : 8;
    else
      a6 = 4;
    sub_40B780(292 * (v36 + a6), (void **)this + 70, (int)&savedregs);
    this[71] += a6;
  }
  v38 = 73 * this[72];
  a6 = 292 * v36;
  sub_46CAB0(*v37 + 4 * (v36 + 8 * (9 * v36 + 9) + 1), (_BYTE *)(*v37 + 292 * v36), 4 * v38 - 292 * v36);
  v39 = a6;
  v40 = a6;
  ++this[72];
  sub_46CAB0(*v37 + v40, v44, 0x124u);
  qmemcpy((void *)(*v37 + v39), Str, 0x124u);
  if ( *(_BYTE *)(this[137] + 113524) )
    (*(void (__cdecl **)(int, char *, char *))(this[66] + 9126))(a3, &Str[256], Str);
  if ( this[146] != -1 )
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 8))(this, Str);
  LOBYTE(v8) = HIBYTE(a5);
  if ( HIBYTE(a5) )
  {
    sprintf_0(Buffer, ":%s:%s", &Str[256], (const char *)this + 8);
    (*(void (__thiscall **)(_DWORD *, char *, _DWORD, _DWORD))(*this + 44))(this, Buffer, 0, 0);
    v41 = 0;
    v42 = (_DWORD *)((char *)&loc_44E807 + 1);
    do
      v41 -= *v42++;
    while ( v42 < (_DWORD *)&loc_44EB94 );
    v8 = v41 + 1346011580;
    *(_DWORD *)((char *)v48 + v8 + 1289172) = *(_DWORD *)(v48[137] + 23104);
  }
  return v8;
}
// 4154E4: conditional instruction was optimized away because of 'esi.4!=0'
// 4A7088: using guessed type int (__stdcall *dword_4A7088)(_DWORD);

//----- (00415950) --------------------------------------------------------
_DWORD *__thiscall sub_415950(_DWORD *this)
{
  int v1; // ecx
  _DWORD *v2; // ebx
  _DWORD *v3; // edi
  int v4; // ecx
  int v5; // ebp
  signed int v6; // esi
  signed int v7; // eax
  signed int v8; // ecx
  bool v9; // zf
  signed int v11; // [esp+0h] [ebp-14h]
  int v12; // [esp+4h] [ebp-10h]
  int v13; // [esp+8h] [ebp-Ch]
  _DWORD *v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v1 = this[137];
  v14 = 0;
  v11 = 0x7FFFFFFF;
  v15 = v1;
  if ( *(int *)(v1 + 6276) <= 0 )
    return 0;
  v12 = v1 + 2180;
  v13 = *(_DWORD *)(v1 + 6276);
  while ( 1 )
  {
    v2 = *(_DWORD **)v12;
    if ( *(_DWORD *)(*(_DWORD *)v12 + 48) + *(_DWORD *)(*(_DWORD *)v12 + 52) )
    {
      if ( !v2[19] && (int)v2[16] <= 0 )
      {
        v3 = *(_DWORD **)(v1 + 2168);
        if ( v2[22] != v3[22] )
        {
          v4 = v2[2];
          v5 = v2[1];
          v6 = abs32(v3[2] - v4);
          v7 = abs32(v3[1] - v5);
          if ( v7 < v6 )
            v7 = v6;
          if ( v7 < v11 )
          {
            v14 = *(_DWORD **)v12;
            v8 = abs32(v3[2] - v4);
            v11 = abs32(v3[1] - v5);
            if ( v11 < v8 )
              v11 = v8;
          }
        }
      }
    }
    v9 = v13 == 1;
    v12 += 4;
    --v13;
    if ( v9 )
      break;
    v1 = v15;
  }
  return v14;
}

//----- (00415A40) --------------------------------------------------------
char __thiscall sub_415A40(char *this, __int16 a2, __int16 a3, char a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8, char a9, __int16 a10)
{
  int v11; // edx
  char v12; // al
  unsigned int i; // ecx
  int v14; // esi
  __int16 v15; // dx
  int v16; // ecx
  int v17; // esi
  int v18; // edx
  unsigned int v19; // edx
  int v20; // eax
  int v21; // edx
  char v22; // al
  unsigned int v23; // edx
  char v24; // al
  unsigned int v25; // edx
  char v26; // al
  int v27; // edx
  char v28; // al
  unsigned int v29; // edx
  char v30; // al
  unsigned int v31; // edx
  char v32; // al
  unsigned int v33; // edx
  char v34; // al
  char result; // al
  int v36; // eax
  int v37; // ecx
  char v38[2]; // [esp+Ch] [ebp-20h] BYREF
  int v39; // [esp+Eh] [ebp-1Eh]
  __int16 v40; // [esp+12h] [ebp-1Ah]
  __int16 v41; // [esp+14h] [ebp-18h]
  char v42; // [esp+16h] [ebp-16h]
  char v43; // [esp+17h] [ebp-15h]
  __int16 v44; // [esp+18h] [ebp-14h]
  __int16 v45; // [esp+1Ah] [ebp-12h]
  __int16 v46; // [esp+1Ch] [ebp-10h]
  __int16 v47; // [esp+1Eh] [ebp-Eh]
  __int16 v48; // [esp+20h] [ebp-Ch]
  __int16 v49; // [esp+22h] [ebp-Ah]
  __int16 v50; // [esp+24h] [ebp-8h]
  __int16 v51; // [esp+26h] [ebp-6h]
  unsigned int v52; // [esp+28h] [ebp-4h]

  if ( *((int *)this + 1569) > 8 && *((int *)this + 356) > 400 )
    a10 = 0;
  v11 = *(_DWORD *)this;
  v38[0] = 3;
  v38[1] = a4;
  v39 = (*(int (__thiscall **)(char *))(v11 + 64))(this);
  v44 = a2;
  v41 = a3;
  v45 = a6;
  v40 = a5;
  v48 = a10;
  v46 = a7;
  v12 = 0;
  v47 = a8;
  v43 = a9;
  v42 = 0;
  for ( i = 0; i < 0x16; ++i )
    v12 ^= v38[i];
  v42 = v12;
  v14 = 22;
  if ( this[1452] || *((_DWORD *)this + 2985) || (a10 & 0x1F) != 0 && !(rand() % 40) )
  {
    v15 = *((_WORD *)this + 60034);
    v16 = *((_DWORD *)this + 542);
    v49 = a8;
    v50 = v15;
    if ( *(_DWORD *)(v16 + 48) + *(_DWORD *)(v16 + 52) <= 0
      || (v17 = *(_DWORD *)(v16 + 596), v17 + *(_DWORD *)(v16 + 600) <= 0) )
    {
      if ( !*(_BYTE *)(v16 + 169) || (v17 = *(_DWORD *)(v16 + 876), v17 + *(_DWORD *)(v16 + 880) <= 0) )
      {
        v51 = 0;
        goto LABEL_18;
      }
      v18 = *(_DWORD *)(v16 + 880);
    }
    else
    {
      v18 = *(_DWORD *)(v16 + 600);
    }
    v19 = (int)((unsigned __int64)(1374389535i64 * (v17 + v18)) >> 32) >> 5;
    v51 = (v19 >> 31) + v19;
LABEL_18:
    v20 = ((unsigned __int8)v52 ^ (*(_DWORD *)(v16 + 396) + *(_DWORD *)(v16 + 400) > 0)) & 1 ^ v52;
    v52 = v20;
    LOBYTE(v20) = v20 & 0xFD;
    v21 = v20 | (2 * (*(_DWORD *)(v16 + 404) + *(_DWORD *)(v16 + 408) > 0));
    v52 = v21;
    if ( *(_DWORD *)(v16 + 696) + *(_DWORD *)(v16 + 700) < 15 )
      v22 = *(_DWORD *)(v16 + 696) + *(_DWORD *)(v16 + 700);
    else
      v22 = 15;
    v23 = v21 & 0xFFFFFFC3 | (4 * (v22 & 0xF));
    v52 = v23;
    if ( *(_DWORD *)(v16 + 688) + *(_DWORD *)(v16 + 692) < 15 )
      v24 = *(_DWORD *)(v16 + 688) + *(_DWORD *)(v16 + 692);
    else
      v24 = 15;
    v25 = v23 & 0xFFFFFC3F | ((v24 & 0xF) << 6);
    v52 = v25;
    if ( *(_DWORD *)(v16 + 720) + *(_DWORD *)(v16 + 724) < 15 )
      v26 = *(_DWORD *)(v16 + 720) + *(_DWORD *)(v16 + 724);
    else
      v26 = 15;
    BYTE1(v25) &= 0xC3u;
    v27 = v25 | ((v26 & 0xF) << 10);
    v52 = v27;
    if ( *(_DWORD *)(v16 + 704) + *(_DWORD *)(v16 + 708) < 15 )
      v28 = *(_DWORD *)(v16 + 704) + *(_DWORD *)(v16 + 708);
    else
      v28 = 15;
    v29 = v27 & 0xFFFC3FFF | ((v28 & 0xF) << 14);
    v52 = v29;
    if ( *(_DWORD *)(v16 + 728) + *(_DWORD *)(v16 + 732) < 15 )
      v30 = *(_DWORD *)(v16 + 728) + *(_DWORD *)(v16 + 732);
    else
      v30 = 15;
    v31 = v29 & 0xFFC3FFFF | ((v30 & 0xF) << 18);
    v52 = v31;
    if ( *(_DWORD *)(v16 + 712) + *(_DWORD *)(v16 + 716) < 15 )
      v32 = *(_DWORD *)(v16 + 712) + *(_DWORD *)(v16 + 716);
    else
      v32 = 15;
    v33 = v31 & 0xFC3FFFFF | ((v32 & 0xF) << 22);
    v52 = v33;
    if ( *(_DWORD *)(v16 + 736) + *(_DWORD *)(v16 + 740) < 15 )
      v34 = *(_DWORD *)(v16 + 736) + *(_DWORD *)(v16 + 740);
    else
      v34 = 15;
    v14 = 32;
    v52 = v33 & 0xC3FFFFFF | ((v34 & 0xF) << 26);
    v52 = v52 & 0xBFFFFFFF | (16 * (*(_DWORD *)(v16 + 748) & 0x4000000));
    v52 = v52 & 0x7FFFFFFF | ((*(_DWORD *)(v16 + 748) & 0xFFF80000) << 12);
  }
  (*(void (__thiscall **)(char *, char *, int, _DWORD))(*(_DWORD *)this + 16))(this, v38, v14, 0);
  result = a10 & 0x1F;
  if ( (a10 & 0x1F) == 5 )
  {
    v36 = -1738961910;
    v37 = 240;
    do
      v36 ^= dword_4B0468[v37-- - 136242];
    while ( v37 );
    result = (*(int (__thiscall **)(char *, char *, int, _DWORD))(*(_DWORD *)&this[v36 + 289313904] + 16))(
               &this[v36 + 289313904],
               v38,
               v14,
               0);
  }
  return result;
}

//----- (00415F40) --------------------------------------------------------
int __thiscall sub_415F40(int this, int a2)
{
  return (*(int (__thiscall **)(_DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(this + 12) + 260))(
           *(_DWORD *)(this + 12),
           a2,
           *(_DWORD *)(this + 4),
           *(_DWORD *)(this + 8),
           *(_DWORD *)(this + 16),
           *(_DWORD *)(this + 20));
}

//----- (00415FE0) --------------------------------------------------------
int __thiscall sub_415FE0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // ebx
  int result; // eax
  int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  _DWORD *v14; // eax
  _DWORD *v15; // edx
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // ebx
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // eax
  int v24; // [esp+Ch] [ebp-10h] BYREF
  int v25; // [esp+10h] [ebp-Ch]
  int v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+18h] [ebp-4h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  if ( (byte_4C1AE0 & 1) == 0 )
  {
    dword_4C1A88 = 0;
    dword_4C1A8C = 0;
    byte_4C1AE0 |= 1u;
    dword_4C1A90 = 1024;
    dword_4C1A94 = 1024;
    sub_46E3C5(nullsub_5);
  }
  v24 = a2;
  v25 = a3;
  v26 = a4 + 1;
  v27 = a5 + 1;
  if ( !sub_454CB0(&v24) )
  {
    if ( sub_454CB0(&dword_4C1A88) )
    {
      sub_454CD0(&v24);
    }
    else
    {
      if ( v24 < dword_4C1A88 )
        v24 = dword_4C1A88;
      if ( v25 < dword_4C1A8C )
        v25 = dword_4C1A8C;
      v9 = v26;
      if ( v26 > dword_4C1A90 )
      {
        v9 = dword_4C1A90;
        v26 = dword_4C1A90;
      }
      if ( v27 > dword_4C1A94 )
        v27 = dword_4C1A94;
      if ( v9 < dword_4C1A88 )
        v26 = dword_4C1A88;
      if ( v27 < dword_4C1A8C )
        v27 = dword_4C1A8C;
      if ( v24 > dword_4C1A90 )
        v24 = dword_4C1A90;
      if ( v25 > dword_4C1A94 )
        v25 = dword_4C1A94;
    }
  }
  result = v24;
  if ( v24 < v26 )
  {
    result = v25;
    if ( v25 < v27 )
    {
      result = this[7060];
      if ( result != 256 )
      {
        if ( --result < 0 )
        {
LABEL_29:
          v12 = (*(int (__thiscall **)(_DWORD *))(*this + 64))(this) - a7;
          if ( v12 > 0x7530 )
            v12 = 0;
          v13 = this[5776] - v12;
          v14 = (_DWORD *)sub_40B720((int)&savedregs, 0x28u);
          v15 = v14;
          if ( v14 )
          {
            v14[1] = a8;
            v14[2] = v24;
            v14[3] = v25;
            v14[4] = v26;
            v16 = v27;
            v15[6] = v13;
            v15[7] = this;
            v15[5] = v16;
            v15[9] = a6;
            *v15 = &off_4AC354;
            v17 = 0;
            v18 = (_DWORD *)((char *)&loc_4264CB + 1);
            do
              v17 -= *v18++;
            while ( v18 < (_DWORD *)((char *)&loc_426895 + 3) );
            *((_BYTE *)v15 + v17 - 1847248514) = 1;
            v19 = v15;
          }
          else
          {
            v19 = 0;
          }
          v20 = 76287812;
          v21 = 238;
          do
            v20 ^= dword_4AB8D0[v21-- - 96156];
          while ( v21 );
          v22 = *(_DWORD *)((char *)this + v20 + 328311448);
          v23 = (int)this + v20 + 328310424;
          if ( v22 >= 256 )
          {
            if ( v19 )
            {
              *v19 = &off_4AC354;
              sub_441B30((int)v19, 0);
              sub_40B7E0((unsigned int)v19);
            }
          }
          else
          {
            *(_DWORD *)(v23 + 4 * v22) = v19;
            ++*(_DWORD *)(v23 + 1024);
          }
          result = (*(int (__thiscall **)(_DWORD *, _DWORD, int, int, int, int))(*this + 260))(
                     this,
                     *(_DWORD *)(this[30019] + 280),
                     16000 * ((v24 + v26) / 2),
                     16000 * ((v25 + v27) / 2),
                     dword_4AA880,
                     dword_4AA884);
        }
        else
        {
          v11 = (int)&this[result + 6804];
          while ( *(_DWORD *)(*(_DWORD *)v11 + 4) != a8 )
          {
            --result;
            v11 -= 4;
            if ( result < 0 )
              goto LABEL_29;
          }
        }
      }
    }
  }
  return result;
}
// 416270: using guessed type int nullsub_5();
// 4AA880: using guessed type int dword_4AA880;
// 4AA884: using guessed type int dword_4AA884;
// 4AC354: using guessed type int (*off_4AC354)();
// 4C1A88: using guessed type int dword_4C1A88;
// 4C1A8C: using guessed type int dword_4C1A8C;
// 4C1A90: using guessed type int dword_4C1A90;
// 4C1A94: using guessed type int dword_4C1A94;
// 4C1AE0: using guessed type char byte_4C1AE0;

//----- (004163D0) --------------------------------------------------------
unsigned int __thiscall sub_4163D0(_DWORD *this)
{
  unsigned int result; // eax
  int v2; // esi
  signed int v3; // edi
  unsigned int v4; // ecx

  result = this[3];
  v2 = *(_DWORD *)(result + 120528);
  if ( v2 )
  {
    v3 = this[1];
    if ( (unsigned int)v3 < 0xFA0000 )
    {
      v4 = this[2];
      if ( v4 < 0xFA0000 )
      {
        result = (unsigned int)((unsigned __int64)(274877907i64 * v3) >> 32) >> 31;
        *(_BYTE *)(v3 / 16000 + (((int)v4 / 16000) << 10) + v2) = -2;
      }
    }
  }
  return result;
}

//----- (00416430) --------------------------------------------------------
int __thiscall sub_416430(int this, int a2, int a3)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // eax
  int *v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edi
  int v20; // eax
  int v21; // ecx
  int v22; // eax

  sub_416CA0(this, a2, a3);
  *(_DWORD *)(this + 444) = 440;
  *(_DWORD *)(this + 448) = 356;
  *(_DWORD *)(this + 460) = 0;
  *(_DWORD *)(this + 464) = 616;
  v4 = dword_4C1AE4;
  *(_DWORD *)(this + 456) = dword_4C1AE4;
  *(_DWORD *)(this + 452) = -v4;
  *(_DWORD *)(this + 480) = 812;
  *(_DWORD *)(this + 484) = 1072;
  *(_DWORD *)(this + 496) = 0;
  *(_DWORD *)(this + 500) = 1220;
  v5 = dword_4C1AE4;
  *(_DWORD *)(this + 492) = dword_4C1AE4;
  *(_DWORD *)(this + 488) = -v5;
  *(_DWORD *)(this + 572) = 76;
  *(_DWORD *)(this + 576) = 332;
  *(_DWORD *)(this + 588) = 0;
  *(_DWORD *)(this + 592) = 1196;
  v6 = dword_4C1AE4;
  *(_DWORD *)(this + 584) = dword_4C1AE4;
  *(_DWORD *)(this + 580) = -v6;
  *(_DWORD *)(this + 620) = 716;
  *(_DWORD *)(this + 624) = 912;
  *(_DWORD *)(this + 636) = 0;
  *(_DWORD *)(this + 640) = 840;
  v7 = dword_4C1AE4;
  *(_DWORD *)(this + 632) = dword_4C1AE4;
  *(_DWORD *)(this + 628) = -v7;
  *(_DWORD *)(this + 840) = 472;
  *(_DWORD *)(this + 844) = 1080;
  *(_DWORD *)(this + 856) = 0;
  *(_DWORD *)(this + 860) = 32;
  v8 = dword_4C1AE4;
  *(_DWORD *)(this + 852) = dword_4C1AE4;
  *(_DWORD *)(this + 848) = -v8;
  *(_DWORD *)this = off_4AC370;
  *(_DWORD *)(this + 100) = &off_4AC36C;
  *(_BYTE *)(this + 156) = 1;
  *(_DWORD *)(this + 76) = 0;
  *(_BYTE *)(this + 812) = 0;
  *(_DWORD *)(this + 868) = -1;
  *(_DWORD *)(this + 828) = -1;
  *(_DWORD *)(this + 824) = -1;
  *(_DWORD *)(this + 508) = -1;
  *(_DWORD *)(this + 560) = 0;
  *(_DWORD *)(this + 660) = 0;
  *(_DWORD *)(this + 652) = 0;
  *(_DWORD *)(this + 356) = 0;
  *(_DWORD *)(this + 644) = 0;
  *(_DWORD *)(this + 428) = 0;
  LOWORD(v8) = *(_WORD *)(a3 + 53);
  v9 = dword_4C1AE4 - (unsigned __int16)v8;
  dword_4C1AE4 = v9;
  *(_DWORD *)(this + 616) = v9;
  *(_DWORD *)(this + 612) = (unsigned __int16)v8 - v9;
  *(_DWORD *)(this + 816) = 0;
  *(_DWORD *)(this + 472) = 0;
  *(_DWORD *)(this + 648) = -1;
  *(_DWORD *)(this + 872) = 0;
  *(_DWORD *)(this + 424) = -1;
  *(_DWORD *)(this + 420) = -1;
  *(_DWORD *)(this + 808) = 0;
  *(_DWORD *)(this + 820) = 0;
  *(_DWORD *)(this + 864) = 0;
  v10 = dword_4C1AE4;
  *(_DWORD *)(this + 880) = dword_4C1AE4;
  *(_DWORD *)(this + 876) = -v10;
  *(_DWORD *)(this + 752) = 0;
  *(_DWORD *)(this + 656) = 0;
  *(_DWORD *)(this + 504) = 0;
  *(_BYTE *)(this + 776) = 0;
  *(_BYTE *)(this + 528) = 0;
  v11 = 0;
  v12 = dword_42686C;
  do
    v11 -= *v12++;
  while ( v12 < (int *)&loc_426908 );
  *(_DWORD *)(v11 - 1371452628 + this + 2517364) = 0;
  *(_DWORD *)(this + 436) = 0;
  v13 = dword_4C1AE4;
  *(_DWORD *)(this + 600) = dword_4C1AE4;
  *(_DWORD *)(this + 596) = -v13;
  v14 = dword_4C1AE4;
  *(_DWORD *)(this + 608) = dword_4C1AE4;
  *(_DWORD *)(this + 604) = -v14;
  *(_DWORD *)(this + 768) = 0;
  v15 = dword_4C1AE4;
  *(_DWORD *)(this + 760) = dword_4C1AE4;
  *(_DWORD *)(this + 756) = -v15;
  v16 = dword_4C1AE4;
  *(_DWORD *)(this + 416) = dword_4C1AE4;
  *(_DWORD *)(this + 412) = -v16;
  v17 = dword_4C1AE4;
  *(_DWORD *)(this + 408) = dword_4C1AE4;
  *(_DWORD *)(this + 404) = -v17;
  v18 = dword_4C1AE4;
  *(_DWORD *)(this + 400) = dword_4C1AE4;
  *(_DWORD *)(this + 396) = -v18;
  v19 = *(_DWORD *)(this + 12);
  v20 = *(_DWORD *)(this + 92);
  *(_DWORD *)(this + 432) = 0;
  *(_DWORD *)(this + 440) = 0;
  *(_DWORD *)(this + 836) = 0;
  *(_DWORD *)(this + 832) = 0;
  *(_DWORD *)(this + 476) = 0;
  *(_DWORD *)(this + 764) = 0;
  *(_DWORD *)(this + 468) = 0;
  *(_DWORD *)(this + 516) = 0;
  *(_DWORD *)(this + 512) = 0;
  *(_DWORD *)(this + 884) = *(_DWORD *)(v19 + 23104) - 101;
  if ( v20 == 8 )
  {
    v20 = 0;
  }
  else
  {
    v21 = *(_DWORD *)(v19 + 1308 * v20 + 13812);
    *(_DWORD *)(this + 80) = v21;
    *(_DWORD *)(this + 68) = 1000 * v21;
  }
  v22 = v19 + 1308 * v20 + 12508;
  *(_DWORD *)(this + 496) = v22;
  *(_DWORD *)(this + 588) = v22;
  *(_DWORD *)(this + 636) = v22;
  *(_DWORD *)(this + 856) = v22;
  *(_DWORD *)(this + 460) = v22;
  sub_4258A0((_DWORD *)this);
  return this;
}
// 42686C: using guessed type int dword_42686C[5];
// 4AC36C: using guessed type int (*off_4AC36C)();
// 4AC370: using guessed type int (__stdcall *off_4AC370[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (004167C0) --------------------------------------------------------
int __thiscall sub_4167C0(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[16] = 0;
  this[15] = 0;
  this[27] = 0;
  this[26] = 0;
  return result;
}

//----- (004167D0) --------------------------------------------------------
int __thiscall sub_4167D0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, char a12, int a13, int a14, int a15)
{
  int result; // eax
  _DWORD *v17; // esi
  int v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  unsigned int v25; // edx
  int v26; // eax
  int v27; // ecx
  int v28; // ecx
  int v29; // eax
  int v30; // eax
  _DWORD *v31; // ebx
  int v32; // eax
  bool v33; // sf
  int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // ecx
  int v38; // ecx
  int v39; // eax
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44[2]; // [esp+Ch] [ebp-20h] BYREF
  int v45; // [esp+14h] [ebp-18h] BYREF
  int v46; // [esp+18h] [ebp-14h]
  int v47; // [esp+1Ch] [ebp-10h] BYREF
  int v48; // [esp+20h] [ebp-Ch]
  int v49; // [esp+24h] [ebp-8h]
  _DWORD *v50; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v50 = this;
  v49 = a11 & 0x1F;
  if ( (a11 & 0x1F) != 0 )
    ++this[432];
  result = a5;
  v17 = (_DWORD *)this[a5 + 28405];
  if ( v17 )
  {
    v18 = v17[83];
    if ( a2 > v18 || (result = abs32(a2 - v18), result >= 1000) )
    {
      v17[83] = a2;
      if ( a14 >= 0 )
      {
        v17[80] = this[5776];
        v19 = a14 - (dword_4C1AE4 - a14);
        dword_4C1AE4 -= a14;
        v17[85] = dword_4C1AE4;
        v17[84] = v19;
      }
      if ( a15 )
      {
        v17[86] = *(_DWORD *)a15;
        v17[87] = *(_DWORD *)(a15 + 4);
        *((_WORD *)v17 + 176) = *(_WORD *)(a15 + 8);
        v17[98] = this[5776];
      }
      v17[89] = a3;
      if ( a4 >= 0 )
        v17[82] = a4;
      v20 = v17[95] + 1;
      v17[93] += a3;
      v17[95] = v20;
      if ( a3 > 150 )
        v17[89] = 150;
      v17[79] = this[5776];
      if ( (a12 & 0x10) != 0 )
      {
        v21 = v17[19];
        v17[11] = 48;
        if ( !v21 )
        {
          v22 = sub_40B720((int)&savedregs, 0x40u);
          if ( v22 )
          {
            v23 = v17[1];
            v24 = v17[2];
            *(_DWORD *)(v22 + 8) = 0;
            *(_DWORD *)(v22 + 4) = 0;
            *(_DWORD *)(v22 + 4) = v23;
            *(_DWORD *)(v22 + 8) = v24;
            *(_DWORD *)(v22 + 12) = this;
            *(_DWORD *)(v22 + 20) = 0;
            *(_DWORD *)(v22 + 16) = 0;
            *(_DWORD *)(v22 + 24) = 0;
            *(_DWORD *)(v22 + 28) = 48;
            *(_DWORD *)(v22 + 32) = 0;
            *(_DWORD *)(v22 + 36) = 11;
            *(_DWORD *)(v22 + 44) = 16;
            *(_DWORD *)(v22 + 48) = 48;
            *(_BYTE *)(v22 + 52) = 0;
            *(_DWORD *)v22 = off_4AC414;
            *(_DWORD *)(v22 + 40) = 0;
            v25 = v22;
          }
          else
          {
            v25 = 0;
          }
          v26 = 1967064616;
          v27 = 56;
          do
            v26 ^= *(_DWORD *)&aSpanishGuatema[4 * v27-- - 427204];
          while ( v27 );
          v28 = *(_DWORD *)((char *)this + v26 + 367019896);
          v29 = (int)this + v26 + 367018872;
          if ( v28 >= 256 )
          {
            sub_40B7E0(v25);
          }
          else
          {
            *(_DWORD *)(v29 + 4 * v28) = v25;
            ++*(_DWORD *)(v29 + 1024);
          }
        }
      }
      if ( (v17[24] & 0x20) == 0 && (a12 & 0x20) != 0 )
      {
        v30 = 0;
        v31 = (_DWORD *)((char *)&loc_40F9D9 + 3);
        do
          v30 -= *v31++;
        while ( v31 < (_DWORD *)((char *)&loc_40FB36 + 2) );
        (*(void (__thiscall **)(int, int))(*(_DWORD *)((char *)this + v30 + 1381982361) + 212))(
          (int)this + v30 + 1381982361,
          a5);
      }
      *((_BYTE *)v17 + 96) = a12;
      v32 = a13;
      v33 = a13 < 0;
      if ( a13 > 0 )
      {
        if ( a13 < v17[8] + v17[9] && !v17[19] )
        {
          v34 = sub_40B720((int)&savedregs, 0x40u);
          if ( v34 )
          {
            v35 = v17[1];
            v36 = v17[2];
            *(_DWORD *)(v34 + 8) = 0;
            *(_DWORD *)(v34 + 4) = 0;
            *(_DWORD *)(v34 + 4) = v35;
            *(_DWORD *)(v34 + 12) = this;
            *(_DWORD *)(v34 + 20) = 0;
            *(_DWORD *)(v34 + 16) = 0;
            *(_DWORD *)(v34 + 24) = 0;
            *(_DWORD *)(v34 + 28) = 52;
            *(_DWORD *)(v34 + 32) = 0;
            *(_DWORD *)(v34 + 36) = 14;
            *(_DWORD *)(v34 + 44) = 26;
            *(_DWORD *)(v34 + 48) = 52;
            *(_BYTE *)(v34 + 52) = 1;
            *(_DWORD *)v34 = off_4AC414;
            *(_DWORD *)(v34 + 8) = v36;
            *(_DWORD *)(v34 + 40) = 0;
          }
          else
          {
            v34 = 0;
          }
          v37 = this[2170];
          if ( v37 >= 256 )
          {
            sub_40B7E0(v34);
          }
          else
          {
            this[v37 + 1914] = v34;
            ++this[2170];
          }
          v32 = a13;
        }
        v33 = v32 < 0;
      }
      if ( !v33 )
      {
        v38 = dword_4C1AE4 - v32;
        v39 = v32 - (dword_4C1AE4 - v32);
        dword_4C1AE4 = v38;
        v17[9] = v38;
        v17[8] = v39;
      }
      v47 = a8;
      v48 = a9;
      v45 = 1000 * a6;
      v46 = 1000 * a7;
      if ( (_WORD)v49 )
        (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, _DWORD *))(*v50 + 132))(
          v50,
          a11,
          1000 * a6,
          1000 * a7,
          v47,
          v48,
          1000 * a10,
          v17);
      v44[0] = 0;
      v44[1] = 0;
      (*(void (__thiscall **)(_DWORD *, _DWORD, int *, int *, int *, _DWORD))(*v17 + 48))(
        v17,
        v17[89],
        &v45,
        &v47,
        v44,
        0);
      v17[4] = v47;
      v17[5] = v48;
      v17[96] = v47;
      v17[97] = v48;
      v17[94] = 20;
      v17[15] = 1000 * a10;
      v40 = abs32(v45 - v17[1]);
      v41 = abs32(v46 - v17[2]);
      if ( v40 <= 64000 && v41 <= 64000 && (v47 || v48) )
      {
        if ( v40 >= 20 )
          v17[4] += (v45 - v17[1]) / 20;
        else
          v17[1] = v45;
        if ( v41 >= 20 )
        {
          v17[5] += (v46 - v17[2]) / 20;
          result = (*(int (__thiscall **)(_DWORD *))(*v17 + 32))(v17);
        }
        else
        {
          v42 = *v17;
          v17[2] = v46;
          result = (*(int (__thiscall **)(_DWORD *))(v42 + 32))(v17);
        }
      }
      else
      {
        v43 = *v17;
        v17[1] = v45;
        v17[2] = v46;
        v17[94] = 0;
        result = (*(int (__thiscall **)(_DWORD *))(v43 + 32))(v17);
      }
    }
  }
  return result;
}
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00416CA0) --------------------------------------------------------
int __thiscall sub_416CA0(int this, int a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  unsigned __int16 v9; // ax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // eax
  unsigned int (__userpurge *v14)@<eax>(_BYTE *@<ebx>, int@<ebp>, int, int, int); // ebx
  int v15; // eax
  int v16; // eax
  char v17; // bl
  int v18; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // edx

  sub_416F60((_DWORD *)this, a2);
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)this = off_4AC484;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 100) = off_4AC428;
  memset((void *)(this + 220), 0, 0x60u);
  v4 = -1685568677;
  v5 = 210;
  do
    v4 ^= *(_DWORD *)&aThorSHammerLos[4 * v5-- - 531772];
  while ( v5 );
  *(_DWORD *)(v4 + this + 678884) = -1;
  *(_DWORD *)(this + 152) = 0;
  *(_BYTE *)(this + 141) = 0;
  *(_BYTE *)(this + 168) = 0;
  *(_DWORD *)(this + 144) = 0;
  *(_DWORD *)(this + 148) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)this = off_4AC430;
  *(_DWORD *)(this + 100) = &off_4AC42C;
  *(_DWORD *)(this + 24) = *(unsigned __int16 *)(a3 + 51);
  sub_46CAB0(this + 109, (_BYTE *)(a3 + 3), 0x14u);
  *(_BYTE *)(this + 129) = 0;
  sub_46CAB0(this + 170, (_BYTE *)(a3 + 23), 0x14u);
  *(_BYTE *)(this + 129) = 0;
  *(_BYTE *)(this + 141) = (*(int (__thiscall **)(int, int))(*(_DWORD *)(*(_DWORD *)(this + 12) + 112184) + 4))(
                             *(_DWORD *)(this + 12) + 112184,
                             this + 109);
  *(_DWORD *)(this + 204) = *(unsigned __int16 *)(a3 + 55);
  *(_DWORD *)(this + 208) = *(unsigned __int16 *)(a3 + 57);
  *(_DWORD *)(this + 160) = *(_DWORD *)(a3 + 43);
  *(_DWORD *)(this + 164) = *(_DWORD *)(a3 + 47);
  v6 = *(unsigned __int8 *)(a3 + 1);
  *(_DWORD *)(this + 92) = v6;
  if ( v6 != 8 )
  {
    v7 = *(_DWORD *)(*(_DWORD *)(this + 12) + 1308 * v6 + 13812);
    *(_DWORD *)(this + 80) = v7;
    *(_DWORD *)(this + 68) = 1000 * v7;
  }
  *(_DWORD *)(this + 28) = *(__int16 *)(a3 + 59);
  v8 = *(_DWORD *)(this + 12);
  *(_BYTE *)(this + 108) = *(_BYTE *)(a3 + 2) != 0;
  *(_DWORD *)(this + 88) = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 152))(
                             v8,
                             *(unsigned __int16 *)(a3 + 53));
  v9 = *(_WORD *)(a3 + 61);
  v10 = dword_4C1AE4 - v9;
  dword_4C1AE4 = v10;
  *(_DWORD *)(this + 52) = v10;
  *(_DWORD *)(this + 48) = v9 - v10;
  v11 = *(_DWORD *)(this + 24);
  v12 = *(_DWORD *)(this + 12);
  *(_BYTE *)(this + 169) = *(_BYTE *)(a3 + 63) != 0;
  *(_BYTE *)(this + 156) = v11 == *(_DWORD *)(v12 + 7504);
  *(_DWORD *)(this + 40) = -1;
  *(_DWORD *)(this + 216) = *(_DWORD *)(v12 + 23104);
  *(_DWORD *)(this + 320) = 0;
  v13 = 0;
  v14 = sub_42B760;
  do
  {
    v13 -= *(_DWORD *)v14;
    v14 = (unsigned int (__userpurge *)@<eax>(_BYTE *@<ebx>, int@<ebp>, int, int, int))((char *)v14 + 4);
  }
  while ( (char *)v14 < (char *)((char *)&loc_42BAA7 + 1) );
  *(_DWORD *)(v13 - 280196733 + this + 1267956) = 0;
  *(_DWORD *)(this + 376) = 0;
  v15 = dword_4C1AE4;
  *(_DWORD *)(this + 36) = dword_4C1AE4;
  *(_DWORD *)(this + 32) = -v15;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 332) = 0;
  *(_DWORD *)(this + 380) = 0;
  *(_DWORD *)(this + 372) = 0;
  *(_DWORD *)(this + 328) = 0;
  *(_DWORD *)(this + 356) = 0;
  *(_BYTE *)(this + 96) = 0;
  *(_DWORD *)(this + 76) = 2;
  *(_DWORD *)(this + 324) = 0;
  *(_DWORD *)(this + 8) = -1;
  *(_DWORD *)(this + 4) = -1;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 392) = 0;
  *(_DWORD *)(this + 316) = 0;
  *(_DWORD *)(this + 216) = 0;
  v16 = dword_4C1AE4;
  *(_DWORD *)(this + 340) = dword_4C1AE4;
  *(_DWORD *)(this + 336) = -v16;
  v17 = *(_BYTE *)(this + 96) & 0xF0;
  *(_DWORD *)(this + 324) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_BYTE *)(this + 96) = v17;
  v18 = 387392512;
  v19 = 238;
  do
    v18 ^= (unsigned int)*(&off_4AC6D4 + v19-- - 97053);
  while ( v19 );
  v20 = (*(_DWORD *)(this + 92) != 8) - 1;
  v21 = dword_4C1AE4 - v20;
  dword_4C1AE4 = v21;
  *(_DWORD *)(v18 + this + 663336) = v21;
  *(_DWORD *)(v18 + this + 663332) = v20 - v21;
  return this;
}
// 4AC428: using guessed type int (*off_4AC428[2])();
// 4AC42C: using guessed type int (*off_4AC42C)();
// 4AC430: using guessed type int (__stdcall *off_4AC430[2])(int, int);
// 4AC484: using guessed type int (__stdcall *off_4AC484[2])(int, int);
// 4AC6D4: using guessed type int (__stdcall *off_4AC6D4)(int, int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00416F60) --------------------------------------------------------
_DWORD *__thiscall sub_416F60(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = a2;
  *this = &off_4AC49C;
  this[2] = 0;
  this[1] = 0;
  return result;
}
// 4AC49C: using guessed type int (__stdcall *off_4AC49C)(int, int);

//----- (00416FC0) --------------------------------------------------------
char __thiscall sub_416FC0(_DWORD *this, int a2, int *a3, int *a4, int *a5, char a6)
{
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // ebx
  int v11; // eax
  int v12; // edi
  _DWORD *v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  unsigned int v22; // edx
  int v23; // ecx
  int v24; // ebx
  int v25; // eax
  int v26; // edi
  _DWORD *v27; // ecx
  int v28; // eax
  int v29; // edx
  int v30; // eax
  _DWORD *v31; // ecx
  int v32; // eax
  int v33; // eax
  int v34; // ebx
  int v35; // edi
  char result; // al
  int v37; // eax
  int v38; // ecx
  int v39; // [esp+18h] [ebp-Ch]
  int v40; // [esp+1Ch] [ebp-8h]
  int v41; // [esp+1Ch] [ebp-8h]
  char v42; // [esp+22h] [ebp-2h]
  char v43; // [esp+22h] [ebp-2h]
  char v44; // [esp+23h] [ebp-1h]

  v44 = 0;
  v39 = 0;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      v7 = a3[1];
      *a3 += *a4;
      v8 = (int)((unsigned __int64)(274877907i64 * v7) >> 32) >> 6;
      v9 = this[20];
      v40 = (int)(v9 + (v8 >> 31) + v8) / 16;
      v10 = (int)((v8 >> 31) + v8 - v9) / 16;
      if ( *a4 >= 0 )
        v11 = v9 + *a3 / 1000;
      else
        v11 = *a3 / 1000 - v9;
      v12 = v11 / 16;
      if ( *a3 < this[17] )
        v12 = -1;
      v42 = 0;
      if ( v10 <= v40 )
      {
        while ( 1 )
        {
          if ( (unsigned int)v12 >= 0x400 || (unsigned int)v10 >= 0x400 )
            goto LABEL_33;
          v13 = (_DWORD *)this[3];
          v14 = v13[30132];
          if ( v14 )
          {
            v15 = v14 + (v10 << 10);
            v16 = *(unsigned __int8 *)(v15 + v12);
            if ( *(_BYTE *)(v15 + v12) )
            {
              if ( *(unsigned __int8 *)(v15 + v12) <= 0xA9u )
                goto LABEL_33;
              if ( (*(unsigned __int8 *)(v15 + v12) < 0xAAu || *(unsigned __int8 *)(v15 + v12) > 0xBFu)
                && v16 != 220
                && v16 != 241 )
              {
                switch ( v16 )
                {
                  case 242:
                    if ( a6 && *((_BYTE *)this + 156) )
                    {
                      (*(void (__thiscall **)(_DWORD *, int, _DWORD, _WORD, _DWORD))(*this + 44))(
                        this,
                        4 * (*(_DWORD *)(v13[542] + 520) + *(_DWORD *)(v13[542] + 524)) / 5,
                        this[6],
                        0,
                        0);
                      v17 = (_DWORD *)this[3];
                      if ( v17[2950] )
                        v18 = (*(int (__thiscall **)(_DWORD *))(*v17 + 64))(v17) / *(_DWORD *)(this[3] + 11800);
                      else
                        v18 = rand();
                      (*(void (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(this[3] + 2168) + 152))(
                        *(_DWORD *)(this[3] + 2168),
                        v18,
                        -1,
                        -1);
                    }
                    goto LABEL_34;
                  case 254:
                    if ( a6 )
                      (*(void (__thiscall **)(_DWORD *, int, int))(*this + 52))(this, v12, v10);
                    goto LABEL_34;
                  case 255:
                    if ( a6 )
                      (*(void (__thiscall **)(_DWORD *, int, int))(*this + 20))(this, v12, v10);
                    goto LABEL_34;
                }
                if ( v16 != 252 && v16 != 253
                  || !(*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v13 + 464))(
                        v13,
                        v12,
                        v10,
                        this[22]) )
                {
LABEL_33:
                  v42 = 1;
                }
              }
            }
          }
LABEL_34:
          if ( ++v10 > v40 )
          {
            if ( v42 )
            {
              if ( v12 > 1024 )
                v12 = 1024;
              if ( *a4 >= 0 )
                v19 = -1 - this[17];
              else
                v19 = this[17] + 16000;
              *a3 = v19 + 16000 * v12;
              if ( (int)this[16] <= 0 )
              {
                if ( (int)abs32(*a4) > 1000 )
                  v44 = 1;
                v20 = *(_DWORD *)(this[3] + 10976);
                if ( !v20 )
                  v20 = 16;
                *a4 = -16 * *a4 / v20;
                a4[1] = 16 * a4[1] / v20;
                *a5 = -16 * *a5 / v20;
                a5[1] = 16 * a5[1] / v20;
              }
              else
              {
                a5[1] = 0;
                *a5 = 0;
                a4[1] = 0;
                *a4 = 0;
              }
            }
            break;
          }
        }
      }
      v21 = *a3;
      a3[1] += a4[1];
      v22 = (int)((unsigned __int64)(274877907i64 * v21) >> 32) >> 6;
      v23 = this[20];
      v41 = (int)((v22 >> 31) + v22 + v23) / 16;
      v24 = (int)((v22 >> 31) + v22 - v23) / 16;
      if ( a4[1] >= 0 )
        v25 = v23 + a3[1] / 1000;
      else
        v25 = a3[1] / 1000 - v23;
      v26 = v25 / 16;
      if ( a3[1] < this[17] )
        v26 = -1;
      v43 = 0;
      if ( v24 <= v41 )
        break;
LABEL_94:
      if ( ++v39 >= a2 )
        goto LABEL_95;
    }
    while ( 1 )
    {
      if ( (unsigned int)v24 >= 0x400 || (unsigned int)v26 >= 0x400 )
        goto LABEL_79;
      v27 = (_DWORD *)this[3];
      v28 = v27[30132];
      if ( v28 )
      {
        v29 = v28 + (v26 << 10);
        v30 = *(unsigned __int8 *)(v29 + v24);
        if ( *(_BYTE *)(v29 + v24) )
        {
          if ( *(unsigned __int8 *)(v29 + v24) <= 0xA9u )
            goto LABEL_79;
          if ( (*(unsigned __int8 *)(v29 + v24) < 0xAAu || *(unsigned __int8 *)(v29 + v24) > 0xBFu)
            && v30 != 220
            && v30 != 241 )
          {
            switch ( v30 )
            {
              case 242:
                if ( a6 && *((_BYTE *)this + 156) )
                {
                  (*(void (__thiscall **)(_DWORD *, int, _DWORD, _WORD, _DWORD))(*this + 44))(
                    this,
                    4 * (*(_DWORD *)(v27[542] + 520) + *(_DWORD *)(v27[542] + 524)) / 5,
                    this[6],
                    0,
                    0);
                  v31 = (_DWORD *)this[3];
                  if ( v31[2950] )
                    v32 = (*(int (__thiscall **)(_DWORD *))(*v31 + 64))(v31) / *(_DWORD *)(this[3] + 11800);
                  else
                    v32 = rand();
                  (*(void (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(this[3] + 2168) + 152))(
                    *(_DWORD *)(this[3] + 2168),
                    v32,
                    -1,
                    -1);
                }
                goto LABEL_80;
              case 254:
                if ( a6 )
                  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 52))(this, v24, v26);
                goto LABEL_80;
              case 255:
                if ( a6 )
                  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 20))(this, v24, v26);
                goto LABEL_80;
            }
            if ( v30 != 252 && v30 != 253
              || !(*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v27 + 464))(v27, v24, v26, this[22]) )
            {
LABEL_79:
              v43 = 1;
            }
          }
        }
      }
LABEL_80:
      if ( ++v24 > v41 )
      {
        if ( v43 )
        {
          if ( v26 > 1024 )
            v26 = 1024;
          if ( a4[1] >= 0 )
            v33 = -1 - this[17];
          else
            v33 = this[17] + 16000;
          a3[1] = v33 + 16000 * v26;
          if ( (int)this[16] <= 0 )
          {
            v34 = a4[1];
            if ( (int)abs32(v34) > 1000 )
              v44 = 1;
            v35 = *(_DWORD *)(this[3] + 10976);
            if ( !v35 )
              v35 = 16;
            *a4 = 16 * *a4 / v35;
            a4[1] = -16 * v34 / v35;
            *a5 = 16 * *a5 / v35;
            a5[1] = -16 * a5[1] / v35;
          }
          else
          {
            a5[1] = 0;
            *a5 = 0;
            a4[1] = 0;
            *a4 = 0;
          }
        }
        goto LABEL_94;
      }
    }
  }
LABEL_95:
  if ( a6 )
    (*(void (__thiscall **)(_DWORD *))(*this + 12))(this);
  result = v44;
  if ( v44 && a6 )
  {
    v37 = -1946087505;
    v38 = 127;
    do
      v37 ^= dword_4A9230[v38-- - 113831];
    while ( v38 );
    result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)((char *)this
                                                                                                 + v37
                                                                                                 + 1329780)
                                                                                   + 260))(
               *(_DWORD *)((char *)this + v37 + 1329780),
               *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 268),
               *(_DWORD *)((char *)this + v37 + 1329772),
               *(_DWORD *)((char *)this + v37 + 1329776),
               0,
               0);
  }
  return result;
}
// 4A9230: using guessed type int dword_4A9230[];

//----- (00417610) --------------------------------------------------------
__int16 __thiscall sub_417610(char *this, unsigned __int16 a2, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9, int a10, int a11, int a12)
{
  long double v12; // st7
  double v13; // st6
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  __int16 v18; // cx
  int v19; // ebx
  bool v20; // al
  unsigned int v21; // eax
  char v22; // cl
  int v23; // eax
  _DWORD *v24; // ebx
  __int16 v25; // ax
  __int16 v26; // ax
  bool v27; // cl
  int v28; // eax
  _DWORD *i; // ebx
  int v30; // edx
  __int16 v31; // cx

  v12 = (double)a7 * dbl_4AC4A0;
  v13 = (double)a8;
  *((_DWORD *)this + 38) = a10;
  *((_DWORD *)this + 46) = a11;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + 43) = a3;
  *((_DWORD *)this + 4) = a5;
  *(_WORD *)(this + 167) = a2;
  *((_DWORD *)this + 2) = a4;
  *((_DWORD *)this + 44) = a4;
  *((_DWORD *)this + 5) = a6;
  v15 = *((_DWORD *)this + 4) - (__int64)(sin(v12) * v13);
  *((_DWORD *)this + 4) = v15;
  v16 = *((_DWORD *)this + 5) - (__int64)(cos(v12) * v13);
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 5) = v16;
  v17 = v16;
  *((_DWORD *)this + 35) = 0;
  v18 = a2 & 0x1F;
  this[129] = 0;
  if ( v18 == 3 || v18 == 4 )
  {
    if ( (a2 & 0x8000) != 0 )
    {
      *((_DWORD *)this + 5) = 0;
      *((_DWORD *)this + 4) = 0;
    }
    else if ( !v15 && !v17 )
    {
      *((_DWORD *)this + 4) = 1;
    }
    if ( *((_DWORD *)this + 4) || *((_DWORD *)this + 5) )
      *((_DWORD *)this + 35) = *(_DWORD *)(*((_DWORD *)this + 3) + 1308 * a12 + 13700);
    this[129] = *((_DWORD *)this + 35) > 0;
  }
  v19 = *((_DWORD *)this + 2);
  *((_DWORD *)this + 39) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 30) = a11
                         + *((_DWORD *)this + 5)
                         + *((_DWORD *)this + 1)
                         + *((_DWORD *)this + 4)
                         + v19
                         + ((a2 >> 5) & 3)
                         + ((a2 >> 10) & 0x1F);
  v20 = v18 == 1 || v18 == 2 || v18 == 7;
  this[108] = v20;
  HIWORD(v21) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 29) = 0;
  memset(this + 24, 0, 0x54u);
  v22 = this[167] & 0x1F;
  *((_DWORD *)this + 37) = -1;
  this[166] = 0;
  this[164] = 0;
  if ( v22 == 7 )
  {
    this[164] = 1;
    v23 = 0;
    v24 = &loc_44E4C0;
    do
      v23 -= *v24++;
    while ( v24 < (_DWORD *)&loc_44E868 );
    v21 = v23 + 876811627;
    this[v21 + 685970] = 1;
    *(_WORD *)(this + 167) = 66;
  }
  v25 = *(_WORD *)(this + 167);
  *((_DWORD *)this + 40) = -1;
  v26 = v25 & 0x1F;
  *((_DWORD *)this + 34) = -1;
  *((_DWORD *)this + 33) = 0;
  v27 = (v26 == 3 || v26 == 4) && *(_DWORD *)(*((_DWORD *)this + 3) + 1308 * a12 + 13376);
  this[128] = v27;
  if ( v26 == 6 )
  {
    v28 = 0;
    for ( i = (_DWORD *)(&loc_4137CF + 1); (unsigned int)i < 0x413B4C; ++i )
      v28 -= *i;
    *(_DWORD *)&this[v28 - 35492144] = a9[15] / 1000;
    v21 = *((_DWORD *)this + 3);
    *((_DWORD *)this + 31) = a9[12] + a9[13];
    if ( a11 == *(_DWORD *)(v21 + 112476) + *(_DWORD *)(v21 + 112480) )
      v21 = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
              this,
              *(_DWORD *)(*(_DWORD *)(v21 + 120076) + 252));
  }
  if ( (this[167] & 0x1F) == 5 )
  {
    v30 = *(_DWORD *)this;
    *((_DWORD *)this + 39) = 60;
    v21 = (*(int (__thiscall **)(char *))(v30 + 24))(this);
  }
  LOWORD(v21) = *(_WORD *)(this + 167);
  v31 = v21 & 0x1F;
  if ( v31 == 8 )
    JUMPOUT(0x4178D2);
  if ( v31 == 5 )
  {
    LOWORD(v21) = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
                    this,
                    *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 244));
  }
  else if ( v31 != 1 && v31 != 2 || this[164] || this[165] )
  {
    if ( v31 == 3 || v31 == 4 )
    {
      if ( this[128] )
      {
        LOWORD(v21) = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
                        this,
                        *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 4 * ((v21 >> 5) & 3) + 172));
      }
      else if ( *((_DWORD *)this + 4) || *((_DWORD *)this + 5) )
      {
        LOWORD(v21) = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
                        this,
                        *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 4 * ((v21 >> 5) & 3) + 156));
      }
      else
      {
        LOWORD(v21) = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
                        this,
                        *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 4 * ((v21 >> 5) & 3) + 188));
      }
    }
  }
  else
  {
    LOWORD(v21) = (*(int (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 8))(
                    this,
                    *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 4 * ((v21 >> 5) & 3) + 140));
  }
  return v21;
}
// 4178CD: control flows out of bounds to 4178D2
// 417610: could not find valid save-restore pair for ebx
// 417610: could not find valid save-restore pair for edi
// 417610: could not find valid save-restore pair for esi
// 4AC4A0: using guessed type double dbl_4AC4A0;

//----- (004178D7) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge start@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  while ( a2 < (_DWORD *)((char *)&loc_425091 + 3) )
    a1 -= *a2++;
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(a1 + 2128369101 + a3 + 692860) + 8))(
           a1 + 2128369101 + a3 + 692860,
           *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 12) + 120076) + 204));
}
// 417904: positive sp value C has been found
// 4178D7: could not find valid save-restore pair for ebp
// 4178D7: could not find valid save-restore pair for edi

//----- (00417A00) --------------------------------------------------------
int __thiscall sub_417A00(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9, int a10, int a11, int a12, int a13, char a14)
{
  int v15; // ebp
  int result; // eax
  int v17; // esi

  if ( a9 )
  {
    v15 = a9[23];
    a11 = a9[6];
    a12 = a9[22];
  }
  else
  {
    v15 = a13;
  }
  result = (*(int (__thiscall **)(_DWORD *))(*this + 136))(this);
  v17 = result;
  if ( result )
  {
    *(_DWORD *)(result + 180) = this[357];
    *(_BYTE *)(result + 165) = a14;
    (*(void (__thiscall **)(int, int, int, int, int, int, int, int, _DWORD *, int, int, int))(*(_DWORD *)result + 28))(
      result,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a11,
      a12,
      v15);
    result = v17;
    *(_DWORD *)(v17 + 148) = a10;
  }
  return result;
}

//----- (00417AA0) --------------------------------------------------------
char __thiscall sub_417AA0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int *a8)
{
  int v9; // eax
  int v11; // ebx
  __int16 v12; // cx
  int v13; // ecx
  int v14; // ebx
  int v15; // eax
  int v16; // ecx
  _DWORD *v17; // eax
  int v18; // ebp
  long double v19; // st7
  double v20; // st6
  int v21; // ebx
  int v22; // ebp
  int v24; // [esp+80h] [ebp-28h]
  int v25; // [esp+94h] [ebp-14h]
  int v26; // [esp+98h] [ebp-10h]
  int v27; // [esp+9Ch] [ebp-Ch]
  int v28; // [esp+ACh] [ebp+4h]
  int v29; // [esp+B8h] [ebp+10h]
  int v30; // [esp+C0h] [ebp+18h]
  _DWORD *v31; // [esp+C0h] [ebp+18h]
  int v32; // [esp+C4h] [ebp+1Ch]

  v27 = this[1908] + this[1909];
  LOBYTE(v9) = v27 + 4;
  if ( v27 + 4 >= 512 )
    return v9;
  v9 = a8[23];
  if ( v9 == 8 )
    return v9;
  v11 = a2;
  v12 = a2 & 0x1F;
  if ( v12 != 1 && v12 != 2 )
  {
    if ( v12 == 7 )
    {
      v13 = this[327 * v9 + 3331];
      v9 = (int)&this[327 * v9];
      if ( this[1908] + this[1909] + v13 >= 512 )
        return v9;
      v32 = *(_DWORD *)(v9 + 12568);
      LOWORD(a2) = 7;
      (*(void (__thiscall **)(_DWORD *, _DWORD, int, int, _DWORD, _DWORD))(*this + 260))(
        this,
        *(_DWORD *)(this[30019] + 248),
        a3,
        a4,
        0,
        0);
      v29 = this[327 * a8[23] + 3331];
      if ( v29 > 0 )
      {
        v14 = 0;
        v30 = this[327 * a8[23] + 3331];
        do
        {
          (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD, _DWORD, int, int, int *, int, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
            this,
            a2,
            a3,
            a4,
            0,
            0,
            v14 / v29,
            v32,
            a8,
            -1,
            0,
            0,
            0,
            0);
          v14 += 40000;
          --v30;
        }
        while ( v30 );
      }
    }
    else
    {
      if ( v12 == 6 )
        v15 = 0;
      else
        v15 = this[327 * v9 + 3349];
      (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, int, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
        this,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        v15,
        a8,
        -1,
        0,
        0,
        0,
        0);
    }
    goto LABEL_21;
  }
  v16 = this[327 * v9 + 3166];
  v17 = &this[327 * v9];
  v18 = v17[3347];
  v28 = v16 + 40000;
  if ( v17[3178] )
  {
    v19 = (double)(a7 / 1000) * dbl_4AC4B8 - dbl_4AC4B0;
    v20 = (double)a8[20] * dbl_4AC4A8;
    v25 = (__int64)(sin(v19) * v20);
    v26 = (__int64)(cos(v19) * v20);
    (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
      this,
      v11,
      a3 - v25,
      a4 - v26,
      a5,
      a6,
      a7,
      v18,
      a8,
      this[30128],
      0,
      0,
      0,
      0);
    (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
      this,
      v11,
      a3 + v25,
      v26 + a4,
      a5,
      a6,
      a7,
      v18,
      a8,
      this[30128],
      0,
      0,
      0,
      0);
    if ( (v11 & 0x8000) != 0 )
      goto LABEL_19;
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
      this,
      v11,
      a3,
      a4,
      a5,
      a6,
      a7,
      v18,
      a8,
      this[30128],
      0,
      0,
      0,
      0);
    if ( (v11 & 0x8000) != 0 )
    {
LABEL_19:
      (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
        this,
        v11,
        a3,
        a4,
        a5,
        a6,
        a7 + v28,
        v18,
        a8,
        this[30128],
        0,
        0,
        0,
        0);
      (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*this + 248))(
        this,
        v11,
        a3,
        a4,
        a5,
        a6,
        a7 - v28,
        v18,
        a8,
        this[30128],
        0,
        0,
        0,
        0);
      goto LABEL_20;
    }
  }
LABEL_20:
  ++this[30128];
LABEL_21:
  LOBYTE(v9) = sub_417EB0((int)&dword_4C1AD0, 22337, (_BYTE *)this + 1428, 4);
  ++this[357];
  if ( a8 )
  {
    v9 = a8[89];
    if ( v9 )
    {
      v21 = v27;
      v22 = this[1908] + this[1909];
      if ( v27 < v22 )
      {
        v31 = &this[v27 + 2173];
        do
        {
          LOBYTE(v9) = (*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)*v31 + 12))(*v31, a8[89]);
          if ( (_BYTE)v9 )
          {
            v24 = v21;
            --v31;
            --v21;
            LOBYTE(v9) = (*(int (__thiscall **)(_DWORD *, int))(*this + 444))(this, v24);
            --v22;
          }
          ++v21;
          ++v31;
        }
        while ( v21 < v22 );
      }
    }
  }
  return v9;
}
// 4AC4A8: using guessed type double dbl_4AC4A8;
// 4AC4B0: using guessed type double dbl_4AC4B0;
// 4AC4B8: using guessed type double dbl_4AC4B8;
// 4C1AD0: using guessed type int dword_4C1AD0;

//----- (00417EB0) --------------------------------------------------------
char __cdecl sub_417EB0(int a1, int a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // ebp
  int v6; // eax
  _DWORD *v7; // ecx
  int v8; // ebx
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int *v14; // esi
  unsigned int v15; // edi

  LOBYTE(v4) = *(_BYTE *)(a1 + 8);
  if ( (_BYTE)v4 )
  {
    v5 = a3;
    v6 = 0;
    v7 = &a3;
    if ( a3 )
    {
      do
      {
        v8 = v7[1];
        v9 = v7[2];
        v7 += 2;
        v6 += v8;
      }
      while ( v9 );
    }
    v10 = *(_DWORD *)(a1 + 4);
    v11 = *(_DWORD *)(v10 + 4);
    v12 = v11 + v6 + 8;
    *(_DWORD *)(v10 + 4) = v12;
    if ( v12 > *(_DWORD *)a1 )
    {
      v11 = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = v6 + 8;
      *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = 1;
    }
    *(_WORD *)(*(_DWORD *)(a1 + 4) + v11 + 12) = a2;
    *(_WORD *)(*(_DWORD *)(a1 + 4) + v11 + 14) = v6;
    if ( a2 >= 256 )
      v4 = (_BYTE *)sub_412170();
    else
      v4 = (_BYTE *)++dword_4C1B0C;
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + v11 + 16) = v4;
    v13 = *(_DWORD *)(a1 + 4) + v11 + 20;
    if ( v5 )
    {
      v4 = v5;
      v14 = (unsigned int *)&a4;
      do
      {
        v15 = *v14;
        sub_46CAB0(v13, v4, *v14);
        v4 = (_BYTE *)v14[1];
        v14 += 2;
        v13 += v15;
      }
      while ( v4 );
    }
  }
  return (char)v4;
}
// 4C1B0C: using guessed type int dword_4C1B0C;

//----- (00417F70) --------------------------------------------------------
unsigned int __usercall sub_417F70@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>)
{
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned int result; // eax
  _DWORD *v7; // eax
  unsigned int v8; // edi
  int v9; // eax

  v3 = a1[1908];
  v4 = a1[2685];
  if ( v3 + a1[1909] >= v4 )
  {
    if ( v4 == 512 )
    {
      result = 0;
    }
    else
    {
      v7 = (_DWORD *)sub_40B720(a2, 0xC4u);
      v8 = 0;
      if ( v7 )
      {
        v7[2] = 0;
        v7[1] = 0;
        v7[5] = 0;
        v7[4] = 0;
        v7[3] = a1;
        *v7 = off_4AC4C0;
        v8 = (unsigned int)v7;
      }
      v9 = a1[2685];
      if ( v9 >= 512 )
      {
        sub_40B7E0(v8);
      }
      else
      {
        a1[v9 + 2173] = v8;
        ++a1[2685];
      }
      result = v8;
      a1[1908] += a1[1909] - dword_4C1AE4 + 1;
      a1[1909] = dword_4C1AE4;
    }
  }
  else
  {
    a1[1908] = a1[1909] - dword_4C1AE4 + 1 + v3;
    v5 = dword_4C1AE4;
    a1[1909] = dword_4C1AE4;
    result = a1[a1[1908] + 2172 + v5];
  }
  return result;
}
// 4AC4C0: using guessed type int (__stdcall *off_4AC4C0[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00418060) --------------------------------------------------------
int __thiscall sub_418060(int this, int a2, int a3, int a4)
{
  int v4; // ebx
  _BYTE *v5; // eax
  int v6; // ecx
  int v7; // eax
  unsigned int (__userpurge *v8)@<eax>(_BYTE *@<ebx>, int@<ebp>, int, int, int); // ebx

  v4 = this;
  sub_4199D0((_DWORD *)this);
  *(_BYTE *)(v4 + 1453) = 0;
  *(_DWORD *)(v4 + 1724) = 0;
  *(_DWORD *)(v4 + 1720) = 0;
  *(_DWORD *)(v4 + 1716) = 0;
  *(_DWORD *)(v4 + 1740) = 0;
  *(_DWORD *)(v4 + 1736) = 0;
  *(_DWORD *)(v4 + 1732) = 0;
  sub_4185F0((_BYTE *)(v4 + 1752));
  *(_DWORD *)(v4 + 1852) = v4;
  *(_DWORD *)(v4 + 1864) = 0;
  *(_DWORD *)(v4 + 1860) = 0;
  *(_DWORD *)(v4 + 1856) = 0;
  *(_DWORD *)(v4 + 1752) = &off_4AC728;
  *(_BYTE *)(v4 + 1848) = 0;
  v5 = (_BYTE *)(v4 + 1880);
  v6 = 4;
  do
  {
    *v5 = 0;
    v5 += 72;
    --v6;
  }
  while ( v6 );
  *(_DWORD *)(v4 + 6276) = 0;
  memset((void *)(v4 + 2180), 0, 0x1000u);
  *(_DWORD *)(v4 + 7500) = 0;
  memset((void *)(v4 + 6284), 0, 0x4C0u);
  sub_4185F0((_BYTE *)(v4 + 7516));
  *(_DWORD *)(v4 + 7616) = v4;
  *(_DWORD *)(v4 + 7628) = 0;
  *(_DWORD *)(v4 + 7624) = 0;
  *(_DWORD *)(v4 + 7620) = 0;
  *(_DWORD *)(v4 + 7516) = &off_4AC2B4;
  strcpy((char *)(v4 + 7528), (const char *)(9219428 - (_DWORD)dword_41EAC8));
  *(_DWORD *)(v4 + 8680) = 0;
  memset((void *)(v4 + 7656), 0, 0x400u);
  *(_DWORD *)(v4 + 10740) = 0;
  memset((void *)(v4 + 8692), 0, 0x800u);
  *(_DWORD *)(v4 + 22980) = 0;
  *(_DWORD *)(v4 + 22976) = 0;
  *(_DWORD *)(v4 + 22972) = 0;
  sub_4185F0((_BYTE *)(v4 + 22984));
  *(_DWORD *)(v4 + 23084) = v4;
  *(_DWORD *)(v4 + 23096) = 0;
  *(_DWORD *)(v4 + 23092) = 0;
  *(_DWORD *)(v4 + 23088) = 0;
  *(_DWORD *)(v4 + 22984) = off_4AC700;
  *(_BYTE *)(v4 + 22996) = 0;
  *(_BYTE *)(v4 + 27208) = 0;
  *(_DWORD *)(v4 + 28240) = 0;
  memset((void *)(v4 + 27216), 0, 0x400u);
  *(_DWORD *)(v4 + 110188) = 0;
  *(_DWORD *)(v4 + 110184) = 0;
  *(_DWORD *)(v4 + 110180) = 0;
  sub_414F80((_DWORD *)(v4 + 111620), v4);
  *(_DWORD *)(v4 + 112356) = 0;
  *(_BYTE *)(v4 + 112352) = 1;
  *(_DWORD *)(v4 + 112428) = 0;
  *(_DWORD *)(v4 + 112432) = 0;
  *(_DWORD *)(v4 + 112436) = 20;
  *(_DWORD *)(v4 + 112440) = 0;
  *(_BYTE *)(v4 + 112444) = 0;
  *(_BYTE *)(v4 + 112360) = 0;
  *(_DWORD *)(v4 + 112448) = 0;
  *(_BYTE *)(v4 + 112452) = 1;
  *(_DWORD *)(v4 + 112460) = 0;
  *(_DWORD *)(v4 + 112464) = v4;
  *(_DWORD *)(v4 + 112348) = &off_4AC268;
  *(_BYTE *)(v4 + 112424) = 0;
  *(_DWORD *)(v4 + 112468) = 6;
  *(_DWORD *)(v4 + 112456) = 64;
  v7 = 0;
  v8 = sub_42B760;
  do
  {
    v7 -= *(_DWORD *)v8;
    v8 = (unsigned int (__userpurge *)@<eax>(_BYTE *@<ebx>, int@<ebp>, int, int, int))((char *)v8 + 4);
  }
  while ( (char *)v8 < (char *)((char *)&loc_42BAA7 + 1) );
  *(_DWORD *)(v7 - 279157489 + this + 340824) = 0;
  *(_DWORD *)(this + 113508) = 0;
  memset((void *)(this + 112484), 0, 0x400u);
  *(_DWORD *)(this + 113520) = 0;
  *(_DWORD *)(this + 113516) = 0;
  *(_DWORD *)(this + 113512) = 0;
  *(_DWORD *)(this + 113608) = 0;
  *(_DWORD *)(this + 113612) = 0;
  *(_DWORD *)(this + 117716) = a3;
  *(_DWORD *)(this + 119856) = 0;
  *(_DWORD *)(this + 119852) = 0;
  *(_DWORD *)(this + 119848) = 0;
  `eh vector constructor iterator'(
    (char *)(this + 119864),
    8u,
    4,
    (void (__thiscall *)(void *))sub_418410,
    (void (__thiscall *)(void *))sub_415030);
  *(_DWORD *)(this + 120076) = a2;
  *(_BYTE *)(this + 120096) = 1;
  *(_DWORD *)(this + 120100) = 0;
  *(_BYTE *)(this + 120168) = 1;
  *(_DWORD *)(this + 120172) = 0;
  *(_DWORD *)(this + 120176) = 0;
  *(_DWORD *)(this + 120180) = 20;
  *(_BYTE *)(this + 120104) = 0;
  *(_DWORD *)(this + 120204) = 0;
  *(_DWORD *)(this + 120200) = 0;
  *(_DWORD *)(this + 120196) = 0;
  *(_DWORD *)(this + 120208) = this;
  *(_DWORD *)(this + 120192) = &off_4AC6F8;
  *(_DWORD *)(this + 120092) = &off_4AC6D4;
  *(_DWORD *)(this + 120192) = &off_4AC6CC;
  *(_BYTE *)(this + 120188) = 0;
  *(_DWORD *)(this + 120184) = 6;
  *(_DWORD *)(this + 120508) = a4;
  *(_DWORD *)(this + 120524) = 0;
  *(_DWORD *)(this + 120520) = 0;
  *(_DWORD *)(this + 120516) = 0;
  *(_DWORD *)(this + 120528) = 0;
  *(_DWORD *)this = &off_4AC4E8;
  *(_BYTE *)(this + 113572) = 0;
  *(_BYTE *)(this + 113525) = 0;
  *(_BYTE *)(this + 113524) = 0;
  *(_BYTE *)(this + 1420) = 0;
  *(_BYTE *)(this + 1868) = 0;
  *(_BYTE *)(this + 28246) = 0;
  *(_DWORD *)(this + 117784) = 1;
  *(_BYTE *)(this + 117756) = 0;
  return this;
}
// 41EAC8: using guessed type int dword_41EAC8[62];
// 4AC268: using guessed type int (__stdcall *off_4AC268)(int, int, int);
// 4AC2B4: using guessed type int (__stdcall *off_4AC2B4)(int, int, int);
// 4AC4E8: using guessed type int (__stdcall *off_4AC4E8)(int, int, int);
// 4AC6CC: using guessed type int (__stdcall *off_4AC6CC)(int);
// 4AC6D4: using guessed type int (__stdcall *off_4AC6D4)(int, int, int);
// 4AC6F8: using guessed type int (__stdcall *off_4AC6F8)(int);
// 4AC700: using guessed type int (__stdcall *off_4AC700[2])(int, int, int);
// 4AC728: using guessed type int (__stdcall *off_4AC728)(int, int, int);

//----- (00418410) --------------------------------------------------------
_DWORD *__thiscall sub_418410(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[1] = 0;
  return result;
}

//----- (00418420) --------------------------------------------------------
char __thiscall sub_418420(int *this, _DWORD *a2)
{
  return sub_40FDA0(this + 1, a2, 0);
}

//----- (00418440) --------------------------------------------------------
_DWORD *__thiscall sub_418440(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = this[4];
  a2[1] = this[5];
  return result;
}

//----- (00418460) --------------------------------------------------------
int __thiscall sub_418460(_DWORD *this)
{
  return this[178];
}

//----- (00418470) --------------------------------------------------------
char __thiscall sub_418470(char *this)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int **v5; // ebx
  void *v6; // ecx
  void *v7; // ecx
  int v8; // eax
  int v9; // ebx
  char v11[2]; // [esp+12h] [ebp-Eh] BYREF
  int v12; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  *(_DWORD *)this = &off_4AC74C;
  v2 = *((_DWORD *)this + 228);
  v3 = 0;
  v12 = 5;
  if ( v2 )
  {
    v11[0] = 0;
    v11[1] = 7;
    off_4AC760(2, v11);
    (*(void (__thiscall **)(char *, int, char *))(*(_DWORD *)this + 20))(this, 2, v11);
    v4 = 0;
    v5 = &off_40FADC;
    do
      v4 -= (int)*v5++;
    while ( v5 < (int **)sub_40FCDC );
    sub_40FD80((int *)&this[v4 + 25717699]);
    (*(void (__thiscall **)(char *))(*(_DWORD *)this + 24))(this);
  }
  LOBYTE(v12) = 4;
  sub_40C9D0((int)(this + 768), (int)&savedregs, 0);
  LOBYTE(v12) = 3;
  sub_40C9D0((int)(this + 760), (int)&savedregs, 0);
  v6 = (void *)*((_DWORD *)this + 187);
  LOBYTE(v12) = 2;
  sub_40B7D0(v6);
  *((_DWORD *)this + 187) = 0;
  *((_DWORD *)this + 189) = 0;
  *((_DWORD *)this + 188) = 0;
  v7 = (void *)*((_DWORD *)this + 184);
  LOBYTE(v12) = 1;
  sub_40B7D0(v7);
  *((_DWORD *)this + 184) = 0;
  *((_DWORD *)this + 186) = 0;
  *((_DWORD *)this + 185) = 0;
  v8 = *((_DWORD *)this + 183);
  LOBYTE(v12) = 0;
  if ( v8 > 0 )
  {
    v9 = 0;
    do
    {
      sub_40C9D0(v9 + *((_DWORD *)this + 181), (int)&savedregs, 0);
      ++v3;
      v9 += 16;
    }
    while ( v3 < *((_DWORD *)this + 183) );
  }
  sub_40B7D0(*((void **)this + 181));
  *((_DWORD *)this + 181) = 0;
  *((_DWORD *)this + 183) = 0;
  *((_DWORD *)this + 182) = 0;
  v12 = -1;
  return sub_40FE80(this + 4);
}
// 40FADC: using guessed type int *off_40FADC;
// 40FCDC: using guessed type int __stdcall sub_40FCDC(int);
// 4AC74C: using guessed type int (*off_4AC74C)();
// 4AC760: using guessed type int (__stdcall *off_4AC760)(_DWORD, _DWORD);

//----- (004185D0) --------------------------------------------------------
char *__thiscall sub_4185D0(char *this, char a2)
{
  sub_418470(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (004185F0) --------------------------------------------------------
_BYTE *__thiscall sub_4185F0(_BYTE *this)
{
  _BYTE *result; // eax

  result = this;
  this[4] = 1;
  *((_DWORD *)this + 2) = 0;
  this[76] = 1;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 20;
  *((_DWORD *)this + 23) = 0;
  this[96] = 0;
  *(_DWORD *)this = &off_4AC7A0;
  this[12] = 0;
  return result;
}
// 4AC7A0: using guessed type int (__stdcall *off_4AC7A0)(int, int, int);

//----- (00418620) --------------------------------------------------------
void __thiscall sub_418620(int this)
{
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 80) = 0;
  sub_40B7D0(*(void **)(this + 104));
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 108) = 0;
}

//----- (00418650) --------------------------------------------------------
int __thiscall sub_418650(_BYTE *this)
{
  int result; // eax

  result = (*(int (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 380))(this, 13);
  this[23111] = 0;
  return result;
}

//----- (00418670) --------------------------------------------------------
int __thiscall sub_418670(_BYTE *this)
{
  int result; // eax

  result = (*(int (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 380))(this, 11);
  this[23111] = 0;
  return result;
}

//----- (00418690) --------------------------------------------------------
char *__thiscall sub_418690(char *this)
{
  return this + 111912;
}

//----- (004186A0) --------------------------------------------------------
unsigned int __userpurge sub_4186A0@<eax>(unsigned int a1@<ecx>, int a2@<ebp>, char a3)
{
  sub_4187E0(a1, a2);
  if ( (a3 & 1) != 0 )
    sub_40B7E0(a1);
  return a1;
}

//----- (004187E0) --------------------------------------------------------
char __usercall sub_4187E0@<al>(int a1@<ecx>, int a2@<ebp>)
{
  int v3; // eax
  int v4; // ebx
  int v5; // edi
  int v6; // eax
  unsigned int *v7; // edi
  int v8; // ebp
  unsigned int *v9; // edi
  int v10; // ebx
  unsigned int *v11; // edi
  unsigned int *v12; // edi

  *(_DWORD *)a1 = &off_4AC4E8;
  if ( *(_BYTE *)(a1 + 113524) )
    (*(void (**)(void))(*(_DWORD *)(a1 + 23100) + 9098))();
  sub_40B7E0(*(_DWORD *)(a1 + 120528));
  v3 = *(_DWORD *)(a1 + 120524);
  v4 = 0;
  v5 = 0;
  *(_DWORD *)(a1 + 120528) = 0;
  if ( v3 > 0 )
  {
    do
      sub_40B7E0(*(_DWORD *)(*(_DWORD *)(a1 + 120516) + 4 * v5++));
    while ( v5 < *(_DWORD *)(a1 + 120524) );
  }
  sub_40B7D0(*(void **)(a1 + 120516));
  *(_DWORD *)(a1 + 120516) = 0;
  *(_DWORD *)(a1 + 120524) = 0;
  *(_DWORD *)(a1 + 120520) = 0;
  sub_455490(a1 + 120516);
  if ( a1 == -120092 )
    v6 = 0;
  else
    v6 = a1 + 120192;
  sub_4553F0(v6 + 4);
  `eh vector destructor iterator'((char *)(a1 + 119864), 8u, 4, (int (__thiscall *)(char *))sub_415030);
  sub_455410(a1 + 119848);
  sub_40C9D0(a1 + 113608, a2, 0);
  sub_455450(a1 + 113512, a2);
  sub_455180((unsigned int *)(a1 + 112484));
  sub_4087F0((int *)(a1 + 112204));
  sub_455390(a1 + 112188);
  sub_40C9D0(a1 + 112176, a2, 0);
  sub_4553B0(a1 + 111900);
  sub_455430(a1 + 110180);
  sub_455080((_DWORD *)(a1 + 27216));
  sub_4553D0(a1 + 23088);
  sub_455410(a1 + 22972);
  if ( *(int *)(a1 + 10740) > 0 )
  {
    v7 = (unsigned int *)(a1 + 8692);
    do
    {
      sub_40B7E0(*v7);
      *v7 = 0;
      ++v4;
      ++v7;
    }
    while ( v4 < *(_DWORD *)(a1 + 10740) );
  }
  *(_DWORD *)(a1 + 10740) = 0;
  v8 = 0;
  if ( *(int *)(a1 + 8680) > 0 )
  {
    v9 = (unsigned int *)(a1 + 7656);
    do
    {
      sub_40B7E0(*v9);
      *v9 = 0;
      ++v8;
      ++v9;
    }
    while ( v8 < *(_DWORD *)(a1 + 8680) );
  }
  *(_DWORD *)(a1 + 8680) = 0;
  sub_40B7D0(*(void **)(a1 + 7620));
  v10 = 0;
  *(_DWORD *)(a1 + 7620) = 0;
  *(_DWORD *)(a1 + 7628) = 0;
  *(_DWORD *)(a1 + 7624) = 0;
  if ( *(int *)(a1 + 7500) > 0 )
  {
    v11 = (unsigned int *)(a1 + 6284);
    do
    {
      sub_40B7E0(*v11);
      *v11 = 0;
      ++v10;
      ++v11;
    }
    while ( v10 < *(_DWORD *)(a1 + 7500) );
    v10 = 0;
  }
  *(_DWORD *)(a1 + 7500) = 0;
  if ( *(int *)(a1 + 6276) > 0 )
  {
    v12 = (unsigned int *)(a1 + 2180);
    do
    {
      sub_40B7E0(*v12);
      *v12 = 0;
      ++v10;
      ++v12;
    }
    while ( v10 < *(_DWORD *)(a1 + 6276) );
  }
  *(_DWORD *)(a1 + 6276) = 0;
  sub_40B7D0(*(void **)(a1 + 1856));
  *(_DWORD *)(a1 + 1856) = 0;
  *(_DWORD *)(a1 + 1864) = 0;
  *(_DWORD *)(a1 + 1860) = 0;
  sub_40B7D0(*(void **)(a1 + 1732));
  *(_DWORD *)(a1 + 1732) = 0;
  *(_DWORD *)(a1 + 1740) = 0;
  *(_DWORD *)(a1 + 1736) = 0;
  sub_40B7D0(*(void **)(a1 + 1716));
  *(_DWORD *)(a1 + 1716) = 0;
  *(_DWORD *)(a1 + 1724) = 0;
  *(_DWORD *)(a1 + 1720) = 0;
  return sub_418470((char *)a1);
}
// 4AC4E8: using guessed type int (__stdcall *off_4AC4E8)(int, int, int);

//----- (00418C40) --------------------------------------------------------
_DWORD *__thiscall sub_418C40(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11, int a12, int a13)
{
  _DWORD *result; // eax

  result = this;
  this[6] = a12;
  this[7] = a10;
  this[8] = a7;
  this[9] = a2;
  this[11] = a8;
  this[12] = a9;
  this[3] = a13;
  *((_BYTE *)this + 52) = a11;
  this[2] = 0;
  this[1] = 0;
  this[1] = a3;
  this[5] = 0;
  this[2] = a4;
  this[4] = 0;
  this[4] = a5;
  this[14] = a5;
  this[5] = a6;
  this[15] = a6;
  *this = off_4AC414;
  this[10] = 0;
  return result;
}
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);

//----- (00418CC0) --------------------------------------------------------
_DWORD *__thiscall sub_418CC0(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int *v6; // ecx
  int v7; // edi
  _DWORD *v8; // eax

  sub_405EF0(this, a2);
  v3 = 0;
  *this = &off_4AC7C0;
  this[16] = 0;
  this[15] = 0;
  v4 = -1684611717;
  v5 = 210;
  do
    v4 ^= *(_DWORD *)&aDirectsoundRel[4 * v5-- - 511924];
  while ( v5 );
  *(_DWORD *)((char *)this + v4 + 1361528) = 0;
  this[81] = 0;
  memset(this + 17, 0, 0x3Cu);
  v6 = (int *)&unk_4AAC68;
  v7 = 34;
  while ( 1 )
  {
    v8 = (_DWORD *)((char *)this + *(v6 - 2));
    if ( *v6 > 0 )
    {
      do
      {
        *v8 = 0;
        ++v3;
        ++v8;
      }
      while ( v3 < *v6 );
    }
    v6 += 3;
    if ( !--v7 )
      break;
    v3 = 0;
  }
  return this;
}
// 4AC7C0: using guessed type int (*off_4AC7C0)();

//----- (00418D50) --------------------------------------------------------
_DWORD *__thiscall sub_418D50(_DWORD *this, char a2)
{
  sub_418D70(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00418D70) --------------------------------------------------------
int __thiscall sub_418D70(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // esi
  int i; // ebx
  _DWORD *v5; // esi
  int v6; // edi
  int v7; // ecx
  int v8; // ecx
  int v10; // [esp+10h] [ebp-14h]

  *this = &off_4AC7C0;
  v2 = &unk_4AAC68;
  v10 = 34;
  do
  {
    v3 = (_DWORD *)((char *)this + *(v2 - 2));
    for ( i = 0; i < *v2; ++v3 )
    {
      if ( *v3 )
      {
        (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v3 + 28))(*v3);
        if ( *v3 )
          (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v3 + 36))(*v3, 1);
        *v3 = 0;
      }
      ++i;
    }
    v2 += 3;
    --v10;
  }
  while ( v10 );
  v5 = this + 17;
  v6 = 5;
  do
  {
    if ( *v5 )
    {
      (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v5 + 28))(*v5);
      if ( *v5 )
        (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v5 + 36))(*v5, 1);
      *v5 = 0;
    }
    v5 += 3;
    --v6;
  }
  while ( v6 );
  v7 = this[82];
  if ( v7 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v7 + 36))(v7, 1);
  v8 = this[81];
  if ( v8 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 36))(v8, 1);
  *this = &off_4A8580;
  return sub_405FA0((int)this);
}
// 4A8580: using guessed type int (*off_4A8580)();
// 4AC7C0: using guessed type int (*off_4AC7C0)();

//----- (00418EA0) --------------------------------------------------------
int sub_418EA0()
{
  int result; // eax

  if ( byte_4C1AD8 )
    dword_4A7110(dword_4C1AD4);
  result = dword_4C1ADC;
  if ( dword_4C1ADC )
    result = dword_4A729C(dword_4C1ADC);
  byte_4C1AD8 = 0;
  return result;
}
// 4A7110: using guessed type int (__stdcall *dword_4A7110)(_DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4C1AD4: using guessed type int dword_4C1AD4;
// 4C1AD8: using guessed type char byte_4C1AD8;

//----- (00418ED0) --------------------------------------------------------
int __stdcall sub_418ED0(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)(dword_4C1AFC + 197528) = a1;
  return (*(int (__thiscall **)(int, int, int, int))(*(_DWORD *)dword_4C1AFC + 16))(dword_4C1AFC, a2, a3, a4);
}
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (00418F00) --------------------------------------------------------
int __stdcall sub_418F00(int a1, int a2, int a3)
{
  int result; // eax

  if ( (!a1 || a1 == 3) && a2 == 44 )
  {
    if ( dword_4C1AFC )
      *(_BYTE *)(dword_4C1AFC + 206846) = 1;
    result = 1;
  }
  else if ( a1 < 0 )
  {
    result = dword_4A7318(dword_4C1A98, a1, a2, a3);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4A7318: using guessed type int (__stdcall *dword_4A7318)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C1A98: using guessed type int dword_4C1A98;
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (00418F50) --------------------------------------------------------
int __stdcall sub_418F50(int a1, int a2, __int16 a3, int a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax

  if ( a2 == 272 )
  {
    v5 = dword_4A72A0(dword_4C1A38, 106, 9754721 - (_DWORD)&loc_4A1075);
    v6 = dword_4A72A4(dword_4C1A38, v5);
    v7 = dword_4A72A8(v6);
    dword_4A731C(a1, 1007, v7);
  }
  else
  {
    if ( a2 != 273 )
      return 0;
    if ( a3 == 1 || a3 == 2 )
    {
      dword_4A7320(a1, a3 == 1);
      return 1;
    }
  }
  return 1;
}
// 4A72A0: using guessed type int (__stdcall *dword_4A72A0)(_DWORD, _DWORD, _DWORD);
// 4A72A4: using guessed type int (__stdcall *dword_4A72A4)(_DWORD, _DWORD);
// 4A72A8: using guessed type int (__stdcall *dword_4A72A8)(_DWORD);
// 4A731C: using guessed type int (__stdcall *dword_4A731C)(_DWORD, _DWORD, _DWORD);
// 4A7320: using guessed type int (__stdcall *dword_4A7320)(_DWORD, _DWORD);
// 4C1A38: using guessed type int dword_4C1A38;

//----- (00418FE0) --------------------------------------------------------
int __stdcall sub_418FE0(int a1, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
  {
    dword_4A731C(a1, 1007, a4);
  }
  else
  {
    if ( a2 != 273 )
      return 0;
    if ( a3 == 1 || a3 == 2 )
    {
      dword_4A7320(a1, 0);
      return 1;
    }
  }
  return 1;
}
// 4A731C: using guessed type int (__stdcall *dword_4A731C)(_DWORD, _DWORD, _DWORD);
// 4A7320: using guessed type int (__stdcall *dword_4A7320)(_DWORD, _DWORD);

//----- (00419040) --------------------------------------------------------
int __cdecl sub_419040(int a1)
{
  char v2[260]; // [esp+4h] [ebp-108h] BYREF
  int v3; // [esp+108h] [ebp-4h]

  v3 = 9767854;
  sub_407960(v2, a1 + 269, (_BYTE *)(9767854 - ((_DWORD)&loc_4A43B7 + 3)));
  sub_43E490(*(_DWORD *)(a1 + 265), v2);
  return 0;
}

//----- (004190A0) --------------------------------------------------------
int __userpurge sub_4190A0@<eax>(int a1@<ebx>, int a2, int a3, __int16 a4, int a5)
{
  int v6; // edi
  int v7; // eax
  int v8; // eax
  void (__stdcall *v9)(int, int, int, int, _DWORD); // edi

  if ( a3 == 272 )
  {
    dword_4A72D4(a2, -21, a5);
    v9 = (void (__stdcall *)(int, int, int, int, _DWORD))dword_4A732C;
    dword_4A732C(a2, 1008, 1025, 0, 65536000);
    v9(a2, 1008, 1028, 1, 0);
    dword_4A7324(a2, 0, 20, 0);
    return 1;
  }
  if ( a3 == 273 )
  {
    if ( a4 == 2 )
    {
      v8 = dword_4A72E4(a2, -21);
      (*(void (__thiscall **)(int))(*(_DWORD *)(v8 + 75756) + 76))(v8 + 75756);
      dword_4A7328(a2, 0);
      dword_4A7320(a2, 0);
      return 1;
    }
    return 1;
  }
  if ( a3 != 275 )
    return 0;
  v6 = dword_4A72E4(a2, -21);
  v7 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(v6 + 75756) + 68))(v6 + 75756, 0);
  dword_4A732C(a2, 1008, 1026, v7, a1);
  (**(void (__thiscall ***)(int, int))(v6 + 196404))(v6 + 196404, 2);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v6 + 75756) + 312))(v6 + 75756);
  if ( *(_BYTE *)(v6 + 98867) || *(_BYTE *)(v6 + 196486) )
  {
    dword_4A7328(a2, 0);
    dword_4A7320(a2, 0);
  }
  return 1;
}
// 4190A0: could not find valid save-restore pair for ebx
// 4A72D4: using guessed type int (__stdcall *dword_4A72D4)(_DWORD, _DWORD, _DWORD);
// 4A72E4: using guessed type int (__stdcall *dword_4A72E4)(_DWORD, _DWORD);
// 4A7320: using guessed type int (__stdcall *dword_4A7320)(_DWORD, _DWORD);
// 4A7324: using guessed type int (__stdcall *dword_4A7324)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7328: using guessed type int (__stdcall *dword_4A7328)(_DWORD, _DWORD);
// 4A732C: using guessed type int (__stdcall *dword_4A732C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004191E0) --------------------------------------------------------
int __stdcall sub_4191E0(int a1, int a2, int a3, int a4)
{
  return dword_4A739C(a1, a2, a3, a4);
}
// 4A739C: using guessed type int (__stdcall *dword_4A739C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00419200) --------------------------------------------------------
int __stdcall sub_419200(int a1, int a2, char *a3, int a4)
{
  __time32_t v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // eax
  int v9; // eax
  void *v10; // esp
  char *v11; // eax
  _DWORD v13[8]; // [esp+4h] [ebp-30h] BYREF
  _DWORD v14[2]; // [esp+24h] [ebp-10h] BYREF
  _DWORD v15[2]; // [esp+2Ch] [ebp-8h] BYREF

  dword_4C1A38 = a1;
  dword_4A70CC(v14);
  dword_4A710C(v13);
  dword_4A7314(v15);
  v4 = time_0(0);
  v5 = dword_4A70F4() ^ v4;
  v6 = dword_4A70B0() ^ v5;
  v7 = dword_4A7310() ^ v6;
  v8 = dword_4A7098();
  sub_46E980(v14[0] ^ v14[1] ^ v13[3] ^ v13[5] ^ v13[7] ^ ((v15[0] ^ (2 * v15[1])) << 16) ^ v8 ^ v7);
  sub_4120C0();
  v9 = 4 * (rand() % 256) + 3;
  LOBYTE(v9) = v9 & 0xFC;
  v10 = alloca(v9);
  v11 = a3;
  if ( !a3 )
    v11 = (char *)&unk_4A7DB0;
  sub_426120(v11);
  return 0;
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7310: using guessed type int (*dword_4A7310)(void);
// 4A7314: using guessed type int (__cdecl *dword_4A7314)(_DWORD);

//----- (004192D0) --------------------------------------------------------
_DWORD *__thiscall sub_4192D0(_DWORD *this, int a2, const char *a3, int a4, int a5)
{
  char *v6; // esi
  int v7; // edx
  int v8; // ebx
  int v9; // ebx
  int v10; // eax
  int v12[3]; // [esp+10h] [ebp-118h] BYREF
  char Buffer[256]; // [esp+1Ch] [ebp-10Ch] BYREF
  int v14; // [esp+124h] [ebp-4h]

  v12[2] = (int)this;
  v6 = (char *)(this + 1);
  *this = off_4AC868;
  sub_4199D0(this + 1);
  v14 = 0;
  this[354] = 0;
  this[355] = 0;
  LOBYTE(v14) = 1;
  sub_412390(this + 356);
  this[360] = a2;
  *this = &off_4AC854;
  *(_DWORD *)v6 = &off_4AC800;
  *((_BYTE *)this + 1412) = 0;
  *((_BYTE *)this + 1413) = 0;
  sprintf_0(Buffer, "%s:%u", a3, a4);
  (*(void (__thiscall **)(char *))(*(_DWORD *)v6 + 56))(v6);
  *((_DWORD *)v6 + 177) = 0;
  v6[1395] = a5 != 0;
  *((_DWORD *)v6 + 337) = a5;
  sub_40F920((int)(v6 + 4), (int)(this + 356), a5);
  sub_40F0D0(v12, Buffer);
  v7 = v12[1];
  *((_DWORD *)v6 + 235) = v12[0];
  *((_DWORD *)v6 + 236) = v7;
  sub_40F700((int *)v6 + 1, (int)(v6 + 940), 0, 0);
  v8 = sub_412170();
  v9 = rand() * v8;
  v10 = *(_DWORD *)v6;
  *((_DWORD *)v6 + 24) = v9 & 0x7FFFFFFF;
  (*(void (__thiscall **)(char *))(v10 + 48))(v6);
  sub_412390(this + 356);
  return this;
}
// 4AC800: using guessed type int (__stdcall *off_4AC800)(int, int, int);
// 4AC854: using guessed type int (*off_4AC854)();
// 4AC868: using guessed type int (*off_4AC868[3])();

//----- (00419420) --------------------------------------------------------
char *__thiscall sub_419420(char *this, char a2)
{
  char *result; // eax

  sub_419450((int)this);
  result = this - 4;
  if ( (a2 & 1) != 0 )
  {
    sub_40B7E0((unsigned int)(this - 4));
    result = this - 4;
  }
  return result;
}

//----- (00419450) --------------------------------------------------------
char __fastcall sub_419450(int a1)
{
  int v2; // edi
  int v3; // esi
  int v4; // eax
  int v5; // eax
  int (__fastcall *v6)(int *, int); // ebx
  void *v7; // ecx
  void *v8; // ecx
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+10h] [ebp-10h] BYREF
  int v13; // [esp+1Ch] [ebp-4h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  HIWORD(v12) = HIWORD(a1);
  v2 = 0;
  v13 = 0;
  sub_40C9D0(a1 + 1412, (int)&savedregs, 0);
  v3 = a1 != 4 ? a1 : 0;
  *(_DWORD *)v3 = &off_4AC74C;
  v4 = *(_DWORD *)(v3 + 0x390);
  v13 = 6;
  if ( v4 )
  {
    HIWORD(v12) = 1792;
    (*(void (__thiscall **)(int, int, char *))(*(_DWORD *)v3 + 20))(a1 != 4 ? a1 : 0, 2, (char *)&v12 + 2);
    (*(void (__thiscall **)(int, int, char *))(*(_DWORD *)v3 + 20))(a1 != 4 ? a1 : 0, 2, (char *)&v12 + 2);
    v5 = 0;
    v6 = (int (__fastcall *)(int *, int))((char *)&loc_423E79 + 3);
    do
    {
      v5 -= *(_DWORD *)v6;
      v6 = (int (__fastcall *)(int *, int))((char *)v6 + 4);
    }
    while ( (unsigned int)v6 < (unsigned int)sub_423F90 );
    sub_40FD80((int *)(v3 + v5 + 1504681879 + 2385156));
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  }
  LOBYTE(v13) = 5;
  sub_40C9D0(v3 + 768, (int)&savedregs, 0);
  LOBYTE(v13) = 4;
  sub_40C9D0(v3 + 760, (int)&savedregs, 0);
  v7 = *(void **)(v3 + 748);
  LOBYTE(v13) = 3;
  sub_40B7D0(v7);
  *(_DWORD *)(v3 + 748) = 0;
  *(_DWORD *)(v3 + 756) = 0;
  *(_DWORD *)(v3 + 752) = 0;
  v8 = *(void **)(v3 + 736);
  LOBYTE(v13) = 2;
  sub_40B7D0(v8);
  *(_DWORD *)(v3 + 736) = 0;
  *(_DWORD *)(v3 + 744) = 0;
  *(_DWORD *)(v3 + 740) = 0;
  v9 = *(_DWORD *)(v3 + 732);
  LOBYTE(v13) = 1;
  if ( v9 > 0 )
  {
    v10 = 0;
    do
    {
      sub_40C9D0(v10 + *(_DWORD *)(v3 + 724), (int)&savedregs, 0);
      ++v2;
      v10 += 16;
    }
    while ( v2 < *(_DWORD *)(v3 + 732) );
  }
  sub_40B7D0(*(void **)(v3 + 724));
  *(_DWORD *)(v3 + 724) = 0;
  *(_DWORD *)(v3 + 732) = 0;
  *(_DWORD *)(v3 + 728) = 0;
  v13 = -1;
  return sub_40FE80((_BYTE *)(v3 + 4));
}
// 4AC74C: using guessed type int (*off_4AC74C)();

//----- (004195D0) --------------------------------------------------------
int __thiscall sub_4195D0(_DWORD *this, int a2)
{
  int v3; // esi
  unsigned int v4; // eax
  int v5; // ebx

  v3 = 0;
  v4 = this[355];
  if ( v4 >= 0x4F )
  {
    do
    {
      v5 = v3 + this[354];
      if ( !memchr((const void *)(v5 + 78), 0, v4 - 78) )
        break;
      if ( !a2 )
        return v5;
      v4 = this[355];
      --a2;
      v3 += strlen((const char *)(v5 + 78)) + 79;
    }
    while ( v4 - v3 >= 0x4F );
  }
  return 0;
}

//----- (00419650) --------------------------------------------------------
_DWORD *__usercall sub_419650@<eax>(int a1@<ebp>, const char *a2, int a3)
{
  _DWORD *v3; // eax
  _DWORD *result; // eax

  v3 = (_DWORD *)sub_40B720(a1, 0x5A8u);
  if ( v3 )
    result = sub_4192D0(v3, a3, a2, 4990, *(_DWORD *)(dword_4C1AFC + 206740));
  else
    result = 0;
  return result;
}
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (004197D0) --------------------------------------------------------
int sub_4197D0()
{
  int v0; // ecx
  int v2; // ecx
  int v3; // edx
  int Buffer[32]; // [esp+0h] [ebp-84h] BYREF
  int v5; // [esp+80h] [ebp-4h]

  v0 = *(_DWORD *)(dword_4C1AFC + 206740);
  if ( v0 )
  {
    if ( !((unsigned __int8 (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD))((char *)&byte_410001 + 287))(
            v0,
            Buffer[0],
            Buffer[1],
            Buffer[2]) )
      return 0;
    v2 = *(_DWORD *)(*(_DWORD *)(dword_4C1AFC + 206740) + 4);
    if ( v2 )
    {
      v3 = *(_DWORD *)(dword_4C1AFC + 206740);
      v5 = 9096437;
      sprintf_0((char *const)Buffer, aSocksErrorD08x, v2, *(_DWORD *)(v3 + 8));
      v5 = 9080046;
      dword_4A72F4(*(_DWORD *)(dword_4C1AFC + 197821));
    }
  }
  return 1;
}
// 4A72F4: using guessed type int (__stdcall *dword_4A72F4)(_DWORD);
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (00419870) --------------------------------------------------------
char __usercall sub_419870@<al>(int a1@<ebp>, int a2, unsigned __int16 a3, int a4, int a5)
{
  int v5; // eax
  int v7[2]; // [esp+0h] [ebp-10h] BYREF
  int v8[2]; // [esp+8h] [ebp-8h] BYREF

  v5 = dword_4C1AFC;
  if ( !*(_BYTE *)(dword_4C1AFC + 206836) )
  {
    sub_40F920(dword_4C1AFC + 206744, a1, *(_DWORD *)(dword_4C1AFC + 206740));
    v7[0] = 0;
    v7[1] = 0;
    sub_40F700((int *)(dword_4C1AFC + 206744), (int)v7, 0, 0);
    *(_BYTE *)(dword_4C1AFC + 206836) = 1;
    v5 = dword_4C1AFC;
  }
  v8[0] = a2;
  v8[1] = a3;
  sub_40FD30((_DWORD *)(v5 + 206744), v8);
  return sub_40F990((_DWORD *)(dword_4C1AFC + 206744), a4, a5);
}
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (00419920) --------------------------------------------------------
int __usercall sub_419920@<eax>(int a1@<ebp>, _DWORD *a2, _WORD *a3, int a4, int a5)
{
  int v5; // eax
  int result; // eax
  int v7; // ecx
  int v8[2]; // [esp+4h] [ebp-8h] BYREF

  v5 = dword_4C1AFC;
  if ( !*(_BYTE *)(dword_4C1AFC + 206836) )
  {
    sub_40F920(dword_4C1AFC + 206744, a1, *(_DWORD *)(dword_4C1AFC + 206740));
    v8[0] = 0;
    v8[1] = 0;
    sub_40F700((int *)(dword_4C1AFC + 206744), (int)v8, 0, 0);
    *(_BYTE *)(dword_4C1AFC + 206836) = 1;
    v5 = dword_4C1AFC;
  }
  result = sub_40FB20((_DWORD *)(v5 + 206744), a4, a5, (_DWORD *)(v5 + 206756), 0);
  if ( result > 0 )
  {
    v7 = *(_DWORD *)(dword_4C1AFC + 206760);
    *a2 = *(_DWORD *)(dword_4C1AFC + 206756);
    *a3 = v7;
  }
  return result;
}
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (004199D0) --------------------------------------------------------
_DWORD *__thiscall sub_4199D0(_DWORD *this)
{
  int v2; // eax
  _DWORD *v3; // ebx

  sub_40FE60(this + 1);
  sub_457D50(this + 176, (int)(this + 156));
  this[183] = 0;
  this[182] = 0;
  this[181] = 0;
  this[186] = 0;
  this[185] = 0;
  this[184] = 0;
  this[189] = 0;
  this[188] = 0;
  this[187] = 0;
  this[190] = 0;
  this[191] = 0;
  this[192] = 0;
  this[193] = 0;
  this[336] = 0;
  this[335] = 0;
  this[334] = 0;
  this[333] = 0;
  *this = &off_4AC74C;
  this[228] = 0;
  *((_BYTE *)this + 1395) = 0;
  *((_BYTE *)this + 1394) = 0;
  this[347] = 0x400000;
  v2 = 0;
  v3 = (_DWORD *)((char *)&loc_43D738 + 4);
  do
    v2 -= *v3++;
  while ( v3 < (_DWORD *)&loc_43DA58 );
  *(_DWORD *)((char *)this + v2 - 504199836) = 500;
  *((_BYTE *)this + 1404) = 0;
  this[337] = 0;
  return this;
}
// 4AC74C: using guessed type int (*off_4AC74C)();

//----- (00419BD0) --------------------------------------------------------
int __fastcall sub_419BD0(int a1, int a2)
{
  int v4; // ecx
  __int64 pExceptionObject; // [esp+10h] [ebp-8h] BYREF

  pExceptionObject = (unsigned int)(unsigned __int8)a2 + 1;
  v4 = (__int64)_ceil_default(sqrt((double)pExceptionObject) + dbl_4AC8B0) & *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v4;
  if ( (v4 & 1) == 1 )
  {
    HIDWORD(pExceptionObject) = a2 + 49738869;
    _CxxThrowException((char *)&pExceptionObject + 4, &_TI1I);
  }
  return (a2 + 1453886020) ^ 0x4C12C5A1;
}
// 4AC8B0: using guessed type double dbl_4AC8B0;

//----- (00419C50) --------------------------------------------------------
#error "419C5E: positive sp value has been found (funcsize=13)"

//----- (00419CE0) --------------------------------------------------------
#error "419D1B: positive sp value has been found (funcsize=28)"

//----- (00419E60) --------------------------------------------------------
#error "419E6E: positive sp value has been found (funcsize=10)"

//----- (00419E90) --------------------------------------------------------
#error "419EA5: positive sp value has been found (funcsize=16)"

//----- (00419EC0) --------------------------------------------------------
int __usercall sub_419EC0@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, int a3@<ebx>)
{
  __int64 v4; // rax
  int v5; // ecx
  bool v6; // pf
  char v7; // cf

  v4 = (__int64)_ceil_default(sqrt((double)((unsigned int)a1 + 1)) + dbl_4AC8B0);
  v6 = __SETP__(v4 ^ *(_DWORD *)(a2 + 36), 0);
  *(_DWORD *)(a2 + 36) ^= v4;
  if ( v6 )
    JUMPOUT(0x419F04);
  if ( !v6 )
    JUMPOUT(0x419F06);
  v7 = __CFADD__((unsigned __int64)(895469195i64 * *(int *)(a3 - 5)) >> 32 != 0, *(_BYTE *)(a3 + 761140387)) | __CFADD__(((unsigned __int64)(895469195i64 * *(int *)(a3 - 5)) >> 32 != 0) + *(_BYTE *)(a3 + 761140387), 13);
  *(_BYTE *)(a3 + 761140387) += ((unsigned __int64)(895469195i64 * *(int *)(a3 - 5)) >> 32 != 0) + 13;
  *(_DWORD *)(a3 + 4 * (v5 - 1)) = v7 + *(_DWORD *)(a3 + 4 * (v5 - 1)) - 1866244635;
  return sub_419F20();
}
// 419EFF: control flows out of bounds to 419F04
// 419F01: control flows out of bounds to 419F06
// 419F11: variable 'v5' is possibly undefined
// 419F20: using guessed type int sub_419F20(void);
// 4AC8B0: using guessed type double dbl_4AC8B0;

//----- (00419F20) --------------------------------------------------------
#error "419F38: positive sp value has been found (funcsize=15)"

//----- (00419F50) --------------------------------------------------------
void __fastcall sub_419F50(int a1, int a2)
{
  int v2; // esi
  int pExceptionObject; // [esp+4h] [ebp-4h] BYREF

  v2 = 247158997 - a2 + *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = v2;
  if ( (v2 & 1) == 1 )
  {
    pExceptionObject = a2 + 11813003;
    _CxxThrowException(&pExceptionObject, &_TI1I);
  }
  JUMPOUT(0x419F8D);
}
// 419F9F: control flows out of bounds to 419FA0
// 419F88: control flows out of bounds to 419F8D

//----- (0041A0F0) --------------------------------------------------------
#error "41A0FE: positive sp value has been found (funcsize=9)"

//----- (0041A160) --------------------------------------------------------
#error "41A195: positive sp value has been found (funcsize=24)"

//----- (0041A2D0) --------------------------------------------------------
#error "41A2DD: positive sp value has been found (funcsize=9)"

//----- (0041A450) --------------------------------------------------------
void __thiscall sub_41A450(_DWORD *this)
{
  this[4] += *this | 0x32AAD372;
  JUMPOUT(0x41A46A);
}
// 41A47F: control flows out of bounds to 41A480
// 41A465: control flows out of bounds to 41A46A

//----- (0041A4E0) --------------------------------------------------------
#error "41A4F8: positive sp value has been found (funcsize=15)"

//----- (0041A5A9) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_41A5A9(int a1, int a2)
{
  return (a2 + 499053484) ^ 0x2E883F49;
}
// 41A5B1: positive sp value 8 has been found

//----- (0041A5C0) --------------------------------------------------------
#error "41A5D1: positive sp value has been found (funcsize=13)"

//----- (0041A620) --------------------------------------------------------
void __fastcall sub_41A620(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // eax

  v2 = 780376009;
  if ( cos((double)a2) >= dbl_4A91B8 )
    v2 = a1[15];
  *a1 += v2;
  JUMPOUT(0x41A65F);
}
// 41A65A: control flows out of bounds to 41A65F
// 4A91B8: using guessed type double dbl_4A91B8;

//----- (0041A890) --------------------------------------------------------
#error "41A89F: positive sp value has been found (funcsize=13)"

//----- (0041A8C0) --------------------------------------------------------
#error "41A8D1: positive sp value has been found (funcsize=13)"

//----- (0041A9B0) --------------------------------------------------------
void __thiscall sub_41A9B0(_DWORD *this)
{
  this[2] -= this[2] ^ 0x1AFC29B4;
  JUMPOUT(0x41A9C8);
}
// 41A9DF: control flows out of bounds to 41A9E0
// 41A9C3: control flows out of bounds to 41A9C8

//----- (0041AAC0) --------------------------------------------------------
#error "41AACF: positive sp value has been found (funcsize=11)"

//----- (0041AAF0) --------------------------------------------------------
#error "41AB00: positive sp value has been found (funcsize=12)"

//----- (0041AB20) --------------------------------------------------------
#error "41AB32: positive sp value has been found (funcsize=14)"

//----- (0041B19E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41B19E@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41B1B3: positive sp value 10 has been found
// 41B19E: could not find valid save-restore pair for ebx
// 41B19E: could not find valid save-restore pair for edi
// 41B19E: could not find valid save-restore pair for esi

//----- (0041B9E4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41B9E4@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41B9F9: positive sp value 10 has been found
// 41B9E4: could not find valid save-restore pair for ebx
// 41B9E4: could not find valid save-restore pair for edi
// 41B9E4: could not find valid save-restore pair for esi

//----- (0041C13D) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41C13D@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41C152: positive sp value 10 has been found
// 41C13D: could not find valid save-restore pair for ebx
// 41C13D: could not find valid save-restore pair for edi
// 41C13D: could not find valid save-restore pair for esi

//----- (0041C555) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41C555@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41C56A: positive sp value 10 has been found
// 41C555: could not find valid save-restore pair for ebx
// 41C555: could not find valid save-restore pair for edi
// 41C555: could not find valid save-restore pair for esi

//----- (0041C96B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41C96B@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41C980: positive sp value 10 has been found
// 41C96B: could not find valid save-restore pair for ebx
// 41C96B: could not find valid save-restore pair for edi
// 41C96B: could not find valid save-restore pair for esi

//----- (0041CD85) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41CD85@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41CD9A: positive sp value 10 has been found
// 41CD85: could not find valid save-restore pair for ebx
// 41CD85: could not find valid save-restore pair for edi
// 41CD85: could not find valid save-restore pair for esi

//----- (0041D6A7) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41D6A7@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41D6BC: positive sp value 10 has been found
// 41D6A7: could not find valid save-restore pair for ebx
// 41D6A7: could not find valid save-restore pair for edi
// 41D6A7: could not find valid save-restore pair for esi

//----- (0041E110) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41E110@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41E123: positive sp value 10 has been found
// 41E110: could not find valid save-restore pair for ebx
// 41E110: could not find valid save-restore pair for edi
// 41E110: could not find valid save-restore pair for esi

//----- (0041E6AB) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41E6AB@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41E6C0: positive sp value 10 has been found
// 41E6AB: could not find valid save-restore pair for ebx
// 41E6AB: could not find valid save-restore pair for edi
// 41E6AB: could not find valid save-restore pair for esi

//----- (0041F294) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41F294@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41F2A9: positive sp value 10 has been found
// 41F294: could not find valid save-restore pair for ebx
// 41F294: could not find valid save-restore pair for edi
// 41F294: could not find valid save-restore pair for esi

//----- (0041F8E2) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41F8E2@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41F8F7: positive sp value 10 has been found
// 41F8E2: could not find valid save-restore pair for ebx
// 41F8E2: could not find valid save-restore pair for edi
// 41F8E2: could not find valid save-restore pair for esi

//----- (0041FFB4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_41FFB4@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 41FFC9: positive sp value 10 has been found
// 41FFB4: could not find valid save-restore pair for ebx
// 41FFB4: could not find valid save-restore pair for edi
// 41FFB4: could not find valid save-restore pair for esi

//----- (0042068C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_42068C@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 4206A1: positive sp value 10 has been found
// 42068C: could not find valid save-restore pair for ebx
// 42068C: could not find valid save-restore pair for edi
// 42068C: could not find valid save-restore pair for esi

//----- (00420D29) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_420D29@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 420D3E: positive sp value 10 has been found
// 420D29: could not find valid save-restore pair for ebx
// 420D29: could not find valid save-restore pair for edi
// 420D29: could not find valid save-restore pair for esi

//----- (004214FD) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_4214FD@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 421512: positive sp value 10 has been found
// 4214FD: could not find valid save-restore pair for ebx
// 4214FD: could not find valid save-restore pair for edi
// 4214FD: could not find valid save-restore pair for esi

//----- (00421C6A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_421C6A@<eax>(int a1@<ebp>)
{
  return *(_DWORD *)(a1 - 28);
}
// 421C7F: positive sp value 10 has been found
// 421C6A: could not find valid save-restore pair for ebx
// 421C6A: could not find valid save-restore pair for edi
// 421C6A: could not find valid save-restore pair for esi

//----- (00421C80) --------------------------------------------------------
char *__thiscall sub_421C80(char *this, int a2)
{
  void *v2; // edx
  char *v4; // esi
  char *v5; // eax
  char *v6; // ebp
  const char **v7; // edi
  const char **v8; // edi

  v2 = (void *)a2;
  v4 = this + 8;
  *(_DWORD *)this = 0;
  strncpyt(this + 8, v2, 128);
  this[136] = 0;
  *((_DWORD *)this + 36) = 0;
  this[152] = 0;
  _strlwr(v4);
  *((_DWORD *)this + 37) = 2;
  v5 = strrchr(v4, 46);
  if ( v5 )
  {
    v6 = v5 + 1;
    v7 = (const char **)off_4AAE78;
    while ( strcmp(v6, *v7) )
    {
      if ( ++v7 >= (const char **)off_4AAE80 )
        goto LABEL_7;
    }
    *((_DWORD *)this + 37) = 1;
    strcpy(this + 136, v6);
    *(v6 - 1) = 0;
LABEL_7:
    v8 = (const char **)off_4AAE80;
    while ( strcmp(v6, *v8) )
    {
      if ( ++v8 >= (const char **)&unk_4AAE94 )
        goto LABEL_13;
    }
    *((_DWORD *)this + 37) = 0;
    strcpy(this + 136, v6);
    *(v6 - 1) = 0;
  }
  else
  {
    v6 = strchr(v4, 0);
  }
LABEL_13:
  a2 = dword_4A743C[(unsigned __int8)~this[148]] ^ 0xFFFFFF;
  sub_401A70(&a2, (unsigned __int8 *)this + 8, v6 - this - 8);
  *((_DWORD *)this + 1) = a2;
  return this;
}
// 4A743C: using guessed type int dword_4A743C[];
// 4AAE78: using guessed type char *off_4AAE78[7];
// 4AAE80: using guessed type char *off_4AAE80[5];

//----- (00421E20) --------------------------------------------------------
int __cdecl sub_421E20(const void *a1, const void *a2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax

  v2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)a1;
  result = *(_DWORD *)(*(_DWORD *)a2 + 4) - *(_DWORD *)(*(_DWORD *)a1 + 4);
  if ( !result )
  {
    result = v3 - v2;
    if ( v3 == v2 )
      result = strcmp((const char *)a1 + 136, (const char *)a2 + 136);
  }
  return result;
}

//----- (00421E80) --------------------------------------------------------
int __thiscall sub_421E80(_DWORD *this, int a2)
{
  int v2; // esi
  int v3; // edi
  int v4; // eax
  _DWORD **v5; // ecx
  _DWORD **i; // edx

  v2 = this[6];
  v3 = 0;
  v4 = 0;
  if ( v2 <= 0 )
    return 0;
  v5 = (_DWORD **)this[4];
  for ( i = v5; **i != 1; ++i )
  {
LABEL_6:
    if ( ++v4 >= v2 )
      return 0;
  }
  if ( v3 != a2 )
  {
    ++v3;
    goto LABEL_6;
  }
  return v5[v4][67];
}

//----- (00421ED0) --------------------------------------------------------
void __thiscall sub_421ED0(void *this)
{
  int i; // ebp
  unsigned int v3; // edi

  *(_DWORD *)this = &off_4AC8B8;
  for ( i = 0; i < *((_DWORD *)this + 6); ++i )
  {
    v3 = *(_DWORD *)(*((_DWORD *)this + 4) + 4 * i);
    if ( v3 )
    {
      sub_40C9D0(v3 + 268, i, 0);
      sub_40B7E0(v3);
    }
  }
  sub_40B7D0(*((void **)this + 4));
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 5) = 0;
  sub_40B7D0(*((void **)this + 1));
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = 0;
}
// 4AC8B8: using guessed type int (__stdcall *off_4AC8B8)(int);

//----- (00421F80) --------------------------------------------------------
void *__thiscall sub_421F80(void *this, char a2)
{
  sub_421ED0(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00421FD0) --------------------------------------------------------
int __thiscall sub_421FD0(int *this)
{
  int v1; // edx
  char v3[2]; // [esp+0h] [ebp-10h] BYREF
  int v4; // [esp+2h] [ebp-Eh]
  int v5; // [esp+6h] [ebp-Ah]
  int v6; // [esp+Ah] [ebp-6h]

  v1 = *this;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v3[0] = 0;
  v3[1] = 11;
  return (*(int (__thiscall **)(int *, char *, int, int))(v1 + 16))(this, v3, 2, 1);
}

//----- (00422000) --------------------------------------------------------
int __thiscall sub_422000(_DWORD *this, int a2)
{
  int v3; // eax
  int v5; // [esp+0h] [ebp-148h] BYREF
  char Buffer[300]; // [esp+Ch] [ebp-13Ch] BYREF
  int *v7; // [esp+138h] [ebp-10h]
  int v8; // [esp+144h] [ebp-4h]

  v7 = &v5;
  v3 = *(_DWORD *)(a2 + 288);
  if ( !v3 || v3 == 7 || v3 == 9 || v3 == 8 )
    sprintf_0(Buffer, (const char *const)(9482885 - (_DWORD)&loc_45E9A1), off_4B8168[0][*(_DWORD *)(a2 + 288)], a2);
  else
    sprintf_0(
      Buffer,
      (const char *const)(9482206 - ((_DWORD)&loc_45E6EC + 2)),
      off_4B8168[0][*(_DWORD *)(a2 + 288)],
      *(_DWORD *)(this[66] + 8031),
      *(_DWORD *)(this[66] + 8031),
      a2 + 256,
      a2);
  v8 = 0;
  return sub_408740(this + 146, Buffer);
}
// 4B8168: using guessed type char *off_4B8168[16];

//----- (00422120) --------------------------------------------------------
int __usercall sub_422120@<eax>(unsigned int a1@<eax>, int a2@<ecx>)
{
  int v3; // ebp
  int v4; // eax
  int v5; // edi
  int v6; // ebp
  int v7; // ebx
  int v8; // edx
  int result; // eax
  int v10; // ecx
  int v11; // edi
  int *v12; // ebx
  signed int v13; // ecx
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // edi
  __int16 v17; // ax
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  int v22; // edi
  _DWORD *v23; // ecx
  int v24; // edx
  unsigned int v25; // edx
  int v26; // edi
  __int64 v27; // rax
  __int16 v28; // cx
  unsigned int v29; // edx
  int v30; // eax
  signed int v31; // ecx
  __int64 v32; // rax
  int v33; // [esp-8h] [ebp-3Ch] BYREF
  int v34; // [esp-4h] [ebp-38h]
  int v35; // [esp+10h] [ebp-24h]
  int v36; // [esp+14h] [ebp-20h]
  int v37; // [esp+18h] [ebp-1Ch]
  int v38; // [esp+1Ch] [ebp-18h]
  int v39; // [esp+20h] [ebp-14h]
  int v40; // [esp+24h] [ebp-10h]
  int v41; // [esp+28h] [ebp-Ch]
  int v42; // [esp+2Ch] [ebp-8h]
  int v43; // [esp+30h] [ebp-4h]

  v3 = 18000;
  LOWORD(a1) = *(_WORD *)(a2 + 167);
  if ( (a1 & 0x1F) == 4 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 11544) + ((a1 >> 5) & 3);
  }
  else
  {
    if ( (a1 & 0x1F) != 8 )
      goto LABEL_6;
    v4 = ((a1 >> 5) & 3) + *(_DWORD *)(*(_DWORD *)(a2 + 12) + 11544) + 3;
  }
  v3 = 18000 * v4;
LABEL_6:
  v5 = *(_DWORD *)(a2 + 4);
  v6 = v3 - 14000;
  v42 = v6;
  v7 = (v5 - v6) / 16000;
  v8 = (v5 + v6) / 16000;
  v35 = v7;
  v36 = v8;
  if ( v7 < 0 )
  {
    v35 = 0;
LABEL_10:
    v7 = v35;
    goto LABEL_11;
  }
  if ( v7 >= 1024 )
  {
    v35 = 1023;
    goto LABEL_10;
  }
LABEL_11:
  if ( v8 >= 0 )
  {
    if ( v8 >= 1024 )
      v36 = 1023;
  }
  else
  {
    v36 = 0;
  }
  ++*(_DWORD *)(*(_DWORD *)(a2 + 12) + 117784);
  result = v36;
  if ( v7 > v36 )
    return result;
  v10 = 4 * v7 + 23112;
  result = 80 * v7 + 28256;
  v41 = v10;
  v40 = result;
  while ( 1 )
  {
    v39 = 0;
    v11 = *(_DWORD *)(a2 + 12);
    if ( *(_DWORD *)(v10 + v11) )
      break;
LABEL_54:
    ++v7;
    result += 80;
    v10 += 4;
    v35 = v7;
    v40 = result;
    v41 = v10;
    if ( v7 > v36 )
      return result;
  }
  v37 = result;
  while ( 1 )
  {
    v12 = *(int **)(v37 + v11);
    v13 = v6 + v12[17];
    if ( v12[22] == *(_DWORD *)(a2 + 184) )
      goto LABEL_52;
    v14 = v12[1] - *(_DWORD *)(a2 + 4);
    if ( (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) >= v13 )
      goto LABEL_52;
    v15 = v12[2] - *(_DWORD *)(a2 + 8);
    if ( (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) >= v13 )
      goto LABEL_52;
    if ( v12[16] > 0 )
      goto LABEL_52;
    if ( v12[19] )
      goto LABEL_52;
    v16 = *(_DWORD *)(v11 + 117784);
    if ( v12[18] == v16 )
      goto LABEL_52;
    v12[18] = v16;
    v17 = *(_WORD *)(a2 + 167) & 0x1F;
    if ( v17 == 4 || v17 == 8 )
      break;
    if ( v17 == 3 )
      return (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 20))(a2);
    if ( *(_DWORD *)(a2 + 148) != -1 )
    {
      v15 = *(unsigned int *)(a2 + 12);
      if ( *(_DWORD *)(v15 + 7632) + *(_DWORD *)(v15 + 7636) > 0 )
      {
        v18 = 8692;
        do
        {
          v19 = *(_DWORD *)(v18 + v15);
          if ( *(_DWORD *)(v19 + 148) == *(_DWORD *)(a2 + 148) )
            *(_DWORD *)(v19 + 156) = 49;
          LODWORD(v15) = *(_DWORD *)(a2 + 12);
          ++HIDWORD(v15);
          v18 += 4;
        }
        while ( SHIDWORD(v15) < *(_DWORD *)(v15 + 7632) + *(_DWORD *)(v15 + 7636) );
      }
    }
    if ( *(int *)(a2 + 144) <= 0 )
    {
      *(_DWORD *)(a2 + 156) = 49;
      if ( *((_BYTE *)v12 + 156) )
      {
        v23 = *(_DWORD **)(a2 + 12);
        if ( *(_BYTE *)(a2 + 164) )
        {
          v24 = v23[2968];
          goto LABEL_42;
        }
        BYTE4(v15) = *(_BYTE *)(a2 + 167);
        v25 = (int)((unsigned __int64)(274877907i64 * (v23[2740] + v23[2923] * ((HIDWORD(v15) >> 5) & 3))) >> 32) >> 6;
        v26 = (v25 >> 31) + v25;
        if ( *(_BYTE *)(a2 + 165) )
        {
          v24 = v26 * v23[3072];
LABEL_42:
          v26 = v24 / 1000;
        }
        if ( v23[3104] )
        {
          LODWORD(v27) = 1000 * v26;
        }
        else
        {
          v43 = 1000 * rand() % (v26 * v26 + 1);
          v27 = (__int64)(sqrt((double)v43) * dbl_4A91C0);
        }
        if ( *(_BYTE *)(a2 + 164) )
        {
          LOWORD(v38) = 7;
        }
        else
        {
          v28 = 15;
          if ( !*(_BYTE *)(a2 + 165) )
            v28 = *(_WORD *)(a2 + 167);
          LOWORD(v38) = v28;
        }
        (*(void (__thiscall **)(int *, _DWORD, _DWORD, int, _DWORD))(*v12 + 44))(
          v12,
          v27,
          *(_DWORD *)(a2 + 152),
          v38,
          *(_DWORD *)(a2 + 180));
        goto LABEL_52;
      }
    }
    else
    {
      *(_DWORD *)(a2 + 156) = 1;
      if ( *((_BYTE *)v12 + 156) )
      {
        BYTE4(v15) = *(_BYTE *)(a2 + 167);
        v20 = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 10904) * ((HIDWORD(v15) >> 5) & 3);
        v21 = *v12;
        v34 = *(_DWORD *)(a2 + 180);
        v33 = v34;
        v22 = v20;
        sub_422570(&v33, 15);
        (*(void (__thiscall **)(int *, int, _DWORD, int, int))(v21 + 44))(v12, v22, *(_DWORD *)(a2 + 152), v33, v34);
        v6 = v42;
      }
    }
LABEL_52:
    v10 = v41;
    v37 += 4;
    v11 = *(_DWORD *)(a2 + 12);
    v29 = *(_DWORD *)(v41 + v11);
    if ( ++v39 >= v29 )
    {
      v7 = v35;
      result = v40;
      goto LABEL_54;
    }
  }
  if ( *(int *)(a2 + 192) <= 25 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 20))(a2);
  v30 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 132) = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 11684);
  v31 = abs32(v30 - v12[2]);
  v32 = *(_DWORD *)(a2 + 4) - v12[1];
  result = (HIDWORD(v32) ^ v32) - HIDWORD(v32);
  if ( result < v31 )
    result = v31;
  *(_DWORD *)(a2 + 160) = result;
  *(_DWORD *)(a2 + 136) = v12[6];
  return result;
}
// 4A91C0: using guessed type double dbl_4A91C0;

//----- (00422570) --------------------------------------------------------
_WORD *__thiscall sub_422570(_WORD *this, __int16 a2)
{
  _WORD *result; // eax

  result = this;
  *this = a2;
  return result;
}

//----- (00422580) --------------------------------------------------------
void __thiscall sub_422580(int this, char a2)
{
  int v3; // edi
  int i; // ebx
  int v5; // eax
  char Buffer[512]; // [esp+8h] [ebp-21Ch] BYREF
  int v7; // [esp+208h] [ebp-1Ch]
  unsigned int v8; // [esp+20Ch] [ebp-18h] BYREF
  int v9; // [esp+210h] [ebp-14h]
  char v10; // [esp+217h] [ebp-Dh] BYREF
  int v11; // [esp+220h] [ebp-4h]
  int savedregs; // [esp+224h] [ebp+0h] BYREF

  v3 = 0;
  if ( *(_DWORD *)(this + 12) )
  {
    v8 = 0;
    v9 = 0;
    v11 = 0;
    v10 = 0;
    sub_40CA40(&v8, (int)&savedregs, &v10, 1u);
    for ( i = 0; i < *(_DWORD *)(this + 12); v3 += 580 )
    {
      if ( a2 || *(_BYTE *)(*(_DWORD *)(this + 4) + v3) )
      {
        v7 = 9513170;
        v5 = sprintf_0(
               Buffer,
               (const char *const)(9513170 - ((_DWORD)&loc_465FCD + 1)),
               *(_DWORD *)(this + 4) + v3 + 564,
               *(_DWORD *)(this + 4) + v3 + 1,
               *(_DWORD *)(this + 4) + v3 + 52);
        sub_40CA40(&v8, (int)&savedregs, Buffer, v5 + 1);
      }
      ++i;
    }
    v10 = 0;
    sub_40CA40(&v8, (int)&savedregs, &v10, 1u);
    (*(void (__thiscall **)(_DWORD, unsigned int, int))(**(_DWORD **)(this + 16) + 316))(*(_DWORD *)(this + 16), v8, v9);
    v11 = -1;
    sub_40C9D0((int)&v8, (int)&savedregs, 0);
  }
}

//----- (00422680) --------------------------------------------------------
int __thiscall sub_422680(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int v6; // eax
  char v7; // al
  bool v8; // al
  char v9; // cl
  char v10; // dl
  int (__fastcall *v11)(int, unsigned int, unsigned int *, unsigned int); // edi
  int v12; // ecx
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // eax
  int (__stdcall **v17)(int, int); // ebx
  int result; // eax
  char v19[260]; // [esp+Ch] [ebp-104h] BYREF
  char v20; // [esp+11Bh] [ebp+Bh]

  v4 = *(unsigned __int8 *)(a2 + 1);
  this[353] = v4;
  if ( !v4 )
  {
    if ( *(_BYTE *)(a2 + 19) )
    {
      v6 = this[349];
      if ( v6 == 2 || v6 == 3 )
        this[353] = 16;
    }
  }
  *((_BYTE *)this + 2176) = 0;
  v7 = *(_BYTE *)(a2 + 1);
  if ( !v7 || v7 == 13 || v7 == 6 || v7 == 16 )
  {
    v20 = 1;
  }
  else
  {
    v20 = 0;
    if ( v7 != 1 )
      goto LABEL_28;
  }
  v8 = *(_DWORD *)(a2 + 10) != -1 && sub_432CF0(0) != *(_DWORD *)(a2 + 10) && !*(_BYTE *)(a2 + 6);
  v9 = *((_BYTE *)this + 120080);
  v10 = v8 | *((_BYTE *)this + 1432);
  *((_BYTE *)this + 1432) = v10;
  *((_BYTE *)this + 120080) = v10 | v9;
  if ( !v20 )
    goto LABEL_28;
  *((_BYTE *)this + 28244) = 0;
  sub_407960(v19, this[5775] + 269, (_BYTE *)(9521182 - ((_DWORD)&loc_468029 + 1)));
  *((_BYTE *)this + 2176) = sub_432CF0((int)v19) != *(_DWORD *)(a2 + 24);
  this[30022] = *(_DWORD *)(a2 + 20);
  *((_BYTE *)this + 113604) = (*(_DWORD *)(a2 + 20) ^ *(_DWORD *)(a2 + 10)) + *(_DWORD *)(a2 + 20) == -1;
  if ( byte_4C1AF8 )
  {
    v11 = sub_401000;
    do
    {
      v12 = 0;
      v13 = 64;
      do
      {
        v14 = *(_DWORD *)v11;
        v11 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v11 + 4);
        v12 ^= v14;
        --v13;
      }
      while ( v13 );
      sub_40DA80((char *)(9271250 - ((_DWORD)&loc_42AEC1 + 1)));
    }
    while ( (char *)v11 < (char *)&unk_4B8000 );
  }
  if ( !*((_BYTE *)this + 120080) )
  {
    v15 = *(_DWORD *)(a2 + 20);
    if ( (**(int (__thiscall ***)(_DWORD, _DWORD))this[30127])(this[30127], 0) != v15
      && v15 != -1
      && !*(_BYTE *)(a2 + 6) )
    {
      (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*this + 252))(this, 23, 0);
      sub_46E4AC(0);
LABEL_28:
      if ( *(_BYTE *)(a2 + 1) != 1 )
        (*(void (__thiscall **)(_DWORD *))(*this + 56))(this);
      goto LABEL_30;
    }
  }
LABEL_30:
  v16 = 0;
  v17 = &off_4AA7DC;
  do
    v16 -= (int)*v17++;
  while ( v17 < (int (__stdcall **)(int, int))&off_4AA89C );
  result = v16 - 365802081;
  *(_DWORD *)((char *)this + result + 419615160) = 3;
  return result;
}
// 4AA7DC: using guessed type int (__stdcall *off_4AA7DC)(int, int);
// 4AA89C: using guessed type char *off_4AA89C;
// 4C1AF8: using guessed type char byte_4C1AF8;

//----- (00422950) --------------------------------------------------------
void __stdcall sub_422950(int a1, int a2, int a3)
{
  switch ( *(_DWORD *)(a3 + 88) )
  {
    case 8:
      JUMPOUT(0x422EC8);
    case 9:
      JUMPOUT(0x422E10);
    case 0xA:
      JUMPOUT(0x422D9C);
    case 0xB:
      JUMPOUT(0x422C8D);
    case 0xC:
      JUMPOUT(0x422D04);
    case 0xD:
      JUMPOUT(0x422D8D);
    case 0xF:
      JUMPOUT(0x422EBA);
    default:
      JUMPOUT(0x422EDB);
  }
}
// 4229A5: control flows out of bounds to 422C8D
// 4229A5: control flows out of bounds to 422D04
// 4229A5: control flows out of bounds to 422D8D
// 4229A5: control flows out of bounds to 422D9C
// 4229A5: control flows out of bounds to 422E10
// 4229A5: control flows out of bounds to 422EBA
// 4229A5: control flows out of bounds to 422EC8
// 4229A5: control flows out of bounds to 422EDB

//----- (004229D1) --------------------------------------------------------
_WORD *__userpurge sub_4229D1@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4@<edi>, int *a5@<esi>, int a6, int a7, int a8)
{
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  _DWORD *v22; // ebx
  int v23; // eax
  int v24; // eax
  _DWORD *v25; // edx
  char v26; // bl
  int v27; // ecx
  int v28; // edx
  int v29; // ecx
  int v30; // edx
  bool v31; // cl
  int v32; // eax
  int v33; // eax
  int v34; // edx
  int v35; // ebx
  bool v36; // cl
  __int16 v37; // ax
  int v38; // edx
  __int16 v39; // bx
  int v40; // ecx
  _DWORD *v41; // edi
  unsigned int v42; // edx
  unsigned int v43; // ebx
  int v44; // ecx
  int v45; // ecx
  _DWORD *v46; // ebx
  int v47; // ecx
  __int16 v48; // ax
  __int64 v49; // rax
  __int64 v50; // rax
  int v51; // ecx
  int v52; // eax
  int v53; // ecx
  int v54; // eax
  int v55; // eax
  int v56; // edx
  int v57; // eax
  int v58; // ecx
  _DWORD *v59; // edx
  int v60; // eax
  int v61; // ecx
  int v62; // eax
  _DWORD *v63; // ebx
  int v64; // ecx
  int v65; // eax
  int v66; // edx
  _DWORD *v67; // edi
  unsigned int v68; // edx
  unsigned int v69; // ecx
  int v70; // ebx
  int v71; // eax
  int v72; // edx
  int v73; // eax
  int v74; // edx
  unsigned int v75; // edx
  unsigned int v76; // edi
  int v77; // ecx
  int v78; // eax
  int v79; // eax
  int v80; // ecx
  char v81; // al
  char v82; // al
  int v83; // edi
  int v84; // eax
  _DWORD *v85; // ecx
  int v86; // eax
  unsigned int v87; // edx
  int v88; // eax
  int v89; // ecx
  int v90; // ecx
  char v91; // al
  int v92; // eax
  int v93; // ecx
  int v94; // edx
  int v95; // ecx
  int v96; // edx
  int v97; // ecx
  int v98; // edi
  int v99; // eax
  int v100; // ecx
  char v101; // al
  int v102; // eax
  int v103; // eax
  int v104; // ecx
  int v105; // edx
  int v106; // edi
  int v107; // eax
  int v108; // eax
  int v109; // eax
  int v110; // eax
  _DWORD *v111; // edi
  int v112; // edi
  __int16 v113; // dx
  int v114; // eax
  int v115; // ecx
  _DWORD *v116; // ecx
  int v117; // eax
  int v118; // ecx
  int v119; // eax
  int v120; // ecx
  int v121; // eax
  _DWORD *v122; // ebx
  int v123; // eax
  char v124; // al
  int v125; // eax
  int v126; // ecx
  int v127; // ecx
  long double v128; // st7
  double v129; // st6
  int v130; // ecx
  int v131; // edx
  int v132; // edx
  int v133; // ebx
  int v134; // edx
  int v135; // ecx
  int v136; // eax
  _WORD *result; // eax

  if ( !*(_BYTE *)(a2 + 96) && *(int *)(a1 + 1424) <= 250 && a5[129] <= 0 && a5[10] < 0 )
  {
    v8 = -1942309465;
    v9 = 127;
    do
      v8 ^= *(_DWORD *)&a040[4 * v9-- - 474744];
    while ( v9 );
    if ( *(int *)((char *)a5 + v8 + 3141772) == a4 )
    {
      if ( (*(int (__thiscall **)(int *))(*a5 + 80))(a5) )
      {
        (*(void (__thiscall **)(int, int))(*(_DWORD *)a5[3] + 380))(a5[3], 20);
      }
      else
      {
        v10 = a5[3];
        v11 = *(_DWORD *)(v10 + 112464);
        v12 = *(_DWORD *)(v10 + 112472);
        if ( v12 >= *(_DWORD *)(v11 + 6276) )
          v13 = 0;
        else
          v13 = *(_DWORD *)(v11 + 4 * v12 + 2180);
        v14 = v13;
        if ( v13 )
        {
          v15 = *(_DWORD *)(v13 + 28);
          if ( v15 >= 0 )
            v14 = *(_DWORD *)(v10 + 4 * v15 + 113620);
          if ( v14 )
          {
            if ( (*(unsigned __int8 (__thiscall **)(int *))(*a5 + 88))(a5) )
            {
              if ( a5[8] + a5[9] >= *(_DWORD *)(*(_DWORD *)(a3 - 16) + 1164) )
              {
                v16 = *(_DWORD *)(v14 + 92);
                if ( v16 == 8 )
                {
                  *(_DWORD *)(a3 - 12) = 9547831;
                  (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                    a5[3],
                    300,
                    4,
                    *(_DWORD *)(a3 - 12) - 4646415);
                }
                else if ( *(_BYTE *)(v14 + 156) )
                {
                  *(_DWORD *)(a3 - 12) = 9548553;
                  (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                    a5[3],
                    300,
                    4,
                    *(_DWORD *)(a3 - 12) - (_DWORD)sub_46E8F9);
                }
                else if ( a5[22] == *(_DWORD *)(v14 + 88) )
                {
                  if ( *(int *)(a5[3] + 1308 * v16 + 13280) > 0 )
                  {
                    if ( (*(int (__thiscall **)(int))(*(_DWORD *)v14 + 80))(v14) < *(_DWORD *)(a5[3]
                                                                                             + 1308
                                                                                             * *(_DWORD *)(v14 + 92)
                                                                                             + 13280) )
                    {
                      if ( !(*(unsigned __int8 (__thiscall **)(int *, int))(*a5 + 112))(a5, 1) )
                      {
                        v17 = dword_4C1AE4;
                        a5[104] = dword_4C1AE4;
                        a5[103] = -v17;
                        v18 = *(_DWORD *)(*(_DWORD *)(a5[3] + 120076) + 240);
                        (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v18 + 20))(
                          v18,
                          0,
                          0,
                          0,
                          0);
                        (*(void (__thiscall **)(int *, _DWORD))(*a5 + 84))(a5, *(_DWORD *)(v14 + 24));
                      }
                    }
                    else
                    {
                      *(_DWORD *)(a3 - 12) = 9551432;
                      (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                        a5[3],
                        300,
                        4,
                        *(_DWORD *)(a3 - 12) - 4650152);
                    }
                  }
                  else
                  {
                    *(_DWORD *)(a3 - 12) = 9549972;
                    (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                      a5[3],
                      300,
                      4,
                      *(_DWORD *)(a3 - 12) - 4648656);
                  }
                }
                else
                {
                  *(_DWORD *)(a3 - 12) = 9549256;
                  (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                    a5[3],
                    300,
                    4,
                    *(_DWORD *)(a3 - 12) - (_DWORD)&loc_46EBE4);
                }
              }
              else
              {
                *(_DWORD *)(a3 - 12) = 9547118;
                (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                  a5[3],
                  300,
                  4,
                  *(_DWORD *)(a3 - 12) - (_DWORD)&loc_46E326);
              }
            }
            else
            {
              *(_DWORD *)(a3 - 12) = 9546409;
              (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
                a5[3],
                300,
                4,
                *(_DWORD *)(a3 - 12) - 4644925);
            }
          }
        }
      }
    }
    else
    {
      (*(void (__thiscall **)(int *, int))(*a5 + 84))(a5, a4);
    }
  }
  v19 = *(_DWORD *)(a3 + 16);
  v20 = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v19 + 88) = 0;
  a5[126] -= v20;
  a5[164] -= v20;
  if ( *(_BYTE *)(v19 + 10) )
    a4 = 1;
  if ( *(_BYTE *)(v19 + 18) )
    a4 = 5;
  if ( *(_BYTE *)(v19 + 9) || *(_BYTE *)(v19 + 11) )
  {
    a4 = 3;
  }
  else if ( a4 == 5 && *(_DWORD *)(a5[3] + 23104) - a5[165] > 50 && a5[172] + a5[173] )
  {
    a5[126] = 0;
  }
  if ( *(int *)(a5[3] + 10760) > 0 && (*(unsigned __int8 (__thiscall **)(int *))(*a5 + 148))(a5) )
    *(_DWORD *)(a3 - 24) = *(_DWORD *)(a5[3] + 10760);
  else
    *(_DWORD *)(a3 - 24) = *(_DWORD *)(*(_DWORD *)(a3 - 16) + 448);
  v21 = *(_DWORD *)(a3 - 16);
  *(_DWORD *)(a3 - 28) = 0;
  if ( (!*(_DWORD *)(v21 + 1296) || *(_DWORD *)(a5[3] + 23104) - a5[128] > 1) && a4 >= 0 && a5[126] <= 0 )
  {
    v22 = (_DWORD *)a5[3];
    *(_DWORD *)(a3 - 12) = v22;
    if ( (*(int (**)(void))(*v22 + 208))() != v22[6803] )
      (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*v22 + 252))(v22, 28, 0);
    if ( a4 == 1 )
    {
      if ( a5[166] + a5[167] )
      {
        if ( a5[10] < 0 || *(_DWORD *)(a5[3] + 12000) )
        {
          v24 = a5[187];
          if ( (v24 & 0x8000) != 0 && *((_BYTE *)a5 + 812) )
          {
            v25 = *(_DWORD **)(a3 - 16);
            v26 = 1;
            v27 = v25[162];
          }
          else
          {
            v25 = *(_DWORD **)(a3 - 16);
            v26 = 0;
            v27 = v25[43];
          }
          a5[126] = v27;
          if ( v26 )
            v28 = v25[297];
          else
            v28 = v25[140];
          v29 = v28 * (a5[166] + a5[167]);
          v30 = *a5;
          *(_DWORD *)(a3 - 28) = 1000 * v29;
          *(_WORD *)(a3 - 4) = (((v24 & 0x80000) != 0) + 1) & 0x1F;
          v31 = (*(unsigned __int8 (__thiscall **)(int *))(v30 + 148))(a5) && *(_DWORD *)(a5[3] + 10828);
          *(_WORD *)(a3 - 4) = ((v26 & 1) << 15) | *(_WORD *)(a3 - 4) & 0x7F9F ^ (32
                                                                                * (v31
                                                                                 + *((_BYTE *)a5 + 668)
                                                                                 + *((_BYTE *)a5 + 664)
                                                                                 - 1)) & 0x60;
        }
        else
        {
          v23 = *(_DWORD *)(a3 - 24);
          *(_BYTE *)(a3 - 5) = 1;
          a5[126] = v23;
        }
      }
      goto LABEL_150;
    }
    if ( a4 != 3 )
    {
      if ( a4 == 7 )
      {
        if ( a5[174] + a5[175] )
        {
          v64 = *(_DWORD *)(a3 - 24);
          *(_WORD *)(a3 - 4) = 7;
          a5[126] = v64;
        }
        goto LABEL_150;
      }
      if ( a4 == 5 )
      {
        if ( a5[172] + a5[173] )
        {
          v65 = *(_DWORD *)(a3 - 24);
          *(_WORD *)(a3 - 4) = 5;
          a5[126] = v65;
        }
        goto LABEL_150;
      }
      if ( a4 != 6 )
      {
        if ( a4 == 8 )
        {
          if ( a5[180] + a5[181]
            && a5[164] <= 0
            && (*(unsigned __int8 (__thiscall **)(int *, int))(*a5 + 116))(a5, *(_DWORD *)(a5[3] + 11544) + 3) )
          {
            v66 = *(_DWORD *)(a3 - 24);
            *(_WORD *)(a3 - 4) = 8;
            a5[126] = v66;
          }
        }
        else if ( a4 == 109 )
        {
          if ( a5[176] + a5[177] )
          {
            v67 = (_DWORD *)a5[3];
            v68 = a5[2];
            v69 = a5[1];
            v70 = v67[30132];
            if ( !v70
              || v69 < 0xFA0000
              && v68 < 0xFA0000
              && (*(_DWORD *)(a3 + 16) = ((int)v68 / 16000) << 10,
                  !*(_BYTE *)((int)v69 / 16000 + *(_DWORD *)(a3 + 16) + v70)) )
            {
              (*(void (__thiscall **)(_DWORD *, int, int))(*v67 + 272))(v67, a5[1] / 16000, a5[2] / 16000);
              a5[176] += a5[177] - dword_4C1AE4 - 1;
              v71 = *(_DWORD *)(a3 - 24);
              a5[177] = dword_4C1AE4;
              a5[126] = v71;
            }
          }
        }
        else if ( a4 == 110 && a5[178] + a5[179] && a5[103] + a5[104] <= 0 && a5[7] == -1 )
        {
          v72 = *(_DWORD *)(a3 - 16);
          a5[178] += a5[179] - dword_4C1AE4 - 1;
          a5[179] = dword_4C1AE4;
          v73 = *(_DWORD *)(v72 + 88);
          dword_4C1AE4 -= v73;
          v74 = dword_4C1AE4;
          a5[104] = dword_4C1AE4;
          a5[103] = v73 - v74;
          (*(void (__thiscall **)(int *, int))(*a5 + 120))(a5, 3);
        }
        goto LABEL_150;
      }
      if ( !(a5[182] + a5[183]) )
      {
LABEL_150:
        if ( a5[101] + a5[102] > 0 )
          *(_DWORD *)(a3 - 28) = 0;
        if ( (*(unsigned __int8 (__thiscall **)(int *))(*a5 + 148))(a5) )
          *(_DWORD *)(a3 - 28) = *(_DWORD *)(a3 - 28) / 1000 * *(_DWORD *)(a5[3] + 11888);
        if ( a5[130] + a5[131] < *(_DWORD *)(a3 - 28) )
        {
          if ( (*(_BYTE *)(a3 - 4) & 0x1F) != 0 )
          {
            a5[164] = 0;
            a5[126] = 0;
          }
          *(_WORD *)(a3 - 4) &= 0xFFE0u;
        }
        goto LABEL_158;
      }
      *(_WORD *)(a3 - 4) = 6;
LABEL_132:
      a5[126] = *(_DWORD *)(a3 - 24);
      goto LABEL_150;
    }
    if ( !(a5[168] + a5[169]) || a5[164] > 0 )
      goto LABEL_150;
    if ( a5[10] >= 0 && !*(_DWORD *)(a5[3] + 11068) )
    {
      v32 = *(_DWORD *)(a3 - 24);
      *(_BYTE *)(a3 - 5) = 1;
      a5[126] = v32;
      goto LABEL_150;
    }
    if ( (a5[187] & 0x4000000) != 0 )
      v33 = *(_DWORD *)(a5[3] + 11544) + a5[169] + a5[168] - 1;
    else
      v33 = 1;
    if ( !(*(unsigned __int8 (__thiscall **)(int *, int))(*a5 + 116))(a5, v33) )
      goto LABEL_150;
    v34 = *a5;
    *(_DWORD *)(a3 - 28) = 1000
                         * (*(_DWORD *)(*(_DWORD *)(a3 - 16) + 1040)
                          + *(_DWORD *)(*(_DWORD *)(a3 - 16) + 104) * (a5[169] + a5[168] - 1));
    v35 = ((((unsigned int)a5[187] >> 19) & 1) << 7) | (((a5[187] & 0x4000000) != 0) + 3) & 0x1F;
    *(_WORD *)(a3 - 4) = v35;
    v36 = (*(unsigned __int8 (__thiscall **)(int *))(v34 + 148))(a5) && *(_DWORD *)(a5[3] + 11080);
    v37 = a5[167] + a5[166];
    v38 = a5[170];
    v39 = (*(_BYTE *)(a3 - 4) ^ (unsigned __int8)(32 * (v36 + a5[169] + a5[168] - 1))) & 0x60 ^ v35;
    v40 = a5[171];
    *(_WORD *)(a3 - 4) = v39;
    *(_WORD *)(a3 - 4) = ((((_BYTE)v38 + (_BYTE)v40) & 0x1F) << 10) | (*(_DWORD *)(a3 - 4) ^ (*(_DWORD *)(a3 - 4) ^ ((v37 << 8) - 1)) & 0x300) & 0x83FF;
    if ( *(_BYTE *)(*(_DWORD *)(a3 + 16) + 11) )
    {
      v41 = (_DWORD *)a5[3];
      v42 = a5[2];
      v43 = a5[1];
      v44 = v41[30132];
      if ( !v44
        || v43 < 0xFA0000
        && v42 < 0xFA0000
        && (*(_DWORD *)(a3 + 16) = ((int)v42 / 16000) << 10, !*(_BYTE *)((int)v43 / 16000 + *(_DWORD *)(a3 + 16) + v44)) )
      {
        v45 = v41[1908] + v41[1909];
        *(_BYTE *)(a3 + 19) = 0;
        *(_DWORD *)(a3 - 36) = 0;
        *(_DWORD *)(a3 - 32) = 0;
        *(_DWORD *)(a3 - 12) = 0;
        if ( v45 <= 0 )
          goto LABEL_111;
        v46 = v41 + 2173;
        *(_DWORD *)(a3 - 40) = v41[1908] + v41[1909];
        do
        {
          v47 = *v46;
          if ( *(_DWORD *)(*v46 + 184) == a5[22] && !*(_DWORD *)(v47 + 16) && !*(_DWORD *)(v47 + 20) )
          {
            v48 = *(_WORD *)(v47 + 167) & 0x1F;
            if ( v48 == 3 || v48 == 4 )
            {
              v49 = *(_DWORD *)(v47 + 4) - a5[1];
              if ( (int)((HIDWORD(v49) ^ v49) - HIDWORD(v49)) < 1000 )
              {
                v50 = *(_DWORD *)(v47 + 8) - a5[2];
                if ( (int)((HIDWORD(v50) ^ v50) - HIDWORD(v50)) < 1000 )
                  *(_BYTE *)(a3 + 19) = 1;
              }
              v51 = *(_DWORD *)(v47 + 152);
              v52 = a5[6];
              ++*(_DWORD *)(a3 - 36);
              if ( v51 == v52 )
                ++*(_DWORD *)(a3 - 32);
            }
          }
          v53 = *(_DWORD *)(a3 - 40);
          v54 = *(_DWORD *)(a3 - 12) + 1;
          ++v46;
          *(_DWORD *)(a3 - 12) = v54;
        }
        while ( v54 < v53 );
        if ( *(_BYTE *)(a3 + 19) )
        {
          *(_DWORD *)(a3 + 16) = 9600177;
          v55 = *(_DWORD *)(a3 + 16) - (_DWORD)&loc_47B33D;
        }
        else
        {
LABEL_111:
          if ( *(_DWORD *)(a3 - 32) < *(_DWORD *)(*(_DWORD *)(a3 - 16) + 1288) )
          {
            if ( *(_DWORD *)(a3 - 36) < v41[2790] )
            {
              v57 = a5[169];
              v58 = a5[168];
              v59 = *(_DWORD **)(a3 - 16);
              *(_BYTE *)(a3 - 3) |= 0x80u;
              *(_DWORD *)(a3 - 28) = 1000 * (v59[185] + v59[48] * (v57 + v58 - 1));
              v60 = 526124861;
              v61 = 242;
              do
                v60 ^= *(_DWORD *)&aContshmem[4 * v61-- - 551792];
              while ( v61 );
              *(int *)((char *)a5 + v60 + 3356256) = v59[178];
              goto LABEL_108;
            }
            *(_DWORD *)(a3 + 16) = 9602495;
            v55 = *(_DWORD *)(a3 + 16) - ((_DWORD)&loc_47BC7A + 1);
          }
          else
          {
            *(_DWORD *)(a3 + 16) = 9601335;
            v55 = *(_DWORD *)(a3 + 16) - (_DWORD)&loc_47B7DB;
          }
        }
        (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(a5[3], 400, 4, v55);
      }
      *(_WORD *)(a3 - 4) &= 0xFFE0u;
    }
LABEL_108:
    if ( (*(_BYTE *)(a3 - 4) & 0x1F) == 0 )
    {
      a5[126] = 30;
      goto LABEL_150;
    }
    v56 = *(_DWORD *)(a3 - 16);
    if ( *(_DWORD *)(v56 + 868) )
    {
      a5[164] = *(_DWORD *)(a3 - 24);
      goto LABEL_150;
    }
    if ( (BYTE1(*(_DWORD *)(a3 - 4)) & 0x80u) != 0 )
    {
      v62 = 0;
      v63 = &loc_413444;
      do
        v62 -= *v63++;
      while ( (unsigned int)v63 < 0x413820 );
      *(int *)((char *)a5 + v62 + 1367220589) = *(_DWORD *)(v56 + 712);
      goto LABEL_150;
    }
    goto LABEL_132;
  }
LABEL_158:
  if ( a5[110] )
    *(_WORD *)(a3 - 4) &= 0xFFE0u;
  v75 = a5[2];
  v76 = a5[1];
  v77 = *(_DWORD *)(a5[3] + 120528);
  if ( v77
    && v76 < 0xFA0000
    && v75 < 0xFA0000
    && (*(_DWORD *)(a3 + 16) = ((int)v75 / 16000) << 10,
        *(unsigned __int8 *)((int)v76 / 16000 + *(_DWORD *)(a3 + 16) + v77) == 171) )
  {
    if ( (*(_BYTE *)(a3 - 4) & 0x1F) != 0 )
    {
      a5[5] = 0;
      a5[4] = 0;
    }
    v78 = a5[140];
    *(_WORD *)(a3 - 4) &= 0xFFE0u;
    if ( v78 <= 0 )
    {
      v79 = -2084904396;
      v80 = 121;
      do
        v79 ^= *(_DWORD *)&a1Qnan[4 * v80-- - 436160];
      while ( v80 );
      *(int *)((char *)a5 + v79 + 3448664) = *(_DWORD *)(a5[3] + 11912);
      (*(void (__thiscall **)(int, int))(*(_DWORD *)a5[3] + 212))(a5[3], a5[6]);
    }
    v81 = *((_BYTE *)a5 + 96) | 0x20;
  }
  else
  {
    v82 = *((_BYTE *)a5 + 96);
    a5[140] = 0;
    v81 = v82 & 0xDF;
  }
  v83 = a5[119];
  *((_BYTE *)a5 + 96) = v81;
  v84 = a5[3];
  if ( *(_DWORD *)(v84 + 23104) - v83 > 1287 )
  {
    a5[119] = *(_DWORD *)(v84 + 23104);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v84 + 120508) + 32))(*(_DWORD *)(v84 + 120508), 0);
    (*(void (__cdecl **)(int, int))(*(_DWORD *)a5[3] + 460))(a3 - 12264, a5[3] + 110192);
    v85 = (_DWORD *)a5[3];
    if ( *(_DWORD *)(a3 - 12264) != v85[2687]
      || (v86 = a5[20], v86 != *(_DWORD *)(*(_DWORD *)(a3 - 16) + 1304))
      || a5[17] != 1000 * v86 )
    {
      (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*v85 + 252))(v85, 28, 0);
    }
  }
  if ( *(_BYTE *)(a3 - 5) )
    (*(void (__thiscall **)(int *, int))(*a5 + 136))(a5, 1);
  if ( *(_BYTE *)(a3 - 18)
    && a5[129] <= 0
    && a5[184] + a5[185]
    && !(*(unsigned __int8 (__thiscall **)(int *, int))(*a5 + 112))(a5, 1) )
  {
    v87 = (int)((unsigned __int64)(274877907i64 * a5[2]) >> 32) >> 6;
    a5[105] = a5[1] / 1000;
    a5[106] = (v87 >> 31) + v87;
    v88 = -1670777259;
    v89 = 240;
    do
      v88 ^= *(_DWORD *)&aUncarriedFlags[4 * v89-- - 536568];
    while ( v89 );
    *(int *)((char *)a5 + v88 + 3481768) = *(_DWORD *)(a5[3] + 12132);
    a5[184] += a5[185] - dword_4C1AE4 - 1;
    a5[185] = dword_4C1AE4;
    v90 = *(_DWORD *)(*(_DWORD *)(a5[3] + 120076) + 308);
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v90 + 20))(v90, 0, 0, 0, 0);
    a5[126] = 50;
  }
  v91 = *(_BYTE *)(a3 - 17);
  a5[202] -= *(_DWORD *)(a3 + 12);
  if ( v91 && a5[129] <= 0 && !(*(unsigned __int8 (__thiscall **)(int *, int))(*a5 + 112))(a5, 1) )
  {
    if ( a5[202] > 0 || (*(unsigned __int8 (__thiscall **)(int *))(*a5 + 88))(a5) )
    {
      v92 = sub_40B720(a3, 0x40u);
      if ( v92 )
      {
        v93 = a5[1];
        v94 = a5[2];
        *(_DWORD *)(v92 + 12) = a5[3];
        *(_DWORD *)(v92 + 28) = 48;
        *(_DWORD *)(v92 + 8) = 0;
        *(_DWORD *)(v92 + 4) = 0;
        *(_DWORD *)(v92 + 4) = v93;
        *(_DWORD *)(v92 + 20) = 0;
        *(_DWORD *)(v92 + 16) = 0;
        *(_DWORD *)(v92 + 24) = 0;
        *(_DWORD *)(v92 + 32) = 0;
        *(_DWORD *)(v92 + 36) = 11;
        *(_DWORD *)(v92 + 44) = 16;
        *(_DWORD *)(v92 + 48) = 48;
        *(_BYTE *)(v92 + 52) = 0;
        *(_DWORD *)v92 = off_4AC414;
        *(_DWORD *)(v92 + 8) = v94;
        *(_DWORD *)(v92 + 40) = 0;
      }
      else
      {
        v92 = 0;
      }
      v95 = a5[3] + 7656;
      v96 = *(_DWORD *)(a5[3] + 8680);
      if ( v96 >= 256 )
      {
        sub_40B7E0(v92);
      }
      else
      {
        *(_DWORD *)(v95 + 4 * v96) = v92;
        ++*(_DWORD *)(v95 + 1024);
      }
      v97 = *(_DWORD *)(*(_DWORD *)(a5[3] + 120076) + 240);
      (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v97 + 20))(v97, 0, 0, 0, 0);
      if ( a5[202] <= 0 )
      {
        v103 = 1482603382;
        v104 = 247;
        do
          v103 ^= (unsigned int)*(&dword_4A73E0 + v104-- - 134960);
        while ( v104 );
        v105 = dword_4C1AE4;
        *(int *)((char *)a5 + v103 + 3506348) = dword_4C1AE4;
        *(int *)((char *)a5 + v103 + 3506344) = -v105;
        v106 = *a5;
        v107 = rand();
        (*(void (__thiscall **)(int *, int, int, int))(v106 + 152))(a5, v107, -1, -1);
      }
      else
      {
        v98 = 1000 * a5[106];
        v99 = -557369872;
        v100 = 199;
        do
          v99 ^= *(_DWORD *)&aSqrt[4 * v100-- - 466856];
        while ( v100 );
        *(int *)((char *)a5 + v99 + 3497836) = 1000 * a5[105];
        *(int *)((char *)a5 + v99 + 3497840) = v98;
        v101 = *((_BYTE *)a5 + 96) | 0x10;
        a5[202] = 0;
        *((_BYTE *)a5 + 96) = v101;
        v102 = *a5;
        a5[11] = 48;
        (*(void (__thiscall **)(int *))(v102 + 160))(a5);
      }
      v108 = a5[3];
      a5[126] = 50;
      a5[209] = *(_DWORD *)(v108 + 23104);
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 9653441;
      (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)a5[3] + 388))(
        a5[3],
        300,
        4,
        *(_DWORD *)(a3 + 16) - ((_DWORD)&loc_488397 + 2));
    }
  }
  v109 = a5[3];
  if ( *(_DWORD *)(v109 + 23104) - a5[191] > 2871 )
  {
    a5[191] = *(_DWORD *)(v109 + 23104);
    (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(v109 + 120508) + 32))(*(_DWORD *)(v109 + 120508), 1);
    v110 = a5[3];
    if ( *(_DWORD *)(v110 + 120088) != -1 )
    {
      v111 = (_DWORD *)a5[3];
      if ( (***(int (__thiscall ****)(_DWORD, _DWORD))(v110 + 120508))(*(_DWORD *)(v110 + 120508), 0) != v111[30022] )
        (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*v111 + 252))(v111, 27, 0);
    }
  }
  v112 = *(_DWORD *)(a3 - 4);
  v113 = v112 & 0x1F;
  if ( (v112 & 0x1F) != 0 )
  {
    a5[165] = *(_DWORD *)(a5[3] + 23104);
    switch ( v113 )
    {
      case 6:
        v114 = -2031251317;
        v115 = 44;
        do
          v114 ^= (unsigned int)*(&off_4A87AC + v115-- - 109424);
        while ( v115 );
        v116 = (int *)((char *)a5 + v114 + 3533196);
        *(int *)((char *)a5 + v114 + 3533192) += *v116 - dword_4C1AE4 - 1;
        break;
      case 7:
        v117 = 199496083;
        v118 = 75;
        do
          v117 ^= *(_DWORD *)&aAmericanEnglis[4 * v118-- - 398680];
        while ( v118 );
        v116 = (int *)((char *)a5 + v117 + 3535828);
        *(int *)((char *)a5 + v117 + 3535824) += *v116 - dword_4C1AE4 - 1;
        break;
      case 5:
        v119 = -1944011313;
        v120 = 127;
        do
          v119 ^= *(_DWORD *)&aR6027NotEnough[4 * v120-- - 481352];
        while ( v120 );
        v116 = (int *)((char *)a5 + v119 + 3537596);
        *(int *)((char *)a5 + v119 + 3537592) += *v116 - dword_4C1AE4 - 1;
        break;
      case 8:
        v121 = 0;
        v122 = (_DWORD *)((char *)&loc_426113 + 1);
        do
          v121 -= *v122++;
        while ( v122 < (_DWORD *)&loc_4264D8 + 1 );
        v123 = v121 - 532972099;
        v116 = (int *)((char *)a5 + v123 + 3540292);
        *(int *)((char *)a5 + v123 + 3540288) += *v116 - dword_4C1AE4 - 1;
        break;
      default:
        goto LABEL_228;
    }
    *v116 = dword_4C1AE4;
LABEL_228:
    v124 = *((_BYTE *)a5 + 96);
    if ( (v124 & 0x40) == 0 && (v124 & 2) != 0 )
    {
      v125 = 1084548447;
      v126 = 228;
      do
        v125 ^= *(_DWORD *)&aHandleHandle1[4 * v126-- - 367448];
      while ( v126 );
      *((_BYTE *)a5 + v125 + 3543216) &= 0xFDu;
      *((_BYTE *)a5 + 96) |= 0x10u;
    }
    if ( (v113 == 3 || v113 == 4 || v113 == 8) && (v112 & 0x8000) == 0 )
    {
      if ( a5[7] == -1 )
      {
        v127 = a5[15];
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(*(_DWORD *)(a3 - 16) + 176);
        *(_DWORD *)(a3 + 16) = v127 / 1000;
        v128 = (double)*(int *)(a3 + 16) * dbl_4AC920;
        v129 = (double)*(int *)(a3 + 12);
        v130 = a5[5] + (__int64)(cos(v128) * v129);
        a5[4] -= (__int64)(sin(v128) * v129);
        a5[5] = v130;
      }
      a5[109] = 18;
    }
    a5[130] += a5[131] - dword_4C1AE4 - *(_DWORD *)(a3 - 28);
    v131 = dword_4C1AE4;
    a5[131] = dword_4C1AE4;
    if ( a5[130] + v131 < 0 )
    {
      v132 = dword_4C1AE4;
      a5[131] = dword_4C1AE4;
      a5[130] = -v132;
    }
    v133 = 25 * (a5[1] / 1000);
    v134 = a5[15];
    v135 = 25 * (a5[2] / 1000);
    v136 = a5[3];
    *(_DWORD *)(a3 - 12) = v136;
    (*(void (__thiscall **)(_DWORD, _DWORD, int, int, int, int, int, int *))(*(_DWORD *)v136 + 132))(
      *(_DWORD *)(a3 - 12),
      *(_DWORD *)(a3 - 4),
      40 * v133,
      40 * v135,
      a5[4],
      a5[5],
      1000 * (v134 / 1000),
      a5);
  }
  result = *(_WORD **)(a3 + 8);
  *result = *(_WORD *)(a3 - 4);
  return result;
}
// 4229D1: could not find valid save-restore pair for ebx
// 46E8F9: using guessed type int sub_46E8F9();
// 4A73E0: using guessed type int (__stdcall *dword_4A73E0)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A87AC: using guessed type int (__stdcall *off_4A87AC)(char);
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4AC920: using guessed type double dbl_4AC920;
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00423F90) --------------------------------------------------------
int __fastcall sub_423F90(int *a1, int a2)
{
  int v3; // ebp
  int v4; // ecx
  int v5; // eax
  int v6; // ebx
  int v7; // ebp
  int v8; // edi
  int v9; // ecx
  int v10; // edi
  int v11; // ecx
  int v12; // eax
  int v13; // ebp
  int v14; // eax
  int v15; // ebp
  int v16; // eax
  int v17; // ebp
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // ebp
  int v24; // ecx
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // ebp
  int v29; // edi
  int result; // eax
  int v31; // ebp
  int v32; // ecx
  int v33; // edx
  int v34; // edi
  int v35; // ecx
  int v36; // ebp
  int v37; // ebx
  int v38; // ecx
  int v39; // [esp+10h] [ebp-10h]
  int v40; // [esp+10h] [ebp-10h]
  int v41; // [esp+14h] [ebp-Ch]
  int v42; // [esp+18h] [ebp-8h]
  int v43; // [esp+18h] [ebp-8h]

  v3 = a1[5];
  v4 = (a1[6] - 372940938) ^ a1[15];
  v5 = a1[9];
  a1[15] = v4;
  v6 = a1[7];
  v7 = a1[8] + 7217099 + v3;
  a1[9] = __ROL4__(v5, a1[12] + 108);
  a1[5] = v7;
  v8 = (*a1 | (v4 + 811167400)) - __ROL4__(v7, 17);
  v9 = a1[9];
  *a1 = v8;
  v10 = v9 ^ (1782727562 * v6);
  v11 = a1[3];
  v12 = v11 - v7 + 1418623930 + a1[12];
  v13 = a1[19];
  a1[12] = v12;
  v14 = __ROL4__(a2, 26) + v13;
  a1[19] = v14;
  v42 = v14;
  v15 = a1[8];
  v16 = v11 + __ROR4__(v10, 15);
  LOBYTE(v11) = a1[12] - 17;
  a1[3] = v16;
  v17 = __ROR4__(v15, v11);
  v18 = -206616090 * a1[10] + a1[1];
  a1[8] = v17;
  a1[1] = v18;
  v39 = 2 * a1[11] + 1018779096;
  v19 = a1[17];
  a1[4] = (a1[10] + 816600122) ^ __ROR4__(a1[4] ^ (a2 + 507311209), a2 | 0x80);
  *a1 ^= v19 & 0x3081FA9B;
  v41 = (v39 & 0xEEFA1E0) + (v42 ^ 0x3E4BFFEB) + __ROR4__(a2, a1[15] + 31);
  v20 = __ROL4__((v6 | 0x604E179E) + a1[10] + (((v6 | 0x604E179E) + a1[10]) ^ 0x2BB204C7), a1[4] ^ 0xE8);
  a1[6] ^= v41 | 0x361F7E90;
  a1[10] = v20;
  v21 = a1[16];
  v40 = (v39 ^ (v39 + 1316299540)) + v21 + 318893531;
  a1[11] = v40;
  a1[12] += v17 + 1081034020;
  v22 = *a1;
  a1[5] ^= __ROR4__(*a1, 16);
  v43 = a1[8];
  v23 = a1[14];
  *a1 = v22 - v43 - 421223072;
  v24 = (v6 | 0x5F80B57D) + v23;
  a1[14] = v24;
  v25 = v41 * (v20 + 532882789) - 142091727 * v24;
  v26 = a1[1];
  v27 = v26 + v25 - __ROL4__(v21, 25) - 1184504810;
  a1[17] = v27 + a1[17] - 2028438439;
  a1[13] = v27 | 0x79D7FDBF;
  v28 = v10 ^ (v27 + 83098055);
  v29 = a1[12];
  result = __ROR4__(v26, 6) ^ v27;
  a1[9] = v28;
  v31 = a1[13];
  v32 = v21;
  a1[12] = __ROR4__(v43, 1) + v29;
  v33 = v21 + v6 + 1311277814;
  v34 = __ROR4__(v32, 19) + a1[18];
  v35 = v31 ^ v6;
  v36 = a1[2];
  v37 = a1[3];
  a1[13] = v35 ^ 0x16F8846E;
  a1[16] = v33;
  v38 = a1[9] - 1310441799 + *a1;
  a1[18] = v34;
  a1[2] = (v40 + 202161902) ^ v36;
  a1[3] = result - 1538852932 + v37;
  *a1 = v38;
  return result;
}

//----- (00424200) --------------------------------------------------------
int __thiscall sub_424200(_DWORD *this, int a2)
{
  int v3; // edi
  int result; // eax
  _DWORD *v5; // ebx
  int v6; // [esp-Ch] [ebp-14h]

  v3 = 0;
  result = this[1908] + this[1909];
  if ( result > 0 )
  {
    v5 = this + 2173;
    do
    {
      if ( *(_DWORD *)(*v5 + 152) == a2 )
      {
        v6 = v3--;
        --v5;
        (*(void (__thiscall **)(_DWORD *, int))(*this + 444))(this, v6);
      }
      ++v3;
      result = this[1909] + this[1908];
      ++v5;
    }
    while ( v3 < result );
  }
  return result;
}

//----- (00424280) --------------------------------------------------------
char __thiscall sub_424280(int this, _DWORD *a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // eax
  int v25; // edx
  int v26; // eax
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // eax
  int v31; // edx
  int v32; // eax
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v39; // eax
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // eax
  int v44; // ecx
  int v45; // eax
  int v46; // eax
  int v47; // ecx
  int v48; // eax
  int v49; // eax
  int v50; // ecx
  int v51; // eax
  int v52; // eax
  int v53; // ecx
  int v54; // eax
  int v55; // eax
  int v56; // ecx
  int v57; // eax
  int v58; // eax
  int v59; // ecx
  int v60; // eax
  int v61; // eax
  int v62; // ecx
  int v63; // eax
  int v64; // eax
  int v65; // ecx
  int v66; // eax
  int v67; // eax
  int v68; // edx
  int v69; // eax
  _DWORD *v70; // edi
  unsigned int v71; // eax
  int v72; // edx
  int v73; // eax
  int v74; // ecx
  int v75; // eax
  unsigned int v76; // ecx
  char v78[260]; // [esp+8h] [ebp-10Ch] BYREF
  int v79; // [esp+10Ch] [ebp-8h]
  int v80; // [esp+110h] [ebp-4h] BYREF

  v79 = 9696645;
  nullsub_2((const char *)(9696645 - (_DWORD)&loc_492A19), *(unsigned __int8 *)(this + 1868));
  LOBYTE(v3) = *(_BYTE *)(this + 113572);
  if ( !(_BYTE)v3 )
  {
    v79 = 9697930;
    sub_407960(v78, *(_DWORD *)(this + 23100) + 269, (_BYTE *)(9697930 - (_DWORD)&loc_492F22));
    sub_408820(v78);
    if ( !*(_DWORD *)(this + 10752) || sub_408AA0(v78) )
      *(_BYTE *)(this + 1868) = 0;
    v79 = 9700052;
    nullsub_2((const char *)(9700052 - ((_DWORD)&loc_49378B + 1)), *(_DWORD *)(this + 10752), *(_DWORD *)(this + 10752));
    LOBYTE(v3) = *(_BYTE *)(this + 1868);
    if ( (_BYTE)v3 )
    {
      *(_BYTE *)(this + 1868) = 0;
      v80 = -1;
      sub_401A70(&v80, (unsigned __int8 *)(this + 110192), 1428);
      if ( *(_DWORD *)(this + 112340) != v80 )
      {
        v79 = 9704334;
        nullsub_2((const char *)(9704334 - ((_DWORD)&loc_494869 + 1)));
      }
      v3 = *(_DWORD *)(this + 112340);
      if ( v3 == v80 )
      {
        if ( *(_DWORD *)(this + 112324) != a2[51] )
          nullsub_2((const char *)(9706033 - ((_DWORD)&loc_494F2A + 3)), *(_DWORD *)(this + 112324), a2[51]);
        if ( *(_DWORD *)(this + 112328) != a2[52] )
          nullsub_2((const char *)(9707301 - ((_DWORD)&loc_49543E + 3)), *(_DWORD *)(this + 112328), a2[52]);
        if ( *(_DWORD *)(this + 112332) != a2[40] )
          nullsub_2((const char *)(9708570 - ((_DWORD)&loc_495953 + 3)), *(_DWORD *)(this + 112332), a2[40]);
        if ( *(_DWORD *)(this + 112252) != a2[23] )
          nullsub_2((const char *)(9709841 - ((_DWORD)&loc_495E6B + 2)), *(_DWORD *)(this + 112252), a2[23]);
        LOBYTE(v3) = v80;
        if ( *(_DWORD *)(this + 112340) == v80 )
        {
          v3 = a2[51];
          if ( *(_DWORD *)(this + 112324) == v3 )
          {
            v3 = a2[52];
            if ( *(_DWORD *)(this + 112328) == v3 )
            {
              v3 = *(_DWORD *)(this + 112332);
              if ( v3 == a2[40] )
              {
                v3 = a2[23];
                if ( *(_DWORD *)(this + 112252) == v3 )
                {
                  v4 = *(_DWORD *)(this + 112256);
                  v5 = dword_4C1AE4 - v4;
                  v6 = v4 - (dword_4C1AE4 - v4);
                  dword_4C1AE4 = v5;
                  a2[9] = v5;
                  a2[8] = v6;
                  v7 = a2[124];
                  v8 = *(_DWORD *)(this + 112260);
                  v9 = *(_DWORD *)(v7 + a2[120]);
                  if ( v8 < v9 || (v9 = *(_DWORD *)(a2[121] + v7), v8 > v9) )
                  {
                    dword_4C1AE4 -= v9;
                    v10 = v9 - dword_4C1AE4;
                    a2[123] = dword_4C1AE4;
                    a2[122] = v10;
                  }
                  else
                  {
                    v11 = dword_4C1AE4 - v8;
                    v12 = v8 - (dword_4C1AE4 - v8);
                    dword_4C1AE4 = v11;
                    a2[123] = v11;
                    a2[122] = v12;
                  }
                  v13 = a2[147];
                  v14 = *(_DWORD *)(this + 112264);
                  v15 = *(_DWORD *)(v13 + a2[143]);
                  if ( v14 < v15 || (v15 = *(_DWORD *)(a2[144] + v13), v14 > v15) )
                  {
                    dword_4C1AE4 -= v15;
                    v16 = v15 - dword_4C1AE4;
                    a2[146] = dword_4C1AE4;
                    a2[145] = v16;
                  }
                  else
                  {
                    v17 = dword_4C1AE4 - v14;
                    v18 = v14 - (dword_4C1AE4 - v14);
                    dword_4C1AE4 = v17;
                    a2[146] = v17;
                    a2[145] = v18;
                  }
                  v19 = a2[159];
                  v20 = *(_DWORD *)(this + 112268);
                  v21 = *(_DWORD *)(a2[155] + v19);
                  if ( v20 < v21 || (v21 = *(_DWORD *)(a2[156] + v19), v20 > v21) )
                  {
                    dword_4C1AE4 -= v21;
                    v22 = v21 - dword_4C1AE4;
                    a2[158] = dword_4C1AE4;
                    a2[157] = v22;
                  }
                  else
                  {
                    v23 = dword_4C1AE4 - v20;
                    v24 = v20 - (dword_4C1AE4 - v20);
                    dword_4C1AE4 = v23;
                    a2[158] = v23;
                    a2[157] = v24;
                  }
                  v25 = a2[214];
                  v26 = *(_DWORD *)(this + 112272);
                  v27 = *(_DWORD *)(v25 + a2[210]);
                  if ( v26 < v27 || (v27 = *(_DWORD *)(a2[211] + v25), v26 > v27) )
                  {
                    dword_4C1AE4 -= v27;
                    v28 = v27 - dword_4C1AE4;
                    a2[213] = dword_4C1AE4;
                    a2[212] = v28;
                  }
                  else
                  {
                    v29 = dword_4C1AE4 - v26;
                    v30 = v26 - (dword_4C1AE4 - v26);
                    dword_4C1AE4 = v29;
                    a2[213] = v29;
                    a2[212] = v30;
                  }
                  v31 = a2[115];
                  v32 = *(_DWORD *)(this + 112276);
                  v33 = *(_DWORD *)(v31 + a2[111]);
                  if ( v32 < v33 || (v33 = *(_DWORD *)(a2[112] + v31), v32 > v33) )
                  {
                    dword_4C1AE4 -= v33;
                    v34 = v33 - dword_4C1AE4;
                    a2[114] = dword_4C1AE4;
                    a2[113] = v34;
                  }
                  else
                  {
                    v35 = dword_4C1AE4 - v32;
                    v36 = v32 - (dword_4C1AE4 - v32);
                    dword_4C1AE4 = v35;
                    a2[114] = v35;
                    a2[113] = v36;
                  }
                  v37 = 1000 * *(_DWORD *)(this + 112276);
                  v38 = dword_4C1AE4 - v37;
                  v39 = v37 - (dword_4C1AE4 - v37);
                  dword_4C1AE4 = v38;
                  a2[131] = v38;
                  a2[130] = v39;
                  v40 = *(_DWORD *)(this + 112280);
                  v41 = dword_4C1AE4 - v40;
                  v42 = v40 - (dword_4C1AE4 - v40);
                  dword_4C1AE4 = v41;
                  a2[167] = v41;
                  a2[166] = v42;
                  v43 = *(_DWORD *)(this + 112284);
                  v44 = dword_4C1AE4 - v43;
                  v45 = v43 - (dword_4C1AE4 - v43);
                  dword_4C1AE4 = v44;
                  a2[169] = v44;
                  a2[168] = v45;
                  v46 = *(_DWORD *)(this + 112288);
                  v47 = dword_4C1AE4 - v46;
                  v48 = v46 - (dword_4C1AE4 - v46);
                  dword_4C1AE4 = v47;
                  a2[171] = v47;
                  a2[170] = v48;
                  v49 = *(_DWORD *)(this + 112292);
                  v50 = dword_4C1AE4 - v49;
                  v51 = v49 - (dword_4C1AE4 - v49);
                  dword_4C1AE4 = v50;
                  a2[173] = v50;
                  a2[172] = v51;
                  v52 = *(_DWORD *)(this + 112296);
                  v53 = dword_4C1AE4 - v52;
                  v54 = v52 - (dword_4C1AE4 - v52);
                  dword_4C1AE4 = v53;
                  a2[175] = v53;
                  a2[174] = v54;
                  v55 = *(_DWORD *)(this + 112300);
                  v56 = dword_4C1AE4 - v55;
                  v57 = v55 - (dword_4C1AE4 - v55);
                  dword_4C1AE4 = v56;
                  a2[177] = v56;
                  a2[176] = v57;
                  v58 = *(_DWORD *)(this + 112304);
                  v59 = dword_4C1AE4 - v58;
                  v60 = v58 - (dword_4C1AE4 - v58);
                  dword_4C1AE4 = v59;
                  a2[179] = v59;
                  a2[178] = v60;
                  v61 = *(_DWORD *)(this + 112308);
                  v62 = dword_4C1AE4 - v61;
                  v63 = v61 - (dword_4C1AE4 - v61);
                  dword_4C1AE4 = v62;
                  a2[181] = v62;
                  a2[180] = v63;
                  v64 = *(_DWORD *)(this + 112312);
                  v65 = dword_4C1AE4 - v64;
                  v66 = v64 - (dword_4C1AE4 - v64);
                  dword_4C1AE4 = v65;
                  a2[183] = v65;
                  a2[182] = v66;
                  v67 = *(_DWORD *)(this + 112316);
                  v68 = dword_4C1AE4 - v67;
                  dword_4C1AE4 = v68;
                  a2[185] = v68;
                  a2[184] = v67 - v68;
                  v69 = (*(_DWORD *)(this + 112320) & 1) << 17;
                  v70 = (_DWORD *)(this + 112220);
                  v71 = a2[186] & 0xFFFDFFFF | v69;
                  v72 = a2[187];
                  a2[186] = v71;
                  LOBYTE(v72) = v72 & 0x7F;
                  a2[186] = v71 & 0xBFFFFFFF | ((v70[25] & 2) << 29);
                  v73 = v72 | (32 * (v70[25] & 4));
                  a2[187] = v73;
                  BYTE1(v73) &= 0xFDu;
                  v74 = v73 | ((v70[25] & 8) << 6);
                  a2[187] = v74;
                  BYTE1(v74) &= 0x7Fu;
                  v75 = v74 | ((v70[25] & 0x10) << 11);
                  a2[187] = v75;
                  v76 = v75 & 0xFFF7FFFF | ((v70[25] & 0x20) << 14);
                  a2[187] = v76;
                  a2[187] = v76 & 0xFBFFFFFF | ((v70[25] & 0x40) << 20);
                  memset(v70, 0, 0x80u);
                  LOBYTE(v3) = nullsub_2((const char *)(9724682 - ((_DWORD)&loc_49987B + 3)));
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00424930) --------------------------------------------------------
int __thiscall sub_424930(_DWORD *this, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // edi
  unsigned int v9; // esi
  unsigned int v10; // edx
  int result; // eax

  v2 = this[302];
  if ( !*(_BYTE *)(v2 + 8045) )
    return sub_405A90(this[2555], a2);
  v3 = *(_DWORD *)(v2 + 8072);
  if ( v3 <= 10 )
    return sub_405A90(this[2555], a2);
  if ( v3 >= 60 )
  {
    if ( v3 > 200 )
      v3 = 200;
  }
  else
  {
    v3 = 60;
  }
  v4 = (v3 << 8) / 100;
  v5 = v4 * BYTE2(a2);
  LOBYTE(v5) = 0;
  if ( v5 < 0xFF00 )
    v6 = (v4 * (unsigned int)BYTE2(a2)) >> 8;
  else
    v6 = 255;
  v7 = v4 * BYTE1(a2);
  LOBYTE(v7) = 0;
  if ( v7 < 0xFF00 )
    v8 = (v4 * (unsigned int)BYTE1(a2)) >> 8;
  else
    v8 = 255;
  v9 = v4 * (unsigned __int8)a2;
  v10 = v9;
  LOBYTE(v10) = 0;
  if ( v10 < 0xFF00 )
    result = sub_405A90(this[2555], (v9 >> 8) | ((v8 | (v6 << 8)) << 8));
  else
    result = sub_405A90(this[2555], ((v8 | (v6 << 8)) << 8) | 0xFF);
  return result;
}

//----- (00424A60) --------------------------------------------------------
int __thiscall sub_424A60(_WORD *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  _WORD *v6; // esi
  int v7; // edi
  int result; // eax

  v3 = -1677229739;
  v4 = 240;
  do
    v3 ^= *(_DWORD *)&aFailedToLoadDy[4 * v4-- - 536104];
  while ( v4 );
  v5 = a2;
  v6 = this + 52;
  *(_DWORD *)((char *)this + v3 + 5991136) = a2;
  v7 = 260;
  do
  {
    result = v5 / 127773;
    v5 = 16807 * (v5 % 127773) - 2836 * (v5 / 127773) + 123;
    if ( v5 <= 0 )
      v5 += 0x7FFFFFFF;
    *v6++ = v5;
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (00424AF0) --------------------------------------------------------
char __thiscall sub_424AF0(int this, _DWORD *a2)
{
  char result; // al
  _DWORD *v4; // edi
  int v5; // eax
  char *v6; // ebx
  char v7; // al
  char *v8; // eax

  result = *(_BYTE *)(this + 96);
  if ( result )
  {
    v4 = a2;
    if ( *(_BYTE *)(this + 377) )
    {
      if ( a2[23] == 26 )
        *(_BYTE *)(this + 377) = 0;
      v6 = (char *)a2 + 99;
      if ( a2[89] )
      {
        while ( 1 )
        {
          v7 = *v6;
          if ( *v6 == 13 )
            break;
          if ( v7 == 8 && *(_BYTE *)(this + 120) )
          {
            *(strchr((const char *)(this + 120), 0) - 1) = 0;
          }
          else if ( (unsigned __int8)v7 >= 0x20u && (unsigned __int8)v7 < 0x7Fu )
          {
            if ( strlen((const char *)(this + 120)) < 0xFE )
            {
              v8 = strchr((const char *)(this + 120), 0);
              *v8 = *v6;
              v8[1] = 0;
            }
            v4 = a2;
          }
          ++v6;
          if ( v4[89]-- == 1 )
            goto LABEL_30;
        }
        if ( *(_BYTE *)(this + 120) )
        {
          strncpyt((void *)(*(_DWORD *)(this + 104) + 580 * *(_DWORD *)(this + 8) + 52), (void *)(this + 120), 256);
          *(_BYTE *)(*(_DWORD *)(this + 104) + 580 * *(_DWORD *)(this + 8)) = 1;
          *(_BYTE *)(this + 376) = 1;
        }
        *(_BYTE *)(this + 377) = 0;
      }
LABEL_30:
      result = (*(int (__thiscall **)(_DWORD *))(*v4 + 16))(v4);
    }
    else
    {
      if ( memchr((char *)a2 + 99, 13, a2[89]) )
      {
        (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
        *(_BYTE *)(this + 377) = 1;
        *(_BYTE *)(this + 120) = 0;
      }
      v5 = a2[23];
      if ( v5 == 26 )
      {
        *(_BYTE *)(this + 96) = 0;
        sub_40B7D0(*(void **)(this + 104));
        *(_DWORD *)(this + 104) = 0;
        *(_DWORD *)(this + 112) = 0;
        *(_DWORD *)(this + 108) = 0;
        *(_DWORD *)(this + 80) = 0;
        (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
        result = *(_BYTE *)(this + 376);
        if ( result )
          result = (*(int (__thiscall **)(int, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(*(_DWORD *)(this + 116)
                                                                                            + 111620)
                                                                                + 28))(
                     *(_DWORD *)(this + 116) + 111620,
                     9749802 - (_DWORD)&loc_49F9A2,
                     0,
                     0,
                     0,
                     1);
      }
      else if ( v5 == 18 )
      {
        if ( *(_BYTE *)(this + 376) )
          (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)(this + 100) + 4))(this + 100, 0);
        *(_BYTE *)(this + 96) = 0;
        sub_40B7D0(*(void **)(this + 104));
        *(_DWORD *)(this + 104) = 0;
        *(_DWORD *)(this + 112) = 0;
        *(_DWORD *)(this + 108) = 0;
        *(_DWORD *)(this + 80) = 0;
        result = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
      }
      else
      {
        result = sub_443D00((_DWORD *)this, a2);
      }
    }
  }
  return result;
}

//----- (00424F10) --------------------------------------------------------
char __thiscall sub_424F10(_DWORD *this, unsigned int a2, unsigned __int8 *a3)
{
  int v4; // eax
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // eax
  char result; // al
  unsigned __int8 v9; // bl
  int v10; // eax
  char *v11; // ecx
  int v12; // edx
  int v13; // edi
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  char *v17; // [esp+8h] [ebp-20Ch]
  char v18; // [esp+Ch] [ebp-208h] BYREF
  char v19; // [esp+Dh] [ebp-207h] BYREF
  char v20; // [esp+Eh] [ebp-206h] BYREF

  v4 = this[177];
  v5 = a2 + this[345];
  v6 = this[229] + 1;
  this[345] = v5;
  this[229] = v6;
  if ( v4 )
  {
    v7 = sub_4431A0(this + 176, &v18, a3, a2);
    result = sub_40F990(this + 1, (int)&v18, v7);
  }
  else if ( this[24] >= 0x80000000 )
  {
    result = sub_40F990(this + 1, (int)a3, a2);
  }
  else
  {
    v9 = a3[1];
    sub_46CAB0((unsigned int)&v18, a3, a2);
    v10 = 0;
    if ( *a3 )
    {
      v11 = &v19;
      v10 = (int)(a2 + 2) / 4;
    }
    else if ( v9 == 1 || v9 == 2 || this[178] == 1 )
    {
      v11 = v17;
    }
    else
    {
      v11 = &v20;
      v10 = (int)(a2 + 1) / 4;
    }
    v12 = this[24];
    if ( v10 > 0 )
    {
      v13 = (char *)(this + 26) - v11;
      v14 = v10;
      do
      {
        v15 = *(_DWORD *)v11 ^ *(_DWORD *)&v11[v13];
        v11 += 4;
        v16 = v12 ^ v15;
        --v14;
        *((_DWORD *)v11 - 1) = v16;
        v12 = v16;
      }
      while ( v14 );
    }
    result = sub_40F990(this + 1, (int)&v18, a2);
  }
  return result;
}
// 424FDF: variable 'v17' is possibly undefined

//----- (004256D0) --------------------------------------------------------
int __thiscall sub_4256D0(int *this, int a2)
{
  int *v3; // ebx
  _DWORD *v4; // ebp
  unsigned int v5; // edx
  int *v6; // esi
  unsigned int v7; // eax
  bool v8; // al
  int *v9; // edi
  int v10; // ebp
  int result; // eax
  int v12; // ecx
  int *v13; // [esp+10h] [ebp-4h]
  _DWORD *v14; // [esp+18h] [ebp+4h]

  v3 = this + 91;
  v13 = this + 91;
  sub_46CAB0((unsigned int)(this + 91), (_BYTE *)(a2 + 5772), 0xC8u);
  v4 = this + 195;
  this[141] = 112;
  this[142] = 27;
  v14 = this + 195;
  memset(this + 195, 0, 0x34u);
  v5 = 0;
  v6 = v3;
  while ( 1 )
  {
    v8 = ((v6[52] = 0, v7 = (unsigned __int8)*v6, v7 >= 0x41) && (unsigned __int8)*v6 <= 0x5Au
       || (unsigned __int8)*v6 >= 0x30u && (unsigned __int8)*v6 <= 0x39u
       || (unsigned __int8)*v6 >= 0xBAu && (unsigned __int8)*v6 <= 0xC0u
       || (unsigned __int8)*v6 >= 0xDBu && (unsigned __int8)*v6 <= 0xDEu
       || v7 == 32
       || v7 == 8
       || v7 == 13)
      && (*v6 & 0x3330000) == 0;
    *((_BYTE *)v4 + v5) = v8;
    v9 = v3;
    v10 = 52;
    do
    {
      result = *v6;
      v12 = *v9;
      if ( *(_BYTE *)v9 == *(_BYTE *)v6 && (result & ~v12 & 0x7770000) == 0 )
      {
        result = v12 & ~result & 0x7770000;
        v6[52] |= result;
      }
      ++v9;
      --v10;
    }
    while ( v10 );
    ++v5;
    ++v6;
    if ( v5 >= 0x34 )
      break;
    v4 = v14;
    v3 = v13;
  }
  return result;
}

//----- (004257F0) --------------------------------------------------------
char __thiscall sub_4257F0(_DWORD *this, char *String2)
{
  int v3; // ebx
  int i; // edi

  v3 = 0;
  if ( (int)this[3] <= 0 )
    return 0;
  for ( i = 0; _strcmpi((const char *)(i + this[1]), String2); i += 36 )
  {
    if ( ++v3 >= this[3] )
      return 0;
  }
  return 1;
}

//----- (00425840) --------------------------------------------------------
char __thiscall sub_425840(_BYTE *this, int a2)
{
  char result; // al

  (*(void (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 40))(this, a2);
  result = this[197532];
  this[75476] = a2;
  if ( result != (_BYTE)a2 )
  {
    (*(void (__thiscall **)(_BYTE *))(*((_DWORD *)this + 5) + 20))(this + 20);
    (*(void (__thiscall **)(_BYTE *, int))(*((_DWORD *)this + 18939) + 372))(this + 75756, a2);
    result = 0;
    if ( (_BYTE)a2 )
    {
      this[206844] = 0;
      this[206845] = 0;
    }
  }
  this[197532] = a2;
  return result;
}

//----- (004258A0) --------------------------------------------------------
int __thiscall sub_4258A0(_DWORD *this)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  unsigned int v13; // eax
  int v14; // ebx
  unsigned int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // ebx
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // ebx
  int v25; // eax
  int v26; // ebx
  int v27; // eax
  int v28; // ebx
  int v29; // eax
  int v30; // ebx
  int v31; // eax
  int v32; // eax
  unsigned int v33; // eax
  int v34; // ecx
  int v35; // eax
  unsigned int v36; // ecx
  int v37; // eax
  int v38; // ecx
  int v39; // ecx
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // ecx
  int v44; // eax
  int v45; // ecx
  int v46; // ecx
  int v47; // eax
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  int v56; // eax
  int v57; // ecx
  char v58; // al
  int v59; // eax
  _DWORD *v60; // ebx
  int result; // eax
  int v62; // ecx
  int v63; // edi
  int v64; // ecx
  int v65; // esi

  v2 = (_DWORD *)(this[3] + 1308 * (this[23] != 8 ? this[23] : 0) + 12508);
  v3 = *(_DWORD *)(this[124] + this[120]);
  dword_4C1AE4 -= v3;
  v4 = v3 - dword_4C1AE4;
  this[123] = dword_4C1AE4;
  this[122] = v4;
  v5 = *(_DWORD *)(this[115] + this[111]);
  dword_4C1AE4 -= v5;
  v6 = v5 - dword_4C1AE4;
  this[114] = dword_4C1AE4;
  this[113] = v6;
  v7 = *(_DWORD *)(this[159] + this[155]);
  dword_4C1AE4 -= v7;
  v8 = v7 - dword_4C1AE4;
  this[158] = dword_4C1AE4;
  this[157] = v8;
  v9 = *(_DWORD *)(this[147] + this[143]);
  dword_4C1AE4 -= v9;
  v10 = v9 - dword_4C1AE4;
  this[146] = dword_4C1AE4;
  this[145] = v10;
  v11 = *(_DWORD *)(this[214] + this[210]);
  v12 = dword_4C1AE4 - v11;
  dword_4C1AE4 = v12;
  this[213] = v12;
  this[212] = v11 - v12;
  v13 = v2[1];
  if ( v13 > v2[77] )
    v13 = v2[77];
  v14 = dword_4C1AE4 - v13;
  dword_4C1AE4 = v14;
  this[167] = v14;
  this[166] = v13 - v14;
  v15 = v2[144];
  if ( v15 > v2[145] )
    v15 = v2[145];
  v16 = dword_4C1AE4 - v15;
  v17 = v15 - (dword_4C1AE4 - v15);
  dword_4C1AE4 = v16;
  this[169] = v16;
  this[168] = v17;
  v18 = dword_4C1AE4;
  this[171] = dword_4C1AE4;
  this[170] = -v18;
  v19 = v2[190];
  if ( v19 > v2[198] )
    v19 = v2[198];
  v20 = dword_4C1AE4 - v19;
  dword_4C1AE4 = v20;
  this[173] = v20;
  this[172] = v19 - v20;
  v21 = v2[273];
  if ( v21 > v2[57] )
    v21 = v2[57];
  v22 = dword_4C1AE4 - v21;
  dword_4C1AE4 = v22;
  this[175] = v22;
  this[174] = v21 - v22;
  v23 = v2[24];
  if ( v23 > v2[65] )
    v23 = v2[65];
  v24 = dword_4C1AE4 - v23;
  dword_4C1AE4 = v24;
  this[177] = v24;
  this[176] = v23 - v24;
  v25 = v2[30];
  if ( v25 > v2[316] )
    v25 = v2[316];
  v26 = dword_4C1AE4 - v25;
  dword_4C1AE4 = v26;
  this[179] = v26;
  this[178] = v25 - v26;
  v27 = v2[141];
  if ( v27 > v2[151] )
    v27 = v2[151];
  v28 = dword_4C1AE4 - v27;
  dword_4C1AE4 = v28;
  this[181] = v28;
  this[180] = v27 - v28;
  v29 = v2[168];
  if ( v29 > v2[97] )
    v29 = v2[97];
  v30 = dword_4C1AE4 - v29;
  dword_4C1AE4 = v30;
  this[183] = v30;
  this[182] = v29 - v30;
  v31 = v2[231];
  if ( v31 > v2[111] )
    v31 = v2[111];
  dword_4C1AE4 -= v31;
  v32 = v31 - dword_4C1AE4;
  this[185] = dword_4C1AE4;
  this[184] = v32;
  v33 = this[186] & 0xFFFDFFFF | ((v2[250] == 2) << 17);
  this[186] = v33;
  this[186] = v33 & 0xBFFFFFFF | ((v2[255] == 2) << 30);
  v34 = this[187];
  LOBYTE(v34) = v34 & 0x7F;
  v35 = v34 | ((v2[253] == 2) << 7);
  this[187] = v35;
  v36 = v35 & 0xFBF77DFF | ((v2[42] == 2) << 9);
  v37 = this[23];
  this[187] = v36;
  if ( v37 == 8 )
  {
    v38 = dword_4C1AE4;
    this[131] = dword_4C1AE4;
    this[130] = -v38;
  }
  else
  {
    v39 = this[115];
    if ( *(_DWORD *)(this[116] + v39) )
    {
      v40 = this[113] + this[114];
      v41 = *(_DWORD *)(this[112] + v39);
      if ( v40 > v41 )
        v40 = v41;
    }
    else
    {
      v40 = *(_DWORD *)(v39 + this[111]);
    }
    if ( 1000 * v40 >= 100000 )
    {
      v43 = this[115];
      if ( *(_DWORD *)(this[116] + v43) )
      {
        v44 = this[113] + this[114];
        v45 = *(_DWORD *)(this[112] + v43);
        if ( v44 > v45 )
          v44 = v45;
      }
      else
      {
        v44 = *(_DWORD *)(v43 + this[111]);
      }
      v42 = 1000 * v44;
    }
    else
    {
      v42 = 100000;
    }
    v46 = dword_4C1AE4 - v42;
    v47 = v42 - (dword_4C1AE4 - v42);
    dword_4C1AE4 = v46;
    this[131] = v46;
    this[130] = v47;
  }
  this[192] = 0;
  this[109] = 0;
  v48 = dword_4C1AE4;
  this[104] = dword_4C1AE4;
  this[103] = -v48;
  if ( this[12] + this[13] )
    v49 = *(_DWORD *)(this[3] + 10884);
  else
    v49 = 0;
  dword_4C1AE4 -= v49;
  v50 = v49 - dword_4C1AE4;
  this[150] = dword_4C1AE4;
  this[149] = v50;
  v51 = dword_4C1AE4;
  this[152] = dword_4C1AE4;
  this[151] = -v51;
  v52 = dword_4C1AE4;
  this[190] = dword_4C1AE4;
  this[189] = -v52;
  v53 = dword_4C1AE4;
  this[102] = dword_4C1AE4;
  this[101] = -v53;
  v54 = dword_4C1AE4;
  this[100] = dword_4C1AE4;
  this[99] = -v54;
  v55 = dword_4C1AE4;
  this[104] = dword_4C1AE4;
  this[103] = -v55;
  this[161] = 0;
  this[107] = 0;
  v56 = -1212641209;
  v57 = 62;
  do
    v56 ^= *(_DWORD *)&aMemoryError[4 * v57-- - 471988];
  while ( v57 );
  *(_DWORD *)((char *)this + v56 + 238792) = 0;
  v58 = this[24] & 0xF0;
  this[81] = 0;
  this[16] = 0;
  *((_BYTE *)this + 96) = v58;
  v59 = 0;
  v60 = (_DWORD *)((char *)&loc_45235E + 2);
  do
    v59 -= *v60++;
  while ( v60 < (_DWORD *)&loc_452604 );
  result = v59 + 298798809;
  v62 = (this[23] != 8) - 1;
  v63 = dword_4C1AE4 - v62;
  v64 = v62 - (dword_4C1AE4 - v62);
  dword_4C1AE4 = v63;
  *(_DWORD *)((char *)this + result + 663336) = v63;
  *(_DWORD *)((char *)this + result + 663332) = v64;
  v65 = v2[318];
  if ( v65 > 0 )
    result = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 60))(this, 0, v65);
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00425E50) --------------------------------------------------------
int __thiscall sub_425E50(int this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int result; // eax

  *(_DWORD *)(*(_DWORD *)(this + 116) + 117764) = 0;
  if ( *(_DWORD *)(this + 100) == 6 )
    *(_DWORD *)(this + 8) = *(_DWORD *)(this + 124);
  *(_DWORD *)(this + 100) = a2 % 7;
  v3 = 198275451;
  v4 = 75;
  do
    v3 ^= *((_DWORD *)&dbl_4AE678 + v4-- - 97986);
  while ( v4 );
  *(_DWORD *)(v3 + this + 37488) = 0;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 116) + 23100) + 8263) = *(_DWORD *)(this + 100);
  result = *(_DWORD *)(this + 100);
  *(_BYTE *)(this + 96) = result != 0;
  *(_BYTE *)(this + 104) = 1;
  return result;
}
// 4AE678: using guessed type double dbl_4AE678;

//----- (00425ED0) --------------------------------------------------------
_DWORD *__thiscall sub_425ED0(char *this)
{
  int v2; // eax
  bool v3; // al
  _DWORD *result; // eax
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  int v8; // ecx
  int v9; // edx
  int v10; // edi
  int (__cdecl *v11)(int *, int *); // ecx
  bool v12; // zf
  int v13; // ebx
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // edi
  int v20; // edx
  int v21; // edi
  _DWORD *v22; // eax
  int v23; // eax
  int v24; // ebx
  int v25; // eax
  int v26; // ecx
  _DWORD *v27; // [esp+4h] [ebp-8h]
  int v28; // [esp+8h] [ebp-4h]

  v3 = 1;
  if ( !*((_DWORD *)this + 25) )
  {
    v2 = *((_DWORD *)this + 28);
    if ( !v2 || *(_DWORD *)(*((_DWORD *)this + 29) + 23104) - v2 >= 300 )
      v3 = 0;
  }
  this[96] = v3;
  result = (_DWORD *)*((_DWORD *)this + 29);
  if ( result[1569] && result[542] && this[104] )
  {
    this[4] = *(_BYTE *)(result[5775] + 8054) == 0;
    v5 = *(_DWORD *)this;
    *((_DWORD *)this + 20) = result[1569];
    this[104] = 0;
    (*(void (__thiscall **)(char *))(v5 + 8))(this);
    v6 = *((_DWORD *)this + 29);
    v7 = *(_DWORD *)(v6 + 6276);
    if ( *((_DWORD *)this + 31) >= v7 )
      *((_DWORD *)this + 31) = v7 - 1;
    v8 = *((_DWORD *)this + 25);
    if ( v8 == 6 )
      v9 = *((_DWORD *)this + 31);
    else
      v9 = *((_DWORD *)this + 2);
    v10 = *(_DWORD *)(v6 + 4 * v9 + 2180);
    v28 = v10;
    if ( v8 == 3 )
    {
      v11 = (int (__cdecl *)(int *, int *))CompareFunction;
    }
    else if ( v8 == 4 || (v12 = v8 == 6, v11 = sub_414CD0, v12) )
    {
      v11 = sub_414D70;
    }
    qsort((void *)(v6 + 2180), *(_DWORD *)(v6 + 6276), 4u, (_CoreCrtNonSecureSearchSortCompareFunction)v11);
    if ( *((_DWORD *)this + 25) == 6 )
    {
      v13 = *((_DWORD *)this + 29);
      v14 = 0;
      v15 = *(_DWORD *)(v13 + 6276);
      v16 = (_DWORD *)(v13 + 2180);
      if ( v15 <= 0 )
      {
LABEL_23:
        v14 = -1;
      }
      else
      {
        while ( *v16 != v10 )
        {
          ++v14;
          ++v16;
          if ( v14 >= v15 )
            goto LABEL_23;
        }
      }
      v17 = 0;
      *((_DWORD *)this + 31) = v14;
      *((_DWORD *)this + 20) = 0;
      v18 = -1;
      if ( *(int *)(v13 + 6276) > 0 )
      {
        v19 = v13 + 2180;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)v19 + 88) != v18 )
          {
            v18 = *(_DWORD *)(*(_DWORD *)v19 + 88);
            if ( *(_DWORD *)(v28 + 88) == v18 )
              *((_DWORD *)this + 2) = *((_DWORD *)this + 20);
            ++*((_DWORD *)this + 20);
          }
          ++v17;
          v19 += 4;
        }
        while ( v17 < *(_DWORD *)(v13 + 6276) );
      }
      (*(void (__thiscall **)(char *))(*(_DWORD *)this + 8))(this);
    }
    else
    {
      v20 = 0;
      v21 = 0;
      if ( *((int *)this + 20) > 0 )
      {
        v22 = (_DWORD *)(*((_DWORD *)this + 29) + 2180);
        v27 = v22;
        do
        {
          v23 = *v22;
          v24 = *(_DWORD *)(v23 + 160);
          if ( v24 + *(_DWORD *)(v23 + 164) > v20 )
            v20 = v24 + *(_DWORD *)(v23 + 164);
          if ( v23 == v28 )
            *((_DWORD *)this + 2) = v21;
          ++v21;
          v22 = ++v27;
        }
        while ( v21 < *((_DWORD *)this + 20) );
      }
      for ( *((_DWORD *)this + 30) = 1; v20 >= 10; ++*((_DWORD *)this + 30) )
        v20 /= 10;
      if ( *((int *)this + 30) < 6 )
        *((_DWORD *)this + 30) = 6;
      (*(void (__thiscall **)(char *))(*(_DWORD *)this + 8))(this);
      v25 = -16947577;
      v26 = 87;
      do
        v25 ^= *(_DWORD *)&aSlovak[4 * v26-- - 656008];
      while ( v26 );
      *(_DWORD *)&this[v25 + 45052] = *((_DWORD *)this + 2);
    }
    result = (_DWORD *)sprintf_0(
                         this + 12,
                         off_4B816C[*((_DWORD *)this + 25)],
                         *(_DWORD *)(*((_DWORD *)this + 29) + 6276));
  }
  return result;
}
// 4B816C: using guessed type char *[15];

//----- (00426120) --------------------------------------------------------
char __fastcall sub_426120(char *Str)
{
  int v2; // ebx
  int *v3; // ecx
  char result; // al
  _BYTE *v5; // esi
  char *v6; // eax
  bool v7; // cf
  unsigned __int8 v8; // dl
  int v9; // eax
  unsigned __int16 (__stdcall *v10)(int); // esi
  char *v11; // eax
  int (__fastcall *v12)(int, unsigned int, unsigned int *, unsigned int); // esi
  int v13; // ecx
  unsigned int i; // eax
  int v15; // eax
  int v16; // esi
  int v17; // eax
  _DWORD *v18; // eax
  int (__fastcall *v19)(int, unsigned int, unsigned int *, unsigned int); // eax
  int v20; // ecx
  int v21; // edi
  int (__fastcall *v22)(int, unsigned int, unsigned int *, unsigned int); // eax
  int v23; // edi
  unsigned int j; // esi
  int k; // esi
  int v26; // eax
  _DWORD *v27; // eax
  int v28; // esi
  unsigned int l; // esi
  char v30; // bl
  int v31; // ebx
  _DWORD v32[3]; // [esp+0h] [ebp-308h] BYREF
  char pExceptionObject[308]; // [esp+Ch] [ebp-2FCh] BYREF
  _BYTE v34[260]; // [esp+140h] [ebp-1C8h] BYREF
  int v35; // [esp+24Ch] [ebp-BCh] BYREF
  int v36; // [esp+250h] [ebp-B8h] BYREF
  char v37[8]; // [esp+254h] [ebp-B4h] BYREF
  char SubStr[64]; // [esp+25Ch] [ebp-ACh] BYREF
  int (__thiscall **v39[15])(void *, _DWORD); // [esp+29Ch] [ebp-6Ch] BYREF
  char v40[8]; // [esp+2D8h] [ebp-30h] BYREF
  int v41; // [esp+2E0h] [ebp-28h]
  int v42; // [esp+2E4h] [ebp-24h]
  char v43; // [esp+2E8h] [ebp-20h]
  bool v44; // [esp+2E9h] [ebp-1Fh]
  int v45; // [esp+2ECh] [ebp-1Ch] BYREF
  __int64 v46; // [esp+2F0h] [ebp-18h] BYREF
  _DWORD *v47; // [esp+2F8h] [ebp-10h]
  int v48; // [esp+304h] [ebp-4h]
  int savedregs; // [esp+308h] [ebp+0h] BYREF

  v2 = 0;
  v47 = v32;
  HIDWORD(v46) = Str;
  v39[0] = (int (__thiscall **)(void *, _DWORD))&off_4AC038;
  v43 = 0;
  v44 = (unsigned int)dword_4A70A8() < 0x80000000;
  dword_4C1AE4 = sub_431700();
  v48 = 0;
  if ( !strcmp(Str, "Z") )
  {
    sub_427CF0(v39, 1u);
    goto LABEL_3;
  }
  v5 = &unk_4ACCC8;
  v6 = Str;
  while ( 1 )
  {
    LOBYTE(v3) = *v6;
    v7 = (unsigned __int8)*v6 < *v5;
    if ( *v6 != *v5 )
      break;
    if ( !(_BYTE)v3 )
      goto LABEL_10;
    v8 = v6[1];
    LOBYTE(v3) = v8;
    v7 = v8 < v5[1];
    if ( v8 != v5[1] )
      break;
    v6 += 2;
    v5 += 2;
    if ( !v8 )
    {
LABEL_10:
      v9 = 0;
      goto LABEL_12;
    }
  }
  v9 = -v7 - (v7 - 1);
LABEL_12:
  if ( !v9 )
  {
    sub_427CF0(v39, 0);
LABEL_3:
    result = v43;
    v39[0] = (int (__thiscall **)(void *, _DWORD))&off_4AC038;
    if ( v43 )
      result = sub_413B40((int)v39);
    return result;
  }
  dword_4C1AFC = 0;
  LOBYTE(v48) = 1;
  sub_407790(v3);
  sub_4134A0(v39);
  sub_428CF0(0);
  v34[0] = 0;
  dword_4A7100(0, v34, 260);
  sub_407A70(v34);
  if ( !dword_4A7114(v34) )
  {
    v45 = 9778923;
    sub_40DA80((char *)(9778923 - (_DWORD)&byte_4A6AF7));
  }
  byte_4C1A44 = 1;
  sub_412910(SubStr, byte_4ACCBC);
  LOBYTE(v2) = strstr(Str, SubStr)
            || (v10 = (unsigned __int16 (__stdcall *)(int))dword_4A738C, (unsigned __int16)dword_4A738C(145)) && v10(20);
  memset(SubStr, 0, sizeof(SubStr));
  if ( (_BYTE)v2 )
  {
    sub_412910(SubStr, byte_4ACCAC);
    LOBYTE(v48) = 2;
    sub_40D480(SubStr);
    LOBYTE(v48) = 1;
    memset(SubStr, 0, sizeof(SubStr));
  }
  v45 = 9103038;
  v11 = strstr((const char *)HIDWORD(v46), (const char *)(9103038 - ((_DWORD)&loc_401A1C + 2)));
  byte_4C1AF8 = v11 != 0;
  if ( v11 )
  {
    v12 = sub_401000;
    v2 = 9271250;
    do
    {
      v13 = 0;
      for ( i = 0; i < 0x40; ++i )
      {
        v13 ^= *(_DWORD *)v12;
        v12 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v12 + 4);
      }
      HIDWORD(v46) = 9271250;
      sub_40DA80((char *)(9271250 - ((_DWORD)&loc_42AEC1 + 1)));
    }
    while ( (char *)v12 < (char *)&unk_4B8000 );
  }
  *(_DWORD *)&SubStr[24] = 3;
  *(_DWORD *)&SubStr[28] = sub_4191E0;
  *(_DWORD *)&SubStr[32] = 0;
  *(_DWORD *)&SubStr[36] = 0;
  *(_DWORD *)&SubStr[40] = dword_4C1A38;
  *(_DWORD *)&SubStr[44] = 0;
  *(_DWORD *)&SubStr[48] = 0;
  *(_DWORD *)&SubStr[52] = 0;
  *(_DWORD *)&SubStr[56] = 0;
  HIDWORD(v46) = 9195984;
  *(_DWORD *)&SubStr[60] = 9195984 - (_DWORD)&loc_418544;
  dword_4A7390();
  v15 = dword_4A7394(128, *(_DWORD *)&SubStr[60], &unk_4A7DB0, 369098752, 0x4000, 0x4000, 1, 1, 0, 0, dword_4C1A38, 0);
  dword_4A7398(v15);
  dword_4A7048();
  v16 = sub_412170();
  dword_4A7294(&v35, &SubStr[24], v32[0], v32[1]);
  dword_4A7120(&v35, &v46);
  v41 = v16;
  v42 = v46 / 10000;
  if ( !sub_440440(v2) )
    goto LABEL_3;
  byte_4C1AD8 = 0;
  v17 = dword_4A711C(-1, 0, 4, 0, 0x10000, aContshmem);
  dword_4C1ADC = v17;
  if ( v17 )
  {
    dword_4C1AD0 = 65524;
    v18 = (_DWORD *)dword_4A7118(v17, 2, 0, 0, 0);
    dword_4C1AD4 = v18;
    if ( v18 )
    {
      if ( *v18 != 305419605 )
      {
        v18[1] = 0;
        *(_DWORD *)(dword_4C1AD4 + 8) = 0;
        *(_DWORD *)dword_4C1AD4 = 305419605;
      }
      byte_4C1AD8 = 1;
    }
  }
  do
  {
    sub_417EB0((int)&dword_4C1AD0, 21332, 0, 0);
    v19 = sub_401000;
    v20 = 0;
    do
    {
      v21 = *(_DWORD *)v19;
      v19 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v19 + 4);
      v20 ^= v21;
    }
    while ( (char *)v19 < (char *)&unk_4B8000 );
    v22 = sub_401000;
    do
    {
      v23 = *(_DWORD *)v22;
      v22 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v22 + 4);
      v20 ^= v23;
    }
    while ( (char *)v22 < (char *)&unk_4B8000 );
    if ( v20 )
    {
      HIDWORD(v46) = 9557393;
      sub_4073D0((int)pExceptionObject, (char *)(9557393 - ((_DWORD)&loc_47092F + 2)), v20);
      _CxxThrowException(pExceptionObject, &_TI2_AVtext_exception__);
    }
    memset(&SubStr[24], 0, 0x28u);
    for ( j = rand() % 0xAu; j; --j )
      *(_DWORD *)&SubStr[4 * j + 24] = sub_40B720((int)&savedregs, 0x32800u);
    for ( k = rand() % 64; k; --k )
    {
      v26 = rand() % 2048;
      sub_40B720((int)&savedregs, v26);
    }
    v34[0] = 0;
    dword_4A7100(0, v34, 260);
    sub_407A70(v34);
    if ( !dword_4A7114(v34) )
    {
      HIDWORD(v46) = 9778923;
      sub_40DA80((char *)(9778923 - (_DWORD)&byte_4A6AF7));
    }
    v27 = (_DWORD *)sub_40B720((int)&savedregs, 0x32800u);
    v28 = (int)v27;
    HIDWORD(v46) = v27;
    LOBYTE(v48) = 3;
    if ( v27 )
    {
      sub_411CB0(v27);
      LOBYTE(v48) = 4;
      sub_426A50((_DWORD *)(v28 + 20));
      LOBYTE(v48) = 5;
      sub_413C40(v28 + 48, v28 + 20, v28 + 197556);
      LOBYTE(v48) = 6;
      sub_418CC0((_DWORD *)(v28 + 75424), v28 + 20);
      LOBYTE(v48) = 7;
      sub_418060(v28 + 75756, v28 + 75424, v28 + 48, (int)v39);
      LOBYTE(v48) = 8;
      sub_414B30((_WORD *)(v28 + 196404));
      *(_DWORD *)(v28 + 197512) = v39;
      sub_411370((int *)(v28 + 197516));
      LOBYTE(v48) = 9;
      sub_412390((_DWORD *)(v28 + 197536));
      *(_DWORD *)(v28 + 206740) = 0;
      sub_40FE60((_DWORD *)(v28 + 206744));
      *(_BYTE *)(v28 + 206836) = 0;
      *(_DWORD *)(v28 + 206840) = 0;
      *(_BYTE *)(v28 + 206846) = 0;
      *(_DWORD *)v28 = &off_4ACC2C;
      memset((void *)(v28 + 197556), 0, 0x23DCu);
      *(_WORD *)(v28 + 206736) = 0;
    }
    else
    {
      v28 = 0;
    }
    dword_4C1AFC = v28;
    LOBYTE(v48) = 1;
    for ( l = 0; l < 0xA; ++l )
      sub_40B7E0(*(_DWORD *)&SubStr[4 * l + 24]);
    v30 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)dword_4C1AFC + 20))(dword_4C1AFC, 0);
    if ( v30 )
      (*(void (__thiscall **)(int))(*(_DWORD *)dword_4C1AFC + 24))(dword_4C1AFC);
    (*(void (__thiscall **)(int))(*(_DWORD *)dword_4C1AFC + 28))(dword_4C1AFC);
    if ( dword_4C1AFC )
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_4C1AFC + 4))(dword_4C1AFC, 1);
    dword_4C1AFC = 0;
  }
  while ( v30 );
  result = v43;
  v39[0] = (int (__thiscall **)(void *, _DWORD))&off_4AC038;
  if ( v43 )
  {
    result = v44;
    if ( !v44 )
    {
      sub_412910(SubStr, (unsigned __int8 *)&dword_4AC0FC);
      v31 = dword_4A7284(SubStr, 0, 0, 0, 1, 128, 0);
      result = 0;
      memset(SubStr, 0, sizeof(SubStr));
      v45 = 0;
      if ( v31 != -1 )
      {
        v36 = -1;
        strcpy(v37, v40);
        dword_4A70E4(v31, 2, &v36, strlen(v40) + 5, 0, 0, &v45, 0);
        result = dword_4A729C(v31);
      }
    }
  }
  return result;
}
// 42621D: variable 'v3' is possibly undefined
// 4A6AF7: using guessed type char byte_4A6AF7;
// 4A7048: using guessed type int (*dword_4A7048)(void);
// 4A70A8: using guessed type int (*dword_4A70A8)(void);
// 4A70E4: using guessed type int (__stdcall *dword_4A70E4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4A7114: using guessed type int (__stdcall *dword_4A7114)(_DWORD);
// 4A7118: using guessed type int (__stdcall *dword_4A7118)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A711C: using guessed type int (__stdcall *dword_4A711C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7120: using guessed type int (__cdecl *dword_4A7120)(_DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4A738C: using guessed type int (__stdcall *dword_4A738C)(_DWORD);
// 4A7390: using guessed type int (*dword_4A7390)(void);
// 4A7394: using guessed type int (__stdcall *dword_4A7394)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7398: using guessed type int (__stdcall *dword_4A7398)(_DWORD);
// 4AC038: using guessed type int (__stdcall *off_4AC038)(int);
// 4AC0FC: using guessed type int dword_4AC0FC;
// 4ACC2C: using guessed type int (*off_4ACC2C)();
// 4C1A44: using guessed type char byte_4C1A44;
// 4C1AD0: using guessed type int dword_4C1AD0;
// 4C1AD8: using guessed type char byte_4C1AD8;
// 4C1AE4: using guessed type int dword_4C1AE4;
// 4C1AF8: using guessed type char byte_4C1AF8;
// 4C1AFC: using guessed type int dword_4C1AFC;

//----- (004268F0) --------------------------------------------------------
void *__thiscall sub_4268F0(void *this, char a2)
{
  sub_426910((int)this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (00426910) --------------------------------------------------------
int __thiscall sub_426910(int this)
{
  int v2; // esi
  unsigned int v3; // ebp
  int v4; // ebx
  int v6; // [esp+0h] [ebp-24h]
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]

  *(_DWORD *)this = &off_4ACC2C;
  v2 = this + 75756;
  (*(void (__thiscall **)(int))(*(_DWORD *)(this + 75756) + 56))(this + 75756);
  v3 = *(_DWORD *)(this + 206740);
  v4 = 0;
  if ( v3 )
  {
    ((void (__thiscall *)(_DWORD, _DWORD, _DWORD, _DWORD))((char *)&byte_410001 + 111))(
      *(_DWORD *)(this + 206740),
      v6,
      v7,
      v8);
    sub_40B7E0(v3);
  }
  sub_40FE80((_BYTE *)(this + 206744));
  sub_4113A0((_DWORD *)(this + 197516));
  sub_4187E0(v2, v3);
  sub_418D70((_DWORD *)(this + 75424));
  sub_413DA0((_DWORD *)(this + 48));
  *(_DWORD *)(this + 20) = &off_4AC8B8;
  if ( *(int *)(this + 44) > 0 )
  {
    do
    {
      v3 = *(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v4);
      if ( v3 )
      {
        sub_40C9D0(v3 + 268, v3, 0);
        sub_40B7E0(v3);
      }
      ++v4;
    }
    while ( v4 < *(_DWORD *)(this + 44) );
  }
  sub_40B7D0(*(void **)(this + 36));
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 40) = 0;
  sub_40B7D0(*(void **)(this + 24));
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 28) = 0;
  return sub_411D50(this, v3);
}
// 42695F: variable 'v6' is possibly undefined
// 42695F: variable 'v7' is possibly undefined
// 42695F: variable 'v8' is possibly undefined
// 4AC8B8: using guessed type int (__stdcall *off_4AC8B8)(int);
// 4ACC2C: using guessed type int (*off_4ACC2C)();

//----- (00426A50) --------------------------------------------------------
_DWORD *__thiscall sub_426A50(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[3] = 0;
  this[2] = 0;
  this[1] = 0;
  this[6] = 0;
  this[5] = 0;
  this[4] = 0;
  *this = &off_4AC8B8;
  return result;
}
// 4AC8B8: using guessed type int (__stdcall *off_4AC8B8)(int);

//----- (00426A90) --------------------------------------------------------
int __thiscall sub_426A90(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // eax

  result = a2;
  this[23] = a2;
  if ( a2 != 8 )
  {
    v3 = *(_DWORD *)(this[3] + 1308 * a2 + 13812);
    this[20] = v3;
    result = 1000 * v3;
    this[17] = result;
  }
  return result;
}

//----- (00426AF0) --------------------------------------------------------
int __thiscall sub_426AF0(int *this)
{
  return sub_405550(this[300], this[40 * (this[2548] & 0x7F) + 13686]);
}

//----- (00426B20) --------------------------------------------------------
int __thiscall sub_426B20(_DWORD *this)
{
  int v1; // edx
  int v2; // ebp
  int v3; // eax
  int v4; // edi
  const char *v6; // [esp+10h] [ebp-4h]

  v1 = this[137];
  v2 = 0;
  v3 = *(_DWORD *)(v1 + 6276);
  if ( v3 <= 0 )
    return -1;
  v4 = v1 + 2180;
  v6 = (const char *)(this[66] + 8670);
  while ( strcmp((const char *)(*(_DWORD *)v4 + 109), v6) )
  {
    ++v2;
    v4 += 4;
    if ( v2 >= v3 )
      return -1;
  }
  return v2;
}

//----- (00426BA0) --------------------------------------------------------
char __thiscall sub_426BA0(int this, char a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // ebp
  int v8; // edi
  int v9; // ebx
  int v10; // edi
  int v11; // ebx
  unsigned int v13; // [esp-10h] [ebp-14h]

  LOBYTE(v3) = *(_BYTE *)(this + 7652);
  if ( (_BYTE)v3 )
  {
    v3 = *(_DWORD *)(this + 23104) - *(_DWORD *)(this + 7640);
    if ( v3 > 50 )
    {
      LOBYTE(v3) = *(_BYTE *)(this + 113524);
      if ( !(_BYTE)v3 )
      {
        LOBYTE(v3) = *(_BYTE *)(this + 27208);
        if ( !(_BYTE)v3 )
        {
          v3 = *(_DWORD *)(this + 23100);
          if ( !*(_BYTE *)(v3 + 7974) || a2 )
          {
            v3 = (*(int (__cdecl **)(_DWORD))(v3 + 9090))(*(_DWORD *)(this + 23100));
            if ( v3 != -1 )
            {
              v4 = *(_DWORD *)(this + 23100);
              *(_BYTE *)(this + 113524) = 1;
              (*(void (**)(void))(v4 + 9106))();
              v5 = *(_DWORD *)(this + 112464);
              v6 = *(_DWORD *)(this + 112472);
              if ( v6 >= *(_DWORD *)(v5 + 6276) )
                v7 = 0;
              else
                v7 = *(_DWORD *)(v5 + 4 * v6 + 2180);
              v8 = 0;
              if ( *(int *)(this + 6276) > 0 )
              {
                v9 = this + 2180;
                do
                {
                  LOBYTE(v6) = *(_DWORD *)v9 == v7;
                  v13 = v6;
                  LOBYTE(v6) = *(_BYTE *)(*(_DWORD *)v9 + 156);
                  (*(void (__cdecl **)(int, _DWORD, _DWORD, unsigned int, unsigned int))(*(_DWORD *)(this + 23100) + 9114))(
                    *(_DWORD *)v9 + 109,
                    *(_DWORD *)(*(_DWORD *)v9 + 88),
                    *(_DWORD *)(*(_DWORD *)v9 + 92),
                    v6,
                    v13);
                  ++v8;
                  v9 += 4;
                }
                while ( v8 < *(_DWORD *)(this + 6276) );
              }
              v10 = 0;
              if ( *(int *)(this + 111908) > 0 )
              {
                v11 = 0;
                do
                {
                  (*(void (__cdecl **)(_DWORD, int, int))(*(_DWORD *)(this + 23100) + 9126))(
                    *(_DWORD *)(v11 + *(_DWORD *)(this + 111900) + 288),
                    v11 + *(_DWORD *)(this + 111900) + 256,
                    v11 + *(_DWORD *)(this + 111900));
                  ++v10;
                  v11 += 292;
                }
                while ( v10 < *(_DWORD *)(this + 111908) );
              }
              (*(void (**)(void))(*(_DWORD *)(this + 23100) + 9110))();
              LOBYTE(v3) = (*(int (__cdecl **)(int))(*(_DWORD *)(this + 23100) + 9146))(this + 111912);
            }
          }
        }
      }
    }
  }
  return v3;
}
// 426C67: variable 'v6' is possibly undefined

//----- (004273C0) --------------------------------------------------------
int __thiscall sub_4273C0(_DWORD *this)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *i; // ebx

  result = this[129];
  if ( result <= 0 )
  {
    v3 = 8;
    if ( this[23] == 8 )
      v3 = *(_DWORD *)(this[3] + 2172);
    (*(void (__thiscall **)(_DWORD *, int))(*this + 100))(this, v3);
    v4 = 0;
    for ( i = (_DWORD *)(&loc_423AC3 + 1); (unsigned int)i < 0x423E94; ++i )
      v4 -= *i;
    result = v4 + 1455823226;
    *(_DWORD *)((char *)this + result + 618564) = 200;
  }
  return result;
}

//----- (00427420) --------------------------------------------------------
int __thiscall sub_427420(int this)
{
  int result; // eax
  int v3; // ecx
  char v4; // al
  int v5; // ecx
  int v6; // edx

  result = 1276800527;
  v3 = 240;
  do
    result ^= (unsigned int)*(&dword_4A70CC + v3-- - 90082);
  while ( v3 );
  if ( (*(_DWORD *)(result + this + 624124) & 0x200) != 0
    || *(_DWORD *)(this + 92) == 8 && (result = *(_DWORD *)(this + 12), !*(_DWORD *)(result + 12424)) )
  {
    v4 = *(_BYTE *)(this + 96) ^ (*(_BYTE *)(this + 96) ^ ~*(_BYTE *)(this + 96)) & 4;
    v5 = *(_DWORD *)(this + 12);
    *(_BYTE *)(this + 96) = v4;
    v6 = *(_DWORD *)(v5 + 120076);
    if ( (v4 & 4) != 0 )
      result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(v6 + 212) + 20))(
                 *(_DWORD *)(v6 + 212),
                 0,
                 0,
                 0,
                 0);
    else
      result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(v6 + 236) + 20))(
                 *(_DWORD *)(v6 + 236),
                 0,
                 0,
                 0,
                 0);
  }
  return result;
}
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);

//----- (00427BD0) --------------------------------------------------------
int __thiscall sub_427BD0(int this, char *a2, int a3, int a4)
{
  int v5; // esi
  int result; // eax
  const char *v7; // edx
  char Buffer[64]; // [esp+Ch] [ebp-44h] BYREF
  int v9; // [esp+4Ch] [ebp-4h]

  v9 = 9124995;
  v5 = 580 * a3;
  sprintf_0(
    Buffer,
    "%-12.12s %s",
    (const char *)(580 * a3 + *(_DWORD *)(this + 104) + 564),
    (const char *)(580 * a3 + *(_DWORD *)(this + 104) + 1));
  if ( a3 == *(_DWORD *)(this + 8) )
  {
    if ( *(_BYTE *)(this + 377) )
    {
      v7 = (const char *)(this + 120);
      if ( strlen((const char *)(this + 120)) > 0xC )
        v7 = strchr(v7, 0) - 12;
      sprintf_0(a2, (const char *const)(9125709 - ((_DWORD)&loc_407237 + 2)), Buffer, v7);
      result = 3;
    }
    else
    {
      sprintf_0(a2, ">%-48.48s%12.12s<", Buffer, (const char *)(*(_DWORD *)(this + 104) + v5 + 52));
      result = 6;
    }
  }
  else
  {
    sprintf_0(a2, (const char *const)(9125161 - (_DWORD)&loc_407005), Buffer, *(_DWORD *)(this + 104) + v5 + 52);
    result = 0;
  }
  return result;
}

//----- (00427CF0) --------------------------------------------------------
int __thiscall sub_427CF0(int (__thiscall ***this)(void *, _DWORD), unsigned int a2)
{
  __time32_t v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // eax
  unsigned int v9; // esi
  char *v10; // ecx
  int v11; // edx
  char *v12; // edi
  int v13; // edi
  int v14; // edi
  int v16; // [esp+0h] [ebp-1048h] BYREF
  int v17; // [esp+Ch] [ebp-103Ch] BYREF
  char v18; // [esp+10h] [ebp-1038h] BYREF
  char v19; // [esp+14h] [ebp-1034h] BYREF
  char v20[80]; // [esp+FACh] [ebp-9Ch] BYREF
  _DWORD v21[8]; // [esp+FFCh] [ebp-4Ch] BYREF
  int v22; // [esp+101Ch] [ebp-2Ch] BYREF
  int v23; // [esp+1020h] [ebp-28h] BYREF
  unsigned int v24; // [esp+1024h] [ebp-24h] BYREF
  int v25; // [esp+1028h] [ebp-20h] BYREF
  int v26; // [esp+102Ch] [ebp-1Ch] BYREF
  void *v27; // [esp+1030h] [ebp-18h] BYREF
  int v28[2]; // [esp+1034h] [ebp-14h] BYREF
  int v29; // [esp+1044h] [ebp-4h]
  int savedregs; // [esp+1048h] [ebp+0h] BYREF

  v28[1] = (int)&v16;
  v27 = this;
  dword_4A70CC(&v25);
  dword_4A710C(v21);
  dword_4A7314(&v23);
  v3 = time_0(0);
  v4 = dword_4A70F4() ^ v3;
  v5 = dword_4A70B0() ^ v4;
  v6 = dword_4A7310() ^ v5;
  v7 = dword_4A7098() ^ v6;
  v29 = 1;
  v8 = v26;
  v26 = -1;
  v9 = v25 ^ v8 ^ v21[3] ^ v21[5] ^ v21[7] ^ ((v23 ^ (2 * v24)) << 16) ^ v7;
  v24 = v9;
  sub_407E80(&v26, (int)&savedregs, aScrty, 1, 3);
  ReadScrty1FileOffset(&v26, (int)&v17, 4000);
  sub_4087F0(&v26);
  LOBYTE(v29) = 0;
  sub_4087F0(&v26);
  v29 = -1;
  if ( (_BYTE)a2 )
  {
    v17 = 0;
    v10 = &v19;
    v11 = 499;
    do
    {
      v10 += 8;
      v9 = 69069 * v9 + 17009;
      *((_DWORD *)v10 - 2) = v9 >> 1;
      --v11;
    }
    while ( v11 );
  }
  v12 = &v18;
  a2 = 500;
  do
  {
    *(_DWORD *)v12 = (**this)(this, *((_DWORD *)v12 - 1));
    v12 += 8;
    --a2;
  }
  while ( a2 );
  v28[0] = -1;
  v29 = 3;
  sub_4080D0(v28, (int)&savedregs, aScrty, 0, 2);
  sub_4086E0(v28, (int)&v17, 4000);
  sub_4087F0(v28);
  sub_4080D0(v28, (int)&savedregs, aScrty1, 0, 2);
  v22 = 40;
  sub_4086E0(v28, (int)&v22, 4);
  v13 = 1024;
  do
  {
    v9 = 69069 * v9 + 17009;
    a2 = v9;
    sub_457D50(&v24, (int)v20);
    sub_457D60((void **)&v24, -1, a2);
    sub_4086E0(v28, (int)&a2, 4);
    sub_4086E0(v28, (int)v20, 80);
    --v13;
  }
  while ( v13 );
  v14 = 1024;
  do
  {
    v9 = 69069 * v9 + 17009;
    a2 = v9;
    sub_457D50(&v27, (int)v20);
    sub_457D60(&v27, -1, a2);
    sub_458BE0(&v27, a2);
    sub_4086E0(v28, (int)&a2, 4);
    sub_4086E0(v28, (int)v20, 80);
    --v14;
  }
  while ( v14 );
  v29 = -1;
  return sub_4087F0(v28);
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7310: using guessed type int (*dword_4A7310)(void);
// 4A7314: using guessed type int (__cdecl *dword_4A7314)(_DWORD);

//----- (00427FA0) --------------------------------------------------------
int __thiscall sub_427FA0(_DWORD *this)
{
  int v1; // edx
  int v2; // eax
  int v3; // edx
  int result; // eax

  if ( this[23] == 8 || (int)this[192] > 0 )
    goto LABEL_9;
  v1 = this[115];
  if ( *(_DWORD *)(this[116] + v1) )
  {
    v2 = this[113] + this[114];
    v3 = *(_DWORD *)(this[112] + v1);
    if ( v2 > v3 )
      v2 = v3;
  }
  else
  {
    v2 = *(_DWORD *)(this[111] + v1);
  }
  if ( this[130] + this[131] >= 1000 * v2 / 2 )
LABEL_9:
    result = 1;
  else
    result = 0;
  return result;
}

//----- (00428020) --------------------------------------------------------
int __thiscall sub_428020(_DWORD *this)
{
  int result; // eax
  _DWORD *v3; // ebx
  int v4; // edi
  __int64 v5; // rax
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // esi
  int v10; // eax
  bool v11; // cc
  _DWORD *v12; // [esp+8h] [ebp-8h]
  int v13; // [esp+Ch] [ebp-4h]

  memset(this + 5778, 0, 0x1000u);
  v13 = 0;
  result = this[1569];
  if ( result > 0 )
  {
    v12 = this + 545;
    do
    {
      v3 = (_DWORD *)*v12;
      if ( *(_DWORD *)(*v12 + 92) != 8 && !v3[19] && (int)v3[16] <= 0 )
      {
        v4 = v3[20];
        v5 = v3[1] / 1000 - v4;
        v6 = ((BYTE4(v5) & 0xF) + (int)v5) >> 4;
        v7 = (v4 + v3[1] / 1000) / 16 + 1;
        if ( v6 < 0 )
          v6 = 0;
        if ( v7 >= 1024 )
          v7 = 1024;
        if ( v6 < v7 )
        {
          v8 = &this[v6 + 5778];
          v9 = 20 * v6;
          v10 = v7 - v6;
          do
          {
            if ( *v8 < 0x14u )
              this[v9 + 7064 + (*v8)++] = v3;
            ++v8;
            v9 += 20;
            --v10;
          }
          while ( v10 );
        }
      }
      result = v13 + 1;
      v11 = ++v13 < this[1569];
      ++v12;
    }
    while ( v11 );
  }
  return result;
}

//----- (00428690) --------------------------------------------------------
int __thiscall sub_428690(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int *v6; // eax
  int v7; // edx
  int v8; // edi
  _DWORD *v9; // ebx
  int result; // eax
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  _DWORD *v14; // ebx
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // eax
  char *v20; // ebx
  int v21; // ecx
  char v22; // [esp+17h] [ebp+Bh]

  v3 = this[2763];
  if ( v3 > 0 && this[356] > v3 && *(_DWORD *)(this[542] + 48) + *(_DWORD *)(this[542] + 52) > 0 )
  {
    v4 = -1465587685;
    v5 = 242;
    do
      v4 ^= *(_DWORD *)&aTickname[4 * v5-- - 381592];
    while ( v5 );
    (*(void (__thiscall **)(int, int))(*(_DWORD *)((char *)this + v4 + 134763816) + 380))(
      (int)this + v4 + 134763816,
      21);
    v6 = (int *)(this[542] + 48);
    v7 = -dword_4C1AE4;
    v6[1] = dword_4C1AE4;
    *v6 = v7;
  }
  v8 = 0;
  if ( (int)this[1875] > 0 )
  {
    v9 = this + 1571;
    do
    {
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v9 + 4))(*v9, a2);
      ++v8;
      ++v9;
    }
    while ( v8 < this[1875] );
  }
  result = this[3014];
  if ( result )
  {
    result = this[2721];
    if ( result )
    {
      v11 = this[1875];
      v12 = -1;
      v13 = 0;
      v22 = 1;
      if ( v11 > 0 )
      {
        v14 = this + 1571;
        while ( 1 )
        {
          if ( !v22 )
            goto LABEL_21;
          v15 = *(_DWORD *)(*v14 + 20);
          if ( v15 < 0 )
            break;
          if ( v12 == -1 )
          {
            v12 = *(_DWORD *)(*v14 + 20);
          }
          else if ( v12 != v15 )
          {
            break;
          }
LABEL_20:
          ++v13;
          ++v14;
          if ( v13 >= v11 )
            goto LABEL_21;
        }
        v22 = 0;
        goto LABEL_20;
      }
LABEL_21:
      if ( (int)this[1569] > 0 )
      {
        v16 = this + 545;
        v17 = this[1569];
        do
        {
          v18 = *v16;
          if ( *(_DWORD *)(*v16 + 48) + *(_DWORD *)(*v16 + 52) )
          {
            if ( v12 == -1 )
            {
              v12 = *(_DWORD *)(v18 + 88);
            }
            else if ( v12 != *(_DWORD *)(v18 + 88) )
            {
              v22 = 0;
            }
          }
          ++v16;
          --v17;
        }
        while ( v17 );
      }
      result = this[2983];
      if ( result )
      {
        if ( v22 && v12 >= 0 )
        {
          result = this[30141];
          if ( result <= 0 )
          {
            v19 = 0;
            v20 = byte_40FC98;
            do
            {
              v19 -= *(_DWORD *)v20;
              v20 += 4;
            }
            while ( v20 < (char *)sub_40FD30 );
            v21 = *(_DWORD *)(*(_DWORD *)((char *)this + v19 - 1726295695) + 312);
            result = (*(int (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v21 + 20))(v21, 0, 0, 1, 0);
            this[30141] = 12000;
          }
        }
        else
        {
          result = this[30141];
          if ( result > 0 )
          {
            result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this[30019] + 312) + 28))(*(_DWORD *)(this[30019] + 312));
            this[30141] = 0;
          }
        }
      }
    }
  }
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00428860) --------------------------------------------------------
int __thiscall sub_428860(_DWORD *this)
{
  int result; // eax

  if ( this )
    result = (*(int (__thiscall **)(_DWORD *, int))(this[1] + 80))(this + 1, 1);
  return result;
}

//----- (00428910) --------------------------------------------------------
int __thiscall sub_428910(char *this, void *src, char *Str, char a4)
{
  int v5; // ecx
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  int v10; // ecx
  __int16 v11; // ax
  int v12; // edx
  int *v13; // eax
  int v14; // ecx
  char v15; // dl
  _DWORD *v16; // eax
  __time32_t v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // esi
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // ecx
  char v26[80]; // [esp+Ch] [ebp-1B8h] BYREF
  char v27[32]; // [esp+5Ch] [ebp-168h] BYREF
  char v28[60]; // [esp+7Ch] [ebp-148h] BYREF
  char v29[32]; // [esp+B8h] [ebp-10Ch] BYREF
  char v30[12]; // [esp+D8h] [ebp-ECh] BYREF
  int v31; // [esp+E4h] [ebp-E0h]
  int v32; // [esp+ECh] [ebp-D8h]
  int v33; // [esp+F4h] [ebp-D0h]
  char v34[2]; // [esp+F8h] [ebp-CCh] BYREF
  char dst[32]; // [esp+FAh] [ebp-CAh] BYREF
  char v36[8]; // [esp+11Ah] [ebp-AAh] BYREF
  char v37[8]; // [esp+122h] [ebp-A2h] BYREF
  char v38[4]; // [esp+12Ah] [ebp-9Ah] BYREF
  char v39[12]; // [esp+12Eh] [ebp-96h] BYREF
  int v40; // [esp+13Ah] [ebp-8Ah]
  char v41; // [esp+13Eh] [ebp-86h]
  __int16 v42; // [esp+13Fh] [ebp-85h]
  __int16 v43; // [esp+143h] [ebp-81h]
  int v44; // [esp+145h] [ebp-7Fh]
  int v45; // [esp+149h] [ebp-7Bh]
  int v46; // [esp+151h] [ebp-73h]
  __int16 v47; // [esp+155h] [ebp-6Fh]
  int v48; // [esp+157h] [ebp-6Dh]
  char v49; // [esp+15Bh] [ebp-69h]
  int v50; // [esp+15Dh] [ebp-67h] BYREF
  int v51[15]; // [esp+161h] [ebp-63h] BYREF
  _DWORD v52[2]; // [esp+1A0h] [ebp-24h] BYREF
  char *v53; // [esp+1A8h] [ebp-1Ch]
  _DWORD v54[2]; // [esp+1ACh] [ebp-18h] BYREF
  int v55; // [esp+1B4h] [ebp-10h] BYREF
  int v56; // [esp+1B8h] [ebp-Ch]
  int v57; // [esp+1BCh] [ebp-8h] BYREF
  void *v58; // [esp+1C0h] [ebp-4h] BYREF
  char *Stra; // [esp+1D0h] [ebp+Ch]

  v53 = this;
  memset(v34, 0, 0xA4u);
  v5 = *((_DWORD *)this + 30127);
  HIBYTE(v51[14]) = 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 56))(v5);
  v34[1] = a4;
  v34[0] = 36;
  strncpyt(dst, src, 32);
  v6 = *((_DWORD *)this + 349);
  if ( v6 == 1 )
  {
    v7 = strchr(Str, 42);
    if ( v7 )
      strncpyt(v36, v7, 32);
  }
  else if ( v6 == 3 )
  {
    strncpyt(v36, Str, 32);
    if ( a4 )
      goto LABEL_13;
    Stra = (char *)*((_DWORD *)this + 350);
    strcpy(v27, v36);
    strcpy(v30, v36);
    v8 = strrchr(v30, 42);
    if ( v8 )
    {
      if ( strlen(v8) > 0xB )
        goto LABEL_13;
      strcpy(v29, v8);
      *v8 = 0;
    }
    else
    {
      v29[0] = 0;
    }
    sub_43C7E0((int)v36, v27, (int)Stra);
    sub_43C7E0((int)v37, v30, (int)Stra);
    sub_43C7E0((int)v38, v30, 0);
    strcpy(v39, v29);
  }
  else if ( !this[117756] )
  {
    strncpyt(v36, Str, 32);
  }
LABEL_13:
  v48 = *(_DWORD *)(this + 120557);
  v9 = (*(int (__thiscall **)(_DWORD))(**((_DWORD **)this + 30127) + 12))(*((_DWORD *)this + 30127));
  v10 = *((_DWORD *)this + 30127);
  v40 = v9;
  v41 = 4;
  v11 = (*(int (__thiscall **)(int))(*(_DWORD *)v10 + 24))(v10);
  v12 = *(_DWORD *)this;
  v42 = v11;
  v43 = 40;
  v44 = 444;
  if ( (*(unsigned __int8 (__thiscall **)(char *, int *))(v12 + 32))(this, &v55) )
  {
    v47 = v56;
    v45 = v55;
  }
  v13 = (int *)(*(int (__thiscall **)(char *, _DWORD *))(*(_DWORD *)this + 36))(this, v54);
  v55 = *v13;
  v14 = v13[1];
  v15 = this[1395];
  v46 = v55;
  v16 = (_DWORD *)*((_DWORD *)this + 30127);
  v56 = v14;
  v49 = v15;
  v51[1] = v16[2];
  v51[2] = v16[3];
  v51[3] = v16[4];
  v51[4] = v16[5];
  v51[5] = v16[1];
  v51[6] = v16[13];
  v51[7] = v16[6];
  v51[8] = v16[11];
  v51[9] = v16[7];
  v51[10] = v16[10];
  v51[11] = v16[12];
  v51[12] = v16[8];
  v51[13] = v16[14];
  v51[14] = v16[9];
  dword_4A70CC(v54);
  dword_4A710C(v30);
  dword_4A7314(v52);
  v17 = time_0(0);
  v18 = dword_4A70F4() ^ v17;
  v19 = dword_4A70B0() ^ v18;
  v20 = dword_4A7310() ^ v19;
  v21 = dword_4A7098();
  v57 = -1;
  v50 = v54[0] ^ v54[1] ^ v31 ^ v32 ^ v33 ^ ((v52[0] ^ (2 * v52[1])) << 16) ^ v21 ^ v20;
  sub_401A70(&v57, (unsigned __int8 *)&v50, 64);
  v22 = v50;
  v51[0] = v50 ^ v57;
  sub_457D50(&v58, (int)v26);
  sub_457D60(&v58, v22, v50);
  ContinuumEncrypt((unsigned int *)&v58, v28, v51, 0x3Cu);
  qmemcpy(v51, v28, sizeof(v51));
  v23 = -1407602749;
  v24 = 38;
  do
    v23 ^= *(_DWORD *)&a02x[4 * v24-- - 627552];
  while ( v24 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&v53[v23 + 158410824] + 16))(
           &v53[v23 + 158410824],
           v34,
           165,
           1);
}
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7310: using guessed type int (*dword_4A7310)(void);
// 4A7314: using guessed type int (__cdecl *dword_4A7314)(_DWORD);

//----- (00428CF0) --------------------------------------------------------
int __stdcall sub_428CF0(int a1)
{
  unsigned int v1; // esi
  unsigned int v2; // ebx
  unsigned int v3; // edi
  unsigned __int8 *v4; // eax
  int *v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned int i; // ecx
  int v9; // ebx
  int v11[61]; // [esp+Ch] [ebp-1400h] BYREF
  char v12; // [esp+103h] [ebp-1309h]
  char v13; // [esp+104h] [ebp-1308h]
  char v14; // [esp+105h] [ebp-1307h]
  char v15[128]; // [esp+100Ch] [ebp-400h] BYREF
  char v16[260]; // [esp+108Ch] [ebp-380h] BYREF
  int v17[32]; // [esp+1190h] [ebp-27Ch] BYREF
  char v18[128]; // [esp+1210h] [ebp-1FCh] BYREF
  char v19[128]; // [esp+1290h] [ebp-17Ch] BYREF
  char v20[124]; // [esp+1310h] [ebp-FCh] BYREF
  __int16 v21; // [esp+138Ch] [ebp-80h]
  char v22; // [esp+138Eh] [ebp-7Eh]
  int v23[21]; // [esp+1390h] [ebp-7Ch] BYREF
  int v24[4]; // [esp+13E4h] [ebp-28h] BYREF
  int v25; // [esp+13F4h] [ebp-18h]
  _DWORD pExceptionObject[2]; // [esp+13F8h] [ebp-14h] BYREF
  int v27; // [esp+1408h] [ebp-4h]
  int savedregs; // [esp+140Ch] [ebp+0h] BYREF

  v1 = 0;
  v16[0] = 0;
  if ( a1 )
    sub_4079D0(v16, a1);
  else
    dword_4A7100(0, v16, 260);
  a1 = -1;
  v27 = 0;
  sub_407E80(&a1, (int)&savedregs, v16, 3, 3);
  v2 = sub_408270(&a1) - 128;
  sub_40ADE0(v23);
  LOBYTE(v27) = 1;
  if ( v2 )
  {
    do
    {
      v3 = 4096;
      if ( v2 - v1 < 0x1000 )
        v3 = v2 - v1;
      ReadScrty1FileOffset(&a1, (int)v11, v3);
      if ( !v1 && v13 == 80 && v14 == 69 && v12 )
      {
        v25 = 9162287;
        sub_406F10(pExceptionObject, (int)&savedregs, aContinuumHasBe);
        _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
      }
      sub_40AE50(v23, v11, v3);
      v1 += v3;
    }
    while ( v1 < v2 );
  }
  ReadScrty1FileOffset(&a1, (int)v11, 128);
  sub_40AF00(v23, v24);
  memset(v20, 0, sizeof(v20));
  v21 = 0;
  v22 = 0;
  sub_46CAB0((unsigned int)v20, v24, 0x10u);
  sub_46CAB0((unsigned int)v19, v11, 0x80u);
  v4 = (unsigned __int8 *)&unk_4AAE94;
  v5 = v17;
  v6 = 32;
  do
  {
    v7 = 0;
    for ( i = 0; i < 0x20; i += 8 )
    {
      v9 = *v4 << i;
      v7 |= v9;
      ++v4;
    }
    *v5++ = v7;
    --v6;
  }
  while ( v6 );
  qmemcpy(v18, v17, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  v17[0] = 3;
  sub_4556D0((int)v18, v19, (int)v15, 0, v17);
  if ( memcmp(v15, v20, 0x7Fu) )
  {
    v25 = 9168275;
    sub_406F10(pExceptionObject, (int)&savedregs, (const char *)(9168275 - (_DWORD)&loc_411783));
    _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
  }
  LOBYTE(v27) = 0;
  sub_40AE10(v23);
  v27 = -1;
  return sub_4087F0(&a1);
}
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);

//----- (00428F60) --------------------------------------------------------
int __thiscall sub_428F60(_DWORD *this, int a2)
{
  if ( this[25] != 4 )
    return 1;
  if ( a2
    && *(_DWORD *)(*(_DWORD *)(this[29] + 4 * a2 + 2180) + 88) == *(_DWORD *)(*(_DWORD *)(this[29] + 4 * a2 + 2176) + 88) )
  {
    return 1;
  }
  return 2;
}

//----- (00428FA0) --------------------------------------------------------
int *__thiscall sub_428FA0(_DWORD *this, int a2, int a3)
{
  int *result; // eax
  int v5; // edi
  int v6; // eax
  int v7; // [esp-Ch] [ebp-10h]
  int v8; // [esp-8h] [ebp-Ch]

  result = (int *)this[542];
  if ( result )
  {
    v5 = *result;
    v8 = *(_WORD *)(a2 + 3) & 0x3FF;
    v7 = *(_WORD *)(a2 + 1) & 0x3FF;
    v6 = rand();
    result = (int *)(*(int (__thiscall **)(_DWORD, int, int, int))(v5 + 152))(this[542], v6, v7, v8);
  }
  return result;
}

//----- (00429000) --------------------------------------------------------
char __thiscall sub_429000(int this, int *a2)
{
  int v3; // edi
  unsigned int v4; // eax
  int v5; // ebx
  __int16 v6; // cx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  __int16 v10; // cx
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  unsigned __int8 v15; // [esp+10h] [ebp-8h]
  _BYTE *v16; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(this + 4) / 1000;
  v4 = *(_DWORD *)(this + 156);
  v5 = *(_DWORD *)(this + 8) / 1000;
  if ( (int)v4 <= 0 )
  {
    LOWORD(v4) = *(_WORD *)(this + 167);
    v10 = v4 & 0x1F;
    if ( (*(_WORD *)(this + 167) & 0x1F) == 3 || v10 == 4 )
    {
      if ( *(_DWORD *)(this + 16) || *(_DWORD *)(this + 20) )
      {
        if ( *(_BYTE *)(this + 128) )
          v13 = 1;
        else
          v13 = *(_DWORD *)(this + 140) <= 0 ? 0 : 2;
        LOBYTE(v8) = (*(int (__thiscall **)(int *, int, int, _DWORD, unsigned int, int, int))(*a2 + 180))(
                       a2,
                       v3,
                       v5,
                       *(_DWORD *)(this + 192),
                       (v4 >> 5) & 3,
                       v13,
                       1);
      }
      else
      {
        LOBYTE(v8) = (*(int (__thiscall **)(int *, int, int, _DWORD, unsigned int, _DWORD, _DWORD))(*a2 + 180))(
                       a2,
                       v3,
                       v5,
                       *(_DWORD *)(this + 192),
                       (v4 >> 5) & 3,
                       *(unsigned __int8 *)(this + 128),
                       0);
      }
    }
    else if ( v10 == 8 )
    {
      LOBYTE(v8) = (*(int (__thiscall **)(int *, int, int, _DWORD, _DWORD, int, int))(*a2 + 180))(
                     a2,
                     v3,
                     v5,
                     *(_DWORD *)(this + 192),
                     0,
                     3,
                     1);
    }
    else if ( v10 == 6 )
    {
      v8 = *(_DWORD *)(*(_DWORD *)(this + 12) + 4 * *(_DWORD *)(this + 152) + 113620);
      v16 = (_BYTE *)v8;
      if ( v8 )
      {
        v11 = *(_DWORD *)(v8 + 92);
        if ( v11 != 8 )
        {
          (*(void (__thiscall **)(int *, int, int, int, int, _DWORD))(*a2 + 168))(
            a2,
            v3,
            v5,
            (2 * *(_DWORD *)(this + 188) + 40 - *(_DWORD *)(v8 + 60) / 1000) % 40,
            v11,
            0);
          v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 23100) + 8280);
          if ( v8 )
          {
            LOBYTE(v8) = v16[156];
            if ( !(_BYTE)v8 )
              LOBYTE(v8) = (*(int (__thiscall **)(_BYTE *, int *, int, int, _DWORD, int, _DWORD))(*(_DWORD *)v16 + 72))(
                             v16,
                             a2,
                             v3,
                             v5,
                             0,
                             1,
                             *(_DWORD *)(this + 124));
          }
        }
      }
    }
    else
    {
      if ( v10 == 1 || (v15 = 1, *(_BYTE *)(this + 166)) )
        v15 = 0;
      if ( *(_BYTE *)(this + 165) )
      {
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, _DWORD, unsigned int, _DWORD, int))(*a2 + 180))(
                       v3,
                       v5,
                       *(_DWORD *)(this + 192),
                       (v4 >> 5) & 3,
                       v15,
                       2);
      }
      else
      {
        if ( *(_BYTE *)(this + 164) )
          v12 = 4;
        else
          v12 = (v4 >> 5) & 3;
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, _DWORD, int, _DWORD, int))(*a2 + 180))(
                       v3,
                       v5,
                       *(_DWORD *)(this + 192),
                       v12,
                       v15,
                       3);
      }
    }
  }
  else
  {
    v6 = *(_WORD *)(this + 167) & 0x1F;
    if ( v6 == 3 || v6 == 4 || v6 == 8 )
    {
      v9 = *a2;
      if ( *(_BYTE *)(this + 128) )
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, unsigned int, int))(v9 + 176))(v3, v5, v4, 1);
      else
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, unsigned int, _DWORD))(v9 + 176))(v3, v5, v4, 0);
    }
    else
    {
      v7 = *a2;
      if ( v6 == 5 )
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, unsigned int, int))(v7 + 176))(v3, v5, v4, 2);
      else
        LOBYTE(v8) = (*(int (__stdcall **)(int, int, unsigned int, int))(v7 + 176))(v3, v5, v4, 3);
    }
  }
  return v8;
}

//----- (004292F0) --------------------------------------------------------
int __thiscall sub_4292F0(_DWORD *this)
{
  int v1; // esi
  int result; // eax

  v1 = this[233];
  if ( v1 )
    result = 1000 * this[193] / v1;
  else
    result = 0;
  return result;
}

//----- (00429340) --------------------------------------------------------
int __thiscall sub_429340(char *this, _BYTE *a2)
{
  int v3; // eax
  int v4; // ecx
  char v6; // [esp+8h] [ebp-64h] BYREF
  char v7[99]; // [esp+9h] [ebp-63h] BYREF

  v6 = 25;
  sub_46CAB0((unsigned int)v7, a2, 0x60u);
  v3 = 662110019;
  v4 = 227;
  do
    v3 ^= *(_DWORD *)&aSpddetGGGDDDD[4 * v4-- - 567068];
  while ( v4 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v3 + 182299128] + 16))(
           &this[v3 + 182299128],
           &v6,
           97,
           1);
}

//----- (004293A0) --------------------------------------------------------
int __thiscall sub_4293A0(int this, _DWORD *a2)
{
  int v4; // eax
  int (__stdcall *v5)(int); // ebx
  int result; // eax
  int v7; // ebx
  int v8; // kr04_4
  void *v9; // edx
  void *v10; // edx
  void *v11; // edx
  void *v12; // ecx
  char Buffer[64]; // [esp+Ch] [ebp-48h] BYREF
  int v14; // [esp+4Ch] [ebp-8h]
  int v15; // [esp+50h] [ebp-4h]
  int v16; // [esp+5Ch] [ebp+8h]

  a2[18820] = a2[2] / 2;
  v4 = 0;
  v5 = sub_44F4D4;
  do
  {
    v4 -= *(_DWORD *)v5;
    v5 = (int (__stdcall *)(int))((char *)v5 + 4);
  }
  while ( (char *)v5 < (char *)((char *)&loc_44F774 + 4) );
  result = *(_DWORD *)(v4 + 264257467 + this + 601536);
  if ( *(_DWORD *)(result + 23104) - *(_DWORD *)(this + 392) >= 500 )
  {
    a2[18821] = 0;
  }
  else
  {
    v7 = a2[18807];
    v8 = a2[2];
    v15 = 9181472;
    v16 = v8 / 2;
    sprintf_0(
      Buffer,
      (const char *const)(9181472 - (_DWORD)&loc_414998),
      *(unsigned __int16 *)(this + 344),
      10 * *(unsigned __int16 *)(this + 346));
    (*(void (__thiscall **)(_DWORD *, int, _DWORD, char *, _DWORD, int, int))(*a2 + 236))(
      a2,
      v8 / 2,
      0,
      Buffer,
      0,
      -1,
      1);
    v15 = 9181928;
    sprintf_0(
      Buffer,
      aBrstDReplDPrtl,
      (*(_DWORD *)(this + 350) >> 2) & 0xF,
      (*(_DWORD *)(this + 350) >> 6) & 0xF,
      (*(_DWORD *)(this + 350) >> 26) & 0xF);
    (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a2 + 236))(a2, v8 / 2, v7, Buffer, 0, -1, 1);
    if ( (*(_BYTE *)(this + 96) & 2) != 0 )
    {
      v15 = 9182728;
      v9 = (void *)(9182728 - ((_DWORD)&loc_414EA2 + 2));
    }
    else
    {
      v9 = &unk_4A7DB0;
    }
    if ( (*(_BYTE *)(this + 96) & 1) != 0 )
      v15 = 4902744;
    else
      v15 = (int)&unk_4A7DB0;
    v14 = 9182369;
    sprintf_0(
      Buffer,
      (const char *const)(9182369 - (_DWORD)&loc_414D61),
      (*(_DWORD *)(this + 350) >> 18) & 0xF,
      (*(_DWORD *)(this + 350) >> 10) & 0xF,
      v15,
      v9,
      &unk_4A7DB0);
    (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a2 + 236))(
      a2,
      v16,
      2 * v7,
      Buffer,
      0,
      -1,
      1);
    if ( (*(_BYTE *)(this + 96) & 8) != 0 )
    {
      v14 = 9183819;
      v10 = (void *)(9183819 - (_DWORD)&loc_415317);
    }
    else
    {
      v10 = &unk_4A7DB0;
    }
    if ( (*(_BYTE *)(this + 96) & 4) != 0 )
    {
      v14 = 9183644;
      v15 = 4902696;
    }
    else
    {
      v15 = (int)&unk_4A7DB0;
    }
    v14 = 9183457;
    sprintf_0(
      Buffer,
      (const char *const)(9183457 - (_DWORD)&loc_4151D1),
      (*(_DWORD *)(this + 350) >> 14) & 0xF,
      (*(_DWORD *)(this + 350) >> 22) & 0xF,
      v15,
      v10,
      &unk_4A7DB0);
    (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a2 + 236))(
      a2,
      v16,
      3 * v7,
      Buffer,
      0,
      -1,
      1);
    if ( (*(_BYTE *)(this + 350) & 1) != 0 )
    {
      v14 = 9184593;
      v11 = (void *)(9184593 - (_DWORD)&loc_415649);
    }
    else
    {
      v11 = &unk_4A7DB0;
    }
    if ( (*(_BYTE *)(this + 350) & 2) != 0 )
    {
      v14 = 9184585;
      v12 = (void *)(9184585 - (_DWORD)&loc_415649);
    }
    else
    {
      v12 = &unk_4A7DB0;
    }
    v14 = 9184577;
    sprintf_0(Buffer, (const char *const)(9184577 - (_DWORD)&loc_415649), v12, v11);
    (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a2 + 236))(
      a2,
      v16,
      4 * v7,
      Buffer,
      0,
      -1,
      1);
    result = 5 * v7;
    a2[18821] = 5 * v7;
    if ( *(_WORD *)(this + 348) )
    {
      v14 = 9185551;
      sprintf_0(Buffer, (const char *const)(9185551 - ((_DWORD)&loc_415A1F + 4)), *(unsigned __int16 *)(this + 348));
      result = (*(int (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a2 + 236))(
                 a2,
                 v16,
                 5 * v7,
                 Buffer,
                 0,
                 -1,
                 1);
      a2[18821] = 6 * v7;
    }
  }
  return result;
}
// 44F4D4: using guessed type int __stdcall sub_44F4D4(int);

//----- (004296E0) --------------------------------------------------------
bool __thiscall sub_4296E0(int this)
{
  __int16 v2; // ax
  _DWORD *v3; // ecx
  int v4; // edi
  unsigned int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // edi
  int v9; // edx
  int v10; // eax
  _DWORD *v11; // ebx
  unsigned int v12; // edx
  int v13; // edi
  unsigned int v14; // ecx
  int v15; // ecx
  int v16; // edi
  int v17; // edx
  int v18; // eax
  bool result; // al
  int v21; // edi
  int v22; // ebx
  int v23; // edi
  _DWORD *v24; // ecx
  int v25; // edi
  int v26; // ebx
  int v27; // edi
  _DWORD *v28; // edi
  unsigned int v29; // eax
  int v30; // eax
  int v31; // edx
  _DWORD *v32; // ecx
  int v33; // ebx
  int v34; // eax
  __int16 v35; // ax
  int v36; // eax
  int v37; // ecx
  int v38; // [esp+Ch] [ebp-10h]
  int v39; // [esp+10h] [ebp-Ch]
  int v40; // [esp+18h] [ebp-4h]

  v2 = *(_WORD *)(this + 167) & 0x1F;
  if ( (v2 == 2 || v2 == 6 || *(int *)(this + 140) > 0) && *(int *)(this + 144) <= 0 )
  {
    v39 = *(_DWORD *)(this + 8);
    v3 = *(_DWORD **)(this + 12);
    v4 = *(_DWORD *)(this + 16) + *(_DWORD *)(this + 4);
    v38 = *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = v4;
    v5 = v4;
    v6 = v3[30132];
    if ( !v6 )
      goto LABEL_22;
    if ( v5 >= 0xFA0000 || *(_DWORD *)(this + 8) >= 0xFA0000u )
    {
      v8 = 20;
    }
    else
    {
      v7 = *(_DWORD *)(this + 4) / 16000;
      v40 = *(_DWORD *)(this + 8) / 16000;
      v8 = *(unsigned __int8 *)(v6 + (v40 << 10) + v7);
      if ( (v8 == 253 || v8 == 252)
        && (*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v3 + 464))(
             v3,
             v7,
             v40,
             *(_DWORD *)(this + 184))
        || v8 >= 172 && v8 < 191
        || v8 == 254
        || v8 == 255
        || v8 == 171
        || v8 == 170 )
      {
        v8 = 0;
      }
      if ( !v8 )
      {
LABEL_20:
        if ( v8 == 220 || v8 == 241 )
          return 1;
LABEL_22:
        v11 = *(_DWORD **)(this + 12);
        v12 = *(_DWORD *)(this + 20) + *(_DWORD *)(this + 8);
        *(_DWORD *)(this + 8) = v12;
        v13 = v11[30132];
        if ( v13 )
        {
          v14 = *(_DWORD *)(this + 4);
          if ( v14 >= 0xFA0000 || v12 >= 0xFA0000 )
          {
            v16 = 20;
          }
          else
          {
            v15 = (int)v14 / 16000;
            v16 = *(unsigned __int8 *)(v13 + ((*(_DWORD *)(this + 8) / 16000) << 10) + v15);
            if ( (v16 == 253 || v16 == 252)
              && (*(unsigned __int8 (__thiscall **)(_DWORD, int, int, _DWORD))(*v11 + 464))(
                   *(_DWORD *)(this + 12),
                   v15,
                   *(_DWORD *)(this + 8) / 16000,
                   *(_DWORD *)(this + 184))
              || v16 >= 172 && v16 < 191
              || v16 == 254
              || v16 == 255
              || v16 == 171
              || v16 == 170 )
            {
              v16 = 0;
            }
            if ( !v16 )
              goto LABEL_39;
          }
          v17 = *(_DWORD *)(this + 20);
          v18 = *(_DWORD *)(this + 140);
          *(_BYTE *)(this + 166) = 0;
          *(_DWORD *)(this + 8) = v39;
          *(_DWORD *)(this + 20) = -v17;
          *(_DWORD *)(this + 140) = v18 - 1;
LABEL_39:
          if ( v16 == 220 )
            return 1;
          return v16 == 241;
        }
        return 0;
      }
    }
    v9 = *(_DWORD *)(this + 16);
    v10 = *(_DWORD *)(this + 140);
    *(_BYTE *)(this + 166) = 0;
    *(_DWORD *)(this + 4) = v38;
    *(_DWORD *)(this + 16) = -v9;
    *(_DWORD *)(this + 140) = v10 - 1;
    goto LABEL_20;
  }
  if ( v2 == 8 )
  {
    if ( (byte_4C1AB4 & 1) == 0 )
    {
      dword_4C1AB8 = -1024000;
      dword_4C1ABC = -1024000;
      byte_4C1AB4 |= 1u;
      dword_4C1AC0 = 17408000;
      dword_4C1AC4 = 17408000;
      sub_46E3C5(nullsub_7);
    }
    v21 = *(_DWORD *)(this + 8);
    v22 = *(_DWORD *)(this + 16) + *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = v22;
    v23 = *(_DWORD *)(this + 20) + v21;
    *(_DWORD *)(this + 8) = v23;
    if ( v22 < dword_4C1AB8 || v22 >= dword_4C1AC0 || v23 < dword_4C1ABC || v23 >= dword_4C1AC4 )
      return 1;
    v24 = *(_DWORD **)(this + 12);
    v25 = v24[30132];
    if ( v25 && (unsigned int)v22 < 0xFA0000 && *(_DWORD *)(this + 8) < 0xFA0000u )
    {
      if ( (v26 = v22 / 16000,
            v27 = *(unsigned __int8 *)(v25 + ((*(_DWORD *)(this + 8) / 16000) << 10) + v26),
            v27 != 253)
        && v27 != 252
        || !(*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v24 + 464))(
              v24,
              v26,
              *(_DWORD *)(this + 8) / 16000,
              *(_DWORD *)(this + 184)) )
      {
        if ( (v27 < 172 || v27 >= 191) && v27 != 254 && v27 != 255 && v27 != 171 && v27 != 170 )
          return v27 == 242;
      }
    }
    return 0;
  }
  v28 = (_DWORD *)(this + 4);
  v29 = *(_DWORD *)(this + 16) + *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = v29;
  if ( !*(_DWORD *)(*(_DWORD *)(this + 12) + 120528) )
    goto LABEL_77;
  if ( v29 >= 0xFA0000 || *(_DWORD *)(this + 8) >= 0xFA0000u )
    goto LABEL_81;
  v30 = sub_455280((_DWORD *)(this + 4), 16000);
  v32 = *(_DWORD **)(this + 12);
  v33 = *(unsigned __int8 *)(v32[30132] + (v31 << 10) + v30);
  if ( (v33 == 253 || v33 == 252)
    && (*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v32 + 464))(
         v32,
         v30,
         v31,
         *(_DWORD *)(this + 184))
    || v33 >= 172 && v33 < 191
    || v33 == 254
    || v33 == 255
    || v33 == 171
    || v33 == 170 )
  {
    v33 = 0;
  }
  v34 = v33;
  if ( !v33 )
  {
LABEL_77:
    *(_DWORD *)(this + 8) += *(_DWORD *)(this + 20);
    v34 = sub_429C40((_DWORD *)this);
  }
  if ( v34 == 220 || v34 == 241 )
    return 1;
  if ( !v34 )
    return 0;
LABEL_81:
  v35 = *(_WORD *)(this + 167) & 0x1F;
  if ( v35 == 3 || v35 == 4 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)this + 20))(this);
    return 0;
  }
  if ( *(int *)(this + 144) <= 0 )
  {
    v36 = -1287458496;
    v37 = 178;
    do
      v36 ^= *(_DWORD *)&aAmerica[4 * v37-- - 552976];
    while ( v37 );
    *(_DWORD *)(v36 + this + 322184) = 49;
    (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(this + 12) + 260))(
      *(_DWORD *)(this + 12),
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 120076) + 128),
      *v28,
      *(_DWORD *)(this + 8),
      0,
      0);
    result = 0;
  }
  else
  {
    *(_DWORD *)(this + 156) = 1;
    result = 0;
  }
  return result;
}
// 429B00: variable 'v31' is possibly undefined
// 429D10: using guessed type int nullsub_7();
// 4C1AB4: using guessed type char byte_4C1AB4;
// 4C1AB8: using guessed type int dword_4C1AB8;
// 4C1ABC: using guessed type int dword_4C1ABC;
// 4C1AC0: using guessed type int dword_4C1AC0;
// 4C1AC4: using guessed type int dword_4C1AC4;

//----- (00429C40) --------------------------------------------------------
int __thiscall sub_429C40(_DWORD *this)
{
  _DWORD *v1; // ebp
  int v2; // esi
  int v4; // edi
  int v5; // esi

  v1 = (_DWORD *)this[3];
  v2 = v1[30132];
  if ( !v2 )
    return 0;
  if ( this[1] >= 0xFA0000u || this[2] >= 0xFA0000u )
    return 20;
  v4 = this[1] / 16000;
  v5 = *(unsigned __int8 *)(v2 + ((this[2] / 16000) << 10) + v4);
  if ( (v5 == 253 || v5 == 252)
    && (*(unsigned __int8 (__thiscall **)(_DWORD *, int, int, _DWORD))(*v1 + 464))(v1, v4, this[2] / 16000, this[46])
    || v5 >= 172 && v5 < 191
    || v5 == 254
    || v5 == 255
    || v5 == 171
    || v5 == 170 )
  {
    v5 = 0;
  }
  return v5;
}

//----- (00429D20) --------------------------------------------------------
int __thiscall sub_429D20(int *this, _DWORD *a2, char *Format)
{
  _DWORD *v4; // edi
  int v5; // ebx
  int v6; // ecx
  unsigned int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edi
  unsigned int v11; // ebx
  int result; // eax
  char v13; // bl
  int v14; // eax
  long double v15; // st7
  double v16; // st6
  int v17; // edi
  int v18; // ebx
  unsigned int v19; // edx
  _DWORD *v20; // ebx
  int v21; // edi
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  int v26; // edi
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // esi
  int v31; // edi
  char Buffer[128]; // [esp+Ch] [ebp-94h] BYREF
  int v33; // [esp+8Ch] [ebp-14h]
  int v34; // [esp+90h] [ebp-10h]
  int v35; // [esp+94h] [ebp-Ch]
  int v36; // [esp+98h] [ebp-8h]
  unsigned int v37; // [esp+9Ch] [ebp-4h]
  int v38; // [esp+A8h] [ebp+8h]
  char *Formata; // [esp+ACh] [ebp+Ch]

  v4 = (_DWORD *)this[3];
  v5 = v4[2171] - v4[7062] / 2;
  v37 = v4[2172] - v4[7063] / 2;
  v6 = this[1] / 1000;
  v7 = (int)((unsigned __int64)(274877907i64 * this[2]) >> 32) >> 6;
  v34 = v6;
  v8 = (v7 >> 31) + v7;
  v9 = this[19];
  v35 = v8;
  if ( v9 == 2 )
  {
    if ( *((_BYTE *)this + 156) && *(int *)(v4[542] + 768) > 0 && (int)v4[2936] > 200 )
    {
      v10 = this[1] / 1000 - v5;
      v11 = this[2] / 1000 - v37;
      sprintf_0(
        Buffer,
        (const char *const)(9197302 - (_DWORD)&word_418752),
        *(_DWORD *)(*(_DWORD *)(this[3] + 2168) + 768) / 100,
        *(_DWORD *)(*(_DWORD *)(this[3] + 2168) + 768) / 10 % 10);
      (*(void (__thiscall **)(_DWORD *, int, unsigned int, char *, int, int, int))(*a2 + 236))(
        a2,
        v10,
        v11,
        Buffer,
        3,
        -1,
        1);
    }
    return 0;
  }
  v13 = *((_BYTE *)this + 96);
  if ( (v13 & 2) != 0
    && ((v13 & 0x40) != 0 && !*((_BYTE *)this + 156)
     || this[22] != v4[28119] + v4[28120] && (*(_BYTE *)(v4[542] + 96) & 4) == 0)
    || this[1] < 0
    || this[23] == 8
    || this[81] > 0
    || v9 == 1 && v4[5776] % 4 )
  {
    return 0;
  }
  v14 = this[16];
  if ( v14 <= 0 )
  {
    if ( this[10] < 0 )
    {
      v20 = a2;
    }
    else
    {
      v37 = 1000 * (this[20] - 4);
      v33 = this[15] / 1000;
      v15 = (double)v33 * dbl_4AC920;
      v16 = (double)(int)v37;
      v17 = v4[5776];
      v18 = this[2] - (__int64)(cos(v15) * v16);
      v36 = (int)((__int64)(sin(v15) * v16) + this[1]) / 1000;
      v19 = (int)((unsigned __int64)(274877907i64 * v18) >> 32) >> 6;
      v20 = a2;
      v37 = (v19 >> 31) + v19;
      (*(void (__thiscall **)(_DWORD *, int, unsigned int, int, int, _DWORD))(*a2 + 184))(
        a2,
        v36,
        v37,
        v17 / 5 % 10,
        13,
        0);
    }
    v21 = 0;
    v38 = 0;
    if ( this[11] <= 24 )
    {
      v21 = (*(int (__thiscall **)(int *, _DWORD *, char *))(*this + 28))(this, v20, Format);
      v38 = v21;
    }
    v22 = this[3];
    v23 = *(_DWORD *)(*(_DWORD *)(v22 + 23100) + 8280);
    if ( v23 && (!*((_BYTE *)this + 156) && this[7] != *(_DWORD *)(v22 + 7504) || v23 == 2) )
    {
      v24 = *this;
      v37 = (unsigned int)&Format[v21];
      (*(void (__thiscall **)(int *, _DWORD *, int, int, char *, _DWORD, _DWORD))(v24 + 72))(
        this,
        v20,
        v34,
        v35,
        &Format[v21],
        0,
        0);
      if ( *(_DWORD *)(this[3] + 23104) - this[80] < 300 )
      {
        sprintf_0(Buffer, aD, this[84] + this[85]);
        v25 = this[23];
        Formata = *(char **)(this[3] + 1308 * v25 + 12948);
        if ( this[84] + this[85] >= (int)Formata / 2 )
          v26 = 2;
        else
          v26 = (this[84] + this[85] >= (int)Formata / 4) + 3;
        v27 = this[7];
        if ( v27 != -1 )
        {
          v28 = *(_DWORD *)(this[3] + 4 * v27 + 113620);
          if ( v28 )
          {
            v29 = *(_DWORD *)(v28 + 92);
            if ( v29 != 8 )
              v25 = v29;
          }
        }
        (*(void (__thiscall **)(_DWORD *, int, int, int, int, unsigned int, char *, int, int, _DWORD, _DWORD))(*v20 + 172))(
          v20,
          v25,
          v34,
          v35,
          -3 * v20[18806],
          v37,
          Buffer,
          v26,
          -1,
          0,
          0);
        v21 = v38;
      }
    }
    v30 = this[11];
    v31 = v21 + 1;
    if ( v30 > 0 )
      (*(void (__thiscall **)(_DWORD *, int, int, int, int))(*v20 + 176))(v20, v34, v35, v30, 6);
    result = v31;
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *, int, int, int, int))(*a2 + 176))(a2, v6, v8, v14, 4);
    result = 0;
  }
  return result;
}
// 418752: using guessed type __int16 word_418752;
// 4AC920: using guessed type double dbl_4AC920;

//----- (0042A180) --------------------------------------------------------
int __thiscall sub_42A180(_BYTE *this, int a2)
{
  int result; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // eax

  result = *(_DWORD *)(a2 + 88);
  if ( result == 51 )
  {
    v4 = 1387905111;
    v5 = 169;
    do
      v4 ^= *(_DWORD *)&aStar06Bm2[4 * v5-- - 367408];
    while ( v5 );
    this[v4 + 208481613] = this[1869] == 0;
    result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
  }
  else
  {
    if ( result == 50 )
    {
      *((_DWORD *)this + 29441) = (*((_DWORD *)this + 29441) + 1) % (*((_DWORD *)this + 29442) + 1);
      (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 128))(this);
      result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
      this[1869] = 0;
    }
    if ( this[1869] )
    {
      v6 = *(_DWORD *)(a2 + 92);
      if ( v6 || *(_DWORD *)(a2 + 356) )
      {
        if ( *(_DWORD *)(a2 + 356) )
          result = *(unsigned __int8 *)(a2 + 99);
        else
          result = 0;
        switch ( v6 )
        {
          case 10:
            (*(void (__thiscall **)(_BYTE *))(*((_DWORD *)this + 28087) + 48))(this + 112348);
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 11:
            *(_DWORD *)(*((_DWORD *)this + 5775) + 8280) = (*(_DWORD *)(*((_DWORD *)this + 5775) + 8280) + 1) % 3;
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 12:
            this[6280] = this[6280] == 0;
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 13:
            this[6281] = this[6281] == 0;
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 14:
            *(_BYTE *)(*((_DWORD *)this + 5775) + 8058) = *(_BYTE *)(*((_DWORD *)this + 5775) + 8058) == 0;
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 16:
            this[6282] = this[6282] == 0;
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 25:
            (*(void (__thiscall **)(_BYTE *, int, int))(*((_DWORD *)this + 28087) + 44))(
              this + 112348,
              *((_DWORD *)this + 28109) - 1,
              -1);
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          case 24:
            (*(void (__thiscall **)(_BYTE *, int, int))(*((_DWORD *)this + 28087) + 44))(
              this + 112348,
              *((_DWORD *)this + 28109) + 1,
              -1);
            result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            break;
          default:
            if ( result >= 49 && result <= 56 && (v7 = *((_DWORD *)this + 542)) != 0 )
            {
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v7 + 100))(v7, result - 49);
              this[1869] = 0;
              result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            }
            else if ( (result == 115 || result == 83) && (v8 = *((_DWORD *)this + 542)) != 0 )
            {
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 100))(v8, 8);
              this[1869] = 0;
              result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
            }
            else
            {
              switch ( result )
              {
                case 'q':
                case 'Q':
                  (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 284))(this);
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                case 'i':
                case 'I':
                  *(_BYTE *)(*((_DWORD *)this + 5775) + 8061) = *(_BYTE *)(*((_DWORD *)this + 5775) + 8061) == 0;
                  if ( *(_BYTE *)(*((_DWORD *)this + 5775) + 8061) )
                    v9 = 9213921 - (_DWORD)&loc_41C821;
                  else
                    v9 = 9213901 - (_DWORD)&loc_41C821;
                  (*(void (__cdecl **)(_BYTE *, int, int, int))(*(_DWORD *)this + 388))(this, 500, 4, v9);
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                case 'b':
                case 'B':
                  if ( *(_DWORD *)(*((_DWORD *)this + 542) + 92) == 8 )
                    (*(void (__thiscall **)(_BYTE *))(*((_DWORD *)this + 438) + 32))(this + 1752);
                  else
                    (*(void (__cdecl **)(_BYTE *, int, int, int))(*(_DWORD *)this + 388))(
                      this,
                      400,
                      4,
                      9214699 - (_DWORD)&loc_41CB17);
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                case 'a':
                case 'A':
                  (*(void (__thiscall **)(_BYTE *, char *, int, _DWORD, _DWORD))(*(_DWORD *)this + 364))(
                    this,
                    aArena,
                    2,
                    0,
                    0);
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                case 'c':
                case 'C':
                  (*(void (__thiscall **)(_BYTE *, char *, int, _DWORD, _DWORD))(*(_DWORD *)this + 364))(
                    this,
                    aGetsettings,
                    2,
                    0,
                    0);
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                case 'f':
                case 'F':
                  *(_BYTE *)(*((_DWORD *)this + 5775) + 8279) = *(_BYTE *)(*((_DWORD *)this + 5775) + 8279) == 0;
                  this[1869] = 0;
                  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 16))(a2);
                  break;
                default:
                  this[1869] = 0;
                  break;
              }
            }
            break;
        }
      }
    }
  }
  return result;
}

//----- (0042A5A0) --------------------------------------------------------
int __thiscall sub_42A5A0(_DWORD *this)
{
  return this[193];
}

//----- (0042A5B0) --------------------------------------------------------
int __thiscall sub_42A5B0(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  int v5; // ecx
  int v7; // edi
  int result; // eax
  int v9; // ebx
  char *v10; // ecx
  int v11; // eax
  char v12[400]; // [esp+Ch] [ebp-1E4h] BYREF
  char Buffer[80]; // [esp+19Ch] [ebp-54h] BYREF
  int v14; // [esp+1ECh] [ebp-4h]
  char *v15; // [esp+1F8h] [ebp+8h]

  v14 = 9219762;
  v5 = this[26] + 580 * this[2];
  sprintf_0(Buffer, aLowDHighD, *(_DWORD *)(v5 + 44), *(_DWORD *)(v5 + 48));
  v7 = a2[18807] + a4;
  (*(void (__thiscall **)(_DWORD *, int, int, char *, int, int, int))(*a2 + 236))(a2, a3, v7, Buffer, 1, -1, 1);
  result = (*(int (__thiscall **)(_DWORD *, char *, int, int, int))(*a2 + 232))(
             a2,
             v12,
             100,
             this[26] + 580 * this[2] + 308,
             62 * a2[18806]);
  v9 = 0;
  v14 = result;
  if ( result > 0 )
  {
    v10 = v12;
    v15 = v12;
    while ( v9 < 4 )
    {
      v7 += a2[18807];
      v11 = v9 >= result - 1 ? -1 : *((_DWORD *)v10 + 1) - *(_DWORD *)v10;
      (*(void (__thiscall **)(_DWORD *, int, int, _DWORD, int, int, int))(*a2 + 236))(
        a2,
        a3,
        v7,
        *(_DWORD *)v10,
        7,
        v11,
        1);
      result = v14;
      ++v9;
      v15 += 4;
      if ( v9 >= v14 )
        break;
      v10 = v15;
      result = v14;
    }
  }
  return result;
}

//----- (0042A6C0) --------------------------------------------------------
int __thiscall sub_42A6C0(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // edi
  int result; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp-10h] [ebp-20h]
  int v13; // [esp-Ch] [ebp-1Ch]
  int v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]

  v7 = *(_DWORD *)(this[29] + 4 * a5 + 2180);
  if ( this[25] != 4 || (result = (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, a5) - 1, result == a6) )
  {
    v9 = this[25];
    if ( v9 == 6 )
    {
      result = (*(int (__thiscall **)(int, int, int, bool, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)a2 + 256))(
                 a2,
                 a3,
                 a4,
                 a5 == this[2],
                 0,
                 0,
                 0,
                 -1);
    }
    else
    {
      if ( *(_DWORD *)(v7 + 212) == -1 || v9 <= 1 )
        v10 = -1;
      else
        v10 = *(_DWORD *)(v7 + 24);
      v15 = v10;
      LOBYTE(v10) = *(_BYTE *)(v7 + 169);
      v14 = v10;
      v11 = *(_DWORD *)(this[29] + 2168);
      LOBYTE(v11) = *(_DWORD *)(v7 + 28) == *(_DWORD *)(v11 + 24);
      v13 = v11;
      LOBYTE(v11) = *(_DWORD *)(v7 + 92) == 8;
      v12 = v11;
      LOBYTE(v11) = a5 == this[2];
      result = (*(int (__thiscall **)(int, int, int, int, int, int, int, int))(*(_DWORD *)a2 + 256))(
                 a2,
                 a3,
                 a4,
                 v11,
                 v12,
                 v13,
                 v14,
                 v15);
    }
  }
  return result;
}

//----- (0042A790) --------------------------------------------------------
int __thiscall sub_42A790(_DWORD *this)
{
  int v2; // edi
  int v3; // ecx
  _BYTE *v4; // eax
  int i; // edi
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v9; // eax
  int v10; // [esp-8h] [ebp-11Ch]
  char v11; // [esp+Ch] [ebp-108h] BYREF
  __int16 v12; // [esp+Dh] [ebp-107h]
  char v13[260]; // [esp+10h] [ebp-104h] BYREF

  v2 = 0;
  v3 = this[435];
  if ( v3 <= 0 )
  {
LABEL_5:
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this[29429] + 1204) + 20))(*(_DWORD *)(this[29429] + 1204));
    for ( i = 0; i < this[435]; ++i )
    {
      v6 = this[433];
      if ( *(_BYTE *)(17 * i + v6 + 1) )
      {
        v10 = this[5775] + 269;
        v13[0] = 0;
        sub_407960(v13, v10, (_BYTE *)(17 * i + v6 + 1));
        if ( i )
          (*(void (__thiscall **)(_DWORD, char *, int))(**(_DWORD **)(this[29429] + 1204) + 4))(
            *(_DWORD *)(this[29429] + 1204),
            v13,
            30);
        else
          (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 452))(this, v13, this[433] + 1);
      }
    }
    (*(void (__thiscall **)(_DWORD *))(*this + 328))(this);
    if ( *((_BYTE *)this + 112216) )
    {
      (*(void (__thiscall **)(_DWORD *, int))(*this + 172))(this, 1);
      *((_BYTE *)this + 112216) = 0;
    }
    v9 = *this;
    *((_BYTE *)this + 28244) = 0;
    (*(void (__thiscall **)(_DWORD *, int))(v9 + 172))(this, 2);
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)this[29429] + 128))(this[29429]);
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[30019] + 20))(this[30019]);
  }
  else
  {
    v4 = (_BYTE *)this[433];
    while ( *v4 )
    {
      ++v2;
      v4 += 17;
      if ( v2 >= v3 )
        goto LABEL_5;
    }
    v7 = *this;
    v11 = 12;
    v12 = v2;
    result = (*(int (__thiscall **)(_DWORD *, char *, int, int))(v7 + 16))(this, &v11, 3, 1);
    this[29443] = v2;
  }
  return result;
}

//----- (0042A9A0) --------------------------------------------------------
int __thiscall sub_42A9A0(_DWORD *this, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ebx
  int v6; // edi
  int v7; // ecx
  int v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // ebx
  int v21; // ecx
  int v22; // ecx
  int v23; // eax
  int result; // eax
  int v25; // ebx
  int v26; // eax
  int v27; // [esp-Ch] [ebp-9Ch]
  int v28; // [esp-4h] [ebp-94h]
  int v29; // [esp-4h] [ebp-94h]
  char Buffer[64]; // [esp+Ch] [ebp-84h] BYREF
  int v31[4]; // [esp+4Ch] [ebp-44h] BYREF
  int v32; // [esp+5Ch] [ebp-34h]
  unsigned int v33; // [esp+60h] [ebp-30h] BYREF
  int v34; // [esp+64h] [ebp-2Ch]
  int v35; // [esp+68h] [ebp-28h]
  int v36; // [esp+6Ch] [ebp-24h]
  unsigned int v37; // [esp+70h] [ebp-20h] BYREF
  int v38; // [esp+74h] [ebp-1Ch]
  unsigned int v39; // [esp+78h] [ebp-18h]
  int v40; // [esp+7Ch] [ebp-14h]
  unsigned int v41; // [esp+80h] [ebp-10h] BYREF
  int v42; // [esp+84h] [ebp-Ch]
  unsigned int v43; // [esp+88h] [ebp-8h]
  int v44; // [esp+8Ch] [ebp-4h]
  unsigned int v45; // [esp+9Ch] [ebp+Ch]
  int v46; // [esp+A0h] [ebp+10h]

  v4 = a4;
  if ( !a4 )
    v4 = 1;
  v6 = 0;
  v46 = 0;
  if ( a2 < a3 / 2 )
  {
    v6 = 1;
    v46 = 1;
    if ( a2 < a3 / 4 )
    {
      v6 = 2;
      v46 = 2;
    }
  }
  v7 = this[2];
  this[18820] = this[2] / 2;
  v32 = *(_DWORD *)(this[302] + 7995);
  if ( v32 == 2 )
  {
    this[18821] = 0;
  }
  else
  {
    v8 = v7 / 3 + 24;
    v45 = a3 * v8 / v4;
    v9 = a2 * v8 / v4;
    v10 = (unsigned int)(v7 - v8) >> 1;
    v11 = v10 + v8;
    if ( v32 )
    {
      v33 = v10 + v8;
      v37 = v10 - 1;
      v39 = v10;
      v41 = v10 + v45;
      v43 = v10 + v45 + 1;
      v35 = v11 + 1;
      v21 = this[13602];
      v44 = 5;
      v36 = 5;
      v31[0] = v10;
      v29 = v21;
      v22 = this[17];
      v31[2] = v9 + v10;
      v23 = *this;
      v38 = 0;
      v40 = 5;
      v42 = 0;
      v34 = 0;
      v31[1] = 1;
      v31[3] = 4;
      (*(void (__thiscall **)(_DWORD *, int, unsigned int *, int))(v23 + 68))(this, v22, &v37, v29);
      (*(void (__thiscall **)(_DWORD *, _DWORD, unsigned int *, _DWORD))(*this + 68))(this, this[17], &v41, this[13588]);
      (*(void (__thiscall **)(_DWORD *, _DWORD, unsigned int *, _DWORD))(*this + 68))(this, this[17], &v33, this[13602]);
      v6 = v46;
      (*(void (__thiscall **)(_DWORD *, _DWORD, int *, _DWORD))(*this + 68))(
        this,
        this[17],
        v31,
        this[14 * v46 + 13588 + this[2548] / 8 % 14]);
      this[18821] = 5;
    }
    else
    {
      v12 = *this;
      v33 = v10;
      v13 = this[13593];
      v35 = v11;
      v27 = this[17];
      v34 = 9;
      v36 = 11;
      (*(void (__thiscall **)(_DWORD *, int, unsigned int *, int))(v12 + 68))(this, v27, &v33, v13);
      v14 = this[2];
      v15 = this[13588];
      v41 = (v14 - v45) >> 1;
      v28 = v15;
      v16 = this[17];
      v43 = (v45 + v14) >> 1;
      v17 = *this;
      v42 = 9;
      v44 = 11;
      (*(void (__thiscall **)(_DWORD *, int, unsigned int *, int))(v17 + 68))(this, v16, &v41, v28);
      v18 = this[2];
      v6 = v46;
      v39 = (v9 + v18) >> 1;
      v19 = this[2548];
      v37 = (v18 - v9) >> 1;
      v20 = *this;
      v38 = 13;
      v40 = 19;
      (*(void (__thiscall **)(_DWORD *, _DWORD, unsigned int *, _DWORD))(v20 + 68))(
        this,
        this[17],
        &v37,
        this[14 * v46 + 13588 + v19 / 8 % 14]);
      sub_404B80((_DWORD *)this[2885], (this[2] - *(_DWORD *)(this[2885] + 612)) / 2, 0, 0, 1);
      this[18821] = *(_DWORD *)(this[2885] + 616);
    }
  }
  result = *(_DWORD *)(this[302] + 7991);
  if ( !result )
    return (*(int (__thiscall **)(_DWORD *, int, _DWORD, int, _DWORD))(*this + 92))(
             this,
             this[2] - 14,
             0,
             a2,
             this[2884]);
  if ( result == 1 )
  {
    sprintf_0(Buffer, aD, a2);
    v25 = *this;
    v26 = (*(int (__thiscall **)(_DWORD *, char *, int, char *, int, int, int))(*this + 224))(
            this,
            Buffer,
            3 * this[18807],
            Buffer,
            dword_4AAF14[v6],
            -1,
            1);
    result = (*(int (__thiscall **)(_DWORD *, int))(v25 + 236))(this, this[2] - v26);
  }
  return result;
}
// 4AAF14: using guessed type int dword_4AAF14[];

//----- (0042AF60) --------------------------------------------------------
int __thiscall sub_42AF60(_DWORD *this, int a2)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // eax
  int (__thiscall *v6)(char *, char, char *); // ebx
  int result; // eax
  int v8; // ecx
  int v9[8]; // [esp+8h] [ebp-20h] BYREF

  v9[4] = 0;
  v9[5] = 0;
  v9[6] = 0;
  v9[0] = a2;
  v9[7] = 0;
  v3 = this[2555];
  v9[1] = 19;
  v9[2] = 10;
  v9[3] = 0;
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v3 + 20))(v3, v9);
  v4 = this[4956];
  if ( v4 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 8))(v4, 1);
  v5 = 0;
  v6 = sub_447900;
  do
  {
    v5 -= *(_DWORD *)v6;
    v6 = (int (__thiscall *)(char *, char, char *))((char *)v6 + 4);
  }
  while ( (char *)v6 < (char *)((char *)&loc_4479DF + 1) );
  result = v5 - 1655479442;
  *(_DWORD *)((char *)this + result + 158610928) = 0;
  v8 = this[4957];
  if ( v8 )
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)v8 + 8))(v8, 1);
  this[4957] = 0;
  return result;
}

//----- (0042B020) --------------------------------------------------------
unsigned int __thiscall sub_42B020(_DWORD *this, unsigned int a2, int a3, int a4)
{
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  unsigned __int8 *v10; // edi
  int *v11; // eax
  int v12; // esi
  unsigned int i; // ecx
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // esi
  int v17; // edx
  unsigned int v18; // eax
  int v19; // edx
  int v20; // edi
  int v21; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // eax
  int v27; // esi
  int v28; // eax
  int v29; // esi
  int v30; // ecx
  int v31; // eax
  int v32; // eax
  int v33; // ecx
  int v34; // ebp
  int v35; // edi
  int v36; // edi
  void *v37; // esi
  int v38; // ecx
  int v39; // esi
  int v40; // edx
  int v41; // ebp
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // ecx
  unsigned int v46; // kr00_4
  int v47; // eax
  int v48; // esi
  int v49; // edi
  int v50; // edx
  int v51; // eax
  int v52; // edx
  int v53; // edx
  int v54; // eax
  int v55; // ebx
  _DWORD *v56; // edi
  int v57; // ecx
  int v58; // eax
  int v59; // edx
  int v61; // [esp+8h] [ebp-2D0h]
  int v62; // [esp+8h] [ebp-2D0h]
  __int64 v63; // [esp+Ch] [ebp-2CCh] BYREF
  int v64; // [esp+18h] [ebp-2C0h]
  char v65; // [esp+1Ch] [ebp-2BCh] BYREF
  char v66; // [esp+1Dh] [ebp-2BBh]
  unsigned int v67; // [esp+1Eh] [ebp-2BAh]
  unsigned int v68; // [esp+22h] [ebp-2B6h]
  int v69[31]; // [esp+48h] [ebp-290h] BYREF
  __int16 v70; // [esp+C4h] [ebp-214h]
  char v71; // [esp+C6h] [ebp-212h]
  char v72[128]; // [esp+C8h] [ebp-210h] BYREF
  int v73[32]; // [esp+148h] [ebp-190h] BYREF
  char v74[128]; // [esp+1C8h] [ebp-110h] BYREF
  char v75[144]; // [esp+248h] [ebp-90h] BYREF

  v5 = this[178];
  if ( v5 != 4 && a3 > 0 )
  {
    if ( *(_BYTE *)a2 )
    {
      (*(void (__thiscall **)(_DWORD *, unsigned int, int, int))*this)(this, a2, a3, a4);
    }
    else if ( a3 > 1 )
    {
      switch ( *(_BYTE *)(a2 + 1) )
      {
        case 1:
          if ( !v5 && a3 >= 8 )
          {
            v6 = -*(_DWORD *)(a2 + 2);
            (*(void (__thiscall **)(_DWORD *, int))(*this + 12))(this, v6);
            v7 = *this;
            this[178] = 2;
            LOWORD(v63) = 512;
            *(_DWORD *)((char *)&v63 + 2) = v6;
            (*(void (__thiscall **)(_DWORD *, int, __int64 *))(v7 + 20))(this, 6, &v63);
          }
          goto LABEL_89;
        case 2:
          if ( v5 == 1 && a3 >= 6 )
          {
            (*(void (__thiscall **)(_DWORD *, _DWORD))(*this + 12))(this, *(_DWORD *)(a2 + 2));
            this[178] = 2;
            if ( (unsigned int)a3 >= 7 && *(_BYTE *)(a2 + 6) )
            {
              this[349] = 1;
            }
            else if ( (unsigned int)a3 >= 0x87 )
            {
              memset(v69, 0, sizeof(v69));
              v8 = this[5];
              v70 = 0;
              v71 = 0;
              v9 = this[4];
              LOWORD(v69[1]) = v8;
              v69[0] = v9;
              sub_46CAB0((unsigned int)v74, (_BYTE *)(a2 + 7), 0x80u);
              v10 = (unsigned __int8 *)&unk_4AADF8;
              v11 = v73;
              LODWORD(v63) = 32;
              do
              {
                v12 = 0;
                for ( i = 0; i < 0x20; i += 8 )
                {
                  v14 = *v10 << i;
                  v12 |= v14;
                  ++v10;
                }
                v15 = v63;
                *v11++ = v12;
                LODWORD(v63) = v15 - 1;
              }
              while ( v15 != 1 );
              qmemcpy(v75, v73, 0x80u);
              memset(v73, 0, sizeof(v73));
              v73[0] = 3;
              sub_4556D0((int)v75, v74, (int)v72, 0, v73);
              if ( !memcmp(v72, v69, 0x7Fu) )
              {
                if ( a2 < 0x8B )
                {
                  this[349] = 2;
                }
                else
                {
                  this[349] = 3;
                  this[350] = *(_DWORD *)(a2 + 135);
                }
              }
            }
          }
          goto LABEL_89;
        case 3:
          if ( a3 >= 6 )
          {
            v16 = *(_DWORD *)(a2 + 2);
            v17 = *this;
            v65 = 0;
            v66 = 4;
            v64 = v16;
            v67 = v16;
            (*(void (__thiscall **)(_DWORD *, int, char *))(v17 + 20))(this, 6, &v65);
            v18 = this[180];
            if ( v16 >= v18 )
            {
              if ( v16 == v18 )
              {
                v19 = *this;
                this[180] = v18 + 1;
                (*(void (__thiscall **)(_DWORD *, unsigned int, int, int))(v19 + 8))(this, a2 + 6, a3 - 6, 1);
                v20 = 0;
                if ( (int)this[186] > 0 )
                {
                  do
                  {
                    v21 = this[184];
                    v22 = this[180];
                    v23 = *(_DWORD *)(v21 + 4 * v20);
                    v24 = v21 + 4 * v20;
                    if ( *(_DWORD *)(v23 + 8) != v22 )
                      break;
                    v25 = *this;
                    this[180] = v22 + 1;
                    (*(void (__thiscall **)(_DWORD *, int, _DWORD, int))(v25 + 8))(
                      this,
                      *(_DWORD *)v24 + 12,
                      *(unsigned __int16 *)(*(_DWORD *)v24 + 4),
                      1);
                    if ( v20 < this[186] )
                      sub_40B7E0(*(_DWORD *)(this[184] + 4 * v20));
                    ++v20;
                  }
                  while ( v20 < this[186] );
                  if ( v20 )
                  {
                    v26 = this[186];
                    v27 = v20;
                    if ( v20 > v26 )
                      v27 = this[186];
                    sub_46CAB0(this[184], (_BYTE *)(this[184] + 4 * v27), 4 * (v26 + 0x3FFFFFFF * v27));
                    this[186] -= v27;
                  }
                }
              }
              else if ( v16 < v18 + 128 )
              {
                v28 = this[186];
                v29 = 0;
                if ( v28 <= 0 )
                {
                  v30 = HIDWORD(v63);
                }
                else
                {
                  v61 = this[184];
                  v30 = HIDWORD(v63);
                  do
                  {
                    if ( *(_DWORD *)(*(_DWORD *)v61 + 8) >= HIDWORD(v63) )
                      break;
                    ++v29;
                    v61 += 4;
                  }
                  while ( v29 < v28 );
                }
                if ( v29 >= v28 || *(_DWORD *)(*(_DWORD *)(this[184] + 4 * v29) + 8) != v30 )
                {
                  v62 = sub_40B720((int)this, a3 + 6);
                  *(_DWORD *)v62 = sub_412170();
                  v31 = HIDWORD(v63);
                  *(_WORD *)(v62 + 4) = a3 - 6;
                  *(_DWORD *)(v62 + 8) = v31;
                  sub_46CAB0(v62 + 12, (_BYTE *)(a2 + 6), a3 - 6);
                  v32 = this[186];
                  v33 = this[185];
                  v34 = (int)(this + 184);
                  if ( v32 >= v33 )
                  {
                    if ( v32 >= 8 )
                      v35 = v32 >= 32 ? 32 : 8;
                    else
                      v35 = 4;
                    sub_40B780(4 * (v32 + v35), (void **)v34, v34);
                    *(_DWORD *)(v34 + 4) += v35;
                  }
                  v36 = 4 * v29;
                  sub_46CAB0(
                    *(_DWORD *)v34 + 4 * v29 + 4,
                    (_BYTE *)(4 * v29 + *(_DWORD *)v34),
                    4 * (*(_DWORD *)(v34 + 8) + 0x3FFFFFFF * v29));
                  v37 = *(void **)v34;
                  ++*(_DWORD *)(v34 + 8);
                  sub_46CAB0((unsigned int)v37 + v36, (_BYTE *)&v63 + 4, 4u);
                  *(_DWORD *)(v36 + *(_DWORD *)v34) = v62;
                }
              }
            }
          }
          goto LABEL_89;
        case 4:
          if ( a3 < 6 )
            goto LABEL_89;
          v38 = this[189];
          v39 = 0;
          if ( v38 <= 0 )
            goto LABEL_89;
          v40 = this[187];
          v41 = (int)(this + 187);
          v42 = v40;
          break;
        case 5:
          if ( a3 >= 6 )
          {
            v45 = *(_DWORD *)(a2 + 2);
            v65 = 0;
            v66 = 6;
            v68 = 0;
            v67 = v45;
            v46 = sub_412170();
            v47 = *this;
            v68 = v46 / 0xA;
            (*(void (__thiscall **)(_DWORD *, int, char *))(v47 + 20))(this, 10, &v65);
          }
          goto LABEL_89;
        case 6:
          if ( a3 >= 10 )
          {
            v48 = sub_412170() / 10;
            v49 = v48 - *(_DWORD *)(a2 + 2);
            v50 = (unsigned __int64)(274877907i64 * v49 * (1000 - this[232])) >> 32;
            v51 = *(_DWORD *)(a2 + 6);
            HIDWORD(v63) = v49;
            v52 = v51 + ((unsigned int)v50 >> 31) + (v50 >> 6);
            LOBYTE(v51) = *((_BYTE *)this + 1405);
            v53 = v52 - v48;
            v64 = v53;
            if ( (_BYTE)v51 )
            {
              sub_435750(this + 237, v48, v53, v49);
              v54 = this[338];
              v55 = HIDWORD(v63);
              if ( (SHIDWORD(v63) <= v54 + 1 || v48 - this[234] > 12000)
                && (SHIDWORD(v63) < 2 * v54 || v48 - this[234] > 60000) )
              {
                v56 = this + 231;
                if ( (int)abs32(v64 - this[231]) > 1 )
                {
                  nullsub_2("Set time diff %d --> %d (%d) ping:%d\n", *v56, v64, v64 - this[231], HIDWORD(v63));
                  *v56 = v64;
                  sub_417EB0((int)&dword_4C1AD0, 21587, (_BYTE *)this + 924, 4);
                  v55 = HIDWORD(v63);
                }
                this[338] = v55;
                this[234] = v48;
              }
            }
            else
            {
              this[231] = sub_435750(this + 237, v48, v53, v49);
              sub_417EB0((int)&dword_4C1AD0, 21587, (_BYTE *)this + 924, 4);
              v55 = HIDWORD(v63);
            }
            v57 = this[343];
            v58 = 10 * v55;
            v59 = 10 * v55 + this[341];
            this[340] = 10 * v55;
            this[341] = v59;
            if ( 10 * v55 > v57 )
              this[343] = v58;
            if ( v58 < this[342] || !this[344] )
              this[342] = v58;
            ++this[344];
          }
          goto LABEL_89;
        case 7:
          if ( !*((_BYTE *)this + 1394) )
            this[178] = 4;
          goto LABEL_89;
        case 8:
          return sub_42B760((_BYTE *)(a2 + 2), (int)this, a2, a3, a4);
        case 9:
          JUMPOUT(0x42B771);
        case 0xA:
          JUMPOUT(0x42B7AE);
        case 0xB:
        case 0xD:
          goto LABEL_89;
        case 0xC:
          JUMPOUT(0x42B810);
        case 0xE:
          JUMPOUT(0x42B82C);
        case 0x10:
          JUMPOUT(0x42B86F);
        case 0x12:
          JUMPOUT(0x42B8E0);
        case 0x14:
          JUMPOUT(0x42B9B1);
        default:
          JUMPOUT(0x42B9CC);
      }
      while ( *(_DWORD *)(*(_DWORD *)v42 + 8) != *(_DWORD *)(a2 + 2) )
      {
        ++v39;
        v42 += 4;
        if ( v39 >= v38 )
          goto LABEL_89;
      }
      sub_40B7E0(*(_DWORD *)(v40 + 4 * v39));
      sub_46CAB0(
        *(_DWORD *)v41 + 4 * v39,
        (_BYTE *)(*(_DWORD *)v41 + 4 * (v39 + 1)),
        4 * (*(_DWORD *)(v41 + 8) + 0x3FFFFFFF * (v39 + 1)));
      v43 = *(_DWORD *)(v41 + 8) - 1;
      *(_DWORD *)(v41 + 8) = v43;
      if ( v43 && *(_DWORD *)(v41 + 4) - v43 > 32 )
      {
        v44 = *(_DWORD *)(v41 + 4) - 16;
        *(_DWORD *)(v41 + 4) = v44;
        sub_40B780(4 * v44, (void **)v41, v41);
      }
    }
  }
LABEL_89:
  JUMPOUT(0x42B9DA);
}
// 42B09E: control flows out of bounds to 42B771
// 42B09E: control flows out of bounds to 42B7AE
// 42B09E: control flows out of bounds to 42B810
// 42B09E: control flows out of bounds to 42B82C
// 42B09E: control flows out of bounds to 42B86F
// 42B09E: control flows out of bounds to 42B8E0
// 42B09E: control flows out of bounds to 42B9B1
// 42B09E: control flows out of bounds to 42B9CC
// 42B09E: control flows out of bounds to 42B9DA
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 4C1AD0: using guessed type int dword_4C1AD0;

//----- (0042B760) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __userpurge sub_42B760@<eax>(_BYTE *a1@<ebx>, int a2@<ebp>, int a3, int a4, int a5)
{
  unsigned int v6; // [esp-2D8h] [ebp-2DCh]

  return sub_40CA40((unsigned int *)(a2 + 760), a2, a1, v6);
}
// 42B9F2: positive sp value 2DC has been found
// 42B760: could not find valid save-restore pair for edi
// 42B760: could not find valid save-restore pair for esi
// 42B767: variable 'v6' is possibly undefined

//----- (0042BA70) --------------------------------------------------------
bool __thiscall sub_42BA70(_DWORD *this)
{
  int v1; // edx
  int v2; // eax
  int v3; // edx

  v1 = this[115];
  if ( *(_DWORD *)(this[116] + v1) )
  {
    v2 = this[113] + this[114];
    v3 = *(_DWORD *)(this[112] + v1);
    if ( v2 > v3 )
      v2 = v3;
  }
  else
  {
    v2 = *(_DWORD *)(this[111] + v1);
  }
  return this[130] + this[131] >= 1000 * v2;
}

//----- (0042BAD0) --------------------------------------------------------
int __thiscall sub_42BAD0(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // ebx

  result = a4 / 256;
  if ( (unsigned int)(a4 / 256) < 8 )
  {
    v5 = this[result + 2897];
    if ( v5 )
      result = sub_405930(
                 v5,
                 a2,
                 (this[18807] - 8) / 2 + a3 - 1,
                 12 * (a4 % 16),
                 8 * (a4 / 16 % 16),
                 12 * (a4 % 16) + 12,
                 8 * (a4 / 16 % 16) + 8,
                 1);
  }
  return result;
}

//----- (0042BB87) --------------------------------------------------------
void __usercall sub_42BB87(int a1@<edx>, char a2@<cl>, int a3@<esi>)
{
  *(_DWORD *)(a1 + 8) = __ROL4__(a3, a2);
}

//----- (0042BB90) --------------------------------------------------------
int __thiscall sub_42BB90(_DWORD *this, int a2)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // edi

  v3 = 0;
  result = this[1875];
  if ( result > 0 )
  {
    v5 = this + 1571;
    do
    {
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v5 + 8))(*v5, a2);
      result = this[1875];
      ++v3;
      ++v5;
    }
    while ( v3 < result );
  }
  return result;
}

//----- (0042BBD0) --------------------------------------------------------
int __thiscall sub_42BBD0(int *this)
{
  int *v1; // edi
  int result; // eax
  int v3; // ebp
  _DWORD *v4; // esi
  int v5; // ebx
  int v6; // ecx
  int *v7; // esi
  int v8; // ebx
  int v9; // eax
  int v10; // ebp
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  bool v16; // cc
  int v17; // [esp+4h] [ebp-1Ch]
  int v18; // [esp+8h] [ebp-18h]
  unsigned int v20; // [esp+10h] [ebp-10h]
  int v21; // [esp+14h] [ebp-Ch]
  int v22; // [esp+18h] [ebp-8h]

  v1 = this;
  result = 0;
  v18 = 0;
  if ( this[6] > 0 )
  {
    v3 = 0;
    v4 = this + 4;
    v21 = 0;
    do
    {
      v5 = 4 * result;
      v22 = 4 * result;
      v6 = *(_DWORD *)(4 * result + *v4);
      v20 = v6;
      if ( *(_BYTE *)(v6 + 280) )
      {
        v17 = 0;
        if ( v1[3] > 0 )
        {
          v7 = v1 + 1;
          v8 = 0;
          while ( 1 )
          {
            if ( *(_DWORD *)(v8 + *v7) == v6 )
            {
              v9 = v8;
              v8 -= 156;
              --v17;
              v10 = 156 * v7[2] - (v9 + 156);
              sub_46CAB0(*v7 + v9, (_BYTE *)(*v7 + v9 + 156), v10);
              v11 = v7[2] - 1;
              v7[2] = v11;
              if ( v11 && v7[1] - v11 > 32 )
              {
                v12 = v7[1] - 16;
                v7[1] = v12;
                sub_40B780(156 * v12, (void **)v7, v10);
              }
              v1 = this;
            }
            v8 += 156;
            if ( ++v17 >= v1[3] )
              break;
            v6 = v20;
          }
          v3 = v21;
          v5 = v22;
          v6 = v20;
        }
        if ( v6 )
        {
          sub_42BD80(v6, v3);
          sub_40B7E0(v20);
        }
        --v18;
        v4 = v1 + 4;
        v13 = v3 + 0x3FFFFFFF;
        v3 -= 0x3FFFFFFF;
        sub_46CAB0(v1[4] + v5, (_BYTE *)(v5 + v1[4] + 4), 4 * (v13 + v1[6]));
        v14 = v1[6] - 1;
        v1[6] = v14;
        if ( v14 )
        {
          if ( v1[5] - v14 > 32 )
          {
            v15 = v1[5] - 16;
            v1[5] = v15;
            sub_40B780(4 * v15, (void **)v1 + 4, v3);
          }
        }
      }
      result = v18 + 1;
      v3 += 0x3FFFFFFF;
      v16 = ++v18 < v1[6];
      v21 = v3;
    }
    while ( v16 );
  }
  return result;
}

//----- (0042BD80) --------------------------------------------------------
void __usercall sub_42BD80(int a1@<ecx>, int a2@<ebp>)
{
  sub_40C9D0(a1 + 268, a2, 0);
}

//----- (0042BD90) --------------------------------------------------------
int __thiscall sub_42BD90(_DWORD *this, int *a2, int a3, int a4, char a5, char a6)
{
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int result; // eax

  v7 = a3 * this[18806];
  v8 = a4 * this[18807];
  *a2 = 3;
  a2[1] = 3;
  a2[2] = v7 + 7;
  a2[3] = v8 + 6;
  if ( a5 )
  {
    v9 = (*a2 + this[2] - a2[2]) / 2;
    a2[2] += v9;
    *a2 += v9;
  }
  if ( a6 )
    sub_405680(this[300], *a2, a2[1], a2[2], a2[3], this[40 * (this[2548] & 0x7F) + 13702]);
  (*(void (__thiscall **)(_DWORD *, _DWORD, int, int, int, int))(*this + 96))(this, this[300], *a2, a2[1], a2[2], a2[3]);
  sub_405BC0(this[300], *a2, a2[2], this[18807] + a2[1] + 1, this[40 * (this[2548] & 0x7F) + 13687]);
  sub_405330(this[300]);
  v10 = a2[2];
  v11 = a2[1] + 1;
  result = a2[3] - 1;
  *a2 += 2;
  a2[1] = v11;
  a2[2] = v10 - 2;
  a2[3] = result;
  return result;
}

//----- (0042BED0) --------------------------------------------------------
int __thiscall sub_42BED0(_DWORD *this, char *a2, int a3, int a4)
{
  char *v5; // esi
  int v6; // ecx
  int v7; // edi
  int v8; // edx
  char *i; // ebp
  char v10; // al
  bool v11; // zf
  int v12; // ebp
  int v13; // edi
  int v14; // edx
  char *v15; // eax
  int v16; // ecx
  char v17; // al
  int result; // eax
  int v19; // [esp+2Ch] [ebp-14h]
  int v20; // [esp+2Ch] [ebp-14h]
  int v21[4]; // [esp+30h] [ebp-10h] BYREF
  int v22; // [esp+44h] [ebp+4h]
  int v23; // [esp+4Ch] [ebp+Ch]

  v5 = a2;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v19 = 0;
  for ( i = a2; ; ++i )
  {
    v10 = *i;
    if ( *i >= 32 )
      ++v6;
    if ( v10 == 10 || !v10 )
    {
      if ( v7 < v6 )
        v7 = v6;
      v6 = 0;
      ++v8;
      if ( !v10 )
        break;
    }
LABEL_11:
    ;
  }
  v11 = v19++ == 0;
  if ( v11 )
  {
    i = (char *)(a3 - 1);
    goto LABEL_11;
  }
  (*(void (__thiscall **)(_DWORD *, int *, int, int, int, int))(*this + 268))(this, v21, v7, v8, a4, 1);
  v12 = v21[0];
  v13 = v21[1];
  v14 = v21[0];
  v20 = 0;
  v23 = 1;
  v22 = v21[0];
  v15 = v5;
  v16 = v21[0];
  while ( 1 )
  {
    while ( 1 )
    {
      while ( *v5 >= 32 )
      {
        v14 += this[18806];
        ++v5;
        v22 = v14;
      }
      if ( v15 != v5 )
      {
        (*(void (__thiscall **)(_DWORD *, int, int, char *, int, int, int))(*this + 236))(
          this,
          v16,
          v13,
          v15,
          v23,
          v5 - v15,
          1);
        v12 = v21[0];
        v14 = v22;
      }
      v17 = *v5;
      if ( *v5 < 1 || v17 > 8 )
        break;
      v16 = v14;
      v23 = v17 - 1;
      v15 = ++v5;
    }
    if ( v17 == 10 || !v17 )
    {
      v13 += this[18807];
      v14 = v12;
      v22 = v12;
      if ( !v17 )
        break;
    }
LABEL_25:
    v15 = v5 + 1;
    v16 = v14;
    ++v5;
  }
  result = v20 + 1;
  v11 = v20++ == 0;
  if ( v11 )
  {
    v13 += 2;
    v5 = (char *)(a3 - 1);
    goto LABEL_25;
  }
  return result;
}

//----- (0042C050) --------------------------------------------------------
BOOL __thiscall sub_42C050(_DWORD *this)
{
  int v2; // esi

  this[5776] = sub_412170() / 0xAu;
  (*(void (__thiscall **)(_DWORD *))(*this + 240))(this);
  (*(void (__thiscall **)(_DWORD *))(*this + 84))(this);
  v2 = this[354];
  return v2 != 1 && v2 != 2;
}

//----- (0042C0A0) --------------------------------------------------------
void __thiscall sub_42C0A0(_DWORD *this, int a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // esi
  int v6; // eax
  int v7; // [esp+10h] [ebp-4h]

  v2 = this[8];
  if ( v2 <= 60 )
  {
    if ( this[13] )
    {
      v3 = (_DWORD *)this[3];
      if ( v3[5776] - this[9] < 1500 )
      {
        v4 = this[1];
        v5 = this[2];
        if ( v4 >= v3[359] && v4 < v3[361] && v5 >= v3[360] && v5 < v3[362] )
        {
          if ( v2 > 0 || (v7 = 0, this[14] <= v3[3047]) )
            v7 = 10;
          v6 = (unsigned __int64)(1717986919i64 * (int)v3[5776]) >> 32;
          (*(void (__thiscall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)a2 + 184))(
            a2,
            this[1] / 1000,
            this[2] / 1000,
            v7 + (int)(((unsigned int)v6 >> 31) + (v6 >> 1)) % 10,
            13,
            0);
        }
      }
    }
  }
}

//----- (0042C1A0) --------------------------------------------------------
int __userpurge sub_42C1A0@<eax>(int *a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int *v5; // edi
  int v6; // kr00_4
  int v7; // edx
  _BYTE *v8; // eax
  int v9; // edx
  int v10; // ebp
  int v11; // ecx
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  int v16; // [esp+0h] [ebp-24h]

  v5 = a1 + 4956;
  v6 = a1[2];
  v7 = *a1;
  v8 = (_BYTE *)a1[302];
  a1[4966] = v6 / 2 - 64;
  LOBYTE(a2) = v8[8069];
  v16 = a2;
  LOBYTE(a2) = v8[8232];
  LOBYTE(v8) = v8[8056];
  (*(void (__thiscall **)(int *, int *, int *, int, int, int, _BYTE *, int, int))(v7 + 104))(
    a1,
    a1 + 4956,
    a1 + 4968,
    v6 / 2 - 64,
    a3,
    a4,
    v8,
    a2,
    v16);
  v9 = a1[4966];
  a1[4958] = 0;
  v10 = a1[3];
  a1[4959] = 0;
  a1[4960] = v9;
  v11 = v10 - v9 - 6;
  a1[4961] = v9;
  v12 = a1[2];
  v13 = v12 - 6;
  v14 = v12 - v9 - 6;
  a1[4962] = v14;
  a1[4963] = v11;
  a1[4964] = v13;
  a1[4965] = v10 - 6;
  (*(void (__thiscall **)(int *, int, int, int, int, int))(*a1 + 96))(a1, a1[300], v14, v11, v13, v10 - 6);
  sub_404B80(
    (_DWORD *)a1[2892],
    a1[2] - *(_DWORD *)(a1[2892] + 612),
    a1[3] - *(_DWORD *)(a1[2892] + 616) - *(_DWORD *)(a1[2893] + 616),
    1,
    0);
  sub_404B80((_DWORD *)a1[2893], a1[2] - *(_DWORD *)(a1[2893] + 612), a1[3] - *(_DWORD *)(a1[2893] + 616), 1, 0);
  sub_4057F0(*v5, a1[4962], a1[4963], *(_BYTE *)(a1[302] + 8056));
  return sub_44D900(a1, a1[2546], a1[2547], 5);
}

//----- (0042C310) --------------------------------------------------------
int __thiscall sub_42C310(char *this)
{
  int i; // esi
  int v2; // eax
  int v3; // eax
  int v4; // esi
  char *v5; // eax
  int j; // edi
  int k; // esi
  int v8; // eax
  char v9; // al
  int v10; // edx
  int *v11; // eax
  char *v12; // ebx
  int v13; // edi
  int v14; // esi
  int *v15; // edi
  int v16; // eax
  _DWORD *v17; // ebx
  int result; // eax
  int v19; // ecx
  unsigned int v20; // [esp-18h] [ebp-394h]
  int v21; // [esp+0h] [ebp-37Ch] BYREF
  char v22[96]; // [esp+Ch] [ebp-370h] BYREF
  char v23[164]; // [esp+6Ch] [ebp-310h] BYREF
  int v24[101]; // [esp+110h] [ebp-26Ch] BYREF
  int v25[41]; // [esp+2A4h] [ebp-D8h] BYREF
  int v26[6]; // [esp+348h] [ebp-34h] BYREF
  int v27; // [esp+360h] [ebp-1Ch]
  char *v28; // [esp+364h] [ebp-18h]
  int v29; // [esp+368h] [ebp-14h]
  int *v30; // [esp+36Ch] [ebp-10h]
  int v31; // [esp+378h] [ebp-4h]
  int savedregs; // [esp+37Ch] [ebp+0h] BYREF

  v28 = this;
  v30 = &v21;
  for ( i = 0; ; ++i )
  {
    v27 = i;
    if ( i >= 2 )
      break;
    v24[0] = -1;
    v31 = 0;
    if ( i )
    {
      v29 = 9353776;
      v2 = 9353776 - ((_DWORD)&loc_43E96F + 1);
    }
    else
    {
      v29 = 9353760;
      v2 = 9353760 - ((_DWORD)&loc_43E96F + 1);
    }
    sub_4077F0(v24, v2);
    while ( v24[0] != -1 )
    {
      if ( (unsigned int)sub_407910(v24) <= 0x2710 && strlen(sub_4078F0((char *)v24)) < 0x3F )
      {
        LOBYTE(v31) = 1;
        if ( i )
        {
          v29 = 9336551;
          v3 = 9336551 - ((_DWORD)&locret_43EDD1 + 2);
        }
        else
        {
          v29 = 9354875;
          v3 = 9354875 - ((_DWORD)&locret_43EDD1 + 2);
        }
        v4 = v3;
        v5 = sub_4078F0((char *)v24);
        sub_407960(v22, v4, v5);
        sub_409050(v26, (int)&savedregs, v22);
        LOBYTE(v31) = 2;
        for ( j = 0; j < 8; ++j )
        {
          for ( k = 0; k < 12; ++k )
          {
            v8 = sub_40A220(v26, (int)&savedregs, k, j);
            v9 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*((_DWORD *)v28 + 25) + 117716) + 272))(
                   *(_DWORD *)(*((_DWORD *)v28 + 25) + 117716),
                   v8);
            v10 = k + 12 * j;
            *((_BYTE *)v25 + v10) = v9;
          }
        }
        strcpy((char *)&v25[24], sub_4078F0((char *)v24));
        v25[40] = *(_DWORD *)(*((_DWORD *)v28 + 25) + 23104);
        v11 = (int *)sub_455620((int)(v28 + 104), (int)&savedregs, *((_DWORD *)v28 + 28));
        LOBYTE(v31) = 1;
        qmemcpy(v11, v25, 0xA4u);
        sub_4090C0(v26);
        i = v27;
        v31 = 0;
      }
      sub_407820(v24);
    }
    v31 = -1;
    sub_4077D0(v24);
  }
  v12 = v28 + 104;
  qsort(*((void **)v28 + 26), *((_DWORD *)v28 + 28), 0xA4u, sub_414F60);
  v29 = 9358813;
  strcpy((char *)&v25[24], (const char *)(9358813 - ((_DWORD)&loc_43FD44 + 1)));
  memset(v25, 0, 0x60u);
  v13 = *((_DWORD *)v12 + 2);
  v25[40] = *(_DWORD *)(*((_DWORD *)v28 + 25) + 23104);
  if ( v13 >= *((_DWORD *)v12 + 1) )
  {
    if ( v13 >= 8 )
      v14 = v13 >= 32 ? 32 : 8;
    else
      v14 = 4;
    sub_40B780(164 * (v13 + v14), (void **)v12, (int)&savedregs);
    *((_DWORD *)v12 + 1) += v14;
  }
  sub_46CAB0(
    *(_DWORD *)v12 + 4 * (v13 + 8 * (5 * v13 + 5) + 1),
    (_BYTE *)(*(_DWORD *)v12 + 164 * v13),
    164 * *((_DWORD *)v12 + 2) - 164 * v13);
  v20 = 164 * v13 + *(_DWORD *)v12;
  ++*((_DWORD *)v12 + 2);
  sub_46CAB0(v20, v23, 0xA4u);
  v15 = (int *)(164 * v13 + *(_DWORD *)v12);
  v29 = 9359916;
  qmemcpy(v15, v25, 0xA4u);
  strcpy(v28 + 12, (const char *)(v29 - ((_DWORD)&loc_4401B3 + 1)));
  v16 = 0;
  v17 = (_DWORD *)(&loc_40F9D9 + 3);
  do
    v16 -= *v17++;
  while ( v17 < (_DWORD *)((char *)&loc_40FB36 + 2) );
  result = v16 + 1381668001;
  v19 = (int)v28;
  *(_DWORD *)&v28[result + 314440] = *((_DWORD *)v28 + 28);
  *(_BYTE *)(v19 + 96) = 1;
  return result;
}

//----- (0042C690) --------------------------------------------------------
char __thiscall sub_42C690(int this, int *a2)
{
  int *v3; // edi
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  unsigned __int16 v7; // ax
  int v8; // ebx
  bool v9; // zf
  struct tm *v10; // eax
  char v11; // dl
  int v12; // ecx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int *v18; // eax
  int v19; // ecx
  int v20; // ebx
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // edx
  int v26; // edx
  int v27; // edx
  int v28; // eax
  int v29; // ecx
  int v30; // eax
  int v31; // eax
  char v32; // al
  int v33; // edx
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  bool v39; // cc
  int v40; // ebx
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  int v44; // ecx
  int v45; // eax
  int v46; // ebx
  int v47; // eax
  int v48; // ecx
  int v49; // eax
  int v50; // edx
  __int16 v51; // ax
  int v52; // eax
  _DWORD *v53; // esi
  _DWORD *v54; // ecx
  char v56[64]; // [esp+Ch] [ebp-A4h] BYREF
  char Buffer[32]; // [esp+4Ch] [ebp-64h] BYREF
  int v58; // [esp+6Ch] [ebp-44h]
  int v59; // [esp+70h] [ebp-40h]
  int v60; // [esp+74h] [ebp-3Ch]
  int v61; // [esp+78h] [ebp-38h]
  int v62; // [esp+7Ch] [ebp-34h]
  int v63; // [esp+80h] [ebp-30h]
  int v64; // [esp+84h] [ebp-2Ch]
  int v65; // [esp+88h] [ebp-28h]
  int v66; // [esp+8Ch] [ebp-24h] BYREF
  int v67; // [esp+90h] [ebp-20h]
  int v68; // [esp+94h] [ebp-1Ch]
  int v69; // [esp+98h] [ebp-18h]
  int v70; // [esp+9Ch] [ebp-14h]
  int v71; // [esp+A0h] [ebp-10h]
  int v72; // [esp+A4h] [ebp-Ch] BYREF
  int v73; // [esp+A8h] [ebp-8h]
  __time32_t Time; // [esp+ACh] [ebp-4h] BYREF
  int v75; // [esp+B8h] [ebp+8h]
  int v76; // [esp+B8h] [ebp+8h]
  int v77; // [esp+B8h] [ebp+8h]
  int v78; // [esp+B8h] [ebp+8h]
  bool v79; // [esp+BBh] [ebp+Bh]

  if ( *(_BYTE *)(this + 113557) )
  {
    v3 = a2;
    a2[18825] = -1;
    a2[18824] = -1;
    a2[18827] = -1;
    a2[18826] = -1;
    (*(void (__thiscall **)(int *, _DWORD, _DWORD))(*a2 + 100))(a2, *(_DWORD *)(this + 120528), 0);
    v4 = *(_DWORD *)(this + 10836);
    if ( v4 )
    {
      v73 = 8;
      Time = this + 117724;
      do
      {
        v5 = *(_DWORD *)Time;
        if ( *(_DWORD *)Time )
        {
          v6 = *(_DWORD *)(v5 + 12);
          if ( *(_DWORD *)(v6 + 23104) - *(_DWORD *)(v5 + 36) < 1500 )
          {
            if ( *(_DWORD *)(v5 + 52)
              || (v7 = *(_WORD *)(v5 + 50), v7 >= 0x400u)
              || (v8 = *(_DWORD *)(v6 + 4 * (__int16)v7 + 113620)) == 0 )
            {
              sub_44D900(v3, *(_DWORD *)(v5 + 4) / 1000, *(_DWORD *)(v5 + 8) / 1000, 3);
            }
            else
            {
              v3 = a2;
              sub_44D900(
                a2,
                *(_DWORD *)(v5 + 4) / 1000,
                *(_DWORD *)(v5 + 8) / 1000,
                (*(_DWORD *)(v8 + 88) != *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480)) + 7);
            }
          }
        }
        LOBYTE(v4) = v73 - 1;
        v9 = v73 == 1;
        Time += 4;
        --v73;
      }
      while ( !v9 );
    }
    return v4;
  }
  LOBYTE(v4) = *(_BYTE *)(this + 6280);
  if ( !(_BYTE)v4 )
    return v4;
  if ( *(_BYTE *)(*(_DWORD *)(this + 23100) + 8053) )
  {
    Time = time_0(0);
    v10 = localtime(&Time);
    v11 = 97;
    v12 = v10->tm_hour;
    if ( v12 <= 12 )
    {
      if ( v12 == 12 )
      {
        v11 = 112;
LABEL_19:
        v73 = 9371495;
        sprintf_0(Buffer, (const char *const)(9371495 - ((_DWORD)&loc_442E90 + 3)), v12, v10->tm_min, v11);
        goto LABEL_23;
      }
    }
    else
    {
      v12 -= 12;
      v11 = 112;
    }
    if ( !v12 )
      v12 = 12;
    goto LABEL_19;
  }
  Buffer[0] = 0;
LABEL_23:
  v13 = sub_455280((_DWORD *)(*(_DWORD *)(this + 2168) + 4), 16000);
  v73 = 20 * v14;
  v72 = 20 * v13;
  v15 = sub_455280(&v72, 1024);
  v73 = 9373228;
  sprintf_0(v56, (const char *const)(9373228 - ((_DWORD)&loc_443562 + 2)), Buffer, v15 + 65, v16 + 1);
  (*(void (__thiscall **)(int *, _DWORD, _DWORD, _DWORD, char *))(*a2 + 156))(
    a2,
    *(_DWORD *)(this + 120528),
    *(_DWORD *)(this + 12156),
    0,
    v56);
  (*(void (__thiscall **)(int *, int *))(*a2 + 160))(a2, &v66);
  v66 *= 1000;
  v67 *= 1000;
  v68 *= 1000;
  v18 = *(int **)(this + 2168);
  v69 *= 1000;
  if ( v18[202] > 0 )
    sub_44D900(a2, v18[105], v18[106], 2);
  v19 = *(_DWORD *)(this + 11416);
  v20 = *(_DWORD *)(this + 10912);
  v21 = 0;
  Time = 0;
  v70 = 0;
  v22 = 1000 * (0x2000 - v19);
  v23 = 200 * (5 * v19 + 40960);
  if ( v20 == 3 )
  {
    v24 = *(_DWORD *)(this + 2168);
    v59 = v22;
    v25 = *(_DWORD *)(v24 + 88);
    v60 = 16384000;
    v21 = v25 & 1;
    v70 = v21;
    Time = 1;
    v58 = 0;
    v61 = v23;
    v65 = 0;
    v64 = 0;
    v63 = 0;
    v62 = 0;
  }
  else if ( v20 == 4 )
  {
    v26 = *(_DWORD *)(this + 2168);
    v58 = 0;
    v59 = v22;
    v27 = *(_DWORD *)(v26 + 88);
    v62 = v22;
    v21 = v27 & 3;
    v70 = v21;
    Time = 3;
    v60 = 16384000;
    v61 = v23;
    v63 = 0;
    v64 = v23;
    v65 = 16384000;
  }
  v28 = *(_DWORD *)(this + 6276);
  v71 = 0;
  if ( v28 > 0 )
  {
    v73 = this + 2180;
    do
    {
      v29 = *(_DWORD *)v73;
      if ( *(_DWORD *)(*(_DWORD *)v73 + 92) == 8
        || *(_DWORD *)(v29 + 76)
        || *(int *)(v29 + 4) < 0
        || *(_DWORD *)(v29 + 28) != -1
        || (*(_BYTE *)(v29 + 96) & 0x40) != 0 && !*(_BYTE *)(v29 + 156) )
      {
        goto LABEL_67;
      }
      v30 = *(_DWORD *)(v29 + 4);
      if ( v30 < v66 )
        goto LABEL_67;
      if ( v30 >= v68 )
        goto LABEL_67;
      v31 = *(_DWORD *)(v29 + 8);
      if ( v31 < v67 || v31 >= v69 )
        goto LABEL_67;
      v32 = *(_BYTE *)(v29 + 364);
      if ( *(_BYTE *)(v29 + 365) )
      {
        v75 = 5 - (v32 != 0);
      }
      else
      {
        if ( *(_DWORD *)(v29 + 88) == *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480) )
        {
          v33 = (v32 != 0) + 6;
LABEL_65:
          v75 = v33;
          goto LABEL_66;
        }
        if ( *(_BYTE *)(v29 + 368) && (*(_BYTE *)(*(_DWORD *)(this + 2168) + 96) & 4) == 0 )
          goto LABEL_67;
        v34 = *(int *)(v29 + 4) >= 8192000 ? (*(_DWORD *)(v29 + 8) < 8192000 ? 1 : 3) : *(_DWORD *)(v29 + 8) < 8192000 ? 0 : 2;
        if ( (Time & v34) != v21 )
        {
          v35 = *(_DWORD *)(v29 + 4);
          if ( v35 < v58 || v35 >= v60 || (v36 = *(_DWORD *)(v29 + 8), v36 < v59) || v36 >= v61 )
          {
            v37 = *(_DWORD *)(v29 + 4);
            if ( v37 < v62 )
              goto LABEL_67;
            if ( v37 >= v64 )
              goto LABEL_67;
            v38 = *(_DWORD *)(v29 + 8);
            if ( v38 < v63 || v38 >= v65 )
              goto LABEL_67;
          }
        }
        if ( *(_DWORD *)(this + 10804) && *(_BYTE *)(v29 + 364) )
        {
          v75 = 8;
        }
        else
        {
          if ( !*(_BYTE *)(v29 + 367) )
          {
            v33 = 11 - (*(_BYTE *)(v29 + 366) != 0);
            goto LABEL_65;
          }
          v75 = 9;
        }
      }
LABEL_66:
      sub_44D900(a2, *(_DWORD *)(v29 + 4) / 1000, *(_DWORD *)(v29 + 8) / 1000, v75);
      v21 = v70;
LABEL_67:
      v39 = ++v71 < *(_DWORD *)(this + 6276);
      v73 += 4;
    }
    while ( v39 );
  }
  v40 = 0;
  if ( *(int *)(this + 113508) > 0 )
  {
    v76 = this + 112484;
    do
    {
      sub_44D900(a2, 16 * *(_DWORD *)(*(_DWORD *)v76 + 4), 16 * *(_DWORD *)(*(_DWORD *)v76 + 8), 0);
      ++v40;
      v76 += 4;
    }
    while ( v40 < *(_DWORD *)(this + 113508) );
  }
  if ( *(_DWORD *)(*(_DWORD *)(this + 2168) + 92) != 8 || !*(_DWORD *)(this + 12420) )
  {
    v41 = *(_DWORD *)(this + 7500);
    v71 = 0;
    if ( v41 > 0 )
    {
      v77 = this + 6284;
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)v77 + 20) == *(_DWORD *)(this + 112480) + *(_DWORD *)(this + 112476) )
          sub_44D900(a2, *(_DWORD *)(*(_DWORD *)v77 + 4) / 1000, *(_DWORD *)(*(_DWORD *)v77 + 8) / 1000, 1);
        v39 = ++v71 < *(_DWORD *)(this + 7500);
        v77 += 4;
      }
      while ( v39 );
    }
  }
  v42 = *(_DWORD *)(*(_DWORD *)(this + 2168) + 92);
  if ( v42 == 8 )
  {
    v43 = *(_DWORD *)(this + 113560);
    if ( v43 < 0 )
      goto LABEL_85;
    v44 = *(_DWORD *)(this + 4 * v43 + 113620);
    if ( !v44 )
      goto LABEL_85;
    v42 = *(_DWORD *)(v44 + 92);
  }
  v45 = this + 1308 * v42 + 12508;
  if ( v45 )
  {
    v79 = *(_DWORD *)(v45 + 200) != 0;
    v46 = *(_DWORD *)(v45 + 1300) - 1;
    goto LABEL_86;
  }
LABEL_85:
  v79 = 0;
  v46 = -1;
LABEL_86:
  v47 = *(_DWORD *)(this + 7632) + *(_DWORD *)(this + 7636);
  v70 = v46;
  v71 = 0;
  if ( v47 > 0 )
  {
    v73 = this + 8692;
    while ( 1 )
    {
      v48 = *(_DWORD *)v73;
      v49 = *(_DWORD *)(*(_DWORD *)v73 + 4);
      v50 = *(_DWORD *)(*(_DWORD *)v73 + 8);
      if ( v49 >= v66 && v49 < v68 && v50 >= v67 && v50 < v69 )
      {
        v51 = *(_WORD *)(v48 + 167) & 0x1F;
        if ( v51 == 3 || v51 == 4 )
        {
          if ( !*(_DWORD *)(v48 + 16) && !*(_DWORD *)(v48 + 20) )
          {
            if ( !v79 )
              goto LABEL_119;
LABEL_118:
            sub_44D900(a2, *(_DWORD *)(v48 + 4) / 1000, *(_DWORD *)(v48 + 8) / 1000, 12);
            goto LABEL_119;
          }
          if ( *(int *)(v48 + 156) > 0
            && *(_DWORD *)(v48 + 184) == *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480) )
          {
LABEL_98:
            sub_44D900(a2, *(_DWORD *)(v48 + 4) / 1000, *(_DWORD *)(v48 + 8) / 1000, 14);
            goto LABEL_119;
          }
          if ( v46 >= 0 )
          {
            LOWORD(v50) = *(_WORD *)(v48 + 167);
            if ( (int)(((unsigned int)v50 >> 5) & 3) >= v46 )
              goto LABEL_118;
          }
        }
        else
        {
          if ( v51 == 8
            && *(int *)(v48 + 156) > 0
            && *(_DWORD *)(v48 + 184) == *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480) )
          {
            goto LABEL_98;
          }
          if ( v51 == 6 )
          {
            v52 = *(_DWORD *)(this + 4 * *(_DWORD *)(v48 + 152) + 113620);
            if ( v52 )
            {
              if ( *(_DWORD *)(v48 + 184) == *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480) )
              {
                Time = 13;
              }
              else if ( *(_DWORD *)(v48 + 124) && *(_DWORD *)(this + 10804) )
              {
                Time = 8;
              }
              else if ( *(_BYTE *)(v52 + 169) )
              {
                Time = 9;
              }
              else
              {
                Time = (*(_DWORD *)(v52 + 32) + *(_DWORD *)(v52 + 36) < *(_DWORD *)(*(_DWORD *)(this + 23100) + 8039))
                     + 10;
              }
              sub_44D900(a2, *(_DWORD *)(v48 + 4) / 1000, *(_DWORD *)(v48 + 8) / 1000, Time);
            }
          }
        }
      }
LABEL_119:
      v39 = ++v71 < *(_DWORD *)(this + 7632) + *(_DWORD *)(this + 7636);
      v73 += 4;
      if ( !v39 )
        break;
      v46 = v70;
    }
  }
  v53 = (_DWORD *)(this + 117724);
  v78 = 8;
  do
  {
    v54 = (_DWORD *)*v53;
    if ( *v53 && v54[13] && *(_DWORD *)(v54[3] + 23104) - v54[9] < 1500 )
      sub_44D900(a2, v54[1] / 1000, v54[2] / 1000, 3);
    ++v53;
    LOBYTE(v4) = --v78;
  }
  while ( v78 );
  return v4;
}
// 42CD0D: conditional instruction was optimized away because of 'eax.4==8'
// 42C87A: variable 'v14' is possibly undefined
// 42C8A2: variable 'v16' is possibly undefined

//----- (0042D030) --------------------------------------------------------
int __thiscall sub_42D030(int this)
{
  int result; // eax
  char v3; // cl
  unsigned int v4; // esi
  int v5; // ecx
  int v6; // edx
  __int16 v7; // ax
  int v8; // edx

  result = 0;
  v3 = *(_BYTE *)(this + 77);
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( !v3 )
  {
    v4 = 983040;
    v5 = 0;
    v6 = 0;
    do
    {
      v5 = __ROL4__(*(_DWORD *)v4 ^ v5, 1);
      v6 = __ROR4__(v5 ^ v6, 1);
      v4 += 4;
    }
    while ( v4 < 0xFFFC0 );
    v7 = v5 * v6;
    v8 = v6 << 16;
    LOWORD(v8) = v7 ^ v8;
    result = v5;
    *(_DWORD *)(this + 8) = v5;
    *(_DWORD *)(this + 12) = v8;
  }
  return result;
}

//----- (0042D0B0) --------------------------------------------------------
int __thiscall sub_42D0B0(_DWORD *this)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD *))(*this + 144))(this);
  this[437] = result;
  return result;
}

//----- (0042D0D0) --------------------------------------------------------
int __thiscall sub_42D0D0(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // eax
  _DWORD *i; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  _DWORD *v16; // ebx
  int v17; // edi
  _DWORD *v18; // edi
  int *v19; // eax
  int *v20; // ebx
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // eax
  int v28; // ecx
  int v29; // eax
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  _DWORD *v35; // esi
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  int v39; // eax
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  int v44; // eax
  int v45; // eax
  int v46; // eax
  int v47; // ecx
  int v48; // eax
  int v49; // edx
  int v50; // eax
  int v51; // ecx
  _DWORD *v52; // edx
  int v53; // eax
  int v54; // edx
  int v55; // eax
  int v56; // ecx
  int v57; // edi
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int v61; // ecx
  int v62; // edx
  int v63; // eax
  int v64; // eax
  int v65; // eax
  int **v66; // ebx
  int v67; // ecx
  int result; // eax
  int v69; // edi
  bool v70; // bl
  int v71; // eax
  int v72; // eax
  int v73; // eax
  int v74; // ecx
  int v75; // eax
  _DWORD *v76; // ebx
  unsigned int *v77; // eax
  int v78; // eax
  int v79; // ebx
  _DWORD *v80; // edi
  int v81; // ebx
  _DWORD *v82; // edi
  int v83; // edi
  _DWORD *v84; // ebx
  int v85; // eax
  bool v86; // dl
  int v87; // ecx
  int v88; // edi
  char v89; // bl
  char v90; // bl
  _DWORD *v91; // ecx
  bool v92; // cl
  bool v93; // cc
  int v94; // edi
  int *v95; // edx
  int v96; // eax
  int v97; // ecx
  int v98; // ecx
  _BYTE *v99; // ecx
  int *v100; // ecx
  int v101; // edi
  int v102; // ebx
  int v103; // edx
  int v104; // ecx
  int v105; // edx
  int v106; // eax
  int v107; // ebx
  int v108; // kr00_4
  int v109; // ecx
  int v110; // edx
  int v111; // eax
  int v112; // ebx
  int v113; // edx
  int v114; // eax
  int v115; // edi
  int v116; // eax
  int v117; // ecx
  int v118; // edi
  int v119; // eax
  int v120; // ecx
  int v121; // eax
  int v122; // [esp-4h] [ebp-88h]
  char v123[80]; // [esp+Ch] [ebp-78h] BYREF
  unsigned int v124; // [esp+5Ch] [ebp-28h]
  int *v125; // [esp+60h] [ebp-24h] BYREF
  unsigned int *v126; // [esp+64h] [ebp-20h]
  unsigned int v127; // [esp+68h] [ebp-1Ch]
  _DWORD *v128; // [esp+6Ch] [ebp-18h]
  int v129; // [esp+70h] [ebp-14h]
  int v130; // [esp+74h] [ebp-10h]
  int v131; // [esp+80h] [ebp-4h]
  int savedregs; // [esp+84h] [ebp+0h] BYREF
  int v133; // [esp+8Ch] [ebp+8h]
  _DWORD *v134; // [esp+8Ch] [ebp+8h]
  int v135; // [esp+8Ch] [ebp+8h]
  int v136; // [esp+8Ch] [ebp+8h]
  bool v137; // [esp+8Fh] [ebp+Bh]

  v3 = this;
  v4 = this[5776];
  v128 = this;
  if ( a2 / 100 != v4 / 100 )
  {
    this[29990] = this[29991];
    v5 = 0;
    for ( i = (_DWORD *)(&loc_423AC3 + 1); (unsigned int)i < 0x423E94; ++i )
      v5 -= *i;
    *(_DWORD *)((char *)this + v5 + 1456561238) = 0;
  }
  v7 = this[30125];
  if ( v7 )
  {
    if ( a2 - v7 < 1500 )
      goto LABEL_14;
    if ( this[30126] < 75 * this[3107] && this[354] == 5 )
    {
      v8 = this[542];
      if ( v8 )
      {
        if ( *(_DWORD *)(v8 + 92) != 8 && *(int *)(v8 + 560) <= 0 )
          (*(void (__thiscall **)(_DWORD *, int, int))(*this + 148))(this, 1, 9438785 - (_DWORD)&loc_453549);
      }
    }
  }
  v3[30126] = 0;
  v3[30125] = a2;
LABEL_14:
  ++v3[29991];
  ++v3[30126];
  v9 = a2 - v3[5776];
  v3[5776] = a2;
  v130 = v9;
  if ( v9 > 300 )
  {
    v130 = 300;
LABEL_18:
    v9 = v130;
    goto LABEL_19;
  }
  if ( v9 < 0 )
  {
    v130 = 0;
    goto LABEL_18;
  }
LABEL_19:
  dword_4C1AE4 += v3[437];
  v137 = 1;
  if ( v3[542] )
  {
    v10 = v3[354];
    if ( v10 == 5 || v10 == 6 )
      v137 = 0;
  }
  if ( v3[437] != (*(int (__thiscall **)(_DWORD *))(*v3 + 144))(v3) )
  {
    nullsub_2(aBadStatusCrc);
    (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*v3 + 252))(v3, 62, 0);
  }
  if ( !v3[30132] || v137 )
  {
    if ( v3[354] == 3 )
    {
      (*(void (__thiscall **)(_DWORD *, void *, int))(*v3 + 188))(v3, &unk_4A7DB0, 1);
      v119 = -1868245421;
      v120 = 44;
      do
        v119 ^= *(_DWORD *)&aIgnoreTxt[4 * v120-- - 452900];
      while ( v120 );
      v9 = v130;
      *(_DWORD *)((char *)v3 + v119 + 377267712) = 4;
      v3[2171] = 3276;
      v3[2172] = 16374;
    }
    (*(void (__thiscall **)(_DWORD *))(*v3 + 240))(v3);
    if ( *(_DWORD *)(a3 + 92) == 26 || *((_BYTE *)v3 + 1420) )
      *((_BYTE *)v3 + 27208) = 1;
    v121 = -8 * v9 + v3[2172];
    v3[2172] = v121;
    if ( v121 < 100 )
      v3[2172] = 16374;
    if ( !v137 )
    {
      (*(void (__thiscall **)(_DWORD *))(v3[28087] + 32))(v3 + 28087);
      (*(void (__thiscall **)(_DWORD *))(v3[27905] + 36))(v3 + 27905);
      (*(void (__thiscall **)(_DWORD *, int))(v3[28087] + 24))(v3 + 28087, a3);
      (*(void (__thiscall **)(_DWORD *, int))(v3[27905] + 16))(v3 + 27905, a3);
    }
    result = (*(int (__thiscall **)(_DWORD *))(*v3 + 84))(v3);
  }
  else
  {
    if ( *((_BYTE *)v3 + 28246) )
    {
      v11 = v3[29429];
      v12 = v3[28404];
      *((_BYTE *)v3 + 28246) = 0;
      (*(void (__thiscall **)(int, int))(*(_DWORD *)v11 + 248))(v11, v12);
    }
    if ( v3[5776] - v3[28392] >= 500 )
    {
      v13 = v3[30127];
      v3[28392] = v3[5776];
      if ( (*(unsigned __int8 (__thiscall **)(int, char *))(*(_DWORD *)v13 + 64))(v13, v123) )
        (*(void (__thiscall **)(_DWORD *, int, char *))(*v3 + 252))(v3, 61, v123);
      if ( (int)v3[30131] > 250 )
      {
        sub_40B7E0(*(_DWORD *)v3[30129]);
        sub_46CAB0(v3[30129], (_BYTE *)(v3[30129] + 4), 4 * v3[30131] - 4);
        v14 = v3[30131] - 1;
        v3[30131] = v14;
        if ( v14 )
        {
          if ( v3[30130] - v14 > 256 )
          {
            v15 = v3[30130] - 128;
            v3[30130] = v15;
            sub_40B780(4 * v15, (void **)v3 + 30129, (int)&savedregs);
          }
        }
      }
      v16 = v3 + 30129;
      v133 = v3[30131];
      if ( v133 >= v3[30130] )
      {
        v17 = sub_4558E0(v3 + 30129);
        sub_40B780(4 * (v17 + v3[30131]), (void **)v3 + 30129, (int)&savedregs);
        v3[30130] += v17;
      }
      sub_46CAB0(*v16 + 4 * v133 + 4, (_BYTE *)(*v16 + 4 * v133), 4 * (v3[30131] + 0x3FFFFFFF * v133));
      ++v3[30131];
      sub_46CAB0(*v16 + 4 * v133, &v125, 4u);
      *(_DWORD *)(*v16 + 4 * v133) = v3[542];
      v18 = (_DWORD *)v3[542];
      v19 = (int *)sub_40B720((int)&savedregs, 0x378u);
      v20 = v19;
      v125 = v19;
      v131 = 0;
      if ( v19 )
      {
        sub_42E180(v19, (int)v18);
        v21 = v18[99] + v18[100];
        v22 = dword_4C1AE4 - v21;
        v23 = v21 - (dword_4C1AE4 - v21);
        dword_4C1AE4 = v22;
        v20[100] = v22;
        v20[99] = v23;
        v24 = v18[101] + v18[102];
        v25 = dword_4C1AE4 - v24;
        v26 = v24 - (dword_4C1AE4 - v24);
        dword_4C1AE4 = v25;
        v20[102] = v25;
        v20[101] = v26;
        v27 = v18[103] + v18[104];
        v28 = dword_4C1AE4 - v27;
        v29 = v27 - (dword_4C1AE4 - v27);
        dword_4C1AE4 = v28;
        v20[104] = v28;
        v20[103] = v29;
        v20[105] = v18[105];
        v20[106] = v18[106];
        v20[107] = v18[107];
        v20[108] = v18[108];
        v20[109] = v18[109];
        v20[110] = v18[110];
        v20[111] = v18[111];
        v20[112] = v18[112];
        v30 = v18[113] + v18[114];
        v31 = dword_4C1AE4 - v30;
        v32 = v30 - (dword_4C1AE4 - v30);
        dword_4C1AE4 = v31;
        v20[114] = v31;
        v20[113] = v32;
        v20[115] = v18[115];
        v20[116] = v18[116];
        v20[117] = v18[117];
        v20[118] = v18[118];
        v20[119] = v18[119];
        sub_42E450(v20 + 120, v18 + 120);
        v20[126] = v18[126];
        v20[127] = v18[127];
        v20[128] = v18[128];
        v20[129] = v18[129];
        v33 = v18[130] + v18[131];
        v34 = dword_4C1AE4 - v33;
        dword_4C1AE4 = v34;
        v20[131] = v34;
        v20[130] = v33 - v34;
        qmemcpy(v20 + 132, v18 + 132, 0x20u);
        v35 = v18;
        v20[140] = v18[140];
        v20[141] = v18[141];
        v20[142] = v18[142];
        sub_42E450(v20 + 143, v18 + 143);
        v36 = v35[149] + v35[150];
        v37 = dword_4C1AE4 - v36;
        v38 = v36 - (dword_4C1AE4 - v36);
        dword_4C1AE4 = v37;
        v20[150] = v37;
        v20[149] = v38;
        v39 = v35[151] + v35[152];
        v40 = dword_4C1AE4 - v39;
        v41 = v39 - (dword_4C1AE4 - v39);
        dword_4C1AE4 = v40;
        v20[152] = v40;
        v20[151] = v41;
        v42 = v35[153] + v35[154];
        v43 = dword_4C1AE4 - v42;
        dword_4C1AE4 = v43;
        v20[154] = v43;
        v20[153] = v42 - v43;
        sub_42E450(v20 + 155, v18 + 155);
        v20[161] = v18[161];
        v20[162] = v18[162];
        v20[163] = v18[163];
        v20[164] = v18[164];
        v20[165] = v18[165];
        sub_42E490(v20 + 166, v18 + 166);
        v20[188] = v18[188];
        v44 = v35[189] + v35[190];
        dword_4C1AE4 -= v44;
        v45 = v44 - dword_4C1AE4;
        v20[190] = dword_4C1AE4;
        v20[189] = v45;
        v20[191] = v18[191];
        v20[192] = v18[192];
        v20[193] = v18[193];
        qmemcpy(v20 + 194, v18 + 194, 0x25u);
        v20[204] = v18[204];
        v20[205] = v18[205];
        v20[206] = v18[206];
        v20[207] = v18[207];
        v20[208] = v18[208];
        v20[209] = v18[209];
        sub_42E450(v20 + 210, v18 + 210);
        v20[216] = v18[216];
        v20[217] = v18[217];
        v20[218] = v18[218];
        v46 = v18[219] + v18[220];
        v47 = dword_4C1AE4 - v46;
        v48 = v46 - (dword_4C1AE4 - v46);
        dword_4C1AE4 = v47;
        v20[220] = v47;
        v20[219] = v48;
        v3 = v128;
        v20[221] = v18[221];
        *v20 = (int)off_4AC370;
        v20[25] = (int)&off_4AC36C;
      }
      else
      {
        v20 = 0;
      }
      v49 = v3[1876];
      v3[542] = v20;
      v50 = 0;
      v131 = -1;
      v3[v49 + 28405] = v20;
      v51 = v3[1569];
      if ( v51 <= 0 )
      {
LABEL_46:
        v50 = -1;
      }
      else
      {
        v52 = v3 + 545;
        while ( (_DWORD *)*v52 != v18 )
        {
          ++v50;
          ++v52;
          if ( v50 >= v51 )
            goto LABEL_46;
        }
      }
      v3[v50 + 545] = v3[542];
      v9 = v130;
    }
    v53 = v3[29445];
    if ( v53 > 0 )
      v3[29445] = v53 - v9;
    (*(void (__thiscall **)(_DWORD *))(v3[27905] + 36))(v3 + 27905);
    if ( *(_BYTE *)(v3[5775] + 5973) )
    {
      (*(void (__thiscall **)(int))(*(_DWORD *)a3 + 28))(a3);
    }
    else
    {
      *(_DWORD *)(a3 + 836) = 0;
      *(_DWORD *)(a3 + 832) = 0;
    }
    if ( !*((_BYTE *)v3 + 111912) && !*((_BYTE *)v3 + 112200) || !*(_DWORD *)(a3 + 356) )
    {
      (*(void (__thiscall **)(_DWORD *, int))(v3[30023] + 24))(v3 + 30023, a3);
      (*(void (__thiscall **)(_DWORD *, int))(v3[438] + 24))(v3 + 438, a3);
      (*(void (__thiscall **)(_DWORD *, int))(v3[1879] + 24))(v3 + 1879, a3);
      (*(void (__thiscall **)(_DWORD *, int))(v3[5746] + 24))(v3 + 5746, a3);
    }
    (*(void (__thiscall **)(_DWORD *, int))(*v3 + 352))(v3, a3);
    v54 = v3[28087];
    *((_BYTE *)v3 + 113557) = *(_BYTE *)(a3 + 33);
    (*(void (__thiscall **)(_DWORD *, int))(v54 + 24))(v3 + 28087, a3);
    (*(void (__thiscall **)(_DWORD *, int))(v3[27905] + 16))(v3 + 27905, a3);
    if ( *((_BYTE *)v3 + 1420) && (*(unsigned __int8 (__thiscall **)(_DWORD))(*(_DWORD *)v3[542] + 108))(v3[542]) )
    {
      v55 = *v3;
      *((_BYTE *)v3 + 27208) = 1;
      (*(void (__thiscall **)(_DWORD *, _DWORD))(v55 + 436))(v3, 0);
    }
    v56 = v3[542];
    v57 = v130;
    v58 = *(_DWORD *)(v56 + 560);
    if ( v58 > 0 )
    {
      *(_DWORD *)(v56 + 560) = v58 - v130;
      v59 = v3[542];
      if ( *(int *)(v59 + 560) <= 0 )
      {
        *(_DWORD *)(v59 + 560) = 1;
        v60 = 61335318;
        v61 = 223;
        do
          v60 ^= *(_DWORD *)&a08x_0[4 * v61-- - 611844];
        while ( v61 );
        v62 = *(_DWORD *)((char *)v3 + v60 + 389572392);
        *((_BYTE *)v3 + v60 + 389599600) = 1;
        (*(void (__stdcall **)(_DWORD))(v62 + 436))(0);
        *(_DWORD *)(v3[542] + 560) = 0;
      }
    }
    v63 = v3[30141];
    if ( v63 > 0 )
    {
      v64 = v63 - v57;
      v3[30141] = v64;
      if ( v64 <= 0 )
      {
        v65 = 0;
        v66 = &off_40FADC;
        do
          v65 -= (int)*v66++;
        while ( v66 < (int **)sub_40FCDC );
        v67 = *(_DWORD *)(*(_DWORD *)((char *)v3 + v65 + 25837771) + 312);
        (*(void (__thiscall **)(int))(*(_DWORD *)v67 + 28))(v67);
      }
    }
    if ( v57 )
    {
      (*(void (__thiscall **)(_DWORD *, _DWORD))(*v3 + 88))(v3, 0);
      v69 = 0;
      if ( v130 <= 0 )
      {
LABEL_108:
        v135 = 0;
        if ( (int)v3[1569] > 0 )
        {
          v128 = v3 + 545;
          do
          {
            v85 = *v128;
            v86 = (*(_BYTE *)(v3[542] + 96) & 4) != 0;
            v125 = *(int **)(v3[5775] + 8039);
            if ( *(_BYTE *)(v85 + 156) || (v87 = *(_DWORD *)(v85 + 24), v88 = v3[28390], v129 = 0, v87 == v88) )
              v129 = 1;
            v89 = *(_BYTE *)(v85 + 96);
            *(_BYTE *)(v85 + 365) = v129;
            v90 = v89 & 1;
            v91 = (_DWORD *)(*(_DWORD *)(v85 + 12) + 112476);
            *(_BYTE *)(v85 + 368) = v90;
            if ( *(_DWORD *)(v85 + 88) == *v91 + v91[1] || (_BYTE)v129 || !v90 || v86 )
            {
              *(_BYTE *)(v85 + 366) = *(_DWORD *)(v85 + 32) + *(_DWORD *)(v85 + 36) >= (int)v125;
              v92 = *(_DWORD *)(v85 + 48) + *(_DWORD *)(v85 + 52) || *(int *)(v85 + 40) >= 0;
              *(_BYTE *)(v85 + 364) = v92;
              *(_BYTE *)(v85 + 367) = *(_BYTE *)(v85 + 169);
            }
            else
            {
              *(_BYTE *)(v85 + 366) = 0;
              *(_BYTE *)(v85 + 364) = 0;
              *(_BYTE *)(v85 + 367) = 0;
            }
            v93 = ++v135 < v3[1569];
            ++v128;
          }
          while ( v93 );
        }
        v94 = 0;
        v136 = 0;
        if ( (int)v3[1569] > 0 )
        {
          v95 = v3 + 545;
          do
          {
            v96 = *v95;
            v97 = *(_DWORD *)(*v95 + 160) + *(_DWORD *)(*v95 + 164);
            *(_BYTE *)(*v95 + 168) = 0;
            if ( v97 > v94 )
            {
              v94 = v97;
              v125 = (int *)v96;
            }
            v98 = *(_DWORD *)(v96 + 28);
            if ( v98 != -1 )
            {
              v99 = (_BYTE *)v3[v98 + 28405];
              if ( v99 )
              {
                v99[365] |= *(_BYTE *)(v96 + 365);
                v99[368] &= *(_BYTE *)(v96 + 368);
                v99[366] |= *(_BYTE *)(v96 + 366);
                v99[364] |= *(_BYTE *)(v96 + 364);
                v99[367] |= *(_BYTE *)(v96 + 367);
              }
            }
            ++v95;
            ++v136;
          }
          while ( v136 < v3[1569] );
          if ( v94 )
            *((_BYTE *)v125 + 168) = 1;
        }
        v100 = (int *)v3[542];
        v101 = v100[4] / 10;
        v102 = v100[5] / 10;
        v103 = (unsigned __int64)(274877907i64 * v100[1]) >> 32;
        v104 = v100[2];
        v124 = ((unsigned int)v103 >> 31) + (v103 >> 6);
        (*(void (__thiscall **)(_DWORD, unsigned int, int, int, int))(*(_DWORD *)v3[30019] + 12))(
          v3[30019],
          v124,
          v104 / 1000,
          v101,
          v102);
        (*(void (__thiscall **)(_DWORD *))(v3[28087] + 32))(v3 + 28087);
        (*(void (__thiscall **)(_DWORD *, int, int))(*v3 + 300))(v3, v130, a3);
        v105 = (unsigned __int64)(274877907i64 * *(int *)(v3[542] + 8)) >> 32;
        v106 = v3[7062];
        v3[2171] = *(_DWORD *)(v3[542] + 4) / 1000;
        v3[2172] = ((unsigned int)v105 >> 31) + (v105 >> 6);
        v107 = v106 / 2;
        v108 = v3[7063];
        v109 = 1000 * (v3[2171] - v106 / 2 - 80);
        v110 = 1000 * (v3[2172] - v108 / 2 - 80);
        v111 = 125 * (v3[2172] + v108 / 2 + 80);
        v112 = 1000 * (v3[2171] + v107 + 80);
        v3[359] = v109;
        v3[360] = v110;
        v113 = v3[542];
        v3[361] = v112;
        v3[362] = 8 * v111;
        v114 = *(_DWORD *)(v113 + 772);
        if ( v114 > 0 )
        {
          v115 = v114 / 4 + 4;
          v124 = rand() % v115 - v115 / 2;
          v116 = rand();
          v117 = v130;
          v118 = v116 % v115 - v115 / 2 + v3[2172];
          v3[2171] += v124;
          v3[2172] = v118;
          *(_DWORD *)(v3[542] + 772) -= v117;
        }
      }
      else
      {
        while ( 1 )
        {
          v125 = (int *)(v69 + 1);
          v70 = v69 + 1 >= v130;
          if ( v69 + 1 >= v130 && *(_DWORD *)(v3[542] + 92) != 8 )
            (*(void (__thiscall **)(_DWORD *, int, int))(*v3 + 176))(v3, v130, a3);
          if ( !v69 )
          {
            (*(void (__thiscall **)(_DWORD *))(*v3 + 240))(v3);
            if ( !v3[30132] )
              break;
            if ( !v3[542] )
              break;
            v71 = v3[354];
            if ( v71 != 5 && v71 != 6 )
              break;
          }
          v72 = v3[542];
          if ( *(_DWORD *)(v72 + 92) != 8 )
          {
            v73 = *(_DWORD *)(v72 + 88);
            v74 = dword_4C1AE4 - v73;
            v75 = v73 - (dword_4C1AE4 - v73);
            dword_4C1AE4 = v74;
            v3[28120] = v74;
            v3[28119] = v75;
          }
          if ( v70 || !*((_BYTE *)v3 + 117788) )
            (*(void (__thiscall **)(_DWORD *, int))(*v3 + 104))(v3, 1);
          (*(void (__thiscall **)(_DWORD *, int))(*v3 + 220))(v3, 1);
          (*(void (__thiscall **)(_DWORD *, int))(*v3 + 416))(v3, 1);
          (*(void (__thiscall **)(_DWORD *))(*v3 + 184))(v3);
          if ( !v69 && (int)v3[2170] > 0 )
          {
            v76 = v3 + 1914;
            v129 = 0;
            v134 = v3 + 1914;
            do
            {
              if ( !(*(unsigned __int8 (__thiscall **)(_DWORD, int))(*(_DWORD *)*v134 + 12))(*v134, v130) )
              {
                v128 = (_DWORD *)v129;
                v129 -= 0x3FFFFFFF;
                v127 = 4 * v69;
                --v134;
                v77 = &v76[v69--];
                v126 = v77;
                sub_40B7E0(*v77);
                sub_46CAB0((unsigned int)v126, &v76[v127 / 4 + 1], 4 * ((_DWORD)v128 + v3[2170] + 0x3FFFFFFF));
                --v3[2170];
              }
              v78 = v3[2170];
              ++v69;
              v129 += 0x3FFFFFFF;
              ++v134;
            }
            while ( v69 < v78 );
          }
          v79 = 0;
          if ( (int)v3[1569] > 0 )
          {
            v80 = v3 + 545;
            do
            {
              if ( *(_DWORD *)(*v80 + 28) == -1 )
                (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v80 + 68))(*v80, 1);
              ++v79;
              ++v80;
            }
            while ( v79 < v3[1569] );
          }
          v81 = 0;
          if ( (int)v3[1569] > 0 )
          {
            v82 = v3 + 545;
            do
            {
              if ( *(_DWORD *)(*v82 + 28) != -1 )
                (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v82 + 68))(*v82, 1);
              ++v81;
              ++v82;
            }
            while ( v81 < v3[1569] );
          }
          (*(void (__thiscall **)(_DWORD *))(*v3 + 92))(v3);
          v83 = 0;
          if ( v3[1908] + v3[1909] > 0 )
          {
            v84 = v3 + 2173;
            do
            {
              if ( (*(unsigned __int8 (__thiscall **)(_DWORD, int))(*(_DWORD *)*v84 + 12))(*v84, 1) )
              {
                v122 = v83--;
                --v84;
                (*(void (__thiscall **)(_DWORD *, int))(*v3 + 444))(v3, v122);
              }
              ++v83;
              ++v84;
            }
            while ( v83 < v3[1909] + v3[1908] );
          }
          v69 = (int)v125;
          if ( (int)v125 >= v130 )
            goto LABEL_108;
        }
      }
      (*(void (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
      result = (*(int (__thiscall **)(_DWORD *))(*v3 + 84))(v3);
    }
    else
    {
      result = (*(int (__thiscall **)(_DWORD *))(*v3 + 84))(v3);
    }
  }
  return result;
}
// 42D16C: conditional instruction was optimized away because of 'eax.4!=0'
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 40FADC: using guessed type int *off_40FADC;
// 40FCDC: using guessed type int __stdcall sub_40FCDC(int);
// 4AC36C: using guessed type int (*off_4AC36C)();
// 4AC370: using guessed type int (__stdcall *off_4AC370[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0042E180) --------------------------------------------------------
_DWORD *__thiscall sub_42E180(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  int v3; // ecx
  int v4; // esi
  int v5; // ecx
  int v6; // ecx
  int v7; // esi
  int v8; // ecx
  int v9; // ebp
  int v10; // ecx
  int v11; // esi
  int v12; // ecx

  result = this;
  this[1] = *(_DWORD *)(a2 + 4);
  this[2] = *(_DWORD *)(a2 + 8);
  this[3] = *(_DWORD *)(a2 + 12);
  *this = &off_4AC49C;
  this[4] = *(_DWORD *)(a2 + 16);
  this[5] = *(_DWORD *)(a2 + 20);
  *this = off_4AD124;
  this[6] = *(_DWORD *)(a2 + 24);
  this[7] = *(_DWORD *)(a2 + 28);
  v3 = *(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 36);
  v4 = dword_4C1AE4 - v3;
  v5 = v3 - (dword_4C1AE4 - v3);
  dword_4C1AE4 = v4;
  result[9] = v4;
  result[8] = v5;
  result[10] = *(_DWORD *)(a2 + 40);
  result[11] = *(_DWORD *)(a2 + 44);
  v6 = *(_DWORD *)(a2 + 48) + *(_DWORD *)(a2 + 52);
  v7 = dword_4C1AE4 - v6;
  v8 = v6 - (dword_4C1AE4 - v6);
  dword_4C1AE4 = v7;
  result[12] = v8;
  result[13] = v7;
  *((_WORD *)result + 28) = *(_WORD *)(a2 + 56);
  *((_BYTE *)result + 58) = *(_BYTE *)(a2 + 58);
  result[15] = *(_DWORD *)(a2 + 60);
  result[16] = *(_DWORD *)(a2 + 64);
  result[17] = *(_DWORD *)(a2 + 68);
  result[18] = *(_DWORD *)(a2 + 72);
  result[19] = *(_DWORD *)(a2 + 76);
  result[20] = *(_DWORD *)(a2 + 80);
  *((_BYTE *)result + 84) = *(_BYTE *)(a2 + 84);
  result[22] = *(_DWORD *)(a2 + 88);
  result[23] = *(_DWORD *)(a2 + 92);
  *((_BYTE *)result + 96) = *(_BYTE *)(a2 + 96);
  *result = off_4AC484;
  if ( a2 )
    v9 = a2 + 100;
  else
    v9 = 0;
  result[26] = *(_DWORD *)(v9 + 4);
  *((_BYTE *)result + 108) = *(_BYTE *)(v9 + 8);
  qmemcpy((char *)result + 109, (const void *)(v9 + 9), 0x21u);
  result[36] = *(_DWORD *)(v9 + 44);
  result[37] = *(_DWORD *)(v9 + 48);
  result[38] = *(_DWORD *)(v9 + 52);
  *((_BYTE *)result + 156) = *(_BYTE *)(v9 + 56);
  result[40] = *(_DWORD *)(v9 + 60);
  result[41] = *(_DWORD *)(v9 + 64);
  *((_BYTE *)result + 168) = *(_BYTE *)(v9 + 68);
  *((_BYTE *)result + 169) = *(_BYTE *)(v9 + 69);
  qmemcpy((char *)result + 170, (const void *)(v9 + 70), 0x20u);
  result[51] = *(_DWORD *)(v9 + 104);
  result[52] = *(_DWORD *)(v9 + 108);
  result[53] = *(_DWORD *)(v9 + 112);
  result[54] = *(_DWORD *)(v9 + 116);
  qmemcpy(result + 55, (const void *)(v9 + 120), 0x60u);
  result[25] = off_4AC428;
  result[79] = *(_DWORD *)(a2 + 316);
  result[80] = *(_DWORD *)(a2 + 320);
  result[81] = *(_DWORD *)(a2 + 324);
  result[82] = *(_DWORD *)(a2 + 328);
  result[83] = *(_DWORD *)(a2 + 332);
  v10 = *(_DWORD *)(a2 + 336) + *(_DWORD *)(a2 + 340);
  v11 = dword_4C1AE4 - v10;
  v12 = v10 - (dword_4C1AE4 - v10);
  dword_4C1AE4 = v11;
  result[84] = v12;
  result[85] = v11;
  result[86] = *(_DWORD *)(a2 + 344);
  result[87] = *(_DWORD *)(a2 + 348);
  *((_WORD *)result + 176) = *(_WORD *)(a2 + 352);
  result[89] = *(_DWORD *)(a2 + 356);
  result[90] = *(_DWORD *)(a2 + 360);
  *((_BYTE *)result + 364) = *(_BYTE *)(a2 + 364);
  *((_BYTE *)result + 365) = *(_BYTE *)(a2 + 365);
  *((_BYTE *)result + 366) = *(_BYTE *)(a2 + 366);
  *((_BYTE *)result + 367) = *(_BYTE *)(a2 + 367);
  *((_BYTE *)result + 368) = *(_BYTE *)(a2 + 368);
  result[93] = *(_DWORD *)(a2 + 372);
  result[94] = *(_DWORD *)(a2 + 376);
  result[95] = *(_DWORD *)(a2 + 380);
  result[96] = *(_DWORD *)(a2 + 384);
  result[97] = *(_DWORD *)(a2 + 388);
  result[98] = *(_DWORD *)(a2 + 392);
  *result = off_4AC430;
  result[25] = &off_4AC42C;
  return result;
}
// 4AC428: using guessed type int (*off_4AC428[2])();
// 4AC42C: using guessed type int (*off_4AC42C)();
// 4AC430: using guessed type int (__stdcall *off_4AC430[2])(int, int);
// 4AC484: using guessed type int (__stdcall *off_4AC484[2])(int, int);
// 4AC49C: using guessed type int (__stdcall *off_4AC49C)(int, int);
// 4AD124: using guessed type int (__stdcall *off_4AD124[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0042E450) --------------------------------------------------------
_DWORD *__thiscall sub_42E450(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = this;
  *this = *a2;
  this[1] = a2[1];
  v3 = a2[2] + a2[3];
  v4 = dword_4C1AE4 - v3;
  v5 = v3 - (dword_4C1AE4 - v3);
  dword_4C1AE4 = v4;
  result[3] = v4;
  result[2] = v5;
  result[4] = a2[4];
  result[5] = a2[5];
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0042E490) --------------------------------------------------------
int *__thiscall sub_42E490(int *this, _DWORD *a2)
{
  int *result; // eax
  int v4; // edx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // edx
  int v12; // edx
  int v13; // edx
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // edi
  int v18; // edx
  int v19; // esi
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // esi
  int v24; // edx
  int v25; // edx
  int v26; // esi
  int v27; // edx
  int v28; // edx
  int v29; // esi
  int v30; // edx
  int v31; // esi
  int v32; // edx
  int v33; // esi
  int v34; // edx
  int v35; // esi
  int v36; // edx
  int v37; // esi

  result = this;
  v4 = *a2 + a2[1];
  dword_4C1AE4 -= v4;
  v5 = v4 - dword_4C1AE4;
  result[1] = dword_4C1AE4;
  *result = v5;
  v6 = a2[2] + a2[3];
  dword_4C1AE4 -= v6;
  v7 = v6 - dword_4C1AE4;
  result[3] = dword_4C1AE4;
  result[2] = v7;
  v8 = a2[4] + a2[5];
  dword_4C1AE4 -= v8;
  v9 = v8 - dword_4C1AE4;
  result[5] = dword_4C1AE4;
  result[4] = v9;
  v10 = a2[6] + a2[7];
  dword_4C1AE4 -= v10;
  v11 = v10 - dword_4C1AE4;
  result[7] = dword_4C1AE4;
  result[6] = v11;
  v12 = a2[8] + a2[9];
  dword_4C1AE4 -= v12;
  v13 = v12 - dword_4C1AE4;
  result[9] = dword_4C1AE4;
  result[8] = v13;
  v14 = a2[10] + a2[11];
  dword_4C1AE4 -= v14;
  v15 = v14 - dword_4C1AE4;
  result[11] = dword_4C1AE4;
  result[10] = v15;
  v16 = a2[12] + a2[13];
  v17 = dword_4C1AE4 - v16;
  dword_4C1AE4 = v17;
  result[13] = v17;
  result[12] = v16 - v17;
  v18 = a2[14] + a2[15];
  v19 = dword_4C1AE4 - v18;
  dword_4C1AE4 = v19;
  result[15] = v19;
  result[14] = v18 - v19;
  v20 = a2[16] + a2[17];
  dword_4C1AE4 -= v20;
  v21 = v20 - dword_4C1AE4;
  result[17] = dword_4C1AE4;
  result[16] = v21;
  v22 = a2[18] + a2[19];
  v23 = dword_4C1AE4 - v22;
  v24 = v22 - (dword_4C1AE4 - v22);
  dword_4C1AE4 = v23;
  result[19] = v23;
  result[18] = v24;
  v25 = result[20] ^ (a2[20] ^ result[20]) & 0x1FFFF;
  result[20] = v25;
  v26 = v25 ^ (a2[20] ^ v25) & 0x20000;
  result[20] = v26;
  v27 = v26 ^ (a2[20] ^ v26) & 0x3FFC0000;
  result[20] = v27;
  result[20] = v27 ^ (a2[20] ^ v27) & 0x40000000;
  v28 = result[21] ^ ((unsigned __int8)a2[21] ^ (unsigned __int8)result[21]) & 0x7F;
  result[21] = v28;
  v29 = v28 ^ ((unsigned __int8)a2[21] ^ (unsigned __int8)v28) & 0x80;
  result[21] = v29;
  v30 = v29 ^ ((unsigned __int16)a2[21] ^ (unsigned __int16)v29) & 0x100;
  result[21] = v30;
  v31 = v30 ^ ((unsigned __int16)a2[21] ^ (unsigned __int16)v30) & 0x200;
  result[21] = v31;
  v32 = v31 ^ ((unsigned __int16)a2[21] ^ (unsigned __int16)v31) & 0x7C00;
  result[21] = v32;
  v33 = v32 ^ ((unsigned __int16)a2[21] ^ (unsigned __int16)v32) & 0x8000;
  result[21] = v33;
  v34 = v33 ^ (a2[21] ^ v33) & 0x70000;
  result[21] = v34;
  v35 = v34 ^ (a2[21] ^ v34) & 0x80000;
  result[21] = v35;
  v36 = v35 ^ (a2[21] ^ v35) & 0x3F00000;
  result[21] = v36;
  v37 = v36 ^ (a2[21] ^ v36) & 0x4000000;
  result[21] = v37;
  result[21] = v37 ^ (a2[21] ^ v37) & 0x18000000;
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0042E6F0) --------------------------------------------------------
int __thiscall sub_42E6F0(_DWORD *this)
{
  int result; // eax
  int v3; // ecx
  int v4; // eax
  _DWORD *i; // ebx
  int v6; // ebx
  int v7; // edi
  int v8; // eax
  int v9; // edx
  int j; // edi
  int v11; // eax
  int v12; // edx
  int v13; // edi
  int v14; // ebx
  int l; // edi
  int v16; // [esp+8h] [ebp-4h]
  int k; // [esp+8h] [ebp-4h]

  result = this[20];
  if ( result )
  {
    v3 = this[2];
    if ( v3 >= 0 )
    {
      if ( v3 >= result )
        this[2] = result - 1;
    }
    else
    {
      this[2] = 0;
    }
    if ( this[2] < this[21] )
    {
      v4 = 0;
      for ( i = (_DWORD *)(&loc_426113 + 1); (unsigned int)i < 0x4264DC; ++i )
        v4 -= *i;
      *(_DWORD *)((char *)this + v4 - 529432447) = this[2];
    }
    v6 = this[21];
    v7 = this[20] - 1;
    v8 = 0;
    v16 = 0;
    if ( v6 <= v7 )
    {
      do
      {
        v9 = (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, v6++) + v16;
        v16 = v9;
      }
      while ( v6 <= v7 );
      v8 = v9;
    }
    for ( j = v8; j < this[22]; j += (*(int (__thiscall **)(_DWORD *, int))(v12 + 28))(this, v11 - 1) )
    {
      v11 = this[21];
      if ( !v11 )
        break;
      v12 = *this;
      this[21] = v11 - 1;
    }
    v13 = this[21];
    v14 = 0;
    for ( k = this[2]; v13 <= k; ++v13 )
      v14 += (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, v13);
    result = this[22];
    for ( l = v14; l > result; ++this[21] )
    {
      l -= (*(int (__thiscall **)(_DWORD *, _DWORD))(*this + 28))(this, this[21]);
      result = this[22];
    }
  }
  else
  {
    this[21] = 0;
    this[2] = 0;
  }
  return result;
}

//----- (0042E7F0) --------------------------------------------------------
void __thiscall sub_42E7F0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // edi
  int v8; // ebx
  int v9; // ebp
  int v10; // ecx
  int v11; // ecx

  v7 = a2 - *(_DWORD *)(this + 19880);
  v8 = a3 - *(_DWORD *)(this + 19884);
  v9 = (a4 + 400000) % 40;
  if ( a5 == -1 )
  {
    sub_404E20(*(_DWORD **)(this + 11508), v7, v8, (a4 + 400000) % 40, 1);
  }
  else if ( a5 >= 0 )
  {
    if ( a6
      && (v10 = *(_DWORD *)(this + 11400)) != 0
      && *(_BYTE *)(v10 + 640)
      && *(_DWORD *)(v10 + 636) >= *(_DWORD *)(*(_DWORD *)(this + 4 * a5 + 11368) + 636) )
    {
      if ( *(_DWORD *)(this + 19876) != a5 )
      {
        v11 = *(_DWORD *)(this + 11400);
        *(_DWORD *)(this + 19876) = a5;
        (*(void (__thiscall **)(int, char **))(*(_DWORD *)v11 + 20))(v11, &(&off_4AA118)[8 * a5]);
      }
      if ( a6 <= 0 )
        sub_404E20(*(_DWORD **)(this + 11400), v7, v8, v9 + 8 * (5 * a6 + 25), 1);
      else
        sub_404E20(*(_DWORD **)(this + 11400), v7, v8, v9 + 8 * (5 * a6 + 20), 1);
    }
    else
    {
      sub_404E20(*(_DWORD **)(this + 4 * a5 + 11368), v7, v8, (a4 + 400000) % 40, 1);
    }
  }
  else
  {
    sub_404E20(*(_DWORD **)(this + 11504), v7, v8, (a4 + 400000) % 40, 1);
  }
}
// 4AA118: using guessed type char *off_4AA118;

//----- (0042E920) --------------------------------------------------------
void __thiscall sub_42E920(int *this)
{
  int v2; // ecx
  int v3; // edi
  int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // edx
  int v7; // edi
  int v8; // eax
  _DWORD *v9; // ebx
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  bool v13; // zf
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp-4h]

  if ( this[23] != 8 && this[192] <= 0 )
  {
    v2 = this[17];
    v14 = (this[1] - v2) / 16000;
    v3 = (this[2] - v2) / 16000;
    v15 = (v2 + this[1]) / 16000;
    v4 = (v2 + this[2]) / 16000;
    if ( v3 <= v4 )
    {
      v5 = v3 << 10;
      v17 = v3 << 10;
      v16 = v4 - v3 + 1;
      do
      {
        v6 = v14;
        if ( v14 <= v15 )
        {
          v7 = *(_DWORD *)(this[3] + 120528);
          while ( !v7
               || v6 >= 0x400
               || v5 >= 0x100000
               || *(unsigned __int8 *)(v5 + v7 + v6) != 252
               && (*(unsigned __int8 *)(v5 + v7 + v6) < 0xA2u || *(unsigned __int8 *)(v5 + v7 + v6) > 0xA9u) )
          {
            if ( (int)++v6 > v15 )
              goto LABEL_18;
          }
          v8 = 0;
          v9 = (_DWORD *)((char *)&loc_44E13B + 1);
          do
            v8 -= *v9++;
          while ( v9 < (_DWORD *)((char *)&loc_44E503 + 1) );
          v10 = *(_DWORD *)(*(_DWORD *)(*(int *)((char *)this + v8 - 184532293) + 120076) + 240);
          (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v10 + 20))(v10, 0, 0, 0, 0);
          v11 = *this;
          v12 = rand();
          (*(void (__thiscall **)(int *, int, int, int))(v11 + 152))(this, v12, -1, -1);
          v5 = v17;
        }
LABEL_18:
        v5 += 1024;
        v13 = v16 == 1;
        v17 = v5;
        --v16;
      }
      while ( !v13 );
    }
  }
}

//----- (0042EAD0) --------------------------------------------------------
int __thiscall sub_42EAD0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  signed int v5; // ebp
  _DWORD *v6; // esi
  int v7; // edx
  int v8; // ecx
  long double v9; // st7
  double v10; // st6
  int v11; // [esp+4h] [ebp-14h]
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]

  result = 0;
  v12 = 0;
  v11 = 0;
  if ( *(int *)(this[3] + 119856) > 0 )
  {
    v5 = 1000 * abs32(a2);
    do
    {
      v6 = (_DWORD *)(*(_DWORD *)(this[3] + 119848) + 8 * v11);
      v13 = (*v6 - this[1]) / 1000;
      v7 = (v6[1] - this[2]) / 1000;
      v8 = v7 * v7 + v13 * v13 + 1;
      if ( v8 < v5 )
      {
        v9 = atan2((double)v13, (double)((v6[1] - this[2]) / 1000));
        v12 = 1000 * a2 / v8;
        v10 = (double)v12;
        this[4] += a3 * (__int64)(sin(v9) * v10);
        this[5] += a3 * (__int64)(cos(v9) * v10);
      }
      ++v11;
    }
    while ( v11 < *(_DWORD *)(this[3] + 119856) );
    result = v12;
  }
  return result;
}

//----- (0042EBF0) --------------------------------------------------------
char __thiscall sub_42EBF0(_DWORD *this, int a2, int a3)
{
  int v3; // esi
  int v4; // edi
  int *v5; // eax
  int v6; // ecx
  char v7; // al
  int v8; // edx
  int v10; // esi
  int v11; // eax
  char *v12; // eax
  unsigned __int8 *v13; // [esp-4h] [ebp-1D8h]
  int v14; // [esp+0h] [ebp-1D4h] BYREF
  char v15[260]; // [esp+Ch] [ebp-1C8h] BYREF
  char v16[4]; // [esp+110h] [ebp-C4h] BYREF
  int v17; // [esp+114h] [ebp-C0h]
  char v18[148]; // [esp+118h] [ebp-BCh] BYREF
  _DWORD pExceptionObject[2]; // [esp+1ACh] [ebp-28h] BYREF
  int v20; // [esp+1B4h] [ebp-20h]
  _DWORD *v21; // [esp+1B8h] [ebp-1Ch]
  int v22; // [esp+1BCh] [ebp-18h]
  int v23; // [esp+1C0h] [ebp-14h]
  int *v24; // [esp+1C4h] [ebp-10h]
  int v25; // [esp+1D0h] [ebp-4h]
  int savedregs; // [esp+1D4h] [ebp+0h] BYREF

  v3 = (int)this;
  v24 = &v14;
  v21 = this;
  sub_421C80(v16, a3);
  v4 = *(_DWORD *)(v3 + 4);
  v20 = v4;
  v23 = 0;
  while ( 1 )
  {
    if ( v23 >= *(_DWORD *)(v3 + 12) )
      return 0;
    if ( *(_DWORD *)(v4 + 4) == v17 && !strcmp((const char *)(v4 + 8), v18) && !*(_BYTE *)(v4 + 152) )
      break;
LABEL_17:
    v3 = (int)v21;
    v4 += 156;
    ++v23;
    v20 = v4;
  }
  v5 = *(int **)v4;
  v25 = 0;
  *(_DWORD *)(a2 + 16) = v5[1];
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(v4 + 144);
  v6 = **(_DWORD **)v4;
  if ( !v6 )
  {
    sub_407960(v15, *(_DWORD *)v4 + 8, (_BYTE *)(v4 + 8));
    v7 = *(_BYTE *)(v4 + 136);
    v22 = v4 + 136;
    if ( v7 )
    {
      strcat(v15, ".");
      strcat(v15, (const char *)v22);
    }
    sub_40CFE0((unsigned int *)a2, (int)&savedregs, v15, 0);
LABEL_10:
    v8 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 12) = v8;
    *(_BYTE *)(a2 + 24) = 1;
    return 1;
  }
  if ( v6 != 1 )
  {
    v25 = -1;
    *(_BYTE *)(v21[1] + 156 * v23 + 152) = 1;
    goto LABEL_17;
  }
  v10 = *(_DWORD *)(v4 + 140);
  v11 = *(_DWORD *)(v10 + 4);
  if ( v11 != *(_DWORD *)(v10 + 12) )
  {
    sub_40C9D0(a2, (int)&savedregs, v11 + 64);
    v13 = *(unsigned __int8 **)(v10 + 12);
    v12 = strchr((const char *)(v10 + 16), 0);
    if ( sub_412680(*(unsigned __int8 **)a2, *(_DWORD *)(a2 + 4), (unsigned __int8 *)v12 + 1, v13) != *(_DWORD *)(v10 + 4) )
    {
      v22 = 9551872;
      sub_40DA80((char *)(9551872 - ((_DWORD)&loc_46EECF + 1)));
      sub_406F10(pExceptionObject, (int)&savedregs, byte_4A7DB0);
      _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
    }
    goto LABEL_10;
  }
  *(_DWORD *)(a2 + 8) = strchr((const char *)(v10 + 16), 0) + 1;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(v10 + 4);
  *(_BYTE *)(a2 + 24) = 1;
  return 1;
}

//----- (0042EE90) --------------------------------------------------------
int __thiscall sub_42EE90(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int (__thiscall *v5)(char *, char, char *); // ebx
  int result; // eax

  if ( a3 > 0 )
    this[27] = a3;
  if ( (int)this[27] > 64 )
    this[27] = 64;
  this[22] = a2;
  if ( a2 < 2 )
    this[22] = 2;
  v3 = this[27];
  if ( this[22] > v3 )
    this[22] = v3;
  *(_DWORD *)(*(_DWORD *)(this[29] + 23100) + 8267) = this[22];
  v4 = 0;
  v5 = sub_447900;
  do
  {
    v4 -= *(_DWORD *)v5;
    v5 = (int (__thiscall *)(char *, char, char *))((char *)v5 + 4);
  }
  while ( (char *)v5 < (char *)((char *)&loc_4479DF + 1) );
  result = v4 - 1497350546;
  *((_BYTE *)this + result + 462312) = 1;
  return result;
}

//----- (0042EF10) --------------------------------------------------------
void __thiscall sub_42EF10(_DWORD *this, int a2, int a3)
{
  int v4; // ebx
  int v5; // ecx
  int v6; // kr00_4
  int v7; // ebp
  int v8; // esi
  __int16 v10; // ax
  int v11; // ecx
  int v12; // ecx
  int v13; // eax
  int v14; // [esp+10h] [ebp-1Ch]
  int v15; // [esp+14h] [ebp-18h]
  int v16; // [esp+1Ch] [ebp-10h]
  int v17; // [esp+20h] [ebp-Ch]
  int v18; // [esp+24h] [ebp-8h]
  int v19; // [esp+28h] [ebp-4h]
  int v20; // [esp+30h] [ebp+4h]

  v4 = this[27547];
  if ( v4 )
  {
    v5 = this[7062] / 2;
    v16 = this[2171] - v5;
    v6 = this[7063];
    v7 = this[2172];
    v18 = v5 + this[2171];
    v8 = this[27545];
    v17 = v7 - v6 / 2;
    v19 = v6 / 2 + v7;
    v14 = v4;
    do
    {
      if ( *(unsigned __int8 *)(v8 + 19) == a3 )
      {
        v20 = *(unsigned __int8 *)(v8 + 18);
        if ( v20 < this[1912] )
        {
          v10 = *(_WORD *)(v8 + 20);
          if ( (v10 & 0xF000u) == 0
            || (v11 = *(_DWORD *)(v8 + 8)) != 0
            && ((*(_WORD *)(v8 + 20) & 0xFFF) == 0 || this[5776] - v11 < 10 * (v10 & 0xFFF)) )
          {
            if ( (*(_BYTE *)(v8 + 12) & 1) != 0 )
            {
              v12 = *(__int16 *)(v8 + 14);
              if ( v12 < v18 && v12 + *(_DWORD *)v8 > v16 )
              {
                v13 = *(__int16 *)(v8 + 16);
                if ( v13 < v19 && v13 + *(_DWORD *)(v8 + 4) > v17 )
                  (*(void (__thiscall **)(int, int, int, int, int))(*(_DWORD *)a2 + 200))(
                    a2,
                    v12 - v16,
                    v13 - v17,
                    v20,
                    this[5776] - *(_DWORD *)(v8 + 8));
              }
            }
            else
            {
              v15 = *(_DWORD *)(a2 + 8 * (*(_WORD *)(v8 + 14) & 0xF) + 75232);
              if ( v15 >= 0 && *(int *)(a2 + 8 * (*(_WORD *)(v8 + 16) & 0xF) + 75236) >= 0 )
                (*(void (__thiscall **)(int, int, int, int, int))(*(_DWORD *)a2 + 200))(
                  a2,
                  v15 + (*(__int16 *)(v8 + 14) >> 4),
                  *(_DWORD *)(a2 + 8 * (*(_WORD *)(v8 + 16) & 0xF) + 75236) + (*(__int16 *)(v8 + 16) >> 4),
                  v20,
                  this[5776] - *(_DWORD *)(v8 + 8));
            }
          }
        }
      }
      v8 += 28;
      --v14;
    }
    while ( v14 );
  }
}
// 42EF74: conditional instruction was optimized away because of 'ebx.4!=0'

//----- (0042F0C0) --------------------------------------------------------
void __thiscall sub_42F0C0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebp
  int v8; // esi
  _DWORD *v10; // ecx

  v7 = a5;
  v8 = dword_4AAF20[a7];
  if ( a5 >= v8 )
    v7 = v8 - 1;
  v10 = (_DWORD *)this[a7 + 2858];
  sub_404E20(v10, a2 - this[4970], a3 - this[4971], v10[155] * (v7 + a6 * v8) + a4 * v10[158] / v10[157] % v10[155], 1);
}

//----- (0042F140) --------------------------------------------------------
void __thiscall sub_42F140(int this, int a2, int a3)
{
  char v3; // dl
  char *v4; // esi
  int v6; // eax
  int v7; // ecx
  unsigned __int8 *v8; // ebx
  int v9; // esi
  size_t v10; // eax
  int v11; // esi
  int *v12; // ecx
  int v13; // eax
  int v14; // ecx
  char *v15; // eax
  int v16; // [esp+0h] [ebp-68h] BYREF
  char Buffer[64]; // [esp+Ch] [ebp-5Ch] BYREF
  unsigned __int8 *v18; // [esp+4Ch] [ebp-1Ch] BYREF
  int v19; // [esp+50h] [ebp-18h]
  int v20[2]; // [esp+54h] [ebp-14h] BYREF
  int v21; // [esp+64h] [ebp-4h]
  int savedregs; // [esp+68h] [ebp+0h] BYREF

  v3 = *(_BYTE *)(a2 + 1);
  v4 = (char *)(a2 + 1);
  v20[1] = (int)&v16;
  v21 = 0;
  if ( v3 || *(_DWORD *)(this + 1416) != 3 )
  {
    *(_BYTE *)(a2 + 16) = 0;
    sub_40BCB0(v4, 92, 95);
    sub_40BCB0(v4, 47, 95);
    sub_40BCB0(v4, 58, 95);
    v19 = 9589276;
    sprintf_0(Buffer, (const char *const)(9589276 - ((_DWORD)&loc_4780C7 + 1)), v4);
    v13 = 1816002047;
    v14 = 247;
    do
      v13 ^= dword_4A9230[v14-- - 153468];
    while ( v14 );
    (*(void (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(v13 + this + 448318940) + 28))(
      v13 + this + 448318940,
      Buffer,
      0,
      0,
      0,
      1);
    v20[0] = -1;
    LOBYTE(v21) = 4;
    sub_4080D0(v20, (int)&savedregs, v4, 0, 2);
    sub_4086E0(v20, a2 + 17, a3 - 17);
    sub_4087F0(v20);
    a3 = 9591605;
    v15 = sub_40BB60(v4, (const char *)(9591605 - ((_DWORD)&loc_4789E8 + 1)));
    if ( v15 && !_strcmpi(v15, (const char *)(9591605 - ((_DWORD)&loc_4789E8 + 1))) && !*(_BYTE *)(this + 120188) )
      (*(void (__thiscall **)(int, char *))(*(_DWORD *)(this + 120092) + 32))(this + 120092, v4);
    LOBYTE(v21) = 0;
    v12 = v20;
    goto LABEL_12;
  }
  v6 = -2114919365;
  v7 = 210;
  do
    v6 ^= *(_DWORD *)&aSweden[4 * v7-- - 541744];
  while ( v7 );
  *(_BYTE *)(v6 + this + 443766455) = 1;
  v8 = (unsigned __int8 *)(a2 + 17);
  if ( *(_WORD *)(a2 + 17) != 0x9C78 )
  {
    a2 = -1;
    LOBYTE(v21) = 3;
    sub_4080D0(&a2, (int)&savedregs, (char *)(this + 1453), 0, 2);
    sub_4086E0(&a2, (int)v8, a3 - 17);
    sub_4087F0(&a2);
    LOBYTE(v21) = 0;
    v12 = &a2;
LABEL_12:
    sub_4087F0(v12);
    return;
  }
  v18 = 0;
  v19 = 0;
  v9 = a3;
  LOBYTE(v21) = 1;
  v10 = 10 * a3;
  if ( 10 * a3 > 1000000 )
    v10 = 1000000;
  sub_40C9D0((int)&v18, (int)&savedregs, v10);
  v11 = sub_412680(v18, v19, v8, (unsigned __int8 *)(v9 - 17));
  if ( v11 > 0 )
  {
    a3 = -1;
    LOBYTE(v21) = 2;
    sub_4080D0(&a3, (int)&savedregs, (char *)(this + 1453), 0, 2);
    sub_4086E0(&a3, (int)v18, v11);
    sub_4087F0(&a3);
    LOBYTE(v21) = 1;
    sub_4087F0(&a3);
  }
  LOBYTE(v21) = 0;
  sub_40C9D0((int)&v18, (int)&savedregs, 0);
}
// 4A9230: using guessed type int dword_4A9230[];

//----- (0042F3E0) --------------------------------------------------------
int __thiscall sub_42F3E0(int this, int a2, int a3)
{
  int v3; // ebp

  v3 = 7;
  if ( (*(_BYTE *)(this + 96) & 0x40) == 0 )
    v3 = *(_DWORD *)(this + 92);
  if ( *(_DWORD *)(this + 28) != -1 )
    v3 = -1;
  (*(void (__thiscall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)a2 + 168))(
    a2,
    *(_DWORD *)(this + 4) / 1000,
    *(_DWORD *)(this + 8) / 1000,
    *(_DWORD *)(this + 60) / 1000,
    v3,
    0);
  return 0;
}

//----- (0042F470) --------------------------------------------------------
int __thiscall sub_42F470(char *this, char a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  char v7[2]; // [esp+4h] [ebp-8h] BYREF
  int v8; // [esp+6h] [ebp-6h]

  v7[0] = 32;
  v7[1] = a2;
  v8 = a3;
  v4 = 1413239741;
  v5 = 235;
  do
    v4 ^= *(_DWORD *)&asc_4AFA24[4 * v5-- - 400440];
  while ( v5 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v4 + 451947408] + 16))(
           &this[v4 + 451947408],
           v7,
           6,
           1);
}

//----- (0042F4C0) --------------------------------------------------------
_DWORD *__thiscall sub_42F4C0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  __int16 v3; // ax
  _DWORD *result; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // ebx
  _DWORD *v9; // edx
  unsigned __int16 v10; // ax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  int v21; // eax

  v2 = this;
  v3 = *((_WORD *)a2 + 5);
  if ( v3 < 0 || v3 != this[16] || (result = (_DWORD *)a2[3]) != 0 )
  {
    result = (_DWORD *)this[3];
    this[16] = -1;
    this[9] = result[5776];
    if ( memcmp(this + 10, a2, 0x10u) )
    {
      v5 = a2;
      if ( a2[3] && !v2[13] && (*((_WORD *)a2 + 3) || *((_WORD *)a2 + 4)) )
      {
        (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*result + 260))(
          result,
          *(_DWORD *)(result[30019] + 296),
          v2[1],
          v2[2],
          0,
          0);
        v5 = a2;
      }
      v6 = 0;
      v2[8] = 0;
      if ( v5[3] )
        v6 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2[3] + 64))(v2[3]) - a2[3];
      v2[14] = v6;
      if ( v6 < 0 )
        v2[14] = 1;
      v7 = 0;
      v8 = (_DWORD *)((char *)&loc_44EB73 + 1);
      do
        v7 -= *v8++;
      while ( v8 < (_DWORD *)((char *)&loc_44EC9F + 1) );
      v9 = (_DWORD *)((char *)this + v7 - 1167007891);
      *v9 = *a2;
      v9[1] = a2[1];
      v9[2] = a2[2];
      v9[3] = a2[3];
      v10 = *((_WORD *)this + 25);
      v11 = 0;
      if ( v10 >= 0x400u )
      {
        v14 = this[3];
        v15 = 0;
        if ( *(int *)(v14 + 6276) > 0 )
        {
          v16 = 2180;
          do
          {
            v17 = *(_DWORD *)(v16 + v14);
            if ( *(_DWORD *)(v17 + 40) == *((unsigned __int8 *)this + 41) )
              *(_DWORD *)(v17 + 40) = -1;
            v14 = this[3];
            ++v15;
            v16 += 4;
          }
          while ( v15 < *(_DWORD *)(v14 + 6276) );
        }
      }
      else
      {
        v12 = *(_DWORD *)(this[3] + 4 * (__int16)v10 + 113620);
        if ( v12 )
        {
          v13 = *(_DWORD *)(v12 + 92);
          if ( v13 != 8 )
            v11 = v13;
        }
      }
      v18 = this[3];
      v19 = *(_DWORD *)(v18 + 1308 * v11 + 13000);
      this[15] = 1000000;
      this[7] = v19;
      v20 = 5 * *((__int16 *)this + 22);
      this[1] = 1000 * *((__int16 *)this + 21);
      this[4] = *((__int16 *)this + 23);
      this[2] = 200 * v20;
      this[5] = *((__int16 *)this + 24);
      result = (_DWORD *)this[13];
      if ( result )
      {
        v21 = (*(int (__thiscall **)(int))(*(_DWORD *)v18 + 64))(v18) - this[13];
        if ( v21 >= 0 )
        {
          if ( v21 > 6000 )
            v21 = 6000;
          result = (_DWORD *)(*(int (__thiscall **)(_DWORD *, int))(*this + 20))(this, v21);
        }
        else
        {
          result = (_DWORD *)(*(int (__thiscall **)(_DWORD *, _DWORD))(*this + 20))(this, 0);
        }
      }
    }
  }
  return result;
}

//----- (0042F730) --------------------------------------------------------
int __thiscall sub_42F730(_DWORD *this)
{
  return (this[231] + sub_412170() / 10) & 0x7FFFFFFF;
}

//----- (0042F7B0) --------------------------------------------------------
char __thiscall sub_42F7B0(char *this)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // edi
  int v5; // eax
  _DWORD *v6; // ebx
  void *v7; // edi
  char Buffer[320]; // [esp+Ch] [ebp-148h] BYREF
  int v10; // [esp+14Ch] [ebp-8h]
  int v11; // [esp+150h] [ebp-4h]

  if ( *(_BYTE *)(*((_DWORD *)this + 66) + 8284)
    && (v2 = this + 292, v11 = (int)(this + 292), v3 = strstr(this + 292, asc_4AD170), (v4 = v3) != 0)
    && *v2 == 58 )
  {
    if ( v3 == v2 )
    {
      *((_DWORD *)this + 68) = -1;
      goto LABEL_7;
    }
    if ( !memchr(this + 293, 58, v3 - this - 293) )
    {
      do
      {
LABEL_7:
        v5 = 0;
        v6 = &loc_44E4C0;
        do
          v5 -= *v6++;
        while ( v6 < (_DWORD *)&loc_44E868 );
        *(_DWORD *)&this[v5 + 877497703] = (*((_DWORD *)this + 68) + 1) % 5u;
      }
      while ( !*(_BYTE *)(*((_DWORD *)this + 66) + 24 * *((_DWORD *)this + 68) + 8284) );
      v10 = 9641601;
      sprintf_0(
        Buffer,
        (const char *const)(9641601 - (_DWORD)sub_485B55),
        *((_DWORD *)this + 66) + 24 * *((_DWORD *)this + 68) + 8284,
        v4 + 2);
      v7 = (void *)v11;
      goto LABEL_14;
    }
  }
  else
  {
    v7 = this + 292;
    if ( this[292] == 35 && *(_BYTE *)(*(_DWORD *)(*((_DWORD *)this + 137) + 2168) + 170) )
    {
      v11 = 9646066;
      sprintf_0(
        Buffer,
        (const char *const)(9646066 - (_DWORD)&off_485E8A),
        *(_DWORD *)(*((_DWORD *)this + 137) + 2168) + 170,
        this + 293);
LABEL_14:
      strncpyt(v7, Buffer, 256);
      return 1;
    }
  }
  return 0;
}
// 485E8A: using guessed type char *off_485E8A;

//----- (0042F9F0) --------------------------------------------------------
bool __thiscall sub_42F9F0(_DWORD *this, int a2)
{
  int v2; // esi
  int v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // eax

  v2 = this[6];
  if ( v2 )
  {
    v3 = 100 - 100 * this[10] / v2;
    if ( v3 < 0 )
      v3 = 0;
    v4 = v3 * this[15];
    this[4] = this[14] * v3 / 100;
    this[5] = v4 / 100;
  }
  v5 = a2 * this[5] + this[2];
  this[1] += a2 * this[4];
  this[2] = v5;
  v6 = this[7];
  v7 = a2 + this[10];
  this[10] = v7;
  return v7 < v6;
}

//----- (0042FAB0) --------------------------------------------------------
char __thiscall sub_42FAB0(char *this, int a2, char a3, char a4, char a5)
{
  int v6; // eax
  char *v7; // esi
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // edi
  int v11; // ecx
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  _DWORD *v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // ecx
  int v30; // ecx
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // ecx
  int v35; // eax
  int v36; // ecx
  int v37; // ecx
  int v38; // edx
  int v39; // ecx
  int v40; // eax
  unsigned int v41; // eax
  int v42; // eax
  unsigned int v43; // eax
  int v44; // eax
  int v45; // eax
  char v46; // al
  int v47; // eax
  int v48; // eax
  int v49; // ecx
  int v50; // ecx
  int v51; // eax
  int v52; // ecx
  int v53; // eax
  int v54; // edx
  int v55; // eax
  int v56; // ecx
  int v57; // eax
  int v58; // ecx
  int v59; // edx
  int v60; // eax
  int v61; // ecx
  int v62; // eax
  int v63; // ecx
  int v64; // edx
  int v65; // eax
  int v66; // ecx
  int v67; // eax
  int v68; // ecx
  int v69; // edx
  int v70; // eax
  int v71; // ecx
  int v72; // eax
  int v73; // ecx
  int v74; // edx
  int v75; // eax
  int v76; // ecx
  int v77; // eax
  int v78; // ecx
  int v79; // edx
  int v80; // eax
  int v81; // ecx
  int v82; // eax
  int v83; // ecx
  int v84; // edx
  int v85; // eax
  int v86; // ecx
  int v87; // eax
  int v88; // ecx
  int v89; // edx
  int v90; // eax
  int v91; // ecx
  int v92; // eax
  int v93; // eax
  int v94; // ecx
  int v95; // ecx
  int v96; // eax
  unsigned int v97; // eax
  int v98; // eax
  int v99; // eax
  unsigned int v100; // eax
  int v101; // ecx
  int v102; // ecx
  int v103; // edx
  int v104; // ecx
  int v105; // ecx
  int v106; // ecx
  int v107; // edx
  int v108; // ecx
  int v109; // ecx
  int v110; // eax
  int v111; // ecx
  int v112; // eax
  int v113; // edx
  int v114; // ecx
  int v115; // edx
  int v116; // ecx
  int v117; // edx
  int v118; // ecx
  int v119; // edx
  int v120; // ecx
  int v121; // eax
  int v122; // eax
  int v123; // eax
  int v124; // eax
  int v125; // eax
  int v126; // esi
  int v127; // eax
  int v128; // edx
  int v129; // ecx
  int v130; // eax
  int v131; // ecx
  int v132; // edx
  unsigned int v133; // eax
  int v134; // edi
  int v135; // ecx
  unsigned int v136; // eax
  int v137; // edx
  int v138; // ecx
  int v139; // eax
  int v140; // edx
  int v141; // ecx
  int v142; // eax
  int v143; // edx
  int v144; // ecx
  int v145; // eax
  int v146; // edx
  int v147; // ecx
  int v148; // eax
  int v149; // edx
  int v150; // ecx
  int v151; // eax
  int v152; // edx
  int v153; // ecx
  int v154; // eax
  int v155; // edx
  int v156; // ecx
  int v157; // eax
  int v158; // edx
  int v159; // ecx
  int v160; // eax
  int v161; // eax
  int v162; // eax
  int v163; // eax
  int v164; // edx
  int v165; // ecx
  int v166; // edx
  int v167; // edx
  int v168; // ecx
  int v169; // edx
  int v170; // eax
  int v171; // eax
  int v172; // eax
  int v173; // edx
  int v174; // edx
  int v175; // eax
  int v176; // eax
  int v177; // ecx
  int v178; // eax
  int v179; // ecx
  int v180; // eax
  int v181; // ecx
  int v182; // eax
  int v183; // ecx
  int v184; // ecx
  int v185; // ecx
  int v186; // eax
  int v187; // ecx
  char Buffer[32]; // [esp+Ch] [ebp-30h] BYREF
  char *v190; // [esp+2Ch] [ebp-10h]
  int v191; // [esp+30h] [ebp-Ch]
  _DWORD *v192; // [esp+34h] [ebp-8h]
  int v193; // [esp+38h] [ebp-4h]

  v6 = *((_DWORD *)this + 23);
  v190 = this;
  if ( v6 != 8 )
  {
    v7 = 0;
    if ( this[156] )
    {
      if ( *((_DWORD *)this + 130) + *((_DWORD *)this + 131) >= 0 )
      {
        v8 = *((_DWORD *)this + 3);
        v9 = 327 * v6;
        v10 = (_DWORD *)(v8 + 4 * v9 + 12508);
        v191 = (int)v10;
        if ( !*(_DWORD *)(v8 + 4 * v9 + 13368) && a2 == 19 )
          a2 = 13;
        v193 = 0;
        v192 = 0;
        switch ( -1 - a2 )
        {
          case 0:
            v11 = *((_DWORD *)this + 124);
            if ( *((_DWORD *)this + 122) + *((_DWORD *)this + 123) <= *(_DWORD *)(v11 + *((_DWORD *)this + 120)) )
              goto LABEL_13;
            *((_DWORD *)this + 122) += *((_DWORD *)this + 123)
                                     - *(_DWORD *)(*((_DWORD *)this + 125) + v11)
                                     - dword_4C1AE4;
            *((_DWORD *)this + 123) = dword_4C1AE4;
            v12 = *(_DWORD *)(*((_DWORD *)this + 120) + *((_DWORD *)this + 124));
            if ( *((_DWORD *)this + 122) + *((_DWORD *)this + 123) < v12 )
            {
              v13 = dword_4C1AE4 - v12;
              v14 = v12 - (dword_4C1AE4 - v12);
              dword_4C1AE4 = v13;
              *((_DWORD *)this + 123) = v13;
              *((_DWORD *)this + 122) = v14;
            }
            v192 = this + 480;
            v193 = 9673306;
            v15 = 9673306 - (_DWORD)&loc_48C4CE;
            break;
          case 1:
            v21 = *((_DWORD *)this + 115);
            if ( *(_DWORD *)(*((_DWORD *)this + 116) + v21) )
            {
              v22 = *(_DWORD *)(*((_DWORD *)this + 112) + v21);
              if ( *((_DWORD *)this + 113) + *((_DWORD *)this + 114) <= v22 )
                v22 = *((_DWORD *)this + 113) + *((_DWORD *)this + 114);
            }
            else
            {
              v22 = *(_DWORD *)(v21 + *((_DWORD *)this + 111));
            }
            if ( v22 > 0 )
            {
              v23 = *((_DWORD *)this + 115);
              if ( *((_DWORD *)this + 113) + *((_DWORD *)this + 114) > *(_DWORD *)(*((_DWORD *)this + 111) + v23) )
              {
                *((_DWORD *)this + 113) += *((_DWORD *)this + 114)
                                         - *(_DWORD *)(*((_DWORD *)this + 116) + v23)
                                         - dword_4C1AE4;
                *((_DWORD *)this + 114) = dword_4C1AE4;
                v24 = *(_DWORD *)(*((_DWORD *)this + 115) + *((_DWORD *)this + 111));
                if ( *((_DWORD *)this + 113) + *((_DWORD *)this + 114) < v24 )
                {
                  v25 = dword_4C1AE4 - v24;
                  v26 = v24 - (dword_4C1AE4 - v24);
                  dword_4C1AE4 = v25;
                  *((_DWORD *)this + 114) = v25;
                  *((_DWORD *)this + 113) = v26;
                }
                v191 = 9674512;
                v7 = (char *)(9674512 - ((_DWORD)&loc_48C9BB + 1));
                v193 = 9674512 - ((_DWORD)&loc_48C9BB + 1);
              }
              v27 = *((_DWORD *)this + 115);
              if ( *(_DWORD *)(*((_DWORD *)this + 116) + v27) )
              {
                v28 = *((_DWORD *)this + 113) + *((_DWORD *)this + 114);
                v29 = *(_DWORD *)(*((_DWORD *)this + 112) + v27);
                if ( v28 > v29 )
                  v28 = v29;
              }
              else
              {
                v28 = *(_DWORD *)(*((_DWORD *)this + 111) + v27);
              }
              if ( *((_DWORD *)this + 130) + *((_DWORD *)this + 131) > 1000 * v28 )
              {
                v30 = *((_DWORD *)this + 115);
                if ( *(_DWORD *)(*((_DWORD *)this + 116) + v30) )
                {
                  v31 = *((_DWORD *)this + 113) + *((_DWORD *)this + 114);
                  v32 = *(_DWORD *)(*((_DWORD *)this + 112) + v30);
                  if ( v31 > v32 )
                    v31 = v32;
                }
                else
                {
                  v31 = *(_DWORD *)(*((_DWORD *)this + 111) + v30);
                }
                v33 = 1000 * v31;
                v34 = dword_4C1AE4 - v33;
                v35 = v33 - (dword_4C1AE4 - v33);
                dword_4C1AE4 = v34;
                *((_DWORD *)this + 131) = v34;
                *((_DWORD *)this + 130) = v35;
              }
            }
            goto LABEL_14;
          case 2:
            v36 = *((_DWORD *)this + 159);
            if ( *((_DWORD *)this + 157) + *((_DWORD *)this + 158) <= *(_DWORD *)(v36 + *((_DWORD *)this + 155)) )
              goto LABEL_13;
            *((_DWORD *)this + 157) += *((_DWORD *)this + 158)
                                     - *(_DWORD *)(*((_DWORD *)this + 160) + v36)
                                     - dword_4C1AE4;
            *((_DWORD *)this + 158) = dword_4C1AE4;
            v37 = *(_DWORD *)(*((_DWORD *)this + 159) + *((_DWORD *)this + 155));
            if ( *((_DWORD *)this + 157) + *((_DWORD *)this + 158) < v37 )
            {
              v38 = dword_4C1AE4 - v37;
              v39 = v37 - (dword_4C1AE4 - v37);
              dword_4C1AE4 = v38;
              *((_DWORD *)this + 158) = v38;
              *((_DWORD *)this + 157) = v39;
            }
            v192 = this + 620;
            v193 = 9676589;
            v15 = 9676589 - (_DWORD)&loc_48D1F5;
            break;
          case 3:
            v40 = *((_DWORD *)this + 186);
            this[96] &= 0xFEu;
            if ( (v40 & 0x20000) != 0 )
            {
              v191 = 9677839;
              v7 = (char *)(9677839 - ((_DWORD)&loc_48D6E6 + 1));
              v41 = *((_DWORD *)this + 186) & 0xFFFDFFFF;
              v193 = 9677839 - ((_DWORD)&loc_48D6E6 + 1);
              *((_DWORD *)this + 186) = v41;
            }
            goto LABEL_14;
          case 4:
            v42 = *((_DWORD *)this + 186);
            this[96] &= 0xFDu;
            if ( (v42 & 0x40000000) != 0 )
            {
              v191 = 9679094;
              v7 = (char *)(9679094 - ((_DWORD)&loc_48DBD7 + 3));
              v43 = *((_DWORD *)this + 186) & 0xBFFFFFFF;
              v193 = 9679094 - ((_DWORD)&loc_48DBD7 + 3);
              *((_DWORD *)this + 186) = v43;
            }
            goto LABEL_14;
          case 5:
            v44 = *((_DWORD *)this + 187);
            this[96] &= 0xFBu;
            if ( (v44 & 0x200) != 0 )
            {
              v191 = 9680347;
              v7 = (char *)(9680347 - (_DWORD)&loc_48E0CF);
              v45 = *((_DWORD *)this + 187);
              BYTE1(v45) &= 0xFDu;
              v193 = 9680347 - (_DWORD)&loc_48E0CF;
              *((_DWORD *)this + 187) = v45;
            }
            goto LABEL_14;
          case 7:
            if ( *((_DWORD *)this + 166) + *((_DWORD *)this + 167) != *(_DWORD *)(v8 + 4 * v9 + 12512) )
            {
              v191 = 9682428;
              v7 = (char *)(9682428 - ((_DWORD)&loc_48E912 + 2));
              v48 = *(_DWORD *)(v8 + 4 * v9 + 12512);
              v49 = *((_DWORD *)this + 167) + *((_DWORD *)this + 166) - 1;
              v193 = 9682428 - ((_DWORD)&loc_48E912 + 2);
              if ( v48 < v49 )
                v48 = *((_DWORD *)this + 167) + *((_DWORD *)this + 166) - 1;
              v50 = dword_4C1AE4 - v48;
              v51 = v48 - (dword_4C1AE4 - v48);
              dword_4C1AE4 = v50;
              *((_DWORD *)this + 167) = v50;
              *((_DWORD *)this + 166) = v51;
            }
            goto LABEL_14;
          case 8:
            if ( *((_DWORD *)this + 168) + *((_DWORD *)this + 169) != *(_DWORD *)(v8 + 4 * v9 + 13084) )
            {
              v191 = 9689937;
              v7 = (char *)(9689937 - ((_DWORD)&loc_4906F8 + 1));
              v93 = *(_DWORD *)(v8 + 4 * v9 + 13084);
              v94 = *((_DWORD *)this + 169) + *((_DWORD *)this + 168) - 1;
              v193 = 9689937 - ((_DWORD)&loc_4906F8 + 1);
              if ( v93 < v94 )
                v93 = *((_DWORD *)this + 169) + *((_DWORD *)this + 168) - 1;
              v95 = dword_4C1AE4 - v93;
              v96 = v93 - (dword_4C1AE4 - v93);
              dword_4C1AE4 = v95;
              *((_DWORD *)this + 169) = v95;
              *((_DWORD *)this + 168) = v96;
            }
            goto LABEL_14;
          case 9:
            if ( (*((_DWORD *)this + 187) & 0x80000) != 0 )
            {
              v191 = 9690766;
              v7 = (char *)(9690766 - (_DWORD)&loc_490A4E);
              v97 = *((_DWORD *)this + 187) & 0xFFF7FFFF;
              v193 = 9690766 - (_DWORD)&loc_490A4E;
              *((_DWORD *)this + 187) = v97;
            }
            goto LABEL_14;
          case 10:
            v101 = *((_DWORD *)this + 147);
            if ( *((_DWORD *)this + 145) + *((_DWORD *)this + 146) <= *(_DWORD *)(v101 + *((_DWORD *)this + 143)) )
              goto LABEL_13;
            *((_DWORD *)this + 145) += *((_DWORD *)this + 146)
                                     - *(_DWORD *)(*((_DWORD *)this + 148) + v101)
                                     - dword_4C1AE4;
            *((_DWORD *)this + 146) = dword_4C1AE4;
            v102 = *(_DWORD *)(*((_DWORD *)this + 147) + *((_DWORD *)this + 143));
            if ( *((_DWORD *)this + 145) + *((_DWORD *)this + 146) < v102 )
            {
              v103 = dword_4C1AE4 - v102;
              v104 = v102 - (dword_4C1AE4 - v102);
              dword_4C1AE4 = v103;
              *((_DWORD *)this + 146) = v103;
              *((_DWORD *)this + 145) = v104;
            }
            v192 = this + 572;
            v193 = 9693694;
            v15 = 9693694 - ((_DWORD)&loc_4915FC + 2);
            break;
          case 11:
            v105 = *((_DWORD *)this + 214);
            if ( *((_DWORD *)this + 212) + *((_DWORD *)this + 213) <= *(_DWORD *)(v105 + *((_DWORD *)this + 210)) )
              goto LABEL_13;
            *((_DWORD *)this + 212) += *((_DWORD *)this + 213)
                                     - *(_DWORD *)(*((_DWORD *)this + 215) + v105)
                                     - dword_4C1AE4;
            *((_DWORD *)this + 213) = dword_4C1AE4;
            v106 = *(_DWORD *)(*((_DWORD *)this + 214) + *((_DWORD *)this + 210));
            if ( *((_DWORD *)this + 212) + *((_DWORD *)this + 213) < v106 )
            {
              v107 = dword_4C1AE4 - v106;
              v108 = v106 - (dword_4C1AE4 - v106);
              dword_4C1AE4 = v107;
              *((_DWORD *)this + 213) = v107;
              *((_DWORD *)this + 212) = v108;
            }
            v192 = this + 840;
            v193 = 9694531;
            v15 = 9694531 - (_DWORD)byte_491957;
            break;
          case 12:
            v191 = 9695367;
            v7 = (char *)(9695367 - ((_DWORD)&loc_491CAE + 1));
            v193 = 9695367 - ((_DWORD)&loc_491CAE + 1);
            *((_DWORD *)this + 131) = --dword_4C1AE4;
            *((_DWORD *)this + 130) = 1 - *((_DWORD *)this + 131);
            goto LABEL_14;
          case 13:
            v191 = 9696196;
            v109 = *((_DWORD *)this + 3);
            v7 = (char *)(9696196 - ((_DWORD)&loc_492007 + 1));
            v193 = 9696196 - ((_DWORD)&loc_492007 + 1);
            v110 = 3 * *(_DWORD *)(v109 + 11252);
            v111 = dword_4C1AE4 - v110;
            v112 = v110 - (dword_4C1AE4 - v110);
            dword_4C1AE4 = v111;
            *((_DWORD *)this + 152) = v111;
            *((_DWORD *)this + 151) = v112;
            goto LABEL_14;
          case 14:
            v98 = *((_DWORD *)this + 187);
            this[812] = 0;
            if ( (v98 & 0x8000) != 0 )
            {
              v191 = 9692032;
              v7 = (char *)(9692032 - ((_DWORD)&loc_490F4C + 4));
              v99 = *((_DWORD *)this + 187);
              BYTE1(v99) &= 0x7Fu;
              v193 = 9692032 - ((_DWORD)&loc_490F4C + 4);
              *((_DWORD *)this + 187) = v99;
            }
            goto LABEL_14;
          case 15:
            if ( (*((_DWORD *)this + 187) & 0x4000000) != 0 )
            {
              v191 = 9692862;
              v7 = (char *)(9692862 - ((_DWORD)&loc_4912A2 + 4));
              v100 = *((_DWORD *)this + 187) & 0xFBFFFFFF;
              v193 = 9692862 - ((_DWORD)&loc_4912A2 + 4);
              *((_DWORD *)this + 187) = v100;
            }
            goto LABEL_14;
          case 18:
            if ( *((_DWORD *)this + 170) + *((_DWORD *)this + 171) )
            {
              v191 = 9683256;
              v52 = *(_DWORD *)(v8 + 4 * v9 + 12984);
              v7 = (char *)(9683256 - ((_DWORD)&loc_48EC63 + 1));
              v53 = *((_DWORD *)this + 170);
              v54 = *((_DWORD *)this + 171) - v52;
              v193 = 9683256 - ((_DWORD)&loc_48EC63 + 1);
              if ( v53 + v54 > 0 )
                v55 = *((_DWORD *)this + 170) + *((_DWORD *)this + 171) - v52;
              else
                v55 = 0;
              v56 = dword_4C1AE4 - v55;
              v57 = v55 - (dword_4C1AE4 - v55);
              dword_4C1AE4 = v56;
              *((_DWORD *)this + 171) = v56;
              *((_DWORD *)this + 170) = v57;
            }
            goto LABEL_14;
          case 19:
            v46 = this[748];
            this[96] &= 0xF7u;
            if ( v46 < 0 )
            {
              v191 = 9681600;
              v7 = (char *)(9681600 - (_DWORD)&loc_48E5C4);
              v47 = *((_DWORD *)this + 187);
              LOBYTE(v47) = v47 & 0x7F;
              v193 = 9681600 - (_DWORD)&loc_48E5C4;
              *((_DWORD *)this + 187) = v47;
            }
            goto LABEL_14;
          case 20:
            if ( *((_DWORD *)this + 172) + *((_DWORD *)this + 173) )
            {
              v191 = 9684088;
              v58 = *((_DWORD *)this + 173);
              v59 = *((_DWORD *)this + 172);
              v7 = (char *)(9684088 - ((_DWORD)&loc_48EFB3 + 1));
              v193 = 9684088 - ((_DWORD)&loc_48EFB3 + 1);
              if ( v58 + v59 - 1 > 0 )
                v60 = *((_DWORD *)this + 173) + *((_DWORD *)this + 172) - 1;
              else
                v60 = 0;
              v61 = dword_4C1AE4 - v60;
              v62 = v60 - (dword_4C1AE4 - v60);
              dword_4C1AE4 = v61;
              *((_DWORD *)this + 173) = v61;
              *((_DWORD *)this + 172) = v62;
            }
            goto LABEL_14;
          case 21:
            if ( *((_DWORD *)this + 174) + *((_DWORD *)this + 175) )
            {
              v191 = 9684925;
              v63 = *((_DWORD *)this + 175);
              v64 = *((_DWORD *)this + 174);
              v7 = (char *)(9684925 - ((_DWORD)&loc_48F301 + 4));
              v193 = 9684925 - ((_DWORD)&loc_48F301 + 4);
              if ( v63 + v64 - 1 > 0 )
                v65 = *((_DWORD *)this + 175) + *((_DWORD *)this + 174) - 1;
              else
                v65 = 0;
              v66 = dword_4C1AE4 - v65;
              v67 = v65 - (dword_4C1AE4 - v65);
              dword_4C1AE4 = v66;
              *((_DWORD *)this + 175) = v66;
              *((_DWORD *)this + 174) = v67;
            }
            goto LABEL_14;
          case 22:
            if ( *((_DWORD *)this + 182) + *((_DWORD *)this + 183) )
            {
              v191 = 9685764;
              v68 = *((_DWORD *)this + 183);
              v69 = *((_DWORD *)this + 182);
              v7 = (char *)(9685764 - (_DWORD)byte_48F658);
              v193 = 9685764 - (_DWORD)byte_48F658;
              if ( v68 + v69 - 1 > 0 )
                v70 = *((_DWORD *)this + 183) + *((_DWORD *)this + 182) - 1;
              else
                v70 = 0;
              v71 = dword_4C1AE4 - v70;
              v72 = v70 - (dword_4C1AE4 - v70);
              dword_4C1AE4 = v71;
              *((_DWORD *)this + 183) = v71;
              *((_DWORD *)this + 182) = v72;
            }
            goto LABEL_14;
          case 23:
            if ( *((_DWORD *)this + 180) + *((_DWORD *)this + 181) )
            {
              v191 = 9686593;
              v73 = *((_DWORD *)this + 181);
              v74 = *((_DWORD *)this + 180);
              v7 = (char *)(9686593 - ((_DWORD)&loc_48F9A8 + 1));
              v193 = 9686593 - ((_DWORD)&loc_48F9A8 + 1);
              if ( v73 + v74 - 1 > 0 )
                v75 = *((_DWORD *)this + 181) + *((_DWORD *)this + 180) - 1;
              else
                v75 = 0;
              v76 = dword_4C1AE4 - v75;
              v77 = v75 - (dword_4C1AE4 - v75);
              dword_4C1AE4 = v76;
              *((_DWORD *)this + 181) = v76;
              *((_DWORD *)this + 180) = v77;
            }
            goto LABEL_14;
          case 25:
            if ( *((_DWORD *)this + 176) + *((_DWORD *)this + 177) )
            {
              v191 = 9688268;
              v83 = *((_DWORD *)this + 177);
              v84 = *((_DWORD *)this + 176);
              v7 = (char *)(9688268 - (_DWORD)&byte_48FF74[220]);
              v193 = 9688268 - (_DWORD)&byte_48FF74[220];
              if ( v83 + v84 - 1 > 0 )
                v85 = *((_DWORD *)this + 177) + *((_DWORD *)this + 176) - 1;
              else
                v85 = 0;
              v86 = dword_4C1AE4 - v85;
              v87 = v85 - (dword_4C1AE4 - v85);
              dword_4C1AE4 = v86;
              *((_DWORD *)this + 177) = v86;
              *((_DWORD *)this + 176) = v87;
            }
            goto LABEL_14;
          case 26:
            if ( *((_DWORD *)this + 178) + *((_DWORD *)this + 179) )
            {
              v191 = 9689104;
              v88 = *((_DWORD *)this + 179);
              v89 = *((_DWORD *)this + 178);
              v7 = (char *)(9689104 - (_DWORD)&loc_4903A4);
              v193 = 9689104 - (_DWORD)&loc_4903A4;
              if ( v88 + v89 - 1 > 0 )
                v90 = *((_DWORD *)this + 179) + *((_DWORD *)this + 178) - 1;
              else
                v90 = 0;
              v91 = dword_4C1AE4 - v90;
              v92 = v90 - (dword_4C1AE4 - v90);
              dword_4C1AE4 = v91;
              *((_DWORD *)this + 179) = v91;
              *((_DWORD *)this + 178) = v92;
            }
            goto LABEL_14;
          case 27:
            if ( *((_DWORD *)this + 184) + *((_DWORD *)this + 185) )
            {
              v191 = 9687428;
              v78 = *((_DWORD *)this + 185);
              v79 = *((_DWORD *)this + 184);
              v7 = (char *)(9687428 - ((_DWORD)&loc_48FCFB + 1));
              v193 = 9687428 - ((_DWORD)&loc_48FCFB + 1);
              if ( v78 + v79 - 1 > 0 )
                v80 = *((_DWORD *)this + 185) + *((_DWORD *)this + 184) - 1;
              else
                v80 = 0;
              v81 = dword_4C1AE4 - v80;
              v82 = v80 - (dword_4C1AE4 - v80);
              dword_4C1AE4 = v81;
              *((_DWORD *)this + 185) = v81;
              *((_DWORD *)this + 184) = v82;
            }
            goto LABEL_14;
          default:
            goto LABEL_14;
        }
        v7 = (char *)v15;
        v193 = v15;
LABEL_13:
        v10 = (_DWORD *)v191;
LABEL_14:
        LOBYTE(v6) = a2 - 1;
        switch ( a2 )
        {
          case 1:
            v191 = 9700933;
            v7 = (char *)(9700933 - ((_DWORD)&loc_4930D0 + 1));
            v16 = this + 480;
            v17 = *((_DWORD *)this + 123)
                + *(_DWORD *)(*((_DWORD *)this + 125) + *((_DWORD *)this + 124))
                - dword_4C1AE4
                + *((_DWORD *)this + 122);
            v193 = 9700933 - ((_DWORD)&loc_4930D0 + 1);
            *((_DWORD *)this + 122) = v17;
            *((_DWORD *)this + 123) = dword_4C1AE4;
            v18 = *(_DWORD *)(*((_DWORD *)this + 121) + *((_DWORD *)this + 124));
            if ( *((_DWORD *)this + 122) + *((_DWORD *)this + 123) <= v18 )
              goto LABEL_156;
            v192 = this + 480;
            v19 = dword_4C1AE4 - v18;
            v20 = v18 - (dword_4C1AE4 - v18);
            dword_4C1AE4 = v19;
            *((_DWORD *)this + 123) = v19;
            *((_DWORD *)this + 122) = v20;
            goto LABEL_166;
          case 2:
            v191 = 9701322;
            v7 = (char *)(9701322 - ((_DWORD)&loc_49342D + 1));
            v16 = this + 444;
            v113 = *((_DWORD *)this + 114)
                 + *(_DWORD *)(*((_DWORD *)this + 116) + *((_DWORD *)this + 115))
                 - dword_4C1AE4
                 + *((_DWORD *)this + 113);
            v193 = 9701322 - ((_DWORD)&loc_49342D + 1);
            *((_DWORD *)this + 113) = v113;
            *((_DWORD *)this + 114) = dword_4C1AE4;
            v114 = *(_DWORD *)(*((_DWORD *)this + 112) + *((_DWORD *)this + 115));
            if ( *((_DWORD *)this + 113) + *((_DWORD *)this + 114) <= v114 )
              goto LABEL_156;
            v192 = this + 444;
            v115 = dword_4C1AE4 - v114;
            v116 = v114 - (dword_4C1AE4 - v114);
            dword_4C1AE4 = v115;
            *((_DWORD *)this + 114) = v115;
            *((_DWORD *)this + 113) = v116;
            goto LABEL_166;
          case 3:
            v191 = 9702156;
            v7 = (char *)(9702156 - ((_DWORD)&loc_49378B + 1));
            v16 = this + 620;
            v117 = *((_DWORD *)this + 158)
                 + *(_DWORD *)(*((_DWORD *)this + 160) + *((_DWORD *)this + 159))
                 - dword_4C1AE4
                 + *((_DWORD *)this + 157);
            v193 = 9702156 - ((_DWORD)&loc_49378B + 1);
            *((_DWORD *)this + 157) = v117;
            *((_DWORD *)this + 158) = dword_4C1AE4;
            v118 = *(_DWORD *)(*((_DWORD *)this + 156) + *((_DWORD *)this + 159));
            if ( *((_DWORD *)this + 157) + *((_DWORD *)this + 158) <= v118 )
              goto LABEL_156;
            v192 = this + 620;
            v119 = dword_4C1AE4 - v118;
            v120 = v118 - (dword_4C1AE4 - v118);
            dword_4C1AE4 = v119;
            *((_DWORD *)this + 158) = v119;
            *((_DWORD *)this + 157) = v120;
            goto LABEL_166;
          case 4:
            if ( !v10[250] )
              goto LABEL_166;
            v121 = *((_DWORD *)this + 186);
            v191 = 9702997;
            *((_DWORD *)this + 186) = v121 | 0x20000;
            v122 = v191 - (_DWORD)&loc_493AE9;
            goto LABEL_164;
          case 5:
            if ( !v10[255] )
              goto LABEL_166;
            v123 = *((_DWORD *)this + 186);
            v191 = 9703841;
            *((_DWORD *)this + 186) = v123 | 0x40000000;
            v122 = v191 - ((_DWORD)&loc_493E48 + 1);
            goto LABEL_164;
          case 6:
            if ( !v10[42] )
              goto LABEL_166;
            v125 = *((_DWORD *)this + 187);
            v191 = 9705528;
            BYTE1(v125) |= 2u;
            *((_DWORD *)this + 187) = v125;
            v122 = v191 - ((_DWORD)&loc_494506 + 2);
            goto LABEL_164;
          case 7:
            if ( *((_DWORD *)this + 7) != -1 )
              return v6;
            v126 = *(_DWORD *)this;
            v127 = rand();
            (*(void (__thiscall **)(char *, int, int, int))(v126 + 152))(this, v127, -1, -1);
            v7 = aWarp;
            goto LABEL_165;
          case 8:
            v191 = 9708534;
            v128 = *((_DWORD *)this + 166);
            v129 = v10[77];
            v7 = (char *)(9708534 - ((_DWORD)&loc_4950D8 + 6));
            v130 = v128 + *((_DWORD *)this + 167);
            v193 = 9708534 - ((_DWORD)&loc_4950D8 + 6);
            if ( v130 < v129 )
            {
              *((_DWORD *)this + 166) = *((_DWORD *)this + 167) - dword_4C1AE4 + 1 + v128;
              *((_DWORD *)this + 167) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 9:
            v191 = 9716175;
            v158 = *((_DWORD *)this + 168);
            v159 = v10[145];
            v7 = (char *)(9716175 - ((_DWORD)&loc_496F6E + 1));
            v160 = v158 + *((_DWORD *)this + 169);
            v193 = 9716175 - ((_DWORD)&loc_496F6E + 1);
            if ( v160 < v159 )
            {
              *((_DWORD *)this + 168) = *((_DWORD *)this + 169) - dword_4C1AE4 + 1 + v158;
              *((_DWORD *)this + 169) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 10:
            v191 = 9717027;
            v7 = (char *)(9717027 - ((_DWORD)&loc_4972D6 + 1));
            v161 = *((_DWORD *)this + 187) | 0x80000;
            v193 = 9717027 - ((_DWORD)&loc_4972D6 + 1);
            *((_DWORD *)this + 187) = v161;
            goto LABEL_166;
          case 11:
            v191 = 9720463;
            v7 = (char *)(9720463 - ((_DWORD)&loc_49807E + 1));
            v16 = this + 572;
            v164 = *((_DWORD *)this + 146)
                 + *(_DWORD *)(*((_DWORD *)this + 148) + *((_DWORD *)this + 147))
                 - dword_4C1AE4
                 + *((_DWORD *)this + 145);
            v193 = 9720463 - ((_DWORD)&loc_49807E + 1);
            *((_DWORD *)this + 145) = v164;
            *((_DWORD *)this + 146) = dword_4C1AE4;
            v165 = *(_DWORD *)(*((_DWORD *)this + 144) + *((_DWORD *)this + 147));
            if ( *((_DWORD *)this + 145) + *((_DWORD *)this + 146) <= v165 )
              goto LABEL_156;
            v192 = this + 572;
            v166 = dword_4C1AE4 - v165;
            dword_4C1AE4 = v166;
            *((_DWORD *)this + 146) = v166;
            *((_DWORD *)this + 145) = v165 - v166;
            goto LABEL_166;
          case 12:
            v191 = 9721316;
            v7 = (char *)(9721316 - (_DWORD)&loc_4983EC);
            v16 = this + 840;
            v167 = *((_DWORD *)this + 213)
                 + *(_DWORD *)(*((_DWORD *)this + 215) + *((_DWORD *)this + 214))
                 - dword_4C1AE4
                 + *((_DWORD *)this + 212);
            v193 = 9721316 - (_DWORD)&loc_4983EC;
            *((_DWORD *)this + 212) = v167;
            *((_DWORD *)this + 213) = dword_4C1AE4;
            v168 = *(_DWORD *)(*((_DWORD *)this + 211) + *((_DWORD *)this + 214));
            if ( *((_DWORD *)this + 212) + *((_DWORD *)this + 213) > v168 )
            {
              v169 = dword_4C1AE4 - v168;
              dword_4C1AE4 = v169;
              *((_DWORD *)this + 213) = v169;
              *((_DWORD *)this + 212) = v168 - v169;
            }
LABEL_156:
            v192 = v16;
            goto LABEL_166;
          case 14:
            v191 = 9723048;
            v7 = (char *)(9723048 - ((_DWORD)&loc_498AC1 + 3));
            v170 = *((_DWORD *)this + 3);
            v193 = 9723048 - ((_DWORD)&loc_498AC1 + 3);
            v171 = *(_DWORD *)(v170 + 11252);
            dword_4C1AE4 -= v171;
            v172 = v171 - dword_4C1AE4;
            *((_DWORD *)this + 152) = dword_4C1AE4;
            *((_DWORD *)this + 151) = v172;
            goto LABEL_166;
          case 15:
            if ( (*((_DWORD *)this + 187) & 0x8000) == 0 )
              this[812] = *(_BYTE *)(*(_DWORD *)(*((_DWORD *)this + 3) + 23100) + 8066);
            v191 = 9718755;
            v7 = (char *)(9718755 - (_DWORD)&loc_4979AB);
            v162 = *((_DWORD *)this + 187) | 0x8000;
            v193 = 9718755 - (_DWORD)&loc_4979AB;
            *((_DWORD *)this + 187) = v162;
            goto LABEL_166;
          case 16:
            v191 = 9719608;
            v7 = (char *)(9719608 - ((_DWORD)&loc_497D13 + 1));
            v163 = *((_DWORD *)this + 187) | 0x4000000;
            v193 = 9719608 - ((_DWORD)&loc_497D13 + 1);
            *((_DWORD *)this + 187) = v163;
            goto LABEL_166;
          case 17:
            if ( *((_DWORD *)this + 101) + *((_DWORD *)this + 102) > 0 )
            {
              v191 = 9726097;
              v122 = 9726097 - (_DWORD)&loc_4996C5;
LABEL_164:
              v7 = (char *)v122;
LABEL_165:
              v193 = (int)v7;
            }
            else if ( v10[323] )
            {
              v191 = 9724780;
              v7 = (char *)(9724780 - ((_DWORD)&loc_49919E + 2));
              v193 = 9724780 - ((_DWORD)&loc_49919E + 2);
              v173 = 100 * rand() % v10[323];
              dword_4C1AE4 -= v173;
              v174 = v173 - dword_4C1AE4;
              *((_DWORD *)this + 102) = dword_4C1AE4;
              *((_DWORD *)this + 101) = v174;
            }
LABEL_166:
            if ( v7 )
              goto LABEL_177;
            if ( a2 < 0 )
            {
              if ( !a4 && !a5 )
              {
                v7 = (char *)(9732792 - (_DWORD)&loc_49AEE0);
                v193 = 9732792 - (_DWORD)&loc_49AEE0;
                dword_4C1AE4 -= 1000;
                *((_DWORD *)this + 131) = dword_4C1AE4;
                *((_DWORD *)this + 130) = 1000 - *((_DWORD *)this + 131);
              }
            }
            else
            {
              v177 = *((_DWORD *)this + 115);
              if ( *(_DWORD *)(*((_DWORD *)this + 116) + v177) )
              {
                v179 = *(_DWORD *)(*((_DWORD *)this + 112) + v177);
                v178 = *((_DWORD *)this + 113) + *((_DWORD *)this + 114);
                if ( v178 > v179 )
                  v178 = v179;
              }
              else
              {
                v178 = *(_DWORD *)(*((_DWORD *)this + 111) + v177);
              }
              v180 = 1000 * v178;
              v181 = dword_4C1AE4 - v180;
              dword_4C1AE4 = v181;
              *((_DWORD *)this + 131) = v181;
              *((_DWORD *)this + 130) = v180 - v181;
              v7 = (char *)(9730895 - ((_DWORD)&loc_49A9B1 + 2));
              v193 = 9730895 - ((_DWORD)&loc_49A9B1 + 2);
              if ( (_UNKNOWN *)((char *)&loc_49A9B1 + 2) == (_UNKNOWN *)9730895 )
                goto LABEL_178;
            }
LABEL_177:
            LOBYTE(v6) = a2;
            if ( a2 < 0 )
              goto LABEL_179;
LABEL_178:
            v6 = *((_DWORD *)this + 9) - dword_4C1AE4 + 1 + *((_DWORD *)this + 8);
            *((_DWORD *)this + 8) = v6;
            *((_DWORD *)this + 9) = dword_4C1AE4;
LABEL_179:
            if ( v7 )
            {
              LOBYTE(v6) = a3;
              if ( !a3 )
              {
                if ( v192 )
                {
                  v182 = v192[4];
                  if ( *(_DWORD *)(v192[5] + v182)
                    && (v183 = *(_DWORD *)(v192[1] + v182), v183 - *(_DWORD *)(v182 + *v192) > 0)
                    && (v184 = 100 * (v192[2] + v192[3]) / v183, v184 != 100) )
                  {
                    sprintf_0(Buffer, (const char *const)(9736629 - ((_DWORD)&loc_49C025 + 4)), v184);
                  }
                  else
                  {
                    strcpy(Buffer, (const char *)(9736194 - (_DWORD)&loc_49BE6E));
                    v7 = (char *)v193;
                  }
                }
                else
                {
                  Buffer[0] = 0;
                }
                if ( a4 )
                  (*(void (__cdecl **)(_DWORD, int, int, int, char *, char *))(**((_DWORD **)this + 3) + 388))(
                    *((_DWORD *)this + 3),
                    300,
                    4,
                    9738388 - (_DWORD)&loc_49C718,
                    v7,
                    Buffer);
                else
                  (*(void (__cdecl **)(_DWORD, int, int, int, char *, char *))(**((_DWORD **)this + 3) + 388))(
                    *((_DWORD *)this + 3),
                    300,
                    1,
                    9739267 - (_DWORD)&loc_49CA8F,
                    v7,
                    Buffer);
                if ( a2 == 7 )
                {
                  v185 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 240);
                }
                else if ( a2 < 0 )
                {
                  v185 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 3) + 120076) + 128);
                }
                else
                {
                  v186 = -1600835069;
                  v187 = 242;
                  do
                    v186 ^= *(_DWORD *)&aTickname[4 * v187-- - 381592];
                  while ( v187 );
                  v185 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)&v190[v186 + 3772236] + 120076) + 272);
                }
                LOBYTE(v6) = (*(int (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v185 + 20))(
                               v185,
                               0,
                               0,
                               0,
                               0);
              }
            }
            break;
          case 18:
            v191 = 9727397;
            v7 = (char *)(9727397 - ((_DWORD)&loc_499BEC + 1));
            v175 = v10[240];
            v193 = 9727397 - ((_DWORD)&loc_499BEC + 1);
            dword_4C1AE4 -= v175;
            v176 = v175 - dword_4C1AE4;
            *((_DWORD *)this + 100) = dword_4C1AE4;
            *((_DWORD *)this + 99) = v176;
            goto LABEL_166;
          case 19:
            v191 = 9709381;
            v131 = v10[119];
            v132 = *((_DWORD *)this + 171);
            v7 = (char *)(9709381 - ((_DWORD)&loc_49543E + 3));
            v133 = v10[215];
            v134 = *((_DWORD *)this + 170);
            v193 = 9709381 - ((_DWORD)&loc_49543E + 3);
            if ( v133 > v131 + v134 + v132 )
              v133 = v134 + v131 + *((_DWORD *)this + 171);
            v135 = dword_4C1AE4 - v133;
            v136 = v133 - (dword_4C1AE4 - v133);
            dword_4C1AE4 = v135;
            *((_DWORD *)this + 171) = v135;
            *((_DWORD *)this + 170) = v136;
            goto LABEL_166;
          case 20:
            if ( !v10[253] )
              goto LABEL_166;
            v124 = *((_DWORD *)this + 187);
            v191 = 9704685;
            LOBYTE(v124) = v124 | 0x80;
            *((_DWORD *)this + 187) = v124;
            v122 = v191 - (_DWORD)&loc_4941A9;
            goto LABEL_164;
          case 21:
            v191 = 9710229;
            v137 = *((_DWORD *)this + 172);
            v138 = v10[198];
            v7 = (char *)(9710229 - ((_DWORD)&loc_4957A2 + 3));
            v139 = v137 + *((_DWORD *)this + 173);
            v193 = 9710229 - ((_DWORD)&loc_4957A2 + 3);
            if ( v139 < v138 )
            {
              *((_DWORD *)this + 172) = *((_DWORD *)this + 173) - dword_4C1AE4 + 1 + v137;
              *((_DWORD *)this + 173) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 22:
            v191 = 9711077;
            v140 = *((_DWORD *)this + 174);
            v141 = v10[57];
            v7 = (char *)(9711077 - ((_DWORD)&loc_495B07 + 2));
            v142 = v140 + *((_DWORD *)this + 175);
            v193 = 9711077 - ((_DWORD)&loc_495B07 + 2);
            if ( v142 < v141 )
            {
              *((_DWORD *)this + 174) = *((_DWORD *)this + 175) - dword_4C1AE4 + 1 + v140;
              *((_DWORD *)this + 175) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 23:
            v191 = 9711925;
            v143 = *((_DWORD *)this + 182);
            v144 = v10[97];
            v7 = (char *)(9711925 - ((_DWORD)&loc_495E6B + 2));
            v145 = v143 + *((_DWORD *)this + 183);
            v193 = 9711925 - ((_DWORD)&loc_495E6B + 2);
            if ( v145 < v144 )
            {
              *((_DWORD *)this + 182) = *((_DWORD *)this + 183) - dword_4C1AE4 + 1 + v143;
              *((_DWORD *)this + 183) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 24:
            v191 = 9712767;
            v146 = *((_DWORD *)this + 180);
            v147 = v10[151];
            v7 = (char *)(9712767 - ((_DWORD)&loc_4961CD + 6));
            v148 = v146 + *((_DWORD *)this + 181);
            v193 = 9712767 - ((_DWORD)&loc_4961CD + 6);
            if ( v148 < v147 )
            {
              *((_DWORD *)this + 180) = *((_DWORD *)this + 181) - dword_4C1AE4 + 1 + v146;
              *((_DWORD *)this + 181) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 25:
            (*(void (__thiscall **)(char *, _DWORD, _DWORD))(*(_DWORD *)this + 60))(
              this,
              0,
              *(_DWORD *)(*((_DWORD *)this + 3) + 10900));
            v191 = 9728706;
            v122 = 9728706 - ((_DWORD)&loc_49A112 + 4);
            goto LABEL_164;
          case 26:
            v191 = 9714467;
            v152 = *((_DWORD *)this + 176);
            v153 = v10[65];
            v7 = (char *)(9714467 - ((_DWORD)&loc_49689D + 2));
            v154 = v152 + *((_DWORD *)this + 177);
            v193 = 9714467 - ((_DWORD)&loc_49689D + 2);
            if ( v154 < v153 )
            {
              *((_DWORD *)this + 176) = *((_DWORD *)this + 177) - dword_4C1AE4 + 1 + v152;
              *((_DWORD *)this + 177) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 27:
            v191 = 9715320;
            v155 = *((_DWORD *)this + 178);
            v156 = v10[316];
            v7 = (char *)(9715320 - ((_DWORD)&loc_496C06 + 2));
            v157 = v155 + *((_DWORD *)this + 179);
            v193 = 9715320 - ((_DWORD)&loc_496C06 + 2);
            if ( v157 < v156 )
            {
              *((_DWORD *)this + 178) = *((_DWORD *)this + 179) - dword_4C1AE4 + 1 + v155;
              *((_DWORD *)this + 179) = dword_4C1AE4;
            }
            goto LABEL_166;
          case 28:
            v191 = 9713618;
            v149 = *((_DWORD *)this + 184);
            v150 = v10[111];
            v7 = (char *)(9713618 - ((_DWORD)&loc_496535 + 5));
            v151 = v149 + *((_DWORD *)this + 185);
            v193 = 9713618 - ((_DWORD)&loc_496535 + 5);
            if ( v151 < v150 )
            {
              *((_DWORD *)this + 184) = *((_DWORD *)this + 185) - dword_4C1AE4 + 1 + v149;
              *((_DWORD *)this + 185) = dword_4C1AE4;
            }
            goto LABEL_166;
          default:
            goto LABEL_166;
        }
      }
    }
  }
  return v6;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (004311E0) --------------------------------------------------------
int __thiscall sub_4311E0(char *this, void *a2, int a3, char a4)
{
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // esi
  int v10; // ebx
  int result; // eax
  unsigned int v12; // [esp-18h] [ebp-58h]
  char v13[24]; // [esp+Ch] [ebp-34h] BYREF
  int v14[6]; // [esp+24h] [ebp-1Ch] BYREF
  int v15; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v15 = (int)this;
  strncpyt(&v14[1], a2, 16);
  v14[0] = a3;
  LOBYTE(v14[5]) = a4;
  v5 = 0;
  v6 = (_DWORD *)((char *)&loc_44DDEF + 1);
  do
    v5 -= *v6++;
  while ( v6 < (_DWORD *)((char *)&loc_44E19A + 2) );
  v7 = v5 - 1376953025;
  v8 = *(_DWORD *)&this[v7 + 495316];
  v9 = (int)&this[v7 + 495308];
  if ( v8 >= *(_DWORD *)(v9 + 4) )
  {
    if ( v8 >= 8 )
      v10 = v8 >= 32 ? 32 : 8;
    else
      v10 = 4;
    sub_40B780(24 * (v8 + v10), (void **)v9, (int)&savedregs);
    *(_DWORD *)(v9 + 4) += v10;
  }
  sub_46CAB0(*(_DWORD *)v9 + 8 * (3 * v8 + 3), (_BYTE *)(*(_DWORD *)v9 + 24 * v8), 24 * *(_DWORD *)(v9 + 8) - 24 * v8);
  v12 = 24 * v8 + *(_DWORD *)v9;
  ++*(_DWORD *)(v9 + 8);
  sub_46CAB0(v12, v13, 0x18u);
  result = v15;
  qmemcpy((void *)(24 * v8 + *(_DWORD *)v9), v14, 0x18u);
  ++*(_DWORD *)(result + 80);
  *(_BYTE *)(result + 96) = 1;
  return result;
}

//----- (004312D0) --------------------------------------------------------
int __thiscall sub_4312D0(int this)
{
  int *v2; // esi
  int result; // eax
  int v4; // edx
  int v5; // edx
  char v6; // [esp+8h] [ebp-8h] BYREF
  int v7; // [esp+9h] [ebp-7h]

  v2 = (int *)(this + 4);
  (*(void (__thiscall **)(int))(*(_DWORD *)(this + 4) + 60))(this + 4);
  if ( (*(int (__thiscall **)(int *))(*v2 + 40))(v2) != 1 && (*(int (__thiscall **)(int *))(*v2 + 40))(v2) != 2 )
    return -1;
  if ( !*(_BYTE *)(this + 1412) )
  {
    if ( sub_412400((_DWORD *)(this + 1424), 5000) )
      return -1;
    if ( !*(_BYTE *)(this + 1412) )
      goto LABEL_11;
  }
  if ( sub_412400((_DWORD *)(this + 1424), 120000) )
    return -1;
  if ( !*(_BYTE *)(this + 1412) )
  {
LABEL_11:
    if ( (*(int (__thiscall **)(int *))(*v2 + 40))(v2) == 2 )
    {
      v4 = *v2;
      v7 = *(_DWORD *)(this + 1440);
      v6 = 1;
      (*(void (__thiscall **)(int *, char *, int, int))(v4 + 16))(v2, &v6, 5, 1);
      *(_BYTE *)(this + 1412) = 1;
    }
  }
  if ( *(_BYTE *)(this + 1413) )
    return 100;
  v5 = (*(int (__thiscall **)(int *))(*v2 + 68))(v2) / 10;
  result = 100;
  if ( v5 < 100 )
    result = v5;
  return result;
}

//----- (004313D0) --------------------------------------------------------
int __thiscall sub_4313D0(_DWORD *this, int a2)
{
  int v3; // edi
  int v4; // kr00_4
  int v5; // ebp
  int v6; // edx
  int v7; // ebx
  int v8; // ebx
  int v9; // edi
  int v10; // eax
  int v11; // ecx
  bool v12; // cc
  _DWORD *v13; // ecx
  int v14; // eax
  int v15; // edi
  int result; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  _DWORD *v20; // ecx
  int v21; // edi
  char *v22; // esi
  _DWORD *v23; // [esp+24h] [ebp-424h]
  _DWORD *v24; // [esp+24h] [ebp-424h]
  char *v25; // [esp+28h] [ebp-420h]
  char *v26; // [esp+28h] [ebp-420h]
  char *v27; // [esp+28h] [ebp-420h]
  int v28; // [esp+2Ch] [ebp-41Ch]
  int v29; // [esp+2Ch] [ebp-41Ch]
  int v30; // [esp+34h] [ebp-414h]
  int v31; // [esp+3Ch] [ebp-40Ch]
  char v32[1024]; // [esp+48h] [ebp-400h] BYREF

  v3 = this[7062] / 2;
  v4 = this[7063];
  v28 = 0;
  v30 = 1000 * (this[2172] - v4 / 2 - 36);
  v5 = 1000 * (this[2171] - v3 - 36);
  v6 = 1000 * (this[2172] + v4 / 2 + 36);
  v7 = 125 * (this[2171] + v3 + 36);
  memset(v32, 0, sizeof(v32));
  v31 = v6;
  v8 = 8 * v7;
  if ( (int)this[1569] > 0 )
  {
    v23 = this + 545;
    do
    {
      v9 = *v23;
      if ( *(_DWORD *)(*v23 + 212) != -1 )
      {
        (*(void (__thiscall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)a2 + 264))(
          a2,
          *(_DWORD *)(v9 + 24),
          v9 + 220,
          *(_DWORD *)(*v23 + 212));
        v6 = v31;
      }
      if ( *(_DWORD *)(v9 + 28) == -1 && *(_DWORD *)(v9 + 92) != 8 && !*(_BYTE *)(v9 + 156) )
      {
        v10 = *(_DWORD *)(v9 + 4);
        v11 = *(_DWORD *)(v9 + 8);
        if ( v10 >= v5 && v10 < v8 && v11 >= v30 && v11 < v6 )
        {
          v25 = &v32[*(_DWORD *)(v9 + 24)];
          *v25 += (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v9 + 24))(v9, a2, (unsigned __int8)*v25);
          v6 = v31;
        }
      }
      v12 = ++v28 < this[1569];
      ++v23;
    }
    while ( v12 );
  }
  v13 = (_DWORD *)this[542];
  if ( v13[7] == -1 )
  {
    v14 = v13[1];
    v15 = v13[2];
    if ( v14 >= v5 && v14 < v8 && v15 >= v30 && v15 < v6 )
    {
      v26 = &v32[v13[6]];
      *v26 += (*(int (__thiscall **)(_DWORD *, int, _DWORD))(*v13 + 24))(v13, a2, (unsigned __int8)*v26);
      v6 = v31;
    }
  }
  result = this[1569];
  v29 = 0;
  if ( result > 0 )
  {
    v24 = this + 545;
    do
    {
      v17 = *v24;
      if ( *(_DWORD *)(*v24 + 28) != -1 && !*(_BYTE *)(v17 + 156) )
      {
        v18 = *(_DWORD *)(v17 + 4);
        if ( v18 >= v5 && v18 < v8 )
        {
          v19 = *(_DWORD *)(v17 + 8);
          if ( v19 >= v30 && v19 < v6 )
          {
            v27 = &v32[*(_DWORD *)(v17 + 28)];
            *v27 += (*(int (__stdcall **)(int, _DWORD))(*(_DWORD *)v17 + 24))(a2, (unsigned __int8)*v27);
            v6 = v31;
          }
        }
      }
      result = v29 + 1;
      v12 = ++v29 < this[1569];
      ++v24;
    }
    while ( v12 );
  }
  v20 = (_DWORD *)this[542];
  if ( v20[7] != -1 )
  {
    result = v20[1];
    v21 = v20[2];
    if ( result >= v5 && result < v8 && v21 >= v30 && v21 < v6 )
    {
      v22 = &v32[v20[7]];
      result = (*(int (__stdcall **)(int, _DWORD))(*v20 + 24))(a2, (unsigned __int8)*v22);
      *v22 += result;
    }
  }
  return result;
}

//----- (004316A0) --------------------------------------------------------
unsigned int __stdcall sub_4316A0(int a1, int a2, int a3, _DWORD *a4)
{
  int i; // ebp
  unsigned int result; // eax

  for ( i = 0; a3 || !i; ++i )
  {
    a1 -= a4[153];
    sub_404B80(a4, a1, a2, a3 % 10, 1);
    result = (unsigned int)((unsigned __int64)(1717986919i64 * a3) >> 32) >> 31;
    a3 /= 10;
  }
  return result;
}

//----- (00431700) --------------------------------------------------------
int sub_431700()
{
  __time32_t v0; // esi
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v5; // [esp+4h] [ebp-38h]
  _DWORD v6[3]; // [esp+8h] [ebp-34h] BYREF
  _DWORD v7[2]; // [esp+14h] [ebp-28h] BYREF
  _DWORD v8[8]; // [esp+1Ch] [ebp-20h] BYREF

  dword_4A70CC(v7);
  dword_4A710C(v8);
  dword_4A7314(v6);
  v0 = time_0(0);
  v1 = dword_4A70F4() ^ v0;
  v2 = dword_4A70B0() ^ v1;
  v3 = dword_4A7310() ^ v2;
  return v6[2] ^ v8[1] ^ v8[3] ^ v8[5] ^ ((v5 ^ (2 * v6[0])) << 16) ^ dword_4A7098() ^ v3 ^ v6[1];
}
// 431760: variable 'v5' is possibly undefined
// 4A7098: using guessed type int (*dword_4A7098)(void);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A70CC: using guessed type int (__stdcall *dword_4A70CC)(_DWORD);
// 4A70F4: using guessed type int (*dword_4A70F4)(void);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7310: using guessed type int (*dword_4A7310)(void);
// 4A7314: using guessed type int (__cdecl *dword_4A7314)(_DWORD);

//----- (00431830) --------------------------------------------------------
int __thiscall sub_431830(_DWORD *this, unsigned int a2)
{
  int result; // eax
  int v4; // esi
  int *i; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // ebx
  char v11[8]; // [esp+0h] [ebp-8h]

  result = this[30132];
  if ( result )
  {
    v11[0] = (8 * ((a2 & 1) == 0)) | 0xA2;
    v11[1] = (a2 & 2) != 0 ? -93 : -86;
    v11[2] = (a2 & 4) != 0 ? -92 : -86;
    v11[3] = (a2 & 8) != 0 ? -91 : -86;
    v11[4] = (a2 & 0x10) != 0 ? -90 : -86;
    v11[5] = (a2 & 0x20) != 0 ? -89 : -86;
    v11[6] = ~(unsigned __int8)(a2 >> 5) & 2 | 0xA8;
    v4 = this[431];
    v11[7] = -((a2 & 0x80u) != 0) - 86;
    for ( i = (int *)this[429]; v4; *(_BYTE *)(v7 + (v6 << 10) + this[30132]) = v11[v8] )
    {
      v6 = i[1];
      v7 = *i;
      v8 = i[2];
      i += 3;
      --v4;
    }
    v9 = 0;
    v10 = (_DWORD *)((char *)&loc_44DA63 + 1);
    do
      v9 -= *v10++;
    while ( v10 < (_DWORD *)((char *)&loc_44DE1B + 1) );
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)((char *)this + v9 - 208496668) + 160))(*(_DWORD *)((char *)this + v9 - 208496668));
  }
  return result;
}

//----- (00431940) --------------------------------------------------------
int __thiscall sub_431940(char *this, int a2, int a3)
{
  _DWORD *v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // ebx
  _DWORD *v17; // eax
  int v18; // edx
  int *v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // edi
  int v23; // eax
  int v24; // eax
  unsigned int v25; // ecx
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  unsigned int v29; // edi
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // edi
  int v37; // eax
  int v38; // ebx
  int v39; // eax
  int v40; // eax
  unsigned int v41; // ecx
  int v42; // edx
  int v43; // eax
  int v44; // ecx
  int v45; // eax
  int v46; // ecx
  int v47; // ecx
  int v48; // ecx
  unsigned __int16 v49; // dx
  _DWORD *v50; // ecx
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // edx
  int v56; // eax
  char *v57; // ecx
  int v58; // edi
  int *v59; // eax
  int v60; // edx
  _DWORD *v61; // ecx
  int v62; // eax
  _DWORD *v63; // ebx
  __int64 v64; // rax
  int v65; // edi
  __int64 v66; // rax
  __int64 v67; // rax
  int v68; // ecx
  int v69; // eax
  int v70; // ecx
  int v71; // ecx
  int v72; // [esp-Ch] [ebp-20h]
  int v73; // [esp-8h] [ebp-1Ch]
  int v74; // [esp-4h] [ebp-18h]
  int v75; // [esp-4h] [ebp-18h]
  int v76; // [esp+Ch] [ebp-8h]
  int v77; // [esp+Ch] [ebp-8h]
  int v78; // [esp+10h] [ebp-4h]
  int v79; // [esp+10h] [ebp-4h]
  int v80; // [esp+10h] [ebp-4h]

  v4 = (_DWORD *)*((_DWORD *)this + 542);
  if ( v4[23] == 8 )
  {
    if ( *(_DWORD *)(a3 + 88) == 27 )
      return (*(int (__thiscall **)(_DWORD *))(*v4 + 156))(v4);
    v4[5] = 0;
    *(_DWORD *)(*((_DWORD *)this + 542) + 16) = 0;
    if ( *(_DWORD *)(a3 + 88) == 13 )
    {
      (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 542) + 128))(*((_DWORD *)this + 542));
      *(_DWORD *)(a3 + 88) = 0;
    }
    (*(void (__thiscall **)(_DWORD, _DWORD))(**((_DWORD **)this + 30127) + 40))(*((_DWORD *)this + 30127), 0);
    v10 = 0;
    v11 = 0;
    v76 = 0;
    v78 = 0;
    if ( *(_BYTE *)(a3 + 58) )
    {
      v11 = -1;
      v78 = -1;
    }
    if ( *(_BYTE *)(a3 + 59) )
      v78 = ++v11;
    if ( *(_BYTE *)(a3 + 56) )
    {
      v10 = -1;
      v76 = -1;
    }
    if ( *(_BYTE *)(a3 + 57) )
      v76 = ++v10;
    if ( v10 || v11 )
    {
      v12 = 1046988946;
      v13 = 233;
      do
        v12 ^= *(_DWORD *)&aJvrollBm2[4 * v13-- - 559364];
      while ( v13 );
      *(_DWORD *)&this[v12 + 8205472] = 0;
      (*(void (__thiscall **)(char *, int))(*(_DWORD *)this + 192))(this, -1);
      *((_DWORD *)this + 28390) = -1;
      v14 = *(_BYTE *)(a3 + 60) != 0 ? 12000 : 5000;
      v15 = a2 * v78 * v14;
      v16 = a2 * v76 * v14;
      v17 = (_DWORD *)(*((_DWORD *)this + 542) + 4);
      *v17 += v16;
      v17[1] += v15;
      if ( (byte_4C1A9C & 1) == 0 )
      {
        dword_4C1AE8 = 0;
        dword_4C1AEC = 0;
        byte_4C1A9C |= 1u;
        dword_4C1AF0 = 16383999;
        dword_4C1AF4 = 16383999;
        sub_46E3C5(nullsub_8);
      }
      v18 = dword_4C1AE8;
      v19 = (int *)(*((_DWORD *)this + 542) + 4);
      if ( *v19 < dword_4C1AE8 || (v18 = dword_4C1AF0, *v19 > dword_4C1AF0) )
        *v19 = v18;
      v20 = v19[1];
      v21 = dword_4C1AEC;
      if ( v20 < dword_4C1AEC || (v21 = dword_4C1AF4, v20 > dword_4C1AF4) )
        v19[1] = v21;
    }
    if ( !*(_BYTE *)(a3 + 60) )
    {
      if ( *(_BYTE *)(a3 + 61) || *(_BYTE *)(a3 + 63) )
      {
LABEL_55:
        v40 = *((_DWORD *)this + 28116);
        v41 = *((_DWORD *)this + 28118);
        if ( v41 >= *(_DWORD *)(v40 + 6276) )
          v42 = 0;
        else
          v42 = *(_DWORD *)(v40 + 4 * v41 + 2180);
        if ( v42 && *(_DWORD *)(v42 + 92) != 8 )
        {
          v43 = 1209369571;
          v44 = 128;
          do
            v43 ^= *(_DWORD *)&aImageCropNotIm[4 * v44-- - 627084];
          while ( v44 );
          *(_DWORD *)&this[v43 + 10618432] = 1;
          (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 192))(this, *(_DWORD *)(v42 + 24));
        }
        goto LABEL_63;
      }
      v22 = *(_DWORD *)(a3 + 92);
      if ( v22 == 12 )
      {
        v23 = *((_DWORD *)this + 352);
        if ( v23 == 1 || v23 == 2 )
        {
          v24 = *((_DWORD *)this + 28116);
          v25 = *((_DWORD *)this + 28118);
          if ( v25 >= *(_DWORD *)(v24 + 6276) )
            v26 = 0;
          else
            v26 = *(_DWORD *)(v24 + 4 * v25 + 2180);
          if ( v26 && *(_DWORD *)(v26 + 92) != 8 )
          {
            v27 = -319492202;
            v28 = 248;
            do
              v27 ^= *(_DWORD *)&aBallbncWa2[4 * v28-- - 560608];
            while ( v28 );
            *(_DWORD *)&this[v27 + 11704264] = 2;
            *((_DWORD *)this + 28391) = *(_DWORD *)(v26 + 24);
          }
          goto LABEL_63;
        }
        goto LABEL_55;
      }
      if ( v22 == 13 )
      {
        if ( *((_DWORD *)this + 352) != 3 )
          *((_DWORD *)this + 30118) = -1;
        v29 = 0;
        v30 = *((_DWORD *)this + 30118) + 1;
        while ( 1 )
        {
          v31 = v30 & 7;
          v32 = *(_DWORD *)&this[4 * v31 + 117724];
          if ( v32 )
          {
            if ( *(__int16 *)(v32 + 42) <= 0x4000 )
              break;
          }
          ++v29;
          LOBYTE(v30) = v30 + 1;
          if ( v29 >= 8 )
            goto LABEL_54;
        }
        *((_DWORD *)this + 352) = 3;
        v33 = -1985265582;
        v34 = 240;
        do
          v33 ^= *(_DWORD *)&aFardownRight[4 * v34-- - 524452];
        while ( v34 );
        *(_DWORD *)&this[v33 + 13512400] = v31;
        v35 = *(_DWORD *)&this[4 * v31 + 117724];
        v36 = *(__int16 *)(v35 + 42);
        v74 = *(__int16 *)(v35 + 44);
        v79 = v74;
        LOWORD(v74) = 0;
        v37 = *((_DWORD *)this + 542);
        v38 = *(_DWORD *)this;
        LOBYTE(v35) = *(_BYTE *)(v37 + 96);
        v73 = v35;
        v72 = sub_432030((_DWORD *)(v37 + 520)) / 1000;
        v39 = sub_432030((_DWORD *)(*((_DWORD *)this + 542) + 32));
        (*(void (__thiscall **)(char *, int, int, _DWORD, int, int, int, int, int, int))(v38 + 180))(
          this,
          v36,
          v79,
          0,
          dword_4AAF30,
          dword_4AAF34,
          v39,
          v72,
          v73,
          v74);
        *(_DWORD *)(*((_DWORD *)this + 542) + 752) = *((_DWORD *)this + 5776);
LABEL_54:
        (*(void (__thiscall **)(char *, int))(*(_DWORD *)this + 192))(this, -1);
        *((_DWORD *)this + 28390) = -1;
      }
    }
LABEL_63:
    v45 = *((_DWORD *)this + 542);
    v80 = *(_DWORD *)(v45 + 8);
    v46 = *((_DWORD *)this + 352);
    v77 = *(_DWORD *)(v45 + 4);
    if ( v46 == 1 || v46 == 2 )
    {
      v51 = *((_DWORD *)this + 28390);
      if ( v51 < 0 || (v52 = *(_DWORD *)&this[4 * v51 + 113620]) == 0 || *(_DWORD *)(v52 + 92) == 8 )
      {
        v53 = *((_DWORD *)this + 28053);
        if ( v53 < 0 || (v54 = *(_DWORD *)&this[4 * v53 + 113620]) == 0 || *(_DWORD *)(v54 + 92) == 8 )
        {
          v55 = *((_DWORD *)this + 1569);
          v56 = 0;
          if ( v55 > 0 )
          {
            v57 = this + 2180;
            while ( *(_DWORD *)(*(_DWORD *)v57 + 92) == 8 )
            {
              ++v56;
              v57 += 4;
              if ( v56 >= v55 )
                goto LABEL_88;
            }
            (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 192))(
              this,
              *(_DWORD *)(*(_DWORD *)&this[4 * v56 + 2180] + 24));
          }
        }
      }
LABEL_88:
      v58 = *((_DWORD *)this + 28053);
      if ( v58 != *((_DWORD *)this + 28390) && v58 >= 0 )
      {
        v59 = *(int **)&this[4 * v58 + 113620];
        if ( v59 )
        {
          if ( *((_DWORD *)this + 5776) - v59[79] < 100 || v59[16] > 0 || v59[81] > 0 )
            *((_DWORD *)this + 28390) = v58;
        }
      }
      v60 = *((_DWORD *)this + 28390);
      if ( v60 < 0 )
        v61 = 0;
      else
        v61 = *(_DWORD **)&this[4 * v60 + 113620];
      v62 = *((_DWORD *)this + 28391);
      if ( v62 < 0 )
        v63 = 0;
      else
        v63 = *(_DWORD **)&this[4 * v62 + 113620];
      if ( *((_DWORD *)this + 352) != 2 || v60 != v58 )
        goto LABEL_109;
      if ( !v61 )
        goto LABEL_114;
      if ( v63
        && *((_DWORD *)this + 5776) - v63[79] < 100
        && (v64 = v61[1] - v63[1],
            v65 = 4 * v61[20],
            (int)((HIDWORD(v64) ^ v64) - HIDWORD(v64)) < 1000 * (*((_DWORD *)this + 7062) - v65))
        && (v66 = v61[2] - v63[2], (int)((HIDWORD(v66) ^ v66) - HIDWORD(v66)) < 1000 * (*((_DWORD *)this + 7063) - v65)) )
      {
        v67 = v63[1] + v61[1];
        v77 = ((int)v67 - HIDWORD(v67)) >> 1;
        v80 = (v63[2] + v61[2]) / 2;
      }
      else
      {
LABEL_109:
        if ( !v61 )
          goto LABEL_114;
        v80 = v61[2];
        v77 = v61[1];
        if ( (int)v61[16] > 0 && v61[19] )
        {
          v80 = -1;
          v77 = -1;
        }
      }
      v68 = v61[22];
      v69 = dword_4C1AE4 - v68;
      v70 = v68 - (dword_4C1AE4 - v68);
      dword_4C1AE4 = v69;
      *((_DWORD *)this + 28120) = v69;
      *((_DWORD *)this + 28119) = v70;
      goto LABEL_114;
    }
    if ( v46 != 3 )
      goto LABEL_114;
    v47 = *((_DWORD *)this + 30118);
    if ( v47 < 0 )
      goto LABEL_114;
    v48 = *(_DWORD *)&this[4 * v47 + 117724];
    if ( !v48 )
      goto LABEL_114;
    if ( *(_DWORD *)(v48 + 52) )
    {
      if ( *(int *)(v48 + 32) <= 0 )
      {
        v77 = *(_DWORD *)(v48 + 4);
        v80 = *(_DWORD *)(v48 + 8);
LABEL_114:
        v71 = *((_DWORD *)this + 542);
        *(_DWORD *)(v71 + 4) = v77;
        HIWORD(v75) = HIWORD(v71);
        *(_DWORD *)(v71 + 8) = v80;
        LOWORD(v75) = 0;
        (*(void (__thiscall **)(_DWORD, _DWORD, int))(**((_DWORD **)this + 542) + 132))(*((_DWORD *)this + 542), 0, v75);
        return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 542) + 120))(*((_DWORD *)this + 542), -1);
      }
    }
    else
    {
      v49 = *(_WORD *)(v48 + 50);
      if ( v49 < 0x400u )
      {
        v50 = *(_DWORD **)(*(_DWORD *)(v48 + 12) + 4 * (__int16)v49 + 113620);
        if ( v50 )
        {
          if ( v50[19] != 2 )
          {
            v77 = v50[1];
            v80 = v50[2];
            goto LABEL_114;
          }
        }
      }
    }
    v77 = *(_DWORD *)(v45 + 4);
    v80 = *(_DWORD *)(v45 + 8);
    goto LABEL_114;
  }
  v5 = v4[22];
  dword_4C1AE4 -= v5;
  v6 = v5 - dword_4C1AE4;
  *((_DWORD *)this + 28120) = dword_4C1AE4;
  *((_DWORD *)this + 28119) = v6;
  v7 = 350220006;
  v8 = 223;
  do
    v7 ^= *(_DWORD *)&aMutexAcquirePo[4 * v8-- - 612420];
  while ( v8 );
  *(_DWORD *)&this[v7 + (_DWORD)&loc_422A6E + 2] = -1;
  return (*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 192))(this, -1);
}
// 431B74: conditional instruction was optimized away because of 'edi.4==C'
// 432040: using guessed type int nullsub_8();
// 4AAF30: using guessed type int dword_4AAF30;
// 4AAF34: using guessed type int dword_4AAF34;
// 4C1A9C: using guessed type char byte_4C1A9C;
// 4C1AE4: using guessed type int dword_4C1AE4;
// 4C1AE8: using guessed type int dword_4C1AE8;
// 4C1AEC: using guessed type int dword_4C1AEC;
// 4C1AF0: using guessed type int dword_4C1AF0;
// 4C1AF4: using guessed type int dword_4C1AF4;

//----- (00432030) --------------------------------------------------------
int __thiscall sub_432030(_DWORD *this)
{
  return *this + this[1];
}

//----- (00432050) --------------------------------------------------------
char __thiscall sub_432050(int this, _DWORD *a2)
{
  void *v3; // eax
  int v4; // eax
  int v5; // ecx

  LOBYTE(v3) = *(_BYTE *)(this + 96);
  if ( (_BYTE)v3 )
  {
    sub_443D00((_DWORD *)this, a2);
    if ( a2[23] == 26 )
    {
      (*(void (__thiscall **)(int))(*(_DWORD *)this + 40))(this);
      *(_BYTE *)(this + 96) = 0;
      LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
    }
    else
    {
      v3 = memchr((char *)a2 + 99, 13, a2[89]);
      if ( v3 )
      {
        (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 100) + 276))(
          *(_DWORD *)(this + 100),
          *(_DWORD *)(this + 104) + 24 * *(_DWORD *)(this + 8) + 4);
        (*(void (__thiscall **)(int))(*(_DWORD *)this + 40))(this);
        v4 = 843150655;
        v5 = 137;
        do
          v4 ^= *(_DWORD *)&aAmericanEnglis[4 * v5-- - 580212];
        while ( v5 );
        *(_BYTE *)(v4 + this + 28400) = 0;
        LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
      }
    }
  }
  return (char)v3;
}

//----- (00432120) --------------------------------------------------------
int __thiscall sub_432120(char *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6, __int16 a7)
{
  int v8; // eax
  int v9; // eax
  _DWORD *i; // ebx
  char v12[2]; // [esp+8h] [ebp-10h] BYREF
  __int16 v13; // [esp+Ah] [ebp-Eh]
  __int16 v14; // [esp+Ch] [ebp-Ch]
  __int16 v15; // [esp+Eh] [ebp-Ah]
  __int16 v16; // [esp+10h] [ebp-8h]
  __int16 v17; // [esp+12h] [ebp-6h]
  int v18; // [esp+14h] [ebp-4h]

  v12[1] = a6;
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v8 = *(_DWORD *)this;
  v16 = a5;
  v12[0] = 31;
  v17 = a7;
  v18 = (*(int (__thiscall **)(char *))(v8 + 64))(this);
  v9 = 0;
  for ( i = (_DWORD *)(&loc_426113 + 1); (unsigned int)i < 0x4264DC; ++i )
    v9 -= *i;
  (*(void (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v9 - 529432531] + 16))(
    &this[v9 - 529432531],
    v12,
    16,
    1);
  return (*(int (__thiscall **)(char *, char *))(*(_DWORD *)this + 344))(this, v12);
}

//----- (00432840) --------------------------------------------------------
int __thiscall sub_432840(char *this)
{
  int v1; // ebx
  _WORD *v2; // ebp
  int v3; // edi
  _WORD *v4; // esi
  int v5; // eax
  int result; // eax
  int v7; // et2
  __int16 v8; // dx

  v1 = 0;
  v2 = this + 20534;
  do
  {
    v3 = 0;
    v4 = v2;
    v2 += 126;
    do
    {
      *(v4 - 1) = rand() % 640 + v1 - 2240;
      *v4 = rand() % 640 + v3 - 2240;
      v4[7937] = rand() % 640 + v1 - 2240;
      v5 = rand();
      v4 += 2;
      v7 = v5 % 640;
      result = v5 / 640;
      v8 = v7 + v3 - 2240;
      v3 += 320;
      v4[7936] = v8;
    }
    while ( v3 < 20160 );
    v1 += 320;
  }
  while ( v1 < 20160 );
  return result;
}

//----- (004328F0) --------------------------------------------------------
void __thiscall sub_4328F0(_DWORD *this, int a2)
{
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // edx
  int v6; // eax
  int v7; // ecx
  int v8; // ecx
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  if ( this[542] )
  {
    v3 = a2;
    if ( *(_BYTE *)(a2 + 1) < 8u )
    {
      if ( !this[*(unsigned __int8 *)(a2 + 1) + 29431] )
      {
        v4 = sub_40B720((int)&savedregs, 0x44u);
        v5 = (_DWORD *)v4;
        if ( v4 )
        {
          *(_DWORD *)(v4 + 12) = this;
          *(_DWORD *)(v4 + 8) = 0;
          *(_DWORD *)(v4 + 4) = 0;
          *(_DWORD *)(v4 + 20) = 0;
          *(_DWORD *)(v4 + 16) = 0;
          *(_DWORD *)v4 = off_4AC33C;
          *(_DWORD *)(v4 + 40) = 0;
          *(_DWORD *)(v4 + 44) = 0;
          *(_DWORD *)(v4 + 48) = 0;
          *(_DWORD *)(v4 + 52) = 0;
          *(_WORD *)(v4 + 50) = -1;
          *(_DWORD *)(v4 + 52) = 1;
          v6 = -1989813714;
          v7 = 240;
          do
            v6 ^= *(_DWORD *)&aGetsettings[4 * v7-- - 531564];
          while ( v7 );
          v3 = a2;
          *(_DWORD *)((char *)v5 + v6 + 180872) = 1000000;
          v5[9] = 0;
          v5[8] = 0;
          v5[14] = 0;
          v5[6] = 0;
          v5[16] = -1;
          v5[7] = 10;
        }
        else
        {
          v5 = 0;
        }
        this[*(unsigned __int8 *)(v3 + 1) + 29431] = v5;
      }
      v8 = this[*(unsigned __int8 *)(v3 + 1) + 29431];
      (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 16))(v8, v3);
    }
  }
}
// 4AC33C: using guessed type int (__stdcall *off_4AC33C[2])(int, int);

//----- (004329E0) --------------------------------------------------------
int __thiscall sub_4329E0(_BYTE *this, int a2)
{
  unsigned __int8 *v3; // eax
  int v4; // ecx
  int v5; // esi
  int v6; // edx
  _BYTE *v7; // eax
  int v8; // esi
  int v9; // ecx
  char *v10; // edi
  char v11; // dl
  char v12; // dl
  unsigned int v13; // esi
  bool v14; // bl
  bool v15; // bl
  void **v16; // ecx
  char v17; // al
  unsigned __int8 *v18; // ecx
  unsigned __int8 *v19; // ebx
  int v20; // edx
  int v21; // esi
  int v22; // eax
  _BYTE *v23; // ecx
  int v24; // esi
  int v25; // edx
  char *v26; // edi
  char v27; // al
  char v28; // al
  char *v29; // edi
  unsigned __int8 *v30; // eax
  int v31; // esi
  int v32; // ecx
  unsigned __int8 v33; // dl
  char v34; // dl
  int v35; // eax
  int v36; // esi
  int v37; // eax
  int v38; // edi
  int v39; // ecx
  char v40; // dl
  char v41; // dl
  bool v42; // bl
  int result; // eax
  int v44; // [esp+0h] [ebp-260h]
  char Buffer[128]; // [esp+Ch] [ebp-254h] BYREF
  char Format[256]; // [esp+8Ch] [ebp-1D4h] BYREF
  char v47[64]; // [esp+18Ch] [ebp-D4h] BYREF
  char v48[24]; // [esp+1CCh] [ebp-94h] BYREF
  int v49; // [esp+1E4h] [ebp-7Ch]
  _BYTE v50[64]; // [esp+1F0h] [ebp-70h] BYREF
  _DWORD v51[8]; // [esp+230h] [ebp-30h] BYREF
  int v52; // [esp+250h] [ebp-10h] BYREF
  int v53; // [esp+254h] [ebp-Ch] BYREF
  _BYTE *v54; // [esp+258h] [ebp-8h]
  unsigned int i; // [esp+25Ch] [ebp-4h] BYREF

  v54 = this;
  dword_4A7124(v48, v44);
  v51[0] = 32;
  *(_DWORD *)(a2 + 158) = v49;
  dword_4A710C(v51);
  *(_DWORD *)(a2 + 162) = v51[2];
  v3 = (unsigned __int8 *)&unk_4AD6A0;
  if ( !this[77] )
    v3 = (unsigned __int8 *)&unk_4AD670;
  v4 = v3[1];
  v5 = v3[2];
  v6 = *v3;
  v7 = v3 + 3;
  v8 = v6 ^ v5;
  v9 = v4 ^ 0x45;
  v10 = Format;
  Format[0] = v9 ^ *v7;
  if ( Format[0] )
  {
    do
    {
      v11 = v7[1];
      ++v10;
      ++v7;
      v9 ^= v8;
      v12 = v9 ^ v11;
      *v10 = v12;
    }
    while ( v12 );
  }
  if ( !dword_4A7028(-2147483646, Format, &i) )
  {
    v13 = i;
    if ( i )
    {
      sub_412910(v50, (unsigned __int8 *)aXaOeaiotaradew);
      i = 256;
      v14 = dword_4A7000(v13, v50, 0, 0, Format, &i) == 0;
      memset(v50, 0, sizeof(v50));
      if ( v14 )
        strncpyt((void *)(a2 + 166), Format, 40);
      sub_412910(v50, byte_4AD640);
      i = 256;
      v15 = dword_4A7000(v13, v50, 0, 0, Format, &i) == 0;
      memset(v50, 0, sizeof(v50));
      if ( v15 )
        strncpyt((void *)(a2 + 206), Format, 40);
      dword_4A702C(v13);
    }
  }
  v16 = &off_4AAF40;
  for ( i = (unsigned int)&off_4AAF40; ; v16 = (void **)i )
  {
    v17 = v54[77];
    if ( v17 )
      v18 = (unsigned __int8 *)*(v16 - 1);
    else
      v18 = (unsigned __int8 *)*v16;
    v19 = (unsigned __int8 *)&unk_4AD5E8;
    if ( !v17 )
      v19 = (unsigned __int8 *)&unk_4AD5B4;
    v20 = v18[1];
    v21 = v18[2];
    v22 = *v18;
    v23 = v18 + 3;
    v24 = v22 ^ v21;
    v25 = v20 ^ 0x45;
    v26 = v47;
    v47[0] = v25 ^ *v23;
    if ( v47[0] )
    {
      do
      {
        v27 = v23[1];
        ++v26;
        ++v23;
        v25 ^= v24;
        v28 = v25 ^ v27;
        *v26 = v28;
      }
      while ( v28 );
    }
    v29 = Format;
    v30 = v19 + 3;
    v31 = *v19 ^ v19[2];
    v32 = v19[1] ^ 0x45;
    Format[0] = v32 ^ v19[3];
    if ( Format[0] )
    {
      do
      {
        v33 = v30[1];
        ++v29;
        ++v30;
        v32 ^= v31;
        v34 = v32 ^ v33;
        *v29 = v34;
      }
      while ( v34 );
    }
    sprintf_0(Buffer, Format, v47, *(_DWORD *)(i + 4));
    v35 = dword_4A7028(-2147483646, Buffer, &v53);
    if ( !v35 )
    {
      v36 = v53;
      if ( v53 )
      {
        LOBYTE(v35) = BYTE1(dword_4AD5A4);
        v37 = v35 ^ 0x45;
        v38 = BYTE2(dword_4AD5A4) ^ (unsigned __int8)dword_4AD5A4;
        v50[0] = HIBYTE(dword_4AD5A4) ^ v37;
        if ( HIBYTE(dword_4AD5A4) != (unsigned __int8)v37 )
        {
          v39 = 0;
          do
          {
            v40 = byte_4AD5A8[v39++];
            v37 ^= v38;
            v41 = v37 ^ v40;
            v50[v39] = v41;
          }
          while ( v41 );
        }
        v52 = 256;
        v42 = dword_4A7000(v36, v50, 0, 0, Format, &v52) == 0;
        memset(v50, 0, sizeof(v50));
        if ( v42 )
          strncpyt((void *)(a2 + *(_DWORD *)(i - 8)), Format, 40);
        dword_4A702C(v36);
      }
    }
    result = i + 16;
    i += 16;
    if ( i >= (unsigned int)&unk_4AB010 )
      break;
  }
  return result;
}
// 4329F8: variable 'v44' is possibly undefined
// 4A7000: using guessed type int (__stdcall *dword_4A7000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7028: using guessed type int (__stdcall *dword_4A7028)(_DWORD, _DWORD, _DWORD);
// 4A702C: using guessed type int (__stdcall *dword_4A702C)(_DWORD);
// 4A710C: using guessed type int (__cdecl *dword_4A710C)(_DWORD);
// 4A7124: using guessed type int (__stdcall *dword_4A7124)(_DWORD, _DWORD);
// 4AAF40: using guessed type void *off_4AAF40;
// 4AD5A4: using guessed type int dword_4AD5A4;

//----- (00432CF0) --------------------------------------------------------
int __stdcall sub_432CF0(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // esi
  int v4; // [esp+0h] [ebp-524h] BYREF
  unsigned __int8 v5[1024]; // [esp+Ch] [ebp-518h] BYREF
  char v6[260]; // [esp+40Ch] [ebp-118h] BYREF
  int v7[2]; // [esp+510h] [ebp-14h] BYREF
  int v8; // [esp+520h] [ebp-4h]
  int savedregs; // [esp+524h] [ebp+0h] BYREF

  v7[1] = (int)&v4;
  v6[0] = 0;
  if ( a1 )
    sub_4079D0(v6, a1);
  else
    dword_4A7100(0, v6, 260);
  v8 = 1;
  a1 = -1;
  if ( sub_408AA0(v6) )
  {
    sub_407E80(&a1, (int)&savedregs, v6, 3, 3);
    v7[0] = -1;
    while ( 1 )
    {
      v2 = sub_408570(&a1, (int)v5, 1024);
      if ( !v2 )
        break;
      sub_401A70(v7, v5, v2);
    }
    v3 = ~v7[0];
    LOBYTE(v8) = 0;
    sub_4087F0(&a1);
    result = v3;
  }
  else
  {
    LOBYTE(v8) = 0;
    sub_4087F0(&a1);
    result = 0;
  }
  return result;
}
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);

//----- (00432DF0) --------------------------------------------------------
int __thiscall sub_432DF0(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // esi
  int result; // eax

  v3 = this[30132];
  v4 = this[a2 + 28121];
  if ( v3 )
    *(_BYTE *)(*(_DWORD *)(v4 + 4) + (*(_DWORD *)(v4 + 8) << 10) + v3) = 0;
  v5 = 0;
  v6 = &loc_43540C;
  do
    v5 -= *v6++;
  while ( v6 < (_DWORD *)((char *)&loc_4354FE + 6) );
  v7 = (int)this + v5 + 1721180015;
  sub_40B7E0(*(_DWORD *)(v7 + 4 * a2));
  sub_46CAB0(v7 + 4 * a2, (_BYTE *)(v7 + 4 * (a2 + 1)), 4 * (*(_DWORD *)(v7 + 1024) + 0x3FFFFFFF * (a2 + 1)));
  result = *(_DWORD *)(v7 + 1024) - 1;
  *(_DWORD *)(v7 + 1024) = result;
  return result;
}

//----- (00432E80) --------------------------------------------------------
int __thiscall sub_432E80(_DWORD *this)
{
  int result; // eax
  int v2; // edi
  int v3; // ebx
  _DWORD *v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  int v8; // esi
  _DWORD *v9; // ebx
  unsigned int v10; // eax
  _DWORD *v11; // [esp+4h] [ebp-18h]
  int v12; // [esp+8h] [ebp-14h]
  int v13; // [esp+Ch] [ebp-10h]
  unsigned int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]

  result = this[7060];
  v2 = 0;
  if ( result > 0 )
  {
    v3 = 0;
    v4 = this + 6804;
    do
    {
      if ( (**(unsigned __int8 (__thiscall ***)(_DWORD))*v4)(*v4) )
      {
        v13 = v3;
        v5 = 4 * v2;
        v15 = 4 * v2--;
        v12 = v3 - 0x3FFFFFFF;
        v11 = v4 - 1;
        v6 = 1986649952;
        v7 = 244;
        do
          v6 ^= (unsigned int)*(&dword_4A706C + v7-- - 134507);
        while ( v7 );
        v8 = (int)this + v6 + 66745560;
        v9 = *(_DWORD **)(v5 + v8);
        v10 = v5 + v8;
        v14 = v5 + v8;
        if ( v9 )
        {
          *v9 = &off_4AC354;
          sub_441B30((int)v9, 0);
          sub_40B7E0((unsigned int)v9);
          v5 = v15;
          v10 = v14;
        }
        sub_46CAB0(v10, (_BYTE *)(v5 + v8 + 4), 4 * (v13 + 0x3FFFFFFF + *(_DWORD *)(v8 + 1024)));
        v3 = v12;
        --*(_DWORD *)(v8 + 1024);
        v4 = v11;
      }
      result = (int)this;
      ++v2;
      v3 += 0x3FFFFFFF;
      ++v4;
    }
    while ( v2 < this[7060] );
  }
  return result;
}
// 4A706C: using guessed type int (__stdcall *dword_4A706C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4AC354: using guessed type int (*off_4AC354)();

//----- (00432F80) --------------------------------------------------------
void __thiscall sub_432F80(_DWORD *this, int a2)
{
  long double v3; // st7
  int v4; // esi
  __int64 v5; // rax
  int v6; // ebx
  int v7; // ebp
  int v8; // ebx
  int v9; // ecx
  int v10; // esi
  int v11; // ebx
  _DWORD *v12; // eax
  unsigned int v13; // esi
  int v14; // eax
  int v15; // ecx
  int v16; // esi
  int v17; // ebx
  int v18; // [esp+10h] [ebp-3Ch]
  int v19; // [esp+14h] [ebp-38h]
  int v20; // [esp+18h] [ebp-34h]
  int v21; // [esp+1Ch] [ebp-30h]
  int v22; // [esp+20h] [ebp-2Ch]
  int v23; // [esp+24h] [ebp-28h]
  int v24; // [esp+28h] [ebp-24h]
  int v25; // [esp+2Ch] [ebp-20h]
  int v26; // [esp+2Ch] [ebp-20h]
  int v27; // [esp+34h] [ebp-18h]

  v3 = (double)(this[15] / 1000) * dbl_4AC920;
  v4 = (__int64)(sin(v3) * dbl_4A91C0);
  v5 = (__int64)(cos(v3) * dbl_4AD6D0);
  v6 = this[20];
  v7 = this[1] - v6 * v4;
  v27 = this[2] - v6 * v5;
  v20 = -2 * a2 * v4;
  v21 = -2 * a2 * v5;
  v8 = 3250 - (int)(3 * abs32(this[107])) / 6;
  v9 = v8 * (int)v5 / 1000;
  v18 = v9;
  LODWORD(v5) = this[118];
  v10 = v8 * v4 / -1000;
  v19 = v10;
  this[118] = v5 + 1;
  if ( (v5 & 1) != 0 )
  {
    v9 = -v9;
    v10 = -v10;
    v18 = v9;
    v19 = v10;
  }
  v11 = v9 / 8;
  v22 = v9 / 8;
  v23 = v10 / 10;
  v12 = (_DWORD *)sub_40B720(v7, 0x40u);
  v13 = (unsigned int)v12;
  if ( v12 )
  {
    v24 = v20 + this[4] - v11;
    v25 = v21 + this[5] - v23;
    sub_416F60(v12, this[3]);
    *(_DWORD *)(v13 + 28) = 57;
    *(_DWORD *)(v13 + 48) = 57;
    *(_DWORD *)(v13 + 4) = v7 - v18;
    v11 = v22;
    *(_DWORD *)(v13 + 8) = v27 - v19;
    *(_DWORD *)(v13 + 20) = 0;
    *(_DWORD *)(v13 + 16) = 0;
    *(_DWORD *)(v13 + 16) = v24;
    *(_DWORD *)(v13 + 56) = v24;
    *(_DWORD *)(v13 + 24) = 20;
    *(_DWORD *)(v13 + 32) = 0;
    *(_DWORD *)(v13 + 36) = 9;
    *(_DWORD *)(v13 + 44) = 19;
    *(_BYTE *)(v13 + 52) = 0;
    *(_DWORD *)v13 = off_4AC414;
    *(_DWORD *)(v13 + 20) = v25;
    *(_DWORD *)(v13 + 60) = v25;
    *(_DWORD *)(v13 + 40) = 0;
  }
  else
  {
    v13 = 0;
  }
  v14 = this[3] + 7656;
  v15 = *(_DWORD *)(this[3] + 8680);
  if ( v15 >= 256 )
  {
    sub_40B7E0(v13);
  }
  else
  {
    *(_DWORD *)(v14 + 4 * v15) = v13;
    ++*(_DWORD *)(v14 + 1024);
  }
  v16 = sub_40B720(v7, 0x40u);
  if ( v16 )
  {
    v17 = v20 + this[4] + v11;
    v26 = v23 + v21 + this[5];
    sub_433270((_DWORD *)v16, this[3]);
    *(_DWORD *)(v16 + 4) = v18 + v7;
    *(_DWORD *)(v16 + 28) = 57;
    *(_DWORD *)(v16 + 48) = 57;
    *(_DWORD *)(v16 + 8) = v19 + v27;
    *(_DWORD *)(v16 + 16) = v17;
    *(_DWORD *)(v16 + 56) = v17;
    *(_DWORD *)(v16 + 24) = 20;
    *(_DWORD *)(v16 + 32) = 0;
    *(_DWORD *)(v16 + 36) = 9;
    *(_DWORD *)(v16 + 44) = 19;
    *(_BYTE *)(v16 + 52) = 0;
    *(_DWORD *)v16 = off_4AC414;
    *(_DWORD *)(v16 + 20) = v26;
    *(_DWORD *)(v16 + 60) = v26;
    *(_DWORD *)(v16 + 40) = 0;
  }
  else
  {
    v16 = 0;
  }
  sub_454F80((_DWORD *)(this[3] + 7656), v16);
}
// 4A91C0: using guessed type double dbl_4A91C0;
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4AC920: using guessed type double dbl_4AC920;
// 4AD6D0: using guessed type double dbl_4AD6D0;

//----- (00433270) --------------------------------------------------------
_DWORD *__thiscall sub_433270(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = a2;
  this[2] = 0;
  this[1] = 0;
  *this = off_4AD124;
  this[5] = 0;
  this[4] = 0;
  return result;
}
// 4AD124: using guessed type int (__stdcall *off_4AD124[2])(int, int);

//----- (00433290) --------------------------------------------------------
void __thiscall sub_433290(_DWORD *this)
{
  long double v2; // st7
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // ebp
  int v10; // ebx
  int v11; // esi
  _DWORD *v12; // eax
  unsigned int v13; // esi
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // esi
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // ecx
  _DWORD *v25; // esi
  _DWORD *v26; // eax
  int v27; // ecx
  int v28; // ebx
  int v29; // ebp
  __int64 v30; // rax
  _DWORD *v31; // ecx
  int v32; // [esp-4h] [ebp-48h]
  int v33; // [esp+10h] [ebp-34h]
  int v34; // [esp+10h] [ebp-34h]
  int v35; // [esp+10h] [ebp-34h]
  int v36; // [esp+14h] [ebp-30h]
  int v37; // [esp+14h] [ebp-30h]
  int v38; // [esp+18h] [ebp-2Ch] BYREF
  int v39; // [esp+1Ch] [ebp-28h]
  int v40; // [esp+20h] [ebp-24h] BYREF
  int v41; // [esp+24h] [ebp-20h]
  int v42; // [esp+28h] [ebp-1Ch]
  int v43; // [esp+2Ch] [ebp-18h]
  int v44; // [esp+30h] [ebp-14h]
  int v45; // [esp+34h] [ebp-10h]
  int v46; // [esp+40h] [ebp-4h]

  v2 = (double)(this[15] / 1000) * dbl_4AC920;
  v3 = (__int64)(sin(v2) * dbl_4A91C0);
  v4 = this[2];
  v40 = this[1] - 14 * v3;
  v5 = (__int64)(cos(v2) * dbl_4AD6D0);
  v41 = v4 - 14 * v5;
  v33 = 3500 - (int)(3 * abs32(this[107])) / 6;
  v6 = v33 * v5 / 1000;
  v38 = v6;
  v7 = v33 * v3 / -1000;
  v8 = this[118];
  v9 = -2 * v3;
  v10 = -2 * v5;
  v11 = v7;
  v39 = v7;
  this[118] = v8 + 1;
  if ( (v8 & 1) != 0 )
  {
    v6 = -v6;
    v11 = -v7;
    v38 = v6;
    v39 = -v7;
  }
  v42 = v6 / 6;
  v43 = v11 / 6;
  v12 = (_DWORD *)sub_40B720(v9, 0x40u);
  v13 = (unsigned int)v12;
  if ( v12 )
  {
    v14 = v10 + this[5];
    v44 = v9 + this[4] - v42;
    v45 = v14 - v43;
    v34 = v40 - v38;
    v36 = v41 - v39;
    sub_433270(v12, this[3]);
    *(_DWORD *)(v13 + 28) = 60;
    *(_DWORD *)(v13 + 48) = 60;
    *(_DWORD *)(v13 + 4) = v34;
    v15 = v45;
    *(_DWORD *)(v13 + 8) = v36;
    v16 = v44;
    *(_DWORD *)(v13 + 16) = v44;
    *(_DWORD *)(v13 + 56) = v16;
    *(_DWORD *)(v13 + 24) = 30;
    *(_DWORD *)(v13 + 32) = 0;
    *(_DWORD *)(v13 + 36) = 10;
    *(_DWORD *)(v13 + 44) = 20;
    *(_BYTE *)(v13 + 52) = 0;
    *(_DWORD *)v13 = off_4AC414;
    *(_DWORD *)(v13 + 20) = v15;
    *(_DWORD *)(v13 + 60) = v15;
    *(_DWORD *)(v13 + 40) = 0;
  }
  else
  {
    v13 = 0;
  }
  v17 = this[3] + 7656;
  v18 = *(_DWORD *)(this[3] + 8680);
  if ( v18 >= 256 )
  {
    sub_40B7E0(v13);
  }
  else
  {
    *(_DWORD *)(v17 + 4 * v18) = v13;
    ++*(_DWORD *)(v17 + 1024);
  }
  v19 = sub_40B720(v9, 0x40u);
  if ( v19 )
  {
    v35 = v9 + this[4];
    v20 = this[5];
    v44 = v40;
    v37 = v10 + v20;
    v32 = this[3];
    v45 = v41;
    sub_433270((_DWORD *)v19, v32);
    *(_DWORD *)(v19 + 28) = 60;
    *(_DWORD *)(v19 + 48) = 60;
    v21 = v44;
    *(_DWORD *)(v19 + 24) = 20;
    *(_DWORD *)(v19 + 44) = 20;
    v22 = v45;
    *(_DWORD *)(v19 + 4) = v21;
    *(_DWORD *)(v19 + 8) = v22;
    *(_DWORD *)(v19 + 16) = v35;
    *(_DWORD *)(v19 + 56) = v35;
    *(_DWORD *)(v19 + 32) = 0;
    *(_DWORD *)(v19 + 36) = 10;
    *(_BYTE *)(v19 + 52) = 0;
    *(_DWORD *)v19 = off_4AC414;
    *(_DWORD *)(v19 + 20) = v37;
    *(_DWORD *)(v19 + 60) = v37;
    *(_DWORD *)(v19 + 40) = 0;
  }
  else
  {
    v19 = 0;
  }
  v23 = this[3] + 7656;
  v24 = *(_DWORD *)(this[3] + 8680);
  if ( v24 >= 256 )
  {
    sub_40B7E0(v19);
  }
  else
  {
    *(_DWORD *)(v23 + 4 * v24) = v19;
    ++*(_DWORD *)(v23 + 1024);
  }
  v25 = (_DWORD *)sub_40B720(v9, 0x40u);
  v26 = 0;
  v46 = 0;
  if ( v25 )
  {
    v27 = v10 + this[5];
    v28 = v9 + this[4] + v42;
    v29 = v27 + v43;
    v30 = sub_4552B0(&v40, &v38);
    v26 = sub_418C40(v25, 10, v30, SHIDWORD(v30), v28, v29, 0, 20, 60, 60, 0, 30, this[3]);
  }
  v31 = (_DWORD *)(this[3] + 7656);
  v46 = -1;
  sub_454F80(v31, (unsigned int)v26);
}
// 4A91C0: using guessed type double dbl_4A91C0;
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4AC920: using guessed type double dbl_4AC920;
// 4AD6D0: using guessed type double dbl_4AD6D0;

//----- (004335F0) --------------------------------------------------------
int __thiscall sub_4335F0(_DWORD *this, char *Buffer, int a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // edi
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // edx
  int v12; // eax
  int v13; // ecx
  _DWORD *v14; // esi
  int v15; // edi
  int v16; // ecx
  int v17; // ebx
  int v18; // ecx
  char *v19; // ecx
  char *v20; // edx
  char *v21; // esi
  _DWORD *v22; // eax
  bool v23; // cc
  int v24; // eax
  unsigned int v25; // ebx
  int v26; // eax
  int v27; // [esp+Ch] [ebp-18h]
  int v29; // [esp+10h] [ebp-14h]
  int v30; // [esp+14h] [ebp-10h]
  int v31; // [esp+18h] [ebp-Ch]
  int v32; // [esp+1Ch] [ebp-8h]
  int v33; // [esp+20h] [ebp-4h]
  int v34; // [esp+30h] [ebp+Ch]
  int v35; // [esp+34h] [ebp+10h]

  v4 = a3;
  v5 = this;
  if ( this[25] == 4 && (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, a3) - 1 != a4 )
  {
    v6 = v5[29];
    v7 = v5[20];
    v8 = 0;
    v9 = v6 + 4 * a3 + 2180;
    v10 = *(_DWORD *)(*(_DWORD *)v9 + 88);
    if ( a3 < v7 )
    {
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)v9 + 88) != v10 )
          break;
        ++v8;
        ++v4;
        v9 += 4;
      }
      while ( v4 < v7 );
    }
    if ( v10 > 0x270F )
      sprintf_0(Buffer, a3d, v8);
    else
      sprintf_0(Buffer, (const char *const)(9113934 - (_DWORD)&loc_403A5E), v10, v8);
    return 3;
  }
  v12 = v5[29];
  v13 = v5[25];
  v14 = *(_DWORD **)(v12 + 4 * a3 + 2180);
  if ( v13 < 5 )
  {
    sprintf_0(Buffer, off_4B8188[v5[25]], (char *)v14 + 109, v5[30], v14[40] + v14[41]);
    goto LABEL_12;
  }
  if ( v13 == 5 )
  {
    v16 = v14[51];
    v17 = 10 * (v14[40] + 10 * (v16 - v14[52])) / (v16 + 100);
    if ( v17 < 0 )
      v17 = 0;
    if ( v16 )
      v18 = 10 * v14[40] / v16;
    else
      v18 = 0;
    sprintf_0(
      Buffer,
      off_4B8188[v5[25]],
      (char *)v14 + 109,
      (char *)v14 + 170,
      v14[51],
      v14[52],
      v17,
      v18 / 10,
      v18 % 10);
    goto LABEL_12;
  }
  if ( v13 != 6 )
  {
LABEL_12:
    v15 = v5[29];
    if ( *(_DWORD *)(v15 + 23104) - v14[38] < 3000 )
      return 2;
    v26 = -(*(_DWORD *)(*(_DWORD *)(v15 + 2168) + 88) != v14[22]);
    LOBYTE(v26) = v26 & 0xFC;
    return v26 + 4;
  }
  v35 = -1;
  v30 = 0;
  v27 = *(_DWORD *)(v12 + 6276);
  if ( v27 <= 0 )
  {
    v19 = Buffer;
    v20 = Buffer;
    v21 = Buffer;
  }
  else
  {
    v19 = Buffer;
    v20 = Buffer;
    v21 = Buffer;
    v32 = v12 + 2180;
    do
    {
      v22 = *(_DWORD **)v32;
      if ( *(_DWORD *)(*(_DWORD *)v32 + 88) != v35 )
      {
        if ( --a3 < -1 )
          break;
        v19 = 0;
        v21 = 0;
        v35 = *(_DWORD *)(*(_DWORD *)v32 + 88);
        v20 = 0;
        v33 = 0;
        v31 = 0;
      }
      ++v31;
      v33 += v22[40] + v22[41];
      v19 += v22[51];
      v20 += v22[52];
      v21 += v22[12] + v22[13];
      v23 = ++v30 < v27;
      v32 += 4;
    }
    while ( v23 );
    v5 = this;
  }
  v24 = v5[29];
  if ( *(int *)(v24 + 7500) <= 0 )
  {
    v25 = v35;
  }
  else
  {
    v29 = *(_DWORD *)(v24 + 7500);
    v25 = v35;
    v34 = v24 + 6284;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v34 + 20) == v35 )
        ++v21;
      v34 += 4;
      --v29;
    }
    while ( v29 );
  }
  if ( v25 > 0x270F )
    sprintf_0(Buffer, off_4B81A4, v33, v19, v20, v21);
  else
    sprintf_0(Buffer, off_4B81A0[0], v25, v33, v19, v20, v21);
  return v25 != *(_DWORD *)(*(_DWORD *)(v5[29] + 2168) + 88) ? 0 : 4;
}
// 433840: variable 'v31' is possibly undefined
// 433856: variable 'v33' is possibly undefined
// 4B8188: using guessed type char *[8];
// 4B81A0: using guessed type char *[2];
// 4B81A4: using guessed type char *;

//----- (00433A70) --------------------------------------------------------
void __thiscall sub_433A70(unsigned int *this, int a2)
{
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  unsigned int *v7; // esi
  int v8; // ebx

  v3 = this[542];
  v4 = *(_DWORD *)(v3 + 820);
  if ( v4 > 0 )
  {
    *(_DWORD *)(v3 + 820) = v4 - a2;
    if ( *(int *)(this[542] + 820) <= 0 )
    {
      v5 = 1307235475;
      v6 = 128;
      do
        v5 ^= *(_DWORD *)&aWerollBm2[4 * v6-- - 639416];
      while ( v6 );
      (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)((char *)this + v5 + 90005576) + 136))(
        *(unsigned int *)((char *)this + v5 + 90005576),
        0);
    }
  }
  v7 = this + 29431;
  v8 = 8;
  do
  {
    if ( *v7 )
    {
      if ( !(*(unsigned __int8 (__thiscall **)(unsigned int, int))(*(_DWORD *)*v7 + 20))(*v7, a2) )
      {
        sub_40B7E0(*v7);
        *v7 = 0;
      }
    }
    ++v7;
    --v8;
  }
  while ( v8 );
}

//----- (00433BA0) --------------------------------------------------------
void __thiscall sub_433BA0(int this, char a2)
{
  if ( *(_DWORD *)(*(_DWORD *)(this + 1208) + 7987) != 2 )
    sub_404B80(
      *(_DWORD **)(this + 11524),
      *(_DWORD *)(this + 8) - *(_DWORD *)(*(_DWORD *)(this + 11524) + 612),
      *(_DWORD *)(this + 12) / 2 + 4 * *(_DWORD *)(*(_DWORD *)(this + 11524) + 616) - 44,
      (a2 == 0) + 36,
      0);
}

//----- (00433C00) --------------------------------------------------------
int __thiscall sub_433C00(int *this)
{
  int v2; // eax
  _DWORD *v3; // ebx
  int v4; // edx
  char v6[2]; // [esp+8h] [ebp-10h] BYREF
  unsigned int v7; // [esp+Ah] [ebp-Eh]
  int v8; // [esp+Eh] [ebp-Ah]
  int v9; // [esp+12h] [ebp-6h]

  v8 = 0;
  v6[0] = 0;
  v6[1] = 5;
  v9 = 0;
  v7 = sub_412170() / 0xAu;
  v8 = this[229];
  v2 = 0;
  v3 = (_DWORD *)((char *)&loc_44FC13 + 1);
  do
    v2 -= *v3++;
  while ( v3 < (_DWORD *)&loc_44FF40 );
  v4 = *this;
  v9 = *(int *)((char *)this + v2 - 1081723682);
  return (*(int (__thiscall **)(int *, int, char *))(v4 + 20))(this, 14, v6);
}

//----- (00433C70) --------------------------------------------------------
char __thiscall sub_433C70(int *this, int a2, char a3)
{
  char result; // al
  int v5; // edi
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  int v11; // eax
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edx
  int v16; // eax
  unsigned int v17; // ebx
  int v18; // eax
  int v19; // ecx
  int v20; // edi
  int v21; // eax
  int v22; // edi
  int v23; // eax
  int *v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // edi
  int v30; // edx
  int v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // ebx
  int v38; // eax
  int v39; // edi
  int v40; // edx
  int v41; // eax
  int v42; // [esp+8h] [ebp-18h]
  int v43; // [esp+Ch] [ebp-14h]
  int v44; // [esp+Ch] [ebp-14h]
  unsigned int v45; // [esp+10h] [ebp-10h]
  int v46; // [esp+10h] [ebp-10h]
  int v47; // [esp+14h] [ebp-Ch]
  int v48; // [esp+14h] [ebp-Ch]
  int v49; // [esp+14h] [ebp-Ch]
  int v50; // [esp+18h] [ebp-8h]
  int v51; // [esp+18h] [ebp-8h]
  char v52; // [esp+1Fh] [ebp-1h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF
  int v54; // [esp+28h] [ebp+8h]

  if ( this[1569] > 1 && this[356] > 800 )
    a3 = 0;
  result = a2;
  v52 = 0;
  if ( a2 )
  {
    v5 = a2;
    v42 = a2;
    while ( 1 )
    {
      v50 = this[1569] * this[2788] / 1000;
      if ( v50 > 256 )
        v50 = 256;
      v6 = this[2872];
      v7 = this[30119] + 1;
      this[30119] = v7;
      if ( v7 >= v6 )
      {
        v8 = 1570020710;
        v9 = 247;
        do
          v8 ^= *(_DWORD *)&a04d3d[4 * v9-- - 565200];
        while ( v9 );
        *(int *)((char *)this + v8 + 100740908) = 0;
        v43 = 0;
        if ( this[2954] > 0 )
        {
          do
          {
            v10 = this[2748] + this[1569] * this[2742];
            if ( v10 <= 1024 )
            {
              if ( v10 < 3 )
                v10 = 3;
            }
            else
            {
              v10 = 1024;
            }
            v11 = 2836 * (this[29440] / 127773);
            v12 = 16807 * (this[29440] % 127773) - v11 + 123;
            if ( v12 <= 0 )
              v12 = 16807 * (this[29440] % 127773) - v11 - 2147483526;
            this[29440] = v12;
            v47 = v10 - 2;
            v13 = (1024 - v10) / 2;
            v45 = this[29440] % v47 + v13 + 1;
            v14 = 2836 * (this[29440] / 127773);
            v15 = this[29440] % 127773;
            v16 = 16807 * v15 - v14 + 123;
            if ( v16 <= 0 )
              v16 = 16807 * v15 - v14 - 2147483526;
            this[29440] = v16;
            v17 = v16 % v47 + v13 + 1;
            v18 = (*(int (__thiscall **)(int *))(*this + 392))(this);
            v19 = this[29440];
            v48 = v18;
            v20 = 2836 * (v19 / 127773);
            v21 = 16807 * (v19 % 127773) - v20 + 123;
            if ( v21 <= 0 )
              v21 = 16807 * (v19 % 127773) - v20 - 2147483526;
            this[29440] = v21;
            v22 = this[3041] + v21 % (this[2917] - this[3041] + 1);
            if ( v48 )
            {
              if ( a3 )
              {
                if ( this[28377] < v50 )
                {
                  v23 = this[30132];
                  if ( !v23 || v45 < 0x400 && v17 < 0x400 && !*(_BYTE *)(v23 + (v17 << 10) + v45) )
                  {
                    v24 = (int *)sub_40B720((int)&savedregs, 0x10u);
                    if ( v24 )
                    {
                      *v24 = v48;
                      v24[3] = v22;
                      v24[1] = v45;
                      v24[2] = v17;
                    }
                    else
                    {
                      v24 = 0;
                    }
                    (*(void (__thiscall **)(int *, int *))(*this + 96))(this, v24);
                  }
                }
              }
            }
            ++v43;
          }
          while ( v43 < this[2954] );
          v5 = a2;
        }
      }
      v25 = this[2891];
      v26 = this[1878] + 1;
      this[1878] = v26;
      if ( v26 < v25 )
        goto LABEL_59;
      v27 = -1501329181;
      v28 = 242;
      do
        v27 ^= *(_DWORD *)&aGif[4 * v28-- - 383168];
      while ( v28 );
      *(int *)((char *)this + v27 + 103764792) = 0;
      v5 = this[3001];
      v52 = 1;
      a2 = v5;
      if ( v5 == -1 )
        break;
      if ( v5 == -2 )
      {
        v39 = 2836 * (this[469] / 127773);
        v40 = this[469] % 127773;
        v41 = 16807 * v40 - v39 + 123;
        if ( v41 <= 0 )
          v41 = 16807 * v40 - v39 - 2147483526;
        this[469] = v41;
        v5 = v41 % 256;
        goto LABEL_58;
      }
LABEL_59:
      if ( !--v42 )
      {
        result = v52;
        if ( v52 )
          result = (*(int (__thiscall **)(int *, int))(*this + 368))(this, v5);
        return result;
      }
    }
    v29 = 2836 * (this[469] / 127773);
    v30 = this[469] % 127773;
    v31 = 16807 * v30 - v29 + 123;
    if ( v31 <= 0 )
      v31 = 16807 * v30 - v29 - 2147483526;
    this[469] = v31;
    v51 = v31;
    v32 = 16807 * (v31 % 127773) - 2836 * (v31 / 127773) + 123;
    if ( v32 <= 0 )
      v32 += 0x7FFFFFFF;
    this[469] = v32;
    v49 = v32;
    v33 = 16807 * (v32 % 127773) - 2836 * (v32 / 127773) + 123;
    if ( v33 <= 0 )
      v33 += 0x7FFFFFFF;
    this[469] = v33;
    v46 = v33;
    v34 = 16807 * (v33 % 127773) - 2836 * (v33 / 127773) + 123;
    if ( v34 <= 0 )
      v34 += 0x7FFFFFFF;
    this[469] = v34;
    v44 = v34;
    v35 = 16807 * (v34 % 127773) - 2836 * (v34 / 127773) + 123;
    if ( v35 <= 0 )
      v35 += 0x7FFFFFFF;
    this[469] = v35;
    v54 = v35;
    v36 = 16807 * (v35 % 127773) - 2836 * (v35 / 127773) + 123;
    if ( v36 <= 0 )
      v36 += 0x7FFFFFFF;
    this[469] = v36;
    v37 = v36;
    v38 = 16807 * (v36 % 127773) - 2836 * (v36 / 127773) + 123;
    if ( v38 <= 0 )
      v38 += 0x7FFFFFFF;
    this[469] = v38;
    v5 = (v51 % 2 != 0 ? 0x11 : 0)
       + (v49 % 4 != 0 ? 2 : 0)
       + (v46 % 8 != 0 ? 4 : 0)
       + (v44 % 16 != 0 ? 8 : 0)
       + (v54 % 4 != 0 ? 0x20 : 0)
       + (v37 % 8 != 0 ? 0x40 : 0)
       + (v38 % 16 != 0 ? 0x80 : 0);
LABEL_58:
    a2 = v5;
    goto LABEL_59;
  }
  return result;
}

//----- (004343D0) --------------------------------------------------------
int __thiscall sub_4343D0(char *this, __int16 a2)
{
  int v2; // eax
  _DWORD *v3; // ebx
  char v5; // [esp+4h] [ebp-4h] BYREF
  __int16 v6; // [esp+5h] [ebp-3h]

  v5 = 16;
  v6 = a2;
  v2 = 0;
  v3 = (_DWORD *)((char *)&loc_44EB73 + 1);
  do
    v2 -= *v3++;
  while ( v3 < (_DWORD *)((char *)&loc_44EC9F + 1) );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v2 - 1167007931] + 16))(
           &this[v2 - 1167007931],
           &v5,
           3,
           1);
}

//----- (004344F0) --------------------------------------------------------
int __thiscall sub_4344F0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  _DWORD *v5; // ebx

  result = this[16];
  if ( result <= 0 )
  {
    result = this[19];
    if ( !result && this[1] != -1 )
    {
      v4 = 0;
      v5 = (_DWORD *)((char *)&loc_43D9EF + 1);
      do
        v4 -= *v5++;
      while ( v5 < (_DWORD *)&loc_43DAA0 );
      result = (*(int (__thiscall **)(_DWORD, int, int))(**(_DWORD **)((char *)this + v4 - 1706092535) + 304))(
                 *(_DWORD *)((char *)this + v4 - 1706092535),
                 a2,
                 a3);
    }
  }
  return result;
}

//----- (00434540) --------------------------------------------------------
int __thiscall sub_434540(char *this, void *a2, char a3, __int16 a4, char a5)
{
  int v6; // eax
  _DWORD *v7; // ebx
  char v9[3]; // [esp+Ch] [ebp-100h] BYREF
  __int16 v10; // [esp+Fh] [ebp-FDh]
  char v11[251]; // [esp+11h] [ebp-FBh] BYREF

  v9[2] = a5;
  v10 = a4;
  v9[0] = 6;
  v9[1] = a3;
  strncpyt(v11, a2, 250);
  v6 = 0;
  v7 = &unk_4AA470;
  do
    v6 -= *v7++;
  while ( v7 < dword_4AA7F4 );
  return (*(int (__thiscall **)(char *, char *, unsigned int, int))(*(_DWORD *)&this[v6 + 199663542] + 16))(
           &this[v6 + 199663542],
           v9,
           strlen((const char *)a2) + 6,
           1);
}

//----- (004345D0) --------------------------------------------------------
int __thiscall sub_4345D0(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int result; // eax

  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this[3] + 120508) + 4))(*(_DWORD *)(this[3] + 120508));
  v3 = 345148502;
  v4 = 223;
  do
    v3 ^= *(_DWORD *)&aRiched32Dll[4 * v4-- - 631972];
  while ( v4 );
  if ( *(_DWORD *)((char *)this + v3 + 855172) != a2 )
  {
    v5 = this[3];
    this[7] = a2;
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v5 + 320))(v5, a2);
  }
  result = this[110];
  if ( result )
    this[209] = *(_DWORD *)(this[3] + 23104);
  this[7] = a2;
  if ( a2 >= 0 )
  {
    if ( !result )
    {
      result = this[3];
      this[110] = *(_DWORD *)(result + 23104);
    }
  }
  else
  {
    this[110] = 0;
  }
  return result;
}

//----- (00434670) --------------------------------------------------------
int __fastcall sub_434670(int *a1, unsigned int a2)
{
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // edi
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // ebx
  int v20; // eax
  int v21; // eax
  void (__fastcall *v22)(int *, int); // edi
  int v23; // edi
  unsigned int v24; // ebx
  int v25; // eax
  int v26; // eax
  int v27; // ecx
  int v28; // edi
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // edx
  int v39; // ecx
  int v40; // edx
  int v41; // edi
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // ecx
  int v46; // edx
  int v47; // eax
  int v48; // eax
  int v49; // eax
  int v50; // edx
  int v51; // eax
  int v52; // eax
  void (__fastcall *v53)(int *, int); // ebx
  int v54; // edx
  int v55; // eax
  int v56; // ebx
  int v57; // ecx
  int v58; // edx
  int v59; // ecx
  int result; // eax
  int v61; // ecx
  int v62; // ebx
  int v63; // ecx
  unsigned int v64; // [esp+Ch] [ebp-Ch]
  int (__fastcall *v65)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v66)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v67)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v68)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v69)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v70)(int *, int); // [esp+10h] [ebp-8h]
  int (__fastcall *v71)(int *, int); // [esp+10h] [ebp-8h]

  v4 = a1[14];
  v5 = a1[13];
  v6 = (a1[15] ^ a2 ^ a1[7]) % 0xB;
  v64 = v6;
  v7 = *a1;
  a1[14] = a1[1] - 1061034979 + v4;
  a1[13] = v5 - (a1[18] ^ 0x80A3D7BA);
  *a1 = __ROR4__(v7, *((_BYTE *)a1 + 16) | 0xDC);
  if ( v6 == 4 )
  {
    v8 = ((int (__fastcall *)(int *, int))sub_43EE60)(a1, 1869157821);
    v65 = (int (__fastcall *)(int *, int))(632855013 - ((int (__fastcall *)(int *, int))(249358030 - v8))(
                                                         a1,
                                                         1574203034));
    v9 = v65(a1, 685868954);
    ((void (__fastcall *)(int *, int))(555808442 - v9))(a1, a1[6]);
  }
  v10 = __ROR4__(a2, 42 * a1[13]);
  v11 = a1[4];
  a1[1] &= 368845283 * a1[19];
  a1[4] = (889753166 * v10) & v11;
  if ( v6 == 6 )
  {
    v12 = ((int (__fastcall *)(int *, int))sub_445900)(a1, 1579788501);
    v13 = ((int (__fastcall *)(int *, int))(42697489 - v12))(a1, 1103090369);
    v14 = ((int (__fastcall *)(int *, int))(827054109 - v13))(a1, 2139257560);
    ((void (__fastcall *)(int *, int))(629357281 - v14))(a1, v10);
  }
  v15 = 520449292 * a1[16];
  a1[10] += v10 + 816153272;
  a1[15] = __ROR4__(a1[15], v15);
  if ( v6 == 1 )
  {
    v16 = ((int (__fastcall *)(int *, int))sub_43E460)(a1, 188518661);
    v66 = (int (__fastcall *)(int *, int))(-1814542322
                                         - ((int (__fastcall *)(int *, int))(48677881 - v16))(a1, -518634105));
    v17 = v66(a1, -587550174);
    ((void (__fastcall *)(int *, int))(1596644269 - v17))(a1, a1[11]);
  }
  v18 = a1[14];
  a1[14] = a1[10] & 0x59E8CC ^ v18;
  v19 = __ROR4__(v18, 16) + v10;
  a1[2] *= a1[16] ^ 0x13841127;
  if ( v6 == 3 )
  {
    v20 = ((int (__fastcall *)(int *, int))sub_442CF0)(a1, -94340262);
    v21 = ((int (__fastcall *)(int *, int))(1757226332 - v20))(a1, -287447222);
    v22 = (void (__fastcall *)(int *, int))(405775114
                                          - ((int (__fastcall *)(int *, int))(1640870346 - v21))(a1, -606106373));
    v22(a1, a1[9]);
  }
  v23 = v19 * (v19 | 0x259B9C88);
  v24 = v64;
  a1[1] = (a1[5] + 145026986) | (a1[1] + (a1[15] ^ 0xA9E3D53));
  if ( v64 == 10 )
  {
    v25 = ((int (__fastcall *)(int *, int))sub_44BFD0)(a1, 844451466);
    v67 = (int (__fastcall *)(int *, int))(90990347
                                         - ((int (__fastcall *)(int *, int))(1039547007 - v25))(a1, -757042718));
    v26 = v67(a1, -1837200177);
    ((void (__fastcall *)(int *, int))(496058917 - v26))(a1, a1[18]);
  }
  v27 = a1[11];
  a1[10] += -1030639962 * v23;
  v28 = -1128884328 - v27 - a1[15] - __ROR4__(a1[6], 8) + v23;
  if ( v64 == 9 )
  {
    v29 = ((int (__fastcall *)(int *, int))sub_435430)(a1, 1384240091);
    v68 = (int (__fastcall *)(int *, int))(887388490
                                         - ((int (__fastcall *)(int *, int))(1407437036 - v29))(a1, 1537477701));
    v30 = v68(a1, 1274472906);
    ((void (__fastcall *)(int *, int))(1058482343 - v30))(a1, a1[15]);
  }
  v31 = a1[9];
  a1[13] = __ROL4__(a1[13], a1[19] & 0x28);
  a1[14] ^= v31 ^ 0x16CAF709;
  if ( v64 == 8 )
  {
    v32 = ((int (__fastcall *)(int *, int))sub_432100)(a1, 1277304029);
    v69 = (int (__fastcall *)(int *, int))(524071547 - ((int (__fastcall *)(int *, int))(71099908 - v32))(
                                                         a1,
                                                         -206046243));
    v33 = v69(a1, -702698008);
    ((void (__fastcall *)(int *, int))(189563605 - v33))(a1, a1[10]);
  }
  v34 = a1[5];
  a1[18] += -723283830 * a1[13];
  v35 = a1[15];
  a1[5] = *a1 + v34;
  a1[15] = (v28 ^ 0x7813F512) & v35;
  if ( v64 == 5 )
  {
    v36 = ((int (__fastcall *)(int *, int))sub_42B000)(a1, 1195991208);
    v70 = (int (__fastcall *)(int *, int))(-1594725374
                                         - ((int (__fastcall *)(int *, int))(-1800800783 - v36))(a1, 954173345));
    v37 = v70(a1, -2034306370);
    ((void (__fastcall *)(int *, int))(277897448 - v37))(a1, a1[12]);
  }
  v38 = -1851513494 * a1[2];
  a1[7] ^= a1[7] - 869679170;
  v39 = v38 + a1[6];
  v40 = a1[11];
  a1[6] = v39;
  v41 = v40 & __ROL4__(v28, 72 * *((_BYTE *)a1 + 40)) & 0x65F3D547;
  if ( v64 == 2 )
  {
    v42 = ((int (__fastcall *)(int *, int))sub_445D10)(a1, -1658119070);
    v71 = (int (__fastcall *)(int *, int))(766785424
                                         - ((int (__fastcall *)(int *, int))(367777750 - v42))(a1, 2010316807));
    v43 = v71(a1, -1815691537);
    ((void (__fastcall *)(int *, int))(659584486 - v43))(a1, a1[6]);
  }
  v44 = a1[8];
  v45 = a1[9];
  a1[6] += -357922988 - v41;
  v46 = (v41 ^ a1[14] ^ 0x154065FE) - v44;
  a1[14] = v46 + 1040752306;
  a1[9] = __ROL4__(v46 + 1040752306, 25) + v45;
  if ( !v64 )
  {
    v47 = ((int (__fastcall *)(int *, int))sub_43A500)(a1, -1374329974);
    v48 = ((int (__fastcall *)(int *, int))(7064543 - v47))(a1, 441095570);
    v49 = ((int (__fastcall *)(int *, int))(371586916 - v48))(a1, -1621309672);
    ((void (__fastcall *)(int *, int))(258223388 - v49))(a1, v41);
    v24 = 0;
  }
  v50 = __ROR4__(a1[3], a1[14] + 99);
  a1[17] -= a1[4] | 0x12079EF;
  a1[3] = v50;
  a1[9] += -557824576 - v41;
  if ( v24 == 7 )
  {
    v51 = ((int (__fastcall *)(int *, int))sub_424910)(a1, -1089287446);
    v52 = ((int (__fastcall *)(int *, int))(168195092 - v51))(a1, -414123249);
    v53 = (void (__fastcall *)(int *, int))(729545373
                                          - ((int (__fastcall *)(int *, int))(-1400520141 - v52))(a1, 1217649405));
    v53(a1, a1[19]);
  }
  v54 = a1[12] | 0x679DBAD3;
  v55 = a1[11] * (a1[15] - 1022491975);
  a1[11] = v55;
  v56 = a1[17];
  a1[8] *= v55 - 1985809176;
  v57 = v54 ^ a1[19];
  v58 = a1[18];
  a1[19] = v57;
  v59 = a1[16];
  a1[18] = v58 - (a1[4] & 0x9559097C);
  result = __ROL4__(v41 ^ (v55 - 766475588), v59 - 23);
  v61 = a1[14] | 0x65749A9D;
  a1[5] ^= -1892282334 * a1[7];
  v62 = v56 - v61;
  v63 = a1[13];
  a1[17] = v62;
  a1[13] = (result ^ 0x7DE10CD8) + v63;
  return result;
}
// 424910: using guessed type int sub_424910();
// 42B000: using guessed type int sub_42B000();
// 432100: using guessed type int sub_432100();
// 435430: using guessed type int sub_435430();
// 43A500: using guessed type int sub_43A500();
// 43E460: using guessed type int sub_43E460();
// 43EE60: using guessed type int sub_43EE60();
// 442CF0: using guessed type int sub_442CF0();
// 445900: using guessed type int sub_445900();
// 445D10: using guessed type int sub_445D10();
// 44BFD0: using guessed type int sub_44BFD0();

//----- (00435330) --------------------------------------------------------
int __thiscall sub_435330(int *this, int a2)
{
  unsigned int v2; // edx
  int v4; // ebx
  int *v5; // esi
  int *v6; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // edx
  int result; // eax
  int v11; // [esp-8h] [ebp-64h]
  char Buffer[64]; // [esp+10h] [ebp-4Ch] BYREF
  int v13; // [esp+58h] [ebp-4h]

  v2 = 0;
  v4 = 0x7FFFFFFF;
  v5 = this + 17;
  v6 = this + 19;
  while ( *(v6 - 1) != a2 )
  {
    if ( *v6 < v4 )
    {
      v4 = *v6;
      v5 = v6 - 2;
    }
    ++v2;
    v6 += 3;
    if ( v2 >= 5 )
      goto LABEL_8;
  }
  v5 = &this[3 * v2 + 17];
LABEL_8:
  if ( v5[1] != a2 )
  {
    if ( *v5 )
      (*(void (__thiscall **)(int, int))(*(_DWORD *)*v5 + 36))(*v5, 1);
    *v5 = 0;
    v5[1] = a2;
    sprintf_0(Buffer, "bong%d.wa2", a2);
    v7 = sub_40B720(a2, 0x168u);
    v13 = 0;
    if ( v7 )
      v8 = (int *)sub_406230(v7, (int)this, Buffer, 1u, 0);
    else
      v8 = 0;
    *v5 = (int)v8;
    v9 = *v8;
    v11 = this[15];
    v13 = -1;
    (*(void (__thiscall **)(int *, int, _DWORD))(v9 + 32))(v8, v11, 0);
  }
  (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)*v5 + 20))(*v5, 0, 0, 0, 0);
  result = this[16] + 1;
  this[16] = result;
  v5[2] = result;
  return result;
}

//----- (00435450) --------------------------------------------------------
int sub_435450()
{
  return dword_4A7378(0);
}
// 4A7378: using guessed type int (__stdcall *dword_4A7378)(_DWORD);

//----- (004354F0) --------------------------------------------------------
char __userpurge sub_4354F0@<al>(int *a1@<ecx>, int a2@<ebp>, char *a3)
{
  char result; // al
  int v5; // edi
  int v6; // esi
  _BYTE *v7; // edi
  int v8; // ebx
  unsigned int i; // eax
  char v10; // dl
  int v11; // [esp+4h] [ebp-810h] BYREF
  char v12[2048]; // [esp+8h] [ebp-80Ch] BYREF
  int v13; // [esp+810h] [ebp-4h]

  result = *((_BYTE *)a1 + 8);
  if ( result )
  {
    v11 = -1;
    v13 = 0;
    sub_4080D0(&v11, a2, a3, 0, 2);
    sub_4086E0(&v11, a1[1] + 4, 4);
    v5 = a1[1];
    if ( *(_DWORD *)(v5 + 8) )
      v6 = *a1;
    else
      v6 = *(_DWORD *)(v5 + 4);
    v7 = (_BYTE *)(v5 + 12);
    v8 = 161;
    while ( v6 )
    {
      for ( i = 0; i < 0x800; ++i )
      {
        if ( !v6 )
          break;
        v10 = v8 ^ *v7++;
        v12[i] = v10;
        v8 += 7;
        --v6;
      }
      sub_4086E0(&v11, (int)v12, i);
    }
    v13 = -1;
    result = sub_4087F0(&v11);
  }
  return result;
}

//----- (004355D0) --------------------------------------------------------
BOOL __thiscall sub_4355D0(_DWORD *this)
{
  return this[12] + this[13] > 0 || (int)this[10] >= 0 && *(_DWORD *)(this[3] + 11944);
}

//----- (00435600) --------------------------------------------------------
int __thiscall sub_435600(_DWORD *this, int a2)
{
  int result; // eax
  int v3; // edx

  result = this[27545];
  if ( this[27547] )
  {
    result += 8;
    v3 = this[27547];
    do
    {
      if ( *(unsigned __int16 *)(result + 12) >> 12 == a2 )
        *(_DWORD *)result = this[5776];
      result += 28;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00435640) --------------------------------------------------------
int __fastcall sub_435640(int a1, int a2, int a3)
{
  int v4; // eax

  if ( (unsigned int)a3 > 0x270F )
    return -1;
  if ( a3 < 100 || *(_BYTE *)(a1 + 113604) )
    return a3;
  v4 = 3 * (a1 ^ a3) + 12313;
  LOBYTE(v4) = v4 & 0xF8;
  return a3 & 3 | v4;
}

//----- (00435680) --------------------------------------------------------
int __thiscall sub_435680(char *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int result; // eax
  int v7; // ebx
  char *v8; // edi
  int v9; // ecx
  bool v10; // zf
  int v11; // [esp-8h] [ebp-10h]

  if ( this[117788] )
  {
    v3 = 839574557;
    v4 = 118;
    do
      v3 ^= (unsigned int)*(&off_4AF3D0 + v4-- - 141638);
    while ( v4 );
    this[v3 + 171076004] = 0;
    v5 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 64))(this) - *((_DWORD *)this + 29960);
    if ( v5 >= 0 && v5 <= 30000 )
    {
      if ( v5 > 12000 )
        v5 = 12000;
      (*(void (__thiscall **)(char *, int, _DWORD))(*(_DWORD *)this + 468))(this, v5, 0);
    }
    else
    {
      (*(void (__thiscall **)(char *, _DWORD, _DWORD))(*(_DWORD *)this + 468))(this, 0, 0);
    }
  }
  else
  {
    (*(void (__thiscall **)(char *, int, int))(*(_DWORD *)this + 468))(this, a2, 1);
  }
  result = *((_DWORD *)this + 28377);
  v7 = 0;
  if ( result > 0 )
  {
    v8 = this + 112484;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)v8 + 12) - a2;
      v10 = *(_DWORD *)(*(_DWORD *)v8 + 12) == a2;
      *(_DWORD *)(*(_DWORD *)v8 + 12) = v9;
      if ( v9 < 0 || v10 )
      {
        v11 = v7--;
        v8 -= 4;
        (*(void (__thiscall **)(char *, int))(*(_DWORD *)this + 308))(this, v11);
      }
      result = *((_DWORD *)this + 28377);
      ++v7;
      v8 += 4;
    }
    while ( v7 < result );
  }
  return result;
}
// 4AF3D0: using guessed type int (__stdcall *off_4AF3D0)(char);

//----- (00435750) --------------------------------------------------------
int __thiscall sub_435750(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  char v8; // di
  int v9; // eax
  int v10; // edi
  int v11; // ebx
  int v12; // eax
  bool v13; // cc
  int v14; // edx
  int v15; // ecx
  int v16; // edi
  double v17; // st7
  double v18; // st6
  unsigned int v19; // eax
  int v20; // ebx
  int v21; // ecx
  int v22; // edi
  __int64 v23; // rax
  int v24; // eax
  int v25; // edx
  bool v26; // zf
  double v27; // st7
  int v28; // edi
  __int64 v29; // rax
  int v30; // edi
  int v32; // ebx
  double v33; // st7
  int v34; // [esp+20h] [ebp-80h]
  unsigned int v35; // [esp+28h] [ebp-78h]
  int i; // [esp+28h] [ebp-78h]
  int v37; // [esp+2Ch] [ebp-74h]
  int v38; // [esp+30h] [ebp-70h]
  double v39; // [esp+30h] [ebp-70h]
  double v40; // [esp+38h] [ebp-68h]
  int v41; // [esp+38h] [ebp-68h]
  int v42[12]; // [esp+48h] [ebp-58h] BYREF
  double v43; // [esp+78h] [ebp-28h]
  double v44; // [esp+80h] [ebp-20h]
  double v45; // [esp+88h] [ebp-18h]

  this[this[96]] = a3;
  this[this[96] + 32] = a4;
  this[this[96] + 64] = a2;
  v5 = ((unsigned __int8)this[96] + 1) & 0x1F;
  ++this[97];
  this[96] = v5;
  v6 = ((_BYTE)v5 - 1) & 0x1F;
  v7 = ((_BYTE)v5 - 2) & 0x1F;
  v8 = v5 - 3;
  v9 = this[v7 + 64];
  v10 = v8 & 0x1F;
  v11 = this[v6 + 64] - v9;
  v12 = v9 - this[v10 + 64];
  v13 = this[97] <= 3;
  this[99] = 0;
  if ( !v13 && v11 > 400 && v12 > 400 )
  {
    v14 = this[v7];
    v15 = this[v6] - v14;
    v16 = v14 - this[v10];
    v17 = (double)v15 / (double)v11;
    v18 = (double)v16 / (double)v12;
    v40 = (double)(v16 + v15) / (double)(v11 + v12);
    if ( v17 > dbl_4A91B8 && v18 > dbl_4A91B8 || v17 < dbl_4A91B8 && v18 < dbl_4A91B8 )
      this[99] = (__int64)(v40 * dbl_4A91C0);
    nullsub_2("SpdDet: %g %g %g %d %d %d %d\n", v17, v18, v40, v15, v16, v11, v12);
  }
  v19 = this[97];
  if ( v19 > 0x20 )
  {
    v34 = 32;
    v19 = 32;
  }
  else
  {
    v34 = this[97];
  }
  v20 = 0;
  v21 = this[96] - 1;
  v22 = 10000000;
  v37 = 0;
  if ( v19 )
  {
    v35 = v19;
    do
    {
      v21 &= 0x1Fu;
      v23 = (int)this[v21 + 32];
      v24 = (HIDWORD(v23) ^ v23) - HIDWORD(v23);
      if ( v24 < v22 )
        v22 = v24;
      v20 = this[v21 + 64];
      v25 = this[v21];
      LOBYTE(v21) = v21 - 1;
      v26 = v35 == 1;
      v37 = v25;
      --v35;
    }
    while ( !v26 );
  }
  v38 = (3 * v22 + 3) / 2;
  sub_40ABE0(v42);
  v27 = dbl_4A91B8;
  v28 = this[96] + 31;
  for ( i = 0; v34; --v34 )
  {
    v28 &= 0x1Fu;
    v29 = (int)this[v28 + 32];
    if ( (int)((HIDWORD(v29) ^ v29) - HIDWORD(v29)) < v38 )
    {
      v41 = this[v28];
      ++i;
      sub_40AC80((int)v42, (double)(this[v28 + 64] - v20), (double)(v41 - v37));
      v27 = (double)v41 + v27;
    }
    LOBYTE(v28) = v28 - 1;
  }
  v30 = (__int64)_ceil_default(v27 / (double)i + dbl_4AD770);
  if ( v42[0] <= 2 )
    return v30;
  v39 = v44;
  v32 = (__int64)_ceil_default((double)(a2 - v20) * v44 + (double)v37 + v43 + dbl_4AD770);
  v33 = v45;
  this[98] = (__int64)(v39 * dbl_4A91C0);
  nullsub_2("TimerDiff: cur:%d  reg:%d  ave:%d  ping:%d  drift:%g  determ:%g\n", a3, v32, v30, a4, v39, v33);
  return v32;
}
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C0: using guessed type double dbl_4A91C0;
// 4AD770: using guessed type double dbl_4AD770;

//----- (00435AC0) --------------------------------------------------------
char __thiscall sub_435AC0(_DWORD *this, int a2, int a3, int a4)
{
  int v6; // eax
  int v7; // edx
  _DWORD *i; // edi
  char v10; // [esp+14h] [ebp+4h]
  int v11; // [esp+18h] [ebp+8h]

  switch ( a2 )
  {
    case 16:
      v6 = (a3 & 0xFF0000) != 3538944 ? 0x400000 : 0x4000000;
      break;
    case 17:
      v6 = (a3 & 0x1000000) != 0 ? 0x2000000 : 0x200000;
      break;
    case 18:
      v6 = (a3 & 0x1000000) != 0 ? 0x1000000 : 0x100000;
      break;
    default:
      v6 = 0;
      break;
  }
  v10 = 1;
  this[90] |= v6;
  *((_BYTE *)this + 96) = (a3 & 0x40000000) != 0;
  switch ( a2 )
  {
    case 112:
      this[23] = 9;
      break;
    case 113:
      this[23] = 10;
      break;
    case 114:
      this[23] = 11;
      break;
    case 115:
      this[23] = 12;
      break;
    case 116:
      this[23] = 13;
      break;
    case 117:
      this[23] = 14;
      break;
    case 118:
      this[23] = 15;
      break;
    case 119:
      this[23] = 16;
      break;
    case 120:
      this[23] = 17;
      break;
    case 121:
      this[23] = 18;
      break;
    case 122:
      this[23] = 19;
      break;
    case 123:
      this[23] = 20;
      break;
    case 46:
      this[23] = 8;
      break;
    case 45:
      this[23] = 21;
      break;
    case 36:
      this[23] = 22;
      break;
    case 35:
      this[23] = 23;
      break;
    case 34:
      this[23] = 24;
      break;
    case 33:
      this[23] = 25;
      break;
    case 27:
      this[23] = 26;
      break;
    default:
      v10 = 0;
      break;
  }
  v11 = (*(int (__thiscall **)(_DWORD *))(*this + 24))(this);
  v7 = 0;
  for ( i = this + 91;
        (unsigned __int8)*i != a2
     || (v11 & i[52]) != 0
     || (v11 & *i) != (*i & 0x7770000)
     || a4 != 2 && *((_BYTE *)this + v7 + 780) && (a4 != 1 || v7 != 23 && v7 != 24 && v7 != 25 && v7 != 26);
        ++i )
  {
    if ( (unsigned int)++v7 >= 0x34 )
      return v10;
  }
  this[22] = v7;
  return 1;
}

//----- (00435D90) --------------------------------------------------------
void __thiscall sub_435D90(void (__thiscall ***this)(void *, _DWORD))
{
  int i; // edi

  for ( i = 0; i < (int)this[6]; ++i )
    (**this)(this, this[4][i]);
  qsort(this[1], (size_t)this[3], 0x9Cu, sub_421E20);
}

//----- (00436440) --------------------------------------------------------
BOOL __thiscall sub_436440(_BYTE *this, int a2)
{
  int (__stdcall *v2)(int); // edi
  int v4; // ecx
  char v5; // al
  int *v6; // ebx
  int v7; // ebp
  int v8; // eax
  BOOL result; // eax
  int v10; // [esp+48h] [ebp-4h]

  v2 = dword_4A7374;
  this[56] = (dword_4A7374(37) & 0x8000) != 0;
  this[57] = (v2(39) & 0x8000) != 0;
  this[58] = (v2(38) & 0x8000) != 0;
  this[59] = (v2(40) & 0x8000) != 0;
  this[60] = (v2(16) & 0x8000) != 0;
  this[61] = (v2(17) & 0x8000) != 0;
  this[62] = (v2(18) & 0x8000) != 0;
  this[63] = (v2(9) & 0x8000) != 0;
  this[64] = (v2(46) & 0x8000) != 0;
  this[67] = (v2(114) & 0x8000) != 0;
  this[68] = (v2(115) & 0x8000) != 0;
  this[69] = (v2(116) & 0x8000) != 0;
  this[70] = (v2(117) & 0x8000) != 0;
  this[71] = (v2(118) & 0x8000) != 0;
  this[77] = (v2(45) & 0x8000) != 0;
  this[78] = (v2(36) & 0x8000) != 0;
  this[79] = (v2(35) & 0x8000) != 0;
  this[82] = (v2(27) & 0x8000) != 0;
  v4 = (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 24))(this);
  v10 = v4;
  if ( !this[98] && (v5 = this[63]) != 0 && (v4 & 0x1110000) != 0 )
  {
    this[97] = 1;
  }
  else
  {
    v5 = this[63];
    if ( !v5 && this[97] )
      this[97] = 0;
  }
  this[98] = v5;
  if ( this[97] )
    this[63] = 0;
  v6 = (int *)&unk_4AA498;
  while ( 1 )
  {
    result = (v7 = *v6, (v4 & *(_DWORD *)&this[4 * *v6 + 572]) == 0)
          && (v8 = *(_DWORD *)&this[4 * v7 + 364], (v4 & v8) == (v8 & 0x7770000))
          && (!this[97] || (_BYTE)v8 != 9)
          && (((unsigned __int16)v2((unsigned __int8)v8) >> 8) & 0x80u) != 0
          && (a2 == 2 || !this[v7 + 780])
          || a2 == 1
          && (v6 == (int *)&unk_4AA4F4
           || v6 == (int *)&unk_4AA4F8
           || v6 == (int *)&off_4AA4FC
           || v6 == (int *)&unk_4AA500);
    ++v6;
    this[v7 + 4] = result;
    if ( v6 >= &dword_4AA4C0 )
      break;
    v4 = v10;
  }
  return result;
}
// 4A7374: using guessed type int (__stdcall *dword_4A7374)(_DWORD);
// 4AA4C0: using guessed type int dword_4AA4C0;
// 4AA4FC: using guessed type int (__stdcall *off_4AA4FC)(int, int);

//----- (00436610) --------------------------------------------------------
int __thiscall sub_436610(char *this, int *a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int (__stdcall *v7)(int); // ebx
  char Buffer[64]; // [esp+8h] [ebp-40h] BYREF

  v4 = *a2;
  if ( *a2 )
  {
    if ( v4 == 1 )
    {
      *a2 = 2;
    }
    else if ( v4 == 2 )
    {
      *a2 = 0;
    }
  }
  else
  {
    *a2 = 1;
  }
  v5 = *a2;
  if ( *a2 )
  {
    if ( v5 == 1 )
    {
      sprintf_0(Buffer, aSToCenter, a3);
    }
    else if ( v5 == 2 )
    {
      sprintf_0(Buffer, (const char *const)(9224800 - (_DWORD)dword_41EAC8), a3);
    }
  }
  else
  {
    sprintf_0(Buffer, aSOff, a3);
  }
  v6 = 0;
  v7 = nullsub_4;
  do
  {
    v6 -= *(_DWORD *)v7;
    v7 = (int (__stdcall *)(int))((char *)v7 + 4);
  }
  while ( (int *)v7 < dword_40FA88 );
  return (*(int (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&this[v6 - 304549081] + 28))(
           &this[v6 - 304549081],
           Buffer,
           0,
           0,
           0,
           1);
}
// 40F988: using guessed type int __stdcall nullsub_4(int);
// 40FA88: using guessed type int dword_40FA88[21];
// 41EAC8: using guessed type int dword_41EAC8[62];

//----- (004366D0) --------------------------------------------------------
char __thiscall sub_4366D0(int this)
{
  char result; // al
  int v3; // [esp+0h] [ebp-1FCh] BYREF
  char v4[260]; // [esp+Ch] [ebp-1F0h] BYREF
  char v5[128]; // [esp+110h] [ebp-ECh] BYREF
  char v6[80]; // [esp+190h] [ebp-6Ch] BYREF
  int v7; // [esp+1E0h] [ebp-1Ch]
  int v8; // [esp+1E4h] [ebp-18h] BYREF
  void *v9[2]; // [esp+1E8h] [ebp-14h] BYREF
  int v10; // [esp+1F8h] [ebp-4h]
  int savedregs; // [esp+1FCh] [ebp+0h] BYREF

  result = *(_BYTE *)(this + 1868);
  v9[1] = &v3;
  if ( result )
  {
    sub_457D50(v9, (int)v6);
    sub_457D60(v9, 0, 0x247DA9AAu);
    ContinuumEncryptMD5Step3(v9, -1439978213);
    ContinuumEncrypt((unsigned int *)v9, v5, (_DWORD *)(this + 112220), 0x80u);
    v7 = 9224445;
    sub_407960(v4, *(_DWORD *)(this + 23100) + 269, (_BYTE *)(9224445 - (_DWORD)&loc_41F595));
    v10 = 1;
    v8 = -1;
    sub_4080D0(&v8, (int)&savedregs, v4, 0, 2);
    sub_4086E0(&v8, (int)v5, 128);
    sub_4087F0(&v8);
    LOBYTE(v10) = 0;
    result = sub_4087F0(&v8);
  }
  return result;
}

//----- (004367D0) --------------------------------------------------------
int __thiscall sub_4367D0(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  _DWORD *v5; // ebp
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  unsigned int v9; // eax
  int v10; // [esp+Ch] [ebp+4h]

  result = this[5775];
  if ( *(_BYTE *)(result + 8051) )
  {
    (*(void (__thiscall **)(_DWORD *))(*a2 + 20))(a2);
    if ( a2[7] )
    {
      v10 = 0;
      if ( this[1908] + this[1909] > 0 )
      {
        v5 = this + 2173;
        do
        {
          v6 = *v5;
          if ( *(_BYTE *)(*v5 + 108) )
          {
            v7 = *(_DWORD *)(v6 + 4);
            v8 = *(_DWORD *)(v6 + 8);
            v9 = *(_DWORD *)(v6 + 12) + 1436;
            if ( v7 >= *(_DWORD *)v9
              && v7 < *(_DWORD *)(*(_DWORD *)(v6 + 12) + 1444)
              && v8 >= *(_DWORD *)(*(_DWORD *)(v6 + 12) + 1440)
              && v8 < *(_DWORD *)(*(_DWORD *)(v6 + 12) + 1448) )
            {
              LOBYTE(v9) = *(_BYTE *)(v6 + 167);
              (*(void (__thiscall **)(_DWORD *, int, _DWORD, unsigned int))(*a2 + 188))(
                a2,
                v6 + 24,
                this[5776],
                (v9 >> 5) & 3);
            }
          }
          ++v5;
          ++v10;
        }
        while ( v10 < this[1909] + this[1908] );
      }
    }
    result = (*(int (__thiscall **)(_DWORD *))(*a2 + 64))(a2);
  }
  return result;
}

//----- (004368C0) --------------------------------------------------------
unsigned int __thiscall sub_4368C0(_DWORD *this, const char *a2)
{
  return this[18806] * strlen(a2);
}

//----- (004368E0) --------------------------------------------------------
unsigned int __thiscall sub_4368E0(unsigned int *this, unsigned int a2, int *a3, unsigned int a4)
{
  unsigned int v4; // esi
  int *v5; // edi
  char v6; // dl
  char v7; // dl
  char v9; // dl
  unsigned __int8 *v10; // ecx
  int v11; // eax
  int v12; // edx
  char v13; // cl
  unsigned int v14; // edx
  unsigned __int8 v15; // [esp+Ch] [ebp-210h]
  unsigned __int8 v16; // [esp+Ch] [ebp-210h]
  int v17[131]; // [esp+10h] [ebp-20Ch] BYREF

  v4 = a4;
  v5 = a3;
  if ( a4 > 0x20C )
    v4 = 524;
  if ( !*(_BYTE *)a3 && ((v6 = *((_BYTE *)a3 + 1), v6 == 1) || v6 == 16 || v6 == 17) )
  {
    sub_46CAB0(a2, a3, v4);
  }
  else
  {
    if ( *(_BYTE *)a3 == 0xFF )
    {
      v7 = *((_BYTE *)a3 + 1);
      if ( !v7 || v7 == -1 )
      {
        v5 = (int *)((char *)a3 + 1);
        --v4;
      }
    }
    if ( !v4 )
      return 0;
    ContinuumDecrypt(this, v17, v5, v4);
    v9 = 0;
    v15 = 0;
    v10 = (unsigned __int8 *)v17 + 1;
    if ( v4 != 1 )
    {
      v11 = v4 - 2 + 1;
      do
      {
        v12 = v15 ^ *v10++;
        --v11;
        v9 = byte_4A7A3C[v12];
        v15 = v9;
      }
      while ( v11 );
    }
    if ( LOBYTE(v17[0]) != v9 )
    {
      v13 = 0;
      v16 = 0;
      if ( v4 > 1 )
      {
        v14 = v4 - 1;
        do
        {
          --v14;
          v13 = byte_4A7A3C[BYTE1(v17[0]) ^ v16];
          v16 = v13;
        }
        while ( v14 );
      }
      if ( LOBYTE(v17[0]) != v13 )
        return 0;
    }
    sub_46CAB0(a2, (_BYTE *)v17 + 1, --v4);
  }
  return v4;
}

//----- (00436A20) --------------------------------------------------------
unsigned int __userpurge sub_436A20@<eax>(int a1@<ecx>, int a2@<ebp>, _BYTE *a3, int a4, int a5)
{
  unsigned int *v5; // esi
  unsigned int result; // eax

  if ( *a3 == 1 && a4 >= 1 )
  {
    v5 = (unsigned int *)(a1 + 1412);
    *(_BYTE *)(a1 + 1409) = 1;
    sub_40C9D0(a1 + 1412, a2, a4 - 1);
    result = sub_46CAB0(*v5, a3 + 1, a4 - 1);
  }
  return result;
}

//----- (00436A70) --------------------------------------------------------
int __thiscall sub_436A70(_BYTE *this, _DWORD *a2)
{
  int v3; // eax
  char v4; // al
  int result; // eax
  int v6; // eax
  _DWORD *v7; // ebx

  v3 = a2[22];
  if ( (v3 == 23 || v3 == 24 || v3 == 25 || v3 == 26)
    && (v4 = this[96], *((_DWORD *)this + 28) = *(_DWORD *)(*((_DWORD *)this + 29) + 23104), !v4) )
  {
    this[96] = 1;
    this[104] = 1;
    result = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
  }
  else
  {
    if ( a2[22] == 22 )
    {
      (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 48))(this);
      result = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
    }
    else
    {
      result = sub_443D00(this, a2);
    }
    if ( *((_DWORD *)this + 25) != 6 )
    {
      v6 = 0;
      v7 = (_DWORD *)((char *)&loc_44E807 + 1);
      do
        v6 -= *v7++;
      while ( v7 < (_DWORD *)&loc_44EB94 );
      result = v6 + 1347040892;
      *(_DWORD *)&this[result + 259708] = *((_DWORD *)this + 2);
    }
  }
  return result;
}

//----- (00436C50) --------------------------------------------------------
int __thiscall sub_436C50(int *this, _BYTE *a2)
{
  int *v3; // edi
  int result; // eax
  void *v5; // eax
  int v6; // eax
  _DWORD *v7; // ebx
  int v8; // [esp+0h] [ebp-1A4h] BYREF
  char v9[260]; // [esp+Ch] [ebp-198h] BYREF
  char v10[64]; // [esp+110h] [ebp-94h] BYREF
  char Buffer[64]; // [esp+150h] [ebp-54h] BYREF
  int *v12; // [esp+190h] [ebp-14h]
  int *v13; // [esp+194h] [ebp-10h]
  int v14; // [esp+1A0h] [ebp-4h]
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v13 = &v8;
  v12 = this;
  v3 = this + 146;
  if ( this[146] == -1 )
  {
    v5 = a2;
    if ( !*a2 )
      v5 = aSessionLog;
    strncpyt(v10, v5, 64);
    sub_407960(v9, 9254781 - (_DWORD)&loc_425F7D, v10);
    v14 = 0;
    sub_408840(aLogs);
    sub_407F70(v3, (int)&savedregs, v9, 3, 4);
    sub_408220(v3, 0);
    sprintf_0(Buffer, aLogFileOpenS, v10);
    v14 = -1;
    v6 = 0;
    v7 = (_DWORD *)((char *)&loc_42B3A1 + 3);
    do
      v6 -= *v7++;
    while ( v7 < (_DWORD *)((char *)&loc_42B761 + 3) );
    result = (*(int (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(int *)((char *)this + v6 + 1986858654)
                                                                             + 28))(
               (int)this + v6 + 1986858654,
               Buffer,
               0,
               0,
               0,
               1);
  }
  else
  {
    sub_4087F0(this + 146);
    result = (*(int (__thiscall **)(int *, int, _DWORD, _DWORD, _DWORD, int))(*this + 28))(this, 4904980, 0, 0, 0, 1);
  }
  return result;
}

//----- (00436E60) --------------------------------------------------------
int __thiscall sub_436E60(char *this, void *a2, int a3)
{
  int v4; // eax
  int (__stdcall *v5)(int); // ebx
  int v6; // eax
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  int result; // eax
  unsigned int v11; // [esp-18h] [ebp-130h]
  char v12[132]; // [esp+Ch] [ebp-10Ch] BYREF
  int v13[33]; // [esp+90h] [ebp-88h] BYREF
  int v14; // [esp+114h] [ebp-4h]
  int savedregs; // [esp+118h] [ebp+0h] BYREF

  v14 = (int)this;
  strncpyt(v13, a2, 128);
  v13[32] = a3;
  v4 = 0;
  v5 = sub_44F4D4;
  do
  {
    v4 -= *(_DWORD *)v5;
    v5 = (int (__stdcall *)(int))((char *)v5 + 4);
  }
  while ( (char *)v5 < (char *)((char *)&loc_44F774 + 4) );
  v6 = v4 + 264613883;
  v7 = *(_DWORD *)&this[v6 + 245220];
  v8 = (int)&this[v6 + 245212];
  if ( v7 >= *(_DWORD *)(v8 + 4) )
  {
    if ( v7 >= 8 )
      v9 = v7 >= 32 ? 32 : 8;
    else
      v9 = 4;
    sub_40B780(132 * (v7 + v9), (void **)v8, (int)&savedregs);
    *(_DWORD *)(v8 + 4) += v9;
  }
  sub_46CAB0(*(_DWORD *)v8 + 132 * (v7 + 1), (_BYTE *)(*(_DWORD *)v8 + 132 * v7), 132 * *(_DWORD *)(v8 + 8) - 132 * v7);
  v11 = 132 * v7 + *(_DWORD *)v8;
  ++*(_DWORD *)(v8 + 8);
  sub_46CAB0(v11, v12, 0x84u);
  result = v14;
  qmemcpy((void *)(132 * v7 + *(_DWORD *)v8), v13, 0x84u);
  ++*(_DWORD *)(result + 80);
  *(_BYTE *)(result + 96) = 1;
  return result;
}
// 44F4D4: using guessed type int __stdcall sub_44F4D4(int);

//----- (00436FB0) --------------------------------------------------------
void __thiscall sub_436FB0(_DWORD *this, int a2, int a3, int a4, int a5)
{
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // ecx
  _DWORD *v9; // edx
  _DWORD *v10; // esi
  unsigned int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  unsigned int v15; // ebx
  unsigned int v16; // edx
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // [esp+10h] [ebp-4h]
  int savedregs; // [esp+14h] [ebp+0h] BYREF
  _DWORD *v23; // [esp+24h] [ebp+10h]

  v6 = 16000 * a3;
  v7 = this[1875];
  v21 = 16000 * a4;
  v8 = 0;
  if ( v7 <= 0 )
  {
LABEL_5:
    v10 = (_DWORD *)sub_40B720((int)&savedregs, 0x20u);
    if ( v10 )
    {
      v11 = v21;
      v10[3] = this;
      v10[2] = 0;
      v10[1] = 0;
      *v10 = &off_4AC35C;
      if ( v6 >= 0xFA0000 || v21 >= 0xFA0000 )
      {
        v11 = 0;
        v6 = 0;
      }
      v10[1] = v6;
      v10[2] = v11;
      v10[5] = a5;
      v12 = -1519788549;
      v13 = 38;
      do
        v12 ^= (unsigned int)*(&dword_4A72F8 + v13-- - 155033);
      while ( v13 );
      *(_DWORD *)((char *)v10 + v12 + 88732) = a2;
      v14 = *(_DWORD *)(v10[3] + 120528);
      if ( v14 )
      {
        v15 = v10[1];
        if ( v15 < 0xFA0000 )
        {
          v16 = v10[2];
          if ( v16 < 0xFA0000 )
            *(_BYTE *)((int)v15 / 16000 + (((int)v16 / 16000) << 10) + v14) = -2;
        }
      }
      v10[6] = 0;
      v10[4] = 0;
    }
    else
    {
      v10 = 0;
    }
    v17 = -1945146036;
    v18 = 121;
    do
      v17 ^= *(_DWORD *)&aThreadSUThread[4 * v18-- - 407536];
    while ( v18 );
    v19 = *(_DWORD *)((char *)this + v17 + 260124588);
    v20 = (int)this + v17 + 260123372;
    if ( v19 >= 304 )
    {
      sub_40B7E0((unsigned int)v10);
    }
    else
    {
      *(_DWORD *)(v20 + 4 * v19) = v10;
      ++*(_DWORD *)(v20 + 1216);
    }
  }
  else
  {
    v23 = this + 1571;
    while ( 1 )
    {
      v9 = (_DWORD *)*v23;
      if ( *(_DWORD *)(*v23 + 28) == a2 )
        break;
      ++v8;
      ++v23;
      if ( v8 >= v7 )
        goto LABEL_5;
    }
    v9[1] = v6;
    v9[2] = v21;
    v9[5] = a5;
  }
}
// 4A72F8: using guessed type int (__stdcall *dword_4A72F8)(_DWORD, _DWORD);
// 4AC35C: using guessed type int (__stdcall *off_4AC35C)(int, int);

//----- (00437160) --------------------------------------------------------
void __thiscall sub_437160(int this)
{
  int v2; // edi
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int v6; // edi
  int i; // edi
  int v8; // edi
  int v9; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v2 = 0;
  v3 = *(_DWORD *)(this + 756);
  *(_BYTE *)(this + 1392) = 0;
  *(_DWORD *)(this + 712) = 0;
  *(_DWORD *)(this + 912) = 0;
  *(_DWORD *)(this + 716) = 0;
  *(_DWORD *)(this + 720) = 0;
  if ( v3 > 0 )
  {
    do
      sub_40B7E0(*(_DWORD *)(*(_DWORD *)(this + 748) + 4 * v2++));
    while ( v2 < *(_DWORD *)(this + 756) );
  }
  v4 = 1217996579;
  v5 = 128;
  do
    v4 ^= *(_DWORD *)&aKbReverse[4 * v5-- - 638264];
  while ( v5 );
  v6 = v4;
  sub_40B7D0(*(void **)(v4 + this + 3057516));
  *(_DWORD *)(v6 + this + 3057516) = 0;
  *(_DWORD *)(v6 + this + 3057524) = 0;
  *(_DWORD *)(v6 + this + 3057520) = 0;
  for ( i = 0; i < *(_DWORD *)(this + 744); ++i )
    sub_40B7E0(*(_DWORD *)(*(_DWORD *)(this + 736) + 4 * i));
  sub_40B7D0(*(void **)(this + 736));
  *(_DWORD *)(this + 736) = 0;
  *(_DWORD *)(this + 744) = 0;
  *(_DWORD *)(this + 740) = 0;
  v8 = 0;
  if ( *(int *)(this + 732) > 0 )
  {
    v9 = 0;
    do
    {
      sub_4554B0(v9 + *(_DWORD *)(this + 724), (int)&savedregs);
      ++v8;
      v9 += 16;
    }
    while ( v8 < *(_DWORD *)(this + 732) );
  }
  sub_40B7D0(*(void **)(this + 724));
  *(_DWORD *)(this + 724) = 0;
  *(_DWORD *)(this + 732) = 0;
  *(_DWORD *)(this + 728) = 0;
  sub_40C9D0(this + 760, (int)&savedregs, 0);
  sub_40C9D0(this + 768, (int)&savedregs, 0);
  *(_DWORD *)(this + 1376) = 0;
  *(_DWORD *)(this + 1372) = 0;
  *(_DWORD *)(this + 1364) = 0;
  *(_DWORD *)(this + 1360) = 0;
  *(_DWORD *)(this + 1368) = 0;
  *(_DWORD *)(this + 1384) = 0;
  *(_DWORD *)(this + 1380) = 0;
  *(_DWORD *)(this + 924) = 0;
  *(_DWORD *)(this + 932) = 0;
  *(_BYTE *)(this + 1404) = 0;
  *(_DWORD *)(this + 1344) = 0;
  *(_DWORD *)(this + 1340) = 0;
  *(_DWORD *)(this + 1336) = 0;
  *(_DWORD *)(this + 1332) = 0;
}

//----- (00437370) --------------------------------------------------------
int __thiscall sub_437370(int this, int a2, int a3, int a4, int a5, char a6, int a7)
{
  int v8; // esi
  char *v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  int v15; // [esp-4h] [ebp-94h]
  int v16; // [esp-4h] [ebp-94h]
  char Buffer[128]; // [esp+Ch] [ebp-84h] BYREF
  int v18; // [esp+8Ch] [ebp-4h]
  int v19; // [esp+ACh] [ebp+1Ch]

  if ( !a6 )
    a7 = *(_DWORD *)(this + 48) + *(_DWORD *)(this + 52);
  v8 = a7;
  if ( a7 )
  {
    v18 = 9276998;
    sprintf_0(
      Buffer,
      (const char *const)(9276998 - (_DWORD)&loc_42B60A),
      this + 109,
      *(_DWORD *)(this + 32) + *(_DWORD *)(this + 36),
      a7);
  }
  else
  {
    v18 = 9277458;
    sprintf_0(
      Buffer,
      (const char *const)(9277458 - (_DWORD)&loc_42B7DE),
      this + 109,
      *(_DWORD *)(this + 32) + *(_DWORD *)(this + 36));
  }
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 23100) + 8070) )
  {
    v18 = 9277917;
    v15 = 10 * *(_DWORD *)(this + 356);
    v9 = strchr(Buffer, 0);
    sprintf_0(v9, (const char *const)(9277917 - (_DWORD)&loc_42B9B1), v15);
  }
  if ( *(int *)(this + 40) >= 0 && !a6 )
  {
    v18 = 9278379;
    strcat(Buffer, (const char *)(9278379 - (_DWORD)sub_42BB87));
    v8 = a7;
  }
  if ( *(_DWORD *)(this + 212) == -1 )
    v19 = -1;
  else
    v19 = *(_DWORD *)(this + 24);
  v10 = *(_DWORD *)(this + 12);
  if ( *(_DWORD *)(v10 + 112476) + *(_DWORD *)(v10 + 112480) == *(_DWORD *)(this + 88) )
  {
    v11 = 4;
  }
  else if ( v8 || *(int *)(this + 40) >= 0 && !a6 )
  {
    v11 = 3;
  }
  else
  {
    v11 = 2;
  }
  v12 = *(_DWORD *)(this + 28);
  if ( v12 == -1
    || (v12 = *(_DWORD *)(v10 + 4 * v12 + 113620)) == 0
    || (v12 = *(_DWORD *)(v12 + 92), v13 = v12, v12 == 8) )
  {
    v13 = *(_DWORD *)(this + 92);
  }
  LOBYTE(v12) = *(_BYTE *)(this + 168);
  v16 = v12;
  LOBYTE(v12) = *(_BYTE *)(this + 169);
  return (*(int (__thiscall **)(int, int, int, int, _DWORD, int, char *, int, int, int, int))(*(_DWORD *)a2 + 172))(
           a2,
           v13,
           a3,
           a4,
           0,
           a5,
           Buffer,
           v11,
           v19,
           v12,
           v16);
}

//----- (00437670) --------------------------------------------------------
int __thiscall sub_437670(_DWORD *this)
{
  _DWORD *v1; // ebx
  void *v2; // ecx
  int v3; // eax
  int v4; // ecx
  int result; // eax
  int v6; // edi
  int v7; // eax
  char *v8; // esi
  int v9; // edi
  char *v10; // eax
  char *v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // [esp-4h] [ebp-38h]
  unsigned __int8 *v14; // [esp+Ch] [ebp-28h] BYREF
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  int v17; // [esp+18h] [ebp-1Ch]
  _DWORD *v18; // [esp+1Ch] [ebp-18h]
  int v19; // [esp+20h] [ebp-14h]
  unsigned int v20; // [esp+24h] [ebp-10h]
  int v21; // [esp+30h] [ebp-4h]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v1 = this;
  v2 = (void *)this[27545];
  v18 = v1;
  sub_40B7D0(v2);
  v1[27545] = 0;
  v1[27547] = 0;
  v1[27546] = 0;
  v3 = v1[29429];
  v1[1912] = 0;
  v4 = *(_DWORD *)(v3 + 1204);
  v17 = 0;
  result = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v4 + 36))(v4, 0);
  v6 = result;
  v19 = result;
  if ( !result )
    return result;
  while ( 2 )
  {
    v7 = *(_DWORD *)(v6 + 4);
    v8 = (char *)(v6 + 8);
    v20 = 0;
    if ( !v7 )
      goto LABEL_14;
    do
    {
      if ( v8[16] )
        goto LABEL_12;
      v14 = 0;
      v15 = 0;
      v21 = 0;
      sub_40C9D0((int)&v14, (int)&savedregs, *((_DWORD *)v8 + 1) + 64);
      v9 = *((_DWORD *)v8 + 1);
      v13 = (unsigned __int8 *)*((_DWORD *)v8 + 3);
      v10 = strchr(v8 + 16, 0);
      if ( sub_412680(v14, v15, (unsigned __int8 *)v10 + 1, v13) != v9 )
      {
        v16 = 9291082;
        v11 = (char *)(9291082 - (_DWORD)&loc_42ECEE);
LABEL_10:
        sub_40DA80(v11);
        goto LABEL_11;
      }
      if ( !(*(unsigned __int8 (__thiscall **)(_DWORD *, unsigned __int8 *, int))(*v18 + 440))(v18, v14, v9) )
      {
        v16 = 9291792;
        v11 = (char *)(9291792 - ((_DWORD)&loc_42EFC6 + 2));
        goto LABEL_10;
      }
LABEL_11:
      v21 = -1;
      sub_40C9D0((int)&v14, (int)&savedregs, 0);
      v6 = v19;
LABEL_12:
      ++v20;
      v8 = &strchr(v8 + 16, 0)[*((_DWORD *)v8 + 3) + 1];
    }
    while ( v20 < *(_DWORD *)(v6 + 4) );
    v1 = v18;
LABEL_14:
    v12 = *(_DWORD *)(v1[29429] + 1204);
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)v12 + 36))(v12, ++v17);
    v19 = result;
    if ( result )
    {
      v6 = v19;
      continue;
    }
    return result;
  }
}

//----- (00437870) --------------------------------------------------------
char __thiscall sub_437870(_DWORD *this, char *a2)
{
  int v2; // eax
  _DWORD *v3; // ebx
  int v4; // esi
  int i; // eax
  int v6; // ebx
  _DWORD *v7; // esi
  int v8; // edi
  int v10; // [esp+0h] [ebp-B00h] BYREF
  char v11[580]; // [esp+Ch] [ebp-AF4h] BYREF
  char v12[580]; // [esp+250h] [ebp-8B0h] BYREF
  char v13[1024]; // [esp+494h] [ebp-66Ch] BYREF
  int v14[145]; // [esp+894h] [ebp-26Ch] BYREF
  char v15[16]; // [esp+AD8h] [ebp-28h] BYREF
  _DWORD *v16; // [esp+AE8h] [ebp-18h]
  int v17[2]; // [esp+AECh] [ebp-14h] BYREF
  int v18; // [esp+AFCh] [ebp-4h]
  int savedregs; // [esp+B00h] [ebp+0h] BYREF

  v17[1] = (int)&v10;
  v16 = this;
  v18 = 0;
  v2 = 0;
  v3 = (_DWORD *)((char *)&loc_42B3A1 + 3);
  do
    v2 -= *v3++;
  while ( v3 < (_DWORD *)((char *)&loc_42B761 + 3) );
  v4 = (int)this + v2 + 1986858658;
  for ( i = 0; i < *(_DWORD *)(v4 + 8); ++i )
    ;
  sub_40B7D0(*(void **)v4);
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 4) = 0;
  v17[0] = -1;
  LOBYTE(v18) = 1;
  sub_407E80(v17, (int)&savedregs, a2, 1, 3);
  memset(v12, 0, sizeof(v12));
  while ( sub_4085E0(v17, v13, 1024) )
  {
    sub_40B8B0(v15, 16, v13, 58, 3);
    if ( !strcmp(v15, asc_4AD87C) )
    {
      qmemcpy(v14, v12, sizeof(v14));
    }
    else
    {
      v14[11] = sub_46D80E(v15);
      sub_40B8B0(v15, 16, v13, 58, 4);
      v14[12] = sub_46D80E(v15);
      sub_40B8B0(&v14[77], 256, v13, 58, 5);
    }
    sub_40B8B0(&v14[141], 16, v13, 58, 0);
    sub_40B8B0((_BYTE *)v14 + 1, 40, v13, 58, 1);
    sub_40B8B0(&v14[13], 256, v13, 58, 2);
    if ( LOBYTE(v14[141]) && BYTE1(v14[0]) )
    {
      LOBYTE(v14[0]) = 0;
      v6 = v16[3];
      v7 = v16 + 1;
      if ( v6 >= v16[2] )
      {
        if ( v6 >= 8 )
          v8 = v6 >= 32 ? 32 : 8;
        else
          v8 = 4;
        sub_40B780(580 * (v6 + v8), (void **)v16 + 1, (int)&savedregs);
        v7[1] += v8;
      }
      sub_46CAB0(*v7 + 580 * (v6 + 1), (_BYTE *)(*v7 + 580 * v6), 580 * v7[2]++ - 580 * v6);
      sub_46CAB0(*v7 + 580 * v6, v11, 0x244u);
      qmemcpy((void *)(*v7 + 580 * v6), v14, 0x244u);
      qmemcpy(v12, v14, sizeof(v12));
    }
  }
  LOBYTE(v18) = 0;
  sub_4087F0(v17);
  return 1;
}

//----- (00437C10) --------------------------------------------------------
int __thiscall sub_437C10(_DWORD *this)
{
  unsigned __int16 (__stdcall *v1)(int); // ebx
  int v3; // esi
  bool v4; // zf
  int v5; // eax

  v1 = (unsigned __int16 (__stdcall *)(int))dword_4A7374;
  v3 = 0;
  if ( (((unsigned __int16)dword_4A7374(18) >> 8) & 0x80u) == 0 )
    this[90] &= 0xFEEFFFFF;
  else
    v3 = this[90] & 0x1100000 | 0x10000;
  v4 = ((v1(17) >> 8) & 0x80u) == 0;
  v5 = this[90];
  if ( v4 )
    this[90] = v5 & 0xFDDFFFFF;
  else
    v3 |= v5 & 0x2200000 | 0x20000;
  if ( ((v1(16) >> 8) & 0x80u) != 0 )
    return this[90] & 0x4400000 | 0x40000 | v3;
  this[90] &= 0xFBBFFFFF;
  return v3;
}
// 4A7374: using guessed type int (__stdcall *dword_4A7374)(_DWORD);

//----- (00437CB0) --------------------------------------------------------
char __thiscall sub_437CB0(int this)
{
  int *v2; // ecx
  char result; // al

  sub_411F20((_DWORD *)this, 50);
  sub_407790(v2);
  for ( result = *(_BYTE *)(this + 16); !result; result = *(_BYTE *)(this + 16) )
  {
    if ( sub_4124F0((_DWORD *)(this + 197536)) - *(_DWORD *)(this + 197552) >= 200 )
      (*(void (__thiscall **)(int, int))(*(_DWORD *)this + 32))(this, 1);
    sub_412000((void *)0x64);
  }
  return result;
}
// 437CBA: variable 'v2' is possibly undefined

//----- (00437D00) --------------------------------------------------------
char __thiscall sub_437D00(char *this, int a2)
{
  char *v3; // ebx
  char *v4; // edi
  char *v5; // edi
  int v6; // edx
  int v7; // edx
  int (__stdcall *v8)(char *, _DWORD, _DWORD, _DWORD, _DWORD); // edi
  int (__stdcall *v9)(char *, _DWORD, _DWORD, _DWORD, _DWORD); // edi
  int v10; // eax
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int (__stdcall *v16)(char *, _DWORD, _DWORD, _DWORD, _DWORD); // edi
  int v17; // edx
  int v18; // eax
  int v19; // edi
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // edx
  char v26; // al
  int v27; // edi
  int v28; // eax
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // [esp-1Ch] [ebp-15Ch]
  int v33; // [esp-18h] [ebp-158h]
  int v34; // [esp-14h] [ebp-154h]
  int v35; // [esp-8h] [ebp-148h]
  int v36; // [esp-4h] [ebp-144h]
  _BYTE v37[260]; // [esp+Ch] [ebp-134h] BYREF
  int v38; // [esp+110h] [ebp-30h]
  char v39[28]; // [esp+114h] [ebp-2Ch] BYREF
  int v40; // [esp+130h] [ebp-10h]
  int v41; // [esp+134h] [ebp-Ch]
  bool v42; // [esp+13Bh] [ebp-5h]
  int v43; // [esp+13Ch] [ebp-4h]

  v43 = 9319198;
  *((_DWORD *)this + 49381) = 0;
  sub_40DA80((char *)(v43 - 4413658));
  (**((void (__thiscall ***)(int))this + 12))((int)(this + 48));
  (*(void (__thiscall **)(char *))(*(_DWORD *)this + 36))(this);
  v43 = 9319961;
  sub_40DA80((char *)(9319961 - ((_DWORD)&loc_435BE3 + 2)));
  if ( (*(int (__cdecl **)(char *))(this + 206638))(this + 197556) == 1 )
  {
    v38 = 9322293;
    v41 = 9323320;
    v3 = this + 75756;
    while ( 2 )
    {
      v37[0] = 0;
      dword_4A7100(0, v37, 260);
      sub_407A70(v37);
      if ( !dword_4A7114(v37) )
      {
        v43 = 9778923;
        sub_40DA80((char *)(9778923 - (_DWORD)&byte_4A6AF7));
      }
      memset((void *)(*((_DWORD *)this + 49378) + 4), 0, 0x38u);
      (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 4))(*((_DWORD *)this + 49378));
      v4 = (char *)(v38 - (_DWORD)&loc_436511);
      sub_412170();
      sub_40DA80(v4);
      (*(void (__thiscall **)(char *, char *))(*((_DWORD *)this + 49101) + 20))(this + 196404, this + 197556);
      (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 44))(*((_DWORD *)this + 49378));
      (*(void (__thiscall **)(char *, int, char *))(*(_DWORD *)v3 + 296))(this + 75756, 100000, this + 197556);
      v5 = (char *)(v41 - ((_DWORD)&loc_436927 + 1));
      sub_412170();
      sub_40DA80(v5);
      LOBYTE(v6) = this[198194];
      (*(void (__thiscall **)(char *, int, _DWORD))(*(_DWORD *)v3 + 224))(this + 75756, v6, *((_DWORD *)this + 51685));
      (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 60))(*((_DWORD *)this + 49378));
      while ( 1 )
      {
        while ( 1 )
        {
          sub_412390((_DWORD *)this + 49384);
          v7 = *(_DWORD *)v3;
          v42 = 0;
          if ( !(*(unsigned __int8 (__thiscall **)(char *))(v7 + 312))(this + 75756) )
          {
            while ( !v42 )
            {
              v8 = (int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))dword_4A737C;
              if ( dword_4A737C(v39, 0, 0, 0, 0) )
              {
                do
                {
                  if ( !dword_4A7380(v39, 0, 0, 0) )
                    break;
                  dword_4A7384(v39);
                  dword_4A7388(v39);
                }
                while ( v8(v39, 0, 0, 0, 0) );
              }
              (**((void (__thiscall ***)(int, int))this + 49101))((int)(this + 196404), 2);
              if ( this[196486] )
                goto LABEL_47;
              sub_412000((void *)0x14);
              v42 = sub_412400((_DWORD *)this + 49384, 30000);
              if ( (*(unsigned __int8 (__thiscall **)(char *))(*(_DWORD *)v3 + 312))(this + 75756) )
              {
                if ( !v42 )
                  goto LABEL_14;
                break;
              }
            }
            (*(void (__cdecl **)(int, _DWORD))(this + 206690))(50, 0);
            goto LABEL_47;
          }
LABEL_14:
          v9 = (int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))dword_4A737C;
          if ( this[196486] )
            goto LABEL_47;
          if ( *((_DWORD *)this + 19292) != 1000 )
            break;
          if ( (*(int (__cdecl **)(int, _DWORD))(this + 206690))(97, 0) != 1 )
            goto LABEL_47;
          (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 44))(*((_DWORD *)this + 49378));
          (*(void (__thiscall **)(char *, int, _DWORD))(*(_DWORD *)v3 + 224))(
            this + 75756,
            1,
            *((_DWORD *)this + 51685));
        }
        if ( this[195836] )
        {
          if ( *((int *)this + 48383) >= 40 )
          {
            v10 = 0;
          }
          else
          {
            v43 = 9333175;
            v10 = 9333175 - ((_DWORD)&loc_43907E + 1);
          }
          if ( (*(int (__cdecl **)(int, int))(this + 206690))(100, v10) )
          {
            v43 = 9334496;
            sub_4079D0(this + 77209, 9334496 - (_DWORD)&loc_4395BC);
            (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 476))(this + 75756);
            (*(void (__thiscall **)(char *))(*(_DWORD *)this + 48))(this);
            if ( this[98867] && sub_408AA0(this + 77209) )
            {
              (*(void (__cdecl **)(_DWORD))(this + 206642))(0);
              dword_4A72BC(0, 0, this + 77209, 0, 0, 5);
              return 0;
            }
            goto LABEL_47;
          }
          if ( this[77188] )
            goto LABEL_47;
        }
        v11 = *((_DWORD *)this + 19292);
        if ( v11 )
        {
          v12 = v11 >= 0x11 ? 0 : dword_4AB008[v11];
          if ( !(*(int (__cdecl **)(int, _DWORD))(this + 206690))(v12, *((_DWORD *)this + 47341)) )
          {
            v13 = *((_DWORD *)this + 19292);
            if ( v13 != 6 && v13 != 13 )
              goto LABEL_47;
          }
        }
        if ( *((_DWORD *)this + 19292) != 1 )
          break;
        (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 44))(*((_DWORD *)this + 49378));
        (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 49378) + 20))(*((_DWORD *)this + 49378));
        (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 432))(this + 75756);
      }
      if ( *((_DWORD *)this + 19292) == 16 )
        (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 340))(this + 75756);
      if ( this[77932] )
      {
        v14 = (*(int (__cdecl **)(int, _DWORD))(this + 206690))(99, 0);
        if ( !v14 )
          goto LABEL_47;
        if ( v14 == 2 )
        {
          v43 = 9341518;
          sub_407960(this + 77209, (int)(this + 197825), (_BYTE *)(9341518 - ((_DWORD)&loc_43C257 + 3)));
          (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 472))(this + 75756);
          (*(void (__thiscall **)(char *))(*(_DWORD *)this + 48))(this);
          if ( this[98867] )
            sub_43E490(*(_DWORD *)(this + 197821), this + 77209);
          v9 = (int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))dword_4A737C;
        }
      }
      if ( *((_DWORD *)this + 19293) == 3 )
      {
        this[197532] = 0;
        this[197533] = 1;
        while ( v9(v39, 0, 0, 0, 0) )
        {
          if ( !dword_4A7380(v39, 0, 0, 0) )
            break;
          dword_4A7384(v39);
          dword_4A7388(v39);
        }
        v41 = 9350296;
        sub_40DA80((char *)(9350296 - (_DWORD)sub_43D3A0));
        dword_4A70D4(*((_DWORD *)this + 49380));
        (*(void (__thiscall **)(char *, char *, _DWORD, int))(*((_DWORD *)this + 5) + 12))(
          this + 20,
          this + 197825,
          0,
          20);
        v41 = 9341704;
        (*(void (__thiscall **)(char *, int, _DWORD, int))(*((_DWORD *)this + 5) + 12))(
          this + 20,
          9341704 - (_DWORD)&loc_43D7F8,
          0,
          10);
        v41 = 9330070;
        (*(void (__thiscall **)(char *, int, _DWORD, int))(*((_DWORD *)this + 5) + 12))(
          this + 20,
          9330070 - (_DWORD)&loc_43D90E,
          0,
          10);
        v41 = 9331513;
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD))(*((_DWORD *)this + 5) + 12))(
          this + 20,
          9331513 - ((_DWORD)&loc_43DA24 + 1),
          0,
          0);
        sub_412000((void *)0xA);
        v16 = (int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))dword_4A737C;
        if ( dword_4A737C(v39, 0, 0, 0, 0) )
        {
          do
          {
            if ( !dword_4A7380(v39, 0, 0, 0) )
              break;
            dword_4A7384(v39);
            dword_4A7388(v39);
          }
          while ( v16(v39, 0, 0, 0, 0) );
        }
        v41 = 9353335;
        sub_40DA80((char *)(9353335 - ((_DWORD)&loc_43DF91 + 6)));
        (*(void (__thiscall **)(char *))(*(_DWORD *)this + 12))(this);
        if ( *(_DWORD *)(this + 205563) != 2 )
        {
          v41 = 9354163;
          sub_40DA80((char *)(9354163 - ((_DWORD)&loc_43E2DC + 3)));
          v18 = *(_DWORD *)(this + 205567);
          if ( !v18 || v18 == 2 || (v43 = 8, v18 == 4) )
            v43 = 16;
          switch ( v18 )
          {
            case 0:
            case 1:
              v19 = 44100;
              break;
            case 2:
            case 3:
              v19 = 22050;
              break;
            case 4:
            case 5:
              v19 = 11025;
              break;
            default:
              v19 = 0;
              break;
          }
          LOBYTE(v17) = this[205621];
          (*(void (__thiscall **)(char *, _DWORD, int, int, int))(*((_DWORD *)this + 18856) + 8))(
            this + 75424,
            *((_DWORD *)this + 49382),
            v19,
            v43,
            v17);
        }
        v41 = 9356663;
        sub_40DA80((char *)(9356663 - ((_DWORD)&loc_43ECBA + 1)));
        (*(void (__thiscall **)(char *))(*((_DWORD *)this + 18856) + 16))(this + 75424);
        v20 = *(_DWORD *)(this + 205831);
        if ( v20 )
          v21 = 40 * (5 * v20 - 50);
        else
          v21 = -10000;
        (*(void (__thiscall **)(char *, int))(*((_DWORD *)this + 18856) + 36))(this + 75424, v21);
        v22 = *(_DWORD *)(this + 205827);
        if ( v22 )
          v23 = 40 * (5 * v22 - 50);
        else
          v23 = -10000;
        v36 = 0;
        v35 = v23;
        v24 = (*(int (__thiscall **)(_DWORD))(**((_DWORD **)this + 18934) + 32))(*((_DWORD *)this + 18934));
        LOBYTE(v24) = this[205530] == 0;
        (*(void (__cdecl **)(int))(this + 206642))(v24);
        dword_4A7304(*((_DWORD *)this + 49382));
        v41 = 9359457;
        sub_40DA80((char *)(9359457 - ((_DWORD)&loc_43F7BC + 1)));
        v25 = *(_DWORD *)(this + 205531);
        v41 = *(_DWORD *)(this + 205535);
        v26 = this[205530];
        v40 = v25;
        if ( v26 )
        {
          v27 = dword_4A72C4(0, v35) - 32;
          v28 = dword_4A72C4(1, 0) - 64;
          if ( v40 > v27 )
            v40 = v27;
          if ( v41 > v28 )
            v41 = v28;
        }
        v29 = *(_DWORD *)(this + 205539);
        this[99] = this[205815];
        v34 = v29;
        LOBYTE(v25) = this[205530] == 0;
        v33 = v25;
        v30 = v40;
        v32 = *((_DWORD *)this + 51408) / 8;
        v31 = v41;
        this[100] = this[205814];
        (*(void (__thiscall **)(char *, _DWORD, int, int, int, int, int, _DWORD, _DWORD, int, int))(*((_DWORD *)this + 12)
                                                                                                  + 4))(
          this + 48,
          *((_DWORD *)this + 49382),
          v30,
          v31,
          v32,
          v33,
          v34,
          0,
          0,
          v35,
          v36);
        v41 = 9362557;
        sub_40DA80((char *)(9362557 - (_DWORD)&loc_4403ED));
        (*(void (__thiscall **)(char *))(*((_DWORD *)this + 12) + 116))(this + 48);
        (*(void (__thiscall **)(char *, char *))(*(_DWORD *)v3 + 164))(this + 75756, this + 56);
        v41 = 9363394;
        sub_40DA80((char *)(9363394 - ((_DWORD)sub_440740 + 2)));
        this[197532] = 1;
        this[206844] = 1;
        this[206845] = 1;
        return 1;
      }
      v43 = 9348097;
      (*(void (__cdecl **)(_DWORD, int))(this + 206690))(0, 9348097 - ((_DWORD)&loc_43CAF8 + 1));
LABEL_47:
      if ( (*(int (__cdecl **)(char *))(this + 206638))(this + 197556) == 1 )
        continue;
      break;
    }
  }
  return 0;
}
// 437E69: variable 'v6' is possibly undefined
// 4383B0: variable 'v17' is possibly undefined
// 4384CD: variable 'v25' is possibly undefined
// 4384F9: variable 'v35' is possibly undefined
// 4384F9: variable 'v36' is possibly undefined
// 43D3A0: using guessed type int sub_43D3A0();
// 4A6AF7: using guessed type char byte_4A6AF7;
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4A7114: using guessed type int (__stdcall *dword_4A7114)(_DWORD);
// 4A72BC: using guessed type int (__stdcall *dword_4A72BC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A72C4: using guessed type int (__stdcall *dword_4A72C4)(_DWORD, _DWORD);
// 4A7304: using guessed type int (__stdcall *dword_4A7304)(_DWORD);
// 4A737C: using guessed type int (__stdcall *dword_4A737C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7380: using guessed type int (__stdcall *dword_4A7380)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7384: using guessed type int (__stdcall *dword_4A7384)(_DWORD);
// 4A7388: using guessed type int (__stdcall *dword_4A7388)(_DWORD);
// 4AB008: using guessed type int dword_4AB008[];

//----- (00438570) --------------------------------------------------------
void __thiscall sub_438570(_DWORD *this, _BYTE *a2, int a3)
{
  _DWORD *v3; // edi
  int v4; // eax
  int v5; // esi
  int v6; // eax
  char *v7; // ebx
  int *v8; // eax
  int v9; // edx
  unsigned int v10; // [esp-4h] [ebp-200h]
  int v11; // [esp-4h] [ebp-200h]
  int v12; // [esp+0h] [ebp-1FCh] BYREF
  char v13[260]; // [esp+Ch] [ebp-1F0h] BYREF
  int v14[39]; // [esp+110h] [ebp-ECh] BYREF
  int v15[6]; // [esp+1B0h] [ebp-4Ch] BYREF
  char v16; // [esp+1C8h] [ebp-34h]
  int v17; // [esp+1CCh] [ebp-30h]
  _DWORD pExceptionObject[2]; // [esp+1D0h] [ebp-2Ch] BYREF
  int v19; // [esp+1D8h] [ebp-24h]
  char *v20; // [esp+1DCh] [ebp-20h]
  _DWORD *v21; // [esp+1E0h] [ebp-1Ch]
  unsigned int v22; // [esp+1E4h] [ebp-18h]
  char *v23; // [esp+1E8h] [ebp-14h]
  int *v24; // [esp+1ECh] [ebp-10h]
  int v25; // [esp+1F8h] [ebp-4h]
  int savedregs; // [esp+1FCh] [ebp+0h] BYREF

  v3 = this;
  v24 = &v12;
  v21 = this;
  v4 = sub_40B720((int)&savedregs, 0x11Cu);
  v5 = 0;
  if ( v4 )
  {
    *(_BYTE *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 268) = 0;
    *(_DWORD *)(v4 + 272) = 0;
    v5 = v4;
  }
  v6 = a3;
  v23 = (char *)v5;
  v19 = v5;
  *(_DWORD *)v5 = 1;
  *(_DWORD *)(v5 + 4) = v6;
  *(_BYTE *)(v5 + 280) = 1;
  sub_4079D0((_BYTE *)(v5 + 8), (int)a2);
  a3 = 9367886;
  sub_40DA80((char *)(9367886 - ((_DWORD)&loc_4416E5 + 1)));
  v25 = 0;
  sub_407960(v13, (int)byte_4A7DB0, a2);
  sub_40CFE0((unsigned int *)(v5 + 268), (int)&savedregs, v13, 0);
  v10 = *(_DWORD *)(v5 + 272);
  v20 = *(char **)(v5 + 268);
  if ( !sub_44C8D0(v20, v10) )
  {
    sub_406F10(pExceptionObject, (int)&savedregs, (const char *)(9369591 - ((_DWORD)&loc_441DA2 + 1)));
    _CxxThrowException(pExceptionObject, &_TI1_AVbase_exception__);
  }
  v11 = v3[6];
  v25 = -1;
  *(_DWORD *)sub_455580((int)(v3 + 4), (int)&savedregs, v11) = v5;
  v17 = sub_408AE0(a2);
  v22 = 0;
  v7 = v20 + 8;
  v23 = v20 + 8;
  while ( v22 < *((_DWORD *)v20 + 1) )
  {
    if ( v7[16] )
    {
      sub_421C80((char *)v14, (int)(v7 + 16));
      v14[0] = v19;
      v14[36] = v17;
      v14[35] = (int)v7;
      v8 = (int *)sub_4554C0((int)(v3 + 1), (int)&savedregs, v3[3]);
      qmemcpy(v8, v14, 0x9Cu);
      if ( LOBYTE(v14[2]) == 58
        && !strchr((const char *)&v14[2], 47)
        && !strchr((const char *)&v14[2], 92)
        && !strchr((const char *)&v14[2] + 1, 58) )
      {
        v16 = 0;
        v15[0] = 0;
        v15[1] = 0;
        v9 = *v21;
        v25 = 2;
        if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, int *, int *))(v9 + 28))(v21, v15, &v14[2]) )
        {
          LOBYTE(v25) = 3;
          sub_407960(v13, (int)byte_4A7DB0, a2);
          sub_407A70(v13);
          sub_407960(v13, (int)v13, (_BYTE *)&v14[2] + 1);
          a3 = -1;
          LOBYTE(v25) = 4;
          sub_4080D0(&a3, (int)&savedregs, v13, 0, 2);
          sub_4086E0(&a3, v15[2], v15[3]);
          LOBYTE(v25) = 3;
          sub_4087F0(&a3);
        }
        v25 = -1;
        sub_40C9D0((int)v15, (int)&savedregs, 0);
      }
      v3 = v21;
    }
    ++v22;
    v7 = &strchr(v7 + 16, 0)[*((_DWORD *)v7 + 3) + 1];
    v23 = v7;
  }
  qsort((void *)v3[1], v3[3], 0x9Cu, sub_421E20);
}

//----- (00438890) --------------------------------------------------------
int __thiscall sub_438890(int this, int a2)
{
  int result; // eax
  int v3; // eax
  _DWORD *v4; // ebx
  int v5; // edx

  strcpy((char *)(this + 12), (const char *)(9380680 - (_DWORD)&loc_4448D0));
  result = (**(int (__thiscall ***)(int, int))(this + 100))(this + 100, a2);
  if ( (_BYTE)result )
  {
    v3 = 0;
    v4 = (_DWORD *)((char *)&loc_445982 + 2);
    do
      v3 -= *v4++;
    while ( v4 < (_DWORD *)&loc_445B68 );
    *(_DWORD *)(v3 - 1708789124 + this + 1065600) = *(_DWORD *)(this + 112);
    v5 = *(_DWORD *)(this + 80);
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 84) = 0;
    *(_BYTE *)(this + 377) = 0;
    *(_BYTE *)(this + 376) = 0;
    result = v5 != 0;
    *(_BYTE *)(this + 96) = result;
  }
  return result;
}

//----- (00438950) --------------------------------------------------------
void __thiscall sub_438950(int this)
{
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *i; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // [esp+Ch] [ebp-18h]
  int v14; // [esp+10h] [ebp-14h]
  int v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  int j; // [esp+20h] [ebp-4h]
  int savedregs; // [esp+24h] [ebp+0h] BYREF

  if ( *(_DWORD *)(this + 92) != 8 )
  {
    if ( *(_BYTE *)(this + 156) )
    {
      v2 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 2168) + 520);
      v2[1] = ++dword_4C1AE4;
      *v2 = -1 - v2[1];
    }
    if ( *(int *)(this + 64) <= 0 )
    {
      v3 = *(_DWORD *)(this + 76);
      *(_DWORD *)(this + 64) = 102;
      if ( v3 != 2 )
      {
        v4 = 0;
        for ( i = (_DWORD *)(&loc_42305F + 1); (unsigned int)i < 0x4233EC; ++i )
          v4 -= *i;
        (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(v4
                                                                                             + 45524791
                                                                                             + this
                                                                                             + 1123860)
                                                                               + 260))(
          *(_DWORD *)(v4 + 45524791 + this + 1123860),
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 120076) + 132),
          *(_DWORD *)(v4 + 45524791 + this + 1123852),
          *(_DWORD *)(v4 + 45524791 + this + 1123856),
          0,
          0);
        if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 23100) + 8046) )
        {
          for ( j = 0; j < 90; j += 10 )
          {
            if ( *(_DWORD *)(*(_DWORD *)(this + 12) + 8680) == 256 )
              break;
            v6 = rand() % 3000 - 1500;
            v7 = rand();
            v8 = *(_DWORD *)(this + 16) + (v6 >= 0 ? 500 : -500) + v6;
            v9 = *(_DWORD *)(this + 20) + (v7 % 3000 - 1500 >= 0 ? 500 : -500) + v7 % 3000 - 1500;
            v17 = rand() % 150 + 90;
            v15 = rand() % 90 + 30;
            v10 = sub_40B720((int)&savedregs, 0x40u);
            if ( v10 )
            {
              v13 = *(_DWORD *)(this + 4);
              v14 = *(_DWORD *)(this + 8);
              v16 = *(_DWORD *)(this + 92);
              *(_DWORD *)(v10 + 12) = *(_DWORD *)(this + 12);
              *(_DWORD *)(v10 + 28) = v17;
              *(_DWORD *)(v10 + 32) = j;
              *(_DWORD *)(v10 + 36) = v16;
              *(_DWORD *)(v10 + 48) = v15;
              *(_DWORD *)(v10 + 8) = 0;
              *(_DWORD *)(v10 + 4) = 0;
              *(_DWORD *)(v10 + 4) = v13;
              *(_DWORD *)(v10 + 20) = 0;
              *(_DWORD *)(v10 + 16) = 0;
              *(_DWORD *)(v10 + 16) = v8;
              *(_DWORD *)(v10 + 24) = 0;
              *(_DWORD *)(v10 + 44) = 10;
              *(_BYTE *)(v10 + 52) = 0;
              *(_DWORD *)v10 = off_4AC414;
              *(_DWORD *)(v10 + 8) = v14;
              *(_DWORD *)(v10 + 20) = v9;
              *(_DWORD *)(v10 + 40) = 0;
            }
            else
            {
              v10 = 0;
            }
            v11 = *(_DWORD *)(this + 12) + 7656;
            v12 = *(_DWORD *)(*(_DWORD *)(this + 12) + 8680);
            if ( v12 >= 256 )
            {
              sub_40B7E0(v10);
            }
            else
            {
              *(_DWORD *)(v11 + 4 * v12) = v10;
              ++*(_DWORD *)(v11 + 1024);
            }
          }
        }
      }
    }
  }
}
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00439260) --------------------------------------------------------
unsigned int __thiscall sub_439260(char *this, void *a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // esi
  int v7; // ebx
  unsigned int result; // eax
  unsigned int v9; // [esp-18h] [ebp-6Ch]
  char v10[36]; // [esp+Ch] [ebp-48h] BYREF
  int v11[9]; // [esp+30h] [ebp-24h] BYREF
  int savedregs; // [esp+54h] [ebp+0h] BYREF

  strncpyt(v11, a2, 32);
  v11[8] = strlen((const char *)v11);
  sub_40BD10((char *)v11);
  v3 = -2013097493;
  v4 = 234;
  do
    v3 ^= *(_DWORD *)&aAntiwarpLost[4 * v4-- - 389184];
  while ( v4 );
  v5 = *(_DWORD *)&this[v3 + 48140];
  v6 = (int)&this[v3 + 48132];
  if ( v5 >= *(_DWORD *)(v6 + 4) )
  {
    if ( v5 >= 8 )
      v7 = v5 >= 32 ? 32 : 8;
    else
      v7 = 4;
    sub_40B780(36 * (v5 + v7), (void **)v6, (int)&savedregs);
    *(_DWORD *)(v6 + 4) += v7;
  }
  sub_46CAB0(*(_DWORD *)v6 + 4 * (9 * v5 + 9), (_BYTE *)(*(_DWORD *)v6 + 36 * v5), 36 * *(_DWORD *)(v6 + 8) - 36 * v5);
  v9 = 36 * v5 + *(_DWORD *)v6;
  ++*(_DWORD *)(v6 + 8);
  result = sub_46CAB0(v9, v10, 0x24u);
  qmemcpy((void *)(36 * v5 + *(_DWORD *)v6), v11, 0x24u);
  return result;
}

//----- (00439340) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_439340(_DWORD *this, char a2)
{
  int v3; // edi
  int v4; // ecx
  __int64 v5; // rax
  int v7; // [esp-4h] [ebp-28h]
  int v8; // [esp+0h] [ebp-24h]
  int v9; // [esp+4h] [ebp-20h]
  __int64 v10; // [esp+Ch] [ebp-18h] BYREF
  int v11; // [esp+14h] [ebp-10h] BYREF
  int v12; // [esp+1Ch] [ebp-8h] BYREF

  v3 = sub_412170();
  dword_4A7294((char *)&v10 + 4, v7, v8, v9);
  dword_4A7120(&v12, &v11);
  v5 = v10 / 10000;
  v4 = v3 - this[17];
  HIDWORD(v5) = v10 / 10000 - this[18];
  if ( v4 <= 10000 && SHIDWORD(v5) <= 10000 && !a2 )
    return 0;
  this[18] = v5;
  this[17] = v3;
  return (v4 - HIDWORD(v5)) / 100;
}
// 4393AE: positive sp value 4 has been found
// 439354: variable 'v7' is possibly undefined
// 439354: variable 'v8' is possibly undefined
// 439354: variable 'v9' is possibly undefined
// 4A7120: using guessed type int (__cdecl *dword_4A7120)(_DWORD, _DWORD);
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004393E0) --------------------------------------------------------
int __thiscall sub_4393E0(_DWORD *this)
{
  int result; // eax
  int v3; // esi
  int (__stdcall *v4)(int, _DWORD *); // edi
  _BYTE v5[260]; // [esp+8h] [ebp-34Ch] BYREF
  _DWORD v6[65]; // [esp+10Ch] [ebp-248h] BYREF
  _DWORD v7[11]; // [esp+210h] [ebp-144h] BYREF
  char String[276]; // [esp+23Ch] [ebp-118h] BYREF
  int v9; // [esp+350h] [ebp-4h] BYREF

  dword_4A7128(v6, 260);
  v9 = 9431698;
  sub_407960(v5, (int)v6, (_BYTE *)(9431698 - ((_DWORD)&loc_451210 + 6)));
  result = dword_4A7270(v5, v7);
  v3 = result;
  if ( result != -1 )
  {
    v4 = (int (__stdcall *)(int, _DWORD *))dword_4A726C;
    do
    {
      _strlwr(String);
      v9 = -1;
      sub_401AB0(&v9, (unsigned __int8 *)String);
      if ( v9 == 404182022 )
        this[9] = v7[1] ^ v7[2];
    }
    while ( v4(v3, v7) );
    result = dword_4A7274(v3);
  }
  return result;
}
// 4A7128: using guessed type int (__stdcall *dword_4A7128)(_DWORD, _DWORD);
// 4A726C: using guessed type int (__stdcall *dword_4A726C)(_DWORD, _DWORD);
// 4A7270: using guessed type int (__stdcall *dword_4A7270)(_DWORD, _DWORD);
// 4A7274: using guessed type int (__stdcall *dword_4A7274)(_DWORD);

//----- (004394A0) --------------------------------------------------------
int __thiscall sub_4394A0(const char *this, _BYTE *a2, int a3, int a4)
{
  unsigned __int64 v4; // rax
  unsigned int v6; // kr04_4
  char *v7; // edi

  v4 = (unsigned int)a4;
  if ( a4 > 0 )
  {
    do
    {
      *a2 = *(_BYTE *)(HIDWORD(v4) + a3) ^ 0xAA;
      if ( *(_WORD *)(HIDWORD(v4) + a3) == 0xF9F9 && *(_BYTE *)(HIDWORD(v4) + a3 + 2) == 0xFA )
      {
        HIDWORD(v4) += 6;
        v6 = strlen(this + 60) + 1;
        qmemcpy(a2, this + 60, 4 * (v6 >> 2));
        v7 = &a2[4 * (v6 >> 2)];
        a2 += 6;
        qmemcpy(v7, &this[4 * (v6 >> 2) + 60], v6 & 3);
      }
      v4 = __PAIR64__(HIDWORD(v4), a4) + 0x100000000i64;
      ++a2;
    }
    while ( SHIDWORD(v4) < a4 );
  }
  return v4;
}

//----- (00439570) --------------------------------------------------------
char __thiscall sub_439570(char *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // edx
  unsigned int v7; // edi
  int v8; // ebx
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // edi
  unsigned __int8 v14; // al
  int v15; // eax
  _DWORD *i; // ebx
  int v17; // eax
  int v18; // edx
  bool v19; // zf
  char *v20; // eax
  int v21; // ecx
  int v22; // ecx
  char v24[200]; // [esp+Ch] [ebp-F4h] BYREF
  int v25[6]; // [esp+D4h] [ebp-2Ch] BYREF
  char v26; // [esp+ECh] [ebp-14h]
  int v27; // [esp+F0h] [ebp-10h]
  int v28; // [esp+FCh] [ebp-4h]
  int savedregs; // [esp+100h] [ebp+0h] BYREF

  v2 = a2;
  if ( a2[22] == 28 )
  {
    this[580] = this[580] == 0;
    (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
  }
  v4 = a2[22];
  if ( v4 >= 30 && v4 <= 49 )
  {
    v5 = (_DWORD *)*((_DWORD *)this + 137);
    v6 = v5[28116];
    v7 = v5[28118];
    if ( v7 >= *(_DWORD *)(v6 + 6276) )
      v8 = 0;
    else
      v8 = *(_DWORD *)(v6 + 4 * v7 + 2180);
    v9 = v5[v4 + 30112];
    if ( v9 < 0 )
    {
      if ( this[292] )
        strncpyt((void *)(*((_DWORD *)this + 66) + 50 * (5 * v4 - 150) + 772), this + 292, 250);
      else
        strncpyt(this + 292, (void *)(*((_DWORD *)this + 66) + 50 * (5 * v4 - 150) + 772), 256);
      (*(void (__thiscall **)(char *, char *, int, int))(*(_DWORD *)this + 44))(this, this + 292, v8, 1);
      this[292] = 0;
      v10 = -2087562904;
      v11 = 121;
      do
        v10 ^= *(_DWORD *)&aBg06Bm2[4 * v11-- - 419252];
      while ( v11 );
      this[v10 + 1847488] = 0;
    }
    else if ( v5[3049] && v8 )
    {
      if ( *(_BYTE *)(v8 + 108) )
      {
        (*(void (__thiscall **)(_DWORD *, _DWORD, int))(*v5 + 456))(v5, *(_DWORD *)(v8 + 24), v9);
      }
      else
      {
        v27 = 9449439;
        (*(void (__cdecl **)(_DWORD, int, int, int))(**((_DWORD **)this + 137) + 388))(
          *((_DWORD *)this + 137),
          400,
          4,
          9449439 - (_DWORD)&loc_45551B);
      }
    }
    v2 = a2;
    a2[22] = 0;
  }
  v12 = v2[89];
  v13 = strlen(this + 292);
  v27 = (int)v2 + 99;
  if ( v12 > 0 )
  {
    do
    {
      v14 = *(_BYTE *)v27;
      if ( *(_BYTE *)v27 == 13 )
      {
        if ( v13 )
        {
          v15 = 0;
          for ( i = (_DWORD *)(&loc_424EB7 + 5); (unsigned int)i < 0x425094; ++i )
            v15 -= *i;
          (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD))(*(_DWORD *)&this[v15 + 2129061961] + 44))(
            &this[v15 + 2129061961],
            this + 292,
            *(_DWORD *)(*((_DWORD *)this + 137) + 4 * *(_DWORD *)(*((_DWORD *)this + 137) + 112472) + 2180),
            0);
          v2 = a2;
          this[292] = 0;
          v13 = 0;
        }
        this[580] = 0;
      }
      else if ( v14 == 8 )
      {
        if ( v13 )
          this[--v13 + 292] = 0;
        if ( !this[292] )
          this[580] = 0;
      }
      else if ( v14 == 127 )
      {
        this[580] = 0;
        this[292] = 0;
      }
      else if ( v13 < 0xFF && byte_4A9878[v14] != -1 && (this[580] || !*(_BYTE *)(*((_DWORD *)this + 66) + 5972)) )
      {
        this[v13++ + 292] = v14;
        this[v13 + 292] = 0;
        if ( (*(unsigned __int8 (__thiscall **)(char *))(*(_DWORD *)this + 32))(this) )
          v13 = strlen(this + 292);
      }
      v17 = v2[89] - 1;
      v18 = v27 + 1;
      v19 = v2[89] == 1;
      v2[89] = v17;
      v27 = v18;
    }
    while ( v17 >= 0 && !v19 );
  }
  v20 = (char *)*((_DWORD *)this + 66);
  if ( v20[8058] )
  {
    v21 = *((_DWORD *)this + 137);
    if ( *(_DWORD *)(v21 + 1416) == 5 )
    {
      v20 = (char *)*((_DWORD *)this + 67);
      if ( (unsigned int)(*(_DWORD *)(v21 + 23104) - (_DWORD)v20) >= 0x7D0 )
      {
        if ( !v20 )
        {
          v25[0] = 0;
          v25[1] = 0;
          v26 = 0;
          v28 = 0;
          v22 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)this + 137) + 117716) + 1204);
          if ( (*(unsigned __int8 (__thiscall **)(int, int *, int))(*(_DWORD *)v22 + 28))(
                 v22,
                 v25,
                 9463329 - (_DWORD)&loc_458B69) )
          {
            sub_40CA40((unsigned int *)this + 139, (int)&savedregs, (_BYTE *)v25[2], v25[3]);
            sub_40CA40((unsigned int *)this + 139, (int)&savedregs, byte_4A7DB0, 1u);
            *((_DWORD *)this + 1) = *((_DWORD *)this + 139);
          }
          v28 = -1;
          sub_40C9D0((int)v25, (int)&savedregs, 0);
        }
        v20 = (char *)*((_DWORD *)this + 140);
        *((_DWORD *)this + 67) = *(_DWORD *)(*((_DWORD *)this + 137) + 23104);
        if ( v20 )
        {
          while ( 1 )
          {
            strncpyt(v24, *((void **)this + 1), 200);
            sub_40BCB0(v24, 13, 0);
            sub_40BCB0(v24, 10, 0);
            if ( v24[0] )
              (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this + 28))(
                this,
                v24,
                0,
                0,
                0,
                1);
            v20 = strchr(*((const char **)this + 1), 10);
            *((_DWORD *)this + 1) = v20;
            if ( !v20 )
              break;
            *((_DWORD *)this + 1) = v20 + 1;
            LOBYTE(v20) = v24[0];
            if ( v24[0] )
              return (char)v20;
          }
          v20 = (char *)*((_DWORD *)this + 139);
          *((_DWORD *)this + 1) = v20;
        }
      }
    }
  }
  return (char)v20;
}

//----- (00439A30) --------------------------------------------------------
int sub_439A30()
{
  int result; // eax
  _DWORD v1[43]; // [esp+4h] [ebp-ACh] BYREF

  result = dword_4A712C(v1);
  if ( result )
  {
    if ( result == 2 )
      result = v1[42] + v1[0];
    else
      result = v1[0];
  }
  return result;
}
// 4A712C: using guessed type int (__stdcall *dword_4A712C)(_DWORD);

//----- (00439F30) --------------------------------------------------------
unsigned __int8 __thiscall sub_439F30(int this, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v4; // ebx
  unsigned __int8 result; // al
  char v6[260]; // [esp+Ch] [ebp-104h] BYREF

  sub_407960(v6, (int)byte_4A7DB0, a3);
  v4 = sub_407A40(v6);
  if ( !*(_BYTE *)(this + 113572)
    || (sub_407960(a2, *(_DWORD *)(this + 23100) + 269, (_BYTE *)(this + 113572)),
        sub_407960(a2, (int)a2, v4),
        (result = sub_408AA0(a2)) == 0) )
  {
    sub_407960(a2, *(_DWORD *)(this + 23100) + 269, v4);
    result = sub_408AA0(a2);
    if ( !result )
    {
      sub_4079D0(a2, (int)v6);
      result = sub_408AA0(a2);
      if ( !result )
        result = (unsigned __int8)sub_4079D0(a2, (int)v4);
    }
  }
  return result;
}

//----- (00439FF0) --------------------------------------------------------
unsigned int __thiscall sub_439FF0(unsigned int *this, int a2, unsigned int a3)
{
  unsigned int v3; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int result; // eax
  unsigned int v8; // edx
  char v9; // cl
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // ebx
  char *v13; // edi
  int v14; // eax
  int v15; // eax
  unsigned int v16; // edx
  unsigned int v17; // edx
  bool v18; // [esp+8h] [ebp-210h]
  char v19[524]; // [esp+Ch] [ebp-20Ch] BYREF

  v3 = a3;
  v5 = this[346];
  v6 = this[177];
  this[346] = a3 + v5;
  if ( v6 )
  {
    result = sub_4368E0(this + 176, (unsigned int)v19, (int *)a2, a3);
    if ( result )
    {
      v8 = *this;
      ++this[230];
      result = (*(int (__thiscall **)(unsigned int *, char *, unsigned int, _DWORD))(v8 + 8))(this, v19, result, 0);
    }
  }
  else if ( this[24] >= 0x80000000 )
  {
    v17 = *this;
    ++this[230];
    result = (*(int (__thiscall **)(unsigned int *, int, unsigned int, _DWORD))(v17 + 8))(this, a2, a3, 0);
  }
  else
  {
    v9 = *(_BYTE *)(a2 + 1);
    v18 = *(_BYTE *)a2 != 0;
    if ( v9 != 2 && v9 != 1 && this[178] != 1 || *(_BYTE *)a2 )
    {
      v10 = a2 - v18 + 2;
      v11 = this[24];
      if ( (int)(v18 + a3 + 1) / 4 > 0 )
      {
        v12 = (int)(v18 + a3 + 1) / 4;
        v13 = (char *)this - v10 + 104;
        do
        {
          v14 = *(_DWORD *)&v13[v10];
          v10 += 4;
          v15 = v11 ^ v14;
          v11 = *(_DWORD *)(v10 - 4);
          --v12;
          *(_DWORD *)(v10 - 4) = v11 ^ v15;
        }
        while ( v12 );
      }
      v3 = a3;
    }
    v16 = *this;
    ++this[230];
    result = (*(int (__thiscall **)(unsigned int *, int, unsigned int, _DWORD))(v16 + 8))(this, a2, v3, 0);
  }
  return result;
}

//----- (0043A140) --------------------------------------------------------
char __thiscall sub_43A140(_DWORD *this, char *Buf2, void *a3)
{
  int v4; // ebx
  int v6; // [esp+10h] [ebp-4h]

  v4 = 0;
  v6 = 0;
  if ( (int)this[3] <= 0 )
    return 0;
  while ( _memicmp((const void *)(v4 + this[1]), Buf2, *(_DWORD *)(v4 + this[1] + 32))
       || _memicmp(&Buf2[*(_DWORD *)(v4 + this[1] + 32)], a3, strlen((const char *)a3)) )
  {
    v4 += 36;
    if ( ++v6 >= this[3] )
      return 0;
  }
  return 1;
}

//----- (0043A1D0) --------------------------------------------------------
int __thiscall sub_43A1D0(_DWORD *this, int a2)
{
  int v2; // edx
  int v3; // eax
  int result; // eax

  v2 = a2;
  this[23] = a2;
  if ( a2 == 8 )
  {
    v2 = 0;
  }
  else
  {
    v3 = *(_DWORD *)(this[3] + 1308 * a2 + 13812);
    this[20] = v3;
    this[17] = 1000 * v3;
  }
  result = this[3] + 1308 * v2 + 12508;
  this[124] = result;
  this[147] = result;
  this[159] = result;
  this[214] = result;
  this[115] = result;
  return result;
}

//----- (0043A250) --------------------------------------------------------
int __thiscall sub_43A250(_DWORD *this, _DWORD *a2, __int16 a3, int a4)
{
  int v5; // edi
  int v6; // eax
  int v7; // ecx

  v5 = (*(int (__thiscall **)(_DWORD *))(*this + 64))(this);
  v6 = (__int16)(v5 - a3);
  if ( v6 < -this[3110] && this[3110] || v6 > this[2956] )
    ++this[29965];
  else
    ++this[29430];
  if ( v6 < 0 || v6 > 4000 )
  {
    v6 = this[340] / 10 / 2;
    if ( v6 >= 15 )
      v6 = 15;
  }
  v7 = v6 + this[30018];
  this[30017] = v6;
  this[30018] = v7;
  *a2 = v6 + a4;
  return v5 - (v6 + a4);
}

//----- (0043A520) --------------------------------------------------------
unsigned int __thiscall sub_43A520(_DWORD *this, int a2)
{
  int v2; // ebp
  _DWORD *v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v9; // [esp+10h] [ebp-14h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]
  unsigned int v13; // [esp+28h] [ebp+4h]

  v10 = BYTE2(a2);
  v12 = (unsigned __int8)a2;
  v11 = BYTE1(a2);
  v9 = 0;
  v2 = 100000;
  v13 = 0;
  v3 = this + 13332;
  do
  {
    v4 = abs32((unsigned __int8)BYTE2(*v3) - v10);
    v5 = abs32((unsigned __int8)BYTE1(*v3) - v11);
    v6 = abs32((unsigned __int8)*v3 - v12);
    v7 = v4 * v4 + v5 * v5 + v6 * v6;
    if ( v7 < v2 )
    {
      v2 = v7;
      v9 = v13;
    }
    ++v3;
    ++v13;
  }
  while ( v13 < 0x100 );
  return v9;
}

//----- (0043A5E0) --------------------------------------------------------
void __thiscall sub_43A5E0(_DWORD **this, int a2)
{
  int v2; // edi
  int v4; // eax
  _DWORD *v5; // edx
  int v6; // ecx
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // [esp+Ch] [ebp-4h]

  v2 = a2;
  if ( a2 >= 0 && a2 <= 9999 && (int)this[192] <= 0 )
  {
    if ( this[23] != (_DWORD *)8 )
    {
      if ( ((unsigned __int8 (__thiscall *)(_DWORD **, int))(*this)[28])(this, 1) )
        return;
      if ( this[23] != (_DWORD *)8 )
      {
        if ( !((unsigned __int8 (__thiscall *)(_DWORD **))(*this)[22])(this) )
        {
          (*(void (__cdecl **)(_DWORD *, int, int, int))(*this[3] + 388))(
            this[3],
            300,
            4,
            9561169 - ((_DWORD)&loc_47092F + 2));
          return;
        }
        if ( this[23] != (_DWORD *)8 )
        {
          v2 = a2 % this[3][2829];
          a2 = v2;
        }
      }
    }
    v4 = (*(int (__thiscall **)(_DWORD *, int))(*this[3] + 152))(this[3], v2);
    if ( (_DWORD *)v4 == this[22] )
    {
      (*(void (__cdecl **)(_DWORD *, int, int, int))(*this[3] + 388))(
        this[3],
        300,
        4,
        9563772 - ((_DWORD)&loc_47137C + 4));
    }
    else
    {
      v5 = this[3];
      v11 = 0;
      v6 = v5[1569];
      if ( v6 > 0 )
      {
        v7 = v5 + 545;
        do
        {
          if ( *(_DWORD *)(*v7 + 88) == v4 )
            ++v11;
          ++v7;
          --v6;
        }
        while ( v6 );
        v2 = a2;
      }
      v8 = v5[2933];
      if ( !v8 )
        v8 = v5[2941];
      if ( v11 < v8 )
      {
        this[126] = (_DWORD *)200;
        this[164] = (_DWORD *)200;
        v9 = 7596704;
        v10 = 225;
        do
          v9 ^= dword_4A71BC[v10-- + 3244];
        while ( v10 );
        (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)((char *)this + v9 + 3224340) + 200))(
          *(_DWORD **)((char *)this + v9 + 3224340),
          v2);
      }
      else
      {
        (*(void (__cdecl **)(_DWORD *, int, int, int))(*this[3] + 388))(
          this[3],
          300,
          4,
          9567540 - ((_DWORD)&loc_472243 + 5));
      }
    }
  }
}
// 4A71BC: using guessed type int dword_4A71BC[];

//----- (0043A780) --------------------------------------------------------
int __thiscall sub_43A780(_DWORD *this, int a2)
{
  _DWORD *v3; // ecx
  int result; // eax
  int v5; // eax
  _DWORD *v6; // ebx

  v3 = (_DWORD *)this[542];
  if ( v3[23] == 8 )
    goto LABEL_5;
  if ( !(*(unsigned __int8 (__thiscall **)(_DWORD *))(*v3 + 88))(v3) )
    return (*(int (__cdecl **)(_DWORD *, int, int, int))(*this + 388))(
             this,
             400,
             4,
             9573340 - ((_DWORD)&loc_47388D + 3));
  result = (*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)this[542] + 112))(this[542], 1);
  if ( !(_BYTE)result )
  {
LABEL_5:
    (*(void (__thiscall **)(_DWORD *, int))(*this + 436))(this, 1);
    (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*this + 188))(this, a2, 0);
    v5 = 0;
    v6 = (_DWORD *)((char *)&loc_44EDC0 + 4);
    do
      v5 -= *v6++;
    while ( v6 < &off_44F154 );
    result = v5 + 974399209;
    *(_DWORD *)(*(_DWORD *)((char *)this + result + 440488016) + 516) = 200;
  }
  return result;
}
// 44F154: using guessed type int (__stdcall **off_44F154)(int, int);

//----- (0043A830) --------------------------------------------------------
void __thiscall sub_43A830(_DWORD *this, int a2)
{
  int v3; // ecx
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  int *v7; // eax
  int v8; // ecx
  int v9; // edx
  char Buffer[64]; // [esp+8h] [ebp-4Ch] BYREF
  int v11; // [esp+50h] [ebp-4h]
  int savedregs; // [esp+54h] [ebp+0h] BYREF

  if ( this[14] != a2 )
  {
    v3 = this[81];
    if ( v3 )
      (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 36))(v3, 1);
    this[81] = 0;
    v4 = 0;
    v5 = (_DWORD *)(&loc_422656 + 2);
    do
      v4 -= *v5++;
    while ( v5 < (_DWORD *)((char *)&loc_422879 + 3) );
    *(_DWORD *)((char *)this + v4 - 1549829517) = a2;
    sprintf_0(Buffer, "bong%d.wa2", a2);
    v6 = sub_40B720((int)&savedregs, 0x168u);
    v11 = 0;
    if ( v6 )
      v7 = (int *)sub_406230(v6, (int)this, Buffer, 1u, 0);
    else
      v7 = 0;
    v8 = this[15];
    this[81] = v7;
    v9 = *v7;
    v11 = -1;
    (*(void (__thiscall **)(int *, int, _DWORD))(v9 + 32))(v7, v8, 0);
  }
}

//----- (0043A910) --------------------------------------------------------
int __thiscall sub_43A910(char *this, char a2)
{
  int v3; // eax
  int v4; // ecx

  v3 = 674490335;
  v4 = 137;
  do
    v3 ^= *(_DWORD *)&aDirectdrawRepa[4 * v4-- - 547828];
  while ( v4 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v3 + 443743344] + 16))(
           &this[v3 + 443743344],
           &a2,
           1,
           1);
}

//----- (0043A950) --------------------------------------------------------
char __thiscall sub_43A950(_DWORD *this, int a2)
{
  int v2; // edx
  int v3; // ebx
  int v4; // ebp
  int v5; // edi
  int v6; // edx
  _DWORD *v7; // esi
  __int64 v8; // rax
  __int64 v9; // rax
  int i; // [esp+14h] [ebp+4h]

  v2 = this[3];
  if ( !*(_DWORD *)(v2 + 11352) )
    return 1;
  v3 = *(_DWORD *)(v2 + 6276);
  v4 = 0;
  v5 = 18000 * a2;
  if ( v3 <= 0 )
    return 1;
  v6 = v2 + 2180;
  for ( i = v6; ; i += 4 )
  {
    v7 = *(_DWORD **)v6;
    if ( *(_DWORD *)(*(_DWORD *)v6 + 92) != 8 && !v7[19] && (int)v7[16] <= 0 && v7[22] != this[22] )
    {
      v8 = v7[1] - this[1];
      if ( (int)((HIDWORD(v8) ^ v8) - HIDWORD(v8)) < v5 )
      {
        v9 = v7[2] - this[2];
        if ( (int)((HIDWORD(v9) ^ v9) - HIDWORD(v9)) < v5 )
          break;
      }
    }
    ++v4;
    v6 = i + 4;
    if ( v4 >= v3 )
      return 1;
  }
  return 0;
}

//----- (0043AA00) --------------------------------------------------------
int __thiscall sub_43AA00(_DWORD *this)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // eax
  int v8; // ecx
  char v10[764]; // [esp+Ch] [ebp-300h] BYREF
  __int16 v11; // [esp+308h] [ebp-4h]

  v2 = this[5775];
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  v10[0] = 23;
  strncpyt(&v10[1], (void *)(v2 + 8404), 32);
  strncpyt(&v10[33], (void *)(this[5775] + 8468), 64);
  strncpyt(&v10[97], (void *)(this[5775] + 8532), 32);
  strncpyt(&v10[129], (void *)(this[5775] + 8596), 24);
  v3 = this[5775];
  v10[153] = *(_BYTE *)(v3 + 8667) != 0 ? 77 : 70;
  v4 = *(_DWORD *)(v3 + 8660);
  v10[154] = v4;
  if ( v4 > 255 )
    v10[154] = -1;
  v5 = 0;
  v6 = &loc_423724;
  do
    v5 -= *v6++;
  while ( (unsigned int)v6 < 0x423B00 );
  v10[155] = *(_BYTE *)(*(_DWORD *)((char *)this + v5 - 161073130) + 8664);
  v7 = this[5775];
  v10[156] = *(_BYTE *)(v7 + 8665);
  v8 = this[30127];
  v10[157] = *(_BYTE *)(v7 + 8666);
  (*(void (__thiscall **)(int, char *))(*(_DWORD *)v8 + 16))(v8, v10);
  return (*(int (__thiscall **)(_DWORD *, char *, int, int))(*this + 16))(this, v10, 766, 1);
}

//----- (0043AB40) --------------------------------------------------------
int __thiscall sub_43AB40(_DWORD *this, int a2, int a3, int a4, int a5, int a6, char a7, int a8, int a9)
{
  signed int v10; // ecx
  signed int v11; // eax
  __int64 v13; // rax
  double v14; // st7
  int v15; // edi
  int v16; // edi
  _DWORD *v17; // eax
  int v18; // ecx
  int v19; // ebx
  unsigned int v20; // ecx
  unsigned int v21; // edx
  int v22; // ebx
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  _DWORD *i; // ebx
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+24h] [ebp+10h]

  v10 = abs32(a3 - this[2]);
  v11 = abs32(a2 - this[1]);
  if ( v11 >= v10 )
    v10 = v11;
  LODWORD(v13) = v10 / 1000;
  if ( v10 / 1000 < a4 )
  {
    v14 = (double)((this[2] - a3) / 1000);
    v13 = (__int64)sqrt((double)((this[1] - a2) / 1000) * (double)((this[1] - a2) / 1000) + v14 * v14);
    v29 = v13;
    if ( (int)v13 < a4 && this[23] != 8 )
    {
      v15 = a4 - v13;
      v30 = a5 / a4;
      v16 = a5 / a4 * v15;
      v17 = *(_DWORD **)(this[3] + 4 * a6 + 113620);
      if ( this[6] != a6 )
      {
        if ( v17 )
        {
          if ( !v17[19] )
          {
            v18 = (__int64)sqrt(
                             (double)((v17[1] - a2) / 1000) * (double)((v17[1] - a2) / 1000)
                           + (double)((v17[2] - a3) / 1000) * (double)((v17[2] - a3) / 1000));
            if ( v18 < a4 )
            {
              v16 += v30 * (a4 - v18) / -2;
              if ( v16 < 0 )
                v16 = 0;
            }
          }
        }
      }
      if ( a7 )
      {
        if ( a5 )
        {
          if ( this[6] != a6 )
          {
            v19 = *(_DWORD *)(this[3] + 120528);
            if ( !v19
              || (v20 = this[1], v20 >= 0xFA0000)
              || (v21 = this[2], v21 >= 0xFA0000)
              || *(unsigned __int8 *)((int)v20 / 16000 + (((int)v21 / 16000) << 10) + v19) != 171 )
            {
              v22 = this[189];
              v23 = v16 * *(_DWORD *)(this[3] + 11176) / a5;
              if ( v22 + this[190] >= v23 )
                v23 = v22 + this[190];
              v24 = dword_4C1AE4 - v23;
              v25 = v23 - (dword_4C1AE4 - v23);
              dword_4C1AE4 = v24;
              this[190] = v24;
              this[189] = v25;
            }
          }
        }
      }
      if ( v16 > 0 )
        (*(void (__thiscall **)(_DWORD *, int, int, int, int))(*this + 44))(this, v16, a6, a8, a9);
      v26 = 0;
      for ( i = (_DWORD *)(&loc_426113 + 1); (unsigned int)i < 0x4264DC; ++i )
        v26 -= *i;
      *(_DWORD *)((char *)this + v26 - 529431759) = *(_DWORD *)(this[3] + 12076);
      LODWORD(v13) = v29;
    }
  }
  return v13;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0043AE70) --------------------------------------------------------
__int16 __thiscall sub_43AE70(int this)
{
  char v2; // al
  unsigned int *v3; // ecx
  int v4; // edx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  unsigned int v8; // eax
  __int16 v9; // di
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  int v13; // ebp
  char v14; // bl
  int v15; // edi
  int v16; // eax
  int v17; // ecx
  int v18; // ebx
  __int16 v19; // dx
  int v20; // ebp
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  unsigned int v25; // ecx
  int v26; // ecx
  int v28; // [esp+68h] [ebp-8h]
  __int16 v29; // [esp+6Ch] [ebp-4h]

  v2 = *(_BYTE *)(this + 128);
  *(_DWORD *)(this + 132) = 0;
  v3 = *(unsigned int **)(this + 12);
  v4 = *(_DWORD *)(this + 4);
  if ( v2 )
  {
    v5 = *(_DWORD *)(this + 8);
    *(_DWORD *)(this + 156) = 50;
    v6 = *v3;
    (*(void (__stdcall **)(_DWORD, int, int, _DWORD, _DWORD))(*v3 + 260))(*(_DWORD *)(v3[30019] + 208), v4, v5, 0, 0);
  }
  else
  {
    v7 = *(_DWORD *)(this + 8);
    *(_DWORD *)(this + 156) = 132;
    v6 = *v3;
    (*(void (__stdcall **)(_DWORD, int, int, _DWORD, _DWORD))(*v3 + 260))(*(_DWORD *)(v3[30019] + 136), v4, v7, 0, 0);
  }
  LOWORD(v6) = *(_WORD *)(this + 167);
  v8 = v6;
  v9 = v6 & 0x1F;
  v10 = (v8 >> 5) & 3;
  v11 = *(_DWORD *)(this + 12);
  v12 = *(_DWORD *)(v11 + 11140);
  v13 = *(_DWORD *)(v11 + 11716) * ((v9 != 8 ? 0 : 4) + v10 + 1);
  if ( v9 == 8 )
    v12 += v10 * v10 * v12;
  v14 = *(_BYTE *)(this + 128);
  if ( v14 )
    v12 = *(_DWORD *)(v11 + 11808) * (v12 / 1000);
  if ( *(_BYTE *)(this + 129) )
    v12 = *(_DWORD *)(v11 + 11804) * (v12 / 1000);
  HIWORD(v15) = HIWORD(*(_DWORD *)(this + 180));
  LOWORD(v15) = *(_WORD *)(this + 167);
  v16 = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD, int, int, _DWORD, char, int, _DWORD))(**(_DWORD **)(v11 + 2168)
                                                                                           + 92))(
          *(_DWORD *)(v11 + 2168),
          *(_DWORD *)(this + 4),
          *(_DWORD *)(this + 8),
          v13,
          v12,
          *(_DWORD *)(this + 152),
          v14,
          v15,
          *(_DWORD *)(this + 180));
  if ( v16 < 2048 )
  {
    LOWORD(v16) = *(_WORD *)(this + 167);
    v17 = ((unsigned int)v16 >> 10) & 0x1F;
    if ( *(_DWORD *)(*(_DWORD *)(this + 12) + 7632) + v17 + *(_DWORD *)(*(_DWORD *)(this + 12) + 7636) < 512 )
    {
      v18 = 0;
      v19 = ((v16 & 0x80u) != 0) + 1;
      v16 = ((unsigned int)v16 >> 3) & 0x60;
      v29 = v16 | v19 & 0xFF9F;
      if ( v17 > 0 )
      {
        v28 = 0;
        v20 = 1000000;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(this + 12) + 11212) )
          {
            v21 = 2836 * (*(_DWORD *)(this + 120) / 127773);
            v22 = 16807 * (*(_DWORD *)(this + 120) % 127773) - v21 + 123;
            if ( v22 <= 0 )
              v22 = 16807 * (*(_DWORD *)(this + 120) % 127773) - v21 - 2147483526;
            *(_DWORD *)(this + 120) = v22;
            v23 = v22 % 40000;
          }
          else
          {
            v23 = v28 / v17;
          }
          v24 = (*(int (__thiscall **)(_DWORD, __int16, _DWORD, _DWORD, int, int, int, _DWORD, _DWORD, int, _DWORD, _DWORD, _DWORD, int))(**(_DWORD **)(this + 12) + 248))(
                  *(_DWORD *)(this + 12),
                  v29,
                  *(_DWORD *)(this + 172),
                  *(_DWORD *)(this + 176),
                  dword_4AB050,
                  dword_4AB054,
                  v23,
                  *(_DWORD *)(*(_DWORD *)(this + 12) + 11116),
                  0,
                  -1,
                  *(_DWORD *)(this + 152),
                  *(_DWORD *)(this + 184),
                  0,
                  1);
          if ( v24 )
          {
            v26 = *(_DWORD *)(this + 180);
            *(_DWORD *)(v24 + 144) = 25;
            v25 = v20 + v26;
            *(_DWORD *)(v24 + 180) = v25;
          }
          LOWORD(v25) = *(_WORD *)(this + 167);
          ++v18;
          v17 = (v25 >> 10) & 0x1F;
          v20 += 100000;
          LOWORD(v16) = v28 - 25536;
          v28 += 40000;
        }
        while ( v18 < v17 );
      }
    }
  }
  return v16;
}
// 43B0F2: variable 'v25' is possibly undefined
// 4AB050: using guessed type int dword_4AB050;
// 4AB054: using guessed type int dword_4AB054;

//----- (0043B120) --------------------------------------------------------
int __thiscall sub_43B120(_DWORD *this, int a2, int a3)
{
  int v4; // ecx
  int v5; // ebx
  int v6; // edi
  int v7; // ebp
  int v8; // edi
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // ebp
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // edi
  int v23; // edx
  int v24; // ecx
  int v25; // edi
  int v26; // ecx
  _DWORD *v27; // ecx
  int v28; // eax
  long double v29; // st7
  double v30; // st6
  double v31; // st5
  int v32; // eax
  int v33; // eax
  int v34; // edx
  signed int v35; // ecx
  signed int v36; // eax
  int v37; // ebx
  __int64 v38; // rax
  int v39; // ecx
  int v40; // eax
  int v41; // ecx
  int v42; // ecx
  int v43; // eax
  int v44; // edx
  int v45; // ebx
  int v46; // ebx
  int v47; // eax
  long double v48; // st7
  double v49; // st6
  signed int v50; // ebx
  int v51; // ebp
  int result; // eax
  int v53; // ecx
  bool v54; // [esp+13h] [ebp-25h]
  int v55; // [esp+14h] [ebp-24h]
  int v56; // [esp+18h] [ebp-20h]
  int v57; // [esp+18h] [ebp-20h]
  int v58; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v59; // [esp+20h] [ebp-18h]
  int v60; // [esp+24h] [ebp-14h]
  int v61; // [esp+28h] [ebp-10h]
  int v62; // [esp+2Ch] [ebp-Ch]
  int v63; // [esp+34h] [ebp-4h]
  int v64; // [esp+3Ch] [ebp+4h]
  int v65; // [esp+40h] [ebp+8h]
  int v66; // [esp+40h] [ebp+8h]
  int v67; // [esp+40h] [ebp+8h]

  v4 = this[159];
  if ( *(_DWORD *)(this[160] + v4) )
  {
    v6 = this[157];
    v5 = *(_DWORD *)(this[156] + v4);
    if ( v6 + this[158] <= v5 )
      v5 = v6 + this[158];
  }
  else
  {
    v5 = *(_DWORD *)(v4 + this[155]);
  }
  v7 = this[3];
  v8 = *(_DWORD *)(v7 + 23104) - this[217];
  v62 = v8;
  v59 = (_DWORD *)(v7 + 1308 * this[23] + 12508);
  if ( this[151] + this[152] <= 0 )
  {
    if ( v8 < 15 )
    {
      v9 = *(_DWORD *)(v7 + 1308 * this[23] + 13224);
      if ( !v9 )
        v9 = v5 / 2;
      v5 = v9;
    }
  }
  else
  {
    v5 = 33;
  }
  if ( *(_BYTE *)(a3 + 5) )
  {
    v10 = v5;
  }
  else if ( *(_BYTE *)(a3 + 4) )
  {
    v10 = -v5;
  }
  else
  {
    v11 = *(_DWORD *)(a3 + 832) / 10922;
    if ( v11 >= -2 )
    {
      if ( v11 > 2 )
        v11 = 2;
    }
    else
    {
      v11 = -2;
    }
    v10 = v5 * v11 / 2;
  }
  v12 = a2 * v10;
  v60 = v10;
  if ( v8 < 15 )
  {
    if ( v12 <= 1000 )
    {
      if ( v12 < -1000 )
        v12 = -1000;
    }
    else
    {
      v12 = 1000;
    }
  }
  this[15] = (v12 + this[15] + 40000) % 40000;
  if ( !v10 )
    this[217] = *(_DWORD *)(v7 + 23104);
  v13 = this[107];
  v14 = this[161];
  if ( v13 > v14 )
  {
    v15 = v13 - 100 * a2;
    this[107] = v15;
    if ( v15 >= v14 )
      goto LABEL_33;
    goto LABEL_32;
  }
  if ( v13 < v14 )
  {
    v16 = v13 + 100 * a2;
    this[107] = v16;
    if ( v16 > v14 )
    {
LABEL_32:
      this[107] = v14;
      goto LABEL_33;
    }
  }
LABEL_33:
  v17 = 0;
  v58 = 0;
  if ( this[151] + this[152] > 0 )
    goto LABEL_41;
  if ( *(_BYTE *)(a3 + 7) || (v18 = *(_DWORD *)(a3 + 836), v18 >= 10922) )
  {
    v17 = -1;
    goto LABEL_40;
  }
  if ( *(_BYTE *)(a3 + 6) || v18 <= -10922 )
  {
    v17 = 1;
LABEL_40:
    v58 = v17;
  }
LABEL_41:
  v19 = (*(int (__thiscall **)(_DWORD *))(*this + 80))(this);
  v20 = this[214];
  v61 = v19;
  if ( *(_DWORD *)(this[215] + v20) )
  {
    v21 = this[212] + this[213];
    v56 = *(_DWORD *)(this[211] + v20);
    if ( v21 > v56 )
      goto LABEL_45;
  }
  else
  {
    v21 = *(_DWORD *)(v20 + this[210]);
  }
  v56 = v21;
LABEL_45:
  v22 = 0;
  v63 = 0;
  v55 = 0;
  if ( !v17 && this[103] + this[104] <= 0 || (int)this[7] >= 0 )
  {
    v23 = *this;
    this[161] = 0;
    this[204] = 0;
    (*(void (__thiscall **)(_DWORD *, _DWORD))(v23 + 120))(this, 0);
    goto LABEL_96;
  }
  v24 = this[147];
  if ( *(_DWORD *)(this[148] + v24) )
  {
    v25 = *(_DWORD *)(this[144] + v24);
    if ( this[145] + this[146] <= v25 )
      v25 = this[145] + this[146];
  }
  else
  {
    v25 = *(_DWORD *)(v24 + this[143]);
  }
  v26 = this[103] + this[104];
  v55 = v25;
  v54 = v26 > 0;
  if ( v26 > 0 )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*this + 120))(this, 3);
    v17 = 1;
    v58 = 1;
    this[103] += this[104] - dword_4C1AE4 - a2;
    this[104] = dword_4C1AE4;
    v25 = *(_DWORD *)(this[3] + 11860);
    v55 = v25;
LABEL_60:
    v27 = v59;
    goto LABEL_61;
  }
  if ( !*(_BYTE *)(a3 + 8) || !v17 )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*this + 120))(this, 1);
    goto LABEL_60;
  }
  (*(void (__thiscall **)(_DWORD *, int))(*this + 120))(this, 2);
  v27 = v59;
  v28 = a2 * v59[80];
  if ( this[130] + this[131] > v28 )
  {
    this[130] += this[131] - dword_4C1AE4 - v28;
    this[131] = dword_4C1AE4;
    v25 = v59[83];
    v56 = v59[270];
    v55 = v25;
    this[128] = *(_DWORD *)(this[3] + 23104);
  }
LABEL_61:
  if ( v61 > 0 )
  {
    v25 -= v27[131];
    v55 = v25;
    if ( v25 < 1 )
    {
      v25 = 1;
      v55 = 1;
    }
  }
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 148))(this) )
  {
    v55 = *(_DWORD *)(this[3] + 11292) + v25;
    if ( v55 < 0 )
      v55 = 0;
  }
  v29 = (double)(this[15] / 1000) * dbl_4AC4B8;
  v30 = (double)v55;
  v31 = (double)v58;
  v22 = -(int)(__int64)(sin(v29) * v31 * v30);
  v63 = -(int)(__int64)(cos(v29) * v31 * v30);
  v32 = a2 * v63 + this[5];
  this[4] += a2 * v22;
  this[5] = v32;
  v33 = this[204] - a2;
  this[204] = v33;
  if ( v33 <= 0 )
  {
    v34 = this[3];
    this[204] = v33 + 8;
    if ( *(_BYTE *)(*(_DWORD *)(v34 + 23100) + 8049) )
    {
      if ( v54 )
        (*(void (__thiscall **)(_DWORD *))(*this + 124))(this);
      else
        (*(void (__thiscall **)(_DWORD *, int))(*this + 140))(this, v17);
    }
  }
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this[3] + 117716) + 164))(
         *(_DWORD *)(this[3] + 117716),
         this[23]) )
  {
    v65 = this[4];
    v35 = abs32(this[5]);
    v36 = abs32(v65);
    if ( v36 < v35 )
      v36 = v35;
    v37 = 5999 * v36 / 2000;
    if ( v37 > 5999 )
      v37 = 5999;
    if ( v62 > 80 )
    {
      if ( v60 < 0 )
      {
        this[161] = -v37;
        goto LABEL_96;
      }
      goto LABEL_91;
    }
    v38 = (__int64)(atan2((double)v65, (double)-this[5]) * dbl_4ADB78);
    if ( (int)v38 < 40000 )
      LODWORD(v38) = v38 + 40000;
    v39 = this[15] - v38 + (this[15] - (int)v38 < 0 ? 0x9C40 : 0);
    if ( v39 > 20000 )
      v39 -= 40000;
    if ( v39 > 10000 )
      v39 = 20000 - v39;
    if ( v39 < -10000 )
      v39 = -20000 - v39;
    v41 = 6 * v39 / 8;
    v40 = v41;
    if ( -v37 > v41 )
      v41 = -v37;
    if ( v37 < v41 )
    {
LABEL_91:
      this[161] = v37;
      goto LABEL_96;
    }
    if ( v40 < -v37 )
      v40 = -v37;
    this[161] = v40;
  }
  else
  {
    this[161] = 0;
  }
LABEL_96:
  if ( this[208] != v58 * v55 )
  {
    v42 = this[3];
    this[208] = v58 * v55;
    this[188] = *(_DWORD *)(v42 + 23104) - 1000000;
  }
  v43 = (*(int (__thiscall **)(_DWORD *, _DWORD, int))(*this + 4))(this, v59[259], a2);
  if ( this[103] + this[104] <= 0 )
  {
    v45 = v56;
  }
  else
  {
    v44 = this[3];
    v45 = v56;
    if ( *(_DWORD *)(v44 + 11424) >= v56 )
      v45 = *(_DWORD *)(v44 + 11424);
  }
  v46 = v43 * v59[160] + v45;
  v57 = v46;
  if ( v61 > 0 )
  {
    v46 -= v59[84];
    v57 = v46;
    if ( v46 < 10 )
    {
      v46 = 10;
      v57 = 10;
    }
  }
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 148))(this) )
  {
    v57 = *(_DWORD *)(this[3] + 11332) + v46;
    if ( v57 < 0 )
      v57 = 0;
  }
  v47 = this[218];
  if ( v47 <= 0 && this[7] == -1 )
  {
    v66 = this[4];
    v64 = this[5];
    v48 = atan2((double)v66, (double)v64);
    v49 = (double)v57;
    v50 = abs32((__int64)(sin(v48) * v49));
    v51 = -v50;
    result = abs32((__int64)(cos(v48) * v49));
    if ( v66 < -v50 )
      this[4] = v51;
    if ( this[4] > v50 )
      this[4] = v50;
    v67 = -result;
    if ( v64 < -result )
      this[5] = -result;
    if ( this[5] > result )
      this[5] = result;
    v53 = this[5];
    this[141] = 10 * v22 + this[4];
    this[142] = 10 * v63 + v53;
    if ( this[141] < v51 )
      this[141] = v51;
    if ( this[141] > v50 )
      this[141] = v50;
    if ( this[142] < v67 )
      this[142] = v67;
    if ( this[142] > result )
      this[142] = result;
  }
  else
  {
    this[218] = v47 - a2;
    result = 10 * v63 + this[5];
    this[141] = 10 * v22 + this[4];
    this[142] = result;
  }
  return result;
}
// 4AC4B8: using guessed type double dbl_4AC4B8;
// 4ADB78: using guessed type double dbl_4ADB78;
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0043B8F0) --------------------------------------------------------
char __thiscall sub_43B8F0(char *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int v6; // eax
  int v7; // eax
  int v8; // edx
  char *v9; // ecx

  LOBYTE(v6) = this[28245];
  if ( (_BYTE)v6 && *((_DWORD *)this + 30021) < 0xAu )
  {
    v7 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 64))(this);
    v8 = *((_DWORD *)this + 30021);
    if ( !v8 )
      *(_DWORD *)(this + 119973) = v7;
    v9 = &this[8 * v8 + 119977 + v8];
    *((_DWORD *)this + 30021) = v8 + 1;
    *(_WORD *)v9 = a2;
    *((_WORD *)v9 + 1) = a3;
    *((_WORD *)v9 + 2) = a4;
    *((_WORD *)v9 + 3) = a5;
    v6 = v7 - *(_DWORD *)(this + 119973);
    if ( v6 >= 0 )
    {
      if ( v6 > 255 )
        LOBYTE(v6) = -1;
      this[8 * v8 + 119985 + v8] = v6;
    }
    else
    {
      LOBYTE(v6) = 0;
      this[8 * v8 + 119985 + v8] = 0;
    }
  }
  return v6;
}

//----- (0043B980) --------------------------------------------------------
int __thiscall sub_43B980(_DWORD *this)
{
  int v2; // esi
  int result; // eax
  _DWORD *v4; // edi

  v2 = 0;
  result = this[1875];
  if ( result > 0 )
  {
    v4 = this + 1571;
    do
    {
      (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v4 + 12))(*v4);
      result = this[1875];
      ++v2;
      ++v4;
    }
    while ( v2 < result );
  }
  return result;
}

//----- (0043B9B0) --------------------------------------------------------
char __thiscall sub_43B9B0(_DWORD *this)
{
  int v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  char v7[128]; // [esp+8h] [ebp-C8h] BYREF
  char Buffer[64]; // [esp+88h] [ebp-48h] BYREF
  int v9; // [esp+C8h] [ebp-8h]
  int v10; // [esp+CCh] [ebp-4h]

  v2 = this[542];
  if ( v2 && *(_DWORD *)(v2 + 92) != 8 )
  {
    v3 = this[5776] - this[1911];
    if ( v3 < 1500 )
      return v3;
    if ( this[3108] )
    {
      LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *, char *, _DWORD, _DWORD, _DWORD, int))(this[27905] + 28))(
                     this + 27905,
                     aScreenshotFunc,
                     0,
                     0,
                     0,
                     1);
      return v3;
    }
  }
  v4 = 0;
  v9 = 9717259;
  v10 = 9717664;
  while ( 1 )
  {
    sub_408840((char *)(v9 - (_DWORD)&loc_496A53));
    sprintf_0(Buffer, (const char *const)(v10 - ((_DWORD)&loc_496C06 + 2)), ++dword_4C1AC8);
    LOBYTE(v3) = sub_408AA0(Buffer);
    if ( !(_BYTE)v3 )
      break;
    if ( ++v4 >= 1000 )
      return v3;
  }
  v5 = this[29429];
  this[1911] = this[5776];
  (*(void (__thiscall **)(int, char *))(*(_DWORD *)v5 + 80))(v5, Buffer);
  v10 = 9719820;
  sprintf_0(v7, (const char *const)(9719820 - (_DWORD)&loc_49748C), Buffer);
  LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *, char *, _DWORD, _DWORD, _DWORD, int))(this[27905] + 28))(
                 this + 27905,
                 v7,
                 0,
                 0,
                 0,
                 1);
  return v3;
}
// 4C1AC8: using guessed type int dword_4C1AC8;

//----- (0043BAD0) --------------------------------------------------------
int __thiscall sub_43BAD0(void *this, int a2, int a3)
{
  return (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 384))(this, *(unsigned __int16 *)(a2 + 1));
}

//----- (0043BB80) --------------------------------------------------------
int __thiscall sub_43BB80(int this)
{
  unsigned __int8 **v2; // edi
  int v3; // ebx
  int v4; // edi
  unsigned __int8 **v5; // ebx
  int v6; // edi
  unsigned __int8 **v7; // ebx
  unsigned __int8 *v8; // eax
  int v9; // edx
  unsigned __int8 **v10; // edi
  int v11; // ebx
  int v13; // [esp+Ch] [ebp-4h] BYREF

  v2 = (unsigned __int8 **)(this + 117724);
  v13 = -1;
  sub_401A70(&v13, (unsigned __int8 *)(this + 117724), 32);
  v3 = 8;
  do
  {
    if ( *v2 )
      sub_401A70(&v13, *v2, 68);
    ++v2;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  if ( *(int *)(this + 113508) > 0 )
  {
    v5 = (unsigned __int8 **)(this + 112484);
    do
    {
      sub_401A70(&v13, *v5, 16);
      ++v4;
      ++v5;
    }
    while ( v4 < *(_DWORD *)(this + 113508) );
  }
  sub_401AF0(&v13, *(_DWORD *)(this + 120476));
  v6 = 0;
  if ( *(int *)(this + 7500) > 0 )
  {
    v7 = (unsigned __int8 **)(this + 6284);
    do
    {
      sub_401A70(&v13, *v7, 32);
      ++v6;
      ++v7;
    }
    while ( v6 < *(_DWORD *)(this + 7500) );
  }
  sub_401A70(&v13, *(unsigned __int8 **)(this + 22972), 8 * *(_DWORD *)(this + 22980));
  sub_401A70(&v13, *(unsigned __int8 **)(this + 119848), 8 * *(_DWORD *)(this + 119856));
  v8 = *(unsigned __int8 **)(this + 2168);
  if ( v8 )
    sub_401A70(&v13, v8, 888);
  sub_401A70(&v13, (unsigned __int8 *)(this + 113620), 4096);
  sub_401AF0(&v13, *(_DWORD *)(this + 7504));
  v9 = *(_DWORD *)(this + 7632);
  if ( v9 + *(_DWORD *)(this + 7636) > 0 )
  {
    v10 = (unsigned __int8 **)(this + 8692);
    v11 = v9 + *(_DWORD *)(this + 7636);
    do
    {
      sub_401A70(&v13, *v10++, 196);
      --v11;
    }
    while ( v11 );
  }
  sub_401AF0(&v13, *(_DWORD *)(this + 112476) + *(_DWORD *)(this + 112480));
  return v13;
}

//----- (0043BCF0) --------------------------------------------------------
char __thiscall sub_43BCF0(_DWORD *this, char *String2)
{
  int v3; // edi
  int i; // ebx
  int v6; // eax
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // edx
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v3 = 0;
  if ( (int)this[3] <= 0 )
    return 0;
  for ( i = 0; _strcmpi((const char *)(i + this[1]), String2); i += 36 )
  {
    if ( ++v3 >= this[3] )
      return 0;
  }
  v6 = 0;
  v7 = (_DWORD *)((char *)&loc_422C83 + 1);
  do
    v6 -= *v7++;
  while ( (unsigned int)v7 < 0x423064 );
  v8 = v6 + 1648413220;
  v9 = *(_DWORD *)((char *)this + v8 + 67980);
  v10 = (int)this + v8 + 67972;
  sub_46CAB0(*(_DWORD *)v10 + 36 * v3, (_BYTE *)(*(_DWORD *)v10 + 4 * (9 * v3 + 9)), 36 * v9 - 4 * (9 * v3 + 9));
  v11 = *(_DWORD *)(v10 + 8) - 1;
  *(_DWORD *)(v10 + 8) = v11;
  if ( v11 )
  {
    if ( *(_DWORD *)(v10 + 4) - v11 > 32 )
    {
      v12 = *(_DWORD *)(v10 + 4) - 16;
      *(_DWORD *)(v10 + 4) = v12;
      sub_40B780(36 * v12, (void **)v10, (int)&savedregs);
    }
  }
  return 1;
}

//----- (0043BDB0) --------------------------------------------------------
int __thiscall sub_43BDB0(char *this, __int16 a2, __int16 a3)
{
  int v4; // eax
  int v5; // ecx
  char v7; // [esp+4h] [ebp-8h] BYREF
  __int16 v8; // [esp+5h] [ebp-7h]
  __int16 v9; // [esp+7h] [ebp-5h]

  v7 = 28;
  v8 = a2;
  v9 = a3;
  v4 = -1068498808;
  v5 = 199;
  do
    v4 ^= *(_DWORD *)&aImageGetrgbUns[4 * v5-- - 439556];
  while ( v5 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v4 + 513960480] + 16))(
           &this[v4 + 513960480],
           &v7,
           5,
           1);
}

//----- (0043BE10) --------------------------------------------------------
char __thiscall sub_43BE10(_DWORD *this, int a2, int a3, int a4)
{
  int v4; // edi
  char result; // al
  __int64 v6; // rax
  int v7; // ecx
  int v8; // esi
  int v9; // ebx
  _DWORD *v10; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // esi
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  int v18; // eax
  int v19; // edx
  int v20; // ebx
  int v21; // ecx
  int v22; // edx
  int v23; // ebx
  unsigned int i; // esi
  _DWORD *v25; // ecx
  int v26; // eax
  bool v27; // al
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // ebx
  int v34; // ebx
  int v35; // edx
  int v36; // edx
  int v37; // eax
  int v38; // eax
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  _DWORD *v43; // ebx
  int v44; // edx
  int v45; // [esp+4h] [ebp-4Ch]
  int v46; // [esp+Ch] [ebp-44h]
  int v47; // [esp+14h] [ebp-3Ch] BYREF
  int v48; // [esp+18h] [ebp-38h]
  int v49; // [esp+1Ch] [ebp-34h]
  int v50; // [esp+20h] [ebp-30h]
  int v51; // [esp+28h] [ebp-28h]
  int v52; // [esp+30h] [ebp-20h]
  int v53; // [esp+34h] [ebp-1Ch] BYREF
  int v54; // [esp+38h] [ebp-18h]
  int v55; // [esp+3Ch] [ebp-14h]
  int v56; // [esp+40h] [ebp-10h]
  _DWORD *v57; // [esp+44h] [ebp-Ch]
  int v58; // [esp+48h] [ebp-8h]
  int v59; // [esp+4Ch] [ebp-4h]
  _DWORD *v60; // [esp+58h] [ebp+8h]
  int v61; // [esp+58h] [ebp+8h]
  int v62; // [esp+58h] [ebp+8h]
  char v63; // [esp+5Bh] [ebp+Bh]

  v4 = (int)this;
  v57 = this;
  if ( this[23] == 8 )
  {
    this[1] = 16000 * a3 + 8000;
    result = 25 * a4;
    this[2] = 16000 * a4 + 8000;
    return result;
  }
  v6 = *(int *)(this[3] + 6276);
  v58 = ((((BYTE4(v6) & 7) + (int)v6) >> 3 << 13) + 1024) / 96 + 256;
  if ( v58 > 1024 )
    v58 = 1024;
  v7 = a2;
  v59 = a2;
  v55 = a2;
  v56 = 1;
  while ( 1 )
  {
    if ( (v56 & 0x3F) != 0 )
    {
      v55 = v7;
    }
    else
    {
      v7 = v55;
      v59 = v55;
    }
    v8 = a3;
    if ( a3 <= 0 || (v9 = a4, a4 <= 0) )
    {
      v10 = *(_DWORD **)(v4 + 12);
      v60 = v10;
      v11 = v10[3114];
      if ( v11 )
      {
        v12 = 3 * (*(_DWORD *)(v4 + 88) % v11);
        v13 = v10[3 * (*(_DWORD *)(v4 + 88) % v11) + 3115];
        v14 = v10[v12 + 3116];
        v61 = v60[v12 + 3117];
        v15 = 16807 * (v7 % 127773) - 2836 * (v7 / 127773) + 123;
        if ( v15 <= 0 )
          v15 += 0x7FFFFFFF;
        v8 = v15 % (2 * v61 + 1) - v61 + v13;
        v16 = 16807 * (v15 % 127773) - 2836 * (v15 / 127773) + 123;
        if ( v16 <= 0 )
          v16 = 16807 * (v15 % 127773) - 2836 * (v15 / 127773) - 2147483526;
        v59 = v16;
        v9 = v16 % (2 * v61 + 1) - v61 + v14;
        if ( (byte_4C1A80 & 1) == 0 )
        {
          dword_4C1AA0 = 1;
          dword_4C1AA4 = 1;
          byte_4C1A80 |= 1u;
          dword_4C1AA8 = 1023;
          dword_4C1AAC = 1023;
          sub_46E3C5(nullsub_9);
        }
        v17 = dword_4C1AA0;
        if ( v8 < dword_4C1AA0 || (v17 = dword_4C1AA8, v8 > dword_4C1AA8) )
          v8 = v17;
        v18 = dword_4C1AA4;
        if ( v9 < dword_4C1AA4 || (v18 = dword_4C1AAC, v9 > dword_4C1AAC) )
          v9 = v18;
        v4 = (int)v57;
      }
      else
      {
        switch ( v10[2728] )
        {
          case 1:
          case 3:
            v28 = 16807 * (v7 % 127773) - 2836 * (v7 / 127773) + 123;
            if ( v28 <= 0 )
              v28 += 0x7FFFFFFF;
            v8 = v28 % 256 + 768 * (*(_DWORD *)(v4 + 88) & 1);
            v29 = 16807 * (v28 % 127773) - 2836 * (v28 / 127773) + 123;
            if ( v29 <= 0 )
              v29 = 16807 * (v28 % 127773) - 2836 * (v28 / 127773) - 2147483526;
            v59 = v29;
            v9 = v29 % 512 + 256;
            break;
          case 2:
          case 4:
            v30 = 16807 * (v7 % 127773) - 2836 * (v7 / 127773) + 123;
            if ( v30 <= 0 )
              v30 += 0x7FFFFFFF;
            v8 = v30 % 256 + 768 * (*(_DWORD *)(v4 + 88) & 1);
            v31 = 16807 * (v30 % 127773) - 2836 * (v30 / 127773) + 123;
            if ( v31 <= 0 )
              v31 = 16807 * (v30 % 127773) - 2836 * (v30 / 127773) - 2147483526;
            v32 = *(_DWORD *)(v4 + 88);
            v59 = v31;
            v9 = v31 % 256 + 768 * ((v32 / 2) & 1);
            break;
          default:
            v33 = v10[3042];
            if ( v58 > v33 )
              v58 = v33;
            if ( v58 <= 2 )
              v58 = 3;
            v34 = 16807 * (v7 % 127773) - 2836 * (v7 / 127773) + 123;
            if ( v34 <= 0 )
              v34 = 16807 * (v7 % 127773) - 2836 * (v7 / 127773) - 2147483526;
            v62 = (1024 - v58) / 2;
            v8 = v34 % (v58 - 2) + rand() % 20 + v62 - 9;
            v35 = 16807 * (v34 % 127773) - 2836 * (v34 / 127773) + 123;
            if ( v35 <= 0 )
              v35 = 16807 * (v34 % 127773) - 2836 * (v34 / 127773) - 2147483526;
            v59 = v35;
            v9 = v35 % (v58 - 2) + rand() % 20 + v62 - 9;
            break;
        }
      }
    }
    else
    {
      a3 = -1;
    }
    v63 = 0;
    v19 = dword_4AB05C;
    *(_DWORD *)(v4 + 4) = dword_4AB058 + 16000 * v8;
    *(_DWORD *)(v4 + 8) = v19 + 16000 * v9;
    v20 = *(_DWORD *)(v4 + 4) / 1000;
    v21 = *(_DWORD *)(v4 + 80);
    v51 = *(_DWORD *)(v4 + 8) / 1000;
    v45 = (v20 - v21) / 16;
    v46 = (v21 + v20) / 16 + 1;
    v22 = (v51 - v21) / 16;
    v52 = v22;
    v23 = (v21 + v51) / 16 + 1;
    if ( v22 >= v23 )
      break;
    do
    {
      for ( i = v45; (int)i < v46; v22 = v52 )
      {
        if ( i >= 0x400 || (unsigned int)v22 >= 0x400 )
        {
LABEL_69:
          v27 = 1;
          goto LABEL_70;
        }
        v25 = *(_DWORD **)(v4 + 12);
        v26 = v25[30132];
        if ( v26 )
        {
          v36 = v26 + (v22 << 10);
          v37 = *(unsigned __int8 *)(v36 + i);
          if ( *(_BYTE *)(v36 + i) )
          {
            if ( *(unsigned __int8 *)(v36 + i) <= 0xA9u )
              goto LABEL_69;
            if ( *(unsigned __int8 *)(v36 + i) >= 0xAAu && *(unsigned __int8 *)(v36 + i) <= 0xBFu
              || v37 == 220
              || v37 == 241 )
            {
LABEL_65:
              v27 = 0;
              goto LABEL_70;
            }
            switch ( v37 )
            {
              case 242:
                v27 = 0;
                break;
              case 254:
                v27 = 0;
                break;
              case 255:
                goto LABEL_65;
              case 252:
              case 253:
                v27 = (*(unsigned __int8 (__thiscall **)(_DWORD *, unsigned int, int, _DWORD))(*v25 + 464))(
                        v25,
                        i,
                        v52,
                        *(_DWORD *)(v4 + 88)) == 0;
                break;
              default:
                goto LABEL_69;
            }
          }
          else
          {
            v27 = 0;
          }
        }
        else
        {
          v27 = 0;
        }
LABEL_70:
        ++i;
        v63 |= v27;
      }
      v52 = ++v22;
    }
    while ( v22 < v23 );
    if ( !v63 )
      break;
    if ( ++v56 >= 1024 )
      break;
    v7 = v59;
  }
  v38 = sub_455280((_DWORD *)(v4 + 4), 1000);
  CVecCtrlMob::MoveContext::FlyContext::FlyContext(
    (CVecCtrlMob::MoveContext::FlyContext *)&v47,
    (SECPOINT *)((v38 - *(_DWORD *)(v4 + 80)) / 16),
    (TSecType<int> *)((v39 - *(_DWORD *)(v4 + 80)) / 16),
    (TSecType<long> *)((*(_DWORD *)(v4 + 80) + v38) / 16 + 1),
    (TSecType<long> *)((*(_DWORD *)(v4 + 80) + v39) / 16 + 1));
  v54 = v48;
  if ( v48 < v50 )
  {
    v40 = v49;
    v41 = v47;
    do
    {
      v53 = v41;
      if ( v41 < v40 )
      {
        do
        {
          sub_43C5D0((_DWORD *)v4, &v53, 1);
          v40 = v49;
          ++v53;
        }
        while ( v53 < v49 );
        v41 = v47;
      }
      ++v54;
    }
    while ( v54 < v50 );
  }
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 568) = 0;
  *(_DWORD *)(v4 + 564) = 0;
  v42 = 0;
  v43 = (_DWORD *)((char *)&loc_44EB73 + 1);
  do
    v42 -= *v43++;
  while ( v43 < (_DWORD *)((char *)&loc_44EC9F + 1) );
  *(_DWORD *)(v42 - 1170900923 + v4 + 3893036) = 48;
  v44 = 1000 * (rand() % 40);
  result = *(_BYTE *)(v4 + 96) | 0x10;
  *(_DWORD *)(v4 + 60) = v44;
  *(_BYTE *)(v4 + 96) = result;
  return result;
}
// 43C4EC: variable 'v39' is possibly undefined
// 43C780: using guessed type int nullsub_9();
// 4AB058: using guessed type int dword_4AB058;
// 4AB05C: using guessed type int dword_4AB05C;
// 4C1A80: using guessed type char byte_4C1A80;
// 4C1AA0: using guessed type int dword_4C1AA0;
// 4C1AA4: using guessed type int dword_4C1AA4;
// 4C1AA8: using guessed type int dword_4C1AA8;
// 4C1AAC: using guessed type int dword_4C1AAC;

//----- (0043C5D0) --------------------------------------------------------
bool __thiscall sub_43C5D0(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edx
  unsigned int v5; // edi
  _DWORD *v6; // ecx
  int v7; // eax
  int v9; // ebx
  int v10; // eax
  _DWORD *v11; // ecx
  int v12; // eax

  v4 = *a2;
  if ( *a2 >= 0x400u )
    return 1;
  v5 = a2[1];
  if ( v5 >= 0x400 )
    return 1;
  v6 = (_DWORD *)this[3];
  v7 = v6[30132];
  if ( !v7 )
    return 0;
  v9 = v7 + (v5 << 10);
  v10 = *(unsigned __int8 *)(v9 + v4);
  if ( !*(_BYTE *)(v9 + v4) )
    return 0;
  if ( *(unsigned __int8 *)(v9 + v4) <= 0xA9u )
    return 1;
  if ( *(unsigned __int8 *)(v9 + v4) >= 0xAAu && *(unsigned __int8 *)(v9 + v4) <= 0xBFu || v10 == 220 || v10 == 241 )
    return 0;
  if ( v10 == 242 )
  {
    if ( (_BYTE)a3 && *((_BYTE *)this + 156) )
    {
      LOWORD(a3) = 0;
      (*(void (__thiscall **)(_DWORD *, int, _DWORD, int, _DWORD))(*this + 44))(
        this,
        4 * (*(_DWORD *)(v6[542] + 520) + *(_DWORD *)(v6[542] + 524)) / 5,
        this[6],
        a3,
        0);
      v11 = (_DWORD *)this[3];
      if ( v11[2950] )
        v12 = (*(int (__thiscall **)(_DWORD *))(*v11 + 64))(v11) / *(_DWORD *)(this[3] + 11800);
      else
        v12 = rand();
      (*(void (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(this[3] + 2168) + 152))(
        *(_DWORD *)(this[3] + 2168),
        v12,
        -1,
        -1);
    }
    return 0;
  }
  if ( v10 != 254 )
  {
    if ( v10 == 255 )
    {
      if ( (_BYTE)a3 )
        (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD))(*this + 20))(this, *a2, a2[1]);
      return 0;
    }
    if ( v10 == 252 || v10 == 253 )
      return (*(unsigned __int8 (__thiscall **)(_DWORD *, int, unsigned int, _DWORD))(*v6 + 464))(v6, v4, v5, this[22]) == 0;
    return 1;
  }
  if ( (_BYTE)a3 )
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD))(*this + 52))(this, *a2, a2[1]);
  return 0;
}

//----- (0043C790) --------------------------------------------------------
int __thiscall sub_43C790(_DWORD *this, int a2, int a3)
{
  int result; // eax

  (*(void (__thiscall **)(_DWORD *, int, _DWORD))(*this + 252))(this, a2, 0);
  (*(void (__thiscall **)(_DWORD *))(*this + 56))(this);
  result = a3;
  this[354] = 6;
  if ( a3 )
    result = (*(int (__thiscall **)(_DWORD *, int, _DWORD, _DWORD, _DWORD, int))(this[27905] + 28))(
               this + 27905,
               a3,
               0,
               0,
               0,
               1);
  return result;
}

//----- (0043C7E0) --------------------------------------------------------
int __fastcall sub_43C7E0(int a1, _BYTE *a2, int a3)
{
  char v3; // al
  int v4; // ebp
  _BYTE *v5; // esi
  char v6; // cl
  char *v7; // edi
  _BYTE *i; // ebx
  int v9; // esi
  int v10; // eax
  unsigned int j; // ecx
  char *v12; // edx
  char v13; // al
  int v16[4]; // [esp+14h] [ebp-D0h] BYREF
  int v17[21]; // [esp+24h] [ebp-C0h] BYREF
  int Buffer[24]; // [esp+78h] [ebp-6Ch] BYREF
  int v19; // [esp+E0h] [ebp-4h]

  v3 = *a2;
  v4 = 0;
  v5 = a2;
  if ( *a2 )
  {
    v6 = *a2;
    do
    {
      v4 ^= v6;
      v6 = *++v5;
    }
    while ( v6 );
  }
  v7 = (char *)Buffer;
  for ( i = a2; v3; ++i )
  {
    v9 = v4 ^ v3;
    v10 = (unsigned __int8)(v4 ^ v3);
    if ( !v10 )
      v10 = 237;
    sprintf_0(v7, "%02x", v10);
    v3 = i[1];
    v7 += 2;
    v4 ^= v9 << (v9 & 3);
  }
  sprintf_0(v7, "%u", a3);
  sub_40ADE0(v17);
  v19 = 0;
  sub_40AE50(v17, Buffer, strlen((const char *)Buffer));
  sub_40AF00(v17, v16);
  for ( j = 0; j < 8; ++j )
  {
    v12 = (char *)v16 + j;
    if ( *((_BYTE *)v16 + j) != *((_BYTE *)&v16[2] + j) )
      v13 = *((_BYTE *)v16 + j) ^ *((_BYTE *)&v16[2] + j);
    else
      v13 = 1;
    v12[a1 - (_DWORD)v16] = v13;
  }
  v19 = -1;
  return sub_40AE10(v17);
}

//----- (0043C920) --------------------------------------------------------
int __thiscall sub_43C920(int this, int a2, int a3)
{
  int result; // eax
  _DWORD *v5; // ecx
  int v6; // ebx
  char v7; // al
  int v8; // edi
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // [esp-4h] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)(this + 440);
  if ( !result )
  {
    v5 = *(_DWORD **)(this + 12);
    result = v5[5776] - *(_DWORD *)(this + 884);
    if ( result >= 100 || *(_DWORD *)(this + 92) != 8 )
    {
      v6 = *(_DWORD *)(this + 92);
      v7 = *(_BYTE *)(this + 96) | 0x80;
      *(_BYTE *)(this + 96) = v7;
      v8 = v5[3023];
      if ( v6 == 8 )
      {
        v8 = v5[352] != 3 ? 100 : 10;
      }
      else if ( *(_DWORD *)(this + 520) + *(_DWORD *)(this + 524) >= 0 )
      {
        if ( *(_DWORD *)(this + 28) == -1 )
        {
          if ( *(_DWORD *)(this + 16) == *(_DWORD *)(this + 824)
            && *(_DWORD *)(this + 20) == *(_DWORD *)(this + 828)
            && *(_DWORD *)(this + 60) == *(_DWORD *)(this + 508) )
          {
            v8 *= 2;
            if ( (int)abs32(*(_DWORD *)(this + 16)) < 500 && (int)abs32(*(_DWORD *)(this + 20)) < 500 )
              v8 *= 2;
          }
          else
          {
            *(_BYTE *)(this + 96) = v7 & 0x7F;
          }
        }
        else
        {
          v8 *= 5;
        }
      }
      else
      {
        v8 = 50;
      }
      if ( (_BYTE)a2 || (a3 & 0x1F) != 0 || (result = v5[5776] - *(_DWORD *)(this + 752), result >= v8) )
      {
        v9 = v5[5776];
        *(_DWORD *)(this + 508) = *(_DWORD *)(this + 60);
        v10 = *(_DWORD *)(this + 16);
        *(_DWORD *)(this + 752) = v9;
        v11 = *(_DWORD *)(this + 20);
        *(_DWORD *)(this + 824) = v10;
        *(_DWORD *)(this + 828) = v11;
        if ( *(_DWORD *)(this + 520) + *(_DWORD *)(this + 524) < 0 )
        {
          HIWORD(v14) = HIWORD(v5);
          LOBYTE(a2) = 0x80;
          LOWORD(v14) = 0;
          result = (*(int (__stdcall **)(int, int, _DWORD, int, int, _DWORD, _DWORD, int, int))(**(_DWORD **)(this + 12)
                                                                                              + 180))(
                     dword_4B81A8,
                     dword_4B81AC,
                     0,
                     dword_4C1B00,
                     dword_4C1B04,
                     0,
                     0,
                     a2,
                     v14);
        }
        else
        {
          if ( (a3 & 0x1F) != 0 )
          {
            v12 = *(_DWORD *)(this + 20);
            v15 = *(_DWORD *)(this + 16);
          }
          else
          {
            v12 = *(_DWORD *)(this + 568);
            v15 = *(_DWORD *)(this + 564);
          }
          v13 = *(_DWORD *)(this + 8) / 1000;
          LOBYTE(v13) = *(_BYTE *)(this + 96);
          result = (*(int (__thiscall **)(_DWORD *, int, int, int, int, int, int, int, int, int))(*v5 + 180))(
                     v5,
                     *(_DWORD *)(this + 4) / 1000,
                     *(_DWORD *)(this + 8) / 1000,
                     *(_DWORD *)(this + 60) / 1000,
                     v15,
                     v12,
                     *(_DWORD *)(this + 32) + *(_DWORD *)(this + 36),
                     (*(_DWORD *)(this + 520) + *(_DWORD *)(this + 524)) / 1000,
                     v13,
                     a3);
          *(_BYTE *)(this + 96) &= 0xEFu;
        }
      }
    }
  }
  return result;
}
// 4B81A8: using guessed type int dword_4B81A8;
// 4B81AC: using guessed type int dword_4B81AC;
// 4C1B00: using guessed type int dword_4C1B00;
// 4C1B04: using guessed type int dword_4C1B04;

//----- (0043CB60) --------------------------------------------------------
void __thiscall sub_43CB60(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // ecx

  v5 = (_DWORD *)this[a4 + 2586];
  if ( v5 )
    sub_404DD0(v5, a2, a3, a5, 1, 0, 0);
}

//----- (0043CB90) --------------------------------------------------------
int __stdcall sub_43CB90(_BYTE *a1)
{
  int v1; // eax
  _DWORD *v2; // ecx
  _BYTE v4[260]; // [esp+8h] [ebp-104h] BYREF

  v4[0] = 0;
  dword_4A7100(0, v4, 260);
  sub_407A70(v4);
  sub_407960(v4, (int)v4, a1);
  v1 = sub_432CF0((int)v4);
  if ( !v1 )
    return 0;
  v2 = &unk_4B8120;
  while ( *v2 != v1 )
  {
    if ( ++v2 >= &dword_4B8160 )
    {
      sub_40DA80(aFailedToLoadS);
      return 0;
    }
  }
  return dword_4A70DC(v4);
}
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);

//----- (0043CC40) --------------------------------------------------------
int __thiscall sub_43CC40(_DWORD *this, int a2)
{
  int v3; // edi
  int v4; // ecx
  int result; // eax
  bool v6; // zf
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // edx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int *v23; // ebx

  v3 = a2;
  v4 = this[3];
  if ( !*(_BYTE *)(v4 + 6282) && a2 != 3 )
    v3 = -1;
  result = this[162];
  if ( result != v3 )
  {
    if ( result < 0 && v3 >= 0 )
      (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, int, _DWORD))(**(_DWORD **)(*(_DWORD *)(v4 + 120076) + 256) + 20))(
        *(_DWORD *)(*(_DWORD *)(v4 + 120076) + 256),
        0,
        0,
        1,
        0);
    if ( (int)this[162] >= 0 )
    {
      v6 = v3 == 0;
      if ( v3 >= 0 )
      {
LABEL_12:
        if ( v6 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 260);
          (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 28))(v8);
          v9 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 264);
          (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 28))(v9);
          v10 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 284);
          (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 28))(v10);
          v11 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 288);
        }
        else if ( v3 == 1 )
        {
          v12 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 264);
          (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v12 + 20))(v12, 0, 0, 1, 0);
          v13 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 260);
          (*(void (__thiscall **)(int))(*(_DWORD *)v13 + 28))(v13);
          v14 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 284);
          (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 28))(v14);
          v11 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 288);
        }
        else if ( v3 == 2 )
        {
          v15 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 260);
          (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v15 + 20))(v15, 0, 0, 1, 0);
          v16 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 264);
          (*(void (__thiscall **)(int))(*(_DWORD *)v16 + 28))(v16);
          v17 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 284);
          (*(void (__thiscall **)(int))(*(_DWORD *)v17 + 28))(v17);
          v11 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 288);
        }
        else
        {
          v18 = **(_DWORD **)(*(_DWORD *)(this[3] + 120076) + 284);
          if ( v3 == 3 )
          {
            (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(v18 + 20))(0, 0, 0, 0);
            v19 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 288);
            (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v19 + 20))(v19, 0, 0, 1, 0);
          }
          else
          {
            (*(void (**)(void))(v18 + 28))();
            v20 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 288);
            (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 28))(v20);
          }
          v21 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 260);
          (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 28))(v21);
          v11 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 264);
        }
        (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 28))(v11);
        v22 = 0;
        v23 = dword_42686C;
        do
          v22 -= *v23++;
        while ( v23 < (int *)&loc_426908 );
        result = v22 - 1369069236;
        *(_DWORD *)((char *)this + result + 133848) = v3;
        return result;
      }
      v7 = *(_DWORD *)(*(_DWORD *)(this[3] + 120076) + 256);
      (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 28))(v7);
    }
    v6 = v3 == 0;
    goto LABEL_12;
  }
  return result;
}
// 42686C: using guessed type int dword_42686C[5];

//----- (0043D540) --------------------------------------------------------
int __thiscall sub_43D540(_DWORD *this, _BYTE *a2, int a3)
{
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // ecx
  int *v8; // ecx
  int v9; // eax
  int v10; // edx
  _DWORD v12[6]; // [esp+0h] [ebp-24h] BYREF
  int v13; // [esp+20h] [ebp-4h]
  int savedregs; // [esp+24h] [ebp+0h] BYREF

  v12[5] = v12;
  v12[4] = this;
  v4 = this[82];
  if ( v4 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 36))(v4, 1);
  v5 = 0;
  v6 = (_DWORD *)((char *)&loc_43D738 + 4);
  do
    v5 -= *v6++;
  while ( v6 < (_DWORD *)&loc_43DA58 );
  *(_DWORD *)((char *)this + v5 - 504200436) = 0;
  v13 = 0;
  v7 = sub_40B720((int)&savedregs, 0x168u);
  v12[3] = v7;
  LOBYTE(v13) = 1;
  if ( v7 )
    v8 = (int *)sub_406480(v7, (int)this, a2, a3);
  else
    v8 = 0;
  v9 = this[15];
  this[82] = v8;
  v10 = *v8;
  LOBYTE(v13) = 0;
  return (*(int (__thiscall **)(int *, int, _DWORD))(v10 + 32))(v8, v9, 0);
}

//----- (0043D610) --------------------------------------------------------
unsigned int __thiscall sub_43D610(int *this, _BYTE *a2, signed int a3, char a4)
{
  int v4; // eax
  _DWORD *v5; // ebx
  unsigned int result; // eax
  int v7; // esi
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  v4 = 0;
  v5 = (_DWORD *)((char *)&loc_44EB73 + 1);
  do
    v4 -= *v5++;
  while ( v5 < (_DWORD *)((char *)&loc_44EC9F + 1) );
  result = v4 - 1167437371;
  if ( *(int *)((char *)this + result + 430152) == 2 && a3 > 0 )
  {
    v7 = sub_4552D0((int)(this + 181), (int)&savedregs, this[183]);
    result = sub_40CA40((unsigned int *)v7, (int)&savedregs, a2, a3);
    *(_DWORD *)(v7 + 8) = 0;
    *(_BYTE *)(v7 + 12) = a4;
  }
  return result;
}

//----- (0043D680) --------------------------------------------------------
int __thiscall sub_43D680(_DWORD *this, int a2)
{
  unsigned int v3; // edi
  int v4; // edx
  int result; // eax

  v3 = this[a2 + 2173];
  if ( v3 )
    sub_417EB0((int)&dword_4C1AD0, 22354, (_BYTE *)(v3 + 180), 4);
  sub_46CAB0((unsigned int)&this[a2 + 2173], &this[a2 + 2174], 4 * (this[2685] + 0x3FFFFFFF * (a2 + 1)));
  v4 = this[2685] - 1;
  this[2685] = v4;
  if ( v4 >= 512 )
  {
    sub_40B7E0(v3);
  }
  else
  {
    this[v4 + 2173] = v3;
    ++this[2685];
  }
  result = this[1909] - dword_4C1AE4 - 1 + this[1908];
  this[1908] = result;
  this[1909] = dword_4C1AE4;
  return result;
}
// 4C1AD0: using guessed type int dword_4C1AD0;
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0043D750) --------------------------------------------------------
int __thiscall sub_43D750(void *this, unsigned int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int (__thiscall ***v5)(_DWORD, unsigned int); // ecx
  int v7; // ecx
  int *v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // edi
  int v12; // ecx
  int v13; // edi
  unsigned int v14; // esi
  int i; // ecx
  int v16; // eax
  unsigned int v17; // edx
  unsigned int j; // ecx
  unsigned __int8 v19; // al
  _DWORD *v20; // ecx
  int v21; // esi
  int v22; // ebx
  int v23; // esi
  __int16 v24; // ax
  int v25; // edi
  __int16 v26; // dx
  int v27; // eax
  int v28; // eax
  int v29; // eax
  char v31[12224]; // [esp+Ch] [ebp-2FF8h] BYREF
  int v32; // [esp+2FCCh] [ebp-38h]
  char v33; // [esp+2FD0h] [ebp-34h] BYREF
  int v34; // [esp+2FD1h] [ebp-33h]
  int v35; // [esp+2FD5h] [ebp-2Fh]
  int v36; // [esp+2FD9h] [ebp-2Bh]
  unsigned int v37; // [esp+2FDDh] [ebp-27h]
  int v38; // [esp+2FE1h] [ebp-23h]
  int v39; // [esp+2FE5h] [ebp-1Fh]
  __int16 v40; // [esp+2FE9h] [ebp-1Bh]
  __int16 v41; // [esp+2FEBh] [ebp-19h]
  __int16 v42; // [esp+2FEDh] [ebp-17h]
  __int16 v43; // [esp+2FEFh] [ebp-15h]
  __int16 v44; // [esp+2FF1h] [ebp-13h]
  __int16 v45; // [esp+2FF3h] [ebp-11h]
  __int16 v46; // [esp+2FF5h] [ebp-Fh]
  __int16 v47; // [esp+2FF8h] [ebp-Ch]
  unsigned int v48; // [esp+2FFAh] [ebp-Ah]
  int v49; // [esp+3000h] [ebp-4h]
  int v50; // [esp+300Ch] [ebp+8h]

  v2 = (int)this;
  v49 = (int)this;
  memset(&v33, 0, 0x2Cu);
  HIWORD(v48) = 0;
  v33 = 26;
  v3 = 790844491;
  v4 = 227;
  do
    v3 ^= *(_DWORD *)&aDirectdrawVide[4 * v4-- - 544032];
  while ( v4 );
  v5 = *(int (__thiscall ****)(_DWORD, unsigned int))(v2 + 120508);
  v34 = *(_DWORD *)(v3 + v2 + 42469824);
  v36 = (**v5)(v5, a2);
  v7 = 0;
  v8 = (int *)(v2 + 110192);
  v9 = 357;
  do
  {
    v10 = *v8++;
    v7 += a2 ^ v10;
    --v9;
  }
  while ( v9 );
  v11 = *(_DWORD *)(v2 + 120528);
  v35 = v7;
  v50 = v11;
  if ( v11 )
  {
    v37 = a2;
    v12 = a2 & 0x1F;
    v13 = v11 + (v12 << 10);
    v14 = (unsigned int)(1055 - v12) >> 5;
    v32 = a2 % 0x1F;
    do
    {
      for ( i = v32; i < 1024; i += 31 )
      {
        v16 = *(unsigned __int8 *)(v13 + i);
        if ( *(_BYTE *)(v13 + i) && *(unsigned __int8 *)(v13 + i) < 0xA1u || v16 == 171 )
          v37 += a2 ^ v16;
      }
      v13 += 0x8000;
      --v14;
    }
    while ( v14 );
    v2 = v49;
    v17 = -1;
    for ( j = 0; j < 0x100000; ++j )
    {
      v19 = *(_BYTE *)(v50 + j);
      if ( v19 && (v19 < 0xA1u || v19 == 0xAB) )
        v17 = dword_4A743C[*(unsigned __int8 *)(v50 + j) ^ (unsigned __int8)v17] ^ (v17 >> 8);
    }
    v48 = v17;
  }
  else
  {
    v37 = -12345678;
  }
  (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)v2 + 460))(v2, v31, v2 + 110192);
  v35 += memcmp(v31, (const char *)(v2 + 10748), 12224);
  v20 = (_DWORD *)v49;
  v21 = *(_DWORD *)(v49 + 1376);
  v43 = *(_DWORD *)(v49 + 1360) / 10;
  if ( v21 )
    v44 = (__int16)(*(_DWORD *)(v49 + 1364) / v21) / 10;
  else
    v44 = 0;
  v22 = *(_DWORD *)(v49 + 119860);
  v45 = (__int16)*(_DWORD *)(v49 + 1368) / 10;
  v23 = *(_DWORD *)(v49 + 110176);
  v24 = *(_WORD *)(v49 + 117720);
  v46 = (__int16)*(_DWORD *)(v49 + 1372) / 10;
  v25 = *(_DWORD *)(v49 + 112208);
  v40 = *(_WORD *)(v49 + 119860);
  v26 = *(_WORD *)(v49 + 1340);
  v41 = v24;
  v27 = *(_DWORD *)(v49 + 117720);
  v47 = v26;
  v28 = v22 + v27;
  v38 = v23;
  v39 = v25;
  if ( v28 )
    v42 = *(_DWORD *)(v49 + 120072) / v28;
  else
    v42 = 0;
  if ( v28 > *(_DWORD *)(v49 + 11276) )
  {
    v29 = *(_DWORD *)(v49 + 117720);
    *(_DWORD *)(v49 + 110176) = v23 + v22;
    v20[28052] = v25 + v29;
    v20[29965] = 0;
    v20[29430] = 0;
    v20[30018] = 0;
  }
  return (*(int (__thiscall **)(_DWORD *, char *, int, int))(*v20 + 16))(v20, &v33, 46, 1);
}
// 4A743C: using guessed type int dword_4A743C[];

//----- (0043DA10) --------------------------------------------------------
void __thiscall sub_43DA10(_DWORD *this, unsigned __int8 *a2, int a3, int a4)
{
  unsigned int v4; // eax
  int v5; // eax
  int v6; // edx

  if ( a3 >= 1 )
  {
    v4 = *a2 - 1;
    if ( v4 < 0x3C )
    {
      v5 = 4 * v4;
      if ( a3 >= dword_4AA4C0[v5] && a3 <= dword_4AA4C4[v5] )
      {
        v6 = this[354];
        if ( v6 )
        {
          if ( v6 != 6 && (v6 == 5 || !dword_4AA4C8[v5]) )
            (*(void (__thiscall **)(_DWORD *, int, unsigned int))((char *)&off_4AA4CC + v5 * 4))(this, (int)a2, a3);
        }
      }
    }
  }
}
// 4AA4C0: using guessed type int dword_4AA4C0[];
// 4AA4C4: using guessed type int dword_4AA4C4[];
// 4AA4C8: using guessed type int dword_4AA4C8[];
// 4AA4CC: using guessed type int (__stdcall *off_4AA4CC)(int, int);

//----- (0043DA70) --------------------------------------------------------
int __userpurge sub_43DA70@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4, int a5, _DWORD *a6)
{
  int v7; // ebx
  int v8; // ebp
  unsigned int v9; // edx
  int v10; // ecx
  int v11; // eax
  char *v12; // ebx
  int v13; // eax
  unsigned int v14; // kr08_4
  int v15; // eax
  int v16; // ebp
  char *v17; // ebx
  unsigned int v20; // [esp+74h] [ebp-131Ch]
  int v21; // [esp+78h] [ebp-1318h]
  signed int v22; // [esp+7Ch] [ebp-1314h]
  int v23; // [esp+80h] [ebp-1310h] BYREF
  int v24; // [esp+84h] [ebp-130Ch]
  int v25; // [esp+88h] [ebp-1308h]
  int v26; // [esp+8Ch] [ebp-1304h]
  int v27; // [esp+90h] [ebp-1300h]
  int v28; // [esp+94h] [ebp-12FCh]
  char v29; // [esp+98h] [ebp-12F8h] BYREF
  char v30; // [esp+DCh] [ebp-12B4h] BYREF

  if ( !*(_BYTE *)(a1 + 96) )
    return (**(int (__thiscall ***)(int, int, _DWORD, _DWORD))a1)(a1, a4, 0, 0);
  v7 = 0;
  if ( !*(_DWORD *)(a1 + 80) )
    return (**(int (__thiscall ***)(int, int, _DWORD, _DWORD))a1)(a1, a4, 0, 0);
  v8 = *(_DWORD *)(a1 + 84);
  v20 = strlen((const char *)(a1 + 12));
  v27 = (*(int (__thiscall **)(int, _DWORD, int, int))(*(_DWORD *)a1 + 28))(a1, *(_DWORD *)(a1 + 84), a3, a2);
  v11 = *(_DWORD *)(a1 + 88);
  v28 = 0;
  if ( v11 > 0 )
  {
    v12 = &v30;
    do
    {
      if ( v8 >= *(_DWORD *)(a1 + 80) )
        break;
      if ( !v20 )
        v27 = (*(int (__thiscall **)(int, int))(*(_DWORD *)a1 + 28))(a1, v8);
      v13 = (*(int (__thiscall **)(int, char *, int, unsigned int))(*(_DWORD *)a1 + 4))(a1, v12 - 68, v8, v20);
      v9 = v20;
      *((_DWORD *)v12 - 1) = v13;
      *(_DWORD *)v12 = v8;
      ++v21;
      *((_DWORD *)v12 + 1) = v20;
      v14 = strlen(v12 - 68) + 1;
      if ( (int)(v14 - 1) > v22 )
        v22 = v14 - 1;
      if ( (int)++v20 >= v27 )
      {
        ++v8;
        v20 = 0;
      }
      v10 = *(_DWORD *)(a1 + 88);
      v12 += 76;
      ++v28;
    }
    while ( v28 < v10 );
    v7 = v21;
  }
  LOBYTE(v10) = *(_BYTE *)(a1 + 4);
  LOBYTE(v9) = *(_BYTE *)(a1 + 76);
  (*(void (__thiscall **)(_DWORD *, int *, signed int, int, unsigned int, int))(*a6 + 268))(
    a6,
    &v23,
    v22,
    *(_DWORD *)(a1 + 92) + v7 + 1,
    v9,
    v10);
  (**(void (__thiscall ***)(int, _DWORD *, int, int))a1)(a1, a6, v25, v26);
  (*(void (__thiscall **)(_DWORD *, int, int, int, int, int, int))(*a6 + 236))(a6, v23, v24, a1 + 12, 1, -1, 1);
  v15 = v24 + a6[18807] + 2;
  v24 = v15;
  if ( v7 > 0 )
  {
    v16 = v21;
    v17 = &v29;
    do
    {
      (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*a6 + 236))(
        a6,
        v23,
        v15,
        v17,
        *((_DWORD *)v17 + 16),
        -1,
        1);
      (*(void (__thiscall **)(int, _DWORD *, int, int, _DWORD, _DWORD))(*(_DWORD *)a1 + 16))(
        a1,
        a6,
        v23,
        v24,
        *((_DWORD *)v17 + 17),
        *((_DWORD *)v17 + 18));
      v15 = a6[18807] + v24;
      v17 += 76;
      --v16;
      v24 = v15;
    }
    while ( v16 );
  }
  return (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)a1 + 20))(a1, a6);
}
// 43DA70: could not find valid save-restore pair for ebp
// 43DA70: could not find valid save-restore pair for edi
// 43DB12: variable 'v21' is possibly undefined
// 43DB26: variable 'v22' is possibly undefined
// 43DB86: variable 'v9' is possibly undefined
// 43DB86: variable 'v10' is possibly undefined

//----- (0043DC80) --------------------------------------------------------
int __thiscall sub_43DC80(int *this, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v5; // edi
  int result; // eax
  bool v8; // bl
  int v9; // eax
  unsigned int v10; // eax
  int v11; // ecx
  const char *v12; // edi
  const char *v13; // ecx
  int v14; // edx
  int v15; // eax
  const char *v16; // edi
  char v17; // al
  int v18; // eax
  char v19; // al
  int v20; // esi
  const char *v21; // ebx
  int v22; // eax
  unsigned __int8 *v23; // edi
  unsigned __int8 v24; // al
  unsigned int v25; // kr04_4
  int v26; // ebx
  unsigned int v27; // eax
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF
  const char *v29; // [esp+24h] [ebp+8h]
  const char *v30; // [esp+28h] [ebp+Ch]
  int v31; // [esp+2Ch] [ebp+10h]
  char *v32; // [esp+2Ch] [ebp+10h]

  v5 = a2;
  if ( a2 > 0x100 )
  {
    if ( a2 <= 0x400 )
    {
      if ( a2 != 1024 )
      {
        switch ( a2 )
        {
          case 0x101u:
          case 0x105u:
            sub_4113B0(this + 49379, -1);
            (*(void (__thiscall **)(int *, unsigned int, int))(this[49101] + 8))(this + 49101, a3, a4);
            sub_4114C0((const char *)this + 197516, (int)&savedregs);
            return 1;
          case 0x102u:
            if ( (a4 & 0xC0000000) != -1073741824 )
            {
              v21 = (const char *)(this + 49379);
              v29 = (const char *)(this + 49379);
              sub_4113B0(this + 49379, -1);
              if ( a3 == 22 )
              {
                if ( dword_4A7360(this[49382]) )
                {
                  v22 = dword_4A7334(1);
                  v31 = v22;
                  if ( v22 )
                  {
                    v23 = (unsigned __int8 *)dword_4A7138(v22);
                    if ( v23 )
                    {
                      while ( 1 )
                      {
                        v24 = *v23;
                        if ( *v23 < 0x20u && v24 != 9 )
                          break;
                        if ( v24 == 9 )
                          v24 = 32;
                        (*(void (__thiscall **)(int *, _DWORD))(this[49101] + 12))(this + 49101, v24);
                        ++v23;
                      }
                    }
                    dword_4A7134(v31);
                  }
                  dword_4A7368();
                }
              }
              else if ( a3 == 3 && dword_4A7360(this[49382]) )
              {
                dword_4A736C();
                v32 = (char *)(*(int (__thiscall **)(int *))(this[18939] + 480))(this + 18939);
                v25 = strlen(v32) + 1;
                v26 = dword_4A7130(0x2000, v25);
                v27 = dword_4A7138(v26);
                if ( v27 )
                {
                  sub_46CAB0(v27, v32, v25);
                  dword_4A7134(v26);
                }
                dword_4A7370(1, v26);
                dword_4A7368();
                v21 = v29;
              }
              (*(void (__thiscall **)(int *, unsigned int))(this[49101] + 12))(this + 49101, a3);
              v13 = v21;
LABEL_29:
              sub_4114C0(v13, (int)&savedregs);
            }
            return 0;
          case 0x104u:
            v16 = (const char *)(this + 49379);
            sub_4113B0(this + 49379, -1);
            if ( *((_BYTE *)this + 187668) )
              goto LABEL_58;
            if ( *((_BYTE *)this + 187956) )
              goto LABEL_58;
            if ( *((_BYTE *)this + 77625) )
              goto LABEL_58;
            v19 = *((_BYTE *)this + 195944);
            if ( v19 )
            {
              if ( *((_BYTE *)this + 196225) )
                goto LABEL_58;
            }
            if ( *((_BYTE *)this + 83368) || *((_BYTE *)this + 98836) || *((_BYTE *)this + 77604) || v19 )
              goto LABEL_57;
            v18 = 2;
            break;
          case 0x106u:
            return 0;
          default:
            return dword_4A739C(this[49382], v5, a3, a4);
        }
        goto LABEL_59;
      }
      v12 = (const char *)(this + 49379);
      sub_4113B0(this + 49379, -1);
      if ( *((_BYTE *)this + 197532) )
        (*(void (__thiscall **)(int *))(this[18939] + 156))(this + 18939);
LABEL_81:
      sub_4114C0(v12, (int)&savedregs);
      v5 = a2;
    }
    return dword_4A739C(this[49382], v5, a3, a4);
  }
  if ( a2 == 256 )
  {
    v16 = (const char *)(this + 49379);
    sub_4113B0(this + 49379, -1);
    if ( *((_BYTE *)this + 187668)
      || *((_BYTE *)this + 187956)
      || *((_BYTE *)this + 77625)
      || (v17 = *((_BYTE *)this + 195944)) != 0 && *((_BYTE *)this + 196225) )
    {
LABEL_58:
      v18 = 0;
    }
    else if ( *((_BYTE *)this + 83368) || *((_BYTE *)this + 98836) || *((_BYTE *)this + 77604) || v17 )
    {
LABEL_57:
      v18 = 1;
    }
    else
    {
      v18 = 2;
    }
LABEL_59:
    v20 = (*(unsigned __int8 (__thiscall **)(int *, unsigned int, int, int))(this[49101] + 4))(
            this + 49101,
            a3,
            a4,
            v18);
    sub_4114C0(v16, (int)&savedregs);
    return v20;
  }
  switch ( a2 )
  {
    case 1u:
      v15 = dword_4A70B0();
      dword_4C1A98 = dword_4A735C(2, sub_418F00, 0, v15);
      (*(void (__thiscall **)(int *, int))(*this + 40))(this, 1);
      return 0;
    case 2u:
      (*(void (__thiscall **)(int *, _DWORD))(*this + 40))(this, 0);
      dword_4A7358(dword_4C1A98);
      v12 = (const char *)(this + 49379);
      sub_4113B0(this + 49379, -1);
      v14 = this[18939];
      *((_BYTE *)this + 102964) = 1;
      (*(void (__stdcall **)(_DWORD))(v14 + 436))(0);
      (*(void (__thiscall **)(int *))this[18856])(this + 18856);
      goto LABEL_81;
    case 5u:
      nullsub_2("WM_SIZE %x %x\n", a3, a4);
      if ( *((_BYTE *)this + 205530) )
        return dword_4A739C(this[49382], v5, a3, a4);
      v30 = (const char *)(this + 49379);
      sub_4113B0(this + 49379, -1);
      if ( *((_BYTE *)this + 197533) )
      {
        sub_4114C0(v30, (int)&savedregs);
        return dword_4A739C(this[49382], v5, a3, a4);
      }
      *((_BYTE *)this + 197533) = 1;
      v8 = a3 != 1;
      LOBYTE(a2) = v8;
      sub_40DA80(aStaskoutDD);
      v9 = dword_4A72E4(this[49382], -16);
      if ( v8 )
        v10 = v9 & 0xFFF7FFFF;
      else
        v10 = v9 | 0x80000;
      dword_4A72D4(this[49382], -16, v10);
      if ( v8 )
        dword_4A7350(this[49382]);
      else
        dword_4A7354(this[49382], 134, 1, 0);
      (*(void (__thiscall **)(int *, unsigned int))(*this + 44))(this, a2);
      if ( *((_BYTE *)this + 205818) )
      {
        LOBYTE(v11) = *((_BYTE *)this + 197532) == 0;
        (*(void (__thiscall **)(int *, int))(this[12] + 28))(this + 12, v11);
        (*(void (__thiscall **)(int *))(this[12] + 24))(this + 12);
      }
      *((_BYTE *)this + 197533) = 0;
      sub_4114C0(v30, (int)&savedregs);
      result = 0;
      break;
    case 6u:
      nullsub_2("WM_ACTIVATE %x %x\n", a3, a4);
      if ( !*((_BYTE *)this + 205530) )
        return dword_4A739C(this[49382], v5, a3, a4);
      v12 = (const char *)(this + 49379);
      sub_4113B0(this + 49379, -1);
      if ( *((_BYTE *)this + 197533) )
        goto LABEL_81;
      *((_BYTE *)this + 197533) = 1;
      if ( !(_WORD)a3 || (LOBYTE(a4) = 1, HIWORD(a3)) )
        LOBYTE(a4) = 0;
      sub_40DA80((char *)(9121053 - (_DWORD)sub_4050F9));
      if ( (_BYTE)a4 )
        dword_4A7350(this[49382]);
      (*(void (__thiscall **)(int *, int))(*this + 44))(this, a4);
      *((_BYTE *)this + 197533) = 0;
LABEL_28:
      v13 = v12;
      goto LABEL_29;
    case 0xFu:
      *((_BYTE *)this + 197533) = 0;
      return dword_4A739C(this[49382], v5, a3, a4);
    case 0x10u:
      v12 = (const char *)(this + 49379);
      sub_4113B0(this + 49379, -1);
      (*(void (__thiscall **)(int *))(this[18939] + 284))(this + 18939);
      goto LABEL_28;
    case 0x20u:
      if ( *((_BYTE *)this + 205530) )
        return dword_4A739C(this[49382], v5, a3, a4);
      dword_4A734C(0);
      return 0;
    default:
      return dword_4A739C(this[49382], v5, a3, a4);
  }
  return result;
}
// 43DE21: variable 'v11' is possibly undefined
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 4050F9: using guessed type int __stdcall sub_4050F9(int);
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A7130: using guessed type int (__stdcall *dword_4A7130)(_DWORD, _DWORD);
// 4A7134: using guessed type int (__stdcall *dword_4A7134)(_DWORD);
// 4A7138: using guessed type int (__stdcall *dword_4A7138)(_DWORD);
// 4A72D4: using guessed type int (__stdcall *dword_4A72D4)(_DWORD, _DWORD, _DWORD);
// 4A72E4: using guessed type int (__stdcall *dword_4A72E4)(_DWORD, _DWORD);
// 4A7334: using guessed type int (__stdcall *dword_4A7334)(_DWORD);
// 4A734C: using guessed type int (__stdcall *dword_4A734C)(_DWORD);
// 4A7350: using guessed type int (__stdcall *dword_4A7350)(_DWORD);
// 4A7354: using guessed type int (__stdcall *dword_4A7354)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7358: using guessed type int (__stdcall *dword_4A7358)(_DWORD);
// 4A735C: using guessed type int (__stdcall *dword_4A735C)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7360: using guessed type int (__stdcall *dword_4A7360)(_DWORD);
// 4A7368: using guessed type int (*dword_4A7368)(void);
// 4A736C: using guessed type int (*dword_4A736C)(void);
// 4A7370: using guessed type int (__stdcall *dword_4A7370)(_DWORD, _DWORD);
// 4A739C: using guessed type int (__stdcall *dword_4A739C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043E490) --------------------------------------------------------
void __fastcall sub_43E490(int a1, _BYTE *a2)
{
  int v3; // esi
  int v4; // [esp+0h] [ebp-12Ch] BYREF
  char v5[260]; // [esp+Ch] [ebp-120h] BYREF
  int v6; // [esp+110h] [ebp-1Ch]
  _DWORD v7[3]; // [esp+114h] [ebp-18h] BYREF
  int v8; // [esp+128h] [ebp-4h]
  int savedregs; // [esp+12Ch] [ebp+0h] BYREF

  v7[2] = &v4;
  v8 = 1;
  v7[0] = 0;
  v7[1] = 0;
  sub_407960(v5, (int)byte_4A7DB0, a2);
  sub_40CFE0(v7, (int)&savedregs, v5, 1u);
  v6 = 9125026;
  v3 = dword_4A70DC(4906096);
  dword_4A7348(dword_4C1A38, 105, a1, sub_418FE0, v7[0]);
  dword_4A70D4(v3);
  LOBYTE(v8) = 0;
  sub_40C9D0((int)v7, (int)&savedregs, 0);
}
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A7348: using guessed type int (__stdcall *dword_4A7348)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043E580) --------------------------------------------------------
int __thiscall sub_43E580(_DWORD *this, char *a2, int a3, int a4)
{
  int v5; // esi
  char *v6; // ebx
  char Buffer[64]; // [esp+Ch] [ebp-44h] BYREF
  int v9; // [esp+4Ch] [ebp-4h]

  v5 = 24 * a3;
  v6 = (char *)(24 * a3 + this[26] + 4);
  if ( !*sub_40BCD0(v6) )
  {
    v9 = 9126464;
    sprintf_0(Buffer, (const char *const)(9126464 - ((_DWORD)&loc_4065AE + 2)), v5 + this[26] + 4);
    v6 = Buffer;
  }
  v9 = 9126715;
  sprintf_0(a2, (const char *const)(9126715 - (_DWORD)&loc_4066BB), v6, *(_DWORD *)(v5 + this[26]));
  if ( a3 == this[2] )
    *a2 = 62;
  return *(_BYTE *)(v5 + this[26] + 20) != 0 ? 4 : 0;
}

//----- (0043E620) --------------------------------------------------------
int __thiscall sub_43E620(_DWORD *this, _DWORD *a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // esi
  int v5; // edx

  this[7062] = *a2;
  v2 = this[5775];
  this[7063] = a2[1];
  v3 = *(_DWORD *)(v2 + 8267);
  if ( !v3 )
    v3 = 20;
  v4 = *(_DWORD *)(this[29429] + 12) / *(_DWORD *)(this[29429] + 75228);
  v5 = 3 * v4 / 5;
  if ( v5 < 25 )
    v5 = 25;
  if ( v5 > v4 - 4 )
    v5 = v4 - 4;
  return (*(int (__thiscall **)(_DWORD *, int, int))(this[28087] + 44))(this + 28087, v3, v5);
}

//----- (0043E6A0) --------------------------------------------------------
int __thiscall sub_43E6A0(_DWORD *this)
{
  int v2; // edx
  int v3; // edx
  int v4; // eax
  int v5; // edx
  unsigned int v6; // eax
  int v7; // ecx
  int result; // eax
  char v9; // [esp+8h] [ebp-8h] BYREF
  char v10; // [esp+9h] [ebp-7h]
  int v11; // [esp+Ah] [ebp-6h]
  __int16 v12; // [esp+Eh] [ebp-2h]

  (*(void (__thiscall **)(_DWORD *))(*this + 24))(this);
  this[234] = sub_412170() / 0xAu - 100000;
  v2 = this[177];
  this[338] = 30;
  this[228] = 1;
  this[231] = 0;
  this[230] = 0;
  this[229] = 0;
  this[349] = 0;
  *((_BYTE *)this + 1405) = 0;
  if ( v2 )
  {
    v3 = this[24];
    v9 = 0;
    v4 = *this;
    v12 = 1;
    v10 = 17;
    v11 = v3;
  }
  else
  {
    v5 = this[24];
    v9 = 0;
    v4 = *this;
    v10 = 1;
    v11 = -v5;
    v12 = 17;
  }
  (*(void (__thiscall **)(_DWORD *, int, char *))(v4 + 20))(this, 8, &v9);
  this[227] = sub_412170();
  v6 = (unsigned int)dword_5189D8;
  v7 = 225;
  do
    v6 ^= (unsigned int)*(&dword_4A7410 + v7-- + 3095);
  while ( v7 );
  *(_DWORD *)((char *)this + v6 + 1266504) = 1;
  result = sub_412170() - 5001;
  this[339] = result;
  this[226] = result;
  return result;
}
// 4A7410: using guessed type int (__stdcall *dword_4A7410)(_DWORD);
// 5189D8: using guessed type int dword_5189D8[512];

//----- (0043E7F0) --------------------------------------------------------
int __thiscall sub_43E7F0(char *this)
{
  int v2; // eax
  int v3; // ecx

  v2 = -355454898;
  v3 = 248;
  do
    v2 ^= *((_DWORD *)&PA.deinit + v3-- - 148380);
  while ( v3 );
  *(_DWORD *)&this[v2 + 110514984] = 2;
  (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 30127) + 28))(*((_DWORD *)this + 30127));
  return (*(int (__thiscall **)(char *, int, int, int))(*(_DWORD *)this + 356))(
           this,
           *((_DWORD *)this + 5775) + 575,
           *((_DWORD *)this + 5775) + 599,
           1);
}

//----- (0043E850) --------------------------------------------------------
void __thiscall sub_43E850(char *this)
{
  int v1; // ebx
  const char *v2; // esi
  const char *v3; // esi
  char *v4; // eax
  const char *v5; // eax
  int v6; // edi
  int v7; // ecx
  char v8; // al
  const char *v9; // ebx
  char *v10; // ebx
  char v11; // al
  char v12; // al
  bool v13; // cf
  char *v14; // eax
  char *v15; // edi
  int v16; // edi
  int v17; // eax
  char *v18; // eax
  _QWORD v19[250]; // [esp+Ch] [ebp-81Ch] BYREF
  int v20[2]; // [esp+7DCh] [ebp-4Ch] BYREF
  void *Buf; // [esp+7E4h] [ebp-44h]
  int v22; // [esp+7E8h] [ebp-40h]
  char v23; // [esp+7F4h] [ebp-34h]
  char *v24; // [esp+7F8h] [ebp-30h]
  const char *v25; // [esp+7FCh] [ebp-2Ch]
  int v26; // [esp+800h] [ebp-28h]
  const char **v27; // [esp+804h] [ebp-24h]
  unsigned int v28; // [esp+808h] [ebp-20h]
  int v29; // [esp+80Ch] [ebp-1Ch]
  char *Str1; // [esp+810h] [ebp-18h]
  unsigned int v31; // [esp+814h] [ebp-14h]
  int v32; // [esp+818h] [ebp-10h]
  int v33; // [esp+824h] [ebp-4h]
  int savedregs; // [esp+828h] [ebp+0h] BYREF

  v1 = (int)this;
  v24 = this;
  v31 = 9132215;
  v2 = (const char *)v19;
  v32 = 5772;
  v28 = strlen((const char *)(9132215 - (_DWORD)sub_407C03));
  do
  {
    (*(void (__cdecl **)(const char *, _DWORD))(*(_DWORD *)(v1 + 23100) + 9138))(
      v2,
      *(_DWORD *)(v32 + *(_DWORD *)(v1 + 23100)));
    if ( v28 < strlen(v2) )
      v28 = strlen(v2);
    v2 += 40;
    v32 += 4;
  }
  while ( v32 < 5972 );
  *(_BYTE *)(v1 + 117789) = 0;
  *(_BYTE *)(v1 + 119896) = 0;
  v32 = 0;
  v20[0] = 0;
  v20[1] = 0;
  v23 = 0;
  v33 = 0;
  v31 = 9133291;
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD, int *, int))(**(_DWORD **)(*(_DWORD *)(v1 + 117716) + 1204) + 28))(
         *(_DWORD *)(*(_DWORD *)(v1 + 117716) + 1204),
         v20,
         9133291 - (_DWORD)&loc_408047) )
  {
    v3 = (const char *)Buf;
    v29 = 0;
    v4 = (char *)Buf + v22;
    v31 = (unsigned int)Buf + v22;
    if ( Buf >= (char *)Buf + v22 )
    {
LABEL_36:
      *(_DWORD *)(v1 + 117768) = v32;
      goto LABEL_37;
    }
    while ( 1 )
    {
      v5 = (const char *)memchr(v3, 10, v4 - v3);
      v6 = (int)v5;
      v25 = v5;
      if ( !v5 )
        goto LABEL_36;
      *v5 = 0;
      if ( v5 != v3 && *(v5 - 1) == 13 )
        *((_BYTE *)v5 - 1) = 0;
      if ( *v3 == 35 )
      {
        v7 = *(_DWORD *)(v1 + 117764);
        v29 = 0;
        if ( ++v32 <= v7 )
        {
          *(_BYTE *)(v1 + 117789) = 0;
          strncpyt((void *)(v1 + 119896), (void *)(v3 + 1), 64);
        }
      }
      else if ( v32 == *(_DWORD *)(v1 + 117764) && v29 < 36 )
      {
        v8 = *(_BYTE *)(v1 + 117789);
        v9 = (const char *)(v1 + 117789);
        if ( v8 )
          sub_40BAE0(v9, asc_4A8DE0, 2048);
        v10 = strchr(v9, 0);
        v11 = *v3;
        if ( !*v3 )
        {
LABEL_34:
          v17 = v29;
          *v10 = 0;
          v1 = (int)v24;
          v29 = v17 + 1;
          goto LABEL_35;
        }
        while ( 2 )
        {
          if ( v10 >= v24 + 119787 )
            goto LABEL_34;
          if ( v11 == 37 && (v12 = v3[1], Str1 = (char *)(v3 + 1), v12) )
          {
            if ( v12 == 75 )
            {
              v26 = 0;
              v27 = (const char **)off_4AB060;
              do
              {
                if ( !strncmp(Str1, *v27, strlen(*v27)) )
                {
                  Str1 = (char *)9138157;
                  v16 = v26;
                  v10 += sprintf_0(
                           v10,
                           (const char *const)(9138157 - (_DWORD)sub_409351),
                           v28,
                           &v19[5 * dword_4AB0D8[v26]]);
                  v3 += strlen(off_4AB060[v16]) + 1;
                  goto LABEL_32;
                }
                v13 = v27 + 1 < (const char **)dword_4AB0D8;
                ++v26;
                ++v27;
              }
              while ( v13 );
              v14 = strchr(v3, 32);
              v15 = v14;
              if ( v14 )
              {
                *v14 = 0;
                Str1 = (char *)9139129;
                v10 += sprintf_0(v10, aS_4, v28, v3 + 2);
                *v15 = 32;
                v3 = v15;
              }
              goto LABEL_32;
            }
            v18 = strchr(off_4B81B0, v12);
            if ( !v18 )
              goto LABEL_32;
            ++v3;
            *v10++ = (_BYTE)v18 - (_BYTE)off_4B81B0 + 1;
          }
          else
          {
LABEL_32:
            *v10++ = *v3;
          }
          v11 = v3[1];
          v6 = (int)v25;
          ++v3;
          if ( !v11 )
            goto LABEL_34;
          continue;
        }
      }
LABEL_35:
      v3 = (const char *)(v6 + 1);
      if ( v6 + 1 >= v31 )
        goto LABEL_36;
      v4 = (char *)v31;
    }
  }
  *(_DWORD *)(v1 + 117764) = 0;
LABEL_37:
  v33 = -1;
  sub_40C9D0((int)v20, (int)&savedregs, 0);
}
// 407C03: using guessed type int sub_407C03();
// 409351: using guessed type int sub_409351();
// 4AB060: using guessed type char *off_4AB060[30];
// 4AB0D8: using guessed type int dword_4AB0D8[];

//----- (0043EBD0) --------------------------------------------------------
bool __thiscall sub_43EBD0(_DWORD *this)
{
  _DWORD *v2; // eax
  int v3; // ecx
  int v4; // ecx
  int v5; // eax
  _DWORD *v6; // ebx

  v2 = (_DWORD *)this[7];
  if ( !v2[542] )
    return 0;
  v3 = v2[30132];
  if ( !v3 )
    return 0;
  v4 = *(unsigned __int8 *)(this[2] + (this[3] << 10) + v3);
  if ( this[9] == v2[28119] + v2[28120] )
  {
    if ( v4 != 253 || *((_BYTE *)this + 32) )
      (*(void (__thiscall **)(_DWORD *, int))(*this + 4))(this, 253);
  }
  else if ( v4 != 252 || *((_BYTE *)this + 32) )
  {
    v5 = 0;
    v6 = (_DWORD *)((char *)&loc_45235E + 2);
    do
      v5 -= *v6++;
    while ( v6 < (_DWORD *)&loc_452604 );
    (*(void (__thiscall **)(int, int))(*(_DWORD *)((char *)this + v5 + 299462109) + 4))((int)this + v5 + 299462109, 252);
  }
  return *(_DWORD *)(this[7] + 23104) - this[6] > *(_DWORD *)(this[7] + 12252);
}

//----- (0043ECA0) --------------------------------------------------------
char __thiscall sub_43ECA0(int this, _DWORD *a2)
{
  char result; // al
  int v4; // ecx
  char Buffer[1024]; // [esp+8h] [ebp-400h] BYREF

  if ( *(_DWORD *)(this + 117764) )
  {
    a2[18815] = -1;
    a2[18814] = -1;
    (*(void (__thiscall **)(_DWORD *, int, int, _DWORD))(*a2 + 252))(a2, this + 119896, this + 117789, 0);
  }
  result = *(_BYTE *)(this + 1869);
  if ( result )
  {
    v4 = *(_DWORD *)(this + 23100);
    sprintf_0(
      Buffer,
      (const char *const)off_4B81B4,
      v4 + 8946,
      v4 + 8963,
      v4 + 8980,
      v4 + 8997,
      v4 + 9014,
      v4 + 9031,
      v4 + 9048,
      v4 + 9065);
    result = (*(int (__thiscall **)(_DWORD *, int, char *, int))(*a2 + 252))(a2, 4906176, Buffer, 1);
  }
  return result;
}
// 4B81B4: using guessed type void *off_4B81B4;

//----- (0043ED80) --------------------------------------------------------
int __thiscall sub_43ED80(_DWORD *this, int a2)
{
  int result; // eax
  int v4; // ebx
  int v5; // eax
  int v6; // ecx

  result = this[129];
  if ( result <= 0 )
  {
    result = this[23];
    v4 = a2;
    if ( result == a2 )
    {
      if ( a2 != 8 )
      {
        HIWORD(a2) = 139;
        result = (*(int (__cdecl **)(_DWORD, int, int, int))(*(_DWORD *)this[3] + 388))(
                   this[3],
                   400,
                   4,
                   9148232 - (_DWORD)sub_40BA10);
      }
    }
    else if ( result == 8 || (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 88))(this) )
    {
      v6 = this[3];
      BYTE2(a2) = 24;
      HIBYTE(a2) = v4;
      result = (*(int (__thiscall **)(int, char *, int, int))(*(_DWORD *)v6 + 16))(v6, (char *)&a2 + 2, 2, 1);
      if ( this[23] == 8 )
        this[221] = *(_DWORD *)(this[3] + 23104);
    }
    else
    {
      HIWORD(a2) = 139;
      if ( v4 == 8 )
        v5 = 4906244;
      else
        v5 = 4906200;
      result = (*(int (__cdecl **)(_DWORD, int, int, int))(*(_DWORD *)this[3] + 388))(this[3], 400, 4, v5);
    }
  }
  return result;
}
// 40BA10: using guessed type int __stdcall sub_40BA10(int);

//----- (0043EE80) --------------------------------------------------------
void __thiscall sub_43EE80(int this, char a2)
{
  char v3; // al
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  int v9; // [esp+10h] [ebp-18h]
  const char *v10; // [esp+14h] [ebp-14h]
  char v11; // [esp+1Bh] [ebp-Dh]
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v11 = 0;
  v10 = (const char *)(this + 197516);
  sub_4113B0((int *)(this + 197516), -1);
  if ( !*(_BYTE *)(this + 197532) || a2 )
  {
    v4 = 0;
    v5 = &loc_428CD4;
    do
      v4 -= *v5++;
    while ( v5 < (_DWORD *)&loc_428F9C );
    (*(void (__thiscall **)(int))(*(_DWORD *)(v4 - 816102060 + this + 244690740) + 16))(v4 - 816102060 + this + 244690740);
  }
  else if ( *(_BYTE *)(this + 187668)
         || *(_BYTE *)(this + 187956)
         || *(_BYTE *)(this + 77625)
         || (v3 = *(_BYTE *)(this + 195944)) != 0 && *(_BYTE *)(this + 196225) )
  {
    (**(void (__thiscall ***)(int, _DWORD))(this + 196404))(this + 196404, 0);
  }
  else if ( *(_BYTE *)(this + 83368) || *(_BYTE *)(this + 98836) || *(_BYTE *)(this + 77604) || v3 )
  {
    (**(void (__thiscall ***)(int, int))(this + 196404))(this + 196404, 1);
  }
  else
  {
    (**(void (__thiscall ***)(int, int))(this + 196404))(this + 196404, 2);
  }
  *(_DWORD *)(this + 197552) = sub_4124F0((_DWORD *)(this + 197536));
  v6 = this + 75756;
  v9 = *(_DWORD *)(this + 197552) / 10 + 100000;
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)(this + 75756) + 244))(this + 75756, v9, this + 196404);
  if ( a2 )
    goto LABEL_23;
  v7 = *(_DWORD *)(this + 205583);
  if ( v7 != 2 )
  {
    LOBYTE(v7) = v7 == 0;
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 160))(this + 75756, v7);
  }
  if ( *(_BYTE *)(this + 197532) || *(_BYTE *)(this + 205530) )
  {
    v8 = this + 48;
    if ( (*(unsigned __int8 (__thiscall **)(int, int))(*(_DWORD *)(this + 48) + 76))(this + 48, 1) )
    {
      v11 = 1;
    }
    else
    {
      if ( *(_BYTE *)(this + 206844) )
      {
        if ( !*(_BYTE *)(this + 206845) )
        {
          (*(void (__thiscall **)(int))(*(_DWORD *)(this + 75424) + 20))(this + 75424);
          *(_BYTE *)(this + 206845) = 1;
        }
      }
      else
      {
        (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 128))(this + 48);
        *(_BYTE *)(this + 206844) = 1;
      }
      (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)v8 + 136))(
        this + 48,
        *(_DWORD *)(this + 84440),
        *(_DWORD *)(this + 84444),
        v9,
        0,
        0);
      (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 124))(this + 75756, this + 48);
      (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 16))(this + 48, 0);
      (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 132))(this + 48);
    }
    sub_4114C0(v10, (int)&savedregs);
    if ( v9 == dword_4C1B08 && !*(_BYTE *)(this + 205816) || v11 )
      sub_412000((void *)1);
    dword_4C1B08 = v9;
  }
  else
  {
LABEL_23:
    sub_4114C0(v10, (int)&savedregs);
  }
}
// 43F03A: conditional instruction was optimized away because of 'al.1!=0'
// 4C1B08: using guessed type int dword_4C1B08;

//----- (0043F130) --------------------------------------------------------
int __thiscall sub_43F130(_DWORD *this, int a2, int a3)
{
  int v3; // edi
  int v4; // edx
  _DWORD *i; // esi
  int v6; // esi

  v3 = this[28377];
  v4 = 0;
  if ( v3 <= 0 )
    return 0;
  for ( i = this + 28121; *(_DWORD *)(*i + 4) != a2 || *(_DWORD *)(*i + 8) != a3; ++i )
  {
    if ( ++v4 >= v3 )
      return 0;
  }
  v6 = *(_DWORD *)this[v4 + 28121];
  (*(void (__thiscall **)(_DWORD *, int))(*this + 308))(this, v4);
  return v6;
}

//----- (0043F9C0) --------------------------------------------------------
int __thiscall sub_43F9C0(_DWORD *this)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  int v4; // edi
  int v5; // ebx
  _DWORD *i; // esi
  int result; // eax
  int v8; // eax
  int v9; // esi

  if ( !this[1877] )
    return 0;
  v1 = 2836 * (this[29440] / 127773);
  v2 = 16807 * (this[29440] % 127773) - v1 + 123;
  if ( v2 <= 0 )
    v2 = 16807 * (this[29440] % 127773) - v1 - 2147483526;
  this[29440] = v2;
  v3 = v2 % this[1877];
  v4 = 0;
  v5 = 0;
  for ( i = this + 3075; ; ++i )
  {
    if ( *i )
    {
      if ( v3 >= v4 )
      {
        v4 += *i;
        if ( v3 < v4 )
          break;
      }
    }
    if ( ++v5 >= 29 )
      return 0;
  }
  v8 = 2836 * (this[29440] / 127773);
  v9 = 16807 * (this[29440] % 127773) - v8 + 123;
  if ( v9 <= 0 )
    v9 = 16807 * (this[29440] % 127773) - v8 - 2147483526;
  this[29440] = v9;
  result = v5;
  if ( !(v9 % this[3030]) )
    result = -v5;
  return result;
}

//----- (0043FB00) --------------------------------------------------------
int __thiscall sub_43FB00(int this, int a2)
{
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  int result; // eax
  int v7; // edi
  int v8; // ecx
  bool v9; // sf
  unsigned int v10; // ebx
  int v11; // ebx
  int v12; // eax
  int v13; // eax
  int v14; // ebp
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  unsigned __int8 *v18; // ecx
  int v19; // ebx
  int i; // edi
  int v21; // edi
  int v22; // ebx
  int v23; // ebx
  unsigned __int8 v24; // al
  int v25; // eax
  int v26; // ecx
  _DWORD *v27; // ecx
  unsigned int v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edx
  int v37; // ebx
  int v38; // ebp
  int v39; // ecx
  _BYTE *v40; // edx
  int v41; // edi
  int v42; // ebx
  int v43; // ebx
  bool v44; // cc
  int v45; // ecx
  int v46; // edx
  int v47; // edi
  _BYTE *v48; // ebx
  int v49; // ebp
  int v50[140]; // [esp+0h] [ebp-2A8h]
  int v51; // [esp+230h] [ebp-78h]
  int v52; // [esp+234h] [ebp-74h]
  int v53; // [esp+238h] [ebp-70h]
  int v54; // [esp+23Ch] [ebp-6Ch]
  int v55; // [esp+240h] [ebp-68h]
  int v56; // [esp+244h] [ebp-64h]
  int v57; // [esp+258h] [ebp-50h]
  int v58; // [esp+25Ch] [ebp-4Ch]
  _BYTE *v59; // [esp+264h] [ebp-44h]
  int v60; // [esp+268h] [ebp-40h]
  _BYTE *v61; // [esp+26Ch] [ebp-3Ch]
  unsigned __int8 *v62; // [esp+270h] [ebp-38h]
  int v63; // [esp+278h] [ebp-30h]
  int v64; // [esp+27Ch] [ebp-2Ch]
  int v65; // [esp+280h] [ebp-28h]
  int v66; // [esp+284h] [ebp-24h]
  int v67; // [esp+288h] [ebp-20h]
  int v68; // [esp+28Ch] [ebp-1Ch]
  int v69; // [esp+290h] [ebp-18h]
  int v70; // [esp+294h] [ebp-14h]
  int v71; // [esp+298h] [ebp-10h]
  int v72; // [esp+29Ch] [ebp-Ch]
  int v73; // [esp+2A0h] [ebp-8h]
  int v74; // [esp+2A4h] [ebp-4h]

  v3 = *(_DWORD *)(this + 19880);
  v4 = *(_DWORD *)(this + 19884);
  v5 = v3 + 0x8000;
  result = v3 >> 4;
  v7 = v4 >> 4;
  v65 = result;
  v66 = v7;
  v8 = -(v5 % 16);
  v10 = (*(_DWORD *)(this + 19884) + 0x8000) & 0x8000000F;
  v9 = *(_DWORD *)(this + 19884) + 0x8000 < 0;
  v63 = v8;
  if ( v9 )
    v10 = (((_BYTE)v10 - 1) | 0xFFFFFFF0) + 1;
  v11 = -v10;
  v64 = v11;
  if ( result < -1 )
  {
    v65 = -1;
    v63 = 16 * (-1 - result) + v8;
  }
  if ( v7 < -1 )
  {
    v66 = -1;
    v12 = -1 - v7;
    v7 = -1;
    result = 16 * v12;
    v11 += result;
    v64 = v11;
  }
  if ( v65 <= 1024 )
  {
    v13 = *(_DWORD *)(this + 10192) / 8 % 4 - 1;
    v57 = v7;
    v14 = v11;
    v15 = v13 + 162;
    v71 = v13 + 166;
    v72 = v13 + 166;
    v73 = v13 + 166;
    v74 = v13 + 166;
    v16 = *(_DWORD *)(this + 12);
    v67 = v15;
    v68 = v15;
    v69 = v15;
    v70 = v15;
    if ( v11 < v16 )
    {
      v59 = (_BYTE *)(1024 - v7);
      v17 = v7 << 10;
      v61 = (_BYTE *)(v7 << 10);
      v18 = (unsigned __int8 *)(a2 + (v7 << 10) + v65);
      v62 = v18;
      while ( 1 )
      {
        if ( v17 > 0x100000 )
          goto LABEL_62;
        v19 = v65;
        if ( (unsigned int)v17 >= 0x100000 )
        {
          for ( i = v63; i < *(_DWORD *)(this + 8); ++v19 )
          {
            if ( v19 > 1024 )
              break;
            sub_404B80(*(_DWORD **)(this + 10220), i, v14, 19, 0);
            i += 16;
          }
          goto LABEL_61;
        }
        v21 = v63;
        v22 = *(_DWORD *)(this + 8);
        v60 = (int)v18;
        if ( v63 < v22 )
          break;
LABEL_61:
        v11 = v64;
        v14 += 16;
        v17 = (int)(v61 + 1024);
        ++v57;
        v34 = *(_DWORD *)(this + 12);
        v18 = v62 + 1024;
        --v59;
        v7 = v66;
        v61 += 1024;
        v62 += 1024;
        if ( v14 >= v34 )
          goto LABEL_62;
      }
      v23 = (int)&v18[-v17 - a2];
      while ( 1 )
      {
        if ( v23 > 1024 )
          goto LABEL_61;
        if ( (unsigned int)v23 < 0x400 )
        {
          v24 = *v18;
          if ( *v18 )
          {
            if ( v24 < 0xBFu )
            {
              if ( v24 != 0xAC )
              {
                if ( v24 < 0xA2u || v24 > 0xA9u )
                {
                  if ( v24 < 0xB0u )
                  {
                    if ( v24 != 0xAA )
                      sub_404B80(*(_DWORD **)(this + 10220), v21, v14, *v18 - 1, 0);
                  }
                  else
                  {
                    v28 = *(_DWORD *)(this + 20528);
                    if ( v28 < 0x80 )
                    {
                      *(_WORD *)(this + 4 * v28 + 19888) = v21;
                      *(_WORD *)(this + 4 * *(_DWORD *)(this + 20528) + 19890) = v14;
                      *(_BYTE *)(*(_DWORD *)(this + 20528) + this + 20400) = *v18;
                      ++*(_DWORD *)(this + 20528);
                    }
                  }
                }
                else
                {
                  sub_404B80(*(_DWORD **)(this + 10220), v21, v14, v50[*v18], 0);
                }
                goto LABEL_60;
              }
              switch ( *(_DWORD *)(this + 75360) )
              {
                case 1:
                  v25 = v23 >= 512;
                  break;
                case 2:
                  v25 = v57 >= 512;
                  break;
                case 3:
                case 4:
                  if ( v23 >= 512 )
                    v25 = v57 < 512 ? 1 : 3;
                  else
                    v25 = v57 < 512 ? 0 : 2;
                  break;
                case 5:
                case 6:
                  if ( v23 >= v57 )
                    v25 = (v23 >= (int)v59) + 2;
                  else
                    v25 = v23 >= (int)v59;
                  break;
                default:
                  v25 = 0;
                  break;
              }
              switch ( *(_DWORD *)(this + 75360) )
              {
                case 0:
                  LOBYTE(v58) = 1;
                  break;
                case 1:
                case 2:
                  LOBYTE(v58) = (*(_DWORD *)(this + 75364) & 1) != v25;
                  break;
                case 3:
                case 5:
                  LOBYTE(v58) = (*(_DWORD *)(this + 75364) & 3) != v25;
                  break;
                case 4:
                case 6:
                  LOBYTE(v58) = (*(_DWORD *)(this + 75364) & 3) == v25;
                  break;
                default:
                  LOBYTE(v58) = 0;
                  break;
              }
              v26 = *(_DWORD *)(this + 10192);
              v56 = 9 * (unsigned __int8)v58;
              v55 = 9;
              v54 = 1;
              v53 = v26;
              v27 = *(_DWORD **)(this + 10252);
              v52 = v14;
              v51 = v21;
              goto LABEL_59;
            }
            if ( v24 >= 0xD8u && v24 < 0xDDu )
            {
              v29 = *(_DWORD *)(this + 10192);
              v56 = 0;
              v55 = 0;
              v54 = 1;
              v53 = v29;
              v52 = v14;
              v51 = v21;
              v27 = *(_DWORD **)(this + 4 * v24 + 9360);
LABEL_59:
              sub_404DD0(v27, v51, v52, v53, v54, v55, v56);
              goto LABEL_60;
            }
            switch ( v24 )
            {
              case 0xFF:
                v30 = *(_DWORD *)(this + 10192);
                v27 = *(_DWORD **)(this + 10244);
                v56 = 0;
                v55 = 0;
                v54 = 1;
                v53 = v30;
                v52 = v14;
                v51 = v21;
                goto LABEL_59;
              case 0xFC:
                v31 = *(_DWORD *)(this + 10192);
                v56 = 0;
                v55 = 10;
                v54 = 1;
                v53 = v31;
LABEL_58:
                v27 = *(_DWORD **)(this + 10340);
                v52 = v14;
                v51 = v21;
                goto LABEL_59;
              case 0xFD:
                v32 = *(_DWORD *)(this + 10192);
                v56 = 10;
                v55 = 10;
                v54 = 1;
                v53 = v32;
                goto LABEL_58;
            }
          }
        }
        else
        {
          sub_404B80(*(_DWORD **)(this + 10220), v21, v14, 19, 0);
        }
LABEL_60:
        v33 = *(_DWORD *)(this + 8);
        v21 += 16;
        v18 = (unsigned __int8 *)(v60 + 1);
        ++v23;
        ++v60;
        if ( v21 >= v33 )
          goto LABEL_61;
      }
    }
LABEL_62:
    v35 = v7 - 6;
    v36 = v65 - 6;
    v58 = v65 - 6;
    if ( v65 - 6 < 0 )
    {
      v58 = 0;
      v36 = 0;
    }
    if ( v35 < 0 )
      v35 = 0;
    v57 = v35;
    v60 = v7 - v35;
    v37 = v11 - 16 * (v7 - v35);
    v63 -= 16 * (v65 - v36);
    v62 = (unsigned __int8 *)(16 * (v65 - v36));
    v64 = v37;
    v38 = v37;
    if ( v35 < v7 )
    {
      v39 = v35 << 10;
      v62 = (unsigned __int8 *)v39;
      v40 = (_BYTE *)(a2 + v39 + v58);
      v61 = v40;
      do
      {
        if ( v39 >= 0x100000 || v38 >= *(_DWORD *)(this + 12) )
          break;
        v41 = v63;
        v42 = *(_DWORD *)(this + 8);
        v59 = v40;
        if ( v63 < v42 )
        {
          v43 = (int)&v40[-v39 - a2];
          do
          {
            if ( v43 >= 1024 )
              break;
            if ( *v59 >= 0xD8u && *v59 < 0xDDu )
            {
              sub_404DD0(
                *(_DWORD **)(this + 4 * (unsigned __int8)*v59 + 9360),
                v41,
                v38,
                *(_DWORD *)(this + 10192),
                1,
                0,
                0);
              v40 = v61;
              v39 = (int)v62;
            }
            v41 += 16;
            ++v43;
            ++v59;
          }
          while ( v41 < *(_DWORD *)(this + 8) );
        }
        v7 = v66;
        v37 = v64;
        v39 += 1024;
        v40 += 1024;
        v38 += 16;
        v44 = ++v57 < v66;
        v62 = (unsigned __int8 *)v39;
        v61 = v40;
      }
      while ( v44 );
    }
    result = v37 + 16 * v60;
    v45 = result;
    v61 = (_BYTE *)result;
    if ( v7 < 1024 )
    {
      result = v7 << 10;
      v59 = (_BYTE *)(v7 << 10);
      v46 = a2 + (v7 << 10) + v58;
      v62 = (unsigned __int8 *)v46;
      do
      {
        if ( v45 >= *(_DWORD *)(this + 12) )
          break;
        if ( result >= 0 )
        {
          v47 = v63;
          v48 = (_BYTE *)v46;
          if ( v63 < *(_DWORD *)(this + 8) )
          {
            v49 = v46 - result - a2;
            do
            {
              if ( v49 >= v65 || v49 >= 1024 )
                break;
              if ( *v48 >= 0xD8u && *v48 < 0xDDu )
              {
                sub_404DD0(
                  *(_DWORD **)(this + 4 * (unsigned __int8)*v48 + 9360),
                  v47,
                  v45,
                  *(_DWORD *)(this + 10192),
                  1,
                  0,
                  0);
                v45 = (int)v61;
                v46 = (int)v62;
              }
              v47 += 16;
              ++v48;
              ++v49;
              result = (int)v59;
            }
            while ( v47 < *(_DWORD *)(this + 8) );
          }
        }
        result += 1024;
        v46 += 1024;
        v45 += 16;
        v59 = (_BYTE *)result;
        v62 = (unsigned __int8 *)v46;
        v61 = (_BYTE *)v45;
      }
      while ( result < 0x100000 );
    }
  }
  return result;
}

//----- (00440150) --------------------------------------------------------
int __thiscall sub_440150(_DWORD *this, char a2)
{
  int result; // eax
  int v4; // edx
  int v5; // ecx

  result = this[30021];
  if ( result && (this[5776] - this[29961] >= 10 || a2) )
  {
    v4 = *this;
    *((_BYTE *)this + 119972) = 50;
    result = (*(int (__thiscall **)(_DWORD *, _DWORD *, int, int))(v4 + 16))(this, this + 29993, 9 * result + 5, 1);
    v5 = this[5776];
    this[30021] = 0;
    this[29961] = v5;
  }
  return result;
}

//----- (004401E0) --------------------------------------------------------
unsigned int __thiscall sub_4401E0(_DWORD *this)
{
  unsigned int result; // eax
  int v3; // [esp+8h] [ebp-10Ch] BYREF
  int v4; // [esp+Ch] [ebp-108h] BYREF
  int v5; // [esp+10h] [ebp-104h] BYREF
  unsigned __int8 v6[256]; // [esp+14h] [ebp-100h] BYREF

  v3 = 256;
  dword_4A7024(v6, &v3);
  v4 = -1;
  sub_401AB0(&v4, v6);
  this[8] = v4;
  v3 = 256;
  dword_4A70A4(v6, &v3);
  v5 = -1;
  result = sub_401AB0(&v5, v6);
  this[14] = v5;
  return result;
}
// 4A70A4: invalid function type has been ignored
// 4A7024: using guessed type int (__stdcall *dword_4A7024)(_DWORD, _DWORD);
// 4A70A4: using guessed type int (__stdcall *dword_4A70A4)(_DWORD, _DWORD);

//----- (00440260) --------------------------------------------------------
int __thiscall sub_440260(_DWORD *this, int a2)
{
  int result; // eax
  int v4; // edx
  unsigned int v5; // ecx
  int *v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  _DWORD *v13; // edi
  int v14; // eax
  _DWORD *v15; // ebp
  int v16; // ecx
  int v17; // eax
  int v18; // edx

  result = this[23];
  this[19] = 0;
  this[10] = -1;
  if ( result != 8 )
  {
    v4 = this[3];
    v5 = 0;
    v6 = (int *)(v4 + 117724);
    while ( 1 )
    {
      v7 = *v6;
      if ( *v6 )
      {
        if ( *(__int16 *)(v7 + 50) == this[6] && !*(_DWORD *)(v7 + 52) )
          break;
      }
      ++v5;
      ++v6;
      if ( v5 >= 8 )
        goto LABEL_9;
    }
    this[10] = v5;
LABEL_9:
    v8 = this[94];
    if ( v8 > 0 )
    {
      v9 = v8 - a2;
      this[94] = v9;
      if ( v9 <= 0 )
      {
        v10 = this[97];
        this[4] = this[96];
        this[5] = v10;
      }
    }
    v11 = this[11];
    if ( v11 > 0 )
      this[11] = v11 - a2;
    v12 = this[81];
    if ( v12 <= 0 )
    {
      v13 = this + 1;
      if ( this[1] == -1 )
      {
        this[19] = 2;
      }
      else
      {
        v14 = *(_DWORD *)(this[3] + 23104) - this[79];
        if ( v14 <= 500 )
        {
          if ( v14 > 300 )
          {
            v15 = (_DWORD *)this[3];
            v16 = this[2];
            if ( *v13 >= v15[359] && *v13 < v15[361] && v16 >= v15[360] && v16 < v15[362] )
            {
              this[19] = 1;
            }
            else
            {
              this[79] = *(_DWORD *)(this[3] + 23104) - 600;
              this[19] = 2;
            }
          }
        }
        else
        {
          this[19] = 2;
        }
      }
      v17 = this[19];
      if ( v17 == 2 || v17 == 1 )
      {
        result = 0;
        this[16] = 0;
        this[11] = 0;
      }
      else
      {
        result = this[16];
        if ( result <= 0 )
        {
          if ( this[7] == -1 )
          {
            if ( *v13 != -1 )
              result = (*(int (__thiscall **)(_DWORD *, int, _DWORD *, _DWORD *, _DWORD *, int))(*this + 48))(
                         this,
                         a2,
                         this + 1,
                         this + 4,
                         this + 96,
                         1);
          }
          else
          {
            result = (*(int (__thiscall **)(_DWORD *))(*this + 32))(this);
          }
        }
        else
        {
          (*(void (__thiscall **)(_DWORD *, int, _DWORD *, _DWORD *, _DWORD *, _DWORD))(*this + 48))(
            this,
            a2,
            this + 1,
            this + 4,
            this + 96,
            0);
          result = this[16] - a2;
          this[16] = result;
          if ( result <= 0 )
          {
            v18 = this[3];
            this[19] = 2;
            this[2] = -1;
            *v13 = -1;
            result = *(_DWORD *)(v18 + 11744);
            this[81] = result;
          }
        }
      }
    }
    else
    {
      result = v12 - a2;
      this[19] = 2;
      this[81] = result;
    }
  }
  return result;
}

//----- (00440440) --------------------------------------------------------
BOOL __usercall sub_440440@<eax>(int a1@<ebx>)
{
  int v1; // ebx
  int v4; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v5 = 0;
  v6 = 0;
  v4 = 9207953;
  if ( !dword_4A7018(-2147483647, off_4B8164[0], &v6) )
  {
    v4 = 4;
    dword_4A7000(v6, 4906336, 0, 0, &v5, &v4);
  }
  if ( v5 < 0x28 )
  {
    v4 = 9208987;
    v1 = dword_4A70DC(4906096);
    if ( dword_4A7348(dword_4C1A38, 104, 0, sub_418F50, 0) )
    {
      ((void (__cdecl *)(int))dword_4A7260)(a1);
      v5 = 40;
      dword_4A701C(v6, 4906336);
      dword_4A7020(v6, 4906336, 0, 4, &v5, 4);
    }
    dword_4A70D4(v1);
  }
  dword_4A702C(v6);
  return v5 >= 0x28;
}
// 440440: could not find valid save-restore pair for ebx
// 4A7000: using guessed type int (__stdcall *dword_4A7000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7018: using guessed type int (__stdcall *dword_4A7018)(_DWORD, _DWORD, _DWORD);
// 4A701C: using guessed type int (__stdcall *dword_4A701C)(_DWORD, _DWORD);
// 4A7020: using guessed type int (__stdcall *dword_4A7020)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A702C: using guessed type int (__stdcall *dword_4A702C)(_DWORD);
// 4A70D4: using guessed type int (__stdcall *dword_4A70D4)(_DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7348: using guessed type int (__stdcall *dword_4A7348)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4B8164: using guessed type char *off_4B8164[17];

//----- (00440530) --------------------------------------------------------
int __thiscall sub_440530(int this, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // esi
  int v6; // edx
  int v7; // edx

  result = *(_DWORD *)(this + 100);
  if ( result != 6 )
  {
    v3 = *(_DWORD *)(this + 116);
    result = 0;
    v4 = *(_DWORD *)(v3 + 6276);
    v5 = (_DWORD *)(v3 + 2180);
    if ( v4 > 0 )
    {
      v6 = *(_DWORD *)(v3 + 4 * a2 + 113620);
      while ( *v5 != v6 )
      {
        ++result;
        ++v5;
        if ( result >= v4 )
        {
          *(_BYTE *)(this + 104) = 1;
          return result;
        }
      }
      if ( result >= 0 )
      {
        v7 = *(_DWORD *)(this + 8);
        if ( v7 > result )
          *(_DWORD *)(this + 8) = v7 - 1;
      }
    }
  }
  *(_BYTE *)(this + 104) = 1;
  return result;
}

//----- (004405D0) --------------------------------------------------------
int __thiscall sub_4405D0(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // ebp
  int i; // edi
  int v7; // [esp+10h] [ebp-A0h]
  char v8[4]; // [esp+14h] [ebp-9Ch] BYREF
  int v9; // [esp+18h] [ebp-98h]
  char v10[148]; // [esp+1Ch] [ebp-94h] BYREF

  sub_421C80(v8, a2);
  v3 = this[3];
  v4 = 0;
  if ( v3 <= 0 )
    return 0;
  v7 = this[1];
  for ( i = v7 + 8; *(_DWORD *)(i - 4) != v9 || strcmp((const char *)i, v10) || *(_BYTE *)(i + 144); i += 156 )
  {
    if ( ++v4 >= v3 )
      return 0;
  }
  return *(_DWORD *)(v7 + 156 * v4 + 144);
}

//----- (00440680) --------------------------------------------------------
int __thiscall sub_440680(char *this, __int16 a2)
{
  int v3; // eax
  int v4; // ecx
  char v6; // [esp+4h] [ebp-4h] BYREF
  __int16 v7; // [esp+5h] [ebp-3h]

  v6 = 15;
  v7 = a2;
  v3 = 2053883039;
  v4 = 247;
  do
    v3 ^= *(_DWORD *)&aSat[4 * v4-- - 642600];
  while ( v4 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v3 + 216080568] + 16))(
           &this[v3 + 216080568],
           &v6,
           3,
           1);
}

//----- (004406E0) --------------------------------------------------------
void __thiscall sub_4406E0(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v6; // ecx
  int v7; // ebx
  int v8; // eax

  v6 = (_DWORD *)this[a5 + 2851];
  v7 = v6[158];
  v8 = v7 * (v6[157] - a4) / v6[157];
  if ( v8 < 0 )
    v8 = 0;
  if ( v8 >= v7 )
    v8 = v7 - 1;
  sub_404E20(v6, a2 - this[4970], a3 - this[4971], v8, 1);
}

//----- (00440740) --------------------------------------------------------
int __thiscall sub_440740(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  int result; // eax
  int v5; // ebx
  _DWORD *v6; // edi
  int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // edx
  _DWORD *v10; // edi
  int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // edx
  _DWORD *v14; // ebp
  int v15; // esi
  unsigned int v16; // edx
  unsigned int v17; // edi
  int v18; // eax
  _DWORD *v19; // edi
  int v20; // esi
  unsigned int v21; // eax
  unsigned int v22; // edx
  int v23; // [esp+1Ch] [ebp+Ch]
  int v24; // [esp+1Ch] [ebp+Ch]
  int v25; // [esp+1Ch] [ebp+Ch]
  int v26; // [esp+1Ch] [ebp+Ch]

  result = this[4];
  v5 = (int)&this[14 * a4 + 13630];
  switch ( result )
  {
    case 1:
      v6 = a2;
      v23 = 7;
      do
      {
        v7 = a3 - *v6;
        if ( v7 < 14 )
        {
          v8 = v6[1] - this[4970];
          v9 = v6[2] - this[4971];
          if ( v8 < this[2] && v9 < this[3] )
            *(_BYTE *)(v8 + this[7] + v9 * this[8]) = *(_BYTE *)(v5 + 4 * v7);
        }
        v6 += 3;
        result = --v23;
      }
      while ( v23 );
      break;
    case 2:
      v10 = a2;
      v24 = 7;
      do
      {
        v11 = a3 - *v10;
        if ( v11 < 14 )
        {
          v12 = v10[1] - this[4970];
          v13 = v10[2] - this[4971];
          if ( v12 < this[2] && v13 < this[3] )
            *(_WORD *)(v13 * this[8] + 2 * v12 + this[7]) = *(_WORD *)(v5 + 4 * v11);
        }
        v10 += 3;
        result = --v24;
      }
      while ( v24 );
      break;
    case 3:
      v14 = a2;
      v25 = 7;
      do
      {
        v15 = a3 - *v14;
        if ( v15 < 14 )
        {
          v16 = v14[1] - this[4970];
          v17 = v14[2] - this[4971];
          if ( v16 < this[2] && v17 < this[3] )
          {
            v18 = this[7] + 3 * v16 + v17 * this[8];
            *(_WORD *)v18 = *(_WORD *)(v5 + 4 * v15);
            *(_BYTE *)(v18 + 2) = BYTE2(*(_DWORD *)(v5 + 4 * v15));
          }
        }
        v14 += 3;
        result = --v25;
      }
      while ( v25 );
      break;
    case 4:
      v19 = a2;
      v26 = 7;
      do
      {
        v20 = a3 - *v19;
        if ( v20 < 14 )
        {
          v21 = v19[1] - this[4970];
          v22 = v19[2] - this[4971];
          if ( v21 < this[2] && v22 < this[3] )
            *(_DWORD *)(v22 * this[8] + 4 * v21 + this[7]) = *(_DWORD *)(v5 + 4 * v20);
        }
        v19 += 3;
        result = --v26;
      }
      while ( v26 );
      break;
  }
  return result;
}

//----- (00440910) --------------------------------------------------------
void __thiscall __noreturn sub_440910(char *this)
{
  void (__stdcall *v2)(_DWORD, int, _DWORD, _DWORD); // edi
  int v3; // eax
  int v4; // edx
  int v5; // [esp+0h] [ebp-3Ch] BYREF
  _DWORD v6[9]; // [esp+Ch] [ebp-30h] BYREF
  int v7; // [esp+38h] [ebp-4h]

  v6[8] = &v5;
  v6[7] = this;
  *((_DWORD *)this + 49388) = sub_4124F0((_DWORD *)this + 49384);
  sub_411DC0((int)this, 0, 0);
  v2 = (void (__stdcall *)(_DWORD, int, _DWORD, _DWORD))dword_4A7364;
  v7 = 0;
  while ( 1 )
  {
    while ( dword_4A737C(v6, 0, 0, 0, 0) )
    {
      if ( !dword_4A7380(v6, 0, 0, 0) )
        goto LABEL_16;
      if ( this[189280] )
      {
        (*(void (__cdecl **)(_DWORD *))(this + 206650))(v6);
      }
      else if ( !dword_4A7388(v6) )
      {
        dword_4A7384(v6);
      }
    }
    if ( this[206846] )
    {
      this[206846] = 0;
      v3 = sub_412170();
      if ( v3 - *((_DWORD *)this + 51710) > 1000 )
      {
        *((_DWORD *)this + 51710) = v3;
        v2(*((_DWORD *)this + 49382), 1024, 0, 0);
      }
    }
    (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)this + 32))(this, 0);
    if ( this[102964] || this[206501] && this[189280] )
    {
LABEL_16:
      v4 = *(_DWORD *)this;
      v7 = -1;
      (*(void (__thiscall **)(char *))(v4 + 8))(this);
      (*(void (__cdecl **)(char *))(this + 206706))(this + 197556);
      (*(void (__thiscall **)(char *))(*((_DWORD *)this + 18939) + 428))(this + 75756);
      JUMPOUT(0x303B4);
    }
    if ( !this[197532] )
      sub_412000((void *)0x14);
  }
}
// 440A7C: control flows out of bounds to 303B4
// 4A7364: using guessed type int dword_4A7364;
// 4A737C: using guessed type int (__stdcall *dword_4A737C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7380: using guessed type int (__stdcall *dword_4A7380)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7384: using guessed type int (__stdcall *dword_4A7384)(_DWORD);
// 4A7388: using guessed type int (__stdcall *dword_4A7388)(_DWORD);

//----- (00441120) --------------------------------------------------------
void __thiscall sub_441120(int this, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v7; // ecx

  if ( a5 >= 0 && a5 <= 7 )
  {
    v7 = *(_DWORD **)(this + 4 * a5 + 11448);
    if ( v7 )
    {
LABEL_11:
      sub_404E20(v7, a2 - *(_DWORD *)(this + 19880), a3 - *(_DWORD *)(this + 19884), a4, 1);
      return;
    }
  }
  switch ( a5 )
  {
    case 8:
      v7 = *(_DWORD **)(this + 11480);
      goto LABEL_10;
    case 9:
      v7 = *(_DWORD **)(this + 11488);
      goto LABEL_10;
    case 10:
      v7 = *(_DWORD **)(this + 11484);
LABEL_10:
      if ( !v7 )
        return;
      goto LABEL_11;
    case 11:
      sub_404E20(*(_DWORD **)(this + 11428), a2 - *(_DWORD *)(this + 19880), a3 - *(_DWORD *)(this + 19884), a4, 1);
      break;
    case 12:
      sub_404E20(*(_DWORD **)(this + 11496), a2 - *(_DWORD *)(this + 19880), a3 - *(_DWORD *)(this + 19884), a4, 1);
      break;
    case 13:
      sub_404E20(*(_DWORD **)(this + 11512), a2 - *(_DWORD *)(this + 19880), a3 - *(_DWORD *)(this + 19884), a4, 1);
      break;
    case 14:
      sub_404E20(*(_DWORD **)(this + 11500), a2 - *(_DWORD *)(this + 19880), a3 - *(_DWORD *)(this + 19884), a4, 1);
      break;
  }
}

//----- (00441270) --------------------------------------------------------
int __thiscall sub_441270(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // edi
  int result; // eax

  v1 = this + 2586;
  v2 = 256;
  do
  {
    if ( *v1 )
      result = (*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)*v1 + 8))(*v1, 1);
    *v1++ = 0;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (004413D0) --------------------------------------------------------
int __thiscall sub_4413D0(_DWORD *this, char a2)
{
  int (__stdcall *v3)(_DWORD, int, int, int); // ebx
  int i; // esi
  int result; // eax
  int (__stdcall *v6)(_DWORD, int); // ebx
  int j; // esi

  if ( a2 )
  {
    v3 = (int (__stdcall *)(_DWORD, int, int, int))dword_4A7340;
    for ( i = 0; i < 16; ++i )
      result = v3(this[49382], i, i, 44);
  }
  else
  {
    v6 = (int (__stdcall *)(_DWORD, int))dword_4A7344;
    for ( j = 0; j < 16; ++j )
      result = v6(this[49382], j);
  }
  return result;
}
// 4A7340: using guessed type int dword_4A7340;
// 4A7344: using guessed type int dword_4A7344;

//----- (00441550) --------------------------------------------------------
int __thiscall sub_441550(_DWORD *this, int a2, int a3)
{
  _BYTE *v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v9; // [esp+0h] [ebp-ACh] BYREF
  char Buffer[128]; // [esp+Ch] [ebp-A0h] BYREF
  _DWORD *v11; // [esp+8Ch] [ebp-20h]
  int v12; // [esp+90h] [ebp-1Ch]
  int v13; // [esp+94h] [ebp-18h]
  int v14[2]; // [esp+98h] [ebp-14h] BYREF
  int v15; // [esp+A8h] [ebp-4h]
  int savedregs; // [esp+ACh] [ebp+0h] BYREF

  v14[1] = (int)&v9;
  v11 = this;
  v15 = 1;
  v14[0] = -1;
  sub_407E80(v14, (int)&savedregs, (char *)(a2 + 1), 1, 3);
  v12 = sub_408270(v14);
  v4 = (_BYTE *)sub_40B720((int)&savedregs, v12 + 18);
  ReadScrty1FileOffset(v14, (int)(v4 + 17), v12);
  sub_4087F0(v14);
  v13 = 9279297;
  sprintf_0(Buffer, (const char *const)(9279297 - (_DWORD)&loc_42B9B1), a2 + 1);
  sub_46CAB0((unsigned int)(v4 + 1), (_BYTE *)(a2 + 257), 0x10u);
  *v4 = 22;
  v5 = 673895381;
  v6 = 118;
  do
    v5 ^= (unsigned int)*(&off_4AE630 + v6-- - 140766);
  while ( v6 );
  (*(void (__thiscall **)(int, _BYTE *, int, int))(*(_DWORD *)((char *)this + v5 + 269527632) + 44))(
    (int)this + v5 + 269527632,
    v4,
    v12 + 17,
    1);
  sub_40B7E0((unsigned int)v4);
  LOBYTE(v15) = 0;
  sub_4087F0(v14);
  v7 = this[27905];
  v15 = -1;
  return (*(int (__thiscall **)(_DWORD *, char *, _DWORD, _DWORD, _DWORD, int))(v7 + 28))(
           this + 27905,
           Buffer,
           0,
           0,
           0,
           1);
}
// 4AE630: using guessed type int (__stdcall *off_4AE630)(char);

//----- (004416C0) --------------------------------------------------------
int __thiscall sub_4416C0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ecx

  result = this[16];
  if ( result <= 0 )
  {
    result = this[192];
    if ( result <= 0 && this[1] != -1 )
    {
      result = (*(int (__thiscall **)(_DWORD, int, int))(*(_DWORD *)this[3] + 304))(this[3], a2, a3);
      v5 = result;
      if ( result )
      {
        v6 = 201534631;
        v7 = 169;
        do
          v6 ^= *(_DWORD *)&aSDD[4 * v7-- - 389012];
        while ( v7 );
        (*(void (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)((char *)this + v6 + 2001564) + 336))(
          *(_DWORD *)((char *)this + v6 + 2001564),
          a2,
          a3,
          v5);
        result = (*(int (__thiscall **)(_DWORD *, int, _DWORD, _DWORD, _DWORD))(*this + 36))(this, v5, 0, 0, 0);
      }
    }
  }
  return result;
}

//----- (00441740) --------------------------------------------------------
void __thiscall sub_441740(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi
  signed int v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // eax

  v6 = this[542];
  if ( v6 )
  {
    v7 = abs32(a3 - *(_DWORD *)(v6 + 4));
    v8 = abs32(a4 - *(_DWORD *)(v6 + 8));
    if ( v7 >= v8 )
      v8 = v7;
    if ( v8 <= 800000 )
    {
      if ( v8 >= 16000 )
      {
        (*(void (__thiscall **)(int, int, int, int, int))(*(_DWORD *)a2 + 24))(
          a2,
          a3 / 1000,
          a4 / 1000,
          a5 / 10,
          a6 / 10);
      }
      else if ( this[2974] )
      {
        v9 = this[2974];
        v10 = rand();
        (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)a2 + 20))(
          a2,
          0,
          0,
          0,
          v10 % (2 * v9) - v9);
      }
      else
      {
        (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)a2 + 20))(a2, 0, 0, 0, 0);
      }
    }
  }
}

//----- (00441840) --------------------------------------------------------
int __thiscall sub_441840(int this)
{
  int result; // eax
  int v3; // ecx
  int v4; // ecx
  int v5; // eax
  int *v6; // ebx
  int v7; // ecx
  int v8; // esi
  _DWORD *v9; // eax
  int v10; // [esp+4h] [ebp-14h]
  int v11; // [esp+8h] [ebp-10h]
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]

  result = *(_DWORD *)(this + 1208);
  if ( *(_BYTE *)(result + 8043) && *(_DWORD *)(this + 10256) )
  {
    if ( *(_BYTE *)(this + 75368) )
    {
      v4 = *(_DWORD *)(this + 8);
      v5 = 4 * v4 / 24 * (*(_DWORD *)(result + 7999) != 0 ? 8 : 6) / 8;
      v11 = v4 - v5 - 6;
      v3 = *(_DWORD *)(this + 12) - v5 - 6;
    }
    else
    {
      v3 = *(_DWORD *)(this + 12);
      v11 = *(_DWORD *)(this + 8);
    }
    v12 = v11 - 6;
    v13 = v3 - 6;
    v6 = (int *)(this + 1220);
    v10 = 150;
    do
    {
      if ( *v6 >= 0 )
      {
        v7 = *(_DWORD *)(this + 8) / 2 + 10 * (*(v6 - 2) - *(_DWORD *)(this + 10184)) / 25;
        v8 = *(_DWORD *)(this + 12) / 2 + 10 * (*(v6 - 1) - *(_DWORD *)(this + 10188)) / 25;
        v9 = *(_DWORD **)(this + 4 * *v6 + 10256);
        if ( (int)v9[153] >= 16 || v7 < v12 || v8 < v13 )
          sub_404B80(v9, v7, v8, 0, 1);
      }
      v6 += 3;
      result = --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (004419A0) --------------------------------------------------------
int __thiscall sub_4419A0(_DWORD *this, _DWORD *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // ebp
  int v6; // ecx
  int v7; // ebx
  char v8; // cl
  int v9; // eax
  int v10; // esi
  int v11; // edx
  _DWORD *v12; // edi
  _DWORD *v14; // [esp+10h] [ebp-4h]
  int v15; // [esp+24h] [ebp+10h]

  v5 = this;
  v6 = this[18806];
  *a2 = a4;
  v14 = v5;
  v15 = a5 - v6;
  v7 = 1;
  if ( (int)(v5[18806] * strlen((const char *)a4)) > v15 )
  {
    v8 = *(_BYTE *)(a4 + 1);
    v9 = a4 + 1;
    v10 = 0;
    v11 = 1;
    if ( v8 )
    {
      v12 = a2 + 1;
      while ( 1 )
      {
        if ( v8 == 32 )
          v10 = v9;
        if ( v5[18806] * v11 > v15 )
        {
          if ( v10 )
            v9 = v10 + 1;
          v10 = 0;
          *v12 = v9;
          ++v7;
          ++v12;
          v11 = 0;
          --v9;
          if ( v7 >= a3 )
            break;
        }
        v8 = *(_BYTE *)(v9 + 1);
        ++v11;
        ++v9;
        if ( !v8 )
          break;
        v5 = v14;
      }
    }
  }
  return v7;
}

//----- (00441AE0) --------------------------------------------------------
int __thiscall sub_441AE0(int *this, int a2)
{
  int result; // eax
  int v4; // ecx
  __int16 v5; // cx
  int v6; // eax

  result = -1737748246;
  v4 = 240;
  do
    result ^= *(_DWORD *)&aC256s[4 * v4-- - 529732];
  while ( v4 );
  v5 = a2;
  if ( *(int *)((char *)this + result + 286047972) != a2 )
  {
    v6 = *this;
    this[28053] = a2;
    *(_WORD *)((char *)&a2 + 1) = v5;
    LOBYTE(a2) = 8;
    result = (*(int (__thiscall **)(int *, int *, int, int))(v6 + 16))(this, &a2, 3, 1);
  }
  return result;
}

//----- (00441B30) --------------------------------------------------------
int __thiscall sub_441B30(int this, int a2)
{
  int result; // eax
  int v3; // ebp
  int v4; // edi
  int v5; // esi
  char *i; // eax
  char v7; // dl

  result = *(_DWORD *)(this + 28);
  if ( *(_DWORD *)(result + 120528) )
  {
    result = *(_DWORD *)(this + 20);
    v3 = *(_DWORD *)(this + 12);
    *(_BYTE *)(this + 32) = 0;
    if ( v3 < result )
    {
      v4 = v3 << 10;
      do
      {
        v5 = *(_DWORD *)(this + 8);
        for ( i = (char *)(v5 + v4 + *(_DWORD *)(*(_DWORD *)(this + 28) + 120528)); v5 < *(_DWORD *)(this + 16); ++i )
        {
          v7 = *i;
          if ( !*i || v7 == -4 || v7 == -3 )
            *i = a2;
          ++v5;
        }
        result = *(_DWORD *)(this + 20);
        ++v3;
        v4 += 1024;
      }
      while ( v3 < result );
    }
    if ( a2 )
      result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(*(_DWORD *)(this + 28) + 2168) + 160))(*(_DWORD *)(*(_DWORD *)(this + 28) + 2168));
  }
  return result;
}

//----- (00441BC0) --------------------------------------------------------
char __thiscall sub_441BC0(int *this, unsigned int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char result; // al
  char Buffer[64]; // [esp+8h] [ebp-40h] BYREF

  (*(void (__thiscall **)(int *, _DWORD))(*this + 384))(this, *(_DWORD *)(a2 + 24));
  v3 = this[1569];
  if ( v3 >= 1024 )
  {
    sub_40B7E0(a2);
  }
  else
  {
    this[v3 + 545] = a2;
    v4 = this[1569] + 1;
    this[1569] = v4;
  }
  this[*(_DWORD *)(a2 + 24) + 28405] = a2;
  *((_BYTE *)this + 112452) = 1;
  if ( *(_BYTE *)(a2 + 156) )
  {
    v5 = this[1569];
    *((_BYTE *)this + 112452) = 1;
    v4 = v5 - 1;
    this[28089] = v4;
    this[28118] = v4;
  }
  if ( this[354] == 5 )
  {
    v4 = *(_DWORD *)(this[5775] + 8019);
    if ( v4 == 1 )
    {
      v4 = (*(int (**)(int *, int, int, char *, ...))(*this + 388))(this, 400, 2, aSEnteredArena, a2 + 109);
    }
    else if ( v4 == 2 )
    {
      sprintf_0(Buffer, (const char *const)(9309800 - ((_DWORD)&loc_4330BF + 5)), a2 + 109);
      v4 = (*(int (__thiscall **)(int *, char *, _DWORD, _DWORD, _DWORD, int))(this[27905] + 28))(
             this + 27905,
             Buffer,
             0,
             0,
             0,
             1);
    }
  }
  result = *((_BYTE *)this + 113524);
  if ( result )
  {
    LOBYTE(v4) = *(_BYTE *)(a2 + 156);
    result = (*(int (__cdecl **)(unsigned int, _DWORD, _DWORD, int, int))(this[5775] + 9114))(
               a2 + 109,
               *(_DWORD *)(a2 + 88),
               *(_DWORD *)(a2 + 92),
               v4,
               v4);
  }
  return result;
}
// 441CE3: variable 'v4' is possibly undefined

//----- (00441D00) --------------------------------------------------------
void __thiscall sub_441D00(_DWORD *this, int a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  char Buffer[32]; // [esp+8h] [ebp-24h] BYREF
  int v9; // [esp+28h] [ebp-4h]

  if ( a3 > 0 )
  {
    v5 = this[18807];
    v9 = 16;
    if ( v5 > 16 )
      v9 = v5;
    sub_404DD0((_DWORD *)this[a2 + 2887], this[2] - 16, a2 * v9 + 77, this[2548], 1, 0, 0);
    if ( a4 )
      sprintf_0(Buffer, aD_2, a3);
    else
      sprintf_0(Buffer, aDD, a3 / 100, a3 / 10 % 10);
    v6 = *this;
    v7 = (*(int (__thiscall **)(_DWORD *, char *, int, char *, int, int, int))(*this + 224))(
           this,
           Buffer,
           v9 * (a2 + 1) - this[18807] + 77,
           Buffer,
           (a2 != 2) + 3,
           -1,
           1);
    (*(void (__thiscall **)(_DWORD *, int))(v6 + 236))(this, this[2] - v7 - 16);
  }
}

//----- (00441E20) --------------------------------------------------------
_DWORD *__thiscall sub_441E20(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // ebx
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *result; // eax
  _DWORD *v9; // ecx
  int v10; // edi
  int v11; // ecx
  int v12; // edi
  int v13; // eax
  int *v14; // esi
  int v15; // edx

  (*(void (__thiscall **)(_DWORD *, int))(*this + 212))(this, a2);
  v4 = (_DWORD *)this[a2 + 28405];
  if ( v4 )
  {
    v4[22] = (*(int (__thiscall **)(_DWORD *, int))(*this + 152))(this, a3);
    v5 = dword_4C1AE4;
    v4[13] = dword_4C1AE4;
    v4[12] = -v5;
    if ( *((_BYTE *)this + 113524) )
      (*(void (__cdecl **)(int, _DWORD, _DWORD))(this[5775] + 9122))((int)v4 + 109, v4[22], v4[23]);
  }
  v6 = 0;
  v7 = &loc_44E4C0;
  do
    v6 -= *v7++;
  while ( v7 < (_DWORD *)&loc_44E868 );
  result = (_DWORD *)(v6 + 580823999);
  *((_BYTE *)this + (_DWORD)result + 296785884) = 1;
  v9 = (_DWORD *)this[542];
  if ( v9[7] == a2 )
    result = (_DWORD *)(*(int (__thiscall **)(_DWORD *, int))(*v9 + 84))(v9, -1);
  if ( a2 == this[1876] )
  {
    (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)this[542] + 84))(this[542], -1);
    result = (_DWORD *)(this[542] + 612);
    v10 = a3 - (dword_4C1AE4 - a3);
    dword_4C1AE4 -= a3;
    result[1] = dword_4C1AE4;
    *result = v10;
    v11 = this[542];
    if ( *(_DWORD *)(v11 + 92) != 8 )
    {
      if ( (*(_BYTE *)(v11 + 96) & 0x20) != 0 )
      {
        *(_DWORD *)(v11 + 808) = 0;
      }
      else
      {
        (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 56))(v11);
        v12 = *(_DWORD *)this[542];
        v13 = rand();
        result = (_DWORD *)(*(int (__thiscall **)(_DWORD, int, int, int))(v12 + 152))(this[542], v13, -1, -1);
      }
      v14 = (int *)(this[542] + 520);
      v15 = -dword_4C1AE4;
      v14[1] = dword_4C1AE4;
      *v14 = v15;
    }
  }
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00441F60) --------------------------------------------------------
int __thiscall sub_441F60(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebx
  int result; // eax

  v3 = this[23];
  v4 = this[3];
  v5 = v4 + 1308 * v3 + 12508;
  (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(*(_DWORD *)(v4 + 120076) + 304) + 20))(
    *(_DWORD *)(*(_DWORD *)(v4 + 120076) + 304),
    0,
    0,
    0,
    0);
  v6 = this[3];
  this[205] = *(_DWORD *)(v5 + 112);
  (*(void (__thiscall **)(int, _DWORD, _DWORD))(*(_DWORD *)v6 + 424))(
    v6,
    *(unsigned __int8 *)(a2 + 41),
    *(_DWORD *)(a2 + 52));
  v7 = 0;
  v8 = (_DWORD *)((char *)&loc_42B003 + 1);
  do
    v7 -= *v8++;
  while ( v8 < (_DWORD *)&loc_42B3C4 );
  result = v7 - 1444525245;
  *(_DWORD *)((char *)this + result + 2214288) = *(_DWORD *)(v5 + 448);
  this[129] = 200;
  return result;
}

//----- (00442040) --------------------------------------------------------
char __thiscall sub_442040(_DWORD *this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *i; // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // eax

  v2 = this[137];
  if ( *(_BYTE *)(v2 + 113524) )
  {
    v3 = this[66];
    if ( *(_BYTE *)(v3 + 8944) )
    {
      *(_BYTE *)(v3 + 8944) = 0;
      (*(void (__cdecl **)(_DWORD *))(this[66] + 9142))(this + 73);
      if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 32))(this) )
      {
        v4 = 0;
        for ( i = (_DWORD *)(&loc_4233BF + 1); (unsigned int)i < 0x423764; ++i )
          v4 -= *i;
        (*(void (__cdecl **)(_DWORD *))(*(_DWORD *)((char *)this + v4 + 389047440) + 9146))(this + 73);
      }
    }
    LOBYTE(v2) = *(_BYTE *)(this[66] + 8668);
    if ( (_BYTE)v2 )
    {
      v2 = (*(int (__thiscall **)(_DWORD *))(*this + 20))(this);
      v6 = this[66];
      v7 = v6 + 8694;
      if ( *(_BYTE *)(v6 + 8694) )
      {
        if ( v2 < 0 )
          v8 = 0;
        else
          v8 = *(_DWORD *)(this[137] + 4 * v2 + 2180);
        LOBYTE(v6) = *(_BYTE *)(v6 + 8669);
        LOBYTE(v2) = (*(int (__thiscall **)(_DWORD *, int, int, int))(*this + 44))(this, v7, v8, v6);
      }
      *(_BYTE *)(this[66] + 8668) = 0;
    }
  }
  return v2;
}

//----- (00442120) --------------------------------------------------------
int __thiscall sub_442120(int this, _DWORD *a2)
{
  int v2; // ebx
  int v3; // eax
  char v4; // cl
  int v5; // eax
  int v6; // edi
  int result; // eax
  int v8; // ebp
  _BYTE *v9; // ebx
  char v10; // al
  int v11; // eax
  int v12; // eax
  int v13; // ebp
  char *v14; // ebx
  int v15; // eax
  int v16; // ebp
  _DWORD *v17; // ebp
  int v18; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  char v23; // [esp+4Eh] [ebp-1FAh]
  bool v24; // [esp+4Fh] [ebp-1F9h]
  char *v25; // [esp+50h] [ebp-1F8h]
  int v26; // [esp+50h] [ebp-1F8h]
  int v27; // [esp+54h] [ebp-1F4h]
  int v28; // [esp+54h] [ebp-1F4h]
  int v30; // [esp+5Ch] [ebp-1ECh]
  int v31; // [esp+60h] [ebp-1E8h]
  int v32; // [esp+64h] [ebp-1E4h]
  char *Str; // [esp+68h] [ebp-1E0h]
  int v34; // [esp+6Ch] [ebp-1DCh]
  int v35; // [esp+70h] [ebp-1D8h]
  char Buffer[4]; // [esp+78h] [ebp-1D0h] BYREF
  int v37; // [esp+7Ch] [ebp-1CCh]
  int v38; // [esp+B4h] [ebp-194h]
  _DWORD v39[100]; // [esp+B8h] [ebp-190h] BYREF

  v2 = this;
  v3 = *(_DWORD *)(this + 548);
  v4 = *(_BYTE *)(v3 + 1869);
  if ( v4 )
    v27 = *(_DWORD *)(v3 + 28252) / a2[18807] - 10;
  else
    v27 = *(_DWORD *)(*(_DWORD *)(v2 + 264) + 8035);
  if ( v4 )
  {
    a2[18823] = -1;
    a2[18822] = -1;
  }
  else
  {
    v5 = a2[3] - a2[18807];
    a2[18822] = 0;
    a2[18823] = v5;
  }
  v31 = *(_DWORD *)(v2 + 280) + 292 * *(_DWORD *)(v2 + 288);
  v6 = a2[3] - a2[18807];
  v35 = (*(int (__thiscall **)(_DWORD *))(*a2 + 228))(a2);
  result = *(_DWORD *)(v2 + 288);
  v32 = v27;
  v8 = a2[18806] * (*(_DWORD *)(*(_DWORD *)(v2 + 264) + 8031) + 2);
  v34 = v8;
  v28 = result;
  if ( result != -1 )
  {
    while ( 1 )
    {
      if ( !v32 )
        return result;
      v24 = result >= *(_DWORD *)(v2 + 288);
      if ( result < *(_DWORD *)(v2 + 288) )
        break;
      v25 = (char *)(v2 + 292);
      if ( *(_BYTE *)(v2 + 292) || *(_BYTE *)(v2 + 580) )
      {
        v9 = sub_40BCF0((_BYTE *)(v2 + 292));
        v10 = *v9;
        if ( *v9 == 39 )
          goto LABEL_21;
        if ( v10 == 47 )
        {
          if ( v9[1] != 47 )
            goto LABEL_20;
LABEL_21:
          v30 = 4;
          Str = v25;
          v23 = 0;
LABEL_27:
          v12 = v35;
LABEL_28:
          v13 = (*(int (__thiscall **)(_DWORD *, _DWORD *, int, char *, int))(*a2 + 232))(a2, v39, 100, Str, v12);
          v14 = strchr(Str, 0);
          if ( v24 && v13 )
          {
            v15 = (*(int (__thiscall **)(_DWORD *, _DWORD, int, int))(*a2 + 224))(a2, *(&v38 + v13), v6, 1);
            (*(void (__thiscall **)(_DWORD *, int))(this + 240))(a2, v15 + v37 + 1);
          }
          v16 = v13 - 1;
          v26 = v16;
          if ( v16 >= 0 )
          {
            v17 = &v39[v16];
            do
            {
              if ( !v32 )
                break;
              if ( v23 && *(_BYTE *)(v31 + 256) )
              {
                sprintf_0(
                  Buffer,
                  "%*.*s> ",
                  *(_DWORD *)(*(_DWORD *)(this + 264) + 8031),
                  *(_DWORD *)(*(_DWORD *)(this + 264) + 8031),
                  (const char *)(v31 + 256));
                v18 = 1;
                if ( *(_DWORD *)(v31 + 288) != 4 )
                  v18 = v30;
                v19 = *(_DWORD *)(this + 264);
                LOBYTE(v19) = *(_BYTE *)(v19 + 8057) == 0;
                (*(void (__thiscall **)(_DWORD *, _DWORD, int, char *, int, int, int))(*a2 + 236))(
                  a2,
                  0,
                  v6,
                  Buffer,
                  v18,
                  -1,
                  v19);
              }
              if ( v14 > Str && *(v14 - 1) == 32 )
                --v14;
              v20 = *(_DWORD *)(this + 264);
              LOBYTE(v20) = *(_BYTE *)(v20 + 8057) == 0;
              (*(void (__thiscall **)(_DWORD *, int, int, _DWORD, int, char *, int))(*a2 + 236))(
                a2,
                v23 != 0 ? v34 : 0,
                v6,
                *v17,
                v30,
                &v14[-*v17],
                v20);
              v14 = (char *)*v17;
              v21 = a2[18807];
              a2[18823] = v6;
              --v17;
              v6 -= v21;
              --v26;
              --v32;
            }
            while ( v26 >= 0 );
          }
          v2 = this;
          v8 = v34;
          result = v28;
          goto LABEL_44;
        }
        if ( v10 == 58 && strchr(v9 + 1, 58) )
        {
LABEL_20:
          v30 = 1;
          Str = v25;
          v23 = 0;
          goto LABEL_27;
        }
        Str = v25;
        v30 = *v9 != 59 ? 0 : 6;
        goto LABEL_19;
      }
LABEL_44:
      v31 -= 292;
      v22 = result--;
      v28 = result;
      if ( !v22 )
        return result;
    }
    Str = (char *)v31;
    v11 = *(_DWORD *)(v31 + 288);
    v30 = dword_4AB150[v11];
    if ( v11 && v11 != 7 && v11 != 9 && v11 != 8 )
    {
      v23 = 1;
      v12 = v35 - v8;
      goto LABEL_28;
    }
LABEL_19:
    v23 = 0;
    goto LABEL_27;
  }
  return result;
}

//----- (004424E0) --------------------------------------------------------
int __thiscall sub_4424E0(_DWORD *this, int a2)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int i; // edi
  int v7; // [esp+10h] [ebp-A0h]
  char v8[4]; // [esp+14h] [ebp-9Ch] BYREF
  int v9; // [esp+18h] [ebp-98h]
  char v10[148]; // [esp+1Ch] [ebp-94h] BYREF

  result = (int)sub_421C80(v8, a2);
  v4 = this[3];
  v5 = 0;
  if ( v4 > 0 )
  {
    v7 = this[1];
    for ( i = v7 + 8; ; i += 156 )
    {
      result = v9;
      if ( *(_DWORD *)(i - 4) == v9 )
      {
        result = strcmp((const char *)i, v10);
        if ( !result )
        {
          result = *(unsigned __int8 *)(i + 144);
          if ( !(_BYTE)result )
            break;
        }
      }
      if ( ++v5 >= v4 )
        return result;
    }
    result = v7;
    *(_BYTE *)(v7 + 156 * v5 + 152) = 1;
  }
  return result;
}

//----- (00442590) --------------------------------------------------------
char __thiscall sub_442590(_DWORD *this, char *a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  char *v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // ebp
  unsigned __int16 *v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  __int16 v12; // ax
  int v13; // edi
  _BYTE *v14; // eax
  int v15; // eax
  _DWORD *v16; // esi
  int v17; // ebp
  unsigned int v20; // [esp-14h] [ebp-68h]
  int v22; // [esp+14h] [ebp-40h]
  int v23; // [esp+18h] [ebp-3Ch]
  _DWORD v24[7]; // [esp+1Ch] [ebp-38h] BYREF
  char v25[28]; // [esp+38h] [ebp-1Ch] BYREF
  _DWORD *i; // [esp+5Ch] [ebp+8h]

  v3 = this;
  if ( a3 < 0xC )
    return 0;
  v4 = a2;
  if ( *(_DWORD *)a2 != 827739203 && *(_DWORD *)a2 != 844516419 )
    return 0;
  v5 = *((_DWORD *)a2 + 2);
  if ( v5 >= 0x100 || !v5 )
    return 0;
  v6 = 0;
  v23 = v3[1912];
  v7 = (unsigned __int16 *)&a2[10 * *((_DWORD *)a2 + 1) + 12];
  while ( (int)v3[1912] < 256 )
  {
    if ( (char *)v7 - v4 + 7 >= a3 || !memchr(v7 + 3, 0, v4 - (char *)v7 + a3 - 6) )
      return 0;
    v8 = v3[1912];
    v3[1912] = v8 + 1;
    (*(void (__thiscall **)(_DWORD, int, unsigned __int16 *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v3[29429] + 120))(
      v3[29429],
      v8,
      v7 + 3,
      *v7,
      v7[1],
      v7[2]);
    v3 = this;
    v7 = (unsigned __int16 *)(strchr((const char *)v7 + 6, 0) + 1);
    ++v6;
    v4 = a2;
    if ( v6 >= *((_DWORD *)a2 + 2) )
      break;
  }
  v22 = 0;
  if ( *((_DWORD *)v4 + 1) )
  {
    for ( i = v4 + 12; ; i = (_DWORD *)((char *)i + 10) )
    {
      v24[3] = *i;
      v24[4] = i[1];
      LOWORD(v24[5]) = *((_WORD *)i + 4);
      v24[6] = v23;
      BYTE2(v24[4]) += v23;
      if ( BYTE2(v24[4]) < (int)v3[1912] && HIBYTE(v24[4]) < 8u )
      {
        v9 = *(_DWORD *)(v3[29429] + 4 * BYTE2(v24[4]) + 10344);
        if ( v9 )
        {
          v10 = *(_DWORD *)(v9 + 612);
          v11 = *(_DWORD *)(v9 + 616);
        }
        else
        {
          v10 = 0;
          v11 = 0;
        }
        v24[0] = v10;
        v24[1] = v11;
        if ( v10 )
        {
          if ( v11 )
            break;
        }
      }
LABEL_43:
      if ( (unsigned int)++v22 >= *((_DWORD *)v4 + 1) )
        return 1;
    }
    if ( *(_DWORD *)v4 == 827739203 && (v24[3] & 1) == 0 )
    {
      if ( SHIWORD(v24[3]) <= 15000 )
      {
        if ( v24[3] >= 0 )
          HIWORD(v24[3]) *= 16;
        else
          HIWORD(v24[3]) = (16 * HIWORD(v24[3])) | 2;
      }
      else
      {
        HIWORD(v24[3]) = (16 * (HIWORD(v24[3]) + 480)) | 1;
      }
      if ( SLOWORD(v24[4]) > 15000 )
      {
        v12 = 16 * (LOWORD(v24[4]) + 480);
        LOBYTE(v12) = (16 * (LOBYTE(v24[4]) - 32)) | 1;
LABEL_32:
        LOWORD(v24[4]) = v12;
        goto LABEL_33;
      }
      if ( SLOWORD(v24[4]) >= 0 )
      {
        v12 = 16 * LOWORD(v24[4]);
        goto LABEL_32;
      }
      LOWORD(v24[4]) = (16 * LOWORD(v24[4])) | 2;
    }
LABEL_33:
    v13 = v3[27547];
    v24[2] = 0;
    if ( v13 )
    {
      v14 = (_BYTE *)(v3[27545] + 28 * v13 - 9);
      do
      {
        if ( *v14 <= HIBYTE(v24[4]) )
          break;
        --v13;
        v14 -= 28;
      }
      while ( v13 );
    }
    v15 = v3[27547];
    v16 = v3 + 27545;
    if ( v15 >= v3[27546] )
    {
      if ( v15 >= 8 )
        v17 = v15 >= 32 ? 32 : 8;
      else
        v17 = 4;
      sub_40B780(28 * (v17 + v15), (void **)v3 + 27545, v17);
      v3[27546] += v17;
    }
    sub_46CAB0(*v16 + 28 * (v13 + 1), (_BYTE *)(*v16 + 28 * v13), 28 * v3[27547] - 28 * v13);
    v20 = 28 * v13 + *v16;
    ++v3[27547];
    sub_46CAB0(v20, v25, 0x1Cu);
    v4 = a2;
    qmemcpy((void *)(28 * v13 + *v16), v24, 0x1Cu);
    goto LABEL_43;
  }
  return 1;
}
// 4425F1: conditional instruction was optimized away because of 'ecx.4 in (1..FF)'

//----- (00442900) --------------------------------------------------------
unsigned int __thiscall sub_442900(_DWORD *this, char a2)
{
  unsigned int result; // eax

  result = this[89];
  if ( result < 0x100 )
  {
    *((_BYTE *)this + result + 99) = a2;
    result = this[89] + 1;
    this[89] = result;
  }
  return result;
}

//----- (00442930) --------------------------------------------------------
int __thiscall sub_442930(_DWORD *this)
{
  _DWORD *v1; // edi
  _DWORD *v2; // esi
  int i; // ebx
  int result; // eax
  int v5; // edi
  _DWORD *v6; // esi
  int v8; // [esp+10h] [ebp-4h]

  sub_40DA80((char *)(9379183 - (_DWORD)sub_443FA7));
  v1 = &unk_4AAC68;
  v8 = 34;
  do
  {
    v2 = (_DWORD *)((char *)this + *(v1 - 2));
    for ( i = 0; i < *v1; ++v2 )
    {
      if ( *v2 )
        (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v2 + 4))(*v2, 0);
      ++i;
    }
    v1 += 3;
    result = --v8;
  }
  while ( v8 );
  v5 = 5;
  v6 = this + 17;
  do
  {
    if ( *v6 )
      result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v6 + 4))(*v6, 0);
    v6 += 3;
    --v5;
  }
  while ( v5 );
  return result;
}
// 443FA7: using guessed type int __stdcall sub_443FA7(int, int);

//----- (004429C0) --------------------------------------------------------
int __thiscall sub_4429C0(_DWORD *this, char a2)
{
  int result; // eax
  int v4; // edi
  long double v5; // st7
  double v6; // st6
  __int64 v7; // rax
  int v8; // edx
  int v9; // ecx
  int v10; // ebx

  result = this[10];
  if ( result >= 0 )
  {
    v4 = this[3];
    v5 = (double)(this[15] / 1000) * dbl_4AC920;
    v6 = (double)*(int *)(v4 + 1308 * this[23] + 13012);
    v7 = (__int64)(sin(v5) * v6);
    v8 = this[5] - (__int64)(cos(v5) * v6);
    v9 = v7 + this[4];
    v10 = v8;
    if ( !a2 )
    {
      v9 = -v9;
      v10 = -v8;
      this[129] = 150;
    }
    (*(void (__thiscall **)(int, int, int, int, int, _DWORD, _DWORD))(*(_DWORD *)v4 + 204))(
      v4,
      this[1] / 1000,
      this[2] / 1000,
      v9,
      v10,
      this[10],
      this[6]);
    result = this[3];
    *(_DWORD *)(*(_DWORD *)(result + 4 * this[10] + 117724) + 64) = this[6];
    this[10] = -1;
  }
  return result;
}
// 4AC920: using guessed type double dbl_4AC920;

//----- (00442AD0) --------------------------------------------------------
int __thiscall sub_442AD0(void *this, _BYTE *a2, char a3)
{
  int v3; // esi
  _BYTE *v4; // eax
  char *v5; // ebx
  const char *v6; // edi
  const char *v7; // edi
  unsigned int v8; // kr04_4
  const char *v9; // esi
  char *v10; // edi
  char v11; // al
  int v12; // eax
  int v13; // eax
  _DWORD *i; // ebx
  char v15; // cl
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // edi
  int v20; // edx
  int v21; // eax
  int v22; // edx
  char v24; // [esp+Ch] [ebp-40h] BYREF
  char v25[31]; // [esp+Dh] [ebp-3Fh] BYREF
  _WORD v26[13]; // [esp+2Ch] [ebp-20h] BYREF
  char v27; // [esp+46h] [ebp-6h]
  int v28; // [esp+48h] [ebp-4h]
  char *v29; // [esp+54h] [ebp+8h]

  v3 = (int)this;
  v28 = (int)this;
  v4 = sub_40BCF0(a2);
  strncpyt(&v24, v4, 32);
  sub_40BD10(&v24);
  v5 = &v24;
  if ( v24 )
  {
    v6 = v25;
    v29 = v25;
    do
    {
      if ( !isalnum(*v5) && (*v5 != 35 || v6 != v25) )
      {
        v8 = strlen(v6) + 1;
        v7 = &v6[v8];
        v9 = &v7[-v8];
        qmemcpy(v5, &v7[-v8], 4 * (v8 >> 2));
        v10 = &v5[4 * (v8 >> 2)];
        --v5;
        qmemcpy(v10, &v9[4 * (v8 >> 2)], v8 & 3);
        v3 = v28;
        v6 = v29 - 1;
      }
      v11 = *++v5;
      v29 = (char *)++v6;
    }
    while ( v11 );
  }
  memset(v26, 0, 0x18u);
  v26[12] = 0;
  v27 = 0;
  v12 = *(_DWORD *)(v3 + 2168);
  LOBYTE(v26[0]) = 1;
  if ( v12 )
    HIBYTE(v26[0]) = *(_BYTE *)(v12 + 92);
  else
    HIBYTE(v26[0]) = *(_BYTE *)(*(_DWORD *)(v3 + 23100) + 639);
  v13 = 0;
  for ( i = (_DWORD *)(&loc_423AC3 + 1); (unsigned int)i < 0x423E94; ++i )
    v13 -= *i;
  v15 = *(_BYTE *)(*(_DWORD *)(v13 + 1112232530 + v3 + 344231844) + 8062);
  v16 = *(_DWORD *)(v3 + 117716);
  LOBYTE(v26[1]) = v15;
  v17 = *(_DWORD *)(v3 + 23100);
  HIBYTE(v26[1]) = *(_BYTE *)(v17 + 8059);
  v18 = *(_DWORD *)(v3 + 28248);
  v19 = *(_DWORD *)(v16 + 8);
  v26[2] = v18;
  if ( v18 < v19 )
    v26[2] = v19;
  v20 = *(_DWORD *)(v3 + 28252);
  v21 = *(_DWORD *)(v16 + 12);
  v26[3] = v20;
  if ( v20 < v21 )
    v26[3] = v21;
  v27 = *(_BYTE *)(v17 + 8068);
  *(_BYTE *)(v3 + 113525) = 0;
  if ( a3 )
  {
    v26[4] = -1;
  }
  else if ( v24 )
  {
    if ( *sub_40BCD0(&v24) )
    {
      v26[4] = -3;
      strncpyt(&v26[5], &v24, 16);
      strncpyt((void *)(v3 + 113525), &v26[5], 32);
    }
    else
    {
      v26[4] = sub_46D80E(&v24);
    }
  }
  else
  {
    v26[4] = -2;
  }
  if ( *(_BYTE *)(v3 + 117756) )
  {
    v26[4] = *(_WORD *)(v3 + 120539);
    strncpyt(&v26[5], (void *)(v3 + 120541), 16);
    strncpyt((void *)(v3 + 113525), &v26[5], 32);
    *(_BYTE *)(v3 + 117756) = 0;
  }
  if ( *(_BYTE *)(v3 + 1868) && !*(_BYTE *)(v3 + 113525) )
    HIBYTE(v26[0]) = *(_BYTE *)(v3 + 112252);
  v22 = *(_DWORD *)v3;
  *(_DWORD *)(v3 + 119968) = HIBYTE(v26[0]);
  (*(void (__thiscall **)(int))(v22 + 76))(v3);
  return (*(int (__thiscall **)(int, _WORD *, int, int))(*(_DWORD *)v3 + 16))(v3, v26, 27, 1);
}

//----- (00442D10) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_442D10(int this)
{
  int v2; // eax
  int (__cdecl *v3)(int); // eax
  int v4; // edx
  int pExceptionObject; // [esp+4h] [ebp-Ch] BYREF
  int v7; // [esp+8h] [ebp-8h] BYREF
  int v8; // [esp+Ch] [ebp-4h]

  sub_40DA80((char *)(9403234 - ((_DWORD)&loc_449CFA + 4)));
  v8 = 9403528;
  v2 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 197512) + 68))(
         *(_DWORD *)(this + 197512),
         9403528 - ((_DWORD)&loc_449E2B + 5));
  *(_DWORD *)(this + 197520) = v2;
  if ( !v2 )
  {
    v8 = 9404089;
    sub_406F10(&pExceptionObject, (int)&v7, (const char *)(9404089 - ((_DWORD)&loc_44A090 + 1)));
    _CxxThrowException(&pExceptionObject, &_TI1_AVbase_exception__);
  }
  v8 = 9404384;
  *(_DWORD *)(this + 197524) = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 197512) + 68))(
                                 *(_DWORD *)(this + 197512),
                                 9404384 - (_DWORD)sub_44A1C4);
  v8 = 9404987;
  v3 = (int (__cdecl *)(int))dword_4A70D8(*(_DWORD *)(this + 197524), 9404987 - (_DWORD)&loc_44A427);
  if ( !*(_DWORD *)(this + 197524) || !v3 )
  {
    v8 = 9405542;
    sub_406F10(&pExceptionObject, (int)&v7, (const char *)(9405542 - ((_DWORD)&loc_44A689 + 1)));
    _CxxThrowException(&pExceptionObject, &_TI1_AVbase_exception__);
  }
  v4 = *(_DWORD *)(this + 104);
  *(_DWORD *)(this + 197560) = a040;
  *(_DWORD *)(this + 197556) = v4;
  *(_DWORD *)(this + 206710) = sub_419650;
  *(_DWORD *)(this + 206714) = dword_4196D0;
  *(_DWORD *)(this + 206718) = sub_4197D0;
  *(_DWORD *)(this + 206722) = sub_419870;
  *(_DWORD *)(this + 206726) = sub_419920;
  *(_DWORD *)(this + 206730) = sub_419040;
  *(_DWORD *)(this + 206734) = sub_419090;
  return v3(this + 197556);
}
// 442EAB: positive sp value 8 has been found
// 419090: using guessed type int __thiscall sub_419090(_DWORD);
// 4196D0: using guessed type int dword_4196D0[48];
// 44A1C4: using guessed type int __stdcall sub_44A1C4(int, int);
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);

//----- (00442EB0) --------------------------------------------------------
void __thiscall sub_442EB0(int this)
{
  qsort(*(void **)(this + 104), *(_DWORD *)(this + 112), 0x18u, sub_414EC0);
}

//----- (00442ED0) --------------------------------------------------------
int __thiscall sub_442ED0(_DWORD *this, int a2, unsigned int a3)
{
  int v4; // eax
  int (__stdcall *v5)(int); // ebx
  int v6; // edi
  int result; // eax
  int v8; // [esp-4h] [ebp-10h]

  v4 = 0;
  v5 = (int (__stdcall *)(int))&loc_44F148;
  do
  {
    v4 -= *(_DWORD *)v5;
    v5 = (int (__stdcall *)(int))((char *)v5 + 4);
  }
  while ( (unsigned int)v5 < (unsigned int)sub_44F508 );
  *(_BYTE *)((_DWORD *)((char *)this + v4 + 1943247851) + 356663732) = 0;
  v6 = 0;
  if ( a3 > 3 )
  {
    *(_BYTE *)(a2 + a3 - 1) = 0;
    v6 = a2 + 3;
  }
  v8 = *(unsigned __int16 *)(a2 + 1);
  this[1876] = v8;
  nullsub_2("Selfif: %d\n", v8);
  (*(void (__thiscall **)(_DWORD *, int))(*this + 324))(this, v6);
  result = 4;
  if ( this[354] != 4 )
  {
    this[2171] = 3276;
    this[2172] = 16374;
    this[354] = 4;
  }
  return result;
}
// 404A80: using guessed type int nullsub_2(const char *, ...);
// 44F508: using guessed type int __stdcall sub_44F508(int);

//----- (00442F90) --------------------------------------------------------
int __thiscall sub_442F90(_DWORD *this, char *Buffer, int a3, int a4)
{
  sprintf_0(Buffer, (const char *const)(9421204 - (_DWORD)&loc_44E314), this[26] + 164 * a3 + 96);
  if ( a3 == this[2] )
    *Buffer = 62;
  return 0;
}

//----- (00442FE0) --------------------------------------------------------
unsigned __int8 __thiscall sub_442FE0(_DWORD *this, int a2, int a3, const char *a4, int a5, int a6, char a7)
{
  int v7; // edx
  char *v8; // ebp
  _DWORD *v9; // ebx
  unsigned __int8 v11; // cl
  int v12; // esi
  char *v13; // eax
  unsigned __int8 v14; // cl
  int *v15; // eax
  _DWORD *v16; // ecx
  unsigned __int8 result; // al
  bool v18; // zf
  unsigned int v19; // ecx
  int v20; // eax
  _DWORD *v21; // esi
  _DWORD *v22[2]; // [esp+10h] [ebp-10h]
  int v23[2]; // [esp+18h] [ebp-8h]

  v7 = a6;
  v8 = (char *)a4;
  v9 = this;
  v22[0] = this;
  if ( a6 < 0 )
  {
    a6 = strlen(a4);
    v7 = a6;
  }
  while ( 1 )
  {
    if ( a7 && (unsigned __int8)*v8 <= 0x20u )
    {
      do
      {
        if ( !v7 )
          break;
        v11 = *++v8;
        --v7;
        a2 += v9[18806];
      }
      while ( v11 <= 0x20u );
      a6 = v7;
    }
    if ( v7 <= 2 )
      break;
    v12 = v7;
    if ( v7 > 20 )
      v12 = 20;
    if ( a7 )
    {
      v13 = &v8[v12 - 1];
      if ( (unsigned __int8)*v13 <= 0x20u )
      {
        do
        {
          v14 = *(v13 - 1);
          --v12;
          --v13;
        }
        while ( v14 <= 0x20u );
      }
    }
    v15 = (int *)(*(int (__thiscall **)(_DWORD *, char *, int, int))(*v9 + 84))(v9, v8, v12, a5);
    if ( !v15 )
    {
      v7 = a6;
      break;
    }
    sub_405930(*v15, a2, a3, v15[10], v15[11], v15[12], v15[13], a7);
    v9 = v22[0];
    v8 += v12;
    a2 += v12 * v22[0][18806];
    a6 -= v12;
    v7 = a6;
  }
  v16 = (_DWORD *)v9[2551];
  v22[1] = *((_DWORD **)v9 + 2553);
  v22[0] = v16;
  v23[1] = 72 * a5;
  result = *v8;
  v18 = *v8 == 0;
  v23[0] = 96 * a5;
  if ( !v18 )
  {
    do
    {
      if ( !v7 )
        return result;
      v19 = (unsigned __int8)byte_4A9878[result];
      if ( v19 >= 0x80 )
      {
        if ( !a7 )
        {
          sub_404B80(v22[0], a2, a3, 0, 0);
          goto LABEL_24;
        }
      }
      else
      {
        v20 = (unsigned __int8)byte_4A9778[result];
        v21 = v22[v20];
        if ( *((_BYTE *)v21 + 640) )
        {
          sub_404B80(v21, a2, a3, v19 + v23[v20], a7);
LABEL_24:
          v7 = a6;
          goto LABEL_25;
        }
      }
LABEL_25:
      result = *++v8;
      a2 += *(_DWORD *)(v9[2551] + 612);
      a6 = --v7;
    }
    while ( *v8 );
  }
  return result;
}

//----- (004431A0) --------------------------------------------------------
unsigned int __thiscall sub_4431A0(unsigned int *this, char *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned __int8 v5; // al
  unsigned int result; // eax
  char v7; // bl
  unsigned __int8 *v8; // eax
  unsigned int v9; // edi
  int v10; // edx
  unsigned int v11; // esi
  char v12; // cl
  unsigned __int8 v13; // [esp+8h] [ebp-210h]
  _DWORD v14[131]; // [esp+Ch] [ebp-20Ch] BYREF

  if ( !*a3 && ((v5 = a3[1], v5 == 1) || v5 == 16 || v5 == 17) )
  {
    sub_46CAB0((unsigned int)a2, a3, a4);
    result = a4;
  }
  else
  {
    v7 = 0;
    v13 = 0;
    v8 = a3;
    if ( a4 )
    {
      v9 = a4;
      do
      {
        v10 = v13 ^ *v8++;
        --v9;
        v7 = byte_4A7A3C[v10];
        v13 = v7;
      }
      while ( v9 );
    }
    sub_46CAB0((unsigned int)v14 + 1, a3, a4);
    v11 = a4 + 1;
    LOBYTE(v14[0]) = v7;
    ContinuumEncrypt(this, a2, v14, a4 + 1);
    if ( !*a2 && ((v12 = a2[1], v12 == 1) || v12 == 16 || v12 == 17) || *a2 == -1 )
    {
      sub_46CAB0((unsigned int)(a2 + 1), a2, v11);
      *a2 = -1;
      v11 = a4 + 2;
    }
    result = v11;
  }
  return result;
}

//----- (00443290) --------------------------------------------------------
int __thiscall sub_443290(int this)
{
  int result; // eax
  int v3; // ebx
  int v4; // [esp+0h] [ebp-200h] BYREF
  char v5[260]; // [esp+Ch] [ebp-1F4h] BYREF
  int v6[32]; // [esp+110h] [ebp-F0h] BYREF
  char v7[80]; // [esp+190h] [ebp-70h] BYREF
  int v8; // [esp+1E0h] [ebp-20h] BYREF
  int v9; // [esp+1E4h] [ebp-1Ch]
  void *v10; // [esp+1E8h] [ebp-18h] BYREF
  int v11[2]; // [esp+1ECh] [ebp-14h] BYREF
  int v12; // [esp+1FCh] [ebp-4h]
  int savedregs; // [esp+200h] [ebp+0h] BYREF

  v11[1] = (int)&v4;
  v9 = 9445603;
  nullsub_2((const char *)(9445603 - ((_DWORD)&loc_4541F4 + 3)));
  *(_BYTE *)(this + 1868) = 0;
  v9 = 9441259;
  sub_407960(v5, *(_DWORD *)(this + 23100) + 269, (_BYTE *)(9441259 - ((_DWORD)&loc_454481 + 2)));
  v12 = 1;
  v8 = -1;
  if ( sub_408AA0(v5) )
  {
    sub_407E80(&v8, (int)&savedregs, v5, 1, 3);
    ReadScrty1FileOffset(&v8, (int)v6, 128);
    sub_4087F0(&v8);
    LOBYTE(v12) = 0;
    sub_4087F0(&v8);
    v12 = -1;
    sub_457D50(&v10, (int)v7);
    sub_457D60(&v10, 0, 0x247DA9AAu);
    ContinuumEncryptMD5Step3(&v10, -1439978213);
    ContinuumDecrypt((unsigned int *)&v10, (int *)(this + 112220), v6, 0x80u);
    v9 = *(_DWORD *)(this + 112344);
    *(_DWORD *)(this + 112344) = 0;
    v11[0] = -1;
    sub_401A70(v11, (unsigned __int8 *)(this + 112220), 128);
    v3 = v9;
    if ( v9 != v11[0] )
    {
      v9 = 9454749;
      nullsub_2((const char *)(9454749 - ((_DWORD)&loc_4565C8 + 5)));
    }
    result = _strcmpi((const char *)(*(_DWORD *)(this + 23100) + 575), (const char *)(this + 112220));
    if ( result )
    {
      v9 = 9455376;
      result = nullsub_2((const char *)(9455376 - ((_DWORD)&loc_45685E + 2)));
    }
    if ( v3 == v11[0] )
    {
      result = _strcmpi((const char *)(*(_DWORD *)(this + 23100) + 575), (const char *)(this + 112220));
      if ( !result )
        *(_BYTE *)(this + 1868) = 1;
    }
  }
  else
  {
    LOBYTE(v12) = 0;
    result = sub_4087F0(&v8);
  }
  return result;
}
// 404A80: using guessed type int nullsub_2(const char *, ...);

//----- (00443490) --------------------------------------------------------
int __usercall sub_443490@<eax>(int a1@<ecx>, int a2@<edi>)
{
  int result; // eax
  int (__stdcall *v4)(_DWORD, int); // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // [esp-24h] [ebp-18Ch]
  _DWORD *v10; // [esp-18h] [ebp-180h]
  int v11; // [esp-10h] [ebp-178h]
  int v12; // [esp-Ch] [ebp-174h]
  char pExceptionObject[308]; // [esp+8h] [ebp-160h] BYREF
  _DWORD v14[6]; // [esp+13Ch] [ebp-2Ch] BYREF
  int v15; // [esp+154h] [ebp-14h]
  int v16; // [esp+158h] [ebp-10h]
  int v17; // [esp+15Ch] [ebp-Ch]
  int v18; // [esp+160h] [ebp-8h]
  int v19; // [esp+164h] [ebp-4h]

  v14[0] = 3;
  v14[1] = sub_418ED0;
  v14[2] = 0;
  v14[3] = 0;
  v14[4] = dword_4C1A38;
  v14[5] = dword_4A7338(dword_4C1A38, 102);
  if ( *(_BYTE *)(a1 + 205530) )
  {
    v12 = 32512;
    v11 = 0;
    v15 = dword_4A733C();
  }
  else
  {
    v15 = 0;
  }
  v16 = dword_4A708C();
  v17 = 0;
  v19 = 9453311;
  v18 = 9453311 - ((_DWORD)&loc_457E5D + 6);
  v10 = v14;
  dword_4A7390();
  if ( *(_BYTE *)(a1 + 205530) )
  {
    result = dword_4A7394(0, v18, a1 + 198082, 113901568, 1, 1, 100, 100, 0, 0, dword_4C1A38, 0);
  }
  else
  {
    v4 = dword_4A72C4;
    v8 = dword_4C1A38;
    v5 = dword_4A72C4(1, 0);
    v6 = v4(0, v5);
    result = dword_4A7394(0, v18, a1 + 198082, 0x80000000, 0, 0, v6, 0, v8, 0, a2, v14);
  }
  *(_DWORD *)(a1 + 197528) = result;
  if ( !*(_DWORD *)(a1 + 197528) )
  {
    v19 = 9465433;
    v7 = dword_4A7260(v10, 5, v11, v12);
    sub_4073D0((int)pExceptionObject, (char *)(9465433 - (_DWORD)&loc_458F55), v7);
    _CxxThrowException(pExceptionObject, &_TI2_AVtext_exception__);
  }
  return result;
}
// 443490: could not find valid save-restore pair for edi
// 44359B: variable 'v10' is possibly undefined
// 44359B: variable 'v11' is possibly undefined
// 44359B: variable 'v12' is possibly undefined
// 4A708C: using guessed type int (*dword_4A708C)(void);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A72C4: using guessed type int (__stdcall *dword_4A72C4)(_DWORD, _DWORD);
// 4A7338: using guessed type int (__cdecl *dword_4A7338)(_DWORD, _DWORD);
// 4A733C: using guessed type int (*dword_4A733C)(void);
// 4A7390: using guessed type int (*dword_4A7390)(void);
// 4A7394: using guessed type int (__stdcall *dword_4A7394)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004435D0) --------------------------------------------------------
_DWORD *__userpurge sub_4435D0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, void *a4, int a5, int a6, int a7)
{
  int v8; // ecx
  _DWORD *v9; // eax
  _DWORD *result; // eax

  v8 = *(_DWORD *)(a1 + 4 * a3 + 10344);
  if ( v8 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 8))(v8, 1);
    *(_DWORD *)(a1 + 4 * a3 + 10344) = 0;
  }
  v9 = (_DWORD *)sub_40B720(a2, 0x284u);
  if ( v9 )
    result = sub_403C70(v9, a1, a4, a5, a6, a7, *(_BYTE *)(*(_DWORD *)(a1 + 1208) + 8257));
  else
    result = 0;
  *(_DWORD *)(a1 + 4 * a3 + 10344) = result;
  return result;
}

//----- (00443670) --------------------------------------------------------
int __thiscall sub_443670(int this, void *a2)
{
  unsigned int *v3; // edi
  int v4; // ebx
  int v5; // eax
  unsigned int *v6; // ebx
  int v7; // eax
  int v8; // ecx
  unsigned int *v9; // ebx
  int v10; // eax
  int v11; // ecx
  _DWORD **v12; // eax
  _DWORD *v13; // ebx
  int v14; // ecx
  int v15; // edx
  unsigned int *v16; // ebx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  unsigned int *v20; // ebx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  unsigned int *v26; // ebx
  int v27; // eax
  int v28; // ecx
  int v29; // eax
  _BYTE *v30; // eax
  int v31; // ecx
  char v32; // al
  void *v33; // edx
  char v34; // al
  _BYTE *v35; // eax
  unsigned int v37; // [esp-4h] [ebp-11Ch]
  char v38[260]; // [esp+Ch] [ebp-10Ch] BYREF
  int v39; // [esp+110h] [ebp-8h]
  _DWORD **v40; // [esp+114h] [ebp-4h]

  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 120076) + 40))(*(_DWORD *)(this + 120076));
  v3 = (unsigned int *)(this + 117724);
  v4 = 8;
  do
  {
    sub_40B7E0(*v3);
    *v3++ = 0;
    --v4;
  }
  while ( v4 );
  v5 = *(_DWORD *)(this + 8680);
  v6 = (unsigned int *)(this + 7656);
  v39 = 0;
  if ( v5 > 0 )
  {
    do
    {
      sub_40B7E0(*v6);
      v7 = v39;
      *v6 = 0;
      v8 = *(_DWORD *)(this + 8680);
      ++v6;
      v39 = v7 + 1;
    }
    while ( v7 + 1 < v8 );
  }
  v9 = (unsigned int *)(this + 112484);
  *(_DWORD *)(this + 8680) = 0;
  v39 = 0;
  if ( *(int *)(this + 113508) > 0 )
  {
    do
    {
      sub_40B7E0(*v9);
      v10 = v39;
      *v9 = 0;
      v11 = *(_DWORD *)(this + 113508);
      ++v9;
      v39 = v10 + 1;
    }
    while ( v10 + 1 < v11 );
  }
  v12 = (_DWORD **)(this + 27216);
  *(_DWORD *)(this + 113508) = 0;
  v39 = 0;
  if ( *(int *)(this + 28240) > 0 )
  {
    v40 = (_DWORD **)(this + 27216);
    do
    {
      v13 = *v12;
      if ( *v12 )
      {
        *v13 = &off_4AC354;
        sub_441B30((int)v13, 0);
        sub_40B7E0((unsigned int)v13);
        v12 = v40;
      }
      v14 = v39;
      *v12 = 0;
      v15 = *(_DWORD *)(this + 28240);
      ++v12;
      v39 = v14 + 1;
      v40 = v12;
    }
    while ( v14 + 1 < v15 );
  }
  *(_DWORD *)(this + 28240) = 0;
  sub_40B7D0(*(void **)(this + 1716));
  v16 = (unsigned int *)(this + 6284);
  *(_DWORD *)(this + 1716) = 0;
  *(_DWORD *)(this + 1724) = 0;
  *(_DWORD *)(this + 1720) = 0;
  v17 = *(_DWORD *)(this + 7500);
  v40 = 0;
  if ( v17 > 0 )
  {
    do
    {
      sub_40B7E0(*v16);
      v18 = (int)v40;
      *v16 = 0;
      v19 = *(_DWORD *)(this + 7500);
      ++v16;
      v40 = (_DWORD **)(v18 + 1);
    }
    while ( v18 + 1 < v19 );
  }
  *(_DWORD *)(this + 7500) = 0;
  sub_40B7D0(*(void **)(this + 22972));
  *(_DWORD *)(this + 22972) = 0;
  *(_DWORD *)(this + 22980) = 0;
  *(_DWORD *)(this + 22976) = 0;
  sub_40B7D0(*(void **)(this + 119848));
  v20 = (unsigned int *)(this + 2180);
  *(_DWORD *)(this + 119848) = 0;
  *(_DWORD *)(this + 119856) = 0;
  *(_DWORD *)(this + 119852) = 0;
  v21 = *(_DWORD *)(this + 6276);
  v40 = 0;
  if ( v21 > 0 )
  {
    do
    {
      sub_40B7E0(*v20);
      v22 = (int)v40;
      *v20 = 0;
      v23 = *(_DWORD *)(this + 6276);
      ++v20;
      v40 = (_DWORD **)(v22 + 1);
    }
    while ( v22 + 1 < v23 );
  }
  *(_DWORD *)(this + 6276) = 0;
  sub_40B7D0(*(void **)(this + 110180));
  *(_DWORD *)(this + 110180) = 0;
  *(_DWORD *)(this + 110188) = 0;
  *(_DWORD *)(this + 110184) = 0;
  *(_BYTE *)(this + 112452) = 1;
  memset((void *)(this + 23112), 0, 0x1000u);
  memset((void *)(this + 113620), 0, 0x1000u);
  v24 = 989087419;
  v25 = 227;
  do
    v24 ^= (unsigned int)*(&dword_4A722C + v25-- - 135284);
  while ( v25 );
  *(_DWORD *)(v24 + this + 392108168) = 0;
  v40 = 0;
  if ( *(int *)(this + 10740) > 0 )
  {
    v26 = (unsigned int *)(this + 8692);
    do
    {
      sub_40B7E0(*v26);
      v27 = (int)v40;
      *v26 = 0;
      v28 = *(_DWORD *)(this + 10740);
      ++v26;
      v40 = (_DWORD **)(v27 + 1);
    }
    while ( v27 + 1 < v28 );
  }
  *(_DWORD *)(this + 10740) = 0;
  v29 = dword_4C1AE4;
  *(_DWORD *)(this + 7636) = dword_4C1AE4;
  *(_DWORD *)(this + 7632) = -v29;
  v30 = (_BYTE *)(this + 1880);
  v31 = 4;
  do
  {
    *v30 = 0;
    v30 += 72;
    --v31;
  }
  while ( v31 );
  v37 = *(_DWORD *)(this + 120528);
  *(_DWORD *)(this + 120564) = 0;
  *(_DWORD *)(this + 120472) = -1;
  *(_DWORD *)(this + 113564) = -1;
  *(_DWORD *)(this + 113560) = -1;
  *(_DWORD *)(this + 112212) = -1;
  *(_DWORD *)(this + 1408) = 1;
  *(_BYTE *)(this + 28244) = 0;
  sub_40B7E0(v37);
  v32 = *(_BYTE *)(this + 113524);
  *(_DWORD *)(this + 120528) = 0;
  *(_DWORD *)(this + 1728) = 0;
  if ( v32 )
  {
    (*(void (**)(void))(*(_DWORD *)(this + 23100) + 9106))();
    (*(void (**)(void))(*(_DWORD *)(this + 23100) + 9110))();
  }
  v33 = a2;
  if ( !a2 )
    v33 = (void *)(this + 113525);
  strncpyt((void *)(this + 113572), v33, 32);
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(*(_DWORD *)(this + 117716) + 1204) + 16))(*(_DWORD *)(*(_DWORD *)(this + 117716) + 1204));
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 117716) + 124))(*(_DWORD *)(this + 117716));
  v34 = *(_BYTE *)(this + 113572);
  v38[0] = 0;
  if ( v34 )
    v35 = (_BYTE *)(this + 113572);
  else
    v35 = (_BYTE *)(9485481 - ((_DWORD)&loc_45DD83 + 2));
  sub_407960(v38, *(_DWORD *)(this + 23100) + 269, v35);
  return (*(int (__thiscall **)(_DWORD, char *, int, int))(**(_DWORD **)(*(_DWORD *)(this + 117716) + 1204) + 12))(
           *(_DWORD *)(*(_DWORD *)(this + 117716) + 1204),
           v38,
           1,
           40);
}
// 4A722C: using guessed type int (__cdecl *dword_4A722C)(_DWORD, _DWORD);
// 4AC354: using guessed type int (*off_4AC354)();
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00443A10) --------------------------------------------------------
void __thiscall sub_443A10(_DWORD *this, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  size_t v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  char Buffer[128]; // [esp+8h] [ebp-94h] BYREF
  unsigned __int8 *v13; // [esp+88h] [ebp-14h] BYREF
  int v14; // [esp+8Ch] [ebp-10h]
  int v15; // [esp+98h] [ebp-4h]
  int savedregs; // [esp+9Ch] [ebp+0h] BYREF

  v13 = 0;
  v14 = 0;
  v15 = 0;
  v5 = 10 * (_DWORD)a4;
  if ( 10 * (int)a4 > 1000000 )
    v5 = 1000000;
  sub_40C9D0((int)&v13, (int)&savedregs, v5);
  v6 = sub_412680(v13, v14, a3, a4);
  if ( v6 > 0 )
  {
    v7 = 1404919677;
    v8 = 69;
    do
      v7 ^= *(_DWORD *)&aMultifireLost[4 * v8-- - 562616];
    while ( v8 );
    v9 = *(_DWORD *)(*(_DWORD *)((char *)this + v7 + 1938596) + 120076);
    (*(void (__thiscall **)(int, unsigned __int8 *, int))(*(_DWORD *)v9 + 32))(v9, v13, v6);
    v10 = *(_DWORD *)(this[137] + 120076);
    if ( *(_DWORD *)(v10 + 328) )
    {
      (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(v10 + 328) + 20))(
        *(_DWORD *)(v10 + 328),
        0,
        0,
        0,
        0);
      v11 = *(_DWORD *)(this[137] + 4 * a2 + 113620);
      if ( v11 )
      {
        sprintf_0(Buffer, "Voice: %s", (const char *)(v11 + 109));
        (*(void (__thiscall **)(_DWORD *, char *, _DWORD, _DWORD, _DWORD, int))(*this + 28))(this, Buffer, 0, 0, 0, 1);
      }
    }
  }
  v15 = -1;
  sub_40C9D0((int)&v13, (int)&savedregs, 0);
}

//----- (00443B50) --------------------------------------------------------
int __thiscall sub_443B50(_DWORD *this)
{
  _DWORD *v1; // edx
  int v2; // edi
  int v3; // eax
  _DWORD *v4; // ebx
  int *v5; // ebx
  int *v6; // esi
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp+10h] [ebp-18h]
  int v12; // [esp+18h] [ebp-10h]
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v1 = this;
  v2 = 0;
  this[14] = -1;
  this[81] = 0;
  v3 = 0;
  v4 = (_DWORD *)((char *)&loc_445982 + 2);
  do
    v3 -= *v4++;
  while ( v4 < (_DWORD *)&loc_445B68 );
  *(_DWORD *)((char *)this + v3 - 1707723276) = 0;
  v5 = (int *)&unk_4AAC68;
  v10 = 34;
  do
  {
    v6 = (_DWORD *)((char *)v1 + *(v5 - 2));
    if ( *v5 > 0 )
    {
      v12 = 0;
      do
      {
        v7 = sub_40B720((int)&savedregs, 0x168u);
        if ( v7 )
          v8 = sub_4063A0(v7, (int)this, v12 + *(v5 - 1));
        else
          v8 = 0;
        *v6 = v8;
        ++v2;
        ++v6;
        v12 += 20;
      }
      while ( v2 < *v5 );
      v1 = this;
      v2 = 0;
    }
    v5 += 3;
    result = --v10;
  }
  while ( v10 );
  return result;
}

//----- (00443C30) --------------------------------------------------------
int __thiscall sub_443C30(_DWORD *this, int a2)
{
  _DWORD *v3; // edi
  int *v4; // esi
  int i; // ebx
  int v6; // ecx
  _DWORD *v7; // esi
  int v8; // edi
  int result; // eax
  int v10; // [esp+10h] [ebp-4h]

  v3 = &unk_4AAC68;
  v10 = 34;
  do
  {
    v4 = (_DWORD *)((char *)this + *(v3 - 2));
    for ( i = 0; i < *v3; ++v4 )
    {
      v6 = *v4;
      if ( *v4 && v6 != this[78] )
        (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 32))(v6, a2, 1);
      ++i;
    }
    v3 += 3;
    --v10;
  }
  while ( v10 );
  v7 = this + 17;
  v8 = 5;
  do
  {
    if ( *v7 )
      (*(void (__thiscall **)(_DWORD, int, int))(*(_DWORD *)*v7 + 32))(*v7, a2, 1);
    v7 += 3;
    --v8;
  }
  while ( v8 );
  result = a2;
  this[15] = a2;
  return result;
}

//----- (00443CE0) --------------------------------------------------------
int __thiscall sub_443CE0(void *this, _BYTE *a2, int a3)
{
  *a2 = 29;
  return (*(int (__thiscall **)(void *, _BYTE *, int, int))(*(_DWORD *)this + 16))(this, a2, a3, 1);
}

//----- (00443D00) --------------------------------------------------------
int __thiscall sub_443D00(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int i; // ebx
  int v9; // eax
  int j; // ebx

  result = a2[22];
  switch ( result )
  {
    case 24:
      v4 = -1945083841;
      v5 = 127;
      do
        v4 ^= dword_4A7188[v5-- - 111741];
      while ( v5 );
      if ( *(_DWORD *)((char *)this + v4 + 337408) + 1 < this[20] )
        ++this[2];
      break;
    case 23:
      v6 = this[2];
      if ( v6 )
        this[2] = v6 - 1;
      break;
    case 25:
      v7 = this[2];
      for ( i = this[22]; v7 > 0; v7 = this[2] )
      {
        if ( i <= 0 )
          break;
        i -= (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, v7);
        if ( i >= 0 )
          --this[2];
      }
      break;
    case 26:
      v9 = this[2];
      for ( j = this[22]; v9 + 1 < this[20]; v9 = this[2] )
      {
        if ( j <= 0 )
          break;
        j -= (*(int (__thiscall **)(_DWORD *, int))(*this + 28))(this, v9);
        if ( j >= 0 )
          ++this[2];
      }
      break;
    default:
      return result;
  }
  (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
  return (*(int (__thiscall **)(_DWORD *))(*this + 8))(this);
}
// 4A7188: using guessed type int dword_4A7188[];

//----- (00443DD0) --------------------------------------------------------
int __thiscall sub_443DD0(int *this)
{
  int v2; // eax
  int v3; // ecx
  int *v4; // ebx
  signed int i; // edi
  int *v6; // ebx
  unsigned int j; // edi
  bool v8; // cf
  char v9; // bl
  int v10; // eax
  unsigned int v11; // edi
  int v12; // eax
  int v13; // ebx
  int result; // eax
  int *v15; // [esp+Ch] [ebp-8h]
  signed int v16; // [esp+10h] [ebp-4h]
  unsigned int v17; // [esp+10h] [ebp-4h]

  v2 = -1191969401;
  v3 = 62;
  do
    v2 ^= *(_DWORD *)&aEnter[4 * v3-- - 483184];
  while ( v3 );
  *(int *)((char *)this + v2 + 256481436) = (*(int (__thiscall **)(int *, _DWORD))(*this + 276))(this, 0);
  this[13072] = (*(int (__thiscall **)(int *, int))(*this + 276))(this, 0xFFFFFF);
  this[13075] = (*(int (__thiscall **)(int *, int))(*this + 276))(this, 128);
  v16 = 0;
  v4 = this + 13588;
  do
  {
    for ( i = 0; i < 14; ++i )
      *v4++ = sub_405350(this[2895], i, v16);
    ++v16;
  }
  while ( v16 < 7 );
  v17 = 0;
  v15 = this + 13686;
  do
  {
    v6 = v15;
    for ( j = 0; j < 0x80; ++j )
    {
      *v6 = sub_405350(this[2896], j, v17);
      v6 += 40;
    }
    v8 = ++v17 < 0x28;
    ++v15;
  }
  while ( v8 );
  v9 = *((_BYTE *)this + 1140);
  if ( v9 )
    v10 = this[2];
  else
    v10 = 1280;
  v11 = 92 * v10 / 640;
  if ( v9 )
    v12 = this[2];
  else
    v12 = 1280;
  v13 = 48 * v12 / 640;
  if ( v11 > 0xFF )
    v11 = 255;
  this[13073] = (*(int (__thiscall **)(int *, unsigned int))(*this + 276))(this, 65793 * v11);
  result = (*(int (__thiscall **)(int *, int))(*this + 276))(this, 65793 * v13);
  this[13074] = result;
  return result;
}

//----- (004444C0) --------------------------------------------------------
int __thiscall sub_4444C0(_DWORD *this)
{
  int result; // eax
  _DWORD *v3; // edx
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  __int64 v7; // rax
  unsigned int v8; // ebx
  int v9; // ecx
  int v10; // eax
  _DWORD *v11; // ebx
  unsigned int v12; // [esp+4h] [ebp-8h]
  signed int v13; // [esp+8h] [ebp-4h]

  result = this[19];
  if ( !result )
  {
    result = this[16];
    if ( result <= 0 )
    {
      result = this[1];
      if ( result >= 0 )
      {
        result = this[10];
        if ( result < 0 )
        {
          v3 = (_DWORD *)this[3];
          if ( (int)v3[1569] <= 2 || (result = v3[356], result <= v3[2798]) )
          {
            result = 117724;
            v4 = 1000 * v3[327 * this[23] + 3214];
            v13 = v4;
            v12 = 117724;
            while ( 1 )
            {
              v5 = this[3];
              v6 = *(_DWORD *)(result + v5);
              if ( v6 )
              {
                if ( *(int *)(v6 + 32) <= 0 )
                {
                  if ( *(_DWORD *)(v6 + 52) )
                  {
                    v7 = *(_DWORD *)(v6 + 4) - this[1];
                    if ( (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) < v4 )
                    {
                      v8 = this[2];
                      if ( (int)abs32(*(_DWORD *)(v6 + 8) - v8) < v13
                        && (*(__int16 *)(v6 + 50) != this[6] || !*(_DWORD *)(v6 + 16) && !*(_DWORD *)(v6 + 20))
                        && *(_DWORD *)(v6 + 56) > *(_DWORD *)(v5 + 12188) )
                      {
                        v9 = *(_DWORD *)(v5 + 120528);
                        if ( (!v9
                           || this[1] >= 0xFA0000u
                           || v8 >= 0xFA0000
                           || *(unsigned __int8 *)(this[1] / 16000 + (((int)v8 / 16000) << 10) + v9) != 171
                           || this[4]
                           || this[5]
                           || !*(_DWORD *)(this[3] + 12448))
                          && (!*(_DWORD *)(this[3] + 12452)
                           || (*(unsigned __int8 (__thiscall **)(_DWORD *, _DWORD, _DWORD))*this)(
                                this,
                                *(_DWORD *)(v6 + 4),
                                *(_DWORD *)(v6 + 8))) )
                        {
                          *(_DWORD *)(v6 + 32) = 100;
                          v10 = 0;
                          v11 = (_DWORD *)((char *)&loc_44EDC0 + 4);
                          do
                            v10 -= *v11++;
                          while ( v11 < &off_44F154 );
                          (*(void (__thiscall **)(int, int))(*(_DWORD *)((char *)this + v10 + 1414885057) + 16))(
                            (int)this + v10 + 1414885057,
                            v6);
                        }
                      }
                    }
                  }
                }
              }
              result = v12 + 4;
              v12 += 4;
              if ( v12 >= 0x1CBFC )
                break;
              v4 = v13;
            }
          }
        }
      }
    }
  }
  return result;
}
// 44F154: using guessed type int (__stdcall **off_44F154)(int, int);

//----- (004446B0) --------------------------------------------------------
int __thiscall sub_4446B0(int *this, __int16 *a2, int a3)
{
  int v4; // ebx
  _DWORD *v5; // esi
  int *v6; // ecx
  int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  int v11; // eax
  int (__fastcall *v12)(int *, int); // ebx
  int v13; // ecx
  unsigned int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int result; // eax
  int *v21; // esi
  int v22; // eax
  int i; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF
  int v25; // [esp+18h] [ebp+8h]
  int v26; // [esp+1Ch] [ebp+Ch]

  if ( !this[1875] )
  {
    v4 = 0;
    for ( i = 0; v4 < this[5745]; i = v4 )
    {
      v5 = (_DWORD *)sub_40B720((int)&savedregs, 0x20u);
      if ( v5 )
      {
        v6 = (int *)(this[5743] + 8 * v4);
        v7 = *v6;
        v8 = v6[1];
        v5[3] = this;
        v5[2] = 0;
        v5[1] = 0;
        *v5 = &off_4AC35C;
        v9 = 16000 * v7;
        v10 = 16000 * v8;
        if ( v9 >= 0xFA0000 || v10 >= 0xFA0000 )
        {
          v10 = 0;
          v9 = 0;
        }
        v5[1] = v9;
        v5[2] = v10;
        v5[5] = -1;
        v11 = 0;
        v12 = (int (__fastcall *)(int *, int))(&loc_423E79 + 3);
        do
        {
          v11 -= *(_DWORD *)v12;
          v12 = (int (__fastcall *)(int *, int))((char *)v12 + 4);
        }
        while ( (unsigned int)v12 < (unsigned int)sub_423F90 );
        *(_DWORD *)((char *)v5 + v11 + 1507067059) = i;
        v13 = *(_DWORD *)(v5[3] + 120528);
        if ( v13 )
        {
          if ( v5[1] < 0xFA0000u )
          {
            v14 = v5[2];
            if ( v14 < 0xFA0000 )
              *(_BYTE *)(v5[1] / 16000 + (((int)v14 / 16000) << 10) + v13) = -2;
          }
        }
        v4 = i;
        v5[6] = 0;
        v5[4] = 0;
      }
      else
      {
        v5 = 0;
      }
      v15 = this[1875];
      if ( v15 >= 304 )
      {
        sub_40B7E0((unsigned int)v5);
      }
      else
      {
        this[v15 + 1571] = (int)v5;
        ++this[1875];
      }
      ++v4;
    }
  }
  v16 = 300847115;
  v17 = 75;
  do
    v16 ^= (unsigned int)*(&dword_4A7280 + v17-- - 90564);
  while ( v17 );
  v18 = *(int *)((char *)this + v16 + 440372700);
  result = a3;
  if ( v18 == a3 )
  {
    result = this[1875];
    v26 = 0;
    if ( result > 0 )
    {
      v21 = this + 1571;
      do
      {
        v25 = *v21;
        v22 = (*(int (__thiscall **)(int *, _DWORD))(*this + 152))(this, *a2);
        ++v21;
        ++a2;
        *(_DWORD *)(v25 + 20) = v22;
        result = ++v26;
      }
      while ( v26 < this[1875] );
    }
  }
  return result;
}
// 4A7280: using guessed type int (__stdcall *dword_4A7280)(_DWORD, _DWORD);
// 4AC35C: using guessed type int (__stdcall *off_4AC35C)(int, int);

//----- (00444890) --------------------------------------------------------
int __thiscall sub_444890(int this)
{
  return dword_4A7348(dword_4C1A38, 107, *(_DWORD *)(this + 197821), sub_4190A0, this);
}
// 4A7348: using guessed type int (__stdcall *dword_4A7348)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004448B0) --------------------------------------------------------
int __userpurge sub_4448B0@<eax>(int *a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, const char *a6)
{
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  int v10; // kr00_4
  int v11; // edx
  int v12; // ebp
  __int64 v13; // rax
  int v14; // edi
  int v15; // eax
  int v16; // ebp
  int v17; // eax
  int v18; // ecx
  char v19; // al
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // ebx
  int v24; // edi
  int v25; // kr08_4
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  unsigned int v29; // eax
  int v30; // edi
  int v31; // ecx
  int v33; // [esp+8h] [ebp-24h]

  v7 = a1[302];
  v8 = -(*(_DWORD *)(v7 + 7999) == 0);
  LOBYTE(v8) = v8 & 0xFE;
  v9 = v8 + 8;
  v10 = (v8 + 8) * (8 * a1[2] / a4);
  v11 = *a1;
  a1[4966] = v10 / 8;
  LOBYTE(a2) = *(_BYTE *)(v7 + 8069);
  v33 = a2;
  LOBYTE(a2) = *(_BYTE *)(v7 + 8230);
  LOBYTE(v7) = *(_BYTE *)(v7 + 8055);
  (*(void (__thiscall **)(int *, int *, int *, int, int, int, int, int, int))(v11 + 104))(
    a1,
    a1 + 4957,
    a1 + 4967,
    v10 / 8,
    a3,
    a5,
    v7,
    a2,
    v33);
  v12 = a1[4966];
  v13 = 4 * v9 * (a1[2] / 24);
  v14 = ((BYTE4(v13) & 7) + (int)v13) >> 3;
  LODWORD(v13) = v12 * a1[2547] / 0x4000 - v14 / 2;
  a1[4958] = v12 * a1[2546] / 0x4000 - v14 / 2;
  a1[4959] = v13;
  v15 = a1[4958];
  v16 = v12 - v14;
  if ( v15 >= 0 )
  {
    if ( v15 > v16 )
      a1[4958] = v16;
  }
  else
  {
    a1[4958] = 0;
  }
  v17 = a1[4959];
  if ( v17 >= 0 )
  {
    if ( v17 > v16 )
      a1[4959] = v16;
  }
  else
  {
    a1[4959] = 0;
  }
  v18 = v14 + a1[4959];
  a1[4960] = v14 + a1[4958];
  v19 = *((_BYTE *)a1 + 75368);
  a1[4961] = v18;
  if ( v19 )
  {
    v24 = a1[2];
    v25 = 4 * v24 / 24 * (*(_DWORD *)(a1[302] + 7999) != 0 ? 8 : 6);
    v20 = v24 - v25 / 8 - 6;
    v21 = a1[3] - v25 / 8 - 6;
    v22 = v24 - 6;
    v23 = a1[3] - 6;
  }
  else
  {
    v20 = a1[2];
    v21 = a1[3];
    v22 = v20;
    v23 = v21;
  }
  a1[4962] = v20;
  a1[4963] = v21;
  a1[4964] = v22;
  a1[4965] = v23;
  (*(void (__thiscall **)(int *, int, int, int, int, int))(*a1 + 96))(a1, a1[300], v20, v21, v22, v23);
  v26 = a1[4963];
  v27 = a1[3];
  a1[18824] = a1[4962];
  v28 = a1[2893];
  a1[18825] = v26;
  sub_404B80(
    (_DWORD *)a1[2892],
    a1[2] - *(_DWORD *)(a1[2892] + 612),
    v27 - *(_DWORD *)(a1[2892] + 616) - *(_DWORD *)(v28 + 616),
    1,
    0);
  sub_404B80((_DWORD *)a1[2893], a1[2] - *(_DWORD *)(a1[2893] + 612), a1[3] - *(_DWORD *)(a1[2893] + 616), 1, 0);
  sub_405930(a1[4957], a1[4962], a1[4963], a1[4958], a1[4959], a1[4960], a1[4961], *(_BYTE *)(a1[302] + 8055));
  v29 = a1[2] - a1[18806] * strlen(a6) - 6;
  a1[18826] = v29;
  v30 = *a1;
  v31 = a1[4963] - a1[18807] - 4;
  a1[18827] = v31;
  return (*(int (__thiscall **)(int *, unsigned int, int, const char *, _DWORD, int, int))(v30 + 236))(
           a1,
           v29,
           v31,
           a6,
           0,
           -1,
           1);
}

//----- (00444BD0) --------------------------------------------------------
void __thiscall sub_444BD0(_DWORD *this, int a2, int a3, int a4, char a5)
{
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // edi
  int v10; // edx
  unsigned int v11; // edx
  unsigned int v12; // ecx
  int v13; // edi
  int v14; // edi
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  unsigned int v27; // edx
  int v28; // eax
  int v29; // ecx
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  int v34; // edi
  unsigned int v35; // eax
  int v36; // ecx
  int v37; // ecx
  int v38; // eax
  int v39; // ecx
  int v40; // edx
  unsigned int v41; // edx
  int v42; // eax
  _DWORD *v43; // ebx
  int v44; // esi
  int v45; // eax
  int v46; // esi
  int v47; // [esp+Ch] [ebp-Ch]
  int savedregs; // [esp+18h] [ebp+0h] BYREF
  bool v49; // [esp+2Bh] [ebp+13h]

  v6 = this[23];
  if ( v6 != 8 && a2 && (this[24] & 0x40) == 0 )
  {
    if ( a2 == -1 )
    {
      (*(void (__thiscall **)(_DWORD *))(*this + 40))(this);
    }
    else if ( *((_BYTE *)this + 156) && this[130] + this[131] >= 0 && a2 >= 0 )
    {
      v7 = this[3] + 1308 * v6 + 12508;
      v47 = v7;
      if ( this[99] + this[100] > 0 )
      {
        v8 = *(_DWORD *)(v7 + 960);
        if ( v8 > 0 )
          a2 = 1000 * (a2 / 1000 * (v8 - this[100] - this[99]) / v8);
      }
      if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 148))(this) )
      {
        v9 = *(_DWORD *)(this[3] + 12180);
        if ( v9 != 1000 )
        {
          if ( v9 == 1999 )
            v10 = 1999 * a2 / 1000;
          else
            v10 = v9 * (a2 / 1000);
          a2 = v10;
        }
      }
      v11 = this[2];
      v12 = this[1];
      v13 = *(_DWORD *)(this[3] + 120528);
      if ( !v13
        || v12 >= 0xFA0000
        || v11 >= 0xFA0000
        || *(unsigned __int8 *)((int)v12 / 16000 + (((int)v11 / 16000) << 10) + v13) != 171 )
      {
        goto LABEL_25;
      }
      if ( this[12] + this[13] )
        (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)this[3] + 380))(this[3], 21);
      if ( (int)this[10] >= 0 )
      {
LABEL_25:
        if ( a2 )
        {
          sub_417EB0((int)&dword_4C1AD0, 22344, &a5, 4);
          v14 = a3;
          (*(void (__thiscall **)(_DWORD, int, int, int, int))(*(_DWORD *)this[3] + 332))(
            this[3],
            a3,
            a4,
            (this[130] + this[131]) / 1000,
            a2 / 1000);
          v15 = this[115];
          if ( *(_DWORD *)(this[116] + v15) )
          {
            v16 = *(_DWORD *)(this[112] + v15);
            if ( this[113] + this[114] <= v16 )
              v16 = this[113] + this[114];
          }
          else
          {
            v16 = *(_DWORD *)(v15 + this[111]);
          }
          v49 = this[130] + this[131] < 200 * (5 * v16 - 50);
          this[130] += this[131] - dword_4C1AE4 - a2;
          v17 = dword_4C1AE4;
          this[131] = dword_4C1AE4;
          if ( this[6] == a3 )
          {
            if ( this[130] + v17 < 0 )
            {
              v18 = dword_4C1AE4;
              this[131] = dword_4C1AE4;
              this[130] = -v18;
            }
          }
          else
          {
            v19 = this[3];
            v20 = *(_DWORD *)(v19 + 12116);
            if ( v20 > 0 && this[130] + this[131] < 1000 * v20 )
            {
              v21 = *(_DWORD *)(v19 + 23104);
              if ( v21 - this[163] > 200 )
              {
                this[163] = v21;
                this[8] += this[9] - dword_4C1AE4 - 1;
                v22 = dword_4C1AE4;
                this[9] = dword_4C1AE4;
                if ( this[8] + v22 < 0 )
                {
                  v23 = dword_4C1AE4;
                  this[9] = dword_4C1AE4;
                  this[8] = -v23;
                }
                v24 = sub_40B720((int)&savedregs, 0x40u);
                if ( v24 )
                {
                  v25 = this[1];
                  v26 = this[2];
                  *(_DWORD *)(v24 + 12) = this[3];
                  *(_DWORD *)(v24 + 8) = 0;
                  *(_DWORD *)(v24 + 4) = 0;
                  *(_DWORD *)(v24 + 4) = v25;
                  *(_DWORD *)(v24 + 28) = 52;
                  *(_DWORD *)(v24 + 48) = 52;
                  v14 = a3;
                  *(_DWORD *)(v24 + 8) = v26;
                  *(_DWORD *)(v24 + 20) = 0;
                  *(_DWORD *)(v24 + 16) = 0;
                  *(_DWORD *)(v24 + 24) = 0;
                  *(_DWORD *)(v24 + 32) = 0;
                  *(_DWORD *)(v24 + 36) = 14;
                  *(_DWORD *)(v24 + 44) = 26;
                  *(_BYTE *)(v24 + 52) = 1;
                  *(_DWORD *)v24 = off_4AC414;
                  *(_DWORD *)(v24 + 40) = 0;
                  v27 = v24;
                }
                else
                {
                  v27 = 0;
                }
                v28 = -4039931;
                v29 = 48;
                do
                  v28 ^= *(_DWORD *)&aScrty[4 * v29-- - 9588];
                while ( v29 );
                v30 = *(_DWORD *)((char *)this + v28 + 3346884) + 7656;
                v31 = *(_DWORD *)(v30 + 1024);
                if ( v31 >= 256 )
                {
                  sub_40B7E0(v27);
                }
                else
                {
                  *(_DWORD *)(v30 + 4 * v31) = v27;
                  ++*(_DWORD *)(v30 + 1024);
                }
              }
            }
          }
          if ( this[130] + this[131] >= 0 )
          {
            if ( v49 && *(int *)(v47 + 1004) > 0 && !(rand() % (200000 * *(_DWORD *)(v47 + 1004) / a2 + 1)) )
            {
              v34 = *this;
              v35 = rand();
              (*(void (__thiscall **)(_DWORD *, int, _DWORD, int, _DWORD))(v34 + 36))(
                this,
                dword_4AB17C[v35 % 0x16],
                0,
                1,
                0);
              this[8] += this[9] - dword_4C1AE4 - 1;
              v36 = dword_4C1AE4;
              this[9] = dword_4C1AE4;
              if ( this[8] + v36 < 0 )
              {
                v37 = dword_4C1AE4;
                this[9] = dword_4C1AE4;
                this[8] = -v37;
              }
              v38 = sub_40B720((int)&savedregs, 0x40u);
              if ( v38 )
              {
                v39 = this[1];
                v40 = this[2];
                *(_DWORD *)(v38 + 12) = this[3];
                *(_DWORD *)(v38 + 8) = 0;
                *(_DWORD *)(v38 + 4) = 0;
                *(_DWORD *)(v38 + 4) = v39;
                *(_DWORD *)(v38 + 8) = v40;
                *(_DWORD *)(v38 + 20) = 0;
                *(_DWORD *)(v38 + 16) = 0;
                *(_DWORD *)(v38 + 24) = 0;
                *(_DWORD *)(v38 + 28) = 52;
                *(_DWORD *)(v38 + 32) = 0;
                *(_DWORD *)(v38 + 36) = 14;
                *(_DWORD *)(v38 + 44) = 26;
                *(_DWORD *)(v38 + 48) = 52;
                *(_BYTE *)(v38 + 52) = 1;
                *(_DWORD *)v38 = off_4AC414;
                *(_DWORD *)(v38 + 40) = 0;
                v41 = v38;
              }
              else
              {
                v41 = 0;
              }
              v42 = 0;
              v43 = (_DWORD *)(&loc_422656 + 2);
              do
                v42 -= *v43++;
              while ( v43 < (_DWORD *)((char *)&loc_422879 + 3) );
              v44 = *(_DWORD *)((char *)this + v42 - 1549829561);
              v45 = *(_DWORD *)(v44 + 8680);
              v46 = v44 + 7656;
              if ( v45 >= 256 )
              {
                sub_40B7E0(v41);
              }
              else
              {
                *(_DWORD *)(v46 + 4 * v45) = v41;
                ++*(_DWORD *)(v46 + 1024);
              }
            }
          }
          else
          {
            sub_417EB0((int)&dword_4C1AD0, 17476, 0, 0);
            (*(void (__thiscall **)(_DWORD *))(*this + 40))(this);
            v32 = 204376927;
            v33 = 169;
            do
              v32 ^= *(_DWORD *)&aAsyncFileQueue[4 * v33-- - 365684];
            while ( v33 );
            (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)((char *)this + v32 + 3353988) + 348))(
              *(_DWORD *)((char *)this + v32 + 3353988),
              v14,
              this[8] + this[9]);
            (*(void (__thiscall **)(_DWORD *, int))(*this + 84))(this, -1);
          }
        }
      }
    }
  }
}
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);
// 4C1AD0: using guessed type int dword_4C1AD0;
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (004451E0) --------------------------------------------------------
int __thiscall sub_4451E0(int this, int a2, int a3)
{
  int result; // eax
  int v4; // esi
  int v5; // edx
  int v6; // ebx
  _DWORD *v7; // esi
  int v8; // eax
  int (__fastcall *v9)(int *, int); // ebx
  int v10; // ecx

  result = *(_DWORD *)(this + 64);
  if ( result <= 0 )
  {
    result = *(_DWORD *)(this + 76);
    if ( !result )
    {
      v4 = *(_DWORD *)(this + 12);
      if ( *(_DWORD *)(v4 + 12056) != 2 || (result = *(_DWORD *)(this + 48) + *(_DWORD *)(this + 52)) == 0 )
      {
        v5 = *(_DWORD *)(v4 + 7500);
        v6 = 0;
        result = 16000 * a2;
        if ( v5 > 0 )
        {
          result = v4 + 6284;
          while ( 1 )
          {
            v7 = *(_DWORD **)result;
            if ( *(_DWORD *)(*(_DWORD *)result + 4) == 16000 * a2 && v7[2] == 16000 * a3 )
              break;
            ++v6;
            result += 4;
            if ( v6 >= v5 )
              return result;
          }
          if ( v7[5] != *(_DWORD *)(this + 88) )
          {
            result = v7[4];
            if ( result <= 0 )
            {
              result = v7[6];
              if ( result <= 0 )
              {
                if ( *(_BYTE *)(this + 156) )
                {
                  v8 = 0;
                  v9 = (int (__fastcall *)(int *, int))(&loc_423E79 + 3);
                  do
                  {
                    v8 -= *(_DWORD *)v9;
                    v9 = (int (__fastcall *)(int *, int))((char *)v9 + 4);
                  }
                  while ( (unsigned int)v9 < (unsigned int)sub_423F90 );
                  v10 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v8 + 1505556687 + this + 1510356) + 120076) + 276);
                  (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v10 + 20))(v10, 0, 0, 0, 0);
                  (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 12) + 420))(
                    *(_DWORD *)(this + 12),
                    v7[7]);
                }
                result = *(_DWORD *)(this + 12);
                if ( *(_DWORD *)(result + 12056) )
                  v7[4] = 300;
                else
                  v7[5] = *(_DWORD *)(this + 88);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00445310) --------------------------------------------------------
char __thiscall sub_445310(_DWORD *this)
{
  char result; // al
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  __int16 *v9; // ebp
  int v10; // ecx
  int v11; // eax
  bool v12; // cc
  int v13; // [esp+4h] [ebp-44h]
  __int16 *v14; // [esp+8h] [ebp-40h]
  int v15; // [esp+Ch] [ebp-3Ch]
  int v16; // [esp+10h] [ebp-38h]
  int v17; // [esp+14h] [ebp-34h] BYREF
  int v18; // [esp+18h] [ebp-30h] BYREF
  int v19; // [esp+1Ch] [ebp-2Ch]
  int v20; // [esp+20h] [ebp-28h]
  int v21; // [esp+24h] [ebp-24h]
  int v22[4]; // [esp+28h] [ebp-20h] BYREF
  int v23[4]; // [esp+38h] [ebp-10h] BYREF

  result = sub_4052C0(this[300]);
  if ( result )
  {
    v3 = this[2];
    v4 = this[3];
    v18 = (this[2546] + 2 * (640 - v3 / 2) + 640 - v3 / 2) / 320;
    v5 = this[2546];
    v19 = (this[2547] + 2 * (640 - v4 / 2) + 640 - v4 / 2) / 320;
    v6 = (v3 - v3 / 2 + v5 + 2 * (v3 - v3 / 2) + 2240) / 320;
    v7 = this[2547];
    v20 = v6;
    v22[0] = 0;
    v22[1] = 0;
    v21 = (v4 - v4 / 2 + v7 + 2 * (v4 - v4 / 2) + 2240) / 320;
    v22[2] = 63;
    v22[3] = 63;
    sub_454CE0(&v18, v22);
    sub_445560((int)this, v23);
    v15 = v18;
    if ( v18 <= v20 )
    {
      v8 = 63 * v18;
      v16 = 63 * v18;
      do
      {
        v13 = v19;
        v9 = (__int16 *)&this[v8 + 5133 + v19];
        v14 = v9;
        if ( v19 <= v21 )
        {
          do
          {
            v10 = this[2] / 2 - (this[2546] - *v9) / 3;
            v11 = this[3] / 2 - (this[2547] - v9[1]) / 3;
            if ( (unsigned int)v10 < this[2] && (unsigned int)v11 < this[3] && (v10 < v23[0] || v11 < v23[1]) )
            {
              *(_DWORD *)(this[300] + 28) = *(_DWORD *)(this[300] + 16) + v11 * *(_DWORD *)(this[300] + 20);
              v17 = this[13073];
              sub_46CAB0(
                *(_DWORD *)(this[300] + 28) + v10 * *(_DWORD *)(this[300] + 24),
                &v17,
                *(_DWORD *)(this[300] + 24));
            }
            v9 = v14 + 2;
            v12 = ++v13 <= v21;
            v14 += 2;
          }
          while ( v12 );
          v8 = v16;
        }
        v8 += 63;
        v12 = ++v15 <= v20;
        v16 = v8;
      }
      while ( v12 );
    }
    sub_4455F0((int)this, 1, 5);
    result = sub_405330(this[300]);
  }
  return result;
}

//----- (00445560) --------------------------------------------------------
_DWORD *__thiscall sub_445560(int this, _DWORD *a2)
{
  int v2; // edx
  _DWORD *result; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // esi
  int v7; // ecx
  int v8; // kr00_4

  if ( *(_BYTE *)(this + 75368) )
  {
    v5 = *(_DWORD *)(this + 1208);
    v6 = *(_DWORD *)(this + 8);
    v7 = *(_DWORD *)(this + 12);
    v8 = 4 * v6 / 24 * (*(_DWORD *)(v5 + 7999) != 0 ? 8 : 6);
    result = a2;
    a2[2] = v6 - 6;
    *a2 = v6 - v8 / 8 - 6;
    a2[1] = v7 - v8 / 8 - 6;
    a2[3] = v7 - 6;
  }
  else
  {
    v2 = *(_DWORD *)(this + 12);
    result = a2;
    v4 = *(_DWORD *)(this + 8);
    *a2 = v4;
    a2[1] = v2;
    a2[2] = v4;
    a2[3] = v2;
  }
  return result;
}

//----- (004455F0) --------------------------------------------------------
int __thiscall sub_4455F0(int this, int a2, int a3)
{
  int v4; // edi
  int v5; // ebx
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // edx
  int result; // eax
  int v10; // ebp
  int v11; // edx
  int v12; // eax
  __int16 *v13; // ebp
  int v14; // edi
  int v15; // eax
  bool v16; // cc
  int v17; // [esp+10h] [ebp-34h]
  __int16 *v18; // [esp+14h] [ebp-30h]
  int v19; // [esp+18h] [ebp-2Ch]
  int v20; // [esp+1Ch] [ebp-28h]
  int v21; // [esp+20h] [ebp-24h] BYREF
  int v22; // [esp+24h] [ebp-20h]
  int v23; // [esp+28h] [ebp-1Ch]
  int v24; // [esp+2Ch] [ebp-18h]
  int v25; // [esp+30h] [ebp-14h]
  int v26; // [esp+34h] [ebp-10h] BYREF
  int v27; // [esp+38h] [ebp-Ch]
  int v28; // [esp+3Ch] [ebp-8h]
  int v29; // [esp+40h] [ebp-4h]

  v4 = *(_DWORD *)(this + 8);
  v5 = *(_DWORD *)(this + 12);
  v22 = (*(_DWORD *)(this + 10184) + a3 * (1920 / a3 - v4 / 2)) / 320;
  v23 = (*(_DWORD *)(this + 10188) + a3 * (1920 / a3 - v5 / 2)) / 320;
  v6 = (a3 * (v4 + 1920 / a3 - v4 / 2) + *(_DWORD *)(this + 10184) + 320) / 320;
  v7 = *(_DWORD *)(this + 10188);
  v24 = v6;
  v8 = (int)((unsigned __int64)(1717986919i64 * (a3 * (1920 / a3 + v5 - v5 / 2) + v7 + 320)) >> 32) >> 7;
  result = v22;
  v10 = (v8 >> 31) + v8;
  v11 = v23;
  v25 = v10;
  if ( v22 < v6 && v23 < v10 )
  {
    if ( v22 < 0 )
    {
      v22 = 0;
      result = 0;
    }
    if ( v23 < 0 )
    {
      v23 = 0;
      v11 = 0;
    }
    if ( v6 > 63 )
    {
      v24 = 63;
      v6 = 63;
    }
    if ( v10 > 63 )
    {
      v25 = 63;
      v10 = 63;
    }
    if ( v6 < 0 )
    {
      v24 = 0;
      v6 = 0;
    }
    if ( v10 < 0 )
      v25 = 0;
    if ( result > 63 )
    {
      v22 = 63;
      result = 63;
    }
    if ( v11 > 63 )
    {
      v23 = 63;
      v11 = 63;
    }
  }
  if ( *(_BYTE *)(this + 75368) )
  {
    v12 = 4 * v4 / 24 * (*(_DWORD *)(*(_DWORD *)(this + 1208) + 7999) != 0 ? 8 : 6) / 8;
    CVecCtrlMob::MoveContext::FlyContext::FlyContext(
      (CVecCtrlMob::MoveContext::FlyContext *)&v26,
      (SECPOINT *)(v4 - v12 - 6),
      (TSecType<int> *)(v5 - v12 - 6),
      (TSecType<long> *)(v4 - 6),
      (TSecType<long> *)(v5 - 6));
    result = v22;
    v6 = v24;
    v11 = v23;
  }
  else
  {
    v26 = v4;
    v27 = v5;
    v28 = v4;
    v29 = v5;
  }
  v19 = result;
  if ( result <= v6 )
  {
    result = 63 * (result + 63 * a2);
    v20 = result;
    do
    {
      v17 = v11;
      v13 = (__int16 *)(this + 4 * (result + v11) + 20532);
      v18 = v13;
      if ( v11 <= v25 )
      {
        do
        {
          v14 = *(_DWORD *)(this + 8) / 2 - (*(_DWORD *)(this + 10184) - *v13) / a3;
          v15 = *(_DWORD *)(this + 12) / 2 - (*(_DWORD *)(this + 10188) - v13[1]) / a3;
          if ( (unsigned int)v14 < *(_DWORD *)(this + 8)
            && (unsigned int)v15 < *(_DWORD *)(this + 12)
            && (v14 < v26 || v15 < v27) )
          {
            *(_DWORD *)(*(_DWORD *)(this + 1200) + 28) = *(_DWORD *)(*(_DWORD *)(this + 1200) + 16)
                                                       + v15 * *(_DWORD *)(*(_DWORD *)(this + 1200) + 20);
            v21 = *(_DWORD *)(this + 4 * a2 + 52292);
            sub_46CAB0(
              *(_DWORD *)(*(_DWORD *)(this + 1200) + 28) + v14 * *(_DWORD *)(*(_DWORD *)(this + 1200) + 24),
              &v21,
              *(_DWORD *)(*(_DWORD *)(this + 1200) + 24));
          }
          v13 = v18 + 2;
          v16 = ++v17 <= v25;
          v18 += 2;
        }
        while ( v16 );
        result = v20;
        v6 = v24;
        v11 = v23;
      }
      result += 63;
      v20 = result;
      ++v19;
    }
    while ( v19 <= v6 );
  }
  return result;
}

//----- (00445920) --------------------------------------------------------
int __thiscall sub_445920(_DWORD *this, __int16 a2, int a3)
{
  int v4; // edi
  int v5; // eax
  int v6; // edx

  v4 = this[2 * a3 + 29966];
  v5 = 4;
  if ( !*((_BYTE *)this + a3 + 120480) )
    v5 = this[2 * a3 + 29967];
  *((_BYTE *)this + a3 + 120480) = 1;
  *(_BYTE *)v4 = 14;
  *(_BYTE *)(v4 + 1) = a3;
  *(_WORD *)(v4 + 2) = a2;
  v6 = *this;
  if ( v5 <= 512 )
    (*(void (__thiscall **)(_DWORD *, int, int, int))(v6 + 16))(this, v4, v5, 1);
  else
    (*(void (__thiscall **)(_DWORD *, int, int, _DWORD))(v6 + 44))(this, v4, v5, 0);
  return (*(int (__thiscall **)(_DWORD *, _DWORD, int, int))(this[27905] + 4))(
           this + 27905,
           this[1876],
           v4 + 4,
           this[2 * a3 + 29967] - 4);
}

//----- (004459B0) --------------------------------------------------------
unsigned int sub_4459B0()
{
  int v0; // ecx
  int v1; // eax
  int v2; // edx
  char v3; // bl
  char v4; // bl
  int (__stdcall *v5)(char *, char *, int, int *, char *, char *, char *, int); // esi
  bool v6; // bl
  int v7; // eax
  int v8; // esi
  int v9; // ecx
  char v10; // dl
  char v11; // dl
  bool v12; // bl
  unsigned int result; // eax
  char v14[256]; // [esp+Ch] [ebp-28Ch] BYREF
  char v15[256]; // [esp+10Ch] [ebp-18Ch] BYREF
  char v16[64]; // [esp+20Ch] [ebp-8Ch] BYREF
  char v17[64]; // [esp+24Ch] [ebp-4Ch] BYREF
  char v18[4]; // [esp+28Ch] [ebp-Ch] BYREF
  char v19[4]; // [esp+290h] [ebp-8h] BYREF
  int v20; // [esp+294h] [ebp-4h] BYREF

  v0 = BYTE2(dword_4ADF58) ^ (unsigned __int8)dword_4ADF58;
  v1 = BYTE1(dword_4ADF58) ^ 0x45;
  v17[0] = v1 ^ HIBYTE(dword_4ADF58);
  if ( (unsigned __int8)v1 != HIBYTE(dword_4ADF58) )
  {
    v2 = 0;
    do
    {
      v3 = byte_4ADF5C[v2++];
      v1 ^= v0;
      v4 = v1 ^ v3;
      v17[v2] = v4;
    }
    while ( v4 );
  }
  v5 = (int (__stdcall *)(char *, char *, int, int *, char *, char *, char *, int))dword_4A713C;
  v6 = dword_4A713C(v17, v15, 256, &v20, v19, v18, v16, 64) && v20;
  memset(v17, 0, sizeof(v17));
  if ( v6 )
    goto LABEL_20;
  dword_4A7128(v14, 256);
  if ( v5(v14, v15, 256, &v20, v19, v18, v16, 64) )
  {
    if ( v20 )
      goto LABEL_20;
  }
  v7 = BYTE1(dword_4ADF50) ^ 0x45;
  v8 = BYTE2(dword_4ADF50) ^ (unsigned __int8)dword_4ADF50;
  v17[0] = v7 ^ HIBYTE(dword_4ADF50);
  if ( (unsigned __int8)v7 != HIBYTE(dword_4ADF50) )
  {
    v9 = 0;
    do
    {
      v10 = byte_4ADF54[v9++];
      v7 ^= v8;
      v11 = v7 ^ v10;
      v17[v9] = v11;
    }
    while ( v11 );
  }
  v12 = dword_4A713C(v17, v15, 256, &v20, v19, v18, v16, 64) && v20;
  memset(v17, 0, sizeof(v17));
  if ( v12 )
LABEL_20:
    result = abs32(v20);
  else
    result = 1;
  return result;
}
// 4A7128: using guessed type int (__stdcall *dword_4A7128)(_DWORD, _DWORD);
// 4A713C: using guessed type int (__stdcall *dword_4A713C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4ADF50: using guessed type int dword_4ADF50;
// 4ADF58: using guessed type int dword_4ADF58;

//----- (00445B60) --------------------------------------------------------
char __thiscall sub_445B60(_DWORD *this, int a2, int a3)
{
  int v4; // edx
  int v5; // eax
  int (__fastcall *v6)(int *, int); // ebx
  _DWORD *v7; // eax
  int v8; // ebx
  int v9; // esi
  _DWORD *v10; // ecx
  int v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // esi
  _DWORD *i; // ecx
  int v20; // [esp+18h] [ebp+Ch]

  v4 = this[a3 + 28405];
  v20 = v4;
  v5 = 0;
  v6 = (int (__fastcall *)(int *, int))(&loc_423E79 + 3);
  do
  {
    v5 -= *(_DWORD *)v6;
    v6 = (int (__fastcall *)(int *, int))((char *)v6 + 4);
  }
  while ( (unsigned int)v6 < (unsigned int)sub_423F90 );
  v7 = (_DWORD *)(v5 + 1036298535);
  if ( *(_DWORD *)((char *)this + (_DWORD)v7 + 470780552) )
  {
    v8 = this[1875];
    v9 = 0;
    if ( v8 > 0 )
    {
      v10 = this + 1571;
      while ( 1 )
      {
        v7 = (_DWORD *)*v10;
        if ( *(_DWORD *)(*v10 + 28) == a2 )
          break;
        ++v9;
        ++v10;
        if ( v9 >= v8 )
          goto LABEL_14;
      }
      v11 = *(_DWORD *)(v7[3] + 120528);
      if ( v11 )
      {
        v12 = v7[1];
        if ( v12 < 0xFA0000 )
        {
          v13 = v7[2];
          if ( v13 < 0xFA0000 )
            *(_BYTE *)((int)v12 / 16000 + (((int)v13 / 16000) << 10) + v11) = 0;
        }
      }
      sub_40B7E0(this[v9 + 1571]);
      sub_46CAB0((unsigned int)&this[v9 + 1571], &this[v9 + 1572], 4 * (this[1875] + 0x3FFFFFFF * (v9 + 1)));
      v7 = (_DWORD *)(this[1875] - 1);
      this[1875] = v7;
LABEL_14:
      v4 = v20;
    }
    if ( v4 )
    {
      *(_DWORD *)(v4 + 48) += *(_DWORD *)(v4 + 52) - dword_4C1AE4 + 1;
      *(_DWORD *)(v4 + 52) = dword_4C1AE4;
      LOBYTE(v7) = *(_BYTE *)(v4 + 156);
      if ( (_BYTE)v7 )
      {
        v14 = this[2721];
        v15 = dword_4C1AE4 - v14;
        v7 = (_DWORD *)(this[542] + 596);
        v16 = v14 - (dword_4C1AE4 - v14);
        dword_4C1AE4 = v15;
        v7[1] = v15;
        *v7 = v16;
      }
    }
  }
  else if ( v4 )
  {
    v17 = this[1875];
    v7 = 0;
    if ( v17 > 0 )
    {
      for ( i = this + 1571; *(_DWORD *)(*i + 28) != a2; ++i )
      {
        v7 = (_DWORD *)((char *)v7 + 1);
        if ( (int)v7 >= v17 )
          return (char)v7;
      }
      v7 = *(_DWORD **)(v4 + 88);
      *(_DWORD *)(*i + 20) = v7;
    }
  }
  return (char)v7;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00445D70) --------------------------------------------------------
void __thiscall sub_445D70(_DWORD *this, unsigned int a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int v7; // esi

  v3 = 1348957927;
  v4 = 240;
  do
    v3 ^= *(_DWORD *)&aLicense[4 * v4-- - 382632];
  while ( v4 );
  v5 = *(_DWORD *)((char *)this + v3 + 477517644);
  v6 = (int)this + v3 + 477516620;
  if ( v5 >= 256 )
  {
    sub_40B7E0(a2);
  }
  else
  {
    *(_DWORD *)(v6 + 4 * v5) = a2;
    ++*(_DWORD *)(v6 + 1024);
  }
  v7 = this[30132];
  if ( v7 )
    *(_BYTE *)(*(_DWORD *)(a2 + 4) + (*(_DWORD *)(a2 + 8) << 10) + v7) = -1;
}

//----- (00445DF0) --------------------------------------------------------
int __thiscall sub_445DF0(_DWORD *this)
{
  int result; // eax

  (*(void (__thiscall **)(_DWORD *, int))(this[12] + 12))(this + 12, 1);
  result = this[49382];
  if ( result )
  {
    result = dword_4A7398(this[49382]);
    this[49382] = 0;
  }
  return result;
}
// 4A7398: using guessed type int (__stdcall *dword_4A7398)(_DWORD);

//----- (00445E20) --------------------------------------------------------
char __userpurge sub_445E20@<al>(__int64 a1@<edx:eax>, int *a2@<ecx>, int a3)
{
  int v3; // edi
  int v4; // ebx
  int v6; // eax
  char v7; // cl
  int v8; // ecx
  int v9; // ecx
  __int16 v10; // ax
  __int16 v11; // ax
  int v12; // eax
  _DWORD *v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // edi
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  __int16 v20; // cx
  _DWORD *v22; // eax
  int v23; // edi
  int v24; // ebx
  int v25; // edi
  int v26; // edi
  int v27; // eax
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  int v31; // edx
  int i; // [esp+Ch] [ebp-4h]
  int savedregs; // [esp+10h] [ebp+0h] BYREF

  v3 = a3;
  v4 = 0;
  for ( i = 0; v4 < a3; i = ++v4 )
  {
    HIDWORD(a1) = a2[48] + 1;
    --a2[36];
    LODWORD(a1) = a2[39];
    a2[48] = HIDWORD(a1);
    if ( (int)a1 <= 0 )
    {
      v8 = a2[2];
      a2[43] = a2[1];
      a2[44] = v8;
      v9 = a2[3];
      if ( *(_DWORD *)(v9 + 12088) )
      {
        v10 = *(_WORD *)((_BYTE *)a2 + 167) & 0x1F;
        if ( v10 == 3 || v10 == 4 )
          sub_42EAD0(a2, *(_DWORD *)(v9 + 13544), 1);
      }
      if ( a2[4] || a2[5] )
      {
        if ( (*(unsigned __int8 (__thiscall **)(int *))(*a2 + 16))(a2) )
          return 1;
        if ( a2[39] > 0 )
        {
          v11 = *(_WORD *)((_BYTE *)a2 + 167) & 0x1F;
          if ( v11 == 3 || v11 == 4 )
            break;
        }
        if ( *((_BYTE *)a2 + 108) )
        {
          if ( (a2[48] & 1) != 0 )
          {
            a2[3 * a2[28] + 6] = *(_DWORD *)(a2[3] + 23104);
            HIDWORD(a1) = a2[2] / 1000;
            LODWORD(a1) = 3 * a2[28];
            a2[(_DWORD)a1 + 7] = a2[1] / 1000;
            a2[(_DWORD)a1 + 8] = HIDWORD(a1);
            LODWORD(a1) = a2[28] + 1;
            a2[28] = a1;
            if ( (unsigned int)a1 >= 7 )
              a2[28] = 0;
          }
        }
      }
      if ( a2[33] <= 0 && (*((_BYTE *)a2 + 167) & 0x1F) != 6 && (v4 & 3) == 0 && !*((_BYTE *)a2 + 166) )
      {
        (*(void (__thiscall **)(int *))(*a2 + 36))(a2);
        if ( a2[39] > 1 )
        {
          v12 = 0;
          v13 = (_DWORD *)((char *)&loc_44EB73 + 1);
          do
            v12 -= *v13++;
          while ( v13 < (_DWORD *)((char *)&loc_44EC9F + 1) );
          (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)((char *)a2
                                                                                               + v12
                                                                                               - 1167007919)
                                                                                 + 260))(
            *(int *)((char *)a2 + v12 - 1167007919),
            *(_DWORD *)(*(_DWORD *)(a2[3] + 120076) + 128),
            *(int *)((char *)a2 + v12 - 1167007927),
            *(int *)((char *)a2 + v12 - 1167007923),
            0,
            0);
          v4 = i;
        }
      }
      if ( a2[39] <= 0 )
      {
        v14 = a2[33];
        if ( v14 > 0 )
        {
          v15 = v14 - 1;
          a2[33] = v15;
          if ( v15 > 0 )
          {
            v16 = *(_DWORD *)(a2[3] + 4 * a2[34] + 113620);
            if ( v16 )
            {
              v17 = abs32(a2[2] - *(_DWORD *)(v16 + 8));
              a1 = a2[1] - *(_DWORD *)(v16 + 4);
              LODWORD(a1) = (HIDWORD(a1) ^ a1) - HIDWORD(a1);
              if ( (int)a1 < v17 )
                LODWORD(a1) = v17;
              if ( a2[40] >= (int)a1 )
              {
                a2[40] = a1;
              }
              else
              {
                v18 = *a2;
                a2[33] = 0;
                (*(void (__thiscall **)(int *))(v18 + 20))(a2);
              }
            }
            else
            {
              v19 = *a2;
              a2[40] = 0;
              (*(void (__thiscall **)(int *))(v19 + 20))(a2);
            }
          }
          else
          {
            (*(void (__thiscall **)(int *))(*a2 + 20))(a2);
          }
        }
      }
    }
    else
    {
      v6 = a1 - 1;
      v7 = *((_BYTE *)a2 + 167) & 0x1F;
      a2[39] = v6;
      if ( v7 == 5 && (v6 == 30 || !v6) )
        (*(void (__thiscall **)(int *))(*a2 + 24))(a2);
      if ( !a2[39] )
        return 1;
    }
    v3 = a3;
  }
  if ( a2[39] <= 0 )
  {
    WORD2(a1) = *(_WORD *)((char *)a2 + 167);
    v20 = BYTE4(a1) & 0x1F;
    if ( v20 == 3 || v20 == 4 || v20 == 8 )
    {
      if ( a2[4] || a2[5] )
      {
        v22 = (_DWORD *)a2[3];
        if ( *(_BYTE *)(v22[5775] + 8050) )
        {
          v23 = a2[29] - v3;
          a2[29] = v23;
          if ( v23 <= 0 )
          {
            v24 = a2[2];
            a2[29] = v23 + 5;
            v25 = a2[1];
            if ( v25 >= v22[359] && v25 < v22[361] && v24 >= v22[360] && v24 < v22[362] )
            {
              if ( v20 == 8 )
                v26 = 40;
              else
                v26 = 10 * ((HIDWORD(a1) >> 5) & 3);
              v27 = sub_40B720((int)&savedregs, 0x40u);
              if ( v27 )
              {
                v28 = a2[1];
                v29 = a2[2];
                *(_DWORD *)(v27 + 12) = a2[3];
                *(_DWORD *)(v27 + 32) = v26;
                *(_DWORD *)(v27 + 8) = 0;
                *(_DWORD *)(v27 + 4) = 0;
                *(_DWORD *)(v27 + 20) = 0;
                *(_DWORD *)(v27 + 16) = 0;
                *(_DWORD *)(v27 + 24) = 0;
                *(_DWORD *)(v27 + 4) = v28;
                *(_DWORD *)(v27 + 28) = 30;
                *(_DWORD *)(v27 + 36) = 8;
                *(_DWORD *)(v27 + 44) = 10;
                *(_DWORD *)(v27 + 48) = 30;
                *(_BYTE *)(v27 + 52) = 0;
                *(_DWORD *)v27 = off_4AC414;
                *(_DWORD *)(v27 + 8) = v29;
                *(_DWORD *)(v27 + 40) = 0;
              }
              else
              {
                v27 = 0;
              }
              v30 = a2[3] + 7656;
              v31 = *(_DWORD *)(a2[3] + 8680);
              if ( v31 >= 256 )
              {
                sub_40B7E0(v27);
              }
              else
              {
                *(_DWORD *)(v30 + 4 * v31) = v27;
                ++*(_DWORD *)(v30 + 1024);
              }
            }
          }
        }
      }
      if ( a2[4] || a2[5] )
      {
        if ( a2[48] >= *(_DWORD *)(a2[3] + 11784) )
          return 1;
      }
      else if ( a2[48] >= *(_DWORD *)(a2[3] + 11376) )
      {
        return 1;
      }
    }
    else if ( v20 == 6 )
    {
      if ( a2[48] >= *(_DWORD *)(a2[3] + 11076) )
        return 1;
    }
    else if ( a2[48] >= *(_DWORD *)(a2[3] + 12232) )
    {
      return 1;
    }
  }
  return 0;
}
// 4461B9: variable 'a1' is possibly undefined
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);

//----- (004462D0) --------------------------------------------------------
int __thiscall sub_4462D0(int this)
{
  int v1; // edi
  int result; // eax
  int v4; // eax
  char v5; // bl
  int v6; // ebp
  int v7; // edx
  unsigned int v8; // ecx
  char v9; // dl
  char v10; // al
  int v11; // edx
  int v12; // [esp+8h] [ebp-38h]
  int v13; // [esp+Ch] [ebp-34h] BYREF
  int v14; // [esp+10h] [ebp-30h]
  int v15; // [esp+14h] [ebp-2Ch]
  int v16; // [esp+18h] [ebp-28h]
  int v17; // [esp+2Ch] [ebp-14h]
  int v18; // [esp+34h] [ebp-Ch]

  v1 = 0;
  v13 = 52;
  v18 = -1;
  v14 = 3267;
  result = dword_4A73A4(0, &v13);
  if ( !result )
  {
    v4 = sub_412170();
    v5 = v14;
    v6 = v18;
    v7 = v16 - 0x8000;
    v12 = v4;
    *(_DWORD *)(this + 832) = v15 - 0x8000;
    *(_DWORD *)(this + 836) = v7;
    while ( 1 )
    {
      v8 = *(_DWORD *)(this + 4 * v1 + 364) & 0xFF00;
      if ( !v8 )
        goto LABEL_32;
      v9 = 0;
      v10 = 0;
      if ( v8 >= 0x100 && v8 <= 0x2000 )
      {
        v11 = 1 << ((unsigned __int16)(v8 - 256) >> 8);
        if ( (v11 & v17) == 0 )
          goto LABEL_32;
        if ( (v11 & *(_DWORD *)(this + 840)) != 0 )
          v10 = 1;
        goto LABEL_27;
      }
      if ( v8 < 0x2100 || v8 > 0x2400 || (v5 & 0x40) == 0 )
        goto LABEL_32;
      if ( v8 == 8448 )
        break;
      if ( v8 == 8704 )
      {
        if ( v6 != 9000 )
          goto LABEL_24;
        goto LABEL_23;
      }
      if ( v8 == 8960 )
      {
        if ( v6 != 18000 )
          goto LABEL_24;
        goto LABEL_23;
      }
      if ( v8 == 9216 && v6 == 27000 )
        goto LABEL_23;
LABEL_24:
      if ( v6 == *(_DWORD *)(this + 844) )
        v10 = 1;
      if ( !v9 )
        goto LABEL_32;
LABEL_27:
      if ( *(_BYTE *)(v1 + this + 848) )
      {
        if ( v1 == 5 && *(_BYTE *)(this + 60) )
        {
          *(_BYTE *)(this + 11) = 1;
          goto LABEL_32;
        }
      }
      else if ( v12 - *(_DWORD *)(this + 4 * v1 + 900) >= 300 || !v10 )
      {
        *(_DWORD *)(this + 4 * v1 + 900) = v12;
        *(_DWORD *)(this + 88) = v1;
        *(_BYTE *)(this + 96) = v10;
      }
      *(_BYTE *)(v1 + this + 4) = 1;
LABEL_32:
      if ( ++v1 >= 50 )
      {
        result = v17;
        *(_DWORD *)(this + 844) = v6;
        *(_DWORD *)(this + 840) = result;
        return result;
      }
    }
    if ( v6 )
      goto LABEL_24;
LABEL_23:
    v9 = 1;
    goto LABEL_24;
  }
  *(_DWORD *)(this + 836) = 0;
  *(_DWORD *)(this + 832) = 0;
  return result;
}
// 4A73A4: using guessed type int (__stdcall *dword_4A73A4)(_DWORD, _DWORD);

//----- (00446B30) --------------------------------------------------------
int __thiscall sub_446B30(_DWORD *this, int a2, unsigned __int8 a3)
{
  int v4; // ebp
  int result; // eax
  _DWORD *v6; // ebx
  int i; // esi
  _DWORD *v8; // ecx
  int v9; // esi
  int v10; // edx

  v4 = 0;
  result = this[1908] + this[1909];
  if ( result > 0 )
  {
    v6 = this + 2173;
    for ( i = a3; ; i = a3 )
    {
      v8 = (_DWORD *)*v6;
      if ( i == *(_DWORD *)(*v6 + 156) > 0 && v8[1] != -1 )
      {
        v9 = v8[2];
        v10 = v8[1];
        if ( v10 >= *(_DWORD *)(v8[3] + 1436)
          && v10 < *(_DWORD *)(v8[3] + 1444)
          && v9 >= *(_DWORD *)(v8[3] + 1440)
          && v9 < *(_DWORD *)(v8[3] + 1448) )
        {
          (*(void (__thiscall **)(_DWORD *, int))(*v8 + 32))(v8, a2);
        }
      }
      ++v4;
      result = this[1909] + this[1908];
      ++v6;
      if ( v4 >= result )
        break;
    }
  }
  return result;
}

//----- (00447860) --------------------------------------------------------
int __thiscall sub_447860(_DWORD *this, char a2, int a3)
{
  unsigned __int16 v4; // dx
  int v5; // ecx
  int result; // eax
  char Buffer[128]; // [esp+8h] [ebp-80h] BYREF

  LOBYTE(v4) = 0;
  v5 = this[5775];
  *((_BYTE *)this + 23110) = a2;
  HIBYTE(v4) = *(_WORD *)(v5 + 636);
  sprintf_0(
    Buffer,
    "%d.%d.%d.%d:%d",
    (unsigned __int8)*(_DWORD *)(v5 + 632),
    BYTE1(*(_DWORD *)(v5 + 632)),
    (unsigned __int8)BYTE2(*(_DWORD *)(v5 + 632)),
    HIBYTE(*(_DWORD *)(v5 + 632)),
    HIBYTE(*(unsigned __int16 *)(v5 + 636)) | v4);
  result = (*(int (__thiscall **)(_DWORD *, char *, int))(*this + 52))(this, Buffer, a3);
  this[354] = 1;
  *((_BYTE *)this + 1869) = 0;
  return result;
}

//----- (00447900) --------------------------------------------------------
int __thiscall sub_447900(char *this, char a2, char *a3)
{
  unsigned int v4; // edi
  int v5; // eax
  _DWORD *v6; // ebx
  char v8[2]; // [esp+Ch] [ebp-84h] BYREF
  char v9[130]; // [esp+Eh] [ebp-82h] BYREF

  v8[1] = a2;
  v8[0] = 27;
  memset(v9, 0, 0x80u);
  v4 = 1;
  if ( a3 )
  {
    v4 = strlen(a3) + 1;
    if ( v4 > 0x80 )
      v4 = 128;
    sub_46CAB0((unsigned int)v9, a3, v4);
  }
  v5 = 0;
  v6 = &loc_43540C;
  do
    v5 -= *v6++;
  while ( v6 < (_DWORD *)((char *)&loc_4354FE + 6) );
  return (*(int (__thiscall **)(char *, char *, unsigned int, int))(*(_DWORD *)&this[v5 + 1721067531] + 16))(
           &this[v5 + 1721067531],
           v8,
           v4 + 2,
           1);
}

//----- (004479B0) --------------------------------------------------------
int __thiscall sub_4479B0(_DWORD *this, int a2, int a3)
{
  int result; // eax
  int v4; // edx

  if ( a2 == 16 )
  {
    result = ~((a3 & 0xFF0000) != 3538944 ? 0x400000 : 0x4000000);
    this[90] &= result;
  }
  else if ( a2 == 17 )
  {
    result = ~((a3 & 0x1000000) != 0 ? 0x2000000 : 0x200000);
    this[90] &= result;
  }
  else
  {
    if ( a2 == 18 )
    {
      result = ~((a3 & 0x1000000) != 0 ? 0x1000000 : 0x100000);
      v4 = result & this[90];
    }
    else
    {
      v4 = this[90];
      result = -1;
    }
    this[90] = v4;
  }
  return result;
}

//----- (00447A60) --------------------------------------------------------
int __thiscall sub_447A60(_DWORD *this, _BYTE *a2, int a3, int a4)
{
  int v4; // edx
  const char *v5; // edi
  char v6; // al

  v4 = 0;
  v5 = (const char *)(this[26] + 132 * a3);
  v6 = *v5;
  if ( *v5 >= 1 && v6 <= 8 )
  {
    v4 = v6 - 1;
    ++v5;
  }
  strcpy(a2 + 1, v5);
  *a2 = a3 != this[2] ? 32 : 62;
  return v4;
}

//----- (00447AE0) --------------------------------------------------------
int __thiscall sub_447AE0(_DWORD *this, int a2, int a3)
{
  int v4; // ebx
  int v5; // ebx
  unsigned int v6; // eax
  int v7; // eax
  _DWORD *v8; // ebx
  int result; // eax
  int v10; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = this[3];
  v10 = *(_DWORD *)(v4 + 117760);
  *(_DWORD *)(v4 + 117760) = rand() ^ v10;
  v5 = 0;
  for ( i = 0; v5 < a3; ++i )
  {
    if ( i >= 10000 )
      break;
    if ( a2 )
    {
      (*(void (__thiscall **)(_DWORD *, int, _DWORD, _DWORD, int))(*this + 36))(this, a2, 0, 0, 1);
    }
    else
    {
      v6 = abs32((*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[3] + 392))(this[3]));
      if ( v6 == 14 || v6 == 18 || v6 == 17 || v6 == 25 || v6 == 7 || v6 == 26 )
        --v5;
      else
        (*(void (__thiscall **)(_DWORD *, unsigned int, int, _DWORD, int))(*this + 36))(this, v6, 1, 0, 1);
    }
    ++v5;
  }
  v7 = 0;
  v8 = (_DWORD *)((char *)&loc_445982 + 2);
  do
    v7 -= *v8++;
  while ( v8 < (_DWORD *)&loc_445B68 );
  result = v7 - 1707912748;
  *(_DWORD *)(*(_DWORD *)((char *)this + result + 189156) + 117760) = v10;
  return result;
}

//----- (00447BC0) --------------------------------------------------------
char __thiscall sub_447BC0(_BYTE *this)
{
  char result; // al

  result = this[1420];
  if ( !result )
    result = (*(int (__cdecl **)(_BYTE *, int, int, int))(*(_DWORD *)this + 388))(this, 30000, 4, 4906864);
  this[1420] = 1;
  return result;
}

//----- (00447C00) --------------------------------------------------------
int __thiscall sub_447C00(_DWORD *this, char a2, char a3)
{
  int v4; // ecx
  int result; // eax
  int *v6; // [esp+28h] [ebp+8h]

  v4 = this[2905];
  if ( v4 )
  {
    if ( a3 )
    {
      v6 = (int *)&unk_4AB1D8;
      do
      {
        sub_4057F0(
          this[2905],
          10 * (*v6 - this[2546]) / 25 + this[2] / 2 - *(_DWORD *)(this[2905] + 36) / 2,
          10 * (v6[1] - this[2547]) / 25 + this[3] / 2 - *(_DWORD *)(this[2905] + 40) / 2,
          1);
        result = (int)(v6 + 2);
        v6 += 2;
      }
      while ( v6 < dword_4AB200 );
    }
    else
    {
      result = sub_4057F0(v4, (this[2] - *(_DWORD *)(v4 + 36)) / 2, a2 != 0 ? 0 : 29, 1);
    }
  }
  return result;
}
// 4AB200: using guessed type int dword_4AB200[];

//----- (00447D20) --------------------------------------------------------
int __thiscall sub_447D20(_DWORD *this)
{
  int v1; // edx
  int result; // eax
  int v3; // esi
  int v4; // ecx
  int v5; // edx

  v1 = this[3];
  result = 0;
  v3 = *(_DWORD *)(v1 + 6276);
  if ( v3 > 0 )
  {
    v4 = this[6];
    v5 = v1 + 2180;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v5 + 28) == v4 )
        ++result;
      v5 += 4;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00447E30) --------------------------------------------------------
_BYTE *__thiscall sub_447E30(_BYTE *this, char a2)
{
  _BYTE *result; // eax

  result = this;
  *this = a2;
  return result;
}

//----- (00447E40) --------------------------------------------------------
int __thiscall sub_447E40(int this)
{
  return (*(_DWORD *)(this + 4) >> 28) + 16 * ((*(unsigned __int16 *)(this + 8) >> 14) + 4 * *(char *)(this + 10));
}

//----- (00447E60) --------------------------------------------------------
int __thiscall sub_447E60(unsigned __int16 *this)
{
  return this[4] << 18 >> 18;
}

//----- (00447E70) --------------------------------------------------------
void __thiscall sub_447E70(int this, int a2, int a3, char a4)
{
  sub_404DD0(
    *(_DWORD **)(this + 10248),
    a2 - *(_DWORD *)(this + 19880),
    a3 - *(_DWORD *)(this + 19884),
    *(_DWORD *)(this + 10192),
    1,
    10,
    a4 != 0 ? 0xA : 0);
}

//----- (00447EE0) --------------------------------------------------------
int __thiscall sub_447EE0(_DWORD *this, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // eax

  v2 = this[4];
  v3 = a2;
  if ( v2 > 0 )
    this[4] = v2 - a2;
  v4 = this[6];
  if ( v4 > 0 )
    this[6] = v4 - a2;
  if ( (int)this[4] <= 0 && (int)this[6] <= 0 )
  {
    v5 = (_DWORD *)this[3];
    if ( (int)v5[1569] > 10 )
    {
      v3 = v5[356];
      if ( v3 > v5[2942] )
        this[6] = 600;
    }
  }
  return (*(int (__fastcall **)(_DWORD *, int))(*this + 12))(this, v3);
}

//----- (00447F80) --------------------------------------------------------
int __thiscall sub_447F80(char *this, __int16 a2)
{
  int v2; // eax
  _DWORD *i; // ebx
  char v5; // [esp+4h] [ebp-4h] BYREF
  __int16 v6; // [esp+5h] [ebp-3h]

  v5 = 19;
  v6 = a2;
  v2 = 0;
  for ( i = (_DWORD *)(&loc_424EB7 + 5); (unsigned int)i < 0x425094; ++i )
    v2 -= *i;
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v2 + 2129061961] + 16))(
           &this[v2 + 2129061961],
           &v5,
           3,
           1);
}

//----- (00447FD0) --------------------------------------------------------
bool __thiscall sub_447FD0(_DWORD *this, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  _DWORD *i; // edx

  v4 = this[7060];
  v5 = 0;
  if ( v4 <= 0 )
    return 1;
  for ( i = this + 6804;
        a2 < *(_DWORD *)(*i + 8)
     || a2 >= *(_DWORD *)(*i + 16)
     || a3 < *(_DWORD *)(*i + 12)
     || a3 >= *(_DWORD *)(*i + 20);
        ++i )
  {
    if ( ++v5 >= v4 )
      return 1;
  }
  return *(_DWORD *)(this[v5 + 6804] + 36) == a4;
}

//----- (00448040) --------------------------------------------------------
int __thiscall sub_448040(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  int *v6; // esi

  v6 = &this[40 * (this[2548] & 0x7F) + 13686];
  sub_405BC0(a2, a3 - 1, a5 + 1, a4 - 1, this[40 * (this[2548] & 0x7F) + 13687]);
  sub_405D00(a2, a4 - 1, a6 + 1, a3 - 1, v6[1]);
  sub_405BC0(a2, a3 - 1, a5 + 1, a6, v6[1]);
  sub_405D00(a2, a4 - 1, a6 + 1, a5, v6[1]);
  sub_405BC0(a2, a3 - 2, a5 + 2, a4 - 2, v6[2]);
  sub_405D00(a2, a4 - 2, a6 + 2, a3 - 2, v6[2]);
  sub_405BC0(a2, a3 - 2, a5 + 2, a6 + 1, v6[2]);
  sub_405D00(a2, a4 - 2, a6 + 2, a5 + 1, v6[2]);
  sub_405BC0(a2, a3 - 1, a5 + 1, a4 - 3, v6[3]);
  sub_405D00(a2, a4 - 1, a6 + 1, a3 - 3, v6[3]);
  sub_405BC0(a2, a3 - 1, a5 + 1, a6 + 2, v6[3]);
  return sub_405D00(a2, a4 - 1, a6 + 1, a5 + 2, v6[3]);
}

//----- (004481D0) --------------------------------------------------------
char __thiscall sub_4481D0(_DWORD *this, int a2, int a3)
{
  char result; // al
  _DWORD *v5; // edi
  char v6; // al
  int v7; // eax
  int v8; // ecx
  int v9; // ebx
  int v10; // eax

  result = (*(int (__thiscall **)(_DWORD *, int))(*this + 212))(this, a2);
  v5 = (_DWORD *)this[a2 + 28405];
  if ( v5 )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*v5 + 76))(v5, a3);
    v6 = *((_BYTE *)v5 + 156);
    v5[7] = -1;
    if ( v6 )
    {
      v7 = -1316978140;
      v8 = 178;
      do
        v7 ^= (unsigned int)off_4AC700[v8-- - 134796];
      while ( v8 );
      *(_DWORD *)((char *)this + v7 + 46571536) = 1;
      this[28390] = -1;
      (*(void (__thiscall **)(_DWORD *))(*v5 + 56))(v5);
      *(_DWORD *)(this[5775] + 639) = a3;
      *(_DWORD *)(this[542] + 560) = 0;
      if ( a3 == 8 )
      {
        this[28053] = -1;
      }
      else
      {
        this[543] = a3;
        (*(void (__thiscall **)(_DWORD *, int))(*this + 192))(this, -1);
        v9 = *(_DWORD *)this[542];
        v10 = rand();
        (*(void (__thiscall **)(_DWORD, int, int, int))(v9 + 152))(this[542], v10, -1, -1);
      }
    }
    else
    {
      v5[19] = 2;
    }
    result = *((_BYTE *)this + 113524);
    if ( result )
      result = (*(int (__cdecl **)(int, _DWORD, _DWORD))(this[5775] + 9122))((int)v5 + 109, v5[22], v5[23]);
  }
  return result;
}
// 4AC700: using guessed type int (__stdcall *off_4AC700[2])(int, int, int);

//----- (004482E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __thiscall sub_4482E0(char *this, _BYTE *Buf1, _DWORD *a3, int a4)
{
  char *v4; // esi
  int v5; // eax
  _DWORD *v6; // edi
  char v7; // al
  char *v8; // ebx
  char *v9; // edi
  char *v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // edx
  const char *v17; // edi
  char *v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // edx
  char v23; // al
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // ecx
  const char *v30; // eax
  int v31; // edx
  int v32; // ebx
  int v33; // eax
  _DWORD *v34; // ebx
  int v35; // ecx
  char *v36; // edi
  char v37; // al
  int v38; // esi
  int v39; // eax
  unsigned int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // eax
  int v44; // ecx
  int v45; // eax
  _DWORD *v46; // ebx
  char *v47; // eax
  char *v48; // esi
  char *v49; // esi
  int v50; // ebx
  const char *v51; // edx
  size_t v52; // edi
  char v53; // al
  int v54; // ebx
  unsigned int v55; // edi
  int v56; // edx
  int v57; // eax
  int v58; // ecx
  int v59; // ecx
  unsigned int v60; // edi
  int v61; // edx
  int v62; // eax
  int v63; // ecx
  int v64; // eax
  int v65; // eax
  _DWORD *v66; // ebx
  int v67; // eax
  _DWORD *v68; // ebx
  int v69; // eax
  int v70; // ecx
  int v71; // edx
  int v72; // eax
  int v73; // ecx
  int v74; // eax
  int v75; // ecx
  int v76; // eax
  int v77; // ecx
  int v78; // eax
  int v79; // ecx
  int v80; // eax
  int v81; // eax
  int v82; // eax
  int v83; // ebx
  int v84; // eax
  int v85; // ecx
  int v86; // eax
  int v87; // ecx
  int v88; // ecx
  int v89; // eax
  int v90; // edx
  int v91; // eax
  int v92; // ecx
  char v93; // al
  void *v94; // edx
  int v95; // edi
  int v96; // edx
  int v97; // eax
  int v98; // ebx
  int v99; // eax
  int v100; // ecx
  int v101; // edi
  int v102; // ebx
  int v103; // eax
  int v104; // ecx
  int i; // edi
  int v106; // eax
  _DWORD *v107; // ebx
  int j; // edi
  int v109; // eax
  int v110; // ecx
  int v111; // eax
  int v112; // ebx
  bool v113; // cc
  int v114; // eax
  int v115; // ecx
  int v116; // eax
  int v117; // ebx
  char *v118; // edx
  char *v119; // ecx
  char *v120; // eax
  int v121; // eax
  _DWORD *k; // ebx
  int v123; // eax
  int v124; // ecx
  int v125; // eax
  int v126; // eax
  int v127; // eax
  int v128; // eax
  int v129; // ecx
  int v130; // eax
  int v131; // eax
  int v132; // eax
  int v133; // eax
  int v134; // esi
  char *v135; // edi
  int v136; // ecx
  char *v137; // eax
  size_t v138; // eax
  int v139; // eax
  int v140; // ebx
  int v141; // eax
  int v142; // ebx
  int v143; // edx
  int v144; // eax
  void *v145; // ecx
  int v146; // eax
  _DWORD *v147; // ebx
  char *v148; // eax
  const char *v149; // ecx
  char *v150; // [esp-48h] [ebp-460h]
  int v151; // [esp-44h] [ebp-45Ch]
  char *v152; // [esp-40h] [ebp-458h]
  int v153; // [esp-3Ch] [ebp-454h]
  char *v154; // [esp-34h] [ebp-44Ch]
  const char *v155; // [esp-30h] [ebp-448h]
  int v156; // [esp-2Ch] [ebp-444h]
  int v157; // [esp-28h] [ebp-440h]
  int v158; // [esp-20h] [ebp-438h]
  int v159; // [esp-1Ch] [ebp-434h]
  int v160; // [esp-18h] [ebp-430h]
  const char *v161; // [esp-18h] [ebp-430h]
  int v162; // [esp-18h] [ebp-430h]
  int v163; // [esp-14h] [ebp-42Ch]
  int v164; // [esp-14h] [ebp-42Ch]
  int v165; // [esp-10h] [ebp-428h] BYREF
  char v166[352]; // [esp+Ch] [ebp-40Ch] BYREF
  char v167[260]; // [esp+16Ch] [ebp-2ACh] BYREF
  int v168[2]; // [esp+270h] [ebp-1A8h] BYREF
  int v169[2]; // [esp+278h] [ebp-1A0h] BYREF
  int v170[2]; // [esp+280h] [ebp-198h] BYREF
  int v171[2]; // [esp+288h] [ebp-190h] BYREF
  char Str; // [esp+290h] [ebp-188h] BYREF
  char Buf2; // [esp+291h] [ebp-187h] BYREF
  char v174; // [esp+292h] [ebp-186h] BYREF
  char String2[12]; // [esp+3D0h] [ebp-48h] BYREF
  int (__stdcall **v176)(int); // [esp+3DCh] [ebp-3Ch] BYREF
  void *v177; // [esp+3E0h] [ebp-38h]
  int v178; // [esp+3E4h] [ebp-34h]
  int v179; // [esp+3E8h] [ebp-30h]
  int v180; // [esp+3ECh] [ebp-2Ch]
  int v181; // [esp+3F0h] [ebp-28h]
  char *v182; // [esp+3F4h] [ebp-24h]
  char *v183; // [esp+3F8h] [ebp-20h]
  _DWORD *v184; // [esp+3FCh] [ebp-1Ch]
  size_t Size; // [esp+400h] [ebp-18h]
  char *Buffer; // [esp+404h] [ebp-14h]
  int *v187; // [esp+408h] [ebp-10h] BYREF
  int v188; // [esp+414h] [ebp-4h]
  char *Buf1a; // [esp+420h] [ebp+8h]
  const char *Buf1b; // [esp+420h] [ebp+8h]
  int Buf1c; // [esp+420h] [ebp+8h]
  char *Buf1d; // [esp+420h] [ebp+8h]
  void *Buf1e; // [esp+420h] [ebp+8h]
  int v194; // [esp+424h] [ebp+Ch]
  int v195; // [esp+424h] [ebp+Ch]

  v4 = this;
  v187 = &v165;
  v5 = *((_DWORD *)this + 137);
  v182 = this;
  v181 = 0;
  v6 = *(_DWORD **)(v5 + 2168);
  v184 = v6;
  Buf1a = sub_40BCF0(Buf1);
  v7 = *Buf1a;
  v8 = &Str;
  Buffer = &Str;
  if ( v7 )
  {
    do
    {
      if ( (unsigned int)(v8 - &Str) >= 0x100 )
        break;
      if ( v7 == 37 )
      {
        v9 = Buf1a + 1;
        Buf1a = v9;
        if ( isdigit(*v9) )
        {
          v181 = sub_46D80E(v9);
          Buf1a = sub_40BCD0(v9);
        }
        else if ( *v9 == 37 )
        {
          *v8++ = 37;
          Buffer = v8;
          Buf1a = v9 + 1;
        }
        else
        {
          v183 = 0;
          v10 = off_4B821C[0];
          Size = 4948508;
          if ( off_4B821C[0] )
          {
            while ( _memicmp(v9, v10, strlen(v10)) )
            {
              Size += 4;
              ++v183;
              v10 = *(char **)Size;
              if ( !*(_DWORD *)Size )
                goto LABEL_13;
            }
            Buf1a = &v9[strlen(*(const char **)Size)];
          }
LABEL_13:
          switch ( (unsigned int)v183 )
          {
            case 0u:
              v11 = sub_455280(v184 + 1, 16000);
              v171[1] = v12;
              v171[0] = v11;
              v13 = sub_4552A0(v171, 20);
              v170[1] = v14;
              v170[0] = v13;
              v15 = sub_455280(v170, 1024);
              Size = 21767200;
              v17 = (&(&off_4B81B8[4 * (v16 / 4)])[v15 / 4])[v16 / 4];
              goto LABEL_15;
            case 1u:
              v19 = sub_455280(v184 + 1, 16000);
              v169[1] = v20;
              v169[0] = v19;
              v21 = sub_4552A0(v169, 20);
              v168[1] = v22;
              v168[0] = v21;
              v23 = sub_455280(v168, 1024);
              Size = 9090685;
              *v8++ = v23 + 65;
              v25 = sprintf_0(v8, (const char *const)(Size - 4204921), v24 + 1);
              goto LABEL_18;
            case 2u:
              if ( v184[23] == 8 )
                v26 = rand() % 10000;
              else
                v26 = v184[153] + v184[154];
              Size = 9090799;
              v25 = sprintf_0(v8, aD, v26);
              goto LABEL_18;
            case 3u:
              v17 = (char *)v184 + 170;
              goto LABEL_15;
            case 4u:
              Size = 9091026;
              v25 = sprintf_0(v8, (const char *const)(9091026 - (_DWORD)byte_402ACE), v184[12] + v184[13]);
              goto LABEL_18;
            case 5u:
              v17 = (const char *)(v184 + 132);
              goto LABEL_15;
            case 6u:
              v17 = (const char *)(v184 + 194);
              goto LABEL_15;
            case 7u:
              Size = 9091490;
              v8 += sprintf_0(v8, (const char *const)(9091490 - (_DWORD)&loc_402C9E), (v184[130] + v184[131]) / 1000);
              Buffer = v8;
              break;
            case 8u:
              Size = 9091373;
              v25 = sprintf_0(v8, aD, v184[8] + v184[9]);
LABEL_18:
              v8 += v25;
              Buffer = v8;
              break;
            case 9u:
              v27 = -679215;
              v28 = 48;
              do
                v27 ^= *(_DWORD *)&aUs[4 * v28-- - 21780];
              while ( v28 );
              v29 = (*(int (__thiscall **)(char *))(*(_DWORD *)&v4[v27 + 321636] + 24))(&v4[v27 + 321636]);
              if ( !v29 )
                goto LABEL_42;
              Size = 9091726;
              v30 = (const char *)(9091726 - (_DWORD)&loc_402D8A);
              v31 = *(_DWORD *)(v29 + 52);
              v32 = *(_DWORD *)(v29 + 48);
              goto LABEL_41;
            case 0xAu:
              if ( !a3 )
                break;
              v17 = (char *)a3 + 109;
LABEL_15:
              strcpy(v8, v17);
              v161 = v8;
              goto LABEL_16;
            case 0xBu:
              v17 = (char *)v184 + 109;
              goto LABEL_15;
            case 0xCu:
              v33 = 0;
              v34 = (_DWORD *)((char *)&loc_44FC13 + 1);
              do
                v33 -= *v34++;
              while ( v34 < (_DWORD *)&loc_44FF40 );
              v35 = (*(int (__thiscall **)(char *))(*(_DWORD *)&v4[v33 - 1081724602] + 24))(&v4[v33 - 1081724602]);
              if ( !v35 )
                goto LABEL_42;
              Size = 9092204;
              v30 = (const char *)(9092204 - (_DWORD)&loc_402F68);
              v31 = *(_DWORD *)(v35 + 36);
              v32 = *(_DWORD *)(v35 + 32);
LABEL_41:
              v36 = Buffer;
              Buffer = &v36[sprintf_0(Buffer, v30, v32 + v31)];
LABEL_42:
              v8 = Buffer;
              break;
            case 0xDu:
              v40 = (unsigned int)&loc_47D6C8;
              v41 = 225;
              do
                v40 ^= (unsigned int)*(&dword_4A7160 + v41-- + 3267);
              while ( v41 );
              v42 = (*(int (__thiscall **)(char *))(*(_DWORD *)&v4[v40 + 331632] + 24))(&v4[v40 + 331632]);
              if ( !v42 )
                goto LABEL_42;
              v161 = strcpy(Buffer, (const char *)(v42 + 109));
LABEL_16:
              v18 = strchr(v161, 0);
              v4 = v182;
              Buffer = v18;
              v8 = v18;
              break;
            case 0xEu:
              v43 = 202946987;
              v44 = 169;
              do
                v43 ^= *(_DWORD *)&aPrChina[4 * v44-- - 395172];
              while ( v44 );
              v45 = (*(int (__thiscall **)(char *))(*(_DWORD *)&v4[v43 + 335748] + 24))(&v4[v43 + 335748]);
              v46 = (_DWORD *)v45;
              if ( !v45 )
                goto LABEL_42;
              v47 = strchr(strcpy(Buffer, (const char *)(v45 + 109)), 0);
              Size = 9092815;
              *v47 = 40;
              v48 = &v47[sprintf_0(v47 + 1, (const char *const)(Size - ((_DWORD)&loc_4031C7 + 4)), v46[8] + v46[9]) + 1];
              Size = 9092940;
              *v48 = 58;
              v49 = &v48[sprintf_0(v48 + 1, (const char *const)(Size - (_DWORD)&loc_403248), v46[12] + v46[13]) + 1];
              *v49 = 41;
              Buffer = v49 + 1;
              v8 = v49 + 1;
              v4 = v182;
              break;
            default:
              *v8++ = 37;
              Buffer = v8;
              break;
          }
        }
      }
      else
      {
        *v8++ = v7;
        Buffer = v8;
        ++Buf1a;
      }
      v6 = v184;
      v7 = *Buf1a;
    }
    while ( *Buf1a );
  }
  *v8 = 0;
  v37 = Str;
  if ( Str == 61 )
  {
    if ( isdigit(Buf2) )
    {
      v38 = *v6;
      v39 = sub_46D80E(&Buf2);
      (*(void (__thiscall **)(_DWORD *, int))(v38 + 144))(v6, v39);
    }
    return;
  }
  if ( Str != 63 )
  {
LABEL_248:
    v135 = &Str;
    Buf1e = 0;
    a4 = 2 - ((_BYTE)a4 != 0);
    if ( v37 == 39 )
    {
      v135 = &Buf2;
      a4 = 3;
    }
    else if ( v37 == 47 )
    {
      if ( Buf2 == 47 )
      {
        v135 = &v174;
        a4 = 3;
      }
      else
      {
        if ( !a3 )
          return;
        Buf1e = (void *)a3[6];
        v135 = &Buf2;
        v136 = *(_DWORD *)(*((_DWORD *)v4 + 137) + 23104);
        a4 = 5;
        a3[38] = v136;
      }
    }
    else if ( v37 == 34 )
    {
      if ( !a3 )
        return;
      v135 = &Buf2;
      Buf1e = (void *)a3[6];
      a4 = 4;
    }
    else if ( v37 == 59 )
    {
      v135 = &Buf2;
      a4 = 9;
    }
    else
    {
      if ( v37 == 58 )
      {
        v137 = strchr(&Buf2, 58);
        v183 = v137;
        if ( v137 )
        {
          a4 = 7;
          v135 = &Str;
          v138 = v137 - &Str - 1;
          Size = 31;
          if ( v138 < 0x1F )
            Size = v138;
          v139 = *((_DWORD *)v4 + 137);
          v140 = 0;
          if ( *(int *)(v139 + 6276) > 0 )
          {
            v195 = 2180;
            while ( _memicmp((const void *)(*(_DWORD *)(v139 + v195) + 109), &Buf2, Size) )
            {
              v139 = *((_DWORD *)v4 + 137);
              ++v140;
              v195 += 4;
              if ( v140 >= *(_DWORD *)(v139 + 6276) )
                goto LABEL_270;
            }
            v141 = *((_DWORD *)v4 + 137);
            a4 = 5;
            v142 = *(_DWORD *)(v141 + 4 * v140 + 2180);
            v143 = *(_DWORD *)(v141 + 23104);
            v144 = (int)v183;
            v145 = *(void **)(v142 + 24);
            *(_DWORD *)(v142 + 152) = v143;
            Buf1e = v145;
            v135 = (char *)(v144 + 1);
          }
        }
LABEL_270:
        v37 = Str;
      }
      if ( !v37 && !v181 )
        return;
    }
    v146 = 0;
    v147 = &loc_428CD4;
    do
      v146 -= *v147++;
    while ( v147 < (_DWORD *)&loc_428F9C );
    (*(void (__thiscall **)(_DWORD, char *, int, void *, int))(**(_DWORD **)&v4[v146 - 571607176] + 364))(
      *(_DWORD *)&v4[v146 - 571607176],
      v135,
      a4,
      Buf1e,
      v181);
    if ( a4 == 9 )
    {
      v148 = sub_40BCD0(v135);
      v149 = a1;
      if ( *v148 == 59 && v148 != v135 )
      {
        v149 = v135;
        *v148 = 0;
        v135 = v148 + 1;
      }
      sprintf_0(v166, aSSS_0, v149, (const char *)(*(_DWORD *)(*((_DWORD *)v4 + 137) + 2168) + 109), v135);
    }
    (*(void (__thiscall **)(char *, int, int, int, int, int))(*(_DWORD *)v4 + 28))(v4, 1, v158, v159, v162, v164);
    return;
  }
  v183 = 0;
  Buf1b = (const char *)21801568;
  v50 = 4948572;
  v51 = (const char *)unk_4B825C;
  if ( unk_4B825C )
  {
    while ( 1 )
    {
      v52 = strlen(v51);
      if ( !_memicmp(&Buf2, v51, v52) )
      {
        v53 = *(&Buf2 + v52);
        if ( v53 == 61 || v53 == 32 || !v53 )
          break;
      }
      v51 = *(const char **)(v50 + 4);
      v50 += 4;
      ++v183;
      if ( !v51 )
      {
        v54 = 21801568;
        goto LABEL_67;
      }
    }
    v54 = (int)(&Buf2 + v52);
    Buf1b = &Buf2 + v52;
    if ( *(&Buf2 + v52) )
      Buf1b = (const char *)++v54;
LABEL_67:
    v6 = v184;
  }
  else
  {
    v54 = 21801568;
  }
  switch ( (unsigned int)v183 )
  {
    case 0u:
      v55 = *(_DWORD *)(*((_DWORD *)v4 + 66) + 8035);
      if ( isdigit(*(char *)v54) )
        v55 = sub_46D80E((char *)v54);
      v56 = 32;
      if ( v55 < 0x20 )
        v56 = v55;
      v57 = -539987;
      v58 = 48;
      do
        v57 ^= *(_DWORD *)&aShip3Bm2[4 * v58-- - 5436];
      while ( v58 );
      v59 = *(_DWORD *)&v4[v57 + 428328];
      a4 = 9121753;
      *(_DWORD *)(v59 + 8035) = v56;
      sprintf_0(&Str, (const char *const)(a4 - ((_DWORD)&loc_404E33 + 2)), *(_DWORD *)(*((_DWORD *)v4 + 66) + 8035));
      goto LABEL_86;
    case 1u:
      v60 = *(_DWORD *)(*((_DWORD *)v4 + 66) + 8031);
      if ( isdigit(*(char *)v54) )
        v60 = sub_46D80E((char *)v54);
      v61 = 24;
      if ( v60 < 0x18 )
        v61 = v60;
      v62 = 1403408841;
      v63 = 69;
      do
        v62 ^= *(_DWORD *)&aDamagedBundleF[4 * v63-- - 564188];
      while ( v63 );
      *(_DWORD *)(*(_DWORD *)&v4[v62 + 433620] + 8031) = v61;
      v64 = *((_DWORD *)v4 + 66);
      if ( *(int *)(v64 + 8031) <= 0 )
        *(_DWORD *)(v64 + 8031) = 1;
      a4 = 9122278;
      sprintf_0(&Str, aMessageNameLen, *(_DWORD *)(*((_DWORD *)v4 + 66) + 8031));
LABEL_86:
      (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, &Str, 0, 0, 0, 1);
      return;
    case 2u:
      if ( isdigit(*(char *)v54) )
        *(_DWORD *)(*((_DWORD *)v4 + 66) + 8039) = sub_46D80E((char *)v54);
      a4 = 9122575;
      sprintf_0(&Str, (const char *const)(9122575 - (_DWORD)&loc_405197), *(_DWORD *)(*((_DWORD *)v4 + 66) + 8039));
      v65 = 0;
      v66 = (_DWORD *)((char *)&loc_44DDEF + 1);
      do
        v65 -= *v66++;
      while ( v66 < (_DWORD *)((char *)&loc_44E19A + 2) );
      (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v4[v65 - 1376457821] + 28))(
        &v4[v65 - 1376457821],
        &Str,
        0,
        0,
        0,
        1);
      return;
    case 3u:
      v67 = 0;
      v68 = (_DWORD *)((char *)&loc_445982 + 2);
      do
        v67 -= *v68++;
      while ( v68 < (_DWORD *)&loc_445B68 );
      (*(void (__thiscall **)(_DWORD, const char *))(**(_DWORD **)&v4[v67 - 1707723056] + 276))(
        *(_DWORD *)&v4[v67 - 1707723056],
        Buf1b);
      return;
    case 4u:
      v69 = *((_DWORD *)v4 + 137);
      v70 = *(_DWORD *)(v69 + 1376);
      if ( v70 )
        v71 = *(_DWORD *)(v69 + 1364) / v70;
      else
        v71 = 0;
      a4 = 9122916;
      sprintf_0(
        &Str,
        (const char *const)(9122916 - (_DWORD)byte_405328),
        *(_DWORD *)(*((_DWORD *)v4 + 137) + 1360),
        v71,
        *(_DWORD *)(*((_DWORD *)v4 + 137) + 1368),
        *(_DWORD *)(*((_DWORD *)v4 + 137) + 1372));
      v72 = 1590832915;
      v73 = 169;
      do
        v72 ^= *(_DWORD *)&aDominicanRepub[4 * v73-- - 382832];
      while ( v73 );
      (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v4[v72 + 445116] + 28))(
        &v4[v72 + 445116],
        &Str,
        0,
        0,
        0,
        1);
      return;
    case 5u:
      a4 = 9123222;
      v74 = 1988897659;
      v75 = 247;
      do
        v74 ^= *(_DWORD *)&aLowerleftCorne[4 * v75-- - 622636];
      while ( v75 );
      (*(void (__thiscall **)(char *, int, int))(*(_DWORD *)&v4[v74 + 446292] + 12))(
        &v4[v74 + 446292],
        *((_DWORD *)v4 + 66) + 8015,
        9123222 - (_DWORD)&loc_40546A);
      return;
    case 6u:
      a4 = 9123368;
      v76 = 198653619;
      v77 = 75;
      do
        v76 ^= (unsigned int)*(&dword_4A70DC + v77-- - 90459);
      while ( v77 );
      (*(void (__thiscall **)(char *, int, int))(*(_DWORD *)&v4[v76 + 448056] + 12))(
        &v4[v76 + 448056],
        *((_DWORD *)v4 + 66) + 8019,
        9123368 - ((_DWORD)&loc_40550A + 2));
      return;
    case 7u:
      a4 = 9123516;
      v78 = 1972701824;
      v79 = 244;
      do
        v78 ^= *(_DWORD *)&aWallDRcktDSSS[4 * v79-- - 562256];
      while ( v79 );
      (*(void (__thiscall **)(char *, int, int))(*(_DWORD *)&v4[v78 + 450408] + 12))(
        &v4[v78 + 450408],
        *((_DWORD *)v4 + 66) + 8023,
        4907276);
      return;
    case 8u:
      if ( v6[23] == 8 )
        return;
      v80 = v6[159];
      if ( *(_DWORD *)(v6[160] + v80) && *(_DWORD *)(v6[156] + v80) - *(_DWORD *)(v6[155] + v80) > 0 )
        a4 = 100 * (v6[157] + v6[158]) / *(_DWORD *)(v6[156] + v80);
      else
        a4 = 100;
      v81 = v6[214];
      if ( *(_DWORD *)(v6[215] + v81) && *(_DWORD *)(v6[211] + v81) - *(_DWORD *)(v6[210] + v81) > 0 )
        Buf1c = 100 * (v6[212] + v6[213]) / *(_DWORD *)(v6[211] + v81);
      else
        Buf1c = 100;
      v82 = v6[147];
      if ( *(_DWORD *)(v6[148] + v82) && *(_DWORD *)(v6[144] + v82) - *(_DWORD *)(v6[143] + v82) > 0 )
        v83 = 100 * (v6[145] + v6[146]) / *(_DWORD *)(v6[144] + v82);
      else
        v83 = 100;
      v84 = v6[124];
      if ( *(_DWORD *)(v6[125] + v84) && (v194 = *(_DWORD *)(v6[121] + v84), v194 - *(_DWORD *)(v84 + v6[120]) > 0) )
        v85 = 100 * (v6[122] + v6[123]) / v194;
      else
        v85 = 100;
      sprintf_0(&Str, (const char *const)(9123771 - ((_DWORD)&loc_4056F6 + 1)), v85, v83, Buf1c, a4, v6[170] + v6[171]);
      v86 = 1042137366;
      v87 = 233;
      do
        v86 ^= *(_DWORD *)&aSpanishModern[4 * v87-- - 575952];
      while ( v87 );
      v88 = (int)&v4[v86 + 468636];
      goto LABEL_212;
    case 9u:
      *(_BYTE *)(*((_DWORD *)v4 + 66) + 8063) = *(_BYTE *)(*((_DWORD *)v4 + 66) + 8063) == 0;
      if ( *(_BYTE *)(*((_DWORD *)v4 + 66) + 8063) )
      {
        a4 = 9125512;
        v89 = 9125512 - (_DWORD)&loc_405DD8;
      }
      else
      {
        a4 = 9125492;
        v89 = 9125492 - (_DWORD)&loc_405DD8;
      }
      v90 = v89;
      v91 = 1972692976;
      v92 = 244;
      do
        v91 ^= *(_DWORD *)&a08x[4 * v92-- - 545560];
      while ( v92 );
      (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v4[v91 + 471576] + 28))(
        &v4[v91 + 471576],
        v90,
        0,
        0,
        0,
        1);
      return;
    case 0xAu:
      v93 = *(_BYTE *)v54;
      if ( !*(_BYTE *)v54 && !a3 )
        return;
      v94 = (void *)v54;
      v95 = v93 == 0 ? (unsigned int)a3 : 0;
      if ( !v93 )
        v94 = (void *)(v95 + 109);
      strncpyt(String2, v94, 32);
      v96 = *((_DWORD *)v4 + 141);
      HIBYTE(a4) = 1;
      if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, char *))(v96 + 12))((_DWORD *)v4 + 141, String2) )
      {
        a4 = 9126952;
        sprintf_0(&Str, (const char *const)(9126952 - (_DWORD)byte_40639C), String2);
        HIBYTE(a4) = 0;
      }
      else
      {
        (*(void (__thiscall **)(_DWORD *, char *))(*((_DWORD *)v4 + 141) + 8))((_DWORD *)v4 + 141, String2);
        sprintf_0(&Str, (const char *const)(9127289 - (_DWORD)&loc_4064FD), String2);
      }
      if ( v95 )
        goto LABEL_150;
      v97 = *((_DWORD *)v4 + 137);
      if ( *(int *)(v97 + 6276) <= 0 )
        goto LABEL_151;
      v98 = 2180;
      while ( _strcmpi((const char *)(*(_DWORD *)(v97 + v98) + 109), String2) )
      {
        v97 = *((_DWORD *)v4 + 137);
        ++v95;
        v98 += 4;
        if ( v95 >= *(_DWORD *)(v97 + 6276) )
          goto LABEL_151;
      }
      v95 = *(_DWORD *)(*((_DWORD *)v4 + 137) + 4 * v95 + 2180);
      if ( v95 )
LABEL_150:
        *(_BYTE *)(v95 + 141) = HIBYTE(a4);
LABEL_151:
      v99 = 1083534435;
      v100 = 228;
      do
        v99 ^= *(_DWORD *)&aFailedToLoadGr[4 * v100-- - 390180];
      while ( v100 );
      v88 = (int)&v4[v99 + 498036];
      goto LABEL_212;
    case 0xBu:
      (**(void (__thiscall ***)(char *, int))v4)(v4, v54);
      return;
    case 0xCu:
      (**(void (__thiscall ***)(char *, int))v4)(v4, v54);
      if ( *((_DWORD *)v4 + 146) != -1 )
      {
        v101 = 0;
        if ( *((_DWORD *)v4 + 72) - 1 > 0 )
        {
          v102 = 0;
          do
          {
            (*(void (__thiscall **)(char *, int))(*(_DWORD *)v4 + 8))(v4, *((_DWORD *)v4 + 70) + v102);
            ++v101;
            v102 += 292;
          }
          while ( v101 < *((_DWORD *)v4 + 72) - 1 );
        }
      }
      return;
    case 0xDu:
      if ( *(_BYTE *)v54 )
      {
        a4 = 9129253;
        strcpy(v4 + 8, Buf1b);
        v103 = 46664798;
        v104 = 203;
        do
          v103 ^= (unsigned int)*(&dword_4A72D4 + v104-- - 89521);
        while ( v104 );
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v182[v103 + 508620] + 28))(
          &v182[v103 + 508620],
          a4 - 4222145,
          0,
          0,
          0,
          1);
      }
      else
      {
        v4[8] = 0;
        a4 = 9129507;
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(
          v4,
          9129507 - ((_DWORD)&loc_406DD4 + 3),
          0,
          0,
          0,
          1);
      }
      return;
    case 0xEu:
      if ( *(_BYTE *)v54 )
      {
        v188 = 1;
        a4 = -1;
        sub_407960(v167, (int)byte_4A7DB0, (_BYTE *)v54);
        if ( !sub_408AA0(v167) )
          sub_407AA0(v167, aMac);
        sub_407E80(&a4, (int)&v187, v167, 1, 3);
        memset((void *)(*((_DWORD *)v4 + 66) + 772), 0, 0x1388u);
        for ( i = 0; i < 20 && sub_4085E0(&a4, &Str, 320); ++i )
          strncpyt((void *)(*((_DWORD *)v4 + 66) + 250 * i + 772), &Str, 250);
        v106 = 0;
        v107 = (_DWORD *)((char *)&loc_42B003 + 1);
        do
          v106 -= *v107++;
        while ( v107 < (_DWORD *)&loc_42B3C4 );
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v4[v106 - 1442311461] + 28))(
          &v4[v106 - 1442311461],
          9130704 - (_DWORD)byte_407298,
          0,
          0,
          0,
          1);
        LOBYTE(v188) = 0;
        sub_4087F0(&a4);
      }
      return;
    case 0xFu:
      if ( *(_BYTE *)v54 )
      {
        v188 = 3;
        sub_407960(v167, (int)byte_4A7DB0, (_BYTE *)v54);
        sub_407AA0(v167, (char *)(9131385 - (_DWORD)&loc_407531));
        a4 = -1;
        LOBYTE(v188) = 4;
        sub_4080D0(&a4, (int)&v187, v167, 0, 2);
        for ( j = 0; j < 20; ++j )
        {
          sub_408740(&a4, (const char *)(*((_DWORD *)v4 + 66) + 250 * j + 772));
          sub_408740(&a4, asc_4AE034);
        }
        v109 = 765688979;
        v110 = 227;
        do
          v109 ^= *(_DWORD *)&aYouAreAlreadyI[4 * v110-- - 568540];
        while ( v110 );
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)&v4[v109 + 535080] + 28))(
          &v4[v109 + 535080],
          4907044,
          0,
          0,
          0,
          1);
        LOBYTE(v188) = 3;
        sub_4087F0(&a4);
      }
      return;
    case 0x10u:
      if ( !a3 )
        return;
      v111 = *((_DWORD *)v4 + 137);
      Str = 0;
      v181 = 0;
      if ( *(int *)(v111 + 6276) <= 0 )
        return;
      a4 = 2180;
      break;
    case 0x11u:
      a4 = 9134143;
      sprintf_0(&Str, (const char *const)(9134143 - (_DWORD)&loc_408047), *(_DWORD *)(*((_DWORD *)v4 + 137) + 7500));
      (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, &Str, 0, 0, 0, 1);
      v116 = *((_DWORD *)v4 + 137);
      Str = 0;
      Buf1d = 0;
      if ( *(int *)(v116 + 6276) <= 0 )
        return;
      a4 = 2180;
      do
      {
        v117 = *(_DWORD *)(v116 + a4);
        if ( *(_DWORD *)(v117 + 48) + *(_DWORD *)(v117 + 52) )
        {
          v181 = v117 + 109;
          if ( strlen(&Str) + strlen((const char *)(v117 + 109)) > 0x4B )
          {
            (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(
              v4,
              &Str,
              0,
              0,
              0,
              1);
            Str = 0;
          }
          if ( *(_DWORD *)(v117 + 88) == *(_DWORD *)(*((_DWORD *)v4 + 137) + 112476)
                                       + *(_DWORD *)(*((_DWORD *)v4 + 137) + 112480) )
            v118 = (char *)(9133337 - ((_DWORD)&loc_40849C + 1));
          else
            v118 = byte_4A7DB0;
          v119 = asc_4ADFF4;
          if ( !Str )
            v119 = aFlags;
          v153 = *(_DWORD *)(v117 + 48) + *(_DWORD *)(v117 + 52);
          v152 = v118;
          v151 = v181;
          v150 = v119;
          v120 = strchr(&Str, 0);
          sprintf_0(v120, (const char *const)(9135127 - ((_DWORD)&loc_408435 + 2)), v150, v151, v152, v153);
        }
        v116 = *((_DWORD *)v4 + 137);
        v113 = (int)++Buf1d < *(_DWORD *)(v116 + 6276);
        a4 += 4;
      }
      while ( v113 );
      if ( !Str )
        return;
      v121 = 0;
      for ( k = (_DWORD *)(&loc_424EB7 + 5); (unsigned int)k < 0x425094; ++k )
        v121 -= *k;
      v88 = (int)&v4[v121 + 2129061961];
      goto LABEL_212;
    case 0x12u:
      if ( *(_BYTE *)v54 )
      {
        *(_DWORD *)(*((_DWORD *)v4 + 66) + 8271) = sub_46D80E((char *)v54);
        v125 = *((_DWORD *)v4 + 66);
        if ( *(int *)(v125 + 8271) > 10 )
          *(_DWORD *)(v125 + 8271) = 10;
        v126 = *((_DWORD *)v4 + 66);
        if ( *(int *)(v126 + 8271) < 0 )
          *(_DWORD *)(v126 + 8271) = 0;
        v127 = *(_DWORD *)(*((_DWORD *)v4 + 66) + 8271);
        if ( v127 )
          v128 = 40 * (5 * v127 - 50);
        else
          v128 = -10000;
        v129 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 137) + 120076) + 312);
        (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v129 + 32))(v129, v128, 1);
      }
      a4 = 9136713;
      sprintf_0(&Str, aVictoryMusicVo, *(_DWORD *)(*((_DWORD *)v4 + 66) + 8271));
      goto LABEL_238;
    case 0x13u:
      if ( *(_BYTE *)v54 )
      {
        *(_DWORD *)(*((_DWORD *)v4 + 66) + 8275) = sub_46D80E((char *)v54);
        v130 = *((_DWORD *)v4 + 66);
        if ( *(int *)(v130 + 8275) > 10 )
          *(_DWORD *)(v130 + 8275) = 10;
        v131 = *((_DWORD *)v4 + 66);
        if ( *(int *)(v131 + 8275) < 0 )
          *(_DWORD *)(v131 + 8275) = 0;
        v132 = *(_DWORD *)(*((_DWORD *)v4 + 66) + 8275);
        if ( v132 )
          v133 = 40 * (5 * v132 - 50);
        else
          v133 = -10000;
        (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(*((_DWORD *)v4 + 137) + 120076) + 36))(
          *(_DWORD *)(*((_DWORD *)v4 + 137) + 120076),
          v133);
      }
      a4 = 9137742;
      sprintf_0(
        &Str,
        (const char *const)(9137742 - ((_DWORD)&loc_408EBD + 1)),
        *(_DWORD *)(*((_DWORD *)v4 + 66) + 8275));
LABEL_238:
      (*(void (__thiscall **)(char *, _DWORD, _DWORD, int, int, int))(*(_DWORD *)v4 + 28))(v4, 0, 0, 1, v160, v163);
      return;
    case 0x14u:
      if ( !*(_BYTE *)(*((_DWORD *)v4 + 137) + 120188) )
        goto LABEL_247;
      return;
    case 0x15u:
      if ( *(_BYTE *)v54 )
      {
        v134 = *((_DWORD *)v4 + 137);
        v179 = 0;
        v178 = 0;
        v177 = 0;
        v180 = v134;
        v176 = &off_4AC6F8;
        v188 = 6;
        if ( sub_437870(&v176, (char *)v54) )
          sub_422580((int)&v176, 1);
        v188 = -1;
        sub_40B7D0(v177);
      }
      return;
    case 0x16u:
      if ( *(_BYTE *)v54 )
        strncpyt((void *)(*((_DWORD *)v4 + 66) + 643), (void *)v54, 129);
      goto LABEL_247;
    case 0x17u:
      v123 = 1591496559;
      v124 = 169;
      do
        v123 ^= *(_DWORD *)&aFardownRight[4 * v124-- - 364776];
      while ( v124 );
      v4[v123 + 568560] = v4[552] == 0;
      if ( v4[552] )
      {
        a4 = 9135826;
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, 4906960, 0, 0, 0, 1);
      }
      else
      {
        a4 = 9135810;
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, 4906944, 0, 0, 0, 1);
      }
      return;
    default:
LABEL_247:
      v37 = Str;
      goto LABEL_248;
  }
  do
  {
    v112 = *(_DWORD *)(v111 + a4);
    if ( *(_DWORD *)(v112 + 88) != a3[22] )
      goto LABEL_191;
    if ( strlen(&Str) + strlen((const char *)(v112 + 109)) > 0x4B )
    {
      (*(void (__thiscall **)(char *, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, &Str, 0, 0, 0, 1);
      Str = 0;
LABEL_189:
      Size = 9133375;
      sprintf_0(
        &Str,
        (const char *const)(9133375 - ((_DWORD)&loc_407D29 + 2)),
        v112 + 109,
        *(_DWORD *)(v112 + 48) + *(_DWORD *)(v112 + 52));
      goto LABEL_191;
    }
    if ( !Str )
      goto LABEL_189;
    Size = 9133566;
    strchr(&Str, 0);
    sprintf_0(v154, v155, v156, v157);
LABEL_191:
    v111 = *((_DWORD *)v4 + 137);
    v113 = ++v181 < *(_DWORD *)(v111 + 6276);
    a4 += 4;
  }
  while ( v113 );
  if ( Str )
  {
    v114 = 843674055;
    v115 = 137;
    do
      v114 ^= *(_DWORD *)&aApr[4 * v115-- - 580544];
    while ( v115 );
    v88 = (int)&v4[v114 + 551544];
LABEL_212:
    (*(void (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v88 + 28))(v88, &Str, 0, 0, 0, 1);
  }
}
// 4492D1: positive sp value 10 has been found
// 448432: variable 'v12' is possibly undefined
// 44844E: variable 'v14' is possibly undefined
// 448488: variable 'v16' is possibly undefined
// 4484E2: variable 'v20' is possibly undefined
// 4484FE: variable 'v22' is possibly undefined
// 44852E: variable 'v24' is possibly undefined
// 4494CE: variable 'v154' is possibly undefined
// 4494CE: variable 'v155' is possibly undefined
// 4494CE: variable 'v156' is possibly undefined
// 4494CE: variable 'v157' is possibly undefined
// 4498B0: variable 'v160' is possibly undefined
// 4498B0: variable 'v163' is possibly undefined
// 449BA0: variable 'v158' is possibly undefined
// 449BA0: variable 'v159' is possibly undefined
// 449BA0: variable 'v162' is possibly undefined
// 449BA0: variable 'v164' is possibly undefined
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4A7160: using guessed type int (*dword_4A7160)(void);
// 4A72D4: using guessed type int (__stdcall *dword_4A72D4)(_DWORD, _DWORD, _DWORD);
// 4AC6F8: using guessed type int (__stdcall *off_4AC6F8)(int);
// 4B81B8: using guessed type char *[40];
// 4B821C: using guessed type char *[15];

//----- (00449C80) --------------------------------------------------------
_DWORD *__thiscall sub_449C80(int this, int a2)
{
  int v2; // edx
  _DWORD *result; // eax
  int v4; // esi

  v2 = *(_DWORD *)(this + 4);
  result = (_DWORD *)(*(_DWORD *)(this + 12) + 1436);
  v4 = *(_DWORD *)(this + 8);
  if ( v2 >= *result
    && v2 < *(_DWORD *)(*(_DWORD *)(this + 12) + 1444)
    && v4 >= *(_DWORD *)(*(_DWORD *)(this + 12) + 1440)
    && v4 < *(_DWORD *)(*(_DWORD *)(this + 12) + 1448) )
  {
    result = (_DWORD *)(*(int (__thiscall **)(int, int, int, int, _DWORD, _DWORD))(*(_DWORD *)a2 + 184))(
                         a2,
                         *(_DWORD *)(this + 4) / 1000,
                         v4 / 1000,
                         *(_DWORD *)(this + 32)
                       + *(_DWORD *)(this + 44) * *(_DWORD *)(this + 40) / *(_DWORD *)(this + 48)
                       % *(_DWORD *)(this + 44),
                         *(_DWORD *)(this + 36),
                         *(unsigned __int8 *)(this + 52));
  }
  return result;
}

//----- (0044A360) --------------------------------------------------------
int __thiscall sub_44A360(_DWORD *this, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // edx
  int result; // eax
  int v6; // eax
  int v7; // edx
  int v8; // edx

  v2 = this[4];
  v3 = *(_DWORD *)(v2 + *this);
  if ( a2 >= v3 )
  {
    v6 = *(_DWORD *)(this[1] + v2);
    if ( a2 <= v6 )
    {
      result = dword_4C1AE4 - a2;
      v8 = a2 - (dword_4C1AE4 - a2);
      dword_4C1AE4 = result;
      this[3] = result;
      this[2] = v8;
    }
    else
    {
      v7 = dword_4C1AE4 - v6;
      result = v6 - (dword_4C1AE4 - v6);
      dword_4C1AE4 = v7;
      this[3] = v7;
      this[2] = result;
    }
  }
  else
  {
    v4 = dword_4C1AE4 - v3;
    result = v3 - (dword_4C1AE4 - v3);
    dword_4C1AE4 = v4;
    this[3] = v4;
    this[2] = result;
  }
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0044A3D0) --------------------------------------------------------
void __thiscall sub_44A3D0(int this, int a2, int a3)
{
  sub_404DD0(
    *(_DWORD **)(this + 11492),
    a2 - *(_DWORD *)(this + 19880) - *(_DWORD *)(*(_DWORD *)(this + 11492) + 612) / 2,
    a3 - *(_DWORD *)(this + 19884) - *(_DWORD *)(*(_DWORD *)(this + 11492) + 616) / 2,
    *(_DWORD *)(this + 10192),
    1,
    0,
    0);
}

//----- (0044A510) --------------------------------------------------------
int __thiscall sub_44A510(int this)
{
  return (*(_DWORD *)(this + 3) >> 28) + 16 * ((*(unsigned __int16 *)(this + 7) >> 14) + 4 * *(char *)(this + 9));
}

//----- (0044A530) --------------------------------------------------------
int __thiscall sub_44A530(int this)
{
  return *(unsigned __int16 *)(this + 7) << 18 >> 18;
}

//----- (0044A540) --------------------------------------------------------
int __userpurge sub_44A540@<eax>(int *a1@<ecx>, int a2@<ebp>, void *a3, int a4)
{
  int v5; // edx
  int v6; // edi
  int v7; // edi
  int v8; // eax
  int v10[2]; // [esp+8h] [ebp-8h] BYREF

  (*(void (__thiscall **)(int *))(*a1 + 56))(a1);
  *((_BYTE *)a1 + 1395) = a4 != 0;
  a1[337] = a4;
  a1[177] = 0;
  sub_40F920((int)(a1 + 1), a2, a4);
  sub_40F0D0(v10, a3);
  v5 = v10[1];
  a1[235] = v10[0];
  a1[236] = v5;
  sub_40F700(a1 + 1, (int)(a1 + 235), 0, 0);
  v6 = sub_412170();
  v7 = rand() * v6;
  v8 = *a1;
  a1[24] = v7 & 0x7FFFFFFF;
  return (*(int (__thiscall **)(int *))(v8 + 48))(a1);
}

//----- (0044B3A0) --------------------------------------------------------
int __thiscall sub_44B3A0(_DWORD *this, int a2, int a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // ebp
  size_t v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v12; // [esp+10h] [ebp-11Ch] BYREF
  unsigned __int8 *v13; // [esp+14h] [ebp-118h] BYREF
  int v14; // [esp+18h] [ebp-114h]
  char v15[260]; // [esp+1Ch] [ebp-110h] BYREF
  int v16; // [esp+128h] [ebp-4h]

  v4 = this[433];
  v5 = this[29443];
  v15[0] = 0;
  sub_407960(v15, this[5775] + 269, (_BYTE *)(17 * v5 + v4 + 1));
  v6 = a3 - 17;
  if ( a3 == 17 )
  {
    sub_408820(v15);
  }
  else
  {
    v12 = -1;
    v16 = 0;
    sub_4080D0(&v12, v6, v15, 0, 2);
    if ( this[29443] )
    {
      sub_4086E0(&v12, a2 + 17, v6);
    }
    else
    {
      v13 = 0;
      v14 = 0;
      LOBYTE(v16) = 1;
      v7 = 20 * a3;
      if ( 20 * a3 > 1000000 )
        v7 = 1000000;
      sub_40C9D0((int)&v13, v6, v7);
      v8 = sub_412680(v13, v14, (unsigned __int8 *)(a2 + 17), (unsigned __int8 *)(a3 - 17));
      sub_4086E0(&v12, (int)v13, v8);
      LOBYTE(v16) = 0;
      sub_40C9D0((int)&v13, v6, 0);
    }
    sub_4087F0(&v12);
    v16 = -1;
    sub_4087F0(&v12);
  }
  v9 = this[29443];
  v10 = this[433];
  this[468] += a3;
  *(_BYTE *)(17 * v9 + v10) = 1;
  return (*(int (__thiscall **)(_DWORD *))(*this + 376))(this);
}

//----- (0044B530) --------------------------------------------------------
bool __thiscall sub_44B530(int this, int a2)
{
  int v3; // eax
  int v4; // ecx
  unsigned __int16 v5; // ax
  _DWORD *v6; // eax
  bool result; // al
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // edi
  unsigned int v12; // edx
  signed int v13; // ecx
  signed int v14; // ebx
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  signed int v20; // edi
  unsigned int v21; // edx
  int v22; // ecx
  int v23; // ecx
  int v24; // eax
  int v25; // ebx
  unsigned int v26; // edi
  int v27; // edi
  int v28; // ebx
  int v29; // ecx
  int v30; // eax
  char *v31; // ebx
  _DWORD *v32; // ecx
  int v33; // edi
  unsigned int v34; // edx
  signed int v35; // ebx
  int v36; // ebx
  int v37; // edx
  int v38; // edi
  bool v39; // al
  _DWORD *v40; // eax
  int v41; // edi
  int v42; // ecx
  int v43; // edx
  int v44; // eax
  int v45; // ecx
  int v46; // edx
  int v47; // ecx
  int v48; // edx
  int v49; // [esp+4h] [ebp-14h]
  int v50; // [esp+8h] [ebp-10h]
  int v51; // [esp+10h] [ebp-8h]
  char v52; // [esp+17h] [ebp-1h]
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = *(_DWORD *)(this + 32);
  if ( v3 > 0 )
    *(_DWORD *)(this + 32) = v3 - a2;
  v4 = *(_DWORD *)(this + 52);
  *(_DWORD *)(this + 56) += a2;
  if ( v4 )
  {
    if ( *(_DWORD *)(this + 16) || *(_DWORD *)(this + 20) )
    {
      v52 = 0;
      v51 = 0;
      if ( a2 > 0 )
      {
        while ( 1 )
        {
          v8 = *(_DWORD *)(this + 12);
          v9 = *(_DWORD *)(this + 4);
          v10 = *(_DWORD *)(this + 8);
          v49 = v9;
          v50 = v10;
          if ( *(_DWORD *)(v8 + 12024) )
          {
            v11 = *(_DWORD *)(this + 16);
            v12 = *(_DWORD *)(this + 8);
            v13 = v11 + v9;
            *(_DWORD *)(this + 4) = v13;
            v14 = v13;
            v15 = *(_DWORD *)(v8 + 120528);
            if ( v15 )
            {
              if ( (unsigned int)v14 >= 0xFA0000
                || v12 >= 0xFA0000
                || (v16 = (((int)v12 / 16000) << 10) + v15, v17 = *(unsigned __int8 *)(v14 / 16000 + v16), v17 != 253)
                && v17 != 252
                && v17 != 220
                && (*(unsigned __int8 *)(v14 / 16000 + v16) < 0xACu || *(unsigned __int8 *)(v14 / 16000 + v16) >= 0xBFu)
                && v17 != 254
                && v17 != 255
                && v17 != 170
                && v17 != 171
                && *(_BYTE *)(v14 / 16000 + v16) )
              {
                v52 = 1;
                *(_DWORD *)(this + 4) = v49;
                *(_DWORD *)(this + 16) = -v11;
              }
            }
            v18 = *(_DWORD *)(this + 20);
            v19 = *(_DWORD *)(this + 12);
            v20 = *(_DWORD *)(this + 4);
            v21 = v18 + *(_DWORD *)(this + 8);
            *(_DWORD *)(this + 8) = v21;
            v22 = *(_DWORD *)(v19 + 120528);
            if ( v22 )
            {
              if ( (unsigned int)v20 >= 0xFA0000
                || v21 >= 0xFA0000
                || (v23 = (((int)v21 / 16000) << 10) + v22, v24 = *(unsigned __int8 *)(v20 / 16000 + v23), v24 != 253)
                && v24 != 252
                && v24 != 220
                && (*(unsigned __int8 *)(v20 / 16000 + v23) < 0xACu || *(unsigned __int8 *)(v20 / 16000 + v23) >= 0xBFu)
                && v24 != 254
                && v24 != 255
                && v24 != 170
                && v24 != 171
                && *(_BYTE *)(v20 / 16000 + v23) )
              {
                v52 = 1;
                *(_DWORD *)(this + 8) = v50;
                *(_DWORD *)(this + 20) = -v18;
              }
            }
          }
          else
          {
            v25 = *(_DWORD *)(this + 8);
            v26 = *(_DWORD *)(this + 16) + *(_DWORD *)(this + 4);
            *(_DWORD *)(this + 4) = v26;
            *(_DWORD *)(this + 8) = *(_DWORD *)(this + 20) + v25;
            if ( v26 >= 0xFA0000 )
            {
              *(_DWORD *)(this + 4) = v9;
              *(_DWORD *)(this + 16) = -*(_DWORD *)(this + 16);
            }
            if ( *(_DWORD *)(this + 8) >= 0xFA0000u )
            {
              *(_DWORD *)(this + 8) = v10;
              *(_DWORD *)(this + 20) = -*(_DWORD *)(this + 20);
            }
          }
          v27 = *(_DWORD *)(this + 60);
          v28 = v27 / 1000 * *(_DWORD *)(this + 20);
          *(_DWORD *)(this + 16) = v27 / 1000 * *(_DWORD *)(this + 16) / 1000;
          v29 = *(_DWORD *)(this + 28);
          *(_DWORD *)(this + 20) = v28 / 1000;
          *(_DWORD *)(this + 60) = v27 - v29;
          if ( v27 - v29 < 0 )
            break;
          if ( ++v51 >= a2 )
            goto LABEL_51;
        }
        v30 = 0;
        v31 = byte_40FC98;
        do
        {
          v30 -= *(_DWORD *)v31;
          v31 += 4;
        }
        while ( v31 < (char *)sub_40FD30 );
        *(_DWORD *)(v30 - 1726525659 + this + 109948) = 0;
      }
LABEL_51:
      if ( a2 < 10 && v52 )
        (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(this + 12) + 260))(
          *(_DWORD *)(this + 12),
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 120076) + 300),
          *(_DWORD *)(this + 4),
          *(_DWORD *)(this + 8),
          0,
          0);
    }
    v32 = *(_DWORD **)(this + 12);
    if ( *(_DWORD *)(v32[542] + 24) == *(__int16 *)(this + 50) )
    {
      v33 = v32[30132];
      v34 = *(_DWORD *)(this + 8);
      v35 = *(_DWORD *)(this + 4);
      if ( v33 )
      {
        if ( (unsigned int)v35 < 0xFA0000
          && v34 < 0xFA0000
          && *(unsigned __int8 *)(v35 / 16000 + (((int)v34 / 16000) << 10) + v33) == 172 )
        {
          v36 = v35 / 16000;
          v37 = *(_DWORD *)(this + 8) / 16000;
          switch ( v32[2753] )
          {
            case 1:
              v38 = v36 >= 512;
              break;
            case 2:
              v38 = v37 >= 512;
              break;
            case 3:
            case 4:
              if ( v36 >= 512 )
                v38 = v37 < 512 ? 1 : 3;
              else
                v38 = v37 < 512 ? 0 : 2;
              break;
            case 5:
            case 6:
              if ( v36 >= v37 )
                v38 = (v36 >= 1024 - v37) + 2;
              else
                v38 = v36 >= 1024 - v37;
              break;
            default:
              v38 = 0;
              break;
          }
          switch ( *(_DWORD *)(*(_DWORD *)(this + 12) + 11012) )
          {
            case 0:
              goto LABEL_74;
            case 1:
            case 2:
              v39 = (*(_DWORD *)(v32[542] + 88) & 1) != v38;
              goto LABEL_73;
            case 3:
            case 5:
              v39 = (*(_DWORD *)(v32[542] + 88) & 3) != v38;
              goto LABEL_73;
            case 4:
            case 6:
              v39 = (*(_DWORD *)(v32[542] + 88) & 3) == v38;
LABEL_73:
              if ( v39 )
LABEL_74:
                (*(void (__thiscall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(this + 12) + 140))(
                  *(_DWORD *)(this + 12),
                  *(unsigned __int8 *)(this + 41),
                  v36,
                  *(_DWORD *)(this + 8) / 16000);
              break;
            default:
              break;
          }
        }
      }
    }
    if ( *(_DWORD *)(this + 16) || *(_DWORD *)(this + 20) )
    {
      v40 = *(_DWORD **)(this + 12);
      if ( *(_BYTE *)(v40[5775] + 8052) )
      {
        v41 = *(_DWORD *)(this + 24) - a2;
        *(_DWORD *)(this + 24) = v41;
        if ( v41 <= 0 && *(int *)(this + 32) <= 0 )
        {
          v42 = *(_DWORD *)(this + 4);
          v43 = *(_DWORD *)(this + 8);
          if ( v42 >= v40[359] && v42 < v40[361] && v43 >= v40[360] && v43 < v40[362] )
          {
            *(_DWORD *)(this + 24) = v41 + 5;
            v44 = sub_40B720((int)&savedregs, 0x40u);
            if ( v44 )
            {
              v45 = *(_DWORD *)(this + 4);
              v46 = *(_DWORD *)(this + 8);
              *(_DWORD *)(v44 + 12) = *(_DWORD *)(this + 12);
              *(_DWORD *)(v44 + 8) = 0;
              *(_DWORD *)(v44 + 4) = 0;
              *(_DWORD *)(v44 + 4) = v45;
              *(_DWORD *)(v44 + 20) = 0;
              *(_DWORD *)(v44 + 16) = 0;
              *(_DWORD *)(v44 + 24) = 0;
              *(_DWORD *)(v44 + 28) = 30;
              *(_DWORD *)(v44 + 32) = 20;
              *(_DWORD *)(v44 + 36) = 13;
              *(_DWORD *)(v44 + 44) = 10;
              *(_DWORD *)(v44 + 48) = 30;
              *(_BYTE *)(v44 + 52) = 0;
              *(_DWORD *)v44 = off_4AC414;
              *(_DWORD *)(v44 + 8) = v46;
              *(_DWORD *)(v44 + 40) = 0;
            }
            else
            {
              v44 = 0;
            }
            v47 = *(_DWORD *)(this + 12) + 7656;
            v48 = *(_DWORD *)(*(_DWORD *)(this + 12) + 8680);
            if ( v48 >= 256 )
            {
              sub_40B7E0(v44);
            }
            else
            {
              *(_DWORD *)(v47 + 4 * v48) = v44;
              ++*(_DWORD *)(v47 + 1024);
            }
          }
        }
      }
    }
    result = *(_DWORD *)(*(_DWORD *)(this + 12) + 23104) - *(_DWORD *)(this + 36) < 1500;
  }
  else
  {
    v5 = *(_WORD *)(this + 50);
    if ( v5 < 0x400u )
    {
      v6 = *(_DWORD **)(*(_DWORD *)(this + 12) + 4 * (__int16)v5 + 113620);
      if ( v6 )
      {
        if ( !v6[19] )
        {
          *(_DWORD *)(this + 4) = v6[1];
          *(_DWORD *)(this + 8) = v6[2];
        }
      }
    }
    result = 1;
  }
  return result;
}
// 4AC414: using guessed type int (__stdcall *off_4AC414[2])(int, int);

//----- (0044BB30) --------------------------------------------------------
void __thiscall sub_44BB30(char *this, int a2, char a3, int a4)
{
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  int v11; // edi
  int v12; // edx
  int v13; // [esp+18h] [ebp+8h]

  v5 = sub_40B720((int)this, 0x11Cu);
  if ( v5 )
  {
    *(_BYTE *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 268) = 0;
    *(_DWORD *)(v5 + 272) = 0;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  v7 = a4;
  *(_DWORD *)v6 = 0;
  *(_BYTE *)(v6 + 280) = a3;
  *(_DWORD *)(v6 + 4) = v7;
  sub_4079D0((_BYTE *)(v6 + 8), a2);
  v8 = *((_DWORD *)this + 6);
  v9 = (int *)(this + 16);
  if ( v8 >= *((_DWORD *)this + 5) )
  {
    if ( v8 >= 8 )
    {
      v10 = (v8 >= 32) - 1;
      LOBYTE(v10) = v10 & 0xE8;
      v13 = v10 + 32;
    }
    else
    {
      v13 = 4;
    }
    sub_40B780(4 * (v8 + v13), (void **)this + 4, (int)this);
    *((_DWORD *)this + 5) += v13;
  }
  sub_46CAB0(*v9 + 4 * v8 + 4, (_BYTE *)(*v9 + 4 * v8), 4 * (*((_DWORD *)this + 6) + 0x3FFFFFFF * v8));
  v11 = 4 * v8;
  v12 = *v9;
  ++*((_DWORD *)this + 6);
  sub_46CAB0(v12 + v11, &a4, 4u);
  *(_DWORD *)(v11 + *v9) = v6;
  (**(void (__thiscall ***)(void *, int))this)(this, v6);
  qsort(*((void **)this + 1), *((_DWORD *)this + 3), 0x9Cu, sub_421E20);
}

//----- (0044BC40) --------------------------------------------------------
int __thiscall sub_44BC40(int this)
{
  int v2; // eax
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // ecx
  int v6; // esi

  *(_DWORD *)(this + 324) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_BYTE *)(this + 96) &= 0xF0u;
  v2 = 0;
  v3 = (_DWORD *)((char *)&loc_44FC13 + 1);
  do
    v2 -= *v3++;
  while ( v3 < (_DWORD *)&loc_44FF40 );
  result = v2 - 1082387902;
  v5 = (*(_DWORD *)(this + 92) != 8) - 1;
  v6 = dword_4C1AE4 - v5;
  dword_4C1AE4 = v6;
  *(_DWORD *)(result + this + 663336) = v6;
  *(_DWORD *)(result + this + 663332) = v5 - v6;
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0044BCA0) --------------------------------------------------------
int __thiscall sub_44BCA0(_DWORD *this)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  char v6[2]; // [esp+6h] [ebp-2h] BYREF

  result = this[228];
  if ( result )
  {
    v3 = *this;
    v6[0] = 0;
    v6[1] = 7;
    (*(void (__thiscall **)(_DWORD *, int, char *))(v3 + 20))(this, 2, v6);
    (*(void (__thiscall **)(_DWORD *, int, char *))(*this + 20))(this, 2, v6);
    v4 = 6733144;
    v5 = 225;
    do
      v4 ^= (unsigned int)*(&dword_4A7410 + v5-- + 3095);
    while ( v5 );
    sub_40FD80((_DWORD *)((char *)this + v4 + 2385156));
    result = (*(int (__thiscall **)(_DWORD *))(*this + 24))(this);
  }
  return result;
}
// 4A7410: using guessed type int (__stdcall *dword_4A7410)(_DWORD);

//----- (0044BD10) --------------------------------------------------------
char __thiscall sub_44BD10(_DWORD *this, int a2, unsigned __int8 *a3, int a4)
{
  char result; // al
  int v6; // esi
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int v10; // eax
  unsigned __int8 *v11; // ebx
  int v12; // edi
  int v13; // [esp+10h] [ebp-18h]

  result = (a2 >> 31) + a2;
  v6 = a2 / 256;
  if ( (unsigned int)(a2 / 256) < 8 && (a4 != this[a2 + 2908] || (result = *((_BYTE *)this + v6 + 11624)) != 0) )
  {
    if ( !this[v6 + 2897] )
    {
      v7 = (_DWORD *)sub_40B720((int)this, 0x2Cu);
      if ( v7 )
        v8 = sub_405030(v7, (int)this, 192, 128, *(_BYTE *)(this[302] + 8233));
      else
        v8 = 0;
      this[v6 + 2897] = v8;
    }
    v9 = (_DWORD *)this[v6 + 2897];
    result = sub_4052C0((int)v9);
    if ( result )
    {
      v10 = 8 * (a2 / 16 % 16);
      v13 = 0;
      v11 = a3;
      while ( 1 )
      {
        v12 = 0;
        v9[7] = v9[4] + v9[5] * (v10 + v13);
        do
        {
          a3 = (unsigned __int8 *)this[*v11 + 13076];
          sub_46CAB0(v9[7] + v9[6] * (v12 + 12 * (a2 % 16)), &a3, v9[6]);
          ++v12;
          ++v11;
        }
        while ( v12 < 12 );
        if ( ++v13 >= 8 )
          break;
        v10 = 8 * (a2 / 16 % 16);
      }
      v9[3] = sub_405410((int)v9);
      sub_405330((int)v9);
      result = a2;
      this[a2 + 2908] = a4;
    }
  }
  return result;
}

//----- (0044BEB0) --------------------------------------------------------
char __thiscall sub_44BEB0(char *this)
{
  char *v1; // ebx
  int v2; // eax
  _DWORD *v3; // edi
  char *v4; // esi
  int i; // ebx
  _DWORD *v6; // ecx
  _DWORD *v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // esi
  int *v11; // edi
  int v12; // ebx
  int v13; // esi
  int v15; // [esp+4h] [ebp-8h]

  v1 = this;
  LOBYTE(v2) = this[10180];
  if ( (_BYTE)v2 )
  {
    v2 = *((_DWORD *)this + 14);
    if ( v2 )
    {
      sub_40DA80((char *)(9210725 - (_DWORD)sub_41A999));
      v1[10181] = 0;
      v3 = &unk_4AA220;
      v15 = 40;
      while ( 1 )
      {
        v4 = &v1[*(v3 - 2)];
        for ( i = 0; i < *v3; v4 += 4 )
        {
          if ( *(_DWORD *)v4 )
            sub_4043D0(*(_DWORD **)v4, 0);
          ++i;
        }
        v3 += 4;
        if ( !--v15 )
          break;
        v1 = this;
      }
      v6 = (_DWORD *)*((_DWORD *)this + 2850);
      if ( v6 )
        sub_4043D0(v6, 0);
      v7 = this + 3020;
      v8 = 128;
      do
      {
        *v7 = 0;
        v7 += 14;
        --v8;
      }
      while ( v8 );
      v9 = *((_DWORD *)this + 4956);
      if ( v9 && sub_405410(*((_DWORD *)this + 4956)) != *(_DWORD *)(v9 + 12) )
        *(_BYTE *)(v9 + 32) = 1;
      v10 = *((_DWORD *)this + 4957);
      if ( v10 && sub_405410(*((_DWORD *)this + 4957)) != *(_DWORD *)(v10 + 12) )
        *(_BYTE *)(v10 + 32) = 1;
      v11 = (int *)(this + 11588);
      v12 = 8;
      do
      {
        v13 = *v11;
        if ( *v11 && sub_405410(*v11) != *(_DWORD *)(v13 + 12) )
          *(_BYTE *)(v13 + 32) = 1;
        ++v11;
        --v12;
      }
      while ( v12 );
      LOBYTE(v2) = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 88))(this);
    }
  }
  return v2;
}
// 41A999: using guessed type int sub_41A999();

//----- (0044BFF0) --------------------------------------------------------
int __thiscall sub_44BFF0(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // ecx
  int result; // eax
  _DWORD *v6; // ecx
  int v7; // ebx
  int *v8; // ecx
  int v9; // edi
  _WORD *v10; // eax
  int v11; // [esp-4h] [ebp-14h]

  v4 = (_DWORD *)this[542];
  if ( v4[130] + v4[131] >= 0 )
  {
    v7 = a3;
    (*(void (__thiscall **)(_DWORD *, int, int))(*v4 + 104))(v4, a2, a3);
    v8 = (int *)this[542];
    v11 = v7;
    v9 = *v8;
    v10 = (_WORD *)(*(int (__thiscall **)(int *, int *, int, int))(*v8 + 96))(v8, &a3, a2, v7);
    LOWORD(v10) = *v10;
    result = (*(int (__thiscall **)(_DWORD, _DWORD, _WORD *))(v9 + 132))(this[542], 0, v10);
  }
  else
  {
    HIWORD(v11) = HIWORD(v4);
    LOWORD(v11) = 0;
    (*(void (__stdcall **)(_DWORD, int))(*(_DWORD *)this[542] + 132))(0, v11);
    result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)this[542] + 120))(this[542], 0);
    if ( *(_DWORD *)(a3 + 88) == 13 )
    {
      v6 = (_DWORD *)this[542];
      result = v6[187];
      if ( (result & 0x200) != 0 )
        result = (*(int (__thiscall **)(_DWORD *))(*v6 + 128))(v6);
    }
  }
  return result;
}

//----- (0044C0A0) --------------------------------------------------------
int __thiscall sub_44C0A0(int this, char **a2, int a3)
{
  int v5; // ecx
  int v6; // ecx
  int v7; // ebx
  unsigned int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // edx
  unsigned int v22; // edx
  int v23; // eax
  char Buffer[64]; // [esp+Ch] [ebp-50h] BYREF
  int v26; // [esp+4Ch] [ebp-10h]
  unsigned int v27; // [esp+50h] [ebp-Ch]
  int v28; // [esp+54h] [ebp-8h]
  char *Format; // [esp+58h] [ebp-4h]
  int v30; // [esp+64h] [ebp+8h]
  int v31; // [esp+64h] [ebp+8h]

  if ( *(int *)(this + 436) > 0 )
  {
    v5 = *(_DWORD *)(this + 60);
    Format = (char *)(1000 * (*(_DWORD *)(this + 80) + 2));
    (*((void (__thiscall **)(char **, int, int, _DWORD, int))*a2 + 44))(
      a2,
      (int)((__int64)(sin((double)(v5 / 1000) * dbl_4AC920) * (double)(int)Format) + *(_DWORD *)(this + 4)) / 1000,
      (int)(*(_DWORD *)(this + 8) - (__int64)(cos((double)(v5 / 1000) * dbl_4AC920) * (double)(int)Format)) / 1000,
      *(_DWORD *)(this + 436),
      5);
  }
  v6 = 7;
  if ( (*(_BYTE *)(this + 96) & 0x40) == 0 )
    v6 = *(_DWORD *)(this + 92);
  v30 = v6;
  v7 = *(_DWORD *)(this + 4) / 1000;
  v8 = (int)((unsigned __int64)(274877907i64 * *(int *)(this + 8)) >> 32) >> 6;
  v26 = v7;
  v9 = *(_DWORD *)(this + 28);
  v27 = (v8 >> 31) + v8;
  if ( v9 != -1 )
    v30 = -2;
  v10 = *(_DWORD *)(this + 428);
  Format = *a2;
  (*((void (__thiscall **)(char **, int, unsigned int, int, int, int))Format + 42))(
    a2,
    v7,
    v27,
    *(_DWORD *)(this + 60) / 1000,
    v30,
    v10 / 1000);
  v11 = *(_DWORD *)(this + 28);
  v12 = 0;
  if ( v11 == -1
    || (v13 = *(_DWORD *)(*(_DWORD *)(this + 12) + 4 * v11 + 113620)) == 0
    || (v14 = *(_DWORD *)(v13 + 92), v14 == 8) )
  {
    v31 = *(_DWORD *)(this + 92);
  }
  else
  {
    v31 = v14;
  }
  if ( *(int *)(this + 820) > 0 && *(int *)(this + 40) >= 0 )
  {
    Format = (char *)9215985;
    v15 = *(_DWORD *)(this + 820);
    Format = aDD;
    sprintf_0(Buffer, aDD, v15 / 100, v15 / 10 % 10);
    (*((void (__thiscall **)(char **, int, int, unsigned int, _DWORD, int, char *, int, int, _DWORD, _DWORD))*a2 + 43))(
      a2,
      v31,
      v26,
      v27,
      0,
      a3,
      Buffer,
      6,
      -1,
      0,
      0);
    v12 = 1;
  }
  v16 = *(_DWORD *)(this + 460);
  if ( *(_DWORD *)(*(_DWORD *)(this + 464) + v16) )
  {
    v17 = *(_DWORD *)(this + 452) + *(_DWORD *)(this + 456);
    v18 = *(_DWORD *)(*(_DWORD *)(this + 448) + v16);
    if ( v17 > v18 )
      v17 = v18;
  }
  else
  {
    v17 = *(_DWORD *)(*(_DWORD *)(this + 444) + v16);
  }
  v19 = *(_DWORD *)(this + 520) + *(_DWORD *)(this + 524);
  v28 = 1000 * v17;
  if ( v19 < 1000 * v17 / 2 )
  {
    Format = (char *)9200078;
    v20 = *(_DWORD *)(this + 524);
    v21 = *(_DWORD *)(this + 520);
    Format = aD;
    v22 = (int)((unsigned __int64)(274877907i64 * (v21 + v20)) >> 32) >> 6;
    sprintf_0(Buffer, aD, (v22 >> 31) + v22);
    v23 = *(_DWORD *)(this + 520);
    Format = *a2;
    (*((void (__thiscall **)(char **, int, int, unsigned int, _DWORD, int, char *, int, int, _DWORD, _DWORD))Format + 43))(
      a2,
      v31,
      v26,
      v27,
      0,
      v12 + a3,
      Buffer,
      (v23 + *(_DWORD *)(this + 524) >= v28 / 4) + 3,
      -1,
      0,
      0);
    ++v12;
  }
  return v12;
}
// 4AC920: using guessed type double dbl_4AC920;

//----- (0044C3C0) --------------------------------------------------------
int __thiscall sub_44C3C0(_DWORD *this, int a2, int a3)
{
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  bool v19; // zf
  int v20; // ecx
  int v21; // edi
  _DWORD *v22; // ecx
  char *v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v28; // [esp+0h] [ebp-34h] BYREF
  int v29; // [esp+Ch] [ebp-28h] BYREF
  int v30; // [esp+10h] [ebp-24h]
  _DWORD *v31; // [esp+14h] [ebp-20h]
  int v32; // [esp+18h] [ebp-1Ch]
  _DWORD *v33; // [esp+1Ch] [ebp-18h]
  char *v34; // [esp+20h] [ebp-14h]
  int *v35; // [esp+24h] [ebp-10h]
  int v36; // [esp+30h] [ebp-4h]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v4 = a3;
  this[5776] = a2;
  v33 = this + 5775;
  this[5775] = v4;
  this[27971] = v4;
  *((_BYTE *)this + 113572) = 0;
  v5 = this[5775];
  v35 = &v28;
  v31 = this;
  this[29992] = *(_DWORD *)(v5 + 639);
  this[543] = 0;
  *((_BYTE *)this + 1432) = 0;
  *((_BYTE *)this + 120080) = 0;
  *((_BYTE *)this + 1420) = 0;
  *((_BYTE *)this + 27208) = 0;
  *((_BYTE *)this + 2176) = 0;
  *((_BYTE *)this + 112216) = 1;
  this[2788] = 4000;
  this[2872] = 100;
  this[2954] = 50;
  this[2742] = 0;
  this[2748] = 250;
  this[3030] = 300;
  this[3041] = 4000;
  this[2917] = 12000;
  this[2891] = 250;
  this[3001] = -1;
  v6 = -1858991499;
  v7 = 240;
  do
    v6 ^= *(_DWORD *)&a4040s[4 * v7-- - 536192];
  while ( v7 );
  v8 = this + 3075;
  *(_DWORD *)((char *)this + v6 + 225488228) = 0;
  this[29442] = 2;
  this[1911] = 0;
  memset(this + 3075, 1u, 0x1Cu);
  *((_BYTE *)this + 12328) = 1;
  this[1877] = 0;
  v9 = 29;
  do
  {
    v10 = *v8++ + this[1877];
    --v9;
    this[1877] = v10;
  }
  while ( v9 );
  memset(this + 29431, 0, 0x20u);
  memset(this + 28405, 0, 0x1000u);
  memset(this + 5778, 0, 0x1000u);
  this[30119] = 0;
  this[29440] = 0;
  this[542] = 0;
  this[1876] = -1;
  *((_BYTE *)this + 23109) = 0;
  *((_BYTE *)this + 23108) = 0;
  *((_BYTE *)this + 28244) = 0;
  *((_BYTE *)this + 7652) = 0;
  this[352] = 1;
  this[30118] = -1;
  this[28391] = -1;
  this[28390] = -1;
  this[28053] = -1;
  v11 = dword_4C1AE4;
  this[1909] = dword_4C1AE4;
  this[1908] = -v11;
  this[30128] = 0;
  this[357] = 0;
  this[1878] = 0;
  this[469] = 1;
  this[30141] = 0;
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)this[30127] + 52))(this[30127]);
  v12 = (int)v33;
  v13 = this[28087];
  this[432] = 0;
  v14 = *(_DWORD *)v12;
  this[29960] = 0;
  *((_BYTE *)this + 113557) = 0;
  *((_BYTE *)this + 117788) = 0;
  *((_BYTE *)this + 1452) = 0;
  this[30132] = 0;
  this[2172] = 0;
  this[2171] = 0;
  (*(void (__thiscall **)(_DWORD *, _DWORD))(v13 + 40))(this + 28087, *(_DWORD *)(v14 + 8263));
  if ( !*(_DWORD *)(*(_DWORD *)v12 + 8280) )
    *(_DWORD *)(*(_DWORD *)v12 + 8280) = 1;
  *((_BYTE *)this + 28245) = 0;
  this[29961] = 0;
  this[30021] = 0;
  this[30017] = 0;
  this[30018] = 0;
  sub_40C9D0((int)(this + 28402), (int)&savedregs, 0);
  v15 = *(_DWORD *)v12;
  v16 = *(_DWORD *)(*(_DWORD *)v12 + 7999);
  *((_BYTE *)this + 6281) = 1;
  *((_BYTE *)this + 6280) = v16 != 2;
  v17 = *(_DWORD *)(v15 + 8007);
  v18 = this[5776];
  v19 = v17 == 0;
  v20 = this[30127];
  this[29445] = 0;
  *((_BYTE *)this + 6282) = v19;
  this[436] = 0;
  this[29991] = 0;
  this[29990] = 0;
  this[30126] = 0;
  this[30125] = 0;
  this[28392] = v18;
  (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 20))(v20);
  *((_BYTE *)this + 117789) = 0;
  *((_BYTE *)this + 113524) = 0;
  *((_BYTE *)this + 113604) = 0;
  this[29965] = 0;
  this[29430] = 0;
  this[27544] = 0;
  this[28052] = 0;
  a3 = 0;
  v21 = 0;
  while ( 1 )
  {
    v32 = v21;
    if ( v21 >= 20 || a3 >= 4 )
      break;
    v22 = v33;
    this[v21 + 30142] = -1;
    *((_BYTE *)this + v21 + 120480) = 0;
    v23 = strstr((const char *)(*v22 + 250 * v21 + 772), aW);
    if ( v23 && (v34 = v23 + 3, sub_408AA0(v23 + 3)) )
    {
      v36 = 2;
      v29 = 0;
      v30 = 0;
      a2 = -1;
      sub_407E80(&a2, (int)&savedregs, v34, 1, 3);
      if ( (unsigned int)sub_408270(&a2) <= 0x10000 )
      {
        v24 = sub_408270(&a2);
        sub_40C9D0((int)&v29, (int)&savedregs, v24);
        ReadScrty1FileOffset(&a2, v29, v30);
        v34 = (char *)&this[2 * a3 + 29966];
        sub_40C9D0((int)v34, (int)&savedregs, (v30 + 999) / 1000 + v30 + 12);
        v25 = sub_4126C0(*(_DWORD *)v34 + 4, this[2 * a3 + 29967] - 4, v29, v30);
        if ( v25 <= 0 )
        {
          sub_40C9D0((int)v34, (int)&savedregs, 0);
        }
        else
        {
          v26 = a3;
          this[v21 + 30142] = a3;
          a3 = v26 + 1;
          sub_40C9D0((int)v34, (int)&savedregs, v25 + 4);
        }
      }
      LOBYTE(v36) = 1;
      sub_4087F0(&a2);
      LOBYTE(v36) = 0;
      sub_40C9D0((int)&v29, (int)&savedregs, 0);
      v36 = -1;
      ++v21;
    }
    else
    {
      ++v21;
    }
  }
  (*(void (__thiscall **)(_DWORD *))(*this + 108))(this);
  return (*(int (__thiscall **)(_DWORD *))(*this + 84))(this);
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0044C8D0) --------------------------------------------------------
char __thiscall sub_44C8D0(char *this, unsigned int a2)
{
  unsigned int v2; // edi
  char *v3; // esi
  void *v4; // eax
  unsigned int v5; // ebx
  int v8; // [esp+18h] [ebp+4h]

  if ( a2 >= 8 && *(_DWORD *)this == 1414418243 )
  {
    v2 = a2 - 8;
    v3 = this + 8;
    v8 = 0;
    if ( !*((_DWORD *)this + 1) )
      return 1;
    while ( v2 >= 0x11 )
    {
      if ( *(_DWORD *)v3 != 1414418243 )
        break;
      v4 = memchr(v3 + 16, 0, v2 - 16);
      if ( !v4 )
        break;
      v5 = (unsigned int)v4 + *((_DWORD *)v3 + 3) - (_DWORD)v3 + 1;
      if ( v5 > v2 )
        break;
      v2 -= v5;
      v3 = &strchr(v3 + 16, 0)[*((_DWORD *)v3 + 3) + 1];
      if ( (unsigned int)++v8 >= *((_DWORD *)this + 1) )
        return 1;
    }
  }
  return 0;
}

//----- (0044C970) --------------------------------------------------------
unsigned int __thiscall sub_44C970(_DWORD *this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int (__stdcall *v5)(int); // ebx
  unsigned int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  int v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  char **v18; // edi
  _DWORD *v19; // ebx
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  _DWORD *v27; // eax
  _DWORD *v28; // eax
  _DWORD *v29; // eax
  int v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  _BYTE *v33; // eax
  int v34; // ebx
  char **v35; // edi
  char v36; // dl
  char v37; // cl
  char v38; // dl
  _DWORD *v39; // eax
  _DWORD *v40; // eax
  unsigned int v41; // ecx
  char **v42; // edi
  _DWORD *v43; // ebx
  _DWORD *v44; // eax
  _DWORD *v45; // eax
  _DWORD *v46; // edi
  int v47; // ebx
  _DWORD *v48; // eax
  _DWORD *v49; // eax
  _DWORD *v50; // eax
  _DWORD *v51; // eax
  _DWORD *v52; // eax
  _DWORD *v53; // eax
  _DWORD *v54; // eax
  _DWORD *v55; // eax
  _DWORD *v56; // eax
  _DWORD *v57; // eax
  _DWORD *v58; // eax
  _DWORD *v59; // eax
  _DWORD *v60; // eax
  _DWORD *v61; // eax
  _DWORD *v62; // eax
  _DWORD *v63; // eax
  _DWORD *v64; // eax
  _DWORD *v65; // eax
  _DWORD *v66; // eax
  _DWORD *v67; // eax
  _BYTE *v68; // eax
  int v69; // ebx
  char v70; // dl
  char v71; // cl
  char v72; // dl
  char v73; // cl
  char v74; // dl
  char **v75; // edi
  _DWORD *v76; // eax
  _DWORD *v77; // eax
  unsigned int v78; // ecx
  char **v79; // edi
  _DWORD *v80; // ebx
  _DWORD *v81; // eax
  _DWORD *v82; // eax
  _DWORD *v83; // eax
  int v84; // ecx
  _DWORD *v85; // eax
  _DWORD *v86; // eax
  _DWORD *v87; // eax
  _DWORD *v88; // eax
  _DWORD *v89; // eax
  _DWORD *v90; // eax
  _DWORD *v91; // eax
  _DWORD *v92; // eax
  _DWORD *v93; // eax
  _DWORD *v94; // eax
  _DWORD *v95; // eax
  _DWORD *v96; // eax
  _DWORD *v97; // eax
  _DWORD *v98; // eax
  _DWORD *v99; // eax
  _BYTE *v100; // eax
  int v101; // ebx
  char v102; // dl
  char v103; // cl
  char v104; // dl
  char **v105; // edi
  _DWORD *v106; // eax
  _DWORD *v107; // eax
  unsigned int v108; // ecx
  _DWORD *v109; // eax
  _DWORD *v110; // eax
  _DWORD *v111; // eax
  _DWORD *v112; // eax
  _DWORD *v113; // eax
  _DWORD *v114; // eax
  _DWORD *v115; // eax
  _DWORD *v116; // eax
  _DWORD *v117; // eax
  _DWORD *v118; // eax
  int v119; // eax
  char **v120; // edi
  _DWORD *v121; // ebx
  _DWORD *v122; // eax
  _DWORD *v123; // eax
  int v124; // eax
  unsigned int *v125; // ebx
  int *v126; // edi
  int v127; // eax
  int v128; // ecx
  _DWORD *v129; // ebx
  int v130; // edi
  char *v131; // ecx
  int j; // eax
  unsigned int result; // eax
  char v134[1024]; // [esp+Ch] [ebp-550h] BYREF
  char pExceptionObject[308]; // [esp+40Ch] [ebp-150h] BYREF
  int v136; // [esp+540h] [ebp-1Ch]
  char v137; // [esp+544h] [ebp-18h]
  char v138; // [esp+545h] [ebp-17h]
  char v139; // [esp+546h] [ebp-16h]
  unsigned int i; // [esp+548h] [ebp-14h]
  _DWORD *v141; // [esp+54Ch] [ebp-10h]
  int v142; // [esp+558h] [ebp-4h]
  int savedregs; // [esp+55Ch] [ebp+0h] BYREF

  memset(this + 2908, 0, 0x2000u);
  if ( sub_404F40((int)v134, 0, 0x67u, aTilesBm2) )
  {
    sub_46CAB0((unsigned int)(this + 13332), v134, 0x400u);
    v2 = this[302];
    if ( !*(_BYTE *)(v2 + 8045) || (v3 = *(_DWORD *)(v2 + 8072), v3 <= 10) )
      v3 = 100;
    this[299] = v3;
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 60))(this, v134);
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 8))(this, v134);
  }
  v4 = 0;
  v5 = nullsub_4;
  do
  {
    v4 -= *(_DWORD *)v5;
    v5 = (int (__stdcall *)(int))((char *)v5 + 4);
  }
  while ( (int *)v5 < dword_40FA88 );
  *(_DWORD *)((char *)this + v4 - 304538881) = 0;
  v6 = *(_DWORD *)(this[302] + 8003);
  if ( v6 >= 4 )
    v6 = 1;
  v7 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v7;
  v142 = 0;
  if ( v7 )
    v8 = sub_403F00(v7, (int)this, (int)&(&off_4A9678)[16 * v6], *(_BYTE *)(this[302] + 8209), 0);
  else
    v8 = 0;
  v142 = -1;
  this[2551] = v8;
  v9 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v9;
  v142 = 1;
  if ( v9 )
    v10 = sub_403F00(v9, (int)this, (int)&(&off_4A9678)[16 * v6], 1, 0);
  else
    v10 = 0;
  v142 = -1;
  this[2552] = v10;
  v11 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v11;
  v142 = 2;
  if ( v11 )
    v12 = sub_403F00(v11, (int)this, (int)&(&off_4A9698)[16 * v6], *(_BYTE *)(this[302] + 8209), 0);
  else
    v12 = 0;
  v142 = -1;
  this[2553] = v12;
  v13 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v13;
  v142 = 3;
  if ( v13 )
    v14 = sub_403F00(v13, (int)this, (int)&(&off_4A9698)[16 * v6], 1, 0);
  else
    v14 = 0;
  this[2554] = v14;
  v15 = this[2551];
  v142 = -1;
  this[18806] = *(_DWORD *)(v15 + 612);
  this[18807] = *(_DWORD *)(v15 + 616);
  v16 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v16;
  v142 = 4;
  if ( v16 )
    v17 = sub_403C70(v16, (int)this, aTilesBm2, 19, 10, 1, *(_BYTE *)(this[302] + 8210));
  else
    v17 = 0;
  v142 = -1;
  this[2555] = v17;
  v18 = &off_4A95D8;
  v19 = this + 2556;
  do
  {
    v20 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    i = (unsigned int)v20;
    v142 = 5;
    if ( v20 )
      v21 = sub_403F00(v20, (int)this, (int)v18, *(_BYTE *)(this[302] + 8257), 0);
    else
      v21 = 0;
    *v19 = v21;
    v18 += 8;
    ++v19;
    v142 = -1;
  }
  while ( v18 < &off_4A9678 );
  v22 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v22;
  v142 = 6;
  if ( v22 )
    v23 = sub_403C70(v22, (int)this, aPrizesBm2, 10, 1, 120, *(_BYTE *)(this[302] + 8220));
  else
    v23 = 0;
  v142 = -1;
  this[2561] = v23;
  v24 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v24;
  v142 = 7;
  if ( v24 )
    v25 = sub_403C70(v24, (int)this, aFlagBm2, 10, 2, 100, *(_BYTE *)(this[302] + 8221));
  else
    v25 = 0;
  v142 = -1;
  this[2562] = v25;
  v26 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v26;
  v142 = 8;
  if ( v26 )
    v27 = sub_403C70(v26, (int)this, aGoalBm2, 9, 2, 50, *(_BYTE *)(this[302] + 8241));
  else
    v27 = 0;
  v142 = -1;
  this[2563] = v27;
  v28 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  i = (unsigned int)v28;
  v142 = 9;
  if ( v28 )
    v29 = sub_403C70(v28, (int)this, aWallBm2, 10, 2, 100, *(_BYTE *)(this[302] + 8214));
  else
    v29 = 0;
  this[2585] = v29;
  v30 = this[302];
  v142 = -1;
  if ( *(_BYTE *)(v30 + 8050) )
  {
    v31 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    i = (unsigned int)v31;
    v142 = 10;
    if ( v31 )
      v32 = sub_403C70(v31, (int)this, aTrailBm2, 10, 5, 1, *(_BYTE *)(this[302] + 8213));
    else
      v32 = 0;
    v142 = -1;
    this[2870] = v32;
  }
  v33 = (_BYTE *)this[302];
  v34 = 0;
  v35 = &off_4A9CF8;
  v36 = v33[8212];
  LOBYTE(v136) = v33[8216];
  v37 = v33[8225];
  BYTE1(v136) = v36;
  v38 = v33[8211];
  BYTE2(v136) = v37;
  HIBYTE(v136) = v38;
  i = (unsigned int)(this + 2858);
  do
  {
    v39 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v39;
    v142 = 11;
    if ( v39 )
      v40 = sub_403F00(v39, (int)this, (int)v35, *((_BYTE *)&v136 + v34), 0);
    else
      v40 = 0;
    v41 = i;
    v35 += 8;
    ++v34;
    v142 = -1;
    *(_DWORD *)i = v40;
    i = v41 + 4;
  }
  while ( v35 < &off_4A9D78 );
  v42 = &off_4A9F18;
  v43 = this + 2842;
  do
  {
    v44 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v44;
    v142 = 12;
    if ( v44 )
      v45 = sub_403F00(v44, (int)this, (int)v42, *(_BYTE *)(this[302] + 8215), (int)(v42 + 8));
    else
      v45 = 0;
    *v43 = v45;
    v42 += 16;
    ++v43;
    v142 = -1;
  }
  while ( v42 < &off_4AA118 );
  v46 = this + 753;
  v47 = 128;
  do
  {
    v48 = (_DWORD *)sub_40B720((int)&savedregs, 0x2Cu);
    v141 = v48;
    v142 = 13;
    if ( v48 )
      v49 = sub_405030(v48, (int)this, 20 * this[18806], this[18807], *(_BYTE *)(this[302] + 8231));
    else
      v49 = 0;
    *v46 = v49;
    v46 += 14;
    --v47;
    v142 = -1;
  }
  while ( v47 );
  if ( *(_BYTE *)(this[302] + 8049) )
  {
    v50 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v50;
    v142 = 14;
    if ( v50 )
      v51 = sub_403C70(v50, (int)this, aExhaustBm2, 19, 2, 1, *(_BYTE *)(this[302] + 8235));
    else
      v51 = 0;
    v142 = -1;
    this[2872] = v51;
    v52 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v52;
    v142 = 15;
    if ( v52 )
    {
      v53 = sub_403C70(v52, (int)this, aRocketBm2, 13, 2, 1, *(_BYTE *)(this[302] + 8242));
      v142 = -1;
      this[2871] = v53;
    }
    else
    {
      v142 = -1;
      this[2871] = 0;
    }
  }
  v54 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v54;
  v142 = 16;
  if ( v54 )
    v55 = sub_403C70(v54, (int)this, aWarppntBm2, 10, 1, 100, *(_BYTE *)(this[302] + 8229));
  else
    v55 = 0;
  v142 = -1;
  this[2873] = v55;
  v56 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v56;
  v142 = 17;
  if ( v56 )
    v57 = sub_403C70(v56, (int)this, aSparkBm2, 10, 1, 30, *(_BYTE *)(this[302] + 8243));
  else
    v57 = 0;
  v142 = -1;
  this[2874] = v57;
  v58 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v58;
  v142 = 18;
  if ( v58 )
    v59 = sub_403C70(v58, (int)this, aDamageBm2, 20, 2, 52, *(_BYTE *)(this[302] + 8226));
  else
    v59 = 0;
  v142 = -1;
  this[2875] = v59;
  v60 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v60;
  v142 = 19;
  if ( v60 )
    v61 = sub_403C70(v60, (int)this, aKingBm2, 10, 1, 100, *(_BYTE *)(this[302] + 8227));
  else
    v61 = 0;
  v142 = -1;
  this[2880] = v61;
  v62 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v62;
  v142 = 20;
  if ( v62 )
    v63 = sub_403C70(v62, (int)this, aTurretBm2, 8, 5, 1, *(_BYTE *)(this[302] + 8217));
  else
    v63 = 0;
  v142 = -1;
  this[2876] = v63;
  v64 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v64;
  v142 = 21;
  if ( v64 )
    v65 = sub_403C70(v64, (int)this, aTurret2Bm2, 20, 2, 1, *(_BYTE *)(this[302] + 8217));
  else
    v65 = 0;
  v142 = -1;
  this[2877] = v65;
  v66 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v66;
  v142 = 22;
  if ( v66 )
    v67 = sub_403C70(v66, (int)this, aPowerbBm2, 10, 3, 50, *(_BYTE *)(this[302] + 8224));
  else
    v67 = 0;
  this[2878] = v67;
  v68 = (_BYTE *)this[302];
  v142 = -1;
  v69 = 0;
  v70 = v68[8238];
  LOBYTE(v136) = v68[8237];
  v71 = v68[8218];
  BYTE1(v136) = v70;
  v72 = v68[8236];
  BYTE2(v136) = v71;
  v73 = v68[8240];
  HIBYTE(v136) = v72;
  v74 = v68[8222];
  LOBYTE(v68) = v68[8219];
  v137 = v73;
  v138 = v74;
  v139 = (char)v68;
  v75 = &off_4A9C18;
  i = (unsigned int)(this + 2851);
  do
  {
    v76 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v76;
    v142 = 23;
    if ( v76 )
      v77 = sub_403F00(v76, (int)this, (int)v75, *((_BYTE *)&v136 + v69), 0);
    else
      v77 = 0;
    v78 = i;
    v75 += 8;
    ++v69;
    v142 = -1;
    *(_DWORD *)i = v77;
    i = v78 + 4;
  }
  while ( v75 < &off_4A9CF8 );
  if ( *(_BYTE *)(this[302] + 8046) )
  {
    v79 = &off_4A9E18;
    v80 = this + 2862;
    do
    {
      v81 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
      v141 = v81;
      v142 = 24;
      if ( v81 )
        v82 = sub_403F00(v81, (int)this, (int)v79, *(_BYTE *)(this[302] + 8245), 0);
      else
        v82 = 0;
      *v80 = v82;
      v79 += 8;
      ++v80;
      v142 = -1;
    }
    while ( v79 < &off_4A9F18 );
  }
  if ( *(_BYTE *)(this[302] + 8047) )
  {
    v83 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v83;
    v142 = 25;
    if ( v83 )
    {
      v84 = this[302];
      this[4969] = 0;
      v85 = sub_403F00(v83, (int)this, (int)&off_4AA118, *(_BYTE *)(v84 + 8246), 0);
    }
    else
    {
      v85 = 0;
    }
    this[2850] = v85;
    v142 = -1;
  }
  v86 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v86;
  v142 = 26;
  if ( v86 )
    v87 = sub_403C70(v86, (int)this, aSsshieldBm2, 10, 1, 70, *(_BYTE *)(this[302] + 8228));
  else
    v87 = 0;
  v142 = -1;
  this[2879] = v87;
  v88 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v88;
  v142 = 27;
  if ( v88 )
    v89 = sub_403C70(v88, (int)this, aIconsBm2, 9, 6, 1, *(_BYTE *)(this[302] + 8234));
  else
    v89 = 0;
  v142 = -1;
  this[2881] = v89;
  v90 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v90;
  v142 = 28;
  if ( v90 )
    v91 = sub_403C70(v90, (int)this, aIcondoorBm2, 12, 2, 1, *(_BYTE *)(this[302] + 8249));
  else
    v91 = 0;
  v142 = -1;
  this[2882] = v91;
  v92 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v92;
  v142 = 29;
  if ( v92 )
    v93 = sub_403C70(v92, (int)this, aDispBm2, 1, 1, 1, *(_BYTE *)(this[302] + 8248));
  else
    v93 = 0;
  v142 = -1;
  this[2883] = v93;
  v94 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v94;
  v142 = 30;
  if ( v94 )
    v95 = sub_403C70(v94, (int)this, aEngyfontBm2, 10, 1, 1, *(_BYTE *)(this[302] + 8250));
  else
    v95 = 0;
  v142 = -1;
  this[2884] = v95;
  v96 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v96;
  v142 = 31;
  if ( v96 )
    v97 = sub_403C70(v96, (int)this, aHlthbarBm2, 2, 1, 1, *(_BYTE *)(this[302] + 8223));
  else
    v97 = 0;
  v142 = -1;
  this[2885] = v97;
  v98 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v98;
  v142 = 32;
  if ( v98 )
    v99 = sub_403C70(v98, (int)this, aLedBm2, 10, 1, 1, *(_BYTE *)(this[302] + 8251));
  else
    v99 = 0;
  this[2886] = v99;
  v100 = (_BYTE *)this[302];
  v142 = -1;
  v101 = 0;
  v102 = v100[8254];
  LOBYTE(v136) = v100[8253];
  v103 = v100[8255];
  BYTE1(v136) = v102;
  v104 = v100[8229];
  LOBYTE(v100) = v100[8256];
  BYTE2(v136) = v103;
  HIBYTE(v136) = v104;
  v137 = (char)v100;
  v105 = &off_4A9D78;
  i = (unsigned int)(this + 2887);
  do
  {
    v106 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
    v141 = v106;
    v142 = 33;
    if ( v106 )
      v107 = sub_403F00(v106, (int)this, (int)v105, *((_BYTE *)&v136 + v101), 0);
    else
      v107 = 0;
    v108 = i;
    v105 += 8;
    ++v101;
    v142 = -1;
    *(_DWORD *)i = v107;
    i = v108 + 4;
  }
  while ( v105 < &off_4A9E18 );
  v109 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v109;
  v142 = 34;
  if ( v109 )
    v110 = sub_403C70(v109, (int)this, aRadarvBm2, 1, 1, 1, *(_BYTE *)(this[302] + 8239));
  else
    v110 = 0;
  v142 = -1;
  this[2892] = v110;
  v111 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v111;
  v142 = 35;
  if ( v111 )
    v112 = sub_403C70(v111, (int)this, aRadarhBm2, 1, 1, 1, *(_BYTE *)(this[302] + 8239));
  else
    v112 = 0;
  v142 = -1;
  this[2893] = v112;
  v113 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v113;
  v142 = 36;
  if ( v113 )
    v114 = sub_403C70(v113, (int)this, aSpectateBm2, 11, 1, 1, *(_BYTE *)(this[302] + 8252));
  else
    v114 = 0;
  v142 = -1;
  this[2894] = v114;
  v115 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v115;
  v142 = 37;
  if ( v115 )
    v116 = sub_403C70(v115, (int)this, aGradientBm2, 1, 1, 1, 1);
  else
    v116 = 0;
  v142 = -1;
  this[2895] = v116;
  v117 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
  v141 = v117;
  v142 = 38;
  if ( v117 )
    v118 = sub_403C70(v117, (int)this, aColorsBm2, 1, 1, 1, 1);
  else
    v118 = 0;
  this[2896] = v118;
  v119 = this[302];
  v142 = -1;
  if ( *(_BYTE *)(v119 + 8043) )
  {
    v120 = &off_4A9978;
    v121 = this + 2564;
    do
    {
      v122 = (_DWORD *)sub_40B720((int)&savedregs, 0x284u);
      v141 = v122;
      v142 = 39;
      if ( v122 )
        v123 = sub_403F00(v122, (int)this, (int)v120, *(_BYTE *)(this[302] + 8244), 0);
      else
        v123 = 0;
      *v121 = v123;
      v120 += 8;
      ++v121;
      v142 = -1;
    }
    while ( v120 < &off_4A9C18 );
  }
  (*(void (__thiscall **)(_DWORD *, int))(*this + 248))(this, 1);
  (*(void (__thiscall **)(_DWORD *))(*this + 108))(this);
  (*(void (__thiscall **)(_DWORD *))(*this + 88))(this);
  v136 = 0;
  v124 = 0;
  v125 = (unsigned int *)v134;
  v126 = this + 13076;
  do
  {
    if ( this[4] == 1 )
    {
      *v126 = v124;
    }
    else
    {
      i = *v125;
      *v126 = sub_405A90(this[2555], i & 0xFF00 | ((unsigned __int8)i << 16) | BYTE2(i));
      v124 = v136;
    }
    ++v124;
    ++v125;
    ++v126;
    v136 = v124;
  }
  while ( v124 < 256 );
  v127 = this[2];
  v128 = this[3];
  this[18812] = v127;
  *((_BYTE *)this + 10180) = 1;
  *((_BYTE *)this + 10181) = 0;
  this[18810] = v127 / 2;
  this[18813] = v128;
  this[18811] = v128 / 2;
  v129 = &unk_4AA218;
  for ( i = 0; i < 0x28; ++i )
  {
    if ( *((_BYTE *)v129 + 12) )
    {
      v130 = v129[2];
      v131 = (char *)this + *v129;
      for ( j = 0; j < v130; v131 += 4 )
      {
        if ( *(_DWORD *)v131 )
        {
          if ( !*(_BYTE *)(*(_DWORD *)v131 + 640) )
          {
            i = 9282285;
            sub_4073D0((int)pExceptionObject, (char *)(9282285 - ((_DWORD)&loc_42C104 + 5)), *(_DWORD *)v131 + 44);
            _CxxThrowException(pExceptionObject, &_TI2_AVtext_exception__);
          }
        }
        ++j;
      }
    }
    v129 += 4;
    result = i + 1;
  }
  return result;
}
// 40F988: using guessed type int __stdcall nullsub_4(int);
// 40FA88: using guessed type int dword_40FA88[21];
// 4A95D8: using guessed type char *off_4A95D8;
// 4A9678: using guessed type char *off_4A9678;
// 4A9698: using guessed type char *off_4A9698;
// 4A9978: using guessed type char *off_4A9978;
// 4A9C18: using guessed type char *off_4A9C18;
// 4A9CF8: using guessed type char *off_4A9CF8;
// 4A9D78: using guessed type char *off_4A9D78;
// 4A9E18: using guessed type char *off_4A9E18;
// 4A9F18: using guessed type char *off_4A9F18;
// 4AA118: using guessed type char *off_4AA118;

//----- (0044D8A0) --------------------------------------------------------
int __thiscall sub_44D8A0(char *this, __int16 a2, __int16 a3)
{
  int v3; // eax
  _DWORD *v4; // ebx
  char v6; // [esp+4h] [ebp-8h] BYREF
  __int16 v7; // [esp+5h] [ebp-7h]
  __int16 v8; // [esp+7h] [ebp-5h]

  v6 = 5;
  v7 = a2;
  v8 = a3;
  v3 = 0;
  v4 = (_DWORD *)(&loc_40F9D9 + 3);
  do
    v3 -= *v4++;
  while ( v4 < (_DWORD *)((char *)&loc_40FB36 + 2) );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v3 + 1381982361] + 16))(
           &this[v3 + 1381982361],
           &v6,
           5,
           1);
}

//----- (0044D900) --------------------------------------------------------
int __thiscall sub_44D900(int *this, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // esi
  int result; // eax
  int v7; // edi
  int v8; // ebp
  int v9; // eax
  int v10; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // edx

  v4 = this[4966];
  v5 = v4 * a2 / 0x4000;
  result = v4 * a3 / 0x4000;
  if ( v5 >= this[4958]
    && v5 < this[4960]
    && result >= this[4959]
    && result < this[4961]
    && this[40 * (this[2548] & 0x7F) + 13709 + a4] )
  {
    v7 = v5 - this[4958] + this[4962];
    v8 = result - this[4959] + this[4963];
    v9 = v7;
    v10 = v8 + 2;
    v11 = v7 + 2;
    if ( a4 == 7 || a4 == 4 || a4 == 8 )
    {
      v9 = v7 - 1;
      --v8;
    }
    else if ( a4 == 2 )
    {
      v12 = (this[2548] / 16) & 3;
      v13 = 8 * v12 + 4895232;
      v14 = dword_4AB200[2 * v12];
      v15 = *(_DWORD *)(v13 + 4);
      v11 = v14 + v7 + 1;
      v10 = v15 + v8 + 1;
      v9 = v7 + v14;
      v8 += v15;
    }
    result = sub_405680(this[300], v9, v8, v11, v10, this[40 * (this[2548] & 0x7F) + 13709 + a4]);
  }
  return result;
}
// 4AB200: using guessed type int dword_4AB200[];

//----- (0044DA30) --------------------------------------------------------
int __stdcall sub_44DA30(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 75256) = a2;
  *(_DWORD *)(a1 + 75260) = a3;
  return result;
}

//----- (0044DA70) --------------------------------------------------------
_DWORD *__thiscall sub_44DA70(_DWORD *this)
{
  _DWORD *result; // eax

  result = (_DWORD *)this[7];
  if ( result != (_DWORD *)-1 )
  {
    result = *(_DWORD **)(this[3] + 4 * (_DWORD)result + 113620);
    if ( result )
    {
      if ( !result[19] && (int)result[1] > 0 && (int)result[2] > 0 )
      {
        this[1] = result[1];
        this[2] = result[2];
        this[4] = result[96];
        result = (_DWORD *)result[97];
        this[5] = result;
      }
    }
  }
  return result;
}

//----- (0044DAC0) --------------------------------------------------------
int __stdcall sub_44DAC0(int a1)
{
  int v1; // ebp
  int v2; // edx
  int v3; // ebx
  int (__fastcall *v4)(int, unsigned int, unsigned int *, unsigned int); // eax
  int v5; // ecx
  int v6; // esi
  int v7; // esi
  _DWORD *v8; // ecx
  unsigned int v9; // eax
  unsigned __int8 *v10; // esi
  char *v11; // eax
  int v12; // edi
  unsigned int i; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // edi
  _DWORD *v17; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // edi
  int v21; // esi
  int v22; // ecx
  int v23; // ecx
  int v24; // edx
  int v25; // edi
  int v26; // esi
  int v27; // ecx
  int v28; // edi
  int v29; // edx
  int v30; // esi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // esi
  int v35; // edx
  int v36; // edi
  int v37; // ecx
  int v38; // esi
  int v39; // ebp
  int v40; // esi
  int v41; // edx
  int v42; // edi
  int v43; // ecx
  int v44; // esi
  int v45; // edx
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // edx
  int v50; // ecx
  int v51; // edx
  int v52; // esi
  int v53; // edi
  int v54; // ebp
  int v55; // edx
  int v56; // esi
  int v57; // ecx
  int v58; // edi
  int v59; // ebp
  int v60; // edx
  int v61; // ecx
  int v62; // esi
  int v63; // edi
  int v64; // edx
  int v65; // ecx
  int v66; // esi
  int v67; // edi
  int v68; // edx
  int v69; // ecx
  int v70; // edx
  int v71; // edi
  int v72; // esi
  int v73; // ecx
  int v74; // edx
  int v75; // edi
  int v76; // esi
  int v77; // ecx
  int v78; // edx
  int v79; // edi
  int v80; // esi
  int v81; // ecx
  int v82; // edx
  int v83; // edi
  int v84; // edi
  int v85; // ecx
  int v86; // esi
  bool v87; // zf
  int v88; // edi
  unsigned int v89; // eax
  _DWORD *v90; // eax
  int v91; // ecx
  int v92; // edx
  int v93; // esi
  int v94; // ecx
  int v95; // edx
  int v96; // ecx
  int v97; // esi
  int v98; // edi
  int v99; // edx
  int v100; // ecx
  int v101; // esi
  int v102; // edi
  int v103; // edx
  int v104; // ecx
  int v105; // esi
  int v106; // ecx
  int v107; // edx
  int v108; // ecx
  int v109; // esi
  int v110; // edi
  int v111; // edx
  int v112; // ecx
  int v113; // esi
  int v114; // edi
  int v115; // edx
  int v116; // ecx
  int v117; // edi
  int v118; // edx
  int v119; // ecx
  int v120; // esi
  int v121; // ebp
  int v122; // esi
  int v123; // edi
  int v124; // edx
  int v125; // ecx
  int v126; // esi
  int v127; // edi
  int v128; // ebp
  int v129; // ecx
  int v130; // edx
  int v131; // ecx
  int v132; // edx
  int v133; // ebp
  int v134; // esi
  int v135; // ecx
  int v136; // edx
  int v137; // esi
  int v138; // edi
  int v139; // ecx
  int v140; // edx
  int v141; // esi
  int v142; // edi
  int v143; // ecx
  int v144; // edx
  int v145; // esi
  int v146; // edi
  int v147; // ecx
  int v148; // edx
  int v149; // esi
  int v150; // edi
  int v151; // ebp
  int v152; // ecx
  int v153; // esi
  int v154; // edi
  int v155; // ecx
  int v156; // edi
  int v157; // edi
  int v158; // esi
  int v160; // [esp+10h] [ebp-1B0h]
  int v161; // [esp+10h] [ebp-1B0h]
  int v162; // [esp+10h] [ebp-1B0h]
  int v163; // [esp+10h] [ebp-1B0h]
  int v164; // [esp+10h] [ebp-1B0h]
  int v165; // [esp+10h] [ebp-1B0h]
  int v166; // [esp+10h] [ebp-1B0h]
  int v167; // [esp+14h] [ebp-1ACh]
  int v168; // [esp+14h] [ebp-1ACh]
  int v169; // [esp+14h] [ebp-1ACh]
  int v170; // [esp+14h] [ebp-1ACh]
  int v171; // [esp+14h] [ebp-1ACh]
  int v172; // [esp+14h] [ebp-1ACh]
  int v173; // [esp+14h] [ebp-1ACh]
  int v174; // [esp+14h] [ebp-1ACh]
  int v175; // [esp+14h] [ebp-1ACh]
  int v176; // [esp+14h] [ebp-1ACh]
  int v177; // [esp+14h] [ebp-1ACh]
  int v178; // [esp+18h] [ebp-1A8h]
  int v179; // [esp+18h] [ebp-1A8h]
  int v180; // [esp+18h] [ebp-1A8h]
  int v181; // [esp+18h] [ebp-1A8h]
  int v182; // [esp+1Ch] [ebp-1A4h]
  int (__fastcall *v183)(int, unsigned int, unsigned int *, unsigned int); // [esp+20h] [ebp-1A0h]
  unsigned int v184; // [esp+20h] [ebp-1A0h]
  int v185; // [esp+24h] [ebp-19Ch]
  int v186; // [esp+24h] [ebp-19Ch]
  int v187; // [esp+2Ch] [ebp-194h]
  int v188; // [esp+34h] [ebp-18Ch]
  int v189; // [esp+38h] [ebp-188h]
  int v190; // [esp+3Ch] [ebp-184h]
  int v191[16]; // [esp+40h] [ebp-180h] BYREF
  char v192[64]; // [esp+80h] [ebp-140h] BYREF
  char v193[64]; // [esp+C0h] [ebp-100h] BYREF
  char v194[64]; // [esp+100h] [ebp-C0h] BYREF
  char v195[64]; // [esp+140h] [ebp-80h] BYREF
  char v196[64]; // [esp+180h] [ebp-40h] BYREF

  v1 = -1732587289;
  v2 = 288508015;
  v187 = 1731542808;
  v3 = -271730848;
  v188 = -1732587289;
  v189 = 288508015;
  v4 = sub_401000;
  v183 = sub_401000;
  v5 = 69069 * a1 + 17009;
  v6 = v5;
  v190 = v5;
  v182 = v5;
  do
  {
    if ( ((unsigned __int16)v4 & 0x7FF) == 0 )
    {
      if ( ((unsigned __int16)v4 & 0x3FFF) == 0 )
      {
        if ( (char *)v4 == (char *)&loc_408000 )
        {
          v7 = 0;
          v8 = v4;
          do
          {
            v9 = *v8++ >> 17;
            v192[++v7 + 63] = v9 % 0xEE;
          }
          while ( (unsigned int)v8 < 0x4080FC );
          v10 = (unsigned __int8 *)&unk_4AB220;
          v11 = v195;
          v160 = 16;
          do
          {
            v12 = 0;
            for ( i = 0; i < 0x20; i += 8 )
            {
              v14 = *v10 << i;
              v12 |= v14;
              ++v10;
            }
            *(_DWORD *)v11 = v12;
            v11 += 4;
            --v160;
          }
          while ( v160 );
          qmemcpy(v192, v195, sizeof(v192));
          memset(v191, 0, sizeof(v191));
          v191[0] = 3;
          sub_4557C0((int)v192, v193, (int)v194, 1, v191);
          v15 = 37;
          qmemcpy(v196, v194, sizeof(v196));
          do
          {
            v16 = (v15 * (unsigned __int8)v195[v15 + 27]) ^ v182;
            ++v15;
            v182 = v16;
          }
          while ( (unsigned int)(v15 - 37) < 0x40 );
          v2 = v189;
          v4 = v183;
        }
        v17 = (_DWORD *)((char *)v4 + 56);
        v185 = 2;
        while ( 1 )
        {
          v18 = v3 + __ROL4__(*(v17 - 14) + (v1 & v3 | v2 & ~v3) + v187 - 680900511, 7);
          v19 = v18 + __ROL4__(v2 + (v3 & v18 | v1 & ~v18) + *(v17 - 13) - 395859121, 12);
          v20 = __ROL4__(*(v17 - 12) + (v18 & v19 | v3 & ~v19) + v1 + 606105538, 17);
          v21 = v19 + v20 + __ROL4__(*(v17 - 11) + ((v19 + v20) & v19 | v18 & ~(v19 + v20)) + v3 - 1047715081, 22);
          v22 = __ROL4__(v18 + *(v17 - 10) + (v21 & (v19 + v20) | v19 & ~v21) - 177007434, 7);
          v167 = v21 + v22;
          v23 = v21
              + v22
              + __ROL4__(v19 + ((v21 + v22) & v21 | (v19 + v20) & ~(v21 + v22)) + *(v17 - 9) + 1200085555, 12);
          v24 = v23 + __ROL4__(*(v17 - 8) + v19 + v20 + (v167 & v23 | v21 & ~v23) - 1472701942, 17);
          v25 = __ROL4__(*(v17 - 7) + v21 + (v24 & v23 | v167 & ~v24) - 45709032, 22);
          v161 = v24 + v25;
          v26 = v24 + v25 + __ROL4__(*(v17 - 6) + (v161 & v24 | v23 & ~v161) + v167 + 1753253057, 7);
          v27 = v26 + __ROL4__(*(v17 - 5) + v23 + (v26 & (v24 + v25) | v24 & ~v26) - 1958417482, 12);
          v28 = __ROL4__(v24 + (v26 & v27 | (v24 + v25) & ~v27) + *(v17 - 4) - 7387224, 17);
          v178 = v27 + v28;
          v29 = v27 + v28 + __ROL4__(*(v17 - 3) + v161 + (v178 & v27 | v26 & ~v178) - 1987261529, 22);
          v30 = __ROL4__(v26 + *(v17 - 2) + (v29 & (v27 + v28) | v27 & ~v29) + 1804600379, 7);
          v168 = v29 + v30;
          v31 = v27 + ((v29 + v30) & v29 | (v27 + v28) & ~(v29 + v30)) + *(v17 - 1) - 40342134;
          v32 = v29 + v30;
          v33 = v29 + v30 + __ROL4__(v31, 12);
          v34 = v33 + __ROL4__(*v17 + ((v29 + v30) & v33 | v29 & ~v33) + v178 - 1501995113, 17);
          v35 = v34 + __ROL4__(v17[1] + v29 + (v34 & v33 | v32 & ~v34) + 1232344120, 22);
          v36 = __ROL4__(*(v17 - 13) + (v35 & v33 | v34 & ~v33) + v168 - 166643333, 5);
          v169 = v35 + v36;
          v37 = v35 + v36 + __ROL4__(v33 + ((v35 + v36) & v34 | v35 & ~v34) + *(v17 - 8) - 985616551, 9);
          v38 = __ROL4__(*(v17 - 3) + v34 + (v35 & v37 | (v35 + v36) & ~v35) + 643716680, 14);
          v39 = v169 & (v37 + v38) | v37 & ~v169;
          v40 = v37 + v38;
          v41 = v40 + __ROL4__(*(v17 - 14) + v35 + v39 - 374023245, 20);
          v42 = __ROL4__(*(v17 - 9) + (v41 & v37 | v40 & ~v37) + v169 - 702084028, 5);
          v43 = v41 + v42 + __ROL4__(v37 + ((v41 + v42) & v40 | v41 & ~v40) + *(v17 - 4) + 39061578, 9);
          v44 = v43 + __ROL4__(v17[1] + v40 + (v41 & v43 | (v41 + v42) & ~v41) - 660518248, 14);
          v162 = v44 + __ROL4__(v41 + ((v41 + v42) & v44 | v43 & ~(v41 + v42)) + *(v17 - 10) - 405542959, 20);
          v45 = v162 + __ROL4__(*(v17 - 5) + (v162 & v43 | v44 & ~v43) + v41 + v42 + 568644095, 5);
          v46 = v45 + __ROL4__(v43 + *v17 + (v45 & v44 | v162 & ~v44) - 1019798577, 9);
          v47 = __ROL4__(v44 + (v162 & v46 | v45 & ~v162) + *(v17 - 11) - 187359330, 14);
          v48 = v46 + v47 + __ROL4__(*(v17 - 6) + v162 + (v45 & (v46 + v47) | v46 & ~v45) + 1163528436, 20);
          v170 = v48 + __ROL4__(v45 + *(v17 - 1) + (v48 & v46 | (v46 + v47) & ~v46) - 1456212708, 5);
          v49 = v46 + v47;
          v50 = v170 + __ROL4__(v46 + (v170 & (v46 + v47) | v48 & ~(v46 + v47)) + *(v17 - 12) - 51396639, 9);
          v51 = v50 + __ROL4__(*(v17 - 7) + v49 + (v48 & v50 | v170 & ~v48) + 1735335360, 14);
          v52 = v51 + __ROL4__(v48 + (v170 & v51 | v50 & ~v170) + *(v17 - 2) - 1926672237, 20);
          v53 = v52 + __ROL4__(*(v17 - 9) + (v52 ^ v51 ^ v50) + v170 - 235264677, 4);
          v54 = v53 + __ROL4__(*(v17 - 6) + v50 + (v53 ^ v52 ^ v51) - 2022577512, 11);
          v55 = v54 + __ROL4__(v51 + (v53 ^ v52 ^ v54) + *(v17 - 3) + 1832746299, 16);
          v56 = v55 + __ROL4__(*v17 + (v53 ^ v55 ^ v54) + v52 - 35314667, 23);
          v57 = v56 + __ROL4__(*(v17 - 13) + (v56 ^ v55 ^ v54) + v53 - 1531021731, 4);
          v58 = v57 + __ROL4__(*(v17 - 10) + v54 + (v57 ^ v56 ^ v55) + 1272897456, 11);
          v59 = v58 + __ROL4__(*(v17 - 7) + v55 + (v57 ^ v56 ^ v58) - 155691143, 16);
          v60 = v59 + __ROL4__(v56 + (v57 ^ v59 ^ v58) + *(v17 - 4) - 1094737815, 23);
          v61 = v60 + __ROL4__(*(v17 - 1) + (v60 ^ v59 ^ v58) + v57 + 680747743, 4);
          v62 = v61 + __ROL4__(v58 + (v61 ^ v60 ^ v59) + *(v17 - 14) - 358532125, 11);
          v63 = v62 + __ROL4__(*(v17 - 11) + v59 + (v61 ^ v60 ^ v62) - 722494308, 16);
          v64 = v63 + __ROL4__(*(v17 - 8) + v60 + (v61 ^ v63 ^ v62) + 76022044, 23);
          v65 = v64 + __ROL4__(v61 + *(v17 - 5) + (v64 ^ v63 ^ v62) - 640364768, 4);
          v66 = v65 + __ROL4__(*(v17 - 2) + v62 + (v65 ^ v64 ^ v63) - 429160964, 11);
          v67 = v66 + __ROL4__(v17[1] + v63 + (v65 ^ v64 ^ v66) + 530735329, 16);
          v68 = __ROL4__(*(v17 - 12) + v64 + (v65 ^ v67 ^ v66) - 995349892, 23);
          v163 = v67 + v68;
          v69 = v67 + v68 + __ROL4__(*(v17 - 14) + (v67 ^ ((v67 + v68) | ~v66)) + v65 - 197902755, 6);
          v70 = v69 + __ROL4__(*(v17 - 7) + v66 + ((v67 + v68) ^ (v69 | ~v67)) + 1126855566, 10);
          v71 = v70 + __ROL4__(v67 + *v17 + (v69 ^ (v70 | ~v163)) - 1416347714, 15);
          v72 = v71 + __ROL4__(*(v17 - 9) + v163 + (v70 ^ (v71 | ~v69)) - 57295840, 21);
          v73 = v72 + __ROL4__(v69 + *(v17 - 2) + (v71 ^ (v72 | ~v70)) + 1700087258, 6);
          v74 = v73 + __ROL4__(*(v17 - 11) + v70 + (v72 ^ (v73 | ~v71)) - 1894985589, 10);
          v75 = v74 + __ROL4__(*(v17 - 4) + v71 + (v73 ^ (v74 | ~v72)) - 168826780, 15);
          v76 = v75 + __ROL4__(*(v17 - 13) + v72 + (v74 ^ (v75 | ~v73)) - 2054929976, 21);
          v77 = v76 + __ROL4__(v73 + *(v17 - 6) + (v75 ^ (v76 | ~v74)) + 1873109590, 6);
          v78 = v77 + __ROL4__(v17[1] + v74 + (v76 ^ (v77 | ~v75)) - 181601543, 10);
          v79 = v78 + __ROL4__(*(v17 - 8) + v75 + (v77 ^ (v78 | ~v76)) - 1560192755, 15);
          v80 = v79 + __ROL4__(*(v17 - 1) + v76 + (v78 ^ (v79 | ~v77)) + 1309167032, 21);
          v81 = v80 + __ROL4__(v77 + *(v17 - 10) + (v79 ^ (v80 | ~v78)) - 145399141, 6);
          v82 = v81 + __ROL4__(*(v17 - 3) + v78 + (v80 ^ (v81 | ~v79)) + 1161489964, 10);
          v83 = *(v17 - 12) + v79 + (v81 ^ (v82 | ~v80)) + 718773922;
          v17 += 16;
          v84 = v82 + __ROL4__(v83, 15);
          v187 += v81;
          v1 = v84 + v188;
          v85 = v84 + __ROL4__(v80 + (v82 ^ (v84 | ~v81)) + *(v17 - 21) - 346632312, 21);
          v86 = v82 + v189;
          v3 += v85;
          v87 = v185 == 1;
          v188 += v84;
          v189 += v82;
          --v185;
          if ( v87 )
            break;
          v2 = v189;
        }
        v5 = v190;
        v2 = v86;
        v6 = v182;
      }
      v5 = 69069 * v5 + 17009;
      v4 = v183;
      v190 = v5;
      v6 ^= v5 ^ (unsigned int)v183 ^ v1 ^ v189 ^ v3 ^ (v6 - 87634857) ^ (v6 + 3463463);
    }
    v88 = *((_DWORD *)v4 + 1) - *(_DWORD *)v4;
    v4 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v4 + 16);
    v183 = v4;
    v6 ^= (*((_DWORD *)v4 - 2) ^ (v187 + v88)) - *((_DWORD *)v4 - 1);
    v182 = v6;
  }
  while ( (int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v4 < &dword_4A7000 );
  v89 = (unsigned int)dword_4A743C;
  v184 = (unsigned int)dword_4A743C;
  do
  {
    if ( (v89 & 0x7FF) == 0 )
    {
      if ( (v89 & 0x3FFF) == 0 )
      {
        v90 = (_DWORD *)(v89 + 56);
        v186 = 2;
        while ( 1 )
        {
          v91 = v3 + __ROL4__(*(v90 - 14) + (v1 & v3 | v2 & ~v3) + v187 - 680900511, 7);
          v92 = v91 + __ROL4__(*(v90 - 13) + (v3 & v91 | v1 & ~v91) + v2 - 395859121, 12);
          v171 = v92 + __ROL4__(*(v90 - 12) + (v91 & v92 | v3 & ~v92) + v1 + 606105538, 17);
          v93 = v171 + __ROL4__(*(v90 - 11) + (v171 & v92 | v91 & ~v171) + v3 - 1047715081, 22);
          v94 = __ROL4__(*(v90 - 10) + (v93 & v171 | v92 & ~v93) + v91 - 177007434, 7);
          v179 = v93 + v94;
          v95 = v93 + v94 + __ROL4__(*(v90 - 9) + ((v93 + v94) & v93 | v171 & ~(v93 + v94)) + v92 + 1200085555, 12);
          v96 = v95 + __ROL4__(*(v90 - 8) + ((v93 + v94) & v95 | v93 & ~v95) + v171 - 1472701942, 17);
          v97 = __ROL4__(v93 + *(v90 - 7) + (v96 & v95 | v179 & ~v96) - 45709032, 22);
          v164 = v96 + v97;
          v98 = v96 + v97 + __ROL4__(*(v90 - 6) + (v164 & v96 | v95 & ~v164) + v179 + 1753253057, 7);
          v99 = v98 + __ROL4__(v95 + *(v90 - 5) + (v98 & (v96 + v97) | v96 & ~v98) - 1958417482, 12);
          v100 = __ROL4__(*(v90 - 4) + (v98 & v99 | (v96 + v97) & ~v99) + v96 - 7387224, 17);
          v172 = v99 + v100;
          v101 = v99 + v100 + __ROL4__(*(v90 - 3) + (v172 & v99 | v98 & ~v172) + v164 - 1987261529, 22);
          v102 = __ROL4__(v98 + *(v90 - 2) + (v101 & (v99 + v100) | v99 & ~v101) + 1804600379, 7);
          v180 = v101 + v102;
          v103 = v101
               + v102
               + __ROL4__(*(v90 - 1) + ((v101 + v102) & v101 | (v99 + v100) & ~(v101 + v102)) + v99 - 40342134, 12);
          v104 = __ROL4__(v172 + *v90 + (~v103 & v101 | (v101 + v102) & v103) - 1501995113, 17);
          v173 = v103 + v104;
          v105 = v103
               + v104
               + __ROL4__(v101 + v90[1] + (~(v103 + v104) & (v101 + v102) | (v103 + v104) & v103) + 1232344120, 22);
          v106 = __ROL4__(v180 + *(v90 - 13) + (~v103 & (v103 + v104) | v105 & v103) - 166643333, 5);
          v181 = v105 + v106;
          v107 = v105 + v106 + __ROL4__(v103 + *(v90 - 8) + (~v173 & v105 | (v105 + v106) & v173) - 985616551, 9);
          v108 = v107 + __ROL4__(*(v90 - 3) + (v105 & v107 | (v105 + v106) & ~v105) + v173 + 643716680, 14);
          v109 = __ROL4__(*(v90 - 14) + (v181 & v108 | v107 & ~v181) + v105 - 374023245, 20);
          v165 = v108 + v109;
          v110 = v108 + v109 + __ROL4__(*(v90 - 9) + ((v108 + v109) & v107 | v108 & ~v107) + v181 - 702084028, 5);
          v111 = v110 + __ROL4__(v107 + *(v90 - 4) + (v110 & v108 | (v108 + v109) & ~v108) + 39061578, 9);
          v112 = __ROL4__(v90[1] + (v165 & v111 | v110 & ~v165) + v108 - 660518248, 14);
          v174 = v111 + v112;
          v113 = v111 + v112 + __ROL4__(*(v90 - 10) + (v110 & (v111 + v112) | v111 & ~v110) + v165 - 405542959, 20);
          v114 = __ROL4__(v110 + *(v90 - 5) + (v113 & v111 | (v111 + v112) & ~v111) + 568644095, 5);
          v115 = v113 + v114 + __ROL4__(*v90 + ((v113 + v114) & v174 | v113 & ~v174) + v111 - 1019798577, 9);
          v116 = v115 + __ROL4__(v174 + *(v90 - 11) + (v113 & v115 | (v113 + v114) & ~v113) - 187359330, 14);
          v166 = v116 + __ROL4__(*(v90 - 6) + ((v113 + v114) & v116 | v115 & ~(v113 + v114)) + v113 + 1163528436, 20);
          v117 = v166 + __ROL4__(*(v90 - 1) + (v166 & v115 | v116 & ~v115) + v113 + v114 - 1456212708, 5);
          v118 = v117 + __ROL4__(v115 + *(v90 - 12) + (v117 & v116 | v166 & ~v116) - 51396639, 9);
          v119 = v118 + __ROL4__(*(v90 - 7) + (v166 & v118 | v117 & ~v166) + v116 + 1735335360, 14);
          v120 = __ROL4__(*(v90 - 2) + (v117 & v119 | v118 & ~v117) + v166 - 1926672237, 20);
          v121 = *(v90 - 9) + ((v119 + v120) ^ v119 ^ v118);
          v122 = v119 + v120;
          v123 = v122 + __ROL4__(v117 + v121 - 235264677, 4);
          v124 = v123 + __ROL4__(v118 + *(v90 - 6) + (v123 ^ v122 ^ v119) - 2022577512, 11);
          v125 = v124 + __ROL4__(*(v90 - 3) + (v123 ^ v122 ^ v124) + v119 + 1832746299, 16);
          v126 = v125 + __ROL4__(*v90 + (v123 ^ v125 ^ v124) + v122 - 35314667, 23);
          v127 = v126 + __ROL4__(v123 + *(v90 - 13) + (v126 ^ v125 ^ v124) - 1531021731, 4);
          v128 = v127 + __ROL4__(v124 + *(v90 - 10) + (v127 ^ v126 ^ v125) + 1272897456, 11);
          v129 = v128 + __ROL4__(*(v90 - 7) + (v127 ^ v126 ^ v128) + v125 - 155691143, 16);
          v130 = v129 ^ v128;
          v175 = v129;
          v131 = v129 + __ROL4__(*(v90 - 4) + (v127 ^ v129 ^ v128) + v126 - 1094737815, 23);
          v132 = v131 + __ROL4__(*(v90 - 1) + (v131 ^ v130) + v127 + 680747743, 4);
          v133 = v132 + __ROL4__(*(v90 - 14) + (v132 ^ v131 ^ v175) + v128 - 358532125, 11);
          v134 = __ROL4__(*(v90 - 11) + (v132 ^ v131 ^ v133) + v175 - 722494308, 16);
          v176 = v133 + v134;
          v135 = v133 + v134 + __ROL4__(*(v90 - 8) + (v132 ^ (v133 + v134) ^ v133) + v131 + 76022044, 23);
          v136 = v135 + __ROL4__(*(v90 - 5) + (v135 ^ (v133 + v134) ^ v133) + v132 - 640364768, 4);
          v137 = v136 + __ROL4__(*(v90 - 2) + (v136 ^ v135 ^ (v133 + v134)) + v133 - 429160964, 11);
          v138 = __ROL4__(v90[1] + (v136 ^ v135 ^ v137) + v176 + 530735329, 16);
          v177 = v137 + v138;
          v139 = v137 + v138 + __ROL4__(v135 + *(v90 - 12) + (v136 ^ (v137 + v138) ^ v137) - 995349892, 23);
          v140 = v139 + __ROL4__(*(v90 - 14) + ((v137 + v138) ^ (v139 | ~v137)) + v136 - 197902755, 6);
          v141 = v140 + __ROL4__(v137 + *(v90 - 7) + (v139 ^ (v140 | ~(v137 + v138))) + 1126855566, 10);
          v142 = v141 + __ROL4__(v177 + *v90 + (v140 ^ (v141 | ~v139)) - 1416347714, 15);
          v143 = v142 + __ROL4__(v139 + *(v90 - 9) + (v141 ^ (v142 | ~v140)) - 57295840, 21);
          v144 = v143 + __ROL4__(v140 + *(v90 - 2) + (v142 ^ (v143 | ~v141)) + 1700087258, 6);
          v145 = v144 + __ROL4__(v141 + *(v90 - 11) + (v143 ^ (v144 | ~v142)) - 1894985589, 10);
          v146 = v145 + __ROL4__(v142 + *(v90 - 4) + (v144 ^ (v145 | ~v143)) - 168826780, 15);
          v147 = v146 + __ROL4__(v143 + *(v90 - 13) + (v145 ^ (v146 | ~v144)) - 2054929976, 21);
          v90 += 16;
          v148 = v147 + __ROL4__(v144 + *(v90 - 22) + (v146 ^ (v147 | ~v145)) + 1873109590, 6);
          v149 = v148 + __ROL4__(v145 + *(v90 - 15) + (v147 ^ (v148 | ~v146)) - 181601543, 10);
          v150 = v149 + __ROL4__(v146 + *(v90 - 24) + (v148 ^ (v149 | ~v147)) - 1560192755, 15);
          v151 = v150 + __ROL4__(v147 + *(v90 - 17) + (v149 ^ (v150 | ~v148)) + 1309167032, 21);
          v152 = v151 + __ROL4__(*(v90 - 26) + (v150 ^ (v151 | ~v149)) + v148 - 145399141, 6);
          v153 = v152 + __ROL4__(*(v90 - 19) + (v151 ^ (v152 | ~v150)) + v149 + 1161489964, 10);
          v154 = v153 + __ROL4__(*(v90 - 28) + (v152 ^ (v153 | ~v151)) + v150 + 718773922, 15);
          v187 += v152;
          v155 = __ROL4__(*(v90 - 21) + (v153 ^ (v154 | ~v152)) + v151 - 346632312, 21);
          v1 = v154 + v188;
          v3 += v154 + v155;
          v156 = v153 + v189;
          v87 = v186 == 1;
          v188 = v1;
          v189 += v153;
          --v186;
          if ( v87 )
            break;
          v2 = v189;
        }
        v5 = v190;
        v6 = v182;
        v2 = v156;
      }
      v5 = 69069 * v5 + 17009;
      v89 = v184;
      v190 = v5;
      v182 = v5 ^ v6 ^ v184 ^ v1 ^ v189 ^ v3 ^ (v6 + 87634757) ^ (v6 - 3469463);
    }
    v157 = *(_DWORD *)(v89 + 8) + *(_DWORD *)(v89 + 4) - *(_DWORD *)(v89 + 12);
    v158 = v187 - *(_DWORD *)v89;
    v89 += 16;
    v184 = v89;
    v6 = v158 ^ v157 ^ v182;
    v182 = v6;
  }
  while ( v89 < (unsigned int)&off_4B3E90 );
  return v6;
}
// 4A7000: using guessed type int (__stdcall *dword_4A7000)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A743C: using guessed type int dword_4A743C[];
// 4B3E90: using guessed type void *off_4B3E90;

//----- (0044EC40) --------------------------------------------------------
unsigned int __thiscall sub_44EC40(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int result; // eax
  int v4; // edi
  int v6; // eax
  int v7; // edi
  int v8; // eax
  int (__fastcall *v9)(int *, int); // ebx
  int v10; // eax
  int v11; // eax
  bool v12; // zf
  int savedregs; // [esp+18h] [ebp+0h] BYREF
  unsigned int v14; // [esp+24h] [ebp+Ch]

  result = a3;
  v4 = a2;
  if ( a3 >= 0x40 )
  {
    v14 = a3 >> 6;
    do
    {
      if ( *(unsigned __int16 *)(v4 + 51) == this[1876] )
      {
        v6 = sub_40B720((int)&savedregs, 0x378u);
        if ( v6 )
          v7 = sub_416430(v6, (int)this, v4);
        else
          v7 = 0;
        v8 = 0;
        v9 = (int (__fastcall *)(int *, int))(&loc_423E79 + 3);
        do
        {
          v8 -= *(_DWORD *)v9;
          v9 = (int (__fastcall *)(int *, int))((char *)v9 + 4);
        }
        while ( (unsigned int)v9 < (unsigned int)sub_423F90 );
        (*(void (__thiscall **)(int, int))(*(_DWORD *)((char *)this + v8 + 1507067031) + 112))(
          (int)this + v8 + 1507067031,
          v7);
        this[542] = v7;
        v4 = a2;
      }
      else
      {
        v10 = sub_40B720((int)&savedregs, 0x18Cu);
        if ( v10 )
          v11 = sub_416CA0(v10, (int)this, v4);
        else
          v11 = 0;
        (*(void (__thiscall **)(_DWORD *, int))(*this + 112))(this, v11);
      }
      v4 += 64;
      result = v14 - 1;
      v12 = v14 == 1;
      a2 = v4;
      --v14;
    }
    while ( !v12 );
  }
  return result;
}

//----- (0044ED70) --------------------------------------------------------
int __thiscall sub_44ED70(_DWORD *this, _DWORD *a2, int a3, int a4, int a5, int a6)
{
  int result; // eax

  result = a5;
  if ( a5 < this[28] )
  {
    (*(void (__thiscall **)(_DWORD *, int, int, _DWORD))(*a2 + 264))(
      a2,
      a5 + 1024,
      this[26] + 164 * a5,
      *(_DWORD *)(this[26] + 164 * a5 + 160));
    result = (*(int (__thiscall **)(_DWORD *, int, int, int))(*a2 + 260))(a2, a2[18806] + a3 + 1, a4, a5 + 1024);
  }
  return result;
}

//----- (0044FB80) --------------------------------------------------------
#error "44FB8C: call analysis failed (funcsize=7)"

//----- (0044FBA0) --------------------------------------------------------
int __thiscall sub_44FBA0(char *this, __int16 a2, __int16 a3, __int16 a4)
{
  int v5; // eax
  int v6; // ecx
  char v8; // [esp+8h] [ebp-Ch] BYREF
  int v9; // [esp+9h] [ebp-Bh]
  __int16 v10; // [esp+Dh] [ebp-7h]
  __int16 v11; // [esp+Fh] [ebp-5h]
  __int16 v12; // [esp+11h] [ebp-3h]

  v8 = 7;
  v9 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 64))(this);
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v5 = 1271064326;
  v6 = 247;
  do
    v5 ^= *(_DWORD *)&aSouthAfrica[4 * v6-- - 574768];
  while ( v6 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v5 + 329851632] + 16))(
           &this[v5 + 329851632],
           &v8,
           11,
           1);
}

//----- (0044FC30) --------------------------------------------------------
int __thiscall sub_44FC30(void **this)
{
  int v2; // eax
  void (__thiscall **v3)(void **); // edx
  int i; // esi
  int v5; // eax
  int v6; // ebx
  int j; // esi
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // esi
  _DWORD *v11; // ebx
  int *v12; // esi
  int v13; // eax
  unsigned int v14; // ebp
  int v15; // edx
  int v16; // ecx
  unsigned int v17; // eax
  int v18; // ecx
  int v19; // ebp
  int v20; // esi
  int v21; // eax
  int v22; // edx
  bool v23; // cc
  int result; // eax
  int v25; // [esp+1Ch] [ebp-5F4h]
  int v26; // [esp+20h] [ebp-5F0h]
  int v27; // [esp+24h] [ebp-5ECh]
  int v28; // [esp+28h] [ebp-5E8h]
  int v29; // [esp+2Ch] [ebp-5E4h]
  char v30[2]; // [esp+30h] [ebp-5E0h] BYREF
  int v31; // [esp+32h] [ebp-5DEh]
  char v32[474]; // [esp+36h] [ebp-5DAh] BYREF
  char v33[1024]; // [esp+210h] [ebp-400h] BYREF

  v2 = sub_412170();
  v25 = v2;
  if ( this[228] == (void *)1 )
  {
    if ( this[178] == (void *)2 && v2 - (int)this[226] >= 5000 )
    {
      v3 = (void (__thiscall **)(void **))*this;
      this[226] = (void *)v2;
      v3[7](this);
    }
    for ( i = 0; i < 100; ++i )
    {
      v5 = sub_40FB20(this + 1, (int)v33, 1024, this + 4, 0);
      if ( !v5 )
        break;
      (*((void (__thiscall **)(void **, char *, int))*this + 1))(this, v33, v5);
      this[339] = (void *)v25;
    }
    if ( this[178] == (void *)1 && v25 - (int)this[227] >= 800 )
      (*((void (__thiscall **)(void **))*this + 12))(this);
  }
  v6 = 0;
  for ( j = 0; j < (int)this[189]; ++j )
  {
    if ( v6 >= 10 )
      break;
    v8 = this[187];
    v9 = v8[j];
    if ( (unsigned int)(v25 - *(_DWORD *)v9) >= 0x384
      && (unsigned int)(*(_DWORD *)(v9 + 8) - *(_DWORD *)(*v8 + 8)) < 0x10 )
    {
      *(_DWORD *)v9 = v25;
      (*((void (__thiscall **)(void **, _DWORD, int))*this + 5))(this, *(unsigned __int16 *)(v9 + 4), v9 + 6);
      ++v6;
    }
  }
  if ( (int)this[189] < 4 )
  {
    v10 = 0;
    v26 = 0;
    if ( (int)this[183] > 0 )
    {
      v11 = this + 181;
      v27 = 0;
      v28 = 0;
      do
      {
        v12 = (int *)(*v11 + v10);
        v29 = *((_BYTE *)v12 + 12) != 0 ? 4 : 2;
        if ( (int)this[189] < v29 )
        {
          v13 = v12[1];
          while ( 1 )
          {
            v14 = v13 - v12[2];
            if ( v14 > 0x1DA )
              v14 = 474;
            v15 = v12[2];
            v16 = *v12;
            v31 = v13;
            v30[0] = 0;
            v30[1] = 10;
            sub_46CAB0((unsigned int)v32, (_BYTE *)(v16 + v15), v14);
            (*((void (__thiscall **)(void **, char *, unsigned int, int))*this + 4))(this, v30, v14 + 6, 1);
            v17 = v14 + v12[2];
            v12[2] = v17;
            v18 = v17;
            v13 = v12[1];
            if ( v18 >= v13 )
              break;
            if ( (int)this[189] >= v29 )
              goto LABEL_30;
          }
          v19 = v28;
          v20 = v27;
          v28 -= 0xFFFFFFF;
          v27 -= 16;
          --v26;
          sub_4554B0(*v11 + v20, v19);
          sub_46CAB0(*v11 + v20, (_BYTE *)(v20 + *v11 + 16), 16 * ((_DWORD)this[183] + v19 + 0xFFFFFFF));
          v21 = (int)this[183] - 1;
          this[183] = (void *)v21;
          if ( v21 && (int)this[182] - v21 > 32 )
          {
            v22 = (int)this[182] - 16;
            this[182] = (void *)v22;
            sub_40B780(16 * v22, this + 181, v19);
          }
        }
LABEL_30:
        v28 += 0xFFFFFFF;
        v10 = v27 + 16;
        v23 = ++v26 < (int)this[183];
        v27 += 16;
      }
      while ( v23 );
    }
  }
  if ( this[189] && (unsigned int)(v25 - **(_DWORD **)this[187]) > 0x3A98 )
  {
    result = 1;
    *((_BYTE *)this + 1404) = 1;
  }
  else
  {
    result = 0;
    *((_BYTE *)this + 1404) = 0;
  }
  return result;
}

//----- (0044FEF0) --------------------------------------------------------
char __thiscall sub_44FEF0(void *this, char a2)
{
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  char result; // al
  int v9; // edx
  int v10; // edi

  v3 = *((_DWORD *)this + 542);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 604);
    v5 = *((_DWORD *)this + 2774);
    if ( v4 + *(_DWORD *)(v3 + 608) >= v5 )
      v5 = v4 + *(_DWORD *)(v3 + 608);
    v6 = dword_4C1AE4 - v5;
    v7 = v5 - (dword_4C1AE4 - v5);
    dword_4C1AE4 = v6;
    *(_DWORD *)(v3 + 608) = v6;
    *(_DWORD *)(v3 + 604) = v7;
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 84))(this);
  }
  result = a2;
  v9 = *((_DWORD *)this + 5776);
  *((_BYTE *)this + 7652) = a2 == 0;
  *((_DWORD *)this + 1910) = v9;
  if ( a2 )
  {
    result = *((_BYTE *)this + 113524);
    if ( result )
    {
      (*(void (__cdecl **)(int))(*((_DWORD *)this + 5775) + 9142))((int)this + 111912);
      v10 = (*(int (__thiscall **)(int))(*((_DWORD *)this + 27905) + 20))((int)this + 111620);
      result = (*(int (**)(void))(*((_DWORD *)this + 5775) + 9098))();
      if ( v10 >= 0 )
      {
        *((_DWORD *)this + 28089) = v10;
        *((_DWORD *)this + 28118) = v10;
        *((_BYTE *)this + 112452) = 1;
      }
      *((_BYTE *)this + 113524) = 0;
    }
  }
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (0044FFD0) --------------------------------------------------------
int __thiscall sub_44FFD0(char *this, char a2, __int16 a3, __int16 a4)
{
  int v5; // eax
  int v6; // ecx
  char v8[2]; // [esp+4h] [ebp-8h] BYREF
  __int16 v9; // [esp+6h] [ebp-6h]
  __int16 v10; // [esp+8h] [ebp-4h]

  v8[1] = a2;
  v8[0] = 33;
  v9 = a3;
  v10 = a4;
  v5 = 959935163;
  v6 = 227;
  do
    v5 ^= dword_4A73F8[v6-- - 135399];
  while ( v6 );
  return (*(int (__thiscall **)(char *, char *, int, int))(*(_DWORD *)&this[v5 + 345777168] + 16))(
           &this[v5 + 345777168],
           v8,
           6,
           1);
}
// 4A73F8: using guessed type int dword_4A73F8[];

//----- (00450030) --------------------------------------------------------
char __thiscall sub_450030(int this, _DWORD *a2, int a3, int a4, int a5, int a6)
{
  char result; // al

  result = *(_BYTE *)(this + 377);
  if ( result )
  {
    result = a5;
    if ( a5 == *(_DWORD *)(this + 8) )
      result = (*(int (__thiscall **)(_DWORD *, int, int, int))(*a2 + 240))(a2, a2[18806] + a3 + 60 * a2[18806], a4, 1);
  }
  return result;
}

//----- (00450080) --------------------------------------------------------
int __thiscall sub_450080(_DWORD *this, int *a2, unsigned __int8 a3, _DWORD *a4)
{
  int result; // eax
  int v6; // edx
  int v7; // ebx
  int v8; // edi
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  int v13; // edi
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // ebx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  unsigned int v22; // ecx
  int v23; // edx
  int v24; // ebx
  int v25; // edi
  int v26; // eax
  int v27; // ebx
  int v28; // ecx
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // ecx
  unsigned int v33; // ecx
  int v34; // eax
  int v35; // eax
  _DWORD *v36; // ecx
  int v37; // eax
  int v38; // edi
  int v39; // edi
  int v40; // ebx
  int v41; // eax
  int v42; // ecx
  int v43; // eax
  int v44; // ecx
  int v45; // edi
  char v46; // dl
  char v47; // dl
  int v48; // eax
  int v49; // ecx
  int v50; // edi
  char v51; // dl
  char v52; // dl
  int v53; // eax
  _BYTE *v54; // edx
  bool v55; // zf
  int v56; // edi
  int v57; // ebx
  int v58; // ecx
  char *v59; // eax
  int v60; // edx
  int v61; // eax
  _BYTE *v62; // ecx
  char *v63; // edx
  int v64; // ebx
  int v65; // ecx
  char v66; // al
  int v67; // eax
  int v68; // edx
  char Format[64]; // [esp+Ch] [ebp-148h] BYREF
  char v70[64]; // [esp+4Ch] [ebp-108h] BYREF
  char v71[64]; // [esp+8Ch] [ebp-C8h] BYREF
  char Buffer[64]; // [esp+CCh] [ebp-88h] BYREF
  int v73[7]; // [esp+10Ch] [ebp-48h] BYREF
  int v74; // [esp+128h] [ebp-2Ch]
  int v75; // [esp+12Ch] [ebp-28h]
  int v76; // [esp+130h] [ebp-24h]
  int v77; // [esp+134h] [ebp-20h]
  int v78; // [esp+138h] [ebp-1Ch]
  unsigned int i; // [esp+13Ch] [ebp-18h]
  int v80; // [esp+140h] [ebp-14h]
  int v81; // [esp+144h] [ebp-10h]
  int v82; // [esp+150h] [ebp-4h]
  int v83; // [esp+15Ch] [ebp+8h]
  int v84; // [esp+15Ch] [ebp+8h]
  int v85; // [esp+160h] [ebp+Ch]
  int v86; // [esp+160h] [ebp+Ch]
  int v87; // [esp+160h] [ebp+Ch]
  int v88; // [esp+160h] [ebp+Ch]
  char *v89; // [esp+160h] [ebp+Ch]
  int v90; // [esp+164h] [ebp+10h]
  int *v91; // [esp+164h] [ebp+10h]

  result = this[302];
  if ( *(_DWORD *)(result + 7987) == 2 )
    return result;
  v6 = a2[7];
  v7 = a2[16];
  v8 = a2[14];
  v73[0] = a2[8] + a2[9];
  v9 = a2[17];
  v73[1] = a2[6] + v6;
  v10 = v7 + v9;
  v11 = v8 + a2[15];
  v12 = a2[12];
  v13 = a2[18];
  v73[2] = v10;
  v14 = a2[11];
  v73[3] = v11;
  v15 = a2[13];
  v73[4] = a2[10] + v14;
  v16 = v12 + v15;
  v17 = a2[2];
  v18 = v13 + a2[19];
  v73[5] = v16;
  v19 = *a2;
  v73[6] = v18;
  v20 = v19 + a2[1];
  v21 = a2[3];
  v78 = v20;
  v22 = a2[21];
  v23 = v17 + v21;
  v24 = a2[4];
  v75 = v23;
  v81 = (v22 >> 26) & 1;
  v25 = (v22 >> 19) & 1;
  v80 = v24 + a2[5];
  if ( (v22 & 0x8000) == 0 )
    v77 = 0;
  else
    v77 = 2 - a3;
  v26 = this[2881];
  v27 = this[3] / 2 - 48;
  v29 = *(_DWORD *)(v26 + 616) + 1;
  v76 = this[2] - *(_DWORD *)(v26 + 612);
  v28 = v76;
  v83 = v29;
  this[18816] = *(_DWORD *)(v26 + 612);
  this[18817] = v27;
  v30 = *(_DWORD *)(v26 + 612);
  this[18828] = v28;
  this[18818] = v30;
  v31 = this[302];
  this[18829] = v27;
  this[18830] = v28;
  v32 = *(_DWORD *)(v31 + 7987);
  v74 = v27;
  if ( v32 != 1 )
  {
    v33 = 0;
    v85 = v27;
    for ( i = 0; ; v33 = i )
    {
      if ( *(int *)((char *)v73 + v33) <= 0 )
        v34 = 4 - *(_DWORD *)(this[2881] + 612);
      else
        v34 = 0;
      sub_404B80((_DWORD *)this[2881], v34, v85, *(int *)((char *)&dword_4AB260 + v33), 0);
      v35 = v73[i / 4];
      if ( v35 > 1 )
      {
        if ( v35 >= 10 )
          v35 = 10;
        sub_404B80((_DWORD *)this[2882], 24, v85 + 6, v35, 0);
      }
      v85 += v83;
      i += 4;
      if ( i >= 0x1C )
        break;
    }
    v36 = (_DWORD *)this[2881];
    v37 = v36[153] + v76 - 4;
    v86 = v37;
    if ( v78 )
      v37 = v76;
    sub_404B80(v36, v37, v27, v77 + 2 * v25 + v25 + v78 + 2 * (v77 + 2 * v25 + v25) - 1, 0);
    v38 = v76;
    if ( !v75 )
      v38 = v86;
    sub_404B80((_DWORD *)this[2881], v38, v27 + v83, v81 + 2 * (v80 != 0) + v75 + 2 * (v81 + 2 * (v80 != 0)) + 17, 0);
    v39 = 32;
    v40 = v27 + 2 * v83;
    do
    {
      v41 = v76;
      if ( !*a4 )
        v41 = v86;
      sub_404B80((_DWORD *)this[2881], v41, v40, v39 + (*a4 == 1), 0);
      v39 += 2;
      v40 += v83;
      ++a4;
    }
    while ( v39 < 40 );
    v42 = v74;
    result = v83;
    this[18831] = v74 + 6 * v83;
    this[18819] = v42 + 7 * v83;
    return result;
  }
  v84 = this[18807] + 1;
  if ( v78 )
  {
    v43 = BYTE1(dword_4AE3C8) ^ 0x45;
    v44 = BYTE2(dword_4AE3C8) ^ (unsigned __int8)dword_4AE3C8;
    Format[0] = HIBYTE(dword_4AE3C8) ^ BYTE1(dword_4AE3C8) ^ 0x45;
    if ( Format[0] )
    {
      v45 = 0;
      do
      {
        v46 = byte_4AE3CC[v45++];
        v43 ^= v44;
        v47 = v43 ^ v46;
        Format[v45] = v47;
      }
      while ( v47 );
    }
    sprintf_0(Buffer, Format, v78);
    memset(Format, 0, sizeof(Format));
    (*(void (__fastcall **)(_DWORD *, _DWORD, int, int, char *, _DWORD, int, int))(*this + 236))(
      this,
      0,
      1,
      v27,
      Buffer,
      0,
      -1,
      1);
  }
  if ( v75 )
  {
    v48 = BYTE1(dword_4AE3B8) ^ 0x45;
    v49 = BYTE2(dword_4AE3B8) ^ (unsigned __int8)dword_4AE3B8;
    Format[0] = HIBYTE(dword_4AE3B8) ^ BYTE1(dword_4AE3B8) ^ 0x45;
    if ( Format[0] )
    {
      v50 = 0;
      do
      {
        v51 = byte_4AE3BC[v50++];
        v48 ^= v49;
        v52 = v48 ^ v51;
        Format[v50] = v52;
      }
      while ( v52 );
    }
    sprintf_0(Buffer, &Format[v81 == 0], v75, v80);
    memset(Format, 0, sizeof(Format));
    (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*this + 236))(
      this,
      1,
      v27 + v84,
      Buffer,
      0,
      -1,
      1);
  }
  v53 = BYTE1(dword_4AE390) ^ 0x45;
  v87 = BYTE2(dword_4AE390) ^ (unsigned __int8)dword_4AE390;
  v54 = (_BYTE *)(&dword_4AE390 + 3);
  v71[0] = HIBYTE(dword_4AE390) ^ BYTE1(dword_4AE390) ^ 0x45;
  if ( v71[0] )
  {
    do
    {
      ++v54;
      v53 ^= v87;
      v55 = *v54 == (unsigned __int8)v53;
      v71[(_DWORD)v54 - 4907923] = *v54 ^ v53;
    }
    while ( !v55 );
  }
  v82 = 0;
  v56 = v27 + 2 * v84;
  v57 = 0;
  v80 = 0;
  do
  {
    if ( v57 )
    {
      v58 = a4[v57 - 1];
    }
    else
    {
      if ( !v77 )
        goto LABEL_48;
      v58 = v77 ^ 3;
    }
    if ( v58 )
    {
      v55 = v71[7 * v57] == 32;
      v59 = &v71[7 * v57];
      v60 = 7;
      v81 = (int)v59;
      v88 = 7;
      if ( v55 )
      {
        ++v59;
        v60 = 6;
        v81 = (int)v59;
        v88 = 6;
      }
      if ( v58 == 2 )
      {
        sub_405680(this[300], 0, v56, v60 * this[18806] + 1, v56 + this[18807], this[13075]);
        (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD, int, int))(*this + 236))(this, 1, v56, v81, 0, v88, 1);
        v57 = v80;
      }
      else
      {
        (*(void (__thiscall **)(_DWORD *, int, int, char *, int, int, int))(*this + 236))(this, 1, v56, v59, 2, v60, 1);
      }
    }
LABEL_48:
    ++v57;
    v56 += v84;
    v80 = v57;
  }
  while ( v57 < 5 );
  v61 = BYTE1(dword_4AE358) ^ 0x45;
  v90 = BYTE2(dword_4AE358) ^ (unsigned __int8)dword_4AE358;
  v62 = (_BYTE *)(&dword_4AE358 + 3);
  v70[0] = v61 ^ HIBYTE(dword_4AE358);
  if ( (unsigned __int8)v61 != HIBYTE(dword_4AE358) )
  {
    do
    {
      ++v62;
      v61 ^= v90;
      v55 = (unsigned __int8)v61 == *v62;
      v70[(_DWORD)v62 - 4907867] = v61 ^ *v62;
    }
    while ( !v55 );
  }
  v63 = v70;
  LOBYTE(v82) = 1;
  v91 = v73;
  v89 = v70;
  v81 = 7;
  do
  {
    v64 = *v91;
    if ( *v91 )
    {
      v65 = 7;
      if ( *v63 == 32 )
      {
        do
        {
          v66 = *++v63;
          --v65;
        }
        while ( v66 == 32 );
      }
      v80 = 9422432;
      sprintf_0(Buffer, (const char *const)(9422432 - (_DWORD)&loc_44E314), v65, v65, v63, v64);
      (*(void (__thiscall **)(_DWORD *, int, int, char *, _DWORD, int, int))(*this + 236))(
        this,
        1,
        v56,
        Buffer,
        0,
        -1,
        1);
      v63 = v89;
    }
    v63 += 7;
    v56 += v84;
    v55 = v81 == 1;
    v89 = v63;
    ++v91;
    --v81;
  }
  while ( !v55 );
  v67 = this[2];
  v68 = v74;
  this[18819] = v56;
  this[18828] = v67;
  this[18830] = v67;
  result = 0;
  this[18831] = v68;
  memset(v70, 0, sizeof(v70));
  memset(v71, 0, sizeof(v71));
  return result;
}
// 4AB260: using guessed type int dword_4AB260;
// 4AE358: using guessed type int dword_4AE358;
// 4AE390: using guessed type int dword_4AE390;
// 4AE3B8: using guessed type int dword_4AE3B8;
// 4AE3C8: using guessed type int dword_4AE3C8;

//----- (00450700) --------------------------------------------------------
int __thiscall sub_450700(_DWORD *this, int a2)
{
  _DWORD *v2; // edx
  int v3; // ebp
  int *v4; // eax
  int v5; // edi
  int v7; // ecx
  int *v8; // ebx
  int v9; // edi
  int v10; // edx
  int *v11; // eax
  int result; // eax
  int v13; // esi
  int v14; // ebp
  _DWORD *v15; // edi
  __int64 v16; // rax
  int v18; // [esp+14h] [ebp-4h]

  v2 = this;
  v3 = 0;
  v4 = &dword_4A9984;
  do
  {
    v5 = *v4;
    v4 += 8;
    v3 += v5;
  }
  while ( v4 < dword_4A9C24 );
  v18 = v3;
  v7 = 0;
  v8 = v2 + 304;
  do
  {
    a2 = 16807 * (a2 % 127773) - 2836 * (a2 / 127773) + 123;
    if ( a2 <= 0 )
      a2 += 0x7FFFFFFF;
    v9 = 0;
    v10 = a2 % v3 - dword_4A9984;
    if ( v10 >= 0 )
    {
      v11 = &dword_4A9984;
      do
      {
        v11 += 8;
        ++v9;
        v10 -= *v11;
      }
      while ( v10 >= 0 );
    }
    v8[1] = -1;
    result = this[v9 + 2564];
    if ( result )
    {
      v13 = 16807 * (a2 % 127773) - 2836 * (a2 / 127773) + 123;
      if ( v13 <= 0 )
        v13 += 0x7FFFFFFF;
      *(v8 - 1) = v13 % 0x4000;
      result = v13 / 127773;
      a2 = 16807 * (v13 % 127773) - 2836 * (v13 / 127773) + 123;
      if ( a2 <= 0 )
        a2 += 0x7FFFFFFF;
      *v8 = a2 % 0x4000;
      v8[1] = v9;
      if ( v7 > 0 )
      {
        v14 = v7;
        v15 = this + 304;
        do
        {
          v16 = *(v8 - 1) - *(v15 - 1);
          result = (HIDWORD(v16) ^ v16) - HIDWORD(v16);
          if ( result < 256 )
          {
            result = abs32(*v8 - *v15);
            if ( result < 256 )
              v8[1] = -1;
          }
          v15 += 3;
          --v14;
        }
        while ( v14 );
      }
      v3 = v18;
    }
    ++v7;
    v8 += 3;
  }
  while ( (unsigned int)v7 < 0x96 );
  return result;
}
// 4A9984: using guessed type int dword_4A9984;

//----- (004508D0) --------------------------------------------------------
int __thiscall sub_4508D0(int this, int a2, int a3)
{
  int v4; // eax
  _DWORD *i; // ebx
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int result; // eax
  int v13; // eax
  char Buffer[128]; // [esp+Ch] [ebp-84h] BYREF
  int *v15; // [esp+8Ch] [ebp-4h]

  v4 = 0;
  for ( i = (_DWORD *)(&loc_424EB7 + 5); (unsigned int)i < 0x425094; ++i )
    v4 -= *i;
  v6 = *(_DWORD *)(*(_DWORD *)(v4 + 1762412689 + this + 366769348) + 316);
  (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v6 + 20))(v6, 0, 0, 0, 0);
  for ( ; *(int *)(this + 7500) > 0; --*(_DWORD *)(this + 7500) )
  {
    sub_40B7E0(*(_DWORD *)(this + 6284));
    sub_46CAB0(this + 6284, (_BYTE *)(this + 6288), 4 * *(_DWORD *)(this + 7500) - 4);
  }
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(*(_DWORD *)(this + 120076) + 312) + 28))(*(_DWORD *)(*(_DWORD *)(this + 120076) + 312));
  v7 = *(_DWORD *)(this + 6276);
  v8 = 0;
  *(_DWORD *)(this + 120564) = 0;
  if ( v7 > 0 )
  {
    v15 = (int *)(this + 2180);
    do
    {
      v9 = *v15;
      if ( *(_DWORD *)(*v15 + 88) == a2 && *(_DWORD *)(v9 + 92) != 8 && (*(_BYTE *)(v9 + 96) & 0x20) == 0 )
      {
        if ( *(_DWORD *)(this + 23104) - *(_DWORD *)(v9 + 216) > 500 )
          *(_DWORD *)(v9 + 164) += a3;
        (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 56))(v9);
      }
      v10 = dword_4C1AE4;
      *(_DWORD *)(v9 + 52) = dword_4C1AE4;
      *(_DWORD *)(v9 + 48) = -v10;
      v11 = *(_DWORD *)(this + 6276);
      ++v8;
      ++v15;
    }
    while ( v8 < v11 );
  }
  if ( a2 >= 0 )
  {
    v13 = *(_DWORD *)(this + 2168);
    if ( v13 && *(_DWORD *)(v13 + 88) == a2 )
    {
      (*(void (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(this + 111620) + 28))(
        this + 111620,
        aTeamVictory,
        0,
        0,
        0,
        1);
      sprintf_0(Buffer, "Reward: %d points", a3);
      result = (*(int (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(this + 111620) + 28))(
                 this + 111620,
                 Buffer,
                 0,
                 0,
                 0,
                 1);
    }
    else
    {
      sprintf_0(Buffer, "Opposing team won (%d points given)", a3);
      result = (*(int (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(this + 111620) + 28))(
                 this + 111620,
                 Buffer,
                 0,
                 0,
                 0,
                 1);
    }
  }
  else
  {
    result = (*(int (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(this + 111620) + 28))(
               this + 111620,
               aFlagGameReset,
               0,
               0,
               0,
               1);
  }
  if ( *(_DWORD *)(this + 112448) == 3 )
    *(_BYTE *)(this + 112452) = 1;
  return result;
}
// 4C1AE4: using guessed type int dword_4C1AE4;

//----- (00450AF0) --------------------------------------------------------
int __thiscall sub_450AF0(_DWORD *this, int *a2)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // eax
  int v5; // ebx
  int **v6; // ecx
  char *v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebp
  _DWORD *v11; // eax
  const char *v12; // edi
  int v13; // ebp
  void **v14; // esi
  int v15; // edi
  int v16; // ecx
  int v17; // [esp+4h] [ebp-3ECh]
  int v19; // [esp+Ch] [ebp-3E4h]
  int v20; // [esp+10h] [ebp-3E0h]
  int v21[39]; // [esp+14h] [ebp-3DCh] BYREF
  int v22[101]; // [esp+B0h] [ebp-340h] BYREF
  char v23[260]; // [esp+244h] [ebp-1ACh] BYREF
  char v24[156]; // [esp+348h] [ebp-A8h] BYREF
  int v25; // [esp+3ECh] [ebp-4h]

  v2 = this;
  result = *a2;
  if ( !*a2 )
  {
    v4 = this[3];
    v5 = 0;
    v17 = 0;
    if ( v4 > 0 )
    {
      v6 = (int **)this[1];
      do
      {
        if ( *v6 == a2 )
          break;
        ++v5;
        v6 += 39;
      }
      while ( v5 < v4 );
      v17 = v5;
    }
    v22[0] = -1;
    v25 = 0;
    sub_407960(v23, (int)(a2 + 2), asc_4AD87C);
    sub_4077F0(v22, (int)v23);
    if ( v22[0] != -1 )
    {
      while ( 1 )
      {
        v7 = sub_4078F0((char *)v22);
        sub_421C80((char *)v21, (int)v7);
        v8 = sub_407850((char *)v22);
        v9 = v2[3];
        v21[36] = v8;
        v10 = v5;
        v20 = v9;
        if ( v5 < v9 )
        {
          v19 = v2[1];
          v11 = (_DWORD *)(v19 + 156 * v5);
          v12 = (const char *)(v11 + 2);
          while ( (int *)*v11 == a2 )
          {
            if ( *((_DWORD *)v12 - 1) == v21[1] )
            {
              if ( !strcmp(v12, (const char *)&v21[2]) && !strcmp(v12 + 128, (const char *)&v21[34]) )
              {
                v16 = 156 * v10;
                if ( *(_DWORD *)(156 * v10 + v19 + 144) != v21[36] )
                {
                  *(_DWORD *)(v16 + v19 + 144) = v21[36];
                  *(_BYTE *)(v16 + this[1] + 152) = 0;
                }
                v5 = v17;
                goto LABEL_24;
              }
              v9 = v20;
              v5 = v17;
              v2 = this;
            }
            ++v10;
            v11 += 39;
            v12 += 156;
            if ( v10 >= v9 )
              break;
          }
        }
        v13 = v2[3];
        v14 = (void **)(v2 + 1);
        v21[0] = (int)a2;
        if ( v13 >= (int)v14[1] )
        {
          if ( v13 >= 8 )
            v15 = v13 >= 32 ? 32 : 8;
          else
            v15 = 4;
          sub_40B780(156 * (v15 + v13), v14, v13);
          v14[1] = (char *)v14[1] + v15;
        }
        sub_46CAB0((unsigned int)*v14 + 156 * v13 + 156, (_BYTE *)*v14 + 156 * v13, 156 * (_DWORD)v14[2] - 156 * v13);
        v14[2] = (char *)v14[2] + 1;
        sub_46CAB0((unsigned int)*v14 + 156 * v13, v24, 0x9Cu);
        qmemcpy((char *)*v14 + 156 * v13, v21, 0x9Cu);
LABEL_24:
        sub_407820(v22);
        if ( v22[0] == -1 )
          break;
        v2 = this;
      }
    }
    result = sub_4077D0(v22);
  }
  return result;
}

//----- (004516F0) --------------------------------------------------------
int __thiscall sub_4516F0(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // edi
  int v12; // eax
  char Buffer[64]; // [esp+4h] [ebp-44h] BYREF
  int v14; // [esp+44h] [ebp-4h]

  result = *(_DWORD *)(this[302] + 7991);
  if ( result )
  {
    if ( result == 1 )
    {
      v14 = 9499641;
      sprintf_0(Buffer, (const char *const)(9499641 - (_DWORD)&loc_460F9D), a2);
      v7 = *this;
      v8 = (*(int (__thiscall **)(_DWORD *, char *, _DWORD, char *, _DWORD, int, int))(*this + 224))(
             this,
             Buffer,
             0,
             Buffer,
             0,
             -1,
             1);
      (*(void (__thiscall **)(_DWORD *, int))(v7 + 236))(this, this[2] - v8);
      sprintf_0(Buffer, (const char *const)(9500334 - ((_DWORD)&loc_461259 + 1)), a5);
      v9 = *this;
      v10 = (*(int (__thiscall **)(_DWORD *, char *, _DWORD, char *, _DWORD, int, int))(*this + 224))(
              this,
              Buffer,
              this[18807],
              Buffer,
              0,
              -1,
              1);
      (*(void (__thiscall **)(_DWORD *, int))(v9 + 236))(this, this[2] - v10);
      sprintf_0(Buffer, (const char *const)(9501020 - (_DWORD)&loc_461514), a3, a4);
      v11 = *this;
      v12 = (*(int (__thiscall **)(_DWORD *, char *, int, char *, _DWORD, int, int))(*this + 224))(
              this,
              Buffer,
              2 * this[18807],
              Buffer,
              0,
              -1,
              1);
      result = (*(int (__thiscall **)(_DWORD *, int))(v11 + 236))(this, this[2] - v12);
    }
  }
  else
  {
    sub_404B80((_DWORD *)this[2883], this[2] - *(_DWORD *)(this[2883] + 612), 5, 0, 1);
    (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD))(*this + 92))(this, this[2] - 12, 33, a2, this[2886]);
    (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD))(*this + 92))(this, this[2] - 12, 45, a4, this[2886]);
    (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD))(*this + 92))(this, this[2] - 33, 45, a3, this[2886]);
    result = (*(int (__thiscall **)(_DWORD *, int, int, int, _DWORD))(*this + 92))(
               this,
               this[2] - 12,
               57,
               a5,
               this[2886]);
  }
  return result;
}

//----- (004518A0) --------------------------------------------------------
char __thiscall sub_4518A0(_DWORD *this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // ebx
  __int64 v6; // rax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  bool v11; // bl
  int v12; // eax
  int v13; // eax
  int v14; // ecx

  (*(void (__thiscall **)(_DWORD *))(*this + 60))(this);
  if ( this[354] == 1 && (*(int (__thiscall **)(_DWORD *))(*this + 40))(this) == 2 )
  {
    if ( !this[349] && !*((_BYTE *)this + 23110) )
    {
      LOBYTE(v2) = (*(int (__thiscall **)(_DWORD *))(*this + 56))(this);
      this[353] = 1000;
      return v2;
    }
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)this[30127] + 28))(this[30127]);
    v3 = sub_412170();
    (*(void (__thiscall **)(_DWORD *, int))(*this + 40))(this, v3);
    sub_40DA80((char *)(9506457 - (_DWORD)&loc_4629A9));
    (*(void (__thiscall **)(_DWORD *, int, int, _DWORD))(*this + 356))(this, this[5775] + 575, this[5775] + 599, 0);
    v4 = 0;
    v5 = (_DWORD *)((char *)&loc_44E13B + 1);
    do
      v4 -= *v5++;
    while ( v5 < (_DWORD *)((char *)&loc_44E503 + 1) );
    *(_DWORD *)((char *)this + v4 - 184530889) = 2;
  }
  v6 = 3435973837i64 * (unsigned int)(sub_412170() - this[339]);
  LOBYTE(v6) = *((_BYTE *)this + 28244);
  this[356] = HIDWORD(v6) >> 3;
  if ( (_BYTE)v6 || (v7 = this[354], v7 != 5) && v7 != 6 )
    this[356] = 0;
  v8 = this[542];
  v9 = this[2870];
  if ( (!v8 || *(_DWORD *)(v8 + 92) == 8) && v9 < 6000 )
    v9 = 6000;
  v10 = this[354];
  v11 = v10 == 5 && this[356] > v9;
  if ( !v10 || v10 == 6 )
  {
LABEL_30:
    LOBYTE(v2) = *((_BYTE *)this + 1404);
    if ( !(_BYTE)v2 )
      return v2;
    if ( this[354] != 5 )
      return v2;
    v2 = this[542];
    if ( !v2 || *(_DWORD *)(v2 + 92) == 8 )
      return v2;
    v2 = 9513408 - (_DWORD)&loc_464550;
    goto LABEL_35;
  }
  if ( (*(int (__thiscall **)(_DWORD *))(*this + 40))(this) == 1
    || (*(int (__thiscall **)(_DWORD *))(*this + 40))(this) == 2 )
  {
    if ( v11 )
      goto LABEL_28;
    goto LABEL_30;
  }
  if ( v11 )
  {
LABEL_28:
    v2 = 9512427 - ((_DWORD)&loc_464126 + 1);
    goto LABEL_35;
  }
  v2 = 9512746 - (_DWORD)&loc_46428A;
LABEL_35:
  if ( v2 )
  {
    if ( this[354] == 5 )
      (*(void (__thiscall **)(_DWORD *, int, _DWORD, _DWORD, _DWORD, int))(this[27905] + 28))(
        this + 27905,
        v2,
        0,
        0,
        0,
        1);
    v12 = sub_412170();
    (*(void (__thiscall **)(_DWORD *, int))(*this + 40))(this, v12);
    sub_40DA80((char *)(9515176 - ((_DWORD)&loc_464C42 + 2)));
    v13 = -1193648141;
    v14 = 242;
    do
      v13 ^= *(_DWORD *)&aIgnore[4 * v14-- - 381472];
    while ( v14 );
    *(_DWORD *)((char *)this + v13 + 410445912) = this[354] != 5 ? 0 : 6;
    LOBYTE(v2) = (*(int (__thiscall **)(_DWORD *))(*this + 56))(this);
  }
  return v2;
}

//----- (00451B40) --------------------------------------------------------
int __thiscall sub_451B40(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // ebx
  void *v4; // edi
  unsigned int v5; // esi
  int v6; // edi
  int v7; // edx
  int v8; // edx
  int *v9; // ebx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int *v17; // eax
  int v18; // eax
  int v19; // ebx
  int v20; // ebx
  int v21; // edx
  int v22; // edx
  int v23; // eax
  int *v24; // ebx
  int v25; // ecx
  __int64 v26; // rax
  int v27; // eax
  int v28; // ecx
  int *v29; // esi
  int v30; // edi
  int v31; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  int v35; // edx
  int *v36; // esi
  int v37; // eax
  int v38; // edx
  int v39; // eax
  int v40; // ecx
  int v41; // esi
  int v42; // ecx
  char v44[20]; // [esp+8h] [ebp-58h] BYREF
  int v45; // [esp+1Ch] [ebp-44h]
  char v46[8]; // [esp+20h] [ebp-40h] BYREF
  char v47[12]; // [esp+28h] [ebp-38h] BYREF
  int v48; // [esp+34h] [ebp-2Ch]
  int v49; // [esp+38h] [ebp-28h]
  int v50; // [esp+3Ch] [ebp-24h]
  _DWORD *v51; // [esp+40h] [ebp-20h]
  _DWORD *v52; // [esp+44h] [ebp-1Ch]
  unsigned int v53; // [esp+48h] [ebp-18h] BYREF
  int v54; // [esp+4Ch] [ebp-14h] BYREF
  int i; // [esp+50h] [ebp-10h] BYREF
  int v56; // [esp+5Ch] [ebp-4h]

  v3 = this;
  v52 = this;
  sub_40B7D0(this[429]);
  v3[429] = 0;
  v3[431] = 0;
  v3[430] = 0;
  sub_40B7D0(v3[5743]);
  v3[5743] = 0;
  v3[5745] = 0;
  v3[5744] = 0;
  sub_40B7D0(v3[29962]);
  v3[29962] = 0;
  v3[29964] = 0;
  v3[29963] = 0;
  v54 = -1;
  v56 = 0;
  sub_407E80(a2, 1, 3);
  HIBYTE(a2) = 0;
  ReadScrty1FileOffset(&v54, (int)&i + 2, 2);
  if ( HIWORD(i) == 19778 )
  {
    ReadScrty1FileOffset(&v54, (int)&a2, 4);
    sub_408180(a2);
    HIBYTE(a2) = 1;
  }
  else
  {
    sub_408180(0);
  }
  v4 = (void *)sub_40B720(0x100000);
  v3[30132] = v4;
  v50 = 0;
  memset(v4, 0, 0x100000u);
  while ( sub_408570(&v53, 4) == 4 )
  {
    v5 = (v53 >> 12) & 0x3FF;
    v6 = v53 & 0x3FF;
    v7 = v3[30132] + (v5 << 10);
    v53 >>= 24;
    *(_BYTE *)(v7 + v6) = v53;
    v50 += v53 + v5 + v6;
    if ( v53 == 170 )
    {
      v8 = v3[30132];
      v9 = v3 + 5743;
      *(_BYTE *)(v8 + (v5 << 10) + v6) = 0;
      v10 = v9[2];
      v11 = v9[1];
      v51 = (_DWORD *)v10;
      if ( v10 >= v11 )
      {
        v12 = sub_4558C0(v9);
        v13 = v12 + v9[2];
        v49 = v12;
        sub_40B780(v9, 8 * v13);
        v9[1] += v49;
        v10 = (int)v51;
      }
      v51 = (_DWORD *)(8 * v10);
      sub_46CAB0(*v9 + 8 * v10 + 8, *v9 + 8 * v10, 8 * (v9[2] + 0x1FFFFFFF * v10));
      v14 = (int)v51;
      v15 = *v9;
      ++v9[2];
      sub_46CAB0(v15 + v14, v47, 8);
      v16 = *v9;
      v3 = v52;
      v17 = (_DWORD *)((char *)v51 + v16);
      *v17 = v6;
      v17[1] = v5;
    }
    else if ( v53 < 0xA2 || v53 > 0xA9 )
    {
      if ( v53 >= 0xD8 && v53 <= 0xDC )
      {
        v25 = dword_4AAF1C[v53];
        HIDWORD(v26) = 0;
        v49 = 0;
        if ( v25 > 0 )
        {
          v51 = (_DWORD *)(v5 << 10);
          do
          {
            LODWORD(v26) = 0;
            for ( i = 0; i < v25; ++i )
            {
              if ( v26 )
              {
                *((_BYTE *)v51 + v3[30132] + i + v6) = (v53 == 220) - 16;
                HIDWORD(v26) = v49;
              }
              LODWORD(v26) = i + 1;
            }
            v49 = ++HIDWORD(v26);
            v51 += 256;
          }
          while ( SHIDWORD(v26) < v25 );
        }
        if ( v53 == 220 )
        {
          *(_BYTE *)(v3[30132] + v25 / 2 + ((v25 / 2 + v5) << 10) + v6) = -14;
          v27 = 16000 * v25 / 2;
          v28 = v27 + 16000 * v5;
          v29 = v3 + 29962;
          v30 = v27 + 16000 * v6;
          v48 = v28;
          v32 = v3[29963];
          v51 = (_DWORD *)v3[29964];
          v31 = (int)v51;
          if ( (int)v51 >= v32 )
          {
            v33 = sub_4558C0(v3 + 29962);
            v34 = v33 + v3[29964];
            v49 = v33;
            sub_40B780(v3 + 29962, 8 * v34);
            v31 = (int)v51;
            v3[29963] += v49;
          }
          v51 = (_DWORD *)(8 * v31);
          sub_46CAB0(*v29 + 8 * v31 + 8, *v29 + 8 * v31, 8 * (v3[29964] + 0x1FFFFFFF * v31));
          v35 = *v29;
          ++v3[29964];
          sub_46CAB0((char *)v51 + v35, v46, 8);
          v36 = (_DWORD *)((char *)v51 + *v29);
          v37 = v48;
          *v36 = v30;
          v36[1] = v37;
        }
      }
    }
    else
    {
      v18 = v3[430];
      v45 = v53 - 162;
      v51 = v3 + 429;
      v19 = v3[431];
      i = v19;
      if ( v19 >= v18 )
      {
        v49 = sub_4558A0();
        sub_40B780(v51, 12 * (v51[2] + v49));
        v51[1] += v49;
      }
      v20 = 12 * v19;
      sub_46CAB0(v52[429] + 4 * (3 * i + 3), v52[429] + v20, 12 * v52[431] - v20);
      v21 = v52[429];
      ++v52[431];
      sub_46CAB0(v21 + v20, v44, 12);
      v22 = (int)v52;
      v23 = v45;
      v24 = (int *)(v52[429] + v20);
      *v24 = v6;
      v24[1] = v5;
      v24[2] = v23;
      v3 = (_DWORD *)v22;
    }
  }
  (*(void (__thiscall **)(_DWORD *))(*v3 + 280))(v3);
  if ( HIBYTE(a2) )
  {
    v38 = a3;
  }
  else
  {
    a2 = 9537633;
    v38 = 9537633 - (_DWORD)&loc_46A521;
  }
  v39 = 704883932;
  v40 = 243;
  do
    v39 ^= *(_DWORD *)&aShip3Bm2[4 * v40-- - 546892];
  while ( v40 );
  v41 = (int)v52;
  (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)((char *)v52 + v39 + 421661828) + 244))(
    *(_DWORD *)((char *)v52 + v39 + 421661828),
    v38);
  v42 = v50;
  *(_BYTE *)(v41 + 28246) = 1;
  *(_DWORD *)(v41 + 113616) = v42;
  v56 = -1;
  return sub_4087F0(&v54);
}
// 407E80: using guessed type _DWORD __stdcall sub_407E80(_DWORD, _DWORD, _DWORD);
// 408180: using guessed type _DWORD __stdcall sub_408180(_DWORD);
// 408570: using guessed type _DWORD __stdcall sub_408570(_DWORD, _DWORD);
// 4087F0: using guessed type int __thiscall sub_4087F0(_DWORD);
// 40B720: using guessed type _DWORD __cdecl sub_40B720(_DWORD);
// 40B780: using guessed type int __fastcall sub_40B780(_DWORD, _DWORD);
// 40B7D0: using guessed type int __thiscall sub_40B7D0(_DWORD);
// 4558A0: using guessed type int sub_4558A0(void);
// 4558C0: using guessed type int __thiscall sub_4558C0(_DWORD);
// 46CAB0: using guessed type _DWORD __cdecl sub_46CAB0(_DWORD, _DWORD, _DWORD);
// 4AAF1C: using guessed type int dword_4AAF1C[];

//----- (00452010) --------------------------------------------------------
void __thiscall sub_452010(int this, _DWORD *a2)
{
  int v3; // eax
  int v4; // ecx

  if ( *(_BYTE *)(this + 96) )
  {
    sub_443D00((_DWORD *)this, a2);
    if ( a2[23] == 26 )
    {
      *(_BYTE *)(this + 96) = 0;
      sub_40B7D0(*(void **)(this + 104));
      *(_DWORD *)(this + 104) = 0;
      *(_DWORD *)(this + 112) = 0;
      *(_DWORD *)(this + 108) = 0;
      (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
    }
    else if ( memchr((char *)a2 + 99, 13, a2[89]) && *(_DWORD *)(this + 8) < *(_DWORD *)(this + 112) )
    {
      v3 = 627452831;
      v4 = 64;
      do
        v3 ^= *(_DWORD *)&aYouAreAlreadyI[4 * v4-- - 648116];
      while ( v4 );
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(v3 + this + 407608) + 396))(
        *(_DWORD *)(v3 + this + 407608),
        *(_DWORD *)(this + 104) + 164 * *(_DWORD *)(this + 8));
      *(_BYTE *)(this + 96) = 0;
      sub_40B7D0(*(void **)(this + 104));
      *(_DWORD *)(this + 104) = 0;
      *(_DWORD *)(this + 112) = 0;
      *(_DWORD *)(this + 108) = 0;
      (*(void (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
    }
  }
}

//----- (004520E0) --------------------------------------------------------
int __thiscall sub_4520E0(int this, int a2)
{
  int result; // eax
  int v4; // edx
  int v5; // edi
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  _BYTE *v9; // ecx
  _BYTE *v10; // ebp
  int v11; // ebx
  bool v12; // cc
  int v13; // edi
  __int16 *v14; // ebx
  int v15; // [esp+10h] [ebp-14h]
  int v16; // [esp+14h] [ebp-10h]
  _BYTE *v17; // [esp+18h] [ebp-Ch]
  int v18; // [esp+1Ch] [ebp-8h]

  result = *(_DWORD *)(this + 20528);
  if ( (unsigned int)result < 0x80 )
  {
    v13 = 0;
    if ( result > 0 )
    {
      v14 = (__int16 *)(this + 19888);
      do
      {
        sub_404B80(*(_DWORD **)(this + 10220), *v14, v14[1], *(unsigned __int8 *)(this + v13 + 20400) - 1, 1);
        result = *(_DWORD *)(this + 20528);
        ++v13;
        v14 += 2;
      }
      while ( v13 < result );
    }
  }
  else
  {
    result = *(int *)(this + 19880) >> 4;
    v4 = *(int *)(this + 19884) >> 4;
    v5 = -((*(_DWORD *)(this + 19880) + 0x8000) % 16);
    v18 = v5;
    v6 = -((*(_DWORD *)(this + 19884) + 0x8000) % 16);
    if ( result < 0 )
    {
      v5 = -16 * result - (*(_DWORD *)(this + 19880) + 0x8000) % 16;
      result = 0;
      v18 = v5;
    }
    if ( v4 < 0 )
    {
      v6 = -16 * v4 - (*(_DWORD *)(this + 19884) + 0x8000) % 16;
      v4 = 0;
    }
    if ( result <= 1024 )
    {
      v15 = v6;
      if ( v6 < *(_DWORD *)(this + 12) )
      {
        v7 = v4 << 10;
        v16 = v7;
        v8 = v7 + result;
        result = a2;
        v9 = (_BYTE *)(a2 + v8);
        v17 = v9;
        do
        {
          if ( v7 >= 0x100000 )
            break;
          v10 = v9;
          if ( v5 < *(_DWORD *)(this + 8) )
          {
            v11 = (int)&v9[-v7 - a2];
            do
            {
              if ( v11 >= 1024 )
                break;
              if ( *v10 >= 0xB0u && *v10 <= 0xBFu )
              {
                sub_404B80(*(_DWORD **)(this + 10220), v5, v15, (unsigned __int8)*v10 - 1, 1);
                v7 = v16;
                v9 = v17;
              }
              v5 += 16;
              ++v10;
              ++v11;
            }
            while ( v5 < *(_DWORD *)(this + 8) );
            v5 = v18;
          }
          result = v15 + 16;
          v7 += 1024;
          v9 += 1024;
          v12 = v15 + 16 < *(_DWORD *)(this + 12);
          v15 += 16;
          v16 = v7;
          v17 = v9;
        }
        while ( v12 );
      }
    }
  }
  return result;
}

//----- (004522D0) --------------------------------------------------------
int sub_4522D0()
{
  int (__fastcall *v0)(int, unsigned int, unsigned int *, unsigned int); // eax
  int v1; // ecx
  int v2; // edx
  int *v3; // eax
  int v4; // edx
  int result; // eax
  char pExceptionObject[308]; // [esp+0h] [ebp-138h] BYREF
  int v7; // [esp+134h] [ebp-4h]

  v0 = sub_401000;
  v1 = 0;
  do
  {
    v2 = *(_DWORD *)v0;
    v0 = (int (__fastcall *)(int, unsigned int, unsigned int *, unsigned int))((char *)v0 + 4);
    v1 ^= v2;
  }
  while ( (char *)v0 < byte_4A6FF1 );
  v3 = (int *)&unk_4A7440;
  do
  {
    v4 = *v3++;
    v1 ^= v4;
  }
  while ( v3 < (int *)((char *)&stru_4B3E68.pIPtoStateMap + 1) );
  result = -2134769668;
  if ( v1 )
  {
    v7 = 9557393;
    sub_4073D0((int)pExceptionObject, (char *)(9557393 - ((_DWORD)&loc_47092F + 2)), v1);
    _CxxThrowException(pExceptionObject, &_TI2_AVtext_exception__);
  }
  return result;
}
// 4B3E68: using guessed type FuncInfoV1 stru_4B3E68;

//----- (00452350) --------------------------------------------------------
BOOL __thiscall sub_452350(_DWORD *this, int a2)
{
  int v2; // edx
  int v3; // eax
  BOOL result; // eax

  v2 = this[2850];
  result = 0;
  if ( v2 )
  {
    v3 = this[a2 + 2842];
    if ( v3 )
    {
      if ( *(_BYTE *)(v2 + 640) && *(_BYTE *)(v3 + 640) && *(_DWORD *)(v2 + 636) >= *(_DWORD *)(v3 + 636) )
        result = 1;
    }
  }
  return result;
}

//----- (004523A0) --------------------------------------------------------
void __thiscall sub_4523A0(void **this, _BYTE *a2, signed int a3, char a4)
{
  signed int v5; // esi
  signed int v6; // edi
  int v7; // edi
  int v8; // ebx
  _DWORD *v9; // esi
  int v10; // eax
  int v11; // ecx
  int v12; // ebx
  signed int i; // [esp+10h] [ebp-1F8h]
  int v14; // [esp+10h] [ebp-1F8h]
  char v15[4]; // [esp+14h] [ebp-1F4h] BYREF
  char v16[2]; // [esp+18h] [ebp-1F0h] BYREF
  char v17[494]; // [esp+1Ah] [ebp-1EEh] BYREF

  if ( this[178] == (void *)2 )
  {
    if ( a4 )
    {
      if ( a3 < 496 )
      {
        v7 = sub_40B720((int)this, a3 + 12);
        *(_DWORD *)v7 = sub_412170();
        *(_WORD *)(v7 + 4) = a3 + 6;
        *(_BYTE *)(v7 + 6) = 0;
        *(_BYTE *)(v7 + 7) = 3;
        *(_DWORD *)(v7 + 8) = this[179];
        this[179] = (char *)this[179] + 1;
        sub_46CAB0(v7 + 12, a2, a3);
        v8 = (int)this[189];
        v9 = this + 187;
        if ( v8 >= (int)this[188] )
        {
          if ( v8 >= 8 )
          {
            v10 = (v8 >= 32) - 1;
            LOBYTE(v10) = v10 & 0xE8;
            v14 = v10 + 32;
          }
          else
          {
            v14 = 4;
          }
          sub_40B780(4 * (v8 + v14), this + 187, (int)this);
          this[188] = (char *)this[188] + v14;
        }
        sub_46CAB0(*v9 + 4 * v8 + 4, (_BYTE *)(*v9 + 4 * v8), 4 * ((_DWORD)this[189] + 0x3FFFFFFF * v8));
        v11 = *v9;
        this[189] = (char *)this[189] + 1;
        v12 = 4 * v8;
        sub_46CAB0(v12 + v11, v15, 4u);
        *(_DWORD *)(*v9 + v12) = v7;
        if ( (unsigned int)(*(_DWORD *)(v7 + 8) - *(_DWORD *)(*(_DWORD *)*v9 + 8)) >= 0x10 )
          *(_DWORD *)v7 -= 10000;
        else
          (*((void (__thiscall **)(void **, _DWORD, int))*this + 5))(this, *(unsigned __int16 *)(v7 + 4), v7 + 6);
      }
      else
      {
        v5 = 0;
        v6 = a3;
        for ( i = a3; ; v6 = i )
        {
          if ( v6 >= 480 )
            v6 = 480;
          v16[1] = (v6 + v5 >= a3) + 8;
          v16[0] = 0;
          sub_46CAB0((unsigned int)v17, &a2[v5], v6);
          (*((void (__thiscall **)(void **, char *, int, int))*this + 4))(this, v16, v6 + 2, 1);
          v5 += 480;
          i -= 480;
          if ( v5 >= a3 )
            break;
        }
      }
    }
    else
    {
      (*((void (__thiscall **)(void **, signed int, _BYTE *))*this + 5))(this, a3, a2);
    }
  }
}
// 4523DF: conditional instruction was optimized away because of '%arg_4.4>=1F0'

//----- (004525C0) --------------------------------------------------------
char __thiscall sub_4525C0(_DWORD *this, int a2, int a3, unsigned __int8 *a4)
{
  int v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // edx
  int v8; // eax
  int v9; // ecx
  char result; // al
  int v11; // ecx
  unsigned __int8 *v12; // ebx
  int v13; // esi
  int v14; // [esp+Ch] [ebp-10h]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v5 = this[2905];
  if ( v5 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v5 + 8))(v5, 1);
    this[2905] = 0;
  }
  v6 = (_DWORD *)sub_40B720((int)&savedregs, 0x2Cu);
  if ( v6 )
    v7 = sub_405030(v6, (int)this, a2, a3, *(_BYTE *)(this[302] + 8247));
  else
    v7 = 0;
  v8 = 1709179896;
  v9 = 244;
  do
    v8 ^= *(_DWORD *)&aJunkjvBm2[4 * v9-- - 557772];
  while ( v9 );
  *(_DWORD *)((char *)this + v8 + 276038532) = v7;
  result = sub_4052C0(this[2905]);
  if ( result )
  {
    v11 = 0;
    v14 = 0;
    if ( a3 > 0 )
    {
      v12 = a4;
      do
      {
        v13 = 0;
        *(_DWORD *)(this[2905] + 28) = *(_DWORD *)(this[2905] + 16) + v11 * *(_DWORD *)(this[2905] + 20);
        if ( a2 > 0 )
        {
          do
          {
            a4 = (unsigned __int8 *)this[*v12 + 13076];
            sub_46CAB0(
              *(_DWORD *)(this[2905] + 28) + v13 * *(_DWORD *)(this[2905] + 24),
              &a4,
              *(_DWORD *)(this[2905] + 24));
            ++v13;
            ++v12;
          }
          while ( v13 < a2 );
          v11 = v14;
        }
        v14 = ++v11;
      }
      while ( v11 < a3 );
    }
    result = sub_405330(this[2905]);
  }
  return result;
}

//----- (00452700) --------------------------------------------------------
int __thiscall sub_452700(void *this, int *a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int result; // eax

  v3 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 64))(this);
  v4 = (v3 & 0x3FF) - a3;
  if ( v4 >= -300 )
  {
    if ( v4 < 0 )
      v4 = 0;
    result = v3 - v4;
    *a2 = v4;
  }
  else
  {
    v5 = v4 + 1024;
    result = v3 - v5;
    *a2 = v5;
  }
  return result;
}

//----- (00452740) --------------------------------------------------------
char __thiscall sub_452740(int this, int a2)
{
  int v3; // eax
  _DWORD *v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // edi
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  unsigned int v20; // edx
  int v21; // ecx
  unsigned int v22; // edx
  unsigned int v23; // ecx
  unsigned int v24; // edx
  unsigned int v25; // ecx
  unsigned int v26; // edx
  int v28; // [esp+4h] [ebp-4h] BYREF

  LOBYTE(v3) = *(_BYTE *)(this + 113572);
  if ( !(_BYTE)v3 )
  {
    v3 = *(_DWORD *)(this + 2168);
    *(_BYTE *)(this + 1868) = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(this + 10752) && ((_BYTE)a2 || *(int *)(v3 + 560) > 0 || *(_DWORD *)(this + 1416) == 6) )
      {
        memset((void *)(this + 112220), 0, 0x80u);
        strcpy((char *)(this + 112220), (const char *)(*(_DWORD *)(this + 2168) + 109));
        v4 = *(_DWORD **)(this + 2168);
        *(_DWORD *)(this + 112252) = v4[23];
        *(_DWORD *)(this + 112256) = v4[8] + v4[9];
        v5 = v4[124];
        if ( *(_DWORD *)(v4[125] + v5) )
        {
          v7 = v4[122];
          v6 = *(_DWORD *)(v4[121] + v5);
          if ( v7 + v4[123] <= v6 )
            v6 = v7 + v4[123];
        }
        else
        {
          v6 = *(_DWORD *)(v4[120] + v5);
        }
        *(_DWORD *)(this + 112260) = v6;
        v8 = v4[147];
        if ( *(_DWORD *)(v4[148] + v8) )
        {
          v10 = *(_DWORD *)(v4[144] + v8);
          v9 = v4[145] + v4[146];
          if ( v9 > v10 )
            v9 = v10;
        }
        else
        {
          v9 = *(_DWORD *)(v8 + v4[143]);
        }
        *(_DWORD *)(this + 112264) = v9;
        v11 = v4[159];
        if ( *(_DWORD *)(v4[160] + v11) )
        {
          v13 = *(_DWORD *)(v4[156] + v11);
          v12 = v4[157] + v4[158];
          if ( v12 > v13 )
            v12 = v13;
        }
        else
        {
          v12 = *(_DWORD *)(v11 + v4[155]);
        }
        *(_DWORD *)(this + 112268) = v12;
        v14 = v4[214];
        if ( *(_DWORD *)(v4[215] + v14) )
        {
          v16 = *(_DWORD *)(v4[211] + v14);
          v15 = v4[212] + v4[213];
          if ( v15 > v16 )
            v15 = v16;
        }
        else
        {
          v15 = *(_DWORD *)(v14 + v4[210]);
        }
        *(_DWORD *)(this + 112272) = v15;
        v17 = v4[115];
        if ( *(_DWORD *)(v4[116] + v17) )
        {
          v19 = *(_DWORD *)(v4[112] + v17);
          v18 = v4[113] + v4[114];
          if ( v18 > v19 )
            v18 = v19;
        }
        else
        {
          v18 = *(_DWORD *)(v17 + v4[111]);
        }
        *(_DWORD *)(this + 112276) = v18;
        *(_DWORD *)(this + 112280) = v4[166] + v4[167];
        *(_DWORD *)(this + 112284) = v4[168] + v4[169];
        *(_DWORD *)(this + 112288) = v4[170] + v4[171];
        *(_DWORD *)(this + 112292) = v4[172] + v4[173];
        *(_DWORD *)(this + 112296) = v4[174] + v4[175];
        *(_DWORD *)(this + 112300) = v4[176] + v4[177];
        *(_DWORD *)(this + 112304) = v4[178] + v4[179];
        *(_DWORD *)(this + 112308) = v4[180] + v4[181];
        *(_DWORD *)(this + 112312) = v4[182] + v4[183];
        v20 = *(_DWORD *)(this + 112320) & 0xFFFFFFFE;
        *(_DWORD *)(this + 112316) = v4[184] + v4[185];
        v21 = v20 | (v4[186] >> 17) & 1;
        *(_DWORD *)(this + 112320) = v21;
        v22 = v21 & 0xFFFFFFFD | (v4[186] >> 29) & 2;
        *(_DWORD *)(this + 112320) = v22;
        v23 = v22 & 0xFFFFFFFB | (v4[187] >> 5) & 4;
        *(_DWORD *)(this + 112320) = v23;
        v24 = v23 & 0xFFFFFFF7 | (v4[187] >> 6) & 8;
        *(_DWORD *)(this + 112320) = v24;
        v25 = v24 & 0xFFFFFFEF | (v4[187] >> 11) & 0x10;
        *(_DWORD *)(this + 112320) = v25;
        v26 = v25 & 0xFFFFFFDF | (v4[187] >> 14) & 0x20;
        *(_DWORD *)(this + 112320) = v26;
        *(_DWORD *)(this + 112320) = v26 & 0xFFFFFFBF | (v4[187] >> 20) & 0x40;
        *(_DWORD *)(this + 112324) = v4[51];
        *(_DWORD *)(this + 112328) = v4[52];
        *(_DWORD *)(this + 112332) = v4[40];
        *(_DWORD *)(this + 112336) = v4[41];
        a2 = -1;
        sub_401A70(&a2, (unsigned __int8 *)(this + 110192), 1428);
        *(_DWORD *)(this + 112340) = a2;
        v28 = -1;
        sub_401A70(&v28, (unsigned __int8 *)(this + 112220), 128);
        LOBYTE(v3) = v28;
        *(_DWORD *)(this + 112344) = v28;
        *(_BYTE *)(this + 1868) = 1;
      }
    }
  }
  return v3;
}

//----- (00452B10) --------------------------------------------------------
int __thiscall sub_452B10(_DWORD *this, char *Format)
{
  int v3; // eax
  char *v4; // esi
  bool v5; // al
  char *v6; // esi
  unsigned int v7; // edx
  int v8; // edi
  int v9; // eax
  int result; // eax
  int v11; // eax
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // edi
  _DWORD *v15; // edi
  int v16; // kr04_4
  int v17; // edx
  int v18; // eax
  int v19; // edi
  _DWORD *v20; // ecx
  _DWORD *v21; // edx
  _DWORD *v22; // ecx
  int v23; // eax
  unsigned int v24; // ecx
  unsigned int v25; // edx
  unsigned int v26; // ecx
  int v27; // edx
  int *v28; // ecx
  _DWORD *v29; // eax
  int v30; // ecx
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  int v33; // eax
  int v34; // ecx
  unsigned int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // ecx
  int v42; // [esp-10h] [ebp-B8h]
  int v43; // [esp-Ch] [ebp-B4h]
  int v44; // [esp-4h] [ebp-ACh]
  char Buffer[128]; // [esp+Ch] [ebp-9Ch] BYREF
  int v46[2]; // [esp+8Ch] [ebp-1Ch] BYREF
  unsigned int v47; // [esp+94h] [ebp-14h]
  unsigned int v48; // [esp+98h] [ebp-10h]
  int v49; // [esp+9Ch] [ebp-Ch]
  _DWORD *v50; // [esp+A0h] [ebp-8h]
  bool v51; // [esp+A6h] [ebp-2h]
  char v52; // [esp+A7h] [ebp-1h]
  char *Formata; // [esp+B0h] [ebp+8h]
  int Formatb; // [esp+B0h] [ebp+8h]
  char *Formatc; // [esp+B0h] [ebp+8h]
  char *Formatd; // [esp+B0h] [ebp+8h]
  char *Formate; // [esp+B0h] [ebp+8h]

  v51 = !this[542] || (v3 = this[354], v3 != 5) && v3 != 6;
  if ( !this[30132] || (v52 = 0, v51) )
    v52 = 1;
  v4 = Format;
  *((_DWORD *)Format + 18840) = this[2753];
  *((_DWORD *)Format + 18841) = this[28119] + this[28120];
  v5 = *((_BYTE *)this + 6280) && !*((_BYTE *)this + 113557) && !v52;
  Format[75368] = v5;
  (*(void (__thiscall **)(_DWORD *, char *, _DWORD))(*this + 404))(this, Format, 0);
  if ( *(_BYTE *)(this[5775] + 8044) )
    (*(void (__thiscall **)(char *))(*(_DWORD *)Format + 144))(Format);
  (*(void (__thiscall **)(char *))(*(_DWORD *)Format + 140))(Format);
  (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, Format, 1);
  if ( v52 )
  {
    strcpy(Buffer, aEnteringArena);
    if ( v51 )
    {
      v6 = Format;
    }
    else
    {
      v6 = Format;
      (*(void (__thiscall **)(_DWORD *, char *))(this[27905] + 40))(this + 27905, Format);
      (*(void (__thiscall **)(_DWORD *, char *))(this[28087] + 12))(this + 28087, Format);
      v7 = 0;
      if ( (int)this[435] >= 2 )
      {
        if ( this[2686] )
          v7 = (unsigned int)(100 * (this[468] + (*(int (__thiscall **)(_DWORD *))(*this + 72))(this))) / this[2686];
      }
      else
      {
        v7 = (*(int (__thiscall **)(_DWORD *))(*this + 68))(this) / 10;
      }
      sprintf_0(Buffer, (const char *const)(9623570 - ((_DWORD)&loc_47F2D2 + 4)), v7);
    }
    v8 = *(_DWORD *)v6;
    v9 = (*(int (__thiscall **)(char *, char *, int, char *, int, int, int))(*(_DWORD *)v6 + 224))(
           v6,
           Buffer,
           4 * this[7063] / 5,
           Buffer,
           2,
           -1,
           1);
    (*(void (__thiscall **)(char *, int))(v8 + 236))(v6, (this[7062] - v9) / 2);
    result = (*(int (__thiscall **)(char *, _DWORD, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v6 + 168))(
               v6,
               this[2171],
               this[2172],
               0,
               this[29992] != 8 ? this[29992] : 0,
               0);
  }
  else
  {
    if ( (int)this[29445] > 0 )
    {
      v11 = this[436];
      if ( !v11 || v11 == 2 )
      {
        LOBYTE(v11) = v11 == 2;
        v44 = v11;
        v12 = *(_DWORD *)(this[542] + 92);
        LOBYTE(v12) = v12 == 8;
        (*(void (__thiscall **)(char *, int, int))(*(_DWORD *)Format + 284))(Format, v12, v44);
      }
    }
    (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)Format + 148))(Format, this[30132]);
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, Format, 2);
    v13 = (_DWORD *)this[542];
    if ( (int)v13[202] > 0 )
      (*(void (__thiscall **)(char *, _DWORD, _DWORD))(*(_DWORD *)Format + 192))(Format, v13[105], v13[106]);
    if ( *(_DWORD *)(this[542] + 92) != 8 || !this[3105] )
      (*(void (__thiscall **)(_DWORD *, char *))(*this + 264))(this, Format);
    v14 = 0;
    if ( (int)this[2170] > 0 )
    {
      Formata = (char *)(this + 1914);
      do
      {
        (*(void (__thiscall **)(_DWORD, char *))(**(_DWORD **)Formata + 16))(*(_DWORD *)Formata, v4);
        ++v14;
        Formata += 4;
      }
      while ( v14 < this[2170] );
    }
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 400))(this, v4);
    (*(void (__thiscall **)(_DWORD *, char *, _DWORD))(*this + 412))(this, v4, 0);
    v15 = this + 29431;
    Formatb = 8;
    do
    {
      if ( *v15 )
        (*(void (__thiscall **)(_DWORD, char *))(*(_DWORD *)*v15 + 12))(*v15, v4);
      ++v15;
      --Formatb;
    }
    while ( Formatb );
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, v4, 3);
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 256))(this, v4);
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 412))(this, v4, 1);
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, v4, 4);
    (*(void (__thiscall **)(char *, _DWORD))(*(_DWORD *)v4 + 152))(v4, this[30132]);
    *((_DWORD *)v4 + 18816) = 0;
    v16 = this[7063];
    *((_DWORD *)v4 + 18818) = 0;
    *((_DWORD *)v4 + 18817) = v16 / 2;
    *((_DWORD *)v4 + 18819) = v16 / 2;
    *((_DWORD *)v4 + 18828) = this[7062];
    *((_DWORD *)v4 + 18829) = this[7063] / 2;
    v17 = *((_DWORD *)v4 + 18829);
    *((_DWORD *)v4 + 18830) = *((_DWORD *)v4 + 18828);
    *((_DWORD *)v4 + 18831) = v17;
    v18 = this[542];
    if ( v18 )
    {
      if ( *(_DWORD *)(v18 + 92) == 8 )
      {
        if ( !this[3106] )
        {
          LOBYTE(v18) = (*(_BYTE *)(v18 + 96) & 4) != 0;
          (*(void (__thiscall **)(char *, int))(*(_DWORD *)v4 + 204))(v4, v18);
        }
      }
      else
      {
        Formatc = 0;
        if ( (int)this[1875] > 0 )
        {
          v19 = this[28120] + this[28119];
          v20 = this + 1571;
          v50 = (_DWORD *)this[1875];
          do
          {
            if ( *(_DWORD *)(*v20 + 20) == v19 )
              ++Formatc;
            ++v20;
            v50 = (_DWORD *)((char *)v50 - 1);
          }
          while ( v50 );
        }
        if ( this[3014] && (int)this[1569] > 0 )
        {
          v21 = this + 545;
          v50 = (_DWORD *)this[1569];
          do
          {
            v22 = (_DWORD *)*v21;
            if ( *(_DWORD *)(*v21 + 48) + *(_DWORD *)(*v21 + 52) > 0 && v22[22] == this[28119] + this[28120] )
              Formatc += v22[12] + v22[13];
            ++v21;
            v50 = (_DWORD *)((char *)v50 - 1);
          }
          while ( v50 );
        }
        (*(void (__thiscall **)(char *, int, int, char *, int))(*(_DWORD *)v4 + 212))(
          v4,
          *(_DWORD *)(v18 + 612) + *(_DWORD *)(v18 + 616),
          *(_DWORD *)(v18 + 48) + *(_DWORD *)(v18 + 52),
          Formatc,
          *(_DWORD *)(v18 + 32) + *(_DWORD *)(v18 + 36));
        v23 = this[542];
        v46[0] = ((*(_DWORD *)(v23 + 744) >> 17) & 1) + (*(_BYTE *)(v23 + 96) & 1);
        v24 = *(unsigned __int8 *)(v23 + 96);
        v25 = *(_BYTE *)(v23 + 96) & 0x40 | HIBYTE(*(_DWORD *)(v23 + 744)) & 0x40;
        v23 += 664;
        v46[1] = ((v24 >> 1) & 1) + (v25 >> 6);
        v47 = ((*(_DWORD *)(v23 + 84) >> 9) & 1) + ((*(unsigned __int8 *)(v23 - 568) >> 2) & 1);
        v26 = v47;
        LOBYTE(v26) = *(_BYTE *)(v23 - 568);
        v27 = *(_DWORD *)v4;
        v48 = ((*(_DWORD *)(v23 + 84) >> 7) & 1) + ((v26 >> 3) & 1);
        v28 = v46;
        LOBYTE(v28) = *(_BYTE *)(v23 + 148);
        (*(void (__thiscall **)(char *, int, int *, int *))(v27 + 208))(v4, v23, v28, v46);
        v29 = (_DWORD *)this[542];
        v30 = v29[115];
        if ( *(_DWORD *)(v29[116] + v30) )
        {
          Formatd = *(char **)(v29[112] + v30);
          if ( v29[113] + v29[114] <= (int)Formatd )
            Formatd = (char *)(v29[113] + v29[114]);
        }
        else
        {
          Formatd = *(char **)(v29[111] + v30);
        }
        (*(void (__thiscall **)(char *, int, char *, _DWORD))(*(_DWORD *)v4 + 216))(
          v4,
          (v29[130] + v29[131]) / 1000,
          Formatd,
          this[327 * v29[23] + 3216]);
        v31 = (_DWORD *)this[542];
        if ( v31[99] + v31[100] )
          (*(void (__fastcall **)(char *, int, _DWORD, int, int))(*(_DWORD *)v4 + 220))(
            v4,
            100 * (v31[99] + v31[100]) % this[327 * v31[23] + 3367],
            0,
            100 * (v31[99] + v31[100]) / this[327 * v31[23] + 3367],
            1);
        (*(void (__thiscall **)(char *, int, int, _DWORD))(*(_DWORD *)v4 + 220))(
          v4,
          1,
          *(_DWORD *)(this[542] + 404) + *(_DWORD *)(this[542] + 408),
          0);
        (*(void (__thiscall **)(char *, int, _DWORD, _DWORD))(*(_DWORD *)v4 + 220))(
          v4,
          3,
          *(_DWORD *)(this[542] + 808),
          0);
        v32 = (_DWORD *)this[542];
        if ( v32[12] + v32[13] )
          (*(void (__thiscall **)(char *, int, int, _DWORD))(*(_DWORD *)v4 + 220))(v4, 2, v32[149] + v32[150], 0);
        v33 = this[542];
        if ( *(_BYTE *)(v33 + 169) )
          (*(void (__thiscall **)(char *, int, int, _DWORD))(*(_DWORD *)v4 + 220))(
            v4,
            4,
            *(_DWORD *)(v33 + 876) + *(_DWORD *)(v33 + 880),
            0);
      }
    }
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 196))(this, v4);
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, v4, 5);
    if ( !*((_BYTE *)this + 113557) && (*((_BYTE *)this + 6281) || *((_BYTE *)this + 1869)) )
      (*(void (__thiscall **)(_DWORD *, char *))(this[27905] + 40))(this + 27905, v4);
    (*(void (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, v4, 6);
    if ( (int)this[29445] > 0 && this[436] == 1 )
    {
      LOBYTE(v34) = *(_DWORD *)(this[542] + 92) == 8;
      (*(void (__thiscall **)(char *, int, _DWORD))(*(_DWORD *)v4 + 284))(v4, v34, 0);
    }
    if ( !*((_BYTE *)this + 1869) )
    {
      v35 = 0;
      v36 = (int)(this + 470);
      Formate = 0;
      v50 = this + 470;
      do
      {
        if ( *(_DWORD *)(v36 + 64) > this[5776] && *(_BYTE *)v36 )
        {
          v43 = *(_DWORD *)(v36 + 68);
          v42 = v36;
          v37 = this[7063];
          v49 = *(_DWORD *)v4;
          (*(void (__thiscall **)(char *, int, unsigned int, int, int, int, int))(v49 + 236))(
            v4,
            this[7062] / 6,
            3 * v37 / 5 + v35 * *((_DWORD *)v4 + 18807),
            v42,
            v43,
            -1,
            1);
          v36 = (int)v50;
          v35 = (unsigned int)Formate;
        }
        ++v35;
        v36 += 72;
        Formate = (char *)v35;
        v50 = (_DWORD *)v36;
      }
      while ( v35 < 4 );
    }
    if ( *(_DWORD *)(this[542] + 92) == 8 )
    {
      v38 = this[28390];
      if ( v38 >= 0 && (v39 = this[v38 + 28405]) != 0 )
      {
        (*(void (__thiscall **)(int, char *))(*(_DWORD *)v39 + 64))(v39, v4);
      }
      else
      {
        v40 = this[7062];
        *((_DWORD *)v4 + 18821) = 0;
        *((_DWORD *)v4 + 18820) = v40 / 2;
      }
    }
    v41 = *(_DWORD *)(this[542] + 560);
    if ( v41 > 0 )
    {
      sprintf_0(
        Buffer,
        (const char *const)(9678973 - ((_DWORD)&loc_48CB5F + 2)),
        v41 / 100 / 3600,
        v41 / 100 / 60 % 60,
        v41 / 100 % 60);
      (*(void (__thiscall **)(char *, int, int, char *, int, int, int))(*(_DWORD *)v4 + 236))(
        v4,
        this[7062] / 2,
        this[7063] / 2 - 48,
        Buffer,
        4,
        -1,
        1);
    }
    if ( this[354] == 6 || (int)this[356] > 1500 )
      (*(void (__thiscall **)(char *, int, int, int, int, int, int))(*(_DWORD *)v4 + 236))(
        v4,
        this[7062] / 6,
        2 * this[7063] / 5,
        9680621 - (_DWORD)&loc_48D1F5,
        4,
        -1,
        1);
    if ( !this[29441] )
      (*(void (__thiscall **)(_DWORD *, char *))(this[28087] + 12))(this + 28087, v4);
    (*(void (__thiscall **)(_DWORD *, char *))(this[30023] + 12))(this + 30023, v4);
    (*(void (__thiscall **)(_DWORD *, char *))(*this + 116))(this, v4);
    (*(void (__thiscall **)(_DWORD *, char *))(this[1879] + 12))(this + 1879, v4);
    (*(void (__thiscall **)(_DWORD *, char *))(this[5746] + 12))(this + 5746, v4);
    (*(void (__thiscall **)(_DWORD *, char *))(this[438] + 12))(this + 438, v4);
    if ( *(_BYTE *)(this[5775] + 8279) )
    {
      sprintf_0(Buffer, (const char *const)(9661907 - (_DWORD)&loc_48E0CF), this[29990]);
      (*(void (__thiscall **)(char *, int, _DWORD, char *, int, int, int))(*(_DWORD *)v4 + 236))(
        v4,
        this[7062] / 4,
        0,
        Buffer,
        3,
        -1,
        1);
    }
    result = (*(int (__thiscall **)(_DWORD *, char *, int))(*this + 404))(this, v4, 7);
  }
  return result;
}
// 4531DF: conditional instruction was optimized away because of 'eax.4!=0'
// 45327C: variable 'v34' is possibly undefined

//----- (00453560) --------------------------------------------------------
int __userpurge sub_453560@<eax>(int a1@<ecx>, int a2@<ebx>, int a3)
{
  _DWORD *v4; // ecx
  int v5; // ebx
  int v6; // eax
  int v7; // edx
  int v8; // ebx
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // edi
  int v12; // edi
  int v13; // eax
  int v14; // ecx
  int result; // eax
  char Buffer[64]; // [esp+8h] [ebp-44h] BYREF
  unsigned int v17; // [esp+48h] [ebp-4h]

  v4 = *(_DWORD **)(a1 + 2168);
  if ( v4 && v4[7] == a3 )
    (*(void (__thiscall **)(_DWORD *, int))(*v4 + 84))(v4, -1);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)a1 + 212))(a1, a3, a2);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 113620);
  if ( v5 )
  {
    if ( *(_BYTE *)(a1 + 113524) )
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 23100) + 9118))(v5 + 109);
    v6 = *(_DWORD *)(*(_DWORD *)(a1 + 23100) + 8023);
    if ( v6 == 1 )
    {
      v17 = 9701575;
      (*(void (__cdecl **)(int, int, int, int, int))(*(_DWORD *)a1 + 388))(
        a1,
        400,
        2,
        9701575 - ((_DWORD)&loc_492362 + 1),
        v5 + 109);
    }
    else if ( v6 == 2 )
    {
      v17 = 9702863;
      sprintf_0(Buffer, (const char *const)(9702863 - ((_DWORD)&loc_49286A + 1)), v5 + 109);
      (*(void (__thiscall **)(int, char *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 111620) + 28))(
        a1 + 111620,
        Buffer,
        0,
        0,
        0,
        1);
    }
  }
  v7 = *(_DWORD *)(a1 + 6276);
  v8 = a1 + 2180;
  v9 = 0;
  if ( v7 <= 0 )
  {
LABEL_15:
    v11 = -1;
  }
  else
  {
    v10 = (_DWORD *)(a1 + 2180);
    while ( *v10 != *(_DWORD *)(a1 + 4 * a3 + 113620) )
    {
      ++v9;
      ++v10;
      if ( v9 >= v7 )
        goto LABEL_15;
    }
    v11 = v9;
  }
  (*(void (__thiscall **)(int, int))(*(_DWORD *)(a1 + 112348) + 36))(a1 + 112348, a3);
  if ( v11 < 0 )
  {
    v12 = a3;
    sub_40B7E0(*(_DWORD *)(a1 + 4 * a3 + 113620));
  }
  else
  {
    v17 = v8 + 4 * v11;
    sub_40B7E0(*(_DWORD *)v17);
    sub_46CAB0(v17, (_BYTE *)(v8 + 4 * (v11 + 1)), 4 * (*(_DWORD *)(a1 + 6276) + 0x3FFFFFFF * (v11 + 1)));
    v12 = a3;
    --*(_DWORD *)(a1 + 6276);
  }
  *(_DWORD *)(a1 + 4 * v12 + 113620) = 0;
  if ( v12 == *(_DWORD *)(a1 + 7504) )
    *(_DWORD *)(a1 + 2168) = 0;
  if ( *(_DWORD *)(a1 + 112212) == v12 )
    *(_DWORD *)(a1 + 112212) = -1;
  if ( *(_DWORD *)(a1 + 113560) == v12 )
  {
    v13 = 1687491606;
    v14 = 227;
    do
      v13 ^= *(_DWORD *)&aKbForward[4 * v14-- - 380952];
    while ( v14 );
    *(_DWORD *)(v13 + a1 + 498148504) = -1;
  }
  result = *(_DWORD *)(a1 + 113564);
  if ( result == v12 )
    *(_DWORD *)(a1 + 113564) = -1;
  return result;
}

//----- (00453750) --------------------------------------------------------
char __thiscall sub_453750(_DWORD *this, int a2, int a3)
{
  int v3; // esi
  int v4; // edi
  int v5; // ebx
  int v6; // ebp
  int v7; // esi
  int v8; // edx
  signed int v9; // edi
  signed int v10; // ebx
  int v11; // eax
  int v12; // edx
  int v13; // ebp
  int v14; // eax
  int v15; // eax
  int v17; // [esp+14h] [ebp-4h]
  int v18; // [esp+1Ch] [ebp+4h]

  v3 = a2 - this[1];
  v4 = a3 - this[2];
  v5 = abs32(v3);
  v6 = abs32(v4);
  if ( v5 >= 16000 || v6 >= 16000 )
  {
    if ( v5 >= v6 )
    {
      v7 = v3 <= 0 ? -8000 : 8000;
      v17 = 8000 * v4 / v5;
      v8 = v5 / 8000 - 1;
    }
    else
    {
      v7 = 8000 * v3 / v6;
      v17 = v4 <= 0 ? -8000 : 8000;
      v8 = v6 / 8000 - 1;
    }
    v9 = this[1];
    v10 = this[2];
    v11 = v8;
    v12 = v8 - 1;
    v18 = v12;
    if ( v11 )
    {
      v13 = *(_DWORD *)(this[3] + 120528);
      do
      {
        v9 += v7;
        v10 += v17;
        if ( v13 )
        {
          if ( (unsigned int)v9 >= 0xFA0000 || (unsigned int)v10 >= 0xFA0000 )
            return 0;
          v14 = *(unsigned __int8 *)(v9 / 16000 + ((v10 / 16000) << 10) + v13);
          if ( *(_BYTE *)(v9 / 16000 + ((v10 / 16000) << 10) + v13)
            && v14 != 253
            && v14 != 252
            && (*(unsigned __int8 *)(v9 / 16000 + ((v10 / 16000) << 10) + v13) < 0xACu
             || *(unsigned __int8 *)(v9 / 16000 + ((v10 / 16000) << 10) + v13) > 0xBFu)
            && v14 != 254
            && v14 != 255
            && v14 != 171
            && v14 != 170 )
          {
            return 0;
          }
          v12 = v18;
        }
        v15 = v12--;
        v18 = v12;
      }
      while ( v15 );
    }
  }
  return 1;
}

//----- (004538F0) --------------------------------------------------------
char __thiscall sub_4538F0(int this, _DWORD *a2)
{
  void *v3; // eax
  int v4; // eax
  int v5; // ecx
  int v7; // [esp-8h] [ebp-110h]
  char Buffer[256]; // [esp+8h] [ebp-100h] BYREF

  LOBYTE(v3) = *(_BYTE *)(this + 96);
  if ( (_BYTE)v3 )
  {
    sub_443D00((_DWORD *)this, a2);
    if ( a2[23] == 26 )
    {
      (*(void (__thiscall **)(int))(*(_DWORD *)this + 36))(this);
      *(_BYTE *)(this + 96) = 0;
      LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
    }
    else
    {
      v3 = memchr((char *)a2 + 99, 13, a2[89]);
      if ( v3 )
      {
        v7 = *(_DWORD *)(this + 104) + 132 * *(_DWORD *)(this + 8);
        sprintf_0(Buffer, (const char *const)(9734211 - ((_DWORD)&loc_49A2CE + 1)), *(_DWORD *)(v7 + 128), v7);
        (*(void (__thiscall **)(_DWORD, char *, int, _DWORD, _DWORD))(**(_DWORD **)(this + 100) + 364))(
          *(_DWORD *)(this + 100),
          Buffer,
          2,
          0,
          0);
        (*(void (__thiscall **)(int))(*(_DWORD *)this + 36))(this);
        v4 = -639763;
        v5 = 48;
        do
          v4 ^= (unsigned int)*(&dword_4A7108 + v5-- + 3508);
        while ( v5 );
        *(_BYTE *)(v4 + this + 489152) = 0;
        LOBYTE(v3) = (*(int (__thiscall **)(_DWORD *))(*a2 + 16))(a2);
      }
    }
  }
  return (char)v3;
}
// 4A7108: using guessed type int (__cdecl *dword_4A7108)(_DWORD, _DWORD);

//----- (00453D60) --------------------------------------------------------
int __thiscall sub_453D60(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // esi
  int i; // ebx
  int result; // eax
  _DWORD *v6; // esi
  int v7; // edi
  int v8; // ecx
  int v9; // ecx
  int v10; // [esp+10h] [ebp-4h]

  v2 = &unk_4AAC68;
  v10 = 34;
  do
  {
    v3 = (_DWORD *)((char *)this + *(v2 - 2));
    for ( i = 0; i < *v2; ++v3 )
    {
      if ( *v3 )
        (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*v3 + 28))(*v3);
      ++i;
    }
    v2 += 3;
    result = --v10;
  }
  while ( v10 );
  v6 = this + 17;
  v7 = 5;
  do
  {
    if ( *v6 )
      result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*v6 + 28))(*v6);
    v6 += 3;
    --v7;
  }
  while ( v7 );
  v8 = this[81];
  if ( v8 )
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v8 + 28))(v8);
  v9 = this[82];
  if ( v9 )
    result = (*(int (**)(void))(*(_DWORD *)v9 + 28))();
  return result;
}

//----- (00453E10) --------------------------------------------------------
int __thiscall sub_453E10(_DWORD *this)
{
  char *v1; // esi
  unsigned int v2; // edi
  int v3; // ebx
  int v4; // ebp
  _DWORD *v5; // eax
  int v6; // eax
  int *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  int *v10; // eax
  int v11; // eax
  int *v12; // eax
  int v13; // eax
  int *v14; // ecx
  int *v15; // eax
  int v16; // eax
  int *v17; // eax
  int result; // eax
  int v20; // [esp+20h] [ebp-A88h]
  int v21[640]; // [esp+24h] [ebp-A84h] BYREF
  int *v22; // [esp+A24h] [ebp-84h]
  char v23[128]; // [esp+A28h] [ebp-80h] BYREF

  memset(v21, 0, sizeof(v21));
  v1 = (char *)&unk_4B8358;
  do
  {
    v2 = *((_DWORD *)v1 - 1);
    v3 = *((_DWORD *)v1 - 2);
    v4 = *(_DWORD *)v1;
    v20 = *((_DWORD *)v1 + 1);
    if ( sub_454C30(v21, v2) || !v22 )
    {
      v5 = 0;
    }
    else
    {
      *v22 = v2;
      v5 = v22 + 1;
    }
    *v5 = v3;
    v1 += 16;
    v5[1] = 0;
    v5[2] = v4;
    v5[3] = v20;
  }
  while ( v1 < aI );
  sub_412FA0(-2147483646, 0, (int)v23, (int)v21, 0);
  sub_412FA0(-2147483647, 0, (int)v23, (int)v21, 0);
  v6 = 103;
  if ( v21[515] == -1807319176 )
  {
LABEL_11:
    v7 = &v21[5 * v6 + 1];
    if ( v7 )
    {
      v8 = this;
      this[5] = v7[1];
      goto LABEL_15;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( !v21[5 * v6] )
      {
        v22 = &v21[5 * v6];
        goto LABEL_14;
      }
      v6 = ((_BYTE)v6 + 1) & 0x7F;
      if ( v6 == 103 )
        break;
      if ( v21[5 * v6] == -1807319176 )
        goto LABEL_11;
    }
    v22 = 0;
  }
LABEL_14:
  v8 = this;
LABEL_15:
  v9 = 104;
  if ( v21[520] == 1564824291 )
  {
LABEL_23:
    v10 = &v21[5 * v9 + 1];
    if ( v10 )
      v8[1] = v10[1];
  }
  else
  {
    while ( 1 )
    {
      if ( !v21[5 * v9] )
      {
        v22 = &v21[5 * v9];
        goto LABEL_25;
      }
      v9 = ((_BYTE)v9 + 1) & 0x7F;
      if ( v9 == 104 )
        break;
      if ( v21[5 * v9] == 1564824291 )
        goto LABEL_23;
    }
    v22 = 0;
  }
LABEL_25:
  v11 = 35;
  if ( v21[175] == -1543654745 )
  {
LABEL_29:
    v12 = &v21[5 * v11 + 1];
    if ( v12 )
      v8[13] = v12[1];
  }
  else
  {
    while ( 1 )
    {
      if ( !v21[5 * v11] )
      {
        v22 = &v21[5 * v11];
        goto LABEL_31;
      }
      v11 = ((_BYTE)v11 + 1) & 0x7F;
      if ( v11 == 35 )
        break;
      if ( v21[5 * v11] == -1543654745 )
        goto LABEL_29;
    }
    v22 = 0;
  }
LABEL_31:
  v13 = 39;
  if ( v21[195] != 1790600800 )
  {
    while ( v21[5 * v13] )
    {
      v13 = ((_BYTE)v13 + 1) & 0x7F;
      if ( v13 == 39 )
      {
LABEL_44:
        v22 = 0;
        goto LABEL_47;
      }
      if ( v21[5 * v13] == 1790600800 )
        goto LABEL_35;
    }
    goto LABEL_43;
  }
LABEL_35:
  v14 = &v21[5 * v13 + 1];
  if ( !v14 )
    goto LABEL_47;
  v13 = 13;
  if ( v21[65] != 1910586287 )
  {
    while ( v21[5 * v13] )
    {
      v13 = ((_BYTE)v13 + 1) & 0x7F;
      if ( v13 == 13 )
        goto LABEL_44;
      if ( v21[5 * v13] == 1910586287 )
        goto LABEL_45;
    }
LABEL_43:
    v22 = &v21[5 * v13];
    goto LABEL_47;
  }
LABEL_45:
  v15 = &v21[5 * v13 + 1];
  if ( v15 )
    v8[6] = v14[1] ^ v15[1];
LABEL_47:
  v16 = 57;
  if ( v21[285] == 1999537002 )
  {
LABEL_51:
    v17 = &v21[5 * v16 + 1];
    if ( v17 )
      v8[11] = v17[1];
  }
  else
  {
    while ( 1 )
    {
      if ( !v21[5 * v16] )
      {
        v22 = &v21[5 * v16];
        goto LABEL_53;
      }
      v16 = ((_BYTE)v16 + 1) & 0x7F;
      if ( v16 == 57 )
        break;
      if ( v21[5 * v16] == 1999537002 )
        goto LABEL_51;
    }
    v22 = 0;
  }
LABEL_53:
  result = sub_454C30(v21, 0x46E523Bu);
  if ( result )
    v8[12] = *(_DWORD *)(result + 4);
  return result;
}

//----- (00454100) --------------------------------------------------------
int __thiscall sub_454100(_DWORD *this)
{
  _DWORD *v2; // edi
  int v3; // ecx
  int v4; // ecx
  long double v5; // st7
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // ecx
  int result; // eax
  _DWORD *v10; // ebx
  long double v11; // st7
  int v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]
  int v15; // [esp+18h] [ebp-4h]

  v2 = *(_DWORD **)(this[3] + 2168);
  if ( v2[22] != this[46] )
  {
    v3 = *(_DWORD *)(v2[3] + 120528);
    if ( !v3
      || v2[1] >= 0xFA0000u
      || v2[2] >= 0xFA0000u
      || *(unsigned __int8 *)(v3 + ((v2[2] / 16000) << 10) + v2[1] / 16000) != 171 )
    {
      v4 = *(_DWORD *)(this[3] + 12224);
      v12 = v2[1] - this[1];
      if ( (int)abs32(v12) / 1000 < v4 && (int)abs32(v2[2] - this[2]) / 1000 < v4 )
      {
        v5 = atan2((double)v12, (double)(v2[2] - this[2]));
        v2[4] = (__int64)(sin(v5) * (double)*(int *)(this[3] + 11844));
        *(_DWORD *)(*(_DWORD *)(this[3] + 2168) + 20) = (__int64)(cos(v5) * (double)*(int *)(this[3] + 11844));
        v6 = -2013126493;
        v7 = 234;
        do
          v6 ^= *(_DWORD *)&aBullet[4 * v7-- - 380436];
        while ( v7 );
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)((char *)this + v6 + 2756) + 2168) + 872) = *(_DWORD *)(this[3] + 11924);
      }
    }
  }
  v8 = (_DWORD *)this[3];
  v14 = 0;
  result = v8[1908] + v8[1909];
  if ( result > 0 )
  {
    v15 = 2173;
    do
    {
      v10 = (_DWORD *)v8[v15];
      v13 = v10[2] - this[2];
      if ( v10[46] != this[46] && (int)abs32(v10[1] - this[1]) / 1000 < v8[3056] && (int)abs32(v13) / 1000 < v8[3056] )
      {
        v11 = atan2((double)(v10[1] - this[1]), (double)v13);
        v10[4] = (__int64)(sin(v11) * (double)(int)v8[2961]);
        v10[5] = (__int64)(cos(v11) * (double)*(int *)(this[3] + 11844));
        v10[48] = 0;
      }
      result = v14 + 1;
      ++v15;
      v8 = (_DWORD *)this[3];
      v14 = result;
    }
    while ( result < v8[1908] + v8[1909] );
  }
  return result;
}

//----- (00454360) --------------------------------------------------------
int __thiscall sub_454360(int this)
{
  int result; // eax

  memset((void *)(this + 4), 0, 0x34u);
  memset((void *)(this + 56), 0, 0x1Cu);
  *(_WORD *)(this + 84) = 0;
  result = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 356) = 0;
  return result;
}

//----- (00454390) --------------------------------------------------------
int __thiscall sub_454390(_DWORD *this, int a2)
{
  int result; // eax
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // edi
  int v6; // edx

  result = this[4];
  if ( result <= 0 )
  {
    result = this[6];
    if ( result <= 0 )
    {
      v3 = (_DWORD *)this[3];
      result = this[1];
      v4 = this[2];
      if ( result >= v3[359] && result < v3[361] && v4 >= v3[360] && v4 < v3[362] )
      {
        v5 = this[1] / 1000;
        v6 = this[2] / 1000;
        LOBYTE(this) = this[5] == v3[28119] + v3[28120];
        result = (*(int (__thiscall **)(int, int, int, _DWORD *))(*(_DWORD *)a2 + 196))(a2, v5, v6, this);
      }
    }
  }
  return result;
}

//----- (00454430) --------------------------------------------------------
bool __thiscall sub_454430(_DWORD *this, char a2)
{
  _DWORD *v3; // ebx
  int v4; // ecx
  int v5; // esi
  __int64 v6; // rax
  __int64 v7; // rax
  bool v8; // cc
  int v9; // eax
  int v10; // ecx
  bool result; // al
  int v12; // edi
  int v13; // [esp+Ch] [ebp-8h]
  _DWORD *v14; // [esp+10h] [ebp-4h]

  v13 = 0;
  v3 = (_DWORD *)this[3];
  v4 = 1000 * v3[2711];
  if ( (int)v3[1569] <= 0 )
  {
LABEL_16:
    if ( this[110] )
    {
      result = 1;
    }
    else
    {
      v12 = this[209];
      result = v12 && v3[5776] - v12 < v3[3109];
    }
  }
  else
  {
    v14 = v3 + 545;
    while ( 1 )
    {
      v5 = *v14;
      if ( *(_DWORD *)(*v14 + 88) != this[22]
        && *(_DWORD *)(v5 + 92) != 8
        && (*(_BYTE *)(v5 + 96) & 8) != 0
        && !*(_DWORD *)(v5 + 76) )
      {
        v6 = *(_DWORD *)(v5 + 4) - this[1];
        if ( (int)((HIDWORD(v6) ^ v6) - HIDWORD(v6)) < v4 )
        {
          v7 = *(_DWORD *)(v5 + 8) - this[2];
          if ( (int)((HIDWORD(v7) ^ v7) - HIDWORD(v7)) < v4 )
            break;
        }
      }
      v8 = ++v13 < v3[1569];
      ++v14;
      if ( !v8 )
        goto LABEL_16;
    }
    if ( a2 )
    {
      v9 = 1083317623;
      v10 = 228;
      do
        v9 ^= (unsigned int)*(&off_4A8328 + v10-- - 91482);
      while ( v10 );
      (*(void (**)(_DWORD, int, int, char *, ...))(**(_DWORD **)((char *)this + v9 + 59508) + 388))(
        *(_DWORD *)((char *)this + v9 + 59508),
        300,
        4,
        aAntiwarpEngage,
        v5 + 109);
    }
    result = 1;
  }
  return result;
}
// 4A8328: using guessed type int (__stdcall *off_4A8328)(char);

//----- (00454BE0) --------------------------------------------------------
int __thiscall sub_454BE0(int *this, int a2, int a3, char a4)
{
  int result; // eax

  if ( !a4 || (result = this[2548] / 32, (result & 1) == 0) )
    result = sub_405D00(this[300], a3, a3 + this[18807], a2, this[13072]);
  return result;
}

//----- (00454C30) --------------------------------------------------------
int __thiscall sub_454C30(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edi
  int v4; // edx
  int result; // eax
  _DWORD *v6; // edx

  v2 = ((-25033 * (a2 ^ HIWORD(a2))) >> 9) & 0x7F;
  v3 = v2;
  v4 = this[5 * v2];
  if ( v4 == a2 )
    return (int)&this[5 * v2 + 1];
  while ( 1 )
  {
    if ( !v4 )
    {
      v6 = &this[5 * v2];
      result = 0;
      this[640] = v6;
      return result;
    }
    v2 = ((_BYTE)v2 + 1) & 0x7F;
    if ( v2 == v3 )
      break;
    v4 = this[5 * v2];
    if ( v4 == a2 )
      return (int)&this[5 * v2 + 1];
  }
  this[640] = 0;
  return 0;
}

//----- (00454CB0) --------------------------------------------------------
BOOL __thiscall sub_454CB0(_DWORD *this)
{
  return *this >= this[2] || this[1] >= this[3];
}

//----- (00454CD0) --------------------------------------------------------
int __thiscall sub_454CD0(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[3] = 0;
  this[2] = 0;
  this[1] = 0;
  *this = 0;
  return result;
}

//----- (00454CE0) --------------------------------------------------------
_DWORD *__thiscall sub_454CE0(_DWORD *this, int *a2)
{
  _DWORD *result; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx

  result = this;
  v3 = this[2];
  if ( *this < v3 )
  {
    v4 = this[1];
    if ( v4 < this[3] )
    {
      v5 = *a2;
      if ( *a2 >= a2[2] || a2[1] >= a2[3] )
      {
        this[3] = 0;
        this[2] = 0;
        this[1] = 0;
        *this = 0;
      }
      else
      {
        if ( *this < v5 )
          *this = v5;
        v6 = a2[1];
        if ( v4 < v6 )
          this[1] = v6;
        v7 = a2[2];
        if ( v3 > v7 )
          this[2] = v7;
        v8 = a2[3];
        if ( this[3] > v8 )
          this[3] = v8;
        if ( this[2] < *a2 )
          this[2] = *a2;
        v9 = a2[1];
        if ( this[3] < v9 )
          this[3] = v9;
        v10 = a2[2];
        if ( *this > v10 )
          *this = v10;
        v11 = a2[3];
        if ( result[1] > v11 )
          result[1] = v11;
      }
    }
  }
  return result;
}

//----- (00454D90) --------------------------------------------------------
void __thiscall CVecCtrlMob::MoveContext::FlyContext::FlyContext(CVecCtrlMob::MoveContext::FlyContext *this, SECPOINT *e, TSecType<int> *d, TSecType<long> *a, TSecType<long> *c)
{
  *(_DWORD *)this = e;
  *((_DWORD *)this + 1) = d;
  *((_DWORD *)this + 2) = a;
  *((_DWORD *)this + 3) = c;
}

//----- (00454F80) --------------------------------------------------------
void __thiscall sub_454F80(_DWORD *this, unsigned int a2)
{
  int v2; // eax

  v2 = this[256];
  if ( v2 >= 256 )
  {
    sub_40B7E0(a2);
  }
  else
  {
    this[v2] = a2;
    ++this[256];
  }
}

//----- (00455080) --------------------------------------------------------
int __thiscall sub_455080(_DWORD *this)
{
  _DWORD *v1; // ebx
  int v2; // ebp
  int result; // eax
  _DWORD **v4; // edi
  _DWORD *v5; // esi

  v1 = this;
  v2 = 0;
  result = this[256];
  if ( result <= 0 )
  {
    this[256] = 0;
  }
  else
  {
    v4 = (_DWORD **)this;
    do
    {
      v5 = *v4;
      if ( *v4 )
      {
        *v5 = &off_4AC354;
        sub_441B30((int)v5, 0);
        sub_40B7E0((unsigned int)v5);
      }
      *v4 = 0;
      result = v1[256];
      ++v2;
      ++v4;
    }
    while ( v2 < result );
    v1[256] = 0;
  }
  return result;
}
// 4AC354: using guessed type int (*off_4AC354)();

//----- (00455180) --------------------------------------------------------
int __thiscall sub_455180(unsigned int *this)
{
  unsigned int *v1; // edi
  int v2; // ebx
  int result; // eax
  unsigned int *v4; // esi

  v1 = this;
  v2 = 0;
  result = this[256];
  if ( result <= 0 )
  {
    this[256] = 0;
  }
  else
  {
    v4 = this;
    do
    {
      sub_40B7E0(*v4);
      *v4 = 0;
      result = v1[256];
      ++v2;
      ++v4;
    }
    while ( v2 < result );
    v1[256] = 0;
  }
  return result;
}

//----- (00455280) --------------------------------------------------------
int __fastcall sub_455280(_DWORD *a1, int a2)
{
  return *a1 / a2;
}

//----- (004552A0) --------------------------------------------------------
int __fastcall sub_4552A0(_DWORD *a1, int a2)
{
  return a2 * *a1;
}

//----- (004552B0) --------------------------------------------------------
__int64 __fastcall sub_4552B0(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // rax

  LODWORD(result) = *a2 + *a1;
  HIDWORD(result) = a2[1] + a1[1];
  return result;
}

//----- (004552D0) --------------------------------------------------------
int __userpurge sub_4552D0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax
  int v5; // edi
  void *v6; // edx
  int v7; // edi
  int v9[4]; // [esp+Ch] [ebp-10h] BYREF

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 >= *(_DWORD *)(a1 + 4) )
  {
    if ( v4 >= 8 )
      v5 = v4 >= 32 ? 32 : 8;
    else
      v5 = 4;
    sub_40B780(16 * (v4 + v5), (void **)a1, a2);
    *(_DWORD *)(a1 + 4) += v5;
  }
  sub_46CAB0(
    *(_DWORD *)a1 + 16 * (a3 + 1),
    (_BYTE *)(*(_DWORD *)a1 + 16 * a3),
    16 * (*(_DWORD *)(a1 + 8) + 0xFFFFFFF * a3));
  v6 = *(void **)a1;
  ++*(_DWORD *)(a1 + 8);
  v9[0] = 0;
  v9[1] = 0;
  sub_46CAB0((unsigned int)v6 + 16 * a3, v9, 0x10u);
  v7 = *(_DWORD *)a1 + 16 * a3;
  sub_40C9D0((int)v9, a2, 0);
  return v7;
}

//----- (00455390) --------------------------------------------------------
int __thiscall sub_455390(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (004553B0) --------------------------------------------------------
int __thiscall sub_4553B0(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (004553D0) --------------------------------------------------------
int __thiscall sub_4553D0(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (004553F0) --------------------------------------------------------
int __thiscall sub_4553F0(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00455410) --------------------------------------------------------
int __thiscall sub_455410(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00455430) --------------------------------------------------------
int __thiscall sub_455430(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (00455450) --------------------------------------------------------
void __usercall sub_455450(int a1@<ecx>, int a2@<ebp>)
{
  int i; // edi

  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
    sub_40C9D0(*(_DWORD *)a1 + 8 * i, a2, 0);
  sub_40B7D0(*(void **)a1);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
}

//----- (00455490) --------------------------------------------------------
int __thiscall sub_455490(int this)
{
  int result; // eax

  sub_40B7D0(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (004554B0) --------------------------------------------------------
void __usercall sub_4554B0(int a1@<ecx>, int a2@<ebp>)
{
  sub_40C9D0(a1, a2, 0);
}

//----- (004554C0) --------------------------------------------------------
int __userpurge sub_4554C0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax
  int v5; // esi
  unsigned int v7; // [esp-18h] [ebp-C0h]
  char v8[156]; // [esp+Ch] [ebp-9Ch] BYREF

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 >= *(_DWORD *)(a1 + 4) )
  {
    if ( v4 >= 8 )
      v5 = v4 >= 32 ? 32 : 8;
    else
      v5 = 4;
    sub_40B780(156 * (v5 + v4), (void **)a1, a2);
    *(_DWORD *)(a1 + 4) += v5;
  }
  sub_46CAB0(*(_DWORD *)a1 + 156 * (a3 + 1), (_BYTE *)(*(_DWORD *)a1 + 156 * a3), 156 * *(_DWORD *)(a1 + 8) - 156 * a3);
  v7 = *(_DWORD *)a1 + 156 * a3;
  ++*(_DWORD *)(a1 + 8);
  sub_46CAB0(v7, v8, 0x9Cu);
  return *(_DWORD *)a1 + 156 * a3;
}

//----- (00455580) --------------------------------------------------------
int __userpurge sub_455580@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax
  int v5; // edi
  char v7[4]; // [esp+Ch] [ebp-4h] BYREF

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 >= *(_DWORD *)(a1 + 4) )
  {
    if ( v4 >= 8 )
      v5 = v4 >= 32 ? 32 : 8;
    else
      v5 = 4;
    sub_40B780(4 * (v4 + v5), (void **)a1, a2);
    *(_DWORD *)(a1 + 4) += v5;
  }
  sub_46CAB0(*(_DWORD *)a1 + 4 * a3 + 4, (_BYTE *)(*(_DWORD *)a1 + 4 * a3), 4 * (*(_DWORD *)(a1 + 8) + 0x3FFFFFFF * a3));
  ++*(_DWORD *)(a1 + 8);
  sub_46CAB0(*(_DWORD *)a1 + 4 * a3, v7, 4u);
  return *(_DWORD *)a1 + 4 * a3;
}

//----- (00455620) --------------------------------------------------------
int __userpurge sub_455620@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // eax
  int v5; // edi
  char v7[164]; // [esp+Ch] [ebp-A4h] BYREF

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 >= *(_DWORD *)(a1 + 4) )
  {
    if ( v4 >= 8 )
      v5 = v4 >= 32 ? 32 : 8;
    else
      v5 = 4;
    sub_40B780(164 * (v5 + v4), (void **)a1, a2);
    *(_DWORD *)(a1 + 4) += v5;
  }
  sub_46CAB0(
    *(_DWORD *)a1 + 4 * (a3 + 8 * (5 * a3 + 5) + 1),
    (_BYTE *)(*(_DWORD *)a1 + 164 * a3),
    164 * *(_DWORD *)(a1 + 8) - 164 * a3);
  ++*(_DWORD *)(a1 + 8);
  sub_46CAB0(*(_DWORD *)a1 + 164 * a3, v7, 0xA4u);
  return *(_DWORD *)a1 + 164 * a3;
}

//----- (004556D0) --------------------------------------------------------
unsigned int __thiscall sub_4556D0(int this, const void *a2, int a3, int a4, _DWORD *a5)
{
  char *v5; // eax
  int *v6; // edi
  int v7; // ebp
  int v8; // esi
  unsigned int i; // ecx
  int v10; // edx
  unsigned int result; // eax
  unsigned int v12; // edx
  char v14[128]; // [esp+10h] [ebp-B00h] BYREF
  int v15[32]; // [esp+90h] [ebp-A80h] BYREF
  int v16[640]; // [esp+110h] [ebp-A00h] BYREF

  qmemcpy(v14, a2, 128 - (a4 != 0));
  if ( a4 )
    v14[127] = 1;
  v5 = v14;
  v6 = v15;
  v7 = 32;
  do
  {
    v8 = 0;
    for ( i = 0; i < 0x20; i += 8 )
    {
      v10 = (unsigned __int8)*v5 << i;
      v8 |= v10;
      ++v5;
    }
    *v6++ = v8;
    --v7;
  }
  while ( v7 );
  if ( *(int *)(this + 124) < 0 )
    sub_401520(0x20u, v15, v16, a5, (unsigned int *)this);
  result = 0;
  do
  {
    v12 = (unsigned int)v15[result >> 2] >> (8 * (result & 3));
    *(_BYTE *)(++result + a3 - 1) = v12;
  }
  while ( result < (unsigned int)(a4 != 0) + 127 );
  return result;
}
// 455784: conditional instruction was optimized away because of 'edx.4<100u'

//----- (004557C0) --------------------------------------------------------
unsigned int __thiscall sub_4557C0(int this, const void *a2, int a3, int a4, _DWORD *a5)
{
  char *v5; // eax
  int *v6; // edi
  int v7; // ebp
  int v8; // esi
  unsigned int i; // ecx
  int v10; // edx
  unsigned int result; // eax
  unsigned int v12; // edx
  char v14[64]; // [esp+10h] [ebp-580h] BYREF
  int v15[16]; // [esp+50h] [ebp-540h] BYREF
  int v16[320]; // [esp+90h] [ebp-500h] BYREF

  qmemcpy(v14, a2, 64 - (a4 != 0));
  if ( a4 )
    v14[63] = 1;
  v5 = v14;
  v6 = v15;
  v7 = 16;
  do
  {
    v8 = 0;
    for ( i = 0; i < 0x20; i += 8 )
    {
      v10 = (unsigned __int8)*v5 << i;
      v8 |= v10;
      ++v5;
    }
    *v6++ = v8;
    --v7;
  }
  while ( v7 );
  if ( *(int *)(this + 60) < 0 )
    sub_401520(0x10u, v15, v16, a5, (unsigned int *)this);
  result = 0;
  do
  {
    v12 = (unsigned int)v15[result >> 2] >> (8 * (result & 3));
    *(_BYTE *)(++result + a3 - 1) = v12;
  }
  while ( result < (unsigned int)(a4 != 0) + 63 );
  return result;
}
// 455868: conditional instruction was optimized away because of 'edx.4<100u'

//----- (004558A0) --------------------------------------------------------
int __thiscall sub_4558A0(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[2];
  if ( v1 >= 8 )
    result = v1 >= 32 ? 32 : 8;
  else
    result = 4;
  return result;
}

//----- (004558C0) --------------------------------------------------------
int __thiscall sub_4558C0(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[2];
  if ( v1 >= 8 )
    result = v1 >= 32 ? 32 : 8;
  else
    result = 4;
  return result;
}

//----- (004558E0) --------------------------------------------------------
int __thiscall sub_4558E0(_DWORD *this)
{
  int v1; // eax
  int v3; // ecx

  v1 = this[2];
  if ( v1 < 8 )
    return 4;
  v3 = (v1 >= 32) - 1;
  LOBYTE(v3) = v3 & 8;
  return v3 + 256;
}

//----- (00455910) --------------------------------------------------------
int __thiscall sub_455910(unsigned __int8 *this)
{
  int v2; // [esp+0h] [ebp-4h] BYREF

  v2 = -1;
  sub_401A70(&v2, this + 10748, 12224);
  return v2;
}

//----- (00455940) --------------------------------------------------------
int __fastcall sub_455940(int a1, unsigned int a2, _DWORD *a3, int a4)
{
  int v5; // eax
  unsigned int *v6; // edi
  __int16 *v7; // ecx
  int v8; // ebx
  unsigned int v9; // edx
  unsigned int v10; // eax
  int v11; // edx
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // edx
  int v17; // eax
  unsigned int *v18; // ecx
  int v19; // edi
  unsigned int v20; // eax
  int result; // eax
  int v22; // [esp+14h] [ebp+4h]

  v5 = -3060 - (_DWORD)a3;
  v6 = a3 + 765;
  v7 = (__int16 *)(a4 + 14);
  v22 = -3060 - (_DWORD)a3;
  v8 = 8;
  while ( 1 )
  {
    LOBYTE(a2) = *((_BYTE *)v7 + 18);
    *(v6 - 1) = (a2 >> 2) & 1;
    v9 = v7[9] & 3;
    *v6 = v9;
    v10 = (unsigned int)&a3[(((unsigned int)v6 + v5) >> 2) + 440];
    if ( (v7[9] & 0x3F8) != 0 )
    {
      LOWORD(v9) = v7[9];
      v11 = (v9 >> 3) & 0x7F;
    }
    else
    {
      v11 = 14;
    }
    v6[1] = v11;
    v12 = (_DWORD *)(v10 + 1668);
    *(v12 - 324) = (unsigned __int16)v7[14];
    *(v12 - 188) = (unsigned __int16)v7[16];
    v12 -= 100;
    *(v12 - 95) = v7[8];
    v12 -= 16;
    *(v12 - 80) = v7[25];
    *(v12 - 156) = HIBYTE(*(_DWORD *)(v7 + 57)) & 3;
    *(v12 - 105) = v7[10];
    *(v12 - 282) = v7[21];
    *(v12 - 100) = *(_DWORD *)(v7 - 5);
    *(v12 - 109) = v7[30];
    v12[2] = (*(_DWORD *)(v7 + 57) >> 20) & 3;
    *(v12 - 4) = (unsigned __int16)v7[2];
    *(v12 - 269) = v7[25];
    *(v12 - 209) = v7[46];
    *(v12 - 96) = v7[45];
    *(v12 - 286) = v7[32];
    *(v12 - 178) = v7[45];
    *(v12 - 188) = v7[43];
    *(v12 - 11) = v7[32];
    *(v12 - 179) = (unsigned __int16)v7[13];
    *(v12 - 83) = *((unsigned __int8 *)v7 + 112);
    *(v12 - 60) = *((unsigned __int8 *)v7 + 96);
    *(v12 - 78) = v7[33];
    *(v12 - 290) = (unsigned __int16)v7[19];
    *(v12 - 288) = *((unsigned __int8 *)v7 + 101);
    *(v12 - 184) = (unsigned __int16)v7[12];
    *(v12 - 185) = v7[37];
    *(v12 - 271) = *((unsigned __int8 *)v7 + 109);
    *(v12 - 187) = *((unsigned __int8 *)v7 + 98);
    v12[6] = *((unsigned __int8 *)v7 + 100);
    *(v12 - 194) = *((unsigned __int8 *)v7 + 105);
    v12 += 31;
    *(v12 - 267) = *((unsigned __int8 *)v7 + 103);
    v12 += 104;
    *(v12 - 309) = *(v7 - 1);
    *(v12 - 334) = (unsigned __int16)v7[13];
    *(v12 - 390) = (*(_DWORD *)(v7 + 57) >> 10) & 3;
    *(v12 - 412) = *((unsigned __int8 *)v7 + 108);
    v12 -= 93;
    *(v12 - 116) = v7[35];
    *(v12 - 212) = v7[33];
    *(v12 - 72) = (*(_DWORD *)(v7 + 57) >> 18) & 3;
    *(v12 - 76) = *v7;
    *(v12 - 175) = *((unsigned __int8 *)v7 + 111);
    *(v12 - 317) = v7[4];
    *(v12 - 298) = (*(_DWORD *)(v7 + 57) >> 18) & 3;
    *(v12 - 273) = *((unsigned __int8 *)v7 + 102);
    *(v12 - 252) = v7[38];
    *(v12 - 184) = *((unsigned __int8 *)v7 + 104);
    *(v12 - 274) = *((unsigned __int8 *)v7 + 106);
    *(v12 - 41) = (*(_DWORD *)(v7 + 57) >> 26) & 1;
    *(v12 - 58) = v7[21];
    *(v12 - 146) = v7[28];
    *(v12 - 177) = v7[7];
    *(v12 - 106) = (unsigned __int8)HIBYTE(v7[57]) >> 6;
    *(v12 - 213) = (*(_DWORD *)(v7 + 57) >> 22) & 3;
    *(v12 - 70) = *((unsigned __int8 *)v7 + 107);
    *(v12 - 170) = (*(_DWORD *)(v7 + 57) >> 20) & 3;
    *(v12 - 137) = v7[27];
    *(v12 - 210) = v7[44];
    *(v12 - 157) = *(_DWORD *)(v7 - 5);
    *(v12 - 23) = (unsigned __int16)v7[5];
    *(v12 - 270) = (unsigned __int16)v7[2];
    *(v12 - 150) = *((unsigned __int8 *)v7 + 96);
    v12 -= 43;
    *(v12 - 250) = (*(_DWORD *)(v7 + 57) >> 28) & 1;
    v12 -= 161;
    *(v12 - 64) = v7[22];
    v12 += 356;
    *(v12 - 183) = v7[37];
    *(v12 - 251) = (*(_DWORD *)(v7 + 57) >> 5) & 0x1F;
    *(v12 - 325) = (*(_DWORD *)(v7 + 57) >> 5) & 0x1F;
    *(v12 - 397) = *((unsigned __int8 *)v7 + 96);
    *(v12 - 324) = v7[34];
    *(v12 - 265) = (unsigned __int16)v7[1];
    *(v12 - 259) = (unsigned __int16)v7[5];
    *(v12 - 282) = v7[43];
    *(v12 - 344) = *((unsigned __int8 *)v7 + 102);
    *(v12 - 257) = v7[39];
    *(v12 - 269) = *((unsigned __int8 *)v7 + 97);
    *(v12 - 250) = v7[7];
    *(v12 - 209) = v7[27];
    *(v12 - 308) = (unsigned __int16)v7[23];
    *(v12 - 335) = *v7;
    *(v12 - 304) = v7[20];
    *(v12 - 389) = v7[34];
    *(v12 - 231) = v7[8];
    *(v12 - 356) = (unsigned __int16)v7[19];
    *(v12 - 247) = v7[20];
    *(v12 - 481) = *((unsigned __int8 *)v7 + 105);
    *(v12 - 359) = v7[31];
    *(v12 - 177) = v7[40];
    *(v12 - 456) = v7[10];
    *(v12 - 423) = (unsigned __int16)v7[12];
    *(v12 - 234) = (*(_DWORD *)(v7 + 57) >> 28) & 1;
    v12 -= 446;
    v12[56] = v7[32];
    ++v12;
    v12[229] = v7[20];
    v12 += 162;
    v12[65] = v7[42];
    v12[39] = v7[41];
    *(v12 - 71) = *((unsigned __int8 *)v7 + 110);
    *(v12 - 102) = (unsigned __int16)v7[24];
    *(v12 - 13) = (unsigned __int16)v7[14];
    *(v12 - 38) = v7[39];
    v12[75] = (*(_DWORD *)(v7 + 57) >> 12) & 3;
    *(v12 - 51) = *((unsigned __int8 *)v7 + 98);
    *(v12 - 97) = *((unsigned __int8 *)v7 + 112);
    v12[87] = v7[26];
    *(v12 - 205) = v7[4];
    *(v12 - 47) = (unsigned __int16)v7[11];
    v12[70] = *((unsigned __int8 *)v7 + 106);
    v12[77] = HIBYTE(*(_DWORD *)(v7 + 57)) & 3;
    v12[16] = (unsigned __int16)v7[15];
    *(v12 - 163) = (*(_DWORD *)(v7 + 57) >> 12) & 3;
    v12[69] = *v7;
    *(v12 - 77) = *(_DWORD *)(v7 - 3);
    *(v12 - 100) = v7[37];
    *(v12 - 206) = *((unsigned __int8 *)v7 + 99);
    v12[80] = (unsigned __int16)v7[5];
    *(v12 - 5) = (unsigned __int16)v7[14];
    *(v12 - 2) = v7[25];
    *(v12 - 78) = *((unsigned __int8 *)v7 + 99);
    *(v12 - 159) = v7[30];
    *(v12 - 3) = *((unsigned __int8 *)v7 + 108);
    v12[62] = *((unsigned __int8 *)v7 + 98);
    v12 -= 185;
    v12[205] = v7[36];
    v12 += 12;
    v12[93] = v7[22];
    v12[216] = (*(_DWORD *)(v7 + 57) >> 10) & 3;
    v12[41] = v7[30];
    v12[85] = v7[6];
    v12[239] = *v7;
    v12[80] = (*(_DWORD *)(v7 + 57) >> 5) & 0x1F;
    v12[70] = *((unsigned __int8 *)v7 + 112);
    v12[20] = *((unsigned __int8 *)v7 + 99);
    v12[280] = *((unsigned __int8 *)v7 + 102);
    v12[173] = HIWORD(*(_DWORD *)(v7 + 57)) & 3;
    *(v12 - 35) = v7[26];
    *(v12 - 14) = *((unsigned __int8 *)v7 + 109);
    v12[254] = *((unsigned __int8 *)v7 + 111);
    v12[241] = *((unsigned __int8 *)v7 + 111);
    *(v12 - 11) = v7[44];
    v12[105] = (*(_DWORD *)(v7 + 57) >> 22) & 3;
    v12[44] = (unsigned __int16)v7[16];
    v12[109] = (unsigned __int16)v7[18];
    *(v12 - 21) = v7[29];
    v12[257] = v7[45];
    *(v12 - 29) = HIWORD(*(_DWORD *)(v7 + 57)) & 3;
    v12[125] = (unsigned __int16)v7[15];
    v12 += 267;
    *(v12 - 227) = v7[32];
    *(v12 - 235) = v7[39];
    *(v12 - 128) = v7[38];
    *(v12 - 95) = v7[41];
    *(v12 - 63) = v7[36];
    *(v12 - 177) = v7[31];
    *(v12 - 46) = (unsigned __int16)v7[3];
    *(v12 - 248) = (unsigned __int16)v7[18];
    *(v12 - 229) = (*(_DWORD *)(v7 + 57) >> 20) & 3;
    v12 += 32;
    *(v12 - 322) = v7[10];
    v12 -= 72;
    *(v12 - 211) = v7[47];
    *(v12 - 41) = (*(_DWORD *)(v7 + 57) >> 28) & 1;
    *(v12 - 64) = (unsigned __int8)HIBYTE(v7[57]) >> 6;
    *(v12 - 225) = (unsigned __int16)v7[1];
    *(v12 - 245) = *(_DWORD *)(v7 - 3);
    *(v12 - 162) = *((unsigned __int8 *)v7 + 101);
    v12 -= 185;
    v12[168] = v7[36];
    v12[182] = (unsigned __int16)v7[16];
    *(v12 - 13) = *((unsigned __int8 *)v7 + 110);
    v12[172] = HIWORD(*(_DWORD *)(v7 + 57)) & 3;
    *(v12 - 3) = *((unsigned __int8 *)v7 + 110);
    v12[45] = v7[47];
    *(v12 - 18) = v7[42];
    v12[15] = (*(_DWORD *)(v7 + 57) >> 27) & 1;
    v12[184] = *((unsigned __int8 *)v7 + 109);
    v12[232] = (*(_DWORD *)(v7 + 57) >> 18) & 3;
    v12[59] = (unsigned __int16)v7[1];
    v12[136] = (*(_DWORD *)(v7 + 57) >> 27) & 1;
    v12[16] = *((unsigned __int8 *)v7 + 101);
    v12[66] = (unsigned __int16)v7[2];
    *(v12 - 41) = *((unsigned __int8 *)v7 + 107);
    v12[187] = (unsigned __int16)v7[18];
    v12[86] = *(_DWORD *)(v7 + 57) & 0x1F;
    --v12;
    v12[96] = v7[44];
    v12[166] = (*(_DWORD *)(v7 + 57) >> 27) & 1;
    v12[215] = *((unsigned __int8 *)v7 + 109);
    v12 += 195;
    *(v12 - 16) = *(v7 - 1);
    *(v12 - 91) = (unsigned __int16)v7[19];
    v12 += 35;
    *(v12 - 135) = v7[21];
    *(v12 - 153) = (unsigned __int16)v7[23];
    *(v12 - 250) = *((unsigned __int8 *)v7 + 106);
    *(v12 - 182) = *(_DWORD *)(v7 - 5);
    *(v12 - 12) = *((unsigned __int8 *)v7 + 113);
    *(v12 - 106) = *((unsigned __int8 *)v7 + 97);
    *(v12 - 221) = (unsigned __int16)v7[19];
    *(v12 - 131) = v7[20];
    *(v12 - 267) = v7[35];
    *(v12 - 68) = (*(_DWORD *)(v7 + 57) >> 10) & 3;
    *(v12 - 185) = v7[28];
    *(v12 - 91) = v7[29];
    *(v12 - 310) = *(_DWORD *)(v7 + 57) & 0x1F;
    *(v12 - 234) = v7[46];
    *(v12 - 141) = v7[34];
    *(v12 - 35) = *((unsigned __int8 *)v7 + 105);
    *(v12 - 172) = *(v7 - 1);
    *(v12 - 216) = *((unsigned __int8 *)v7 + 107);
    *(v12 - 253) = *((unsigned __int8 *)v7 + 100);
    *(v12 - 287) = *((unsigned __int8 *)v7 + 113);
    *(v12 - 222) = v7[21];
    *(v12 - 133) = v7[40];
    *(v12 - 54) = (unsigned __int16)v7[12];
    v12 -= 304;
    v12[79] = (*(_DWORD *)(v7 + 57) >> 26) & 1;
    v12[277] = (unsigned __int16)v7[11];
    v12[182] = *((unsigned __int8 *)v7 + 108);
    v12[177] = *((unsigned __int8 *)v7 + 104);
    v12[228] = *((unsigned __int8 *)v7 + 97);
    v12 += 260;
    *(v12 - 199) = v7[40];
    *(v12 - 229) = v7[38];
    *(v12 - 66) = (unsigned __int16)v7[11];
    v12[22] = (unsigned __int16)v7[16];
    v12[40] = v7[47];
    *(v12 - 200) = v7[25];
    v12[25] = v7[43];
    *(v12 - 58) = (unsigned __int16)v7[14];
    *(v12 - 180) = *(_DWORD *)(v7 - 3);
    *(v12 - 104) = v7[36];
    v12[43] = v7[6];
    *(v12 - 219) = (unsigned __int16)v7[12];
    *(v12 - 8) = v7[45];
    v12[49] = HIBYTE(*(_DWORD *)(v7 + 57)) & 3;
    *(v12 - 123) = (*(_DWORD *)(v7 + 57) >> 26) & 1;
    v12[42] = v7[42];
    *(v12 - 192) = v7[35];
    *(v12 - 155) = *((unsigned __int8 *)v7 + 105);
    *(v12 - 124) = (unsigned __int16)v7[24];
    v12[3] = v7[8];
    *(v12 - 113) = *((unsigned __int8 *)v7 + 110);
    *(v12 - 205) = *((unsigned __int8 *)v7 + 96);
    *(v12 - 77) = (unsigned __int16)v7[15];
    *(v12 - 129) = *((unsigned __int8 *)v7 + 113);
    v12 += 161;
    *(v12 - 273) = v7[29];
    v12 -= 6;
    *(v12 - 164) = v7[8];
    *(v12 - 367) = (unsigned __int16)v7[23];
    v12 -= 64;
    *(v12 - 349) = v7[27];
    *(v12 - 126) = *((unsigned __int8 *)v7 + 112);
    *(v12 - 262) = (*(_DWORD *)(v7 + 57) >> 28) & 1;
    *(v12 - 345) = *((unsigned __int8 *)v7 + 103);
    v12 -= 355;
    v12[27] = v7[38];
    v12[98] = v7[4];
    v12[15] = (unsigned __int16)v7[17];
    v12[213] = *(_DWORD *)(v7 + 57) & 0x1F;
    v12[32] = v7[30];
    v12[88] = v7[7];
    v12[153] = v7[31];
    v12[156] = v7[26];
    v12[20] = v7[39];
    v12[222] = *((unsigned __int8 *)v7 + 97);
    *(v12 - 1) = (*(_DWORD *)(v7 + 57) >> 18) & 3;
    v12[214] = (*(_DWORD *)(v7 + 57) >> 5) & 0x1F;
    v12[218] = v7[7];
    v12[150] = (unsigned __int16)v7[2];
    v12[237] = v7[35];
    v12[18] = v7[40];
    v12[36] = HIBYTE(*(_DWORD *)(v7 + 57)) & 3;
    v12[178] = v7[22];
    v12[34] = v7[26];
    v12[82] = v7[34];
    v12[299] = *((unsigned __int8 *)v7 + 107);
    v12[80] = v7[43];
    v12[252] = (unsigned __int16)v7[11];
    v12[79] = (unsigned __int16)v7[24];
    v12[33] = *((unsigned __int8 *)v7 + 100);
    v12[298] = *((unsigned __int8 *)v7 + 103);
    v12[3] = *((unsigned __int8 *)v7 + 100);
    v12 += 341;
    *(v12 - 222) = v7[37];
    v12 -= 3;
    *(v12 - 239) = v7[33];
    *(v12 - 278) = (unsigned __int16)v7[3];
    *(v12 - 23) = v7[41];
    *(v12 - 56) = v7[46];
    *(v12 - 126) = *(_DWORD *)(v7 + 57) & 0x1F;
    *(v12 - 142) = *((unsigned __int8 *)v7 + 99);
    *(v12 - 338) = v7[33];
    *(v12 - 24) = *((unsigned __int8 *)v7 + 104);
    *(v12 - 184) = (unsigned __int16)v7[1];
    *(v12 - 307) = (unsigned __int16)v7[24];
    *(v12 - 220) = v7[42];
    *(v12 - 146) = *((unsigned __int8 *)v7 + 104);
    *(v12 - 100) = *(_DWORD *)(v7 - 3);
    *(v12 - 158) = (unsigned __int16)v7[13];
    *(v12 - 145) = v7[47];
    *(v12 - 222) = v7[22];
    *(v12 - 155) = (unsigned __int16)v7[5];
    *(v12 - 105) = (*(_DWORD *)(v7 + 57) >> 22) & 3;
    *(v12 - 35) = v7[28];
    *(v12 - 93) = v7[6];
    *(v12 - 177) = v7[28];
    *(v12 - 190) = (*(_DWORD *)(v7 + 57) >> 10) & 3;
    *(v12 - 284) = (unsigned __int16)v7[3];
    *(v12 - 19) = (*(_DWORD *)(v7 + 57) >> 12) & 3;
    *(v12 - 237) = v7[44];
    v12 -= 335;
    v12[198] = (unsigned __int16)v7[23];
    v12[247] = (*(_DWORD *)(v7 + 57) >> 27) & 1;
    v12[271] = *((unsigned __int8 *)v7 + 102);
    v12[289] = (*(_DWORD *)(v7 + 57) >> 20) & 3;
    v12[228] = (unsigned __int8)HIBYTE(v7[57]) >> 6;
    v12[245] = (*(_DWORD *)(v7 + 57) >> 12) & 3;
    v12[46] = (*(_DWORD *)(v7 + 57) >> 26) & 1;
    v12[185] = *((unsigned __int8 *)v7 + 106);
    v12[267] = (unsigned __int16)v7[15];
    v12 += 126;
    *(v12 - 23) = *(v7 - 1);
    v12 += 236;
    *(v12 - 63) = v7[4];
    *(v12 - 186) = HIWORD(*(_DWORD *)(v7 + 57)) & 3;
    *(v12 - 364) = (unsigned __int16)v7[18];
    *(v12 - 336) = (*(_DWORD *)(v7 + 57) >> 22) & 3;
    *(v12 - 315) = (unsigned __int16)v7[13];
    *(v12 - 97) = (unsigned __int16)v7[17];
    *(v12 - 221) = v7[10];
    *(v12 - 218) = *((unsigned __int8 *)v7 + 101);
    *(v12 - 105) = (unsigned __int16)v7[17];
    *(v12 - 101) = *((unsigned __int8 *)v7 + 111);
    *(v12 - 45) = *((unsigned __int8 *)v7 + 98);
    *(v12 - 303) = *((unsigned __int8 *)v7 + 108);
    *(v12 - 195) = *((unsigned __int8 *)v7 + 103);
    *(v12 - 319) = v7[6];
    *(v12 - 268) = (unsigned __int16)v7[3];
    v12 -= 231;
    v13 = *((unsigned __int8 *)v7 + 113);
    v7 += 72;
    v12[175] = v13;
    v6 += 327;
    v12[174] = *(v7 - 43);
    *(v12 - 49) = *(v7 - 26);
    *(v12 - 94) = (unsigned __int8)HIBYTE(*(v7 - 15)) >> 6;
    *(v12 - 109) = *(v7 - 45);
    v12[187] = *(_DWORD *)(v7 - 77);
    v12[178] = *(v7 - 31);
    --v8;
    *(v12 - 127) = (unsigned __int16)*(v7 - 55);
    a2 = *(v7 - 41);
    *(v12 - 92) = a2;
    if ( !v8 )
      break;
    v5 = v22;
  }
  a3[292] = *(char *)(a4 + 1368);
  a3[146] = *(__int16 *)(a4 + 1354);
  a3[190] = *(unsigned __int8 *)(a4 + 1373);
  a3[112] = *(unsigned __int8 *)(a4 + 1384);
  a3[257] = *(_DWORD *)(a4 + 1200);
  a3[66] = *(char *)(a4 + 1372);
  a3[173] = *(unsigned __int8 *)(a4 + 1390);
  a3[280] = *(__int16 *)(a4 + 1318);
  a3[236] = *(_DWORD *)(a4 + 1200);
  a3[131] = *(unsigned __int8 *)(a4 + 1385);
  a3[330] = *(_DWORD *)(a4 + 1228);
  a3[386] = *(__int16 *)(a4 + 1276);
  a3[285] = *(__int16 *)(a4 + 1340);
  a3[369] = *(__int16 *)(a4 + 1284);
  a3[196] = *(__int16 *)(a4 + 1260);
  a3[44] = *(unsigned __int8 *)(a4 + 1373);
  a3[71] = *(unsigned __int8 *)(a4 + 1380);
  a3[243] = *(__int16 *)(a4 + 1344);
  a3[340] = *(__int16 *)(a4 + 1326);
  a3[136] = *(__int16 *)(a4 + 1352);
  a3[353] = *(_DWORD *)(a4 + 1196);
  a3[307] = *(__int16 *)(a4 + 1278);
  a3[149] = *(_DWORD *)(a4 + 1204);
  a3[276] = *(unsigned __int8 *)(a4 + 1381);
  a3[132] = *(__int16 *)(a4 + 1356);
  a3[75] = *(__int16 *)(a4 + 1282);
  a3[19] = *(__int16 *)(a4 + 1286);
  a3[355] = *(__int16 *)(a4 + 1320);
  a3[273] = *(unsigned __int8 *)(a4 + 1376);
  a3[290] = *(__int16 *)(a4 + 1276);
  a3[28] = *(__int16 *)(a4 + 1306);
  a3[20] = *(unsigned __int8 *)(a4 + 1388);
  a3[370] = *(char *)(a4 + 1368);
  a3[67] = *(unsigned __int8 *)(a4 + 1382);
  a3[382] = *(__int16 *)(a4 + 1334);
  a3[354] = *(__int16 *)(a4 + 1302);
  a3[54] = *(_DWORD *)(a4 + 1180);
  a3[213] = *(__int16 *)(a4 + 1252);
  a3[59] = *(_DWORD *)(a4 + 1224);
  a3[8] = *(__int16 *)(a4 + 1306);
  a3[138] = *(__int16 *)(a4 + 1292);
  a3[107] = *(__int16 *)(a4 + 1322);
  a3[39] = *(_DWORD *)(a4 + 1220);
  a3[119] = *(__int16 *)(a4 + 1270);
  a3[296] = *(unsigned __int8 *)(a4 + 1387);
  a3[151] = *(unsigned __int8 *)(a4 + 1377);
  a3[205] = *(__int16 *)(a4 + 1356);
  a3[264] = *(__int16 *)(a4 + 1332);
  a3[24] = *(__int16 *)(a4 + 1308);
  a3[348] = *(unsigned __int8 *)(a4 + 1383);
  a3[170] = *(unsigned __int8 *)(a4 + 1375);
  a3[116] = *(char *)(a4 + 1368);
  a3[350] = *(char *)(a4 + 1370);
  a3[81] = *(__int16 *)(a4 + 1346);
  a3[110] = *(unsigned __int8 *)(a4 + 1383);
  a3[259] = *(_DWORD *)(a4 + 1168);
  a3[198] = *(__int16 *)(a4 + 1256);
  a3[314] = *(__int16 *)(a4 + 1310);
  a3[218] = *(unsigned __int8 *)(a4 + 1387);
  a3[244] = *(__int16 *)(a4 + 1288);
  a3[6] = *(unsigned __int8 *)(a4 + 1379);
  a3[320] = *(__int16 *)(a4 + 1254);
  a3[263] = *(_DWORD *)(a4 + 1224);
  a3[85] = *(_DWORD *)(a4 + 1208);
  a3[364] = *(__int16 *)(a4 + 1272);
  a3[168] = *(__int16 *)(a4 + 1294);
  a3[247] = *(unsigned __int8 *)(a4 + 1378);
  a3[153] = *(unsigned __int8 *)(a4 + 1388);
  a3[35] = *(__int16 *)(a4 + 1316);
  a3[192] = *(char *)(a4 + 1368);
  a3[106] = *(_DWORD *)(a4 + 1212);
  a3[315] = *(unsigned __int8 *)(a4 + 1391);
  a3[169] = *(_DWORD *)(a4 + 1216);
  a3[323] = *(__int16 *)(a4 + 1328);
  a3[237] = *(__int16 *)(a4 + 1300);
  a3[185] = *(__int16 *)(a4 + 1294);
  a3[100] = *(_DWORD *)(a4 + 1156);
  a3[58] = *(unsigned __int8 *)(a4 + 1390);
  a3[56] = *(unsigned __int8 *)(a4 + 1378);
  a3[195] = *(__int16 *)(a4 + 1270);
  a3[23] = *(_DWORD *)(a4 + 1160);
  a3[94] = *(__int16 *)(a4 + 1312);
  a3[188] = *(__int16 *)(a4 + 1354);
  a3[293] = *(__int16 *)(a4 + 1290);
  a3[210] = *(unsigned __int8 *)(a4 + 1387);
  a3[127] = *(__int16 *)(a4 + 1354);
  a3[96] = *(__int16 *)(a4 + 1304);
  a3[305] = *(unsigned __int8 *)(a4 + 1380);
  a3[47] = *(_DWORD *)(a4 + 1164);
  a3[113] = *(__int16 *)(a4 + 1352);
  a3[281] = *(_DWORD *)(a4 + 1196);
  a3[262] = *(_DWORD *)(a4 + 1196);
  a3[219] = *(__int16 *)(a4 + 1332);
  a3[240] = *(__int16 *)(a4 + 1254);
  a3[362] = *(unsigned __int8 *)(a4 + 1380);
  a3[60] = *(__int16 *)(a4 + 1342);
  a3[227] = *(_DWORD *)(a4 + 1192);
  a3[304] = *(unsigned __int8 *)(a4 + 1385);
  a3[337] = *(__int16 *)(a4 + 1348);
  a3[289] = *(_DWORD *)(a4 + 1196);
  a3[250] = *(__int16 *)(a4 + 1340);
  a3[331] = *(char *)(a4 + 1369);
  a3[199] = *(__int16 *)(a4 + 1268);
  a3[101] = *(__int16 *)(a4 + 1292);
  a3[212] = *(unsigned __int8 *)(a4 + 1382);
  a3[61] = *(__int16 *)(a4 + 1296);
  a3[70] = *(unsigned __int8 *)(a4 + 1386);
  a3[159] = *(__int16 *)(a4 + 1310);
  a3[325] = *(_DWORD *)(a4 + 1160);
  a3[311] = *(__int16 *)(a4 + 1252);
  a3[25] = *(__int16 *)(a4 + 1340);
  a3[275] = *(__int16 *)(a4 + 1264);
  a3[373] = *(__int16 *)(a4 + 1262);
  a3[226] = *(__int16 *)(a4 + 1350);
  a3[163] = *(unsigned __int8 *)(a4 + 1390);
  a3[267] = *(unsigned __int8 *)(a4 + 1381);
  a3[17] = *(unsigned __int8 *)(a4 + 1381);
  a3[229] = *(__int16 *)(a4 + 1348);
  a3[91] = *(unsigned __int8 *)(a4 + 1373);
  a3[162] = *(unsigned __int8 *)(a4 + 1376);
  a3[115] = *(__int16 *)(a4 + 1318);
  a3[234] = *(__int16 *)(a4 + 1254);
  a3[326] = *(__int16 *)(a4 + 1304);
  a3[145] = *(__int16 *)(a4 + 1316);
  a3[208] = *(__int16 *)(a4 + 1336);
  a3[282] = *(_DWORD *)(a4 + 1156);
  a3[99] = *(__int16 *)(a4 + 1280);
  a3[284] = *(unsigned __int8 *)(a4 + 1382);
  a3[209] = *(__int16 *)(a4 + 1284);
  a3[178] = *(__int16 *)(a4 + 1266);
  a3[32] = *(__int16 *)(a4 + 1334);
  a3[366] = *(_DWORD *)(a4 + 1172);
  a3[80] = *(char *)(a4 + 1370);
  a3[241] = *(unsigned __int8 *)(a4 + 1379);
  a3[26] = *(unsigned __int8 *)(a4 + 1377);
  a3[383] = *(__int16 *)(a4 + 1270);
  a3[68] = *(__int16 *)(a4 + 1252);
  a3[29] = *(__int16 *)(a4 + 1296);
  a3[233] = *(__int16 *)(a4 + 1330);
  a3[349] = *(char *)(a4 + 1371);
  a3[120] = *(__int16 *)(a4 + 1278);
  a3[380] = *(__int16 *)(a4 + 1274);
  a3[194] = *(__int16 *)(a4 + 1266);
  a3[347] = *(__int16 *)(a4 + 1338);
  a3[111] = *(__int16 *)(a4 + 1348);
  a3[211] = *(_DWORD *)(a4 + 1160);
  a3[286] = *(__int16 *)(a4 + 1308);
  a3[7] = *(__int16 *)(a4 + 1310);
  a3[11] = *(__int16 *)(a4 + 1314);
  a3[231] = *(unsigned __int8 *)(a4 + 1381);
  a3[294] = *(__int16 *)(a4 + 1282);
  a3[154] = *(__int16 *)(a4 + 1308);
  a3[344] = *(_DWORD *)(a4 + 1180);
  a3[158] = *(__int16 *)(a4 + 1284);
  a3[83] = *(unsigned __int8 *)(a4 + 1389);
  a3[1] = *(unsigned __int8 *)(a4 + 1385);
  a3[182] = *(unsigned __int8 *)(a4 + 1374);
  a3[343] = *(__int16 *)(a4 + 1304);
  a3[270] = *(__int16 *)(a4 + 1356);
  a3[77] = *(__int16 *)(a4 + 1268);
  a3[105] = *(__int16 *)(a4 + 1260);
  a3[171] = *(_DWORD *)(a4 + 1172);
  a3[308] = *(__int16 *)(a4 + 1276);
  a3[317] = *(__int16 *)(a4 + 1320);
  a3[187] = *(_DWORD *)(a4 + 1184);
  a3[379] = *(unsigned __int8 *)(a4 + 1379);
  a3[272] = *(__int16 *)(a4 + 1338);
  a3[372] = *(__int16 *)(a4 + 1282);
  a3[222] = *(__int16 *)(a4 + 1328);
  a3[14] = *(__int16 *)(a4 + 1288);
  a3[291] = *(_DWORD *)(a4 + 1176);
  a3[246] = *(unsigned __int8 *)(a4 + 1374);
  a3[327] = *(unsigned __int8 *)(a4 + 1384);
  a3[201] = *(__int16 *)(a4 + 1290);
  a3[89] = *(__int16 *)(a4 + 1340);
  a3[9] = *(__int16 *)(a4 + 1312);
  a3[148] = *(__int16 *)(a4 + 1254);
  a3[139] = *(__int16 *)(a4 + 1352);
  a3[338] = *(_DWORD *)(a4 + 1204);
  a3[214] = *(_DWORD *)(a4 + 1200);
  a3[117] = *(__int16 *)(a4 + 1264);
  a3[34] = *(_DWORD *)(a4 + 1204);
  a3[301] = *(__int16 *)(a4 + 1314);
  a3[357] = *(_DWORD *)(a4 + 1168);
  a3[206] = *(__int16 *)(a4 + 1330);
  a3[3] = *(__int16 *)(a4 + 1344);
  a3[95] = *(__int16 *)(a4 + 1346);
  a3[269] = *(__int16 *)(a4 + 1336);
  a3[52] = *(unsigned __int8 *)(a4 + 1384);
  a3[5] = *(unsigned __int8 *)(a4 + 1378);
  a3[288] = *(__int16 *)(a4 + 1268);
  a3[102] = *(_DWORD *)(a4 + 1212);
  a3[384] = *(__int16 *)(a4 + 1324);
  a3[109] = *(_DWORD *)(a4 + 1220);
  a3[164] = *(__int16 *)(a4 + 1318);
  a3[45] = *(__int16 *)(a4 + 1342);
  a3[179] = *(__int16 *)(a4 + 1356);
  a3[92] = *(_DWORD *)(a4 + 1232);
  a3[271] = *(__int16 *)(a4 + 1266);
  a3[228] = *(__int16 *)(a4 + 1288);
  a3[318] = *(char *)(a4 + 1370);
  a3[69] = *(char *)(a4 + 1372);
  a3[177] = *(_DWORD *)(a4 + 1180);
  a3[88] = *(__int16 *)(a4 + 1310);
  a3[332] = *(__int16 *)(a4 + 1262);
  a3[174] = *(char *)(a4 + 1369);
  a3[216] = *(__int16 *)(a4 + 1262);
  a3[181] = *(_DWORD *)(a4 + 1192);
  a3[150] = *(unsigned __int8 *)(a4 + 1374);
  a3[377] = *(__int16 *)(a4 + 1348);
  a3[133] = *(__int16 *)(a4 + 1294);
  *a3 = *(__int16 *)(a4 + 1302);
  a3[376] = *(__int16 *)(a4 + 1318);
  a3[365] = *(__int16 *)(a4 + 1286);
  a3[336] = *(__int16 *)(a4 + 1256);
  a3[215] = *(unsigned __int8 *)(a4 + 1374);
  a3[278] = *(_DWORD *)(a4 + 1212);
  a3[126] = *(__int16 *)(a4 + 1266);
  a3[129] = *(_DWORD *)(a4 + 1224);
  a3[203] = *(unsigned __int8 *)(a4 + 1388);
  a3[238] = *(_DWORD *)(a4 + 1188);
  a3[63] = *(_DWORD *)(a4 + 1164);
  a3[167] = *(__int16 *)(a4 + 1326);
  a3[385] = *(__int16 *)(a4 + 1334);
  a3[261] = *(__int16 *)(a4 + 1302);
  a3[78] = *(unsigned __int8 *)(a4 + 1378);
  a3[223] = *(__int16 *)(a4 + 1262);
  a3[202] = *(__int16 *)(a4 + 1272);
  a3[141] = *(_DWORD *)(a4 + 1228);
  a3[352] = *(__int16 *)(a4 + 1274);
  a3[335] = *(unsigned __int8 *)(a4 + 1376);
  a3[260] = *(__int16 *)(a4 + 1314);
  a3[255] = *(__int16 *)(a4 + 1312);
  a3[97] = *(unsigned __int8 *)(a4 + 1375);
  a3[274] = *(_DWORD *)(a4 + 1188);
  a3[76] = *(__int16 *)(a4 + 1314);
  a3[10] = *(unsigned __int8 *)(a4 + 1384);
  a3[339] = *(_DWORD *)(a4 + 1176);
  a3[87] = *(_DWORD *)(a4 + 1228);
  a3[15] = *(__int16 *)(a4 + 1302);
  a3[57] = *(__int16 *)(a4 + 1272);
  a3[359] = *(__int16 *)(a4 + 1280);
  a3[287] = *(_DWORD *)(a4 + 1180);
  a3[375] = *(__int16 *)(a4 + 1336);
  a3[165] = *(unsigned __int8 *)(a4 + 1385);
  a3[84] = *(__int16 *)(a4 + 1350);
  a3[43] = *(__int16 *)(a4 + 1300);
  a3[130] = *(char *)(a4 + 1371);
  a3[242] = *(__int16 *)(a4 + 1258);
  a3[2] = *(__int16 *)(a4 + 1292);
  a3[345] = *(__int16 *)(a4 + 1258);
  a3[176] = *(__int16 *)(a4 + 1298);
  a3[65] = *(unsigned __int8 *)(a4 + 1389);
  a3[239] = *(__int16 *)(a4 + 1332);
  a3[156] = *(unsigned __int8 *)(a4 + 1376);
  a3[333] = *(unsigned __int8 *)(a4 + 1387);
  a3[50] = *(__int16 *)(a4 + 1328);
  a3[55] = *(__int16 *)(a4 + 1298);
  a3[302] = *(__int16 *)(a4 + 1256);
  a3[249] = *(__int16 *)(a4 + 1264);
  a3[306] = *(_DWORD *)(a4 + 1172);
  a3[224] = *(unsigned __int8 *)(a4 + 1386);
  a3[207] = *(__int16 *)(a4 + 1320);
  a3[166] = *(_DWORD *)(a4 + 1224);
  a3[309] = *(__int16 *)(a4 + 1324);
  a3[303] = *(unsigned __int8 *)(a4 + 1383);
  a3[137] = *(__int16 *)(a4 + 1260);
  a3[13] = *(_DWORD *)(a4 + 1156);
  a3[134] = *(__int16 *)(a4 + 1252);
  a3[36] = *(_DWORD *)(a4 + 1192);
  a3[277] = *(__int16 *)(a4 + 1264);
  a3[351] = *(__int16 *)(a4 + 1306);
  a3[152] = *(__int16 *)(a4 + 1322);
  a3[160] = *(__int16 *)(a4 + 1258);
  a3[221] = *(__int16 *)(a4 + 1276);
  a3[387] = *(__int16 *)(a4 + 1286);
  a3[143] = *(char *)(a4 + 1369);
  a3[64] = *(char *)(a4 + 1371);
  a3[48] = *(__int16 *)(a4 + 1278);
  a3[268] = *(__int16 *)(a4 + 1274);
  a3[82] = *(_DWORD *)(a4 + 1172);
  a3[104] = *(unsigned __int8 *)(a4 + 1389);
  a3[142] = *(_DWORD *)(a4 + 1184);
  a3[144] = *(__int16 *)(a4 + 1256);
  a3[217] = *(char *)(a4 + 1372);
  a3[258] = *(__int16 *)(a4 + 1312);
  a3[312] = *(_DWORD *)(a4 + 1228);
  a3[316] = *(__int16 *)(a4 + 1298);
  a3[368] = *(__int16 *)(a4 + 1350);
  a3[254] = *(unsigned __int8 *)(a4 + 1373);
  a3[232] = *(__int16 *)(a4 + 1280);
  a3[341] = *(__int16 *)(a4 + 1344);
  a3[175] = *(__int16 *)(a4 + 1304);
  a3[30] = *(__int16 *)(a4 + 1260);
  a3[248] = *(__int16 *)(a4 + 1292);
  a3[193] = *(unsigned __int8 *)(a4 + 1386);
  a3[186] = *(__int16 *)(a4 + 1296);
  a3[298] = *(unsigned __int8 *)(a4 + 1382);
  a3[172] = *(_DWORD *)(a4 + 1216);
  a3[367] = *(__int16 *)(a4 + 1300);
  a3[40] = *(__int16 *)(a4 + 1258);
  a3[200] = *(__int16 *)(a4 + 1338);
  a3[319] = *(char *)(a4 + 1369);
  a3[251] = *(_DWORD *)(a4 + 1184);
  a3[197] = *(__int16 *)(a4 + 1322);
  a3[125] = *(__int16 *)(a4 + 1274);
  a3[161] = *(unsigned __int8 *)(a4 + 1379);
  a3[180] = *(_DWORD *)(a4 + 1168);
  a3[322] = *(__int16 *)(a4 + 1282);
  a3[42] = *(unsigned __int8 *)(a4 + 1389);
  a3[27] = *(__int16 *)(a4 + 1352);
  a3[140] = *(__int16 *)(a4 + 1342);
  a3[103] = *(unsigned __int8 *)(a4 + 1375);
  a3[22] = *(unsigned __int8 *)(a4 + 1391);
  a3[93] = *(__int16 *)(a4 + 1346);
  a3[21] = *(char *)(a4 + 1370);
  a3[225] = *(__int16 *)(a4 + 1320);
  a3[358] = *(__int16 *)(a4 + 1342);
  a3[46] = *(__int16 *)(a4 + 1308);
  a3[31] = *(_DWORD *)(a4 + 1232);
  a3[157] = *(_DWORD *)(a4 + 1192);
  a3[363] = *(_DWORD *)(a4 + 1208);
  a3[295] = *(__int16 *)(a4 + 1338);
  a3[265] = *(__int16 *)(a4 + 1324);
  a3[230] = *(__int16 *)(a4 + 1300);
  a3[118] = *(unsigned __int8 *)(a4 + 1383);
  a3[191] = *(__int16 *)(a4 + 1268);
  a3[374] = *(__int16 *)(a4 + 1278);
  a3[18] = *(unsigned __int8 *)(a4 + 1377);
  a3[361] = *(__int16 *)(a4 + 1324);
  a3[4] = *(_DWORD *)(a4 + 1220);
  a3[79] = *(__int16 *)(a4 + 1290);
  a3[334] = *(_DWORD *)(a4 + 1184);
  a3[346] = *(__int16 *)(a4 + 1328);
  a3[360] = *(__int16 *)(a4 + 1346);
  a3[98] = *(_DWORD *)(a4 + 1160);
  a3[324] = *(_DWORD *)(a4 + 1176);
  a3[122] = *(unsigned __int8 *)(a4 + 1388);
  a3[49] = *(__int16 *)(a4 + 1334);
  a3[313] = *(char *)(a4 + 1371);
  a3[329] = *(__int16 *)(a4 + 1284);
  a3[253] = *(__int16 *)(a4 + 1332);
  a3[220] = *(__int16 *)(a4 + 1316);
  a3[300] = *(_DWORD *)(a4 + 1188);
  a3[135] = *(_DWORD *)(a4 + 1188);
  a3[378] = *(_DWORD *)(a4 + 1232);
  a3[41] = *(unsigned __int8 *)(a4 + 1386);
  a3[62] = *(_DWORD *)(a4 + 1216);
  a3[124] = *(__int16 *)(a4 + 1354);
  a3[371] = *(_DWORD *)(a4 + 1164);
  a3[266] = *(__int16 *)(a4 + 1322);
  a3[121] = *(__int16 *)(a4 + 1272);
  a3[279] = *(__int16 *)(a4 + 1290);
  a3[299] = *(unsigned __int8 *)(a4 + 1390);
  a3[252] = *(_DWORD *)(a4 + 1176);
  a3[73] = *(unsigned __int8 *)(a4 + 1375);
  a3[128] = *(__int16 *)(a4 + 1326);
  a3[147] = *(_DWORD *)(a4 + 1200);
  a3[38] = *(__int16 *)(a4 + 1316);
  a3[37] = *(_DWORD *)(a4 + 1232);
  a3[108] = *(__int16 *)(a4 + 1298);
  a3[310] = *(__int16 *)(a4 + 1280);
  a3[381] = *(_DWORD *)(a4 + 1164);
  a3[12] = *(unsigned __int8 *)(a4 + 1391);
  a3[123] = *(_DWORD *)(a4 + 1220);
  a3[321] = *(_DWORD *)(a4 + 1208);
  a3[33] = *(unsigned __int8 *)(a4 + 1377);
  a3[86] = *(_DWORD *)(a4 + 1168);
  a3[114] = *(__int16 *)(a4 + 1296);
  a3[189] = *(__int16 *)(a4 + 1286);
  a3[53] = *(_DWORD *)(a4 + 1156);
  a3[74] = *(__int16 *)(a4 + 1326);
  a3[72] = *(char *)(a4 + 1372);
  a3[204] = *(__int16 *)(a4 + 1306);
  a3[342] = *(__int16 *)(a4 + 1330);
  a3[184] = *(__int16 *)(a4 + 1330);
  a3[16] = *(__int16 *)(a4 + 1288);
  a3[155] = *(_DWORD *)(a4 + 1208);
  a3[245] = *(_DWORD *)(a4 + 1204);
  a3[235] = *(__int16 *)(a4 + 1294);
  a3[283] = *(unsigned __int8 *)(a4 + 1380);
  a3[328] = *(unsigned __int8 *)(a4 + 1391);
  a3[90] = *(_DWORD *)(a4 + 1212);
  a3[356] = *(__int16 *)(a4 + 1270);
  a3[297] = *(_DWORD *)(a4 + 1216);
  a3[256] = *(__int16 *)(a4 + 1336);
  a3[51] = *(__int16 *)(a4 + 1344);
  a3[183] = *(__int16 *)(a4 + 1350);
  v14 = 0;
  v15 = (unsigned int)(a3 + 388);
  do
  {
    v15 += 4;
    v16 = *(unsigned __int8 *)(a4 + v14++ + 1399);
    *(_DWORD *)(v15 - 4) = v16;
  }
  while ( v14 < 29 );
  a3[417] = *(_BYTE *)(a4 + 1) & 1;
  LOBYTE(v15) = *(_BYTE *)(a4 + 1);
  a3[418] = (v15 >> 1) & 1;
  LOBYTE(v16) = *(_BYTE *)(a4 + 1);
  a3[419] = (v16 >> 2) & 1;
  a3[420] = (*(unsigned __int8 *)(a4 + 1) >> 3) & 7;
  a3[421] = (*(unsigned __int8 *)(a4 + 1) >> 6) & 1;
  v17 = *(unsigned __int8 *)(a4 + 1392);
  a3[427] = 0;
  a3[422] = 10 * v17;
  memset(a3 + 428, 0, 0x30u);
  v18 = (unsigned int *)(a4 + 1236);
  v19 = 4;
  do
  {
    v20 = *v18;
    if ( (*v18 & 0x3FF) != 0 || (v20 & 0x1FFFFC00) != 0 )
    {
      a3[3 * a3[427] + 428] = *v18 & 0x3FF;
      a3[3 * a3[427] + 429] = (*v18 >> 10) & 0x3FF;
      a3[3 * a3[427] + 430] = (*v18 >> 20) & 0x1FF;
      v20 = a3[427] + 1;
      a3[427] = v20;
    }
    ++v18;
    --v19;
  }
  while ( v19 );
  a3[423] = *(unsigned __int8 *)(a4 + 1358);
  a3[424] = *(_BYTE *)(a4 + 2) & 7;
  LOBYTE(v20) = *(_BYTE *)(a4 + 2);
  result = (v20 >> 4) & 1;
  a3[425] = result;
  a3[426] = (*(unsigned __int8 *)(a4 + 2) >> 3) & 1;
  return result;
}

//----- (00457D50) --------------------------------------------------------
_DWORD *__thiscall sub_457D50(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = a2;
  return result;
}

//----- (00457D60) --------------------------------------------------------
_DWORD *__userpurge sub_457D60@<eax>(void **a1@<ecx>, int a2@<ebx>, unsigned int a3)
{
  void **v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  int v14; // esi
  int v15; // edi
  int v16; // ecx
  int v17; // edi
  int v18; // ecx
  int v19; // edx
  int v20; // esi
  int v21; // edi
  int v22; // ecx
  int v23; // edx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // edx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // esi
  int v41; // ebx
  int v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // esi
  int v46; // edi
  int v47; // ecx
  int v48; // edx
  int v49; // esi
  int v50; // edi
  int v51; // ecx
  int v52; // ebx
  int v53; // esi
  int v54; // edx
  int v55; // ecx
  int v56; // edi
  int v57; // ebx
  int v58; // edx
  int v59; // ecx
  int v60; // esi
  int v61; // edi
  int v62; // ebx
  int v63; // edi
  int v64; // edx
  int v65; // ecx
  int v66; // esi
  int v67; // edi
  int v68; // edx
  int v69; // ecx
  int v70; // esi
  int v71; // edi
  int v72; // edx
  int v73; // ecx
  int v74; // esi
  int v75; // edi
  int v76; // edx
  int v77; // ecx
  int v78; // esi
  int v79; // ebp
  int v80; // ebx
  int v81; // edi
  unsigned int v82; // edx
  int i; // ecx
  _DWORD *result; // eax
  int v85; // ecx
  int v86; // edx
  int v87; // esi
  int v88; // edi
  int v89; // ecx
  int v90; // edi
  int v91; // ecx
  int v92; // edx
  int v93; // esi
  int v94; // edi
  int v95; // ecx
  int v96; // edi
  int v97; // ecx
  int v98; // edx
  int v99; // esi
  int v100; // edi
  int v101; // ecx
  int v102; // edx
  int v103; // esi
  int v104; // edi
  int v105; // ecx
  int v106; // edx
  int v107; // esi
  int v108; // edi
  int v109; // ecx
  int v110; // edx
  int v111; // ecx
  int v112; // edx
  int v113; // esi
  int v114; // edi
  int v115; // ecx
  int v116; // edx
  int v117; // ecx
  int v118; // ebx
  int v119; // edi
  int v120; // esi
  int v121; // edx
  int v122; // ecx
  int v123; // edi
  int v124; // esi
  int v125; // edx
  int v126; // ecx
  int v127; // edi
  int v128; // esi
  int v129; // ebx
  int v130; // ebp
  int v131; // ecx
  int v132; // edx
  int v133; // esi
  int v134; // edi
  int v135; // ecx
  int v136; // edx
  int v137; // esi
  int v138; // ebp
  int v139; // edi
  int v140; // ecx
  int v141; // edx
  int v142; // esi
  int v143; // edi
  int v144; // ecx
  int v145; // edx
  int v146; // esi
  int v147; // edi
  int v148; // ecx
  int v149; // edx
  int v150; // esi
  int v151; // edi
  int v152; // ebx
  int v153; // ecx
  int v154; // esi
  int v155; // edx
  int v156; // ebp
  int v157; // edx
  unsigned int v158; // edx
  int j; // ecx
  int v160; // [esp+10h] [ebp-20h]
  int v161; // [esp+10h] [ebp-20h]
  int v162; // [esp+10h] [ebp-20h]
  int v163; // [esp+10h] [ebp-20h]
  int v164; // [esp+10h] [ebp-20h]
  int v166; // [esp+20h] [ebp-10h]
  int v167; // [esp+24h] [ebp-Ch]
  int v168; // [esp+28h] [ebp-8h]
  int v169; // [esp+2Ch] [ebp-4h]

  LOBYTE(a2) = a3;
  BYTE1(a2) = a3;
  v3 = a1;
  v4 = a2 << 16;
  LOWORD(v4) = a2;
  memset32(*a1, v4, 0x14u);
  *(_DWORD *)*a1 ^= a3;
  v5 = *a1;
  v6 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v7 = v6 + __ROL4__((v6 & 0xEFCDAAC9 | ~v6 & 0x98BACD4E) + *((_DWORD *)*v3 + 1) - 107344724, 12);
  v8 = v7 + __ROL4__((v6 & v7 | ~v7 & 0xEFCDAAC9) + *((_DWORD *)*v3 + 2) - 1126481991, 17);
  v9 = __ROL4__((v8 & v7 | v6 & ~v8) + v5[3] - 1319441881, 22);
  v10 = v5[4] + ((v8 + v9) & v8 | v7 & ~(v8 + v9)) + v6 - 177010401;
  v11 = v8 + v9;
  v12 = v11 + __ROL4__(v10, 7);
  v13 = v12 + __ROL4__(v5[5] + (v12 & v11 | v8 & ~v12) + v7 + 1200080794, 12);
  v14 = v13 + __ROL4__(v5[6] + (v12 & v13 | v11 & ~v13) + v8 - 1472706653, 17);
  v15 = __ROL4__(v5[7] + (v14 & v13 | v12 & ~v14) + v11 - 45706063, 22);
  v16 = v5[8] + ((v14 + v15) & v14 | v13 & ~(v14 + v15)) + v12 + 1753258344;
  v17 = v14 + v15;
  v18 = v17 + __ROL4__(v16, 7);
  v19 = v18 + __ROL4__(v5[9] + (v18 & v17 | v14 & ~v18) + v13 - 1958414817, 12);
  v20 = v19 + __ROL4__(v5[10] + (v18 & v19 | v17 & ~v19) + v14 - 7382527, 17);
  v21 = __ROL4__(v5[11] + (v20 & v19 | v18 & ~v20) + v17 - 1987258866, 22);
  v160 = v20 + v21;
  v22 = v20 + v21 + __ROL4__(v5[12] + ((v20 + v21) & v20 | v19 & ~(v20 + v21)) + v18 + 1804605842, 7);
  v23 = v22 + __ROL4__(v5[13] + (v22 & (v20 + v21) | v20 & ~v22) + v19 - 40341469, 12);
  v24 = v23 + __ROL4__(v20 + v5[14] + (v22 & v23 | (v20 + v21) & ~v23) - 1502002626, 17);
  v25 = v24 + __ROL4__(v5[15] + (v24 & v23 | v22 & ~v24) + v160 + 1232341393, 22);
  v26 = v25 + __ROL4__(v5[1] + (v25 & v23 | v24 & ~v23) + v22 - 166648622, 5);
  v27 = v26 + __ROL4__(v5[6] + (v26 & v24 | v25 & ~v24) + v23 - 985615632, 9);
  v28 = v27 + __ROL4__(v5[11] + (v25 & v27 | v26 & ~v25) + v24 + 643714017, 14);
  v29 = v28 + __ROL4__(*v5 + (v26 & v28 | v27 & ~v26) + v25 - 374028774, 20);
  v30 = __ROL4__(v5[5] + (v29 & v27 | v28 & ~v27) + v26 - 702082579, 5);
  v31 = v5[10] + ((v29 + v30) & v28 | v29 & ~v28) + v27 + 39065059;
  v32 = v29 + v30;
  v33 = v32 + __ROL4__(v31, 9);
  v34 = v33 + __ROL4__(v5[15] + (v29 & v33 | v32 & ~v29) + v28 - 660515023, 14);
  v35 = v34 + __ROL4__(v5[4] + (v32 & v34 | v33 & ~v32) + v29 - 405538184, 20);
  v36 = __ROL4__(v5[9] + (v35 & v33 | v34 & ~v33) + v32 + 568642646, 5);
  v37 = v5[14] + ((v35 + v36) & v34 | v35 & ~v34) + v33 - 1019804058;
  v38 = v35 + v36;
  v39 = v38 + __ROL4__(v37, 9);
  v40 = v39 + __ROL4__(v5[3] + (v35 & v39 | v38 & ~v35) + v34 - 187366857, 14);
  v41 = v5[8];
  v42 = v40 + __ROL4__(v41 + (v38 & v40 | v39 & ~v38) + v35 + 1163531613, 20);
  v43 = __ROL4__(v5[13] + (v42 & v39 | v40 & ~v39) + v38 - 1456215883, 5);
  v161 = v42 + v43;
  v44 = v42 + v43 + __ROL4__(v5[2] + ((v42 + v43) & v40 | v42 & ~v40) + v39 - 51404216, 9);
  v45 = v44 + __ROL4__(v40 + v5[7] + (v42 & v44 | (v42 + v43) & ~v42) + 1735327849, 14);
  v46 = v45 + __ROL4__(v5[12] + (v161 & v45 | v44 & ~v161) + v42 - 1926673094, 20);
  v47 = v46 + __ROL4__(v5[5] + (v46 ^ v45 ^ v44) + v161 - 235259662, 4);
  v48 = v47 + __ROL4__(v44 + v41 + (v47 ^ v46 ^ v45) - 2022574287, 11);
  v49 = v48 + __ROL4__(v5[11] + (v47 ^ v46 ^ v48) + v45 + 1832738962, 16);
  v50 = v49 + __ROL4__(v46 + v5[14] + (v47 ^ v49 ^ v48) - 35309124, 23);
  v51 = v50 + __ROL4__(v5[1] + (v50 ^ v49 ^ v48) + v47 - 1531024396, 4);
  v52 = v51 + __ROL4__(v5[4] + (v51 ^ v50 ^ v49) + v48 + 1272889881, 11);
  v53 = v52 + __ROL4__(v5[7] + (v51 ^ v50 ^ v52) + v49 - 155694384, 16);
  v54 = v53 + __ROL4__(v5[10] + (v51 ^ v53 ^ v52) + v50 - 1094730304, 23);
  v55 = v54 + __ROL4__(v51 + v5[13] + (v54 ^ v53 ^ v52) + 680755062, 4);
  v56 = v55 + __ROL4__(*v5 + (v55 ^ v54 ^ v53) + v52 - 358537654, 11);
  v57 = v56 + __ROL4__(v5[3] + (v55 ^ v54 ^ v56) + v53 - 722501323, 16);
  v58 = v57 + __ROL4__(v54 + v5[6] + (v55 ^ v57 ^ v56) + 76029109, 23);
  v59 = v58 + __ROL4__(v5[9] + (v58 ^ v57 ^ v56) + v55 - 640363895, 4);
  v60 = v59 + __ROL4__(v5[12] + (v59 ^ v58 ^ v57) + v56 - 429156267, 11);
  v61 = v5[15] + (v59 ^ v58 ^ v60) + v57 + 530742600;
  v62 = v5[2];
  v63 = v60 + __ROL4__(v61, 16);
  v64 = v63 + __ROL4__(v58 + v62 + (v59 ^ v63 ^ v60) - 995346475, 23);
  v65 = v64 + __ROL4__(v59 + *v5 + (v63 ^ (v64 | ~v60)) - 197909516, 6);
  v66 = v65 + __ROL4__(v60 + v5[7] + (v64 ^ (v65 | ~v63)) + 1126854183, 10);
  v67 = v66 + __ROL4__(v63 + v5[14] + (v65 ^ (v66 | ~v64)) - 1416355305, 15);
  v68 = v67 + __ROL4__(v64 + v5[5] + (v66 ^ (v67 | ~v65)) - 57302647, 21);
  v69 = v68 + __ROL4__(v65 + v5[12] + (v67 ^ (v68 | ~v66)) + 1700092019, 6);
  v70 = v69 + __ROL4__(v66 + v5[3] + (v68 ^ (v69 | ~v67)) - 1894986462, 10);
  v71 = v70 + __ROL4__(v67 + v5[10] + (v69 ^ (v70 | ~v68)) - 168823347, 15);
  v72 = v71 + __ROL4__(v68 + v5[1] + (v70 ^ (v71 | ~v69)) - 2054923167, 21);
  v73 = v72 + __ROL4__(v69 + v5[8] + (v71 ^ (v72 | ~v70)) + 1873117183, 6);
  v74 = v73 + __ROL4__(v70 + v5[15] + (v72 ^ (v73 | ~v71)) - 181606576, 10);
  v75 = v74 + __ROL4__(v71 + v5[6] + (v73 ^ (v74 | ~v72)) - 1560197980, 15);
  v76 = v75 + __ROL4__(v72 + v5[13] + (v74 ^ (v75 | ~v73)) + 1309167633, 21);
  v77 = v76 + __ROL4__(v73 + v5[4] + (v75 ^ (v76 | ~v74)) - 145391822, 6);
  v78 = v77 + __ROL4__(v74 + v5[11] + (v76 ^ (v77 | ~v75)) + 1161491333, 10);
  v79 = v62 + (v77 ^ (v78 | ~v76));
  v166 = v77 + 1731535537;
  v80 = v5[9];
  v81 = v78 + __ROL4__(v75 + v79 + 718766859, 15);
  v169 = v78 + 288511430;
  v168 = v81 - 1732588210;
  v167 = __ROL4__(v80 + (v78 ^ (v81 | ~v77)) + v76 - 346631647, 21) + v81 - 271734071;
  v82 = a3;
  for ( i = 0; i < 20; ++i )
  {
    v5[i] ^= v82 + *(&v166 + (i & 3));
    v5 = *a1;
    v82 = *((_DWORD *)*a1 + i);
  }
  sub_434670((int *)*a1, a3);
  *(_DWORD *)*a1 ^= a3;
  result = *a1;
  v85 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v86 = v85 + __ROL4__((v85 & 0xEFCDAAC9 | ~v85 & 0x98BACD4E) + *((_DWORD *)*a1 + 1) - 107344724, 12);
  v87 = v86 + __ROL4__((v85 & v86 | ~v86 & 0xEFCDAAC9) + *((_DWORD *)*a1 + 2) - 1126481991, 17);
  v88 = __ROL4__((v87 & v86 | v85 & ~v87) + *((_DWORD *)*a1 + 3) - 1319441881, 22);
  v89 = *((_DWORD *)*a1 + 4) + ((v87 + v88) & v87 | v86 & ~(v87 + v88)) + v85 - 177010401;
  v90 = v87 + v88;
  v91 = v90 + __ROL4__(v89, 7);
  v92 = v91 + __ROL4__(v86 + (v91 & v90 | v87 & ~v91) + *((_DWORD *)*a1 + 5) + 1200080794, 12);
  v93 = v92 + __ROL4__(v87 + (v91 & v92 | v90 & ~v92) + *((_DWORD *)*a1 + 6) - 1472706653, 17);
  v94 = __ROL4__(*((_DWORD *)*a1 + 7) + (v93 & v92 | v91 & ~v93) + v90 - 45706063, 22);
  v95 = *((_DWORD *)*a1 + 8) + ((v93 + v94) & v93 | v92 & ~(v93 + v94)) + v91 + 1753258344;
  v96 = v93 + v94;
  v97 = v96 + __ROL4__(v95, 7);
  v98 = v97 + __ROL4__(*((_DWORD *)*a1 + 9) + (v97 & v96 | v93 & ~v97) + v92 - 1958414817, 12);
  v99 = v98 + __ROL4__(*((_DWORD *)*a1 + 10) + (v97 & v98 | v96 & ~v98) + v93 - 7382527, 17);
  v100 = __ROL4__(*((_DWORD *)*a1 + 11) + (v99 & v98 | v97 & ~v99) + v96 - 1987258866, 22);
  v162 = v99 + v100;
  v101 = v99 + v100 + __ROL4__(*((_DWORD *)*a1 + 12) + ((v99 + v100) & v99 | v98 & ~(v99 + v100)) + v97 + 1804605842, 7);
  v102 = v101 + __ROL4__(*((_DWORD *)*a1 + 13) + (v101 & (v99 + v100) | v99 & ~v101) + v98 - 40341469, 12);
  v103 = v102 + __ROL4__(v99 + *((_DWORD *)*a1 + 14) + (v101 & v102 | (v99 + v100) & ~v102) - 1502002626, 17);
  v104 = v103 + __ROL4__(*((_DWORD *)*a1 + 15) + (v103 & v102 | v101 & ~v103) + v162 + 1232341393, 22);
  v105 = v104 + __ROL4__(*((_DWORD *)*a1 + 1) + (v104 & v102 | v103 & ~v102) + v101 - 166648622, 5);
  v106 = v105 + __ROL4__(v102 + (v105 & v103 | v104 & ~v103) + *((_DWORD *)*a1 + 6) - 985615632, 9);
  v107 = v106 + __ROL4__(*((_DWORD *)*a1 + 11) + (v104 & v106 | v105 & ~v104) + v103 + 643714017, 14);
  v108 = v107 + __ROL4__(*(_DWORD *)*a1 + (v105 & v107 | v106 & ~v105) + v104 - 374028774, 20);
  v109 = __ROL4__(*((_DWORD *)*a1 + 5) + (v108 & v106 | v107 & ~v106) + v105 - 702082579, 5);
  v110 = *((_DWORD *)*a1 + 10) + ((v108 + v109) & v107 | v108 & ~v107) + v106 + 39065059;
  v111 = v108 + v109;
  v112 = v111 + __ROL4__(v110, 9);
  v113 = v112 + __ROL4__(*((_DWORD *)*a1 + 15) + (v108 & v112 | v111 & ~v108) + v107 - 660515023, 14);
  v114 = v113 + __ROL4__(*((_DWORD *)*a1 + 4) + (v111 & v113 | v112 & ~v111) + v108 - 405538184, 20);
  v115 = __ROL4__(*((_DWORD *)*a1 + 9) + (v114 & v112 | v113 & ~v112) + v111 + 568642646, 5);
  v163 = v114 + v115;
  v116 = v114 + v115 + __ROL4__(*((_DWORD *)*a1 + 14) + ((v114 + v115) & v113 | v114 & ~v113) + v112 - 1019804058, 9);
  v117 = v116 + __ROL4__(*((_DWORD *)*a1 + 3) + v113 + (v114 & v116 | (v114 + v115) & ~v114) - 187366857, 14);
  v118 = *((_DWORD *)*a1 + 8);
  v119 = v117 + __ROL4__(v118 + (v163 & v117 | v116 & ~v163) + v114 + 1163531613, 20);
  v120 = __ROL4__(*((_DWORD *)*a1 + 13) + (v119 & v116 | v117 & ~v116) + v163 - 1456215883, 5);
  v164 = v119 + v120;
  v121 = v119 + v120 + __ROL4__(v116 + ((v119 + v120) & v117 | v119 & ~v117) + *((_DWORD *)*a1 + 2) - 51404216, 9);
  v122 = v121 + __ROL4__(v117 + *((_DWORD *)*a1 + 7) + (v119 & v121 | (v119 + v120) & ~v119) + 1735327849, 14);
  v123 = v122 + __ROL4__(*((_DWORD *)*a1 + 12) + (v164 & v122 | v121 & ~v164) + v119 - 1926673094, 20);
  v124 = v123 + __ROL4__(*((_DWORD *)*a1 + 5) + (v123 ^ v122 ^ v121) + v164 - 235259662, 4);
  v125 = v124 + __ROL4__(v121 + v118 + (v124 ^ v123 ^ v122) - 2022574287, 11);
  v126 = v125 + __ROL4__(*((_DWORD *)*a1 + 11) + (v124 ^ v123 ^ v125) + v122 + 1832738962, 16);
  v127 = v126 + __ROL4__(v123 + *((_DWORD *)*a1 + 14) + (v124 ^ v126 ^ v125) - 35309124, 23);
  v128 = v127 + __ROL4__(*((_DWORD *)*a1 + 1) + (v127 ^ v126 ^ v125) + v124 - 1531024396, 4);
  v129 = v128 + __ROL4__(v125 + (v128 ^ v127 ^ v126) + *((_DWORD *)*a1 + 4) + 1272889881, 11);
  v130 = v129 + __ROL4__(*((_DWORD *)*a1 + 7) + (v128 ^ v127 ^ v129) + v126 - 155694384, 16);
  v131 = v130 + __ROL4__(*((_DWORD *)*a1 + 10) + (v128 ^ v130 ^ v129) + v127 - 1094730304, 23);
  v132 = v131 + __ROL4__(*((_DWORD *)*a1 + 13) + (v131 ^ v130 ^ v129) + v128 + 680755062, 4);
  v133 = v132 + __ROL4__(v129 + (v132 ^ v131 ^ v130) + *(_DWORD *)*a1 - 358537654, 11);
  v134 = v133 + __ROL4__(v130 + (v132 ^ v131 ^ v133) + *((_DWORD *)*a1 + 3) - 722501323, 16);
  v135 = v134 + __ROL4__(v131 + *((_DWORD *)*a1 + 6) + (v132 ^ v134 ^ v133) + 76029109, 23);
  v136 = v135 + __ROL4__(*((_DWORD *)*a1 + 9) + (v135 ^ v134 ^ v133) + v132 - 640363895, 4);
  v137 = v136 + __ROL4__(*((_DWORD *)*a1 + 12) + (v136 ^ v135 ^ v134) + v133 - 429156267, 11);
  v138 = *((_DWORD *)*a1 + 2);
  v139 = v137 + __ROL4__(*((_DWORD *)*a1 + 15) + (v136 ^ v135 ^ v137) + v134 + 530742600, 16);
  v140 = v139 + __ROL4__(v138 + (v136 ^ v139 ^ v137) + v135 - 995346475, 23);
  v141 = v140 + __ROL4__(*(_DWORD *)*a1 + (v139 ^ (v140 | ~v137)) + v136 - 197909516, 6);
  v142 = v141 + __ROL4__(*((_DWORD *)*a1 + 7) + (v140 ^ (v141 | ~v139)) + v137 + 1126854183, 10);
  v143 = v142 + __ROL4__(*((_DWORD *)*a1 + 14) + (v141 ^ (v142 | ~v140)) + v139 - 1416355305, 15);
  v144 = v143 + __ROL4__(*((_DWORD *)*a1 + 5) + (v142 ^ (v143 | ~v141)) + v140 - 57302647, 21);
  v145 = v144 + __ROL4__(*((_DWORD *)*a1 + 12) + (v143 ^ (v144 | ~v142)) + v141 + 1700092019, 6);
  v146 = v145 + __ROL4__(v142 + (v144 ^ (v145 | ~v143)) + *((_DWORD *)*a1 + 3) - 1894986462, 10);
  v147 = v146 + __ROL4__(*((_DWORD *)*a1 + 10) + (v145 ^ (v146 | ~v144)) + v143 - 168823347, 15);
  v148 = v147 + __ROL4__(*((_DWORD *)*a1 + 1) + (v146 ^ (v147 | ~v145)) + v144 - 2054923167, 21);
  v149 = v148 + __ROL4__(*((_DWORD *)*a1 + 8) + (v147 ^ (v148 | ~v146)) + v145 + 1873117183, 6);
  v150 = v149 + __ROL4__(*((_DWORD *)*a1 + 15) + (v148 ^ (v149 | ~v147)) + v146 - 181606576, 10);
  v151 = v150 + __ROL4__(v147 + (v149 ^ (v150 | ~v148)) + *((_DWORD *)*a1 + 6) - 1560197980, 15);
  v152 = v151 + __ROL4__(*((_DWORD *)*a1 + 13) + (v150 ^ (v151 | ~v149)) + v148 + 1309167633, 21);
  v153 = v152 + __ROL4__(*((_DWORD *)*a1 + 4) + (v151 ^ (v152 | ~v150)) + v149 - 145391822, 6);
  v154 = v153 + __ROL4__(*((_DWORD *)*a1 + 11) + (v152 ^ (v153 | ~v151)) + v150 + 1161491333, 10);
  v155 = v151 + (v153 ^ (v154 | ~v152)) + v138 + 718766859;
  v156 = *((_DWORD *)*a1 + 9);
  v157 = v154 + __ROL4__(v155, 15);
  v166 = v153 + 1731535537;
  v169 = v154 + 288511430;
  v167 = __ROL4__(v156 + (v154 ^ (v157 | ~v153)) + v152 - 346631647, 21) + v157 - 271734071;
  v168 = v157 - 1732588210;
  v158 = a3;
  for ( j = 0; j < 20; ++j )
  {
    result[j] ^= v158 + *(&v166 + (j & 3));
    result = *a1;
    v158 = *((_DWORD *)*a1 + j);
  }
  return result;
}

//----- (00458BE0) --------------------------------------------------------
int __thiscall sub_458BE0(_DWORD *this, int a2)
{
  return ((int (__fastcall *)(_DWORD, int))loc_421520)(*this, a2);
}

//----- (00458BF0) --------------------------------------------------------
char __thiscall ContinuumEncrypt(unsigned int *this, char *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // esi
  _DWORD *v8; // ebx
  int v9; // edx
  int *v10; // edx
  unsigned int v11; // edi
  int v12; // ebp
  int *v13; // edx
  int v14; // edi
  int v15; // edx
  _BYTE *v16; // esi
  unsigned int v17; // edi
  char v18; // dl
  int v21; // [esp+18h] [ebp+4h]
  unsigned int v22; // [esp+1Ch] [ebp+8h]
  int v23; // [esp+20h] [ebp+Ch]

  v4 = a4;
  v5 = 0;
  v6 = 0;
  v7 = a2;
  v8 = a3;
  if ( a4 > 7 )
  {
    v9 = (char *)a3 - a2;
    v21 = (char *)a3 - a2;
    v22 = a4 >> 3;
    while ( 1 )
    {
      v5 ^= *v8;
      v6 ^= *(_DWORD *)&v7[v9 + 4];
      v10 = (int *)*this;
      v11 = *this + 80;
      if ( *this < v11 )
      {
        do
        {
          v12 = *v10;
          v10 += 2;
          v5 = __ROL4__(v5 + v12, v6);
          v6 = __ROL4__(v6 + *(v10 - 1), v5);
        }
        while ( (unsigned int)v10 < v11 );
        v4 = a4;
      }
      *(_DWORD *)v7 = v5;
      *((_DWORD *)v7 + 1) = v6;
      v8 += 2;
      v7 += 8;
      v4 -= 8;
      a4 = v4;
      if ( !--v22 )
        break;
      v9 = v21;
    }
  }
  if ( v4 > 3 )
  {
    v5 ^= *v8;
    v13 = (int *)*this;
    if ( *this < *this + 80 )
    {
      do
      {
        v14 = *v13;
        v13 += 2;
        v5 = __ROL4__(v5 + v14, v6);
        v6 += *(v13 - 1);
      }
      while ( (unsigned int)v13 < *this + 80 );
    }
    *(_DWORD *)v7 = v5;
    ++v8;
    v7 += 4;
    v4 -= 4;
  }
  if ( v4 )
  {
    v15 = v7 - (char *)v8;
    v23 = v7 - (char *)v8;
    do
    {
      LOBYTE(v5) = *(_BYTE *)v8 ^ v5;
      v16 = (_BYTE *)*this;
      v17 = *this + 80;
      if ( *this < v17 )
      {
        do
        {
          v18 = *v16;
          v16 += 8;
          LOBYTE(v5) = v6 + v18 + v5;
          v6 += *((_DWORD *)v16 - 1);
        }
        while ( (unsigned int)v16 < v17 );
        v15 = v23;
      }
      *((_BYTE *)v8 + v15) = v5;
      v8 = (_DWORD *)((char *)v8 + 1);
      --v4;
    }
    while ( v4 );
  }
  return v5;
}

//----- (00458D00) --------------------------------------------------------
unsigned int __thiscall ContinuumDecrypt(unsigned int *this, int *a2, int *a3, unsigned int a4)
{
  unsigned int result; // eax
  int *v5; // ebx
  int i; // ebp
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // edx
  int v11; // ebx
  unsigned int v12; // ecx
  bool v13; // zf
  int v14; // edi
  int v15; // ecx
  unsigned int v16; // edx
  _DWORD *v17; // eax
  int v18; // ebp
  int *v19; // edi
  char v20; // bl
  int v21; // ecx
  unsigned int v22; // esi
  unsigned int v23; // edx
  _BYTE *v24; // eax
  int v25; // ebp
  int v26; // edx
  char v27; // dl
  int v28; // [esp+10h] [ebp-Ch]
  int v30; // [esp+18h] [ebp-4h]
  unsigned int v31; // [esp+20h] [ebp+4h]
  int *v32; // [esp+24h] [ebp+8h]
  int v33; // [esp+24h] [ebp+8h]
  unsigned int v34; // [esp+28h] [ebp+Ch]

  result = a4;
  v5 = a2;
  i = 0;
  v28 = 0;
  v32 = a2;
  if ( a4 > 7 )
  {
    v30 = (char *)a2 - (char *)a3;
    v31 = a4 >> 3;
    do
    {
      v8 = *a3;
      v9 = a3[1];
      v10 = (_DWORD *)(*this + 80);
      if ( (unsigned int)v10 > *this )
      {
        do
        {
          v11 = *(v10 - 1);
          v10 -= 2;
          v9 = __ROR4__(v9, v8) - v11;
          v8 = __ROR4__(v8, v9) - *v10;
        }
        while ( (unsigned int)v10 > *this );
        v5 = v32;
      }
      a3 += 2;
      *v5 = v28 ^ v8;
      v5 += 2;
      *(int *)((char *)a3 + v30 - 4) = i ^ v9;
      i = *(a3 - 1);
      v12 = a4 - 8;
      v13 = v31 == 1;
      v28 = *(a3 - 2);
      v32 = v5;
      a4 -= 8;
      --v31;
    }
    while ( !v13 );
    result = v12;
  }
  if ( result > 3 )
  {
    v14 = *a3;
    v15 = i;
    v16 = *this;
    v17 = (_DWORD *)(*this + 80);
    if ( *this < (unsigned int)v17 )
    {
      do
      {
        v18 = *(_DWORD *)(v16 + 4);
        v16 += 8;
        v15 += v18;
      }
      while ( v16 < (unsigned int)v17 );
    }
    for ( i = v15; (unsigned int)v17 > *this; v14 = __ROR4__(v14, v15) - *v17 )
    {
      v15 -= *(v17 - 1);
      v17 -= 2;
    }
    ++a3;
    *v5 = v28 ^ v14;
    v28 = *(a3 - 1);
    ++v5;
    result = a4 - 4;
  }
  v19 = a3;
  if ( result )
  {
    v34 = result;
    v33 = (char *)v5 - (char *)a3;
    do
    {
      v20 = *(_BYTE *)v19;
      v21 = i;
      v22 = *this;
      v23 = *this;
      v24 = (_BYTE *)(*this + 80);
      if ( *this < (unsigned int)v24 )
      {
        do
        {
          v25 = *(_DWORD *)(v23 + 4);
          v23 += 8;
          v21 += v25;
        }
        while ( v23 < (unsigned int)v24 );
      }
      for ( i = v21; (unsigned int)v24 > v22; v20 -= v21 + *v24 )
      {
        v26 = *((_DWORD *)v24 - 1);
        v24 -= 8;
        v21 -= v26;
      }
      *((_BYTE *)v19 + v33) = v20 ^ v28;
      v27 = *(_BYTE *)v19;
      v19 = (int *)((char *)v19 + 1);
      result = v34 - 1;
      v13 = v34 == 1;
      LOBYTE(v28) = v27;
      --v34;
    }
    while ( !v13 );
  }
  return result;
}

//----- (00458E90) --------------------------------------------------------
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // edx
  int v21; // esi
  int v22; // edi
  int v23; // ebx
  int v24; // edx
  int v25; // esi
  int v26; // edi
  int v27; // ebx
  int v28; // edx
  int v29; // esi
  int v30; // edi
  int v31; // ebx
  int v32; // ecx
  int v33; // esi
  int v34; // ecx
  int v35; // esi
  int v36; // edi
  int v37; // edx
  int v38; // ebx
  int v39; // ecx
  int v40; // esi
  int v41; // edi
  int v42; // ebx
  int v43; // ecx
  int v44; // esi
  int v45; // edi
  int v46; // ebx
  int v47; // ecx
  int v48; // esi
  int v49; // edi
  int v50; // edx
  int v51; // ecx
  int v52; // esi
  int v53; // edi
  int v54; // edx
  int v55; // ecx
  int v56; // esi
  int v57; // ebp
  int v58; // edi
  int v59; // edx
  int v60; // ecx
  int v61; // esi
  int v62; // edi
  int v63; // edx
  int v64; // ecx
  int v65; // esi
  int v66; // edi
  int v67; // edx
  int v68; // ecx
  int v69; // esi
  int v70; // edi
  int v71; // ebx
  int v72; // edx
  int v73; // esi
  int v74; // ecx
  int v75; // ebp
  int v76; // edi
  int v77; // ecx
  int v78; // edx
  int i; // ecx
  int v80; // [esp+10h] [ebp-20h]
  int v81; // [esp+10h] [ebp-20h]
  int v82; // [esp+10h] [ebp-20h]
  int v84[4]; // [esp+20h] [ebp-10h]

  **(_DWORD **)this ^= a2;
  result = *(_DWORD **)this;
  v3 = __ROL4__(**(_DWORD **)this - 681945657, 7) - 271734071;
  v4 = v3 + __ROL4__((v3 & 0xEFCDAAC9 | ~v3 & 0x98BACD4E) + *(_DWORD *)(*(_DWORD *)this + 4) - 107344724, 12);
  v5 = v4 + __ROL4__((v3 & v4 | ~v4 & 0xEFCDAAC9) + *(_DWORD *)(*(_DWORD *)this + 8) - 1126481991, 17);
  v6 = *(_DWORD *)(*(_DWORD *)this + 16);
  v7 = __ROL4__((v5 & v4 | v3 & ~v5) + *(_DWORD *)(*(_DWORD *)this + 12) - 1319441881, 22);
  v8 = v6 + ((v5 + v7) & v5 | v4 & ~(v5 + v7)) + v3 - 177010401;
  v9 = v5 + v7;
  v10 = v9 + __ROL4__(v8, 7);
  v11 = v10 + __ROL4__(result[5] + (v10 & v9 | v5 & ~v10) + v4 + 1200080794, 12);
  v12 = v11 + __ROL4__(result[6] + (v10 & v11 | v9 & ~v11) + v5 - 1472706653, 17);
  v13 = __ROL4__(result[7] + (v12 & v11 | v10 & ~v12) + v9 - 45706063, 22);
  v14 = result[8] + ((v12 + v13) & v12 | v11 & ~(v12 + v13)) + v10 + 1753258344;
  v15 = v12 + v13;
  v16 = v15 + __ROL4__(v14, 7);
  v17 = v16 + __ROL4__(result[9] + (v16 & v15 | v12 & ~v16) + v11 - 1958414817, 12);
  v18 = v17 + __ROL4__(result[10] + (v16 & v17 | v15 & ~v17) + v12 - 7382527, 17);
  v19 = __ROL4__(result[11] + (v18 & v17 | v16 & ~v18) + v15 - 1987258866, 22);
  v80 = v18 + v19;
  v20 = v18 + v19 + __ROL4__(result[12] + ((v18 + v19) & v18 | v17 & ~(v18 + v19)) + v16 + 1804605842, 7);
  v21 = v20 + __ROL4__(result[13] + (v20 & (v18 + v19) | v18 & ~v20) + v17 - 40341469, 12);
  v22 = v21 + __ROL4__(v18 + result[14] + (v20 & v21 | (v18 + v19) & ~v21) - 1502002626, 17);
  v23 = v22 + __ROL4__(result[15] + (v22 & v21 | v20 & ~v22) + v80 + 1232341393, 22);
  v24 = v23 + __ROL4__(result[1] + (v23 & v21 | v22 & ~v21) + v20 - 166648622, 5);
  v25 = v24 + __ROL4__(result[6] + (v24 & v22 | v23 & ~v22) + v21 - 985615632, 9);
  v26 = v25 + __ROL4__(result[11] + (v23 & v25 | v24 & ~v23) + v22 + 643714017, 14);
  v27 = v26 + __ROL4__(*result + (v24 & v26 | v25 & ~v24) + v23 - 374028774, 20);
  v28 = __ROL4__(result[5] + (v27 & v25 | v26 & ~v25) + v24 - 702082579, 5);
  v81 = v27 + v28;
  v29 = v27 + v28 + __ROL4__(result[10] + ((v27 + v28) & v26 | v27 & ~v26) + v25 + 39065059, 9);
  v30 = v29 + __ROL4__(result[15] + (v27 & v29 | (v27 + v28) & ~v27) + v26 - 660515023, 14);
  v31 = v30 + __ROL4__(result[4] + ((v27 + v28) & v30 | v29 & ~(v27 + v28)) + v27 - 405538184, 20);
  v32 = __ROL4__(result[9] + (v31 & v29 | v30 & ~v29) + v81 + 568642646, 5);
  v33 = result[14] + ((v31 + v32) & v30 | v31 & ~v30) + v29 - 1019804058;
  v34 = v31 + v32;
  v35 = v34 + __ROL4__(v33, 9);
  v36 = v35 + __ROL4__(result[3] + (v31 & v35 | v34 & ~v31) + v30 - 187366857, 14);
  v37 = result[8];
  v38 = v36 + __ROL4__(v37 + (v34 & v36 | v35 & ~v34) + v31 + 1163531613, 20);
  v39 = __ROL4__(result[13] + (v38 & v35 | v36 & ~v35) + v34 - 1456215883, 5);
  v82 = v38 + v39;
  v40 = v38 + v39 + __ROL4__(result[2] + ((v38 + v39) & v36 | v38 & ~v36) + v35 - 51404216, 9);
  v41 = v40 + __ROL4__(v36 + result[7] + (v38 & v40 | (v38 + v39) & ~v38) + 1735327849, 14);
  v42 = v41 + __ROL4__(result[12] + (v82 & v41 | v40 & ~v82) + v38 - 1926673094, 20);
  v43 = v42 + __ROL4__(result[5] + (v42 ^ v41 ^ v40) + v82 - 235259662, 4);
  v44 = v43 + __ROL4__(v40 + v37 + (v43 ^ v42 ^ v41) - 2022574287, 11);
  v45 = v44 + __ROL4__(result[11] + (v43 ^ v42 ^ v44) + v41 + 1832738962, 16);
  v46 = v45 + __ROL4__(v42 + result[14] + (v43 ^ v45 ^ v44) - 35309124, 23);
  v47 = v46 + __ROL4__(result[1] + (v46 ^ v45 ^ v44) + v43 - 1531024396, 4);
  v48 = v47 + __ROL4__(result[4] + (v47 ^ v46 ^ v45) + v44 + 1272889881, 11);
  v49 = v48 + __ROL4__(result[7] + (v47 ^ v46 ^ v48) + v45 - 155694384, 16);
  v50 = v49 + __ROL4__(result[10] + (v47 ^ v49 ^ v48) + v46 - 1094730304, 23);
  v51 = v50 + __ROL4__(v47 + result[13] + (v50 ^ v49 ^ v48) + 680755062, 4);
  v52 = v51 + __ROL4__(*result + (v51 ^ v50 ^ v49) + v48 - 358537654, 11);
  v53 = v52 + __ROL4__(result[3] + (v51 ^ v50 ^ v52) + v49 - 722501323, 16);
  v54 = v53 + __ROL4__(v50 + result[6] + (v51 ^ v53 ^ v52) + 76029109, 23);
  v55 = v54 + __ROL4__(result[9] + (v54 ^ v53 ^ v52) + v51 - 640363895, 4);
  v56 = v55 + __ROL4__(result[12] + (v55 ^ v54 ^ v53) + v52 - 429156267, 11);
  v57 = result[2];
  v58 = v56 + __ROL4__(result[15] + (v55 ^ v54 ^ v56) + v53 + 530742600, 16);
  v59 = v58 + __ROL4__(v57 + (v55 ^ v58 ^ v56) + v54 - 995346475, 23);
  v60 = v59 + __ROL4__(*result + (v58 ^ (v59 | ~v56)) + v55 - 197909516, 6);
  v61 = v60 + __ROL4__(result[7] + (v59 ^ (v60 | ~v58)) + v56 + 1126854183, 10);
  v62 = v61 + __ROL4__(result[14] + (v60 ^ (v61 | ~v59)) + v58 - 1416355305, 15);
  v63 = v62 + __ROL4__(result[5] + (v61 ^ (v62 | ~v60)) + v59 - 57302647, 21);
  v64 = v63 + __ROL4__(result[12] + (v62 ^ (v63 | ~v61)) + v60 + 1700092019, 6);
  v65 = v64 + __ROL4__(result[3] + (v63 ^ (v64 | ~v62)) + v61 - 1894986462, 10);
  v66 = v65 + __ROL4__(result[10] + (v64 ^ (v65 | ~v63)) + v62 - 168823347, 15);
  v67 = v66 + __ROL4__(result[1] + (v65 ^ (v66 | ~v64)) + v63 - 2054923167, 21);
  v68 = v67 + __ROL4__(result[8] + (v66 ^ (v67 | ~v65)) + v64 + 1873117183, 6);
  v69 = v68 + __ROL4__(result[15] + (v67 ^ (v68 | ~v66)) + v65 - 181606576, 10);
  v70 = v69 + __ROL4__(result[6] + (v68 ^ (v69 | ~v67)) + v66 - 1560197980, 15);
  v71 = v70 + __ROL4__(result[13] + (v69 ^ (v70 | ~v68)) + v67 + 1309167633, 21);
  v72 = v71 + __ROL4__(result[4] + (v70 ^ (v71 | ~v69)) + v68 - 145391822, 6);
  v73 = v72 + __ROL4__(result[11] + (v71 ^ (v72 | ~v70)) + v69 + 1161491333, 10);
  v74 = v57 + (v72 ^ (v73 | ~v71));
  v75 = result[9];
  v76 = v73 + __ROL4__(v74 + v70 + 718766859, 15);
  v84[0] = v72 + 1731535537;
  v84[3] = v73 + 288511430;
  v77 = __ROL4__(v75 + (v73 ^ (v76 | ~v72)) + v71 - 346631647, 21) + v76 - 271734071;
  v78 = a2;
  v84[1] = v77;
  v84[2] = v76 - 1732588210;
  for ( i = 0; i < 20; ++i )
  {
    result[i] ^= v78 + v84[i & 3];
    result = *(_DWORD **)this;
    v78 = *(_DWORD *)(*(_DWORD *)this + 4 * i);
  }
  return result;
}

//----- (00459A70) --------------------------------------------------------
CxFile *__thiscall CxFile::CxFile(CxFile *this)
{
  CxFile *result; // eax

  result = this;
  *(_DWORD *)this = &CxFile::`vftable';
  return result;
}
// 4A83D8: using guessed type void *CxFile::`vftable';

//----- (00459A80) --------------------------------------------------------
void __thiscall CxFile::~CxFile(CxFile *this)
{
  *(_DWORD *)this = &CxFile::`vftable';
}
// 4A83D8: using guessed type void *CxFile::`vftable';

//----- (00459A90) --------------------------------------------------------
CxFile *__thiscall CxFile::CxFile(CxFile *this, const struct CxFile *a2)
{
  CxFile *result; // eax

  result = this;
  *(_DWORD *)this = &CxFile::`vftable';
  return result;
}
// 4A83D8: using guessed type void *CxFile::`vftable';

//----- (00459AA0) --------------------------------------------------------
void *__thiscall CxFile::operator=(void *this, int a2)
{
  return this;
}

//----- (00459AB0) --------------------------------------------------------
char *__thiscall sub_459AB0(char *this, char a2)
{
  char *result; // eax

  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 4u, *((_DWORD *)this - 1), (int (__thiscall *)(char *))CxFile::~CxFile);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)(this - 4));
    result = this - 4;
  }
  else
  {
    *(_DWORD *)this = &CxFile::`vftable';
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this);
    result = this;
  }
  return result;
}
// 4A83D8: using guessed type void *CxFile::`vftable';

//----- (00459B10) --------------------------------------------------------
CxMemFile *__thiscall CxMemFile::CxMemFile(CxMemFile *this, unsigned __int8 *a2, unsigned int a3)
{
  CxMemFile *result; // eax

  result = this;
  *((_DWORD *)this + 1) = a2;
  *(_DWORD *)this = &CxMemFile::`vftable';
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = a3;
  *((_DWORD *)this + 2) = a3;
  *((_BYTE *)this + 12) = a2 == 0;
  return result;
}
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (00459B40) --------------------------------------------------------
bool __thiscall CxMemFile::Open(CxMemFile *this)
{
  int v3; // eax

  if ( *((_DWORD *)this + 1) )
    return 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  v3 = sub_46D9FD(0);
  *((_DWORD *)this + 1) = v3;
  *((_BYTE *)this + 12) = 1;
  return v3 != 0;
}

//----- (00459B80) --------------------------------------------------------
unsigned __int8 *__thiscall CxMemFile::GetBuffer(CxMemFile *this)
{
  unsigned __int8 *result; // eax

  result = (unsigned __int8 *)*((_DWORD *)this + 1);
  *((_BYTE *)this + 12) = 0;
  return result;
}

//----- (00459B90) --------------------------------------------------------
CxMemFile *__thiscall CxMemFile::CxMemFile(CxMemFile *this, const struct CxMemFile *a2)
{
  CxMemFile *result; // eax

  result = this;
  *(_DWORD *)this = &CxFile::`vftable';
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_BYTE *)this + 12) = *((_BYTE *)a2 + 12);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)this + 5) = *((_DWORD *)a2 + 5);
  *(_DWORD *)this = &CxMemFile::`vftable';
  return result;
}
// 4A83D8: using guessed type void *CxFile::`vftable';
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (00459BD0) --------------------------------------------------------
int __thiscall CxMemFile::operator=(int this, int a2)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(this + 12) = *(_BYTE *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 20) = *(_DWORD *)(a2 + 20);
  return result;
}

//----- (00459C00) --------------------------------------------------------
void __thiscall CxMemFile::`default constructor closure'(CxMemFile *this)
{
  CxMemFile::CxMemFile(this, 0, 0);
}

//----- (00459C10) --------------------------------------------------------
CxMemFile *__thiscall sub_459C10(CxMemFile *this, char a2)
{
  CxMemFile *result; // eax

  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      (char *)this,
      0x18u,
      *((_DWORD *)this - 1),
      (int (__thiscall *)(char *))CxMemFile::~CxMemFile);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this - 4);
    result = (CxMemFile *)((char *)this - 4);
  }
  else
  {
    CxMemFile::~CxMemFile(this);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this);
    result = this;
  }
  return result;
}

//----- (00459C70) --------------------------------------------------------
unsigned int __thiscall CxMemFile::Read(CxMemFile *this, void *a2, unsigned int a3, unsigned int a4)
{
  int v5; // ebp
  unsigned int result; // eax
  signed int v7; // esi
  signed int v8; // ecx

  v5 = *((_DWORD *)this + 1);
  if ( !v5 )
    return 0;
  if ( !a2 )
    return 0;
  v7 = *((_DWORD *)this + 4);
  v8 = *((_DWORD *)this + 2);
  if ( v7 > v8 )
    return 0;
  result = a4 * a3;
  if ( a4 * a3 )
  {
    if ( (int)(v7 + result) > v8 )
      result = v8 - v7;
    qmemcpy(a2, (const void *)(v5 + v7), result);
    *((_DWORD *)this + 4) += result;
    result /= a3;
  }
  return result;
}

//----- (00459CF0) --------------------------------------------------------
unsigned int __thiscall CxMemFile::Write(CxMemFile *this, const void *a2, unsigned int a3, unsigned int a4)
{
  void *v5; // ecx
  unsigned int v7; // ebp
  signed int v8; // edi
  unsigned int v9; // eax
  size_t v10; // edi
  signed int v11; // ecx
  signed int v12; // edx

  v5 = (void *)*((_DWORD *)this + 1);
  if ( !v5 )
    return 0;
  if ( !a2 )
    return 0;
  v7 = a4 * a3;
  if ( !(a4 * a3) )
    return 0;
  v8 = *((_DWORD *)this + 5);
  v9 = v7 + *((_DWORD *)this + 4);
  if ( (int)v9 > v8 && v9 > v8 )
  {
    v10 = ((v9 - v8 + 4095) >> 12 << 12) + v8;
    *((_DWORD *)this + 1) = sub_46DC4A(v5, v10);
    *((_BYTE *)this + 12) = 1;
    *((_DWORD *)this + 5) = v10;
  }
  qmemcpy((void *)(*((_DWORD *)this + 1) + *((_DWORD *)this + 4)), a2, v7);
  v11 = *((_DWORD *)this + 2);
  v12 = v7 + *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = v12;
  if ( v12 > v11 )
    *((_DWORD *)this + 2) = v12;
  return a4;
}

//----- (00459DA0) --------------------------------------------------------
char __thiscall CxMemFile::Seek(CxMemFile *this, int a2, int a3)
{
  int v3; // eax
  int v4; // eax

  if ( !*((_DWORD *)this + 1) )
    return 0;
  v3 = *((_DWORD *)this + 4);
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 != 2 )
        return 0;
      v3 = *((_DWORD *)this + 2);
    }
    v4 = a2 + v3;
  }
  else
  {
    v4 = a2;
  }
  if ( v4 >= 0 )
  {
    *((_DWORD *)this + 4) = v4;
    return 1;
  }
  return 0;
}

//----- (00459DE0) --------------------------------------------------------
int __thiscall CxMemFile::Tell(CxMemFile *this)
{
  int result; // eax

  if ( *((_DWORD *)this + 1) )
    result = *((_DWORD *)this + 4);
  else
    result = -1;
  return result;
}

//----- (00459DF0) --------------------------------------------------------
int __thiscall CxMemFile::Size(CxMemFile *this)
{
  int result; // eax

  if ( *((_DWORD *)this + 1) )
    result = *((_DWORD *)this + 2);
  else
    result = -1;
  return result;
}

//----- (00459E00) --------------------------------------------------------
bool __thiscall CxMemFile::Flush(CxMemFile *this)
{
  return *((_DWORD *)this + 1) != 0;
}

//----- (00459E10) --------------------------------------------------------
bool __thiscall CxMemFile::Eof(CxMemFile *this)
{
  bool result; // al

  if ( *((_DWORD *)this + 1) )
    result = *((_DWORD *)this + 4) >= *((_DWORD *)this + 2);
  else
    result = 1;
  return result;
}

//----- (00459E30) --------------------------------------------------------
int __thiscall CxMemFile::Error(CxMemFile *this)
{
  int result; // eax

  if ( *((_DWORD *)this + 1) )
    result = *((_DWORD *)this + 4) > *((_DWORD *)this + 2);
  else
    result = -1;
  return result;
}

//----- (00459E50) --------------------------------------------------------
char __thiscall CxMemFile::PutC(CxMemFile *this, unsigned __int8 a2)
{
  void *v3; // ecx
  unsigned int v5; // edi
  int v6; // eax
  size_t v7; // edi
  int v8; // ecx
  int v9; // edx

  v3 = (void *)*((_DWORD *)this + 1);
  if ( !v3 )
    return 0;
  v5 = *((_DWORD *)this + 5);
  v6 = *((_DWORD *)this + 4) + 1;
  if ( v6 > (int)v5 && v6 > v5 )
  {
    v7 = ((v6 - v5 + 4095) >> 12 << 12) + v5;
    *((_DWORD *)this + 1) = sub_46DC4A(v3, v7);
    *((_BYTE *)this + 12) = 1;
    *((_DWORD *)this + 5) = v7;
  }
  *(_BYTE *)(*((_DWORD *)this + 4) + *((_DWORD *)this + 1)) = a2;
  v8 = *((_DWORD *)this + 2);
  v9 = *((_DWORD *)this + 4) + 1;
  *((_DWORD *)this + 4) = v9;
  if ( v9 > v8 )
    *((_DWORD *)this + 2) = v9;
  return 1;
}

//----- (00459EC0) --------------------------------------------------------
int __thiscall CxMemFile::GetC(CxMemFile *this)
{
  int v3; // eax
  int v4; // edx

  if ( (*(unsigned __int8 (__thiscall **)(CxMemFile *))(*(_DWORD *)this + 32))(this) )
    return -1;
  v3 = *((_DWORD *)this + 4);
  v4 = *(unsigned __int8 *)(*((_DWORD *)this + 1) + v3);
  *((_DWORD *)this + 4) = v3 + 1;
  return v4;
}

//----- (00459EF0) --------------------------------------------------------
void __thiscall CxMemFile::Alloc(CxMemFile *this, unsigned int a2)
{
  unsigned int v3; // esi
  size_t v4; // esi
  void *v5; // eax

  v3 = *((_DWORD *)this + 5);
  if ( v3 < a2 )
  {
    v4 = ((a2 - v3 + 4095) >> 12 << 12) + v3;
    v5 = (void *)*((_DWORD *)this + 1);
    if ( v5 )
      *((_DWORD *)this + 1) = sub_46DC4A(v5, v4);
    else
      *((_DWORD *)this + 1) = sub_46D9FD(v4);
    *((_BYTE *)this + 12) = 1;
    *((_DWORD *)this + 5) = v4;
  }
}

//----- (00459F50) --------------------------------------------------------
void __thiscall CxMemFile::Free(CxMemFile *this)
{
  (*(void (__thiscall **)(CxMemFile *))(*(_DWORD *)this + 4))(this);
}

//----- (00459F60) --------------------------------------------------------
CxIOFile *__thiscall CxIOFile::CxIOFile(CxIOFile *this, struct _iobuf *a2)
{
  CxIOFile *result; // eax

  result = this;
  *((_DWORD *)this + 1) = a2;
  *(_DWORD *)this = &CxIOFile::`vftable';
  *((_BYTE *)this + 8) = a2 == 0;
  return result;
}
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (00459F80) --------------------------------------------------------
void __thiscall CxIOFile::~CxIOFile(CxIOFile *this)
{
  FILE *v2; // eax

  v2 = (FILE *)*((_DWORD *)this + 1);
  *(_DWORD *)this = &CxIOFile::`vftable';
  if ( v2 && *((_BYTE *)this + 8) )
  {
    fclose(v2);
    *((_DWORD *)this + 1) = 0;
  }
  *(_DWORD *)this = &CxFile::`vftable';
}
// 4A83D8: using guessed type void *CxFile::`vftable';
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (00459FB0) --------------------------------------------------------
bool __thiscall CxIOFile::Open(CxIOFile *this, const char *a2, const char *a3)
{
  bool result; // al
  FILE *v5; // eax

  if ( *((_DWORD *)this + 1) )
    return 0;
  v5 = sub_46F017((char *)a2, (char *)a3);
  *((_DWORD *)this + 1) = v5;
  if ( !v5 )
    return 0;
  result = 1;
  *((_BYTE *)this + 8) = 1;
  return result;
}

//----- (00459FF0) --------------------------------------------------------
bool __thiscall CxIOFile::Close(CxIOFile *this)
{
  int v2; // eax
  FILE *v3; // ecx

  v2 = 0;
  v3 = (FILE *)*((_DWORD *)this + 1);
  if ( v3 && *((_BYTE *)this + 8) )
  {
    v2 = fclose(v3);
    *((_DWORD *)this + 1) = 0;
  }
  return v2 == 0;
}

//----- (0045A020) --------------------------------------------------------
FILE *__thiscall CxIOFile::Read(CxIOFile *this, void *a2, unsigned int a3, unsigned int a4)
{
  FILE *result; // eax

  result = (FILE *)*((_DWORD *)this + 1);
  if ( result )
    result = (FILE *)sub_46F02A(a2, a3, a4, result);
  return result;
}

//----- (0045A050) --------------------------------------------------------
FILE *__thiscall CxIOFile::Write(CxIOFile *this, const void *a2, unsigned int a3, unsigned int a4)
{
  FILE *result; // eax

  result = (FILE *)*((_DWORD *)this + 1);
  if ( result )
    result = (FILE *)sub_46F141((void *)a2, a3, a4, result);
  return result;
}

//----- (0045A080) --------------------------------------------------------
bool __thiscall CxIOFile::Seek(CxIOFile *this, int Offset, int Origin)
{
  FILE *v3; // eax
  bool result; // al

  v3 = (FILE *)*((_DWORD *)this + 1);
  if ( v3 )
    result = fseek(v3, Offset, Origin) == 0;
  else
    result = 0;
  return result;
}

//----- (0045A0B0) --------------------------------------------------------
int __thiscall CxIOFile::Tell(CxIOFile *this)
{
  int result; // eax

  result = *((_DWORD *)this + 1);
  if ( result )
    result = sub_46F333(*((FILE **)this + 1));
  return result;
}

//----- (0045A0D0) --------------------------------------------------------
int __thiscall CxIOFile::Size(CxIOFile *this)
{
  FILE *v2; // eax
  int v4; // edi
  int v5; // ebx

  v2 = (FILE *)*((_DWORD *)this + 1);
  if ( !v2 )
    return -1;
  v4 = sub_46F333(v2);
  fseek(*((FILE **)this + 1), 0, 2);
  v5 = sub_46F333(*((FILE **)this + 1));
  fseek(*((FILE **)this + 1), v4, 0);
  return v5;
}

//----- (0045A120) --------------------------------------------------------
bool __thiscall CxIOFile::Flush(CxIOFile *this)
{
  bool result; // al

  if ( *((_DWORD *)this + 1) )
    result = fflush(*((FILE **)this + 1)) == 0;
  else
    result = 0;
  return result;
}

//----- (0045A140) --------------------------------------------------------
int __thiscall CxIOFile::Eof(CxIOFile *this)
{
  int v1; // eax
  int result; // eax

  v1 = *((_DWORD *)this + 1);
  if ( v1 )
    result = (*(_DWORD *)(v1 + 12) >> 4) & 1;
  else
    result = 1;
  return result;
}

//----- (0045A160) --------------------------------------------------------
int __thiscall CxIOFile::Error(CxIOFile *this)
{
  int v1; // eax
  int result; // eax

  v1 = *((_DWORD *)this + 1);
  if ( v1 )
    result = *(_DWORD *)(v1 + 12) & 0x20;
  else
    result = -1;
  return result;
}

//----- (0045A180) --------------------------------------------------------
bool __thiscall CxIOFile::PutC(CxIOFile *this, unsigned __int8 a2)
{
  FILE *v2; // eax
  bool result; // al

  v2 = (FILE *)*((_DWORD *)this + 1);
  if ( v2 )
    result = fputc(a2, v2) == a2;
  else
    result = 0;
  return result;
}

//----- (0045A1B0) --------------------------------------------------------
int __thiscall CxIOFile::GetC(CxIOFile *this)
{
  int result; // eax

  if ( *((_DWORD *)this + 1) )
    result = sub_46F698(*((FILE **)this + 1));
  else
    result = -1;
  return result;
}

//----- (0045A1D0) --------------------------------------------------------
CxIOFile *__thiscall CxIOFile::CxIOFile(CxIOFile *this, const struct CxIOFile *a2)
{
  CxIOFile *result; // eax

  result = this;
  *(_DWORD *)this = &CxFile::`vftable';
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_BYTE *)this + 8) = *((_BYTE *)a2 + 8);
  *(_DWORD *)this = &CxIOFile::`vftable';
  return result;
}
// 4A83D8: using guessed type void *CxFile::`vftable';
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (0045A200) --------------------------------------------------------
int __thiscall CxIOFile::operator=(int this, int a2)
{
  int result; // eax

  result = this;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(this + 8) = *(_BYTE *)(a2 + 8);
  return result;
}

//----- (0045A220) --------------------------------------------------------
void __thiscall CxIOFile::`default constructor closure'(CxIOFile *this)
{
  CxIOFile::CxIOFile(this, 0);
}

//----- (0045A250) --------------------------------------------------------
CxIOFile *__thiscall sub_45A250(CxIOFile *this, char a2)
{
  CxIOFile *result; // eax

  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      (char *)this,
      0xCu,
      *((_DWORD *)this - 1),
      (int (__thiscall *)(char *))CxIOFile::~CxIOFile);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this - 4);
    result = (CxIOFile *)((char *)this - 4);
  }
  else
  {
    CxIOFile::~CxIOFile(this);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this);
    result = this;
  }
  return result;
}

//----- (0045A2B0) --------------------------------------------------------
void *__thiscall CxImage::GetDIB(CxImage *this)
{
  return (void *)*((_DWORD *)this + 1);
}

//----- (0045A2C0) --------------------------------------------------------
unsigned int __thiscall CxImage::GetHeight(CxImage *this)
{
  return *((_DWORD *)this + 4);
}

//----- (0045A2D0) --------------------------------------------------------
unsigned int __thiscall CxImage::GetWidth(CxImage *this)
{
  return *((_DWORD *)this + 3);
}

//----- (0045A2E0) --------------------------------------------------------
unsigned int __thiscall CxImage::GetEffWidth(CxImage *this)
{
  return *((_DWORD *)this + 12);
}

//----- (0045A2F0) --------------------------------------------------------
unsigned int __thiscall CxImage::GetNumColors(CxImage *this)
{
  return *((_DWORD *)this + 10);
}

//----- (0045A300) --------------------------------------------------------
unsigned __int16 __thiscall CxImage::GetBpp(CxImage *this)
{
  return *((_WORD *)this + 11);
}

//----- (0045A310) --------------------------------------------------------
unsigned int __thiscall CxImage::GetType(CxImage *this)
{
  return *((_DWORD *)this + 15);
}

//----- (0045A320) --------------------------------------------------------
char *__thiscall CxImage::GetLastError(CxImage *this)
{
  return (char *)this + 64;
}

//----- (0045A330) --------------------------------------------------------
unsigned int __thiscall CxImage::GetFrameDelay(CxImage *this)
{
  return *((_DWORD *)this + 87);
}

//----- (0045A340) --------------------------------------------------------
void __thiscall CxImage::SetFrameDelay(CxImage *this, unsigned int a2)
{
  *((_DWORD *)this + 87) = a2;
}

//----- (0045A350) --------------------------------------------------------
void __thiscall CxImage::GetOffset(CxImage *this, int *a2, int *a3)
{
  *a2 = *((_DWORD *)this + 95);
  *a3 = *((_DWORD *)this + 96);
}

//----- (0045A370) --------------------------------------------------------
void __thiscall CxImage::SetOffset(CxImage *this, int a2, int a3)
{
  *((_DWORD *)this + 95) = a2;
  *((_DWORD *)this + 96) = a3;
}

//----- (0045A390) --------------------------------------------------------
unsigned __int8 __thiscall CxImage::GetJpegQuality(CxImage *this)
{
  return *((_BYTE *)this + 336);
}

//----- (0045A3A0) --------------------------------------------------------
void __thiscall CxImage::SetJpegQuality(CxImage *this, unsigned __int8 a2)
{
  *((_BYTE *)this + 336) = a2;
}

//----- (0045A3B0) --------------------------------------------------------
int __thiscall CxImage::GetXDPI(CxImage *this)
{
  return *((_DWORD *)this + 88);
}

//----- (0045A3C0) --------------------------------------------------------
int __thiscall CxImage::GetYDPI(CxImage *this)
{
  return *((_DWORD *)this + 89);
}

//----- (0045A3D0) --------------------------------------------------------
int __thiscall CxImage::GetProgress(CxImage *this)
{
  return *((_DWORD *)this + 80);
}

//----- (0045A3E0) --------------------------------------------------------
int __thiscall CxImage::GetEscape(CxImage *this)
{
  return *((_DWORD *)this + 81);
}

//----- (0045A3F0) --------------------------------------------------------
void __thiscall CxImage::SetProgress(CxImage *this, int a2)
{
  *((_DWORD *)this + 80) = a2;
}

//----- (0045A400) --------------------------------------------------------
void __thiscall CxImage::SetEscape(CxImage *this, int a2)
{
  *((_DWORD *)this + 81) = a2;
}

//----- (0045A410) --------------------------------------------------------
int __thiscall CxImage::GetTransIndex(CxImage *this)
{
  return *((_DWORD *)this + 82);
}

//----- (0045A420) --------------------------------------------------------
void __thiscall CxImage::SetTransIndex(CxImage *this, int a2)
{
  *((_DWORD *)this + 82) = a2;
}

//----- (0045A430) --------------------------------------------------------
void __thiscall CxImage::SetTransColor(CxImage *this, struct tagRGBQUAD a2)
{
  *((struct tagRGBQUAD *)this + 83) = a2;
}

//----- (0045A440) --------------------------------------------------------
BOOL __thiscall CxImage::IsTransparent(CxImage *this)
{
  return *((_DWORD *)this + 82) >= 0;
}

//----- (0045A450) --------------------------------------------------------
unsigned int __thiscall CxImage::GetEncodeOption(CxImage *this)
{
  return *((_DWORD *)this + 97);
}

//----- (0045A460) --------------------------------------------------------
void __thiscall CxImage::SetEncodeOption(CxImage *this, unsigned int a2)
{
  *((_DWORD *)this + 97) = a2;
}

//----- (0045A470) --------------------------------------------------------
BOOL __thiscall CxImage::IsIndexed(CxImage *this)
{
  return *((_DWORD *)this + 10) != 0;
}

//----- (0045A480) --------------------------------------------------------
BOOL __thiscall CxImage::IsValid(CxImage *this)
{
  return *((_DWORD *)this + 1) != 0;
}

//----- (0045A490) --------------------------------------------------------
bool __thiscall CxImage::IsEnabled(CxImage *this)
{
  return *((_BYTE *)this + 378);
}

//----- (0045A4A0) --------------------------------------------------------
void __thiscall CxImage::Enable(CxImage *this, bool a2)
{
  *((_BYTE *)this + 378) = a2;
}

//----- (0045A4B0) --------------------------------------------------------
int __thiscall CxImage::GetNumFrames(CxImage *this)
{
  return *((_DWORD *)this + 86);
}

//----- (0045A4C0) --------------------------------------------------------
int __thiscall CxImage::GetFrame(CxImage *this)
{
  return *((_DWORD *)this + 85);
}

//----- (0045A4D0) --------------------------------------------------------
void __thiscall CxImage::SetFrame(CxImage *this, int a2)
{
  *((_DWORD *)this + 85) = a2;
}

//----- (0045A4E0) --------------------------------------------------------
void __thiscall CxImage::`default constructor closure'(CxImage *this)
{
  *(_DWORD *)this = &CxImage::`vftable';
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_DWORD *)this + 15) = 0;
  *((_BYTE *)this + 336) = 75;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045A590) --------------------------------------------------------
void __thiscall CxImage::`copy constructor closure'(CxImage *this, const struct CxImage *a2)
{
  int v3; // ebp

  *(_DWORD *)this = &CxImage::`vftable';
  v3 = *((_DWORD *)a2 + 15);
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_DWORD *)this + 15) = v3;
  *((_BYTE *)this + 336) = 75;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
  CxImage::Copy(this, a2, 1, 1, 1);
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045A650) --------------------------------------------------------
void __thiscall CxImage::Startup(CxImage *this, unsigned int a2)
{
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_DWORD *)this + 15) = a2;
  *((_BYTE *)this + 336) = 75;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
}

//----- (0045A6F0) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, unsigned int a2)
{
  *(_DWORD *)this = &CxImage::`vftable';
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_DWORD *)this + 15) = a2;
  *((_BYTE *)this + 336) = 75;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045A820) --------------------------------------------------------
unsigned int __thiscall sub_45A820(unsigned int this, char a2)
{
  unsigned int result; // eax
  int v4; // eax

  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      (char *)this,
      0x190u,
      *(_DWORD *)(this - 4),
      (int (__thiscall *)(char *))CxImage::~CxImage);
    if ( (a2 & 1) != 0 )
      sub_40B7E0(this - 4);
    result = this - 4;
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    *(_DWORD *)this = &CxImage::`vftable';
    if ( v4 && !*(_DWORD *)(this + 56) )
    {
      if ( *(_DWORD *)(this + 392) )
      {
        sub_46D360(*(_DWORD *)(this + 392));
        *(_DWORD *)(this + 392) = 0;
      }
      if ( *(_DWORD *)(this + 396) )
      {
        sub_46D360(*(_DWORD *)(this + 396));
        *(_DWORD *)(this + 396) = 0;
      }
      sub_46D360(*(_DWORD *)(this + 4));
      *(_DWORD *)(this + 4) = 0;
    }
    if ( (a2 & 1) != 0 )
      sub_40B7E0(this);
    result = this;
  }
  return result;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045A8D0) --------------------------------------------------------
void __thiscall CxImage::~CxImage(CxImage *this)
{
  int v2; // eax

  v2 = *((_DWORD *)this + 1);
  *(_DWORD *)this = &CxImage::`vftable';
  if ( v2 && !*((_DWORD *)this + 14) )
  {
    if ( *((_DWORD *)this + 98) )
    {
      sub_46D360(*((_DWORD *)this + 98));
      *((_DWORD *)this + 98) = 0;
    }
    if ( *((_DWORD *)this + 99) )
    {
      sub_46D360(*((_DWORD *)this + 99));
      *((_DWORD *)this + 99) = 0;
    }
    sub_46D360(*((_DWORD *)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045A940) --------------------------------------------------------
void __thiscall CxImage::Destroy(CxImage *this)
{
  if ( *((_DWORD *)this + 1) && !*((_DWORD *)this + 14) )
  {
    if ( *((_DWORD *)this + 98) )
    {
      sub_46D360(*((_DWORD *)this + 98));
      *((_DWORD *)this + 98) = 0;
    }
    if ( *((_DWORD *)this + 99) )
    {
      sub_46D360(*((_DWORD *)this + 99));
      *((_DWORD *)this + 99) = 0;
    }
    sub_46D360(*((_DWORD *)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
}

//----- (0045A9A0) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, unsigned int a2, unsigned int a3, int a4, int a5)
{
  *(_DWORD *)this = &CxImage::`vftable';
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_BYTE *)this + 336) = 75;
  *((_DWORD *)this + 15) = a5;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
  CxImage::Create(this, a2, a3, a4, a5);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045AA60) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, const struct CxImage *a2, bool a3, bool a4, bool a5)
{
  int v6; // ebp

  *(_DWORD *)this = &CxImage::`vftable';
  v6 = *((_DWORD *)a2 + 15);
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_DWORD *)this + 1) = 0;
  memset((char *)this + 8, 0, 0x28u);
  *((_DWORD *)this + 2) = 40;
  memset((char *)this + 48, 0, 0x158u);
  *((_DWORD *)this + 15) = v6;
  *((_BYTE *)this + 336) = 75;
  *((_BYTE *)this + 376) = -1;
  *((_DWORD *)this + 82) = -1;
  *((_BYTE *)this + 378) = 1;
  *((_DWORD *)this + 88) = 72;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(2835.145669291338);
  *((_DWORD *)this + 89) = 72;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(2835.145669291338);
  CxImage::Copy(this, a2, a3, a4, a5);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045AB30) --------------------------------------------------------
void __thiscall CxImage::Copy(CxImage *this, const struct CxImage *a2, bool a3, bool a4, bool a5)
{
  struct tagRGBQUAD *v6; // eax
  size_t v7; // esi
  void *v8; // eax
  void *v9; // eax

  qmemcpy((char *)this + 48, (char *)a2 + 48, 0x158u);
  CxImage::Create(this, *((_DWORD *)a2 + 3), *((_DWORD *)a2 + 4), *((unsigned __int16 *)a2 + 11), *((_DWORD *)a2 + 15));
  if ( a3 && *((_DWORD *)this + 1) && *((_DWORD *)a2 + 1) )
  {
    qmemcpy(
      *((void **)this + 1),
      *((const void **)a2 + 1),
      *((_DWORD *)this + 2) + *((_DWORD *)this + 7) + CxImage::GetPaletteSize(this));
  }
  else
  {
    v6 = CxImage::GetPalette(a2);
    CxImage::SetPalette(this, v6, 0x100u);
  }
  v7 = *((_DWORD *)this + 3) * *((_DWORD *)this + 4);
  if ( a4 && *((_DWORD *)a2 + 98) )
  {
    if ( *((_DWORD *)this + 98) )
      sub_46D360(*((_DWORD *)this + 98));
    v8 = (void *)sub_46D9FD(v7);
    *((_DWORD *)this + 98) = v8;
    qmemcpy(v8, *((const void **)a2 + 98), v7);
  }
  if ( a5 && *((_DWORD *)a2 + 99) )
  {
    if ( *((_DWORD *)this + 99) )
      sub_46D360(*((_DWORD *)this + 99));
    v9 = (void *)sub_46D9FD(v7);
    *((_DWORD *)this + 99) = v9;
    qmemcpy(v9, *((const void **)a2 + 99), v7);
  }
}

//----- (0045AC70) --------------------------------------------------------
void __thiscall CxImage::CopyInfo(CxImage *this, const struct CxImage *a2)
{
  if ( !*((_DWORD *)this + 1) )
    qmemcpy((char *)this + 48, (char *)a2 + 48, 0x158u);
}

//----- (0045AC90) --------------------------------------------------------
CxImage *__thiscall CxImage::operator=(CxImage *this, struct CxImage *a2)
{
  if ( this != a2 )
    CxImage::Copy(this, a2, 1, 1, 1);
  return this;
}

//----- (0045ACB0) --------------------------------------------------------
void *__thiscall CxImage::Create(CxImage *this, unsigned int a2, unsigned int a3, int a4, int a5)
{
  int v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // eax
  void *result; // eax
  struct tagRGBQUAD *v12; // edi
  _DWORD *v13; // esi

  if ( *((_DWORD *)this + 1) && !*((_DWORD *)this + 14) )
  {
    if ( *((_DWORD *)this + 98) )
    {
      sub_46D360(*((_DWORD *)this + 98));
      *((_DWORD *)this + 98) = 0;
    }
    if ( *((_DWORD *)this + 99) )
    {
      sub_46D360(*((_DWORD *)this + 99));
      *((_DWORD *)this + 99) = 0;
    }
    sub_46D360(*((_DWORD *)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
  if ( a4 > 1 )
  {
    if ( a4 > 4 )
      v6 = a4 > 8 ? 24 : 8;
    else
      v6 = 4;
  }
  else
  {
    v6 = 1;
  }
  switch ( v6 )
  {
    case 1:
      *((_DWORD *)this + 10) = 2;
      break;
    case 4:
      *((_DWORD *)this + 10) = 16;
      break;
    case 8:
      *((_DWORD *)this + 10) = 256;
      break;
    default:
      *((_DWORD *)this + 10) = 0;
      break;
  }
  *((_DWORD *)this + 3) = a2;
  v7 = 4 * ((v6 * a2 + 31) >> 5);
  *((_DWORD *)this + 12) = v7;
  *((_WORD *)this + 11) = v6;
  *((_DWORD *)this + 15) = a5;
  *((_DWORD *)this + 4) = a3;
  *((_WORD *)this + 10) = 1;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 7) = a3 * v7;
  *((_DWORD *)this + 11) = 0;
  v8 = (_DWORD *)((char *)this + 8);
  v9 = CxImage::GetPaletteSize(this);
  v10 = sub_46D9FD(*((_DWORD *)this + 7) + *((_DWORD *)this + 2) + v9);
  *((_DWORD *)this + 1) = v10;
  if ( !v10 )
    return 0;
  memset(*((void **)this + 1), 0, *((_DWORD *)this + 7) + *v8 + CxImage::GetPaletteSize(this));
  v12 = CxImage::GetPalette(this);
  if ( v12 )
    memset(v12, 0, CxImage::GetPaletteSize(this));
  qmemcpy(*((void **)this + 1), v8, 0x28u);
  v13 = (_DWORD *)*((_DWORD *)this + 1);
  if ( v13 )
  {
    *((_DWORD *)this + 13) = (char *)v13 + *v13 + CxImage::GetPaletteSize(this);
    result = v13;
  }
  else
  {
    *((_DWORD *)this + 13) = 0;
    result = 0;
  }
  return result;
}

//----- (0045AE50) --------------------------------------------------------
unsigned __int8 *__thiscall CxImage::GetBits(CxImage *this)
{
  _DWORD *v1; // eax
  unsigned __int8 *result; // eax

  v1 = (_DWORD *)*((_DWORD *)this + 1);
  if ( v1 )
    result = (unsigned __int8 *)v1 + *v1 + CxImage::GetPaletteSize(this);
  else
    result = 0;
  return result;
}

//----- (0045AE70) --------------------------------------------------------
int __thiscall CxImage::GetSize(CxImage *this)
{
  return *((_DWORD *)this + 2) + *((_DWORD *)this + 7) + CxImage::GetPaletteSize(this);
}

//----- (0045AE90) --------------------------------------------------------
BOOL __thiscall CxImage::IsInside(CxImage *this, int a2, int a3)
{
  return a3 >= 0 && a3 < *((_DWORD *)this + 4) && a2 >= 0 && a2 < *((_DWORD *)this + 3);
}

//----- (0045AEC0) --------------------------------------------------------
void __userpurge CxImage::Clear(CxImage *this@<ecx>, int a2@<ebx>, unsigned __int8 a3)
{
  char *v3; // edi
  unsigned int v4; // edx
  int v5; // eax

  if ( *((_DWORD *)this + 1) )
  {
    LOBYTE(a2) = a3;
    v3 = (char *)*((_DWORD *)this + 13);
    BYTE1(a2) = a3;
    v4 = *((_DWORD *)this + 7);
    v5 = a2 << 16;
    LOWORD(v5) = a2;
    memset32(v3, v5, v4 >> 2);
    memset(&v3[4 * (v4 >> 2)], a3, v4 & 3);
  }
}
// 45AEC0: could not find valid save-restore pair for ebx

//----- (0045AF00) --------------------------------------------------------
void __thiscall CxImage::Transfer(CxImage *this, struct CxImage *a2)
{
  if ( *((_DWORD *)this + 1) && !*((_DWORD *)this + 14) )
  {
    if ( *((_DWORD *)this + 98) )
    {
      sub_46D360(*((_DWORD *)this + 98));
      *((_DWORD *)this + 98) = 0;
    }
    if ( *((_DWORD *)this + 99) )
    {
      sub_46D360(*((_DWORD *)this + 99));
      *((_DWORD *)this + 99) = 0;
    }
    sub_46D360(*((_DWORD *)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
  qmemcpy((char *)this + 8, (char *)a2 + 8, 0x28u);
  qmemcpy((char *)this + 48, (char *)a2 + 48, 0x158u);
  *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
  *((_DWORD *)this + 98) = *((_DWORD *)a2 + 98);
  *((_DWORD *)this + 99) = *((_DWORD *)a2 + 99);
  memset((char *)a2 + 8, 0, 0x28u);
  memset((char *)a2 + 48, 0, 0x158u);
  *((_DWORD *)a2 + 1) = 0;
}

//----- (0045AFC0) --------------------------------------------------------
void __thiscall CxImage::Ghost(CxImage *this, struct CxImage *a2)
{
  if ( a2 )
  {
    qmemcpy((char *)this + 8, (char *)a2 + 8, 0x28u);
    qmemcpy((char *)this + 48, (char *)a2 + 48, 0x158u);
    *((_DWORD *)this + 1) = *((_DWORD *)a2 + 1);
    *((_DWORD *)this + 98) = *((_DWORD *)a2 + 98);
    *((_DWORD *)this + 99) = *((_DWORD *)a2 + 99);
    *((_DWORD *)this + 14) = a2;
  }
}

//----- (0045B010) --------------------------------------------------------
void __thiscall CxImage::Bitfield2RGB(CxImage *this, unsigned __int8 *a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int8 a6)
{
  CxImage *v6; // esi
  int v7; // ecx
  int v8; // eax
  unsigned __int8 *v9; // ebx
  int v10; // edx
  _BYTE *v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // ebx
  int v14; // esi
  char v15; // dl
  char v16; // dl
  char v17; // di
  char v18; // bp
  int i; // eax
  char v20; // di
  int v21; // kr00_4
  int v22; // edx
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v26; // eax
  unsigned __int8 *v27; // edi
  int v28; // esi
  int v29; // edx
  __int16 v30; // ax
  int v32; // [esp+14h] [ebp-1Ch]
  int v33; // [esp+18h] [ebp-18h]
  int v34; // [esp+1Ch] [ebp-14h]
  char v35; // [esp+24h] [ebp-Ch]
  char v36; // [esp+28h] [ebp-8h]
  char v37; // [esp+2Ch] [ebp-4h]
  int v38; // [esp+3Ch] [ebp+Ch]
  int v39; // [esp+40h] [ebp+10h]
  int v40; // [esp+44h] [ebp+14h]
  int v41; // [esp+44h] [ebp+14h]

  v6 = this;
  if ( a6 == 16 )
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    for ( i = 0; i < 16; ++i )
    {
      if ( ((a3 >> i) & 1) != 0 )
        ++v16;
      if ( ((a4 >> i) & 1) != 0 )
        ++v17;
      if ( ((a5 >> i) & 1) != 0 )
        ++v18;
    }
    v20 = v16 + v17;
    v35 = 8 - v16;
    v21 = *((_DWORD *)this + 3) + 1;
    v22 = *((_DWORD *)this + 13);
    v23 = 4 * (v21 / 2);
    v24 = *((_DWORD *)this + 4) - 1;
    v36 = v20 - 8;
    v37 = v20 + v18 - 8;
    v34 = *((_DWORD *)v6 + 13);
    v41 = v24;
    if ( v24 >= 0 )
    {
      v25 = v23 * v24;
      v32 = v23 * v24;
      do
      {
        v26 = *((_DWORD *)v6 + 3) - 1;
        if ( v26 >= 0 )
        {
          v27 = &a2[2 * v26 + v25];
          v28 = v24 * *((_DWORD *)v6 + 12) + v22 + 2 * (*((_DWORD *)v6 + 3) - 1) + *((_DWORD *)v6 + 3);
          v29 = v26 + 1;
          do
          {
            v28 -= 3;
            v30 = *v27 + (v27[1] << 8);
            v27 -= 2;
            *(_BYTE *)(v28 - 1 + 3) = ((unsigned __int8)v30 & (unsigned __int8)a5) << v35;
            *(_BYTE *)(v28 + 3) = (unsigned __int16)(a4 & v30) >> v36;
            --v29;
            *(_BYTE *)(v28 + 4) = (unsigned __int16)(a3 & v30) >> v37;
          }
          while ( v29 );
          v24 = v41;
          v22 = v34;
          v6 = this;
          v25 = v32;
        }
        --v24;
        v25 += -4 * (v21 / 2);
        v41 = v24;
        v32 = v25;
      }
      while ( v24 >= 0 );
    }
  }
  else if ( a6 == 32 )
  {
    v40 = *((_DWORD *)this + 13);
    v7 = 4 * *((_DWORD *)this + 3);
    v8 = *((_DWORD *)v6 + 4) - 1;
    v38 = v8;
    if ( v8 >= 0 )
    {
      v9 = a2;
      v39 = v7 * v8;
      v33 = -v7;
      do
      {
        v10 = *((_DWORD *)v6 + 3) - 1;
        if ( v10 >= 0 )
        {
          v11 = (_BYTE *)(v8 * *((_DWORD *)v6 + 12) + v40 + 2 * (*((_DWORD *)v6 + 3) - 1) + *((_DWORD *)v6 + 3));
          v12 = (int)&v9[4 * v10 + 1 + v39];
          v13 = (unsigned __int8 *)(a2 - (v9 + 1) + 2);
          v14 = *((_DWORD *)v6 + 3);
          do
          {
            v15 = *(_BYTE *)(v12 - 1);
            v12 -= 4;
            *(v11 - 1) = v15;
            *v11 = *(_BYTE *)(v12 + 4);
            v11[1] = v13[v12 + 4];
            v11 -= 3;
            --v14;
          }
          while ( v14 );
          v6 = this;
          v9 = a2;
          v8 = v38;
        }
        v38 = --v8;
        v39 += v33;
      }
      while ( v8 >= 0 );
    }
  }
}

//----- (0045B250) --------------------------------------------------------
bool __thiscall CxImage::CreateFromARGB(CxImage *this, unsigned int a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned __int8 *v6; // ecx
  unsigned int i; // edx
  unsigned __int8 *v8; // eax
  unsigned int v9; // esi
  unsigned __int8 v10; // bl
  _BYTE *v11; // eax

  if ( !a4 )
    return 0;
  if ( CxImage::Create(this, a2, a3, 24, 0) )
  {
    v6 = a4;
    for ( i = a3 - 1; ; --i )
    {
      v8 = (unsigned __int8 *)(*((_DWORD *)this + 13) + i * *((_DWORD *)this + 12));
      if ( a2 )
      {
        v9 = a2;
        do
        {
          v10 = *v6;
          v6 += 4;
          *v8 = v10;
          v11 = v8 + 1;
          *v11++ = *(v6 - 3);
          *v11 = *(v6 - 2);
          v8 = v11 + 1;
          --v9;
        }
        while ( v9 );
      }
    }
  }
  return 0;
}

//----- (0045B2C0) --------------------------------------------------------
int __cdecl CxImage::CompareColors(const void *a1, const void *a2)
{
  int v2; // esi
  int v3; // edx
  int result; // eax

  v2 = (11 * *(unsigned __int8 *)a1 + 30 * *((unsigned __int8 *)a1 + 2) + 59 * *((unsigned __int8 *)a1 + 1)) / 100;
  v3 = (11 * *(unsigned __int8 *)a2 + 30 * *((unsigned __int8 *)a2 + 2) + 59 * *((unsigned __int8 *)a2 + 1)) / 100;
  if ( v2 == v3 )
    result = 0;
  else
    result = v2 <= v3 ? -1 : 1;
  return result;
}

//----- (0045B360) --------------------------------------------------------
struct tagRGBQUAD __thiscall CxImage::GetTransColor(CxImage *this, _DWORD *a2)
{
  int v2; // eax
  struct tagRGBQUAD result; // eax

  if ( *((_WORD *)this + 11) >= 0x18u || (v2 = *((_DWORD *)this + 82), v2 == -1) )
  {
    result = (struct tagRGBQUAD)a2;
    *a2 = *((_DWORD *)this + 83);
  }
  else
  {
    CxImage::GetPaletteColor(this, a2, v2);
    result = (struct tagRGBQUAD)a2;
  }
  return result;
}

//----- (0045B3A0) --------------------------------------------------------
int __usercall CxImage::GetColorType@<eax>(CxImage *this@<ecx>, int a2@<eax>)
{
  LOBYTE(a2) = *((_WORD *)this + 11) > 8u;
  return a2 + 1;
}

//----- (0045B3B0) --------------------------------------------------------
void __thiscall CxImage::SetXDPI(CxImage *this, int a2)
{
  double v2; // st7

  v2 = (double)a2 * dbl_4AE618;
  *((_DWORD *)this + 88) = a2;
  *((_DWORD *)this + 8) = (__int64)_ceil_default(v2 + dbl_4AD770);
}
// 4AD770: using guessed type double dbl_4AD770;
// 4AE618: using guessed type double dbl_4AE618;

//----- (0045B3F0) --------------------------------------------------------
void __thiscall CxImage::SetYDPI(CxImage *this, int a2)
{
  double v2; // st7

  v2 = (double)a2 * dbl_4AE618;
  *((_DWORD *)this + 89) = a2;
  *((_DWORD *)this + 9) = (__int64)_ceil_default(v2 + dbl_4AD770);
}
// 4AD770: using guessed type double dbl_4AD770;
// 4AE618: using guessed type double dbl_4AE618;

//----- (0045B430) --------------------------------------------------------
char *__thiscall CxImage::GetVersion(CxImage *this)
{
  return aCximage551;
}

//----- (0045B440) --------------------------------------------------------
int __thiscall CxImage::GetPaletteSize(CxImage *this)
{
  return 4 * *((_DWORD *)this + 10);
}

//----- (0045B450) --------------------------------------------------------
void __thiscall CxImage::SetPaletteIndex(CxImage *this, unsigned __int8 a2, char a3, char a4, char a5, unsigned __int8 a6)
{
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // eax

  v6 = *((_DWORD *)this + 1);
  if ( v6 )
  {
    v7 = *((_DWORD *)this + 10);
    if ( v7 )
    {
      if ( a2 < v7 )
      {
        v8 = 4 * a2;
        *(_BYTE *)(v8 + v6 + 40) = a5;
        *(_BYTE *)(++v8 + v6 + 40) = a4;
        *(_BYTE *)(++v8 + v6 + 40) = a3;
        *(_BYTE *)(v8 + v6 + 41) = a6;
      }
    }
  }
}

//----- (0045B4A0) --------------------------------------------------------
void __thiscall CxImage::SetPaletteIndex(CxImage *this, unsigned __int8 a2, struct tagRGBQUAD a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  int v5; // eax

  v3 = *((_DWORD *)this + 1);
  if ( v3 )
  {
    v4 = *((_DWORD *)this + 10);
    if ( v4 )
    {
      if ( a2 < v4 )
      {
        v5 = 4 * a2;
        *(_BYTE *)(v5 + v3 + 40) = a3.rgbBlue;
        *(_BYTE *)(++v5 + v3 + 40) = a3.rgbGreen;
        *(_WORD *)(v5 + 1 + v3 + 40) = *(_WORD *)&a3.rgbRed;
      }
    }
  }
}

//----- (0045B4E0) --------------------------------------------------------
void __thiscall CxImage::SetPaletteIndex(CxImage *this, unsigned __int8 a2, unsigned int a3)
{
  int v3; // esi
  unsigned int v4; // ecx
  int v5; // eax

  v3 = *((_DWORD *)this + 1);
  if ( v3 )
  {
    v4 = *((_DWORD *)this + 10);
    if ( v4 )
    {
      if ( a2 < v4 )
      {
        v5 = 4 * a2;
        *(_BYTE *)(v5 + v3 + 40) = BYTE2(a3);
        *(_BYTE *)(++v5 + v3 + 40) = BYTE1(a3);
        *(_WORD *)(v5 + 1 + v3 + 40) = (unsigned __int8)a3;
      }
    }
  }
}

//----- (0045B530) --------------------------------------------------------
struct tagRGBQUAD *__thiscall CxImage::GetPalette(CxImage *this)
{
  struct tagRGBQUAD *v1; // eax
  struct tagRGBQUAD *result; // eax

  v1 = (struct tagRGBQUAD *)*((_DWORD *)this + 1);
  if ( v1 && *((_DWORD *)this + 10) )
    result = v1 + 10;
  else
    result = 0;
  return result;
}

//----- (0045B550) --------------------------------------------------------
struct tagRGBQUAD __thiscall CxImage::GetPaletteColor(CxImage *this, _DWORD *a2, unsigned __int8 a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  int v5; // eax
  char v6; // cl
  struct tagRGBQUAD result; // eax
  int v8; // [esp+0h] [ebp-4h]

  v3 = *((_DWORD *)this + 1);
  v8 = 0;
  if ( v3 )
  {
    v4 = *((_DWORD *)this + 10);
    if ( !v4 )
    {
LABEL_5:
      result = (struct tagRGBQUAD)a2;
      *a2 = v8;
      return result;
    }
    if ( a3 < v4 )
    {
      v5 = 4 * a3;
      v6 = *(_BYTE *)(v5 + v3 + 40);
      ++v5;
      LOBYTE(v8) = v6;
      BYTE1(v8) = *(_BYTE *)(v5 + v3 + 40);
      HIWORD(v8) = *(_WORD *)(v5 + 1 + v3 + 40);
      goto LABEL_5;
    }
  }
  result = (struct tagRGBQUAD)a2;
  *a2 = 0;
  return result;
}

//----- (0045B5C0) --------------------------------------------------------
unsigned __int8 __thiscall CxImage::GetPixelIndex(CxImage *this, int a2, int a3)
{
  unsigned __int16 v3; // ax
  int v4; // eax
  char v5; // al
  char v6; // cl
  char v8; // [esp+Ch] [ebp+8h]

  if ( !*((_DWORD *)this + 1) || !*((_DWORD *)this + 10) )
    goto LABEL_15;
  if ( a2 < 0 || a3 < 0 || a2 >= *((_DWORD *)this + 3) || a3 >= *((_DWORD *)this + 4) )
  {
    v4 = *((_DWORD *)this + 82);
    if ( v4 != -1 )
      return v4;
    goto LABEL_15;
  }
  v3 = *((_WORD *)this + 11);
  if ( v3 != 8 )
  {
    v8 = *(_BYTE *)(a3 * *((_DWORD *)this + 12) + ((a2 * v3) >> 3) + *((_DWORD *)this + 13));
    if ( v3 == 4 )
    {
      v5 = 15;
      v6 = 4 - 4 * (a2 & 1);
      return (unsigned __int8)(v8 & (v5 << v6)) >> v6;
    }
    if ( v3 == 1 )
    {
      v5 = 1;
      v6 = 7 - (a2 & 7);
      return (unsigned __int8)(v8 & (v5 << v6)) >> v6;
    }
LABEL_15:
    LOBYTE(v4) = 0;
    return v4;
  }
  LOBYTE(v4) = *(_BYTE *)(*((_DWORD *)this + 13) + a3 * *((_DWORD *)this + 12) + a2);
  return v4;
}
// 45B64D: conditional instruction was optimized away because of '%arg_0.4>=0'
// 45B679: conditional instruction was optimized away because of '%arg_0.4>=0'

//----- (0045B6D0) --------------------------------------------------------
struct tagRGBQUAD __thiscall CxImage::GetPixelColor(CxImage *this, int a2, int a3, int a4)
{
  int v5; // edx
  int v6; // eax
  unsigned __int8 v7; // al
  int v8; // ecx
  unsigned int v9; // esi
  int v10; // eax
  char v11; // dl
  struct tagRGBQUAD result; // eax
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // esi
  int v16; // eax
  char v17; // cl
  int v18; // [esp+Ch] [ebp-4h]
  int v19; // [esp+18h] [ebp+8h]
  int v20; // [esp+18h] [ebp+8h]

  v5 = *((_DWORD *)this + 1);
  v6 = *((_DWORD *)this + 83);
  if ( v5 && a3 >= 0 && a4 >= 0 && a3 < *((_DWORD *)this + 3) && a4 < *((_DWORD *)this + 4) )
  {
    if ( *((_DWORD *)this + 10) )
    {
      v7 = CxImage::GetPixelIndex(this, a3, a4);
      v8 = *((_DWORD *)this + 1);
      v19 = 0;
      if ( v8 )
      {
        v9 = *((_DWORD *)this + 10);
        if ( v9 )
        {
          if ( v7 < v9 )
          {
            v10 = 4 * v7;
            v11 = *(_BYTE *)(v10 + v8 + 40);
            ++v10;
            LOBYTE(v19) = v11;
            BYTE1(v19) = *(_BYTE *)(v10 + v8 + 40);
            HIWORD(v19) = *(_WORD *)(v10 + 1 + v8 + 40);
          }
        }
      }
      result = (struct tagRGBQUAD)a2;
      *(_DWORD *)a2 = v19;
    }
    else
    {
      v13 = 3 * a3 + *((_DWORD *)this + 13) + a4 * *((_DWORD *)this + 12);
      LOWORD(v18) = *(_WORD *)v13;
      HIWORD(v18) = *(unsigned __int8 *)(v13 + 2);
      result = (struct tagRGBQUAD)a2;
      *(_DWORD *)a2 = v18;
    }
  }
  else
  {
    v14 = *((_DWORD *)this + 82);
    if ( v14 != -1 && *((_WORD *)this + 11) < 0x18u )
    {
      v20 = 0;
      if ( v5 )
      {
        v15 = *((_DWORD *)this + 10);
        if ( v15 )
        {
          if ( (unsigned __int8)v14 < v15 )
          {
            v16 = 4 * (unsigned __int8)v14;
            v17 = *(_BYTE *)(v16 + v5 + 40);
            ++v16;
            LOBYTE(v20) = v17;
            BYTE1(v20) = *(_BYTE *)(v16 + v5 + 40);
            HIWORD(v20) = *(_WORD *)(v16 + 1 + v5 + 40);
          }
        }
      }
      v6 = v20;
    }
    *(_DWORD *)a2 = v6;
    result = (struct tagRGBQUAD)a2;
  }
  return result;
}

//----- (0045B840) --------------------------------------------------------
int __thiscall CxImage::GetPixelGray(CxImage *this, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-8h] BYREF

  CxImage::GetPixelColor(this, (int)&v4, a2, a3);
  return (11 * (unsigned __int8)v4 + 59 * BYTE1(v4) + 30 * BYTE2(v4)) / 100;
}

//----- (0045B8B0) --------------------------------------------------------
void __thiscall CxImage::SetPixelIndex(CxImage *this, int a2, int a3, unsigned __int8 a4)
{
  unsigned __int16 v4; // ax
  _BYTE *v5; // esi

  if ( *((_DWORD *)this + 1)
    && *((_DWORD *)this + 10)
    && a2 >= 0
    && a3 >= 0
    && a2 < *((_DWORD *)this + 3)
    && a3 < *((_DWORD *)this + 4) )
  {
    v4 = *((_WORD *)this + 11);
    if ( v4 == 8 )
    {
      *(_BYTE *)(*((_DWORD *)this + 13) + a3 * *((_DWORD *)this + 12) + a2) = a4;
    }
    else
    {
      v5 = (_BYTE *)(*((_DWORD *)this + 13) + a3 * *((_DWORD *)this + 12) + ((a2 * v4) >> 3));
      if ( v4 == 4 )
      {
        *v5 = ((a4 & 0xF) << (4 - 4 * (a2 & 1))) | *v5 & ~(15 << (4 - 4 * (a2 & 1)));
      }
      else if ( v4 == 1 )
      {
        *v5 = ((a4 & 1) << (7 - (a2 & 7))) | *v5 & ~(1 << (7 - (a2 & 7)));
      }
    }
  }
}
// 45B93C: conditional instruction was optimized away because of '%arg_0.4>=0'
// 45B981: conditional instruction was optimized away because of '%arg_0.4>=0'

//----- (0045B9C0) --------------------------------------------------------
void __thiscall CxImage::SetPixelColor(CxImage *this, int a2, int a3, struct tagRGBQUAD a4)
{
  BYTE v5; // cl
  unsigned int v6; // edx
  unsigned __int8 v7; // al
  BYTE *v8; // eax

  v5 = a4.rgbBlue;
  v6 = HIWORD(*(unsigned int *)&a4);
  a4.rgbRed = a4.rgbBlue;
  a4.rgbBlue = v6;
  a4.rgbReserved = 0;
  if ( *((_DWORD *)this + 1) && a2 >= 0 && a3 >= 0 && a2 < *((_DWORD *)this + 3) && a3 < *((_DWORD *)this + 4) )
  {
    if ( *((_DWORD *)this + 10) )
    {
      v7 = CxImage::GetNearestIndex(this, a4);
      CxImage::SetPixelIndex(this, a2, a3, v7);
    }
    else
    {
      v8 = (BYTE *)(3 * a2 + *((_DWORD *)this + 13) + a3 * *((_DWORD *)this + 12));
      *v8++ = v6;
      *v8 = a4.rgbGreen;
      v8[1] = v5;
    }
  }
}

//----- (0045BA50) --------------------------------------------------------
void __thiscall CxImage::SetPixelColor(CxImage *this, int a2, int a3, struct tagRGBQUAD a4, bool a5)
{
  unsigned __int8 v6; // al
  BYTE *v7; // eax

  if ( *((_DWORD *)this + 1) && a2 >= 0 && a3 >= 0 && a2 < *((_DWORD *)this + 3) && a3 < *((_DWORD *)this + 4) )
  {
    if ( *((_DWORD *)this + 10) )
    {
      v6 = CxImage::GetNearestIndex(this, a4);
      CxImage::SetPixelIndex(this, a2, a3, v6);
    }
    else
    {
      v7 = (BYTE *)(*((_DWORD *)this + 13) + 3 * a2 + a3 * *((_DWORD *)this + 12));
      *v7++ = a4.rgbBlue;
      *v7 = a4.rgbGreen;
      v7[1] = a4.rgbRed;
    }
  }
}

//----- (0045BAC0) --------------------------------------------------------
char __thiscall CxImage::GetNearestIndex(CxImage *this, struct tagRGBQUAD a2)
{
  int v2; // edi
  int v3; // eax
  char v4; // cl
  int v5; // ebx
  int v6; // ecx
  unsigned __int8 *i; // edi
  int v8; // ecx
  int v10; // [esp+4h] [ebp-10h]
  char v11; // [esp+8h] [ebp-Ch]

  v2 = *((_DWORD *)this + 1);
  if ( !v2 )
    return 0;
  v3 = *((_DWORD *)this + 10);
  if ( !v3 )
    return 0;
  v4 = 0;
  v5 = 0;
  v10 = 200000;
  v11 = 0;
  if ( v3 > 0 )
  {
    v6 = a2.rgbGreen;
    for ( i = (unsigned __int8 *)(v2 + 41); ; i += 4 )
    {
      v8 = (*i - v6) * (*i - v6)
         + (i[1] - a2.rgbRed) * (i[1] - a2.rgbRed)
         + (*(i - 1) - a2.rgbBlue) * (*(i - 1) - a2.rgbBlue);
      if ( !v8 )
        break;
      if ( v8 < v10 )
      {
        v10 = v8;
        v11 = v5;
      }
      if ( ++v5 >= v3 )
        return v11;
      v6 = a2.rgbGreen;
    }
    v4 = v5;
  }
  return v4;
}

//----- (0045BBA0) --------------------------------------------------------
void __thiscall CxImage::RGBtoBGR(CxImage *this, unsigned __int8 *a2, int a3)
{
  int v3; // edi
  unsigned __int8 *v4; // eax
  unsigned __int8 v5; // cl

  if ( a2 && !*((_DWORD *)this + 10) )
  {
    v3 = a3;
    if ( a3 >= *((_DWORD *)this + 12) )
      v3 = *((_DWORD *)this + 12);
    if ( v3 > 0 )
    {
      v4 = a2 + 2;
      do
      {
        v5 = *(v4 - 2);
        *(v4 - 2) = *v4;
        *v4 = v5;
        v4 += 3;
      }
      while ( (int)&v4[-2 - (_DWORD)a2] < v3 );
    }
  }
}

//----- (0045BBF0) --------------------------------------------------------
struct tagRGBQUAD __thiscall CxImage::RGBtoRGBQUAD(CxImage *this, unsigned int a2, int a3)
{
  char v4; // cl
  struct tagRGBQUAD result; // eax
  int v6; // [esp+8h] [ebp+8h]

  HIWORD(v6) = (unsigned __int8)a3;
  v4 = BYTE1(a3);
  LOBYTE(v6) = BYTE2(a3);
  result = (struct tagRGBQUAD)a2;
  BYTE1(v6) = v4;
  *(_DWORD *)a2 = v6;
  return result;
}

//----- (0045BC20) --------------------------------------------------------
int __thiscall CxImage::RGBQUADtoRGB(CxImage *this, struct tagRGBQUAD a2)
{
  unsigned __int16 v2; // ax

  LOBYTE(v2) = 0;
  HIBYTE(v2) = a2.rgbBlue;
  return a2.rgbRed | ((a2.rgbGreen | v2) << 8);
}

//----- (0045BC50) --------------------------------------------------------
char __thiscall CxImage::GetRGB(CxImage *this, int a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  int v5; // eax
  int v6; // eax

  v5 = *((_DWORD *)this + 1);
  if ( !v5 )
    return 0;
  if ( !*((_DWORD *)this + 10) )
    return 0;
  v6 = v5 + 40;
  if ( !v6 )
    return 0;
  *a3 = *(_BYTE *)(v6 + 4 * a2 + 2);
  *a4 = *(_BYTE *)(v6 + 4 * a2 + 1);
  *a5 = *(_BYTE *)(v6 + 4 * a2);
  return 1;
}

//----- (0045BCA0) --------------------------------------------------------
void __thiscall CxImage::SetPalette(CxImage *this, unsigned int a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  int v5; // edx
  unsigned int v6; // ecx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  unsigned int v9; // ebp
  unsigned __int8 *v10; // esi
  _BYTE *v11; // ecx
  int v12; // edi
  unsigned __int8 v13; // dl

  if ( a3 )
  {
    v5 = *((_DWORD *)this + 1);
    if ( v5 )
    {
      v6 = *((_DWORD *)this + 10);
      if ( v6 )
      {
        v7 = a4;
        if ( !a4 )
          v7 = a3;
        v8 = a5;
        if ( !a5 )
          v8 = v7;
        v9 = a2;
        if ( a2 >= v6 )
          v9 = v6;
        if ( v9 )
        {
          v10 = (unsigned __int8 *)(a3 - v7);
          v11 = (_BYTE *)(v5 + 41);
          v12 = v8 - v7;
          do
          {
            v13 = (v7++)[(_DWORD)v10];
            v11[1] = v13;
            *v11 = *(v7 - 1);
            *(v11 - 1) = v7[v12 - 1];
            v11 += 4;
            --v9;
          }
          while ( v9 );
        }
      }
    }
  }
}

//----- (0045BD10) --------------------------------------------------------
void __thiscall CxImage::SetPalette(CxImage *this, struct rgb_color *a2, unsigned int a3)
{
  int v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // esi
  char *v6; // eax
  _BYTE *v7; // ecx
  char v8; // dl

  if ( a2 )
  {
    v3 = *((_DWORD *)this + 1);
    if ( v3 )
    {
      v4 = *((_DWORD *)this + 10);
      if ( v4 )
      {
        v5 = a3;
        if ( a3 >= v4 )
          v5 = *((_DWORD *)this + 10);
        if ( v5 )
        {
          v6 = (char *)a2 + 2;
          v7 = (_BYTE *)(v3 + 41);
          do
          {
            v8 = *(v6 - 2);
            v6 += 3;
            v7[1] = v8;
            *v7 = *(v6 - 4);
            *(v7 - 1) = *(v6 - 3);
            v7 += 4;
            --v5;
          }
          while ( v5 );
        }
      }
    }
  }
}

//----- (0045BD60) --------------------------------------------------------
void __thiscall CxImage::SetPalette(CxImage *this, struct tagRGBQUAD *a2, unsigned int a3)
{
  int v3; // edx
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // ecx

  if ( a2 )
  {
    v3 = *((_DWORD *)this + 1);
    if ( v3 )
    {
      v4 = *((_DWORD *)this + 10);
      if ( v4 )
      {
        v5 = 4 * v4;
        v6 = 4 * a3;
        if ( v5 < 4 * a3 )
          v6 = v5;
        qmemcpy((void *)(v3 + 40), a2, v6);
      }
    }
  }
}

//----- (0045BDA0) --------------------------------------------------------
void __thiscall CxImage::SetGrayPalette(CxImage *this)
{
  int v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ebx
  int v4; // esi
  char v5; // al

  v1 = *((_DWORD *)this + 1);
  if ( v1 )
  {
    v2 = *((_DWORD *)this + 10);
    if ( v2 )
    {
      v3 = 0;
      v4 = v1 + 41;
      do
      {
        v4 += 4;
        v5 = v3 * (0xFF / (v2 - 1));
        *(_BYTE *)(v4 - 3) = v5;
        *(_BYTE *)(v4 - 4) = v5;
        *(_BYTE *)(v4 - 5) = v5;
        v2 = *((_DWORD *)this + 10);
        ++v3;
      }
      while ( v3 < v2 );
    }
  }
}
// 45BDB3: conditional instruction was optimized away because of 'eax.4!=0'

//----- (0045BDE0) --------------------------------------------------------
void __thiscall CxImage::BlendPalette(CxImage *this, unsigned int a2, int a3)
{
  int v3; // esi
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  int v7; // edx
  int v8; // ebx
  int v9; // ebp
  int v10; // ecx
  int v11; // edi
  int v12; // esi
  int v13; // eax
  unsigned int v15; // [esp+18h] [ebp+4h]

  v3 = *((_DWORD *)this + 1);
  if ( v3 && *((_DWORD *)this + 10) )
  {
    v4 = (unsigned __int8)a2;
    v5 = BYTE2(a2);
    v6 = a3;
    v7 = BYTE1(a2);
    if ( a3 > 100 )
      v6 = 100;
    v15 = 0;
    v8 = v6 * v5;
    v9 = v6 * v7;
    v10 = v6 * v4;
    v11 = 100 - v6;
    v12 = v3 + 42;
    do
    {
      v13 = *(unsigned __int8 *)(v12 - 2);
      v12 += 4;
      *(_BYTE *)(v12 - 6) = (v8 + v11 * v13) / 0x64u;
      *(_BYTE *)(v12 - 5) = (v9 + v11 * (unsigned int)*(unsigned __int8 *)(v12 - 5)) / 0x64;
      *(_BYTE *)(v12 - 4) = (v10 + v11 * (unsigned int)*(unsigned __int8 *)(v12 - 4)) / 0x64;
      ++v15;
    }
    while ( v15 < *((_DWORD *)this + 10) );
  }
}
// 45BE39: conditional instruction was optimized away because of 'edi.4!=0'

//----- (0045BEC0) --------------------------------------------------------
char __thiscall CxImage::IsGrayScale(CxImage *this)
{
  int v1; // eax
  int v2; // edx
  unsigned int v3; // esi
  int v4; // eax
  unsigned __int8 *i; // ecx

  v1 = *((_DWORD *)this + 1);
  if ( v1 && *((_DWORD *)this + 10) )
    v2 = v1 + 40;
  else
    v2 = 0;
  if ( v1 )
  {
    if ( v2 )
    {
      v3 = *((_DWORD *)this + 10);
      if ( v3 )
      {
        v4 = 0;
        for ( i = (unsigned __int8 *)(v2 + 2); *(i - 2) == v4 && *(i - 1) == v4 && *i == v4; i += 4 )
        {
          if ( ++v4 >= v3 )
            return 1;
        }
      }
    }
  }
  return 0;
}
// 45BEE9: conditional instruction was optimized away because of 'esi.4!=0'

//----- (0045BF20) --------------------------------------------------------
void __thiscall CxImage::SwapIndex(CxImage *this, unsigned __int8 a2, unsigned __int8 a3)
{
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // esi
  int v7; // ecx
  char v8; // dl
  char v9; // dl
  char v10; // dl
  char v11; // bl
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  unsigned int v15; // edx
  int v16; // eax
  int i; // ebp
  int j; // esi
  unsigned __int8 v19; // bl
  char v20; // [esp+10h] [ebp-8h]
  char v21; // [esp+11h] [ebp-7h]
  char v22; // [esp+12h] [ebp-6h]
  char v23; // [esp+13h] [ebp-5h]
  char v24; // [esp+15h] [ebp-3h]
  char v25; // [esp+17h] [ebp-1h]

  v4 = *((_DWORD *)this + 1);
  if ( v4 && *((_DWORD *)this + 10) )
    v5 = v4 + 40;
  else
    v5 = 0;
  if ( v4 && v5 )
  {
    v6 = *((_DWORD *)this + 10);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    if ( v6 && a2 < v6 )
    {
      v7 = 4 * a2;
      v8 = *(_BYTE *)(v7 + v4 + 40);
      ++v7;
      v20 = v8;
      v9 = *(_BYTE *)(v7 + v4 + 40);
      ++v7;
      v21 = v9;
      v22 = *(_BYTE *)(v7 + v4 + 40);
      v23 = *(_BYTE *)(v7 + v4 + 41);
    }
    v10 = 0;
    v11 = 0;
    v24 = 0;
    v25 = 0;
    if ( v6 )
    {
      if ( a3 < v6 )
      {
        v12 = 4 * a3;
        v10 = *(_BYTE *)(v12 + v4 + 40);
        v24 = *(_BYTE *)(v12 + v4 + 41);
        v12 += 2;
        v11 = *(_BYTE *)(v12 + v4 + 40);
        v25 = *(_BYTE *)(v12 + v4 + 41);
      }
      if ( a2 < v6 )
      {
        v13 = 4 * a2;
        *(_BYTE *)(v13 + v4 + 40) = v10;
        *(_BYTE *)(++v13 + v4 + 40) = v24;
        *(_BYTE *)(++v13 + v4 + 40) = v11;
        *(_BYTE *)(v13 + v4 + 41) = v25;
      }
    }
    v14 = *((_DWORD *)this + 1);
    if ( v14 )
    {
      v15 = *((_DWORD *)this + 10);
      if ( v15 )
      {
        if ( a3 < v15 )
        {
          v16 = 4 * a3;
          *(_BYTE *)(v16 + v14 + 40) = v20;
          *(_BYTE *)(++v16 + v14 + 40) = v21;
          *(_BYTE *)(++v16 + v14 + 40) = v22;
          *(_BYTE *)(v16 + v14 + 41) = v23;
        }
      }
    }
    for ( i = 0; i < *((_DWORD *)this + 4); ++i )
    {
      for ( j = 0; j <= *((_DWORD *)this + 3); ++j )
      {
        v19 = CxImage::GetPixelIndex(this, j, i);
        if ( v19 == a2 )
          CxImage::SetPixelIndex(this, j, i, a3);
        if ( v19 == a3 )
          CxImage::SetPixelIndex(this, j, i, a2);
      }
    }
  }
}
// 45BFD9: conditional instruction was optimized away because of 'esi.4!=0'

//----- (0045C0B0) --------------------------------------------------------
void __thiscall CxImage::SetStdPalette(CxImage *this)
{
  char *v1; // eax
  int v3; // edi
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  char v7[64]; // [esp+8h] [ebp-440h] BYREF
  char v8[1024]; // [esp+48h] [ebp-400h] BYREF

  v1 = 0;
  v3 = *((_DWORD *)this + 1);
  if ( v3 )
  {
    v4 = *((unsigned __int16 *)this + 11);
    if ( (unsigned __int16)v4 == 4 )
    {
      v7[28] = -64;
      v7[29] = -64;
      v7[30] = -64;
      v6 = *((_DWORD *)this + 10);
      v7[0] = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
      v7[4] = 0;
      v7[5] = 0;
      v7[6] = 0x80;
      v7[7] = 0;
      v7[8] = 0;
      v7[9] = 0x80;
      v7[10] = 0;
      v7[11] = 0;
      v7[12] = 0;
      v7[13] = 0x80;
      v7[14] = 0x80;
      v7[15] = 0;
      v7[16] = 0x80;
      v7[17] = 0;
      v7[18] = 0;
      v7[19] = 0;
      v7[20] = 0x80;
      v7[21] = 0;
      v7[22] = 0x80;
      v7[23] = 0;
      v7[24] = 0x80;
      v7[25] = 0x80;
      v7[26] = 0;
      v7[27] = 0;
      v7[31] = 0;
      v7[32] = 0x80;
      v7[33] = 0x80;
      v7[34] = 0x80;
      v7[35] = 0;
      v7[36] = 0;
      v7[37] = 0;
      v7[38] = -1;
      v7[39] = 0;
      v7[40] = 0;
      v7[41] = -1;
      v7[42] = 0;
      v7[43] = 0;
      v7[44] = 0;
      v7[45] = -1;
      v7[46] = -1;
      v7[47] = 0;
      v7[48] = -1;
      v7[49] = 0;
      v7[50] = 0;
      v7[51] = 0;
      v7[52] = -1;
      v7[53] = 0;
      v7[54] = -1;
      v7[55] = 0;
      v7[56] = -1;
      v7[57] = -1;
      v7[58] = 0;
      v7[59] = 0;
      v7[60] = -1;
      v7[61] = -1;
      v7[62] = -1;
      v7[63] = 0;
      if ( v6 )
        v1 = (char *)(v3 + 40);
      qmemcpy(v1, v7, 0x40u);
    }
    else if ( v4 == 8 )
    {
      v8[28] = -64;
      v8[29] = -64;
      v8[30] = -64;
      v8[32] = -64;
      v8[34] = -64;
      v8[0] = 0;
      v8[1] = 0;
      v8[2] = 0;
      v8[3] = 0;
      v8[4] = 0;
      v8[5] = 0;
      v8[6] = 0x80;
      v8[7] = 0;
      v8[8] = 0;
      v8[9] = 0x80;
      v8[10] = 0;
      v8[11] = 0;
      v8[12] = 0;
      v8[13] = 0x80;
      v8[14] = 0x80;
      v8[15] = 0;
      v8[16] = 0x80;
      v8[17] = 0;
      v8[18] = 0;
      v8[19] = 0;
      v8[20] = 0x80;
      v8[21] = 0;
      v8[22] = 0x80;
      v8[23] = 0;
      v8[24] = 0x80;
      v8[25] = 0x80;
      v8[26] = 0;
      v8[27] = 0;
      v8[31] = 0;
      v8[33] = -36;
      v8[35] = 0;
      v8[36] = -16;
      v8[37] = -54;
      v8[38] = -90;
      v8[39] = 0;
      v8[40] = -44;
      v8[41] = -16;
      v8[42] = -1;
      v8[43] = 0;
      v8[44] = -79;
      v8[45] = -30;
      v8[46] = -1;
      v8[47] = 0;
      v8[48] = -114;
      v8[49] = -44;
      v8[50] = -1;
      v8[51] = 0;
      v8[52] = 107;
      v8[53] = -58;
      v8[54] = -1;
      v8[55] = 0;
      v8[56] = 72;
      v8[57] = -72;
      v8[58] = -1;
      v8[59] = 0;
      v8[60] = 37;
      v8[61] = -86;
      v8[62] = -1;
      v8[63] = 0;
      v8[64] = 0;
      v8[65] = -86;
      v8[66] = -1;
      v8[67] = 0;
      v8[68] = 0;
      v8[69] = -110;
      v8[70] = -36;
      v8[71] = 0;
      v8[72] = 0;
      v8[73] = 122;
      v8[74] = -71;
      v8[75] = 0;
      v8[76] = 0;
      v8[77] = 98;
      v8[78] = -106;
      v8[79] = 0;
      v8[80] = 0;
      strcpy(&v8[81], "Js");
      v8[84] = 0;
      strcpy(&v8[85], "2P");
      v8[88] = -44;
      v8[89] = -29;
      v8[90] = -1;
      v8[91] = 0;
      v8[92] = -79;
      v8[93] = -57;
      v8[94] = -1;
      v8[95] = 0;
      v8[96] = -114;
      v8[97] = -85;
      v8[98] = -1;
      v8[99] = 0;
      v8[100] = 107;
      v8[101] = -113;
      v8[102] = -1;
      v8[103] = 0;
      v8[104] = 72;
      v8[105] = 115;
      v8[106] = -1;
      v8[107] = 0;
      v8[108] = 37;
      v8[109] = 87;
      v8[110] = -1;
      v8[111] = 0;
      v8[112] = 0;
      v8[113] = 85;
      v8[114] = -1;
      v8[115] = 0;
      v8[116] = 0;
      v8[117] = 73;
      v8[118] = -36;
      v8[119] = 0;
      v8[120] = 0;
      v8[121] = 61;
      v8[122] = -71;
      v8[123] = 0;
      v8[124] = 0;
      v8[125] = 49;
      v8[126] = -106;
      v8[127] = 0;
      v8[128] = 0;
      strcpy(&v8[129], "%s");
      v8[132] = 0;
      v8[133] = 25;
      v8[134] = 80;
      v8[135] = 0;
      v8[136] = -44;
      v8[137] = -44;
      v8[138] = -1;
      v8[139] = 0;
      v8[140] = -79;
      v8[141] = -79;
      v8[142] = -1;
      v8[143] = 0;
      v8[144] = -114;
      v8[145] = -114;
      v8[146] = -1;
      v8[147] = 0;
      v8[148] = 107;
      v8[149] = 107;
      v8[150] = -1;
      v8[151] = 0;
      v8[152] = 72;
      v8[153] = 72;
      v8[154] = -1;
      v8[155] = 0;
      v8[156] = 37;
      v8[157] = 37;
      v8[158] = -1;
      v8[159] = 0;
      v8[160] = 0;
      v8[161] = 0;
      v8[162] = -2;
      v8[163] = 0;
      v8[164] = 0;
      v8[165] = 0;
      v8[166] = -36;
      v8[167] = 0;
      v8[168] = 0;
      v8[169] = 0;
      v8[170] = -71;
      v8[171] = 0;
      v8[172] = 0;
      v8[173] = 0;
      v8[174] = -106;
      v8[175] = 0;
      v8[176] = 0;
      v8[177] = 0;
      v8[178] = 115;
      v8[179] = 0;
      v8[180] = 0;
      v8[181] = 0;
      v8[182] = 80;
      v8[183] = 0;
      v8[184] = -29;
      v8[185] = -44;
      v8[186] = -1;
      v8[187] = 0;
      v8[188] = -57;
      v8[189] = -79;
      v8[190] = -1;
      v8[191] = 0;
      v8[192] = -85;
      v8[193] = -114;
      v8[194] = -1;
      v8[195] = 0;
      v8[196] = -113;
      v8[197] = 107;
      v8[198] = -1;
      v8[199] = 0;
      v8[200] = 115;
      v8[201] = 72;
      v8[202] = -1;
      v8[203] = 0;
      v8[204] = 87;
      v8[205] = 37;
      v8[206] = -1;
      v8[207] = 0;
      v8[208] = 85;
      v8[209] = 0;
      v8[210] = -1;
      v8[211] = 0;
      v8[212] = 73;
      v8[213] = 0;
      v8[214] = -36;
      v8[215] = 0;
      v8[216] = 61;
      v8[217] = 0;
      v8[218] = -71;
      v8[219] = 0;
      v8[220] = 49;
      v8[221] = 0;
      v8[222] = -106;
      v8[223] = 0;
      v8[224] = 37;
      v8[225] = 0;
      v8[226] = 115;
      v8[227] = 0;
      v8[228] = 25;
      v8[229] = 0;
      v8[230] = 80;
      v8[231] = 0;
      v8[232] = -16;
      v8[233] = -44;
      v8[234] = -1;
      v8[235] = 0;
      v8[236] = -30;
      v8[237] = -79;
      v8[238] = -1;
      v8[239] = 0;
      v8[240] = -44;
      v8[241] = -114;
      v8[242] = -1;
      v8[243] = 0;
      v8[244] = -58;
      v8[245] = 107;
      v8[246] = -1;
      v8[247] = 0;
      v8[248] = -72;
      v8[249] = 72;
      v8[250] = -1;
      v8[251] = 0;
      v8[252] = -86;
      v8[253] = 37;
      v8[254] = -1;
      v8[255] = 0;
      v8[256] = -86;
      v8[257] = 0;
      v8[258] = -1;
      v8[259] = 0;
      v8[260] = -110;
      v8[261] = 0;
      v8[262] = -36;
      v8[263] = 0;
      v8[264] = 122;
      v8[265] = 0;
      v8[266] = -71;
      v8[267] = 0;
      v8[268] = 98;
      v8[269] = 0;
      v8[270] = -106;
      v8[271] = 0;
      v8[272] = 74;
      v8[273] = 0;
      v8[274] = 115;
      v8[275] = 0;
      v8[276] = 50;
      v8[277] = 0;
      v8[278] = 80;
      v8[279] = 0;
      v8[280] = -1;
      v8[281] = -44;
      v8[282] = -1;
      v8[283] = 0;
      v8[284] = -1;
      v8[285] = -79;
      v8[286] = -1;
      v8[287] = 0;
      v8[288] = -1;
      v8[289] = -114;
      v8[290] = -1;
      v8[291] = 0;
      v8[292] = -1;
      v8[293] = 107;
      v8[294] = -1;
      v8[295] = 0;
      v8[296] = -1;
      v8[297] = 72;
      v8[298] = -1;
      v8[299] = 0;
      v8[300] = -1;
      v8[301] = 37;
      v8[302] = -1;
      v8[303] = 0;
      v8[304] = -2;
      v8[305] = 0;
      v8[306] = -2;
      v8[307] = 0;
      v8[308] = -36;
      v8[309] = 0;
      v8[310] = -36;
      v8[311] = 0;
      v8[312] = -71;
      v8[313] = 0;
      v8[314] = -71;
      v8[315] = 0;
      v8[316] = -106;
      v8[317] = 0;
      v8[318] = -106;
      v8[319] = 0;
      v8[320] = 115;
      v8[321] = 0;
      v8[322] = 115;
      v8[323] = 0;
      v8[324] = 80;
      v8[325] = 0;
      v8[326] = 80;
      v8[327] = 0;
      v8[328] = -1;
      v8[329] = -44;
      v8[330] = -16;
      v8[331] = 0;
      v8[332] = -1;
      v8[333] = -79;
      v8[334] = -30;
      v8[335] = 0;
      v8[336] = -1;
      v8[337] = -114;
      v8[338] = -44;
      v8[339] = 0;
      v8[340] = -1;
      v8[341] = 107;
      v8[342] = -58;
      v8[343] = 0;
      v8[344] = -1;
      v8[345] = 72;
      v8[346] = -72;
      v8[347] = 0;
      v8[348] = -1;
      v8[349] = 37;
      v8[350] = -86;
      v8[351] = 0;
      v8[352] = -1;
      v8[353] = 0;
      v8[354] = -86;
      v8[355] = 0;
      v8[356] = -36;
      v8[357] = 0;
      v8[358] = -110;
      v8[359] = 0;
      v8[360] = -71;
      v8[361] = 0;
      v8[362] = 122;
      v8[363] = 0;
      v8[364] = -106;
      v8[365] = 0;
      v8[366] = 98;
      v8[367] = 0;
      v8[368] = 115;
      v8[369] = 0;
      v8[370] = 74;
      v8[371] = 0;
      v8[372] = 80;
      v8[373] = 0;
      v8[374] = 50;
      v8[375] = 0;
      v8[376] = -1;
      v8[377] = -44;
      v8[378] = -29;
      v8[379] = 0;
      v8[380] = -1;
      v8[381] = -79;
      v8[382] = -57;
      v8[383] = 0;
      v8[384] = -1;
      v8[385] = -114;
      v8[386] = -85;
      v8[387] = 0;
      v8[388] = -1;
      v8[389] = 107;
      v8[390] = -113;
      v8[391] = 0;
      v8[392] = -1;
      strcpy(&v8[393], "Hs");
      v8[396] = -1;
      strcpy(&v8[397], "%W");
      v8[400] = -1;
      v8[401] = 0;
      v8[402] = 85;
      v8[403] = 0;
      v8[404] = -36;
      v8[405] = 0;
      v8[406] = 73;
      v8[407] = 0;
      v8[408] = -71;
      v8[409] = 0;
      v8[410] = 61;
      v8[411] = 0;
      v8[412] = -106;
      v8[413] = 0;
      v8[414] = 49;
      v8[415] = 0;
      v8[416] = 115;
      v8[417] = 0;
      v8[418] = 37;
      v8[419] = 0;
      v8[420] = 80;
      v8[421] = 0;
      v8[422] = 25;
      v8[423] = 0;
      v8[424] = -1;
      v8[425] = -44;
      v8[426] = -44;
      v8[427] = 0;
      v8[428] = -1;
      v8[429] = -79;
      v8[430] = -79;
      v8[431] = 0;
      v8[432] = -1;
      v8[433] = -114;
      v8[434] = -114;
      v8[435] = 0;
      v8[436] = -1;
      strcpy(&v8[437], "kk");
      v8[440] = -1;
      strcpy(&v8[441], "HH");
      v8[444] = -1;
      strcpy(&v8[445], "%%");
      v8[448] = -2;
      v8[449] = 0;
      v8[450] = 0;
      v8[451] = 0;
      v8[452] = -36;
      v8[453] = 0;
      v8[454] = 0;
      v8[455] = 0;
      v8[456] = -71;
      v8[457] = 0;
      v8[458] = 0;
      v8[459] = 0;
      v8[460] = -106;
      v8[461] = 0;
      v8[462] = 0;
      v8[463] = 0;
      v8[464] = 115;
      v8[465] = 0;
      v8[466] = 0;
      v8[467] = 0;
      v8[468] = 80;
      v8[469] = 0;
      v8[470] = 0;
      v8[471] = 0;
      v8[472] = -1;
      v8[473] = -29;
      v8[474] = -44;
      v8[475] = 0;
      v8[476] = -1;
      v8[477] = -57;
      v8[478] = -79;
      v8[479] = 0;
      v8[480] = -1;
      v8[481] = -85;
      v8[482] = -114;
      v8[483] = 0;
      v8[484] = -1;
      v8[485] = -113;
      v8[486] = 107;
      v8[487] = 0;
      v8[488] = -1;
      strcpy(&v8[489], "sH");
      v8[492] = -1;
      strcpy(&v8[493], "W%");
      v8[496] = -1;
      v8[497] = 85;
      v8[498] = 0;
      v8[499] = 0;
      v8[500] = -36;
      v8[501] = 73;
      v8[502] = 0;
      v8[503] = 0;
      v8[504] = -71;
      v8[505] = 61;
      v8[506] = 0;
      v8[507] = 0;
      v8[508] = -106;
      v8[509] = 49;
      v8[510] = 0;
      v8[511] = 0;
      strcpy(&v8[512], "s%");
      v8[515] = 0;
      v8[516] = 80;
      v8[517] = 25;
      v8[518] = 0;
      v8[519] = 0;
      v8[520] = -1;
      v8[521] = -16;
      v8[522] = -44;
      v8[523] = 0;
      v8[524] = -1;
      v8[525] = -30;
      v8[526] = -79;
      v8[527] = 0;
      v8[528] = -1;
      v8[529] = -44;
      v8[530] = -114;
      v8[531] = 0;
      v8[532] = -1;
      v8[533] = -58;
      v8[534] = 107;
      v8[535] = 0;
      v8[536] = -1;
      v8[537] = -72;
      v8[538] = 72;
      v8[539] = 0;
      v8[540] = -1;
      v8[541] = -86;
      v8[542] = 37;
      v8[543] = 0;
      v8[544] = -1;
      v8[545] = -86;
      v8[546] = 0;
      v8[547] = 0;
      v8[548] = -36;
      v8[549] = -110;
      v8[550] = 0;
      v8[551] = 0;
      v8[552] = -71;
      v8[553] = 122;
      v8[554] = 0;
      v8[555] = 0;
      v8[556] = -106;
      v8[557] = 98;
      v8[558] = 0;
      v8[559] = 0;
      strcpy(&v8[560], "sJ");
      v8[563] = 0;
      strcpy(&v8[564], "P2");
      v8[567] = 0;
      v8[568] = -1;
      v8[569] = -1;
      v8[570] = -44;
      v8[571] = 0;
      v8[572] = -1;
      v8[573] = -1;
      v8[574] = -79;
      v8[575] = 0;
      v8[576] = -1;
      v8[577] = -1;
      v8[578] = -114;
      v8[579] = 0;
      v8[580] = -1;
      v8[581] = -1;
      v8[582] = 107;
      v8[583] = 0;
      v8[584] = -1;
      v8[585] = -1;
      v8[586] = 72;
      v8[587] = 0;
      v8[588] = -1;
      v8[589] = -1;
      v8[590] = 37;
      v8[591] = 0;
      v8[592] = -2;
      v8[593] = -2;
      v8[594] = 0;
      v8[595] = 0;
      v8[596] = -36;
      v8[597] = -36;
      v8[598] = 0;
      v8[599] = 0;
      v8[600] = -71;
      v8[601] = -71;
      v8[602] = 0;
      v8[603] = 0;
      v8[604] = -106;
      v8[605] = -106;
      v8[606] = 0;
      v8[607] = 0;
      strcpy(&v8[608], "ss");
      v8[611] = 0;
      strcpy(&v8[612], "PP");
      v8[615] = 0;
      v8[616] = -16;
      v8[617] = -1;
      v8[618] = -44;
      v8[619] = 0;
      v8[620] = -30;
      v8[621] = -1;
      v8[622] = -79;
      v8[623] = 0;
      v8[624] = -44;
      v8[625] = -1;
      v8[626] = -114;
      v8[627] = 0;
      v8[628] = -58;
      v8[629] = -1;
      v8[630] = 107;
      v8[631] = 0;
      v8[632] = -72;
      v8[633] = -1;
      v8[634] = 72;
      v8[635] = 0;
      v8[636] = -86;
      v8[637] = -1;
      v8[638] = 37;
      v8[639] = 0;
      v8[640] = -86;
      v8[641] = -1;
      v8[642] = 0;
      v8[643] = 0;
      v8[644] = -110;
      v8[645] = -36;
      v8[646] = 0;
      v8[647] = 0;
      v8[648] = 122;
      v8[649] = -71;
      v8[650] = 0;
      v8[651] = 0;
      v8[652] = 98;
      v8[653] = -106;
      v8[654] = 0;
      v8[655] = 0;
      strcpy(&v8[656], "Js");
      v8[659] = 0;
      strcpy(&v8[660], "2P");
      v8[663] = 0;
      v8[664] = -29;
      v8[665] = -1;
      v8[666] = -44;
      v8[667] = 0;
      v8[668] = -57;
      v8[669] = -1;
      v8[670] = -79;
      v8[671] = 0;
      v8[672] = -85;
      v8[673] = -1;
      v8[674] = -114;
      v8[675] = 0;
      v8[676] = -113;
      v8[677] = -1;
      v8[678] = 107;
      v8[679] = 0;
      v8[680] = 115;
      v8[681] = -1;
      v8[682] = 72;
      v8[683] = 0;
      v8[684] = 87;
      v8[685] = -1;
      v8[686] = 37;
      v8[687] = 0;
      v8[688] = 85;
      v8[689] = -1;
      v8[690] = 0;
      v8[691] = 0;
      v8[692] = 73;
      v8[693] = -36;
      v8[694] = 0;
      v8[695] = 0;
      v8[696] = 61;
      v8[697] = -71;
      v8[698] = 0;
      v8[699] = 0;
      v8[700] = 49;
      v8[701] = -106;
      v8[702] = 0;
      v8[703] = 0;
      strcpy(&v8[704], "%s");
      v8[707] = 0;
      v8[708] = 25;
      v8[709] = 80;
      v8[710] = 0;
      v8[711] = 0;
      v8[712] = -44;
      v8[713] = -1;
      v8[714] = -44;
      v8[715] = 0;
      v8[716] = -79;
      v8[717] = -1;
      v8[718] = -79;
      v8[719] = 0;
      v8[720] = -114;
      v8[721] = -1;
      v8[722] = -114;
      v8[723] = 0;
      v8[724] = 107;
      v8[725] = -1;
      v8[726] = 107;
      v8[727] = 0;
      v8[728] = 72;
      v8[729] = -1;
      v8[730] = 72;
      v8[731] = 0;
      v8[732] = 37;
      v8[733] = -1;
      v8[734] = 37;
      v8[735] = 0;
      v8[736] = 0;
      v8[737] = -2;
      v8[738] = 0;
      v8[739] = 0;
      v8[740] = 0;
      v8[741] = -36;
      v8[742] = 0;
      v8[743] = 0;
      v8[744] = 0;
      v8[745] = -71;
      v8[746] = 0;
      v8[747] = 0;
      v8[748] = 0;
      v8[749] = -106;
      v8[750] = 0;
      v8[751] = 0;
      v8[752] = 0;
      v8[753] = 115;
      v8[754] = 0;
      v8[755] = 0;
      v8[756] = 0;
      v8[757] = 80;
      v8[758] = 0;
      v8[759] = 0;
      v8[760] = -44;
      v8[761] = -1;
      v8[762] = -29;
      v8[763] = 0;
      v8[764] = -79;
      v8[765] = -1;
      v8[766] = -57;
      v8[767] = 0;
      v8[768] = -114;
      v8[769] = -1;
      v8[770] = -85;
      v8[771] = 0;
      v8[772] = 107;
      v8[773] = -1;
      v8[774] = -113;
      v8[775] = 0;
      v8[776] = 72;
      v8[777] = -1;
      v8[778] = 115;
      v8[779] = 0;
      v8[780] = 37;
      v8[781] = -1;
      v8[782] = 87;
      v8[783] = 0;
      v8[784] = 0;
      v8[785] = -1;
      v8[786] = 85;
      v8[787] = 0;
      v8[788] = 0;
      v8[789] = -36;
      v8[790] = 73;
      v8[791] = 0;
      v8[792] = 0;
      v8[793] = -71;
      v8[794] = 61;
      v8[795] = 0;
      v8[796] = 0;
      v8[797] = -106;
      v8[798] = 49;
      v8[799] = 0;
      v8[800] = 0;
      strcpy(&v8[801], "s%");
      v8[804] = 0;
      v8[805] = 80;
      v8[806] = 25;
      v8[807] = 0;
      v8[808] = -44;
      v8[809] = -1;
      v8[810] = -16;
      v8[811] = 0;
      v8[812] = -79;
      v8[813] = -1;
      v8[814] = -30;
      v8[815] = 0;
      v8[816] = -114;
      v8[817] = -1;
      v8[818] = -44;
      v8[819] = 0;
      v8[820] = 107;
      v8[821] = -1;
      v8[822] = -58;
      v8[823] = 0;
      v8[824] = 72;
      v8[825] = -1;
      v8[826] = -72;
      v8[827] = 0;
      v8[828] = 37;
      v8[829] = -1;
      v8[830] = -86;
      v8[831] = 0;
      v8[832] = 0;
      v8[833] = -1;
      v8[834] = -86;
      v8[835] = 0;
      v8[836] = 0;
      v8[837] = -36;
      v8[838] = -110;
      v8[839] = 0;
      v8[840] = 0;
      v8[841] = -71;
      v8[842] = 122;
      v8[843] = 0;
      v8[844] = 0;
      v8[845] = -106;
      v8[846] = 98;
      v8[847] = 0;
      v8[848] = 0;
      strcpy(&v8[849], "sJ");
      v8[852] = 0;
      strcpy(&v8[853], "P2");
      v8[856] = -44;
      v8[857] = -1;
      v8[858] = -1;
      v8[859] = 0;
      v8[860] = -79;
      v8[861] = -1;
      v8[862] = -1;
      v8[863] = 0;
      v8[864] = -114;
      v8[865] = -1;
      v8[866] = -1;
      v8[867] = 0;
      v8[868] = 107;
      v8[869] = -1;
      v8[870] = -1;
      v8[871] = 0;
      v8[872] = 72;
      v8[873] = -1;
      v8[874] = -1;
      v8[875] = 0;
      v8[876] = 37;
      v8[877] = -1;
      v8[878] = -1;
      v8[879] = 0;
      v8[880] = 0;
      v8[881] = -2;
      v8[882] = -2;
      v8[883] = 0;
      v8[884] = 0;
      v8[885] = -36;
      v8[886] = -36;
      v8[904] = -14;
      v8[905] = -14;
      v8[906] = -14;
      v8[908] = -26;
      v8[909] = -26;
      v8[910] = -26;
      v8[912] = -38;
      v8[913] = -38;
      v8[914] = -38;
      v8[916] = -50;
      v8[917] = -50;
      v8[918] = -50;
      v8[920] = -62;
      v8[921] = -62;
      v8[922] = -62;
      v8[924] = -74;
      v8[925] = -74;
      v8[926] = -74;
      v8[932] = -98;
      v8[933] = -98;
      v8[934] = -98;
      v8[940] = -122;
      v8[941] = -122;
      v8[942] = -122;
      strcpy(&v8[948], "nnn");
      v8[887] = 0;
      v8[888] = 0;
      v8[889] = -71;
      v8[890] = -71;
      v8[891] = 0;
      v8[892] = 0;
      v8[893] = -106;
      v8[894] = -106;
      v8[895] = 0;
      v8[896] = 0;
      strcpy(&v8[897], "ss");
      v8[900] = 0;
      strcpy(&v8[901], "PP");
      v8[907] = 0;
      v8[911] = 0;
      v8[915] = 0;
      v8[919] = 0;
      v8[923] = 0;
      v8[927] = 0;
      v8[928] = -86;
      v8[929] = -86;
      v8[930] = -86;
      v8[931] = 0;
      v8[935] = 0;
      v8[936] = -110;
      v8[937] = -110;
      v8[938] = -110;
      v8[939] = 0;
      v8[943] = 0;
      strcpy(&v8[944], "zzz");
      strcpy(&v8[952], "bbb");
      strcpy(&v8[956], "VVV");
      strcpy(&v8[964], ">>>");
      strcpy(&v8[972], "&&&");
      v8[976] = 26;
      v8[977] = 26;
      v8[978] = 26;
      v8[980] = 14;
      v8[981] = 14;
      v8[982] = 14;
      v8[989] = -96;
      v8[990] = -96;
      v5 = *((_DWORD *)this + 10);
      strcpy(&v8[960], "JJJ");
      strcpy(&v8[968], "222");
      v8[979] = 0;
      v8[983] = 0;
      v8[984] = -16;
      v8[985] = -5;
      v8[986] = -1;
      v8[987] = 0;
      v8[988] = -92;
      v8[991] = 0;
      v8[992] = 0x80;
      v8[993] = 0x80;
      v8[994] = 0x80;
      v8[995] = 0;
      v8[996] = 0;
      v8[997] = 0;
      v8[998] = -1;
      v8[999] = 0;
      v8[1000] = 0;
      v8[1001] = -1;
      v8[1002] = 0;
      v8[1003] = 0;
      v8[1004] = 0;
      v8[1005] = -1;
      v8[1006] = -1;
      v8[1007] = 0;
      v8[1008] = -1;
      v8[1009] = 0;
      v8[1010] = 0;
      v8[1011] = 0;
      v8[1012] = -1;
      v8[1013] = 0;
      v8[1014] = -1;
      v8[1015] = 0;
      v8[1016] = -1;
      v8[1017] = -1;
      v8[1018] = 0;
      v8[1019] = 0;
      v8[1020] = -1;
      v8[1021] = -1;
      v8[1022] = -1;
      v8[1023] = 0;
      if ( v5 )
        v1 = (char *)(v3 + 40);
      qmemcpy(v1, v8, 0x400u);
    }
  }
}

//----- (0045DF30) --------------------------------------------------------
CxImageGIF *__thiscall CxImageGIF::CxImageGIF(CxImageGIF *this)
{
  CxImage::CxImage(this, 2u);
  *(_DWORD *)this = &CxImageGIF::`vftable';
  *((_DWORD *)this + 16016) = 0;
  *((_DWORD *)this + 16017) = 0;
  *((_BYTE *)this + 63808) = 0;
  return this;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';

//----- (0045DF60) --------------------------------------------------------
char __thiscall CxImageGIF::Decode(CxImageGIF *this, struct _iobuf *a2)
{
  char v2; // bl
  void **v4; // [esp+4h] [ebp-18h] BYREF
  FILE *Stream; // [esp+8h] [ebp-14h]
  bool v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  Stream = a2;
  v4 = &CxIOFile::`vftable';
  v6 = a2 == 0;
  v7 = 0;
  v2 = CxImageGIF::Decode(this, (struct CxFile *)&v4);
  v4 = &CxIOFile::`vftable';
  if ( Stream && v6 )
    fclose(Stream);
  return v2;
}
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (0045DFE0) --------------------------------------------------------
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct _iobuf *a2)
{
  char v2; // bl
  void **v4; // [esp+4h] [ebp-18h] BYREF
  FILE *Stream; // [esp+8h] [ebp-14h]
  bool v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  Stream = a2;
  v4 = &CxIOFile::`vftable';
  v6 = a2 == 0;
  v7 = 0;
  v2 = CxImageGIF::Encode(this, (struct CxFile *)&v4);
  v4 = &CxIOFile::`vftable';
  if ( Stream && v6 )
    fclose(Stream);
  return v2;
}
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (0045E060) --------------------------------------------------------
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct _iobuf *a2, struct CxImage **a3, int a4, bool a5)
{
  char v5; // bl
  void **v7; // [esp+4h] [ebp-18h] BYREF
  FILE *Stream; // [esp+8h] [ebp-14h]
  bool v9; // [esp+Ch] [ebp-10h]
  int v10; // [esp+18h] [ebp-4h]

  Stream = a2;
  v7 = &CxIOFile::`vftable';
  v9 = a2 == 0;
  v10 = 0;
  v5 = CxImageGIF::Encode(this, (struct CxFile *)&v7, a3, a4, a5);
  v7 = &CxIOFile::`vftable';
  if ( Stream && v9 )
    fclose(Stream);
  return v5;
}
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (0045E0F0) --------------------------------------------------------
CxImageGIF *__thiscall CxImageGIF::CxImageGIF(CxImageGIF *this, const struct CxImageGIF *a2)
{
  CxImage::CxImage(this, a2, 1, 1, 1);
  *((_DWORD *)this + 100) = *((_DWORD *)a2 + 100);
  *((_DWORD *)this + 101) = *((_DWORD *)a2 + 101);
  *((_DWORD *)this + 102) = *((_DWORD *)a2 + 102);
  *((_DWORD *)this + 103) = *((_DWORD *)a2 + 103);
  *((_DWORD *)this + 104) = *((_DWORD *)a2 + 104);
  *((_DWORD *)this + 105) = *((_DWORD *)a2 + 105);
  *((_DWORD *)this + 106) = *((_DWORD *)a2 + 106);
  *((_DWORD *)this + 107) = *((_DWORD *)a2 + 107);
  *((_DWORD *)this + 108) = *((_DWORD *)a2 + 108);
  *((_DWORD *)this + 109) = *((_DWORD *)a2 + 109);
  *((_DWORD *)this + 110) = *((_DWORD *)a2 + 110);
  *((_DWORD *)this + 111) = *((_DWORD *)a2 + 111);
  *((_DWORD *)this + 112) = *((_DWORD *)a2 + 112);
  qmemcpy((char *)this + 452, (char *)a2 + 452, 0x4001u);
  *((_WORD *)this + 8419) = *((_WORD *)a2 + 8419);
  *((_WORD *)this + 8420) = *((_WORD *)a2 + 8420);
  *((_WORD *)this + 8421) = *((_WORD *)a2 + 8421);
  *((_WORD *)this + 8422) = *((_WORD *)a2 + 8422);
  *((_WORD *)this + 8423) = *((_WORD *)a2 + 8423);
  *((_WORD *)this + 8424) = *((_WORD *)a2 + 8424);
  *((_WORD *)this + 8425) = *((_WORD *)a2 + 8425);
  *((_WORD *)this + 8426) = *((_WORD *)a2 + 8426);
  *((_BYTE *)this + 16854) = *((_BYTE *)a2 + 16854);
  qmemcpy((char *)this + 16855, (char *)a2 + 16855, 0x105u);
  qmemcpy((char *)this + 17116, (char *)a2 + 17116, 0x1000u);
  qmemcpy((char *)this + 21212, (char *)a2 + 21212, 0x1000u);
  qmemcpy((char *)this + 25308, (char *)a2 + 25308, 0x2000u);
  qmemcpy((char *)this + 33500, (char *)a2 + 33500, 0x4E2Cu);
  qmemcpy((char *)this + 53512, (char *)a2 + 53512, 0x2716u);
  *((_DWORD *)this + 15880) = *((_DWORD *)a2 + 15880);
  *((_WORD *)this + 31762) = *((_WORD *)a2 + 31762);
  *((_WORD *)this + 31763) = *((_WORD *)a2 + 31763);
  *((_DWORD *)this + 15882) = *((_DWORD *)a2 + 15882);
  *((_DWORD *)this + 15883) = *((_DWORD *)a2 + 15883);
  *((_DWORD *)this + 15884) = *((_DWORD *)a2 + 15884);
  *((_DWORD *)this + 15885) = *((_DWORD *)a2 + 15885);
  *((_DWORD *)this + 15886) = *((_DWORD *)a2 + 15886);
  *((_DWORD *)this + 15887) = *((_DWORD *)a2 + 15887);
  qmemcpy((char *)this + 63552, (char *)a2 + 63552, 0x100u);
  qmemcpy((char *)this + 63808, (char *)a2 + 63808, 0x108u);
  *(_DWORD *)this = &CxImageGIF::`vftable';
  return this;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';

//----- (0045E370) --------------------------------------------------------
int __thiscall CxImageGIF::operator=(int this, struct CxImage *a2)
{
  char *v3; // eax
  _BYTE *v4; // ecx
  _BYTE *v5; // ecx
  _BYTE *v6; // ecx
  _BYTE *v7; // ecx
  _WORD *v8; // ecx
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  _WORD *v12; // ecx
  int v13; // edx
  _BYTE *v14; // ecx
  _BYTE *v15; // ecx

  CxImage::operator=((CxImage *)this, a2);
  *(_DWORD *)(this + 400) = *((_DWORD *)a2 + 100);
  *(_DWORD *)(this + 404) = *((_DWORD *)a2 + 101);
  *(_DWORD *)(this + 408) = *((_DWORD *)a2 + 102);
  *(_DWORD *)(this + 412) = *((_DWORD *)a2 + 103);
  *(_DWORD *)(this + 416) = *((_DWORD *)a2 + 104);
  *(_DWORD *)(this + 420) = *((_DWORD *)a2 + 105);
  *(_DWORD *)(this + 424) = *((_DWORD *)a2 + 106);
  *(_DWORD *)(this + 428) = *((_DWORD *)a2 + 107);
  *(_DWORD *)(this + 432) = *((_DWORD *)a2 + 108);
  *(_DWORD *)(this + 436) = *((_DWORD *)a2 + 109);
  *(_DWORD *)(this + 440) = *((_DWORD *)a2 + 110);
  *(_DWORD *)(this + 444) = *((_DWORD *)a2 + 111);
  *(_DWORD *)(this + 448) = *((_DWORD *)a2 + 112);
  v3 = (char *)a2 - this;
  v4 = (_BYTE *)(this + 452);
  do
  {
    *v4 = v4[(_DWORD)v3];
    ++v4;
  }
  while ( (unsigned int)&v4[-452 - this] < 0x4001 );
  *(_WORD *)(this + 16838) = *((_WORD *)a2 + 8419);
  *(_WORD *)(this + 16840) = *((_WORD *)a2 + 8420);
  *(_WORD *)(this + 16842) = *((_WORD *)a2 + 8421);
  *(_WORD *)(this + 16844) = *((_WORD *)a2 + 8422);
  *(_WORD *)(this + 16846) = *((_WORD *)a2 + 8423);
  *(_WORD *)(this + 16848) = *((_WORD *)a2 + 8424);
  *(_WORD *)(this + 16850) = *((_WORD *)a2 + 8425);
  *(_WORD *)(this + 16852) = *((_WORD *)a2 + 8426);
  *(_BYTE *)(this + 16854) = *((_BYTE *)a2 + 16854);
  v5 = (_BYTE *)(this + 16855);
  do
  {
    *v5 = v3[(_DWORD)v5];
    ++v5;
  }
  while ( (unsigned int)&v5[-16855 - this] < 0x101 );
  *(_DWORD *)(this + 17112) = *((_DWORD *)a2 + 4278);
  v6 = (_BYTE *)(this + 17116);
  do
  {
    *v6 = v3[(_DWORD)v6];
    ++v6;
  }
  while ( (unsigned int)&v6[-17116 - this] < 0x1000 );
  v7 = (_BYTE *)(this + 21212);
  do
  {
    *v7 = v3[(_DWORD)v7];
    ++v7;
  }
  while ( (unsigned int)&v7[-21212 - this] < 0x1000 );
  v8 = (_WORD *)(this + 25308);
  v9 = 4096;
  do
  {
    *v8 = *(_WORD *)&v3[(_DWORD)v8];
    ++v8;
    --v9;
  }
  while ( v9 );
  v10 = (_DWORD *)(this + 33500);
  v11 = 5003;
  do
  {
    *v10 = *(_DWORD *)&v3[(_DWORD)v10];
    ++v10;
    --v11;
  }
  while ( v11 );
  v12 = (_WORD *)(this + 53512);
  v13 = 5003;
  do
  {
    *v12 = *(_WORD *)&v3[(_DWORD)v12];
    ++v12;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)(this + 63520) = *((_DWORD *)a2 + 15880);
  *(_WORD *)(this + 63524) = *((_WORD *)a2 + 31762);
  *(_WORD *)(this + 63526) = *((_WORD *)a2 + 31763);
  *(_DWORD *)(this + 63528) = *((_DWORD *)a2 + 15882);
  *(_DWORD *)(this + 63532) = *((_DWORD *)a2 + 15883);
  *(_DWORD *)(this + 63536) = *((_DWORD *)a2 + 15884);
  *(_DWORD *)(this + 63540) = *((_DWORD *)a2 + 15885);
  *(_DWORD *)(this + 63544) = *((_DWORD *)a2 + 15886);
  *(_DWORD *)(this + 63548) = *((_DWORD *)a2 + 15887);
  v14 = (_BYTE *)(this + 63552);
  do
  {
    *v14 = v3[(_DWORD)v14];
    ++v14;
  }
  while ( (unsigned int)&v14[-63552 - this] < 0x100 );
  v15 = (_BYTE *)(this + 63808);
  do
  {
    *v15 = v3[(_DWORD)v15];
    ++v15;
  }
  while ( (unsigned int)&v15[-63808 - this] < 0x100 );
  *(_DWORD *)(this + 64064) = *((_DWORD *)a2 + 16016);
  *(_DWORD *)(this + 64068) = *((_DWORD *)a2 + 16017);
  return this;
}

//----- (0045E670) --------------------------------------------------------
CxImageGIF *__thiscall sub_45E670(CxImageGIF *this, char a2)
{
  CxImageGIF *result; // eax

  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(
      (char *)this,
      0xFA48u,
      *((_DWORD *)this - 1),
      (int (__thiscall *)(char *))CxImageGIF::~CxImageGIF);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this - 4);
    result = (CxImageGIF *)((char *)this - 4);
  }
  else
  {
    CxImageGIF::~CxImageGIF(this);
    if ( (a2 & 1) != 0 )
      sub_40B7E0((unsigned int)this);
    result = this;
  }
  return result;
}

//----- (0045E6D0) --------------------------------------------------------
char __thiscall CxImage::Load(CxImage *this, const char *a2, unsigned int a3)
{
  FILE *v4; // eax
  FILE *v5; // esi
  char v7; // bl
  FILE *v8; // eax
  FILE *v9; // esi
  char v10; // [esp+13h] [ebp-101h]
  char v11[256]; // [esp+14h] [ebp-100h] BYREF

  if ( !a3 || a3 >= 6 )
    goto LABEL_7;
  v4 = sub_46F017((char *)a2, aRb);
  v5 = v4;
  if ( !v4 )
    return 0;
  v7 = CxImage::Decode(this, v4, a3);
  fclose(v5);
  if ( v7 )
    return v7;
LABEL_7:
  strcpy(v11, (const char *)this + 64);
  v8 = sub_46F017((char *)a2, aRb);
  v9 = v8;
  if ( !v8 )
    return 0;
  v10 = CxImage::Decode(this, v8, 0);
  fclose(v9);
  if ( !v10 )
  {
    if ( a3 )
      strcpy((char *)this + 64, v11);
  }
  return v10;
}

//----- (0045E7F0) --------------------------------------------------------
char __thiscall CxImage::Load(CxImage *this, const unsigned __int16 *a2, unsigned int a3)
{
  struct _iobuf *v4; // eax
  FILE *v5; // esi
  char v7; // bl
  struct _iobuf *v8; // eax
  FILE *v9; // esi
  char v10; // [esp+13h] [ebp-101h]
  char v11[256]; // [esp+14h] [ebp-100h] BYREF

  if ( !a3 || a3 >= 6 )
    goto LABEL_7;
  v4 = (struct _iobuf *)sub_46F6D4((int)a2, aRb_0);
  v5 = v4;
  if ( !v4 )
    return 0;
  v7 = CxImage::Decode(this, v4, a3);
  fclose(v5);
  if ( v7 )
    return v7;
LABEL_7:
  strcpy(v11, (const char *)this + 64);
  v8 = (struct _iobuf *)sub_46F6D4((int)a2, aRb_0);
  v9 = v8;
  if ( !v8 )
    return 0;
  v10 = CxImage::Decode(this, v8, 0);
  fclose(v9);
  if ( !v10 )
  {
    if ( a3 )
      strcpy((char *)this + 64, v11);
  }
  return v10;
}
// 4B84A0: using guessed type wchar_t aRb_0[3];

//----- (0045E910) --------------------------------------------------------
char __thiscall CxImage::LoadResource(CxImage *this, HRSRC a2, unsigned int a3, HINSTANCE a4)
{
  int v5; // esi
  int v6; // eax
  int v7; // eax
  void **v9; // [esp+14h] [ebp-24h] BYREF
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+34h] [ebp-4h]
  char v16; // [esp+3Ch] [ebp+4h]

  v5 = dword_4A72AC(a4, a2);
  v6 = dword_4A72A4(a4, a2);
  if ( !v6 )
  {
    strcpy((char *)this + 64, aUnableToLoadRe);
    return 0;
  }
  v7 = dword_4A72A8(v6);
  if ( !v7 )
    return 0;
  v10 = v7;
  v9 = &CxMemFile::`vftable';
  v13 = 0;
  v14 = v5;
  v11 = v5;
  LOBYTE(v12) = 0;
  v15 = 0;
  v16 = CxImage::Decode(this, (struct CxFile *)&v9, a3);
  v9 = &CxMemFile::`vftable';
  if ( v10 )
  {
    if ( (_BYTE)v12 )
      sub_46D360(v10);
  }
  return v16;
}
// 4A72A4: using guessed type int (__stdcall *dword_4A72A4)(_DWORD, _DWORD);
// 4A72A8: using guessed type int (__stdcall *dword_4A72A8)(_DWORD);
// 4A72AC: using guessed type int (__stdcall *dword_4A72AC)(_DWORD, _DWORD);
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (0045E9F0) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, const char *a2, unsigned int a3)
{
  *(_DWORD *)this = &CxImage::`vftable';
  CxImage::Startup(this, a3);
  CxImage::Load(this, a2, a3);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045EA20) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, struct _iobuf *a2, unsigned int a3)
{
  *(_DWORD *)this = &CxImage::`vftable';
  CxImage::Startup(this, a3);
  CxImage::Decode(this, a2, a3);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045EA50) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, struct CxFile *a2, unsigned int a3)
{
  *(_DWORD *)this = &CxImage::`vftable';
  CxImage::Startup(this, a3);
  CxImage::Decode(this, a2, a3);
  return this;
}
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045EA80) --------------------------------------------------------
CxImage *__thiscall CxImage::CxImage(CxImage *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  void **v6; // [esp+8h] [ebp-24h] BYREF
  unsigned __int8 *v7; // [esp+Ch] [ebp-20h]
  unsigned int v8; // [esp+10h] [ebp-1Ch]
  bool v9; // [esp+14h] [ebp-18h]
  int v10; // [esp+18h] [ebp-14h]
  unsigned int v11; // [esp+1Ch] [ebp-10h]
  int v12; // [esp+28h] [ebp-4h]

  *(_DWORD *)this = &CxImage::`vftable';
  CxImage::Startup(this, a4);
  v7 = a2;
  v6 = &CxMemFile::`vftable';
  v10 = 0;
  v11 = a3;
  v8 = a3;
  v9 = a2 == 0;
  v12 = 0;
  CxImage::Decode(this, (struct CxFile *)&v6, a4);
  v6 = &CxMemFile::`vftable';
  if ( v7 && v9 )
    sub_46D360((unsigned int)v7);
  return this;
}
// 4A8424: using guessed type void *CxMemFile::`vftable';
// 4AE610: using guessed type void *CxImage::`vftable';

//----- (0045EB30) --------------------------------------------------------
char __thiscall CxImage::Decode(CxImage *this, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  char v4; // bl
  void **v6; // [esp+4h] [ebp-24h] BYREF
  unsigned __int8 *v7; // [esp+8h] [ebp-20h]
  unsigned int v8; // [esp+Ch] [ebp-1Ch]
  bool v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  unsigned int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+24h] [ebp-4h]

  v7 = a2;
  v6 = &CxMemFile::`vftable';
  v10 = 0;
  v11 = a3;
  v8 = a3;
  v9 = a2 == 0;
  v12 = 0;
  v4 = CxImage::Decode(this, (struct CxFile *)&v6, a4);
  v6 = &CxMemFile::`vftable';
  if ( v7 && v9 )
    sub_46D360((unsigned int)v7);
  return v4;
}
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (0045EBD0) --------------------------------------------------------
char __thiscall CxImage::Decode(CxImage *this, struct _iobuf *a2, unsigned int a3)
{
  char v3; // bl
  void **v5; // [esp+4h] [ebp-18h] BYREF
  FILE *Stream; // [esp+8h] [ebp-14h]
  bool v7; // [esp+Ch] [ebp-10h]
  int v8; // [esp+18h] [ebp-4h]

  Stream = a2;
  v5 = &CxIOFile::`vftable';
  v7 = a2 == 0;
  v8 = 0;
  v3 = CxImage::Decode(this, (struct CxFile *)&v5, a3);
  v5 = &CxIOFile::`vftable';
  if ( Stream && v7 )
    fclose(Stream);
  return v3;
}
// 4AE5E0: using guessed type void *CxIOFile::`vftable';

//----- (0045EC50) --------------------------------------------------------
char __thiscall CxImage::Decode(CxImage *this, struct CxFile *a2, unsigned int a3)
{
  struct _EXCEPTION_REGISTRATION_RECORD *v3; // eax
  void *v4; // esp
  int v6; // edi
  char *v8; // edi
  int v9; // ecx
  bool v10; // zf
  int v11; // eax
  int v12[16]; // [esp+28h] [ebp-FD74h] BYREF
  char v13[336]; // [esp+68h] [ebp-FD34h] BYREF
  int v14[16]; // [esp+1B8h] [ebp-FBE4h] BYREF
  char v15[336]; // [esp+1F8h] [ebp-FBA4h] BYREF
  int v16[16]; // [esp+348h] [ebp-FA54h] BYREF
  char v17[276]; // [esp+388h] [ebp-FA14h] BYREF
  int v18; // [esp+49Ch] [ebp-F900h]
  int v19; // [esp+4A0h] [ebp-F8FCh]
  char v20; // [esp+FC88h] [ebp-114h]
  int v21; // [esp+FD88h] [ebp-14h]
  int v22; // [esp+FD8Ch] [ebp-10h]
  struct _EXCEPTION_REGISTRATION_RECORD *v23; // [esp+FD90h] [ebp-Ch]
  void *v24; // [esp+FD94h] [ebp-8h]
  int v25; // [esp+FD98h] [ebp-4h]

  v25 = -1;
  v3 = NtCurrentTeb()->NtTib.ExceptionList;
  v24 = &loc_4A626E;
  v23 = v3;
  v4 = alloca(64872);
  switch ( a3 )
  {
    case 0u:
      v6 = (*(int (__thiscall **)(struct CxFile *))(*(_DWORD *)a2 + 20))(a2);
      CxImage::CxImage((CxImage *)v12, 1u);
      v12[0] = (int)&off_4AE630;
      v25 = 0;
      if ( sub_4654D0((CxImage *)v12, (int)a2) )
        goto LABEL_32;
      (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v6, 0);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v12);
      CxImage::CxImage((CxImage *)v12, 3u);
      v12[0] = (int)off_4AE62C;
      v25 = 1;
      if ( sub_464A40((CxImage *)v12, -1, (int)a2) )
        goto LABEL_32;
      (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v6, 0);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v12);
      CxImage::CxImage((CxImage *)v16, 2u);
      v16[0] = (int)&CxImageGIF::`vftable';
      v21 = 0;
      v22 = 0;
      v20 = 0;
      v25 = 2;
      if ( CxImageGIF::Decode((CxImageGIF *)v16, a2) )
      {
        CxImage::Transfer(this, (struct CxImage *)v16);
        v25 = -1;
        CxImage::~CxImage((CxImage *)v16);
        return 1;
      }
      (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v6, 0);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v16);
      CxImage::CxImage((CxImage *)v12, 4u);
      v12[0] = (int)off_4AE628;
      v25 = 3;
      if ( sub_463F70((CxImage *)v12, -1, (int)a2, (int)a2) )
        goto LABEL_32;
      (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v6, 0);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v12);
      CxImage::CxImage((CxImage *)v12, 5u);
      v12[0] = (int)off_4AE624;
      v25 = 4;
      if ( sub_462FD0((CxImage *)v12, (int)a2) )
        goto LABEL_32;
      (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v6, 0);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v12);
      goto LABEL_11;
    case 1u:
      CxImage::CxImage((CxImage *)v12, 1u);
      v12[0] = (int)&off_4AE630;
      v25 = 5;
      if ( sub_4654D0((CxImage *)v12, (int)a2) )
        goto LABEL_32;
      v8 = v13;
      v9 = -1;
      do
      {
        if ( !v9 )
          break;
        v10 = *v8++ == 0;
        --v9;
      }
      while ( !v10 );
LABEL_19:
      v25 = -1;
      qmemcpy((char *)this + 64, &v8[v9 + 1], ~v9);
      CxImage::~CxImage((CxImage *)v12);
      return 0;
    case 3u:
      CxImage::CxImage((CxImage *)v12, 3u);
      v12[0] = (int)off_4AE62C;
      v25 = 6;
      if ( sub_464A40((CxImage *)v12, -1, (int)a2) )
        goto LABEL_32;
      v8 = v13;
      v9 = -1;
      do
      {
        if ( !v9 )
          break;
        v10 = *v8++ == 0;
        --v9;
      }
      while ( !v10 );
      goto LABEL_19;
    case 2u:
      CxImage::CxImage((CxImage *)v16, 2u);
      v16[0] = (int)&CxImageGIF::`vftable';
      v21 = 0;
      v22 = 0;
      v20 = 0;
      v11 = *((_DWORD *)this + 85);
      v25 = 7;
      v18 = v11;
      if ( CxImageGIF::Decode((CxImageGIF *)v16, a2) )
      {
        CxImage::Transfer(this, (struct CxImage *)v16);
        v25 = -1;
        CxImage::~CxImage((CxImage *)v16);
        return 1;
      }
      *((_DWORD *)this + 86) = v19;
      v25 = -1;
      strcpy((char *)this + 64, v17);
      CxImage::~CxImage((CxImage *)v16);
      return 0;
    case 4u:
      CxImage::CxImage((CxImage *)v12, 4u);
      v12[0] = (int)off_4AE628;
      v25 = 8;
      if ( !sub_463F70((CxImage *)v12, -1, 0, (int)a2) )
      {
        v25 = -1;
        strcpy((char *)this + 64, v13);
        CxImage::~CxImage((CxImage *)v12);
        return 0;
      }
LABEL_32:
      CxImage::Transfer(this, (struct CxImage *)v12);
      v25 = -1;
      CxImage::~CxImage((CxImage *)v12);
      return 1;
  }
  if ( a3 != 5 )
  {
LABEL_11:
    strcpy((char *)this + 64, aDecodeUnknownO);
    return 0;
  }
  CxImage::CxImage((CxImage *)v14, 5u);
  v14[0] = (int)off_4AE624;
  v25 = 9;
  if ( !sub_462FD0((CxImage *)v14, (int)a2) )
  {
    v25 = -1;
    strcpy((char *)this + 64, v15);
    CxImage::~CxImage((CxImage *)v14);
    return 0;
  }
  CxImage::Transfer(this, (struct CxImage *)v14);
  v25 = -1;
  CxImage::~CxImage((CxImage *)v14);
  return 1;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';
// 4AE624: using guessed type int (__stdcall *off_4AE624[4])(char);
// 4AE628: using guessed type int (__stdcall *off_4AE628[3])(char);
// 4AE62C: using guessed type int (__stdcall *off_4AE62C[2])(char);
// 4AE630: using guessed type int (__stdcall *off_4AE630)(char);

//----- (0045F280) --------------------------------------------------------
CxImage *__thiscall sub_45F280(CxImage *this, char a2)
{
  CxImage::~CxImage(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (0045F2B0) --------------------------------------------------------
CxImage *__thiscall sub_45F2B0(CxImage *this, char a2)
{
  CxImage::~CxImage(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (0045F2E0) --------------------------------------------------------
CxImage *__thiscall sub_45F2E0(CxImage *this, char a2)
{
  CxImage::~CxImage(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (0045F310) --------------------------------------------------------
CxImage *__thiscall sub_45F310(CxImage *this, char a2)
{
  CxImage::~CxImage(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (0045F340) --------------------------------------------------------
char __thiscall CxImageGIF::Decode(CxImageGIF *this, struct CxFile *a2)
{
  struct _EXCEPTION_REGISTRATION_RECORD *v2; // eax
  void *v3; // esp
  struct CxFile *v4; // edi
  int v5; // ebp
  CxImage *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  __int16 v11; // ax
  __int16 v12; // cx
  int v13; // edx
  int v14; // edi
  bool v15; // zf
  int v16; // edi
  int v17; // eax
  char *v18; // ecx
  unsigned __int8 v19; // dl
  unsigned int v20; // eax
  unsigned __int8 *v21; // eax
  unsigned int v22; // edi
  CxImage *v23; // ecx
  int v24; // ebp
  int v25; // ebx
  unsigned __int16 v26; // ax
  int v27; // ebp
  CxImage *v28; // ebx
  unsigned __int8 *v29; // eax
  CxImage *v30; // eax
  unsigned __int16 v31; // ax
  int v32; // edi
  struct tagRGBQUAD *v33; // eax
  int v35; // [esp+20h] [ebp-100ACh]
  int v36; // [esp+38h] [ebp-10094h] BYREF
  __int16 v37[2]; // [esp+3Ch] [ebp-10090h]
  int v38; // [esp+40h] [ebp-1008Ch] BYREF
  int v39; // [esp+44h] [ebp-10088h]
  int v40; // [esp+48h] [ebp-10084h]
  CxImage *v41; // [esp+4Ch] [ebp-10080h]
  int v42; // [esp+50h] [ebp-1007Ch]
  unsigned __int8 *v43; // [esp+54h] [ebp-10078h]
  unsigned __int8 v44[4]; // [esp+58h] [ebp-10074h] BYREF
  char Str1[6]; // [esp+5Ch] [ebp-10070h] BYREF
  int v46; // [esp+62h] [ebp-1006Ah]
  char v47; // [esp+66h] [ebp-10066h]
  int v48; // [esp+6Ch] [ebp-10060h] BYREF
  int v49; // [esp+70h] [ebp-1005Ch] BYREF
  __int16 v50; // [esp+74h] [ebp-10058h] BYREF
  __int16 v51; // [esp+76h] [ebp-10056h]
  char v52; // [esp+78h] [ebp-10054h] BYREF
  char v53; // [esp+79h] [ebp-10053h] BYREF
  unsigned __int8 v54[256]; // [esp+378h] [ebp-FD54h] BYREF
  unsigned __int8 v55[256]; // [esp+478h] [ebp-FC54h] BYREF
  unsigned __int8 v56[256]; // [esp+578h] [ebp-FB54h] BYREF
  int v57[15952]; // [esp+678h] [ebp-FA54h] BYREF
  char v58; // [esp+FFB8h] [ebp-114h]
  int v59; // [esp+100B8h] [ebp-14h]
  int v60; // [esp+100BCh] [ebp-10h]
  struct _EXCEPTION_REGISTRATION_RECORD *v61; // [esp+100C0h] [ebp-Ch]
  void *v62; // [esp+100C4h] [ebp-8h]
  int v63; // [esp+100C8h] [ebp-4h]

  v63 = -1;
  v2 = NtCurrentTeb()->NtTib.ExceptionList;
  v62 = &loc_4A62A7;
  v61 = v2;
  v3 = alloca(65672);
  v4 = a2;
  v5 = 0;
  if ( !a2 )
    return 0;
  (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(a2, Str1, 13, 1);
  if ( strncmp(Str1, Str2, 4u) )
    return 0;
  v7 = 0;
  v39 = 0;
  v41 = 0;
  v8 = 1 << ((v47 & 7) + 1);
  v51 = v8;
  v50 = ((v47 >> 3) & 0xE) + 1;
  if ( v47 >= 0 )
    v39 = 1;
  else
    (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(a2, &v52, 3 * (__int16)v8, 1);
  v40 = 0;
  v9 = CxImageGIF::get_num_frames(this, a2, (struct CxImageGIF::tag_TabCol *)&v50);
  v10 = *((_DWORD *)this + 85);
  *((_DWORD *)this + 86) = v9;
  if ( v10 < 0 || v10 >= v9 )
    return 0;
  v42 = 1;
  while ( 1 )
  {
    if ( (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)v4 + 8))(v4, (char *)&v38 + 3, 1, 1) != 1 )
    {
LABEL_68:
      if ( v39 >= 2 )
      {
        if ( !v7 )
          return 1;
        if ( (*((_BYTE *)this + 400) & 1) != 0 )
        {
          *((_DWORD *)v7 + 83) = **(_DWORD **)&CxImage::GetPaletteColor(this, v44, *((_BYTE *)this + 328));
          *((_DWORD *)v7 + 82) = 0;
        }
        CxImage::Transfer(this, v7);
      }
      if ( v7 )
        (**(void (__thiscall ***)(CxImage *, int))v7)(v7, 1);
      return 1;
    }
    if ( *((_DWORD *)this + 81) )
      return 0;
    if ( HIBYTE(v38) != 33 )
      break;
    LOBYTE(v42) = CxImageGIF::DecodeExtension(this, v4);
    v42 = (unsigned __int8)v42;
LABEL_67:
    if ( !v42 )
      goto LABEL_68;
  }
  if ( HIBYTE(v38) != 44 )
  {
    if ( HIBYTE(v38) == 59 )
      goto LABEL_68;
    goto LABEL_67;
  }
  (*(void (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v4 + 8))(v4, &v36, 9, 1);
  LOWORD(v36) = (unsigned __int8)v36 + (BYTE1(v36) << 8);
  HIWORD(v36) = BYTE2(v36) + (HIBYTE(v36) << 8);
  v11 = LOBYTE(v37[0]) + (HIBYTE(v37[0]) << 8);
  v12 = LOBYTE(v37[1]) + (HIBYTE(v37[1]) << 8);
  v37[0] = v11;
  v37[1] = v12;
  if ( !v5 && v11 != (_WORD)v46 && v12 != HIWORD(v46) )
    ++v39;
  if ( (v38 & 0x80u) != 0 )
  {
    v13 = *(_DWORD *)v4;
    v51 = 1 << ((v38 & 7) + 1);
    (*(void (__thiscall **)(struct CxFile *, char *, int, int))(v13 + 8))(v4, &v52, 3 * v51, 1);
  }
  if ( v51 > 2 )
    v14 = v51 > 16 ? 8 : 4;
  else
    v14 = 1;
  CxImage::CxImage((CxImage *)v57, 2u);
  v57[0] = (int)&CxImageGIF::`vftable';
  v59 = 0;
  v60 = 0;
  v58 = 0;
  v15 = v5 == 0;
  v63 = 0;
  if ( v5 > 0 )
  {
    if ( (*((_BYTE *)this + 400) & 0x1C) == 4 )
      CxImage::Copy((CxImage *)v57, this, 1, 1, 1);
    v15 = v5 == 0;
  }
  if ( v15 )
    *(_DWORD *)v44 = *((_DWORD *)this + 82);
  CxImage::Create(this, (unsigned __int16)v37[0], (unsigned __int16)v37[1], v14, 2);
  if ( (v38 & 0x80u) != 0 || v47 < 0 )
  {
    v16 = v51;
    v17 = 0;
    if ( v51 > 0 )
    {
      v18 = &v53;
      do
      {
        v19 = *(v18 - 1);
        v18 += 3;
        v56[v17] = v19;
        v54[v17] = *(v18 - 3);
        v55[v17++] = *(v18 - 2);
      }
      while ( v17 < v16 );
    }
    if ( *((_DWORD *)this + 82) != -1 && v17 < 256 )
    {
      v43 = &v55[v17];
      v5 = 256 - v17;
      memset(&v56[v17], 0xFFu, 4 * ((unsigned int)(256 - v17) >> 2) + (-(char)v17 & 3));
      memset(&v54[v17], 0xFFu, 4 * ((unsigned int)(256 - v17) >> 2) + (-(char)v17 & 3));
      memset(v43, 0xFFu, 4 * ((unsigned int)(256 - v17) >> 2) + (-(char)v17 & 3));
    }
    v20 = 256;
    if ( *((_DWORD *)this + 82) == -1 )
      v20 = v51;
    CxImage::SetPalette(this, v20, v56, v54, v55);
  }
  v21 = (unsigned __int8 *)sub_40B720(v5, 0x18u);
  v22 = (unsigned int)v21;
  v43 = v21;
  LOBYTE(v63) = 1;
  if ( v21 )
  {
    *((_DWORD *)v21 + 5) = this;
    if ( this )
      *((_DWORD *)v21 + 4) = CxImage::GetBits(this);
    *(_DWORD *)(v22 + 4) = 0;
    *(_DWORD *)v22 = 0;
    *(_DWORD *)(v22 + 12) = 0;
    *(_DWORD *)(v22 + 8) = 0;
  }
  else
  {
    v22 = 0;
  }
  v23 = *(CxImage **)(v22 + 20);
  *(_DWORD *)v22 = 0;
  LOBYTE(v63) = 0;
  *(_DWORD *)(v22 + 4) = *((_DWORD *)v23 + 4) - 1;
  v24 = *((_DWORD *)v23 + 12);
  v25 = *((_DWORD *)v23 + 4);
  *(_DWORD *)(v22 + 16) = &CxImage::GetBits(v23)[v24 * (v25 - 1)];
  v26 = v37[1];
  *((_DWORD *)this + 106) = v38 & 0x40;
  v35 = *(_DWORD *)v37;
  v27 = 0;
  *((_DWORD *)this + 111) = 16385;
  *((_DWORD *)this + 109) = v26;
  *((_DWORD *)this + 108) = 8;
  *((_DWORD *)this + 107) = 0;
  *((_DWORD *)this + 110) = 0;
  CxImageGIF::decoder(this, a2, (struct CImageIterator *)v22, v35, &v48);
  sub_40B7E0(v22);
  if ( !*((_DWORD *)this + 81) )
  {
    if ( v40 > 0 && (*((_BYTE *)this + 400) & 0x1C) == 4 && v39 < 2 )
    {
      CxImageGIF::GifMix(
        (CxImageGIF *)v57,
        this,
        -(unsigned __int16)v36,
        HIWORD(v36) + (unsigned __int16)v37[1] - v57[4]);
      v57[82] = *(_DWORD *)v44;
      CxImage::Transfer(this, (struct CxImage *)v57);
    }
    (*(void (__thiscall **)(struct CxFile *, int, int))(*(_DWORD *)a2 + 16))(
      a2,
      *((_DWORD *)this + 111) - *((_DWORD *)this + 112) + 1,
      1);
    if ( v39 >= 2 )
    {
      v28 = v41;
      v15 = v41 == 0;
      *((_DWORD *)this + 85) = *((_DWORD *)this + 86) - 1;
      if ( v15 )
      {
        v29 = (unsigned __int8 *)sub_40B720(0, 0x190u);
        v43 = v29;
        LOBYTE(v63) = 2;
        if ( v29 )
          v30 = CxImage::CxImage((CxImage *)v29, (unsigned __int16)v46, HIWORD(v46), 24, 2);
        else
          v30 = 0;
        LOBYTE(v63) = 0;
        v41 = v30;
        v28 = v30;
      }
      if ( v37[1] )
      {
        v31 = v37[1];
        do
        {
          v32 = 0;
          if ( v37[0] )
          {
            do
            {
              v33 = (struct tagRGBQUAD *)CxImage::GetPixelColor(this, (int)&v49, v32, v31 - v27 - 1);
              CxImage::SetPixelColor(v28, v32 + (unsigned __int16)v36, HIWORD(v46) - HIWORD(v36) - v27 - 1, *v33, 0);
              v31 = v37[1];
              ++v32;
            }
            while ( v32 < (unsigned __int16)v37[0] );
          }
          ++v27;
        }
        while ( v27 < v31 );
      }
    }
    if ( *((_DWORD *)this + 85) == v40 )
      v42 = 0;
    else
      ++v40;
    v63 = -1;
    CxImage::~CxImage((CxImage *)v57);
    v4 = a2;
    v7 = v41;
    v5 = v40;
    goto LABEL_67;
  }
  v63 = -1;
  CxImage::~CxImage((CxImage *)v57);
  return 0;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';

//----- (0045F9F0) --------------------------------------------------------
bool __thiscall CxImageGIF::DecodeExtension(CxImageGIF *this, struct CxFile *a2)
{
  struct CxFile *v2; // esi
  int v4; // eax
  bool v5; // bl
  int v6; // eax
  _BYTE *v7; // edi
  unsigned int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v15; // [esp+78h] [ebp-18h] BYREF
  char v16[8]; // [esp+7Ch] [ebp-14h] BYREF
  char v17[12]; // [esp+84h] [ebp-Ch] BYREF

  v2 = a2;
  v4 = (*(int (__thiscall **)(struct CxFile *, struct CxFile **, int, int))(*(_DWORD *)a2 + 8))(a2, &a2, 1, 1);
  v5 = v4 == 1;
  if ( v4 == 1 )
  {
    if ( (_BYTE)a2 == 0xF9 )
    {
      v6 = (*(int (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v2 + 8))(v2, &v15, 1, 1);
      v5 = v6 == 1;
      if ( v6 == 1 )
      {
        v7 = (char *)this + 400;
        v8 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)v2 + 8))(
               v2,
               (char *)this + 400,
               1,
               4);
        v5 = (unsigned __int8)v15 == v8;
        if ( (unsigned __int8)v15 == v8 )
        {
          LOBYTE(v8) = *v7;
          if ( (*v7 & 1) != 0 )
            *((_DWORD *)this + 82) = *((unsigned __int8 *)this + 403);
          *((_DWORD *)this + 87) = *(unsigned __int16 *)((char *)this + 401);
          *((_DWORD *)this + 16017) = (v8 >> 2) & 7;
        }
      }
    }
    if ( (_BYTE)a2 == 0xFE )
    {
      v9 = (*(int (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v2 + 8))(v2, &v15, 1, 1);
      v5 = v9 == 1;
      if ( v9 == 1 )
      {
        v5 = (*(int (__thiscall **)(struct CxFile *, char *, _DWORD, int))(*(_DWORD *)v2 + 8))(
               v2,
               (char *)this + 63808,
               (unsigned __int8)v15,
               1) == 1;
        *((_BYTE *)this + (unsigned __int8)v15 + 63808) = 0;
      }
    }
    if ( (_BYTE)a2 == 0xFF )
    {
      v10 = (*(int (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v2 + 8))(v2, &v15, 1, 1);
      v5 = v10 == 1;
      if ( v10 != 1 )
        return v5;
      v5 = (_BYTE)v15 == 11;
      if ( (_BYTE)v15 != 11 )
        return v5;
      v11 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)v2 + 8))(v2, v17, 11, 1);
      v5 = v11 == 1;
      if ( v11 != 1 )
        return v5;
      v12 = (*(int (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v2 + 8))(v2, &v15, 1, 1);
      v5 = v12 == 1;
      if ( v12 != 1 )
        return v5;
      v5 = (_BYTE)v15 == 3;
      if ( (_BYTE)v15 != 3 )
        return v5;
      v13 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)v2 + 8))(v2, v16, 3, 1);
      v5 = v13 == 1;
      if ( v13 != 1 )
        return v5;
      *((_DWORD *)this + 16016) = (unsigned __int8)v16[1] + ((unsigned __int8)v16[2] << 8);
    }
    if ( v5 )
    {
      while ( (*(int (__thiscall **)(struct CxFile *, int *, int, int))(*(_DWORD *)v2 + 8))(v2, &v15, 1, 1)
           && (_BYTE)v15 )
        (*(void (__thiscall **)(struct CxFile *, _DWORD, int))(*(_DWORD *)v2 + 16))(v2, (unsigned __int8)v15, 1);
    }
  }
  return v5;
}

//----- (0045FBF0) --------------------------------------------------------
int __thiscall CxImageGIF::get_byte(CxImageGIF *this, struct CxFile *a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // ecx

  if ( *((int *)this + 111) >= 0x4000 )
  {
    v3 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
           a2,
           (char *)this + 452,
           1,
           0x4000);
    *((_DWORD *)this + 112) = v3;
    if ( v3 < 0x4000 )
      *((_BYTE *)this + v3 + 452) = -1;
    *((_DWORD *)this + 111) = 0;
  }
  v4 = *((_DWORD *)this + 111);
  if ( v4 >= *((_DWORD *)this + 112) )
    return -1;
  v6 = *((unsigned __int8 *)this + v4 + 452);
  *((_DWORD *)this + 111) = v4 + 1;
  return v6;
}

//----- (0045FC70) --------------------------------------------------------
int __thiscall CxImageGIF::out_line(CxImageGIF *this, struct CImageIterator *a2, unsigned __int8 *a3, int a4)
{
  int v5; // edi
  unsigned __int16 v6; // cx
  unsigned __int8 *v7; // eax
  char v8; // bp
  char v9; // dl
  int v11; // edi
  CxImage *v12; // ecx
  int v13; // eax
  int v14; // ecx
  unsigned __int8 *v15; // ebp
  int v16; // ecx
  int v17; // esi
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int result; // eax
  CxImage *v22; // ecx
  int v23; // ecx
  unsigned __int8 *v24; // edi
  int v25; // eax
  struct CImageIterator *v26; // [esp+14h] [ebp+4h]

  if ( *((_WORD *)this + 11) < 8u )
  {
    v5 = 0;
    if ( *((int *)this + 3) > 0 )
    {
      while ( 1 )
      {
        v6 = *((_WORD *)this + 11);
        v7 = &a3[(v5 * v6) >> 3];
        if ( v6 == 4 )
          break;
        if ( v6 == 1 )
        {
          v8 = 7 - v5 % 8;
          *v7 &= ~(1 << v8);
          v9 = a3[v5] & 1;
          goto LABEL_7;
        }
LABEL_8:
        if ( ++v5 >= *((_DWORD *)this + 3) )
          goto LABEL_9;
      }
      v8 = 4 - 4 * (v5 % 2);
      *v7 &= ~(15 << v8);
      v9 = a3[v5] & 0xF;
LABEL_7:
      *v7 |= v9 << v8;
      goto LABEL_8;
    }
  }
LABEL_9:
  if ( *((_DWORD *)this + 106) )
  {
    v11 = *((_DWORD *)this + 109) - *((_DWORD *)this + 107) - 1;
    if ( v11 >= 0 )
    {
      v12 = (CxImage *)*((_DWORD *)a2 + 5);
      if ( v11 <= *((_DWORD *)v12 + 4) )
      {
        *((_DWORD *)a2 + 1) = v11;
        v26 = (struct CImageIterator *)*((_DWORD *)v12 + 12);
        *((_DWORD *)a2 + 4) = &CxImage::GetBits(v12)[v11 * (_DWORD)v26];
      }
    }
    v13 = a4;
    if ( a4 >= 0 )
    {
      v14 = *((_DWORD *)a2 + 5);
      if ( a4 >= *(_DWORD *)(v14 + 48) )
        v13 = *(_DWORD *)(v14 + 48);
    }
    else
    {
      v13 = *(_DWORD *)(*((_DWORD *)a2 + 5) + 48);
    }
    v15 = (unsigned __int8 *)*((_DWORD *)a2 + 4);
    if ( v15 )
      qmemcpy(v15, a3, v13);
    v16 = *((_DWORD *)this + 108);
    v17 = v16 + *((_DWORD *)this + 107);
    *((_DWORD *)this + 107) = v17;
    v18 = v17;
    v19 = *((_DWORD *)this + 109);
    if ( v18 >= v19 )
    {
      do
      {
        v20 = *((_DWORD *)this + 110);
        *((_DWORD *)this + 110) = v20 + 1;
        if ( v20 > 0 )
          *((_DWORD *)this + 108) = v16 / 2;
        v16 = *((_DWORD *)this + 108);
        *((_DWORD *)this + 107) = v16 / 2;
      }
      while ( v16 / 2 > v19 );
    }
    result = 0;
  }
  else
  {
    v22 = (CxImage *)*((_DWORD *)a2 + 5);
    if ( v22 && CxImage::IsInside(v22, *(_DWORD *)a2, *((_DWORD *)a2 + 1)) )
    {
      v23 = a4;
      if ( a4 >= 0 )
      {
        if ( a4 >= *(_DWORD *)(*((_DWORD *)a2 + 5) + 48) )
          v23 = *(_DWORD *)(*((_DWORD *)a2 + 5) + 48);
      }
      else
      {
        v23 = *(_DWORD *)(*((_DWORD *)a2 + 5) + 48);
      }
      v24 = (unsigned __int8 *)*((_DWORD *)a2 + 4);
      if ( v24 )
        qmemcpy(v24, a3, v23);
      v25 = *((_DWORD *)a2 + 1) - 1;
      *((_DWORD *)a2 + 1) = v25;
      if ( v25 >= 0 )
        *((_DWORD *)a2 + 4) -= *(_DWORD *)(*((_DWORD *)a2 + 5) + 48);
      result = 0;
    }
    else
    {
      result = -1;
    }
  }
  return result;
}

//----- (0045FE90) --------------------------------------------------------
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct CxFile *a2)
{
  char *v3; // edx
  unsigned int v4; // eax
  char *v5; // edi
  char *v6; // esi
  int v7; // ecx
  char result; // al
  char *v9; // ebx
  unsigned int v10; // kr04_4
  int v11; // edi

  if ( !a2 )
  {
    v3 = (char *)this + 64;
    v4 = strlen(aCanTOpenGifFor) + 1;
    qmemcpy(v3, aCanTOpenGifFor, 4 * (v4 >> 2));
    v6 = &aCanTOpenGifFor[4 * (v4 >> 2)];
    v5 = &v3[4 * (v4 >> 2)];
    v7 = v4 & 3;
    result = 0;
    qmemcpy(v5, v6, v7);
    return result;
  }
  if ( *((_WORD *)this + 11) > 8u )
    return CxImageGIF::EncodeRGB(this, a2);
  CxImageGIF::EncodeHeader(this, a2);
  CxImageGIF::EncodeExtension(this, a2);
  CxImageGIF::EncodeBody(this, a2, 0);
  v9 = (char *)this + 63808;
  v10 = strlen((const char *)this + 63808) + 1;
  v11 = v10 - 1;
  if ( (int)(v10 - 1) > 255 )
  {
    v11 = 255;
LABEL_8:
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 254);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v11);
    (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, v9, v11, 1);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
    goto LABEL_9;
  }
  if ( v10 != 1 )
    goto LABEL_8;
LABEL_9:
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 59);
  return 1;
}

//----- (0045FF60) --------------------------------------------------------
char __thiscall CxImageGIF::Encode(CxImageGIF *this, struct CxFile *a2, struct CxImage **a3, int a4, bool a5)
{
  struct CxImage *v6; // ecx
  int v7; // eax
  int v8; // edi
  int i; // edi
  char *v10; // ebx
  unsigned int v11; // kr08_4
  int v12; // edi
  int v14; // [esp+0h] [ebp-FA78h] BYREF
  int v15[15952]; // [esp+Ch] [ebp-FA6Ch] BYREF
  char v16; // [esp+F94Ch] [ebp-12Ch]
  int v17; // [esp+FA4Ch] [ebp-2Ch]
  int v18; // [esp+FA50h] [ebp-28h]
  char *pExceptionObject; // [esp+FA58h] [ebp-20h] BYREF
  char *v20; // [esp+FA5Ch] [ebp-1Ch] BYREF
  char *v21; // [esp+FA60h] [ebp-18h] BYREF
  CxImageGIF *v22; // [esp+FA64h] [ebp-14h]
  int *v23; // [esp+FA68h] [ebp-10h]
  int v24; // [esp+FA74h] [ebp-4h]

  v23 = &v14;
  v22 = this;
  v24 = 0;
  if ( !a2 )
  {
    pExceptionObject = aInvalidFilePoi;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  if ( !a3 || !a4 || !*a3 )
  {
    v20 = aMultipageGifNo;
    _CxxThrowException(&v20, &PA.deinit);
  }
  CxImage::CxImage((CxImage *)v15, 2u);
  v15[0] = (int)&CxImageGIF::`vftable';
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v6 = *a3;
  LOBYTE(v24) = 1;
  CxImage::Ghost((CxImage *)v15, v6);
  CxImageGIF::EncodeHeader((CxImageGIF *)v15, a2);
  v7 = *((_DWORD *)this + 16016);
  if ( v7 != 1 )
  {
    v17 = v7 - 1 < 0 ? 0 : v7 - 1;
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 255);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 11);
    (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, aNetscape20, 11, 1);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 3);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 1);
    v8 = v17;
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v17);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v8 / 256);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
  }
  v18 = *((_DWORD *)this + 16017);
  CxImageGIF::EncodeExtension((CxImageGIF *)v15, a2);
  CxImageGIF::EncodeBody((CxImageGIF *)v15, a2, 0);
  for ( i = 2; i <= a4; ++i )
  {
    if ( !a3[i - 1] )
    {
      v21 = aBadImagePointe;
      _CxxThrowException(&v21, &PA.deinit);
    }
    CxImage::Ghost((CxImage *)v15, a3[i - 1]);
    v18 = *((_DWORD *)v22 + 16017);
    CxImageGIF::EncodeExtension((CxImageGIF *)v15, a2);
    CxImageGIF::EncodeBody((CxImageGIF *)v15, a2, a5);
  }
  v10 = (char *)v22 + 63808;
  v11 = strlen((const char *)v22 + 63808) + 1;
  v12 = v11 - 1;
  if ( (int)(v11 - 1) > 255 )
  {
    v12 = 255;
LABEL_16:
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 254);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v12);
    (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, v10, v12, 1);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
    goto LABEL_17;
  }
  if ( v11 != 1 )
    goto LABEL_16;
LABEL_17:
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 59);
  LOBYTE(v24) = 0;
  CxImage::~CxImage((CxImage *)v15);
  return 1;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';

//----- (00460200) --------------------------------------------------------
void __thiscall CxImageGIF::EncodeHeader(CxImageGIF *this, struct CxFile *a2)
{
  struct CxFile *v2; // esi
  int v4; // ebx
  int v5; // ebx
  struct tagRGBQUAD *v6; // eax
  unsigned int v7; // ebp
  BYTE *v8; // ebx
  int v9; // eax
  int v10; // eax

  v2 = a2;
  (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, aGif89a, 1, 6);
  v4 = *((_DWORD *)this + 3);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v4);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v4 / 256);
  v5 = *((_DWORD *)this + 4);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v5);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v5 / 256);
  if ( *((_DWORD *)this + 10) )
    LOBYTE(a2) = (*((_BYTE *)this + 22) - 1) | (32 * (*((_BYTE *)this + 22) + 7)) | 0x80;
  else
    LOBYTE(a2) = 17;
  (*(void (__thiscall **)(struct CxFile *, struct CxFile *))(*(_DWORD *)v2 + 40))(v2, a2);
  (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)v2 + 40))(v2, 0);
  (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)v2 + 40))(v2, 0);
  if ( *((_DWORD *)this + 10) )
  {
    v6 = CxImage::GetPalette(this);
    v7 = 0;
    if ( *((_DWORD *)this + 10) )
    {
      v8 = &v6->rgbGreen;
      do
      {
        LOBYTE(v6) = v8[1];
        v9 = (*(int (__thiscall **)(struct CxFile *, struct tagRGBQUAD *))(*(_DWORD *)v2 + 40))(v2, v6);
        LOBYTE(v9) = *v8;
        v10 = (*(int (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v9);
        LOBYTE(v10) = *(v8 - 1);
        (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v2 + 40))(v2, v10);
        v6 = (struct tagRGBQUAD *)*((_DWORD *)this + 10);
        ++v7;
        v8 += 4;
      }
      while ( v7 < (unsigned int)v6 );
    }
  }
}

//----- (004602F0) --------------------------------------------------------
void __thiscall CxImageGIF::EncodeExtension(CxImageGIF *this, struct CxFile *a2)
{
  __int16 v4; // ax
  char v5; // cl

  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 249);
  v4 = *((_WORD *)this + 174);
  *((_BYTE *)this + 400) = (*((_DWORD *)this + 82) != -1) | (4 * (*((_BYTE *)this + 64068) & 7));
  v5 = *((_BYTE *)this + 328);
  *(_WORD *)((char *)this + 401) = v4;
  *((_BYTE *)this + 403) = v5;
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 4);
  (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, (char *)this + 400, 4, 1);
  (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
}

//----- (00460380) --------------------------------------------------------
void __thiscall CxImageGIF::EncodeLoopExtension(CxImageGIF *this, struct CxFile *a2)
{
  int v4; // edi

  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 255);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 11);
  (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, aNetscape20, 11, 1);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 3);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 1);
  v4 = *((_DWORD *)this + 16016);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v4);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v4 / 256);
  (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
}

//----- (00460400) --------------------------------------------------------
void __thiscall CxImageGIF::EncodeBody(CxImageGIF *this, struct CxFile *a2, bool a3)
{
  struct CxFile *v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // ebp
  int v9; // ebp
  int v10; // ebp
  int v11; // ebp
  struct tagRGBQUAD *v12; // eax
  unsigned int v13; // ebx
  BYTE *v14; // ebp
  int v15; // eax
  int v16; // eax
  int v17; // ebx

  v4 = a2;
  v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 101) = 0;
  v6 = v5 - 1;
  v7 = *((_DWORD *)this + 3) * v5;
  *((_DWORD *)this + 102) = v6;
  *((_DWORD *)this + 103) = v7;
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 44);
  v8 = *((_DWORD *)this + 95);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v8);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v8 / 256);
  v9 = *((_DWORD *)this + 96);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v9);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v9 / 256);
  v10 = *((_DWORD *)this + 3);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v10);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v10 / 256);
  v11 = *((_DWORD *)this + 4);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v11);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v11 / 256);
  LOBYTE(a2) = 0;
  if ( a3 )
    LOBYTE(a2) = (*((_BYTE *)this + 22) - 1) | 0x80;
  (*(void (__thiscall **)(struct CxFile *, struct CxFile *))(*(_DWORD *)v4 + 40))(v4, a2);
  if ( a3 )
  {
    v12 = CxImage::GetPalette(this);
    v13 = 0;
    if ( *((_DWORD *)this + 10) )
    {
      v14 = &v12->rgbGreen;
      do
      {
        LOBYTE(v12) = v14[1];
        v15 = (*(int (__thiscall **)(struct CxFile *, struct tagRGBQUAD *))(*(_DWORD *)v4 + 40))(v4, v12);
        LOBYTE(v15) = *v14;
        v16 = (*(int (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v15);
        LOBYTE(v16) = *(v14 - 1);
        (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v16);
        v12 = (struct tagRGBQUAD *)*((_DWORD *)this + 10);
        ++v13;
        v14 += 4;
      }
      while ( v13 < (unsigned int)v12 );
    }
  }
  if ( *((_WORD *)this + 11) > 1u )
    v17 = *((unsigned __int16 *)this + 11);
  else
    v17 = 2;
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v17);
  if ( *((_DWORD *)this + 97) == 1 )
  {
    CxImageGIF::compressNONE(this, v17 + 1, v4);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)v4 + 40))(v4, 0);
  }
  else
  {
    if ( *((_DWORD *)this + 97) == 2 )
      CxImageGIF::compressLZW(this, v17 + 1, v4);
    else
      CxImageGIF::compressRLE(this, v17 + 1, v4);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)v4 + 40))(v4, 0);
  }
}

//----- (004605A0) --------------------------------------------------------
void __thiscall CxImageGIF::EncodeComment(CxImageGIF *this, struct CxFile *a2)
{
  char *v2; // ebx
  unsigned int v3; // kr04_4
  int v4; // edi

  v2 = (char *)this + 63808;
  v3 = strlen((const char *)this + 63808) + 1;
  v4 = v3 - 1;
  if ( (int)(v3 - 1) <= 255 )
  {
    if ( v3 == 1 )
      return;
  }
  else
  {
    v4 = 255;
  }
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 33);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, 254);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a2 + 40))(a2, v4);
  (*(void (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 12))(a2, v2, v4, 1);
  (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)a2 + 40))(a2, 0);
}

//----- (00460610) --------------------------------------------------------
char __thiscall CxImageGIF::EncodeRGB(CxImageGIF *this, struct CxFile *a2)
{
  struct _EXCEPTION_REGISTRATION_RECORD *v2; // eax
  void *v3; // esp
  struct CxFile *v4; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // edi
  signed int v9; // eax
  signed int v10; // ebp
  struct tagRGBQUAD *v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // ebx
  char v14; // al
  struct tagRGBQUAD *v15; // eax
  struct tagRGBQUAD *v16; // eax
  unsigned __int8 v17; // al
  const char *v18; // esi
  unsigned int v19; // kr04_4
  int v20; // edi
  char v22; // [esp+1h] [ebp-FA75h]
  int v23; // [esp+2h] [ebp-FA74h]
  unsigned int v24; // [esp+6h] [ebp-FA70h]
  int v25; // [esp+Ah] [ebp-FA6Ch]
  int i; // [esp+Eh] [ebp-FA68h]
  unsigned __int8 v27; // [esp+12h] [ebp-FA64h]
  int v28; // [esp+16h] [ebp-FA60h] BYREF
  int v29; // [esp+1Ah] [ebp-FA5Ch] BYREF
  int v30; // [esp+1Eh] [ebp-FA58h] BYREF
  int v31[15952]; // [esp+22h] [ebp-FA54h] BYREF
  char v32; // [esp+F962h] [ebp-114h]
  int v33; // [esp+FA62h] [ebp-14h]
  int v34; // [esp+FA66h] [ebp-10h]
  struct _EXCEPTION_REGISTRATION_RECORD *v35; // [esp+FA6Ah] [ebp-Ch]
  void *v36; // [esp+FA6Eh] [ebp-8h]
  int v37; // [esp+FA72h] [ebp-4h]

  v37 = -1;
  v2 = NtCurrentTeb()->NtTib.ExceptionList;
  v36 = &loc_4A62EB;
  v35 = v2;
  v3 = alloca(64108);
  v4 = a2;
  CxImageGIF::EncodeHeader(this, a2);
  CxImage::CxImage((CxImage *)v31, 2u);
  v31[0] = (int)&CxImageGIF::`vftable';
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v6 = *((_DWORD *)this + 4);
  v37 = 0;
  v23 = 0;
  if ( v6 > 0 )
  {
    do
    {
      v7 = *((_DWORD *)this + 3);
      v8 = 0;
      for ( i = 0; v8 < v7; i = v8 )
      {
        v9 = v7 - v8;
        if ( v9 >= 17 )
        {
          v24 = 17;
          v9 = 17;
        }
        else
        {
          v24 = v9;
        }
        v10 = *((_DWORD *)this + 4) - v23;
        if ( v10 >= 15 )
          v10 = 15;
        if ( v9 != v31[3] || v10 != v31[4] )
          CxImage::Create((CxImage *)v31, v9, v10, 8, 0);
        if ( *((int *)this + 82) >= 0 )
        {
          v31[82] = 0;
          v11 = (struct tagRGBQUAD *)CxImage::GetTransColor(this, &v30);
          CxImage::SetPaletteIndex((CxImage *)v31, 0, *v11);
        }
        v12 = 0;
        v25 = 0;
        if ( v10 )
        {
          do
          {
            v13 = 0;
            if ( v24 )
            {
              v14 = 17 * v12 + 1;
              v22 = v14;
              while ( 1 )
              {
                v27 = v13 + v14;
                v15 = (struct tagRGBQUAD *)CxImage::GetPixelColor(
                                             this,
                                             (int)&v28,
                                             v13 + v8,
                                             v12 + *((_DWORD *)this + 4) - v23 - v10);
                CxImage::SetPaletteIndex((CxImage *)v31, v27, *v15);
                v16 = (struct tagRGBQUAD *)CxImage::GetPaletteColor((CxImage *)v31, &v29, v27);
                v17 = CxImage::GetNearestIndex((CxImage *)v31, *v16);
                CxImage::SetPixelIndex((CxImage *)v31, v13++, v25, v17);
                if ( v13 >= v24 )
                  break;
                v14 = v22;
                v12 = v25;
                v8 = i;
              }
              v12 = v25;
              v8 = i;
            }
            v25 = ++v12;
          }
          while ( v12 < v10 );
          v4 = a2;
        }
        v31[96] = v23;
        v31[95] = v8;
        CxImageGIF::EncodeExtension((CxImageGIF *)v31, v4);
        CxImageGIF::EncodeBody((CxImageGIF *)v31, v4, 1);
        v7 = *((_DWORD *)this + 3);
        v8 += 17;
      }
      v23 += 15;
    }
    while ( v23 < *((_DWORD *)this + 4) );
  }
  v18 = (char *)this + 63808;
  v19 = strlen(v18) + 1;
  v20 = v19 - 1;
  if ( (int)(v19 - 1) > 255 )
  {
    v20 = 255;
LABEL_26:
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, 33);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, 254);
    (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, v20);
    (*(void (__thiscall **)(struct CxFile *, const char *, int, int))(*(_DWORD *)v4 + 12))(v4, v18, v20, 1);
    (*(void (__thiscall **)(struct CxFile *, _DWORD))(*(_DWORD *)v4 + 40))(v4, 0);
    goto LABEL_27;
  }
  if ( v19 != 1 )
    goto LABEL_26;
LABEL_27:
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)v4 + 40))(v4, 59);
  v37 = -1;
  CxImage::~CxImage((CxImage *)v31);
  return 1;
}
// 4AE620: using guessed type void *CxImageGIF::`vftable';

//----- (004608B0) --------------------------------------------------------
int __thiscall CxImageGIF::GifNextPixel(CxImageGIF *this)
{
  int v2; // eax
  int result; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx

  v2 = *((_DWORD *)this + 103);
  if ( !v2 )
    return -1;
  v4 = *((_DWORD *)this + 101);
  *((_DWORD *)this + 103) = v2 - 1;
  LOBYTE(result) = CxImage::GetPixelIndex(this, v4, *((_DWORD *)this + 102));
  v5 = *((_DWORD *)this + 3);
  result = (unsigned __int8)result;
  v6 = *((_DWORD *)this + 101) + 1;
  *((_DWORD *)this + 101) = v6;
  if ( v6 == v5 )
  {
    v7 = *((_DWORD *)this + 102);
    *((_DWORD *)this + 101) = 0;
    *((_DWORD *)this + 102) = v7 - 1;
  }
  return result;
}

//----- (00460910) --------------------------------------------------------
void __thiscall CxImageGIF::Putword(CxImageGIF *this, int a2, struct CxFile *a3)
{
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a3 + 40))(a3, a2);
  (*(void (__thiscall **)(struct CxFile *, int))(*(_DWORD *)a3 + 40))(a3, a2 / 256);
}

//----- (00460940) --------------------------------------------------------
void __thiscall CxImageGIF::compressNONE(CxImageGIF *this, int a2, struct CxFile *a3)
{
  int v4; // edx
  int v5; // eax
  int v6; // ebx
  unsigned __int8 v7; // al
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // edi
  unsigned __int8 v14; // al
  int v15; // ecx
  int v16; // eax
  __int16 v17; // ax
  int v18; // [esp-8h] [ebp-18h]
  int v19; // [esp-8h] [ebp-18h]
  int v20; // [esp-4h] [ebp-14h]
  int v21; // [esp-4h] [ebp-14h]
  __int16 v22; // [esp-4h] [ebp-14h]

  *((_DWORD *)this + 15883) = a2;
  *((_DWORD *)this + 15884) = a3;
  *((_DWORD *)this + 15880) = a2;
  *((_DWORD *)this + 15882) = 0;
  v4 = (1 << a2) - 1;
  *((_DWORD *)this + 105) = 0;
  *((_DWORD *)this + 104) = 0;
  *((_WORD *)this + 31762) = v4;
  *((_DWORD *)this + 15887) = 0;
  *((_DWORD *)this + 15885) = 1 << (a2 - 1);
  *((_DWORD *)this + 15886) = (1 << (a2 - 1)) + 1;
  *((_WORD *)this + 31763) = *((_WORD *)this + 31770) + 2;
  v5 = *((_DWORD *)this + 103);
  if ( v5 )
  {
    v20 = *((_DWORD *)this + 102);
    v18 = *((_DWORD *)this + 101);
    *((_DWORD *)this + 103) = v5 - 1;
    v7 = CxImage::GetPixelIndex(this, v18, v20);
    v4 = *((_DWORD *)this + 3);
    v8 = v7;
    v9 = *((_DWORD *)this + 101) + 1;
    *((_DWORD *)this + 101) = v9;
    if ( v9 == v4 )
    {
      v10 = *((_DWORD *)this + 102);
      *((_DWORD *)this + 101) = 0;
      *((_DWORD *)this + 102) = v10 - 1;
    }
    v6 = v8;
  }
  else
  {
    v6 = -1;
  }
  CxImageGIF::output(this, v4, *((_WORD *)this + 31770));
  if ( v6 != -1 )
  {
    do
    {
      v12 = *((_DWORD *)this + 103);
      if ( v12 )
      {
        v21 = *((_DWORD *)this + 102);
        v19 = *((_DWORD *)this + 101);
        *((_DWORD *)this + 103) = v12 - 1;
        v14 = CxImage::GetPixelIndex(this, v19, v21);
        v15 = *((_DWORD *)this + 3);
        v11 = *((_DWORD *)this + 101) + 1;
        v13 = v14;
        *((_DWORD *)this + 101) = v11;
        if ( v11 == v15 )
        {
          v16 = *((_DWORD *)this + 102);
          *((_DWORD *)this + 101) = 0;
          *((_DWORD *)this + 102) = v16 - 1;
        }
      }
      else
      {
        v13 = -1;
      }
      CxImageGIF::output(this, v11, v6);
      v17 = *((_WORD *)this + 31763);
      LOWORD(v6) = v13;
      if ( v17 >= 4096 )
      {
        v22 = *((_WORD *)this + 31770);
        *((_WORD *)this + 31763) = v22 + 2;
        *((_DWORD *)this + 15882) = 1;
        CxImageGIF::output(this, v11, v22);
      }
      else
      {
        *((_WORD *)this + 31763) = v17 + 1;
      }
    }
    while ( v13 != -1 );
  }
  LOWORD(v11) = *((_WORD *)this + 31772);
  CxImageGIF::output(this, v11, v11);
}
// 460A83: variable 'v11' is possibly undefined

//----- (00460AF0) --------------------------------------------------------
void __thiscall CxImageGIF::compressLZW(CxImageGIF *this, int a2, struct CxFile *a3)
{
  int v4; // eax
  int v5; // ebp
  unsigned __int8 v6; // al
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  char v10; // cl
  int i; // eax
  int v12; // edx
  int v13; // edx
  int v14; // eax
  unsigned __int8 v15; // al
  int v16; // ecx
  int v17; // ecx
  int v18; // ebx
  int v19; // edi
  int v20; // ecx
  int *v21; // eax
  int v22; // ecx
  __int16 v23; // ax
  __int16 v24; // ax
  int v25; // edx
  int v26; // edx
  int v27; // [esp-8h] [ebp-18h]
  int v28; // [esp-8h] [ebp-18h]
  int v29; // [esp-4h] [ebp-14h]
  int v30; // [esp-4h] [ebp-14h]
  char v31; // [esp+14h] [ebp+4h]
  int v32; // [esp+18h] [ebp+8h]

  *((_DWORD *)this + 15883) = a2;
  *((_DWORD *)this + 15884) = a3;
  *((_DWORD *)this + 15880) = a2;
  *((_DWORD *)this + 15882) = 0;
  *((_DWORD *)this + 105) = 0;
  *((_DWORD *)this + 104) = 0;
  *((_WORD *)this + 31762) = (1 << a2) - 1;
  *((_DWORD *)this + 15887) = 0;
  *((_DWORD *)this + 15885) = 1 << (a2 - 1);
  *((_DWORD *)this + 15886) = (1 << (a2 - 1)) + 1;
  *((_WORD *)this + 31763) = *((_WORD *)this + 31770) + 2;
  v4 = *((_DWORD *)this + 103);
  if ( v4 )
  {
    v29 = *((_DWORD *)this + 102);
    v27 = *((_DWORD *)this + 101);
    *((_DWORD *)this + 103) = v4 - 1;
    v6 = CxImage::GetPixelIndex(this, v27, v29);
    v7 = *((_DWORD *)this + 3);
    v5 = v6;
    v8 = *((_DWORD *)this + 101) + 1;
    *((_DWORD *)this + 101) = v8;
    if ( v8 == v7 )
    {
      v9 = *((_DWORD *)this + 102);
      *((_DWORD *)this + 101) = 0;
      *((_DWORD *)this + 102) = v9 - 1;
    }
  }
  else
  {
    v5 = -1;
  }
  v10 = 0;
  for ( i = 5003; i < 0x10000; i *= 2 )
    ++v10;
  v31 = 8 - v10;
  CxImageGIF::cl_hash(this, 5003);
  CxImageGIF::output(this, v12, *((_WORD *)this + 31770));
  while ( 1 )
  {
    v14 = *((_DWORD *)this + 103);
    if ( !v14 )
      break;
    v30 = *((_DWORD *)this + 102);
    v28 = *((_DWORD *)this + 101);
    *((_DWORD *)this + 103) = v14 - 1;
    v15 = CxImage::GetPixelIndex(this, v28, v30);
    v13 = *((_DWORD *)this + 3);
    v16 = *((_DWORD *)this + 101) + 1;
    v32 = v15;
    *((_DWORD *)this + 101) = v16;
    if ( v16 == v13 )
    {
      v17 = *((_DWORD *)this + 102);
      *((_DWORD *)this + 101) = 0;
      *((_DWORD *)this + 102) = v17 - 1;
    }
    v18 = v5 + (v15 << 12);
    v19 = v5 ^ (v15 << v31);
    v20 = *((_DWORD *)this + v19 + 8375);
    v21 = (int *)((char *)this + 4 * v19 + 33500);
    if ( v20 == v18 )
      goto LABEL_12;
    if ( v20 < 0 )
    {
LABEL_20:
      CxImageGIF::output(this, v13, v5);
      v23 = *((_WORD *)this + 31763);
      v5 = v32;
      if ( v23 >= 4096 )
      {
        CxImageGIF::cl_hash(this, 5003);
        v24 = *((_WORD *)this + 31770);
        *((_DWORD *)this + 15882) = 1;
        *((_WORD *)this + 31763) = v24 + 2;
        CxImageGIF::output(this, v25, v24);
      }
      else
      {
        *((_WORD *)this + v19 + 26756) = v23;
        ++*((_WORD *)this + 31763);
        *((_DWORD *)this + v19 + 8375) = v18;
      }
    }
    else
    {
      v22 = 5003 - v19;
      if ( !v19 )
        v22 = 1;
      while ( 1 )
      {
        v19 -= v22;
        v21 -= v22;
        if ( v19 < 0 )
        {
          v19 += 5003;
          v21 += 5003;
        }
        v13 = *v21;
        if ( *v21 == v18 )
          break;
        if ( v13 <= 0 )
          goto LABEL_20;
      }
LABEL_12:
      v5 = *((unsigned __int16 *)this + v19 + 26756);
    }
  }
  CxImageGIF::output(this, v13, v5);
  LOWORD(v26) = *((_WORD *)this + 31772);
  CxImageGIF::output(this, v26, v26);
}
// 460C55: conditional instruction was optimized away because of 'eax.4<100u'
// 460BED: variable 'v12' is possibly undefined
// 460D2A: variable 'v25' is possibly undefined
// 460D32: variable 'v13' is possibly undefined
// 460D41: variable 'v26' is possibly undefined

//----- (00460D50) --------------------------------------------------------
void __fastcall CxImageGIF::output(CxImageGIF *this, int a2, __int16 a3)
{
  int v4; // ecx
  int v5; // edi
  int v6; // eax
  int v7; // edx
  unsigned int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  unsigned int v13; // edx
  int v14; // eax

  v4 = *((_DWORD *)this + 105);
  v5 = dword_4AE634[v4] & *((_DWORD *)this + 104);
  *((_DWORD *)this + 104) = v5;
  if ( v4 <= 0 )
  {
    *((_DWORD *)this + 104) = a3;
  }
  else
  {
    a2 = v5 | (a3 << v4);
    *((_DWORD *)this + 104) = a2;
  }
  v6 = v4 + *((_DWORD *)this + 15880);
  *((_DWORD *)this + 105) = v6;
  if ( v6 >= 8 )
  {
    do
    {
      *((_BYTE *)this + *((_DWORD *)this + 15887) + 63552) = *((_DWORD *)this + 104);
      v7 = *((_DWORD *)this + 15887) + 1;
      *((_DWORD *)this + 15887) = v7;
      if ( v7 >= 254 )
      {
        (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v7);
        (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
          *((_DWORD *)this + 15884),
          (char *)this + 63552,
          1,
          *((_DWORD *)this + 15887));
        *((_DWORD *)this + 15887) = 0;
      }
      v8 = *((_DWORD *)this + 104);
      v9 = *((_DWORD *)this + 105) - 8;
      *((_DWORD *)this + 105) = v9;
      a2 = v8 >> 8;
      *((_DWORD *)this + 104) = a2;
    }
    while ( v9 >= 8 );
  }
  if ( *((_WORD *)this + 31763) > *((_WORD *)this + 31762) || *((_DWORD *)this + 15882) )
  {
    if ( *((_DWORD *)this + 15882) )
    {
      v10 = *((_DWORD *)this + 15883);
      *((_DWORD *)this + 15880) = v10;
      *((_DWORD *)this + 15882) = 0;
      a2 = (1 << v10) - 1;
      *((_WORD *)this + 31762) = a2;
    }
    else
    {
      v11 = *((_DWORD *)this + 15880) + 1;
      *((_DWORD *)this + 15880) = v11;
      if ( v11 == 12 )
        *((_WORD *)this + 31762) = 4096;
      else
        *((_WORD *)this + 31762) = (1 << v11) - 1;
    }
  }
  if ( a3 == *((_DWORD *)this + 15886) )
  {
    if ( *((int *)this + 105) > 0 )
    {
      do
      {
        *((_BYTE *)this + *((_DWORD *)this + 15887) + 63552) = *((_DWORD *)this + 104);
        v12 = *((_DWORD *)this + 15887) + 1;
        *((_DWORD *)this + 15887) = v12;
        if ( v12 >= 254 )
        {
          (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v12);
          (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
            *((_DWORD *)this + 15884),
            (char *)this + 63552,
            1,
            *((_DWORD *)this + 15887));
          *((_DWORD *)this + 15887) = 0;
        }
        v13 = *((_DWORD *)this + 104);
        v14 = *((_DWORD *)this + 105) - 8;
        *((_DWORD *)this + 105) = v14;
        a2 = v13 >> 8;
        *((_DWORD *)this + 104) = a2;
      }
      while ( v14 > 0 );
    }
    if ( *((int *)this + 15887) > 0 )
    {
      LOBYTE(a2) = *((_BYTE *)this + 63548);
      (*(void (__thiscall **)(_DWORD, _WORD))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), a2);
      (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
        *((_DWORD *)this + 15884),
        (char *)this + 63552,
        1,
        *((_DWORD *)this + 15887));
      *((_DWORD *)this + 15887) = 0;
    }
    (*(void (__thiscall **)(_DWORD))(**((_DWORD **)this + 15884) + 28))(*((_DWORD *)this + 15884));
    if ( (*(int (__thiscall **)(_DWORD))(**((_DWORD **)this + 15884) + 36))(*((_DWORD *)this + 15884)) )
      strcpy((char *)this + 64, aWriteErrorInGi);
  }
}
// 460DD5: conditional instruction was optimized away because of 'edx.4>=FE'
// 460ED6: conditional instruction was optimized away because of 'edx.4>=FE'

//----- (00460FB0) --------------------------------------------------------
void __thiscall CxImageGIF::cl_hash(CxImageGIF *this, int a2)
{
  _DWORD *v2; // eax
  int v3; // edx
  int v4; // edx

  v2 = (_DWORD *)((char *)this + 4 * a2 + 33500);
  v3 = a2 - 16;
  do
  {
    *(v2 - 16) = -1;
    *(v2 - 15) = -1;
    *(v2 - 14) = -1;
    *(v2 - 13) = -1;
    *(v2 - 12) = -1;
    *(v2 - 11) = -1;
    *(v2 - 10) = -1;
    *(v2 - 9) = -1;
    *(v2 - 8) = -1;
    *(v2 - 7) = -1;
    *(v2 - 6) = -1;
    *(v2 - 5) = -1;
    *(v2 - 4) = -1;
    *(v2 - 3) = -1;
    *(v2 - 2) = -1;
    *(v2 - 1) = -1;
    v2 -= 16;
    v3 -= 16;
  }
  while ( v3 >= 0 );
  v4 = v3 + 16;
  if ( v4 > 0 )
  {
    do
    {
      --v2;
      --v4;
      *v2 = -1;
    }
    while ( v4 );
  }
}

//----- (00461010) --------------------------------------------------------
void __thiscall CxImageGIF::char_out(CxImageGIF *this, int a2)
{
  int v3; // edx

  *((_BYTE *)this + *((_DWORD *)this + 15887) + 63552) = a2;
  v3 = *((_DWORD *)this + 15887) + 1;
  *((_DWORD *)this + 15887) = v3;
  if ( v3 >= 254 )
  {
    (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v3);
    (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
      *((_DWORD *)this + 15884),
      (char *)this + 63552,
      1,
      *((_DWORD *)this + 15887));
    *((_DWORD *)this + 15887) = 0;
  }
}
// 46103C: conditional instruction was optimized away because of 'edx.4>=FE'

//----- (00461080) --------------------------------------------------------
void __thiscall CxImageGIF::flush_char(CxImageGIF *this)
{
  if ( *((int *)this + 15887) > 0 )
  {
    (*(void (__thiscall **)(_DWORD, _BYTE))(**((_DWORD **)this + 15884) + 40))(
      *((_DWORD *)this + 15884),
      *((_BYTE *)this + 63548));
    (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
      *((_DWORD *)this + 15884),
      (char *)this + 63552,
      1,
      *((_DWORD *)this + 15887));
    *((_DWORD *)this + 15887) = 0;
  }
}

//----- (004610D0) --------------------------------------------------------
__int16 __thiscall CxImageGIF::init_exp(CxImageGIF *this, __int16 a2)
{
  __int16 v2; // ax

  *((_WORD *)this + 8419) = a2 + 1;
  *((_WORD *)this + 8423) = 1 << (a2 + 1);
  *((_WORD *)this + 8420) = 1 << a2;
  *((_WORD *)this + 8421) = (1 << a2) + 1;
  v2 = (1 << a2) + 2;
  *((_WORD *)this + 8422) = v2;
  *((_WORD *)this + 8424) = v2;
  *((_WORD *)this + 8426) = 0;
  *((_WORD *)this + 8425) = 0;
  memset((char *)this + 17116, 0, 0x1000u);
  memset((char *)this + 25308, 0, 0x1000u);
  memset((char *)this + 21212, 0, 0x1000u);
  return 0;
}

//----- (00461160) --------------------------------------------------------
__int16 __thiscall CxImageGIF::get_next_code(CxImageGIF *this, struct CxFile *a2)
{
  int v4; // ebp
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  char v10; // al
  int v11; // ecx
  char *v12; // eax
  char v13; // dl
  __int16 v14; // ax
  int v15; // ebp
  int v16; // eax
  int v17; // ecx
  int v18; // ebp
  int v19; // eax
  int v20; // ecx
  char v21; // al
  int v22; // ecx
  unsigned __int8 *v23; // eax
  unsigned __int8 v24; // dl
  int v25; // edx
  __int16 v26; // ax
  struct CxFile *v28; // [esp+30h] [ebp+4h]

  v4 = 0;
  if ( !*((_WORD *)this + 8426) )
  {
    if ( *((__int16 *)this + 8425) <= 0 )
    {
      *((_DWORD *)this + 4278) = (char *)this + 16855;
      if ( *((int *)this + 111) >= 0x4000 )
      {
        v5 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
               a2,
               (char *)this + 452,
               1,
               0x4000);
        *((_DWORD *)this + 112) = v5;
        if ( v5 < 0x4000 )
          *((_BYTE *)this + v5 + 452) = -1;
        *((_DWORD *)this + 111) = 0;
      }
      v6 = *((_DWORD *)this + 111);
      if ( v6 < *((_DWORD *)this + 112) )
      {
        LOWORD(v7) = *((unsigned __int8 *)this + v6 + 452);
        *((_DWORD *)this + 111) = v6 + 1;
      }
      else
      {
        LOWORD(v7) = -1;
      }
      *((_WORD *)this + 8425) = v7;
      if ( (v7 & 0x8000u) != 0 )
        return v7;
      if ( (_WORD)v7 )
      {
        while ( 1 )
        {
          if ( *((int *)this + 111) >= 0x4000 )
          {
            v8 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
                   a2,
                   (char *)this + 452,
                   1,
                   0x4000);
            *((_DWORD *)this + 112) = v8;
            if ( v8 < 0x4000 )
              *((_BYTE *)this + v8 + 452) = -1;
            *((_DWORD *)this + 111) = 0;
          }
          v9 = *((_DWORD *)this + 111);
          if ( v9 >= *((_DWORD *)this + 112) )
            break;
          v10 = *((_BYTE *)this + v9 + 452);
          *((_DWORD *)this + 111) = v9 + 1;
          v11 = (__int16)v4++;
          *((_BYTE *)this + v11 + 16855) = v10;
          if ( (__int16)v4 >= *((__int16 *)this + 8425) )
            goto LABEL_18;
        }
LABEL_42:
        LOWORD(v7) = -1;
        return v7;
      }
    }
LABEL_18:
    v12 = (char *)*((_DWORD *)this + 4278);
    v13 = *v12;
    --*((_WORD *)this + 8425);
    *((_BYTE *)this + 16854) = v13;
    *((_DWORD *)this + 4278) = v12 + 1;
    *((_WORD *)this + 8426) = 8;
  }
  if ( *((__int16 *)this + 8425) >= 0 )
  {
    v14 = *((_WORD *)this + 8426);
    v15 = *((unsigned __int8 *)this + 16854) >> (8 - v14);
    v28 = (struct CxFile *)v15;
    if ( *((__int16 *)this + 8419) <= v14 )
    {
LABEL_43:
      v26 = *((_WORD *)this + 8419);
      *((_WORD *)this + 8426) -= v26;
      return v15 & dword_4AE634[v26];
    }
    while ( 1 )
    {
      if ( *((__int16 *)this + 8425) <= 0 )
      {
        *((_DWORD *)this + 4278) = (char *)this + 16855;
        if ( *((int *)this + 111) >= 0x4000 )
        {
          v16 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
                  a2,
                  (char *)this + 452,
                  1,
                  0x4000);
          *((_DWORD *)this + 112) = v16;
          if ( v16 < 0x4000 )
            *((_BYTE *)this + v16 + 452) = -1;
          *((_DWORD *)this + 111) = 0;
        }
        v17 = *((_DWORD *)this + 111);
        if ( v17 < *((_DWORD *)this + 112) )
        {
          LOWORD(v7) = *((unsigned __int8 *)this + v17 + 452);
          *((_DWORD *)this + 111) = v17 + 1;
        }
        else
        {
          LOWORD(v7) = -1;
        }
        *((_WORD *)this + 8425) = v7;
        if ( (v7 & 0x8000u) != 0 )
          return v7;
        if ( (_WORD)v7 )
          break;
      }
LABEL_40:
      v23 = (unsigned __int8 *)*((_DWORD *)this + 4278);
      v24 = *v23;
      *((_DWORD *)this + 4278) = v23 + 1;
      LOWORD(v23) = *((_WORD *)this + 8426);
      *((_BYTE *)this + 16854) = v24;
      v25 = v24 << (char)v23;
      LOWORD(v23) = (_WORD)v23 + 8;
      *((_WORD *)this + 8426) = (_WORD)v23;
      v15 |= v25;
      --*((_WORD *)this + 8425);
      v28 = (struct CxFile *)v15;
      if ( *((__int16 *)this + 8419) <= (__int16)v23 )
        goto LABEL_43;
    }
    v18 = 0;
    while ( 1 )
    {
      if ( *((int *)this + 111) >= 0x4000 )
      {
        v19 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
                a2,
                (char *)this + 452,
                1,
                0x4000);
        *((_DWORD *)this + 112) = v19;
        if ( v19 < 0x4000 )
          *((_BYTE *)this + v19 + 452) = -1;
        *((_DWORD *)this + 111) = 0;
      }
      v20 = *((_DWORD *)this + 111);
      if ( v20 >= *((_DWORD *)this + 112) )
        goto LABEL_42;
      v21 = *((_BYTE *)this + v20 + 452);
      *((_DWORD *)this + 111) = v20 + 1;
      v22 = (__int16)v18++;
      *((_BYTE *)this + v22 + 16855) = v21;
      if ( (__int16)v18 >= *((__int16 *)this + 8425) )
      {
        v15 = (int)v28;
        goto LABEL_40;
      }
    }
  }
  LOWORD(v7) = *((_WORD *)this + 8421);
  return v7;
}
// 461272: conditional instruction was optimized away because of 'ax.2<100u'
// 4613E9: conditional instruction was optimized away because of 'ax.2<100u'
// 46120D: conditional instruction was optimized away because of 'ax.2 in (1..FF)'
// 461388: conditional instruction was optimized away because of 'ax.2 in (1..FF)'

//----- (00461480) --------------------------------------------------------
__int16 __thiscall CxImageGIF::decoder(CxImageGIF *this, struct CxFile *a2, struct CImageIterator *a3, int a4, int *a5)
{
  int v6; // eax
  int v7; // ecx
  __int16 v9; // ax
  _BYTE *v10; // ebp
  __int16 v11; // ax
  int v12; // edi
  int v13; // eax
  unsigned __int8 *v14; // ebx
  __int16 i; // ax
  __int16 v16; // ax
  __int16 j; // ax
  __int16 v18; // di
  __int16 v19; // dx
  __int16 v20; // cx
  __int16 v21; // dx
  __int16 v22; // dx
  __int16 v23; // cx
  __int16 v24; // ax
  unsigned __int8 v25; // dl
  __int16 v26; // bp
  unsigned __int8 *v27; // [esp+10h] [ebp-18h]
  __int16 v28; // [esp+14h] [ebp-14h]
  char v29; // [esp+18h] [ebp-10h]
  __int16 v30; // [esp+20h] [ebp-8h]
  int v31; // [esp+24h] [ebp-4h]

  *a5 = 0;
  if ( *((int *)this + 111) >= 0x4000 )
  {
    v6 = (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(
           a2,
           (char *)this + 452,
           1,
           0x4000);
    *((_DWORD *)this + 112) = v6;
    if ( v6 < 0x4000 )
      *((_BYTE *)this + v6 + 452) = -1;
    *((_DWORD *)this + 111) = 0;
  }
  v7 = *((_DWORD *)this + 111);
  if ( v7 >= *((_DWORD *)this + 112) )
    return -1;
  v9 = *((unsigned __int8 *)this + v7 + 452);
  *((_DWORD *)this + 111) = v7 + 1;
  if ( v9 < 2 || v9 > 9 )
    return -20;
  v30 = v9 + 1;
  *((_WORD *)this + 8419) = v9 + 1;
  v10 = (char *)this + 17116;
  *((_WORD *)this + 8426) = 0;
  v31 = 1 << (v9 + 1);
  *((_WORD *)this + 8423) = v31;
  *((_WORD *)this + 8425) = 0;
  v29 = 0;
  v28 = 0;
  *((_WORD *)this + 8420) = 1 << v9;
  v11 = (1 << v9) + 1;
  *((_WORD *)this + 8421) = v11++;
  *((_WORD *)this + 8422) = v11;
  *((_WORD *)this + 8424) = v11;
  memset((char *)this + 17116, 0, 0x1000u);
  memset((char *)this + 25308, 0, 0x1000u);
  memset((char *)this + 21212, 0, 0x1000u);
  v12 = a4;
  v13 = sub_40B720((int)this + 17116, (__int16)a4 + 1);
  v14 = (unsigned __int8 *)v13;
  if ( !v13 )
    return -10;
  v27 = (unsigned __int8 *)v13;
  for ( i = CxImageGIF::get_next_code(this, a2); i != *((_WORD *)this + 8421); i = CxImageGIF::get_next_code(this, a2) )
  {
    if ( i < 0 )
    {
      sub_40B7E0((unsigned int)v14);
      return 0;
    }
    if ( i == *((_WORD *)this + 8420) )
    {
      v16 = *((_WORD *)this + 8422);
      *((_WORD *)this + 8419) = v30;
      *((_WORD *)this + 8423) = v31;
      *((_WORD *)this + 8424) = v16;
      for ( j = CxImageGIF::get_next_code(this, a2); j == *((_WORD *)this + 8420); j = CxImageGIF::get_next_code(
                                                                                         this,
                                                                                         a2) )
        ;
      if ( j == *((_WORD *)this + 8421) )
        break;
      if ( j >= *((__int16 *)this + 8424) )
        j = 0;
      v29 = j;
      v28 = j;
      *v27 = j;
      --v12;
      ++v27;
      if ( !(_WORD)v12 )
      {
        v18 = CxImageGIF::out_line(this, a3, v14, (__int16)a4);
        if ( v18 < 0 )
        {
LABEL_44:
          sub_40B7E0((unsigned int)v14);
          return v18;
        }
        v12 = a4;
        v27 = v14;
      }
    }
    else
    {
      v19 = *((_WORD *)this + 8424);
      v20 = i;
      if ( i >= v19 )
      {
        if ( i > v19 )
          ++*a5;
        v20 = v28;
        *v10++ = v29;
      }
      for ( ; v20 >= *((__int16 *)this + 8422); v20 = *((_WORD *)this + v20 + 12654) )
        *v10++ = *((_BYTE *)this + v20 + 21212);
      *v10 = v20;
      v21 = *((_WORD *)this + 8424);
      ++v10;
      if ( v21 < *((__int16 *)this + 8423) )
      {
        v29 = v20;
        *((_BYTE *)this + v21 + 21212) = v20;
        v22 = v28;
        v28 = i;
        *((_WORD *)this + (__int16)(*((_WORD *)this + 8424))++ + 12654) = v22;
      }
      v23 = *((_WORD *)this + 8423);
      if ( *((__int16 *)this + 8424) >= v23 )
      {
        v24 = *((_WORD *)this + 8419);
        if ( v24 < 12 )
        {
          *((_WORD *)this + 8423) = 2 * v23;
          *((_WORD *)this + 8419) = v24 + 1;
        }
      }
      while ( v10 > (_BYTE *)this + 17116 )
      {
        v25 = *--v10;
        *v27 = v25;
        --v12;
        ++v27;
        if ( !(_WORD)v12 )
        {
          v18 = CxImageGIF::out_line(this, a3, v14, (__int16)a4);
          if ( v18 < 0 )
            goto LABEL_44;
          v12 = a4;
          v27 = v14;
        }
      }
    }
  }
  v26 = 0;
  if ( (_WORD)v12 != (_WORD)a4 )
    v26 = CxImageGIF::out_line(this, a3, v14, (__int16)a4 - (__int16)v12);
  sub_40B7E0((unsigned int)v14);
  return v26;
}
// 461500: conditional instruction was optimized away because of 'ax.2<100u'

//----- (00461850) --------------------------------------------------------
int __thiscall CxImageGIF::get_num_frames(CxImageGIF *this, struct CxFile *a2, struct CxImageGIF::tag_TabCol *a3)
{
  int v4; // edx
  int v5; // edx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // esi
  CxImage *v9; // ecx
  int v10; // edi
  unsigned __int8 *v11; // eax
  int v12; // edx
  char v14; // [esp+1Fh] [ebp-32Dh] BYREF
  int v15; // [esp+20h] [ebp-32Ch] BYREF
  __int16 v16[2]; // [esp+24h] [ebp-328h]
  int v17; // [esp+28h] [ebp-324h]
  int v18; // [esp+2Ch] [ebp-320h]
  int v19; // [esp+30h] [ebp-31Ch]
  int v20; // [esp+34h] [ebp-318h]
  int v21; // [esp+38h] [ebp-314h] BYREF
  __int16 v22[386]; // [esp+3Ch] [ebp-310h] BYREF
  int v23; // [esp+348h] [ebp-4h]

  v20 = (*(int (__thiscall **)(struct CxFile *))(*(_DWORD *)a2 + 20))(a2);
  v18 = 0;
  qmemcpy(v22, a3, sizeof(v22));
  while ( (*(int (__thiscall **)(struct CxFile *, char *, int, int))(*(_DWORD *)a2 + 8))(a2, &v14, 1, 1) == 1 )
  {
    switch ( v14 )
    {
      case '!':
        CxImageGIF::DecodeExtension(this, a2);
        break;
      case ',':
        v4 = *(_DWORD *)a2;
        ++v18;
        (*(void (__thiscall **)(struct CxFile *, int *, int, int))(v4 + 8))(a2, &v15, 9, 1);
        LOWORD(v15) = (unsigned __int8)v15 + (BYTE1(v15) << 8);
        HIWORD(v15) = BYTE2(v15) + (HIBYTE(v15) << 8);
        v16[0] = LOBYTE(v16[0]) + (HIBYTE(v16[0]) << 8);
        v16[1] = LOBYTE(v16[1]) + (HIBYTE(v16[1]) << 8);
        if ( (v17 & 0x80u) != 0 )
        {
          v5 = *(_DWORD *)a2;
          v22[1] = 1 << ((v17 & 7) + 1);
          (*(void (__thiscall **)(struct CxFile *, __int16 *, int, int))(v5 + 8))(a2, &v22[2], 3 * v22[1], 1);
        }
        if ( v22[1] > 2 )
          v6 = v22[1] > 16 ? 8 : 4;
        else
          v6 = 1;
        CxImage::Create(this, (unsigned __int16)v16[0], (unsigned __int16)v16[1], v6, 2);
        v7 = sub_40B720((int)a2, 0x18u);
        v8 = v7;
        v19 = v7;
        v23 = 0;
        if ( v7 )
        {
          *(_DWORD *)(v7 + 20) = this;
          if ( this )
            *(_DWORD *)(v7 + 16) = CxImage::GetBits(this);
          *(_DWORD *)(v8 + 4) = 0;
          *(_DWORD *)v8 = 0;
          *(_DWORD *)(v8 + 12) = 0;
          *(_DWORD *)(v8 + 8) = 0;
        }
        else
        {
          v8 = 0;
        }
        v9 = *(CxImage **)(v8 + 20);
        *(_DWORD *)v8 = 0;
        v23 = -1;
        *(_DWORD *)(v8 + 4) = *((_DWORD *)v9 + 4) - 1;
        v10 = *((_DWORD *)v9 + 12);
        v19 = *((_DWORD *)v9 + 4);
        v11 = CxImage::GetBits(v9);
        *(_DWORD *)(v8 + 16) = &v11[v10 * (v19 - 1)];
        LOWORD(v11) = v16[1];
        *((_DWORD *)this + 106) = v17 & 0x40;
        v12 = *(_DWORD *)v16;
        *((_DWORD *)this + 109) = (unsigned __int16)v11;
        *((_DWORD *)this + 111) = 16385;
        *((_DWORD *)this + 108) = 8;
        *((_DWORD *)this + 107) = 0;
        *((_DWORD *)this + 110) = 0;
        CxImageGIF::decoder(this, a2, (struct CImageIterator *)v8, v12, &v21);
        sub_40B7E0(v8);
        (*(void (__thiscall **)(struct CxFile *, int, int))(*(_DWORD *)a2 + 16))(
          a2,
          *((_DWORD *)this + 111) - *((_DWORD *)this + 112) + 1,
          1);
        break;
      case ';':
        goto LABEL_19;
    }
  }
LABEL_19:
  (*(void (__thiscall **)(struct CxFile *, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v20, 0);
  return v18;
}

//----- (00461AE0) --------------------------------------------------------
void __thiscall CxImageGIF::SetDisposalMethod(CxImageGIF *this, int a2)
{
  *((_DWORD *)this + 16017) = a2;
}

//----- (00461AF0) --------------------------------------------------------
int __thiscall CxImageGIF::GetDisposalMethod(CxImageGIF *this)
{
  return *((_DWORD *)this + 16017);
}

//----- (00461B00) --------------------------------------------------------
void __thiscall CxImageGIF::SetLoops(CxImageGIF *this, int a2)
{
  *((_DWORD *)this + 16016) = a2;
}

//----- (00461B10) --------------------------------------------------------
int __thiscall CxImageGIF::GetLoops(CxImageGIF *this)
{
  return *((_DWORD *)this + 16016);
}

//----- (00461B20) --------------------------------------------------------
void __thiscall CxImageGIF::SetComment(CxImageGIF *this, const char *a2)
{
  if ( a2 )
    strncpy((char *)this + 63808, a2, 0xFFu);
}

//----- (00461B40) --------------------------------------------------------
void __thiscall CxImageGIF::GetComment(CxImageGIF *this, char *Destination)
{
  if ( Destination )
    strncpy(Destination, (const char *)this + 63808, 0xFFu);
}

//----- (00461B60) --------------------------------------------------------
void __thiscall CxImageGIF::GifMix(CxImageGIF *this, struct CxImage *a2, int a3, int a4)
{
  int v5; // ebx
  int j; // esi
  unsigned __int8 v7; // al
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  char i; // [esp+24h] [ebp+4h]

  v8 = *((_DWORD *)this + 3);
  if ( v8 >= (unsigned int)(*((_DWORD *)a2 + 3) - a3) )
    v8 = *((_DWORD *)a2 + 3) - a3;
  v9 = *((_DWORD *)this + 4);
  if ( v9 >= (unsigned int)(*((_DWORD *)a2 + 4) - a4) )
    v9 = *((_DWORD *)a2 + 4) - a4;
  v5 = 0;
  for ( i = *((_BYTE *)a2 + 328); v5 < v9; ++v5 )
  {
    for ( j = 0; j < v8; ++j )
    {
      v7 = CxImage::GetPixelIndex(a2, j + a3, v5 + a4);
      if ( v7 != i )
        CxImage::SetPixelIndex(this, j, v5, v7);
    }
  }
}

//----- (00461C10) --------------------------------------------------------
void __thiscall CxImageGIF::rle_clear(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  int v2; // edx

  v2 = *((_DWORD *)a2 + 10);
  *((_DWORD *)a2 + 6) = *((_DWORD *)a2 + 7);
  *((_DWORD *)a2 + 11) = *((_DWORD *)a2 + 12);
  *((_DWORD *)a2 + 9) = v2;
  *((_DWORD *)a2 + 8) = 0;
  *((_DWORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 5) = 1;
}

//----- (00461C40) --------------------------------------------------------
void __thiscall CxImageGIF::rle_flush(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  CxImageGIF *v2; // edi
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // ebp
  unsigned int v23; // edi
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // edx
  unsigned int i; // ecx
  unsigned int j; // edx
  int v29; // ecx
  int v30; // edi
  int v31; // edx
  int v32; // eax
  unsigned int v33; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // edx

  v2 = this;
  v3 = *((_DWORD *)a2 + 2);
  if ( v3 == 1 )
  {
    v4 = *((_DWORD *)a2 + 17);
    v5 = *((_DWORD *)a2 + 16);
    v6 = *(_DWORD *)a2 << v4;
    *((_DWORD *)a2 + 5) = 0;
    *((_DWORD *)a2 + 16) = v6 | v5;
    v7 = v4 + *((_DWORD *)a2 + 6);
    *((_DWORD *)a2 + 17) = v7;
    if ( v7 >= 8 )
    {
      do
      {
        *((_BYTE *)a2 + *((_DWORD *)a2 + 82) + 72) = *((_BYTE *)a2 + 64);
        v8 = *((_DWORD *)a2 + 82) + 1;
        *((_DWORD *)a2 + 82) = v8;
        if ( v8 >= 255 )
          CxImageGIF::rle_write_block(v2, a2);
        v9 = *((_DWORD *)a2 + 16);
        v10 = *((_DWORD *)a2 + 17) - 8;
        *((_DWORD *)a2 + 17) = v10;
        *((_DWORD *)a2 + 16) = v9 >> 8;
      }
      while ( v10 >= 8 );
    }
    v11 = *((_DWORD *)a2 + 9);
    v12 = *((_DWORD *)a2 + 8) + 1;
    *((_DWORD *)a2 + 8) = v12;
    if ( v12 >= v11 )
    {
      v13 = *((_DWORD *)a2 + 6) + 1;
      *((_DWORD *)a2 + 6) = v13;
      *((_DWORD *)a2 + 9) = v11 + (1 << (v13 - 1));
    }
    if ( v12 < *((_DWORD *)a2 + 11) )
    {
      *((_DWORD *)a2 + 2) = 0;
    }
    else
    {
      v14 = *((_DWORD *)a2 + 17);
      *((_DWORD *)a2 + 16) |= *((_DWORD *)a2 + 14) << v14;
      v15 = v14 + *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 17) = v15;
      if ( v15 >= 8 )
      {
        do
        {
          *((_BYTE *)a2 + *((_DWORD *)a2 + 82) + 72) = *((_BYTE *)a2 + 64);
          v16 = *((_DWORD *)a2 + 82) + 1;
          *((_DWORD *)a2 + 82) = v16;
          if ( v16 >= 255 )
            CxImageGIF::rle_write_block(v2, a2);
          v17 = *((_DWORD *)a2 + 16);
          v18 = *((_DWORD *)a2 + 17) - 8;
          *((_DWORD *)a2 + 17) = v18;
          *((_DWORD *)a2 + 16) = v17 >> 8;
        }
        while ( v18 >= 8 );
      }
      v19 = *((_DWORD *)a2 + 10);
      v20 = *((_DWORD *)a2 + 12);
      *((_DWORD *)a2 + 6) = *((_DWORD *)a2 + 7);
      *((_DWORD *)a2 + 9) = v19;
      *((_DWORD *)a2 + 11) = v20;
      *((_DWORD *)a2 + 8) = 0;
      *((_DWORD *)a2 + 4) = 0;
      *((_DWORD *)a2 + 5) = 1;
      *((_DWORD *)a2 + 2) = 0;
    }
  }
  else if ( *((_DWORD *)a2 + 5) )
  {
    CxImageGIF::rle_flush_fromclear(this, v3, a2);
    *((_DWORD *)a2 + 2) = 0;
  }
  else if ( *((int *)a2 + 4) >= 2 && *((_DWORD *)a2 + 3) == *(_DWORD *)a2 )
  {
    CxImageGIF::rle_flush_withtable(this, v3, a2);
    *((_DWORD *)a2 + 2) = 0;
  }
  else
  {
    v21 = *((_DWORD *)a2 + 13);
    v22 = 0;
    v23 = *((_DWORD *)a2 + 2);
    v24 = (unsigned int)(v21 * (v21 + 1)) >> 1;
    if ( v3 >= v24 )
    {
      do
      {
        v23 -= v24;
        v22 += v21;
      }
      while ( v23 >= v24 );
    }
    if ( v23 )
    {
      v25 = CxImageGIF::rle_isqrt(this, v23);
      v26 = v25 + 1;
      for ( i = 2 * v23; v25 * v26 >= i; --v26 )
        --v25;
      for ( j = v25 + 1; v25 * j < i; ++j )
        ++v25;
      v22 += v25;
    }
    if ( v22 + 1 >= v3 )
    {
      if ( v3 > 0 )
      {
        do
        {
          CxImageGIF::rle_output_plain(this, *(_DWORD *)a2, a2);
          --v3;
        }
        while ( v3 );
      }
      *((_DWORD *)a2 + 2) = 0;
    }
    else
    {
      v29 = *((_DWORD *)a2 + 17);
      v30 = *((_DWORD *)a2 + 16);
      v31 = *((_DWORD *)a2 + 14) << v29;
      v32 = v29 + *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 17) = v32;
      *((_DWORD *)a2 + 16) = v31 | v30;
      if ( v32 >= 8 )
      {
        do
        {
          CxImageGIF::rle_block_out(this, *((_BYTE *)a2 + 64), a2);
          v33 = *((_DWORD *)a2 + 16);
          v34 = *((_DWORD *)a2 + 17) - 8;
          *((_DWORD *)a2 + 17) = v34;
          *((_DWORD *)a2 + 16) = v33 >> 8;
        }
        while ( v34 >= 8 );
      }
      v35 = *((_DWORD *)a2 + 12);
      v36 = *((_DWORD *)a2 + 7);
      *((_DWORD *)a2 + 9) = *((_DWORD *)a2 + 10);
      *((_DWORD *)a2 + 11) = v35;
      *((_DWORD *)a2 + 6) = v36;
      *((_DWORD *)a2 + 8) = 0;
      *((_DWORD *)a2 + 4) = 0;
      *((_DWORD *)a2 + 5) = 1;
      CxImageGIF::rle_flush_fromclear(this, v3, a2);
      *((_DWORD *)a2 + 2) = 0;
    }
  }
}

//----- (00461EF0) --------------------------------------------------------
void __thiscall CxImageGIF::rle_output_plain(CxImageGIF *this, int a2, struct CxImageGIF::tag_RLE *a3)
{
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ecx
  unsigned int v14; // edx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // edx

  v4 = *((_DWORD *)a3 + 17);
  v5 = *((_DWORD *)a3 + 16);
  *((_DWORD *)a3 + 5) = 0;
  *((_DWORD *)a3 + 16) = (a2 << v4) | v5;
  v6 = *((_DWORD *)a3 + 6) + v4;
  *((_DWORD *)a3 + 17) = v6;
  if ( v6 >= 8 )
  {
    do
    {
      *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
      v7 = *((_DWORD *)a3 + 82) + 1;
      *((_DWORD *)a3 + 82) = v7;
      if ( v7 >= 255 )
      {
        (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v7);
        (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
          *((_DWORD *)this + 15884),
          (char *)a3 + 72,
          1,
          *((_DWORD *)a3 + 82));
        *((_DWORD *)a3 + 82) = 0;
      }
      v8 = *((_DWORD *)a3 + 16);
      v9 = *((_DWORD *)a3 + 17) - 8;
      *((_DWORD *)a3 + 17) = v9;
      *((_DWORD *)a3 + 16) = v8 >> 8;
    }
    while ( v9 >= 8 );
  }
  v10 = *((_DWORD *)a3 + 9);
  v11 = *((_DWORD *)a3 + 8) + 1;
  *((_DWORD *)a3 + 8) = v11;
  if ( v11 >= v10 )
  {
    v12 = *((_DWORD *)a3 + 6) + 1;
    *((_DWORD *)a3 + 6) = v12;
    *((_DWORD *)a3 + 9) = v10 + (1 << (v12 - 1));
  }
  if ( v11 >= *((_DWORD *)a3 + 11) )
  {
    v13 = *((_DWORD *)a3 + 17);
    v14 = *((_DWORD *)a3 + 14) << v13;
    *((_DWORD *)a3 + 16) |= v14;
    v15 = v13 + *((_DWORD *)a3 + 6);
    *((_DWORD *)a3 + 17) = v15;
    if ( v15 >= 8 )
    {
      do
      {
        *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
        v16 = *((_DWORD *)a3 + 82) + 1;
        *((_DWORD *)a3 + 82) = v16;
        if ( v16 >= 255 )
        {
          LOBYTE(v14) = *((_BYTE *)a3 + 328);
          (*(void (__thiscall **)(_DWORD, unsigned int))(**((_DWORD **)this + 15884) + 40))(
            *((_DWORD *)this + 15884),
            v14);
          (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
            *((_DWORD *)this + 15884),
            (char *)a3 + 72,
            1,
            *((_DWORD *)a3 + 82));
          *((_DWORD *)a3 + 82) = 0;
        }
        v17 = *((_DWORD *)a3 + 16);
        v18 = *((_DWORD *)a3 + 17) - 8;
        *((_DWORD *)a3 + 17) = v18;
        v14 = v17 >> 8;
        *((_DWORD *)a3 + 16) = v14;
      }
      while ( v18 >= 8 );
    }
    v19 = *((_DWORD *)a3 + 10);
    v20 = *((_DWORD *)a3 + 12);
    *((_DWORD *)a3 + 6) = *((_DWORD *)a3 + 7);
    *((_DWORD *)a3 + 9) = v19;
    *((_DWORD *)a3 + 11) = v20;
    *((_DWORD *)a3 + 8) = 0;
    *((_DWORD *)a3 + 4) = 0;
    *((_DWORD *)a3 + 5) = 1;
  }
}

//----- (00462070) --------------------------------------------------------
void __thiscall CxImageGIF::rle_flush_fromclear(CxImageGIF *this, int a2, struct CxImageGIF::tag_RLE *a3)
{
  int v3; // ebx
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // eax
  unsigned int v12; // edx
  int v13; // eax
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // ecx
  int v18; // edx
  int v19; // edx
  int v20; // ecx
  int v21; // eax
  unsigned int v22; // edx
  int v23; // eax
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  int v27; // ecx
  int v28; // edx
  int v29; // ebx
  int v30; // ecx
  int v31; // eax
  unsigned int v32; // edx
  int v33; // eax
  int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // eax
  int v38; // eax
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // ecx
  int v43; // [esp+18h] [ebp+8h]

  v3 = a2;
  v6 = *(_DWORD *)a3;
  *((_DWORD *)a3 + 11) = *((_DWORD *)a3 + 13);
  v7 = 1;
  *((_DWORD *)a3 + 3) = v6;
  v43 = 1;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      if ( v7 == 1 )
      {
        v8 = *((_DWORD *)a3 + 17);
        v9 = *(_DWORD *)a3 << v8;
        *((_DWORD *)a3 + 4) = 1;
        v10 = *((_DWORD *)a3 + 16);
        *((_DWORD *)a3 + 5) = 0;
        *((_DWORD *)a3 + 16) = v9 | v10;
        v11 = v8 + *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 17) = v11;
        if ( v11 >= 8 )
        {
          do
          {
            CxImageGIF::rle_block_out(this, *((_BYTE *)a3 + 64), a3);
            v12 = *((_DWORD *)a3 + 16);
            v13 = *((_DWORD *)a3 + 17) - 8;
            *((_DWORD *)a3 + 17) = v13;
            *((_DWORD *)a3 + 16) = v12 >> 8;
          }
          while ( v13 >= 8 );
        }
        v14 = *((_DWORD *)a3 + 9);
        v15 = *((_DWORD *)a3 + 8) + 1;
        *((_DWORD *)a3 + 8) = v15;
        if ( v15 >= v14 )
        {
          v16 = *((_DWORD *)a3 + 6) + 1;
          *((_DWORD *)a3 + 6) = v16;
          *((_DWORD *)a3 + 9) = v14 + (1 << (v16 - 1));
        }
        if ( v15 >= *((_DWORD *)a3 + 11) )
        {
          CxImageGIF::rle_output(this, *((_DWORD *)a3 + 14), a3);
          v17 = *((_DWORD *)a3 + 10);
          v18 = *((_DWORD *)a3 + 12);
          *((_DWORD *)a3 + 6) = *((_DWORD *)a3 + 7);
          *((_DWORD *)a3 + 9) = v17;
          *((_DWORD *)a3 + 11) = v18;
          *((_DWORD *)a3 + 8) = 0;
          *((_DWORD *)a3 + 4) = 0;
          *((_DWORD *)a3 + 5) = 1;
        }
        --v3;
      }
      else
      {
        if ( v3 < v7 )
        {
          v27 = *((_DWORD *)a3 + 4);
          if ( v3 == 1 )
          {
            v28 = *(_DWORD *)a3;
            v29 = *((_DWORD *)a3 + 16);
            *((_DWORD *)a3 + 4) = v27 + 1;
            v30 = *((_DWORD *)a3 + 17);
            v31 = v30 + *((_DWORD *)a3 + 6);
            *((_DWORD *)a3 + 5) = 0;
            *((_DWORD *)a3 + 17) = v31;
            *((_DWORD *)a3 + 16) = (v28 << v30) | v29;
            if ( v31 >= 8 )
            {
              do
              {
                CxImageGIF::rle_block_out(this, *((_BYTE *)a3 + 64), a3);
                v32 = *((_DWORD *)a3 + 16);
                v33 = *((_DWORD *)a3 + 17) - 8;
                *((_DWORD *)a3 + 17) = v33;
                *((_DWORD *)a3 + 16) = v32 >> 8;
              }
              while ( v33 >= 8 );
            }
            v34 = *((_DWORD *)a3 + 9);
            v35 = *((_DWORD *)a3 + 8) + 1;
            *((_DWORD *)a3 + 8) = v35;
            if ( v35 >= v34 )
            {
              v36 = *((_DWORD *)a3 + 6) + 1;
              *((_DWORD *)a3 + 6) = v36;
              *((_DWORD *)a3 + 9) = v34 + (1 << (v36 - 1));
            }
            if ( v35 >= *((_DWORD *)a3 + 11) )
              goto LABEL_30;
          }
          else
          {
            v37 = *((_DWORD *)a3 + 1);
            *((_DWORD *)a3 + 4) = v27 + 1;
            *((_DWORD *)a3 + 5) = 0;
            CxImageGIF::rle_output(this, v37 + v3 - 2, a3);
            v38 = *((_DWORD *)a3 + 9);
            v39 = *((_DWORD *)a3 + 8) + 1;
            *((_DWORD *)a3 + 8) = v39;
            if ( v39 >= v38 )
            {
              v40 = *((_DWORD *)a3 + 6) + 1;
              *((_DWORD *)a3 + 6) = v40;
              *((_DWORD *)a3 + 9) = v38 + (1 << (v40 - 1));
            }
            if ( v39 >= *((_DWORD *)a3 + 11) )
            {
LABEL_30:
              CxImageGIF::rle_output(this, *((_DWORD *)a3 + 14), a3);
              CxImageGIF::rle_clear(this, a3);
            }
          }
          v3 = 0;
          goto LABEL_32;
        }
        v19 = *((_DWORD *)a3 + 1);
        v20 = *((_DWORD *)a3 + 17);
        *((_DWORD *)a3 + 4) = v7;
        *((_DWORD *)a3 + 5) = 0;
        *((_DWORD *)a3 + 16) |= (v19 + v7 - 2) << v20;
        v21 = *((_DWORD *)a3 + 6) + v20;
        *((_DWORD *)a3 + 17) = v21;
        if ( v21 >= 8 )
        {
          do
          {
            CxImageGIF::rle_block_out(this, *((_BYTE *)a3 + 64), a3);
            v22 = *((_DWORD *)a3 + 16);
            v23 = *((_DWORD *)a3 + 17) - 8;
            *((_DWORD *)a3 + 17) = v23;
            *((_DWORD *)a3 + 16) = v22 >> 8;
          }
          while ( v23 >= 8 );
        }
        v24 = *((_DWORD *)a3 + 9);
        v25 = *((_DWORD *)a3 + 8) + 1;
        *((_DWORD *)a3 + 8) = v25;
        if ( v25 >= v24 )
        {
          v26 = *((_DWORD *)a3 + 6) + 1;
          *((_DWORD *)a3 + 6) = v26;
          *((_DWORD *)a3 + 9) = v24 + (1 << (v26 - 1));
        }
        if ( v25 >= *((_DWORD *)a3 + 11) )
        {
          CxImageGIF::rle_output(this, *((_DWORD *)a3 + 14), a3);
          CxImageGIF::rle_clear(this, a3);
        }
        v3 -= v43;
      }
LABEL_32:
      if ( *((_DWORD *)a3 + 8) )
        ++v43;
      else
        v43 = 1;
      if ( v3 <= 0 )
        break;
      v7 = v43;
    }
  }
  v41 = *((_DWORD *)a3 + 12);
  v42 = *((_DWORD *)a3 + 8);
  *((_DWORD *)a3 + 11) = v41;
  if ( v42 >= v41 )
  {
    CxImageGIF::rle_output(this, *((_DWORD *)a3 + 14), a3);
    CxImageGIF::rle_clear(this, a3);
  }
}

//----- (00462310) --------------------------------------------------------
void __thiscall CxImageGIF::rle_reset_out_clear(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax

  v3 = *((_DWORD *)a2 + 12);
  v4 = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 11) = v3;
  if ( v4 >= v3 )
  {
    v5 = *((_DWORD *)a2 + 17);
    *((_DWORD *)a2 + 16) |= *((_DWORD *)a2 + 14) << v5;
    v6 = *((_DWORD *)a2 + 6) + v5;
    *((_DWORD *)a2 + 17) = v6;
    if ( v6 >= 8 )
    {
      do
      {
        *((_BYTE *)a2 + *((_DWORD *)a2 + 82) + 72) = *((_BYTE *)a2 + 64);
        v7 = *((_DWORD *)a2 + 82) + 1;
        *((_DWORD *)a2 + 82) = v7;
        if ( v7 >= 255 )
        {
          (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v7);
          (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
            *((_DWORD *)this + 15884),
            (char *)a2 + 72,
            1,
            *((_DWORD *)a2 + 82));
          *((_DWORD *)a2 + 82) = 0;
        }
        v8 = *((_DWORD *)a2 + 16);
        v9 = *((_DWORD *)a2 + 17) - 8;
        *((_DWORD *)a2 + 17) = v9;
        *((_DWORD *)a2 + 16) = v8 >> 8;
      }
      while ( v9 >= 8 );
    }
    v10 = *((_DWORD *)a2 + 7);
    v11 = *((_DWORD *)a2 + 10);
    v12 = *((_DWORD *)a2 + 12);
    *((_DWORD *)a2 + 8) = 0;
    *((_DWORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 6) = v10;
    *((_DWORD *)a2 + 9) = v11;
    *((_DWORD *)a2 + 11) = v12;
    *((_DWORD *)a2 + 5) = 1;
  }
}

//----- (004623E0) --------------------------------------------------------
void __thiscall CxImageGIF::rle_flush_withtable(CxImageGIF *this, unsigned int a2, struct CxImageGIF::tag_RLE *a3)
{
  int v4; // ecx
  int v5; // ebx
  unsigned int v6; // ebp
  int v7; // edx
  int v8; // eax
  struct CxImageGIF::tag_RLE *v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int i; // ecx
  unsigned int j; // edx
  int v16; // ecx
  unsigned int v17; // edi
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int k; // ecx
  unsigned int l; // edx
  int v23; // ecx
  int v24; // eax
  int v25; // eax
  unsigned int v26; // edx
  int v27; // eax
  int v28; // eax
  int v29; // ecx
  CxImageGIF *v30; // ebx
  int v31; // eax
  int v32; // edx
  int v33; // ecx
  int v34; // edx
  int v35; // ecx
  int v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // eax
  int v40; // edx
  int v41; // ecx
  int v42; // [esp-8h] [ebp-20h]
  char *v44; // [esp+14h] [ebp-4h]
  unsigned int v45; // [esp+1Ch] [ebp+4h]
  struct CxImageGIF::tag_RLE *v46; // [esp+20h] [ebp+8h]
  struct CxImageGIF::tag_RLE *v47; // [esp+20h] [ebp+8h]

  v4 = *((_DWORD *)a3 + 4);
  v5 = (int)a2 / v4;
  v6 = (int)a2 % v4;
  v7 = *((_DWORD *)a3 + 13);
  v8 = *((_DWORD *)a3 + 8);
  v44 = (char *)((int)a2 % v4 != 0);
  if ( (int)&v44[v8 + (int)a2 / v4] > v7 )
  {
    v5 = v7 - v8;
    v6 = a2 - (v7 - v8) * v4;
    v9 = 0;
    v10 = (unsigned int)(v7 * (v7 + 1)) >> 1;
    v11 = v6;
    v46 = 0;
    if ( v6 >= v10 )
    {
      do
      {
        v11 -= v10;
        v9 = (struct CxImageGIF::tag_RLE *)((char *)v9 + v7);
      }
      while ( v11 >= v10 );
      v46 = v9;
    }
    if ( v11 )
    {
      v12 = CxImageGIF::rle_isqrt(this, v11);
      v13 = v12 + 1;
      for ( i = 2 * v11; v12 * v13 >= i; --v13 )
        --v12;
      for ( j = v12 + 1; v12 * j < i; ++j )
        ++v12;
      v9 = (struct CxImageGIF::tag_RLE *)((char *)v46 + v12);
    }
    v44 = (char *)v9 + 1;
  }
  v16 = *((_DWORD *)a3 + 13);
  v17 = a2;
  v47 = 0;
  v18 = (unsigned int)(v16 * (v16 + 1)) >> 1;
  if ( a2 >= v18 )
  {
    do
    {
      v17 -= v18;
      v47 = (struct CxImageGIF::tag_RLE *)((char *)v47 + v16);
    }
    while ( v17 >= v18 );
  }
  if ( v17 )
  {
    v19 = CxImageGIF::rle_isqrt(this, v17);
    v20 = v19 + 1;
    for ( k = 2 * v17; v19 * v20 >= k; --v20 )
      --v19;
    for ( l = v19 + 1; v19 * l < k; ++l )
      ++v19;
    v47 = (struct CxImageGIF::tag_RLE *)((char *)v47 + v19);
  }
  if ( (char *)v47 + 1 >= &v44[v5] )
  {
    *((_DWORD *)a3 + 11) = *((_DWORD *)a3 + 13);
    if ( v5 <= 0 )
    {
      v30 = this;
    }
    else
    {
      v45 = v5;
      do
      {
        v30 = this;
        v42 = *((_DWORD *)a3 + 1) + *((_DWORD *)a3 + 4) - 2;
        *((_DWORD *)a3 + 5) = 0;
        CxImageGIF::rle_output(this, v42, a3);
        v31 = *((_DWORD *)a3 + 9);
        v32 = *((_DWORD *)a3 + 8) + 1;
        *((_DWORD *)a3 + 8) = v32;
        if ( v32 >= v31 )
        {
          v33 = *((_DWORD *)a3 + 6) + 1;
          *((_DWORD *)a3 + 6) = v33;
          *((_DWORD *)a3 + 9) = v31 + (1 << (v33 - 1));
        }
        if ( v32 >= *((_DWORD *)a3 + 11) )
        {
          CxImageGIF::rle_output(this, *((_DWORD *)a3 + 14), a3);
          v34 = *((_DWORD *)a3 + 7);
          v35 = *((_DWORD *)a3 + 12);
          *((_DWORD *)a3 + 9) = *((_DWORD *)a3 + 10);
          *((_DWORD *)a3 + 6) = v34;
          *((_DWORD *)a3 + 11) = v35;
          *((_DWORD *)a3 + 8) = 0;
          *((_DWORD *)a3 + 4) = 0;
          *((_DWORD *)a3 + 5) = 1;
        }
        --v45;
      }
      while ( v45 );
    }
    if ( !v6 )
      goto LABEL_47;
    if ( *((_DWORD *)a3 + 5) )
    {
      CxImageGIF::rle_flush_fromclear(v30, v6, a3);
      CxImageGIF::rle_reset_out_clear(v30, a3);
      return;
    }
    *((_DWORD *)a3 + 5) = 0;
    if ( v6 == 1 )
    {
      CxImageGIF::rle_output(v30, *(_DWORD *)a3, a3);
      v36 = *((_DWORD *)a3 + 9);
      v37 = *((_DWORD *)a3 + 8) + 1;
      *((_DWORD *)a3 + 8) = v37;
      if ( v37 >= v36 )
      {
        v38 = *((_DWORD *)a3 + 6) + 1;
        *((_DWORD *)a3 + 6) = v38;
        *((_DWORD *)a3 + 9) = v36 + (1 << (v38 - 1));
      }
      if ( v37 < *((_DWORD *)a3 + 11) )
        goto LABEL_47;
    }
    else
    {
      CxImageGIF::rle_output(v30, *((_DWORD *)a3 + 1) + v6 - 2, a3);
      v39 = *((_DWORD *)a3 + 9);
      v40 = *((_DWORD *)a3 + 8) + 1;
      *((_DWORD *)a3 + 8) = v40;
      if ( v40 >= v39 )
      {
        v41 = *((_DWORD *)a3 + 6) + 1;
        *((_DWORD *)a3 + 6) = v41;
        *((_DWORD *)a3 + 9) = v39 + (1 << (v41 - 1));
      }
      if ( v40 < *((_DWORD *)a3 + 11) )
        goto LABEL_47;
    }
    CxImageGIF::rle_output(v30, *((_DWORD *)a3 + 14), a3);
    CxImageGIF::rle_clear(v30, a3);
LABEL_47:
    CxImageGIF::rle_reset_out_clear(v30, a3);
    return;
  }
  v23 = *((_DWORD *)a3 + 17);
  *((_DWORD *)a3 + 16) |= *((_DWORD *)a3 + 14) << v23;
  v24 = *((_DWORD *)a3 + 6) + v23;
  *((_DWORD *)a3 + 17) = v24;
  if ( v24 >= 8 )
  {
    do
    {
      *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
      v25 = *((_DWORD *)a3 + 82) + 1;
      *((_DWORD *)a3 + 82) = v25;
      if ( v25 >= 255 )
        CxImageGIF::rle_write_block(this, a3);
      v26 = *((_DWORD *)a3 + 16);
      v27 = *((_DWORD *)a3 + 17) - 8;
      *((_DWORD *)a3 + 17) = v27;
      *((_DWORD *)a3 + 16) = v26 >> 8;
    }
    while ( v27 >= 8 );
  }
  v28 = *((_DWORD *)a3 + 10);
  v29 = *((_DWORD *)a3 + 12);
  *((_DWORD *)a3 + 6) = *((_DWORD *)a3 + 7);
  *((_DWORD *)a3 + 9) = v28;
  *((_DWORD *)a3 + 11) = v29;
  *((_DWORD *)a3 + 8) = 0;
  *((_DWORD *)a3 + 4) = 0;
  *((_DWORD *)a3 + 5) = 1;
  CxImageGIF::rle_flush_fromclear(this, a2, a3);
}

//----- (00462720) --------------------------------------------------------
int __thiscall CxImageGIF::rle_compute_triangle_count(CxImageGIF *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  int v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // edx
  unsigned int i; // ecx
  unsigned int j; // edx

  v3 = a2;
  v4 = 0;
  v5 = (a3 * (a3 + 1)) >> 1;
  if ( a2 >= v5 )
  {
    do
    {
      v3 -= v5;
      v4 += a3;
    }
    while ( v3 >= v5 );
  }
  if ( v3 )
  {
    v6 = v3;
    if ( v3 >= 2 )
    {
      v7 = 1;
      do
      {
        v6 >>= 2;
        v7 *= 2;
      }
      while ( v6 );
      while ( 1 )
      {
        v8 = (v7 + v3 / v7) >> 1;
        if ( v8 == v7 || v8 == v7 + 1 )
          break;
        v7 = (v7 + v3 / v7) >> 1;
      }
      v6 = v7;
    }
    v9 = v6 + 1;
    for ( i = 2 * v3; v6 * v9 >= i; --v9 )
      --v6;
    for ( j = v6 + 1; v6 * j < i; ++j )
      ++v6;
    v4 += v6;
  }
  return v4;
}

//----- (004627B0) --------------------------------------------------------
unsigned int __thiscall CxImageGIF::rle_isqrt(CxImageGIF *this, unsigned int a2)
{
  unsigned int result; // eax
  unsigned int v3; // ecx
  unsigned int v4; // eax

  result = a2;
  if ( a2 >= 2 )
  {
    v3 = 1;
    do
    {
      result >>= 2;
      v3 *= 2;
    }
    while ( result );
    while ( 1 )
    {
      v4 = (v3 + a2 / v3) >> 1;
      if ( v4 == v3 || v4 == v3 + 1 )
        break;
      v3 = (v3 + a2 / v3) >> 1;
    }
    result = v3;
  }
  return result;
}
// 4627C3: conditional instruction was optimized away because of '%arg_0.4>=2u'

//----- (004627F0) --------------------------------------------------------
void __thiscall CxImageGIF::rle_flush_clearorrep(CxImageGIF *this, int a2, struct CxImageGIF::tag_RLE *a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // ebx
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned int i; // ecx
  unsigned int j; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // edx
  int v23; // eax
  int v24; // eax
  int v25; // ecx
  unsigned int v26; // edx
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // ecx
  int v31; // ecx
  int v32; // eax
  unsigned int v33; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // edx
  int v37; // [esp+14h] [ebp+4h]

  v4 = a2;
  v5 = *((_DWORD *)a3 + 13);
  v6 = 0;
  v7 = a2;
  v8 = (unsigned int)(v5 * (v5 + 1)) >> 1;
  if ( a2 >= v8 )
  {
    do
    {
      v7 -= v8;
      v6 += v5;
    }
    while ( v7 >= v8 );
  }
  if ( v7 )
  {
    v9 = v7;
    if ( v7 >= 2 )
    {
      v10 = 1;
      do
      {
        v9 >>= 2;
        v10 *= 2;
      }
      while ( v9 );
      while ( 1 )
      {
        v11 = (v10 + v7 / v10) >> 1;
        if ( v11 == v10 || v11 == v10 + 1 )
          break;
        v10 = (v10 + v7 / v10) >> 1;
      }
      v9 = v10;
    }
    v12 = v9 + 1;
    for ( i = 2 * v7; v9 * v12 >= i; --v12 )
      --v9;
    for ( j = v9 + 1; v9 * j < i; ++j )
      ++v9;
    v4 = a2;
    v6 += v9;
  }
  if ( v6 + 1 >= v4 )
  {
    if ( v4 > 0 )
    {
      v37 = v4;
      do
      {
        v21 = *((_DWORD *)a3 + 17);
        v22 = *(_DWORD *)a3;
        v23 = *((_DWORD *)a3 + 16);
        *((_DWORD *)a3 + 5) = 0;
        *((_DWORD *)a3 + 16) = (v22 << v21) | v23;
        v24 = v21 + *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 17) = v24;
        if ( v24 >= 8 )
        {
          do
          {
            *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
            v25 = *((_DWORD *)a3 + 82) + 1;
            *((_DWORD *)a3 + 82) = v25;
            if ( v25 >= 255 )
              CxImageGIF::rle_write_block(this, a3);
            v26 = *((_DWORD *)a3 + 16);
            v27 = *((_DWORD *)a3 + 17) - 8;
            *((_DWORD *)a3 + 17) = v27;
            *((_DWORD *)a3 + 16) = v26 >> 8;
          }
          while ( v27 >= 8 );
        }
        v28 = *((_DWORD *)a3 + 9);
        v29 = *((_DWORD *)a3 + 8) + 1;
        *((_DWORD *)a3 + 8) = v29;
        if ( v29 >= v28 )
        {
          v30 = *((_DWORD *)a3 + 6) + 1;
          *((_DWORD *)a3 + 6) = v30;
          *((_DWORD *)a3 + 9) = v28 + (1 << (v30 - 1));
        }
        if ( v29 >= *((_DWORD *)a3 + 11) )
        {
          v31 = *((_DWORD *)a3 + 17);
          *((_DWORD *)a3 + 16) |= *((_DWORD *)a3 + 14) << v31;
          v32 = *((_DWORD *)a3 + 6) + v31;
          *((_DWORD *)a3 + 17) = v32;
          if ( v32 >= 8 )
          {
            do
            {
              CxImageGIF::rle_block_out(this, *((_BYTE *)a3 + 64), a3);
              v33 = *((_DWORD *)a3 + 16);
              v34 = *((_DWORD *)a3 + 17) - 8;
              *((_DWORD *)a3 + 17) = v34;
              *((_DWORD *)a3 + 16) = v33 >> 8;
            }
            while ( v34 >= 8 );
          }
          v35 = *((_DWORD *)a3 + 7);
          v36 = *((_DWORD *)a3 + 10);
          *((_DWORD *)a3 + 11) = *((_DWORD *)a3 + 12);
          *((_DWORD *)a3 + 6) = v35;
          *((_DWORD *)a3 + 9) = v36;
          *((_DWORD *)a3 + 8) = 0;
          *((_DWORD *)a3 + 4) = 0;
          *((_DWORD *)a3 + 5) = 1;
        }
        --v37;
      }
      while ( v37 );
    }
  }
  else
  {
    v15 = *((_DWORD *)a3 + 17);
    v16 = v15 + *((_DWORD *)a3 + 6);
    *((_DWORD *)a3 + 16) |= *((_DWORD *)a3 + 14) << v15;
    *((_DWORD *)a3 + 17) = v16;
    if ( v16 >= 8 )
    {
      do
      {
        *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
        v17 = *((_DWORD *)a3 + 82) + 1;
        *((_DWORD *)a3 + 82) = v17;
        if ( v17 >= 255 )
        {
          (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v17);
          (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
            *((_DWORD *)this + 15884),
            (char *)a3 + 72,
            1,
            *((_DWORD *)a3 + 82));
          v4 = a2;
          *((_DWORD *)a3 + 82) = 0;
        }
        v18 = *((_DWORD *)a3 + 17) - 8;
        *((_DWORD *)a3 + 16) >>= 8;
        *((_DWORD *)a3 + 17) = v18;
      }
      while ( v18 >= 8 );
    }
    v19 = *((_DWORD *)a3 + 10);
    *((_DWORD *)a3 + 6) = *((_DWORD *)a3 + 7);
    v20 = *((_DWORD *)a3 + 12);
    *((_DWORD *)a3 + 9) = v19;
    *((_DWORD *)a3 + 11) = v20;
    *((_DWORD *)a3 + 8) = 0;
    *((_DWORD *)a3 + 4) = 0;
    *((_DWORD *)a3 + 5) = 1;
    CxImageGIF::rle_flush_fromclear(this, v4, a3);
  }
}

//----- (00462A70) --------------------------------------------------------
void __thiscall CxImageGIF::rle_write_block(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  (*(void (__thiscall **)(_DWORD, _BYTE))(**((_DWORD **)this + 15884) + 40))(
    *((_DWORD *)this + 15884),
    *((_BYTE *)a2 + 328));
  (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
    *((_DWORD *)this + 15884),
    (char *)a2 + 72,
    1,
    *((_DWORD *)a2 + 82));
  *((_DWORD *)a2 + 82) = 0;
}

//----- (00462AC0) --------------------------------------------------------
void __thiscall CxImageGIF::rle_block_out(CxImageGIF *this, char a2, struct CxImageGIF::tag_RLE *a3)
{
  int v4; // eax

  *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = a2;
  v4 = *((_DWORD *)a3 + 82) + 1;
  *((_DWORD *)a3 + 82) = v4;
  if ( v4 >= 255 )
  {
    (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v4);
    (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
      *((_DWORD *)this + 15884),
      (char *)a3 + 72,
      1,
      *((_DWORD *)a3 + 82));
    *((_DWORD *)a3 + 82) = 0;
  }
}

//----- (00462B20) --------------------------------------------------------
void __thiscall CxImageGIF::rle_block_flush(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  if ( *((int *)a2 + 82) > 0 )
  {
    (*(void (__thiscall **)(_DWORD, _BYTE))(**((_DWORD **)this + 15884) + 40))(
      *((_DWORD *)this + 15884),
      *((_BYTE *)a2 + 328));
    (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
      *((_DWORD *)this + 15884),
      (char *)a2 + 72,
      1,
      *((_DWORD *)a2 + 82));
    *((_DWORD *)a2 + 82) = 0;
  }
}

//----- (00462B70) --------------------------------------------------------
void __thiscall CxImageGIF::rle_output(CxImageGIF *this, int a2, struct CxImageGIF::tag_RLE *a3)
{
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  unsigned int v7; // edx
  int v8; // eax

  v4 = *((_DWORD *)a3 + 17);
  *((_DWORD *)a3 + 16) |= a2 << v4;
  v5 = *((_DWORD *)a3 + 6) + v4;
  *((_DWORD *)a3 + 17) = v5;
  if ( v5 >= 8 )
  {
    do
    {
      *((_BYTE *)a3 + *((_DWORD *)a3 + 82) + 72) = *((_BYTE *)a3 + 64);
      v6 = *((_DWORD *)a3 + 82) + 1;
      *((_DWORD *)a3 + 82) = v6;
      if ( v6 >= 255 )
      {
        (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v6);
        (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
          *((_DWORD *)this + 15884),
          (char *)a3 + 72,
          1,
          *((_DWORD *)a3 + 82));
        *((_DWORD *)a3 + 82) = 0;
      }
      v7 = *((_DWORD *)a3 + 16);
      v8 = *((_DWORD *)a3 + 17) - 8;
      *((_DWORD *)a3 + 17) = v8;
      *((_DWORD *)a3 + 16) = v7 >> 8;
    }
    while ( v8 >= 8 );
  }
}

//----- (00462C10) --------------------------------------------------------
void __thiscall CxImageGIF::rle_output_flush(CxImageGIF *this, struct CxImageGIF::tag_RLE *a2)
{
  int v3; // eax

  if ( *((int *)a2 + 17) > 0 )
  {
    *((_BYTE *)a2 + *((_DWORD *)a2 + 82) + 72) = *((_BYTE *)a2 + 64);
    v3 = *((_DWORD *)a2 + 82) + 1;
    *((_DWORD *)a2 + 82) = v3;
    if ( v3 >= 255 )
    {
      (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v3);
      (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
        *((_DWORD *)this + 15884),
        (char *)a2 + 72,
        1,
        *((_DWORD *)a2 + 82));
      *((_DWORD *)a2 + 82) = 0;
    }
  }
  if ( *((int *)a2 + 82) > 0 )
  {
    (*(void (__thiscall **)(_DWORD, _DWORD))(**((_DWORD **)this + 15884) + 40))(
      *((_DWORD *)this + 15884),
      *((_DWORD *)a2 + 82));
    (*(void (__thiscall **)(_DWORD, char *, int, _DWORD))(**((_DWORD **)this + 15884) + 12))(
      *((_DWORD *)this + 15884),
      (char *)a2 + 72,
      1,
      *((_DWORD *)a2 + 82));
    *((_DWORD *)a2 + 82) = 0;
  }
}

//----- (00462CB0) --------------------------------------------------------
void __thiscall CxImageGIF::compressRLE(CxImageGIF *this, int a2, struct CxFile *a3)
{
  int v4; // edx
  int v5; // ebp
  unsigned int v6; // edi
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  bool v10; // cc
  int v11; // edx
  int v12; // eax
  int v13; // edi
  unsigned __int8 v14; // al
  int v15; // edx
  int v16; // ecx
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // [esp-8h] [ebp-164h]
  int v22; // [esp-4h] [ebp-160h]
  int v23[2]; // [esp+10h] [ebp-14Ch] BYREF
  int v24; // [esp+18h] [ebp-144h]
  int v25; // [esp+1Ch] [ebp-140h]
  int v26; // [esp+20h] [ebp-13Ch]
  int v27; // [esp+24h] [ebp-138h]
  int v28; // [esp+28h] [ebp-134h]
  int v29; // [esp+2Ch] [ebp-130h]
  int v30; // [esp+30h] [ebp-12Ch]
  int v31; // [esp+34h] [ebp-128h]
  int v32; // [esp+38h] [ebp-124h]
  int v33; // [esp+3Ch] [ebp-120h]
  int v34; // [esp+40h] [ebp-11Ch]
  int v35; // [esp+44h] [ebp-118h]
  int v36; // [esp+48h] [ebp-114h]
  int v37; // [esp+4Ch] [ebp-110h]
  unsigned int v38; // [esp+50h] [ebp-10Ch]
  int v39; // [esp+54h] [ebp-108h]
  char v40[256]; // [esp+58h] [ebp-104h] BYREF
  int v41; // [esp+158h] [ebp-4h]

  *((_DWORD *)this + 15884) = a3;
  v4 = 1 << (a2 - 1);
  *((_DWORD *)this + 15883) = a2;
  v5 = 9;
  v6 = v4;
  v7 = v4 - 1;
  v36 = v4;
  v32 = v4 - 1;
  v37 = v4 + 1;
  v23[1] = v4 + 2;
  if ( a2 > 3 )
    v5 = v4 - 2;
  v34 = v5;
  v33 = v5;
  v35 = 4093 - v4;
  v8 = 0;
  v9 = 0;
  v29 = a2;
  v24 = 0;
  v28 = a2;
  v31 = v7;
  v30 = 0;
  v26 = 0;
  v27 = 1;
  v41 = 0;
  v38 = v6;
  v39 = a2;
  if ( a2 >= 8 )
  {
    do
    {
      v40[v9] = v38;
      v9 = ++v41;
      if ( v41 >= 255 )
      {
        (*(void (__thiscall **)(_DWORD, int))(**((_DWORD **)this + 15884) + 40))(*((_DWORD *)this + 15884), v9);
        (*(void (__thiscall **)(_DWORD, char *, int, int))(**((_DWORD **)this + 15884) + 12))(
          *((_DWORD *)this + 15884),
          v40,
          1,
          v41);
        v9 = 0;
        v41 = 0;
      }
      v10 = v39 - 8 < 8;
      v38 >>= 8;
      v39 -= 8;
    }
    while ( !v10 );
    v8 = v24;
  }
  v11 = v23[0];
  while ( 1 )
  {
    v12 = *((_DWORD *)this + 103);
    if ( v12 )
    {
      v22 = *((_DWORD *)this + 102);
      v21 = *((_DWORD *)this + 101);
      *((_DWORD *)this + 103) = v12 - 1;
      v14 = CxImage::GetPixelIndex(this, v21, v22);
      v15 = *((_DWORD *)this + 3);
      v16 = *((_DWORD *)this + 101) + 1;
      *((_DWORD *)this + 101) = v16;
      if ( v16 == v15 )
      {
        v17 = *((_DWORD *)this + 102);
        *((_DWORD *)this + 101) = 0;
        *((_DWORD *)this + 102) = v17 - 1;
      }
      v11 = v23[0];
      v8 = v24;
      v13 = v14;
    }
    else
    {
      v13 = -1;
    }
    if ( v8 > 0 && v13 != v11 )
    {
      if ( v8 == 1 )
      {
        v27 = 0;
        CxImageGIF::rle_output(this, v11, (struct CxImageGIF::tag_RLE *)v23);
        v18 = ++v30;
        if ( v30 >= v31 )
          v31 += 1 << v28++;
        if ( v18 >= v33 )
        {
          CxImageGIF::rle_output(this, v36, (struct CxImageGIF::tag_RLE *)v23);
          CxImageGIF::rle_clear(this, (struct CxImageGIF::tag_RLE *)v23);
        }
      }
      else if ( v27 )
      {
        CxImageGIF::rle_flush_fromclear(this, v8, (struct CxImageGIF::tag_RLE *)v23);
      }
      else if ( v26 >= 2 && v25 == v11 )
      {
        CxImageGIF::rle_flush_withtable(this, v8, (struct CxImageGIF::tag_RLE *)v23);
      }
      else
      {
        CxImageGIF::rle_flush_clearorrep(this, v8, (struct CxImageGIF::tag_RLE *)v23);
      }
      v11 = v23[0];
      v8 = 0;
      v24 = 0;
    }
    if ( v13 == -1 )
      break;
    if ( v11 == v13 )
    {
      v24 = ++v8;
    }
    else
    {
      v11 = v13;
      v8 = 1;
      v23[0] = v13;
      v24 = 1;
    }
  }
  v19 = v37 << v39;
  v20 = v28 + v39;
  v39 = v20;
  v38 |= v19;
  if ( v20 >= 8 )
  {
    do
    {
      v40[v41++] = v38;
      if ( v41 >= 255 )
        CxImageGIF::rle_write_block(this, (struct CxImageGIF::tag_RLE *)v23);
      v20 = v39 - 8;
      v10 = v39 - 8 < 8;
      v38 >>= 8;
      v39 -= 8;
    }
    while ( !v10 );
  }
  if ( v20 > 0 )
  {
    v40[v41++] = v38;
    if ( v41 >= 255 )
      CxImageGIF::rle_write_block(this, (struct CxImageGIF::tag_RLE *)v23);
  }
  CxImageGIF::rle_block_flush(this, (struct CxImageGIF::tag_RLE *)v23);
}

//----- (00462FD0) --------------------------------------------------------
char __thiscall sub_462FD0(CxImage *this, int a2)
{
  int v2; // ebx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  unsigned __int16 v7; // dx
  char v8; // cl
  unsigned int v9; // eax
  unsigned int v10; // edi
  bool v11; // cc
  signed int v12; // esi
  int v13; // ecx
  int v14; // edi
  _BYTE *v15; // eax
  int v16; // esi
  int v17; // eax
  char v18; // dl
  char v19; // cl
  int i; // edi
  CxImage *v21; // edi
  unsigned int j; // esi
  int v23; // eax
  int v24; // ecx
  _BYTE *v25; // edi
  char *v26; // eax
  int v27; // ebx
  unsigned __int8 *v28; // esi
  int k; // edi
  unsigned __int16 v30; // dx
  int l; // esi
  int v33; // [esp+0h] [ebp-3DCh] BYREF
  char v34; // [esp+Ch] [ebp-3D0h] BYREF
  char v35; // [esp+Dh] [ebp-3CFh] BYREF
  char v36[766]; // [esp+Eh] [ebp-3CEh] BYREF
  char v37[3]; // [esp+30Ch] [ebp-D0h] BYREF
  char v38; // [esp+30Fh] [ebp-CDh]
  unsigned __int16 v39; // [esp+310h] [ebp-CCh]
  int v40; // [esp+312h] [ebp-CAh]
  int v41; // [esp+316h] [ebp-C6h]
  int v42[12]; // [esp+31Ah] [ebp-C2h]
  char v43; // [esp+34Dh] [ebp-8Fh]
  char *v44; // [esp+34Eh] [ebp-8Eh]
  char *pExceptionObject; // [esp+390h] [ebp-4Ch] BYREF
  char *v46; // [esp+394h] [ebp-48h] BYREF
  char *v47; // [esp+398h] [ebp-44h] BYREF
  char *v48; // [esp+39Ch] [ebp-40h] BYREF
  char *v49; // [esp+3A0h] [ebp-3Ch] BYREF
  char *v50; // [esp+3A4h] [ebp-38h] BYREF
  char *v51; // [esp+3A8h] [ebp-34h] BYREF
  char *v52; // [esp+3ACh] [ebp-30h] BYREF
  char *v53; // [esp+3B0h] [ebp-2Ch] BYREF
  int v54; // [esp+3B4h] [ebp-28h]
  int v55; // [esp+3B8h] [ebp-24h]
  _BYTE *v56; // [esp+3BCh] [ebp-20h]
  unsigned int v57; // [esp+3C0h] [ebp-1Ch]
  CxImage *v58; // [esp+3C4h] [ebp-18h]
  int v59; // [esp+3C8h] [ebp-14h]
  int *v60; // [esp+3CCh] [ebp-10h]
  int v61; // [esp+3D8h] [ebp-4h]

  v2 = a2;
  v60 = &v33;
  v58 = this;
  if ( !a2 )
    return 0;
  v4 = *(_DWORD *)a2;
  v57 = 0;
  v56 = 0;
  v61 = 0;
  if ( !(*(int (__thiscall **)(int, char *, int, int))(v4 + 8))(a2, v37, 128, 1) )
  {
    pExceptionObject = aCanTReadPcxIma;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  if ( v37[0] != 10 )
  {
    v51 = aErrorNotAPcxFi;
    _CxxThrowException(&v51, &PA.deinit);
  }
  if ( v37[2] != 1 )
  {
    v53 = aPcxFileHasUnkn;
    _CxxThrowException(&v53, &PA.deinit);
  }
  v5 = (unsigned __int16)v41 - (unsigned __int16)v40;
  v6 = HIWORD(v40) - v39;
  v7 = HIWORD(v41);
  *((_DWORD *)this + 89) = LOWORD(v42[0]);
  v8 = v43;
  v9 = v6 + 1;
  v10 = v5 + 1;
  v11 = v43 <= 4;
  v55 = v9;
  v54 = v10;
  *((_DWORD *)this + 88) = v7;
  if ( !v11 )
  {
    v49 = aCanTHandleImag;
    _CxxThrowException(&v49, &PA.deinit);
  }
  if ( v8 >= 3 && v38 == 8 )
  {
    CxImage::Create(this, v9, v10, 24, 5);
  }
  else if ( v8 == 4 && v38 == 1 )
  {
    CxImage::Create(this, v9, v10, 4, 5);
  }
  else
  {
    CxImage::Create(this, v9, v10, v38, 5);
  }
  if ( *((_DWORD *)this + 81) )
  {
    v46 = aCancelled;
    _CxxThrowException(&v46, &PA.deinit);
  }
  v12 = v10 * v43 * (unsigned __int16)v44;
  v59 = sub_46D9FD(v12);
  v57 = v59;
  while ( v12 > 0 )
  {
    if ( !v2 || (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v2 + 32))(v2) )
    {
      v52 = aCorruptedPcx;
      _CxxThrowException(&v52, &PA.deinit);
    }
    (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, (char *)&a2 + 3, 1, 1);
    if ( (HIBYTE(a2) & 0xC0) == 0xC0 )
    {
      v14 = HIBYTE(a2) & 0x3F;
      (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, (char *)&a2 + 3, 1, 1);
      if ( v14 > v12 )
      {
        v47 = aRepeatCountSpa;
        _CxxThrowException(&v47, &PA.deinit);
      }
      v15 = (_BYTE *)v59;
      v12 -= v14;
      while ( --v14 >= 0 )
      {
        *v15++ = HIBYTE(a2);
        v59 = (int)v15;
      }
    }
    else
    {
      v13 = v59;
      *(_BYTE *)v59 = HIBYTE(a2);
      v59 = v13 + 1;
      --v12;
    }
  }
  v16 = 0;
  while ( v16 < 16 )
  {
    v17 = 3 * v16++;
    v18 = *((_BYTE *)v42 + v17 + 3);
    *(&v34 + v17) = *((_BYTE *)v42 + v17 + 2);
    v19 = *((_BYTE *)&v42[1] + v17);
    *(&v35 + v17) = v18;
    v36[v17] = v19;
  }
  if ( v38 != 8 )
    goto LABEL_41;
  if ( v43 == 1 )
  {
    (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, (char *)&a2 + 3, 1, 1);
    if ( HIBYTE(a2) != 12 )
    {
      v50 = aBadColorMapSig;
      _CxxThrowException(&v50, &PA.deinit);
    }
    for ( i = 0; i < 256; ++i )
    {
      (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, &v34 + 3 * i, 1, 1);
      (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, &v35 + 3 * i, 1, 1);
      (*(void (__thiscall **)(int, char *, int, int))(*(_DWORD *)v2 + 8))(v2, &v36[3 * i], 1, 1);
    }
LABEL_41:
    if ( v38 == 1 && v43 == 1 )
    {
      v36[0] = 0;
      v35 = 0;
      v34 = 0;
      v36[3] = -1;
      v36[2] = -1;
      v36[1] = -1;
    }
  }
  v21 = v58;
  for ( j = 0; j < *((_DWORD *)v21 + 10); ++j )
    CxImage::SetPaletteIndex(v21, j, *(&v34 + 3 * j), *(&v35 + 3 * j), v36[3 * j], 0);
  v23 = sub_46D9FD(v55 + 8 * (unsigned __int16)v44);
  LOBYTE(v24) = v43;
  v25 = (_BYTE *)v23;
  v26 = v44;
  v56 = v25;
  v59 = 0;
  while ( v59 < v54 )
  {
    if ( *((_DWORD *)v58 + 81) )
    {
      v48 = aCancelled;
      _CxxThrowException(&v48, &PA.deinit);
    }
    v27 = v54 - v59 - 1;
    v28 = (unsigned __int8 *)(v57 + v59 * (char)v24 * (unsigned __int16)v26);
    if ( (_BYTE)v24 == 3 )
    {
      if ( v38 != 8 )
        goto LABEL_58;
      for ( k = 0; k < v55; ++k )
      {
        HIBYTE(v30) = v28[2 * (unsigned __int16)v26 + k];
        LOBYTE(v30) = v28[k + (unsigned __int16)v26];
        CxImage::SetPixelColor(v58, k, v27, (struct tagRGBQUAD)(v28[k] | (v30 << 8)));
        v26 = v44;
        LOBYTE(v24) = v43;
      }
      v25 = v56;
      ++v59;
    }
    else
    {
      if ( (_BYTE)v24 != 1 )
      {
LABEL_58:
        LOWORD(v24) = (char)v24;
        sub_463AB0(v25, v28, v26, v24, v38);
        goto LABEL_59;
      }
      sub_463B80(v25, v28, (__int16)v26, (char *)1, v38);
LABEL_59:
      for ( l = 0; l < v55; ++l )
        CxImage::SetPixelIndex(v58, l, v27, v25[l]);
      v26 = v44;
      LOBYTE(v24) = v43;
      ++v59;
    }
  }
  if ( v57 )
    sub_46D360(v57);
  if ( v25 )
    sub_46D360((unsigned int)v25);
  return 1;
}
// 46343C: variable 'v24' is possibly undefined

//----- (00463510) --------------------------------------------------------
char __thiscall sub_463510(CxImage *this, int a2)
{
  __int16 v3; // dx
  __int16 v4; // cx
  unsigned __int16 v5; // ax
  __int16 v6; // cx
  int v7; // ecx
  int v8; // eax
  bool v9; // zf
  int v10; // ecx
  int v11; // edx
  int i; // edi
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // ebx
  int v17; // eax
  int v18; // edi
  struct tagRGBQUAD v19; // eax
  struct tagRGBQUAD v20; // eax
  struct tagRGBQUAD v21; // eax
  int v22; // ebx
  int j; // edi
  unsigned __int8 v24; // al
  int v25; // edi
  int v26; // eax
  int v27; // ebx
  int v28; // edi
  __int16 v29; // cx
  _BYTE *v30; // eax
  struct tagRGBQUAD *v31; // eax
  int v32; // ebx
  int v33; // eax
  int k; // edi
  int l; // eax
  int v36; // ecx
  char *v37; // eax
  int v38; // edi
  int v39; // edx
  int m; // ecx
  int v41; // esi
  int v42; // eax
  int v44; // [esp+0h] [ebp-DCh] BYREF
  _WORD v45[64]; // [esp+10h] [ebp-CCh] BYREF
  int pExceptionObject[2]; // [esp+90h] [ebp-4Ch] BYREF
  int v47; // [esp+98h] [ebp-44h]
  char *v48; // [esp+9Ch] [ebp-40h]
  int v49; // [esp+A0h] [ebp-3Ch] BYREF
  void **v50; // [esp+A4h] [ebp-38h] BYREF
  int v51; // [esp+A8h] [ebp-34h]
  int v52; // [esp+ACh] [ebp-30h]
  char v53; // [esp+B0h] [ebp-2Ch]
  int v54; // [esp+B4h] [ebp-28h]
  int v55; // [esp+B8h] [ebp-24h]
  unsigned __int8 v56[4]; // [esp+BCh] [ebp-20h] BYREF
  int v57; // [esp+C0h] [ebp-1Ch] BYREF
  int n; // [esp+C4h] [ebp-18h]
  bool v59; // [esp+C9h] [ebp-13h]
  char v60; // [esp+CAh] [ebp-12h] BYREF
  unsigned __int8 v61; // [esp+CBh] [ebp-11h] BYREF
  int *v62; // [esp+CCh] [ebp-10h]
  int v63; // [esp+D8h] [ebp-4h]

  v62 = &v44;
  pExceptionObject[1] = (int)this;
  if ( !a2 )
    return 0;
  v3 = *((_WORD *)this + 6);
  memset(v45, 0, sizeof(v45));
  v4 = *((_WORD *)this + 8) - 1;
  v45[4] = v3 - 1;
  v5 = *((_WORD *)this + 176);
  v45[5] = v4;
  v6 = *((_WORD *)this + 178);
  v45[6] = v5;
  v45[7] = v6;
  v7 = *((_DWORD *)this + 10);
  v45[34] = v7 == 0;
  v8 = v5;
  LOWORD(v8) = *((_WORD *)this + 11);
  v63 = 0;
  v45[0] = 1290;
  LOBYTE(v45[1]) = 1;
  v45[2] = 0;
  v45[3] = 0;
  LOBYTE(v45[32]) = 0;
  if ( (unsigned __int16)v8 == 8 || v8 == 24 )
  {
    HIBYTE(v45[1]) = 8;
    v45[33] = v3;
    HIBYTE(v45[32]) = v7 != 0 ? 1 : 3;
  }
  else
  {
    v9 = v7 == 16;
    v10 = *((_DWORD *)this + 3) + 7;
    HIBYTE(v45[1]) = 1;
    HIBYTE(v45[32]) = !v9 ? 1 : 4;
    v45[33] = v10 >> 3;
    if ( (!v9 ? 0 : 3) != 0 )
    {
      if ( (!v9 ? 0 : 3) == 3 )
      {
        for ( i = 0; i < 16; ++i )
        {
          v13 = **(_DWORD **)&CxImage::GetPaletteColor(this, v56, i);
          v14 = 3 * i;
          v57 = v13;
          *((_BYTE *)&v45[8] + v14) = BYTE2(v13);
          *((_BYTE *)&v45[8] + v14 + 1) = BYTE1(v13);
          *((_BYTE *)&v45[9] + v14) = v13;
        }
      }
    }
    else
    {
      v45[9] = -256;
      v45[8] = 0;
      v45[10] = -1;
    }
  }
  v11 = *(_DWORD *)a2;
  v45[33] = (v45[33] + 1) & 0xFFFE;
  if ( !(*(int (__thiscall **)(int, _WORD *, int, int))(v11 + 12))(a2, v45, 128, 1) )
  {
    pExceptionObject[0] = (int)aCannotWritePcx;
    _CxxThrowException(pExceptionObject, &PA.deinit);
  }
  v50 = &CxMemFile::`vftable';
  v51 = 0;
  v53 = 1;
  LOBYTE(v63) = 1;
  v55 = 0;
  v52 = 0;
  v54 = 0;
  v51 = sub_46D9FD(0);
  v15 = *((_DWORD *)this + 10);
  v53 = 1;
  if ( v15 )
  {
    if ( *((_WORD *)this + 11) == 8 )
    {
      v22 = *((_DWORD *)this + 4);
      while ( --v22 >= 0 )
      {
        v60 = 0;
        v61 = 0;
        for ( j = 0; j < *((_DWORD *)this + 3); ++j )
        {
          v24 = CxImage::GetPixelIndex(this, j, v22);
          sub_463CF0(v24, &v61, &v60, (int)&v50);
        }
        sub_463CF0(-1 - (*((_DWORD *)this + 3) & 1), &v61, &v60, (int)&v50);
      }
      v25 = v51;
      v53 = 0;
      v26 = CxMemFile::Size((CxMemFile *)&v50);
      (*(void (__thiscall **)(int, int, int, int))(*(_DWORD *)a2 + 12))(a2, v25, v26, 1);
      if ( *((_WORD *)this + 11) == 8 )
      {
        (*(void (__thiscall **)(int, int))(*(_DWORD *)a2 + 40))(a2, 12);
        v27 = sub_46D9FD(0x300u);
        v28 = 0;
        while ( v28 < 256 )
        {
          v57 = **(_DWORD **)&CxImage::GetPaletteColor(this, v56, v28);
          v29 = v57;
          v30 = (_BYTE *)(v28 + v27 + 2 * v28);
          ++v28;
          *v30 = BYTE2(v57);
          v30[1] = HIBYTE(v29);
          v30[2] = v29;
        }
        (*(void (__thiscall **)(int, int, int, int))(*(_DWORD *)a2 + 12))(a2, v27, 768, 1);
        sub_46D360(v27);
      }
      goto LABEL_64;
    }
    v31 = CxImage::GetPalette(this);
    v59 = 0;
    if ( CxImage::CompareColors(v31, &v31[1]) > 0 )
      v59 = *((_WORD *)this + 11) == 1;
    v48 = (char *)sub_46D9FD(v45[33]);
    v32 = sub_46D9FD(*((_DWORD *)this + 3));
    v33 = *((_DWORD *)this + 4) - 1;
    v57 = v32;
    n = v33;
    while ( v33 >= 0 )
    {
      for ( k = 0; k < *((_DWORD *)this + 3); ++k )
        *(_BYTE *)(v32 + k) = CxImage::GetPixelIndex(this, k, n);
      if ( v59 )
      {
        for ( l = 0; l < *((_DWORD *)this + 3); ++l )
          *(_BYTE *)(v32 + l) = 1 - *(_BYTE *)(v32 + l);
      }
      v36 = 0;
      v49 = 0;
      while ( v36 < SHIBYTE(v45[32]) )
      {
        *(_DWORD *)v56 = *((_DWORD *)this + 3);
        v37 = v48 - 1;
        v38 = -1;
        v39 = 1 << v36;
        for ( m = 0; ; ++m )
        {
          v47 = m;
          if ( m >= *(int *)v56 )
            break;
          if ( v38 < 0 )
          {
            ++v37;
            v38 = 7;
            *v37 = 0;
          }
          if ( ((unsigned __int8)v39 & *(_BYTE *)(m + v57)) != 0 )
          {
            *v37 |= 1 << v38;
            m = v47;
          }
          --v38;
        }
        sub_463D80(v48, v45[33], (int)&v50);
        v32 = v57;
        v36 = ++v49;
      }
      v33 = --n;
    }
    sub_46D360((unsigned int)v48);
    sub_46D360(v32);
  }
  else
  {
    v16 = *((_DWORD *)this + 4);
    while ( --v16 >= 0 )
    {
      for ( n = 0; ; ++n )
      {
        v17 = n;
        if ( n >= SHIBYTE(v45[32]) )
          break;
        v60 = 0;
        v61 = 0;
        v18 = 0;
        while ( v18 < *((_DWORD *)this + 3) )
        {
          if ( v17 )
          {
            if ( v17 == 1 )
            {
              v20 = CxImage::GetPixelColor(this, (int)&v57, v18, v16);
              sub_463CF0(*(unsigned __int8 *)(*(_DWORD *)&v20 + 1), &v61, &v60, (int)&v50);
              v17 = n;
              ++v18;
            }
            else
            {
              if ( v17 == 2 )
              {
                v21 = CxImage::GetPixelColor(this, (int)&v49, v18, v16);
                sub_463CF0(*(unsigned __int8 *)v21.rgbBlue, &v61, &v60, (int)&v50);
              }
              v17 = n;
              ++v18;
            }
          }
          else
          {
            v19 = CxImage::GetPixelColor(this, (int)v56, v18, v16);
            sub_463CF0(*(unsigned __int8 *)(*(_DWORD *)&v19 + 2), &v61, &v60, (int)&v50);
            v17 = n;
            ++v18;
          }
        }
        sub_463CF0(-1 - (*((_DWORD *)this + 3) & 1), &v61, &v60, (int)&v50);
      }
    }
  }
  v41 = v51;
  v53 = 0;
  v42 = CxMemFile::Size((CxMemFile *)&v50);
  (*(void (__thiscall **)(int, int, int, int))(*(_DWORD *)a2 + 12))(a2, v41, v42, 1);
LABEL_64:
  v53 = 0;
  sub_46D360(v51);
  v50 = &CxMemFile::`vftable';
  if ( v51 && v53 )
    sub_46D360(v51);
  return 1;
}
// 4A8424: using guessed type void *CxMemFile::`vftable';

//----- (00463AB0) --------------------------------------------------------
int __stdcall sub_463AB0(void *a1, unsigned __int8 *a2, char *pExceptionObject, int i, __int16 a5)
{
  __int16 v5; // dx
  int result; // eax
  int v7; // esi
  int v8; // ebp
  _BYTE *v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // esi

  v5 = i;
  if ( (__int16)i > 4 )
  {
    pExceptionObject = aCanTHandleMore;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  if ( a5 != 1 )
  {
    pExceptionObject = aCanTHandleMore_0;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  result = 8 * (__int16)pExceptionObject - 1;
  if ( result >= 0 )
  {
    result = 0;
    memset(a1, 0, 8 * (__int16)pExceptionObject);
  }
  v7 = v5;
  v8 = 0;
  for ( i = v5; v8 < v7; ++v8 )
  {
    result = (__int16)pExceptionObject;
    v10 = a1;
    if ( (__int16)pExceptionObject > 0 )
    {
      v11 = (__int16)pExceptionObject;
      do
      {
        v12 = *a2++;
        v13 = v12;
        result = 128;
        do
        {
          if ( (result & v13) != 0 )
            *v10 |= 1 << v8;
          result >>= 1;
          ++v10;
        }
        while ( result );
        --v11;
      }
      while ( v11 );
      v7 = i;
    }
  }
  return result;
}

//----- (00463B80) --------------------------------------------------------
char __stdcall sub_463B80(_BYTE *a1, _BYTE *a2, __int16 a3, char *pExceptionObject, __int16 a5)
{
  int v5; // eax
  _BYTE *v6; // ecx
  int v7; // esi
  int v8; // esi
  unsigned __int8 *v9; // esi
  _BYTE *v10; // ecx
  int v11; // edi
  int v12; // edx
  _BYTE *v13; // ecx
  unsigned __int8 *v14; // esi
  _BYTE *v15; // ecx
  int v16; // edi
  _BYTE *v17; // ecx
  char v18; // dl
  char *v19; // esi
  int v20; // edi
  int v21; // edi
  char v22; // cl
  bool *v23; // eax

  if ( (_WORD)pExceptionObject != 1 )
  {
    pExceptionObject = aCanTHandlePack;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  LOBYTE(v5) = a5;
  switch ( a5 )
  {
    case 8:
      LOWORD(v5) = a3 - 1;
      if ( a3 > 0 )
      {
        v6 = a2;
        v7 = (__int16)v5;
        v5 = (int)a1;
        v8 = v7 + 1;
        do
        {
          *(_BYTE *)v5++ = *v6++;
          --v8;
        }
        while ( v8 );
      }
      break;
    case 4:
      LOWORD(v5) = a3 - 1;
      if ( a3 > 0 )
      {
        v9 = a2;
        v10 = a1;
        v11 = (__int16)v5 + 1;
        do
        {
          v5 = *v9++;
          v12 = v5;
          LOBYTE(v5) = v5 & 0xF;
          *v10 = (v12 >> 4) & 0xF;
          v13 = v10 + 1;
          *v13 = v5;
          v10 = v13 + 1;
          --v11;
        }
        while ( v11 );
      }
      break;
    case 2:
      LOWORD(v5) = a3 - 1;
      if ( a3 > 0 )
      {
        v14 = a2;
        v15 = a1;
        v16 = (__int16)v5 + 1;
        do
        {
          v5 = *v14++;
          *v15 = (v5 >> 6) & 3;
          v17 = v15 + 1;
          *v17++ = (v5 >> 4) & 3;
          v18 = (v5 >> 2) & 3;
          LOBYTE(v5) = v5 & 3;
          *v17++ = v18;
          *v17 = v5;
          v15 = v17 + 1;
          --v16;
        }
        while ( v16 );
      }
      break;
    case 1:
      LOWORD(v5) = a3 - 1;
      if ( a3 > 0 )
      {
        v19 = a2;
        v20 = (__int16)v5;
        v5 = (int)a1;
        v21 = v20 + 1;
        do
        {
          v22 = *v19++;
          *(_BYTE *)v5 = (v22 & 0x80) != 0;
          v23 = (bool *)(v5 + 1);
          *v23++ = (v22 & 0x40) != 0;
          *v23++ = (v22 & 0x20) != 0;
          *v23++ = (v22 & 0x10) != 0;
          *v23++ = (v22 & 8) != 0;
          *v23++ = (v22 & 4) != 0;
          *v23++ = (v22 & 2) != 0;
          *v23 = v22 & 1;
          v5 = (int)(v23 + 1);
          --v21;
        }
        while ( v21 );
      }
      break;
  }
  return v5;
}

//----- (00463CF0) --------------------------------------------------------
char __stdcall sub_463CF0(int a1, unsigned __int8 *a2, _BYTE *a3, int a4)
{
  unsigned __int8 v4; // cl
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  char result; // al

  v4 = *a2;
  v5 = *a2;
  if ( a1 != v5 )
  {
    LOBYTE(v5) = *a3;
    if ( *a3 )
    {
      if ( (_BYTE)v5 == 1 && v4 < 0xC0u )
      {
        (*(void (__thiscall **)(int, unsigned __int8))(*(_DWORD *)a4 + 40))(a4, v4);
      }
      else
      {
        LOBYTE(v5) = v5 | 0xC0;
        (*(void (__thiscall **)(int, int))(*(_DWORD *)a4 + 40))(a4, v5);
        LOBYTE(v6) = *a2;
        (*(void (__thiscall **)(int, int))(*(_DWORD *)a4 + 40))(a4, v6);
      }
      *a3 = 0;
    }
  }
  if ( *a3 == 63 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)a4 + 40))(a4, 255);
    LOBYTE(v7) = *a2;
    (*(void (__thiscall **)(int, int))(*(_DWORD *)a4 + 40))(a4, v7);
    *a3 = 0;
  }
  if ( a1 == -2 )
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)a4 + 40))(a4, 0);
  *a2 = a1;
  result = *a3 + 1;
  *a3 = result;
  return result;
}
// 463D3D: variable 'v6' is possibly undefined
// 463D5C: variable 'v7' is possibly undefined

//----- (00463D80) --------------------------------------------------------
int __stdcall sub_463D80(char *a1, int a2, int a3)
{
  char *v3; // ebp
  char v4; // cl
  char *v5; // edi
  int v6; // eax
  char v7; // bl

  v6 = (int)a1;
  v3 = &a1[a2];
  v4 = *a1;
  v5 = a1 + 1;
  LOBYTE(a1) = *a1;
  LOBYTE(v6) = 1;
  if ( v5 < v3 )
  {
    do
    {
      v7 = *v5++;
      if ( v7 == v4 && (unsigned __int8)v6 < 0x3Fu )
      {
        LOBYTE(v6) = v6 + 1;
      }
      else
      {
        if ( (unsigned __int8)v6 > 1u || (v4 & 0xC0) == 0xC0 )
        {
          LOBYTE(v6) = v6 | 0xC0;
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a3 + 40))(a3, v6);
        }
        v6 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a3 + 40))(a3, a1);
        v4 = v7;
        LOBYTE(v6) = 1;
        LOBYTE(a1) = v7;
      }
    }
    while ( v5 < v3 );
    if ( (unsigned __int8)v6 > 1u )
      goto LABEL_12;
  }
  if ( (v4 & 0xC0) == 0xC0 )
  {
LABEL_12:
    LOBYTE(v6) = v6 | 0xC0;
    (*(void (__thiscall **)(int, int))(*(_DWORD *)a3 + 40))(a3, v6);
  }
  return (*(int (__thiscall **)(int, char *))(*(_DWORD *)a3 + 40))(a3, a1);
}

//----- (00463F70) --------------------------------------------------------
char __userpurge sub_463F70@<al>(CxImage *a1@<ecx>, char a2@<bl>, int a3@<esi>, int a4)
{
  int *v4; // eax
  CxImage *v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  unsigned int v8; // ecx
  bool v9; // zf
  _DWORD *v10; // ebx
  struct tagRGBQUAD *v11; // edi
  unsigned int i; // edx
  unsigned int v13; // ecx
  char v14; // al
  unsigned __int8 *v15; // ebx
  int v16; // edi
  int v17; // esi
  unsigned __int8 *v18; // eax
  int k; // edi
  unsigned __int8 *v20; // esi
  int v21; // eax
  unsigned __int8 v22; // bl
  char v23; // dl
  signed int v24; // ecx
  int v25; // edx
  int v27; // [esp+0h] [ebp-74h] BYREF
  int v28; // [esp+Ch] [ebp-68h]
  int v29; // [esp+10h] [ebp-64h]
  int v30; // [esp+14h] [ebp-60h]
  int v31; // [esp+18h] [ebp-5Ch]
  unsigned __int8 *v32; // [esp+1Ch] [ebp-58h]
  CxImage *v33; // [esp+20h] [ebp-54h]
  int v34; // [esp+24h] [ebp-50h] BYREF
  __int16 v35; // [esp+28h] [ebp-4Ch]
  __int16 v36; // [esp+2Ah] [ebp-4Ah]
  __int16 v37; // [esp+2Ch] [ebp-48h]
  void *v38; // [esp+34h] [ebp-40h] BYREF
  char *v39; // [esp+38h] [ebp-3Ch] BYREF
  char *pExceptionObject; // [esp+3Ch] [ebp-38h] BYREF
  int v41; // [esp+40h] [ebp-34h]
  unsigned __int8 *v42; // [esp+44h] [ebp-30h]
  int v43; // [esp+48h] [ebp-2Ch]
  int v44; // [esp+4Ch] [ebp-28h]
  int v45; // [esp+50h] [ebp-24h] BYREF
  int j; // [esp+54h] [ebp-20h]
  CxImage *v47; // [esp+58h] [ebp-1Ch]
  _DWORD *v48; // [esp+5Ch] [ebp-18h] BYREF
  int *__attribute__((__org_typedef(jmp_buf))) Buf[2]; // [esp+60h] [ebp-14h] BYREF
  int v50; // [esp+70h] [ebp-4h]
  int savedregs; // [esp+74h] [ebp+0h] BYREF

  Buf[1] = &v27;
  v47 = a1;
  v42 = 0;
  v33 = a1;
  if ( a1 )
    v32 = CxImage::GetBits(a1);
  v29 = 0;
  v28 = 0;
  v31 = 0;
  v30 = 0;
  v50 = 0;
  LOBYTE(v4) = png_create_write_struct(a2, 0, (int)a125, 0, 0, 0);
  Buf[0] = v4;
  if ( !v4 )
  {
    pExceptionObject = aFailedToCreate;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  v48 = sub_484630(v4);
  if ( !v48 )
  {
    sub_47DB30((unsigned int *)Buf, 0, 0);
    v39 = aFailedToInitia;
    _CxxThrowException(&v39, &PA.deinit);
  }
  if ( _setjmp3(
         a2,
         (int)&savedregs,
         0,
         a3,
         Buf[0],
         3,
         (struct _EXCEPTION_REGISTRATION_RECORD *)__CxxLongjmpUnwind,
         v50,
         &stru_4B3C68) )
  {
    if ( v42 )
      sub_40B7E0((unsigned int)v42);
    sub_47DB30((unsigned int *)Buf, (unsigned int *)&v48, 0);
    v38 = &unk_4A7DB0;
    _CxxThrowException(&v38, &PA.deinit);
  }
  sub_4843F0(Buf[0], a4, (int)sub_464570);
  v5 = v47;
  sub_484330(Buf[0], (int)v47 + 64, (int)sub_4645A0, 0);
  sub_47CEB0((int)Buf[0], v48);
  LOBYTE(v34) = 0;
  HIWORD(v34) = 192;
  v35 = 192;
  v36 = 192;
  v6 = v48;
  v37 = 0;
  if ( *((_BYTE *)v48 + 30) == 32
    || (!sub_483790((int)Buf[0], (int)v48, &v45) ? sub_47E630((int)Buf[0], (int)&v34, 1, 0, 1.0) : sub_47E630(
                                                                                                     (int)Buf[0],
                                                                                                     v45,
                                                                                                     2,
                                                                                                     1,
                                                                                                     1.0),
        v6 = v48,
        *((_BYTE *)v48 + 30) == 32) )
  {
    if ( sub_483790((int)Buf[0], (int)v6, &v45) )
    {
      v7 = v45;
      *((_BYTE *)v5 + 334) = *(_BYTE *)(v45 + 2);
      *((_BYTE *)v5 + 333) = *(_BYTE *)(v7 + 4);
      *((_BYTE *)v5 + 332) = *(_BYTE *)(v7 + 6);
      *((_BYTE *)v5 + 335) = 0;
    }
    v6 = v48;
  }
  if ( *((_BYTE *)v6 + 24) == 16 )
  {
    sub_47E6E0((int)Buf[0]);
    v6 = v48;
  }
  v8 = *((unsigned __int8 *)v6 + 30);
  v9 = v8 == 16;
  if ( v8 > 0x10 )
  {
    v8 = 24;
    v9 = 0;
  }
  if ( v9 )
    v8 = 8;
  CxImage::Create(v5, *v6, v6[1], v8, 4);
  if ( *((_WORD *)v48 + 10) )
  {
    CxImage::SetPalette(v5, (struct rgb_color *)v48[4], *((unsigned __int16 *)v48 + 10));
  }
  else if ( *((_BYTE *)v48 + 24) == 2 )
  {
    CxImage::SetPaletteIndex(v5, 0, 0, 0, 0, 0);
    CxImage::SetPaletteIndex(v5, 1u, 85, 85, 85, 0);
    CxImage::SetPaletteIndex(v5, 2u, 170, 170, 170, 0);
    CxImage::SetPaletteIndex(v5, 3u, 255, 255, 255, 0);
  }
  else
  {
    CxImage::SetGrayPalette(v5);
  }
  v10 = v48;
  if ( *((_WORD *)v48 + 11) )
  {
    v11 = CxImage::GetPalette(v5);
    if ( v11 )
    {
      for ( i = 0; ; v11[i - 1].rgbReserved = *(_BYTE *)(v48[19] + i - 1) )
      {
        v10 = v48;
        v13 = *((unsigned __int16 *)v48 + 11);
        if ( *((_DWORD *)v5 + 10) < (unsigned int)(unsigned __int16)v13 )
          v13 = *((_DWORD *)v5 + 10);
        if ( i >= v13 )
          break;
        ++i;
      }
      if ( *((_WORD *)v48 + 11) != 1 || v11->rgbReserved )
      {
        *((_BYTE *)v5 + 377) = 1;
        while ( i < *((_DWORD *)v5 + 10) )
        {
          v11[i].rgbReserved = -1;
          v10 = v48;
          ++i;
        }
      }
      else
      {
        *((_DWORD *)v5 + 82) = 0;
      }
    }
    else
    {
      v10 = v48;
    }
  }
  v14 = *((_BYTE *)v10 + 25);
  if ( v14 == 6 || v14 == 4 && *((_BYTE *)v10 + 30) == 32 )
  {
    if ( v14 == 4 )
    {
      sub_47F010((int)Buf[0]);
      sub_47EFD0((int)Buf[0]);
    }
    sub_47E6F0((int)Buf[0]);
    v10 = v48;
  }
  if ( (*((_BYTE *)v10 + 25) & 2) != 0 )
  {
    sub_47E000((int)Buf[0]);
    v10 = v48;
  }
  if ( *((_DWORD *)v5 + 81) )
    longjmp(Buf[0], 1);
  v15 = (unsigned __int8 *)sub_40B720((int)&savedregs, *v10 * ((*((unsigned __int8 *)v10 + 30) + 7) >> 3) + 10);
  v42 = v15;
  if ( *((_BYTE *)v48 + 28) )
    v44 = sub_47E0A0((int)Buf[0]);
  else
    v44 = 1;
  for ( j = 0; j < v44; ++j )
  {
    v28 = 0;
    v16 = *((_DWORD *)v33 + 4);
    v17 = *((_DWORD *)v33 + 12);
    v29 = v16 - 1;
    v18 = CxImage::GetBits(v33);
    v41 = 0;
    v32 = &v18[v17 * (v16 - 1)];
    do
    {
      if ( *((_DWORD *)v47 + 81) )
        longjmp(Buf[0], 1);
      if ( *((_BYTE *)v48 + 28) && j > 0 && v15 && *((int *)v47 + 12) > 0 )
        qmemcpy(v15, v32, *((_DWORD *)v47 + 12));
      sub_47D2E0((int)v15, (int)Buf[0], (char *)v15, 0);
      if ( *((_BYTE *)v48 + 24) == 2 && j == v44 - 1 )
      {
        for ( k = *((_DWORD *)v47 + 3) - 1; k >= 0; --k )
        {
          v20 = &v15[(4 * k) >> 3];
          LOBYTE(v43) = 6 - 2 * (k & 3);
          v21 = ((3 << v43) & v15[(2 * k) >> 3]) >> v43;
          v22 = *v20;
          LOBYTE(v43) = 4 - 4 * (k & 1);
          v23 = v22 & ~(15 << v43);
          v15 = v42;
          *v20 = ((v21 & 0xF) << v43) | v23;
        }
      }
      v24 = *((_DWORD *)v47 + 12);
      if ( v24 >= 0 )
      {
        if ( v24 >= *((_DWORD *)v33 + 12) )
          v24 = *((_DWORD *)v33 + 12);
      }
      else
      {
        v24 = *((_DWORD *)v33 + 12);
      }
      if ( v32 )
        qmemcpy(v32, v15, v24);
      if ( --v29 >= 0 )
        v32 -= *((_DWORD *)v33 + 12);
      v25 = *((_DWORD *)v47 + 4);
      ++v41;
    }
    while ( v41 < v25 );
  }
  sub_40B7E0((unsigned int)v15);
  sub_47D860((int)Buf[0], v48);
  sub_47DB30((unsigned int *)Buf, (unsigned int *)&v48, 0);
  return 1;
}
// 4643E8: conditional instruction was optimized away because of 'edi.4>=0'
// 464421: conditional instruction was optimized away because of 'edi.4>=0'
// 463FC9: variable 'v4' is possibly undefined
// 46CEB3: using guessed type int __stdcall __CxxLongjmpUnwind(int);
// 4B3C68: using guessed type FuncInfoV1 stru_4B3C68;

//----- (00464570) --------------------------------------------------------
int __cdecl sub_464570(int a1, int a2, int a3)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(a1 + 84) + 8))(*(_DWORD *)(a1 + 84), a2, 1, a3);
  if ( result != a3 )
    sub_484040((int *)a1, aReadError);
  return result;
}

//----- (004645A0) --------------------------------------------------------
void __userpurge __noreturn sub_4645A0(jmp_buf Buf, char *Source)
{
  strncpy((char *)Buf[18], Source, 0xFFu);
  longjmp(Buf, 1);
}

//----- (004645D0) --------------------------------------------------------
char __userpurge sub_4645D0@<al>(CxImage *a1@<ecx>, char a2@<bl>, int a3@<edi>, int a4)
{
  int *v4; // eax
  CxImage *v5; // ebx
  int v6; // eax
  char v7; // al
  unsigned __int16 v8; // di
  int v9; // eax
  int v10; // eax
  int v11; // esi
  struct tagRGBQUAD v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // esi
  unsigned __int8 *v16; // edi
  int v17; // esi
  int v18; // edx
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // esi
  int v21; // eax
  int v23; // [esp+0h] [ebp-15Ch] BYREF
  char v24[256]; // [esp+Ch] [ebp-150h] BYREF
  int v25; // [esp+110h] [ebp-4Ch]
  char *v26; // [esp+114h] [ebp-48h] BYREF
  char *pExceptionObject; // [esp+118h] [ebp-44h] BYREF
  char *v28; // [esp+11Ch] [ebp-40h] BYREF
  int v29; // [esp+120h] [ebp-3Ch]
  int v30; // [esp+124h] [ebp-38h]
  int v31; // [esp+128h] [ebp-34h]
  int v32; // [esp+12Ch] [ebp-30h]
  unsigned __int8 *v33; // [esp+130h] [ebp-2Ch]
  CxImage *v34; // [esp+134h] [ebp-28h]
  CxImage *v35; // [esp+138h] [ebp-24h]
  unsigned __int8 v36[4]; // [esp+13Ch] [ebp-20h] BYREF
  int v37; // [esp+140h] [ebp-1Ch]
  int *v38; // [esp+144h] [ebp-18h] BYREF
  int v39[2]; // [esp+148h] [ebp-14h] BYREF
  int v40; // [esp+158h] [ebp-4h]
  int savedregs; // [esp+15Ch] [ebp+0h] BYREF

  v39[1] = (int)&v23;
  v35 = a1;
  if ( !a4 )
    return 0;
  v34 = a1;
  if ( a1 )
    v33 = CxImage::GetBits(a1);
  v30 = 0;
  v29 = 0;
  v32 = 0;
  v31 = 0;
  v40 = 0;
  LOBYTE(v4) = sub_4853C0(a2, a3, (int)a125, 0, 0, 0);
  v38 = v4;
  if ( !v4 )
  {
    pExceptionObject = aFailedToCreate;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  v39[0] = (int)sub_484630(v4);
  if ( !v39[0] )
  {
    sub_485B50((int)&v38, 0, v23);
    v28 = aFailedToInitia;
    _CxxThrowException(&v28, &PA.deinit);
  }
  if ( _setjmp3(
         a2,
         (int)&savedregs,
         a3,
         0,
         v38,
         3,
         (struct _EXCEPTION_REGISTRATION_RECORD *)__CxxLongjmpUnwind,
         v40,
         &stru_4B3CC0) )
  {
    if ( *(_DWORD *)(v39[0] + 16) )
      sub_46D360(*(_DWORD *)(v39[0] + 16));
    sub_485B50((int)&v38, (int)v39, v23);
    v26 = aErrorSavingPng;
    _CxxThrowException(&v26, &PA.deinit);
  }
  v5 = v35;
  v37 = *((_DWORD *)v35 + 12);
  sub_487B80(v38, a4, (int)sub_4649E0, (int)sub_464A10);
  *(_DWORD *)v39[0] = *((_DWORD *)v5 + 3);
  *(_DWORD *)(v39[0] + 4) = *((_DWORD *)v5 + 4);
  *(_BYTE *)(v39[0] + 30) = *((_WORD *)v5 + 11);
  *(_BYTE *)(v39[0] + 29) = *((_WORD *)v5 + 11) > 8u ? 3 : 1;
  v6 = *((unsigned __int16 *)v5 + 11) / (int)*(unsigned __int8 *)(v39[0] + 29);
  *(_BYTE *)(v39[0] + 24) = v6;
  v7 = CxImage::GetColorType(v5, v6);
  v8 = 0;
  *(_BYTE *)(v39[0] + 25) = v7;
  *(_BYTE *)(v39[0] + 28) = 0;
  *(_BYTE *)(v39[0] + 27) = 0;
  *(_BYTE *)(v39[0] + 26) = 0;
  *(_DWORD *)(v39[0] + 8) = 0;
  v9 = v37;
  *(_BYTE *)(v39[0] + 28) = 0;
  *(_DWORD *)(v39[0] + 12) = v9;
  if ( CxImage::GetPalette(v5) )
  {
    sub_486A30(
      v38,
      v39[0],
      *(_DWORD *)v39[0],
      *(_DWORD *)(v39[0] + 4),
      *(unsigned __int8 *)(v39[0] + 24),
      3,
      *(unsigned __int8 *)(v39[0] + 28),
      0,
      0);
    *(_DWORD *)(v39[0] + 8) |= 8u;
    if ( *((_DWORD *)v5 + 82) != -1 )
    {
      v24[0] = 0;
      *(_WORD *)(v39[0] + 22) = 1;
      *(_DWORD *)(v39[0] + 8) |= 0x10u;
      *(_DWORD *)(v39[0] + 76) = v24;
      if ( *((_DWORD *)v5 + 82) )
      {
        CxImage::SwapIndex(v5, 0, *((_DWORD *)v5 + 82));
        v10 = *((_DWORD *)v5 + 14);
        if ( v10 )
          *(_DWORD *)(v10 + 328) = 0;
      }
    }
    if ( *((_BYTE *)v5 + 377) )
    {
      while ( 1 )
      {
        v11 = v8;
        if ( (unsigned int)v8 >= *((_DWORD *)v5 + 10) )
          break;
        v12 = CxImage::GetPaletteColor(v5, v36, v8++);
        v24[v11] = *(_BYTE *)(*(_DWORD *)&v12 + 3);
      }
      *(_WORD *)(v39[0] + 22) = *((_WORD *)v5 + 20);
      *(_DWORD *)(v39[0] + 8) |= 0x10u;
      *(_DWORD *)(v39[0] + 76) = v24;
    }
    v13 = *((_DWORD *)v5 + 10);
    v14 = sub_40B720((int)&savedregs, 3 * v13);
    v15 = 0;
    *(_DWORD *)(v39[0] + 16) = v14;
    *(_WORD *)(v39[0] + 20) = v13;
    while ( v15 < v13 )
    {
      CxImage::GetRGB(
        v5,
        v15,
        (unsigned __int8 *)(*(_DWORD *)(v39[0] + 16) + 3 * v15),
        (unsigned __int8 *)(*(_DWORD *)(v39[0] + 16) + 3 * v15 + 1),
        (unsigned __int8 *)(*(_DWORD *)(v39[0] + 16) + 3 * v15 + 2));
      ++v15;
    }
  }
  sub_484F20(v38, v39[0]);
  v16 = (unsigned __int8 *)sub_40B720((int)&savedregs, v37 + 10);
  *(_DWORD *)v36 = v16;
  v17 = *((_DWORD *)v34 + 4);
  v18 = *((_DWORD *)v34 + 12);
  v29 = 0;
  v25 = v18;
  v30 = v17 - 1;
  v19 = CxImage::GetBits(v34);
  v20 = &v19[v25 * (v17 - 1)];
  v33 = v20;
  do
  {
    if ( v16 && v37 > 0 )
    {
      qmemcpy(v16, v20, v37);
      v16 = *(unsigned __int8 **)v36;
      v20 = v33;
    }
    if ( *(_BYTE *)(v39[0] + 25) == 2 )
      CxImage::RGBtoBGR(v5, v16, v37);
    sub_4857F0((int)v38, v16);
    if ( --v30 >= 0 )
    {
      v20 -= *((_DWORD *)v34 + 12);
      v21 = 1;
      v33 = v20;
    }
    else
    {
      v21 = 0;
    }
  }
  while ( v21 );
  sub_40B7E0((unsigned int)v16);
  sub_485200((int)v38, v39[0]);
  if ( *(_DWORD *)(v39[0] + 16) )
    sub_40B7E0(*(_DWORD *)(v39[0] + 16));
  sub_485B50((int)&v38, (int)v39, v23);
  return 1;
}
// 464634: variable 'v4' is possibly undefined
// 46CEB3: using guessed type int __stdcall __CxxLongjmpUnwind(int);
// 4B3CC0: using guessed type FuncInfoV1 stru_4B3CC0;

//----- (004649E0) --------------------------------------------------------
int __cdecl sub_4649E0(int a1, int a2, int a3)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD, int, int, int))(**(_DWORD **)(a1 + 84) + 12))(*(_DWORD *)(a1 + 84), a2, 1, a3);
  if ( result != a3 )
    sub_484040((int *)a1, aWriteError);
  return result;
}

//----- (00464A10) --------------------------------------------------------
int __cdecl sub_464A10(int a1)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 84) + 28))(*(_DWORD *)(a1 + 84));
  if ( !(_BYTE)result )
    sub_484040((int *)a1, aFlushError);
  return result;
}

//----- (00464A40) --------------------------------------------------------
char __userpurge sub_464A40@<al>(CxImage *a1@<ecx>, int a2@<ebx>, int a3)
{
  int v4; // edi
  CxImage *v6; // ebx
  int v7; // edi
  const void **v8; // eax
  CxImage *v9; // esi
  int v10; // edx
  unsigned __int8 *v11; // eax
  int v12; // esi
  int v13; // ecx
  _BYTE *v14; // eax
  int v15; // edx
  char v16; // bl
  char v17; // di
  unsigned int v18; // ecx
  unsigned __int8 *v19; // esi
  int v20; // eax
  int v21; // edi
  unsigned __int8 *i; // ecx
  unsigned __int8 v23; // al
  int v24; // ecx
  void (__stdcall __noreturn *v25)(int *); // [esp+Ch] [ebp-2ECh] BYREF
  jmp_buf Buf; // [esp+90h] [ebp-268h] BYREF
  int v27; // [esp+D0h] [ebp-228h]
  int v28[9]; // [esp+D4h] [ebp-224h] BYREF
  int v29; // [esp+F8h] [ebp-200h]
  int v30; // [esp+FCh] [ebp-1FCh]
  char v31; // [esp+11Eh] [ebp-1DAh]
  int v32; // [esp+130h] [ebp-1C8h]
  unsigned int v33; // [esp+134h] [ebp-1C4h]
  unsigned int v34; // [esp+144h] [ebp-1B4h]
  unsigned __int8 **v35; // [esp+148h] [ebp-1B0h]
  unsigned int v36; // [esp+14Ch] [ebp-1ACh]
  char v37; // [esp+1D7h] [ebp-121h]
  int v38; // [esp+1D8h] [ebp-120h]
  char v39; // [esp+284h] [ebp-74h] BYREF
  _DWORD *(__cdecl *v40)(int); // [esp+28Ch] [ebp-6Ch]
  char (__cdecl *v41)(_DWORD *); // [esp+290h] [ebp-68h]
  int (__cdecl *v42)(_DWORD *); // [esp+294h] [ebp-64h]
  int v43[8]; // [esp+298h] [ebp-60h] BYREF
  int v44; // [esp+2B8h] [ebp-40h]
  int v45; // [esp+2C0h] [ebp-38h]
  char *v46; // [esp+2C4h] [ebp-34h]
  int v47; // [esp+2C8h] [ebp-30h]
  int v48; // [esp+2CCh] [ebp-2Ch]
  unsigned __int8 *v49; // [esp+2D0h] [ebp-28h]
  CxImage *v50; // [esp+2D4h] [ebp-24h]
  const void **v51; // [esp+2D8h] [ebp-20h]
  int v52; // [esp+2DCh] [ebp-1Ch]
  CxImage *v53; // [esp+2E0h] [ebp-18h]
  char *v54; // [esp+2E4h] [ebp-14h]
  int v55; // [esp+2E8h] [ebp-10h]
  int v56; // [esp+2F4h] [ebp-4h]
  int savedregs; // [esp+2F8h] [ebp+0h] BYREF

  v53 = a1;
  v50 = a1;
  if ( a1 )
    v49 = CxImage::GetBits(a1);
  v4 = (int)a1 + 64;
  v46 = 0;
  v45 = 0;
  v48 = 0;
  v47 = 0;
  v27 = v4;
  v28[0] = (int)jpeg_std_error((int (__cdecl **)(int))&v25);
  v25 = sub_465160;
  if ( _setjmp3(
         a2,
         (int)&savedregs,
         v4,
         0,
         Buf,
         3,
         (struct _EXCEPTION_REGISTRATION_RECORD *)__CxxLongjmpUnwind,
         v56,
         &stru_4B3D18) )
  {
    sub_48ECF0((int)v28);
    return 0;
  }
  sub_48EC10(v28, 62, 432);
  v43[7] = a3;
  v40 = sub_464F20;
  v41 = sub_464F40;
  v42 = sub_464F90;
  v43[2] = (int)sub_464FF0;
  v43[3] = (int)sub_465010;
  v43[4] = (int)sub_465090;
  v43[5] = (int)sub_48F560;
  v43[6] = (int)nullsub_10;
  v43[0] = 0;
  v43[1] = 0;
  v44 = sub_40B720((int)&savedregs, 0x1000u);
  v56 = 0;
  v28[6] = &v39 != 0 ? (unsigned int)v43 : 0;
  sub_48ED10(v28, 1);
  sub_48F140((int)v28);
  v6 = v53;
  CxImage::Create(v53, v28[7], v28[8], 8 * v29, 3);
  if ( v37 == 2 )
  {
    CxImage::SetXDPI(v6, 254 * (unsigned __int16)v38 / 100);
    CxImage::SetYDPI(v6, 254 * HIWORD(v38) / 100);
  }
  else
  {
    CxImage::SetXDPI(v6, (unsigned __int16)v38);
    CxImage::SetYDPI(v6, HIWORD(v38));
  }
  if ( v30 == 1 )
  {
    CxImage::SetGrayPalette(v6);
    *((_DWORD *)v6 + 10) = 256;
  }
  else if ( v31 == 1 )
  {
    CxImage::SetPalette(v6, v34, *v35, v35[1], v35[2]);
    *((_DWORD *)v6 + 10) = v34;
  }
  else
  {
    *((_DWORD *)v6 + 10) = 0;
  }
  v7 = v29 * v32;
  v55 = v29 * v32;
  v8 = (const void **)(*(int (__cdecl **)(int *, int, int, int))(v28[1] + 8))(v28, 1, v29 * v32, 1);
  v45 = 0;
  v9 = v50;
  v51 = v8;
  v10 = *((_DWORD *)v50 + 12);
  v54 = (char *)*((_DWORD *)v50 + 4);
  v46 = v54 - 1;
  v52 = v10;
  v11 = CxImage::GetBits(v50);
  v49 = &v11[v52 * (_DWORD)(v54 - 1)];
  while ( v36 < v33 )
  {
    if ( *((_DWORD *)v6 + 81) )
      longjmp(Buf, 1);
    sub_48F2F0(v28, (int)v51, 1);
    if ( v29 != 4 || v31 )
    {
      v18 = v7;
      if ( v7 >= 0 )
      {
        if ( v7 >= *((_DWORD *)v9 + 12) )
          v18 = *((_DWORD *)v9 + 12);
      }
      else
      {
        v18 = *((_DWORD *)v9 + 12);
      }
      if ( !v49 )
        goto LABEL_31;
      qmemcpy(v49, *v51, v18);
LABEL_29:
      v7 = v55;
    }
    else
    {
      v12 = 0;
      v13 = 0;
      v14 = *v51;
      v15 = *((_DWORD *)v6 + 12);
      v54 = (char *)*v51;
      if ( v15 > 0 )
      {
        while ( v13 < v7 )
        {
          v16 = v14[v13 + 2];
          LOBYTE(v52) = v14[v13 + 3];
          v17 = v52;
          v12 += 3;
          v13 += 4;
          v49[v12 - 3] = -(char)(v52 * v16);
          v49[v12 - 2] = -(char)(v17 * v54[v13 - 3]);
          v49[v12 - 1] = -(char)(v17 * v54[v13 - 4]);
          v6 = v53;
          if ( v12 >= *((_DWORD *)v53 + 12) )
            goto LABEL_29;
          v14 = v54;
          v7 = v55;
        }
      }
    }
    v9 = v50;
LABEL_31:
    if ( (int)--v46 >= 0 )
      v49 -= *((_DWORD *)v9 + 12);
  }
  sub_48F080((int)v28);
  if ( v29 == 3 && !v31 )
  {
    v19 = CxImage::GetBits(v6);
    v20 = *((_DWORD *)v6 + 4);
    v55 = 0;
    if ( v20 > 0 )
    {
      do
      {
        if ( *((_DWORD *)v6 + 81) )
          longjmp(Buf, 1);
        v21 = 0;
        for ( i = v19; v21 < *((_DWORD *)v6 + 3); ++v21 )
        {
          v23 = *i;
          *i = i[2];
          i[2] = v23;
          i += 3;
        }
        v24 = *((_DWORD *)v6 + 4);
        v19 += *((_DWORD *)v6 + 12);
        ++v55;
      }
      while ( v55 < v24 );
    }
  }
  sub_48ECF0((int)v28);
  v56 = -1;
  sub_40B7E0(v44);
  return 1;
}
// 465150: using guessed type int nullsub_10();
// 46CEB3: using guessed type int __stdcall __CxxLongjmpUnwind(int);
// 4B3D18: using guessed type FuncInfoV1 stru_4B3D18;

//----- (00464F20) --------------------------------------------------------
_DWORD *__cdecl sub_464F20(int a1)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = *(_DWORD **)(a1 + 24);
  v2 = result[13];
  result[1] = 4096;
  *result = v2;
  return result;
}

//----- (00464F40) --------------------------------------------------------
char __cdecl sub_464F40(_DWORD *a1)
{
  int v1; // esi
  int v2; // edx

  v1 = a1[6];
  if ( (*(int (__thiscall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(v1 + 48) + 12))(
         *(_DWORD *)(v1 + 48),
         *(_DWORD *)(v1 + 52),
         1,
         4096) != 4096 )
  {
    *(_DWORD *)(*a1 + 20) = 37;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v2 = *(_DWORD *)(v1 + 52);
  *(_DWORD *)(v1 + 4) = 4096;
  *(_DWORD *)v1 = v2;
  return 1;
}

//----- (00464F90) --------------------------------------------------------
int __cdecl sub_464F90(_DWORD *a1)
{
  int v1; // esi
  int result; // eax

  v1 = a1[6];
  if ( *(_DWORD *)(v1 + 4) != 4096
    && !(*(int (__thiscall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(v1 + 48) + 12))(
          *(_DWORD *)(v1 + 48),
          *(_DWORD *)(v1 + 52),
          1,
          4096 - *(_DWORD *)(v1 + 4)) )
  {
    *(_DWORD *)(*a1 + 20) = 37;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 48) + 28))(*(_DWORD *)(v1 + 48));
  result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 48) + 36))(*(_DWORD *)(v1 + 48));
  if ( result )
  {
    *(_DWORD *)(*a1 + 20) = 37;
    result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
  }
  return result;
}

//----- (00464FF0) --------------------------------------------------------
int __cdecl sub_464FF0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 24);
  if ( result )
  {
    *(_BYTE *)(result + 36) = 1;
  }
  else
  {
    result = 0;
    MEMORY[0x38] = 1;
  }
  return result;
}

//----- (00465010) --------------------------------------------------------
char __cdecl sub_465010(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // ecx

  v1 = a1[6];
  if ( v1 )
    v2 = v1 - 20;
  else
    v2 = 0;
  v3 = (*(int (__thiscall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(v2 + 48) + 8))(
         *(_DWORD *)(v2 + 48),
         *(_DWORD *)(v2 + 52),
         1,
         4096);
  if ( !v3 )
  {
    if ( *(_BYTE *)(v2 + 56) )
    {
      *(_DWORD *)(*a1 + 20) = 42;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    *(_DWORD *)(*a1 + 20) = 120;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    v3 = 2;
    **(_BYTE **)(v2 + 52) = -1;
    *(_BYTE *)(*(_DWORD *)(v2 + 52) + 1) = -39;
  }
  v4 = *(_DWORD *)(v2 + 52);
  *(_DWORD *)(v2 + 24) = v3;
  *(_DWORD *)(v2 + 20) = v4;
  *(_BYTE *)(v2 + 56) = 0;
  return 1;
}

//----- (00465090) --------------------------------------------------------
int __cdecl sub_465090(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // ecx

  result = a1[6];
  if ( result )
    v3 = result - 20;
  else
    v3 = 0;
  v4 = a2;
  if ( a2 > 0 )
  {
    v5 = *(_DWORD *)(v3 + 24);
    if ( a2 > v5 )
    {
      do
      {
        v4 -= v5;
        v6 = a1[6];
        if ( v6 )
          v7 = v6 - 20;
        else
          v7 = 0;
        v8 = (*(int (__thiscall **)(_DWORD, _DWORD, int, int))(**(_DWORD **)(v7 + 48) + 8))(
               *(_DWORD *)(v7 + 48),
               *(_DWORD *)(v7 + 52),
               1,
               4096);
        if ( !v8 )
        {
          if ( *(_BYTE *)(v7 + 56) )
          {
            *(_DWORD *)(*a1 + 20) = 42;
            (*(void (__cdecl **)(_DWORD *))*a1)(a1);
          }
          *(_DWORD *)(*a1 + 20) = 120;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
          v8 = 2;
          **(_BYTE **)(v7 + 52) = -1;
          *(_BYTE *)(*(_DWORD *)(v7 + 52) + 1) = -39;
        }
        v9 = *(_DWORD *)(v7 + 52);
        *(_DWORD *)(v7 + 24) = v8;
        *(_DWORD *)(v7 + 20) = v9;
        *(_BYTE *)(v7 + 56) = 0;
        v5 = *(_DWORD *)(v3 + 24);
      }
      while ( v4 > v5 );
    }
    result = *(_DWORD *)(v3 + 24) - v4;
    *(_DWORD *)(v3 + 20) += v4;
    *(_DWORD *)(v3 + 24) = result;
  }
  return result;
}

//----- (00465160) --------------------------------------------------------
void __stdcall __noreturn sub_465160(int *a1)
{
  int v1; // esi

  v1 = *a1;
  (*(void (__cdecl **)(int *, _DWORD))(*a1 + 12))(a1, *(_DWORD *)(*a1 + 196));
  longjmp((int *)(v1 + 132), 1);
}

//----- (00465190) --------------------------------------------------------
char __userpurge sub_465190@<al>(char *a1@<ecx>, int a2@<ebx>, int a3)
{
  unsigned int v4; // eax
  char *v5; // edi
  char *v6; // esi
  int v7; // ecx
  char result; // al
  const char *v9; // edi
  CxImage *v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // edi
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // esi
  void (__stdcall __noreturn *v17)(int *); // [esp+Ch] [ebp-2A4h] BYREF
  int v18[16]; // [esp+90h] [ebp-220h] BYREF
  const char *v19; // [esp+D0h] [ebp-1E0h]
  int v20[8]; // [esp+D4h] [ebp-1DCh] BYREF
  unsigned int v21; // [esp+F4h] [ebp-1BCh]
  int v22; // [esp+F8h] [ebp-1B8h]
  int v23; // [esp+FCh] [ebp-1B4h]
  char v24; // [esp+19Bh] [ebp-115h]
  __int16 v25; // [esp+19Ch] [ebp-114h]
  __int16 v26; // [esp+19Eh] [ebp-112h]
  unsigned int v27; // [esp+1A4h] [ebp-10Ch]
  char v28; // [esp+23Ch] [ebp-74h] BYREF
  _DWORD *(__cdecl *v29)(int); // [esp+244h] [ebp-6Ch]
  char (__cdecl *v30)(_DWORD *); // [esp+248h] [ebp-68h]
  int (__cdecl *v31)(_DWORD *); // [esp+24Ch] [ebp-64h]
  int v32; // [esp+250h] [ebp-60h]
  int v33; // [esp+254h] [ebp-5Ch]
  int (__cdecl *v34)(int); // [esp+258h] [ebp-58h]
  char (__cdecl *v35)(_DWORD *); // [esp+25Ch] [ebp-54h]
  int (__cdecl *v36)(_DWORD *, int); // [esp+260h] [ebp-50h]
  char (__cdecl *v37)(_DWORD *, int); // [esp+264h] [ebp-4Ch]
  int (*v38)(); // [esp+268h] [ebp-48h]
  int v39; // [esp+26Ch] [ebp-44h]
  int v40; // [esp+270h] [ebp-40h]
  int v41; // [esp+278h] [ebp-38h]
  int v42; // [esp+27Ch] [ebp-34h]
  int v43; // [esp+280h] [ebp-30h]
  int v44; // [esp+284h] [ebp-2Ch]
  unsigned __int8 *v45; // [esp+288h] [ebp-28h]
  CxImage *v46; // [esp+28Ch] [ebp-24h]
  int v47; // [esp+290h] [ebp-20h]
  int v48; // [esp+294h] [ebp-1Ch]
  int v49; // [esp+298h] [ebp-18h]
  CxImage *v50; // [esp+29Ch] [ebp-14h]
  void **v51; // [esp+2A0h] [ebp-10h]
  int v52; // [esp+2ACh] [ebp-4h]
  int savedregs; // [esp+2B0h] [ebp+0h] BYREF

  v50 = (CxImage *)a1;
  if ( !*((_DWORD *)a1 + 10) || CxImage::IsGrayScale((CxImage *)a1) )
  {
    v9 = a1 + 64;
    v19 = v9;
    v20[0] = (int)jpeg_std_error((int (__cdecl **)(int))&v17);
    v17 = sub_465160;
    if ( _setjmp3(
           a2,
           (int)&savedregs,
           (int)v9,
           0,
           v18,
           3,
           (struct _EXCEPTION_REGISTRATION_RECORD *)__CxxLongjmpUnwind,
           v52,
           &stru_4B3D40) )
    {
      strcpy((char *)v50 + 64, v19);
      sub_491610((int)v20);
      result = 0;
    }
    else
    {
      sub_491540(v20, 62, 360);
      v39 = a3;
      v29 = sub_464F20;
      v30 = sub_464F40;
      v31 = sub_464F90;
      v34 = sub_464FF0;
      v35 = sub_465010;
      v36 = sub_465090;
      v37 = sub_48F560;
      v38 = nullsub_10;
      v32 = 0;
      v33 = 0;
      v40 = sub_40B720((int)&savedregs, 0x1000u);
      v10 = v50;
      v20[6] = (int)&v28;
      v11 = *((_DWORD *)v50 + 3);
      v52 = 0;
      v20[7] = v11;
      v21 = *((_DWORD *)v50 + 4);
      if ( CxImage::IsGrayScale(v50) )
      {
        v22 = 1;
        v23 = 1;
      }
      else
      {
        v22 = 3;
        v23 = 2;
      }
      sub_491C80((int)v20);
      sub_491C60(v20, *((unsigned __int8 *)v10 + 336), 1);
      v25 = *((_DWORD *)v10 + 88);
      v12 = *((_DWORD *)v10 + 89);
      v24 = 1;
      v26 = v12;
      sub_4918E0(v20, 1);
      v49 = *((_DWORD *)v10 + 12);
      v13 = v49;
      v51 = (void **)(*(int (__cdecl **)(int *, int, int, int))(v20[1] + 8))(v20, 1, v49 + 8, 1);
      v46 = v10;
      if ( v10 )
        v45 = CxImage::GetBits(v10);
      v47 = *((_DWORD *)v10 + 4);
      v42 = v47 - 1;
      v14 = *((_DWORD *)v10 + 12);
      v44 = 0;
      v43 = 0;
      v41 = 0;
      v48 = v14;
      v15 = CxImage::GetBits(v10);
      v16 = &v15[v48 * (v47 - 1)];
      v45 = v16;
      while ( v27 < v21 )
      {
        if ( *v51 && v13 > 0 )
        {
          qmemcpy(*v51, v16, v13);
          v16 = v45;
          v13 = v49;
        }
        if ( !*((_DWORD *)v10 + 10) )
          CxImage::RGBtoBGR(v10, (unsigned __int8 *)*v51, v13);
        if ( --v42 >= 0 )
        {
          v16 -= *((_DWORD *)v10 + 12);
          v45 = v16;
        }
        sub_491960(v20, (int)v51, 1u);
      }
      sub_491680(v20);
      sub_491610((int)v20);
      v52 = -1;
      sub_40B7E0(v40);
      result = 1;
    }
  }
  else
  {
    v4 = strlen(aJpegCanSaveOnl) + 1;
    qmemcpy(a1 + 64, aJpegCanSaveOnl, 4 * (v4 >> 2));
    v6 = &aJpegCanSaveOnl[4 * (v4 >> 2)];
    v5 = &a1[4 * (v4 >> 2) + 64];
    v7 = v4 & 3;
    result = 0;
    qmemcpy(v5, v6, v7);
  }
  return result;
}
// 465150: using guessed type int nullsub_10();
// 46CEB3: using guessed type int __stdcall __CxxLongjmpUnwind(int);
// 4B3D40: using guessed type FuncInfoV1 stru_4B3D40;

//----- (004654D0) --------------------------------------------------------
char __thiscall sub_4654D0(CxImage *this, int a2)
{
  int v3; // eax
  int v4; // edx
  int v5; // edi
  int v6; // edx
  _DWORD *v7; // edi
  unsigned __int16 v8; // ax
  int v9; // eax
  __int64 v10; // rax
  double v11; // st7
  struct tagRGBQUAD *v12; // edi
  int v13; // eax
  unsigned __int16 v14; // cx
  int v15; // eax
  unsigned __int16 v16; // cx
  BYTE *v17; // ecx
  unsigned __int16 v18; // cx
  size_t v19; // edi
  int v20; // eax
  unsigned __int8 *v21; // ebx
  int v22; // edi
  unsigned __int8 *v23; // eax
  unsigned int v24; // ecx
  BOOL v25; // edi
  int v26; // edx
  int v27; // edi
  unsigned __int8 *v28; // eax
  int v29; // ecx
  int v30; // edi
  unsigned __int8 *v31; // edi
  int v32; // edi
  unsigned __int8 *v33; // eax
  unsigned int i; // eax
  int v35; // ecx
  unsigned __int8 v36; // cl
  int v37; // edi
  unsigned __int8 *v38; // eax
  _DWORD v40[5]; // [esp+8h] [ebp-98h] BYREF
  __int16 v41[4]; // [esp+1Ch] [ebp-84h] BYREF
  _BYTE v42[6]; // [esp+24h] [ebp-7Ch]
  unsigned __int16 v43[2]; // [esp+38h] [ebp-68h] BYREF
  unsigned __int16 v44[2]; // [esp+3Ch] [ebp-64h]
  unsigned __int16 v45[2]; // [esp+40h] [ebp-60h]
  CxImage *v46; // [esp+48h] [ebp-58h]
  int v47; // [esp+4Ch] [ebp-54h] BYREF
  int v48; // [esp+50h] [ebp-50h] BYREF
  char *v49; // [esp+54h] [ebp-4Ch] BYREF
  char *v50; // [esp+58h] [ebp-48h] BYREF
  char *v51; // [esp+5Ch] [ebp-44h] BYREF
  char *v52; // [esp+60h] [ebp-40h] BYREF
  char *v53; // [esp+64h] [ebp-3Ch] BYREF
  char *v54; // [esp+68h] [ebp-38h] BYREF
  char *v55; // [esp+6Ch] [ebp-34h] BYREF
  char *v56; // [esp+70h] [ebp-30h] BYREF
  char *pExceptionObject; // [esp+74h] [ebp-2Ch] BYREF
  int v58; // [esp+78h] [ebp-28h]
  BOOL v59; // [esp+7Ch] [ebp-24h]
  int v60; // [esp+80h] [ebp-20h] BYREF
  int v61; // [esp+84h] [ebp-1Ch]
  int v62; // [esp+88h] [ebp-18h]
  bool v63; // [esp+8Eh] [ebp-12h]
  bool v64; // [esp+8Fh] [ebp-11h] BYREF
  _DWORD *v65; // [esp+90h] [ebp-10h]
  int v66; // [esp+9Ch] [ebp-4h]

  v65 = v40;
  v46 = this;
  if ( !a2 )
    return 0;
  v3 = (*(int (__thiscall **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)a2 + 20))(a2, v40[0], v40[1], v40[2]);
  v4 = *(_DWORD *)a2;
  v5 = v3;
  v59 = v3;
  v66 = 0;
  if ( !(*(int (__thiscall **)(int, __int16 *, int, int))(v4 + 8))(a2, v41, 14, 1) )
  {
    pExceptionObject = aNotABmp;
    _CxxThrowException(&pExceptionObject, &PA.deinit);
  }
  if ( v41[0] != 19778 )
  {
    v6 = *(_DWORD *)a2;
    *(_DWORD *)&v42[2] = 0;
    (*(void (__thiscall **)(int, int, _DWORD))(v6 + 16))(a2, v5, 0);
  }
  v7 = (_DWORD *)((char *)this + 8);
  if ( !sub_465D50(a2, (int *)this + 2) )
  {
    v56 = aErrorReadingBm;
    _CxxThrowException(&v56, &PA.deinit);
  }
  v8 = *((_WORD *)this + 11);
  v60 = *((_DWORD *)this + 6);
  v61 = v8;
  v9 = *((_DWORD *)this + 4);
  v64 = *v7 != 40;
  *v7 = 40;
  v63 = v9 < 0;
  if ( v9 < 0 )
    *((_DWORD *)this + 4) = -v9;
  if ( !CxImage::Create(this, *((_DWORD *)this + 3), *((_DWORD *)this + 4), v61, 1) )
  {
    v55 = aCanTAllocateMe;
    _CxxThrowException(&v55, &PA.deinit);
  }
  v10 = (__int64)_ceil_default((double)*((int *)this + 8) * dbl_4AE678 + dbl_4AD770);
  v11 = (double)*((int *)this + 9);
  *((_DWORD *)this + 88) = v10;
  *((_DWORD *)this + 89) = (__int64)_ceil_default(v11 * dbl_4AE678 + dbl_4AD770);
  if ( *((_DWORD *)this + 81) )
  {
    v54 = aCancelled;
    _CxxThrowException(&v54, &PA.deinit);
  }
  v12 = CxImage::GetPalette(this);
  if ( v12 )
  {
    v13 = *((_DWORD *)this + 10);
    if ( v64 )
    {
      if ( !v13 )
      {
        v14 = *((_WORD *)this + 11);
        if ( v14 <= 8u )
          v13 = 1 << v14;
      }
      (*(void (__thiscall **)(int, struct tagRGBQUAD *, int, int))(*(_DWORD *)a2 + 8))(a2, v12, 3 * v13, 1);
      v15 = *((_DWORD *)this + 10);
      if ( !v15 )
      {
        v16 = *((_WORD *)this + 11);
        if ( v16 <= 8u )
          v15 = 1 << v16;
      }
      while ( --v15 >= 0 )
      {
        v17 = (BYTE *)v12 + 2 * v15 + v15;
        v12[v15].rgbRed = v17[2];
        v12[v15].rgbBlue = *v17;
        v12[v15].rgbGreen = v17[1];
        v12[v15].rgbReserved = 0;
      }
    }
    else
    {
      if ( !v13 )
      {
        v18 = *((_WORD *)this + 11);
        if ( v18 <= 8u )
          v13 = 1 << v18;
      }
      (*(void (__thiscall **)(int, struct tagRGBQUAD *, int, int))(*(_DWORD *)a2 + 8))(a2, v12, 4 * v13, 1);
    }
  }
  if ( *((_DWORD *)this + 81) )
  {
    v53 = aCancelled;
    _CxxThrowException(&v53, &PA.deinit);
  }
  switch ( v61 )
  {
    case 1:
    case 4:
    case 8:
      if ( *(_DWORD *)&v42[2] )
        (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v59 + *(_DWORD *)&v42[2], 0);
      switch ( v60 )
      {
        case 0:
          goto LABEL_118;
        case 1:
          LOBYTE(v60) = 0;
          v64 = 0;
          v62 = 0;
          v61 = 0;
          if ( this )
            v31 = CxImage::GetBits(this);
          else
            v31 = *(unsigned __int8 **)v42;
          v58 = 1;
          while ( v58 )
          {
            (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v60, 1, 1);
            if ( (_BYTE)v60 )
            {
              if ( v62 >= 0 && v62 <= *((_DWORD *)this + 4) )
              {
                v32 = *((_DWORD *)this + 12);
                v33 = CxImage::GetBits(this);
                v31 = &v33[v62 * v32];
              }
              (*(void (__thiscall **)(int, bool *, int, int))(*(_DWORD *)a2 + 8))(a2, &v64, 1, 1);
              for ( i = 0; i < (unsigned __int8)v60; ++i )
              {
                v35 = v61;
                v31[v61] = v64;
                v61 = v35 + 1;
              }
            }
            else
            {
              (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v60, 1, 1);
              v36 = v60;
              if ( (_BYTE)v60 )
              {
                if ( (unsigned __int8)v60 == 1 )
                {
                  v58 = 0;
                }
                else if ( (unsigned __int8)v60 == 2 )
                {
                  (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v47, 1, 1);
                  (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v48, 1, 1);
                  v61 += (unsigned __int8)v47;
                  v62 += (unsigned __int8)v48;
                }
                else
                {
                  if ( v62 >= 0 && v62 <= *((_DWORD *)this + 4) )
                  {
                    v37 = *((_DWORD *)this + 12);
                    v38 = CxImage::GetBits(this);
                    v36 = v60;
                    v31 = &v38[v62 * v37];
                  }
                  (*(void (__thiscall **)(int, unsigned __int8 *, _DWORD, int))(*(_DWORD *)a2 + 8))(
                    a2,
                    &v31[v61],
                    v36,
                    1);
                  if ( (v60 & 1) == 1 )
                    (*(void (__thiscall **)(int, bool *, int, int))(*(_DWORD *)a2 + 8))(a2, &v64, 1, 1);
                  v61 += (unsigned __int8)v60;
                }
              }
              else
              {
                v61 = 0;
                ++v62;
              }
            }
          }
          break;
        case 2:
          LOBYTE(v60) = 0;
          v64 = 0;
          v61 = 0;
          v62 = 0;
          v59 = 0;
          if ( this )
            *(_DWORD *)v44 = CxImage::GetBits(this);
          v58 = 1;
          while ( v58 )
          {
            (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v60, 1, 1);
            if ( (_BYTE)v60 )
            {
              if ( v61 >= 0 && v61 <= *((_DWORD *)this + 4) )
              {
                v22 = *((_DWORD *)this + 12);
                v23 = CxImage::GetBits(this);
                *(_DWORD *)v44 = &v23[v61 * v22];
              }
              (*(void (__thiscall **)(int, bool *, int, int))(*(_DWORD *)a2 + 8))(a2, &v64, 1, 1);
              v24 = 0;
              while ( v24 < (unsigned __int8)v60 )
              {
                v25 = v59;
                if ( v59 )
                {
                  if ( v62 + *(_DWORD *)v44 < (unsigned int)(*((_DWORD *)this + 7) + *((_DWORD *)this + 13)) )
                    *(_BYTE *)(v62 + *(_DWORD *)v44) |= v64 & 0xF;
                  ++v62;
                  v59 = !v25;
                  ++v24;
                }
                else
                {
                  if ( v62 + *(_DWORD *)v44 < (unsigned int)(*((_DWORD *)this + 7) + *((_DWORD *)this + 13)) )
                    *(_BYTE *)(v62 + *(_DWORD *)v44) = v64 & 0xF0;
                  v59 = 1;
                  ++v24;
                }
              }
            }
            else
            {
              (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v60, 1, 1);
              if ( (_BYTE)v60 )
              {
                if ( (unsigned __int8)v60 == 1 )
                {
                  v58 = 0;
                }
                else
                {
                  v26 = *(_DWORD *)a2;
                  if ( (unsigned __int8)v60 == 2 )
                  {
                    (*(void (__thiscall **)(int, int *, int, int))(v26 + 8))(a2, &v48, 1, 1);
                    (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)a2 + 8))(a2, &v47, 1, 1);
                    v62 += (unsigned __int8)v48 >> 1;
                    v61 += (unsigned __int8)v47;
                  }
                  else
                  {
                    (*(void (__thiscall **)(int, bool *, int, int))(v26 + 8))(a2, &v64, 1, 1);
                    if ( v61 >= 0 && v61 <= *((_DWORD *)this + 4) )
                    {
                      v27 = *((_DWORD *)this + 12);
                      v28 = CxImage::GetBits(this);
                      *(_DWORD *)v44 = &v28[v61 * v27];
                    }
                    v29 = v59;
                    v30 = 0;
                    while ( v30 < (unsigned __int8)v60 )
                    {
                      if ( v29 )
                      {
                        if ( v62 + *(_DWORD *)v44 < (unsigned int)(*((_DWORD *)this + 7) + *((_DWORD *)this + 13)) )
                          *(_BYTE *)(v62 + *(_DWORD *)v44) |= v64 & 0xF;
                        if ( v30 != (unsigned __int8)v60 - 1 )
                          (*(void (__thiscall **)(int, bool *, int, int))(*(_DWORD *)a2 + 8))(a2, &v64, 1, 1);
                        ++v62;
                        v29 = !v59;
                        ++v30;
                        v59 = v29;
                      }
                      else
                      {
                        if ( *(_DWORD *)v44 + v62 < (unsigned int)(*((_DWORD *)this + 7) + *((_DWORD *)this + 13)) )
                          *(_BYTE *)(*(_DWORD *)v44 + v62) = v64 & 0xF0;
                        v29 = 1;
                        ++v30;
                        v59 = 1;
                      }
                    }
                    if ( (v60 & 2) == 2 )
                      (*(void (__thiscall **)(int, bool *, int, int))(*(_DWORD *)a2 + 8))(a2, &v64, 1, 1);
                  }
                }
              }
              else
              {
                v62 = 0;
                v59 = 0;
                ++v61;
              }
            }
          }
          break;
        default:
          v49 = aCompressionTyp;
          _CxxThrowException(&v49, &PA.deinit);
      }
      break;
    case 16:
      if ( v60 == 3 )
      {
        (*(void (__thiscall **)(int, unsigned __int16 *, int, int))(*(_DWORD *)a2 + 8))(a2, v43, 12, 1);
      }
      else
      {
        *(_DWORD *)v43 = 31744;
        *(_DWORD *)v44 = 992;
        *(_DWORD *)v45 = 31;
      }
      if ( *(_DWORD *)&v42[2] )
        (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v59 + *(_DWORD *)&v42[2], 0);
      (*(void (__thiscall **)(int, _DWORD, int, int))(*(_DWORD *)a2 + 8))(
        a2,
        *((_DWORD *)this + 13),
        4 * *((_DWORD *)this + 4) * ((*((_DWORD *)this + 3) + 1) / 2),
        1);
      CxImage::Bitfield2RGB(this, *((unsigned __int8 **)this + 13), v43[0], v44[0], v45[0], 0x10u);
      break;
    case 24:
      if ( *(_DWORD *)&v42[2] )
        (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v59 + *(_DWORD *)&v42[2], 0);
      if ( v60 )
      {
        v50 = aUnknownCompres;
        _CxxThrowException(&v50, &PA.deinit);
      }
LABEL_118:
      (*(void (__thiscall **)(int, _DWORD, _DWORD, int))(*(_DWORD *)a2 + 8))(
        a2,
        *((_DWORD *)this + 13),
        *((_DWORD *)this + 7),
        1);
      break;
    case 32:
      if ( *(_DWORD *)&v42[2] )
        (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)a2 + 16))(a2, v59 + *(_DWORD *)&v42[2], 0);
      if ( v60 != 3 && v60 )
      {
        v52 = aUnknownCompres;
        _CxxThrowException(&v52, &PA.deinit);
      }
      v19 = 4 * *((_DWORD *)this + 3) * *((_DWORD *)this + 4);
      v20 = sub_46D9FD(v19);
      v21 = (unsigned __int8 *)v20;
      if ( !v20 )
      {
        v51 = aCanTAllocateMe_0;
        _CxxThrowException(&v51, &PA.deinit);
      }
      (*(void (__thiscall **)(int, int, size_t, int))(*(_DWORD *)a2 + 8))(a2, v20, v19, 1);
      CxImage::Bitfield2RGB(this, v21, 0, 0, 0, 0x20u);
      sub_46D360((unsigned int)v21);
      break;
    default:
      break;
  }
  if ( v63 )
    CxImage::Flip(this);
  return 1;
}
// 4AD770: using guessed type double dbl_4AD770;
// 4AE678: using guessed type double dbl_4AE678;

//----- (00465D50) --------------------------------------------------------
char __stdcall sub_465D50(int a1, int *a2)
{
  int v2; // ebx
  int v4; // ecx
  int v5; // edx
  unsigned __int16 v6; // cx
  int v7; // [esp+10h] [ebp-8h]

  v2 = 0;
  if ( !a1 || !a2 || !(*(int (__thiscall **)(int, int *, int, int))(*(_DWORD *)a1 + 8))(a1, a2, 40, 1) )
    return 0;
  if ( *a2 == 12 )
  {
    a2[4] = 0;
    a2[5] = 0;
    a2[6] = 0;
    v4 = *a2;
    a2[7] = 0;
    a2[8] = 0;
    a2[9] = 0;
    v7 = a2[1];
    v5 = a2[2];
    a2[1] = (unsigned __int16)v7;
    *a2 = v4;
    *((_WORD *)a2 + 6) = v5;
    a2[2] = HIWORD(v7);
    *((_WORD *)a2 + 7) = HIWORD(v5);
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)a1 + 16))(a1, -28, 1);
  }
  else if ( *a2 != 40 )
  {
    return 0;
  }
  if ( !a2[5] )
    a2[5] = a2[2] * (((a2[1] * (unsigned int)*((unsigned __int16 *)a2 + 7) + 31) >> 3) & 0x1FFFFFFC);
  if ( !a2[8] )
  {
    v6 = *((_WORD *)a2 + 7);
    if ( v6 <= 8u )
      v2 = 1 << v6;
    a2[8] = v2;
  }
  return 1;
}

//----- (00465E30) --------------------------------------------------------
char __thiscall CxImage::GrayScale(CxImage *this)
{
  struct tagRGBQUAD *v3; // ebp
  unsigned int v4; // edi
  struct tagRGBQUAD *v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  unsigned int i; // eax
  int v10; // edx
  __int16 v11; // ax
  int v12; // ebx
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // ebp
  int j; // edi
  unsigned __int8 v16; // al
  char *v17; // ecx
  int v18; // ebx
  unsigned __int8 *v19; // eax
  int v20; // edx
  unsigned __int8 *v21; // edi
  int v22; // ecx
  char v23; // al
  bool v24; // cc
  int v25; // [esp+4h] [ebp-340h]
  int v26; // [esp+4h] [ebp-340h]
  struct tagRGBQUAD *v27; // [esp+8h] [ebp-33Ch]
  unsigned __int8 *v28; // [esp+8h] [ebp-33Ch]
  int v29; // [esp+Ch] [ebp-338h]
  int v30; // [esp+10h] [ebp-334h]
  int v31; // [esp+14h] [ebp-330h]
  char v32[48]; // [esp+18h] [ebp-32Ch] BYREF
  int v33; // [esp+48h] [ebp-2FCh]
  char v34[48]; // [esp+1A8h] [ebp-19Ch] BYREF
  int v35; // [esp+1D8h] [ebp-16Ch]
  int v36; // [esp+340h] [ebp-4h]

  if ( !*((_DWORD *)this + 1) )
    return 0;
  if ( *((_WORD *)this + 11) > 8u )
  {
    v18 = *((_DWORD *)this + 13);
    v29 = v18;
    CxImage::CxImage((CxImage *)v34, *((_DWORD *)this + 3), *((_DWORD *)this + 4), 8, *((_DWORD *)this + 15));
    v36 = 1;
    CxImage::SetGrayPalette((CxImage *)v34);
    v19 = CxImage::GetBits((CxImage *)v34);
    v20 = 3 * *((_DWORD *)this + 3);
    v26 = 0;
    v30 = v20;
    if ( *((int *)this + 4) > 0 )
    {
      v28 = v19;
      v31 = v35;
      do
      {
        if ( v20 > 0 )
        {
          v21 = v19;
          v22 = v18 + 2;
          do
          {
            v23 = *(_BYTE *)(v22 - 1);
            v22 += 3;
            *v21 = (char)(30 * *(_BYTE *)(v22 - 3) + 11 * *(_BYTE *)(v22 - 5) + 59 * v23) / 100;
            v20 = v30;
            ++v21;
          }
          while ( v22 + -2 - v18 < v30 );
          v18 = v29;
        }
        v18 += *((_DWORD *)this + 12);
        v19 = &v28[v31];
        v24 = v26 + 1 < *((_DWORD *)this + 4);
        v29 = v18;
        ++v26;
        v28 += v31;
      }
      while ( v24 );
    }
    CxImage::Transfer(this, (struct CxImage *)v34);
    v36 = -1;
    v17 = v34;
  }
  else
  {
    v3 = CxImage::GetPalette(this);
    v4 = 0;
    v27 = v3;
    if ( *((_DWORD *)this + 10) )
    {
      v5 = v3;
      do
      {
        v6 = v5->rgbGreen;
        ++v5;
        ++v4;
        v5[-1].rgbBlue = (11 * v5[-1].rgbBlue + 30 * v5[-1].rgbRed + 59 * v6) / 100;
      }
      while ( v4 < *((_DWORD *)this + 10) );
    }
    v7 = *((_DWORD *)this + 82);
    if ( v7 != -1 )
      *((_DWORD *)this + 82) = v3[v7].rgbBlue;
    if ( *((_WORD *)this + 11) == 8 )
    {
      v8 = *((_DWORD *)this + 13);
      for ( i = 0; i < *((_DWORD *)this + 7); *(_BYTE *)(i + v8 - 1) = v3[v10].rgbBlue )
      {
        v10 = *(unsigned __int8 *)(i + v8);
        ++i;
      }
      CxImage::SetGrayPalette(this);
    }
    v11 = *((_WORD *)this + 11);
    if ( v11 != 4 && v11 != 1 )
      return 1;
    CxImage::CxImage((CxImage *)v32, *((_DWORD *)this + 3), *((_DWORD *)this + 4), 8, *((_DWORD *)this + 15));
    v12 = 0;
    v36 = 0;
    CxImage::SetGrayPalette((CxImage *)v32);
    v13 = CxImage::GetBits((CxImage *)v32);
    if ( *((int *)this + 4) > 0 )
    {
      v14 = v13;
      v25 = v33;
      do
      {
        for ( j = 0; j < *((_DWORD *)this + 3); v14[j - 1] = v27[v16].rgbBlue )
          v16 = CxImage::GetPixelIndex(this, j++, v12);
        ++v12;
        v14 += v25;
      }
      while ( v12 < *((_DWORD *)this + 4) );
    }
    CxImage::Transfer(this, (struct CxImage *)v32);
    v36 = -1;
    v17 = v32;
  }
  CxImage::~CxImage((CxImage *)v17);
  return 1;
}

//----- (00466110) --------------------------------------------------------
char __thiscall CxImage::Flip(CxImage *this)
{
  CxImage *v3; // eax
  CxImage *v4; // esi
  unsigned int v5; // ecx
  int v6; // edi
  char *v7; // eax
  char *v8; // edx
  int v9; // [esp+Ch] [ebp-14h]

  if ( !*((_DWORD *)this + 1) )
    return 0;
  v3 = (CxImage *)sub_40B720(0, 0x190u);
  if ( v3 )
    v4 = CxImage::CxImage(v3, this, 0, 0, 1);
  else
    v4 = 0;
  if ( !v4 )
    return 0;
  v5 = *((_DWORD *)this + 12);
  v6 = *((_DWORD *)this + 4);
  v9 = 0;
  v7 = (char *)(*((_DWORD *)this + 13) + v5 * (v6 - 1));
  v8 = (char *)*((_DWORD *)v4 + 13);
  if ( v6 > 0 )
  {
    do
    {
      qmemcpy(v8, v7, v5);
      v5 = *((_DWORD *)this + 12);
      v7 -= v5;
      v8 += v5;
      ++v9;
    }
    while ( v9 < *((_DWORD *)this + 4) );
  }
  CxImage::Transfer(this, v4);
  (**(void (__thiscall ***)(CxImage *, int))v4)(v4, 1);
  return 1;
}

//----- (00466210) --------------------------------------------------------
char __thiscall CxImage::Mirror(CxImage *this)
{
  int v2; // ebx
  CxImage *v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // esi
  _BYTE *v8; // ecx
  int v9; // edi
  unsigned __int8 v10; // al
  _BYTE *v11; // ecx
  _BYTE *v12; // eax
  char v13; // bl
  int v14; // eax
  int v15; // eax
  _BYTE *v16; // edx
  int v17; // eax
  int v18; // [esp+8h] [ebp-18h]
  int j; // [esp+8h] [ebp-18h]
  int i; // [esp+8h] [ebp-18h]
  CxImage *v21; // [esp+Ch] [ebp-14h]
  _BYTE *v22; // [esp+10h] [ebp-10h]

  v2 = 0;
  if ( !*((_DWORD *)this + 1) )
    return 0;
  v4 = (CxImage *)sub_40B720((int)this, 0x190u);
  if ( v4 )
    v21 = CxImage::CxImage(v4, this, 0, 0, 1);
  else
    v21 = 0;
  if ( !v21 )
    return 0;
  v5 = *((_DWORD *)v21 + 13);
  v6 = *((unsigned __int16 *)this + 11);
  v7 = (*((_DWORD *)this + 3) - 1) * (*((_WORD *)this + 11) != 24 ? 1 : 3);
  v8 = (_BYTE *)(v7 + *((_DWORD *)this + 13));
  v22 = v8;
  if ( v6 == 8 )
  {
    for ( i = 0; i < *((_DWORD *)this + 4); ++i )
    {
      v15 = 0;
      if ( v7 >= 0 )
      {
        v16 = v8;
        do
        {
          *(_BYTE *)(v15 + v5) = *v16;
          ++v15;
          --v16;
        }
        while ( v15 <= v7 );
      }
      v17 = *((_DWORD *)this + 12);
      v8 += v17;
      v5 += v17;
    }
  }
  else if ( v6 == 24 )
  {
    for ( j = 0; j < *((_DWORD *)this + 4); ++j )
    {
      if ( v7 >= 0 )
      {
        v11 = v8 + 2;
        v12 = (_BYTE *)(v5 + 1);
        do
        {
          v13 = *(v11 - 2);
          v11 -= 3;
          *(v12 - 1) = v13;
          *v12 = v11[2];
          v12[1] = v11[3];
          v12 += 3;
        }
        while ( (int)&v12[-1 - v5] <= v7 );
        v8 = v22;
      }
      v14 = *((_DWORD *)this + 12);
      v8 += v14;
      v5 += v14;
      v22 = v8;
    }
  }
  else if ( *((int *)this + 4) > 0 )
  {
    do
    {
      v9 = 0;
      if ( v7 >= 0 )
      {
        v18 = v7;
        do
        {
          v10 = CxImage::GetPixelIndex(this, v18, v2);
          CxImage::SetPixelIndex(v21, v9++, v2, v10);
          --v18;
        }
        while ( v9 <= v7 );
      }
      ++v2;
    }
    while ( v2 < *((_DWORD *)this + 4) );
  }
  CxImage::Transfer(this, v21);
  (**(void (__thiscall ***)(CxImage *, int))v21)(v21, 1);
  return 1;
}

//----- (004663E0) --------------------------------------------------------
char __thiscall CxImage::RotateLeft(CxImage *this, struct CxImage *a2)
{
  signed int v4; // esi
  unsigned int v5; // edi
  struct tagRGBQUAD *v6; // eax
  unsigned __int8 *v7; // ebx
  int v8; // edi
  int v9; // esi
  unsigned __int8 *v10; // edi
  char v11; // dl
  int v12; // eax
  int v13; // esi
  unsigned __int8 *v14; // edx
  bool v15; // cc
  int v16; // edi
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // esi
  struct tagRGBQUAD *v21; // eax
  unsigned __int8 v22; // al
  char v23; // [esp+7h] [ebp-1C5h]
  int v24; // [esp+8h] [ebp-1C4h]
  int v25; // [esp+8h] [ebp-1C4h]
  unsigned __int8 *v26; // [esp+Ch] [ebp-1C0h]
  int v27; // [esp+Ch] [ebp-1C0h]
  int v28; // [esp+10h] [ebp-1BCh]
  int v29; // [esp+10h] [ebp-1BCh]
  int v30; // [esp+14h] [ebp-1B8h]
  int v31; // [esp+18h] [ebp-1B4h] BYREF
  int v32; // [esp+1Ch] [ebp-1B0h]
  unsigned __int8 *v33; // [esp+20h] [ebp-1ACh]
  unsigned __int8 *v34; // [esp+24h] [ebp-1A8h]
  int v35; // [esp+28h] [ebp-1A4h]
  char v36[12]; // [esp+30h] [ebp-19Ch] BYREF
  int v37; // [esp+3Ch] [ebp-190h]
  int v38; // [esp+4Ch] [ebp-180h]
  int v39; // [esp+60h] [ebp-16Ch]
  int v40; // [esp+1C8h] [ebp-4h]

  if ( !*((_DWORD *)this + 1) )
    return 0;
  v4 = *((_DWORD *)this + 4);
  v5 = *((_DWORD *)this + 3);
  v24 = v4;
  v28 = v5;
  CxImage::CxImage((CxImage *)v36, 0);
  v40 = 0;
  CxImage::CopyInfo((CxImage *)v36, this);
  CxImage::Create((CxImage *)v36, v4, v5, *((unsigned __int16 *)this + 11), *((_DWORD *)this + 15));
  v6 = CxImage::GetPalette(this);
  CxImage::SetPalette((CxImage *)v36, v6, 0x100u);
  if ( *((_WORD *)this + 11) == 1 )
  {
    v33 = CxImage::GetBits(this);
    v7 = CxImage::GetBits((CxImage *)v36);
    v8 = 8 * v39 - v37;
    v26 = v7;
    v31 = (int)&v7[v38];
    v32 = v8;
    CxImage::Clear((CxImage *)v36, (int)v7, 0);
    v9 = 0;
    v29 = 0;
    if ( *((int *)this + 4) > 0 )
    {
      while ( 1 )
      {
        v35 = sub_46F7DF(v9 + v8, 8);
        v30 = 0;
        v10 = &v33[v9 * *((_DWORD *)this + 12)];
        v23 = 1 << v11;
        if ( *((int *)this + 12) > 0 )
        {
          v12 = v39;
          v25 = 1;
          do
          {
            v13 = 0;
            v34 = &v7[v12 * v25 - v35 - 1];
            do
            {
              v14 = &v34[v12 * v13];
              if ( v14 < v7 || (unsigned int)v14 > v31 )
                break;
              if ( ((unsigned __int8)(128 >> v13) & v10[v30]) != 0 )
              {
                *v14 |= v23;
                v12 = v39;
              }
              v7 = v26;
              ++v13;
            }
            while ( v13 < 8 );
            v15 = ++v30 < *((_DWORD *)this + 12);
            v25 += 8;
          }
          while ( v15 );
          v9 = v29;
        }
        v29 = ++v9;
        if ( v9 >= *((_DWORD *)this + 4) )
          break;
        v8 = v32;
      }
    }
  }
  else
  {
    v16 = 0;
    if ( v4 > 0 )
    {
      v17 = 0;
      v18 = v4 - 1;
      v27 = 0;
      while ( 1 )
      {
        v19 = v17 / v4;
        v20 = 0;
        for ( *((_DWORD *)this + 80) = v19; v20 < v28; ++v20 )
        {
          if ( *((_DWORD *)this + 10) )
          {
            v22 = CxImage::GetPixelIndex(this, v20, v18);
            CxImage::SetPixelIndex((CxImage *)v36, v16, v20, v22);
          }
          else
          {
            v21 = (struct tagRGBQUAD *)CxImage::GetPixelColor(this, (int)&v31, v20, v18);
            CxImage::SetPixelColor((CxImage *)v36, v16, v20, *v21, 0);
          }
        }
        ++v16;
        v17 = v27 + 100;
        --v18;
        v27 += 100;
        if ( v16 >= v24 )
          break;
        v4 = v24;
      }
    }
  }
  if ( a2 )
    CxImage::Transfer(a2, (struct CxImage *)v36);
  else
    CxImage::Transfer(this, (struct CxImage *)v36);
  v40 = -1;
  CxImage::~CxImage((CxImage *)v36);
  return 1;
}
// 466500: variable 'v11' is possibly undefined

//----- (00466680) --------------------------------------------------------
char __thiscall CxImage::RotateRight(CxImage *this, struct CxImage *a2)
{
  signed int v4; // esi
  unsigned int v5; // edi
  struct tagRGBQUAD *v6; // eax
  int v7; // esi
  char v8; // dl
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // edx
  int j; // edi
  unsigned __int8 *v12; // esi
  bool v13; // cc
  int v14; // edi
  int v15; // eax
  int v16; // ebp
  int v17; // eax
  int v18; // esi
  struct tagRGBQUAD *v19; // eax
  unsigned __int8 v20; // al
  char v21; // [esp+7h] [ebp-1BDh]
  int v22; // [esp+8h] [ebp-1BCh]
  int v23; // [esp+8h] [ebp-1BCh]
  int v24; // [esp+Ch] [ebp-1B8h]
  int i; // [esp+Ch] [ebp-1B8h]
  unsigned __int8 *v26; // [esp+10h] [ebp-1B4h]
  int v27; // [esp+10h] [ebp-1B4h]
  int v28; // [esp+14h] [ebp-1B0h]
  int v29; // [esp+18h] [ebp-1ACh] BYREF
  unsigned __int8 *v30; // [esp+1Ch] [ebp-1A8h]
  int v31; // [esp+20h] [ebp-1A4h]
  char v32[16]; // [esp+28h] [ebp-19Ch] BYREF
  int v33; // [esp+38h] [ebp-18Ch]
  int v34; // [esp+44h] [ebp-180h]
  int v35; // [esp+58h] [ebp-16Ch]
  int v36; // [esp+1C0h] [ebp-4h]

  if ( !*((_DWORD *)this + 1) )
    return 0;
  v4 = *((_DWORD *)this + 3);
  v5 = *((_DWORD *)this + 4);
  v24 = v5;
  v22 = v4;
  CxImage::CxImage((CxImage *)v32, 0);
  v36 = 0;
  CxImage::CopyInfo((CxImage *)v32, this);
  CxImage::Create((CxImage *)v32, v5, v4, *((unsigned __int16 *)this + 11), *((_DWORD *)this + 15));
  v6 = CxImage::GetPalette(this);
  CxImage::SetPalette((CxImage *)v32, v6, 0x100u);
  if ( *((_WORD *)this + 11) == 1 )
  {
    v30 = CxImage::GetBits(this);
    v26 = CxImage::GetBits((CxImage *)v32);
    v29 = (int)&v26[v34];
    CxImage::Clear((CxImage *)v32, (int)this, 0);
    v7 = 0;
    for ( i = 0; v7 < *((_DWORD *)this + 4); i = v7 )
    {
      v31 = sub_46F7DF(v7, 8);
      v21 = 128 >> v8;
      v9 = &v30[v7 * *((_DWORD *)this + 12)];
      v28 = 0;
      if ( *((int *)this + 12) > 0 )
      {
        v23 = 0;
        do
        {
          v10 = &v26[v31 + v35 * (v33 - v23 - 1)];
          for ( j = 0; j < 8; ++j )
          {
            v12 = &v10[-(v35 * j)];
            if ( v12 < v26 || (unsigned int)v12 > v29 )
              break;
            if ( ((unsigned __int8)(128 >> j) & v9[v28]) != 0 )
              *v12 |= v21;
          }
          v13 = ++v28 < *((_DWORD *)this + 12);
          v23 += 8;
        }
        while ( v13 );
        v7 = i;
      }
      ++v7;
    }
  }
  else
  {
    v14 = 0;
    if ( v4 > 0 )
    {
      v15 = 0;
      v16 = v4 - 1;
      v27 = 0;
      while ( 1 )
      {
        v17 = v15 / v4;
        v18 = 0;
        for ( *((_DWORD *)this + 80) = v17; v18 < v24; ++v18 )
        {
          if ( *((_DWORD *)this + 10) )
          {
            v20 = CxImage::GetPixelIndex(this, v16, v18);
            CxImage::SetPixelIndex((CxImage *)v32, v18, v14, v20);
          }
          else
          {
            v19 = (struct tagRGBQUAD *)CxImage::GetPixelColor(this, (int)&v29, v16, v18);
            CxImage::SetPixelColor((CxImage *)v32, v18, v14, *v19, 0);
          }
        }
        ++v14;
        v15 = v27 + 100;
        --v16;
        v27 += 100;
        if ( v14 >= v22 )
          break;
        v4 = v22;
      }
    }
  }
  if ( a2 )
    CxImage::Transfer(a2, (struct CxImage *)v32);
  else
    CxImage::Transfer(this, (struct CxImage *)v32);
  v36 = -1;
  CxImage::~CxImage((CxImage *)v32);
  return 1;
}
// 46676C: variable 'v8' is possibly undefined

//----- (004668F0) --------------------------------------------------------
int __cdecl sub_4668F0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned __int8 *v4; // eax
  int result; // eax
  int v6; // esi
  unsigned __int8 *v7[14]; // [esp+8h] [ebp-38h] BYREF

  v7[1] = a4;
  v7[0] = a3;
  v4 = *a2;
  v7[3] = a1;
  v7[4] = v4;
  v7[8] = 0;
  v7[9] = 0;
  result = sub_466C10(v7, a114, 56);
  if ( !result )
  {
    v6 = sub_466C30(v7, 4);
    if ( v6 == 1 )
    {
      *a2 = v7[5];
      result = sub_466AB0(v7);
    }
    else
    {
      sub_466AB0(v7);
      result = -5;
      if ( v6 )
        result = v6;
    }
  }
  return result;
}

//----- (00466990) --------------------------------------------------------
char __cdecl sub_466990(int a1, int *a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v6; // esi
  int v8[14]; // [esp+8h] [ebp-38h] BYREF

  v8[1] = a4;
  v8[3] = a1;
  v8[0] = a3;
  v8[4] = *a2;
  v8[8] = 0;
  v8[9] = 0;
  v8[10] = 0;
  v5 = z_deflateInit_(v8, a5, a114, 56);
  if ( !v5 )
  {
    v6 = sub_467670((int)v8, 4);
    if ( v6 == 1 )
    {
      *a2 = v8[5];
      LOBYTE(v5) = sub_4679D0((int)v8);
    }
    else
    {
      sub_4679D0((int)v8);
      LOBYTE(v5) = -5;
      if ( v6 )
        LOBYTE(v5) = v6;
    }
  }
  return v5;
}

//----- (00466A40) --------------------------------------------------------
char __cdecl sub_466A40(int a1, int *a2, int a3, int a4)
{
  return sub_466990(a1, a2, a3, a4, -1);
}

//----- (00466A60) --------------------------------------------------------
int __cdecl sub_466A60(_DWORD *a1)
{
  _DWORD *v1; // ecx

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  *v1 = v1[3] != 0 ? 7 : 0;
  sub_4688B0(*(_DWORD **)(a1[7] + 20), (int)a1, 0);
  return 0;
}

//----- (00466AB0) --------------------------------------------------------
int __cdecl sub_466AB0(_DWORD *a1)
{
  int v1; // eax
  _DWORD *v2; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 || !a1[9] )
    return -2;
  v2 = *(_DWORD **)(v1 + 20);
  if ( v2 )
    sub_4696E0(v2, (int)a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (00466B00) --------------------------------------------------------
int __cdecl sub_466B00(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  int result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // ecx

  if ( !a3 || *a3 != a114[0] || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v5 = a1[8];
  a1[6] = 0;
  if ( !v5 )
  {
    a1[8] = sub_4698D0;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_4698F0;
  v6 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  a1[7] = v6;
  if ( !v6 )
    return -4;
  v7 = a2;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    v7 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( v7 < 8 || v7 > 15 )
  {
    sub_466AB0(a1);
    result = -2;
  }
  else
  {
    *(_DWORD *)(a1[7] + 16) = v7;
    *(_DWORD *)(a1[7] + 20) = sub_468930((int)a1, *(_DWORD *)(a1[7] + 12) == 0 ? (unsigned int)sub_469770 : 0, 1 << v7);
    if ( *(_DWORD *)(a1[7] + 20) )
    {
      sub_466A60(a1);
      result = 0;
    }
    else
    {
      sub_466AB0(a1);
      result = -4;
    }
  }
  return result;
}

//----- (00466C10) --------------------------------------------------------
int __cdecl sub_466C10(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_466B00(a1, 15, a2, a3);
}

//----- (00466C30) --------------------------------------------------------
int __cdecl sub_466C30(unsigned __int8 **a1, int a2)
{
  int v2; // edi
  unsigned int v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // eax
  int v7; // ecx
  unsigned __int8 *v8; // edx
  unsigned __int8 *v9; // edx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // ebx
  int v12; // ecx
  unsigned __int8 *v13; // eax
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // edx
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // ecx
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // ecx
  int v24; // edx
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // edx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v30; // ecx
  unsigned __int8 *v31; // ecx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // edx
  unsigned __int8 *v34; // edx
  unsigned __int8 *v35; // eax
  unsigned __int8 *v36; // ecx
  unsigned __int8 *v37; // eax
  unsigned __int8 *v38; // ecx
  int v39; // edx
  unsigned __int8 *v40; // eax
  unsigned __int8 *v41; // eax
  unsigned __int8 *v42; // eax
  unsigned int v43; // [esp+18h] [ebp+8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  v2 = -5;
  v3 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v43 = v3;
  while ( 2 )
  {
    v4 = a1[7];
    switch ( *(_DWORD *)v4 )
    {
      case 0:
        v5 = a1[1];
        if ( !v5 )
          return v2;
        a1[1] = v5 - 1;
        v2 = v3;
        ++a1[2];
        *((_DWORD *)v4 + 1) = **a1;
        v6 = a1[7];
        v7 = *((_DWORD *)v6 + 1) & 0xF;
        ++*a1;
        if ( (_BYTE)v7 != 8 )
        {
          *(_DWORD *)v6 = 13;
          v8 = a1[7];
          a1[6] = (unsigned __int8 *)aUnknownCompres_0;
          *((_DWORD *)v8 + 1) = 5;
          continue;
        }
        if ( (unsigned int)((*((_DWORD *)v6 + 1) >> 4) + 8) > *((_DWORD *)v6 + 4) )
        {
          *(_DWORD *)v6 = 13;
          v9 = a1[7];
          a1[6] = (unsigned __int8 *)aInvalidWindowS;
          *((_DWORD *)v9 + 1) = 5;
          continue;
        }
        *(_DWORD *)v6 = 1;
LABEL_12:
        v10 = a1[1];
        if ( !v10 )
          return v2;
        a1[1] = v10 - 1;
        v2 = v3;
        v11 = a1[7];
        ++a1[2];
        v12 = *(*a1)++;
        if ( (v12 + (*((_DWORD *)v11 + 1) << 8)) % 0x1Fu )
        {
          *(_DWORD *)v11 = 13;
          v13 = a1[7];
          v3 = v43;
          a1[6] = (unsigned __int8 *)aIncorrectHeade;
          *((_DWORD *)v13 + 1) = 5;
          continue;
        }
        if ( (v12 & 0x20) == 0 )
        {
          *(_DWORD *)v11 = 7;
          v3 = v43;
          continue;
        }
        v3 = v43;
        *(_DWORD *)a1[7] = 2;
LABEL_35:
        v28 = a1[1];
        if ( !v28 )
          return v2;
        v30 = *a1;
        ++a1[2];
        a1[1] = v28 - 1;
        v2 = v3;
        *((_DWORD *)a1[7] + 2) = *v30 << 24;
        v31 = a1[7];
        ++*a1;
        *(_DWORD *)v31 = 3;
LABEL_38:
        v32 = a1[1];
        if ( !v32 )
          return v2;
        v33 = *a1;
        a1[1] = v32 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v33 << 16;
        v34 = a1[7];
        ++*a1;
        *(_DWORD *)v34 = 4;
LABEL_41:
        v35 = a1[1];
        if ( !v35 )
          return v2;
        v36 = *a1;
        a1[1] = v35 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v36 << 8;
        ++*a1;
        *(_DWORD *)a1[7] = 5;
LABEL_44:
        v37 = a1[1];
        if ( !v37 )
          return v2;
        v38 = *a1;
        v39 = (int)(a1[2] + 1);
        a1[1] = v37 - 1;
        v40 = a1[7];
        a1[2] = (unsigned __int8 *)v39;
        *((_DWORD *)v40 + 2) += *v38;
        ++*a1;
        v41 = a1[7];
        a1[12] = (unsigned __int8 *)*((_DWORD *)v41 + 2);
        *(_DWORD *)v41 = 6;
        return 2;
      case 1:
        goto LABEL_12;
      case 2:
        goto LABEL_35;
      case 3:
        goto LABEL_38;
      case 4:
        goto LABEL_41;
      case 5:
        goto LABEL_44;
      case 6:
        *(_DWORD *)a1[7] = 13;
        v42 = a1[7];
        a1[6] = (unsigned __int8 *)aNeedDictionary;
        *((_DWORD *)v42 + 1) = 0;
        return -2;
      case 7:
        v14 = sub_4689D0(*((_DWORD **)v4 + 5), (int)a1, v2);
        v2 = v14;
        if ( v14 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
        }
        else
        {
          if ( !v14 )
            v2 = v3;
          if ( v2 != 1 )
            return v2;
          v2 = v3;
          sub_4688B0(*((_DWORD **)a1[7] + 5), (int)a1, (_DWORD *)a1[7] + 1);
          v15 = a1[7];
          if ( *((_DWORD *)v15 + 3) )
          {
            *(_DWORD *)v15 = 12;
          }
          else
          {
            *(_DWORD *)v15 = 8;
LABEL_25:
            v16 = a1[1];
            if ( !v16 )
              return v2;
            v17 = a1[7];
            a1[1] = v16 - 1;
            ++a1[2];
            v2 = v3;
            *((_DWORD *)v17 + 2) = *(*a1)++ << 24;
            *(_DWORD *)a1[7] = 9;
LABEL_27:
            v18 = a1[1];
            if ( !v18 )
              return v2;
            v19 = *a1;
            ++a1[2];
            a1[1] = v18 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v19 << 16;
            ++*a1;
            *(_DWORD *)a1[7] = 10;
LABEL_29:
            v20 = a1[1];
            if ( !v20 )
              return v2;
            v21 = *a1;
            ++a1[2];
            a1[1] = v20 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v21 << 8;
            ++*a1;
            *(_DWORD *)a1[7] = 11;
LABEL_31:
            v22 = a1[1];
            if ( !v22 )
              return v2;
            v23 = *a1;
            v24 = (int)(a1[2] + 1);
            a1[1] = v22 - 1;
            v25 = a1[7];
            a1[2] = (unsigned __int8 *)v24;
            v2 = v3;
            *((_DWORD *)v25 + 2) += *v23;
            ++*a1;
            v26 = a1[7];
            if ( *((_DWORD *)v26 + 1) == *((_DWORD *)v26 + 2) )
            {
              *(_DWORD *)a1[7] = 12;
              return 1;
            }
            *(_DWORD *)v26 = 13;
            v27 = a1[7];
            a1[6] = (unsigned __int8 *)aIncorrectDataC;
            *((_DWORD *)v27 + 1) = 5;
          }
        }
        continue;
      case 8:
        goto LABEL_25;
      case 9:
        goto LABEL_27;
      case 0xA:
        goto LABEL_29;
      case 0xB:
        goto LABEL_31;
      case 0xC:
        return 1;
      case 0xD:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (004671F0) --------------------------------------------------------
int __cdecl z_deflateInit_(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  return sub_467220(a1, a2, 8, 15, 8, 0, a3, a4);
}

//----- (00467220) --------------------------------------------------------
int __cdecl sub_467220(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8)
{
  int v8; // ebp
  int result; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // ebx
  _DWORD *v13; // eax
  _DWORD *v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // ecx

  v8 = 0;
  if ( !a7 || *a7 != *off_4B88C0 || a8 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v10 = a1[8];
  a1[6] = 0;
  if ( !v10 )
  {
    a1[8] = sub_4698D0;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_4698F0;
  v11 = a2;
  if ( a2 == -1 )
  {
    a2 = 6;
    v11 = 6;
  }
  v12 = a4;
  if ( a4 < 0 )
  {
    v8 = 1;
    v12 = -a4;
  }
  if ( a5 < 1 || a5 > 9 || a3 != 8 || v12 < 9 || v12 > 15 || v11 < 0 || v11 > 9 || a6 < 0 || a6 > 2 )
    return -2;
  v13 = (_DWORD *)((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 5816);
  v14 = v13;
  if ( !v13 )
    return -4;
  a1[7] = v13;
  v13[6] = v8;
  v13[10] = v12;
  *v13 = a1;
  v13[18] = a5 + 7;
  v13[9] = 1 << v12;
  v13[11] = (1 << v12) - 1;
  v15 = 1 << (a5 + 7);
  v14[17] = v15;
  v14[19] = v15 - 1;
  v14[20] = (a5 + 9) / 3u;
  v16 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1 << v12, 2);
  v17 = v14[9];
  v14[12] = v16;
  v18 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], v17, 2);
  v19 = v14[17];
  v14[14] = v18;
  v14[15] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], v19, 2);
  v14[1445] = 1 << (a5 + 6);
  v20 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1 << (a5 + 6), 4);
  v21 = v14[1445];
  v14[2] = v20;
  v14[3] = 4 * v21;
  if ( v14[12] && v14[14] && v14[15] && v20 )
  {
    *((_BYTE *)v14 + 29) = 8;
    v14[1447] = v20 + 2 * (v21 >> 1);
    v14[1444] = v20 + 2 * v21 + v21;
    v14[32] = a6;
    v14[31] = a2;
    result = sub_467520(a1);
  }
  else
  {
    a1[6] = off_4B8950[0];
    sub_4679D0((int)a1);
    result = -4;
  }
  return result;
}
// 4B88C0: using guessed type char *off_4B88C0;
// 4B8950: using guessed type char *off_4B8950[3];

//----- (00467520) --------------------------------------------------------
int __cdecl sub_467520(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // edx

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v2 = v1[2];
  v1[5] = 0;
  v1[4] = v2;
  if ( (int)v1[6] < 0 )
    v1[6] = 0;
  v1[1] = v1[6] != 0 ? 113 : 42;
  a1[12] = 1;
  v1[8] = 0;
  sub_469900((int)v1);
  sub_467C30((int)v1);
  return 0;
}

//----- (00467670) --------------------------------------------------------
int __cdecl sub_467670(int a1, int a2)
{
  int v3; // esi
  int v4; // eax
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // [esp+14h] [ebp+4h]

  if ( !a1 )
    return -2;
  v3 = *(_DWORD *)(a1 + 28);
  if ( !v3 || a2 > 4 || a2 < 0 )
    return -2;
  if ( !*(_DWORD *)(a1 + 12)
    || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4)
    || (v4 = *(_DWORD *)(v3 + 4), v4 == 666) && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_4B8948[0];
    return -2;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(char **)(a1 + 24) = off_4B8954[0];
    return -5;
  }
  v6 = *(_DWORD *)(v3 + 32);
  *(_DWORD *)v3 = a1;
  v13 = v6;
  *(_DWORD *)(v3 + 32) = a2;
  if ( v4 == 42 )
  {
    v7 = (*(_DWORD *)(v3 + 124) - 1) >> 1;
    if ( v7 > 3 )
      v7 = 3;
    v8 = (v7 << 6) | ((*(_DWORD *)(v3 + 40) << 12) - 30720);
    if ( *(_DWORD *)(v3 + 100) )
      v8 |= 0x20u;
    *(_DWORD *)(v3 + 4) = 113;
    sub_467920(v3, v8 - v8 % 0x1F + 31);
    if ( *(_DWORD *)(v3 + 100) )
    {
      sub_467920(v3, HIWORD(*(_DWORD *)(a1 + 48)));
      sub_467920(v3, *(_DWORD *)(a1 + 48));
    }
    *(_DWORD *)(a1 + 48) = 1;
  }
  if ( *(_DWORD *)(v3 + 20) )
  {
    sub_467950(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(v3 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v13 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_4B8954[0];
    return -5;
  }
  v9 = *(_DWORD *)(v3 + 4);
  v10 = *(_DWORD *)(a1 + 4);
  if ( v9 == 666 )
  {
    if ( v10 )
    {
      *(char **)(a1 + 24) = off_4B8954[0];
      return -5;
    }
  }
  else if ( v10 )
  {
    goto LABEL_34;
  }
  if ( !*(_DWORD *)(v3 + 108) && (!a2 || v9 == 666) )
  {
LABEL_46:
    if ( a2 != 4 )
      return 0;
    if ( *(_DWORD *)(v3 + 24) )
      return 1;
    sub_467920(v3, HIWORD(*(_DWORD *)(a1 + 48)));
    sub_467920(v3, *(_DWORD *)(a1 + 48));
    sub_467950(a1);
    v12 = *(_DWORD *)(v3 + 20);
    *(_DWORD *)(v3 + 24) = -1;
    return v12 == 0;
  }
LABEL_34:
  v11 = funcs_467804[3 * *(_DWORD *)(v3 + 124)](v3, a2);
  if ( v11 == 2 || v11 == 3 )
    *(_DWORD *)(v3 + 4) = 666;
  if ( v11 && v11 != 2 )
  {
    if ( v11 == 1 )
    {
      if ( a2 == 1 )
      {
        sub_469A90(v3);
      }
      else
      {
        sub_4699F0(v3, 0, 0, 0);
        if ( a2 == 3 )
        {
          *(_WORD *)(*(_DWORD *)(v3 + 60) + 2 * *(_DWORD *)(v3 + 68) - 2) = 0;
          memset(*(void **)(v3 + 60), 0, 2 * *(_DWORD *)(v3 + 68) - 2);
        }
      }
      sub_467950(a1);
      if ( !*(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(v3 + 32) = -1;
        return 0;
      }
    }
    goto LABEL_46;
  }
  if ( !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(v3 + 32) = -1;
  return 0;
}
// 4B8948: using guessed type char *off_4B8948[5];
// 4B8954: using guessed type char *off_4B8954[2];

//----- (00467920) --------------------------------------------------------
int __cdecl sub_467920(int a1, __int16 a2)
{
  int result; // eax
  int v3; // esi
  int v4; // edx

  result = a1;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = HIBYTE(a2);
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v4;
  *(_BYTE *)(v3 + v4) = a2;
  ++*(_DWORD *)(a1 + 20);
  return result;
}

//----- (00467950) --------------------------------------------------------
_DWORD *__cdecl sub_467950(int a1)
{
  _DWORD *result; // eax
  int v2; // esi
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // edi

  result = (_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 28);
  v3 = *(_DWORD *)(v2 + 20);
  if ( v3 > *(_DWORD *)(a1 + 16) )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    qmemcpy(*(void **)(a1 + 12), *(const void **)(v2 + 16), v3);
    v4 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v4 + 16) += v3;
    v5 = *(_DWORD *)(a1 + 28);
    v6 = *(_DWORD *)(a1 + 16) - v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(v5 + 20) -= v3;
    result = *(_DWORD **)(a1 + 28);
    if ( !result[5] )
      result[4] = result[2];
  }
  return result;
}

//----- (004679D0) --------------------------------------------------------
char __cdecl sub_4679D0(int a1)
{
  int v1; // eax
  int v2; // edi
  int v3; // eax
  int v4; // ecx
  int v5; // edx

  if ( !a1 )
    return -2;
  v1 = *(_DWORD *)(a1 + 28);
  if ( !v1 )
    return -2;
  v2 = *(_DWORD *)(v1 + 4);
  if ( v2 != 42 && v2 != 113 && v2 != 666 )
    return -2;
  v3 = *(_DWORD *)(v1 + 8);
  if ( v3 )
    (*(void (__cdecl **)(_DWORD, int))(a1 + 36))(*(_DWORD *)(a1 + 40), v3);
  v4 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(v4 + 60) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(v4 + 60));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56));
  v5 = *(_DWORD *)(a1 + 28);
  if ( *(_DWORD *)(v5 + 48) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(v5 + 48));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  return v2 != 113 ? 0 : 0xFD;
}

//----- (00467C30) --------------------------------------------------------
int __cdecl sub_467C30(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ecx
  int result; // eax

  v1 = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 52) = 2 * *(_DWORD *)(a1 + 36);
  *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 60), 0, 2 * *(_DWORD *)(a1 + 68) - 2);
  v2 = 6 * *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a1 + 120) = (unsigned __int16)word_4AE6C2[v2];
  *(_DWORD *)(a1 + 132) = (unsigned __int16)word_4AE6C0[v2];
  *(_DWORD *)(a1 + 136) = (unsigned __int16)word_4AE6C4[v2];
  v3 = (unsigned __int16)word_4AE6C6[v2];
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  result = 2;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 116) = v3;
  *(_DWORD *)(a1 + 112) = 2;
  *(_DWORD *)(a1 + 88) = 2;
  return result;
}
// 4AE6C0: using guessed type __int16 word_4AE6C0[];
// 4AE6C2: using guessed type __int16 word_4AE6C2[];
// 4AE6C4: using guessed type __int16 word_4AE6C4[];
// 4AE6C6: using guessed type __int16 word_4AE6C6[];

//----- (00467CD0) --------------------------------------------------------
int __cdecl sub_467CD0(int *a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  bool v5; // zf
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned int v11; // edx
  _BYTE *v12; // eax
  int v13; // ecx
  _BYTE *v14; // eax
  int v16; // eax
  int v17; // [esp-14h] [ebp-20h]
  int v18; // [esp-14h] [ebp-20h]
  int v19; // [esp-14h] [ebp-20h]

  v2 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v2 = a1[3] - 5;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 <= 1 )
    {
      sub_467E30((int)a1);
      v3 = a1[27];
      if ( !v3 )
        break;
    }
    v4 = a1[25];
    a1[27] = 0;
    v5 = v3 + v4 == 0;
    a1[25] = v3 + v4;
    v6 = a1[21];
    v7 = a1[25];
    v8 = v6 + v2;
    if ( !v5 && v7 < v8
      || ((a1[25] = v8, a1[27] = v7 - v8, v6 < 0) ? (v9 = 0) : (v9 = (_BYTE *)(v6 + a1[12])),
          sub_469CF0((int)a1, v9, v2, 0),
          v17 = *a1,
          a1[21] = a1[25],
          sub_467950(v17),
          *(_DWORD *)(*a1 + 16)) )
    {
      v10 = a1[21];
      v11 = a1[25] - v10;
      if ( v11 < a1[9] - 262 )
        continue;
      v12 = (_BYTE *)(v10 < 0 ? 0 : v10 + a1[12]);
      sub_469CF0((int)a1, v12, v11, 0);
      v18 = *a1;
      a1[21] = a1[25];
      sub_467950(v18);
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v13 = a1[21];
  if ( v13 < 0 )
    v14 = 0;
  else
    v14 = (_BYTE *)(v13 + a1[12]);
  sub_469CF0((int)a1, v14, a1[25] - v13, a2 == 4);
  v19 = *a1;
  a1[21] = a1[25];
  sub_467950(v19);
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v16 = -(a2 != 4);
  LOBYTE(v16) = v16 & 0xFE;
  return v16 + 3;
}
// 467D0E: conditional instruction was optimized away because of 'eax.4==0'

//----- (00467E30) --------------------------------------------------------
int __cdecl sub_467E30(int a1)
{
  unsigned int v1; // ebp
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // ecx
  _WORD *v9; // ecx
  __int16 v10; // ax
  unsigned int v11; // esi
  _WORD *v12; // ecx
  __int16 v13; // ax
  int result; // eax
  unsigned int v15; // esi
  int v16; // ecx
  unsigned __int8 *v17; // edi
  int v18; // eax

  v1 = *(_DWORD *)(a1 + 36);
  do
  {
    v2 = *(_DWORD *)(a1 + 100);
    v3 = *(_DWORD *)(a1 + 108);
    v4 = *(_DWORD *)(a1 + 52) - v2 - v3;
    if ( v4 )
    {
      if ( v4 == -1 )
      {
        v4 = -2;
        goto LABEL_20;
      }
    }
    else if ( !v2 && !v3 )
    {
      v4 = v1;
      goto LABEL_20;
    }
    if ( v2 >= *(_DWORD *)(a1 + 36) + v1 - 262 )
    {
      qmemcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + v1), v1);
      v5 = *(_DWORD *)(a1 + 84);
      v6 = *(_DWORD *)(a1 + 100) - v1;
      *(_DWORD *)(a1 + 104) -= v1;
      v7 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 100) = v6;
      v8 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 84) = v5 - v1;
      v9 = (_WORD *)(v8 + 2 * v7);
      do
      {
        if ( (unsigned __int16)*--v9 < v1 )
          v10 = 0;
        else
          v10 = *v9 - v1;
        --v7;
        *v9 = v10;
      }
      while ( v7 );
      v11 = v1;
      v12 = (_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v1);
      do
      {
        if ( (unsigned __int16)*--v12 < v1 )
          v13 = 0;
        else
          v13 = *v12 - v1;
        --v11;
        *v12 = v13;
      }
      while ( v11 );
      v4 += v1;
    }
LABEL_20:
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    result = sub_467F60(result, (void *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 108)), v4);
    v15 = result + *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 108) = v15;
    if ( v15 >= 3 )
    {
      v16 = *(_DWORD *)(a1 + 80);
      v17 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      v18 = *v17;
      *(_DWORD *)(a1 + 64) = v18;
      result = *(_DWORD *)(a1 + 76) & (v17[1] ^ (v18 << v16));
      *(_DWORD *)(a1 + 64) = result;
    }
    if ( v15 >= 0x106 )
      break;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  while ( result );
  return result;
}

//----- (00467F60) --------------------------------------------------------
unsigned int __cdecl sub_467F60(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v5; // eax

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 > a3 )
    v3 = a3;
  if ( !v3 )
    return 0;
  *(_DWORD *)(a1 + 4) -= v3;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_469770(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, v3);
  qmemcpy(a2, *(const void **)a1, v3);
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a1 += v3;
  *(_DWORD *)(a1 + 8) = v3 + v5;
  return v3;
}

//----- (00468310) --------------------------------------------------------
unsigned int __cdecl sub_468310(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // ebx
  _BYTE *v10; // edx
  char v11; // al
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // edx
  char v15; // al
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // edx
  char v19; // al
  _BYTE *v20; // edx
  char v21; // al
  _BYTE *v22; // edx
  char v23; // al
  _BYTE *v24; // edx
  char v25; // al
  _BYTE *v26; // edx
  char v27; // al
  _BYTE *v28; // edx
  char v29; // al
  _BYTE *v30; // edx
  int v31; // edx
  unsigned int result; // eax
  char v33; // [esp+13h] [ebp-11h]
  unsigned int v34; // [esp+14h] [ebp-10h]
  int v35; // [esp+18h] [ebp-Ch]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]
  char v38; // [esp+28h] [ebp+4h]

  v3 = a1[9];
  v4 = a1[25];
  v5 = a1[28];
  v34 = a1[29];
  v6 = a1[34];
  v7 = (_BYTE *)(v4 + a1[12]);
  v35 = v6;
  if ( v4 <= v3 - 262 )
    v36 = 0;
  else
    v36 = v4 - v3 + 262;
  v8 = v7 + 258;
  v38 = v7[v5 - 1];
  v33 = v7[v5];
  if ( v5 >= a1[33] )
    v34 >>= 2;
  v37 = a1[27];
  if ( v6 > v37 )
    v35 = a1[27];
  do
  {
    v10 = (_BYTE *)(a2 + a1[12]);
    if ( v10[v5] == v33 && v10[v5 - 1] == v38 && *v10 == *v7 )
    {
      v11 = v10[1];
      v12 = v10 + 1;
      if ( v11 == v7[1] )
      {
        v13 = v7 + 2;
        v14 = v12 + 1;
        do
        {
          v15 = *++v13;
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *++v13;
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *++v13;
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *++v13;
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *++v13;
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *++v13;
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *++v13;
          v28 = v26 + 1;
          if ( v27 != *v28 )
            break;
          v29 = *++v13;
          v14 = v28 + 1;
          if ( v29 != *v14 )
            break;
        }
        while ( v13 < v8 );
        v30 = v13;
        v7 = v8 - 258;
        v31 = v30 - v8 + 258;
        if ( v31 > (int)v5 )
        {
          a1[26] = a2;
          v5 = v31;
          if ( v31 >= v35 )
            break;
          v38 = v7[v31 - 1];
          v33 = v7[v31];
        }
      }
    }
    a2 = *(unsigned __int16 *)(a1[14] + 2 * (a2 & a1[11]));
    if ( (unsigned __int16)a2 <= v36 )
      break;
    --v34;
  }
  while ( v34 );
  result = v37;
  if ( v5 <= v37 )
    result = v5;
  return result;
}

//----- (004688B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_4688B0(_DWORD *a1, int a2, _DWORD *a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax

  if ( a3 )
    *a3 = a1[15];
  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    sub_46BD30(a1[1], a2);
  v3 = a1[10];
  *a1 = 0;
  a1[13] = v3;
  a1[12] = v3;
  result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  a1[7] = 0;
  a1[8] = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    a1[15] = result;
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

//----- (00468930) --------------------------------------------------------
int __cdecl sub_468930(int a1, int a2, int a3)
{
  int result; // eax
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  v4 = (_DWORD *)result;
  if ( result )
  {
    v5 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
    v4[9] = v5;
    if ( v5 )
    {
      v6 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
      v4[10] = v6;
      if ( v6 )
      {
        v4[11] = a3 + v6;
        v4[14] = a2;
        *v4 = 0;
        sub_4688B0(v4, a1, 0);
        result = (int)v4;
      }
      else
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v4[9]);
        (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
        result = 0;
      }
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
      result = 0;
    }
  }
  return result;
}

//----- (004689D0) --------------------------------------------------------
int __cdecl sub_4689D0(_DWORD *a1, int a2, int a3)
{
  unsigned int v4; // ebp
  char *v5; // ecx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // esi
  unsigned int v9; // eax
  unsigned __int8 *v10; // edi
  int v11; // edx
  unsigned int v12; // ebp
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // edi
  unsigned __int8 *v17; // eax
  int v18; // edx
  unsigned int v19; // edi
  unsigned int v20; // ecx
  char *v21; // ecx
  char *v22; // edx
  unsigned int v23; // eax
  unsigned int v24; // esi
  int v25; // eax
  char *v26; // edx
  unsigned int v27; // esi
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // edi
  unsigned int v33; // esi
  unsigned __int8 *v34; // eax
  int v35; // edx
  unsigned int v36; // eax
  unsigned int v37; // ecx
  int v38; // esi
  int v39; // eax
  unsigned int v40; // edi
  unsigned __int8 *v41; // eax
  char v42; // cl
  int v43; // eax
  unsigned int v44; // edx
  unsigned int v45; // ecx
  unsigned int v46; // eax
  int v47; // edx
  int v48; // ecx
  int v49; // eax
  int v50; // edx
  unsigned int v51; // eax
  int v52; // eax
  unsigned int v53; // ecx
  int v54; // eax
  int v55; // eax
  int v56; // edx
  unsigned int v57; // edi
  int v58; // eax
  int v59; // ecx
  unsigned int v60; // eax
  int v61; // eax
  unsigned __int8 *v62; // edi
  int v63; // edx
  int v64; // eax
  char *v65; // ecx
  unsigned __int8 *v66; // edi
  unsigned int v67; // eax
  int v68; // eax
  int v69; // ebp
  int result; // eax
  int v71; // ebp
  int v72; // ebp
  unsigned __int8 *v73; // esi
  int v74; // ebp
  int v75; // ebp
  int v76; // ebp
  unsigned __int8 *v77; // edx
  unsigned __int8 *v78; // ebp
  int v79; // esi
  unsigned __int8 *v80; // esi
  int v81; // ebp
  unsigned __int8 *v82; // edi
  int v83; // edx
  unsigned __int8 *v84; // esi
  int v85; // ebp
  unsigned __int8 *v86; // edi
  int v87; // ecx
  int v88; // ecx
  unsigned __int8 *v89; // edx
  unsigned __int8 *v90; // edi
  int v91; // ecx
  unsigned __int8 *v92; // edi
  int v93; // edx
  unsigned __int8 *v94; // edi
  int v95; // ecx
  char *v96; // ecx
  unsigned __int8 *v97; // ebp
  unsigned __int8 *v98; // ebp
  unsigned __int8 *v99; // esi
  int v100; // ebp
  unsigned __int8 *v101; // esi
  int v102; // ebp
  int *v103; // [esp-1Ch] [ebp-5Ch]
  int *v104; // [esp-14h] [ebp-54h]
  int v105; // [esp-8h] [ebp-48h]
  int v106; // [esp-8h] [ebp-48h]
  unsigned __int8 *v107; // [esp+10h] [ebp-30h]
  unsigned int v108; // [esp+14h] [ebp-2Ch]
  unsigned int v109; // [esp+18h] [ebp-28h]
  int v110; // [esp+18h] [ebp-28h]
  int v111; // [esp+18h] [ebp-28h]
  int v112; // [esp+18h] [ebp-28h]
  int v113; // [esp+18h] [ebp-28h]
  unsigned int v114; // [esp+1Ch] [ebp-24h] BYREF
  unsigned int v115; // [esp+20h] [ebp-20h] BYREF
  int v116; // [esp+24h] [ebp-1Ch] BYREF
  int v117; // [esp+28h] [ebp-18h] BYREF
  int v118; // [esp+2Ch] [ebp-14h] BYREF
  int v119; // [esp+30h] [ebp-10h] BYREF
  unsigned int v120; // [esp+34h] [ebp-Ch]
  int v121; // [esp+38h] [ebp-8h] BYREF
  int v122; // [esp+3Ch] [ebp-4h] BYREF
  char *v123; // [esp+44h] [ebp+4h]
  int v124; // [esp+4Ch] [ebp+Ch]

  v4 = a1[7];
  v107 = *(unsigned __int8 **)a2;
  v5 = (char *)a1[13];
  v109 = a1[8];
  v6 = a1[12];
  v108 = *(_DWORD *)(a2 + 4);
  v123 = v5;
  if ( (unsigned int)v5 >= v6 )
    v7 = a1[11] - (_DWORD)v5;
  else
    v7 = v6 - (_DWORD)v5 - 1;
  v114 = v7;
  while ( 2 )
  {
    switch ( *a1 )
    {
      case 0:
        v8 = v109;
        if ( v4 >= 3 )
        {
          v10 = v107;
LABEL_12:
          a1[6] = v8 & 1;
          switch ( (unsigned __int8)(v8 & 7) >> 1 )
          {
            case 0:
              v12 = v4 - 3;
              *a1 = 1;
              v13 = v12 & 7;
              v4 = v12 - v13;
              v109 = v8 >> 3 >> v13;
              continue;
            case 1:
              sub_46C450(&v119, &v118, &v117, &v116);
              v14 = sub_46B540(v119, v118, v117, v116, a2);
              a1[1] = v14;
              if ( v14 )
              {
                v109 = v8 >> 3;
                v4 -= 3;
                *a1 = 6;
                continue;
              }
              a1[8] = v8;
              a1[7] = v4;
              v71 = *(_DWORD *)(a2 + 8);
              *(_DWORD *)(a2 + 4) = v108;
              *(_DWORD *)(a2 + 8) = &v10[v71 - *(_DWORD *)a2];
              *(_DWORD *)a2 = v10;
              a1[13] = v123;
              result = sub_46C480(a1, (_DWORD *)a2, -4);
              break;
            case 2:
              v109 = v8 >> 3;
              v4 -= 3;
              *a1 = 3;
              continue;
            case 3:
              *a1 = 9;
              *(_DWORD *)(a2 + 24) = aInvalidBlockTy;
              a1[8] = v8 >> 3;
              a1[7] = v4 - 3;
              v72 = *(_DWORD *)(a2 + 8);
              *(_DWORD *)(a2 + 4) = v108;
              *(_DWORD *)(a2 + 8) = &v10[v72 - *(_DWORD *)a2];
              *(_DWORD *)a2 = v10;
              a1[13] = v123;
              return sub_46C480(a1, (_DWORD *)a2, -3);
            default:
              continue;
          }
        }
        else
        {
          v9 = v108;
          v10 = v107;
          while ( v9 )
          {
            --v9;
            a3 = 0;
            v11 = *v10 << v4;
            v4 += 8;
            v108 = v9;
            v8 |= v11;
            ++v10;
            v109 = v8;
            v107 = v10;
            if ( v4 >= 3 )
              goto LABEL_12;
          }
          a1[8] = v8;
          a1[7] = v4;
          v69 = (int)&v10[*(_DWORD *)(a2 + 8) - *(_DWORD *)a2];
          *(_DWORD *)(a2 + 4) = 0;
          *(_DWORD *)(a2 + 8) = v69;
          *(_DWORD *)a2 = v10;
          a1[13] = v123;
          result = sub_46C480(a1, (_DWORD *)a2, a3);
        }
        return result;
      case 1:
        v15 = v109;
        v16 = v108;
        v17 = v107;
        if ( v4 >= 0x20 )
          goto LABEL_20;
        do
        {
          if ( !v16 )
          {
            a1[8] = v15;
            a1[7] = v4;
            v73 = *(unsigned __int8 **)a2;
            v74 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)a2 = v17;
            *(_DWORD *)(a2 + 8) = v17 - v73 + v74;
            a1[13] = v123;
            return sub_46C480(a1, (_DWORD *)a2, a3);
          }
          a3 = 0;
          --v16;
          v18 = *v17 << v4;
          v4 += 8;
          v108 = v16;
          v15 |= v18;
          v107 = ++v17;
        }
        while ( v4 < 0x20 );
LABEL_20:
        if ( (unsigned __int16)v15 != ~v15 >> 16 )
        {
          *a1 = 9;
          *(_DWORD *)(a2 + 24) = aInvalidStoredB;
          a1[8] = v15;
          a1[7] = v4;
          v75 = (int)&v17[*(_DWORD *)(a2 + 8) - *(_DWORD *)a2];
          *(_DWORD *)a2 = v17;
          *(_DWORD *)(a2 + 4) = v16;
          *(_DWORD *)(a2 + 8) = v75;
          a1[13] = v123;
          return sub_46C480(a1, (_DWORD *)a2, -3);
        }
        v4 = 0;
        a1[1] = (unsigned __int16)v15;
        v109 = 0;
        if ( (_WORD)v15 )
        {
          *a1 = 2;
          continue;
        }
LABEL_47:
        *a1 = a1[6] != 0 ? 7 : 0;
        continue;
      case 2:
        v19 = v108;
        if ( !v108 )
        {
          a1[8] = v109;
          a1[7] = v4;
          v76 = *(_DWORD *)(a2 + 8);
          v77 = &v107[-*(_DWORD *)a2];
          *(_DWORD *)a2 = v107;
          *(_DWORD *)(a2 + 4) = 0;
          *(_DWORD *)(a2 + 8) = &v77[v76];
          a1[13] = v123;
          return sub_46C480(a1, (_DWORD *)a2, a3);
        }
        v20 = v114;
        if ( v114 )
          goto LABEL_42;
        v21 = (char *)a1[11];
        v22 = v123;
        if ( v123 == v21 )
        {
          v23 = a1[12];
          v24 = a1[10];
          if ( v23 != v24 )
          {
            v22 = (char *)a1[10];
            v123 = v22;
            v20 = (unsigned int)(v24 >= v23 ? &v21[-v24] : v23 - v24 - 1);
            v114 = v20;
            if ( v20 )
              goto LABEL_42;
          }
        }
        a1[13] = v22;
        v25 = sub_46C480(a1, (_DWORD *)a2, a3);
        v26 = (char *)a1[13];
        v27 = a1[12];
        v124 = v25;
        v123 = v26;
        if ( (unsigned int)v26 >= v27 )
          v20 = a1[11] - (_DWORD)v26;
        else
          v20 = v27 - (_DWORD)v26 - 1;
        v28 = a1[11];
        v114 = v20;
        v115 = v28;
        if ( v26 == (char *)v28 )
        {
          v29 = a1[10];
          if ( v27 != v29 )
          {
            v26 = (char *)a1[10];
            v123 = v26;
            if ( v29 >= v27 )
              v20 = v115 - v29;
            else
              v20 = v27 - v29 - 1;
            v114 = v20;
          }
        }
        if ( !v20 )
        {
          a1[8] = v109;
          a1[7] = v4;
          v78 = *(unsigned __int8 **)a2;
          v79 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 4) = v108;
          *(_DWORD *)a2 = v107;
          *(_DWORD *)(a2 + 8) = v107 - v78 + v79;
          a1[13] = v26;
          return sub_46C480(a1, (_DWORD *)a2, v124);
        }
        v19 = v108;
LABEL_42:
        v30 = a1[1];
        a3 = 0;
        if ( v30 > v19 )
          v30 = v19;
        if ( v30 > v20 )
          v30 = v20;
        qmemcpy(v123, v107, v30);
        v107 += v30;
        v31 = a1[1] - v30;
        v108 -= v30;
        v123 += v30;
        v114 -= v30;
        a1[1] = v31;
        if ( !v31 )
          goto LABEL_47;
        continue;
      case 3:
        v32 = v109;
        if ( v4 >= 0xE )
          goto LABEL_52;
        v33 = v108;
        v34 = v107;
        do
        {
          if ( !v33 )
          {
            a1[8] = v32;
            a1[7] = v4;
            v80 = *(unsigned __int8 **)a2;
            v81 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)a2 = v107;
            *(_DWORD *)(a2 + 4) = 0;
            *(_DWORD *)(a2 + 8) = v107 - v80 + v81;
            a1[13] = v123;
            return sub_46C480(a1, (_DWORD *)a2, a3);
          }
          --v33;
          a3 = 0;
          v35 = *v34 << v4;
          v4 += 8;
          v108 = v33;
          v32 |= v35;
          v107 = ++v34;
        }
        while ( v4 < 0xE );
LABEL_52:
        v36 = v32 & 0x3FFF;
        a1[1] = v36;
        v37 = v32 & 0x1F;
        if ( v37 > 0x1D || (v32 & 0x3E0) > 0x3A0 )
        {
          *a1 = 9;
          *(_DWORD *)(a2 + 24) = aTooManyLengthO;
          a1[8] = v32;
          a1[7] = v4;
          v84 = *(unsigned __int8 **)a2;
          v85 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 4) = v108;
          *(_DWORD *)a2 = v107;
          *(_DWORD *)(a2 + 8) = v107 - v84 + v85;
          a1[13] = v123;
          return sub_46C480(a1, (_DWORD *)a2, -3);
        }
        v38 = a2;
        v39 = (*(int (__cdecl **)(_DWORD, unsigned int, int))(a2 + 32))(
                *(_DWORD *)(a2 + 40),
                ((v36 >> 5) & 0x1F) + v37 + 258,
                4);
        a1[3] = v39;
        if ( !v39 )
        {
          a1[8] = v32;
          a1[7] = v4;
          v82 = *(unsigned __int8 **)a2;
          v83 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 4) = v108;
          *(_DWORD *)a2 = v107;
          *(_DWORD *)(a2 + 8) = v107 - v82 + v83;
          a1[13] = v123;
          return sub_46C480(a1, (_DWORD *)a2, -4);
        }
        v40 = v32 >> 14;
        v4 -= 14;
        a1[2] = 0;
        *a1 = 4;
LABEL_57:
        if ( a1[2] < (unsigned int)((a1[1] >> 10) + 4) )
        {
          while ( v4 >= 3 )
          {
LABEL_62:
            v43 = v40 & 7;
            v4 -= 3;
            v40 >>= 3;
            *(_DWORD *)(a1[3] + 4 * dword_4AE738[a1[2]]) = v43;
            v44 = a1[2] + 1;
            a1[2] = v44;
            if ( v44 >= (a1[1] >> 10) + 4 )
              goto LABEL_63;
          }
          v41 = v107;
          while ( v108 )
          {
            --v108;
            v42 = v4;
            v4 += 8;
            a3 = 0;
            v40 |= *v41++ << v42;
            v107 = v41;
            if ( v4 >= 3 )
              goto LABEL_62;
          }
          goto LABEL_110;
        }
LABEL_63:
        if ( a1[2] < 0x13u )
        {
          do
          {
            *(_DWORD *)(a1[3] + 4 * dword_4AE738[a1[2]]) = 0;
            v45 = a1[2] + 1;
            a1[2] = v45;
          }
          while ( v45 < 0x13 );
        }
        v105 = a1[9];
        v104 = (int *)a1[3];
        a1[4] = 7;
        v110 = sub_46BD50(v104, a1 + 4, a1 + 5, v105, v38);
        if ( v110 )
        {
          if ( v110 == -3 )
          {
            (*(void (__cdecl **)(_DWORD, _DWORD))(v38 + 36))(*(_DWORD *)(v38 + 40), a1[3]);
            *a1 = 9;
          }
          a1[8] = v40;
          a1[7] = v4;
          v86 = *(unsigned __int8 **)v38;
          *(_DWORD *)(v38 + 4) = v108;
          v87 = *(_DWORD *)(v38 + 8);
          *(_DWORD *)v38 = v107;
          *(_DWORD *)(v38 + 8) = v107 - v86 + v87;
          a1[13] = v123;
          result = sub_46C480(a1, (_DWORD *)v38, v110);
        }
        else
        {
          a1[2] = 0;
          *a1 = 5;
LABEL_68:
          if ( a1[2] < ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
          {
            while ( 1 )
            {
              v46 = a1[4];
              if ( v4 < v46 )
                break;
LABEL_72:
              v48 = a1[5];
              v49 = v40 & dword_4B9C40[v46];
              v50 = *(unsigned __int8 *)(v48 + 8 * v49 + 1);
              v111 = v50;
              v51 = *(_DWORD *)(v48 + 8 * v49 + 4);
              v120 = v51;
              if ( v51 >= 0x10 )
              {
                v53 = 7;
                if ( v51 != 18 )
                  v53 = v51 - 14;
                v114 = v53;
                v54 = -(v51 != 18);
                LOBYTE(v54) = v54 & 0xF8;
                v115 = v50 + v53;
                v55 = v54 + 11;
                if ( v4 < v50 + v53 )
                {
                  while ( v108 )
                  {
                    a3 = 0;
                    --v108;
                    v56 = *v107 << v4;
                    v4 += 8;
                    v40 |= v56;
                    ++v107;
                    if ( v4 >= v115 )
                    {
                      v50 = v111;
                      goto LABEL_80;
                    }
                  }
                  goto LABEL_110;
                }
LABEL_80:
                v57 = v40 >> v50;
                v58 = (v57 & dword_4B9C40[v114]) + v55;
                v40 = v57 >> v114;
                v112 = v58;
                v4 -= v50 + v114;
                v114 = a1[2];
                if ( v114 + v58 > ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
                  goto LABEL_111;
                if ( v120 == 16 )
                {
                  v52 = v114;
                  if ( !v114 )
                  {
LABEL_111:
                    (*(void (__cdecl **)(_DWORD, _DWORD))(v38 + 36))(*(_DWORD *)(v38 + 40), a1[3]);
                    *a1 = 9;
                    *(_DWORD *)(v38 + 24) = aInvalidBitLeng;
                    a1[8] = v40;
                    a1[7] = v4;
                    v90 = *(unsigned __int8 **)v38;
                    *(_DWORD *)(v38 + 4) = v108;
                    v91 = *(_DWORD *)(v38 + 8);
                    *(_DWORD *)v38 = v107;
                    *(_DWORD *)(v38 + 8) = v107 - v90 + v91;
                    a1[13] = v123;
                    return sub_46C480(a1, (_DWORD *)v38, -3);
                  }
                  v59 = *(_DWORD *)(a1[3] + 4 * v114 - 4);
                }
                else
                {
                  v52 = v114;
                  v59 = 0;
                }
                do
                {
                  ++v52;
                  *(_DWORD *)(a1[3] + 4 * v52 - 4) = v59;
                  --v112;
                }
                while ( v112 );
              }
              else
              {
                v4 -= v50;
                v40 >>= v50;
                *(_DWORD *)(a1[3] + 4 * a1[2]) = v51;
                v52 = a1[2] + 1;
              }
              a1[2] = v52;
              if ( a1[2] >= ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
                goto LABEL_87;
            }
            while ( v108 )
            {
              a3 = 0;
              --v108;
              v47 = *v107 << v4;
              v4 += 8;
              v40 |= v47;
              ++v107;
              if ( v4 >= v46 )
                goto LABEL_72;
            }
LABEL_110:
            a1[8] = v40;
            a1[7] = v4;
            v88 = *(_DWORD *)(v38 + 8);
            v89 = &v107[-*(_DWORD *)v38];
            *(_DWORD *)v38 = v107;
            *(_DWORD *)(v38 + 8) = &v89[v88];
            *(_DWORD *)(v38 + 4) = 0;
            a1[13] = v123;
            return sub_46C480(a1, (_DWORD *)v38, a3);
          }
LABEL_87:
          v60 = a1[1];
          v106 = a1[9];
          v103 = (int *)a1[3];
          a1[5] = 0;
          v115 = 9;
          v114 = 6;
          v113 = sub_46C2C0((v60 & 0x1F) + 257, ((v60 >> 5) & 0x1F) + 1, v103, &v115, &v114, &v122, &v121, v106, v38);
          if ( v113 )
          {
            if ( v113 == -3 )
            {
              (*(void (__cdecl **)(_DWORD, _DWORD))(v38 + 36))(*(_DWORD *)(v38 + 40), a1[3]);
              *a1 = 9;
            }
            a1[8] = v40;
            a1[7] = v4;
            v92 = *(unsigned __int8 **)v38;
            v93 = *(_DWORD *)(v38 + 8);
            *(_DWORD *)(v38 + 4) = v108;
            *(_DWORD *)v38 = v107;
            *(_DWORD *)(v38 + 8) = v107 - v92 + v93;
            a1[13] = v123;
            result = sub_46C480(a1, (_DWORD *)v38, v113);
          }
          else
          {
            v61 = sub_46B540(v115, v114, v122, v121, v38);
            if ( !v61 )
            {
              a1[8] = v40;
              a1[7] = v4;
              v94 = *(unsigned __int8 **)v38;
              *(_DWORD *)(v38 + 4) = v108;
              v95 = *(_DWORD *)(v38 + 8);
              *(_DWORD *)v38 = v107;
              *(_DWORD *)(v38 + 8) = v107 - v94 + v95;
              a1[13] = v123;
              return sub_46C480(a1, (_DWORD *)v38, -4);
            }
            a1[1] = v61;
            (*(void (__cdecl **)(_DWORD, _DWORD))(v38 + 36))(*(_DWORD *)(v38 + 40), a1[3]);
            *a1 = 6;
LABEL_91:
            a1[8] = v40;
            a1[7] = v4;
            v62 = *(unsigned __int8 **)v38;
            *(_DWORD *)(v38 + 4) = v108;
            v63 = *(_DWORD *)(v38 + 8);
            *(_DWORD *)v38 = v107;
            *(_DWORD *)(v38 + 8) = v107 - v62 + v63;
            a1[13] = v123;
            v64 = sub_46B580(a1, v38, a3);
            if ( v64 != 1 )
              return sub_46C480(a1, (_DWORD *)v38, v64);
            a3 = 0;
            sub_46BD30(a1[1], v38);
            v65 = (char *)a1[13];
            v66 = *(unsigned __int8 **)v38;
            v4 = a1[7];
            v109 = a1[8];
            v67 = a1[12];
            v107 = *(unsigned __int8 **)v38;
            v108 = *(_DWORD *)(v38 + 4);
            v123 = v65;
            if ( (unsigned int)v65 >= v67 )
              v68 = a1[11] - (_DWORD)v65;
            else
              v68 = v67 - (_DWORD)v65 - 1;
            v114 = v68;
            if ( !a1[6] )
            {
              *a1 = 0;
              continue;
            }
            *a1 = 7;
LABEL_118:
            a1[13] = v65;
            v64 = sub_46C480(a1, (_DWORD *)v38, a3);
            v96 = (char *)a1[13];
            if ( (char *)a1[12] != v96 )
            {
              a1[7] = v4;
              a1[8] = v109;
              v97 = *(unsigned __int8 **)v38;
              *(_DWORD *)(v38 + 4) = v108;
              *(_DWORD *)v38 = v66;
              *(_DWORD *)(v38 + 8) += v66 - v97;
              a1[13] = v96;
              return sub_46C480(a1, (_DWORD *)v38, v64);
            }
            *a1 = 8;
LABEL_123:
            a1[8] = v109;
            a1[7] = v4;
            v98 = *(unsigned __int8 **)v38;
            *(_DWORD *)(v38 + 4) = v108;
            *(_DWORD *)(v38 + 8) += v66 - v98;
            *(_DWORD *)v38 = v66;
            a1[13] = v96;
            result = sub_46C480(a1, (_DWORD *)v38, 1);
          }
        }
        return result;
      case 4:
        v40 = v109;
        v38 = a2;
        goto LABEL_57;
      case 5:
        v40 = v109;
        v38 = a2;
        goto LABEL_68;
      case 6:
        v40 = v109;
        v38 = a2;
        goto LABEL_91;
      case 7:
        v65 = v123;
        v66 = v107;
        v38 = a2;
        goto LABEL_118;
      case 8:
        v96 = v123;
        v66 = v107;
        v38 = a2;
        goto LABEL_123;
      case 9:
        a1[8] = v109;
        a1[7] = v4;
        v99 = *(unsigned __int8 **)a2;
        v100 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 4) = v108;
        *(_DWORD *)a2 = v107;
        *(_DWORD *)(a2 + 8) = v107 - v99 + v100;
        a1[13] = v123;
        return sub_46C480(a1, (_DWORD *)a2, -3);
      default:
        a1[8] = v109;
        a1[7] = v4;
        v101 = *(unsigned __int8 **)a2;
        v102 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 4) = v108;
        *(_DWORD *)a2 = v107;
        *(_DWORD *)(a2 + 8) = v107 - v101 + v102;
        a1[13] = v123;
        return sub_46C480(a1, (_DWORD *)a2, -2);
    }
  }
}

//----- (004696E0) --------------------------------------------------------
int __cdecl sub_4696E0(_DWORD *a1, int a2)
{
  sub_4688B0(a1, a2, 0);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[10]);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[9]);
  (*(void (__cdecl **)(_DWORD, _DWORD *))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

//----- (00469720) --------------------------------------------------------
int __cdecl sub_469720(int a1, const void *a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = a1;
  qmemcpy(*(void **)(a1 + 40), a2, a3);
  v4 = a3 + *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 52) = v4;
  *(_DWORD *)(a1 + 48) = v4;
  return result;
}

//----- (00469760) --------------------------------------------------------
BOOL __cdecl sub_469760(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (00469770) --------------------------------------------------------
int __cdecl sub_469770(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // ebx
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // edi
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( i = a3; i; v5 %= 0xFFF1u )
  {
    v8 = i;
    if ( i >= 0x15B0 )
      v8 = 5552;
    i -= v8;
    if ( v8 >= 16 )
    {
      v9 = (unsigned int)v8 >> 4;
      v8 += -16 * ((unsigned int)v8 >> 4);
      do
      {
        v10 = *v3;
        v3 += 16;
        v11 = v10 + v4;
        v12 = v11 + v5;
        v13 = *(v3 - 15) + v11;
        v14 = v13 + v12;
        v15 = *(v3 - 14) + v13;
        v16 = v15 + v14;
        v17 = *(v3 - 13) + v15;
        v18 = v17 + v16;
        v19 = *(v3 - 12) + v17;
        v20 = v19 + v18;
        v21 = *(v3 - 11) + v19;
        v22 = v21 + v20;
        v23 = *(v3 - 10) + v21;
        v24 = v23 + v22;
        v25 = *(v3 - 9) + v23;
        v26 = v25 + v24;
        v27 = *(v3 - 8) + v25;
        v28 = v27 + v26;
        v29 = *(v3 - 7) + v27;
        v30 = v29 + v28;
        v31 = *(v3 - 6) + v29;
        v32 = v31 + v30;
        v33 = *(v3 - 5) + v31;
        v34 = v33 + v32;
        v35 = *(v3 - 4) + v33;
        v36 = v35 + v34;
        v37 = *(v3 - 3) + v35;
        v38 = v37 + v36;
        v39 = *(v3 - 2) + v37;
        v40 = v39 + v38;
        v4 = *(v3 - 1) + v39;
        v5 = v4 + v40;
        --v9;
      }
      while ( v9 );
    }
    for ( ; v8; --v8 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

//----- (004698D0) --------------------------------------------------------
BOOL __cdecl sub_4698D0(int a1, int a2, int a3)
{
  return sub_46F804(a2, a3);
}

//----- (004698F0) --------------------------------------------------------
void __cdecl sub_4698F0(int a1, unsigned int a2)
{
  sub_46D360(a2);
}

//----- (00469900) --------------------------------------------------------
_WORD *__cdecl sub_469900(int a1)
{
  nullsub_11();
  *(_DWORD *)(a1 + 2832) = a1 + 140;
  *(_DWORD *)(a1 + 2856) = a1 + 2676;
  *(_DWORD *)(a1 + 2840) = &off_4B89D0;
  *(_DWORD *)(a1 + 2844) = a1 + 2432;
  *(_DWORD *)(a1 + 2852) = &off_4B89E8;
  *(_DWORD *)(a1 + 2864) = &unk_4B8A00;
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  return sub_469980(a1);
}
// 469970: using guessed type int nullsub_11(void);
// 4B89D0: using guessed type void *off_4B89D0;
// 4B89E8: using guessed type void *off_4B89E8;

//----- (00469980) --------------------------------------------------------
_WORD *__cdecl sub_469980(int a1)
{
  int v1; // ecx
  _WORD *v2; // eax
  _WORD *v3; // eax
  int v4; // ecx
  _WORD *result; // eax
  int v6; // ecx

  v1 = 286;
  v2 = (_WORD *)(a1 + 140);
  do
  {
    *v2 = 0;
    v2 += 2;
    --v1;
  }
  while ( v1 );
  v3 = (_WORD *)(a1 + 2432);
  v4 = 30;
  do
  {
    *v3 = 0;
    v3 += 2;
    --v4;
  }
  while ( v4 );
  result = (_WORD *)(a1 + 2676);
  v6 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v6;
  }
  while ( v6 );
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  return result;
}

//----- (004699F0) --------------------------------------------------------
_BYTE *__cdecl sub_4699F0(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // esi
  int v6; // ecx
  int v7; // edi
  int v8; // esi
  int v9; // esi

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 3;
  }
  else
  {
    v5 = a4 << v4;
    v6 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v6) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v7 + v8) = v6;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 13;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a4 >> (16 - v9);
  }
  return sub_46B4A0((_DWORD *)a1, a2, a3, 1);
}

//----- (00469A90) --------------------------------------------------------
int __cdecl sub_469A90(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  unsigned __int16 v10; // ax
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int result; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // eax
  int v24; // ecx
  int v25; // edx
  unsigned __int16 v26; // ax
  int v27; // edi
  int v28; // ecx
  int v29; // ebx
  int v30; // edi
  int v31; // edi

  v1 = *(_DWORD *)(a1 + 5812);
  if ( v1 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= 2 << v1;
    *(_DWORD *)(a1 + 5812) = v1 + 3;
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 20);
    v3 = 2 << v1;
    v4 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v3;
    *(_BYTE *)(v4 + v2) = *(_BYTE *)(a1 + 5808);
    v5 = *(_DWORD *)(a1 + 8);
    v6 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v6;
    *(_BYTE *)(v5 + v6) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    v7 = *(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 5812) = v7 - 13;
    *(_WORD *)(a1 + 5808) = 2u >> (16 - v7);
  }
  v8 = *(_DWORD *)(a1 + 5812);
  v9 = (unsigned __int16)word_4AECD2;
  if ( v8 <= 16 - (unsigned __int16)word_4AECD2 )
  {
    *(_WORD *)(a1 + 5808) |= *(_DWORD *)&word_4AECD0 << v8;
    *(_DWORD *)(a1 + 5812) = v9 + v8;
  }
  else
  {
    v10 = word_4AECD0;
    v11 = (unsigned __int16)word_4AECD0 << v8;
    v12 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v11;
    *(_BYTE *)(v12 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    LOBYTE(v12) = *(_BYTE *)(a1 + 5809);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v13 + v14) = v12;
    v15 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v15 + v9 - 16;
    *(_WORD *)(a1 + 5808) = v10 >> (16 - v15);
  }
  result = sub_46B390(a1);
  v17 = *(_DWORD *)(a1 + 5812);
  if ( *(_DWORD *)(a1 + 5804) - v17 + 11 < 9 )
  {
    if ( v17 <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= 2 << v17;
      *(_DWORD *)(a1 + 5812) = v17 + 3;
    }
    else
    {
      v18 = *(_DWORD *)(a1 + 20);
      v19 = 2 << v17;
      v20 = *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 5808) |= v19;
      *(_BYTE *)(v20 + v18) = *(_BYTE *)(a1 + 5808);
      v21 = *(_DWORD *)(a1 + 8);
      v22 = *(_DWORD *)(a1 + 20) + 1;
      *(_DWORD *)(a1 + 20) = v22;
      *(_BYTE *)(v21 + v22) = *(_BYTE *)(a1 + 5809);
      ++*(_DWORD *)(a1 + 20);
      v23 = *(_DWORD *)(a1 + 5812);
      *(_DWORD *)(a1 + 5812) = v23 - 13;
      *(_WORD *)(a1 + 5808) = 2u >> (16 - v23);
    }
    v24 = *(_DWORD *)(a1 + 5812);
    v25 = (unsigned __int16)word_4AECD2;
    if ( v24 <= 16 - (unsigned __int16)word_4AECD2 )
    {
      *(_WORD *)(a1 + 5808) |= *(_DWORD *)&word_4AECD0 << v24;
      *(_DWORD *)(a1 + 5812) = v25 + v24;
    }
    else
    {
      v26 = word_4AECD0;
      v27 = (unsigned __int16)word_4AECD0 << v24;
      v28 = *(_DWORD *)(a1 + 8);
      *(_WORD *)(a1 + 5808) |= v27;
      *(_BYTE *)(v28 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
      v29 = *(_DWORD *)(a1 + 8);
      LOBYTE(v28) = *(_BYTE *)(a1 + 5809);
      v30 = *(_DWORD *)(a1 + 20) + 1;
      *(_DWORD *)(a1 + 20) = v30;
      *(_BYTE *)(v29 + v30) = v28;
      v31 = *(_DWORD *)(a1 + 5812);
      ++*(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 5812) = v31 + v25 - 16;
      *(_WORD *)(a1 + 5808) = v26 >> (16 - v31);
    }
    result = sub_46B390(a1);
  }
  *(_DWORD *)(a1 + 5804) = 7;
  return result;
}
// 4AECD0: using guessed type __int16 word_4AECD0;
// 4AECD2: using guessed type __int16 word_4AECD2;

//----- (00469CF0) --------------------------------------------------------
_WORD *__cdecl sub_469CF0(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // edi
  bool v8; // zf
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // ebp
  int v18; // ebp
  int v19; // ebx
  int v20; // ebx
  _WORD *result; // eax

  v4 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v6 = a3 + 5;
LABEL_7:
    v5 = v6;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 + 28) == 2 )
    sub_46B2F0(a1);
  sub_469EE0((_DWORD *)a1, (int *)(a1 + 2832));
  sub_469EE0((_DWORD *)a1, (int *)(a1 + 2844));
  v4 = sub_46A4B0(a1);
  v5 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
  v6 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  if ( v6 <= v5 )
    goto LABEL_7;
LABEL_8:
  if ( a3 + 4 <= v5 && a2 )
  {
    v7 = a4;
    sub_4699F0(a1, a2, a3, a4);
  }
  else
  {
    v8 = v6 == v5;
    v9 = *(_DWORD *)(a1 + 5812);
    if ( v8 )
    {
      v7 = a4;
      v10 = a4 + 2;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v10 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v11 = v10 << v9;
        v12 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
        v13 = *(_DWORD *)(a1 + 8);
        v14 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v14;
        *(_BYTE *)(v13 + v14) = *(_BYTE *)(a1 + 5809);
        v15 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v15 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v10 >> (16 - v15);
      }
      sub_46AEB0(a1, (int)&unk_4AE8D0, (int)&unk_4AED50);
    }
    else
    {
      v7 = a4;
      v16 = a4 + 4;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v17 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_BYTE *)(*(_DWORD *)(a1 + 20) + v17) = *(_BYTE *)(a1 + 5808);
        v18 = *(_DWORD *)(a1 + 8);
        v19 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v19;
        *(_BYTE *)(v19 + v18) = *(_BYTE *)(a1 + 5809);
        v20 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v20 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v16 >> (16 - v20);
      }
      sub_46A610(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v4 + 1);
      sub_46AEB0(a1, a1 + 140, a1 + 2432);
    }
  }
  result = sub_469980(a1);
  if ( v7 )
    result = (_WORD *)sub_46B420(a1);
  return result;
}

//----- (00469EE0) --------------------------------------------------------
unsigned int __cdecl sub_469EE0(_DWORD *a1, int *a2)
{
  _WORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // ebx
  int v7; // ecx
  int v8; // eax
  _WORD *v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int i; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // ebp
  int v18; // edx
  int v19; // ecx
  char v20; // al
  int v21; // ecx
  int v22; // edx
  int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]
  _WORD *v26; // [esp+1Ch] [ebp+4h]

  v3 = (_WORD *)*a2;
  v4 = (int *)a2[2];
  v5 = -1;
  v6 = *v4;
  v7 = v4[3];
  v8 = 0;
  v25 = v7;
  v24 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  if ( v7 > 0 )
  {
    v9 = v3;
    do
    {
      if ( *v9 )
      {
        v24 = v8;
        v10 = a1[1298] + 1;
        v5 = v8;
        a1[1298] = v10;
        a1[v10 + 725] = v8;
        *((_BYTE *)a1 + v8 + 5200) = 0;
      }
      else
      {
        v9[1] = 0;
      }
      ++v8;
      v9 += 2;
    }
    while ( v8 < v25 );
  }
  v11 = a1[1298];
  if ( v11 < 2 )
  {
    do
    {
      if ( v5 >= 2 )
        v12 = 0;
      else
        v12 = ++v5;
      v13 = v11 + 1;
      a1[1298] = v13;
      a1[v13 + 725] = v12;
      v3[2 * v12] = 1;
      *((_BYTE *)a1 + v12 + 5200) = 0;
      --a1[1448];
      if ( v6 )
        a1[1449] -= *(unsigned __int16 *)(v6 + 4 * v12 + 2);
      v11 = a1[1298];
    }
    while ( v11 < 2 );
    v24 = v5;
  }
  a2[1] = v5;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_46A120((int)a1, (int)v3, i);
  v26 = &v3[2 * v25];
  do
  {
    v15 = a1[1298];
    v16 = a1[726];
    a1[726] = a1[v15 + 725];
    a1[1298] = v15 - 1;
    sub_46A120((int)a1, (int)v3, 1);
    v17 = a1[726];
    v18 = a1[1299] - 1;
    a1[1299] = v18;
    a1[v18 + 725] = v16;
    v19 = a1[1299] - 1;
    a1[1299] = v19;
    a1[v19 + 725] = v17;
    *v26 = v3[2 * v16] + v3[2 * v17];
    if ( *((_BYTE *)a1 + v16 + 5200) < *((_BYTE *)a1 + v17 + 5200) )
      v20 = *((_BYTE *)a1 + v17 + 5200);
    else
      v20 = *((_BYTE *)a1 + v16 + 5200);
    *((_BYTE *)a1 + v25 + 5200) = v20 + 1;
    v3[2 * v17 + 1] = v25;
    v3[2 * v16 + 1] = v25;
    a1[726] = v25++;
    v26 += 2;
    sub_46A120((int)a1, (int)v3, 1);
  }
  while ( (int)a1[1298] >= 2 );
  v21 = a1[726];
  v22 = a1[1299] - 1;
  a1[1299] = v22;
  a1[v22 + 725] = v21;
  sub_46A200(a1, a2);
  return sub_46A430(v3, v24, (int)(a1 + 717));
}

//----- (0046A120) --------------------------------------------------------
int __cdecl sub_46A120(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // ecx
  bool v7; // cc
  int v8; // esi
  int v9; // ebp
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // bx
  int v12; // esi
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // bx
  int v15; // edx
  int v16; // edx
  int v17; // [esp+14h] [ebp+4h]

  result = a1;
  v4 = *(_DWORD *)(a1 + 5192);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  v6 = 2 * a3;
  v7 = 2 * a3 < v4;
  v17 = v5;
  if ( 2 * a3 > v4 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  else
  {
    while ( 1 )
    {
      if ( v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v6 + 2904);
        v9 = *(_DWORD *)(result + 4 * v6 + 2900);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 5200) <= *(_BYTE *)(result + v9 + 5200) )
          ++v6;
        v5 = v17;
      }
      v12 = *(_DWORD *)(result + 4 * v6 + 2900);
      v13 = *(_WORD *)(a2 + 4 * v5);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v5;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v5 + 5200) <= *(_BYTE *)(v12 + result + 5200) )
        break;
      v15 = a3;
      a3 = v6;
      v6 *= 2;
      *(_DWORD *)(result + 4 * v15 + 2900) = v12;
      v16 = *(_DWORD *)(result + 5192);
      v7 = v6 < v16;
      if ( v6 > v16 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  return result;
}

//----- (0046A200) --------------------------------------------------------
__int16 __cdecl sub_46A200(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int *v3; // eax
  int v4; // ebp
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // edi
  int v13; // esi
  bool v14; // zf
  int v15; // edi
  _WORD *i; // ecx
  int v17; // edi
  _WORD *v18; // ebp
  int v19; // ebp
  int v20; // ecx
  _WORD *v21; // esi
  int v22; // eax
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  _WORD *v27; // [esp+18h] [ebp-14h]
  int v28; // [esp+1Ch] [ebp-10h]
  int v29; // [esp+20h] [ebp-Ch]
  int v30; // [esp+24h] [ebp-8h]
  int v31; // [esp+28h] [ebp-4h]
  int *v32; // [esp+30h] [ebp+4h]
  int v33; // [esp+30h] [ebp+4h]
  int v34; // [esp+34h] [ebp+8h]

  v2 = *a2;
  v3 = (int *)a2[2];
  v28 = a2[1];
  v4 = v3[4];
  v25 = *v3;
  v30 = v3[1];
  v29 = v3[2];
  v24 = 0;
  memset(a1 + 717, 0, 0x20u);
  v6 = a1[1299];
  v31 = v4;
  *(_WORD *)(v2 + 4 * a1[v6 + 725] + 2) = 0;
  v7 = a1[1299] + 1;
  if ( v7 < 573 )
  {
    v32 = &a1[v7 + 725];
    v8 = 573 - v7;
    v9 = 573;
    v26 = v8;
    v34 = 573;
    do
    {
      v10 = *v32;
      v11 = *(unsigned __int16 *)(v2 + 4 * *(unsigned __int16 *)(v2 + 4 * *v32 + 2) + 2) + 1;
      if ( v11 > v4 )
      {
        v11 = v4;
        ++v24;
      }
      *(_WORD *)(v2 + 4 * v10 + 2) = v11;
      if ( v10 <= v28 )
      {
        ++*((_WORD *)a1 + v11 + 1434);
        v12 = 0;
        if ( v10 >= v29 )
          v12 = *(_DWORD *)(v30 + 4 * (v10 - v29));
        v13 = *(unsigned __int16 *)(v2 + 4 * v10);
        a1[1448] += v13 * (v12 + v11);
        if ( v25 )
        {
          v4 = v31;
          a1[1449] += v13 * (v12 + *(unsigned __int16 *)(v25 + 4 * v10 + 2));
        }
        v9 = 573;
      }
      LOWORD(v6) = v26 - 1;
      v14 = v26 == 1;
      ++v32;
      --v26;
    }
    while ( !v14 );
    v15 = v24;
    if ( v24 )
    {
      do
      {
        v6 = v4 - 1;
        for ( i = (_WORD *)a1 + v4 + 1433; !*i; --v6 )
          --i;
        --*((_WORD *)a1 + v6 + 1434);
        *((_WORD *)a1 + v6 + 1435) += 2;
        --*((_WORD *)a1 + v4 + 1434);
        v15 -= 2;
      }
      while ( v15 > 0 );
      v17 = v4;
      if ( v4 )
      {
        v18 = (_WORD *)a1 + v4 + 1434;
        v27 = v18;
        do
        {
          v6 = (unsigned __int16)*v18;
          v33 = v6;
          if ( *v18 )
          {
            v19 = (int)&a1[v9 + 725];
            do
            {
              v20 = *(_DWORD *)(v19 - 4);
              v19 -= 4;
              --v34;
              if ( v20 <= v28 )
              {
                v21 = (_WORD *)(v2 + 4 * v20 + 2);
                HIWORD(v22) = 0;
                if ( (unsigned __int16)*v21 != v17 )
                {
                  LOWORD(v22) = *v21;
                  a1[1448] += *(unsigned __int16 *)(v2 + 4 * v20) * (v17 - v22);
                  *v21 = v17;
                }
                v6 = --v33;
              }
            }
            while ( v6 );
            v9 = v34;
          }
          --v17;
          v18 = --v27;
        }
        while ( v17 );
      }
    }
  }
  return v6;
}

//----- (0046A430) --------------------------------------------------------
unsigned int __cdecl sub_46A430(_WORD *a1, int a2, int a3)
{
  __int16 v3; // ax
  char *v4; // ecx
  int v5; // esi
  __int16 v6; // di
  unsigned int result; // eax
  int v9; // edi
  int v10; // ecx
  unsigned __int16 v11; // dx
  __int16 v12; // [esp+8h] [ebp-20h]
  char v13[30]; // [esp+Ah] [ebp-1Eh] BYREF

  v3 = 0;
  v4 = v13;
  v5 = 15;
  do
  {
    v6 = *(_WORD *)&v4[a3 - (_DWORD)v13];
    v4 += 2;
    v3 = 2 * (v3 + v6);
    --v5;
    *((_WORD *)v4 - 1) = v3;
  }
  while ( v5 );
  result = a2;
  if ( a2 >= 0 )
  {
    v9 = a2 + 1;
    do
    {
      v10 = (unsigned __int16)a1[1];
      if ( (_WORD)v10 )
      {
        v11 = *(&v12 + v10);
        *(&v12 + v10) = v11 + 1;
        result = sub_46B370(v11, v10);
        *a1 = result;
      }
      a1 += 2;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (0046A4B0) --------------------------------------------------------
int __cdecl sub_46A4B0(int a1)
{
  int result; // eax

  sub_46A520((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_46A520((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_469EE0((_DWORD *)a1, (int *)(a1 + 2856));
  for ( result = 18; result >= 3; --result )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_4AE8BC[result] + 2678) )
      break;
  }
  *(_DWORD *)(a1 + 5792) += 3 * result + 17;
  return result;
}

//----- (0046A520) --------------------------------------------------------
int __cdecl sub_46A520(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned __int16 *v8; // ebp
  int v9; // eax
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+18h] [ebp+8h]

  result = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = 0;
  v10 = -1;
  v6 = 7;
  v7 = 4;
  if ( !(_WORD)v4 )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  if ( a3 >= 0 )
  {
    v11 = a3 + 1;
    v8 = (unsigned __int16 *)(result + 6);
    do
    {
      v9 = v4;
      v4 = *v8;
      if ( ++v5 >= v6 || v9 != v4 )
      {
        if ( v5 >= v7 )
        {
          if ( v9 )
          {
            if ( v9 != v10 )
              ++a1[2 * v9 + 1338];
            ++a1[1370];
          }
          else if ( v5 > 10 )
          {
            ++a1[1374];
          }
          else
          {
            ++a1[1372];
          }
        }
        else
        {
          a1[2 * v9 + 1338] += v5;
        }
        v5 = 0;
        v10 = v9;
        if ( v4 )
        {
          if ( v9 == v4 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v8 += 2;
      result = --v11;
    }
    while ( v11 );
  }
  return result;
}

//----- (0046A610) --------------------------------------------------------
int __cdecl sub_46A610(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // edi
  int v21; // edx
  int v22; // edx
  int i; // edi
  int v24; // ecx
  unsigned __int16 v25; // ax
  int v26; // edx
  int v27; // ecx
  int v28; // ebx
  int v29; // edx
  int v30; // edx

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 5;
  }
  else
  {
    v5 = (a2 - 257) << v4;
    v6 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v5) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v8 + v7) = v5;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a2 - 257) >> (16 - v9);
  }
  v10 = *(_DWORD *)(a1 + 5812);
  if ( v10 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << v10;
    *(_DWORD *)(a1 + 5812) = v10 + 5;
  }
  else
  {
    v11 = (a3 - 1) << v10;
    v12 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v11;
    *(_BYTE *)(v12 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    LOBYTE(v11) = *(_BYTE *)(a1 + 5809);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v14 + v13) = v11;
    v15 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v15 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a3 - 1) >> (16 - v15);
  }
  v16 = *(_DWORD *)(a1 + 5812);
  v17 = a4 - 4;
  if ( v16 <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= v17 << v16;
    *(_DWORD *)(a1 + 5812) = v16 + 4;
  }
  else
  {
    v18 = v17 << v16;
    v19 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v18;
    *(_BYTE *)(v19 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v20 = *(_DWORD *)(a1 + 8);
    v21 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v21;
    *(_BYTE *)(v21 + v20) = *(_BYTE *)(a1 + 5809);
    v22 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v22 - 12;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)v17 >> (16 - v22);
  }
  for ( i = 0; i < a4; ++i )
  {
    v24 = *(_DWORD *)(a1 + 5812);
    if ( v24 <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * (unsigned __int8)byte_4AE8BC[i] + 2678) << v24;
      *(_DWORD *)(a1 + 5812) = v24 + 3;
    }
    else
    {
      v25 = *(_WORD *)(a1 + 4 * (unsigned __int8)byte_4AE8BC[i] + 2678);
      v26 = v25 << v24;
      v27 = *(_DWORD *)(a1 + 20);
      *(_WORD *)(a1 + 5808) |= v26;
      *(_BYTE *)(v27 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
      v28 = *(_DWORD *)(a1 + 8);
      v29 = *(_DWORD *)(a1 + 20) + 1;
      *(_DWORD *)(a1 + 20) = v29;
      *(_BYTE *)(v29 + v28) = *(_BYTE *)(a1 + 5809);
      v30 = *(_DWORD *)(a1 + 5812);
      ++*(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 5812) = v30 - 13;
      *(_WORD *)(a1 + 5808) = v25 >> (16 - v30);
    }
  }
  sub_46A880(a1, a1 + 140, a2 - 1);
  return sub_46A880(a1, a1 + 2432, a3 - 1);
}

//----- (0046A880) --------------------------------------------------------
int __cdecl sub_46A880(int a1, unsigned int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // ebx
  int v28; // edi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // esi
  int v36; // ecx
  int v37; // ecx
  int v38; // esi
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // edi
  int v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // esi
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // ebx
  int v55; // edi
  int v56; // edi
  int v57; // ecx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // esi
  bool v63; // zf
  int v65; // [esp+Ch] [ebp-8h]
  int v66; // [esp+10h] [ebp-4h]
  int v67; // [esp+18h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+8h]
  unsigned __int16 *v69; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v65 = -1;
  v5 = 7;
  v6 = 4;
  if ( !(_WORD)v4 )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v7 = a3 + 1;
    v69 = (unsigned __int16 *)(a2 + 6);
    LODWORD(v3) = a1;
    v66 = v7;
    do
    {
      v8 = v4;
      ++HIDWORD(v3);
      v4 = *v69;
      v67 = v4;
      v68 = HIDWORD(v3);
      if ( SHIDWORD(v3) < v5 && v8 == v4 )
        goto LABEL_44;
      if ( SHIDWORD(v3) < v6 )
      {
        do
        {
          v9 = *(_DWORD *)(v3 + 5812);
          v10 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v9 <= 16 - (unsigned __int16)v10 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v9;
            *(_DWORD *)(v3 + 5812) = v10 + v9;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v11 = WORD2(v3) << v9;
            v12 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v11;
            *(_BYTE *)(v12 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v13 = *(_DWORD *)(v3 + 8);
            LOBYTE(v12) = *(_BYTE *)(v3 + 5809);
            v14 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v14;
            *(_BYTE *)(v14 + v13) = v12;
            v15 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v15);
            *(_DWORD *)(v3 + 5812) = v15 + v10 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        while ( HIDWORD(v3) );
        goto LABEL_39;
      }
      if ( v8 )
      {
        if ( v8 != v65 )
        {
          v16 = *(_DWORD *)(v3 + 5812);
          v17 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v16 <= 16 - (unsigned __int16)v17 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v16;
            *(_DWORD *)(v3 + 5812) = v17 + v16;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v18 = WORD2(v3) << v16;
            v19 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v18;
            *(_BYTE *)(v19 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v20 = *(_DWORD *)(v3 + 8);
            LOBYTE(v19) = *(_BYTE *)(v3 + 5809);
            v21 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v21;
            *(_BYTE *)(v21 + v20) = v19;
            v22 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v22);
            *(_DWORD *)(v3 + 5812) = v22 + v17 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        v23 = *(_DWORD *)(v3 + 5812);
        v24 = *(unsigned __int16 *)(v3 + 2742);
        if ( v23 <= 16 - (unsigned __int16)v24 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2740) << v23;
          *(_DWORD *)(v3 + 5812) = v24 + v23;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2740);
          v25 = WORD2(v3) << v23;
          v26 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v25;
          *(_BYTE *)(v26 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v27 = *(_DWORD *)(v3 + 8);
          LOBYTE(v26) = *(_BYTE *)(v3 + 5809);
          v28 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v28;
          *(_BYTE *)(v28 + v27) = v26;
          v29 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v29);
          *(_DWORD *)(v3 + 5812) = v29 + v24 - 16;
          HIDWORD(v3) = v68;
        }
        v30 = *(_DWORD *)(v3 + 5812);
        if ( v30 > 14 )
        {
          HIDWORD(v3) -= 3;
          v31 = HIDWORD(v3) << v30;
          v32 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v31;
          *(_BYTE *)(v32 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v33 = *(_DWORD *)(v3 + 8);
          LOBYTE(v32) = *(_BYTE *)(v3 + 5809);
          v34 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v34;
          *(_BYTE *)(v34 + v33) = v32;
          v35 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v35 - 14;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v35);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v30;
        v36 = v30 + 2;
      }
      else if ( SHIDWORD(v3) > 10 )
      {
        v50 = *(_DWORD *)(v3 + 5812);
        v51 = *(unsigned __int16 *)(v3 + 2750);
        if ( v50 <= 16 - (unsigned __int16)v51 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2748) << v50;
          *(_DWORD *)(v3 + 5812) = v51 + v50;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2748);
          v52 = WORD2(v3) << v50;
          v53 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v52;
          *(_BYTE *)(v53 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v54 = *(_DWORD *)(v3 + 8);
          LOBYTE(v53) = *(_BYTE *)(v3 + 5809);
          v55 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v55;
          *(_BYTE *)(v55 + v54) = v53;
          v56 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v56);
          *(_DWORD *)(v3 + 5812) = v56 + v51 - 16;
          HIDWORD(v3) = v68;
        }
        v57 = *(_DWORD *)(v3 + 5812);
        if ( v57 > 9 )
        {
          HIDWORD(v3) -= 11;
          v58 = HIDWORD(v3) << v57;
          v59 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v58;
          *(_BYTE *)(v59 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v60 = *(_DWORD *)(v3 + 8);
          LOBYTE(v59) = *(_BYTE *)(v3 + 5809);
          v61 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v61;
          *(_BYTE *)(v61 + v60) = v59;
          v62 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v62 - 9;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v62);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 11) << v57;
        v36 = v57 + 7;
      }
      else
      {
        v37 = *(_DWORD *)(v3 + 5812);
        v38 = *(unsigned __int16 *)(v3 + 2746);
        if ( v37 <= 16 - (unsigned __int16)v38 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2744) << v37;
          *(_DWORD *)(v3 + 5812) = v38 + v37;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2744);
          v39 = WORD2(v3) << v37;
          v40 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v39;
          *(_BYTE *)(v40 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v41 = *(_DWORD *)(v3 + 8);
          LOBYTE(v40) = *(_BYTE *)(v3 + 5809);
          v42 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v42;
          *(_BYTE *)(v42 + v41) = v40;
          v43 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v43);
          *(_DWORD *)(v3 + 5812) = v43 + v38 - 16;
          HIDWORD(v3) = v68;
        }
        v44 = *(_DWORD *)(v3 + 5812);
        if ( v44 > 13 )
        {
          HIDWORD(v3) -= 3;
          v45 = HIDWORD(v3) << v44;
          v46 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v45;
          *(_BYTE *)(v46 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v47 = *(_DWORD *)(v3 + 8);
          LOBYTE(v46) = *(_BYTE *)(v3 + 5809);
          v48 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v48;
          *(_BYTE *)(v48 + v47) = v46;
          v49 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v49 - 13;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v49);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v44;
        v36 = v44 + 3;
      }
      *(_DWORD *)(v3 + 5812) = v36;
LABEL_39:
      v4 = v67;
      HIDWORD(v3) = 0;
      v65 = v8;
      if ( v67 )
      {
        if ( v8 == v67 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v63 = v66 == 1;
      v69 += 2;
      --v66;
    }
    while ( !v63 );
  }
  return v3;
}

//----- (0046AEB0) --------------------------------------------------------
int __cdecl sub_46AEB0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // si
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // ebp
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  __int16 v24; // si
  int v25; // ecx
  __int16 v26; // bp
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // ebp
  int v32; // ebx
  char v33; // cl
  int v34; // ebx
  unsigned int v35; // edi
  int v36; // ebx
  int v37; // ecx
  int v38; // esi
  unsigned __int16 v39; // dx
  int v40; // ebp
  int v41; // ebx
  char v42; // cl
  int v43; // ebx
  int v44; // edx
  int v45; // edx
  unsigned int v46; // edi
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // ecx
  int v50; // ebx
  int v51; // esi
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  unsigned __int16 v55; // dx
  int v56; // edi
  int v57; // ecx
  int v58; // ebx
  int v59; // edi
  int v60; // edi
  int v61; // [esp+10h] [ebp-8h]
  unsigned int v62; // [esp+14h] [ebp-4h]
  int v63; // [esp+1Ch] [ebp+4h]
  int v64; // [esp+1Ch] [ebp+4h]

  result = a1;
  v4 = 0;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    while ( 1 )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v7 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v62 = v4 + 1;
      if ( !(_WORD)v6 )
        break;
      v16 = *(_DWORD *)(result + 5812);
      v17 = (unsigned __int8)byte_4AEFC8[v7];
      v63 = v17;
      v18 = *(unsigned __int16 *)(v5 + 4 * v17 + 1030);
      v61 = (unsigned __int16)v18;
      if ( v16 <= 16 - (unsigned __int16)v18 )
      {
        v26 = *(_WORD *)(a2 + 4 * v17 + 1028) << v16;
        v27 = *(_DWORD *)(result + 5812);
        *(_WORD *)(result + 5808) |= v26;
        v25 = v18 + v27;
      }
      else
      {
        v19 = *(_WORD *)(a2 + 4 * v17 + 1028);
        v20 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v19 << v16;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v20) = *(_BYTE *)(result + 5808);
        v21 = *(_DWORD *)(result + 20) + 1;
        v22 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v21;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v21) = v22;
        v23 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v24 = v19 >> (16 - v23);
        v25 = v23 + v61 - 16;
        v17 = v63;
        *(_WORD *)(result + 5808) = v24;
      }
      *(_DWORD *)(result + 5812) = v25;
      v28 = dword_4AE784[v17];
      if ( v28 )
      {
        v29 = v7 - dword_4AF0C8[v17];
        v30 = *(_DWORD *)(result + 5812);
        if ( v30 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_DWORD *)(result + 5812) = v28 + v30;
        }
        else
        {
          v31 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_BYTE *)(*(_DWORD *)(result + 20) + v31) = *(_BYTE *)(result + 5808);
          v32 = *(_DWORD *)(result + 20) + 1;
          v33 = *(_BYTE *)(result + 5809);
          *(_DWORD *)(result + 20) = v32;
          *(_BYTE *)(*(_DWORD *)(result + 8) + v32) = v33;
          v34 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_WORD *)(result + 5808) = (unsigned __int16)v29 >> (16 - v34);
          *(_DWORD *)(result + 5812) = v34 + v28 - 16;
        }
      }
      v35 = v6 - 1;
      if ( v35 >= 0x100 )
        v36 = (unsigned __int8)byte_4AEEC8[v35 >> 7];
      else
        v36 = (unsigned __int8)byte_4AEDC8[v35];
      v37 = *(_DWORD *)(result + 5812);
      v38 = *(unsigned __int16 *)(a3 + 4 * v36 + 2);
      v64 = v36;
      if ( v37 <= 16 - (unsigned __int16)v38 )
      {
        v5 = a2;
        *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v36) << v37;
        *(_DWORD *)(result + 5812) = v38 + v37;
      }
      else
      {
        v39 = *(_WORD *)(a3 + 4 * v36);
        v40 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v39 << v37;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v40) = *(_BYTE *)(result + 5808);
        v41 = *(_DWORD *)(result + 20) + 1;
        v42 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v41;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v41) = v42;
        v43 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v5 = a2;
        *(_WORD *)(result + 5808) = v39 >> (16 - v43);
        v44 = v43 + v38 - 16;
        v36 = v64;
        *(_DWORD *)(result + 5812) = v44;
      }
      v45 = dword_4AE7F8[v36];
      if ( !v45 )
        goto LABEL_24;
      v46 = v35 - dword_4AF13C[v36];
      v47 = *(_DWORD *)(result + 5812);
      if ( v47 <= 16 - v45 )
      {
        *(_WORD *)(result + 5808) |= v46 << v47;
        v15 = v45 + v47;
LABEL_23:
        *(_DWORD *)(result + 5812) = v15;
        goto LABEL_24;
      }
      v48 = v46 << v47;
      v49 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v48;
      *(_BYTE *)(v49 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v50 = *(_DWORD *)(result + 8);
      LOBYTE(v49) = *(_BYTE *)(result + 5809);
      v51 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v51;
      *(_BYTE *)(v51 + v50) = v49;
      v52 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v52 + v45 - 16;
      *(_WORD *)(result + 5808) = (unsigned __int16)v46 >> (16 - v52);
LABEL_24:
      v4 = v62;
      if ( v62 >= *(_DWORD *)(result + 5784) )
        goto LABEL_25;
    }
    LOWORD(v6) = *(_WORD *)(v5 + 4 * v7 + 2);
    v8 = *(_DWORD *)(result + 5812);
    if ( v8 <= 16 - (unsigned __int16)v6 )
    {
      *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 4 * v7) << v8;
      v15 = v6 + v8;
    }
    else
    {
      v9 = *(_WORD *)(v5 + 4 * v7);
      v10 = v9 << v8;
      v11 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v10;
      *(_BYTE *)(v11 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v12 = *(_DWORD *)(result + 8);
      v13 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v13;
      *(_BYTE *)(v13 + v12) = *(_BYTE *)(result + 5809);
      v14 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      v15 = v14 + v6 - 16;
      *(_WORD *)(result + 5808) = v9 >> (16 - v14);
    }
    goto LABEL_23;
  }
LABEL_25:
  v53 = *(_DWORD *)(result + 5812);
  v54 = *(unsigned __int16 *)(v5 + 1026);
  if ( v53 <= 16 - (unsigned __int16)v54 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 1024) << v53;
    *(_DWORD *)(result + 5812) = v54 + v53;
  }
  else
  {
    v55 = *(_WORD *)(v5 + 1024);
    v56 = v55 << v53;
    v57 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v56;
    *(_BYTE *)(v57 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v58 = *(_DWORD *)(result + 8);
    LOBYTE(v57) = *(_BYTE *)(result + 5809);
    v59 = *(_DWORD *)(result + 20) + 1;
    *(_DWORD *)(result + 20) = v59;
    *(_BYTE *)(v59 + v58) = v57;
    v60 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = v55 >> (16 - v60);
    *(_DWORD *)(result + 5812) = v60 + v54 - 16;
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v5 + 1026);
  return result;
}

//----- (0046B2F0) --------------------------------------------------------
BOOL __cdecl sub_46B2F0(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // edx
  unsigned __int16 *v3; // eax
  int v4; // ecx
  unsigned __int16 v5; // si
  unsigned __int16 *v6; // eax
  int v7; // ecx
  unsigned __int16 v8; // bp
  unsigned __int16 *v9; // ecx
  int v10; // eax
  unsigned __int16 v11; // si
  unsigned int v12; // edi
  BOOL result; // eax

  v1 = 0;
  v2 = 0;
  v3 = (unsigned __int16 *)(a1 + 140);
  v4 = 7;
  do
  {
    v5 = *v3;
    v3 += 2;
    v2 += v5;
    --v4;
  }
  while ( v4 );
  v6 = (unsigned __int16 *)(a1 + 168);
  v7 = 121;
  do
  {
    v8 = *v6;
    v6 += 2;
    v1 += v8;
    --v7;
  }
  while ( v7 );
  v9 = (unsigned __int16 *)(a1 + 652);
  v10 = 128;
  do
  {
    v11 = *v9;
    v9 += 2;
    v2 += v11;
    --v10;
  }
  while ( v10 );
  v12 = v1 >> 2;
  result = v2 <= v12;
  *(_BYTE *)(a1 + 28) = v2 <= v12;
  return result;
}

//----- (0046B370) --------------------------------------------------------
unsigned int __cdecl sub_46B370(unsigned int a1, int a2)
{
  unsigned int v4; // eax
  int v5; // esi

  v4 = 0;
  do
  {
    v5 = a1 & 1;
    a1 >>= 1;
    v4 = 2 * (v5 | v4);
    --a2;
  }
  while ( a2 > 0 );
  return v4 >> 1;
}

//----- (0046B390) --------------------------------------------------------
int __cdecl sub_46B390(int a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // esi
  int v4; // edx
  unsigned __int8 v5; // cl

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else if ( v2 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v5 = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = v5;
    *(_DWORD *)(a1 + 5812) -= 8;
  }
  return result;
}

//----- (0046B420) --------------------------------------------------------
int __cdecl sub_46B420(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 <= 8 )
  {
    if ( v2 > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  return result;
}

//----- (0046B4A0) --------------------------------------------------------
_BYTE *__cdecl sub_46B4A0(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edi
  int v5; // edx
  int v6; // edi
  int v7; // ecx
  int v8; // edi
  int v9; // ecx
  _BYTE *result; // eax
  int v11; // ecx

  sub_46B420((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[5] + a1[2]) = a3;
    v4 = a1[2];
    v5 = a1[5] + 1;
    a1[5] = v5;
    *(_BYTE *)(v5 + v4) = BYTE1(a3);
    v6 = a1[2];
    v7 = a1[5] + 1;
    a1[5] = v7;
    *(_BYTE *)(v7 + v6) = ~(_BYTE)a3;
    v8 = a1[5] + 1;
    v9 = a1[2];
    a1[5] = v8;
    *(_BYTE *)(v8 + v9) = ~BYTE1(a3);
    ++a1[5];
  }
  result = (_BYTE *)(a3 - 1);
  if ( a3 )
  {
    v11 = a3;
    result = a2;
    do
    {
      *(_BYTE *)(a1[5] + a1[2]) = *result++;
      --v11;
      ++a1[5];
    }
    while ( v11 );
  }
  return result;
}

//----- (0046B540) --------------------------------------------------------
int __cdecl sub_46B540(char a1, char a2, int a3, int a4, int a5)
{
  int result; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( result )
  {
    *(_BYTE *)(result + 16) = a1;
    *(_BYTE *)(result + 17) = a2;
    *(_DWORD *)result = 0;
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
  }
  return result;
}

//----- (0046B580) --------------------------------------------------------
int __cdecl sub_46B580(_DWORD *a1, int a2, int a3)
{
  _DWORD *v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned __int8 *v11; // ebx
  int v12; // ecx
  int v13; // eax
  unsigned int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  unsigned int v17; // eax
  char v18; // cl
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  unsigned int v23; // eax
  char v24; // cl
  int v25; // ecx
  int v26; // ecx
  unsigned int v27; // eax
  char v28; // cl
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  unsigned int v32; // eax
  char v33; // cl
  int v34; // ecx
  _BYTE *v35; // ecx
  unsigned int v36; // eax
  unsigned int v37; // ecx
  _BYTE *v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // ecx
  int v41; // eax
  int v42; // eax
  unsigned int v43; // eax
  int v44; // ecx
  unsigned int v45; // ecx
  int v46; // eax
  int v47; // ecx
  unsigned int v48; // eax
  unsigned int v49; // ecx
  int v50; // eax
  int v51; // eax
  unsigned int v52; // eax
  int v53; // ecx
  unsigned int v54; // ecx
  int v55; // eax
  int v56; // eax
  unsigned __int8 *v57; // ecx
  int result; // eax
  unsigned __int8 *v59; // ebx
  unsigned __int8 *v60; // ebx
  int v61; // ecx
  int v62; // eax
  unsigned __int8 *v63; // ebx
  unsigned __int8 *v64; // ebx
  unsigned __int8 *v65; // ebx
  _DWORD *v66; // [esp+10h] [ebp-10h]
  unsigned int v67; // [esp+14h] [ebp-Ch]
  unsigned int v68; // [esp+18h] [ebp-8h]
  unsigned __int8 *v69; // [esp+18h] [ebp-8h]
  unsigned int v70; // [esp+18h] [ebp-8h]
  unsigned int v71; // [esp+18h] [ebp-8h]
  unsigned int v72; // [esp+18h] [ebp-8h]
  _BYTE *v73; // [esp+18h] [ebp-8h]
  unsigned int i; // [esp+1Ch] [ebp-4h]
  unsigned int v75; // [esp+24h] [ebp+4h]
  unsigned int v76; // [esp+28h] [ebp+8h]
  int v77; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[1];
  v6 = *(unsigned __int8 **)a2;
  v7 = a1[7];
  v76 = *(_DWORD *)(a2 + 4);
  v8 = a1[12];
  v75 = a1[8];
  v9 = (_BYTE *)a1[13];
  v66 = v5;
  if ( (unsigned int)v9 >= v8 )
    v10 = a1[11] - (_DWORD)v9;
  else
    v10 = v8 - (_DWORD)v9 - 1;
  v67 = v10;
  while ( 2 )
  {
    switch ( *v5 )
    {
      case 0:
        if ( v67 >= 0x102 && v76 >= 0xA )
        {
          a1[8] = v75;
          a1[7] = v7;
          v11 = *(unsigned __int8 **)a2;
          *(_DWORD *)(a2 + 4) = v76;
          v12 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)a2 = v6;
          *(_DWORD *)(a2 + 8) = v6 - v11 + v12;
          a1[13] = v9;
          v13 = sub_46C5C0(
                  *((unsigned __int8 *)v66 + 16),
                  *((unsigned __int8 *)v66 + 17),
                  v66[5],
                  v66[6],
                  a1,
                  (unsigned __int8 **)a2);
          v6 = *(unsigned __int8 **)a2;
          v7 = a1[7];
          v76 = *(_DWORD *)(a2 + 4);
          v14 = a1[12];
          v75 = a1[8];
          v9 = (_BYTE *)a1[13];
          a3 = v13;
          v15 = (unsigned int)v9 >= v14 ? a1[11] - (_DWORD)v9 : v14 - (_DWORD)v9 - 1;
          v67 = v15;
          if ( v13 )
          {
            *v66 = v13 != 1 ? 9 : 7;
            v5 = v66;
            continue;
          }
        }
        v5 = v66;
        v16 = *((unsigned __int8 *)v66 + 16);
        *v66 = 1;
        v66[3] = v16;
        v66[2] = v66[5];
        goto LABEL_14;
      case 1:
LABEL_14:
        v17 = v5[3];
        v68 = v17;
        if ( v7 >= v17 )
          goto LABEL_17;
        do
        {
          if ( !v76 )
            goto LABEL_88;
          v18 = v7;
          --v76;
          v7 += 8;
          a3 = 0;
          v19 = (*v6 << v18) | v75;
          v17 = v68;
          ++v6;
          v75 = v19;
        }
        while ( v7 < v68 );
LABEL_17:
        v69 = (unsigned __int8 *)(v66[2] + 8 * (v75 & dword_4B9C40[v17]));
        v20 = v69[1];
        v75 >>= v20;
        v7 -= v20;
        v21 = *v69;
        if ( *v69 )
        {
          if ( (v21 & 0x10) != 0 )
          {
            v5 = v66;
            v66[2] = v21 & 0xF;
            v22 = *((_DWORD *)v69 + 1);
            *v66 = 2;
            v66[1] = v22;
          }
          else
          {
            if ( (v21 & 0x40) == 0 )
              goto LABEL_22;
            v5 = v66;
            if ( (v21 & 0x20) == 0 )
            {
              *v66 = 9;
              *(_DWORD *)(a2 + 24) = aInvalidLiteral;
LABEL_90:
              a1[8] = v75;
              a1[7] = v7;
              v59 = *(unsigned __int8 **)a2;
              *(_DWORD *)(a2 + 4) = v76;
              *(_DWORD *)(a2 + 8) += v6 - v59;
              *(_DWORD *)a2 = v6;
              a1[13] = v9;
              return sub_46C480(a1, (_DWORD *)a2, -3);
            }
            *v66 = 7;
          }
        }
        else
        {
          v5 = v66;
          v66[2] = *((_DWORD *)v69 + 1);
          *v66 = 6;
        }
        continue;
      case 2:
        v23 = v5[2];
        v70 = v23;
        if ( v7 >= v23 )
          goto LABEL_28;
        do
        {
          if ( !v76 )
            goto LABEL_88;
          v24 = v7;
          --v76;
          v7 += 8;
          a3 = 0;
          v25 = (*v6 << v24) | v75;
          v23 = v70;
          ++v6;
          v75 = v25;
        }
        while ( v7 < v70 );
LABEL_28:
        v66[1] += v75 & dword_4B9C40[v23];
        v75 >>= v70;
        v7 -= v70;
        v5 = v66;
        v26 = *((unsigned __int8 *)v66 + 17);
        *v66 = 3;
        v66[3] = v26;
        v66[2] = v66[6];
LABEL_29:
        v27 = v5[3];
        v71 = v27;
        if ( v7 < v27 )
        {
          while ( v76 )
          {
            v28 = v7;
            --v76;
            v7 += 8;
            a3 = 0;
            v29 = (*v6 << v28) | v75;
            v27 = v71;
            ++v6;
            v75 = v29;
            if ( v7 >= v71 )
              goto LABEL_32;
          }
LABEL_88:
          a1[7] = v7;
          a1[8] = v75;
          v56 = *(_DWORD *)(a2 + 8);
          v57 = &v6[-*(_DWORD *)a2];
          *(_DWORD *)(a2 + 4) = 0;
          *(_DWORD *)a2 = v6;
          *(_DWORD *)(a2 + 8) = &v57[v56];
          a1[13] = v9;
          return sub_46C480(a1, (_DWORD *)a2, a3);
        }
LABEL_32:
        v69 = (unsigned __int8 *)(v66[2] + 8 * (v75 & dword_4B9C40[v27]));
        v30 = v69[1];
        v7 -= v30;
        v75 >>= v30;
        v21 = *v69;
        if ( (v21 & 0x10) != 0 )
        {
          v5 = v66;
          v66[2] = v21 & 0xF;
          v31 = *((_DWORD *)v69 + 1);
          *v66 = 4;
          v66[3] = v31;
        }
        else
        {
          if ( (v21 & 0x40) != 0 )
          {
            *v66 = 9;
            *(_DWORD *)(a2 + 24) = aInvalidDistanc;
            goto LABEL_90;
          }
LABEL_22:
          v66[3] = v21;
          v5 = v66;
          v66[2] = &v69[8 * *((_DWORD *)v69 + 1)];
        }
        continue;
      case 3:
        goto LABEL_29;
      case 4:
        v32 = v5[2];
        v72 = v32;
        if ( v7 >= v32 )
          goto LABEL_39;
        do
        {
          if ( !v76 )
            goto LABEL_88;
          v33 = v7;
          --v76;
          v7 += 8;
          a3 = 0;
          v34 = (*v6 << v33) | v75;
          v32 = v72;
          ++v6;
          v75 = v34;
        }
        while ( v7 < v72 );
LABEL_39:
        v66[3] += v75 & dword_4B9C40[v32];
        v75 >>= v72;
        v7 -= v72;
        v5 = v66;
        *v66 = 5;
LABEL_40:
        v35 = &v9[-v5[3]];
        v36 = a1[10];
        v73 = v35;
        if ( (unsigned int)v35 < v36 )
        {
          v37 = a1[11] - v36;
          v38 = v73;
          for ( i = v37; ; v37 = i )
          {
            v38 += v37;
            if ( (unsigned int)v38 >= a1[10] )
              break;
          }
          v73 = v38;
        }
        v5 = v66;
        if ( !v66[1] )
        {
LABEL_67:
          *v5 = 0;
          continue;
        }
        while ( v67 )
        {
LABEL_64:
          ++v9;
          a3 = 0;
          *(v9 - 1) = *v73++;
          --v67;
          if ( v73 == (_BYTE *)a1[11] )
            v73 = (_BYTE *)a1[10];
          v47 = v5[1] - 1;
          v5[1] = v47;
          if ( !v47 )
            goto LABEL_67;
        }
        if ( v9 == (_BYTE *)a1[11] )
        {
          v39 = a1[12];
          v40 = a1[10];
          if ( v39 != v40 )
          {
            v9 = (_BYTE *)a1[10];
            v41 = v40 >= v39 ? a1[11] - v40 : v39 - v40 - 1;
            v67 = v41;
            if ( v41 )
              goto LABEL_63;
          }
        }
        a1[13] = v9;
        v42 = sub_46C480(a1, (_DWORD *)a2, a3);
        v9 = (_BYTE *)a1[13];
        v77 = v42;
        v43 = a1[12];
        if ( (unsigned int)v9 >= v43 )
          v44 = a1[11] - (_DWORD)v9;
        else
          v44 = v43 - (_DWORD)v9 - 1;
        v67 = v44;
        if ( v9 == (_BYTE *)a1[11] )
        {
          v45 = a1[10];
          if ( v43 != v45 )
          {
            v9 = (_BYTE *)a1[10];
            if ( v45 >= v43 )
              v46 = a1[11] - v45;
            else
              v46 = v43 - v45 - 1;
            v67 = v46;
          }
        }
        if ( v67 )
        {
LABEL_63:
          v5 = v66;
          goto LABEL_64;
        }
LABEL_91:
        a1[8] = v75;
        a1[7] = v7;
        v60 = *(unsigned __int8 **)a2;
        *(_DWORD *)(a2 + 4) = v76;
        v61 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)a2 = v6;
        *(_DWORD *)(a2 + 8) = v6 - v60 + v61;
        a1[13] = v9;
        return sub_46C480(a1, (_DWORD *)a2, v77);
      case 5:
        goto LABEL_40;
      case 6:
        if ( v67 )
          goto LABEL_86;
        if ( v9 != (_BYTE *)a1[11]
          || (v48 = a1[12], v49 = a1[10], v48 == v49)
          || ((v9 = (_BYTE *)a1[10], v49 >= v48) ? (v50 = a1[11] - v49) : (v50 = v48 - v49 - 1), (v67 = v50) == 0) )
        {
          a1[13] = v9;
          v51 = sub_46C480(a1, (_DWORD *)a2, a3);
          v9 = (_BYTE *)a1[13];
          v77 = v51;
          v52 = a1[12];
          if ( (unsigned int)v9 >= v52 )
            v53 = a1[11] - (_DWORD)v9;
          else
            v53 = v52 - (_DWORD)v9 - 1;
          v67 = v53;
          if ( v9 == (_BYTE *)a1[11] )
          {
            v54 = a1[10];
            if ( v52 != v54 )
            {
              v9 = (_BYTE *)a1[10];
              if ( v54 >= v52 )
                v55 = a1[11] - v54;
              else
                v55 = v52 - v54 - 1;
              v67 = v55;
            }
          }
          if ( !v67 )
            goto LABEL_91;
        }
        v5 = v66;
LABEL_86:
        a3 = 0;
        *v9++ = *((_BYTE *)v5 + 8);
        --v67;
        *v5 = 0;
        continue;
      case 7:
        if ( v7 > 7 )
        {
          v7 -= 8;
          --v6;
          ++v76;
        }
        a1[13] = v9;
        v62 = sub_46C480(a1, (_DWORD *)a2, a3);
        v9 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] == v9 )
        {
          *v66 = 8;
LABEL_97:
          a1[8] = v75;
          a1[7] = v7;
          v64 = *(unsigned __int8 **)a2;
          *(_DWORD *)(a2 + 4) = v76;
          *(_DWORD *)(a2 + 8) += v6 - v64;
          *(_DWORD *)a2 = v6;
          a1[13] = v9;
          result = sub_46C480(a1, (_DWORD *)a2, 1);
        }
        else
        {
          a1[7] = v7;
          a1[8] = v75;
          v63 = *(unsigned __int8 **)a2;
          *(_DWORD *)(a2 + 4) = v76;
          *(_DWORD *)(a2 + 8) += v6 - v63;
          *(_DWORD *)a2 = v6;
          a1[13] = v9;
          result = sub_46C480(a1, (_DWORD *)a2, v62);
        }
        return result;
      case 8:
        goto LABEL_97;
      case 9:
        goto LABEL_90;
      default:
        a1[8] = v75;
        a1[7] = v7;
        v65 = *(unsigned __int8 **)a2;
        *(_DWORD *)(a2 + 4) = v76;
        *(_DWORD *)(a2 + 8) += v6 - v65;
        *(_DWORD *)a2 = v6;
        a1[13] = v9;
        return sub_46C480(a1, (_DWORD *)a2, -2);
    }
  }
}

//----- (0046BD30) --------------------------------------------------------
int __cdecl sub_46BD30(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

//----- (0046BD50) --------------------------------------------------------
int __cdecl sub_46BD50(int *a1, unsigned int *a2, int *a3, int a4, int a5)
{
  unsigned int *v5; // ebx
  int result; // eax
  int v7; // eax
  int v8; // esi
  int v9; // [esp-10h] [ebp-1Ch]
  unsigned int v10; // [esp+8h] [ebp-4h] BYREF

  v10 = 0;
  v5 = (unsigned int *)(*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v5 )
    return -4;
  v7 = sub_46BE00(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v10, v5);
  v8 = v7;
  if ( v7 == -3 )
  {
    v9 = *(_DWORD *)(a5 + 40);
    *(_DWORD *)(a5 + 24) = aOversubscribed;
    (*(void (__cdecl **)(int, unsigned int *))(a5 + 36))(v9, v5);
    result = -3;
  }
  else
  {
    if ( v7 == -5 || !*a2 )
    {
      *(_DWORD *)(a5 + 24) = aIncompleteDyna;
      v8 = -3;
    }
    (*(void (__cdecl **)(_DWORD, unsigned int *))(a5 + 36))(*(_DWORD *)(a5 + 40), v5);
    result = v8;
  }
  return result;
}

//----- (0046BE00) --------------------------------------------------------
int __cdecl sub_46BE00(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, int *a6, unsigned int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  int *v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // edx
  int v13; // eax
  unsigned int v15; // ecx
  int *v16; // eax
  unsigned int v17; // ebp
  signed int v18; // eax
  unsigned int v19; // edx
  int *v20; // esi
  int v21; // esi
  int *v22; // ebx
  int v23; // esi
  int v24; // ebx
  int v25; // esi
  int v26; // ecx
  unsigned int v27; // edx
  int v28; // ebx
  int *v29; // edx
  unsigned int v30; // ebx
  int v31; // ecx
  int v32; // edx
  int v33; // ebx
  unsigned int v34; // esi
  int v35; // edx
  unsigned int v36; // ecx
  unsigned int v37; // edx
  unsigned int v38; // ecx
  unsigned int v39; // eax
  int *v40; // ebp
  unsigned int v41; // eax
  unsigned int v42; // edi
  unsigned int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // edx
  int v46; // eax
  unsigned int v47; // eax
  int v48; // ecx
  char v49; // dl
  int v50; // esi
  int v51; // edx
  unsigned int v52; // eax
  _DWORD *v53; // ecx
  unsigned int i; // eax
  int v55; // edx
  int *v56; // eax
  int v57; // edx
  unsigned int v58; // [esp+10h] [ebp-100h]
  signed int v59; // [esp+14h] [ebp-FCh]
  int v60; // [esp+18h] [ebp-F8h]
  int *v61; // [esp+1Ch] [ebp-F4h]
  unsigned int *v62; // [esp+1Ch] [ebp-F4h]
  int v63; // [esp+20h] [ebp-F0h]
  char v64; // [esp+20h] [ebp-F0h]
  int v65; // [esp+24h] [ebp-ECh]
  int *v66; // [esp+28h] [ebp-E8h]
  signed int v67; // [esp+2Ch] [ebp-E4h]
  int v68; // [esp+30h] [ebp-E0h]
  unsigned int v69; // [esp+34h] [ebp-DCh]
  unsigned int v70; // [esp+38h] [ebp-D8h]
  unsigned int v71; // [esp+3Ch] [ebp-D4h]
  int v72; // [esp+40h] [ebp-D0h]
  int v73; // [esp+44h] [ebp-CCh]
  signed int v74; // [esp+48h] [ebp-C8h]
  int *v75; // [esp+4Ch] [ebp-C4h]
  unsigned int v76; // [esp+50h] [ebp-C0h]
  int v77; // [esp+54h] [ebp-BCh] BYREF
  int v78[14]; // [esp+58h] [ebp-B8h] BYREF
  int v79; // [esp+90h] [ebp-80h] BYREF
  int v80; // [esp+94h] [ebp-7Ch] BYREF
  int v81[15]; // [esp+98h] [ebp-78h]
  int v82[15]; // [esp+D4h] [ebp-3Ch] BYREF
  int v83; // [esp+118h] [ebp+8h]

  v10 = a1;
  v11 = 0;
  v12 = a2;
  v77 = 0;
  v78[0] = 0;
  v78[1] = 0;
  v78[2] = 0;
  v78[3] = 0;
  v78[4] = 0;
  v78[5] = 0;
  v78[6] = 0;
  v78[7] = 0;
  v78[8] = 0;
  v78[9] = 0;
  v78[10] = 0;
  v78[11] = 0;
  v78[12] = 0;
  v78[13] = 0;
  v79 = 0;
  do
  {
    v13 = *v10++;
    --v12;
    ++*(&v77 + v13);
  }
  while ( v12 );
  if ( v77 == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    return 0;
  }
  v15 = 1;
  v16 = v78;
  v17 = *a7;
  v58 = *a7;
  do
  {
    if ( *v16 )
      break;
    ++v15;
    ++v16;
  }
  while ( v15 <= 0xF );
  v18 = v15;
  v59 = v15;
  if ( v17 < v15 )
  {
    v58 = v15;
    v17 = v15;
  }
  v19 = 15;
  v20 = &v79;
  do
  {
    if ( *v20 )
      break;
    --v19;
    --v20;
  }
  while ( v19 );
  v67 = v19;
  if ( v17 > v19 )
  {
    v58 = v19;
    v17 = v19;
  }
  *a7 = v17;
  v21 = 1 << v15;
  if ( v15 < v19 )
  {
    v22 = &v77 + v15;
    do
    {
      v23 = v21 - *v22;
      if ( v23 < 0 )
        return -3;
      ++v15;
      ++v22;
      v21 = 2 * v23;
    }
    while ( v15 < v19 );
  }
  v63 = 4 * v19;
  v24 = *(&v77 + v19);
  v25 = v21 - v24;
  v73 = v25;
  if ( v25 < 0 )
    return -3;
  v81[0] = 0;
  *(&v77 + v19) = v25 + v24;
  v26 = 0;
  v27 = v19 - 1;
  if ( v27 )
  {
    v28 = 0;
    do
    {
      v26 += v78[v28++];
      --v27;
      v81[v28] = v26;
    }
    while ( v27 );
  }
  v29 = a1;
  v30 = 0;
  do
  {
    v31 = *v29++;
    v61 = v29;
    if ( v31 )
    {
      v32 = *(&v80 + v31);
      a10[v32] = v30;
      v25 = v73;
      *(&v80 + v31) = v32 + 1;
      v29 = v61;
    }
    ++v30;
  }
  while ( v30 < a2 );
  v33 = -v17;
  v62 = a10;
  v83 = *(int *)((char *)&v80 + v63);
  v70 = 0;
  v80 = 0;
  v60 = -1;
  v82[0] = 0;
  v72 = 0;
  v71 = 0;
  if ( v18 <= v67 )
  {
    v34 = v69;
    v64 = v18 - 1;
    v66 = &v77 + v18;
    while ( 1 )
    {
      v35 = *v66 - 1;
      v65 = v35;
      if ( *v66 )
        break;
LABEL_64:
      ++v18;
      ++v66;
      v59 = v18;
      ++v64;
      if ( v18 > v67 )
      {
        v25 = v73;
        goto LABEL_66;
      }
    }
    while ( 1 )
    {
      v36 = v33 + v17;
      if ( v18 > (int)(v33 + v17) )
        break;
LABEL_49:
      BYTE1(v68) = v18 - v33;
      if ( v62 < &a10[v83] )
      {
        v34 = *v62;
        if ( *v62 >= a3 )
        {
          v50 = 4 * (v34 - a3);
          v49 = *(_BYTE *)(v50 + a5) + 80;
          v34 = *(_DWORD *)(v50 + a4);
        }
        else
        {
          v49 = v34 < 0x100 ? 0 : 96;
        }
        LOBYTE(v68) = v49;
        ++v62;
      }
      else
      {
        LOBYTE(v68) = -64;
      }
      v51 = 1 << (v18 - v33);
      v52 = v11 >> v33;
      if ( v11 >> v33 < v71 )
      {
        v53 = (_DWORD *)(v72 + 8 * v52);
        do
        {
          v52 += v51;
          *v53 = v68;
          v53[1] = v34;
          v53 += 2 * v51;
        }
        while ( v52 < v71 );
      }
      for ( i = 1 << v64; (i & v11) != 0; i >>= 1 )
        v11 ^= i;
      v55 = v60;
      v11 ^= i;
      v56 = &v80 + v60;
      v70 = v11;
      if ( (v11 & ((1 << v33) - 1)) != *v56 )
      {
        do
        {
          --v55;
          v33 -= v58;
          --v56;
        }
        while ( (v11 & ((1 << v33) - 1)) != *v56 );
        v60 = v55;
      }
      v17 = v58;
      v57 = v65--;
      v18 = v59;
      if ( !v57 )
        goto LABEL_64;
      v35 = v65;
    }
    v76 = v35 + 1;
    while ( 1 )
    {
      v33 += v17;
      ++v60;
      v37 = v67 - v33;
      v74 = v17 + v36;
      if ( v67 - v33 > v17 )
        v37 = v17;
      v38 = v18 - v33;
      v39 = 1 << (v18 - v33);
      if ( v39 > v76 )
      {
        v40 = v66;
        v41 = -1 - v65 + v39;
        if ( v38 < v37 && ++v38 < v37 )
        {
          do
          {
            v42 = v40[1];
            ++v40;
            v43 = 2 * v41;
            if ( v43 <= v42 )
              break;
            v41 = v43 - v42;
            ++v38;
          }
          while ( v38 < v37 );
        }
      }
      v44 = *a9;
      v71 = 1 << v38;
      v45 = *a9 + (1 << v38);
      if ( v45 > 0x5A0 )
        return -3;
      *a9 = v45;
      v46 = a8 + 8 * v44;
      v72 = v46;
      v75 = &v82[v60];
      *v75 = v46;
      v11 = v70;
      if ( v60 )
      {
        LOBYTE(v68) = v38;
        *(&v80 + v60) = v70;
        BYTE1(v68) = v58;
        v47 = v70 >> (v33 - v58);
        v48 = *(v75 - 1);
        v34 = ((v72 - v48) >> 3) - v47;
        *(_DWORD *)(v48 + 8 * v47) = v68;
        *(_DWORD *)(v48 + 8 * v47 + 4) = v34;
      }
      else
      {
        *a6 = v46;
      }
      v36 = v74;
      LOBYTE(v18) = v59;
      if ( v59 <= v74 )
        goto LABEL_49;
      v17 = v58;
      v18 = v59;
    }
  }
LABEL_66:
  if ( !v25 || v67 == 1 )
    return 0;
  return -5;
}
// 46BFFD: variable 'v69' is possibly undefined
// 46C122: variable 'v68' is possibly undefined

//----- (0046C2C0) --------------------------------------------------------
int __cdecl sub_46C2C0(unsigned int a1, unsigned int a2, int *a3, unsigned int *a4, unsigned int *a5, int *a6, int *a7, int a8, int a9)
{
  unsigned int *v9; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // [esp-Ch] [ebp-20h]
  int v15; // [esp-8h] [ebp-1Ch]
  int v16; // [esp-8h] [ebp-1Ch]
  int v17; // [esp-8h] [ebp-1Ch]
  unsigned int v18; // [esp+10h] [ebp-4h] BYREF

  v14 = *(_DWORD *)(a9 + 40);
  v18 = 0;
  v9 = (unsigned int *)(*(int (__cdecl **)(int, int, int))(a9 + 32))(v14, 288, 4);
  if ( !v9 )
    return -4;
  v11 = sub_46BE00(a3, a1, 0x101u, (int)&unk_4AF1E4, (int)&unk_4AF260, a6, a4, a8, &v18, v9);
  v12 = v11;
  if ( v11 )
  {
    if ( v11 == -3 )
    {
      v17 = *(_DWORD *)(a9 + 40);
      *(_DWORD *)(a9 + 24) = aOversubscribed_1;
      (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v17, v9);
      return -3;
    }
    if ( v11 == -4 )
      goto LABEL_20;
LABEL_19:
    *(_DWORD *)(a9 + 24) = aIncompleteLite;
    v12 = -3;
    goto LABEL_20;
  }
  if ( !*a4 )
    goto LABEL_19;
  v13 = sub_46BE00(&a3[a1], a2, 0, (int)&unk_4AF2DC, (int)&unk_4AF354, a7, a5, a8, &v18, v9);
  v12 = v13;
  if ( v13 )
  {
    switch ( v13 )
    {
      case -3:
        v15 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aOversubscribed_0;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v15, v9);
        return -3;
      case -5:
        v16 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aIncompleteDist;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v16, v9);
        return -3;
      case -4:
        goto LABEL_20;
    }
  }
  else if ( *a5 || a1 <= 0x101 )
  {
    (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
    return 0;
  }
  *(_DWORD *)(a9 + 24) = aEmptyDistanceT;
  v12 = -3;
LABEL_20:
  (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
  return v12;
}

//----- (0046C450) --------------------------------------------------------
int __cdecl sub_46C450(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax

  *a1 = dword_4B8A48;
  *a2 = dword_4B8A4C;
  result = 0;
  *a3 = &unk_4B8A50;
  *a4 = &unk_4B9A50;
  return result;
}
// 4B8A48: using guessed type int dword_4B8A48;
// 4B8A4C: using guessed type int dword_4B8A4C;

//----- (0046C480) --------------------------------------------------------
int __cdecl sub_46C480(_DWORD *a1, _DWORD *a2, int a3)
{
  unsigned int v3; // ebp
  char *v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edx
  int (__cdecl *v8)(_DWORD, char *, unsigned int); // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // ecx
  char *v12; // esi
  unsigned int v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // edx
  int (__cdecl *v16)(_DWORD, char *, unsigned int); // eax
  int v17; // eax
  char *v18; // edi
  char *v20; // [esp+10h] [ebp-4h]
  char *v21; // [esp+10h] [ebp-4h]

  v3 = a1[13];
  v4 = (char *)a1[12];
  v20 = (char *)a2[3];
  if ( (unsigned int)v4 > v3 )
    v3 = a1[11];
  v5 = a2[4];
  v6 = v3 - (_DWORD)v4;
  if ( v6 > v5 )
    v6 = a2[4];
  if ( v6 && a3 == -5 )
    a3 = 0;
  v7 = v6 + a2[5];
  a2[4] = v5 - v6;
  a2[5] = v7;
  v8 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
  if ( v8 )
  {
    v9 = v8(a1[15], v4, v6);
    a1[15] = v9;
    a2[12] = v9;
  }
  qmemcpy(v20, v4, v6);
  v10 = &v4[v6];
  v11 = (char *)a1[11];
  v21 = &v20[v6];
  if ( &v4[v6] == v11 )
  {
    v12 = (char *)a1[10];
    if ( (char *)a1[13] == v11 )
      a1[13] = v12;
    v13 = a1[13] - (_DWORD)v12;
    v14 = a2[4];
    if ( v13 > v14 )
      v13 = a2[4];
    if ( v13 && a3 == -5 )
      a3 = 0;
    v15 = v13 + a2[5];
    a2[4] = v14 - v13;
    a2[5] = v15;
    v16 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
    if ( v16 )
    {
      v17 = v16(a1[15], v12, v13);
      a1[15] = v17;
      a2[12] = v17;
    }
    qmemcpy(v21, v12, 4 * (v13 >> 2));
    v18 = &v21[4 * (v13 >> 2)];
    v21 += v13;
    v10 = &v12[v13];
    qmemcpy(v18, &v12[4 * (v13 >> 2)], v13 & 3);
  }
  a2[3] = v21;
  a1[12] = v10;
  return a3;
}

//----- (0046C5C0) --------------------------------------------------------
int __cdecl sub_46C5C0(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6)
{
  unsigned __int8 *v6; // ebp
  unsigned int v7; // edx
  unsigned int v8; // esi
  _BYTE *v9; // edi
  unsigned int v10; // eax
  int v11; // esi
  int v12; // ebx
  _BYTE *v13; // esi
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  unsigned int v18; // eax
  unsigned int v19; // edx
  int v20; // esi
  int v21; // ebx
  int v22; // esi
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  unsigned int i; // ebx
  int v27; // ebp
  int v28; // ebp
  _BYTE *v29; // esi
  unsigned int v30; // ebx
  int v31; // ebp
  int v32; // ecx
  _BYTE *v33; // esi
  _BYTE *v34; // edi
  _BYTE *v35; // esi
  unsigned int v36; // ecx
  _BYTE *v37; // edi
  _BYTE *v38; // esi
  unsigned int v39; // ecx
  int v40; // ecx
  _DWORD *v41; // ecx
  unsigned __int8 *v42; // esi
  unsigned int v43; // esi
  unsigned int v44; // ecx
  unsigned __int8 *v45; // ebp
  unsigned __int8 *v46; // edx
  unsigned __int8 *v47; // eax
  unsigned int v49; // ecx
  unsigned __int8 *v50; // ebp
  unsigned __int8 *v51; // edx
  unsigned __int8 *v52; // eax
  unsigned __int8 *v53; // esi
  unsigned __int8 *v54; // ebp
  int v55; // eax
  unsigned __int8 *v56; // edx
  unsigned int v57; // [esp+10h] [ebp-14h]
  unsigned int v58; // [esp+14h] [ebp-10h]
  unsigned __int8 *v59; // [esp+18h] [ebp-Ch]
  int v60; // [esp+1Ch] [ebp-8h]
  int v61; // [esp+20h] [ebp-4h]
  int v62; // [esp+28h] [ebp+4h]
  unsigned int v63; // [esp+2Ch] [ebp+8h]
  unsigned int v64; // [esp+2Ch] [ebp+8h]

  v6 = *a6;
  v7 = a5[8];
  v8 = a5[12];
  v9 = (_BYTE *)a5[13];
  v57 = (unsigned int)a6[1];
  v10 = a5[7];
  v59 = *a6;
  if ( (unsigned int)v9 >= v8 )
    v58 = a5[11] - (_DWORD)v9;
  else
    v58 = v8 - (_DWORD)v9 - 1;
  v60 = dword_4B9C40[a1];
  v61 = dword_4B9C40[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v57;
        v11 = *v6 << v10;
        v10 += 8;
        v7 |= v11;
        ++v6;
      }
      while ( v10 < 0x14 );
      v59 = v6;
    }
    v12 = *(unsigned __int8 *)(a3 + 8 * (v7 & v60));
    v13 = (_BYTE *)(a3 + 8 * (v7 & v60));
    if ( *v13 )
      break;
LABEL_36:
    v40 = (unsigned __int8)v13[1];
    v7 >>= v40;
    v10 -= v40;
    *v9++ = v13[4];
    --v58;
LABEL_37:
    if ( v58 < 0x102 || v57 < 0xA )
    {
      v44 = (unsigned int)&a6[1][-v57];
      if ( v10 >> 3 < v44 )
        v44 = v10 >> 3;
      v45 = &v6[-v44];
      a5[8] = v7;
      a5[7] = v10 - 8 * v44;
      v46 = *a6;
      v47 = a6[2];
      a6[1] = (unsigned __int8 *)(v57 + v44);
      *a6 = v45;
      a6[2] = &v47[v45 - v46];
      a5[13] = v9;
      return 0;
    }
  }
  v14 = (unsigned __int8)v13[1];
  v7 >>= v14;
  v10 -= v14;
  if ( (v12 & 0x10) != 0 )
  {
LABEL_13:
    v17 = v12 & 0xF;
    v18 = v10 - v17;
    v63 = *((_DWORD *)v13 + 1) + (v7 & dword_4B9C40[v17]);
    v19 = v7 >> v17;
    if ( v18 < 0xF )
    {
      do
      {
        --v57;
        v20 = *v6 << v18;
        v18 += 8;
        v19 |= v20;
        ++v6;
      }
      while ( v18 < 0xF );
      v59 = v6;
    }
    v21 = *(unsigned __int8 *)(a4 + 8 * (v19 & v61));
    v22 = a4 + 8 * (v19 & v61);
    v23 = *(unsigned __int8 *)(v22 + 1);
    v7 = v19 >> v23;
    v10 = v18 - v23;
    if ( (v21 & 0x10) == 0 )
    {
      while ( (v21 & 0x40) == 0 )
      {
        v24 = *(_DWORD *)(v22 + 4) + (v7 & dword_4B9C40[v21]);
        v21 = *(unsigned __int8 *)(v22 + 8 * v24);
        v22 += 8 * v24;
        v25 = *(unsigned __int8 *)(v22 + 1);
        v7 >>= v25;
        v10 -= v25;
        if ( (v21 & 0x10) != 0 )
          goto LABEL_19;
      }
      v41 = a6;
      v42 = a6[1];
      a6[6] = (unsigned __int8 *)aInvalidDistanc;
      v64 = (unsigned int)&v42[-v57];
      v43 = v10 >> 3;
      if ( v10 >> 3 >= v64 )
LABEL_50:
        v43 = v64;
LABEL_51:
      v54 = &v6[-v43];
      a5[8] = v7;
      a5[7] = v10 - 8 * v43;
      v55 = v41[2];
      v41[1] = v57 + v43;
      v56 = &v54[-*v41];
      *v41 = v54;
      v41[2] = &v56[v55];
      a5[13] = v9;
      return -3;
    }
LABEL_19:
    for ( i = v21 & 0xF; v10 < i; ++v59 )
    {
      --v57;
      v27 = *v6 << v10;
      v10 += 8;
      v7 |= v27;
      v6 = v59 + 1;
    }
    v28 = *(_DWORD *)(v22 + 4) + (v7 & dword_4B9C40[i]);
    v7 >>= i;
    v10 -= i;
    v58 -= v63;
    v29 = &v9[-v28];
    v30 = a5[10];
    if ( (unsigned int)&v9[-v28] >= v30 )
    {
      *v9 = *v29;
      v37 = v9 + 1;
      *v37 = v29[1];
      v9 = v37 + 1;
      v38 = v29 + 2;
      v39 = v63 - 2;
      do
      {
        *v9++ = *v38++;
        --v39;
      }
      while ( v39 );
      v6 = v59;
    }
    else
    {
      v62 = a5[11];
      do
        v29 += v62 - v30;
      while ( (unsigned int)v29 < v30 );
      v31 = v62 - (_DWORD)v29;
      if ( v63 <= v62 - (int)v29 )
      {
        *v9 = *v29;
        v34 = v9 + 1;
        *v34 = v29[1];
        v9 = v34 + 1;
        v35 = v29 + 2;
        v36 = v63 - 2;
        do
        {
          *v9++ = *v35++;
          --v36;
        }
        while ( v36 );
        v6 = v59;
      }
      else
      {
        v32 = v63 - v31;
        do
        {
          *v9++ = *v29++;
          --v31;
        }
        while ( v31 );
        v33 = (_BYTE *)a5[10];
        do
        {
          *v9++ = *v33++;
          --v32;
        }
        while ( v32 );
        v6 = v59;
      }
    }
    goto LABEL_37;
  }
  while ( (v12 & 0x40) == 0 )
  {
    v15 = *((_DWORD *)v13 + 1) + (v7 & dword_4B9C40[v12]);
    v12 = (unsigned __int8)v13[8 * v15];
    v13 += 8 * v15;
    if ( !v12 )
      goto LABEL_36;
    v16 = (unsigned __int8)v13[1];
    v7 >>= v16;
    v10 -= v16;
    if ( (v12 & 0x10) != 0 )
      goto LABEL_13;
  }
  if ( (v12 & 0x20) == 0 )
  {
    v41 = a6;
    v53 = a6[1];
    a6[6] = (unsigned __int8 *)aInvalidLiteral;
    v64 = (unsigned int)&v53[-v57];
    v43 = v10 >> 3;
    if ( v10 >> 3 >= v64 )
      goto LABEL_50;
    goto LABEL_51;
  }
  v49 = (unsigned int)&a6[1][-v57];
  if ( v10 >> 3 < v49 )
    v49 = v10 >> 3;
  v50 = &v6[-v49];
  a5[8] = v7;
  a5[7] = v10 - 8 * v49;
  v51 = *a6;
  v52 = a6[2];
  a6[1] = (unsigned __int8 *)(v57 + v49);
  *a6 = v50;
  a6[2] = &v52[v50 - v51];
  a5[13] = v9;
  return 1;
}

//----- (0046C9C4) --------------------------------------------------------
int __thiscall type_info::~type_info(type_info *this)
{
  unsigned int v2; // esi

  *(_DWORD *)this = &off_4AF3D0;
  _lock(27);
  v2 = *((_DWORD *)this + 1);
  if ( v2 )
    sub_46D360(v2);
  return sub_46FA37(27);
}
// 4AF3D0: using guessed type int (__stdcall *off_4AF3D0)(char);

//----- (0046C9ED) --------------------------------------------------------
type_info *__thiscall sub_46C9ED(type_info *this, char a2)
{
  type_info::~type_info(this);
  if ( (a2 & 1) != 0 )
    sub_40B7E0((unsigned int)this);
  return this;
}

//----- (0046CA73) --------------------------------------------------------
// #API: RaiseException()
// #API: RaiseException()
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  int v2[8]; // [esp+8h] [ebp-20h] BYREF

  qmemcpy(v2, &unk_4AF3D8, sizeof(v2));
  v2[6] = (int)pExceptionObject;
  v2[7] = (int)pThrowInfo;
  dword_4A7298(v2[0], v2[1], v2[4], &v2[5]);
}
// 4A7298: using guessed type int (__stdcall *dword_4A7298)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046CAB0) --------------------------------------------------------
unsigned int __cdecl sub_46CAB0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  _BYTE *v4; // edi
  unsigned int v5; // ecx
  unsigned int result; // eax
  int v7; // esi
  int v8; // edi
  unsigned int v9; // ecx

  v3 = a2;
  v4 = (_BYTE *)a1;
  if ( a1 > (unsigned int)a2 && a1 < (unsigned int)&a2[a3] )
  {
    v7 = (int)&a2[a3 - 4];
    v8 = a3 + a1 - 4;
    if ( (v8 & 3) == 0 )
    {
      v9 = a3 >> 2;
      if ( a3 >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_32;
          case 1u:
            goto LABEL_33;
          case 2u:
            goto LABEL_34;
          case 3u:
            goto LABEL_35;
        }
      }
      switch ( a3 & 3 )
      {
        case 0u:
          goto LABEL_32;
        case 1u:
          goto LABEL_33;
        case 2u:
          goto LABEL_34;
        case 3u:
          goto LABEL_35;
      }
    }
    switch ( a3 )
    {
      case 0u:
LABEL_32:
        result = a1;
        break;
      case 1u:
LABEL_33:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        result = a1;
        break;
      case 2u:
LABEL_34:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        result = a1;
        break;
      case 3u:
LABEL_35:
        *(_BYTE *)(v8 + 3) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v8 + 2) = *(_BYTE *)(v7 + 2);
        *(_BYTE *)(v8 + 1) = *(_BYTE *)(v7 + 1);
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr loc_46CC94+4[eax*4] }
        return result;
    }
  }
  else
  {
    if ( (a1 & 3) != 0 )
    {
      if ( a3 >= 4 )
        __asm { jmp     dword ptr loc_46CB0C+4[eax*4] }
      __asm { jmp     dword ptr loc_46CC08[ecx*4]; jumptable 0046CAE5 case 0 }
    }
    v5 = a3 >> 2;
    switch ( v5 )
    {
      case 0u:
        goto LABEL_17;
      case 1u:
        goto LABEL_16;
      case 2u:
        goto LABEL_15;
      case 3u:
        goto LABEL_14;
      case 4u:
        goto LABEL_13;
      case 5u:
        goto LABEL_12;
      case 6u:
        goto LABEL_11;
      case 7u:
        *(_DWORD *)(a1 + 4 * v5 - 28) = *(_DWORD *)&a2[4 * v5 - 28];
LABEL_11:
        *(_DWORD *)(a1 + 4 * v5 - 24) = *(_DWORD *)&a2[4 * v5 - 24];
LABEL_12:
        *(_DWORD *)(a1 + 4 * v5 - 20) = *(_DWORD *)&a2[4 * v5 - 20];
LABEL_13:
        *(_DWORD *)(a1 + 4 * v5 - 16) = *(_DWORD *)&a2[4 * v5 - 16];
LABEL_14:
        *(_DWORD *)(a1 + 4 * v5 - 12) = *(_DWORD *)&a2[4 * v5 - 12];
LABEL_15:
        *(_DWORD *)(a1 + 4 * v5 - 8) = *(_DWORD *)&a2[4 * v5 - 8];
LABEL_16:
        *(_DWORD *)(a1 + 4 * v5 - 4) = *(_DWORD *)&a2[4 * v5 - 4];
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(4 * v5 + a1);
LABEL_17:
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_18;
          case 1u:
            goto LABEL_19;
          case 2u:
            goto LABEL_20;
          case 3u:
            goto LABEL_21;
        }
      default:
        qmemcpy((void *)a1, a2, 4 * v5);
        v3 = &a2[4 * v5];
        v4 = (_BYTE *)(a1 + 4 * v5);
        switch ( a3 & 3 )
        {
          case 0u:
LABEL_18:
            result = a1;
            break;
          case 1u:
LABEL_19:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
LABEL_20:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
LABEL_21:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}

//----- (0046CDE5) --------------------------------------------------------
void __stdcall _JumpToContinuation(void *a1, struct EHRegistrationNode *a2)
{
  ((void (*)(void))a1)();
}

//----- (0046CE19) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_46CE19(int a1, int a2)
{
  __int32 v3; // [esp-8h] [ebp-8h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  return ((int (*)(void))_InterlockedExchange((volatile __int32 *)&retaddr, v3))();
}
// 46CE1B: positive sp value 8 has been found
// 46CE1B: variable 'v3' is possibly undefined

//----- (0046CE20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_46CE20(int a1, int a2)
{
  __int32 v3; // [esp-8h] [ebp-8h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  return ((int (*)(void))_InterlockedExchange((volatile __int32 *)&retaddr, v3))();
}
// 46CE22: positive sp value 8 has been found
// 46CE22: variable 'v3' is possibly undefined

//----- (0046CE27) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_46CE27(int a1, int a2)
{
  __int32 v3; // [esp-8h] [ebp-8h]
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  return ((int (*)(void))_InterlockedExchange((volatile __int32 *)&retaddr, v3))();
}
// 46CE29: positive sp value 8 has been found
// 46CE29: variable 'v3' is possibly undefined

//----- (0046CE2E) --------------------------------------------------------
struct _EXCEPTION_REGISTRATION_RECORD *__userpurge unknown_libname_60@<eax>(struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>, int a2, int a3)
{
  int v3; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *result; // eax

  sub_47C8B6(a2, &loc_46CE56, a3, 0);
  v3 = *(_DWORD *)(a3 + 4);
  LOBYTE(v3) = v3 & 0xFD;
  *(_DWORD *)(a3 + 4) = v3;
  result = NtCurrentTeb()->NtTib.ExceptionList;
  *a1 = result;
  return result;
}
// 47C8B6: using guessed type int __stdcall sub_47C8B6(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046CECD) --------------------------------------------------------
void __cdecl _CallCatchBlock2(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, void *a3, int a4, unsigned __int32 a5)
{
  _CallSettingFrame((int)a3, (int)a1, a5);
}

//----- (0046CF21) --------------------------------------------------------
int __usercall CatchGuardHandler@<eax>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5)
{
  return __InternalCxxFrameHandler_0(
           a1,
           a2,
           (int)a3,
           *((_DWORD *)a4 + 3),
           (int)a5,
           0,
           *((struct _s_FuncInfo **)a4 + 2),
           *((_DWORD *)a4 + 4),
           (int)a4,
           0);
}

//----- (0046CF46) --------------------------------------------------------
int __cdecl _CallSETranslator(struct EHExceptionRecord *a1, struct EHRegistrationNode *a2, void *a3, void *a4, const struct _s_FuncInfo *a5, int a6, struct EHRegistrationNode *a7)
{
  int *v7; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // ebx
  unsigned int v10; // [esp-8h] [ebp-48h]
  int v11; // [esp+0h] [ebp-40h] BYREF
  int v12; // [esp+Ch] [ebp-34h]
  int v13[11]; // [esp+10h] [ebp-30h] BYREF
  int v14; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v13[3] = (int)TranslatorGuardHandler;
  v13[4] = (int)a5;
  v13[5] = (int)a2;
  v13[6] = a6;
  v13[7] = (int)a7;
  v14 = 0;
  v13[8] = (int)&loc_46CFCE;
  v13[9] = (int)&v11;
  v13[10] = (int)&savedregs;
  v13[2] = (int)NtCurrentTeb()->NtTib.ExceptionList;
  v12 = 1;
  v13[0] = (int)a1;
  v13[1] = (int)a3;
  v10 = a1->ExceptionCode;
  v7 = _getptd();
  ((void (__cdecl *)(unsigned int, int *))v7[26])(v10, v13);
  v12 = 0;
  if ( v14 )
  {
    v8 = NtCurrentTeb()->NtTib.ExceptionList;
    v8->Next = v8->Next;
  }
  return v12;
}

//----- (0046CFFC) --------------------------------------------------------
int __usercall TranslatorGuardHandler@<eax>(struct _EXCEPTION_REGISTRATION_RECORD **a1@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a4)
{
  int result; // eax

  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )
  {
    *((_DWORD *)TargetFrame + 9) = 1;
    result = 1;
  }
  else
  {
    __InternalCxxFrameHandler_0(
      ExceptionRecord,
      *((_DWORD *)TargetFrame + 3),
      a4,
      0,
      *((_DWORD *)TargetFrame + 2),
      *((_DWORD *)TargetFrame + 4),
      *((_DWORD *)TargetFrame + 5),
      1);
    if ( !*((_DWORD *)TargetFrame + 9) )
      unknown_libname_60(a1, (int)TargetFrame, (int)ExceptionRecord);
    result = (*((int (**)(void))TargetFrame + 6))();
  }
  return result;
}
// 46FB58: using guessed type _DWORD __cdecl __InternalCxxFrameHandler_0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046D071) --------------------------------------------------------
TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *a1, int a2, int a3, unsigned int *a4, unsigned int *a5)
{
  unsigned int v7; // esi
  TryBlockMapEntry *v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v12; // [esp+Ch] [ebp-4h]
  unsigned int v13; // [esp+18h] [ebp+8h]

  v7 = a1->nTryBlocks;
  v8 = a1->pTryBlockMap;
  v9 = v7;
  v13 = v7;
  v12 = v7;
  if ( a2 >= 0 )
  {
    do
    {
      if ( v7 == -1 )
        sub_4705CD((EXCEPTION_POINTERS *)a3, (int)v8, (int)a1, -1);
      if ( v8[--v7].tryHigh < a3 && a3 <= v8[v7].catchHigh || v7 == -1 )
      {
        --a2;
        v12 = v13;
        v13 = v7;
      }
    }
    while ( a2 >= 0 );
    v9 = v12;
  }
  v10 = v7 + 1;
  *a4 = v10;
  *a5 = v9;
  if ( v9 > a1->nTryBlocks || v10 > v9 )
    sub_4705CD((EXCEPTION_POINTERS *)a5, (int)v8, (int)a1, v10);
  return &v8[v10];
}
// 46D094: variable 'a3' is possibly undefined

//----- (0046D0EC) --------------------------------------------------------
int __cdecl _global_unwind2(PVOID TargetFrame)
{
  return sub_47C8B6(TargetFrame, &loc_46D104, 0, 0);
}
// 47C8B6: using guessed type int __stdcall sub_47C8B6(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046D10C) --------------------------------------------------------
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (0046D12E) --------------------------------------------------------
int __usercall _local_unwind2@<eax>(int a1@<ebp>, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *v7; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v8)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]

  v8 = _unwind_handler;
  v7 = NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 || v5 == a3 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_46D1C2(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, _DWORD *)))(v4 + 4 * v6 + 8))(
        v7,
        v8);
    }
  }
  return result;
}
// 46D182: variable 'v7' is possibly undefined
// 46D182: variable 'v8' is possibly undefined

//----- (0046D196) --------------------------------------------------------
int __cdecl _abnormal_termination()
{
  int result; // eax
  struct _EXCEPTION_REGISTRATION_RECORD *v1; // ecx

  result = 0;
  v1 = NtCurrentTeb()->NtTib.ExceptionList;
  if ( (int (__cdecl *)(int, int, int, _DWORD *))v1->Handler == _unwind_handler
    && v1[1].Next == (struct _EXCEPTION_REGISTRATION_RECORD *)*((_DWORD *)v1[1].Handler + 3) )
  {
    result = 1;
  }
  return result;
}

//----- (0046D1B9) --------------------------------------------------------
void __stdcall sub_46D1B9(int a1)
{
  JUMPOUT(0x46D1CC);
}
// 46D1C0: control flows out of bounds to 46D1CC

//----- (0046D1C2) --------------------------------------------------------
int __userpurge sub_46D1C2@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_4B9CB0[2] = *(_DWORD *)(a2 + 8);
  dword_4B9CB0[1] = result;
  dword_4B9CB0[3] = a2;
  return result;
}

//----- (0046D1DA) --------------------------------------------------------
unsigned int sub_46D1DA()
{
  unsigned int result; // eax

  _cfltcvt_init();
  dword_4C1B14 = _ms_p5_mp_test_fdiv();
  result = sub_470623();
  __asm { fnclex }
  return result;
}
// 4C1B14: using guessed type int dword_4C1B14;

//----- (0046D1F2) --------------------------------------------------------
char *(__cdecl *_cfltcvt_init())(int a1, int a2, int a3, size_t Size, int a5)
{
  char *(__cdecl *result)(int, int, int, size_t, int); // eax

  result = _cfltcvt;
  off_4B9F4C = (int (__cdecl *)(_DWORD))sub_4706F6;
  off_4B9F48 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))_cfltcvt;
  off_4B9F50 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))_fassign;
  off_4B9F54 = (int (__cdecl *)(_DWORD))_forcdecpt;
  off_4B9F58 = (int (__cdecl *)(int))sub_470744;
  off_4B9F5C = (int (__cdecl *)(int, int, int, int, int))_cfltcvt;
  return result;
}
// 4B9F48: using guessed type int (__cdecl *off_4B9F48)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4B9F4C: using guessed type int (__cdecl *off_4B9F4C)(_DWORD);
// 4B9F50: using guessed type int (__cdecl *off_4B9F50)(_DWORD, _DWORD, _DWORD);
// 4B9F54: using guessed type int (__cdecl *off_4B9F54)(_DWORD);
// 4B9F58: using guessed type int (__cdecl *off_4B9F58)(int);
// 4B9F5C: using guessed type int (__cdecl *off_4B9F5C)(int, int, int, int, int);

//----- (0046D263) --------------------------------------------------------
void sub_46D263()
{
  _amsg_exit(0x19u);
}

//----- (0046D26C) --------------------------------------------------------
unsigned int __stdcall `eh vector destructor iterator'(char *a1, unsigned int a2, int a3, int (__thiscall *a4)(char *))
{
  unsigned int result; // eax
  char *i; // [esp+30h] [ebp+8h]

  result = a3 * a2;
  for ( i = &a1[a3 * a2]; --a3 >= 0; result = a4(i) )
    i -= a2;
  return result;
}
// 46D2D8: conditional instruction was optimized away because of '%var_1C.4==1'

//----- (0046D2EC) --------------------------------------------------------
int __stdcall __ArrayUnwind(char *a1, unsigned int a2, int a3, int (*a4)(void))
{
  int result; // eax

  while ( --a3 >= 0 )
  {
    a1 -= a2;
    result = a4();
  }
  return result;
}

//----- (0046D34A) --------------------------------------------------------
char __cdecl sub_46D34A(_DWORD **a1)
{
  char result; // al

  if ( **a1 == -529697949 )
    result = sub_470554();
  else
    result = 0;
  return result;
}

//----- (0046D360) --------------------------------------------------------
void __cdecl sub_46D360(unsigned int a1)
{
  _DWORD *v1; // eax
  bool v2; // zf
  _BYTE *v3; // eax
  void **v4; // [esp+Ch] [ebp-28h] BYREF
  _BYTE *v5; // [esp+10h] [ebp-24h]
  int v6; // [esp+14h] [ebp-20h] BYREF
  _DWORD *v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  if ( a1 )
  {
    if ( dword_4C3270 == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      v1 = (_DWORD *)__sbh_find_block_0(a1);
      v7 = v1;
      if ( v1 )
        sub_470F63(v1, a1);
      ms_exc.registration.TryLevel = -1;
      sub_46FA37(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_4C3270 != 2 )
      {
LABEL_11:
        dword_4A7218(dword_4C326C, 0, a1);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = (_BYTE *)sub_4720B5(a1, &v4, (unsigned int *)&v6);
      v5 = v3;
      if ( v3 )
        sub_47210C((int)v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      sub_46FA37(9);
      v2 = v5 == 0;
    }
    if ( !v2 )
      return;
    goto LABEL_11;
  }
}
// 4A7218: using guessed type int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD);
// 4C3270: using guessed type int dword_4C3270;

//----- (0046D449) --------------------------------------------------------
int __stdcall `eh vector constructor iterator'(char *a1, unsigned int a2, int a3, void (__thiscall *a4)(void *), void (__thiscall *a5)(void *))
{
  int result; // eax
  int i; // [esp+10h] [ebp-1Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    a4(a1);
    a1 += a2;
  }
  return result;
}
// 46D4B7: conditional instruction was optimized away because of '%var_20.4==1'

//----- (0046D4D0) --------------------------------------------------------
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count)
{
  size_t v3; // ecx
  size_t v4; // ebx
  const char *v5; // esi
  char *v6; // edi
  size_t v7; // ecx
  char v8; // al
  size_t v10; // ecx
  int v11; // eax
  int v12; // edx

  v3 = Count;
  if ( !Count )
    return Destination;
  v4 = Count;
  v5 = Source;
  v6 = Destination;
  if ( ((unsigned __int8)Source & 3) == 0 )
  {
    v7 = Count >> 2;
    if ( Count >> 2 )
      goto LABEL_21;
LABEL_10:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return Destination;
    }
    while ( --v4 )
LABEL_17:
      *v6++ = v8;
    return Destination;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return Destination;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return Destination;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
LABEL_9:
    v4 &= 3u;
    if ( v4 )
      goto LABEL_10;
    return Destination;
  }
  while ( 1 )
  {
LABEL_21:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto LABEL_20;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto LABEL_30;
    }
LABEL_20:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto LABEL_9;
  }
  *(_DWORD *)v6 = 0;
LABEL_30:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
LABEL_31:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto LABEL_17;
  return Destination;
}

//----- (0046D5CE) --------------------------------------------------------
int *__cdecl _dosmaperr(unsigned int a1)
{
  int v1; // esi
  _DWORD *v2; // eax
  int *result; // eax

  v1 = 0;
  *sub_46D64A() = a1;
  v2 = &unk_4B9CE0;
  do
  {
    if ( a1 == *v2 )
    {
      result = sub_46D641();
      *result = dword_4B9CE4[2 * v1];
      return result;
    }
    v2 += 2;
    ++v1;
  }
  while ( (int)v2 < (int)&unk_4B9E48 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || a1 > 0xCA )
    {
      result = sub_46D641();
      *result = 22;
    }
    else
    {
      result = sub_46D641();
      *result = 8;
    }
  }
  else
  {
    result = sub_46D641();
    *result = 13;
  }
  return result;
}

//----- (0046D641) --------------------------------------------------------
int *sub_46D641()
{
  return _getptd() + 2;
}

//----- (0046D64A) --------------------------------------------------------
int *sub_46D64A()
{
  return _getptd() + 3;
}

//----- (0046D660) --------------------------------------------------------
char *__cdecl strncat(char *Destination, const char *Source, size_t Count)
{
  size_t v3; // ecx
  char *v4; // edi
  int v6; // eax
  int v7; // eax
  char *v8; // edi
  const char *v9; // esi
  char v10; // bl
  size_t v11; // ecx
  int v12; // edx
  char v13; // dl
  char *result; // eax
  int v15; // eax

  v3 = Count;
  if ( !Count )
    return Destination;
  v4 = Destination;
  if ( ((unsigned __int8)Destination & 3) == 0 )
    goto LABEL_5;
  do
  {
    if ( !*v4++ )
    {
LABEL_10:
      v8 = v4 - 1;
      goto LABEL_14;
    }
  }
  while ( ((unsigned __int8)v4 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_5:
      v6 = (*(_DWORD *)v4 + 2130640639) ^ ~*(_DWORD *)v4;
      v4 += 4;
    }
    while ( (v6 & 0x81010100) == 0 );
    v7 = *((_DWORD *)v4 - 1);
    if ( !(_BYTE)v7 )
      break;
    if ( !BYTE1(v7) )
    {
      v8 = v4 - 3;
      goto LABEL_14;
    }
    if ( (v7 & 0xFF0000) == 0 )
    {
      v8 = v4 - 2;
      goto LABEL_14;
    }
    if ( (v7 & 0xFF000000) == 0 )
      goto LABEL_10;
  }
  v8 = v4 - 4;
LABEL_14:
  v9 = Source;
  if ( ((unsigned __int8)Source & 3) == 0 )
  {
    v10 = Count;
    v11 = Count >> 2;
    if ( Count >> 2 )
      goto LABEL_28;
LABEL_21:
    v3 = v10 & 3;
    if ( (v10 & 3) != 0 )
    {
      while ( 1 )
      {
        v13 = *v9++;
        *v8++ = v13;
        if ( !v13 )
          break;
        if ( !--v3 )
          goto LABEL_24;
      }
    }
    else
    {
LABEL_24:
      *v8 = v3;
    }
    return Destination;
  }
  do
  {
    LOBYTE(v12) = *v9++;
    if ( !(_BYTE)v12 )
    {
LABEL_26:
      *v8 = v12;
      return Destination;
    }
    *v8++ = v12;
    if ( !--v3 )
      goto LABEL_24;
  }
  while ( ((unsigned __int8)v9 & 3) != 0 );
  v10 = v3;
  v11 = v3 >> 2;
  if ( !v11 )
    goto LABEL_21;
  while ( 1 )
  {
LABEL_28:
    v15 = (*(_DWORD *)v9 + 2130640639) ^ ~*(_DWORD *)v9;
    v12 = *(_DWORD *)v9;
    v9 += 4;
    if ( (v15 & 0x81010100) == 0 )
      goto LABEL_27;
    if ( !(_BYTE)v12 )
      goto LABEL_26;
    if ( !BYTE1(v12) )
      break;
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_WORD *)v8 = v12;
      result = Destination;
      v8[2] = 0;
      return result;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v8 = v12;
      return Destination;
    }
LABEL_27:
    *(_DWORD *)v8 = v12;
    v8 += 4;
    if ( !--v11 )
      goto LABEL_21;
  }
  *(_WORD *)v8 = (unsigned __int8)v12;
  return Destination;
}

//----- (0046D783) --------------------------------------------------------
int __cdecl atol_0(const char *String)
{
  int v3; // esi
  const char *v4; // edi
  int v5; // ebp
  int v6; // ebx
  int result; // eax

  while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][*(unsigned __int8 *)String] & 8 : _isctype_0(
                                                                                     *(unsigned __int8 *)String,
                                                                                     8) )
    ++String;
  v3 = *(unsigned __int8 *)String;
  v4 = String + 1;
  v5 = v3;
  if ( v3 == 45 || v3 == 43 )
    v3 = *(unsigned __int8 *)v4++;
  v6 = 0;
  while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][v3] & 4 : _isctype_0(v3, 4) )
  {
    v6 = v3 + 10 * v6 - 48;
    v3 = *(unsigned __int8 *)v4++;
  }
  result = v6;
  if ( v5 == 45 )
    result = -v6;
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (0046D80E) --------------------------------------------------------
int __cdecl sub_46D80E(char *String)
{
  return atol_0(String);
}

//----- (0046D8F0) --------------------------------------------------------
char *__cdecl strchr(const char *Str, int Val)
{
  const char *v2; // edx
  char v3; // cl
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  unsigned int v7; // eax
  char *result; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax

  v2 = Str;
  if ( ((unsigned __int8)Str & 3) != 0 )
  {
    while ( 1 )
    {
      v3 = *v2++;
      if ( v3 == (_BYTE)Val )
        break;
      if ( !v3 )
        return 0;
      if ( ((unsigned __int8)v2 & 3) == 0 )
        goto LABEL_5;
    }
    result = (char *)(v2 - 1);
  }
  else
  {
    while ( 1 )
    {
LABEL_5:
      while ( 1 )
      {
        v4 = (((unsigned __int8)Val << 8) | (unsigned __int8)Val | ((((unsigned __int8)Val << 8) | (unsigned __int8)Val) << 16)) ^ *(_DWORD *)v2;
        v5 = *(_DWORD *)v2 + 2130640639;
        v6 = v5 ^ ~*(_DWORD *)v2;
        v2 += 4;
        if ( (((v4 + 2130640639) ^ ~v4) & 0x81010100) != 0 )
          break;
        v7 = v6 & 0x81010100;
        if ( v7 && ((v7 & 0x1010100) != 0 || (v5 & 0x80000000) == 0) )
          return 0;
      }
      v9 = *((_DWORD *)v2 - 1);
      if ( (_BYTE)v9 == (_BYTE)Val )
        break;
      if ( !(_BYTE)v9 )
        return 0;
      if ( BYTE1(v9) == (_BYTE)Val )
        return (char *)(v2 - 3);
      if ( !BYTE1(v9) )
        return 0;
      v10 = HIWORD(v9);
      if ( (_BYTE)v10 == (_BYTE)Val )
        return (char *)(v2 - 2);
      if ( !(_BYTE)v10 )
        return 0;
      if ( BYTE1(v10) == (_BYTE)Val )
        return (char *)(v2 - 1);
      if ( !BYTE1(v10) )
        return 0;
    }
    result = (char *)(v2 - 4);
  }
  return result;
}

//----- (0046D9AC) --------------------------------------------------------
int __cdecl vsprintf_0(char *const Buffer, const char *const Format, va_list ArgList)
{
  int v3; // eax
  bool v4; // sf
  int v5; // esi
  FILE File; // [esp+4h] [ebp-20h] BYREF

  File._base = Buffer;
  File._ptr = Buffer;
  File._flag = 66;
  File._cnt = 0x7FFFFFFF;
  v3 = sub_472811(&File, (char *)Format, (int)ArgList);
  v4 = --File._cnt < 0;
  v5 = v3;
  if ( v4 )
    _flsbuf(0, &File);
  else
    *File._ptr = 0;
  return v5;
}

//----- (0046D9FD) --------------------------------------------------------
int __cdecl sub_46D9FD(size_t a1)
{
  return _nh_malloc_0(a1, dword_4C1BF0);
}
// 4C1BF0: using guessed type int dword_4C1BF0;

//----- (0046DA0F) --------------------------------------------------------
int __cdecl _nh_malloc_0(size_t Size, int a2)
{
  int result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = sub_46DA3B(Size);
    if ( result || !a2 )
      break;
    if ( !sub_473045(Size) )
      return 0;
  }
  return result;
}

//----- (0046DA3B) --------------------------------------------------------
int __cdecl sub_46DA3B(unsigned int a1)
{
  int result; // eax
  unsigned int v2; // esi
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-1Ch]

  if ( dword_4C3270 == 3 )
  {
    if ( a1 <= dword_4C3268 )
    {
      _lock(9);
      v5 = __sbh_alloc_block_0(a1);
      sub_46FA37(9);
      result = (int)v5;
      if ( v5 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_4C3270 != 2 )
  {
LABEL_12:
    v3 = a1;
    if ( !a1 )
      v3 = 1;
    v4 = v3 + 15;
    LOBYTE(v4) = v4 & 0xF0;
    return dword_4A7214(dword_4C326C, 0, v4);
  }
  if ( a1 )
    v2 = (a1 + 15) & 0xFFFFFFF0;
  else
    v2 = 16;
  if ( v2 > dword_4BBF8C || (_lock(9), v6 = sub_472151(v2 >> 4), sub_46FA37(9), (result = v6) == 0) )
    result = dword_4A7214(dword_4C326C, 0, v2);
  return result;
}
// 46F9D6: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4BBF8C: using guessed type int dword_4BBF8C;
// 4C3268: using guessed type int dword_4C3268;
// 4C3270: using guessed type int dword_4C3270;

//----- (0046DB69) --------------------------------------------------------
int __cdecl sub_46DB69(int a1)
{
  int v1; // esi

  v1 = _getptd()[26];
  _getptd()[26] = a1;
  return v1;
}

//----- (0046DC4A) --------------------------------------------------------
void *__cdecl sub_46DC4A(void *Src, size_t a2)
{
  const void *v2; // ebx
  void *result; // eax
  unsigned int v4; // esi
  _DWORD *v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // edi
  size_t v10; // eax
  size_t v11; // eax
  void **v12; // [esp+Ch] [ebp-38h] BYREF
  size_t v13; // [esp+10h] [ebp-34h]
  _BYTE *v14; // [esp+14h] [ebp-30h]
  _DWORD *v15; // [esp+18h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+1Ch] [ebp-28h]
  void *v17; // [esp+20h] [ebp-24h]
  size_t v18; // [esp+24h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  v2 = Src;
  if ( !Src )
    return (void *)sub_46D9FD(a2);
  v4 = a2;
  if ( a2 )
  {
    if ( dword_4C3270 == 3 )
    {
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 0;
          v5 = (_DWORD *)__sbh_find_block_0((int)Src);
          v16 = v5;
          if ( v5 )
          {
            if ( v4 <= dword_4C3268 )
            {
              if ( __sbh_resize_block_0(v5, (int)Src, v4) )
              {
                v17 = Src;
              }
              else
              {
                v17 = __sbh_alloc_block_0(v4);
                if ( v17 )
                {
                  v6 = *((_DWORD *)Src - 1) - 1;
                  v18 = v6;
                  if ( v6 >= v4 )
                    v6 = v4;
                  memcpy_0(v17, Src, v6);
                  v16 = (_DWORD *)__sbh_find_block_0((int)Src);
                  sub_470F63(v16, (int)Src);
                }
              }
            }
            if ( !v17 )
            {
              if ( !v4 )
                v4 = 1;
              v4 = (v4 + 15) & 0xFFFFFFF0;
              v17 = (void *)dword_4A7214(dword_4C326C, 0, v4);
              if ( v17 )
              {
                v7 = *((_DWORD *)Src - 1) - 1;
                v18 = v7;
                if ( v7 >= v4 )
                  v7 = v4;
                memcpy_0(v17, Src, v7);
                sub_470F63(v16, (int)Src);
              }
            }
          }
          ms_exc.registration.TryLevel = -1;
          sub_46FA37(9);
          if ( !v16 )
          {
            if ( !v4 )
              v4 = 1;
            v4 = (v4 + 15) & 0xFFFFFFF0;
            v17 = (void *)dword_4A7210(dword_4C326C, 0, Src, v4);
          }
        }
        result = v17;
        if ( v17 || !dword_4C1BF0 )
          break;
        if ( !sub_473045(v4) )
          goto LABEL_61;
      }
    }
    else if ( dword_4C3270 == 2 )
    {
      if ( a2 <= 0xFFFFFFE0 )
        v4 = (a2 + 15) & 0xFFFFFFF0;
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 1;
          v8 = (_BYTE *)sub_4720B5((unsigned int)v2, &v12, (unsigned int *)&v15);
          v9 = v8;
          v14 = v8;
          if ( v8 )
          {
            if ( v4 < dword_4BBF8C )
            {
              if ( sub_47247D((int)v12, v15, v8, v4 >> 4) )
              {
                v17 = Src;
              }
              else
              {
                v17 = (void *)sub_472151(v4 >> 4);
                if ( v17 )
                {
                  v10 = 16 * (unsigned __int8)*v9;
                  v13 = v10;
                  if ( v10 >= v4 )
                    v10 = v4;
                  memcpy_0(v17, Src, v10);
                  sub_47210C((int)v12, (int)v15, v9);
                }
              }
              v2 = Src;
            }
            if ( !v17 )
            {
              v17 = (void *)dword_4A7214(dword_4C326C, 0, v4);
              if ( v17 )
              {
                v11 = 16 * (unsigned __int8)*v9;
                v13 = v11;
                if ( v11 >= v4 )
                  v11 = v4;
                memcpy_0(v17, v2, v11);
                sub_47210C((int)v12, (int)v15, v9);
              }
            }
          }
          else
          {
            v17 = (void *)dword_4A7210(dword_4C326C, 0, v2, v4);
          }
          ms_exc.registration.TryLevel = -1;
          sub_46FA37(9);
        }
        result = v17;
        if ( v17 || !dword_4C1BF0 )
          break;
        if ( !sub_473045(v4) )
          goto LABEL_61;
      }
    }
    else
    {
      while ( 1 )
      {
        result = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          if ( !v4 )
            v4 = 1;
          v4 = (v4 + 15) & 0xFFFFFFF0;
          result = (void *)dword_4A7210(dword_4C326C, 0, Src, v4);
        }
        if ( result || !dword_4C1BF0 )
          break;
        if ( !sub_473045(v4) )
          goto LABEL_61;
      }
    }
  }
  else
  {
    sub_46D360((unsigned int)Src);
LABEL_61:
    result = 0;
  }
  return result;
}
// 46DDEE: conditional instruction was optimized away because of '%arg_4.4 in (1..FFFFFFE0)'
// 4A7210: using guessed type int (__stdcall *dword_4A7210)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4BBF8C: using guessed type int dword_4BBF8C;
// 4C1BF0: using guessed type int dword_4C1BF0;
// 4C3268: using guessed type int dword_4C3268;
// 4C3270: using guessed type int dword_4C3270;

//----- (0046DF81) --------------------------------------------------------
int __cdecl toupper(int C)
{
  int v1; // ebx
  int result; // eax
  void (__stdcall *v3)(int *); // edi
  int Ca; // [esp+Ch] [ebp+4h]

  v1 = 0;
  if ( dword_4C1C0C )
  {
    dword_4A7204(&dword_4C3248);
    v3 = (void (__stdcall *)(int *))dword_4A720C;
    if ( dword_4C3244 )
    {
      dword_4A720C(&dword_4C3248);
      _lock(19);
      v1 = 1;
    }
    Ca = toupper_0(C);
    if ( v1 )
      sub_46FA37(19);
    else
      v3(&dword_4C3248);
    result = Ca;
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      result = C - 32;
  }
  return result;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (0046DFF0) --------------------------------------------------------
int __cdecl toupper_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  unsigned __int16 v5; // [esp+4h] [ebp-4h] BYREF

  if ( dword_4C1C0C )
  {
    v2 = C;
    if ( (C >= 256 || ((int)dword_4BC19C <= 1 ? (v3 = off_4BBF90[0][C] & 2) : (v3 = _isctype_0(C, 2)), v3))
      && (off_4BBF90[0][BYTE1(v2)] >= 0 ? (LOWORD(C) = (unsigned __int8)v2,
                                           v4 = __crtLCMapStringA_0(
                                                  dword_4C1C0C,
                                                  0x200u,
                                                  (LPCSTR)&C,
                                                  1,
                                                  (LPSTR)&v5,
                                                  3,
                                                  0,
                                                  1)) : (LOBYTE(C) = BYTE1(v2),
                                                         *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2,
                                                         v4 = __crtLCMapStringA_0(
                                                                dword_4C1C0C,
                                                                0x200u,
                                                                (LPCSTR)&C,
                                                                2,
                                                                (LPSTR)&v5,
                                                                3,
                                                                0,
                                                                1)),
          v4) )
    {
      if ( v4 == 1 )
        result = (unsigned __int8)v5;
      else
        result = v5;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      result = C - 32;
  }
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4C1C0C: using guessed type int dword_4C1C0C;

//----- (0046E0C4) --------------------------------------------------------
int __cdecl tolower(int C)
{
  int v1; // ebx
  int result; // eax
  void (__stdcall *v3)(int *); // edi
  int Ca; // [esp+Ch] [ebp+4h]

  v1 = 0;
  if ( dword_4C1C0C )
  {
    dword_4A7204(&dword_4C3248);
    v3 = (void (__stdcall *)(int *))dword_4A720C;
    if ( dword_4C3244 )
    {
      dword_4A720C(&dword_4C3248);
      _lock(19);
      v1 = 1;
    }
    Ca = tolower_0(C);
    if ( v1 )
      sub_46FA37(19);
    else
      v3(&dword_4C3248);
    result = Ca;
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      result = C + 32;
  }
  return result;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (0046E133) --------------------------------------------------------
int __cdecl tolower_0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int16 v6; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_4C1C0C )
  {
    v2 = C;
    if ( (C >= 256 || ((int)dword_4BC19C <= 1 ? (v3 = off_4BBF90[0][C] & 1) : (v3 = _isctype_0(C, 1)), v3))
      && (off_4BBF90[0][BYTE1(v2)] >= 0 ? (LOWORD(C) = (unsigned __int8)v2, v4 = 1) : (LOBYTE(C) = BYTE1(v2),
                                                                                       *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2,
                                                                                       v4 = 2),
          (v5 = __crtLCMapStringA_0(dword_4C1C0C, 0x100u, (LPCSTR)&C, v4, (LPSTR)&v6, 3, 0, 1)) != 0) )
    {
      if ( v5 == 1 )
        result = (unsigned __int8)v6;
      else
        result = v6;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      result = C + 32;
  }
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4C1C0C: using guessed type int dword_4C1C0C;

//----- (0046E200) --------------------------------------------------------
void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount)
{
  void *result; // eax
  unsigned __int8 *v4; // edx
  int v5; // ebx
  unsigned __int8 v6; // cl
  bool v7; // cf
  char *v8; // eax
  unsigned __int8 v9; // cl
  int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx

  result = (void *)MaxCount;
  if ( MaxCount )
  {
    v4 = (unsigned __int8 *)Buf;
    LOBYTE(v5) = Val;
    if ( ((unsigned __int8)Buf & 3) != 0 )
    {
      do
      {
        v6 = *v4++;
        if ( (unsigned __int8)Val == v6 )
          return v4 - 1;
        result = (char *)result - 1;
        if ( !result )
          return result;
      }
      while ( ((unsigned __int8)v4 & 3) != 0 );
    }
    v7 = (unsigned int)result < 4;
    v8 = (char *)result - 4;
    if ( !v7 )
    {
      v5 = 16843009 * (unsigned __int8)Val;
      do
      {
        v10 = v5 ^ *(_DWORD *)v4;
        v4 += 4;
        if ( (((v10 + 2130640639) ^ ~v10) & 0x81010100) != 0 )
        {
          v11 = *((_DWORD *)v4 - 1);
          LOBYTE(v11) = Val ^ v11;
          if ( !(_BYTE)v11 )
            return v4 - 4;
          BYTE1(v11) ^= Val;
          if ( !BYTE1(v11) )
            return v4 - 3;
          v12 = HIWORD(v11);
          if ( (unsigned __int8)Val == (unsigned __int8)v12 )
            return v4 - 2;
          if ( (unsigned __int8)Val == BYTE1(v12) )
            return v4 - 1;
        }
        v7 = (unsigned int)v8 < 4;
        v8 -= 4;
      }
      while ( !v7 );
    }
    result = v8 + 4;
    if ( result )
    {
      while ( 1 )
      {
        v9 = *v4++;
        if ( (unsigned __int8)v5 == v9 )
          break;
        result = (char *)result - 1;
        if ( !result )
          return result;
      }
      return v4 - 1;
    }
  }
  return result;
}

//----- (0046E2A5) --------------------------------------------------------
int sprintf_0(char *const Buffer, const char *const Format, ...)
{
  int v2; // eax
  bool v3; // sf
  int v4; // esi
  FILE File; // [esp+4h] [ebp-20h] BYREF
  va_list va; // [esp+34h] [ebp+10h] BYREF

  va_start(va, Format);
  File._base = Buffer;
  File._ptr = Buffer;
  File._flag = 66;
  File._cnt = 0x7FFFFFFF;
  v2 = sub_472811(&File, (char *)Format, (int)va);
  v3 = --File._cnt < 0;
  v4 = v2;
  if ( v3 )
    _flsbuf(0, &File);
  else
    *File._ptr = 0;
  return v4;
}

//----- (0046E2F7) --------------------------------------------------------
int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList)
{
  int v4; // eax
  bool v5; // sf
  int v6; // esi
  FILE File; // [esp+4h] [ebp-20h] BYREF

  File._base = Buffer;
  File._ptr = Buffer;
  File._cnt = BufferCount;
  File._flag = 66;
  v4 = sub_472811(&File, (char *)Format, (int)ArgList);
  v5 = --File._cnt < 0;
  v6 = v4;
  if ( v5 )
    _flsbuf(0, &File);
  else
    *File._ptr = 0;
  return v6;
}

//----- (0046E347) --------------------------------------------------------
_onexit_t __cdecl _onexit(_onexit_t Func)
{
  unsigned int v1; // eax
  _onexit_t *v2; // ecx
  int v3; // eax
  char *v4; // eax
  int (__cdecl *v5)(); // esi
  int v6; // ecx

  sub_46E591();
  v1 = sub_473C5D(dword_4C3288);
  v2 = (_onexit_t *)dword_4C3284;
  if ( v1 >= dword_4C3284 - dword_4C3288 + 4 )
    goto LABEL_5;
  v3 = sub_473C5D(dword_4C3288);
  v4 = (char *)sub_46DC4A((void *)dword_4C3288, v3 + 16);
  if ( v4 )
  {
    v6 = dword_4C3284 - dword_4C3288;
    dword_4C3288 = (int)v4;
    v2 = (_onexit_t *)&v4[4 * (v6 >> 2)];
    dword_4C3284 = (int)v2;
LABEL_5:
    *v2 = Func;
    dword_4C3284 += 4;
    v5 = Func;
    goto LABEL_6;
  }
  v5 = 0;
LABEL_6:
  sub_46E59A();
  return v5;
}
// 4C3284: using guessed type int dword_4C3284;
// 4C3288: using guessed type int dword_4C3288;

//----- (0046E3C5) --------------------------------------------------------
int __cdecl sub_46E3C5(_onexit_t Func)
{
  return (_onexit(Func) != 0) - 1;
}

//----- (0046E406) --------------------------------------------------------
int sub_46E406(char *a1, ...)
{
  int v1; // edi
  int v2; // ebx
  va_list va; // [esp+14h] [ebp+8h] BYREF

  va_start(va, a1);
  _lock_file2(1, (int)&stru_4BC328);
  v1 = _stbuf_0((int)&stru_4BC328);
  v2 = sub_472811(&stru_4BC328, a1, (int)va);
  _ftbuf(v1, (int)&stru_4BC328);
  sub_473E88(1, (int)&stru_4BC328);
  return v2;
}

//----- (0046E47F) --------------------------------------------------------
void _cinit_0()
{
  if ( off_4B9CC8 )
    off_4B9CC8();
  sub_46E5A3(off_4B801C, (unsigned int)&unk_4B8030);
  sub_46E5A3(off_4B8000, (unsigned int)&unk_4B8018);
}
// 4B9CC8: using guessed type int (*off_4B9CC8)(void);

//----- (0046E4AC) --------------------------------------------------------
int __cdecl sub_46E4AC(int a1)
{
  return sub_46E4EC(a1, 0, 0);
}

//----- (0046E4BD) --------------------------------------------------------
int __cdecl sub_46E4BD(int a1)
{
  return sub_46E4EC(a1, 1, 0);
}

//----- (0046E4EC) --------------------------------------------------------
int __cdecl sub_46E4EC(int a1, int a2, int a3)
{
  int v3; // eax
  void (**v4)(void); // esi

  sub_46E591();
  if ( dword_4C1B58 == 1 )
  {
    v3 = dword_4A7104(a1);
    dword_4A71FC(v3);
  }
  dword_4C1B54 = 1;
  byte_4C1B50 = a3;
  if ( !a2 )
  {
    if ( dword_4C3288 )
    {
      v4 = (void (**)(void))(dword_4C3284 - 4);
      if ( dword_4C3284 - 4 >= (unsigned int)dword_4C3288 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ( (unsigned int)v4 >= dword_4C3288 );
      }
    }
    sub_46E5A3(off_4B8034, (unsigned int)&unk_4B803C);
  }
  sub_46E5A3(off_4B8040, (unsigned int)&unk_4B8048);
  if ( a3 )
    return sub_46E59A();
  dword_4C1B58 = 1;
  return dword_4A7200(a1);
}
// 4A7104: using guessed type int (__stdcall *dword_4A7104)(_DWORD);
// 4A71FC: using guessed type int (__stdcall *dword_4A71FC)(_DWORD);
// 4A7200: using guessed type int (__stdcall *dword_4A7200)(_DWORD);
// 4C1B50: using guessed type char byte_4C1B50;
// 4C1B54: using guessed type int dword_4C1B54;
// 4C1B58: using guessed type int dword_4C1B58;
// 4C3284: using guessed type int dword_4C3284;
// 4C3288: using guessed type int dword_4C3288;

//----- (0046E591) --------------------------------------------------------
int sub_46E591()
{
  return _lock(13);
}
// 46F9D6: using guessed type _DWORD __cdecl _lock(_DWORD);

//----- (0046E59A) --------------------------------------------------------
int sub_46E59A()
{
  return sub_46FA37(13);
}

//----- (0046E5A3) --------------------------------------------------------
void __cdecl sub_46E5A3(void (**a1)(void), unsigned int a2)
{
  while ( (unsigned int)a1 < a2 )
  {
    if ( *a1 )
      (*a1)();
    ++a1;
  }
}

//----- (0046E5BD) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
__time32_t __cdecl time_0(__time32_t *const Time)
{
  int v1; // eax
  int v2; // eax
  __time32_t result; // eax
  _DWORD v4[38]; // [esp+0h] [ebp-CCh] BYREF
  __int16 v5; // [esp+9Ah] [ebp-32h]
  int v6; // [esp+A8h] [ebp-24h]
  int v7; // [esp+ACh] [ebp-20h] BYREF
  int v8; // [esp+B0h] [ebp-1Ch]
  int v9; // [esp+B4h] [ebp-18h]
  int v10; // [esp+B8h] [ebp-14h]
  int v11; // [esp+BCh] [ebp-10h] BYREF
  unsigned __int16 v12; // [esp+C2h] [ebp-Ah]
  unsigned __int16 v13; // [esp+C4h] [ebp-8h]
  unsigned __int16 v14; // [esp+C6h] [ebp-6h]
  unsigned __int16 v15; // [esp+C8h] [ebp-4h]

  dword_4A7294(&v11, v4[0], v4[1], v4[2]);
  dword_4A71F8(&v7);
  if ( v9 == dword_4C1B70 && HIWORD(v8) == word_4C1B6E && v7 == dword_4C1B68 )
  {
    v1 = dword_4C1B60;
  }
  else
  {
    v2 = dword_4A712C(v4);
    if ( v2 == -1 )
      v1 = -1;
    else
      v1 = v2 == 2 && v5 && v6;
    dword_4C1B68 = v7;
    *(&dword_4C1B68 + 1) = v8;
    *(&dword_4C1B68 + 2) = v9;
    *(&dword_4C1B68 + 3) = v10;
    dword_4C1B60 = v1;
  }
  result = __loctotime_t_0((unsigned __int16)v11, HIWORD(v11), v12, v13, v14, v15, v1);
  if ( Time )
    *Time = result;
  return result;
}
// 46E629: bad sp value at call
// 4A712C: using guessed type int (__stdcall *dword_4A712C)(_DWORD);
// 4A71F8: using guessed type int (__cdecl *dword_4A71F8)(_DWORD);
// 4A7294: using guessed type int (__stdcall *dword_4A7294)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C1B60: using guessed type int dword_4C1B60;
// 4C1B68: using guessed type int dword_4C1B68;
// 4C1B6E: using guessed type __int16 word_4C1B6E;
// 4C1B70: using guessed type int dword_4C1B70;

//----- (0046E717) --------------------------------------------------------
int __cdecl isdigit(int C)
{
  int result; // eax

  if ( (int)dword_4BC19C <= 1 )
    result = off_4BBF90[0][C] & 4;
  else
    result = _isctype_0(C, 4);
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (0046E76C) --------------------------------------------------------
int __cdecl isspace(int C)
{
  int result; // eax

  if ( (int)dword_4BC19C <= 1 )
    result = off_4BBF90[0][C] & 8;
  else
    result = _isctype_0(C, 8);
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (0046E7BC) --------------------------------------------------------
int __cdecl isalnum(int C)
{
  int result; // eax

  if ( (int)dword_4BC19C <= 1 )
    result = off_4BBF90[0][C] & 0x107;
  else
    result = _isctype_0(C, 263);
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (0046E900) --------------------------------------------------------
char *__cdecl strstr(const char *Str, const char *SubStr)
{
  char v2; // dl
  const char *v3; // edi
  char v4; // dh
  const char *v5; // ecx
  char *v6; // esi
  char v7; // al
  char v9; // ah
  char v10; // al
  char v11; // al

  v2 = *SubStr;
  v3 = Str;
  if ( !*SubStr )
    return (char *)Str;
  v4 = SubStr[1];
  if ( !v4 )
    JUMPOUT(0x46D8F6);
LABEL_3:
  v5 = SubStr;
  v6 = (char *)(v3 + 1);
  if ( *v3 == v2 )
    goto LABEL_9;
  if ( *v3 )
  {
    while ( 2 )
    {
      v7 = *v6++;
      while ( v7 == v2 )
      {
LABEL_9:
        v7 = *v6++;
        if ( v7 == v4 )
        {
          v3 = v6 - 1;
          while ( 1 )
          {
            v9 = v5[2];
            if ( !v9 )
              break;
            v10 = *v6;
            v6 += 2;
            if ( v10 != v9 )
              goto LABEL_3;
            v11 = v5[3];
            if ( !v11 )
              break;
            v5 += 2;
            if ( v11 != *(v6 - 1) )
              goto LABEL_3;
          }
          return (char *)(v3 - 1);
        }
      }
      if ( v7 )
        continue;
      break;
    }
  }
  return 0;
}
// 46E96E: control flows out of bounds to 46D8F6

//----- (0046E980) --------------------------------------------------------
int *__cdecl sub_46E980(int a1)
{
  int *result; // eax

  result = _getptd();
  result[5] = a1;
  return result;
}

//----- (0046E98D) --------------------------------------------------------
int __cdecl rand()
{
  int *v0; // eax
  unsigned int v1; // ecx

  v0 = _getptd();
  v1 = 214013 * v0[5] + 2531011;
  v0[5] = v1;
  return HIWORD(v1) & 0x7FFF;
}

//----- (0046E9AF) --------------------------------------------------------
long double __cdecl _ceil_default(long double x)
{
  __int16 v1; // cx
  int v2; // ebx
  int v3; // eax
  long double result; // st7
  _BYTE v5[12]; // [esp+4h] [ebp-20h]
  __int16 v6; // [esp+10h] [ebp-14h]
  __int16 v7; // [esp+10h] [ebp-14h]
  double v8; // [esp+1Ch] [ebp-8h]

  v2 = _ctrlfp(v1);
  if ( (HIWORD(x) & 0x7FF0) == 32752 )
  {
    v3 = _sptype(SLODWORD(x), SHIDWORD(x));
    if ( v3 > 0 )
    {
      if ( v3 <= 2 )
      {
        _ctrlfp(v6);
        return x;
      }
      if ( v3 == 3 )
      {
        *(double *)&v5[4] = x;
        *(_DWORD *)v5 = 11;
        return _handle_qnan1(*(double *)v5, SHIDWORD(x));
      }
    }
    result = _except1(8u, 11, SLODWORD(x), SHIDWORD(x), x + dbl_4A91C8, v2);
  }
  else
  {
    v8 = sub_4747E1(x);
    if ( v8 == x || (v2 & 0x20) != 0 )
    {
      _ctrlfp(v7);
      result = v8;
    }
    else
    {
      result = _except1(0x10u, 11, SLODWORD(x), SHIDWORD(x), v8, v2);
    }
  }
  return result;
}
// 46E9C2: variable 'v1' is possibly undefined
// 46EA0C: variable 'v6' is possibly undefined
// 46EA4C: variable 'v7' is possibly undefined
// 4A91C8: using guessed type double dbl_4A91C8;

//----- (0046EA80) --------------------------------------------------------
char *__cdecl strrchr(const char *Str, int Ch)
{
  unsigned int v2; // ecx
  const char *v3; // edi
  bool v4; // zf
  char *v5; // edi
  char *result; // eax

  v2 = strlen(Str) + 1;
  v3 = &Str[v2 - 1];
  do
  {
    if ( !v2 )
      break;
    v4 = *v3-- == (unsigned __int8)Ch;
    --v2;
  }
  while ( !v4 );
  v5 = (char *)(v3 + 1);
  if ( *v5 == (_BYTE)Ch )
    result = v5;
  else
    result = 0;
  return result;
}

//----- (0046EAA7) --------------------------------------------------------
void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction)
{
  char *v5; // esi
  size_t v6; // eax
  char *i; // edi
  char *v8; // eax
  char *v9; // eax
  void **v10; // edx
  char **v11; // ecx
  void **v12; // ecx
  char **v13; // eax
  char v14; // [esp+Ch] [ebp-F8h] BYREF
  char v15; // [esp+84h] [ebp-80h] BYREF
  char *v16; // [esp+FCh] [ebp-8h]
  int v17; // [esp+100h] [ebp-4h]
  char **Basea; // [esp+10Ch] [ebp+8h]
  void **NumOfElementsa; // [esp+110h] [ebp+Ch]

  if ( NumOfElements >= 2 && SizeOfElements )
  {
    v17 = 0;
    Basea = (char **)&v15;
    v5 = (char *)Base + SizeOfElements * (NumOfElements - 1);
    NumOfElementsa = (void **)&v14;
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = (v5 - (_BYTE *)Base) / SizeOfElements + 1;
        if ( v6 <= 8 )
        {
          shortsort((char *)Base, v5, SizeOfElements, (int (__cdecl *)(char *))CompareFunction);
          goto LABEL_6;
        }
        swap((char *)Base + SizeOfElements * (v6 >> 1), (char *)Base, SizeOfElements);
        v16 = (char *)Base;
        for ( i = &v5[SizeOfElements]; ; swap(v16, i, SizeOfElements) )
        {
          do
          {
            v8 = &v16[SizeOfElements];
            v16 += SizeOfElements;
          }
          while ( v16 <= v5 && ((int (__cdecl *)(char *))CompareFunction)(v8) <= 0 );
          do
            i -= SizeOfElements;
          while ( i > Base && ((int (__cdecl *)(char *))CompareFunction)(i) >= 0 );
          if ( i < v16 )
            break;
        }
        swap((char *)Base, i, SizeOfElements);
        v9 = v16;
        if ( i - (_BYTE *)Base - 1 >= v5 - v16 )
          break;
        if ( v16 < v5 )
        {
          v12 = NumOfElementsa;
          ++v17;
          ++NumOfElementsa;
          *v12 = v16;
          v13 = Basea++;
          *v13 = v5;
        }
        if ( (char *)Base + SizeOfElements >= i )
        {
LABEL_6:
          --v17;
          --NumOfElementsa;
          --Basea;
          if ( v17 < 0 )
            return;
          Base = *NumOfElementsa;
          v5 = *Basea;
        }
        else
        {
          v5 = &i[-SizeOfElements];
        }
      }
      if ( (char *)Base + SizeOfElements < i )
      {
        v10 = NumOfElementsa++;
        v11 = Basea;
        ++v17;
        ++Basea;
        *v10 = Base;
        *v11 = &i[-SizeOfElements];
      }
      if ( v9 >= v5 )
        goto LABEL_6;
      Base = v9;
    }
  }
}

//----- (0046EBFB) --------------------------------------------------------
char *__cdecl shortsort(char *a1, char *a2, int a3, int (__cdecl *a4)(char *))
{
  char *result; // eax
  char *i; // edi
  char *v6; // ebx
  char *j; // esi

  result = a1;
  for ( i = a2; i > a1; i -= a3 )
  {
    v6 = a1;
    for ( j = &a1[a3]; j <= i; j += a3 )
    {
      if ( a4(j) > 0 )
        v6 = j;
    }
    result = swap(v6, i, a3);
  }
  return result;
}

//----- (0046EC49) --------------------------------------------------------
// _swap
char *__cdecl swap(char *a1, char *a2, int a3)
{
  char *result; // eax
  char *v4; // ecx
  int v5; // esi
  char v6; // dl

  result = a1;
  v4 = a2;
  if ( a1 != a2 && a3 )
  {
    v5 = a3;
    do
    {
      v6 = *result;
      *result++ = *v4;
      *v4++ = v6;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (0046EC75) --------------------------------------------------------
struct tm *__cdecl localtime(const __time32_t *const Time)
{
  const __time32_t *v1; // esi
  int v3; // eax
  struct tm *v4; // eax
  struct tm *v5; // esi
  bool v6; // zf
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  bool v12; // sf
  int v13; // eax

  v1 = Time;
  if ( *Time < 0 )
    return 0;
  __tzset();
  v3 = *v1;
  if ( *v1 > 259200 && v3 < 2147224447 )
  {
    Time = (const __time32_t *const)(v3 - dword_4BC6A0);
    v4 = gmtime((const __time32_t *const)&Time);
    v5 = v4;
    if ( dword_4BC6A4 )
    {
      if ( _isindst(v4) )
      {
        Time = (const __time32_t *const)((char *)Time - dword_4BC6A8);
        v5 = gmtime((const __time32_t *const)&Time);
        v5->tm_isdst = 1;
      }
    }
    return v5;
  }
  v5 = gmtime(v1);
  v6 = _isindst(v5) == 0;
  v7 = v5->tm_sec;
  if ( !v6 )
    v7 -= dword_4BC6A8;
  Time = (const __time32_t *const)(v7 - dword_4BC6A0);
  v8 = (v7 - dword_4BC6A0) % 60;
  v5->tm_sec = v8;
  if ( v8 < 0 )
  {
    v5->tm_sec = v8 + 60;
    Time -= 15;
  }
  Time = (const __time32_t *const)(v5->tm_min + (int)Time / 60);
  v9 = (int)Time % 60;
  v12 = (int)Time % 60 < 0;
  v5->tm_min = (int)Time % 60;
  if ( v12 )
  {
    v5->tm_min = v9 + 60;
    Time -= 15;
  }
  Time = (const __time32_t *const)(v5->tm_hour + (int)Time / 60);
  v10 = (int)Time % 24;
  v12 = (int)Time % 24 < 0;
  v5->tm_hour = (int)Time % 24;
  if ( v12 )
  {
    v5->tm_hour = v10 + 24;
    Time -= 6;
  }
  v11 = (int)Time / 24;
  v12 = (int)Time / 24 < 0;
  Time = (const __time32_t *const)((int)Time / 24);
  if ( (int)Time <= 0 )
  {
    if ( !v12 )
      return v5;
    v5->tm_wday = (v5->tm_wday + v11 + 7) % 7;
    v5->tm_mday += (int)Time;
    v13 = v5->tm_mday;
    if ( v13 <= 0 )
    {
      --v5->tm_year;
      v5->tm_mday = v13 + 31;
      v5->tm_yday = 364;
      v5->tm_mon = 11;
      return v5;
    }
  }
  else
  {
    v5->tm_wday = (v11 + v5->tm_wday) % 7;
    v5->tm_mday += (int)Time;
  }
  v5->tm_yday += (int)Time;
  return v5;
}
// 4BC6A0: using guessed type int dword_4BC6A0;
// 4BC6A4: using guessed type int dword_4BC6A4;
// 4BC6A8: using guessed type int dword_4BC6A8;

//----- (0046EDE0) --------------------------------------------------------
int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount)
{
  int v3; // ecx
  const char *v4; // edi
  bool v5; // zf
  size_t v6; // ecx
  const char *v7; // edi
  unsigned __int8 v9; // al

  v3 = MaxCount;
  if ( MaxCount )
  {
    v4 = Str1;
    do
    {
      if ( !v3 )
        break;
      v5 = *v4++ == 0;
      --v3;
    }
    while ( !v5 );
    v6 = MaxCount - v3;
    v7 = Str1;
    do
    {
      if ( !v6 )
        break;
      v5 = *Str2++ == *v7++;
      --v6;
    }
    while ( v5 );
    v9 = *(Str2 - 1);
    v3 = 0;
    if ( v9 > (unsigned int)*(v7 - 1) )
      return ~v3;
    if ( v9 != *(v7 - 1) )
    {
      v3 = -2;
      return ~v3;
    }
  }
  return v3;
}

//----- (0046EF20) --------------------------------------------------------
void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_4C1B80 == 1 )
    _FF_MSGBANNER_0();
  _NMSG_WRITE_0(NumberOfBytesWritten);
  off_4B9E60(255);
}
// 4B9E60: using guessed type int (__cdecl *off_4B9E60)(_DWORD);
// 4C1B80: using guessed type int dword_4C1B80;

//----- (0046EF45) --------------------------------------------------------
int __cdecl sub_46EF45(DWORD a1)
{
  if ( dword_4C1B80 == 1 )
    _FF_MSGBANNER_0();
  _NMSG_WRITE_0(a1);
  return dword_4A7200(255);
}
// 4A7200: using guessed type int (__stdcall *dword_4A7200)(_DWORD);
// 4C1B80: using guessed type int dword_4C1B80;

//----- (0046EF69) --------------------------------------------------------
int __cdecl fclose(FILE *Stream)
{
  int v1; // edi

  v1 = -1;
  if ( (Stream->_flag & 0x40) != 0 )
  {
    Stream->_flag = 0;
  }
  else
  {
    _lock_file(Stream);
    v1 = _fclose_lk(Stream);
    sub_473E59((unsigned int)Stream);
  }
  return v1;
}

//----- (0046EF9A) --------------------------------------------------------
int __cdecl _fclose_lk(_iobuf *str)
{
  int v1; // edi

  v1 = -1;
  if ( (str->_flag & 0x83) != 0 )
  {
    v1 = _flush_0(str);
    _freebuf_0(str);
    if ( _close(str->_file) >= 0 )
    {
      if ( str->_tmpfname )
      {
        sub_46D360((unsigned int)str->_tmpfname);
        str->_tmpfname = 0;
      }
    }
    else
    {
      v1 = -1;
    }
  }
  str->_flag = 0;
  return v1;
}

//----- (0046EFE6) --------------------------------------------------------
FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag)
{
  FILE *result; // eax
  FILE *v4; // esi
  FILE *v5; // edi

  result = (FILE *)_getstream();
  v4 = result;
  if ( result )
  {
    v5 = (FILE *)_openfile((char *)FileName, Mode, ShFlag, result);
    sub_473E59((unsigned int)v4);
    result = v5;
  }
  return result;
}

//----- (0046F017) --------------------------------------------------------
FILE *__cdecl sub_46F017(char *FileName, char *Mode)
{
  return _fsopen(FileName, Mode, 64);
}

//----- (0046F02A) --------------------------------------------------------
size_t __cdecl sub_46F02A(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // esi

  _lock_file(Stream);
  v4 = fread(Buffer, ElementSize, ElementCount, Stream);
  sub_473E59((unsigned int)Stream);
  return v4;
}

//----- (0046F059) --------------------------------------------------------
size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // edi
  size_t v6; // ecx
  unsigned int v9; // eax
  int v10; // edi
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  size_t Buffera; // [esp+18h] [ebp+8h]
  unsigned int Streama; // [esp+24h] [ebp+14h]

  v4 = ElementCount * ElementSize;
  v6 = ElementCount * ElementSize;
  Buffera = ElementCount * ElementSize;
  if ( !(ElementCount * ElementSize) )
    return 0;
  if ( (Stream->_flag & 0x10C) != 0 )
    Streama = Stream->_bufsiz;
  else
    Streama = 4096;
  while ( 1 )
  {
    if ( (Stream->_flag & 0x10C) != 0 )
    {
      v9 = Stream->_cnt;
      if ( v9 )
      {
        v10 = v6;
        if ( v6 >= v9 )
          v10 = Stream->_cnt;
        memcpy_0(Buffer, Stream->_ptr, v10);
        Buffera -= v10;
        Stream->_cnt -= v10;
        Stream->_ptr += v10;
        Buffer = (char *)Buffer + v10;
        v4 = ElementCount * ElementSize;
        goto LABEL_20;
      }
    }
    if ( v6 >= Streama )
      break;
    v13 = _filbuf(Stream);
    if ( v13 == -1 )
      return (v4 - Buffera) / ElementSize;
    *(_BYTE *)Buffer = v13;
    Buffer = (char *)Buffer + 1;
    --Buffera;
    Streama = Stream->_bufsiz;
LABEL_20:
    if ( !Buffera )
      return ElementCount;
    v6 = Buffera;
  }
  v11 = v6;
  if ( Streama )
    v11 = v6 - v6 % Streama;
  v12 = _write(Stream->_file, Buffer, v11);
  if ( !v12 )
  {
    Stream->_flag |= 0x10u;
    return (v4 - Buffera) / ElementSize;
  }
  if ( v12 != -1 )
  {
    Buffera -= v12;
    Buffer = (char *)Buffer + v12;
    goto LABEL_20;
  }
  Stream->_flag |= 0x20u;
  return (v4 - Buffera) / ElementSize;
}

//----- (0046F141) --------------------------------------------------------
size_t __cdecl sub_46F141(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // esi

  _lock_file(Stream);
  v4 = fwrite(Buffer, ElementSize, ElementCount, Stream);
  sub_473E59((unsigned int)Stream);
  return v4;
}

//----- (0046F170) --------------------------------------------------------
size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream)
{
  size_t v4; // edi
  size_t v5; // ebx
  unsigned int v8; // eax
  int v9; // edi
  DWORD v10; // edi
  unsigned int v11; // eax
  size_t v12; // eax
  int Streama; // [esp+24h] [ebp+14h]

  v4 = ElementCount * ElementSize;
  v5 = ElementCount * ElementSize;
  if ( !(ElementCount * ElementSize) )
    return 0;
  if ( (Stream->_flag & 0x10C) != 0 )
    Streama = Stream->_bufsiz;
  else
    Streama = 4096;
  while ( 1 )
  {
    if ( (Stream->_flag & 0x108) != 0 )
    {
      v8 = Stream->_cnt;
      if ( v8 )
      {
        v9 = v5;
        if ( v5 >= v8 )
          v9 = Stream->_cnt;
        memcpy_0(Stream->_ptr, Buffer, v9);
        Stream->_cnt -= v9;
        Stream->_ptr += v9;
        v5 -= v9;
        Buffer = (char *)Buffer + v9;
LABEL_19:
        v4 = ElementCount * ElementSize;
        goto LABEL_23;
      }
    }
    if ( v5 >= Streama )
      break;
    if ( _flsbuf(*(char *)Buffer, Stream) == -1 )
      goto LABEL_26;
    Buffer = (char *)Buffer + 1;
    --v5;
    Streama = Stream->_bufsiz;
    if ( Streama <= 0 )
      Streama = 1;
LABEL_23:
    if ( !v5 )
      return ElementCount;
  }
  if ( (Stream->_flag & 0x108) == 0 || !_flush_0(Stream) )
  {
    if ( Streama )
      v10 = v5 - v5 % Streama;
    else
      v10 = v5;
    v11 = sub_476145(Stream->_file, Buffer, v10);
    if ( v11 == -1 || (Buffer = (char *)Buffer + v11, v5 -= v11, v11 < v10) )
    {
      Stream->_flag |= 0x20u;
      v12 = ElementCount * ElementSize;
      return (v12 - v5) / ElementSize;
    }
    goto LABEL_19;
  }
LABEL_26:
  v12 = v4;
  return (v12 - v5) / ElementSize;
}

//----- (0046F27A) --------------------------------------------------------
int __cdecl fseek(FILE *Stream, int Offset, int Origin)
{
  int v3; // esi

  _lock_file(Stream);
  v3 = _fseek_lk((int)Stream, Offset, Origin);
  sub_473E59((unsigned int)Stream);
  return v3;
}

//----- (0046F2A6) --------------------------------------------------------
int __cdecl _fseek_lk(int a1, int Offset, int Origin)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int result; // eax

  v3 = *(_DWORD *)(a1 + 12);
  if ( (v3 & 0x83) != 0 && ((v4 = Origin) == 0 || Origin == 1 || Origin == 2) )
  {
    LOBYTE(v3) = v3 & 0xEF;
    *(_DWORD *)(a1 + 12) = v3;
    if ( Origin == 1 )
    {
      Offset += _ftell_lk(a1);
      v4 = 0;
    }
    _flush_0((_DWORD *)a1);
    v5 = *(_DWORD *)(a1 + 12);
    if ( (v5 & 0x80u) == 0 )
    {
      if ( (v5 & 1) != 0 && (v5 & 8) != 0 && (v5 & 0x400) == 0 )
        *(_DWORD *)(a1 + 24) = 512;
    }
    else
    {
      LOBYTE(v5) = v5 & 0xFC;
      *(_DWORD *)(a1 + 12) = v5;
    }
    result = (sub_476335(*(_DWORD *)(a1 + 16), Offset, v4) != -1) - 1;
  }
  else
  {
    *sub_46D641() = 22;
    result = -1;
  }
  return result;
}

//----- (0046F333) --------------------------------------------------------
int __cdecl sub_46F333(FILE *Stream)
{
  int v1; // edi

  _lock_file(Stream);
  v1 = _ftell_lk((int)Stream);
  sub_473E59((unsigned int)Stream);
  return v1;
}

//----- (0046F355) --------------------------------------------------------
int __cdecl _ftell_lk(int a1)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  unsigned int v6; // eax
  int v7; // edx
  _BYTE *i; // ecx
  int v9; // ecx
  _DWORD *v10; // ebx
  int v11; // esi
  _BYTE *v12; // eax
  _BYTE *v13; // ecx
  bool v14; // zf
  int v15; // eax
  int v16; // ecx
  int v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  LONG v19; // [esp+14h] [ebp-4h]
  unsigned int v20; // [esp+20h] [ebp+8h]

  v2 = *(_DWORD *)(a1 + 16);
  v17 = v2;
  if ( *(int *)(a1 + 4) < 0 )
    *(_DWORD *)(a1 + 4) = 0;
  v3 = sub_476335(v2, 0, 1u);
  v19 = v3;
  if ( v3 < 0 )
    return -1;
  v4 = *(_DWORD *)(a1 + 12);
  if ( (v4 & 0x108) == 0 )
    return v3 - *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  v18 = *(_DWORD *)a1 - v7;
  if ( (v4 & 3) != 0 )
  {
    if ( *(char *)(dword_4C2120[v2 >> 5] + 36 * (v2 & 0x1F) + 4) < 0 )
    {
      for ( i = *(_BYTE **)(a1 + 8); (unsigned int)i < v6; ++i )
      {
        if ( *i == 10 )
          ++v18;
      }
    }
    goto LABEL_16;
  }
  if ( (v4 & 0x80u) == 0 )
  {
    *sub_46D641() = 22;
    return -1;
  }
LABEL_16:
  if ( !v19 )
    return v18;
  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    if ( v9 )
    {
      v20 = v9 + v6 - v7;
      v10 = (_DWORD *)(4 * (v2 >> 5) + 4989216);
      v11 = 36 * (v2 & 0x1F);
      if ( *(char *)(v11 + *v10 + 4) < 0 )
      {
        if ( sub_476335(v17, 0, 2u) == v19 )
        {
          v12 = *(_BYTE **)(a1 + 8);
          v13 = &v12[v20];
          while ( v12 < v13 )
          {
            if ( *v12 == 10 )
              ++v20;
            ++v12;
          }
          v14 = (*(_BYTE *)(a1 + 13) & 0x20) == 0;
        }
        else
        {
          sub_476335(v17, v19, 0);
          v15 = 512;
          if ( v20 > 0x200 || (v16 = *(_DWORD *)(a1 + 12), (v16 & 8) == 0) || (v16 & 0x400) != 0 )
            v15 = *(_DWORD *)(a1 + 24);
          v20 = v15;
          v14 = (*(_BYTE *)(v11 + *v10 + 4) & 4) == 0;
        }
        if ( !v14 )
          ++v20;
      }
      v19 -= v20;
    }
    else
    {
      v18 = 0;
    }
  }
  return v19 + v18;
}
// 4C2120: using guessed type int dword_4C2120[];

//----- (0046F4B6) --------------------------------------------------------
int __cdecl fflush(FILE *Stream)
{
  int v2; // edi

  if ( !Stream )
    return flsall(0);
  _lock_file(Stream);
  v2 = _fflush_lk((int)Stream);
  sub_473E59((unsigned int)Stream);
  return v2;
}

//----- (0046F4E5) --------------------------------------------------------
int __cdecl _fflush_lk(int a1)
{
  if ( _flush_0((_DWORD *)a1) )
    return -1;
  if ( (*(_BYTE *)(a1 + 13) & 0x40) != 0 )
    return -(_commit(*(_DWORD *)(a1 + 16)) != 0);
  return 0;
}

//----- (0046F513) --------------------------------------------------------
int __cdecl _flush_0(_DWORD *a1)
{
  int v1; // ebx
  const void *v2; // eax
  DWORD v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (a1[3] & 3) == 2 && (a1[3] & 0x108) != 0 )
  {
    v2 = (const void *)a1[2];
    if ( *a1 - (int)v2 > 0 )
    {
      v3 = *a1 - (_DWORD)v2;
      if ( sub_476145(a1[4], v2, v3) == v3 )
      {
        v4 = a1[3];
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          a1[3] = v4;
        }
      }
      else
      {
        a1[3] |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = a1[2];
  a1[1] = 0;
  *a1 = v5;
  return v1;
}

//----- (0046F56F) --------------------------------------------------------
int sub_46F56F()
{
  return flsall(1);
}

//----- (0046F578) --------------------------------------------------------
int __cdecl flsall(int a1)
{
  int v1; // ebx
  int v2; // edi
  int i; // esi
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int result; // eax

  v1 = 0;
  v2 = 0;
  _lock(2);
  for ( i = 0; i < dword_4C3240; ++i )
  {
    v4 = *(_DWORD *)(dword_4C2224 + 4 * i);
    if ( v4 && (*(_BYTE *)(v4 + 12) & 0x83) != 0 )
    {
      _lock_file2(i, *(_DWORD *)(dword_4C2224 + 4 * i));
      v5 = *(_DWORD *)(dword_4C2224 + 4 * i);
      v6 = *(_DWORD *)(v5 + 12);
      if ( (v6 & 0x83) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( _fflush_lk(v5) != -1 )
            ++v1;
        }
        else if ( !a1 && (v6 & 2) != 0 && _fflush_lk(*(_DWORD *)(dword_4C2224 + 4 * i)) == -1 )
        {
          v2 = -1;
        }
      }
      sub_473E88(i, *(_DWORD *)(dword_4C2224 + 4 * i));
    }
  }
  sub_46FA37(2);
  result = v1;
  if ( a1 != 1 )
    result = v2;
  return result;
}
// 4C2224: using guessed type int dword_4C2224;
// 4C3240: using guessed type int dword_4C3240;

//----- (0046F61C) --------------------------------------------------------
int __cdecl fputc(int Character, FILE *Stream)
{
  int v3; // edi

  _lock_file(Stream);
  if ( --Stream->_cnt < 0 )
  {
    v3 = _flsbuf(Character, Stream);
  }
  else
  {
    v3 = (unsigned __int8)Character;
    *Stream->_ptr++ = Character;
  }
  sub_473E59((unsigned int)Stream);
  return v3;
}

//----- (0046F667) --------------------------------------------------------
int __cdecl fgetc(FILE *Stream)
{
  int v2; // edi

  _lock_file(Stream);
  if ( --Stream->_cnt < 0 )
    v2 = _filbuf(Stream);
  else
    v2 = *(unsigned __int8 *)Stream->_ptr++;
  sub_473E59((unsigned int)Stream);
  return v2;
}

//----- (0046F698) --------------------------------------------------------
int __cdecl sub_46F698(FILE *Stream)
{
  return fgetc(Stream);
}

//----- (0046F6A3) --------------------------------------------------------
_DWORD *__cdecl sub_46F6A3(int a1, unsigned __int16 *a2, int a3)
{
  _DWORD *result; // eax
  unsigned int v4; // esi
  _DWORD *v5; // edi

  result = _getstream();
  v4 = (unsigned int)result;
  if ( result )
  {
    v5 = sub_4764A0(a1, a2, a3, result);
    sub_473E59(v4);
    result = v5;
  }
  return result;
}

//----- (0046F6D4) --------------------------------------------------------
_DWORD *__cdecl sub_46F6D4(int a1, unsigned __int16 *a2)
{
  return sub_46F6A3(a1, a2, 64);
}

//----- (0046F6E8) --------------------------------------------------------
void __cdecl __noreturn longjmp(jmp_buf Buf, int Value)
{
  int v2; // ebp
  int v3; // esi
  void (__stdcall *v4)(int *__attribute__((__org_typedef(jmp_buf)))); // eax

  v2 = *Buf;
  v3 = Buf[6];
  if ( v3 != __readfsdword(0) )
    _global_unwind2((PVOID)Buf[6]);
  if ( v3 )
  {
    if ( sub_476616((int)(Buf + 8)) && Buf[8] == 1447244336 )
    {
      v4 = (void (__stdcall *)(int *__attribute__((__org_typedef(jmp_buf)))))Buf[9];
      if ( v4 )
        v4(Buf);
    }
    else
    {
      _local_unwind2(v2, v3, Buf[7]);
    }
  }
  sub_46D1C2(Buf[5], v2, 0);
  ((void (*)(void))Buf[5])();
}

//----- (0046F764) --------------------------------------------------------
// DDK Windows 32bit
int __usercall _setjmp3@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, _DWORD *a5, int a6, struct _EXCEPTION_REGISTRATION_RECORD *a7, int a8, ...)
{
  struct _EXCEPTION_REGISTRATION_RECORD *v8; // eax
  unsigned int v9; // ecx
  void *retaddr; // [esp+0h] [ebp+0h] BYREF
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, a8);
  *a5 = a2;
  a5[1] = a1;
  a5[2] = a3;
  a5[3] = a4;
  a5[4] = &retaddr;
  a5[5] = retaddr;
  a5[8] = 1447244336;
  a5[9] = 0;
  v8 = NtCurrentTeb()->NtTib.ExceptionList;
  a5[6] = v8;
  if ( v8 == (struct _EXCEPTION_REGISTRATION_RECORD *)-1 )
  {
    a5[7] = -1;
  }
  else if ( a6 && (v8 = a7, a5[9] = a7, a6 != 1) )
  {
    a5[7] = a8;
    v9 = a6 - 2;
    if ( a6 != 2 )
    {
      if ( v9 > 6 )
        v9 = 6;
      qmemcpy(a5 + 10, va, 4 * v9);
    }
  }
  else
  {
    a5[7] = v8[1].Handler;
  }
  return 0;
}

//----- (0046F7DF) --------------------------------------------------------
int __cdecl sub_46F7DF(int a1, int a2)
{
  int v2; // ecx

  v2 = a1 / a2;
  if ( a1 < 0 && a1 % a2 > 0 )
    ++v2;
  return v2;
}

//----- (0046F804) --------------------------------------------------------
BOOL __cdecl sub_46F804(int a1, int a2)
{
  unsigned int v2; // esi
  BOOL result; // eax
  _DWORD *v4; // [esp+14h] [ebp-20h]
  unsigned int v5; // [esp+18h] [ebp-1Ch]

  v2 = a2 * a1;
  v5 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_4C3270 == 3 )
      {
        if ( v5 > dword_4C3268 )
          goto LABEL_14;
        _lock(9);
        v4 = __sbh_alloc_block_0(v5);
        sub_46FA37(9);
        if ( v4 )
        {
          memset(v4, 0, v5);
          goto LABEL_14;
        }
LABEL_15:
        v4 = (_DWORD *)dword_4A7214(dword_4C326C, 8, v2);
        goto LABEL_16;
      }
      if ( dword_4C3270 == 2 && v2 <= dword_4BBF8C )
      {
        _lock(9);
        v4 = (_DWORD *)sub_472151(v2 >> 4);
        sub_46FA37(9);
        if ( !v4 )
          goto LABEL_15;
        memset(v4, 0, v2);
      }
LABEL_14:
      if ( v4 )
        return (BOOL)v4;
      goto LABEL_15;
    }
LABEL_16:
    if ( v4 || !dword_4C1BF0 )
      return (BOOL)v4;
    result = sub_473045(v2);
    if ( !result )
      return result;
  }
}
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4BBF8C: using guessed type int dword_4BBF8C;
// 4C1BF0: using guessed type int dword_4C1BF0;
// 4C3268: using guessed type int dword_4C3268;
// 4C3270: using guessed type int dword_4C3270;

//----- (0046F941) --------------------------------------------------------
int _mtinitlocks()
{
  void (__stdcall *v0)(void *); // esi

  v0 = (void (__stdcall *)(void *))dword_4A71EC;
  dword_4A71EC(off_4B9EAC);
  v0(off_4B9E9C);
  v0(off_4B9E8C);
  return ((int (__stdcall *)(void *))v0)(off_4B9E6C);
}
// 4A71EC: using guessed type int (__stdcall *dword_4A71EC)(_DWORD);
// 4B9E6C: using guessed type void *off_4B9E6C;
// 4B9E8C: using guessed type void *off_4B9E8C;
// 4B9E9C: using guessed type void *off_4B9E9C;
// 4B9EAC: using guessed type void *off_4B9EAC;

//----- (0046F96A) --------------------------------------------------------
int _mtdeletelocks_0()
{
  void (__stdcall *v0)(unsigned int); // edi
  unsigned int *v1; // esi

  v0 = (void (__stdcall *)(unsigned int))dword_4A71E8;
  v1 = (unsigned int *)dword_4B9E68;
  do
  {
    if ( *v1
      && v1 != (unsigned int *)&off_4B9EAC
      && v1 != (unsigned int *)&off_4B9E9C
      && v1 != (unsigned int *)&off_4B9E8C
      && v1 != (unsigned int *)&off_4B9E6C )
    {
      v0(*v1);
      sub_46D360(*v1);
    }
    ++v1;
  }
  while ( (int)v1 < (int)&unk_4B9F28 );
  v0((unsigned int)off_4B9E8C);
  v0((unsigned int)off_4B9E9C);
  v0((unsigned int)off_4B9EAC);
  return ((int (__stdcall *)(void *))v0)(off_4B9E6C);
}
// 4A71E8: using guessed type int dword_4A71E8;
// 4B9E68: using guessed type int dword_4B9E68[];
// 4B9E6C: using guessed type void *off_4B9E6C;
// 4B9E8C: using guessed type void *off_4B9E8C;
// 4B9E9C: using guessed type void *off_4B9E9C;
// 4B9EAC: using guessed type void *off_4B9EAC;

//----- (0046F9D6) --------------------------------------------------------
int __cdecl _lock(int a1)
{
  int v1; // edi

  if ( !dword_4B9E68[a1] )
  {
    v1 = sub_46D9FD(0x18u);
    if ( !v1 )
      _amsg_exit(0x11u);
    _lock(17);
    if ( dword_4B9E68[a1] )
    {
      sub_46D360(v1);
    }
    else
    {
      dword_4A71EC(v1);
      dword_4B9E68[a1] = v1;
    }
    sub_46FA37(17);
  }
  return dword_4A71E4(dword_4B9E68[a1]);
}
// 46D360: using guessed type _DWORD __cdecl sub_46D360(_DWORD);
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);
// 4A71EC: using guessed type int (__stdcall *dword_4A71EC)(_DWORD);
// 4B9E68: using guessed type int dword_4B9E68[];

//----- (0046FA37) --------------------------------------------------------
int __cdecl sub_46FA37(int a1)
{
  return dword_4A71E0(dword_4B9E68[a1]);
}
// 4A71E0: using guessed type int (__stdcall *dword_4A71E0)(_DWORD);
// 4B9E68: using guessed type int dword_4B9E68[];

//----- (0046FA70) --------------------------------------------------------
int __cdecl strcmp(const char *Str1, const char *Str2)
{
  const char *v2; // edx
  const char *v3; // ecx
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  __int16 v8; // ax

  v2 = Str1;
  v3 = Str2;
  if ( ((unsigned __int8)Str1 & 3) == 0 )
  {
LABEL_2:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      v5 = (unsigned __int8)*(_DWORD *)v2 < (unsigned int)*v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
        break;
      if ( !(_BYTE)v4 )
        return 0;
      v5 = BYTE1(v4) < (unsigned int)v3[1];
      if ( BYTE1(v4) != v3[1] )
        break;
      if ( !BYTE1(v4) )
        return 0;
      v6 = HIWORD(v4);
      v5 = (unsigned __int8)v6 < (unsigned int)v3[2];
      if ( (_BYTE)v6 != v3[2] )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v5 = BYTE1(v6) < (unsigned int)v3[3];
      if ( BYTE1(v6) != v3[3] )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -2 * v5 + 1;
  }
  if ( ((unsigned __int8)Str1 & 1) != 0 )
  {
    v2 = Str1 + 1;
    v5 = *Str1 < (unsigned int)*Str2;
    if ( *Str1 != *Str2 )
      return -2 * v5 + 1;
    v3 = Str2 + 1;
    if ( !*Str1 )
      return 0;
    if ( ((unsigned __int8)v2 & 2) == 0 )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v5 = (unsigned __int8)v8 < (unsigned int)*v3;
  if ( (_BYTE)v8 != *v3 )
    return -2 * v5 + 1;
  if ( !(_BYTE)v8 )
    return 0;
  v5 = HIBYTE(v8) < (unsigned int)v3[1];
  if ( HIBYTE(v8) == v3[1] )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -2 * v5 + 1;
}

//----- (0046FAF4) --------------------------------------------------------
char __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *a1)
{
  PEXCEPTION_RECORD v1; // eax

  v1 = a1->ExceptionRecord;
  if ( a1->ExceptionRecord->ExceptionCode == -529697949
    && v1->NumberParameters == 3
    && v1->ExceptionInformation[0] == 429065504 )
  {
    return sub_470554();
  }
  if ( dword_4C1BE8 && sub_476710((int)dword_4C1BE8) )
    return dword_4C1BE8(a1);
  return 0;
}
// 4C1BE8: using guessed type int (__stdcall *dword_4C1BE8)(_DWORD);

//----- (0046FB58) --------------------------------------------------------
int __usercall __InternalCxxFrameHandler_0@<eax>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3, int a4, int a5, int a6, struct _s_FuncInfo *a7, int a8, int a9, unsigned __int8 a10)
{
  if ( *(_DWORD *)a7 != 429065504 )
    sub_4705CD(a1, a2, 429065504, (int)a7);
  if ( (*(_BYTE *)(a3 + 4) & 0x66) != 0 )
  {
    if ( a7->maxState )
    {
      if ( !a8 )
        __FrameUnwindToState(a4, a6, (int)a7, -1);
    }
  }
  else if ( a7->nTryBlocks )
  {
    if ( *(_DWORD *)a3 == -529697949 && *(_DWORD *)(a3 + 20) > 0x19930520u )
    {
      a1 = *(EXCEPTION_POINTERS **)(*(_DWORD *)(a3 + 28) + 8);
      if ( a1 )
        return ((int (__cdecl *)(int, int, int, int, struct _s_FuncInfo *, int, int, _DWORD))a1)(
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10);
    }
    FindHandler(a1, a2, 429065504, (int)a7, (struct _s_HandlerType *)a3, a4, a5, a6, a7, a10, a8, a9);
  }
  return 1;
}
// 46FBE4: variable 'a1' is possibly undefined

//----- (0046FBF3) --------------------------------------------------------
char __usercall FindHandler@<al>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, struct _s_HandlerType *a5, int a6, int a7, int a8, struct _s_FuncInfo *a9, char a10, int a11, int a12)
{
  struct EHExceptionRecord *v12; // esi
  int *v13; // eax
  BOOL v14; // eax
  EXCEPTION_POINTERS *v15; // ecx
  int v16; // edi
  const struct _s_TryBlockMapEntry *i; // ebx
  int *v18; // eax
  const struct _s_CatchableType **v19; // edi
  EXCEPTION_POINTERS *v21; // [esp-10h] [ebp-28h]
  unsigned int v22; // [esp+0h] [ebp-18h] BYREF
  int v23; // [esp+4h] [ebp-14h]
  int v24; // [esp+8h] [ebp-10h]
  int v25; // [esp+Ch] [ebp-Ch]
  int v26; // [esp+10h] [ebp-8h]
  unsigned int v27; // [esp+14h] [ebp-4h] BYREF
  struct _s_HandlerType *v28; // [esp+20h] [ebp+8h]

  LOBYTE(v23) = 0;
  v24 = *(_DWORD *)(a6 + 8);
  if ( v24 < -1 || (a1 = (EXCEPTION_POINTERS *)a9, v24 >= a9->maxState) )
    sub_4705CD(a1, a2, a3, a4);
  v12 = (struct EHExceptionRecord *)a5;
  if ( a5->adjectives != -529697949 )
    goto LABEL_35;
  if ( a5[1].adjectives == 3 && a5[1].pType == (TypeDescriptor *)429065504 && !a5[1].addressOfHandler )
  {
    v13 = _getptd();
    if ( !v13[27] )
      return (char)v13;
    v12 = (struct EHExceptionRecord *)_getptd()[27];
    a7 = _getptd()[28];
    LOBYTE(v23) = 1;
    v14 = sub_4766D8((int)v12, 1);
    v15 = v21;
    if ( !v14 )
      sub_4705CD(v21, -529697949, 429065504, (int)v12);
    if ( v12->ExceptionCode != -529697949 )
      goto LABEL_35;
    if ( v12->NumberParameters == 3 && v12->params.magicNumber == 429065504 && !v12->params.pThrowInfo )
      sub_4705CD(v15, -529697949, 429065504, (int)v12);
  }
  if ( v12->ExceptionCode != -529697949 || v12->NumberParameters != 3 || v12->params.magicNumber != 429065504 )
  {
LABEL_35:
    if ( a10 )
      LOBYTE(v13) = sub_470554();
    else
      LOBYTE(v13) = FindHandlerForForeignException(
                      v12,
                      (struct EHRegistrationNode *)a6,
                      (void *)a7,
                      (void *)a8,
                      a9,
                      v24,
                      a11,
                      (struct EHRegistrationNode *)a12);
    return (char)v13;
  }
  v16 = v24;
  for ( i = (const struct _s_TryBlockMapEntry *)_GetRangeOfTrysToCheck(a9, a11, v24, &v27, &v22); ; ++i )
  {
    LOBYTE(v13) = v27;
    if ( v27 >= v22 )
      break;
    if ( i->tryLow <= v16 && v16 <= i->tryHigh )
    {
      v28 = (struct _s_HandlerType *)i->pHandlerArray;
      v25 = i->nCatches;
      if ( v25 > 0 )
      {
        while ( 1 )
        {
          v18 = &v12->params.pThrowInfo->pCatchableTypeArray->nCatchableTypes;
          v19 = (const struct _s_CatchableType **)(v18 + 1);
          v26 = *v18;
          if ( v26 > 0 )
            break;
LABEL_27:
          --v25;
          ++v28;
          if ( v25 <= 0 )
            goto LABEL_30;
        }
        while ( !TypeMatch(v28, *v19, v12->params.pThrowInfo) )
        {
          --v26;
          ++v19;
          if ( v26 <= 0 )
            goto LABEL_27;
        }
        CatchIt(
          v12,
          (struct EHRegistrationNode *)a6,
          (struct _CONTEXT *)a7,
          a8,
          a9,
          (struct EHExceptionRecord *)v28,
          *v19,
          i,
          a11,
          (struct EHRegistrationNode *)a12);
      }
LABEL_30:
      v16 = v24;
    }
    ++v27;
  }
  if ( a10 )
    LOBYTE(v13) = sub_4702E5((int)v12);
  return (char)v13;
}
// 46FC72: variable 'v21' is possibly undefined
// 46FC93: variable 'v15' is possibly undefined

//----- (0046FDA6) --------------------------------------------------------
int __cdecl FindHandlerForForeignException(struct EHExceptionRecord *a1, struct EHRegistrationNode *a2, void *a3, void *a4, struct _s_FuncInfo *a5, int a6, int a7, struct EHRegistrationNode *a8)
{
  int result; // eax
  const struct _s_TryBlockMapEntry *i; // esi
  int v10; // eax
  int v11; // ecx
  unsigned int v12; // [esp+8h] [ebp-8h] BYREF
  unsigned int v13; // [esp+Ch] [ebp-4h] BYREF

  if ( !_getptd()[26] || (result = _CallSETranslator(a1, a2, a3, a4, a5, a7, a8)) == 0 )
  {
    for ( i = (const struct _s_TryBlockMapEntry *)_GetRangeOfTrysToCheck(a5, a7, a6, &v13, &v12); ; ++i )
    {
      result = v13;
      if ( v13 >= v12 )
        break;
      if ( a6 >= i->tryLow && a6 <= i->tryHigh )
      {
        v10 = (int)&i->pHandlerArray[i->nCatches];
        v11 = *(_DWORD *)(v10 - 12);
        if ( !v11 || !*(_BYTE *)(v11 + 8) )
          CatchIt(a1, a2, (struct _CONTEXT *)a3, (int)a4, a5, (struct EHExceptionRecord *)(v10 - 16), 0, i, a7, a8);
      }
      ++v13;
    }
  }
  return result;
}

//----- (0046FE50) --------------------------------------------------------
BOOL __cdecl TypeMatch(const struct _s_HandlerType *a1, const struct _s_CatchableType *a2, const struct _s_ThrowInfo *a3)
{
  TypeDescriptor *v3; // eax
  TypeDescriptor *v4; // ecx
  BOOL result; // eax

  v3 = a1->pType;
  result = 1;
  if ( v3 && v3->name[0] )
  {
    if ( (v4 = a2->pType, v3 != v4) && strcmp(v3->name, v4->name)
      || (a2->properties & 2) != 0 && (a1->adjectives & 8) == 0
      || (a3->attributes & 1) != 0 && (a1->adjectives & 1) == 0
      || (a3->attributes & 2) != 0 && (a1->adjectives & 2) == 0 )
    {
      result = 0;
    }
  }
  return result;
}

//----- (0046FEAD) --------------------------------------------------------
void __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4)
{
  EXCEPTION_POINTERS *v4; // ecx
  int i; // esi
  int v6; // eax

  for ( i = *(_DWORD *)(a1 + 8); i != a4; i = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i) )
  {
    if ( i <= -1 || i >= *(_DWORD *)(a3 + 4) )
      sub_4705CD(v4, a1, a3, i);
    v6 = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i + 4);
    if ( v6 )
      _CallSettingFrame(v6, a1, 259);
  }
  *(_DWORD *)(a1 + 8) = i;
}
// 46FEEE: variable 'v4' is possibly undefined

//----- (0046FF4B) --------------------------------------------------------
char __cdecl sub_46FF4B(_DWORD **a1)
{
  char result; // al

  if ( **a1 == -529697949 )
    result = sub_470554();
  else
    result = 0;
  return result;
}

//----- (0046FF61) --------------------------------------------------------
void __cdecl CatchIt(struct EHExceptionRecord *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, int a4, const struct _s_FuncInfo *a5, struct EHExceptionRecord *a6, const struct _s_CatchableType *a7, const struct _s_TryBlockMapEntry *a8, int a9, struct EHRegistrationNode *a10)
{
  void *v10; // eax

  if ( a7 )
    BuildCatchObject(a6, a1, a2, (const struct _s_HandlerType *)a6, a7);
  if ( a10 )
    unknown_libname_60((struct _EXCEPTION_REGISTRATION_RECORD **)a6, (int)a10, (int)a1);
  else
    unknown_libname_60((struct _EXCEPTION_REGISTRATION_RECORD **)a6, (int)a2, (int)a1);
  __FrameUnwindToState((int)a2, a4, (int)a5, a8->tryLow);
  a2->state = a8->tryHigh + 1;
  v10 = CallCatchBlock(a1, a2, a3, a5, a6->ExceptionAddress, a9, 0x100u);
  if ( v10 )
    _JumpToContinuation(v10, a2);
}

//----- (0046FFDC) --------------------------------------------------------
void *__cdecl CallCatchBlock(struct EHExceptionRecord *a1, struct EHRegistrationNode *a2, struct _CONTEXT *a3, const struct _s_FuncInfo *a4, void *a5, int a6, unsigned int a7)
{
  void *v8; // [esp+Ch] [ebp-2Ch]
  __ehstate_t v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]

  v9 = a2[-1].state;
  v11 = _getptd()[27];
  v10 = _getptd()[28];
  _getptd()[27] = (int)a1;
  _getptd()[28] = (int)a3;
  v8 = _CallCatchBlock2(a2, a4, a5, a6, a7);
  a2[-1].state = v9;
  _getptd()[27] = v11;
  _getptd()[28] = v10;
  if ( a1->ExceptionCode == -529697949 && a1->NumberParameters == 3 && a1->params.magicNumber == 429065504 && v8 )
  {
    _abnormal_termination();
    sub_4702E5((int)a1);
  }
  return v8;
}
// 4700E0: conditional instruction was optimized away because of '%var_24.4==0'

//----- (004700F7) --------------------------------------------------------
BOOL __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1)
{
  PEXCEPTION_RECORD v1; // eax

  v1 = a1->ExceptionRecord;
  return a1->ExceptionRecord->ExceptionCode == -529697949
      && v1->NumberParameters == 3
      && v1->ExceptionInformation[0] == 429065504
      && !v1->ExceptionInformation[2];
}

//----- (00470121) --------------------------------------------------------
void __usercall BuildCatchObject(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5)
{
  TypeDescriptor *v5; // eax
  ptrdiff_t v6; // eax
  void **v7; // edi
  void *v8; // esi
  BOOL v9; // eax
  EXCEPTION_POINTERS *v10; // ecx
  BOOL v11; // eax
  void *v12; // eax
  char *v13; // eax
  BOOL v14; // eax
  BOOL v15; // eax
  BOOL v16; // eax
  BOOL v17; // eax
  char *v18; // eax
  BOOL v19; // eax
  BOOL v20; // eax
  BOOL v21; // eax
  void *v22; // [esp-8h] [ebp-30h]
  EXCEPTION_POINTERS *v23; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v24; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v25; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v26; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v27; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v28; // [esp-4h] [ebp-2Ch]
  int v29; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v30; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v31; // [esp-4h] [ebp-2Ch]
  EXCEPTION_POINTERS *v32; // [esp-4h] [ebp-2Ch]

  v5 = a4->pType;
  if ( !v5 )
    return;
  if ( !v5->name[0] )
    return;
  v6 = a4->dispCatchObj;
  if ( !v6 )
    return;
  v7 = (void **)((char *)&a3[1].pNext + v6);
  if ( (a4->adjectives & 8) != 0 )
  {
    v8 = a2;
    v9 = sub_4766D8((int)a2->params.pExceptionObject, 1);
    v10 = v23;
    if ( v9 )
    {
      v11 = sub_4766F4((int)v7, 1);
      v10 = v24;
      if ( v11 )
      {
        v12 = a2->params.pExceptionObject;
        *v7 = v12;
        v13 = AdjustPointer(v12, &a5->thisDisplacement);
LABEL_8:
        *v7 = v13;
        return;
      }
    }
    goto LABEL_25;
  }
  v8 = (void *)a5;
  if ( (a5->properties & 1) == 0 )
  {
    a1 = a2;
    v22 = a2->params.pExceptionObject;
    if ( !a5->copyFunction )
    {
      v16 = sub_4766D8((int)v22, 1);
      v10 = v27;
      if ( v16 )
      {
        v17 = sub_4766F4((int)v7, 1);
        v10 = v28;
        if ( v17 )
        {
          v29 = a5->sizeOrOffset;
          v18 = AdjustPointer(a2->params.pExceptionObject, &a5->thisDisplacement);
          sub_46CAB0((unsigned int)v7, v18, v29);
          return;
        }
      }
      goto LABEL_25;
    }
    v19 = sub_4766D8((int)v22, 1);
    v10 = v30;
    if ( v19 )
    {
      v20 = sub_4766F4((int)v7, 1);
      v10 = v31;
      if ( v20 )
      {
        v21 = sub_476710((int)a5->copyFunction);
        v10 = v32;
        if ( v21 )
        {
          if ( (a5->properties & 4) != 0 )
          {
            AdjustPointer(a2->params.pExceptionObject, &a5->thisDisplacement);
            sub_46CE27((int)v7, (int)a5->copyFunction);
          }
          else
          {
            AdjustPointer(a2->params.pExceptionObject, &a5->thisDisplacement);
            sub_46CE20((int)v7, (int)a5->copyFunction);
          }
          return;
        }
      }
    }
LABEL_25:
    sub_4705CD(v10, (int)a1, (int)v7, (int)v8);
    return;
  }
  a1 = a2;
  v14 = sub_4766D8((int)a2->params.pExceptionObject, 1);
  v10 = v25;
  if ( !v14 )
    goto LABEL_25;
  v15 = sub_4766F4((int)v7, 1);
  v10 = v26;
  if ( !v15 )
    goto LABEL_25;
  sub_46CAB0((unsigned int)v7, (_BYTE *)a2->params.pExceptionObject, a5->sizeOrOffset);
  if ( a5->sizeOrOffset == 4 && *v7 )
  {
    v13 = AdjustPointer(*v7, &a5->thisDisplacement);
    goto LABEL_8;
  }
}
// 470188: variable 'v23' is possibly undefined
// 47019A: variable 'v24' is possibly undefined
// 4701D4: variable 'v25' is possibly undefined
// 4701E6: variable 'v26' is possibly undefined
// 47022C: variable 'v27' is possibly undefined
// 47023E: variable 'v28' is possibly undefined
// 470266: variable 'v30' is possibly undefined
// 470274: variable 'v31' is possibly undefined
// 470281: variable 'v32' is possibly undefined

//----- (004702E5) --------------------------------------------------------
int __cdecl sub_4702E5(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
    if ( v2 )
      result = sub_46CE19(*(_DWORD *)(a1 + 24), v2);
  }
  return result;
}

//----- (0047034C) --------------------------------------------------------
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2)
{
  int v2; // edx
  char *result; // eax

  v2 = a2->pdisp;
  result = (char *)a1 + a2->mdisp;
  if ( v2 >= 0 )
    result += v2 + *(_DWORD *)(*(_DWORD *)((char *)a1 + v2) + a2->vdisp);
  return result;
}

//----- (00470370) --------------------------------------------------------
// Microsoft VisualC 2-10/net runtime
void __stdcall _CallSettingFrame(int a1, int a2, int a3)
{
  void (*v3)(void); // eax
  int v4; // ecx

  sub_46D1B9(a3);
  v3();
  v4 = a3;
  if ( a3 == 256 )
    v4 = 2;
  sub_46D1B9(v4);
}
// 470395: variable 'v3' is possibly undefined

//----- (004703BC) --------------------------------------------------------
int _mtinit()
{
  BOOL v0; // eax
  int *v1; // esi
  int v2; // eax

  _mtinitlocks();
  dword_4B9F40 = ((int (__cdecl *)())dword_4A7278)();
  if ( dword_4B9F40 == -1 )
    return 0;
  v0 = sub_46F804(1, 116);
  v1 = (int *)v0;
  if ( !v0 || !dword_4A727C(dword_4B9F40, v0) )
    return 0;
  sub_47042E((int)v1);
  v2 = dword_4A70B0();
  v1[1] = -1;
  *v1 = v2;
  return 1;
}
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A7278: using guessed type int (__cdecl *dword_4A7278)(_DWORD);
// 4A727C: using guessed type int (__stdcall *dword_4A727C)(_DWORD, _DWORD);

//----- (0047042E) --------------------------------------------------------
int __cdecl sub_47042E(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 80) = &unk_4BC758;
  *(_DWORD *)(a1 + 20) = 1;
  return result;
}

//----- (00470441) --------------------------------------------------------
// #API: GetLastError(), TlsGetValue(), TlsSetValue(), GetCurrentThreadId(), SetLastError()
// #API: GetLastError(), TlsGetValue(), TlsSetValue(), GetCurrentThreadId(), SetLastError()
int *_getptd()
{
  int v0; // edi
  int *v1; // esi
  BOOL v2; // eax
  int v3; // eax

  v0 = dword_4A7260();
  v1 = (int *)dword_4A7290(dword_4B9F40);
  if ( !v1 )
  {
    v2 = sub_46F804(1, 116);
    v1 = (int *)v2;
    if ( !v2 || !dword_4A727C(dword_4B9F40, v2) )
      _amsg_exit(0x10u);
    sub_47042E((int)v1);
    v3 = dword_4A70B0();
    v1[1] = -1;
    *v1 = v3;
  }
  dword_4A71D4(v0);
  return v1;
}
// 4A70B0: using guessed type int (*dword_4A70B0)(void);
// 4A71D4: using guessed type int (__stdcall *dword_4A71D4)(_DWORD);
// 4A7260: using guessed type int (*dword_4A7260)(void);
// 4A727C: using guessed type int (__stdcall *dword_4A727C)(_DWORD, _DWORD);
// 4A7290: using guessed type int (__stdcall *dword_4A7290)(_DWORD);

//----- (00470554) --------------------------------------------------------
char sub_470554()
{
  int *v0; // eax
  char v1; // fps

  if ( _getptd()[24] )
  {
    v0 = _getptd();
    ((void (*)(void))v0[24])();
  }
  _NMSG_WRITE_0(0xAu);
  raise(22);
  sub_46E4BD(3);
  return _abstract_sw(v1);
}

//----- (004705CD) --------------------------------------------------------
char __usercall sub_4705CD@<al>(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v5; // [esp-Ch] [ebp-24h] BYREF
  int v6; // [esp-8h] [ebp-20h]
  int v7; // [esp-4h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

  ms_exc.registration.ScopeTable = stru_4AF4F8;
  ms_exc.registration.ExceptionHandler = _except_handler3;
  ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION *)NtCurrentTeb()->NtTib.ExceptionList;
  ms_exc.exc_ptr = a1;
  v7 = a2;
  v6 = a4;
  v5 = a3;
  ms_exc.old_esp = (DWORD)&v5;
  ms_exc.registration.TryLevel = 0;
  if ( off_4B9F44 )
  {
    off_4B9F44(
      v5,
      v6,
      v7,
      ms_exc.old_esp,
      ms_exc.exc_ptr,
      ms_exc.registration.Next,
      ms_exc.registration.ExceptionHandler,
      ms_exc.registration.ScopeTable,
      1);
    ms_exc.registration.TryLevel = 0;
  }
  ms_exc.registration.TryLevel = -1;
  return sub_470554();
}
// 4AF4F8: using guessed type _SCOPETABLE_ENTRY stru_4AF4F8[2];
// 4B9F44: using guessed type int (__cdecl *off_4B9F44)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00470623) --------------------------------------------------------
unsigned int sub_470623()
{
  return sub_47679B(0x10000u, 196608);
}

//----- (00470635) --------------------------------------------------------
BOOL _ms_p5_test_fdiv()
{
  return dbl_4AF510 - dbl_4AF510 / dbl_4AF518 * dbl_4AF518 > dbl_4A91C8;
}
// 4A91C8: using guessed type double dbl_4A91C8;
// 4AF510: using guessed type double dbl_4AF510;
// 4AF518: using guessed type double dbl_4AF518;

//----- (00470673) --------------------------------------------------------
// #STR: "IsProcessorFeaturePresent", "KERNEL32"
// #API: GetModuleHandleA(), GetProcAddress()
int __cdecl _ms_p5_mp_test_fdiv()
{
  int v0; // eax
  int (__stdcall *v1)(_DWORD); // eax
  int result; // eax

  v0 = dword_4A71F4(aKernel32);
  if ( v0 && (v1 = (int (__stdcall *)(_DWORD))dword_4A70D8(v0, aIsprocessorfea)) != 0 )
    result = v1(0);
  else
    result = _ms_p5_test_fdiv();
  return result;
}
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);
// 4A71F4: using guessed type int (__stdcall *dword_4A71F4)(_DWORD);

//----- (0047069C) --------------------------------------------------------
char __cdecl _forcdecpt(char *a1)
{
  char *v1; // esi
  int v2; // eax
  char result; // al
  char *v4; // esi
  char v5; // cl

  v1 = a1;
  if ( tolower(*a1) != 101 )
  {
    do
    {
      ++v1;
      if ( (int)dword_4BC19C <= 1 )
        v2 = off_4BBF90[0][*v1] & 4;
      else
        v2 = _isctype_0(*v1, 4);
    }
    while ( v2 );
  }
  result = *v1;
  *v1 = byte_4BC1A0;
  v4 = v1 + 1;
  do
  {
    v5 = *v4;
    *v4 = result;
    result = v5;
  }
  while ( *v4++ );
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (004706F6) --------------------------------------------------------
char *__cdecl sub_4706F6(char *a1)
{
  char *v1; // eax
  char i; // cl
  char v3; // cl
  char *result; // eax
  char v5; // cl
  char *v6; // ecx
  char v7; // dl

  v1 = a1;
  for ( i = *a1; i; i = *++v1 )
  {
    if ( i == byte_4BC1A0 )
      break;
  }
  v3 = *v1;
  result = v1 + 1;
  if ( v3 )
  {
    while ( 1 )
    {
      v5 = *result;
      if ( !*result || v5 == 101 || v5 == 69 )
        break;
      ++result;
    }
    v6 = result;
    do
      --result;
    while ( *result == 48 );
    if ( *result == byte_4BC1A0 )
      --result;
    do
    {
      v7 = *v6;
      ++result;
      ++v6;
      *result = v7;
    }
    while ( v7 );
  }
  return result;
}
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (00470744) --------------------------------------------------------
BOOL __cdecl sub_470744(double *a1)
{
  return *a1 >= dbl_4A91B8;
}
// 4A91B8: using guessed type double dbl_4A91B8;

//----- (0047075C) --------------------------------------------------------
char **__cdecl _fassign(int a1, char **a2, char *a3)
{
  char **result; // eax
  int v4[2]; // [esp+0h] [ebp-8h] BYREF

  if ( a1 )
  {
    sub_476D38(v4, a3);
    result = a2;
    *a2 = (char *)v4[0];
    a2[1] = (char *)v4[1];
  }
  else
  {
    sub_476D93(&a3, a3);
    result = a2;
    *a2 = a3;
  }
  return result;
}

//----- (0047079A) --------------------------------------------------------
int __cdecl _cftoe(int a1, int a2, int a3, int a4)
{
  char v7[24]; // [esp+14h] [ebp-28h] BYREF
  int v8[4]; // [esp+2Ch] [ebp-10h] BYREF

  _fltout2(COERCE_UNSIGNED_INT64(*(double *)a1), HIDWORD(COERCE_UNSIGNED_INT64(*(double *)a1)), (int)v8, v7);
  _fptostr((void *)((v8[0] == 45) + a2 + (a3 > 0)), a3 + 1, (int)v8);
  _cftoe2((_BYTE *)a2, a3, a4, (int)v8, 0);
  return a2;
}

//----- (004707FB) --------------------------------------------------------
_BYTE *__cdecl _cftoe2(_BYTE *a1, int a2, int a3, int a4, char a5)
{
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  int v7; // ebx

  if ( a5 )
    _shift(&a1[*(_DWORD *)a4 == 45], a2 > 0);
  v5 = a1;
  if ( *(_DWORD *)a4 == 45 )
  {
    *a1 = 45;
    v5 = a1 + 1;
  }
  if ( a2 > 0 )
  {
    *v5 = v5[1];
    v5[1] = byte_4BC1A0;
  }
  sub_476F50();
  if ( a3 )
    *v6 = 69;
  if ( **(_BYTE **)(a4 + 12) != 48 )
  {
    v7 = *(_DWORD *)(a4 + 4) - 1;
    if ( v7 < 0 )
    {
      v7 = 1 - *(_DWORD *)(a4 + 4);
      v6[1] = 45;
    }
    if ( v7 >= 100 )
    {
      v6[2] += v7 / 100;
      v7 %= 100;
    }
    if ( v7 >= 10 )
    {
      v6[3] += v7 / 10;
      v7 %= 10;
    }
    v6[4] += v7;
  }
  return a1;
}
// 47086E: variable 'v6' is possibly undefined
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (004708BD) --------------------------------------------------------
size_t __cdecl _cftof(char *Src, size_t Size, size_t a3)
{
  char v6[24]; // [esp+14h] [ebp-28h] BYREF
  int v7[4]; // [esp+2Ch] [ebp-10h] BYREF

  _fltout2(COERCE_UNSIGNED_INT64(*(double *)Src), HIDWORD(COERCE_UNSIGNED_INT64(*(double *)Src)), (int)v7, v6);
  _fptostr((void *)(Size + (v7[0] == 45)), a3 + v7[1], (int)v7);
  _cftof2((char *)Size, a3, (int)v7, 0);
  return Size;
}

//----- (00470912) --------------------------------------------------------
char *__cdecl _cftof2(char *Src, size_t Size, int a3, char a4)
{
  int v4; // eax
  char *v5; // eax
  char *v6; // edi
  int v7; // eax
  char *v8; // edi
  int v9; // esi
  char *v10; // edi
  signed int v11; // esi

  v4 = *(_DWORD *)(a3 + 4) - 1;
  if ( a4 && v4 == Size )
  {
    v5 = &Src[v4 + (*(_DWORD *)a3 == 45)];
    *v5 = 48;
    v5[1] = 0;
  }
  v6 = Src;
  if ( *(_DWORD *)a3 == 45 )
  {
    *Src = 45;
    v6 = Src + 1;
  }
  v7 = *(_DWORD *)(a3 + 4);
  if ( v7 > 0 )
  {
    v8 = &v6[v7];
  }
  else
  {
    _shift(v6, 1);
    *v6 = 48;
    v8 = v6 + 1;
  }
  if ( (int)Size > 0 )
  {
    _shift(v8, 1);
    *v8 = byte_4BC1A0;
    v9 = *(_DWORD *)(a3 + 4);
    v10 = v8 + 1;
    if ( v9 < 0 )
    {
      if ( a4 )
      {
        v11 = -v9;
      }
      else
      {
        v11 = -v9;
        if ( (int)Size < v11 )
        {
LABEL_15:
          _shift(v10, Size);
          memset(v10, 48, Size);
          return Src;
        }
      }
      Size = v11;
      goto LABEL_15;
    }
  }
  return Src;
}
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (004709B9) --------------------------------------------------------
char *__cdecl _cftog(char *Src, int Size, int a3, int a4)
{
  int v6; // esi
  char *v7; // edi
  char v9[24]; // [esp+1Ch] [ebp-28h] BYREF
  int v10; // [esp+34h] [ebp-10h] BYREF
  int v11; // [esp+38h] [ebp-Ch]

  _fltout2(COERCE_UNSIGNED_INT64(*(double *)Src), HIDWORD(COERCE_UNSIGNED_INT64(*(double *)Src)), (int)&v10, v9);
  v6 = v11 - 1;
  v7 = (char *)(Size + (v10 == 45));
  _fptostr(v7, a3, (int)&v10);
  if ( v11 - 1 < -4 || v11 - 1 >= a3 )
    return _cftoe2((_BYTE *)Size, a3, a4, (int)&v10, 1);
  if ( v6 < v11 - 1 )
    v7[strlen(v7) - 1] = 0;
  return _cftof2((char *)Size, a3, (int)&v10, 1);
}

//----- (00470A4C) --------------------------------------------------------
char *__cdecl _cfltcvt(int a1, int a2, int a3, size_t Size, int a5)
{
  if ( a3 == 101 || a3 == 69 )
    return (char *)_cftoe(a1, a2, Size, a5);
  if ( a3 == 102 )
    return (char *)_cftof((char *)a1, a2, Size);
  return _cftog((char *)a1, a2, Size, a5);
}

//----- (00470A9D) --------------------------------------------------------
void __cdecl _shift(char *Src, int a2)
{
  size_t v2; // eax

  if ( a2 )
  {
    v2 = strlen(Src);
    sub_46CAB0((unsigned int)&Src[a2], Src, v2 + 1);
  }
}

//----- (00470ACC) --------------------------------------------------------
// Microsoft VisualC 2-10/net runtime
int __cdecl _except_handler3(int a1, PVOID TargetFrame, int a3)
{
  int *v3; // ebp
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // edi
  int v9; // ecx
  int result; // eax
  int v11[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = TargetFrame;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2((int)TargetFrame + 16, (int)TargetFrame, -1);
    result = 1;
  }
  else
  {
    v11[0] = a1;
    v11[1] = a3;
    *((_DWORD *)TargetFrame - 1) = v11;
    v5 = *((_DWORD *)TargetFrame + 3);
    v6 = *((_DWORD *)TargetFrame + 2);
    while ( v5 != -1 )
    {
      if ( *(_DWORD *)(v6 + 12 * v5 + 4) )
      {
        v7 = (*(int (**)(void))(v6 + 12 * v5 + 4))();
        v4 = (_DWORD *)v3[3];
        if ( v7 )
        {
          if ( v7 < 0 )
            return 0;
          v8 = v4[2];
          _global_unwind2((PVOID)v3[3]);
          v3 = v4 + 4;
          _local_unwind2((int)(v4 + 4), (int)v4, v5);
          sub_46D1C2(*(_DWORD *)(v8 + 12 * v5 + 8), (int)(v4 + 4), 1);
          v4[3] = *(_DWORD *)(v8 + 4 * v9);
          (*(void (**)(void))(v8 + 4 * v9 + 8))();
        }
      }
      v6 = v4[2];
      v5 = *(_DWORD *)(v6 + 12 * v5);
    }
    result = 1;
  }
  return result;
}
// 470B49: variable 'v9' is possibly undefined

//----- (00470BA4) --------------------------------------------------------
char __cdecl sub_470BA4(int a1)
{
  int v1; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  v1 = dword_4A71F4(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *(_DWORD *)(v1 + 60);
    if ( v2 )
    {
      v1 += v2;
      *(_BYTE *)a1 = *(_BYTE *)(v1 + 26);
      LOBYTE(v1) = *(_BYTE *)(v1 + 27);
      *(_BYTE *)(a1 + 1) = v1;
    }
  }
  return v1;
}
// 4A71F4: using guessed type int (__stdcall *dword_4A71F4)(_DWORD);

//----- (00470BD1) --------------------------------------------------------
unsigned int sub_470BD1()
{
  unsigned int result; // eax
  char *i; // ecx
  char v2; // al
  char *v3; // eax
  char *j; // ecx
  char v5; // al
  char *v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // ecx
  char Str2[4240]; // [esp+4h] [ebp-122Ch] BYREF
  char SubStr[260]; // [esp+1094h] [ebp-19Ch] BYREF
  _DWORD v11[37]; // [esp+1198h] [ebp-98h] BYREF
  char v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  v11[0] = 148;
  if ( dword_4A71CC(v11) && v11[4] == 2 && v11[1] >= 5u )
    return 1;
  if ( !dword_4A71D0(aMsvcrtHeapSele, Str2, 4240) )
    goto LABEL_29;
  for ( i = Str2; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp(Str1, Str2, 0x16u) )
  {
    v3 = Str2;
  }
  else
  {
    dword_4A7100(0, SubStr, 260);
    for ( j = SubStr; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr(Str2, SubStr);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = (unsigned __int8 *)(v6 + 1);
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = sub_4770C4(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_470BA4((int)v12);
    result = 3 - (v12[0] < 6u);
  }
  return result;
}
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4A71CC: using guessed type int (__stdcall *dword_4A71CC)(_DWORD);
// 4A71D0: using guessed type int (__stdcall *dword_4A71D0)(_DWORD, _DWORD, _DWORD);

//----- (00470D19) --------------------------------------------------------
int __cdecl sub_470D19(int a1)
{
  unsigned int v1; // eax
  void **v2; // eax

  dword_4C326C = dword_4A71C4(a1 == 0, 4096, 0);
  if ( !dword_4C326C )
    return 0;
  v1 = sub_470BD1();
  dword_4C3270 = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_471E59();
  }
  if ( !v2 )
  {
    dword_4A71C8(dword_4C326C);
    return 0;
  }
  return 1;
}
// 4A71C4: using guessed type int (__stdcall *dword_4A71C4)(_DWORD, _DWORD, _DWORD);
// 4A71C8: using guessed type int (__stdcall *dword_4A71C8)(_DWORD);
// 4C3270: using guessed type int dword_4C3270;

//----- (00470EF0) --------------------------------------------------------
int __cdecl __sbh_heap_init(int a1)
{
  int result; // eax

  result = dword_4A7214(dword_4C326C, 0, 320);
  dword_4C3264 = result;
  if ( result )
  {
    dword_4C325C = 0;
    dword_4C3260 = 0;
    dword_4C3254 = result;
    dword_4C3268 = a1;
    dword_4C324C = 16;
    result = 1;
  }
  return result;
}
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4C324C: using guessed type int dword_4C324C;
// 4C3254: using guessed type int dword_4C3254;
// 4C325C: using guessed type int dword_4C325C;
// 4C3260: using guessed type int dword_4C3260;
// 4C3264: using guessed type int dword_4C3264;
// 4C3268: using guessed type int dword_4C3268;
// 4C326C: using guessed type int dword_4C326C;

//----- (00470F38) --------------------------------------------------------
unsigned int __cdecl __sbh_find_block_0(int a1)
{
  unsigned int result; // eax

  for ( result = dword_4C3264; result < dword_4C3264 + 20 * dword_4C3260; result += 20 )
  {
    if ( (unsigned int)(a1 - *(_DWORD *)(result + 12)) < 0x100000 )
      return result;
  }
  return 0;
}
// 4C3260: using guessed type int dword_4C3260;
// 4C3264: using guessed type int dword_4C3264;

//----- (00470F63) --------------------------------------------------------
_DWORD *__cdecl sub_470F63(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  bool v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  void (__stdcall *v18)(_DWORD, _DWORD, int); // esi
  int v19; // eax
  _DWORD *v20; // [esp+Ch] [ebp-10h]
  int v21; // [esp+10h] [ebp-Ch]
  int v22; // [esp+14h] [ebp-8h]
  int v23; // [esp+18h] [ebp-4h]
  char *v24; // [esp+28h] [ebp+Ch]
  int *v25; // [esp+28h] [ebp+Ch]
  char v26; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v20 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v23 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v21 = *(int *)((char *)v3 + v5);
    v22 = *(_DWORD *)(a2 - 8);
    v24 = (char *)v3 + v5;
    if ( (v21 & 1) == 0 )
    {
      v7 = (v21 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v23;
        v6 = v24;
      }
      v5 += v21;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v23 = v5;
      *(_DWORD *)(*((_DWORD *)v24 + 1) + 8) = *((_DWORD *)v24 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v22 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v25 = (int *)((char *)v3 - v22);
      v14 = (v22 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v23 = v22 + v5;
      v13 = ((v22 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v25[1] == v25[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v25[2] + 4) = v25[1];
        *(_DWORD *)(v25[1] + 8) = v25[2];
      }
      v3 = v25;
    }
    if ( (v22 & 1) != 0 || v14 != v13 )
    {
      v17 = &v20[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v26 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v26 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v26 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v26 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v23;
    *(int *)((char *)v3 + v23 - 4) = v23;
    result += 129 * v4 + 81;
    v10 = (*v20)-- == 1;
    if ( v10 )
    {
      if ( dword_4C325C )
      {
        v18 = (void (__stdcall *)(_DWORD, _DWORD, int))dword_4A71C0;
        dword_4A71C0(*(_DWORD *)(dword_4C325C + 12) + (dword_4C3250 << 15), 0x8000, 0x4000);
        *(_DWORD *)(dword_4C325C + 8) |= 0x80000000 >> dword_4C3250;
        *(_DWORD *)(*(_DWORD *)(dword_4C325C + 16) + 4 * dword_4C3250 + 196) = 0;
        --*(_BYTE *)(*(_DWORD *)(dword_4C325C + 16) + 67);
        v19 = dword_4C325C;
        if ( !*(_BYTE *)(*(_DWORD *)(dword_4C325C + 16) + 67) )
        {
          *(_DWORD *)(dword_4C325C + 4) &= 0xFFFFFFFE;
          v19 = dword_4C325C;
        }
        if ( *(_DWORD *)(v19 + 8) == -1 )
        {
          v18(*(_DWORD *)(v19 + 12), 0, 0x8000);
          dword_4A7218(dword_4C326C, 0, *(_DWORD *)(dword_4C325C + 16));
          sub_46CAB0(dword_4C325C, (_BYTE *)(dword_4C325C + 20), 20 * dword_4C3260 - dword_4C325C + dword_4C3264 - 20);
          --dword_4C3260;
          if ( (unsigned int)a1 > dword_4C325C )
            a1 -= 5;
          dword_4C3254 = dword_4C3264;
        }
      }
      result = a1;
      dword_4C3250 = v4;
      dword_4C325C = (int)a1;
    }
  }
  return result;
}
// 4A71C0: using guessed type int (__stdcall *dword_4A71C0)(_DWORD, _DWORD, _DWORD);
// 4A7218: using guessed type int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD);
// 4C3250: using guessed type int dword_4C3250;
// 4C3254: using guessed type int dword_4C3254;
// 4C325C: using guessed type int dword_4C325C;
// 4C3260: using guessed type int dword_4C3260;

//----- (0047128C) --------------------------------------------------------
_DWORD *__cdecl __sbh_alloc_block_0(int a1)
{
  int v1; // ecx
  unsigned int v2; // esi
  tagHeader *i; // ebx
  bool v4; // zf
  bool v5; // zf
  bool v6; // zf
  _DWORD *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int *v14; // edx
  int v15; // ecx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *v18; // edi
  unsigned int v19; // ebx
  _BYTE *v20; // edi
  int v21; // ebx
  _DWORD *v22; // ecx
  char v23; // cl
  _DWORD *v24; // edx
  int v25; // [esp+Ch] [ebp-14h]
  int v26; // [esp+Ch] [ebp-14h]
  signed int v27; // [esp+10h] [ebp-10h]
  unsigned int v28; // [esp+14h] [ebp-Ch]
  _DWORD *v29; // [esp+14h] [ebp-Ch]
  unsigned int v30; // [esp+18h] [ebp-8h]
  int v31; // [esp+18h] [ebp-8h]
  unsigned int v32; // [esp+1Ch] [ebp-4h]
  int v33; // [esp+1Ch] [ebp-4h]
  tagHeader *v34; // [esp+28h] [ebp+8h]

  v32 = dword_4C3264 + 20 * dword_4C3260;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> ((v27 >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (tagHeader *)dword_4C3254;
  v34 = (tagHeader *)dword_4C3254;
  if ( dword_4C3254 < (unsigned int)(dword_4C3264 + 20 * dword_4C3260) )
  {
    do
    {
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
        break;
      i = (tagHeader *)((char *)i + 20);
      v34 = i;
    }
    while ( (unsigned int)i < v32 );
  }
  if ( i == (tagHeader *)v32 )
  {
    for ( i = (tagHeader *)dword_4C3264; ; i = (tagHeader *)((char *)i + 20) )
    {
      v4 = i == (tagHeader *)dword_4C3254;
      v34 = i;
      if ( (unsigned int)i >= dword_4C3254 )
        break;
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
      {
        v4 = i == (tagHeader *)dword_4C3254;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == (tagHeader *)v32;
        if ( (unsigned int)i >= v32 )
          break;
        if ( *((_DWORD *)i + 2) )
        {
          v5 = i == (tagHeader *)v32;
          break;
        }
        i = (tagHeader *)((char *)i + 20);
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (tagHeader *)dword_4C3264; ; i = (tagHeader *)((char *)i + 20) )
        {
          v6 = i == (tagHeader *)dword_4C3254;
          v34 = i;
          if ( (unsigned int)i >= dword_4C3254 )
            break;
          if ( *((_DWORD *)i + 2) )
          {
            v6 = i == (tagHeader *)dword_4C3254;
            break;
          }
        }
        if ( v6 )
        {
          i = __sbh_alloc_new_region();
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      **((_DWORD **)i + 4) = __sbh_alloc_new_group(i);
      if ( **((_DWORD **)i + 4) == -1 )
        return 0;
    }
  }
  dword_4C3254 = (int)i;
  v8 = (_DWORD *)*((_DWORD *)i + 4);
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      *((_DWORD *)v34 + 1) &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *(_DWORD *)v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = v14;
    *(_DWORD *)(v14[1] + 8) = v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *((_DWORD *)i + 1) |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *(_DWORD *)i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && i == (tagHeader *)dword_4C325C && v33 == dword_4C3250 )
    dword_4C325C = 0;
  *v8 = v33;
  return v24 + 1;
}
// 4C3250: using guessed type int dword_4C3250;
// 4C3254: using guessed type int dword_4C3254;
// 4C325C: using guessed type int dword_4C325C;
// 4C3260: using guessed type int dword_4C3260;

//----- (00471595) --------------------------------------------------------
// #API: HeapReAlloc(x,x,x,x)(), HeapAlloc(x,x,x)(), VirtualAlloc(x,x,x,x)(), HeapFree(x,x,x)()
tagHeader *__cdecl __sbh_alloc_new_region()
{
  int v0; // eax
  int v1; // eax
  int v2; // esi
  int v3; // eax
  int v4; // eax

  v0 = dword_4C3260;
  if ( dword_4C3260 == dword_4C324C )
  {
    v1 = dword_4A7210(dword_4C326C, 0, dword_4C3264, 4 * (5 * dword_4C324C + 80));
    if ( !v1 )
      return 0;
    dword_4C324C += 16;
    dword_4C3264 = v1;
    v0 = dword_4C3260;
  }
  v2 = dword_4C3264 + 20 * v0;
  v3 = dword_4A7214(dword_4C326C, 8, 16836);
  *(_DWORD *)(v2 + 16) = v3;
  if ( !v3 )
    return 0;
  v4 = dword_4A71BC(0, 0x100000, 0x2000, 4);
  *(_DWORD *)(v2 + 12) = v4;
  if ( !v4 )
  {
    dword_4A7218(dword_4C326C, 0, *(_DWORD *)(v2 + 16));
    return 0;
  }
  *(_DWORD *)(v2 + 8) = -1;
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  ++dword_4C3260;
  **(_DWORD **)(v2 + 16) = -1;
  return (tagHeader *)v2;
}
// 4A71BC: invalid function type has been ignored
// 4A71BC: using guessed type int (__stdcall *dword_4A71BC)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7210: using guessed type int (__stdcall *dword_4A7210)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4A7218: using guessed type int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD);
// 4C324C: using guessed type int dword_4C324C;
// 4C3260: using guessed type int dword_4C3260;
// 4C3264: using guessed type int dword_4C3264;

//----- (00471646) --------------------------------------------------------
int __cdecl __sbh_alloc_new_group(_DWORD *a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  unsigned int v6; // edi
  _DWORD *v8; // eax

  v1 = a1[4];
  v2 = a1[2];
  v3 = 0;
  while ( v2 >= 0 )
  {
    v2 *= 2;
    ++v3;
  }
  v4 = 63;
  v5 = 516 * v3 + v1 + 324;
  do
  {
    *(_DWORD *)(v5 + 8) = v5;
    *(_DWORD *)(v5 + 4) = v5;
    v5 += 8;
    --v4;
  }
  while ( v4 );
  v6 = a1[3] + (v3 << 15);
  if ( !dword_4A71BC(v6, 0x8000, 4096, 4) )
    return -1;
  if ( v6 <= v6 + 28672 )
  {
    v8 = (_DWORD *)(v6 + 16);
    do
    {
      *(v8 - 2) = -1;
      v8[1019] = -1;
      *(v8 - 1) = 4080;
      *v8 = v8 + 1023;
      v8[1] = v8 - 1025;
      v8[1018] = 4080;
      v8 += 1024;
    }
    while ( (unsigned int)(v8 - 4) <= v6 + 28672 );
  }
  *(_DWORD *)(516 * v3 + v1 + 832) = v6 + 12;
  *(_DWORD *)(v6 + 20) = 516 * v3 + v1 + 828;
  *(_DWORD *)(516 * v3 + v1 + 836) = v6 + 28684;
  *(_DWORD *)(v6 + 28688) = 516 * v3 + v1 + 828;
  *(_DWORD *)(v1 + 4 * v3 + 68) = 0;
  *(_DWORD *)(v1 + 4 * v3 + 196) = 1;
  if ( (*(_BYTE *)(v1 + 67))++ == 0 )
    a1[1] |= 1u;
  a1[2] &= ~(0x80000000 >> v3);
  return v3;
}
// 4A71BC: using guessed type int (__stdcall *dword_4A71BC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00471741) --------------------------------------------------------
int __cdecl __sbh_resize_block_0(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  int v12; // ebx
  bool v13; // zf
  unsigned int v14; // ebx
  _BYTE *v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  char v20; // cl
  int v21; // edx
  int *v22; // eax
  int v24; // ecx
  int *v25; // ebx
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // ebx
  _BYTE *v29; // esi
  int v30; // ebx
  _BYTE *v31; // ecx
  unsigned int v32; // ebx
  unsigned int v33; // ecx
  _DWORD *v34; // eax
  char v35; // cl
  int v36; // [esp+Ch] [ebp-Ch]
  int v37; // [esp+10h] [ebp-8h]
  int v38; // [esp+14h] [ebp-4h]
  int v39; // [esp+14h] [ebp-4h]
  int *v40; // [esp+24h] [ebp+Ch]
  char v41; // [esp+27h] [ebp+Fh]
  int v42; // [esp+28h] [ebp+10h]
  unsigned int v43; // [esp+28h] [ebp+10h]
  int v44; // [esp+28h] [ebp+10h]
  char v45; // [esp+2Bh] [ebp+13h]

  v3 = a1[4];
  v4 = (a3 + 23) & 0xFFFFFFF0;
  v5 = (unsigned int)(a2 - a1[3]) >> 15;
  v36 = 516 * v5 + v3 + 324;
  v6 = *(_DWORD *)(a2 - 4) - 1;
  v42 = v6;
  v7 = *(_DWORD *)(v6 + a2 - 4);
  v8 = v6 + a2 - 4;
  v38 = v7;
  if ( v4 <= v6 )
  {
    if ( v4 < v6 )
    {
      v44 = v6 - v4;
      v24 = v4 + 1;
      *(_DWORD *)(a2 - 4) = v4 + 1;
      v25 = (int *)(a2 + v4 - 4);
      v40 = v25;
      v26 = (v44 >> 4) - 1;
      *(v25 - 1) = v24;
      if ( v26 > 0x3F )
        v26 = 63;
      if ( (v38 & 1) == 0 )
      {
        v27 = (v38 >> 4) - 1;
        if ( v27 > 0x3F )
          v27 = 63;
        if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
        {
          if ( v27 >= 0x20 )
          {
            v31 = (_BYTE *)(v27 + v3 + 4);
            v32 = ~(0x80000000 >> (v27 - 32));
            *(_DWORD *)(v3 + 4 * v5 + 196) &= v32;
            v13 = (*v31)-- == 1;
            if ( v13 )
              a1[1] &= v32;
          }
          else
          {
            v28 = 0x80000000 >> v27;
            v29 = (_BYTE *)(v27 + v3 + 4);
            v30 = ~v28;
            *(_DWORD *)(v3 + 4 * v5 + 68) &= v30;
            v13 = (*v29)-- == 1;
            if ( v13 )
              *a1 &= v30;
          }
          v25 = v40;
        }
        *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
        *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
        v44 += v38;
        v26 = (v44 >> 4) - 1;
        if ( v26 > 0x3F )
          v26 = 63;
      }
      v33 = v36 + 8 * v26;
      v25[1] = *(_DWORD *)(v33 + 4);
      v25[2] = v33;
      *(_DWORD *)(v33 + 4) = v25;
      *(_DWORD *)(v25[1] + 8) = v25;
      if ( v25[1] == v25[2] )
      {
        v41 = *(_BYTE *)(v26 + v3 + 4);
        *(_BYTE *)(v26 + v3 + 4) = v41 + 1;
        if ( v26 >= 0x20 )
        {
          if ( !v41 )
            a1[1] |= 0x80000000 >> (v26 - 32);
          v34 = (_DWORD *)(v3 + 4 * v5 + 196);
          v35 = v26 - 32;
        }
        else
        {
          if ( !v41 )
            *a1 |= 0x80000000 >> v26;
          v34 = (_DWORD *)(v3 + 4 * v5 + 68);
          v35 = v26;
        }
        *v34 |= 0x80000000 >> v35;
      }
      *v25 = v44;
      *(int *)((char *)v25 + v44 - 4) = v44;
    }
  }
  else
  {
    if ( (v7 & 1) != 0 || v4 > v6 + v7 )
      return 0;
    v9 = (v7 >> 4) - 1;
    v37 = v9;
    if ( v9 > 0x3F )
    {
      v9 = 63;
      v37 = 63;
    }
    if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
    {
      if ( v9 >= 0x20 )
      {
        v14 = 0x80000000 >> (v9 - 32);
        v15 = (_BYTE *)(v37 + v3 + 4);
        v16 = ~v14;
        *(_DWORD *)(v3 + 4 * v5 + 196) &= v16;
        v13 = (*v15)-- == 1;
        if ( v13 )
          a1[1] &= v16;
      }
      else
      {
        v10 = 0x80000000 >> v9;
        v11 = (_BYTE *)(v37 + v3 + 4);
        v12 = ~v10;
        *(_DWORD *)(v3 + 4 * v5 + 68) &= v12;
        v13 = (*v11)-- == 1;
        if ( v13 )
          *a1 &= v12;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
    v39 = v42 - v4 + v38;
    if ( v39 <= 0 )
    {
      v21 = a2;
    }
    else
    {
      v17 = (v39 >> 4) - 1;
      v18 = a2 + v4 - 4;
      if ( v17 > 0x3F )
        v17 = 63;
      v43 = v36 + 8 * v17;
      *(_DWORD *)(a2 + v4) = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v43;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(a2 + v4) + 8) = a2 + v4 - 4;
      if ( *(_DWORD *)(a2 + v4) == *(_DWORD *)(a2 + v4 - 4 + 8) )
      {
        v45 = *(_BYTE *)(v17 + v3 + 4);
        *(_BYTE *)(v17 + v3 + 4) = v45 + 1;
        if ( v17 >= 0x20 )
        {
          if ( !v45 )
            a1[1] |= 0x80000000 >> (v17 - 32);
          v19 = (_DWORD *)(v3 + 4 * v5 + 196);
          v20 = v17 - 32;
        }
        else
        {
          if ( !v45 )
            *a1 |= 0x80000000 >> v17;
          v19 = (_DWORD *)(v3 + 4 * v5 + 68);
          v20 = v17;
        }
        *v19 |= 0x80000000 >> v20;
      }
      v21 = a2;
      v22 = (int *)(a2 + v4 - 4);
      *v22 = v39;
      *(int *)((char *)v22 + v39 - 4) = v39;
    }
    *(_DWORD *)(v21 - 4) = v4 + 1;
    *(_DWORD *)(v21 + v4 - 8) = v4 + 1;
  }
  return 1;
}

//----- (00471E59) --------------------------------------------------------
void **sub_471E59()
{
  void **v0; // esi
  int (__stdcall *v1)(int, int, int, int); // ebp
  int v2; // eax
  _DWORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // edx

  if ( dword_4B9F78 == -1 )
  {
    v0 = &off_4B9F68;
  }
  else
  {
    v0 = (void **)dword_4A7214(dword_4C326C, 0, 8224);
    if ( !v0 )
      return 0;
  }
  v1 = dword_4A71BC;
  v2 = dword_4A71BC(0, 0x400000, 0x2000, 4);
  v3 = (_DWORD *)v2;
  if ( !v2 )
  {
LABEL_19:
    if ( v0 != &off_4B9F68 )
      dword_4A7218(dword_4C326C, 0, v0);
    return 0;
  }
  if ( !v1(v2, 0x10000, 4096, 4) )
  {
    dword_4A71C0(v3, 0, 0x8000);
    goto LABEL_19;
  }
  if ( v0 == &off_4B9F68 )
  {
    if ( !off_4B9F68 )
      off_4B9F68 = &off_4B9F68;
    if ( !off_4B9F6C )
      off_4B9F6C = &off_4B9F68;
  }
  else
  {
    *v0 = &off_4B9F68;
    v0[1] = off_4B9F6C;
    off_4B9F6C = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = v3 + 0x100000;
  v4 = (int *)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = v3;
  v0[2] = v0 + 6;
  v5 = 0;
  do
  {
    v6 = v5++ >= 16 ? -1 : 240;
    *v4 = v6;
    v4[1] = 241;
    v4 += 2;
  }
  while ( v5 < 1024 );
  memset(v3, 0, 0x10000u);
  while ( v3 < (_DWORD *)((char *)v0[4] + 0x10000) )
  {
    *((_BYTE *)v3 + 248) = -1;
    *v3 = v3 + 2;
    v3[1] = 240;
    v3 += 1024;
  }
  return v0;
}
// 4A71BC: using guessed type int (__stdcall *dword_4A71BC)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A71C0: using guessed type int (__stdcall *dword_4A71C0)(_DWORD, _DWORD, _DWORD);
// 4A7214: using guessed type int (__stdcall *dword_4A7214)(_DWORD, _DWORD, _DWORD);
// 4A7218: using guessed type int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD);
// 4B9F68: using guessed type void *off_4B9F68;
// 4B9F6C: using guessed type void **off_4B9F6C;
// 4B9F78: using guessed type int dword_4B9F78;

//----- (00471F9D) --------------------------------------------------------
void **__cdecl sub_471F9D(int a1)
{
  void **result; // eax

  result = (void **)dword_4A71C0(*(_DWORD *)(a1 + 16), 0, 0x8000);
  if ( off_4BBF88 == (void **)a1 )
  {
    result = *(void ***)(a1 + 4);
    off_4BBF88 = result;
  }
  if ( (void **)a1 == &off_4B9F68 )
  {
    dword_4B9F78 = -1;
  }
  else
  {
    **(_DWORD **)(a1 + 4) = *(_DWORD *)a1;
    *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)(a1 + 4);
    result = (void **)dword_4A7218(dword_4C326C, 0, a1);
  }
  return result;
}
// 4A71C0: using guessed type int (__stdcall *dword_4A71C0)(_DWORD, _DWORD, _DWORD);
// 4A7218: using guessed type int (__stdcall *dword_4A7218)(_DWORD, _DWORD, _DWORD);
// 4B9F68: using guessed type void *off_4B9F68;
// 4B9F78: using guessed type int dword_4B9F78;
// 4BBF88: using guessed type void **off_4BBF88;

//----- (00471FF3) --------------------------------------------------------
void __cdecl sub_471FF3(int a1)
{
  void **v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = off_4B9F6C;
  do
  {
    if ( v1[4] != (void *)-1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && dword_4A71C0((char *)v1[4] + i, 4096, 0x4000) )
        {
          *v2 = -1;
          --dword_4C1BEC;
          v4 = v1[3];
          if ( !v4 || v4 > v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = (int)v1;
      v1 = (void **)v1[1];
      if ( v8 && *(_DWORD *)(v5 + 24) == -1 )
      {
        v6 = (_DWORD *)(v5 + 32);
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_471F9D(v5);
      }
    }
  }
  while ( v1 != off_4B9F6C && a1 > 0 );
}
// 4A71C0: using guessed type int (__stdcall *dword_4A71C0)(_DWORD, _DWORD, _DWORD);
// 4B9F6C: using guessed type void **off_4B9F6C;
// 4C1BEC: using guessed type int dword_4C1BEC;

//----- (004720B5) --------------------------------------------------------
unsigned int __cdecl sub_4720B5(unsigned int a1, void ***a2, unsigned int *a3)
{
  void **v3; // ecx

  v3 = &off_4B9F68;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_4B9F68 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 4B9F68: using guessed type void *off_4B9F68;

//----- (0047210C) --------------------------------------------------------
void __cdecl sub_47210C(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_4C1BEC == 32 )
    sub_471FF3(16);
}
// 4C1BEC: using guessed type int dword_4C1BEC;

//----- (00472151) --------------------------------------------------------
int __cdecl sub_472151(unsigned int a1)
{
  void **v1; // esi
  void *v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  int result; // eax
  void **v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  int i; // esi
  void **v11; // ecx
  int v12; // eax
  void **v13; // eax
  bool v14; // cf
  void **v15; // eax
  _BYTE *v16; // ecx
  unsigned int Val; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = off_4BBF88;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = (int)v2 + 4096 * (((char *)v3 - (char *)v1 - 24) >> 3);
      v18 = v4;
      if ( v3 < (unsigned int *)v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = sub_472359(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              off_4BBF88 = v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int *)v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (unsigned int *)(v1 + 6);
      Val = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < Val )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = sub_472359(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < Val );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_4BBF88 );
  v7 = &off_4B9F68;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_4B9F68 )
    {
      v15 = sub_471E59();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        off_4BBF88 = v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return (int)(v16 + 256);
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (int)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( dword_4A71BC(i, v20 << 12, 4096, 4) != i )
    return 0;
  v11 = (void **)v8;
  if ( v20 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *v11 = (void *)240;
      v11[1] = (void *)241;
      v12 += 4096;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_4BBF88 = v7;
  v13 = v7 + 2054;
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == (void *)-1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = (void *)(v14 ? (unsigned int)v11 : 0);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = i + 256;
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 4A71BC: using guessed type int (__stdcall *dword_4A71BC)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4B9F68: using guessed type void *off_4B9F68;
// 4BBF88: using guessed type void **off_4BBF88;

//----- (00472359) --------------------------------------------------------
int __cdecl sub_472359(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (0047247D) --------------------------------------------------------
int __cdecl sub_47247D(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  bool v8; // zf
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = (unsigned __int8)*a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * (((int)a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( a2 + 62 >= (_DWORD *)&a3[a4] )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2 )
        {
          if ( v6 >= (_BYTE *)a2 + 248 )
          {
            a2[1] = 0;
            *a2 = a2 + 2;
          }
          else
          {
            v9 = 0;
            *a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            a2[1] = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (00472684) --------------------------------------------------------
int __cdecl _isctype_0(int C, int Type)
{
  int v2; // ecx
  int v3; // eax
  int result; // eax
  int v5; // [esp+0h] [ebp-4h] BYREF

  v5 = v2;
  if ( (unsigned int)(C + 1) <= 0x100 )
  {
    v3 = (unsigned __int16)off_4BBF90[0][C];
    return Type & v3;
  }
  if ( off_4BBF90[0][BYTE1(C)] >= 0 )
  {
    LOWORD(v5) = (unsigned __int8)C;
    result = __crtGetStringTypeA_0(1u, (LPCSTR)&v5, 1, (LPWORD)&C + 1, 0, 0, 1);
  }
  else
  {
    LOBYTE(v5) = BYTE1(C);
    *(_WORD *)((char *)&v5 + 1) = (unsigned __int8)C;
    result = __crtGetStringTypeA_0(1u, (LPCSTR)&v5, 2, (LPWORD)&C + 1, 0, 0, 1);
  }
  if ( result )
  {
    v3 = HIWORD(C);
    return Type & v3;
  }
  return result;
}
// 472687: variable 'v2' is possibly undefined
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (004726F9) --------------------------------------------------------
int __cdecl _flsbuf(int Ch, FILE *File)
{
  FILE *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  char *v6; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = File;
  v3 = File->_flag;
  v4 = File->_file;
  if ( (v3 & 0x82) == 0 || (v3 & 0x40) != 0 )
    goto LABEL_24;
  if ( (v3 & 1) == 0 )
    goto LABEL_6;
  File->_cnt = 0;
  if ( (v3 & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(v3) = v3 | 0x20;
    v2->_flag = v3;
    return -1;
  }
  LOBYTE(v3) = v3 & 0xFE;
  v2->_ptr = v2->_base;
  v2->_flag = v3;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  File = 0;
  LOBYTE(v5) = v5 & 0xEF | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (FILE *)&unk_4BC328 && v2 != &Stream || !_isatty(v4)) )
    _getbuf_0(v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    v6 = v2->_base;
    v7 = v2->_ptr - v6;
    v2->_ptr = v6 + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = &unk_4BC7E0;
      else
        v8 = (_BYTE *)(dword_4C2120[v4 >> 5] + 36 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        sub_476335(v4, 0, 2u);
    }
    else
    {
      File = (FILE *)sub_476145(v4, v6, v7);
    }
    *v2->_base = Ch;
  }
  else
  {
    v7 = 1;
    File = (FILE *)sub_476145(v4, &Ch, 1u);
  }
  if ( File == (FILE *)v7 )
    return (unsigned __int8)Ch;
  v2->_flag |= 0x20u;
  return -1;
}
// 4C2120: using guessed type int dword_4C2120[];

//----- (00472811) --------------------------------------------------------
int __cdecl sub_472811(FILE *a1, char *a2, int a3)
{
  int v3; // esi
  char v4; // bl
  char *v5; // edi
  bool v6; // zf
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // esi
  char *v12; // eax
  char *v13; // ecx
  char *i; // eax
  int v15; // edx
  char *v16; // edi
  __int16 v17; // ax
  __int16 *v18; // eax
  char *v19; // ecx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // esi
  char *j; // eax
  int v24; // edx
  _WORD *v25; // eax
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  int v28; // eax
  int v29; // ebx
  unsigned __int64 v30; // kr08_8
  char *v31; // eax
  char *v32; // eax
  char v33; // bl
  int v34; // esi
  wchar_t *v35; // ebx
  int v36; // edi
  wchar_t v37; // ax
  int v38; // eax
  char MbCh; // [esp+Ch] [ebp-248h] BYREF
  char v42[510]; // [esp+Dh] [ebp-247h] BYREF
  char v43; // [esp+20Bh] [ebp-49h] BYREF
  int v44[2]; // [esp+20Ch] [ebp-48h] BYREF
  __int64 v45; // [esp+214h] [ebp-40h]
  char v46[4]; // [esp+21Ch] [ebp-38h] BYREF
  int v47; // [esp+220h] [ebp-34h]
  int v48; // [esp+224h] [ebp-30h]
  int v49; // [esp+228h] [ebp-2Ch]
  int v50; // [esp+22Ch] [ebp-28h]
  int v51; // [esp+230h] [ebp-24h]
  int v52; // [esp+234h] [ebp-20h]
  int v53; // [esp+238h] [ebp-1Ch]
  char v54[2]; // [esp+23Eh] [ebp-16h] BYREF
  int v55; // [esp+240h] [ebp-14h] BYREF
  int v56; // [esp+244h] [ebp-10h]
  int v57; // [esp+248h] [ebp-Ch]
  char *v58; // [esp+24Ch] [ebp-8h]
  int v59; // [esp+250h] [ebp-4h]
  char *v60; // [esp+260h] [ebp+Ch]

  v3 = 0;
  v4 = *a2;
  v5 = a2 + 1;
  v6 = *a2 == 0;
  v57 = 0;
  v55 = 0;
  v60 = a2 + 1;
  if ( !v6 )
  {
    v7 = v56;
    while ( 1 )
    {
      if ( v55 < 0 )
        return v55;
      if ( v4 < 32 || v4 > 120 )
        v8 = 0;
      else
        v8 = Str1[v4 + 16] & 0xF;
      v48 = byte_4AF580[8 * v8 + v3] >> 4;
      switch ( v48 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v56 = -1;
          v47 = 0;
          v50 = 0;
          v52 = 0;
          v53 = 0;
          v59 = 0;
          v51 = 0;
          goto LABEL_179;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v59 |= 2u;
              break;
            case '#':
              LOBYTE(v59) = v59 | 0x80;
              break;
            case '+':
              v59 |= 1u;
              break;
            case '-':
              v59 |= 4u;
              break;
            case '0':
              v59 |= 8u;
              break;
          }
          goto LABEL_179;
        case 3:
          if ( v4 == 42 )
          {
            v9 = sub_472FF0(&a3);
            v52 = v9;
            if ( v9 >= 0 )
              goto LABEL_179;
            v59 |= 4u;
            v10 = -v9;
          }
          else
          {
            v10 = v4 + 10 * v52 - 48;
          }
          v52 = v10;
          goto LABEL_179;
        case 4:
          v56 = 0;
          goto LABEL_179;
        case 5:
          if ( v4 == 42 )
          {
            v56 = sub_472FF0(&a3);
            if ( v56 < 0 )
              v56 = -1;
          }
          else
          {
            v56 = v4 + 10 * v7 - 48;
          }
          goto LABEL_179;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v59) |= 0x80u;
                v60 = v5 + 2;
              }
              else
              {
                v48 = 0;
LABEL_42:
                v51 = 0;
                if ( off_4BBF90[0][(unsigned __int8)v4] < 0 )
                {
                  write_char_0(v4, a1, (int)&v55);
                  v4 = *v5;
                  v60 = v5 + 1;
                }
                write_char_0(v4, a1, (int)&v55);
              }
              break;
            case 'h':
              v59 |= 0x20u;
              break;
            case 'l':
              v59 |= 0x10u;
              break;
            case 'w':
              BYTE1(v59) |= 8u;
              break;
          }
          goto LABEL_179;
        case 7:
          if ( v4 <= 103 )
          {
            if ( v4 >= 101 )
              goto LABEL_65;
            if ( v4 > 88 )
            {
              if ( v4 == 90 )
              {
                v18 = (__int16 *)sub_472FF0(&a3);
                if ( v18 && (v19 = (char *)*((_DWORD *)v18 + 1)) != 0 )
                {
                  if ( (v59 & 0x800) != 0 )
                  {
                    v20 = (unsigned int)*v18 >> 1;
                    v58 = v19;
                    v57 = v20;
                    v51 = 1;
                    goto LABEL_156;
                  }
                  v51 = 0;
                  v58 = v19;
                  v21 = *v18;
                }
                else
                {
                  v58 = off_4BC1A8;
                  v21 = strlen(off_4BC1A8);
                }
                goto LABEL_155;
              }
              if ( v4 == 99 )
                goto LABEL_69;
              if ( v4 != 100 )
                goto LABEL_156;
LABEL_122:
              v59 |= 0x40u;
LABEL_123:
              v57 = 10;
              goto LABEL_124;
            }
            if ( v4 != 88 )
            {
              if ( v4 != 67 )
              {
                if ( v4 == 69 || v4 == 71 )
                {
                  v47 = 1;
                  v4 += 32;
LABEL_65:
                  v59 |= 0x40u;
                  v16 = &MbCh;
                  v58 = &MbCh;
                  if ( v7 >= 0 )
                  {
                    if ( !v7 && v4 == 103 )
                      v56 = 1;
                  }
                  else
                  {
                    v56 = 6;
                  }
                  a3 += 8;
                  v44[0] = *(_DWORD *)(a3 - 8);
                  v44[1] = *(_DWORD *)(a3 - 4);
                  off_4B9F48(v44, &MbCh, v4, v56, v47);
                  v22 = v59 & 0x80;
                  if ( (v59 & 0x80) != 0 && !v56 )
                    off_4B9F54(&MbCh);
                  if ( v4 == 103 && !v22 )
                    off_4B9F4C(&MbCh);
                  if ( MbCh == 45 )
                  {
                    BYTE1(v59) |= 1u;
                    v16 = v42;
                    v58 = v42;
                  }
                  v21 = strlen(v16);
                }
                else
                {
                  if ( v4 != 83 )
                    goto LABEL_156;
                  if ( (v59 & 0x830) == 0 )
                    BYTE1(v59) |= 8u;
LABEL_55:
                  v11 = v56;
                  if ( v56 == -1 )
                    v11 = 0x7FFFFFFF;
                  v12 = (char *)sub_472FF0(&a3);
                  v13 = v12;
                  v58 = v12;
                  if ( (v59 & 0x810) != 0 )
                  {
                    if ( !v12 )
                    {
                      v13 = (char *)off_4BC1AC;
                      v58 = (char *)off_4BC1AC;
                    }
                    v51 = 1;
                    for ( i = v13; ; i += 2 )
                    {
                      v15 = v11--;
                      if ( !v15 || !*(_WORD *)i )
                        break;
                    }
                    v21 = (i - v13) >> 1;
                  }
                  else
                  {
                    if ( !v12 )
                    {
                      v13 = off_4BC1A8;
                      v58 = off_4BC1A8;
                    }
                    for ( j = v13; ; ++j )
                    {
                      v24 = v11--;
                      if ( !v24 || !*j )
                        break;
                    }
                    v21 = j - v13;
                  }
                }
LABEL_155:
                v57 = v21;
                goto LABEL_156;
              }
              if ( (v59 & 0x830) == 0 )
                BYTE1(v59) |= 8u;
LABEL_69:
              if ( (v59 & 0x810) != 0 )
              {
                v17 = sub_47300D(&a3);
                v57 = wctomb(&MbCh, v17);
                if ( v57 < 0 )
                  v50 = 1;
              }
              else
              {
                MbCh = sub_472FF0(&a3);
                v57 = 1;
              }
              v58 = &MbCh;
              goto LABEL_156;
            }
            goto LABEL_113;
          }
          if ( v4 == 105 )
            goto LABEL_122;
          if ( v4 == 110 )
          {
            v25 = (_WORD *)sub_472FF0(&a3);
            if ( (v59 & 0x20) != 0 )
              *v25 = v55;
            else
              *(_DWORD *)v25 = v55;
            v50 = 1;
            goto LABEL_179;
          }
          if ( v4 != 111 )
          {
            if ( v4 != 112 )
            {
              if ( v4 == 115 )
                goto LABEL_55;
              if ( v4 == 117 )
                goto LABEL_123;
              if ( v4 != 120 )
                goto LABEL_156;
              v49 = 39;
              goto LABEL_114;
            }
            v56 = 8;
LABEL_113:
            v49 = 7;
LABEL_114:
            v57 = 16;
            if ( (v59 & 0x80u) != 0 )
            {
              v54[0] = 48;
              v53 = 2;
              v54[1] = v49 + 81;
            }
            goto LABEL_124;
          }
          v57 = 8;
          if ( (v59 & 0x80u) != 0 )
            BYTE1(v59) |= 2u;
LABEL_124:
          if ( (v59 & 0x8000) == 0 )
          {
            if ( (v59 & 0x20) != 0 )
            {
              if ( (v59 & 0x40) != 0 )
                LODWORD(v26) = (__int16)sub_472FF0(&a3);
              else
                LODWORD(v26) = (unsigned __int16)sub_472FF0(&a3);
            }
            else
            {
              if ( (v59 & 0x40) == 0 )
              {
                v26 = (unsigned int)sub_472FF0(&a3);
                goto LABEL_134;
              }
              LODWORD(v26) = sub_472FF0(&a3);
            }
            v26 = (int)v26;
          }
          else
          {
            v26 = sub_472FFD(&a3);
          }
LABEL_134:
          if ( (v59 & 0x40) != 0 && v26 < 0 )
          {
            HIDWORD(v27) = -(int)v26;
            BYTE1(v59) |= 1u;
            LODWORD(v27) = (unsigned __int64)-v26 >> 32;
          }
          else
          {
            v27 = __PAIR64__(v26, HIDWORD(v26));
          }
          if ( (v59 & 0x8000) == 0 )
            LODWORD(v27) = 0;
          if ( v56 >= 0 )
            v59 &= 0xFFFFFFF7;
          else
            v56 = 1;
          if ( !v27 )
            v53 = 0;
          v58 = &v43;
          while ( 1 )
          {
            v28 = v56--;
            if ( v28 <= 0 && !v27 )
              break;
            v45 = v57;
            v29 = __PAIR64__(v27, HIDWORD(v27)) % v57 + 48;
            v30 = __PAIR64__(v27, HIDWORD(v27)) / v57;
            v27 = __PAIR64__(v30, HIDWORD(v30));
            if ( v29 > 57 )
              LOBYTE(v29) = v49 + v29;
            v31 = v58--;
            *v31 = v29;
          }
          v32 = (char *)(&v43 - v58++);
          v57 = (int)v32;
          if ( (v59 & 0x200) != 0 && (*v58 != 48 || !v32) )
          {
            --v58;
            v21 = (int)(v32 + 1);
            *v58 = 48;
            goto LABEL_155;
          }
LABEL_156:
          if ( v50 )
            goto LABEL_179;
          v33 = v59;
          if ( (v59 & 0x40) == 0 )
            goto LABEL_165;
          if ( (v59 & 0x100) != 0 )
          {
            v54[0] = 45;
LABEL_164:
            v53 = 1;
            goto LABEL_165;
          }
          if ( (v59 & 1) != 0 )
          {
            v54[0] = 43;
            goto LABEL_164;
          }
          if ( (v59 & 2) != 0 )
          {
            v54[0] = 32;
            goto LABEL_164;
          }
LABEL_165:
          v34 = v52 - v53 - v57;
          if ( (v59 & 0xC) == 0 )
            write_multi_char_0(32, v52 - v53 - v57, a1, &v55);
          write_string_0((int)v54, v53, a1, (int)&v55);
          if ( (v33 & 8) != 0 && (v33 & 4) == 0 )
            write_multi_char_0(48, v34, a1, &v55);
          if ( v51 && v57 > 0 )
          {
            v35 = (wchar_t *)v58;
            v36 = v57 - 1;
            do
            {
              v37 = *v35++;
              v38 = wctomb(v46, v37);
              if ( v38 <= 0 )
                break;
              write_string_0((int)v46, v38, a1, (int)&v55);
            }
            while ( v36-- );
          }
          else
          {
            write_string_0((int)v58, v57, a1, (int)&v55);
          }
          if ( (v59 & 4) != 0 )
            write_multi_char_0(32, v34, a1, &v55);
LABEL_179:
          v4 = *v60;
          v5 = v60 + 1;
          v6 = *v60++ == 0;
          if ( v6 )
            return v55;
          v7 = v56;
          v3 = v48;
          break;
        default:
          goto LABEL_179;
      }
    }
  }
  return v55;
}
// 4B9F48: using guessed type int (__cdecl *off_4B9F48)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4B9F4C: using guessed type int (__cdecl *off_4B9F4C)(_DWORD);
// 4B9F54: using guessed type int (__cdecl *off_4B9F54)(_DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BC1A8: using guessed type char *off_4BC1A8;
// 4BC1AC: using guessed type wchar_t *off_4BC1AC;

//----- (00472F52) --------------------------------------------------------
int __cdecl write_char_0(int a1, FILE *File, int a3)
{
  int v4; // eax
  bool v5; // zf
  int result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf(a1, File);
  }
  else
  {
    *File->_ptr++ = a1;
    v4 = (unsigned __int8)a1;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *(_DWORD *)a3 = -1;
  else
    ++*(_DWORD *)a3;
  return result;
}

//----- (00472F87) --------------------------------------------------------
int __cdecl write_multi_char_0(int a1, int a2, FILE *a3, _DWORD *a4)
{
  int result; // eax
  int i; // edi

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    result = write_char_0(a1, a3, (int)a4);
    if ( *a4 == -1 )
      break;
  }
  return result;
}

//----- (00472FB8) --------------------------------------------------------
int __cdecl write_string_0(int a1, int a2, FILE *File, int a4)
{
  int result; // eax
  int i; // ebx
  int v7; // eax

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    v7 = *(char *)a1++;
    result = write_char_0(v7, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (00472FF0) --------------------------------------------------------
int __cdecl sub_472FF0(_DWORD *a1)
{
  *a1 += 4;
  return *(_DWORD *)(*a1 - 4);
}

//----- (00472FFD) --------------------------------------------------------
__int64 __cdecl sub_472FFD(_DWORD *a1)
{
  *a1 += 8;
  return *(_QWORD *)(*a1 - 8);
}

//----- (0047300D) --------------------------------------------------------
__int16 __cdecl sub_47300D(_DWORD *a1)
{
  *a1 += 4;
  return *(_WORD *)(*a1 - 4);
}

//----- (00473045) --------------------------------------------------------
BOOL __cdecl sub_473045(int a1)
{
  return dword_4C1BF4 && dword_4C1BF4(a1);
}
// 4C1BF4: using guessed type int (__cdecl *dword_4C1BF4)(_DWORD);

//----- (00473060) --------------------------------------------------------
void *__cdecl memcpy_0(void *a1, const void *Src, size_t Size)
{
  char *v3; // esi
  char *v4; // edi
  size_t v5; // ecx
  void *result; // eax
  char *v7; // esi
  char *v8; // edi
  size_t v9; // ecx

  v3 = (char *)Src;
  v4 = (char *)a1;
  if ( a1 > Src && a1 < (char *)Src + Size )
  {
    v7 = (char *)Src + Size - 4;
    v8 = (char *)a1 + Size - 4;
    if ( ((unsigned __int8)v8 & 3) == 0 )
    {
      v9 = Size >> 2;
      if ( Size >> 2 >= 8 )
      {
        while ( v9 )
        {
          *(_DWORD *)v8 = *(_DWORD *)v7;
          v7 -= 4;
          v8 -= 4;
          --v9;
        }
        switch ( Size & 3 )
        {
          case 0u:
            goto LABEL_32;
          case 1u:
            goto LABEL_33;
          case 2u:
            goto LABEL_34;
          case 3u:
            goto LABEL_35;
        }
      }
      switch ( Size & 3 )
      {
        case 0u:
          goto LABEL_32;
        case 1u:
          goto LABEL_33;
        case 2u:
          goto LABEL_34;
        case 3u:
          goto LABEL_35;
      }
    }
    switch ( Size )
    {
      case 0u:
LABEL_32:
        result = a1;
        break;
      case 1u:
LABEL_33:
        v8[3] = v7[3];
        result = a1;
        break;
      case 2u:
LABEL_34:
        v8[3] = v7[3];
        v8[2] = v7[2];
        result = a1;
        break;
      case 3u:
LABEL_35:
        v8[3] = v7[3];
        v8[2] = v7[2];
        v8[1] = v7[1];
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr (loc_473244+4)[eax*4] }
        return result;
    }
  }
  else
  {
    if ( ((unsigned __int8)a1 & 3) != 0 )
    {
      if ( Size >= 4 )
        __asm { jmp     dword ptr (loc_4730BC+4)[eax*4] }
      __asm { jmp     dword ptr loc_4731B8[ecx*4]; jumptable 00409CB5 case 0 }
    }
    v5 = Size >> 2;
    switch ( v5 )
    {
      case 0u:
        goto LABEL_17;
      case 1u:
        goto LABEL_16;
      case 2u:
        goto LABEL_15;
      case 3u:
        goto LABEL_14;
      case 4u:
        goto LABEL_13;
      case 5u:
        goto LABEL_12;
      case 6u:
        goto LABEL_11;
      case 7u:
        *((_DWORD *)a1 + v5 - 7) = *((_DWORD *)Src + v5 - 7);
LABEL_11:
        *((_DWORD *)a1 + v5 - 6) = *((_DWORD *)Src + v5 - 6);
LABEL_12:
        *((_DWORD *)a1 + v5 - 5) = *((_DWORD *)Src + v5 - 5);
LABEL_13:
        *((_DWORD *)a1 + v5 - 4) = *((_DWORD *)Src + v5 - 4);
LABEL_14:
        *((_DWORD *)a1 + v5 - 3) = *((_DWORD *)Src + v5 - 3);
LABEL_15:
        *((_DWORD *)a1 + v5 - 2) = *((_DWORD *)Src + v5 - 2);
LABEL_16:
        *((_DWORD *)a1 + v5 - 1) = *((_DWORD *)Src + v5 - 1);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
LABEL_17:
        switch ( Size & 3 )
        {
          case 0u:
            goto LABEL_18;
          case 1u:
            goto LABEL_19;
          case 2u:
            goto LABEL_20;
          case 3u:
            goto LABEL_21;
        }
      default:
        qmemcpy(a1, Src, 4 * v5);
        v3 = (char *)Src + 4 * v5;
        v4 = (char *)a1 + 4 * v5;
        switch ( Size & 3 )
        {
          case 0u:
LABEL_18:
            result = a1;
            break;
          case 1u:
LABEL_19:
            *v4 = *v3;
            result = a1;
            break;
          case 2u:
LABEL_20:
            *v4 = *v3;
            v4[1] = v3[1];
            result = a1;
            break;
          case 3u:
LABEL_21:
            *v4 = *v3;
            v4[1] = v3[1];
            v4[2] = v3[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}

//----- (004735DB) --------------------------------------------------------
char *__cdecl _setlocale_set_cat(int a1, char *Str)
{
  size_t v3; // eax
  char *v4; // eax
  char Stra[132]; // [esp+Ch] [ebp-A4h] BYREF
  char v7[8]; // [esp+90h] [ebp-20h] BYREF
  int v8; // [esp+98h] [ebp-18h] BYREF
  int v9; // [esp+9Ch] [ebp-14h]
  __int16 Src[4]; // [esp+A0h] [ebp-10h] BYREF
  void *v11; // [esp+A8h] [ebp-8h]
  int v12; // [esp+ACh] [ebp-4h]
  char *v13; // [esp+B8h] [ebp+8h]
  int v14; // [esp+BCh] [ebp+Ch]

  if ( !_expandlocale(Str, Stra, Src, (int)&v8) )
    return 0;
  v3 = strlen(Stra);
  v14 = sub_46D9FD(v3 + 1);
  if ( !v14 )
    return 0;
  v13 = (&Destination)[3 * a1];
  v9 = dword_4C1C04[a1];
  v11 = (void *)(6 * a1 + 4988488);
  memcpy_0(v7, v11, 6u);
  v12 = dword_4C1C1C;
  sub_476F50();
  (&Destination)[3 * a1] = v4;
  dword_4C1C04[a1] = (unsigned __int16)Src[0];
  memcpy_0(v11, Src, 6u);
  if ( a1 == 2 )
    dword_4C1C1C = v8;
  if ( a1 == 1 )
    dword_4C1C20 = v8;
  if ( (*(&funcs_4736AC + 3 * a1))() )
  {
    (&Destination)[3 * a1] = v13;
    sub_46D360(v14);
    dword_4C1C04[a1] = v9;
    dword_4C1C1C = v12;
    return 0;
  }
  if ( v13 != (char *)&unk_4BC1B0 )
    sub_46D360((unsigned int)v13);
  return (&Destination)[3 * a1];
}
// 473678: variable 'v4' is possibly undefined
// 4BC2C8: using guessed type int (*funcs_4736AC)();
// 4C1C20: using guessed type int dword_4C1C20;

//----- (004736F6) --------------------------------------------------------
char *_setlocale_get_all()
{
  char *v0; // eax
  int v1; // ebp
  void **v2; // esi
  const char **v3; // ebx
  const char *v5; // [esp-Ch] [ebp-1Ch]

  v0 = Destination;
  v1 = 1;
  if ( !Destination )
  {
    v0 = (char *)sub_46D9FD(0x351u);
    Destination = v0;
  }
  *v0 = 0;
  _strcats(Destination, 3);
  v2 = &off_4BC2D0;
  v3 = (const char **)&off_4BC2D0;
  do
  {
    strcat(Destination, asc_4AF634);
    v5 = (const char *)v2[3];
    v2 += 3;
    if ( strcmp(*v3, v5) )
      v1 = 0;
    v3 = (const char **)v2;
    _strcats(Destination, 3);
  }
  while ( (int)v2 < (int)&off_4BC300 );
  if ( !v1 )
    return Destination;
  sub_46D360((unsigned int)Destination);
  Destination = 0;
  return (char *)off_4BC2DC;
}
// 4BC2D0: using guessed type void *off_4BC2D0;
// 4BC2DC: using guessed type void *off_4BC2DC;
// 4BC300: using guessed type void *off_4BC300;

//----- (004737AF) --------------------------------------------------------
char *__cdecl _expandlocale(char *Str, char *Dest, void *Dst, int a4)
{
  char *result; // eax
  char v5[136]; // [esp+Ch] [ebp-88h] BYREF

  if ( !Str )
    return 0;
  if ( *Str == 67 && !Str[1] )
  {
    result = Dest;
    Dest[1] = 0;
    *Dest = 67;
    if ( Dst )
    {
      *(_WORD *)Dst = 0;
      *((_WORD *)Dst + 1) = 0;
      *((_WORD *)Dst + 2) = 0;
    }
    if ( a4 )
      *(_DWORD *)a4 = 0;
    return result;
  }
  if ( strcmp(aC, Str) && strcmp(aC_0, Str) )
  {
    if ( __lc_strtolc(v5, Str) || !__get_qualified_locale(v5, word_4C1BF8, (int)v5) )
      return 0;
    dword_4C1C00 = (unsigned __int16)word_4C1BFC;
    __lc_lctostr(aC, v5);
    sub_476F50();
  }
  if ( Dst )
    memcpy_0(Dst, word_4C1BF8, 6u);
  if ( a4 )
    memcpy_0((void *)a4, &dword_4C1C00, 4u);
  sub_476F50();
  return aC;
}
// 4C1BFC: using guessed type __int16 word_4C1BFC;
// 4C1C00: using guessed type int dword_4C1C00;

//----- (004738C7) --------------------------------------------------------
int sub_4738C7()
{
  return 0;
}

//----- (004738CA) --------------------------------------------------------
char *__cdecl _strcats(char *Dest, int a2)
{
  int v2; // edi
  int *v3; // esi
  char *result; // eax
  const char *v5; // [esp-8h] [ebp-Ch]

  v2 = a2;
  if ( a2 > 0 )
  {
    v3 = &a2;
    do
    {
      v5 = (const char *)v3[1];
      ++v3;
      result = strcat(Dest, v5);
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (004738EF) --------------------------------------------------------
int __cdecl __lc_strtolc(void *Dst, char *Str)
{
  char *v2; // esi
  int v4; // eax
  char v5; // bl
  char *v6; // edi
  char *v7; // eax
  const char *v8; // [esp-8h] [ebp-14h]
  size_t v9; // [esp-4h] [ebp-10h]
  char *Stra; // [esp+18h] [ebp+Ch]

  memset(Dst, 0, 0x88u);
  v2 = Str;
  if ( !*Str )
    return 0;
  if ( *Str == 46 && Str[1] )
  {
    sub_476F50();
    return 0;
  }
  for ( Stra = 0; ; ++Stra )
  {
    v4 = strcspn(v2, Control);
    if ( !v4 )
      break;
    v5 = v2[v4];
    v6 = &v2[v4];
    if ( Stra )
    {
      if ( Stra == (char *)1 )
      {
        if ( v4 >= 64 || v5 == 95 )
          return -1;
        v9 = v4;
        v8 = v2;
        v7 = (char *)Dst + 64;
      }
      else
      {
        if ( Stra != (char *)2 || v5 && v5 != 44 )
          return -1;
        v9 = v4;
        v8 = v2;
        v7 = (char *)Dst + 128;
      }
      strncpy(v7, v8, v9);
    }
    else
    {
      if ( v4 >= 64 || v5 == 46 )
        return -1;
      strncpy((char *)Dst, v2, v4);
    }
    if ( v5 == 44 || !v5 )
      return 0;
    v2 = v6 + 1;
  }
  return -1;
}

//----- (004739BB) --------------------------------------------------------
char *__cdecl __lc_lctostr(char *Dest, char *Source)
{
  char *result; // eax

  sub_476F50();
  if ( Source[64] )
    _strcats(Dest, 2);
  result = Source + 128;
  if ( Source[128] )
    result = _strcats(Dest, 2);
  return result;
}

//----- (00473A0E) --------------------------------------------------------
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  int v17; // eax
  _DWORD v18[5]; // [esp+0h] [ebp-38h] BYREF
  _DWORD *v19; // [esp+14h] [ebp-24h]
  _DWORD *v20; // [esp+18h] [ebp-20h]
  int v21; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !dword_4C1C24 )
  {
    if ( dword_4A71A8(0, 256, &unk_4AF64C, 1, 0, 0) )
    {
      dword_4C1C24 = 1;
    }
    else
    {
      if ( !dword_4A71AC(0, 256, &unk_4AF648, 1, 0, 0) )
        return 0;
      dword_4C1C24 = 2;
    }
  }
  if ( cbMultiByte > 0 )
    cbMultiByte = (int)strncnt_0(lpMultiByteStr, (_BYTE *)cbMultiByte);
  if ( dword_4C1C24 == 2 )
    return dword_4A71AC(Locale, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest);
  if ( dword_4C1C24 != 1 )
    return 0;
  if ( !CodePage )
    CodePage = dword_4C1C1C;
  v9 = dword_4A71B0(CodePage, a8 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
  v10 = v9;
  v21 = v9;
  if ( !v9 )
    return 0;
  v11 = 2 * v9 + 3;
  LOBYTE(v11) = v11 & 0xFC;
  v12 = alloca(v11);
  ms_exc.old_esp = (DWORD)v18;
  v19 = v18;
  ms_exc.registration.TryLevel = -1;
  if ( !v18 )
    return 0;
  if ( !dword_4A71B0(CodePage, 1, lpMultiByteStr, cbMultiByte, v19, v10) )
    return 0;
  v13 = dword_4A71A8(Locale, dwMapFlags, v19, v10, 0, 0);
  v14 = v13;
  v18[4] = v13;
  if ( !v13 )
    return 0;
  if ( (dwMapFlags & 0x400) != 0 )
  {
    if ( cchDest && (v13 > cchDest || !dword_4A71A8(Locale, dwMapFlags, v19, v10, lpDestStr, cchDest)) )
      return 0;
  }
  else
  {
    v15 = 2 * v13 + 3;
    LOBYTE(v15) = v15 & 0xFC;
    v16 = alloca(v15);
    ms_exc.old_esp = (DWORD)v18;
    v20 = v18;
    ms_exc.registration.TryLevel = -1;
    if ( !v18 || !dword_4A71A8(Locale, dwMapFlags, v19, v21, v18, v14) )
      return 0;
    v17 = cchDest ? dword_4A71B4(CodePage, 544, v18, v14, lpDestStr, cchDest, 0, 0) : dword_4A71B4(
                                                                                        CodePage,
                                                                                        544,
                                                                                        v18,
                                                                                        v14,
                                                                                        0,
                                                                                        0,
                                                                                        0,
                                                                                        0);
    v14 = v17;
    if ( !v17 )
      return 0;
  }
  return v14;
}
// 4A71A8: using guessed type int (__stdcall *dword_4A71A8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A71AC: using guessed type int (__stdcall *dword_4A71AC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B0: using guessed type int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1C24: using guessed type int dword_4C1C24;

//----- (00473C32) --------------------------------------------------------
_BYTE *__cdecl strncnt_0(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *result; // eax

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = a2;
  else
    result = (_BYTE *)(v2 - a1);
  return result;
}

//----- (00473C5D) --------------------------------------------------------
int __cdecl sub_473C5D(unsigned int a1)
{
  int v1; // esi
  bool v2; // zf
  unsigned __int8 *v3; // eax
  void **v5; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v6; // [esp+10h] [ebp-28h]
  unsigned int v7; // [esp+14h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( dword_4C3270 == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    v9 = __sbh_find_block_0(a1);
    if ( v9 )
    {
      v1 = *(_DWORD *)(a1 - 4) - 9;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    sub_46FA37(9);
    v2 = v9 == 0;
  }
  else
  {
    if ( dword_4C3270 != 2 )
      return dword_4A71A4(dword_4C326C, 0, a1);
    _lock(9);
    ms_exc.registration.TryLevel = 1;
    v3 = (unsigned __int8 *)sub_4720B5(a1, &v5, &v7);
    v6 = v3;
    if ( v3 )
    {
      v1 = 16 * *v3;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    sub_46FA37(9);
    v2 = v6 == 0;
  }
  if ( v2 )
    return dword_4A71A4(dword_4C326C, 0, a1);
  return v1;
}
// 4A71A4: using guessed type int (__stdcall *dword_4A71A4)(_DWORD, _DWORD, _DWORD);
// 4C3270: using guessed type int dword_4C3270;

//----- (00473E07) --------------------------------------------------------
void __cdecl _lock_file(FILE *Stream)
{
  if ( Stream < (FILE *)&off_4BC308 || Stream > &stru_4BC568 )
    dword_4A71E4(&Stream[1]);
  else
    _lock((((char *)Stream - (char *)&off_4BC308) >> 5) + 28);
}
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);
// 4BC308: using guessed type void *off_4BC308;

//----- (00473E36) --------------------------------------------------------
int __cdecl _lock_file2(int a1, int a2)
{
  int result; // eax

  if ( a1 >= 20 )
    result = dword_4A71E4(a2 + 32);
  else
    result = _lock(a1 + 28);
  return result;
}
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);

//----- (00473E59) --------------------------------------------------------
int __cdecl sub_473E59(unsigned int a1)
{
  int result; // eax

  if ( a1 < (unsigned int)&off_4BC308 || a1 > (unsigned int)&stru_4BC568 )
    result = dword_4A71E0(a1 + 32);
  else
    result = sub_46FA37(((int)(a1 - (_DWORD)&off_4BC308) >> 5) + 28);
  return result;
}
// 4A71E0: using guessed type int (__stdcall *dword_4A71E0)(_DWORD);
// 4BC308: using guessed type void *off_4BC308;

//----- (00473E88) --------------------------------------------------------
int __cdecl sub_473E88(int a1, int a2)
{
  int result; // eax

  if ( a1 >= 20 )
    result = dword_4A71E0(a2 + 32);
  else
    result = sub_46FA37(a1 + 28);
  return result;
}
// 4A71E0: using guessed type int (__stdcall *dword_4A71E0)(_DWORD);

//----- (00473EAB) --------------------------------------------------------
int __cdecl _stbuf_0(int a1)
{
  int v1; // eax
  int *v2; // edi
  int v3; // eax
  int v4; // edi

  if ( !_isatty(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( (_UNKNOWN *)a1 == &unk_4BC328 )
  {
    v1 = 0;
  }
  else
  {
    if ( (FILE *)a1 != &Stream )
      return 0;
    v1 = 1;
  }
  ++dword_4C1C28;
  if ( (*(_WORD *)(a1 + 12) & 0x10C) != 0 )
    return 0;
  v2 = (int *)(4 * v1 + 4987948);
  if ( dword_4C1C2C[v1] || (v3 = sub_46D9FD(0x1000u), (*v2 = v3) != 0) )
  {
    v4 = *v2;
    *(_DWORD *)(a1 + 24) = 4096;
    *(_DWORD *)(a1 + 8) = v4;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)a1 = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
    *(_DWORD *)(a1 + 4) = 2;
  }
  *(_WORD *)(a1 + 12) |= 0x1102u;
  return 1;
}
// 4C1C28: using guessed type int dword_4C1C28;

//----- (00473F38) --------------------------------------------------------
int __cdecl _ftbuf(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
    {
      result = _flush_0((_DWORD *)a2);
      *(_BYTE *)(a2 + 13) &= 0xEEu;
      *(_DWORD *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  return result;
}

//----- (00473F62) --------------------------------------------------------
int __cdecl __loctotime_t_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // eax
  _DWORD v12[9]; // [esp+4h] [ebp-24h] BYREF
  int v13; // [esp+30h] [ebp+8h]

  v7 = a1 - 1900;
  if ( a1 - 1900 < 70 || v7 > 138 )
    return -1;
  v8 = a3 + dword_4BD078[a2];
  if ( (v7 & 3) == 0 && a2 > 2 )
    ++v8;
  __tzset();
  v12[7] = v8;
  v12[5] = a1 - 1900;
  v12[2] = a4;
  v12[4] = a2 - 1;
  v9 = dword_4BC6A0 + 60 * (a5 + 60 * (a4 + 24 * (((a1 - 1901) >> 2) + v8 + 365 * (a1 - 1900)))) + a6 + 2085978496;
  v13 = v9;
  if ( a7 == 1 || a7 == -1 && dword_4BC6A4 && (v10 = _isindst(v12), v9 = v13, v10) )
    v9 += dword_4BC6A8;
  return v9;
}
// 4BC6A0: using guessed type int dword_4BC6A0;
// 4BC6A4: using guessed type int dword_4BC6A4;
// 4BC6A8: using guessed type int dword_4BC6A8;
// 4BD078: using guessed type int dword_4BD078[];

//----- (00474024) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl _handle_qnan1(double a1, int a2)
{
  __int16 v5; // cx

  if ( !dword_4BD0B0 )
    return _umatherr(
             1,
             SLODWORD(a1),
             SHIDWORD(a1),
             a2,
             COERCE_UNSIGNED_INT64(0.0),
             HIDWORD(COERCE_UNSIGNED_INT64(0.0)),
             *(double *)((char *)&a1 + 4));
  *sub_46D641() = 33;
  _ctrlfp(v5);
  return *(double *)((char *)&a1 + 4);
}
// 474024: variables would overlap: ^2C.8 and ^2C.12
// 4BD0B0: using guessed type int dword_4BD0B0;

//----- (00474078) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl _handle_qnan2(double a1, double a2, int a3)
{
  __int16 v6; // cx
  double v7; // [esp+1Ch] [ebp-8h]

  v7 = *(double *)((char *)&a1 + 4) + *(double *)((char *)&a2 + 4);
  if ( !dword_4BD0B0 )
    return _umatherr(1, SLODWORD(a1), SHIDWORD(a1), SLODWORD(a2), SHIDWORD(a2), a3, v7);
  *sub_46D641() = 33;
  _ctrlfp(v6);
  return v7;
}
// 474078: variables would overlap: ^34.8 and ^34.12
// 474078: variables would overlap: ^40.8 and ^3C.8
// 474078: variables would overlap: ^3C.8 and ^40.8
// 474078: variables would overlap: ^40.8 and ^38.8
// 4BD0B0: using guessed type int dword_4BD0B0;

//----- (004740D8) --------------------------------------------------------
double __cdecl _except1(DWORD dwExceptionCode, int a2, int a3, int a4, double a5, int a6)
{
  __int16 v6; // fps
  int v10; // eax
  __int16 v12; // cx
  char v13[56]; // [esp+1Ch] [ebp-58h] BYREF
  int v14; // [esp+54h] [ebp-20h]

  if ( !_handle_exc(dwExceptionCode, &a5, a6) )
  {
    v14 &= 0xFFFFFFFE;
    _raise_exc(v6, (ULONG_PTR)v13, (int)&a6, dwExceptionCode, a2, (int)&a3, (int)&a5);
  }
  v10 = _errcode(dwExceptionCode);
  if ( !dword_4BD0B0 && v10 )
    return _umatherr(v10, a2, a3, a4, COERCE_UNSIGNED_INT64(0.0), HIDWORD(COERCE_UNSIGNED_INT64(0.0)), a5);
  _set_errno_from_matherr(v10);
  _ctrlfp(v12);
  return a5;
}
// 474164: variable 'v12' is possibly undefined
// 4BD0B0: using guessed type int dword_4BD0B0;

//----- (00474170) --------------------------------------------------------
int sub_474170()
{
  return sub_474173();
}
// 474173: using guessed type int sub_474173(void);

//----- (00474173) --------------------------------------------------------
double __usercall sub_474173@<st0>(int a1@<ebp>)
{
  int v1; // eax
  __int16 v2; // fps
  int v3; // eax
  __int16 v5; // cx
  int v6; // [esp+Ch] [ebp-68h]
  int v7; // [esp+10h] [ebp-64h]

  if ( !_handle_exc(*(_DWORD *)(a1 + 8), (double *)(a1 + 32), *(_DWORD *)(a1 + 40)) )
  {
    v1 = *(_DWORD *)(a1 - 32);
    LOBYTE(v1) = v1 & 0xE3 | 3;
    *(_DWORD *)(a1 - 32) = v1;
    v7 = *(_DWORD *)(a1 + 12);
    v6 = *(_DWORD *)(a1 + 8);
    *(double *)(a1 - 48) = *(double *)(a1 + 24);
    _raise_exc(v2, a1 - 88, a1 + 40, v6, v7, a1 + 16, a1 + 32);
  }
  v3 = _errcode(*(_DWORD *)(a1 + 8));
  if ( !dword_4BD0B0 && v3 )
    return _umatherr(
             v3,
             *(_DWORD *)(a1 + 12),
             COERCE_UNSIGNED_INT64(*(double *)(a1 + 16)),
             HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(a1 + 16))),
             COERCE_UNSIGNED_INT64(*(double *)(a1 + 24)),
             HIDWORD(COERCE_UNSIGNED_INT64(*(double *)(a1 + 24))),
             *(double *)(a1 + 32));
  _set_errno_from_matherr(v3);
  _ctrlfp(v5);
  return *(double *)(a1 + 32);
}
// 474209: variable 'v5' is possibly undefined
// 4BD0B0: using guessed type int dword_4BD0B0;

//----- (00474215) --------------------------------------------------------
ULONG_PTR __usercall _raise_exc@<eax>(__int16 a1@<fpstat>, ULONG_PTR Arguments, int a3, DWORD dwExceptionCode, int a5, int a6, int a7)
{
  char v7; // cl
  int v8; // esi
  char v9; // al
  int v10; // eax
  _DWORD *v11; // eax
  unsigned int v12; // ecx
  int v13; // eax
  _DWORD *v14; // eax
  unsigned int v15; // ecx
  double *v16; // edi
  __int16 v17; // fps
  ULONG_PTR result; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  unsigned int v25; // ecx

  *(_DWORD *)(Arguments + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  v7 = dwExceptionCode;
  if ( (dwExceptionCode & 0x10) != 0 )
  {
    dwExceptionCode = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  if ( (v7 & 2) != 0 )
  {
    dwExceptionCode = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( (v7 & 1) != 0 )
  {
    dwExceptionCode = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( (v7 & 4) != 0 )
  {
    dwExceptionCode = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( (v7 & 8) != 0 )
  {
    dwExceptionCode = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  v8 = a3;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFEF | (16 * ((*(_DWORD *)a3 & 1) == 0));
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFF7 | (2 * (~(unsigned __int8)*(_DWORD *)v8 & 4));
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFB | ((unsigned int)~*(_DWORD *)v8 >> 1) & 4;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFD | ((unsigned int)~*(_DWORD *)v8 >> 3) & 2;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFE | ((unsigned int)~*(_DWORD *)v8 >> 5) & 1;
  v9 = sub_47499B(a1);
  if ( (v9 & 1) != 0 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( (v9 & 4) != 0 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( (v9 & 8) != 0 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( (v9 & 0x10) != 0 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( (v9 & 0x20) != 0 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v10 = *(_DWORD *)v8 & 0xC00;
  switch ( v10 )
  {
    case 0:
      *(_DWORD *)Arguments &= 0xFFFFFFFC;
      break;
    case 1024:
      v11 = (_DWORD *)Arguments;
      v12 = *(_DWORD *)Arguments & 0xFFFFFFFD | 1;
      goto LABEL_28;
    case 2048:
      v11 = (_DWORD *)Arguments;
      v12 = *(_DWORD *)Arguments & 0xFFFFFFFE | 2;
LABEL_28:
      *v11 = v12;
      break;
    case 3072:
      *(_DWORD *)Arguments |= 3u;
      break;
  }
  v13 = *(_DWORD *)v8 & 0x300;
  switch ( v13 )
  {
    case 0:
      v14 = (_DWORD *)Arguments;
      v15 = *(_DWORD *)Arguments & 0xFFFFFFEB | 8;
      goto LABEL_36;
    case 512:
      v14 = (_DWORD *)Arguments;
      v15 = *(_DWORD *)Arguments & 0xFFFFFFE7 | 4;
LABEL_36:
      *v14 = v15;
      break;
    case 768:
      *(_DWORD *)Arguments &= 0xFFFFFFE3;
      break;
  }
  *(_DWORD *)Arguments = *(_DWORD *)Arguments & 0xFFFE001F | (32 * (a5 & 0xFFF));
  *(_DWORD *)(Arguments + 32) |= 1u;
  *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE3 | 2;
  *(double *)(Arguments + 16) = *(double *)a6;
  *(_DWORD *)(Arguments + 80) |= 1u;
  v16 = (double *)a7;
  *(_DWORD *)(Arguments + 80) = *(_DWORD *)(Arguments + 80) & 0xFFFFFFE3 | 2;
  *(double *)(Arguments + 64) = *v16;
  sub_4749A9(v17);
  dword_4A7298(dwExceptionCode, 0, 1, &Arguments);
  result = Arguments;
  if ( (*(_BYTE *)(Arguments + 8) & 0x10) != 0 )
    *(_DWORD *)v8 &= 0xFFFFFFFE;
  if ( (*(_BYTE *)(result + 8) & 8) != 0 )
    *(_DWORD *)v8 &= 0xFFFFFFFB;
  if ( (*(_BYTE *)(result + 8) & 4) != 0 )
    *(_DWORD *)v8 &= 0xFFFFFFF7;
  if ( (*(_BYTE *)(result + 8) & 2) != 0 )
    *(_DWORD *)v8 &= 0xFFFFFFEF;
  if ( (*(_BYTE *)(result + 8) & 1) != 0 )
    *(_DWORD *)v8 &= 0xFFFFFFDF;
  v19 = *(_DWORD *)result & 3;
  if ( !v19 )
  {
    *(_DWORD *)v8 &= 0xFFFFF3FF;
    goto LABEL_56;
  }
  v20 = v19 - 1;
  if ( !v20 )
  {
    v22 = *(_DWORD *)v8;
    BYTE1(v22) = BYTE1(*(_DWORD *)v8) & 0xF7 | 4;
    goto LABEL_54;
  }
  v21 = v20 - 1;
  if ( !v21 )
  {
    v22 = *(_DWORD *)v8;
    BYTE1(v22) = BYTE1(*(_DWORD *)v8) & 0xFB | 8;
LABEL_54:
    *(_DWORD *)v8 = v22;
    goto LABEL_56;
  }
  if ( v21 == 1 )
    *(_BYTE *)(v8 + 1) |= 0xCu;
LABEL_56:
  v23 = (*(_DWORD *)result >> 2) & 7;
  if ( !v23 )
  {
    v25 = *(_DWORD *)v8 & 0xFFFFF3FF;
    BYTE1(v25) |= 3u;
    goto LABEL_62;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
    v25 = *(_DWORD *)v8 & 0xFFFFF3FF;
    BYTE1(v25) |= 2u;
LABEL_62:
    *(_DWORD *)v8 = v25;
    goto LABEL_63;
  }
  if ( v24 == 1 )
    *(_DWORD *)v8 &= 0xFFFFF3FF;
LABEL_63:
  *v16 = *(double *)(result + 64);
  return result;
}
// 4A7298: using guessed type int (__stdcall *dword_4A7298)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004744C8) --------------------------------------------------------
BOOL __cdecl _handle_exc(char a1, double *a2, __int16 a3)
{
  int v3; // edi
  int v4; // ecx
  double *v5; // ecx
  double v7; // st7
  char v8; // c0
  char v9; // c3
  char v11; // c0
  char v12; // c3
  BOOL v13; // esi
  int v14; // ecx
  BOOL v15; // edx
  __int16 v16; // ax
  int v17; // eax
  double v19; // [esp+18h] [ebp-Ch]
  double v20; // [esp+18h] [ebp-Ch]
  int v21; // [esp+20h] [ebp-4h] BYREF

  v3 = a1 & 0x1F;
  if ( (a1 & 8) != 0 && (a3 & 1) != 0 )
  {
    _set_statfp();
    v3 = a1 & 0x17;
    goto LABEL_46;
  }
  if ( (a1 & 4) != 0 && (a3 & 4) != 0 )
  {
    _set_statfp();
    v3 = a1 & 0x1B;
    goto LABEL_46;
  }
  if ( (a1 & 1) != 0 && (a3 & 8) != 0 )
  {
    _set_statfp();
    v4 = a3 & 0xC00;
    if ( (a3 & 0xC00) != 0 )
    {
      switch ( v4 )
      {
        case 1024:
          v5 = a2;
          if ( *a2 <= dbl_4A91B8 )
            v7 = -dbl_4BC660;
          else
            v7 = dbl_4BC670;
          break;
        case 2048:
          v5 = a2;
          if ( *a2 <= dbl_4A91B8 )
            v7 = -dbl_4BC670;
          else
            v7 = dbl_4BC660;
          break;
        case 3072:
          v5 = a2;
          v7 = dbl_4BC670;
          if ( v8 != 0 || v9 != 0 )
            v7 = -dbl_4BC670;
          break;
        default:
LABEL_25:
          v3 = a1 & 0x1E;
          goto LABEL_46;
      }
    }
    else
    {
      v5 = a2;
      v7 = dbl_4BC660;
      if ( v11 != 0 || v12 != 0 )
        v7 = -dbl_4BC660;
    }
    *v5 = v7;
    goto LABEL_25;
  }
  if ( (a1 & 2) != 0 && (a3 & 0x10) != 0 )
  {
    v13 = (a1 & 0x10) != 0;
    v19 = *a2;
    if ( v19 == dbl_4A91B8 )
    {
      v13 = 1;
    }
    else
    {
      v20 = _decomp(v19, (int)&v21);
      v14 = v21 - 1536;
      if ( v21 - 1536 >= -1074 )
      {
        v15 = v20 < dbl_4A91B8;
        v16 = BYTE6(v20) & 0xF;
        LOBYTE(v16) = v16 | 0x10;
        HIWORD(v20) = v16;
        if ( v14 < -1021 )
        {
          v17 = -1021 - v14;
          do
          {
            if ( (LOBYTE(v20) & 1) != 0 && !v13 )
              v13 = 1;
            LODWORD(v20) >>= 1;
            if ( (BYTE4(v20) & 1) != 0 )
              BYTE3(v20) |= 0x80u;
            HIDWORD(v20) >>= 1;
            --v17;
          }
          while ( v17 );
        }
        if ( v15 )
          v20 = -v20;
      }
      else
      {
        v13 = 1;
        v20 = 0.0;
      }
      *a2 = v20;
    }
    if ( v13 )
      _set_statfp();
    v3 = a1 & 0x1D;
  }
LABEL_46:
  if ( (a1 & 0x10) != 0 && (a3 & 0x20) != 0 )
  {
    _set_statfp();
    v3 &= 0xFFFFFFEF;
  }
  return v3 == 0;
}
// 474562: variable 'v8' is possibly undefined
// 474562: variable 'v9' is possibly undefined
// 4745D2: variable 'v11' is possibly undefined
// 4745D2: variable 'v12' is possibly undefined
// 4A91B8: using guessed type double dbl_4A91B8;
// 4BC660: using guessed type double dbl_4BC660;
// 4BC670: using guessed type double dbl_4BC670;

//----- (004746DF) --------------------------------------------------------
double __cdecl _umatherr(int a1, int a2, int a3, int a4, int a5, int a6, double a7)
{
  double result; // st7
  __int16 v8; // [esp-4h] [ebp-24h]

  if ( _get_fname(a2) )
  {
    _ctrlfp(v8);
    if ( !sub_478C32() )
      _set_errno_from_matherr(a1);
    result = a7;
  }
  else
  {
    _ctrlfp(v8);
    _set_errno_from_matherr(a1);
    result = a7;
  }
  return result;
}
// 474728: variable 'v8' is possibly undefined

//----- (00474767) --------------------------------------------------------
void __cdecl _set_errno_from_matherr(int matherrtype)
{
  if ( matherrtype == 1 )
  {
    *sub_46D641() = 33;
  }
  else if ( matherrtype > 1 && matherrtype <= 3 )
  {
    *sub_46D641() = 34;
  }
}

//----- (0047478F) --------------------------------------------------------
char *__cdecl _get_fname(int a1)
{
  int v1; // ecx
  _DWORD *v2; // eax

  v1 = 0;
  v2 = &unk_4BC588;
  while ( *v2 != a1 )
  {
    v2 += 2;
    ++v1;
    if ( (int)v2 >= (int)&dbl_4BC660 )
      return 0;
  }
  return (&off_4BC58C)[2 * v1];
}
// 4BC58C: using guessed type char *off_4BC58C;
// 4BC660: using guessed type double dbl_4BC660;

//----- (004747B4) --------------------------------------------------------
int __cdecl _errcode(char a1)
{
  if ( (a1 & 0x20) != 0 )
    return 5;
  if ( (a1 & 8) != 0 )
    return 1;
  if ( (a1 & 4) != 0 )
    return 2;
  if ( (a1 & 1) != 0 )
    return 3;
  return 2 * (a1 & 2);
}

//----- (004747E1) --------------------------------------------------------
double __cdecl sub_4747E1(double a1)
{
  double result; // st7

  _ST7 = a1;
  __asm { frndint }
  return result;
}

//----- (004747F3) --------------------------------------------------------
double __cdecl _set_exp(double a1, int a2)
{
  double v3; // [esp+0h] [ebp-8h]

  v3 = a1;
  HIWORD(v3) = HIWORD(a1) & 0x800F | (16 * (a2 + 1022));
  return v3;
}

//----- (00474880) --------------------------------------------------------
int __cdecl _sptype(int a1, int a2)
{
  if ( a2 == 2146435072 )
  {
    if ( !a1 )
      return 1;
  }
  else if ( a2 == -1048576 && !a1 )
  {
    return 2;
  }
  if ( (HIWORD(a2) & 0x7FF8) == 32760 )
    return 3;
  if ( (HIWORD(a2) & 0x7FF8) == 32752 && ((a2 & 0x7FFFF) != 0 || a1) )
    return 4;
  return 0;
}

//----- (004748DA) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl _decomp(double a1, int a2)
{
  int v2; // esi
  BOOL v3; // eax
  double result; // st7
  double v5; // [esp+10h] [ebp-8h]

  if ( a1 == dbl_4A91B8 )
  {
    v2 = 0;
    v5 = 0.0;
  }
  else if ( (HIWORD(a1) & 0x7FF0) == 0 && ((HIDWORD(a1) & 0xFFFFF) != 0 || LODWORD(a1)) )
  {
    v2 = -1021;
    v3 = a1 < dbl_4A91B8;
    while ( (BYTE6(a1) & 0x10) == 0 )
    {
      HIDWORD(a1) *= 2;
      if ( (SBYTE3(a1) & 0x80u) != 0 )
        HIDWORD(a1) |= 1u;
      LODWORD(a1) *= 2;
      --v2;
    }
    HIWORD(a1) &= 0xFFEFu;
    if ( v3 )
      HIBYTE(a1) |= 0x80u;
    v5 = _set_exp(a1, 0);
  }
  else
  {
    v5 = _set_exp(a1, 0);
    v2 = ((*(_DWORD *)((char *)&a1 + 6) >> 4) & 0x7FF) - 1022;
  }
  result = v5;
  *(_DWORD *)a2 = v2;
  return result;
}
// 4748DA: variables would overlap: ^20.8 and ^20.10
// 4748DA: variables would overlap: ^2A.2 and ^28.4
// 4A91B8: using guessed type double dbl_4A91B8;

//----- (0047499B) --------------------------------------------------------
int __usercall sub_47499B@<eax>(__int16 a1@<fpstat>)
{
  return a1;
}

//----- (004749A9) --------------------------------------------------------
int __usercall sub_4749A9@<eax>(__int16 a1@<fpstat>)
{
  __asm { fnclex }
  return a1;
}

//----- (004749B8) --------------------------------------------------------
int __fastcall _ctrlfp(__int16 a1)
{
  return a1;
}

//----- (004749DB) --------------------------------------------------------
void _set_statfp()
{
  ;
}

//----- (00474A31) --------------------------------------------------------
int __tzset()
{
  int result; // eax

  if ( !dword_4C1CF0 )
  {
    _lock(11);
    if ( !dword_4C1CF0 )
    {
      _tzset_lk();
      ++dword_4C1CF0;
    }
    result = sub_46FA37(11);
  }
  return result;
}
// 4C1CF0: using guessed type int dword_4C1CF0;

//----- (00474A75) --------------------------------------------------------
char *_tzset_lk()
{
  char *v0; // eax
  const char *v1; // esi
  char *result; // eax
  int (__stdcall *v3)(_DWORD, int, wchar_t *, int, char *, int, _DWORD, int *); // esi
  size_t v4; // eax
  const char *v5; // esi
  int v6; // ecx
  char v7; // al
  int v8; // eax
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h] BYREF

  v9 = 0;
  _lock(12);
  dword_4BC748 = -1;
  dword_4BC738 = -1;
  dword_4C1C38 = 0;
  v0 = getenv_0(VarName);
  v1 = v0;
  if ( !v0 )
  {
    sub_46FA37(12);
    result = (char *)dword_4A712C(&dword_4C1C40);
    if ( result == (char *)-1 )
      return result;
    dword_4BC6A0 = 60 * dword_4C1C40;
    dword_4C1C38 = 1;
    if ( word_4C1C86 )
      dword_4BC6A0 = 60 * dword_4C1C94 + 60 * dword_4C1C40;
    if ( word_4C1CDA && dword_4C1CE8 )
    {
      dword_4BC6A4 = 1;
      dword_4BC6A8 = 60 * (dword_4C1CE8 - dword_4C1C94);
    }
    else
    {
      dword_4BC6A4 = 0;
      dword_4BC6A8 = 0;
    }
    v3 = (int (__stdcall *)(_DWORD, int, wchar_t *, int, char *, int, _DWORD, int *))dword_4A71B4;
    if ( !dword_4A71B4(dword_4C1C1C, 544, aEasternStandar, -1, off_4BC72C, 63, 0, &v10) || v10 )
      *off_4BC72C = 0;
    else
      off_4BC72C[63] = 0;
    if ( v3(dword_4C1C1C, 544, aEasternDayligh, -1, off_4BC730, 63, 0, &v10) && !v10 )
    {
      result = off_4BC730;
      off_4BC730[63] = 0;
      return result;
    }
LABEL_41:
    result = off_4BC730;
    *off_4BC730 = 0;
    return result;
  }
  if ( *v0 && (!dword_4C1CEC || strcmp(v0, dword_4C1CEC)) )
  {
    sub_46D360((unsigned int)dword_4C1CEC);
    v4 = strlen(v1);
    dword_4C1CEC = (char *)sub_46D9FD(v4 + 1);
    if ( dword_4C1CEC )
    {
      sub_476F50();
      sub_46FA37(12);
      strncpy(off_4BC72C, v1, 3u);
      v5 = v1 + 3;
      off_4BC72C[3] = 0;
      if ( *v5 == 45 )
      {
        v9 = 1;
        ++v5;
      }
      v6 = 3600 * atol_0(v5);
      dword_4BC6A0 = v6;
      while ( 1 )
      {
        v7 = *v5;
        if ( *v5 != 43 && (v7 < 48 || v7 > 57) )
          break;
        ++v5;
      }
      if ( *v5 == 58 )
      {
        v6 = 60 * atol_0(++v5) + dword_4BC6A0;
        dword_4BC6A0 = v6;
        while ( *v5 >= 48 && *v5 <= 57 )
          ++v5;
        if ( *v5 == 58 )
        {
          v6 = atol_0(++v5) + dword_4BC6A0;
          dword_4BC6A0 = v6;
          while ( *v5 >= 48 && *v5 <= 57 )
            ++v5;
        }
      }
      if ( v9 )
        dword_4BC6A0 = -v6;
      v8 = *v5;
      dword_4BC6A4 = v8;
      if ( v8 )
      {
        strncpy(off_4BC730, v5, 3u);
        result = off_4BC730;
        off_4BC730[3] = 0;
        return result;
      }
      goto LABEL_41;
    }
  }
  return (char *)sub_46FA37(12);
}
// 4A712C: using guessed type int (__stdcall *dword_4A712C)(_DWORD);
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BC6A0: using guessed type int dword_4BC6A0;
// 4BC6A4: using guessed type int dword_4BC6A4;
// 4BC6A8: using guessed type int dword_4BC6A8;
// 4BC738: using guessed type int dword_4BC738;
// 4BC748: using guessed type int dword_4BC748;
// 4C1C38: using guessed type int dword_4C1C38;
// 4C1C40: using guessed type int dword_4C1C40;
// 4C1C44: using guessed type wchar_t aEasternStandar[22];
// 4C1C86: using guessed type __int16 word_4C1C86;
// 4C1C94: using guessed type int dword_4C1C94;
// 4C1C98: using guessed type wchar_t aEasternDayligh[22];
// 4C1CDA: using guessed type __int16 word_4C1CDA;
// 4C1CE8: using guessed type int dword_4C1CE8;

//----- (00474CFC) --------------------------------------------------------
int __cdecl _isindst(_DWORD *a1)
{
  int v1; // esi

  _lock(11);
  v1 = _isindst_0(a1);
  sub_46FA37(11);
  return v1;
}

//----- (00474D1D) --------------------------------------------------------
int __cdecl _isindst_0(_DWORD *a1)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  BOOL v5; // ecx

  if ( !dword_4BC6A4 )
    return 0;
  v2 = a1[5];
  if ( v2 != dword_4BC738 || v2 != dword_4BC748 )
  {
    if ( dword_4C1C38 )
    {
      if ( word_4C1CD8 )
        cvtdate_0(
          1,
          0,
          v2,
          (unsigned __int16)word_4C1CDA,
          0,
          0,
          (unsigned __int16)word_4C1CDE,
          (unsigned __int16)word_4C1CE0,
          (unsigned __int16)word_4C1CE2,
          (unsigned __int16)word_4C1CE4,
          (unsigned __int16)word_4C1CE6);
      else
        cvtdate_0(
          1,
          1,
          v2,
          (unsigned __int16)word_4C1CDA,
          (unsigned __int16)word_4C1CDE,
          (unsigned __int16)word_4C1CDC,
          0,
          (unsigned __int16)word_4C1CE0,
          (unsigned __int16)word_4C1CE2,
          (unsigned __int16)word_4C1CE4,
          (unsigned __int16)word_4C1CE6);
      if ( word_4C1C84 )
        cvtdate_0(
          0,
          0,
          a1[5],
          (unsigned __int16)word_4C1C86,
          0,
          0,
          (unsigned __int16)word_4C1C8A,
          (unsigned __int16)word_4C1C8C,
          (unsigned __int16)word_4C1C8E,
          (unsigned __int16)word_4C1C90,
          (unsigned __int16)word_4C1C92);
      else
        cvtdate_0(
          0,
          1,
          a1[5],
          (unsigned __int16)word_4C1C86,
          (unsigned __int16)word_4C1C8A,
          (unsigned __int16)word_4C1C88,
          0,
          (unsigned __int16)word_4C1C8C,
          (unsigned __int16)word_4C1C8E,
          (unsigned __int16)word_4C1C90,
          (unsigned __int16)word_4C1C92);
    }
    else
    {
      cvtdate_0(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate_0(0, 1, a1[5], 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = a1[7];
  if ( dword_4BC73C < dword_4BC74C )
  {
    if ( v3 >= dword_4BC73C && v3 <= dword_4BC74C )
    {
      if ( v3 > dword_4BC73C && v3 < dword_4BC74C )
        return 1;
      goto LABEL_24;
    }
    return 0;
  }
  if ( v3 < dword_4BC74C || v3 > dword_4BC73C )
    return 1;
  if ( v3 > dword_4BC74C && v3 < dword_4BC73C )
    return 0;
LABEL_24:
  v4 = 1000 * (*a1 + 60 * (a1[1] + 60 * a1[2]));
  if ( v3 == dword_4BC73C )
    v5 = v4 >= dword_4BC740;
  else
    v5 = v4 < dword_4BC750;
  return v5;
}
// 4BC6A4: using guessed type int dword_4BC6A4;
// 4BC738: using guessed type int dword_4BC738;
// 4BC73C: using guessed type int dword_4BC73C;
// 4BC740: using guessed type int dword_4BC740;
// 4BC748: using guessed type int dword_4BC748;
// 4BC74C: using guessed type int dword_4BC74C;
// 4BC750: using guessed type int dword_4BC750;
// 4C1C38: using guessed type int dword_4C1C38;
// 4C1C84: using guessed type __int16 word_4C1C84;
// 4C1C86: using guessed type __int16 word_4C1C86;
// 4C1C88: using guessed type __int16 word_4C1C88;
// 4C1C8A: using guessed type __int16 word_4C1C8A;
// 4C1C8C: using guessed type __int16 word_4C1C8C;
// 4C1C8E: using guessed type __int16 word_4C1C8E;
// 4C1C90: using guessed type __int16 word_4C1C90;
// 4C1C92: using guessed type __int16 word_4C1C92;
// 4C1CD8: using guessed type __int16 word_4C1CD8;
// 4C1CDA: using guessed type __int16 word_4C1CDA;
// 4C1CDC: using guessed type __int16 word_4C1CDC;
// 4C1CDE: using guessed type __int16 word_4C1CDE;
// 4C1CE0: using guessed type __int16 word_4C1CE0;
// 4C1CE2: using guessed type __int16 word_4C1CE2;
// 4C1CE4: using guessed type __int16 word_4C1CE4;
// 4C1CE6: using guessed type __int16 word_4C1CE6;

//----- (00474EC9) --------------------------------------------------------
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int result; // eax
  int v19; // eax
  bool v20; // sf
  int v21; // ecx
  int v22; // [esp+18h] [ebp+10h]

  if ( a2 == 1 )
  {
    v22 = a3 & 3;
    if ( (a3 & 3) != 0 )
      v12 = dword_4BD078[a4];
    else
      v12 = dword_4BD044[a4];
    v13 = v12 + 1;
    v14 = (365 * a3 + ((a3 - 1) >> 2) + v12 + 1 - 25563) % 7;
    if ( v14 > a6 )
      v15 = a6 + 7 * a5 - v14 + v13;
    else
      v15 = v13 + a6 + 7 * a5 - v14 - 7;
    if ( a5 == 5 )
    {
      if ( v22 )
        v16 = dword_4BD07C[a4];
      else
        v16 = dword_4BD048[a4];
      if ( v15 > v16 )
        v15 -= 7;
    }
  }
  else
  {
    if ( (a3 & 3) != 0 )
      v17 = dword_4BD078[a4];
    else
      v17 = dword_4BD044[a4];
    v15 = a7 + v17;
  }
  if ( a1 == 1 )
  {
    dword_4BC73C = v15;
    dword_4BC738 = a3;
    result = a11 + 1000 * (a10 + 60 * (a9 + 60 * a8));
    dword_4BC740 = result;
    return result;
  }
  dword_4BC74C = v15;
  v19 = 1000 * (a10 + dword_4BC6A8 + 60 * (a9 + 60 * a8));
  v20 = a11 + v19 < 0;
  result = a11 + v19;
  dword_4BC750 = result;
  if ( v20 )
  {
    result += 86400000;
    v21 = v15 - 1;
    dword_4BC750 = result;
LABEL_24:
    dword_4BC74C = v21;
    goto LABEL_25;
  }
  if ( result >= 86400000 )
  {
    result -= 86400000;
    v21 = v15 + 1;
    dword_4BC750 = result;
    goto LABEL_24;
  }
LABEL_25:
  dword_4BC748 = a3;
  return result;
}
// 4BC6A8: using guessed type int dword_4BC6A8;
// 4BC738: using guessed type int dword_4BC738;
// 4BC73C: using guessed type int dword_4BC73C;
// 4BC740: using guessed type int dword_4BC740;
// 4BC748: using guessed type int dword_4BC748;
// 4BC74C: using guessed type int dword_4BC74C;
// 4BC750: using guessed type int dword_4BC750;
// 4BD044: using guessed type int dword_4BD044[];
// 4BD078: using guessed type int dword_4BD078[];

//----- (00475009) --------------------------------------------------------
struct tm *__cdecl gmtime(const __time32_t *const Time)
{
  __time32_t v1; // esi
  int v2; // ebx
  int *v3; // eax
  int *v4; // edi
  int v6; // eax
  struct tm *v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // edx
  int *v11; // edi
  int v12; // esi
  int v13; // eax
  int *i; // ebx
  int v15; // edx
  int v16; // eax
  int v17; // esi

  v1 = *Time;
  v2 = 0;
  v3 = _getptd();
  v4 = v3;
  if ( v1 < 0 )
    return 0;
  if ( v3[16] || (v6 = sub_46D9FD(0x24u), v4[16] = v6, v7 = (struct tm *)&unk_4C1CF8, v6) )
    v7 = (struct tm *)v4[16];
  v8 = v1 / 126230400;
  v9 = v1 % 126230400;
  v10 = 4 * v8 + 70;
  if ( v9 >= 31536000 )
  {
    v9 -= 31536000;
    v10 = 4 * v8 + 71;
    if ( v9 >= 31536000 )
    {
      v9 -= 31536000;
      v10 = 4 * v8 + 72;
      if ( v9 < 31622400 )
      {
        v2 = 1;
      }
      else
      {
        v10 = 4 * v8 + 73;
        v9 -= 31622400;
      }
    }
  }
  v7->tm_year = v10;
  v11 = dword_4BD048;
  v7->tm_yday = v9 / 86400;
  v12 = v9 % 86400;
  if ( !v2 )
    v11 = dword_4BD07C;
  v13 = 1;
  for ( i = v11 + 1; *i < v7->tm_yday; ++i )
    ++v13;
  v15 = v7->tm_yday;
  v16 = v13 - 1;
  v7->tm_mon = v16;
  v7->tm_mday = v15 - v11[v16];
  v7->tm_wday = (*Time / 86400 + 4) % 7;
  v7->tm_hour = v12 / 3600;
  v17 = v12 % 3600;
  v7->tm_min = v17 / 60;
  v7->tm_isdst = 0;
  v7->tm_sec = v17 % 60;
  return v7;
}

//----- (00475113) --------------------------------------------------------
int __cdecl _XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int *v2; // esi
  int *v3; // eax
  void (__cdecl *v4)(int); // ebx
  int result; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // [esp+8h] [ebp-4h]

  v2 = _getptd();
  v3 = xcptlookup(a1, (_DWORD *)v2[20]);
  if ( !v3 )
    return dword_4A71A0(ExceptionInfo);
  v4 = (void (__cdecl *)(int))v3[2];
  if ( !v4 )
    return dword_4A71A0(ExceptionInfo);
  if ( v4 == (void (__cdecl *)(int))5 )
  {
    v3[2] = 0;
    result = 1;
  }
  else
  {
    if ( v4 != (void (__cdecl *)(int))1 )
    {
      v11 = v2[21];
      v2[21] = (int)ExceptionInfo;
      v6 = v3[1];
      if ( v6 == 8 )
      {
        v7 = dword_4BC7D0;
        if ( dword_4BC7D0 < dword_4BC7D0 + dword_4BC7D4 )
        {
          v8 = 12 * dword_4BC7D0;
          do
          {
            v8 += 12;
            *(_DWORD *)(v8 + v2[20] - 4) = 0;
            ++v7;
          }
          while ( v7 < dword_4BC7D0 + dword_4BC7D4 );
        }
        v9 = *v3;
        v10 = v2[22];
        switch ( v9 )
        {
          case -1073741682:
            v2[22] = 131;
            break;
          case -1073741680:
            v2[22] = 129;
            break;
          case -1073741679:
            v2[22] = 132;
            break;
          case -1073741677:
            v2[22] = 133;
            break;
          case -1073741683:
            v2[22] = 130;
            break;
          case -1073741681:
            v2[22] = 134;
            break;
          case -1073741678:
            v2[22] = 138;
            break;
        }
        v4(8);
        v2[22] = v10;
      }
      else
      {
        v3[2] = 0;
        v4(v6);
      }
      v2[21] = v11;
    }
    result = -1;
  }
  return result;
}
// 4A71A0: using guessed type int (__stdcall *dword_4A71A0)(_DWORD);
// 4BC7D0: using guessed type int dword_4BC7D0;
// 4BC7D4: using guessed type int dword_4BC7D4;

//----- (00475251) --------------------------------------------------------
_DWORD *__cdecl xcptlookup(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != a1 )
  {
    do
      result += 3;
    while ( result < &a2[3 * dword_4BC7DC] && *result != a1 );
  }
  if ( result >= &a2[3 * dword_4BC7DC] || *result != a1 )
    result = 0;
  return result;
}
// 4BC7DC: using guessed type int dword_4BC7DC;

//----- (0047528B) --------------------------------------------------------
_BYTE *_wincmdln()
{
  _BYTE *v0; // esi
  unsigned __int8 v1; // al

  if ( !dword_4C3280 )
    sub_4791C9();
  v0 = (_BYTE *)dword_4C3278;
  if ( *(_BYTE *)dword_4C3278 != 34 )
  {
    if ( *(_BYTE *)dword_4C3278 > 0x20u )
    {
      do
        ++v0;
      while ( *v0 > 0x20u );
    }
    goto LABEL_12;
  }
  while ( 1 )
  {
    v1 = *++v0;
    if ( v1 == 34 || !v1 )
      break;
    if ( sub_478D67(v1) )
      ++v0;
  }
  if ( *v0 != 34 )
    goto LABEL_12;
  do
  {
    ++v0;
LABEL_12:
    ;
  }
  while ( *v0 && *v0 <= 0x20u );
  return v0;
}
// 4C3278: using guessed type int dword_4C3278;
// 4C3280: using guessed type int dword_4C3280;

//----- (004752E3) --------------------------------------------------------
void _setenvp_0()
{
  char *v0; // esi
  int v1; // edi
  int *v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  int v6; // eax

  if ( !dword_4C3280 )
    sub_4791C9();
  v0 = dword_4C1B78;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = (int *)sub_46D9FD(4 * v1 + 4);
  dword_4C1B38 = (int)v2;
  if ( !v2 )
    _amsg_exit(9u);
  for ( i = dword_4C1B78; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = sub_46D9FD(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit(9u);
      sub_476F50();
      ++v2;
    }
  }
  sub_46D360((unsigned int)dword_4C1B78);
  dword_4C1B78 = 0;
  *v2 = 0;
  dword_4C327C = 1;
}
// 4C1B38: using guessed type int dword_4C1B38;
// 4C327C: using guessed type int dword_4C327C;
// 4C3280: using guessed type int dword_4C3280;

//----- (0047539C) --------------------------------------------------------
int _setargv_0()
{
  unsigned __int8 *v0; // edi
  unsigned __int8 **v1; // esi
  int result; // eax
  int v3; // [esp+Ch] [ebp-8h] BYREF
  int v4; // [esp+10h] [ebp-4h] BYREF

  if ( !dword_4C3280 )
    sub_4791C9();
  dword_4A7100(0, aFGamesContinuu, 260);
  off_4C1B48 = aFGamesContinuu;
  v0 = (unsigned __int8 *)aFGamesContinuu;
  if ( *(_BYTE *)dword_4C3278 )
    v0 = (unsigned __int8 *)dword_4C3278;
  parse_cmdline_0(v0, 0, 0, &v4, &v3);
  v1 = (unsigned __int8 **)sub_46D9FD(v3 + 4 * v4);
  if ( !v1 )
    _amsg_exit(8u);
  parse_cmdline_0(v0, v1, (unsigned __int8 *)&v1[v4], &v4, &v3);
  result = v4 - 1;
  dword_4C1B30 = (int)v1;
  dword_4C1B2C = v4 - 1;
  return result;
}
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4C1B2C: using guessed type int dword_4C1B2C;
// 4C1B30: using guessed type int dword_4C1B30;
// 4C1B48: using guessed type char *off_4C1B48;
// 4C3278: using guessed type int dword_4C3278;
// 4C3280: using guessed type int dword_4C3280;

//----- (00475435) --------------------------------------------------------
_DWORD *__cdecl parse_cmdline_0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  _DWORD *result; // eax
  int v17; // [esp+14h] [ebp+8h]
  BOOL v18; // [esp+24h] [ebp+18h]

  *a5 = 0;
  v6 = a3;
  v7 = a2;
  *a4 = 1;
  v8 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v7 = ++a2;
  }
  if ( *a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_4C2001[v9] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_4C2001[v10] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = v7;
    }
    ++*a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_4C2001[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_4C2001[v15] & 4) != 0 )
        {
          ++v8;
          ++*a5;
        }
        ++*a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*a4;
  return result;
}
// 4754DE: conditional instruction was optimized away because of 'dl.1 in (==9|==20)'

//----- (004755E9) --------------------------------------------------------
void *__crtGetEnvironmentStringsA_0()
{
  int (*v0)(void); // ebp
  unsigned int v1; // ebx
  int v2; // esi
  _BYTE *v3; // edi
  _WORD *i; // eax
  int (__stdcall *v5)(_DWORD, _DWORD, int, int, int, size_t, _DWORD, _DWORD); // edi
  size_t v6; // eax
  size_t v7; // ebp
  int v8; // eax
  _BYTE *j; // eax
  size_t v11; // ebp
  void *v12; // eax
  void *v13; // esi
  unsigned int v14; // [esp+40h] [ebp-8h]
  int v15; // [esp+44h] [ebp-4h]

  v0 = dword_4A7190;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  if ( dword_4C1E20 )
  {
    if ( dword_4C1E20 == 1 )
      goto LABEL_7;
    if ( dword_4C1E20 != 2 )
      return 0;
  }
  else
  {
    v2 = dword_4A7190();
    if ( v2 )
    {
      dword_4C1E20 = 1;
LABEL_7:
      if ( v2 || (v2 = v0()) != 0 )
      {
        for ( i = (_WORD *)v2; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        v5 = dword_4A71B4;
        v15 = (((int)i - v2) >> 1) + 1;
        v6 = dword_4A71B4(0, 0, v2, v15, 0, 0, 0, 0);
        v7 = v6;
        if ( v6 )
        {
          v8 = sub_46D9FD(v6);
          v14 = v8;
          if ( v8 )
          {
            if ( !v5(0, 0, v2, v15, v8, v7, 0, 0) )
            {
              sub_46D360(v14);
              v14 = 0;
            }
            v1 = v14;
          }
        }
        dword_4A7198(v2);
        return (void *)v1;
      }
      return 0;
    }
    v3 = (_BYTE *)dword_4A7194();
    if ( !v3 )
      return 0;
    dword_4C1E20 = 2;
  }
  if ( !v3 )
  {
    v3 = (_BYTE *)dword_4A7194();
    if ( !v3 )
      return 0;
  }
  for ( j = v3; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v11 = j - v3 + 1;
  v12 = (void *)sub_46D9FD(v11);
  v13 = v12;
  if ( v12 )
    memcpy_0(v12, v3, v11);
  else
    v13 = 0;
  dword_4A719C(v3);
  return v13;
}
// 4A7190: using guessed type int (*dword_4A7190)(void);
// 4A7194: using guessed type int (*dword_4A7194)(void);
// 4A7198: using guessed type int (__stdcall *dword_4A7198)(_DWORD);
// 4A719C: using guessed type int (__stdcall *dword_4A719C)(_DWORD);
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1E20: using guessed type int dword_4C1E20;

//----- (0047571B) --------------------------------------------------------
// #API: GetStartupInfoA(), GetFileType(), GetStdHandle(), LockResource()
// #API: GetStartupInfoA(), GetFileType(), GetStdHandle(), LockResource()
int _ioinit()
{
  unsigned int v0; // esi
  unsigned int i; // eax
  int v2; // edi
  _BYTE *v3; // ebx
  unsigned int *v4; // esi
  unsigned int v5; // eax
  unsigned int j; // ecx
  int k; // esi
  int v8; // eax
  int l; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int *v16; // [esp-4h] [ebp-58h]
  int v17; // [esp+0h] [ebp-54h]
  int v18; // [esp+4h] [ebp-50h]
  int v19; // [esp+8h] [ebp-4Ch]
  int v20; // [esp+Ch] [ebp-48h] BYREF
  __int16 v21; // [esp+3Eh] [ebp-16h]
  _DWORD *v22; // [esp+40h] [ebp-14h]
  _DWORD *v23; // [esp+50h] [ebp-4h]

  v0 = sub_46D9FD(0x480u);
  if ( !v0 )
    _amsg_exit(0x1Bu);
  dword_4C2120[0] = v0;
  dword_4C2220 = 32;
  for ( i = v0 + 1152; v0 < i; i = dword_4C2120[0] + 1152 )
  {
    *(_BYTE *)(v0 + 4) = 0;
    *(_DWORD *)v0 = -1;
    *(_DWORD *)(v0 + 8) = 0;
    *(_BYTE *)(v0 + 5) = 10;
    v0 += 36;
  }
  v16 = &v20;
  dword_4A71F0();
  if ( v21 && v22 )
  {
    v2 = *v22;
    v3 = v22 + 1;
    v23 = (_DWORD *)((char *)v22 + *v22 + 4);
    if ( v2 >= 2048 )
      v2 = 2048;
    if ( dword_4C2220 < v2 )
    {
      v4 = (unsigned int *)&unk_4C2124;
      while ( 1 )
      {
        v5 = sub_46D9FD(0x480u);
        if ( !v5 )
          break;
        dword_4C2220 += 32;
        *v4 = v5;
        for ( j = v5 + 1152; v5 < j; j = *v4 + 1152 )
        {
          *(_BYTE *)(v5 + 4) = 0;
          *(_DWORD *)v5 = -1;
          *(_DWORD *)(v5 + 8) = 0;
          *(_BYTE *)(v5 + 5) = 10;
          v5 += 36;
        }
        ++v4;
        if ( dword_4C2220 >= v2 )
          goto LABEL_19;
      }
      v2 = dword_4C2220;
    }
LABEL_19:
    for ( k = 0; k < v2; ++v3 )
    {
      if ( *v23 != -1 && (*v3 & 1) != 0 && ((*v3 & 8) != 0 || dword_4A7184(*v23)) )
      {
        v8 = dword_4C2120[k >> 5] + 36 * (k & 0x1F);
        *(_DWORD *)v8 = *v23;
        *(_BYTE *)(v8 + 4) = *v3;
      }
      ++v23;
      ++k;
    }
  }
  for ( l = 0; l < 3; ++l )
  {
    v10 = dword_4C2120[0] + 36 * l;
    if ( *(_DWORD *)v10 == -1 )
    {
      *(_BYTE *)(v10 + 4) = -127;
      if ( l )
        v11 = -(l != 1) - 11;
      else
        v11 = -10;
      v12 = dword_4A7188(v11, v16, v17, v18, v19);
      v13 = v12;
      if ( v12 == -1 || (v14 = dword_4A7184(v12)) == 0 || (*(_DWORD *)v10 = v13, (unsigned __int8)v14 == 2) )
      {
        *(_BYTE *)(v10 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)v14 == 3 )
      {
        *(_BYTE *)(v10 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v10 + 4) |= 0x80u;
    }
  }
  return dword_4A718C(dword_4C2220);
}
// 475887: variable 'v16' is possibly undefined
// 475887: variable 'v17' is possibly undefined
// 475887: variable 'v18' is possibly undefined
// 475887: variable 'v19' is possibly undefined
// 4A7184: using guessed type int (__stdcall *dword_4A7184)(_DWORD);
// 4A7188: using guessed type int (__stdcall *dword_4A7188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A718C: using guessed type int (__cdecl *dword_4A718C)(_DWORD);
// 4A71F0: using guessed type int (*dword_4A71F0)(void);
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (0047592B) --------------------------------------------------------
int *_FF_MSGBANNER_0()
{
  int *result; // eax

  result = (int *)dword_4C1B80;
  if ( dword_4C1B80 == 1 || !dword_4C1B80 && dword_4B9E64 == 1 )
  {
    _NMSG_WRITE_0(0xFCu);
    if ( dword_4C1E24 )
      dword_4C1E24();
    result = _NMSG_WRITE_0(0xFFu);
  }
  return result;
}
// 4B9E64: using guessed type int dword_4B9E64;
// 4C1B80: using guessed type int dword_4C1B80;
// 4C1E24: using guessed type int (*dword_4C1E24)(void);

//----- (00475964) --------------------------------------------------------
int *__cdecl _NMSG_WRITE_0(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  size_t v6; // eax
  int v7; // eax
  char *v8; // [esp-10h] [ebp-1B4h]
  char *v9; // [esp-Ch] [ebp-1B0h]
  char *v10; // [esp-8h] [ebp-1ACh]
  char Str[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = dword_4BC808;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_4BC898 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_4BC808[2 * v1] )
  {
    result = (int *)dword_4C1B80;
    if ( dword_4C1B80 == 1 || !dword_4C1B80 && dword_4B9E64 == 1 )
    {
      v5 = (const char **)&(&off_4BC80C)[v3];
      v10 = 0;
      v9 = (char *)&NumberOfBytesWritten;
      v6 = strlen(*v5);
      v7 = dword_4A7188(-12, *v5, v6, &NumberOfBytesWritten, 0);
      result = (int *)dword_4A728C(v7);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !dword_4A7100(0, Str, 260) )
      {
        v10 = aProgramNameUnk;
        v9 = Str;
        sub_476F50();
      }
      v4 = Str;
      if ( strlen(Str) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Str) - 479;
        strncpy(v4, asc_4AFA44, 3u);
      }
      v9 = aRuntimeErrorPr;
      v8 = Destination;
      sub_476F50();
      strcat(Destination, v4);
      strcat(Destination, asc_4AFA24);
      strcat(Destination, (&off_4BC80C)[v3]);
      result = (int *)__crtMessageBoxA_0((int)Destination, (int)aMicrosoftVisua, 73744);
    }
  }
  return result;
}
// 4A7188: invalid function type has been ignored
// 4A728C: invalid function type has been ignored
// 4A7100: using guessed type int (__stdcall *dword_4A7100)(_DWORD, _DWORD, _DWORD);
// 4A7188: using guessed type int (__stdcall *dword_4A7188)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int (__stdcall *dword_4A728C)(_DWORD);
// 4B9E64: using guessed type int dword_4B9E64;
// 4BC808: using guessed type int dword_4BC808[];
// 4BC80C: using guessed type char *off_4BC80C;
// 4C1B80: using guessed type int dword_4C1B80;

//----- (00475AE8) --------------------------------------------------------
int __cdecl _close(int FileHandle)
{
  int v1; // edi
  int result; // eax

  if ( FileHandle < (unsigned int)dword_4C2220
    && (*(_BYTE *)(dword_4C2120[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    v1 = _close_lk(FileHandle);
    _unlock_fhandle(FileHandle);
    result = v1;
  }
  else
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (00475B45) --------------------------------------------------------
#error "475B89: call analysis failed (funcsize=52)"

//----- (00475BC8) --------------------------------------------------------
void __cdecl _freebuf_0(_iobuf *stream)
{
  int v1; // eax

  v1 = stream->_flag;
  if ( (v1 & 0x83) != 0 && (v1 & 8) != 0 )
  {
    sub_46D360((unsigned int)stream->_base);
    LOWORD(stream->_flag) &= 0xFBF7u;
    stream->_ptr = 0;
    stream->_base = 0;
    stream->_cnt = 0;
  }
}

//----- (00475BF3) --------------------------------------------------------
_DWORD *__cdecl _openfile(char *FileName, _BYTE *a2, int ShareFlag, _DWORD *a4)
{
  _BYTE *v4; // edi
  char v5; // al
  int v6; // ecx
  unsigned int v7; // esi
  int v8; // edx
  char v9; // al
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  _DWORD *result; // eax
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]

  v4 = a2;
  v18 = 0;
  v19 = 0;
  v5 = *a2;
  if ( *a2 == 97 )
  {
    v6 = 265;
LABEL_7:
    v7 = dword_4C1EA0 | 2;
    goto LABEL_8;
  }
  if ( v5 != 114 )
  {
    if ( v5 != 119 )
      return 0;
    v6 = 769;
    goto LABEL_7;
  }
  v6 = 0;
  v7 = dword_4C1EA0 | 1;
LABEL_8:
  v8 = 1;
  while ( 1 )
  {
    v9 = *++v4;
    if ( !v9 || !v8 )
      break;
    if ( v9 > 84 )
    {
      v13 = v9 - 98;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( v14 )
        {
          v15 = v14 - 11;
          if ( v15 )
          {
            if ( v15 != 6 || (v6 & 0xC000) != 0 )
LABEL_38:
              v8 = 0;
            else
              BYTE1(v6) |= 0x40u;
          }
          else
          {
            if ( v18 )
              goto LABEL_38;
            v18 = 1;
            v7 &= 0xFFFFBFFF;
          }
        }
        else
        {
          if ( v18 )
            goto LABEL_38;
          v18 = 1;
          v7 |= 0x4000u;
        }
      }
      else
      {
        if ( (v6 & 0xC000) != 0 )
          goto LABEL_38;
        BYTE1(v6) |= 0x80u;
      }
    }
    else if ( v9 == 84 )
    {
      if ( (v6 & 0x1000) != 0 )
        goto LABEL_38;
      v6 |= 0x1000u;
    }
    else
    {
      v10 = v9 - 43;
      if ( v10 )
      {
        v11 = v10 - 25;
        if ( v11 )
        {
          v12 = v11 - 14;
          if ( v12 )
          {
            if ( v12 != 1 || v19 )
              goto LABEL_38;
            v19 = 1;
            v6 |= 0x20u;
          }
          else
          {
            if ( v19 )
              goto LABEL_38;
            v19 = 1;
            v6 |= 0x10u;
          }
        }
        else
        {
          if ( (v6 & 0x40) != 0 )
            goto LABEL_38;
          v6 |= 0x40u;
        }
      }
      else
      {
        if ( (v6 & 2) != 0 )
          goto LABEL_38;
        v6 = v6 & 0xFFFFFFFE | 2;
        v7 = v7 & 0xFFFFFFFC | 0x80;
      }
    }
  }
  v16 = _sopen(FileName, v6, ShareFlag, 420);
  if ( v16 < 0 )
    return 0;
  result = a4;
  ++dword_4C1C28;
  a4[3] = v7;
  a4[1] = 0;
  *a4 = 0;
  a4[2] = 0;
  a4[7] = 0;
  a4[4] = v16;
  return result;
}
// 4C1C28: using guessed type int dword_4C1C28;
// 4C1EA0: using guessed type int dword_4C1EA0;

//----- (00475D63) --------------------------------------------------------
_DWORD *_getstream()
{
  _DWORD *v0; // edi
  int v1; // esi
  int v2; // eax
  int v3; // esi
  int v4; // eax

  v0 = 0;
  _lock(2);
  v1 = 0;
  if ( dword_4C3240 > 0 )
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(dword_4C2224 + 4 * v1);
      if ( !v2 )
        break;
      if ( (*(_BYTE *)(v2 + 12) & 0x83) == 0 )
      {
        _lock_file2(v1, *(_DWORD *)(dword_4C2224 + 4 * v1));
        if ( (*(_BYTE *)(*(_DWORD *)(dword_4C2224 + 4 * v1) + 12) & 0x83) == 0 )
        {
          v0 = *(_DWORD **)(dword_4C2224 + 4 * v1);
          goto LABEL_11;
        }
        sub_473E88(v1, *(_DWORD *)(dword_4C2224 + 4 * v1));
      }
      if ( ++v1 >= dword_4C3240 )
        goto LABEL_13;
    }
    v3 = 4 * v1;
    *(_DWORD *)(v3 + dword_4C2224) = sub_46D9FD(0x38u);
    v4 = *(_DWORD *)(v3 + dword_4C2224);
    if ( !v4 )
      goto LABEL_13;
    dword_4A71EC(v4 + 32);
    dword_4A71E4(*(_DWORD *)(v3 + dword_4C2224) + 32);
    v0 = *(_DWORD **)(v3 + dword_4C2224);
LABEL_11:
    if ( v0 )
    {
      v0[4] = -1;
      v0[1] = 0;
      v0[3] = 0;
      v0[2] = 0;
      *v0 = 0;
      v0[7] = 0;
    }
  }
LABEL_13:
  sub_46FA37(2);
  return v0;
}
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);
// 4A71EC: using guessed type int (__stdcall *dword_4A71EC)(_DWORD);
// 4C2224: using guessed type int dword_4C2224;
// 4C3240: using guessed type int dword_4C3240;

//----- (00475E2B) --------------------------------------------------------
int __cdecl _filbuf(FILE *File)
{
  int v1; // eax
  int v2; // eax
  int v3; // edx
  _BYTE *v4; // edi
  int v5; // ecx
  char *v6; // ecx
  int result; // eax

  v1 = File->_flag;
  if ( (v1 & 0x83) == 0 || (v1 & 0x40) != 0 )
    return -1;
  if ( (v1 & 2) != 0 )
  {
    LOBYTE(v1) = v1 | 0x20;
    File->_flag = v1;
    return -1;
  }
  LOBYTE(v1) = v1 | 1;
  File->_flag = v1;
  if ( (v1 & 0x10C) != 0 )
    File->_ptr = File->_base;
  else
    _getbuf_0(File);
  v2 = _write(File->_file, File->_base, File->_bufsiz);
  File->_cnt = v2;
  if ( !v2 || v2 == -1 )
  {
    File->_flag |= v2 != 0 ? 32 : 16;
    File->_cnt = 0;
    return -1;
  }
  v3 = File->_flag;
  if ( (v3 & 0x82) == 0 )
  {
    v4 = File->_file == -1 ? &unk_4BC7E0 : dword_4C2120[File->_file >> 5] + 36 * (File->_file & 0x1F);
    if ( (v4[4] & 0x82) == 0x82 )
    {
      BYTE1(v3) |= 0x20u;
      File->_flag = v3;
    }
  }
  if ( File->_bufsiz == 512 )
  {
    v5 = File->_flag;
    if ( (v5 & 8) != 0 && (v5 & 0x400) == 0 )
      File->_bufsiz = 4096;
  }
  v6 = File->_ptr;
  File->_cnt = v2 - 1;
  result = (unsigned __int8)*v6;
  File->_ptr = v6 + 1;
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];

//----- (00475F07) --------------------------------------------------------
int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount)
{
  int v3; // edi
  int result; // eax

  if ( FileHandle < (unsigned int)dword_4C2220
    && (*(_BYTE *)(dword_4C2120[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(FileHandle);
    v3 = _read_lk(FileHandle, (LPVOID)Buf, MaxCharCount);
    _unlock_fhandle(FileHandle);
    result = v3;
  }
  else
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (00475F6C) --------------------------------------------------------
unsigned int __cdecl _read_lk(int a1, LPVOID lpBuffer, DWORD nNumberOfBytesToRead)
{
  char *v3; // ebx
  char *v4; // edx
  int v5; // esi
  int v6; // eax
  char v7; // cl
  char v8; // al
  int v9; // eax
  unsigned int v10; // eax
  int v12; // eax
  char *v13; // ecx
  char v14; // al
  char v15; // al
  char *v16; // ecx
  bool v17; // cf
  char v18; // al
  char v19; // al
  _BYTE *v20; // esi
  int v21; // [esp+0h] [ebp-18h]
  int v22; // [esp+4h] [ebp-14h]
  int v23; // [esp+8h] [ebp-10h]
  int v24; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v25; // [esp+10h] [ebp-8h]
  int var1; // [esp+17h] [ebp-1h] BYREF
  char *v27; // [esp+28h] [ebp+10h]

  v25 = 0;
  v3 = (char *)lpBuffer;
  v4 = (char *)lpBuffer;
  if ( nNumberOfBytesToRead )
  {
    v5 = 36 * (a1 & 0x1F);
    v6 = v5 + dword_4C2120[a1 >> 5];
    v7 = *(_BYTE *)(v6 + 4);
    if ( (v7 & 2) == 0 )
    {
      if ( (v7 & 0x48) != 0 )
      {
        v8 = *(_BYTE *)(v6 + 5);
        if ( v8 != 10 )
        {
          --nNumberOfBytesToRead;
          *(_BYTE *)lpBuffer = v8;
          v9 = dword_4C2120[a1 >> 5];
          v4 = (char *)lpBuffer + 1;
          v25 = 1;
          *(_BYTE *)(v9 + v5 + 5) = 10;
        }
      }
      if ( !dword_4A7258(*(_DWORD *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F)), v4, nNumberOfBytesToRead, &v24, 0) )
      {
        v10 = ((int (__cdecl *)())dword_4A7260)();
        if ( v10 == 5 )
        {
          *sub_46D641() = 9;
          *sub_46D64A() = 5;
          return -1;
        }
        if ( v10 != 109 )
        {
          _dosmaperr(v10);
          return -1;
        }
        return 0;
      }
      v12 = dword_4C2120[a1 >> 5];
      v25 += v24;
      v13 = (char *)(v12 + v5 + 4);
      v14 = *v13;
      if ( *v13 < 0 )
      {
        if ( v24 && *(_BYTE *)lpBuffer == 10 )
          v15 = v14 | 4;
        else
          v15 = v14 & 0xFB;
        *v13 = v15;
        v27 = (char *)lpBuffer;
        v16 = (char *)lpBuffer + v25;
        v17 = lpBuffer < (char *)lpBuffer + v25;
        v25 += (unsigned int)lpBuffer;
        if ( v17 )
        {
          do
          {
            v18 = *v27;
            if ( *v27 == 26 )
            {
              v20 = (_BYTE *)(dword_4C2120[a1 >> 5] + v5 + 4);
              if ( (*v20 & 0x40) == 0 )
                *v20 |= 2u;
              break;
            }
            if ( v18 == 13 )
            {
              if ( v27 >= v16 - 1 )
              {
                ++v27;
                if ( !dword_4A7258(*(_DWORD *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F)), &var1, 1, &v24, 0)
                  && dword_4A7260(v21, v22, v23, v24)
                  || !v24 )
                {
LABEL_35:
                  *v3 = 13;
                  goto LABEL_36;
                }
                if ( (*(_BYTE *)(dword_4C2120[a1 >> 5] + v5 + 4) & 0x48) != 0 )
                {
                  v19 = var1;
                  if ( (_BYTE)var1 == 10 )
                    goto LABEL_33;
                  *v3++ = 13;
                  *(_BYTE *)(dword_4C2120[a1 >> 5] + v5 + 5) = v19;
                }
                else
                {
                  if ( v3 == lpBuffer && (_BYTE)var1 == 10 )
                    goto LABEL_33;
                  _lseek_lk(a1, -1, 1u);
                  if ( (_BYTE)var1 != 10 )
                    goto LABEL_35;
                }
              }
              else
              {
                if ( v27[1] == 10 )
                {
                  v27 += 2;
LABEL_33:
                  *v3 = 10;
LABEL_36:
                  ++v3;
                  goto LABEL_37;
                }
                *v3++ = 13;
                ++v27;
              }
            }
            else
            {
              *v3++ = v18;
              ++v27;
            }
LABEL_37:
            v16 = (char *)v25;
          }
          while ( (unsigned int)v27 < v25 );
        }
        v25 = v3 - (_BYTE *)lpBuffer;
      }
      return v25;
    }
  }
  return 0;
}
// 4760C0: variable 'v21' is possibly undefined
// 4760C0: variable 'v22' is possibly undefined
// 4760C0: variable 'v23' is possibly undefined
// 4A7258: using guessed type int (__stdcall *dword_4A7258)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C2120: using guessed type int dword_4C2120[];

//----- (00476145) --------------------------------------------------------
int __cdecl sub_476145(int a1, const void *a2, DWORD a3)
{
  int v3; // edi
  int result; // eax

  if ( a1 < (unsigned int)dword_4C2220 && (*(_BYTE *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(a1);
    v3 = _write_lk(a1, a2, a3);
    _unlock_fhandle(a1);
    result = v3;
  }
  else
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (004761AA) --------------------------------------------------------
int __cdecl _write_lk(int FileHandle, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  _DWORD *v4; // ebx
  int v5; // esi
  int v6; // eax
  char *v7; // eax
  char *v8; // ecx
  char v9; // cl
  int v10; // edi
  int v11; // [esp-Ch] [ebp-42Ch]
  char v12[1028]; // [esp+Ch] [ebp-414h] BYREF
  int v13; // [esp+410h] [ebp-10h]
  int v14; // [esp+414h] [ebp-Ch] BYREF
  int v15; // [esp+418h] [ebp-8h]
  char *v16; // [esp+41Ch] [ebp-4h]
  int FileHandlea; // [esp+428h] [ebp+8h]

  v15 = 0;
  v13 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  v4 = (_DWORD *)(4 * (FileHandle >> 5) + 4989216);
  v5 = 36 * (FileHandle & 0x1F);
  if ( (*(_BYTE *)(dword_4C2120[FileHandle >> 5] + v5 + 4) & 0x20) != 0 )
    _lseek_lk(FileHandle, 0, 2u);
  v6 = v5 + dword_4C2120[FileHandle >> 5];
  if ( *(char *)(v6 + 4) >= 0 )
  {
    if ( dword_4A728C(*(_DWORD *)v6) )
    {
      FileHandlea = 0;
      v15 = v14;
    }
    else
    {
      FileHandlea = dword_4A7260(lpBuffer, nNumberOfBytesToWrite, &v14, 0);
    }
  }
  else
  {
    v16 = (char *)lpBuffer;
    FileHandlea = 0;
    while ( 1 )
    {
      v7 = v12;
      do
      {
        if ( v16 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
          break;
        v8 = v16++;
        v9 = *v8;
        if ( v9 == 10 )
        {
          ++v13;
          *v7++ = 13;
        }
        *v7++ = v9;
      }
      while ( v7 - v12 < 1024 );
      v10 = v7 - v12;
      v11 = v7 - v12;
      if ( !dword_4A728C(*(_DWORD *)(*v4 + v5)) )
        break;
      v15 += v14;
      if ( v14 < v10 || v16 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
        goto LABEL_15;
    }
    FileHandlea = dword_4A7260(v12, v11, &v14, 0);
  }
LABEL_15:
  if ( v15 )
    return v15 - v13;
  if ( FileHandlea )
  {
    if ( FileHandlea == 5 )
    {
      *sub_46D641() = 9;
      *sub_46D64A() = 5;
    }
    else
    {
      _dosmaperr(FileHandlea);
    }
  }
  else
  {
    if ( (*(_BYTE *)(*v4 + v5 + 4) & 0x40) != 0 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *sub_46D641() = 28;
    *sub_46D64A() = 0;
  }
  return -1;
}
// 476214: conditional instruction was optimized away because of '%arg_8.4!=0'
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A728C: using guessed type int (__stdcall *dword_4A728C)(_DWORD);
// 4C2120: using guessed type int dword_4C2120[];

//----- (00476335) --------------------------------------------------------
int __cdecl sub_476335(int a1, LONG a2, DWORD a3)
{
  int v3; // edi
  int result; // eax

  if ( a1 < (unsigned int)dword_4C2220 && (*(_BYTE *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F) + 4) & 1) != 0 )
  {
    _lock_fhandle(a1);
    v3 = _lseek_lk(a1, a2, a3);
    _unlock_fhandle(a1);
    result = v3;
  }
  else
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (0047639A) --------------------------------------------------------
int __cdecl _lseek_lk(int FileHandle, LONG lDistanceToMove, DWORD dwMoveMethod)
{
  intptr_t v3; // eax
  int v4; // edi
  unsigned int v5; // eax
  int v7; // [esp+0h] [ebp-8h]
  int v8; // [esp+4h] [ebp-4h]

  v3 = _get_osfhandle(FileHandle);
  if ( v3 == -1 )
  {
    *sub_46D641() = 9;
    return -1;
  }
  v4 = dword_4A7288(v3, lDistanceToMove, 0, dwMoveMethod, v7, v8);
  if ( v4 == -1 )
    v5 = dword_4A7260();
  else
    v5 = 0;
  if ( v5 )
  {
    _dosmaperr(v5);
    return -1;
  }
  *(_BYTE *)(dword_4C2120[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) &= 0xFDu;
  return v4;
}
// 4763C4: variable 'v7' is possibly undefined
// 4763C4: variable 'v8' is possibly undefined
// 4A7260: using guessed type int (*dword_4A7260)(void);
// 4A7288: using guessed type int (__stdcall *dword_4A7288)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C2120: using guessed type int dword_4C2120[];

//----- (0047640D) --------------------------------------------------------
#error "47645E: call analysis failed (funcsize=52)"

//----- (004764A0) --------------------------------------------------------
_DWORD *__cdecl sub_4764A0(int a1, unsigned __int16 *a2, int a3, _DWORD *a4)
{
  _WORD *v4; // edx
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // esi
  int v8; // edi
  unsigned __int16 v9; // ax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  _DWORD *result; // eax
  int v18; // [esp+8h] [ebp-8h]
  int v19; // [esp+Ch] [ebp-4h]

  v4 = a2;
  v5 = *a2;
  v18 = 0;
  v19 = 0;
  if ( v5 == 97 )
  {
    v6 = 265;
LABEL_7:
    v7 = dword_4C1EA0 | 2;
    goto LABEL_8;
  }
  if ( v5 != 114 )
  {
    if ( v5 != 119 )
      return 0;
    v6 = 769;
    goto LABEL_7;
  }
  v6 = 0;
  v7 = dword_4C1EA0 | 1;
LABEL_8:
  v8 = 1;
  while ( 1 )
  {
    v9 = *++v4;
    if ( !*v4 || !v8 )
      break;
    if ( v9 > 0x54u )
    {
      v13 = v9 - 98;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( v14 )
        {
          v15 = v14 - 11;
          if ( v15 )
          {
            if ( v15 != 6 || (v6 & 0xC000) != 0 )
LABEL_38:
              v8 = 0;
            else
              BYTE1(v6) |= 0x40u;
          }
          else
          {
            if ( v18 )
              goto LABEL_38;
            v18 = 1;
            v7 &= 0xFFFFBFFF;
          }
        }
        else
        {
          if ( v18 )
            goto LABEL_38;
          v18 = 1;
          v7 |= 0x4000u;
        }
      }
      else
      {
        if ( (v6 & 0xC000) != 0 )
          goto LABEL_38;
        BYTE1(v6) |= 0x80u;
      }
    }
    else if ( v9 == 84 )
    {
      if ( (v6 & 0x1000) != 0 )
        goto LABEL_38;
      v6 |= 0x1000u;
    }
    else
    {
      v10 = v9 - 43;
      if ( v10 )
      {
        v11 = v10 - 25;
        if ( v11 )
        {
          v12 = v11 - 14;
          if ( v12 )
          {
            if ( v12 != 1 || v19 )
              goto LABEL_38;
            v19 = 1;
            v6 |= 0x20u;
          }
          else
          {
            if ( v19 )
              goto LABEL_38;
            v19 = 1;
            v6 |= 0x10u;
          }
        }
        else
        {
          if ( (v6 & 0x40) != 0 )
            goto LABEL_38;
          v6 |= 0x40u;
        }
      }
      else
      {
        if ( (v6 & 2) != 0 )
          goto LABEL_38;
        v6 = v6 & 0xFFFFFFFE | 2;
        v7 = v7 & 0xFFFFFFFC | 0x80;
      }
    }
  }
  v16 = sub_4798F3(a1, v6, a3, 164);
  if ( v16 < 0 )
    return 0;
  result = a4;
  ++dword_4C1C28;
  a4[3] = v7;
  a4[1] = 0;
  *a4 = 0;
  a4[2] = 0;
  a4[7] = 0;
  a4[4] = v16;
  return result;
}
// 4C1C28: using guessed type int dword_4C1C28;
// 4C1EA0: using guessed type int dword_4C1EA0;

//----- (00476616) --------------------------------------------------------
int __stdcall sub_476616(int a1)
{
  return 1;
}

//----- (00476680) --------------------------------------------------------
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  size_t v3; // edx
  int v4; // eax
  _BYTE *v5; // edi
  int v6; // ecx
  size_t v7; // ecx
  unsigned int v8; // ecx

  v3 = Size;
  if ( !Size )
    return a1;
  LOBYTE(v4) = Val;
  v5 = a1;
  if ( Size < 4 )
    goto LABEL_13;
  v6 = -(int)a1 & 3;
  if ( v6 )
  {
    v3 = Size - v6;
    do
    {
      *v5++ = Val;
      --v6;
    }
    while ( v6 );
  }
  v4 = 16843009 * (unsigned __int8)Val;
  v7 = v3;
  v3 &= 3u;
  v8 = v7 >> 2;
  if ( !v8 || (memset32(v5, v4, v8), v5 += 4 * v8, v3) )
  {
LABEL_13:
    do
    {
      *v5++ = v4;
      --v3;
    }
    while ( v3 );
  }
  return a1;
}

//----- (004766D8) --------------------------------------------------------
BOOL __cdecl sub_4766D8(int a1, int a2)
{
  return dword_4A7280(a1, a2) == 0;
}
// 4A7280: using guessed type int (__stdcall *dword_4A7280)(_DWORD, _DWORD);

//----- (004766F4) --------------------------------------------------------
BOOL __cdecl sub_4766F4(int a1, int a2)
{
  return dword_4A71B8(a1, a2) == 0;
}
// 4A71B8: using guessed type int (__stdcall *dword_4A71B8)(_DWORD, _DWORD);

//----- (00476710) --------------------------------------------------------
BOOL __cdecl sub_476710(int a1)
{
  return dword_4A7180(a1) == 0;
}
// 4A7180: using guessed type int (__stdcall *dword_4A7180)(_DWORD);

//----- (00476766) --------------------------------------------------------
unsigned int __cdecl _control87_0(unsigned int NewValue, unsigned int Mask)
{
  int v2; // eax
  unsigned int v3; // esi
  char v5; // [esp+4h] [ebp-4h]

  LOBYTE(v2) = _abstract_cw_0(v5);
  v3 = Mask & NewValue | ~Mask & v2;
  _hw_cw_0(v3);
  return v3;
}
// 476772: variable 'v5' is possibly undefined
// 47677E: variable 'v2' is possibly undefined

//----- (0047679B) --------------------------------------------------------
unsigned int __cdecl sub_47679B(unsigned int NewValue, int a2)
{
  return _control87_0(NewValue, a2 & 0xFFF7FFFF);
}

//----- (004767DC) --------------------------------------------------------
char __cdecl _abstract_cw_0(char a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    result |= 1u;
  return result;
}

//----- (0047686E) --------------------------------------------------------
char __cdecl _hw_cw_0(int a1)
{
  char result; // al

  result = (a1 & 0x10) != 0;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 2) != 0 )
    result |= 0x10u;
  if ( (a1 & 1) != 0 )
    result |= 0x20u;
  if ( (a1 & 0x80000) != 0 )
    result |= 2u;
  return result;
}

//----- (004768F7) --------------------------------------------------------
char __cdecl _abstract_sw(char a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    result |= 1u;
  return result;
}

//----- (0047692C) --------------------------------------------------------
int __cdecl _ZeroTail_0(int a1, int a2)
{
  int v2; // esi
  _DWORD *i; // eax

  if ( (~(-1 << (31 - a2 % 32)) & *(_DWORD *)(a1 + 4 * (a2 / 32))) == 0 )
  {
    v2 = a2 / 32 + 1;
    if ( v2 >= 3 )
      return 1;
    for ( i = (_DWORD *)(a1 + 4 * v2); !*i; ++i )
    {
      if ( ++v2 >= 3 )
        return 1;
    }
  }
  return 0;
}

//----- (00476975) --------------------------------------------------------
int __cdecl _IncMan_0(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  unsigned int *v4; // edi

  result = __addl_0(*(_DWORD *)(a1 + 4 * (a2 / 32)), 1 << (31 - a2 % 32), (unsigned int *)(a1 + 4 * (a2 / 32)));
  v3 = a2 / 32 - 1;
  if ( v3 >= 0 )
  {
    v4 = (unsigned int *)(a1 + 4 * v3);
    do
    {
      if ( !result )
        break;
      result = __addl_0(*v4, 1u, v4);
      --v3;
      --v4;
    }
    while ( v3 >= 0 );
  }
  return result;
}

//----- (004769CB) --------------------------------------------------------
int __cdecl _RoundMan_0(int a1, int a2)
{
  int v2; // edi
  int v4; // edx
  _DWORD *v5; // eax
  char v6; // si
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]
  _DWORD *v10; // [esp+20h] [ebp+Ch]

  v2 = a2 - 1;
  v9 = 0;
  v4 = a2 % 32;
  v8 = a2 / 32;
  v5 = (_DWORD *)(a1 + 4 * (a2 / 32));
  v10 = v5;
  v6 = 31 - v4;
  if ( ((1 << (31 - v4)) & *v5) != 0 )
  {
    if ( !_ZeroTail_0(a1, a2 + 1) )
      v9 = _IncMan_0(a1, v2);
    v5 = v10;
  }
  *v5 &= -1 << v6;
  if ( v8 + 1 < 3 )
    memset((void *)(a1 + 4 * (v8 + 1)), 0, 4 * (3 - (v8 + 1)));
  return v9;
}

//----- (00476A57) --------------------------------------------------------
_DWORD *__cdecl sub_476A57(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = a2;
  v3 = 3;
  do
  {
    *(_DWORD *)((char *)result + a1 - (_DWORD)a2) = *result;
    ++result;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (00476A72) --------------------------------------------------------
int __cdecl sub_476A72(_DWORD *a1)
{
  int result; // eax

  result = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}

//----- (00476A7E) --------------------------------------------------------
int __cdecl sub_476A7E(_DWORD *a1)
{
  int v2; // ecx

  v2 = 0;
  while ( !*a1 )
  {
    ++v2;
    ++a1;
    if ( v2 >= 3 )
      return 1;
  }
  return 0;
}

//----- (00476A99) --------------------------------------------------------
int *__cdecl _ShrMan(int *a1, int a2)
{
  int *v2; // edi
  int v3; // edx
  bool v4; // zf
  int v5; // ebx
  int i; // ecx
  int *result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+24h] [ebp+Ch]

  v2 = a1;
  v10 = 3;
  v8 = a2 / 32;
  v3 = a2 % 32;
  v11 = 0;
  do
  {
    v9 = ~(-1 << v3) & *v2;
    *v2 = v11 | ((unsigned int)*v2 >> v3);
    ++v2;
    v4 = v10-- == 1;
    v11 = v9 << (32 - v3);
  }
  while ( !v4 );
  v5 = 2;
  for ( i = 2; i >= 0; --i )
  {
    if ( v5 < v8 )
    {
      result = a1;
      a1[i] = 0;
    }
    else
    {
      result = *(int **)((char *)a1 + i * 4 - 4 * v8);
      a1[i] = (int)result;
    }
    --v5;
  }
  return result;
}

//----- (00476B26) --------------------------------------------------------
int __cdecl _ld12cvt(unsigned __int16 *a1, _DWORD *a2, int *a3)
{
  unsigned __int16 v4; // bx
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int result; // eax
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // edi
  unsigned int v14; // esi
  int v15; // edx
  int v16; // [esp-8h] [ebp-2Ch]
  int v17; // [esp-4h] [ebp-28h]
  int v18; // [esp-4h] [ebp-28h]
  _DWORD v19[3]; // [esp+Ch] [ebp-18h] BYREF
  int v20; // [esp+18h] [ebp-Ch] BYREF
  int v21; // [esp+1Ch] [ebp-8h]
  int v22; // [esp+20h] [ebp-4h]
  int v23; // [esp+2Ch] [ebp+8h]

  v4 = a1[5];
  v23 = v4 & 0x8000;
  v20 = *(_DWORD *)(a1 + 3);
  v5 = *(_DWORD *)(a1 + 1);
  v6 = *a1;
  v7 = (v4 & 0x7FFF) - 0x3FFF;
  v21 = v5;
  v22 = v6 << 16;
  if ( v7 != -16383 )
  {
    sub_476A57((int)v19, &v20);
    if ( _RoundMan_0((int)&v20, a3[2]) )
      ++v7;
    v10 = a3[1];
    if ( v7 >= v10 - a3[2] )
    {
      if ( v7 > v10 )
      {
        if ( v7 >= *a3 )
        {
          sub_476A72(&v20);
          v16 = a3[3];
          HIBYTE(v20) |= 0x80u;
          _ShrMan(&v20, v16);
          v8 = *a3 + a3[5];
          v17 = 1;
          goto LABEL_5;
        }
        v18 = a3[3];
        v12 = a3[5];
        HIBYTE(v20) &= 0x7Fu;
        v8 = v7 + v12;
        _ShrMan(&v20, v18);
        goto LABEL_16;
      }
      v11 = v10 - v7;
      sub_476A57((int)&v20, v19);
      _ShrMan(&v20, v11);
      _RoundMan_0((int)&v20, a3[2]);
      _ShrMan(&v20, a3[3] + 1);
    }
    else
    {
      sub_476A72(&v20);
    }
    v8 = 0;
    goto LABEL_4;
  }
  v8 = 0;
  if ( !sub_476A7E(&v20) )
  {
    sub_476A72(&v20);
LABEL_4:
    v17 = 2;
LABEL_5:
    result = v17;
    goto LABEL_17;
  }
LABEL_16:
  result = 0;
LABEL_17:
  v13 = a3[4];
  v14 = v20 | (v23 != 0 ? 0x80000000 : 0) | (v8 << (31 - *((_BYTE *)a3 + 12)));
  if ( v13 == 64 )
  {
    v15 = v21;
    a2[1] = v14;
    *a2 = v15;
  }
  else if ( v13 == 32 )
  {
    *a2 = v14;
  }
  return result;
}

//----- (00476C92) --------------------------------------------------------
int __cdecl sub_476C92(unsigned __int16 *a1, _DWORD *a2)
{
  return _ld12cvt(a1, a2, dword_4BC8A0);
}

//----- (00476CA8) --------------------------------------------------------
int __cdecl sub_476CA8(unsigned __int16 *a1, _DWORD *a2)
{
  return _ld12cvt(a1, a2, dword_4BC8B8);
}

//----- (00476CBE) --------------------------------------------------------
int __cdecl _ld12told(unsigned __int16 *a1, int a2)
{
  unsigned __int16 v2; // si
  __int16 v3; // di
  int v4; // ecx
  __int16 v5; // si
  unsigned int v6; // ecx
  int v7; // ecx
  unsigned int v9; // [esp+8h] [ebp-10h] BYREF
  int v10; // [esp+Ch] [ebp-Ch]
  int v11; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  v12 = 0;
  v2 = a1[5];
  v3 = v2 & 0x8000;
  v9 = *(_DWORD *)(a1 + 3);
  v4 = *(_DWORD *)(a1 + 1);
  v11 = *a1 << 16;
  v5 = v2 & 0x7FFF;
  v10 = v4;
  if ( _RoundMan_0((int)&v9, 64) )
  {
    v6 = 0x80000000;
    ++v5;
  }
  else
  {
    v6 = v9;
  }
  if ( v5 == 0x7FFF )
    v12 = 1;
  *(_DWORD *)(a2 + 4) = v6;
  v7 = v10;
  *(_WORD *)(a2 + 8) = v5 | v3;
  *(_DWORD *)a2 = v7;
  return v12;
}

//----- (00476D38) --------------------------------------------------------
int __cdecl sub_476D38(_DWORD *a1, char *a2)
{
  unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12_0((int)v3, &a2, a2, 0, 0, 0, 0);
  return sub_476C92(v3, a1);
}

//----- (00476D93) --------------------------------------------------------
int __cdecl sub_476D93(_DWORD *a1, char *a2)
{
  unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12_0((int)v3, &a2, a2, 0, 0, 0, 0);
  return sub_476CA8(v3, a1);
}

//----- (00476DC0) --------------------------------------------------------
char *__cdecl _fptostr(void *Dst, int a2, int a3)
{
  int v3; // edx
  int v4; // ebx
  char *v6; // ecx
  char *v7; // edi
  char *result; // eax
  char v9; // dl
  size_t v10; // eax
  int v11; // [esp+14h] [ebp+8h]

  v3 = a3;
  v4 = a2;
  v6 = *(char **)(a3 + 12);
  v7 = (char *)Dst + 1;
  *(_BYTE *)Dst = 48;
  result = (char *)Dst + 1;
  if ( a2 > 0 )
  {
    v11 = a2;
    v4 = 0;
    do
    {
      v9 = *v6;
      if ( *v6 )
        ++v6;
      else
        v9 = 48;
      *result++ = v9;
      --v11;
    }
    while ( v11 );
    v3 = a3;
  }
  *result = 0;
  if ( v4 >= 0 && *v6 >= 53 )
  {
    while ( *--result == 57 )
      *result = 48;
    ++*result;
  }
  if ( *(_BYTE *)Dst == 49 )
  {
    ++*(_DWORD *)(v3 + 4);
  }
  else
  {
    v10 = strlen(v7);
    result = (char *)sub_46CAB0((unsigned int)Dst, v7, v10 + 1);
  }
  return result;
}

//----- (00476E37) --------------------------------------------------------
_DWORD *__cdecl _fltout2(int a1, int a2, int a3, char *Dest)
{
  int v4; // eax
  _DWORD *v5; // esi
  char *v6; // edi
  int v8; // [esp-10h] [ebp-40h]
  __int16 v9; // [esp+8h] [ebp-28h] BYREF
  char v10; // [esp+Ah] [ebp-26h]
  __int64 v11; // [esp+24h] [ebp-Ch] BYREF
  __int16 v12; // [esp+2Ch] [ebp-4h]

  __dtold((unsigned int)&v11, (int)&v11, &a1);
  LOWORD(v8) = v12;
  v4 = _I10_OUTPUT_0(v11, v8, 17, 0, (int)&v9);
  v5 = (_DWORD *)a3;
  v6 = Dest;
  *(_DWORD *)(a3 + 8) = v4;
  *v5 = v10;
  v5[1] = v9;
  sub_476F50();
  v5[3] = v6;
  return v5;
}
// 476E62: variable 'v8' is possibly undefined

//----- (00476E93) --------------------------------------------------------
int __usercall __dtold@<eax>(unsigned int a1@<eax>, int a2, int *a3)
{
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  __int16 v8; // di
  int result; // eax
  int v10; // ecx
  int v11; // ecx
  unsigned __int64 v12; // rcx
  unsigned int v13; // [esp+Ch] [ebp-4h]
  __int16 v14; // [esp+1Ch] [ebp+Ch]

  LOWORD(a1) = *((_WORD *)a3 + 3);
  v4 = (a1 >> 4) & 0x7FF;
  v14 = a1 & 0x8000;
  v5 = a3[1];
  v6 = *a3;
  v7 = v5 & 0xFFFFF;
  v13 = 0x80000000;
  if ( (_WORD)v4 )
  {
    if ( (unsigned __int16)v4 == 2047 )
      v8 = 0x7FFF;
    else
      v8 = v4 + 15360;
  }
  else
  {
    if ( !v7 && !v6 )
    {
      result = a2;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)a2 = 0;
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    v8 = v4 + 15361;
    v13 = 0;
  }
  v10 = (v7 << 11) | (v6 >> 21);
  result = a2;
  v11 = v13 | v10;
  *(_DWORD *)(a2 + 4) = v11;
  *(_DWORD *)a2 = v6 << 11;
  while ( (v11 & 0x80000000) == 0 )
  {
    v12 = 2 * __PAIR64__(v11, *(_DWORD *)a2);
    *(_QWORD *)a2 = v12;
    --v8;
    v11 = HIDWORD(v12);
  }
  *(_WORD *)(a2 + 8) = v8 | v14;
  return result;
}

//----- (00476F50) --------------------------------------------------------
void sub_476F50()
{
  JUMPOUT(0x476FC1);
}
// 476F55: control flows out of bounds to 476FC1

//----- (00476F60) --------------------------------------------------------
char *__cdecl strcat(char *Destination, const char *Source)
{
  char *v2; // ecx
  int v4; // eax
  int v5; // eax
  char *v6; // edi
  const char *v7; // ecx
  int v8; // edx
  int v9; // eax
  char *result; // eax

  v2 = Destination;
  if ( ((unsigned __int8)Destination & 3) == 0 )
    goto LABEL_4;
  do
  {
    if ( !*v2++ )
    {
LABEL_9:
      v6 = v2 - 1;
      goto LABEL_13;
    }
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v4 = (*(_DWORD *)v2 + 2130640639) ^ ~*(_DWORD *)v2;
      v2 += 4;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *((_DWORD *)v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
    {
      v6 = v2 - 3;
      goto LABEL_13;
    }
    if ( (v5 & 0xFF0000) == 0 )
    {
      v6 = v2 - 2;
      goto LABEL_13;
    }
    if ( (v5 & 0xFF000000) == 0 )
      goto LABEL_9;
  }
  v6 = v2 - 4;
LABEL_13:
  v7 = Source;
  if ( ((unsigned __int8)Source & 3) == 0 )
    goto LABEL_18;
  while ( 1 )
  {
    LOBYTE(v8) = *v7++;
    if ( !(_BYTE)v8 )
      break;
    *v6++ = v8;
    if ( ((unsigned __int8)v7 & 3) == 0 )
    {
      while ( 1 )
      {
LABEL_18:
        v9 = (*(_DWORD *)v7 + 2130640639) ^ ~*(_DWORD *)v7;
        v8 = *(_DWORD *)v7;
        v7 += 4;
        if ( (v9 & 0x81010100) != 0 )
        {
          if ( !(_BYTE)v8 )
            goto LABEL_26;
          if ( !BYTE1(v8) )
          {
            *(_WORD *)v6 = (unsigned __int8)v8;
            return Destination;
          }
          if ( (v8 & 0xFF0000) == 0 )
          {
            *(_WORD *)v6 = v8;
            result = Destination;
            v6[2] = 0;
            return result;
          }
          if ( (v8 & 0xFF000000) == 0 )
          {
            *(_DWORD *)v6 = v8;
            return Destination;
          }
        }
        *(_DWORD *)v6 = v8;
        v6 += 4;
      }
    }
  }
LABEL_26:
  *v6 = v8;
  return Destination;
}

//----- (00477040) --------------------------------------------------------
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx
  int v3; // eax
  int v4; // eax

  v1 = Str;
  if ( ((unsigned __int8)Str & 3) == 0 )
    goto LABEL_4;
  do
  {
    if ( !*v1++ )
      return v1 - 1 - Str;
  }
  while ( ((unsigned __int8)v1 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( (v3 & 0x81010100) == 0 );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( (v4 & 0xFF0000) == 0 )
      return v1 - 2 - Str;
    if ( (v4 & 0xFF000000) == 0 )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}

//----- (004770C4) --------------------------------------------------------
unsigned int __cdecl sub_4770C4(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return strtoxl(a1, a2, a3, 0);
}

//----- (004770DB) --------------------------------------------------------
unsigned int __cdecl strtoxl(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  unsigned __int8 v4; // bl
  unsigned __int8 *i; // esi
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned int v12; // [esp+Ch] [ebp-Ch]
  unsigned int v13; // [esp+10h] [ebp-8h]
  unsigned __int8 *v14; // [esp+14h] [ebp-4h]
  unsigned __int8 *v15; // [esp+14h] [ebp-4h]

  v13 = 0;
  v4 = *a1;
  for ( i = a1 + 1; (int)dword_4BC19C <= 1 ? off_4BBF90[0][v4] & 8 : _isctype_0(v4, 8); ++i )
    v4 = *i;
  v14 = i;
  if ( v4 == 45 )
  {
    a4 |= 2u;
LABEL_10:
    v4 = *i++;
    v14 = i;
    goto LABEL_11;
  }
  if ( v4 == 43 )
    goto LABEL_10;
LABEL_11:
  if ( a3 >= 0 && a3 != 1 && a3 <= 36 )
  {
    if ( !a3 )
    {
      if ( v4 != 48 )
      {
        a3 = 10;
LABEL_26:
        v12 = 0xFFFFFFFF / a3;
        while ( 1 )
        {
          if ( (int)dword_4BC19C <= 1 )
            v7 = off_4BBF90[0][v4] & 4;
          else
            v7 = _isctype_0(v4, 4);
          if ( v7 )
          {
            v8 = (char)v4 - 48;
          }
          else
          {
            if ( (int)dword_4BC19C <= 1 )
              v9 = off_4BBF90[0][v4] & 0x103;
            else
              v9 = _isctype_0(v4, 259);
            if ( !v9 )
            {
LABEL_44:
              v15 = v14 - 1;
              if ( (a4 & 8) != 0 )
              {
                if ( (a4 & 4) != 0
                  || (a4 & 1) == 0 && ((a4 & 2) != 0 && v13 > 0x80000000 || (a4 & 2) == 0 && v13 > 0x7FFFFFFF) )
                {
                  *sub_46D641() = 34;
                  if ( (a4 & 1) != 0 )
                    v13 = -1;
                  else
                    v13 = ((a4 & 2) != 0) + 0x7FFFFFFF;
                }
              }
              else
              {
                if ( a2 )
                  v15 = a1;
                v13 = 0;
              }
              if ( a2 )
                *a2 = v15;
              if ( (a4 & 2) != 0 )
                v13 = -v13;
              return v13;
            }
            v8 = toupper((char)v4) - 55;
          }
          if ( v8 >= a3 )
            goto LABEL_44;
          a4 |= 8u;
          if ( v13 < v12 || v13 == v12 && v8 <= 0xFFFFFFFF % a3 )
            v13 = v8 + a3 * v13;
          else
            a4 |= 4u;
          v10 = v14++;
          v4 = *v10;
        }
      }
      if ( *i != 120 && *i != 88 )
      {
        a3 = 8;
        goto LABEL_26;
      }
      a3 = 16;
    }
    if ( a3 == 16 && v4 == 48 && (*i == 120 || *i == 88) )
    {
      v4 = i[1];
      v14 = i + 2;
    }
    goto LABEL_26;
  }
  if ( a2 )
    *a2 = a1;
  return 0;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (004772F7) --------------------------------------------------------
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  _DWORD v15[5]; // [esp+0h] [ebp-34h] BYREF
  int v16; // [esp+14h] [ebp-20h]
  char v17[4]; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  v7 = dword_4C1E28;
  if ( !dword_4C1E28 )
  {
    if ( dword_4A7178(1, &unk_4AF64C, 1, v17) )
    {
      v7 = 1;
    }
    else
    {
      if ( !dword_4A717C(0, 1, &unk_4AF648, 1, v17) )
        return 0;
      v7 = 2;
    }
    dword_4C1E28 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = dword_4C1C1C;
      v10 = dword_4A71B0(CodePage, a7 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
      v16 = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        ms_exc.old_esp = (DWORD)v15;
        v15[4] = v15;
        memset(v15, 0, v11);
        ms_exc.registration.TryLevel = -1;
        if ( v15 )
        {
          v14 = dword_4A71B0(CodePage, 1, lpMultiByteStr, cbMultiByte, v15, v16);
          if ( v14 )
            return dword_4A7178(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_4C1C0C;
  return dword_4A717C(v8, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType);
}
// 4A7178: using guessed type int (__stdcall *dword_4A7178)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A717C: using guessed type int (__stdcall *dword_4A717C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B0: using guessed type int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C1C1C: using guessed type int dword_4C1C1C;
// 4C1E28: using guessed type int dword_4C1E28;

//----- (00477440) --------------------------------------------------------
int __cdecl _getbuf_0(_DWORD *a1)
{
  int v1; // eax
  int result; // eax

  ++dword_4C1C28;
  v1 = sub_46D9FD(0x1000u);
  a1[2] = v1;
  if ( v1 )
  {
    a1[3] |= 8u;
    a1[6] = 4096;
  }
  else
  {
    a1[3] |= 4u;
    a1[2] = a1 + 5;
    a1[6] = 2;
  }
  result = a1[2];
  a1[1] = 0;
  *a1 = result;
  return result;
}
// 4C1C28: using guessed type int dword_4C1C28;

//----- (00477484) --------------------------------------------------------
int __cdecl _isatty(int FileHandle)
{
  int result; // eax

  if ( FileHandle < (unsigned int)dword_4C2220 )
    result = *(_BYTE *)(dword_4C2120[FileHandle >> 5] + 36 * (FileHandle & 0x1F) + 4) & 0x40;
  else
    result = 0;
  return result;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (004774AD) --------------------------------------------------------
int __cdecl wctomb(char *MbCh, wchar_t WCh)
{
  void (__stdcall *v2)(int *); // edi
  int v3; // ebx
  int WCha; // [esp+18h] [ebp+Ch]

  dword_4A7204(&dword_4C3248);
  v2 = (void (__stdcall *)(int *))dword_4A720C;
  v3 = 0;
  if ( dword_4C3244 )
  {
    dword_4A720C(&dword_4C3248);
    _lock(19);
    v3 = 1;
  }
  WCha = _wctomb_lk(MbCh, WCh);
  if ( v3 )
    sub_46FA37(19);
  else
    v2(&dword_4C3248);
  return WCha;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (00477506) --------------------------------------------------------
int __cdecl _wctomb_lk(LPSTR UsedDefaultChar, unsigned __int16 WideCharStr)
{
  int result; // eax

  result = (int)UsedDefaultChar;
  if ( UsedDefaultChar )
  {
    if ( !dword_4C1C0C )
    {
      if ( WideCharStr <= 0xFFu )
      {
        *UsedDefaultChar = WideCharStr;
        return 1;
      }
      goto LABEL_7;
    }
    UsedDefaultChar = 0;
    result = dword_4A71B4(dword_4C1C1C, 544, &WideCharStr, 1, result, dword_4BC19C, 0, &UsedDefaultChar);
    if ( !result || UsedDefaultChar )
    {
LABEL_7:
      *sub_46D641() = 42;
      return -1;
    }
  }
  return result;
}
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;

//----- (00477655) --------------------------------------------------------
int __init_time()
{
  int v0; // eax
  __lc_time_data *v1; // esi

  if ( dword_4C1C18 )
  {
    v0 = sub_46F804(1, 172);
    v1 = (__lc_time_data *)v0;
    if ( !v0 )
      return 1;
    if ( _get_lc_time(v0) )
    {
      _free_lc_time(v1);
      sub_46D360((unsigned int)v1);
      return 1;
    }
    off_4BD1B0 = (char **)v1;
    _free_lc_time((__lc_time_data *)dword_4C1E2C);
    sub_46D360(dword_4C1E2C);
    dword_4C1E2C = (int)v1;
  }
  else
  {
    off_4BD1B0 = off_4BD1B8;
    _free_lc_time((__lc_time_data *)dword_4C1E2C);
    sub_46D360(dword_4C1E2C);
    dword_4C1E2C = 0;
  }
  return 0;
}
// 4BD1B0: using guessed type char **off_4BD1B0;
// 4BD1B8: using guessed type char *off_4BD1B8[43];
// 4C1C18: using guessed type int dword_4C1C18;
// 4C1E2C: using guessed type int dword_4C1E2C;

//----- (004776E6) --------------------------------------------------------
int __cdecl _get_lc_time(int a1)
{
  int v2; // edi
  int v3; // edi
  int v4; // edi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // edi
  int v13; // edi
  int v14; // edi
  int v15; // edi
  int v16; // edi
  int v17; // edi
  int v18; // edi
  int v19; // edi
  int v20; // edi
  int v21; // edi
  int v22; // edi
  int v23; // edi
  int v24; // edi
  int v25; // edi
  int v26; // edi
  int v27; // edi
  int v28; // edi
  int v29; // edi
  int v30; // edi
  int v31; // edi
  int v32; // edi
  int v33; // edi
  int v34; // edi
  int v35; // edi
  int v36; // edi
  int v37; // edi
  int v38; // edi
  int v39; // edi
  int v40; // edi
  int v41; // edi
  int v42; // edi
  int v43; // edi
  LCID v44; // [esp+4h] [ebp-8h]
  LCID v45; // [esp+8h] [ebp-4h]

  v45 = (unsigned __int16)word_4C1E66;
  v44 = (unsigned __int16)word_4C1E68;
  if ( !a1 )
    return -1;
  v2 = __getlocaleinfo(1, (unsigned __int16)word_4C1E66, 0x31u, a1 + 4);
  v3 = __getlocaleinfo(1, v45, 0x32u, a1 + 8) | v2;
  v4 = __getlocaleinfo(1, v45, 0x33u, a1 + 12) | v3;
  v5 = __getlocaleinfo(1, v45, 0x34u, a1 + 16) | v4;
  v6 = __getlocaleinfo(1, v45, 0x35u, a1 + 20) | v5;
  v7 = __getlocaleinfo(1, v45, 0x36u, a1 + 24) | v6;
  v8 = __getlocaleinfo(1, v45, 0x37u, a1) | v7;
  v9 = __getlocaleinfo(1, v45, 0x2Au, a1 + 32) | v8;
  v10 = __getlocaleinfo(1, v45, 0x2Bu, a1 + 36) | v9;
  v11 = __getlocaleinfo(1, v45, 0x2Cu, a1 + 40) | v10;
  v12 = __getlocaleinfo(1, v45, 0x2Du, a1 + 44) | v11;
  v13 = __getlocaleinfo(1, v45, 0x2Eu, a1 + 48) | v12;
  v14 = __getlocaleinfo(1, v45, 0x2Fu, a1 + 52) | v13;
  v15 = __getlocaleinfo(1, v45, 0x30u, a1 + 28) | v14;
  v16 = __getlocaleinfo(1, v45, 0x44u, a1 + 56) | v15;
  v17 = __getlocaleinfo(1, v45, 0x45u, a1 + 60) | v16;
  v18 = __getlocaleinfo(1, v45, 0x46u, a1 + 64) | v17;
  v19 = __getlocaleinfo(1, v45, 0x47u, a1 + 68) | v18;
  v20 = __getlocaleinfo(1, v45, 0x48u, a1 + 72) | v19;
  v21 = __getlocaleinfo(1, v45, 0x49u, a1 + 76) | v20;
  v22 = __getlocaleinfo(1, v45, 0x4Au, a1 + 80) | v21;
  v23 = __getlocaleinfo(1, v45, 0x4Bu, a1 + 84) | v22;
  v24 = __getlocaleinfo(1, v45, 0x4Cu, a1 + 88) | v23;
  v25 = __getlocaleinfo(1, v45, 0x4Du, a1 + 92) | v24;
  v26 = __getlocaleinfo(1, v45, 0x4Eu, a1 + 96) | v25;
  v27 = __getlocaleinfo(1, v45, 0x4Fu, a1 + 100) | v26;
  v28 = __getlocaleinfo(1, v45, 0x38u, a1 + 104) | v27;
  v29 = __getlocaleinfo(1, v45, 0x39u, a1 + 108) | v28;
  v30 = __getlocaleinfo(1, v45, 0x3Au, a1 + 112) | v29;
  v31 = __getlocaleinfo(1, v45, 0x3Bu, a1 + 116) | v30;
  v32 = __getlocaleinfo(1, v45, 0x3Cu, a1 + 120) | v31;
  v33 = __getlocaleinfo(1, v45, 0x3Du, a1 + 124) | v32;
  v34 = __getlocaleinfo(1, v45, 0x3Eu, a1 + 128) | v33;
  v35 = __getlocaleinfo(1, v45, 0x3Fu, a1 + 132) | v34;
  v36 = __getlocaleinfo(1, v45, 0x40u, a1 + 136) | v35;
  v37 = __getlocaleinfo(1, v45, 0x41u, a1 + 140) | v36;
  v38 = __getlocaleinfo(1, v45, 0x42u, a1 + 144) | v37;
  v39 = __getlocaleinfo(1, v45, 0x43u, a1 + 148) | v38;
  v40 = __getlocaleinfo(1, v45, 0x28u, a1 + 152) | v39;
  v41 = __getlocaleinfo(1, v45, 0x29u, a1 + 156) | v40;
  v42 = __getlocaleinfo(1, v44, 0x1Fu, a1 + 160) | v41;
  v43 = __getlocaleinfo(1, v44, 0x20u, a1 + 164) | v42;
  return v43 | __getlocaleinfo(1, v44, 0x1003u, a1 + 168);
}
// 4C1E66: using guessed type __int16 word_4C1E66;
// 4C1E68: using guessed type __int16 word_4C1E68;

//----- (00477A34) --------------------------------------------------------
void __cdecl _free_lc_time(__lc_time_data *lc_time)
{
  if ( lc_time )
  {
    sub_46D360(*((_DWORD *)lc_time + 1));
    sub_46D360(*((_DWORD *)lc_time + 2));
    sub_46D360(*((_DWORD *)lc_time + 3));
    sub_46D360(*((_DWORD *)lc_time + 4));
    sub_46D360(*((_DWORD *)lc_time + 5));
    sub_46D360(*((_DWORD *)lc_time + 6));
    sub_46D360(*(_DWORD *)lc_time);
    sub_46D360(*((_DWORD *)lc_time + 8));
    sub_46D360(*((_DWORD *)lc_time + 9));
    sub_46D360(*((_DWORD *)lc_time + 10));
    sub_46D360(*((_DWORD *)lc_time + 11));
    sub_46D360(*((_DWORD *)lc_time + 12));
    sub_46D360(*((_DWORD *)lc_time + 13));
    sub_46D360(*((_DWORD *)lc_time + 7));
    sub_46D360(*((_DWORD *)lc_time + 14));
    sub_46D360(*((_DWORD *)lc_time + 15));
    sub_46D360(*((_DWORD *)lc_time + 16));
    sub_46D360(*((_DWORD *)lc_time + 17));
    sub_46D360(*((_DWORD *)lc_time + 18));
    sub_46D360(*((_DWORD *)lc_time + 19));
    sub_46D360(*((_DWORD *)lc_time + 20));
    sub_46D360(*((_DWORD *)lc_time + 21));
    sub_46D360(*((_DWORD *)lc_time + 22));
    sub_46D360(*((_DWORD *)lc_time + 23));
    sub_46D360(*((_DWORD *)lc_time + 24));
    sub_46D360(*((_DWORD *)lc_time + 25));
    sub_46D360(*((_DWORD *)lc_time + 26));
    sub_46D360(*((_DWORD *)lc_time + 27));
    sub_46D360(*((_DWORD *)lc_time + 28));
    sub_46D360(*((_DWORD *)lc_time + 29));
    sub_46D360(*((_DWORD *)lc_time + 30));
    sub_46D360(*((_DWORD *)lc_time + 31));
    sub_46D360(*((_DWORD *)lc_time + 32));
    sub_46D360(*((_DWORD *)lc_time + 33));
    sub_46D360(*((_DWORD *)lc_time + 34));
    sub_46D360(*((_DWORD *)lc_time + 35));
    sub_46D360(*((_DWORD *)lc_time + 36));
    sub_46D360(*((_DWORD *)lc_time + 37));
    sub_46D360(*((_DWORD *)lc_time + 38));
    sub_46D360(*((_DWORD *)lc_time + 39));
    sub_46D360(*((_DWORD *)lc_time + 40));
    sub_46D360(*((_DWORD *)lc_time + 41));
    sub_46D360(*((_DWORD *)lc_time + 42));
  }
}

//----- (00477BC4) --------------------------------------------------------
int __init_numeric()
{
  LCID v0; // edi
  int v1; // esi
  int v2; // esi
  int v3; // esi
  char v5; // al
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  char v8; // al

  v0 = (unsigned __int16)word_4C1E62;
  if ( dword_4C1C14 )
  {
    v1 = __getlocaleinfo(1, (unsigned __int16)word_4C1E62, 0xEu, (int)&dword_4C1E30);
    v2 = __getlocaleinfo(1, v0, 0xFu, (int)&dword_4C1E34) | v1;
    v3 = __getlocaleinfo(1, v0, 0x10u, (int)&dword_4C1E38) | v2;
    fix_grouping((char *)dword_4C1E38);
    if ( v3 )
    {
      sub_46D360(dword_4C1E30);
      sub_46D360(dword_4C1E34);
      sub_46D360(dword_4C1E38);
      dword_4C1E30 = 0;
      dword_4C1E34 = 0;
      dword_4C1E38 = 0;
      return -1;
    }
    if ( *off_4BD2A0 != &unk_4BD268 )
    {
      sub_46D360((unsigned int)*off_4BD2A0);
      sub_46D360((unsigned int)off_4BD2A0[1]);
      sub_46D360((unsigned int)off_4BD2A0[2]);
    }
    *off_4BD2A0 = (void *)dword_4C1E30;
    off_4BD2A0[1] = (void *)dword_4C1E34;
    off_4BD2A0[2] = (void *)dword_4C1E38;
    v5 = *(_BYTE *)*off_4BD2A0;
    dword_4BC1A4 = 1;
    byte_4BC1A0 = v5;
  }
  else
  {
    sub_46D360(dword_4C1E30);
    sub_46D360(dword_4C1E34);
    sub_46D360(dword_4C1E38);
    dword_4C1E30 = 0;
    dword_4C1E34 = 0;
    dword_4C1E38 = 0;
    *off_4BD2A0 = (void *)sub_46D9FD(2u);
    if ( !*off_4BD2A0 )
      return -1;
    sub_476F50();
    off_4BD2A0[1] = (void *)sub_46D9FD(2u);
    v6 = off_4BD2A0[1];
    if ( !v6 )
      return -1;
    *v6 = 0;
    off_4BD2A0[2] = (void *)sub_46D9FD(2u);
    v7 = off_4BD2A0[2];
    if ( !v7 )
      return -1;
    *v7 = 0;
    v8 = *(_BYTE *)*off_4BD2A0;
    dword_4BC1A4 = 1;
    byte_4BC1A0 = v8;
  }
  return 0;
}
// 4BC1A0: using guessed type char byte_4BC1A0;
// 4BC1A4: using guessed type int dword_4BC1A4;
// 4BD2A0: using guessed type void **off_4BD2A0;
// 4C1C14: using guessed type int dword_4C1C14;
// 4C1E30: using guessed type int dword_4C1E30;
// 4C1E34: using guessed type int dword_4C1E34;
// 4C1E38: using guessed type int dword_4C1E38;
// 4C1E62: using guessed type __int16 word_4C1E62;

//----- (00477D99) --------------------------------------------------------
char __cdecl fix_grouping(char *a1)
{
  char *v1; // ecx
  char result; // al
  char *v3; // eax

  v1 = a1;
  for ( result = *a1; *v1; result = *v1 )
  {
    if ( result < 48 || result > 57 )
    {
      if ( result == 59 )
      {
        v3 = v1;
        do
        {
          *v3 = v3[1];
          ++v3;
        }
        while ( *v3 );
        continue;
      }
    }
    else
    {
      *v1 = result - 48;
    }
    ++v1;
  }
  return result;
}

//----- (00477DD0) --------------------------------------------------------
int __init_monetary()
{
  int v0; // eax
  unsigned int *v1; // esi

  if ( dword_4C1C10 )
  {
    v0 = sub_46F804(1, 48);
    v1 = (unsigned int *)v0;
    if ( !v0 )
      return 1;
    if ( _get_lc_lconv(v0) )
    {
      _free_lc_lconv(v1);
      sub_46D360((unsigned int)v1);
      return 1;
    }
    *v1 = (unsigned int)*off_4BD2A0;
    v1[1] = (unsigned int)off_4BD2A0[1];
    v1[2] = (unsigned int)off_4BD2A0[2];
    off_4BD2A0 = (void **)v1;
    _free_lc_lconv((unsigned int *)dword_4C1E3C);
    sub_46D360(dword_4C1E3C);
    dword_4C1E3C = (int)v1;
  }
  else
  {
    off_4BD270 = *off_4BD2A0;
    off_4BD274 = off_4BD2A0[1];
    off_4BD278 = off_4BD2A0[2];
    off_4BD2A0 = &off_4BD270;
    _free_lc_lconv((unsigned int *)dword_4C1E3C);
    sub_46D360(dword_4C1E3C);
    dword_4C1E3C = 0;
  }
  return 0;
}
// 4BD270: using guessed type void *off_4BD270;
// 4BD274: using guessed type void *off_4BD274;
// 4BD278: using guessed type void *off_4BD278;
// 4BD2A0: using guessed type void **off_4BD2A0;
// 4C1C10: using guessed type int dword_4C1C10;
// 4C1E3C: using guessed type int dword_4C1E3C;

//----- (00477E9B) --------------------------------------------------------
int __cdecl _get_lc_lconv(int a1)
{
  LCID v1; // edi
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx

  v1 = (unsigned __int16)word_4C1E5C;
  if ( !a1 )
    return -1;
  v3 = __getlocaleinfo(1, (unsigned __int16)word_4C1E5C, 0x15u, a1 + 12);
  v4 = __getlocaleinfo(1, v1, 0x14u, a1 + 16) | v3;
  v5 = __getlocaleinfo(1, v1, 0x16u, a1 + 20) | v4;
  v6 = __getlocaleinfo(1, v1, 0x17u, a1 + 24) | v5;
  v7 = __getlocaleinfo(1, v1, 0x18u, a1 + 28) | v6;
  sub_477FBD(*(char **)(a1 + 28));
  v8 = __getlocaleinfo(1, v1, 0x50u, a1 + 32) | v7;
  v9 = __getlocaleinfo(1, v1, 0x51u, a1 + 36) | v8;
  v10 = __getlocaleinfo(0, v1, 0x1Au, a1 + 40) | v9;
  v11 = __getlocaleinfo(0, v1, 0x19u, a1 + 41) | v10;
  v12 = __getlocaleinfo(0, v1, 0x54u, a1 + 42) | v11;
  v13 = __getlocaleinfo(0, v1, 0x55u, a1 + 43) | v12;
  v14 = __getlocaleinfo(0, v1, 0x56u, a1 + 44) | v13;
  v15 = __getlocaleinfo(0, v1, 0x57u, a1 + 45) | v14;
  v16 = __getlocaleinfo(0, v1, 0x52u, a1 + 46) | v15;
  return v16 | __getlocaleinfo(0, v1, 0x53u, a1 + 47);
}
// 4C1E5C: using guessed type __int16 word_4C1E5C;

//----- (00477FBD) --------------------------------------------------------
char __cdecl sub_477FBD(char *a1)
{
  char *v1; // ecx
  char result; // al
  char *v3; // eax

  v1 = a1;
  for ( result = *a1; *v1; result = *v1 )
  {
    if ( result < 48 || result > 57 )
    {
      if ( result == 59 )
      {
        v3 = v1;
        do
        {
          *v3 = v3[1];
          ++v3;
        }
        while ( *v3 );
        continue;
      }
    }
    else
    {
      *v1 = result - 48;
    }
    ++v1;
  }
  return result;
}

//----- (00477FF4) --------------------------------------------------------
void __cdecl _free_lc_lconv(unsigned int *a1)
{
  if ( a1 )
  {
    if ( (_UNKNOWN *)a1[3] != &unk_4C1EC0 )
    {
      sub_46D360(a1[3]);
      sub_46D360(a1[4]);
      sub_46D360(a1[5]);
      sub_46D360(a1[6]);
      sub_46D360(a1[7]);
      sub_46D360(a1[8]);
      sub_46D360(a1[9]);
    }
  }
}

//----- (00478042) --------------------------------------------------------
// #API: GetCPInfo()
// #API: GetCPInfo()
int LC_MONETARY()
{
  int v0; // ebx
  _WORD *v1; // edi
  const WCHAR *v2; // eax
  int i; // eax
  char *v4; // eax
  int j; // edx
  int v6; // ecx
  WCHAR *v7; // ecx
  int k; // eax
  __int16 *v9; // edi
  char *v10; // eax
  int v11; // esi
  _WORD *v12; // ecx
  int result; // eax
  unsigned int v14; // [esp+4h] [ebp-24h] BYREF
  char v15; // [esp+Ah] [ebp-1Eh]
  char v16[13]; // [esp+Bh] [ebp-1Dh] BYREF
  _WORD *v17; // [esp+18h] [ebp-10h]
  _WORD *v18; // [esp+1Ch] [ebp-Ch]
  WCHAR *v19; // [esp+20h] [ebp-8h]
  LPCSTR v20; // [esp+24h] [ebp-4h]

  v0 = 0;
  v20 = 0;
  v19 = 0;
  if ( dword_4C1C0C )
  {
    if ( !dword_4C1C1C && __getlocaleinfo(0, (unsigned __int16)word_4C1E54, 0x1004u, (int)&dword_4C1C1C) )
      goto LABEL_38;
    v1 = (_WORD *)sub_46D9FD(0x202u);
    v17 = v1;
    v18 = (_WORD *)sub_46D9FD(0x202u);
    v20 = (LPCSTR)sub_46D9FD(0x101u);
    v2 = (const WCHAR *)sub_46D9FD(0x202u);
    v19 = (WCHAR *)v2;
    if ( !v1 )
      goto LABEL_38;
    if ( !v18 )
      goto LABEL_38;
    if ( !v20 )
      goto LABEL_38;
    if ( !v2 )
      goto LABEL_38;
    for ( i = 0; i < 256; ++i )
      v20[i] = i;
    if ( !dword_4A7174(dword_4C1C1C, &v14) || v14 > 2 )
      goto LABEL_38;
    dword_4BC19C = (unsigned __int16)v14;
    if ( (unsigned __int16)v14 > 1u && v15 )
    {
      v4 = v16;
      do
      {
        LOBYTE(j) = *v4;
        if ( !*v4 )
          break;
        v6 = (unsigned __int8)*(v4 - 1);
        for ( j = (unsigned __int8)j; v6 <= j; j = (unsigned __int8)*v4 )
          v20[v6++] = 0;
        v4 += 2;
      }
      while ( *(v4 - 1) );
    }
    if ( !__crtGetStringTypeA_0(1u, v20, 256, v1 + 1, 0, 0, 0) )
      goto LABEL_38;
    v7 = v19;
    *v1 = 0;
    for ( k = 0; k < 256; ++k )
      *v7++ = k;
    v9 = v18 + 1;
    if ( __crtGetStringTypeW(1u, v19, 256, v18 + 1, 0, 0) )
    {
      *v18 = 0;
      if ( (int)dword_4BC19C > 1 && v15 )
      {
        v10 = v16;
        do
        {
          if ( !*v10 )
            break;
          v11 = (unsigned __int8)*(v10 - 1);
          if ( v11 <= (unsigned __int8)*v10 )
          {
            v12 = &v17[v11 + 1];
            do
            {
              *v12 = 0x8000;
              ++v11;
              ++v12;
            }
            while ( v11 <= (unsigned __int8)*v10 );
          }
          v10 += 2;
        }
        while ( *(v10 - 1) );
      }
      off_4BBF94 = v9;
      off_4BBF90[0] = v17 + 1;
      if ( dword_4C1E40 )
        sub_46D360(dword_4C1E40);
      dword_4C1E40 = (int)v17;
      if ( dword_4C1E44 )
        sub_46D360(dword_4C1E44);
      dword_4C1E44 = (int)v18;
    }
    else
    {
LABEL_38:
      sub_46D360((unsigned int)v17);
      sub_46D360((unsigned int)v18);
      v0 = 1;
    }
    sub_46D360((unsigned int)v20);
    sub_46D360((unsigned int)v19);
    result = v0;
  }
  else
  {
    off_4BBF90[0] = word_4BBF9A;
    off_4BBF94 = word_4BBF9A;
    sub_46D360(dword_4C1E40);
    sub_46D360(dword_4C1E44);
    dword_4C1E40 = 0;
    dword_4C1E44 = 0;
    result = 0;
  }
  return result;
}
// 4A7174: using guessed type int (__stdcall *dword_4A7174)(_DWORD, _DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BBF94: using guessed type __int16 *off_4BBF94;
// 4BBF9A: using guessed type __int16 word_4BBF9A[];
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C1E40: using guessed type int dword_4C1E40;
// 4C1E44: using guessed type int dword_4C1E44;
// 4C1E54: using guessed type __int16 word_4C1E54;

//----- (00478287) --------------------------------------------------------
int sub_478287()
{
  return 0;
}

//----- (00478290) --------------------------------------------------------
size_t __cdecl strcspn(const char *Str, const char *Control)
{
  unsigned int v2; // eax
  size_t v5; // ecx
  signed __int32 v7[9]; // [esp+0h] [ebp-24h] BYREF

  v2 = 0;
  v7[7] = 0;
  v7[6] = 0;
  v7[5] = 0;
  v7[4] = 0;
  v7[3] = 0;
  v7[2] = 0;
  v7[1] = 0;
  v7[0] = 0;
  while ( 1 )
  {
    LOBYTE(v2) = *Control;
    if ( !*Control )
      break;
    ++Control;
    _bittestandset(v7, v2);
  }
  v5 = -1;
  do
  {
    ++v5;
    LOBYTE(v2) = *Str;
    if ( !*Str )
      break;
    ++Str;
  }
  while ( !_bittest(v7, v2) );
  return v5;
}

//----- (004782D0) --------------------------------------------------------
char *__cdecl strpbrk(const char *Str, const char *Control)
{
  char *result; // eax
  signed __int32 v5[9]; // [esp+0h] [ebp-24h] BYREF

  result = 0;
  v5[7] = 0;
  v5[6] = 0;
  v5[5] = 0;
  v5[4] = 0;
  v5[3] = 0;
  v5[2] = 0;
  v5[1] = 0;
  v5[0] = 0;
  while ( 1 )
  {
    LOBYTE(result) = *Control;
    if ( !*Control )
      break;
    ++Control;
    _bittestandset(v5, (unsigned int)result);
  }
  while ( 1 )
  {
    LOBYTE(result) = *Str;
    if ( !*Str )
      break;
    ++Str;
    if ( _bittest(v5, (unsigned int)result) )
      return (char *)(Str - 1);
  }
  return result;
}

//----- (0047830A) --------------------------------------------------------
int __cdecl __get_qualified_locale(char *a1, _WORD *a2, int a3)
{
  char *v3; // eax
  int v4; // edi

  if ( !dword_4C1E8C )
  {
    if ( IsThisWindowsNT() )
      dword_4C1E8C = dword_4A7168;
    else
      dword_4C1E8C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))crtGetLocaleInfoA;
  }
  if ( !a1 )
    goto LABEL_20;
  dword_4C1E7C = a1;
  if ( *a1 )
    TranslateName((int)&off_4BCE40, 64, (const char **)&dword_4C1E7C);
  v3 = a1 + 64;
  String1 = a1 + 64;
  if ( a1 != (char *)-64 && *v3 )
  {
    TranslateName((int)&off_4BCD88, 22, (const char **)&String1);
    v3 = String1;
  }
  dword_4C1E84 = 0;
  if ( !dword_4C1E7C || !*dword_4C1E7C )
  {
    if ( v3 && *v3 )
    {
      GetLcidFromCountry();
      goto LABEL_21;
    }
LABEL_20:
    sub_47893A();
    goto LABEL_21;
  }
  if ( v3 && *v3 )
    GetLcidFromLangCountry();
  else
    GetLcidFromLanguage();
LABEL_21:
  if ( dword_4C1E84 )
  {
    v4 = ProcessCodePage(a1 + 128);
    if ( v4 )
    {
      if ( dword_4A716C((unsigned __int16)v4) && dword_4A7170(dword_4C1E6C, 1) )
      {
        if ( a2 )
        {
          *a2 = dword_4C1E6C;
          a2[1] = dword_4C1E88;
          a2[2] = v4;
        }
        if ( !a3 )
          return 1;
        if ( dword_4C1E8C(dword_4C1E6C, 4097, a3, 64) && dword_4C1E8C(dword_4C1E88, 4098, a3 + 64, 64) )
        {
          _itoa(v4, (char *)(a3 + 128), 10);
          return 1;
        }
      }
    }
  }
  return 0;
}
// 4A7168: using guessed type int (__stdcall *dword_4A7168)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A716C: using guessed type int (__stdcall *dword_4A716C)(_DWORD);
// 4A7170: using guessed type int (__stdcall *dword_4A7170)(_DWORD, _DWORD);
// 4BCD88: using guessed type char *off_4BCD88;
// 4BCE40: using guessed type char *off_4BCE40;
// 4C1E84: using guessed type int dword_4C1E84;
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00478487) --------------------------------------------------------
int __cdecl TranslateName(int a1, int a2, const char **a3)
{
  int v3; // ebx
  int result; // eax
  int v5; // esi

  v3 = 0;
  result = 1;
  while ( v3 <= a2 )
  {
    if ( !result )
      break;
    v5 = (v3 + a2) / 2;
    result = _strcmpi(*a3, *(const char **)(a1 + 8 * v5));
    if ( result )
    {
      if ( result >= 0 )
        v3 = v5 + 1;
      else
        a2 = v5 - 1;
    }
    else
    {
      *a3 = (const char *)(a1 + 8 * v5 + 4);
    }
  }
  return result;
}

//----- (004784DF) --------------------------------------------------------
int GetLcidFromLangCountry()
{
  size_t v0; // eax
  int result; // eax

  dword_4C1E78 = strlen(dword_4C1E7C) == 3;
  v0 = strlen(String1);
  dword_4C1E6C = 0;
  dword_4C1E70 = v0 == 3;
  if ( dword_4C1E78 )
    MaxCount = 2;
  else
    MaxCount = GetPrimaryLen(dword_4C1E7C);
  dword_4A7164(LangCountryEnumProc, 1);
  result = dword_4C1E84;
  if ( (dword_4C1E84 & 0x100) == 0 || (dword_4C1E84 & 0x200) == 0 || (dword_4C1E84 & 7) == 0 )
    dword_4C1E84 = 0;
  return result;
}
// 4A7164: using guessed type int (__stdcall *dword_4A7164)(_DWORD, _DWORD);
// 4C1E70: using guessed type int dword_4C1E70;
// 4C1E78: using guessed type int dword_4C1E78;
// 4C1E84: using guessed type int dword_4C1E84;

//----- (00478566) --------------------------------------------------------
BOOL __stdcall LangCountryEnumProc(LPSTR a1)
{
  int v1; // esi
  int v2; // eax
  BOOL v4; // eax
  char String2[120]; // [esp+Ch] [ebp-78h] BYREF

  v1 = LcidFromHexString(a1);
  v2 = -(dword_4C1E70 != 0);
  LOWORD(v2) = v2 & 0xF005;
  if ( !dword_4C1E8C(v1, v2 + 4098, String2, 120) )
    goto LABEL_17;
  if ( !_strcmpi(String1, String2) )
  {
    if ( !dword_4C1E8C(v1, dword_4C1E78 != 0 ? 3 : 4097, String2, 120) )
    {
LABEL_17:
      dword_4C1E84 = 0;
      return 1;
    }
    if ( !_strcmpi(dword_4C1E7C, String2) )
    {
      LOWORD(dword_4C1E84) = dword_4C1E84 | 0x304;
      dword_4C1E88 = v1;
LABEL_6:
      dword_4C1E6C = v1;
      goto LABEL_15;
    }
    if ( (dword_4C1E84 & 2) == 0 )
    {
      if ( MaxCount && !_strnicmp(dword_4C1E7C, String2, MaxCount) )
      {
        dword_4C1E84 |= 2u;
        dword_4C1E88 = v1;
        if ( strlen(dword_4C1E7C) == MaxCount )
          goto LABEL_6;
      }
      else if ( (dword_4C1E84 & 1) == 0 && sub_4789BA(v1) )
      {
        dword_4C1E84 |= 1u;
        dword_4C1E88 = v1;
      }
    }
  }
LABEL_15:
  if ( (dword_4C1E84 & 0x300) != 768 )
  {
    if ( !dword_4C1E8C(v1, dword_4C1E78 != 0 ? 3 : 4097, String2, 120) )
      goto LABEL_17;
    if ( _strcmpi(dword_4C1E7C, String2) )
    {
      if ( dword_4C1E78 || !MaxCount || _strnicmp(dword_4C1E7C, String2, MaxCount) )
        return ((unsigned int)~dword_4C1E84 >> 2) & 1;
      v4 = TestDefaultLanguage(v1, 0);
    }
    else
    {
      BYTE1(dword_4C1E84) |= 2u;
      if ( dword_4C1E78 || !MaxCount || strlen(dword_4C1E7C) != MaxCount )
        goto LABEL_28;
      v4 = TestDefaultLanguage(v1, 1);
    }
    if ( v4 )
    {
LABEL_28:
      BYTE1(dword_4C1E84) |= 1u;
      if ( !dword_4C1E6C )
        dword_4C1E6C = v1;
      return ((unsigned int)~dword_4C1E84 >> 2) & 1;
    }
  }
  return ((unsigned int)~dword_4C1E84 >> 2) & 1;
}
// 4C1E70: using guessed type int dword_4C1E70;
// 4C1E78: using guessed type int dword_4C1E78;
// 4C1E84: using guessed type int dword_4C1E84;
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047876A) --------------------------------------------------------
int GetLcidFromLanguage()
{
  size_t v0; // eax
  int result; // eax

  v0 = strlen(dword_4C1E7C);
  dword_4C1E78 = v0 == 3;
  if ( v0 == 3 )
    MaxCount = 2;
  else
    MaxCount = GetPrimaryLen(dword_4C1E7C);
  result = dword_4A7164(LanguageEnumProc, 1);
  if ( (dword_4C1E84 & 4) == 0 )
    dword_4C1E84 = 0;
  return result;
}
// 4A7164: using guessed type int (__stdcall *dword_4A7164)(_DWORD, _DWORD);
// 4C1E78: using guessed type int dword_4C1E78;
// 4C1E84: using guessed type int dword_4C1E84;

//----- (004787C0) --------------------------------------------------------
BOOL __stdcall LanguageEnumProc(LPSTR a1)
{
  int v1; // esi
  int v2; // eax
  BOOL v4; // eax
  char String2[120]; // [esp+4h] [ebp-78h] BYREF

  v1 = LcidFromHexString(a1);
  v2 = -(dword_4C1E78 != 0);
  LOWORD(v2) = v2 & 0xF002;
  if ( !dword_4C1E8C(v1, v2 + 4097, String2, 120) )
  {
    dword_4C1E84 = 0;
    return 1;
  }
  if ( _strcmpi(dword_4C1E7C, String2) )
  {
    if ( dword_4C1E78 || !MaxCount || _strnicmp(dword_4C1E7C, String2, MaxCount) )
      return ((unsigned int)~dword_4C1E84 >> 2) & 1;
    v4 = TestDefaultLanguage(v1, 0);
  }
  else
  {
    if ( dword_4C1E78 )
    {
LABEL_11:
      dword_4C1E84 |= 4u;
      dword_4C1E88 = v1;
      dword_4C1E6C = v1;
      return ((unsigned int)~dword_4C1E84 >> 2) & 1;
    }
    v4 = TestDefaultLanguage(v1, 1);
  }
  if ( v4 )
    goto LABEL_11;
  return ((unsigned int)~dword_4C1E84 >> 2) & 1;
}
// 4C1E78: using guessed type int dword_4C1E78;
// 4C1E84: using guessed type int dword_4C1E84;
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047887D) --------------------------------------------------------
int GetLcidFromCountry()
{
  int result; // eax

  dword_4C1E70 = strlen(String1) == 3;
  result = dword_4A7164(CountryEnumProc, 1);
  if ( (dword_4C1E84 & 4) == 0 )
    dword_4C1E84 = 0;
  return result;
}
// 4A7164: using guessed type int (__stdcall *dword_4A7164)(_DWORD, _DWORD);
// 4C1E70: using guessed type int dword_4C1E70;
// 4C1E84: using guessed type int dword_4C1E84;

//----- (004788B4) --------------------------------------------------------
unsigned int __stdcall CountryEnumProc(LPSTR a1)
{
  int v1; // esi
  int v2; // eax
  unsigned int result; // eax
  char String2[120]; // [esp+4h] [ebp-78h] BYREF

  v1 = LcidFromHexString(a1);
  v2 = -(dword_4C1E70 != 0);
  LOWORD(v2) = v2 & 0xF005;
  if ( dword_4C1E8C(v1, v2 + 4098, String2, 120) )
  {
    if ( !_strcmpi(String1, String2) )
    {
      if ( sub_4789BA(v1) )
      {
        dword_4C1E84 |= 4u;
        dword_4C1E88 = v1;
        dword_4C1E6C = v1;
      }
    }
    result = ((unsigned int)~dword_4C1E84 >> 2) & 1;
  }
  else
  {
    dword_4C1E84 = 0;
    result = 1;
  }
  return result;
}
// 4C1E70: using guessed type int dword_4C1E70;
// 4C1E84: using guessed type int dword_4C1E84;
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047893A) --------------------------------------------------------
int sub_47893A()
{
  int result; // eax

  LOWORD(dword_4C1E84) = dword_4C1E84 | 0x104;
  result = dword_4A7160();
  dword_4C1E88 = result;
  dword_4C1E6C = result;
  return result;
}
// 4A7160: using guessed type int (*dword_4A7160)(void);
// 4C1E6C: using guessed type int dword_4C1E6C;
// 4C1E84: using guessed type int dword_4C1E84;
// 4C1E88: using guessed type int dword_4C1E88;

//----- (00478954) --------------------------------------------------------
int __cdecl ProcessCodePage(char *Str1)
{
  const char *v1; // esi
  int result; // eax
  _DWORD v3[2]; // [esp+4h] [ebp-8h] BYREF

  v1 = Str1;
  if ( Str1 && *Str1 && strcmp(Str1, off_4B0100) )
  {
    if ( strcmp(Str1, off_4B00FC) )
      return atol_0(v1);
    result = dword_4C1E8C(dword_4C1E88, 11, v3, 8);
  }
  else
  {
    result = dword_4C1E8C(dword_4C1E88, 4100, v3, 8);
  }
  if ( !result )
    return result;
  v1 = (const char *)v3;
  return atol_0(v1);
}
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004789BA) --------------------------------------------------------
int __cdecl sub_4789BA(__int16 a1)
{
  _WORD *v1; // eax

  v1 = &unk_4BCD74;
  while ( a1 != *v1 )
  {
    if ( (int)++v1 >= (int)&off_4BCD88 )
      return 1;
  }
  return 0;
}
// 4BCD88: using guessed type char *off_4BCD88;

//----- (004789D9) --------------------------------------------------------
BOOL __cdecl TestDefaultLanguage(int a1, int a2)
{
  int v2; // eax
  int v3; // esi
  BOOL result; // eax
  char v5[120]; // [esp+0h] [ebp-78h] BYREF

  v2 = a1 & 0x3FF;
  BYTE1(v2) |= 4u;
  result = 0;
  if ( dword_4C1E8C(v2, 1, v5, 120) )
  {
    if ( a1 == LcidFromHexString(v5) || !a2 || (v3 = GetPrimaryLen(dword_4C1E7C), v3 != strlen(dword_4C1E7C)) )
      result = 1;
  }
  return result;
}
// 4C1E8C: using guessed type int (__stdcall *dword_4C1E8C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00478A3B) --------------------------------------------------------
BOOL IsThisWindowsNT()
{
  int v1[37]; // [esp+0h] [ebp-94h] BYREF

  v1[0] = 148;
  return dword_4A71CC(v1) && v1[4] == 2;
}
// 4A71CC: using guessed type int (__stdcall *dword_4A71CC)(_DWORD);

//----- (00478A71) --------------------------------------------------------
int __stdcall crtGetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR Dest, int cchData)
{
  int v4; // esi
  int v5; // edi
  int v6; // eax
  LCID v7; // ecx
  const char *v9; // eax

  v4 = 0;
  v5 = 26;
  while ( 1 )
  {
    v6 = (v5 + v4) / 2;
    v7 = dword_4BC8D0[11 * v6];
    if ( Locale == v7 )
      break;
    if ( Locale >= v7 )
      v4 = v6 + 1;
    else
      v5 = v6 - 1;
    if ( v4 > v5 )
      return dword_4A7168(Locale, LCType, Dest, cchData);
  }
  switch ( LCType )
  {
    case 1u:
      v9 = &a040a[44 * v6];
      break;
    case 3u:
      v9 = (const char *)(&off_4BC8E0 + 11 * v6);
      break;
    case 7u:
      v9 = (const char *)(&off_4BC8E8 + 11 * v6);
      break;
    case 0xBu:
      v9 = (char *)&unk_4BC8EC + 44 * v6;
      break;
    case 0x1001u:
      v9 = (&off_4BC8DC)[11 * v6];
      break;
    case 0x1002u:
      v9 = (&off_4BC8E4)[11 * v6];
      break;
    case 0x1004u:
      v9 = &a1252[44 * v6];
      break;
    default:
      return dword_4A7168(Locale, LCType, Dest, cchData);
  }
  if ( !v9 || cchData < 1 )
    return dword_4A7168(Locale, LCType, Dest, cchData);
  strncpy(Dest, v9, cchData - 1);
  Dest[cchData - 1] = 0;
  return 1;
}
// 4A7168: using guessed type int (__stdcall *dword_4A7168)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BC8D0: using guessed type int dword_4BC8D0[];
// 4BC8DC: using guessed type char *off_4BC8DC;
// 4BC8E0: using guessed type char (*off_4BC8E0)[3];
// 4BC8E4: using guessed type char *off_4BC8E4;
// 4BC8E8: using guessed type char (*off_4BC8E8)[3];

//----- (00478B57) --------------------------------------------------------
int __cdecl LcidFromHexString(char *a1)
{
  int result; // eax
  char v3; // cl

  for ( result = 0; ; result = v3 + 16 * (result + 268435453) )
  {
    v3 = *a1++;
    if ( !v3 )
      break;
    if ( v3 < 97 || v3 > 102 )
    {
      if ( v3 >= 65 && v3 <= 70 )
        v3 -= 7;
    }
    else
    {
      v3 -= 39;
    }
  }
  return result;
}

//----- (00478B90) --------------------------------------------------------
int __cdecl GetPrimaryLen(char *a1)
{
  int result; // eax
  char v3; // cl

  for ( result = 0; ; ++result )
  {
    v3 = *a1++;
    if ( (v3 < 65 || v3 > 90) && (v3 < 97 || v3 > 122) )
      break;
  }
  return result;
}

//----- (00478C32) --------------------------------------------------------
int sub_478C32()
{
  return 0;
}

//----- (00478C35) --------------------------------------------------------
char *__cdecl sub_478C35(char *VarName)
{
  char *v1; // esi

  _lock(12);
  v1 = getenv_0(VarName);
  sub_46FA37(12);
  return v1;
}

//----- (00478C56) --------------------------------------------------------
char *__cdecl getenv_0(const char *VarName)
{
  const char **v1; // esi
  size_t v2; // edi

  v1 = (const char **)dword_4C1B38;
  if ( dword_4C327C )
  {
    if ( dword_4C1B38 || dword_4C1B40 && !__wtomb_environ_0() && (v1 = (const char **)dword_4C1B38) != 0 )
    {
      if ( VarName )
      {
        v2 = strlen(VarName);
        while ( *v1 )
        {
          if ( strlen(*v1) > v2
            && (*v1)[v2] == 61
            && !_mbsnbicoll_0((const unsigned __int8 *)*v1, (const unsigned __int8 *)VarName, v2) )
          {
            return (char *)&(*v1)[v2 + 1];
          }
          ++v1;
        }
      }
    }
  }
  return 0;
}
// 4C1B38: using guessed type int dword_4C1B38;
// 4C1B40: using guessed type int dword_4C1B40;
// 4C327C: using guessed type int dword_4C327C;

//----- (00478D67) --------------------------------------------------------
int __cdecl sub_478D67(unsigned __int8 a1)
{
  return x_ismbbtype(a1, 0, 4u);
}

//----- (00478DB0) --------------------------------------------------------
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  if ( (a3 & (unsigned __int8)byte_4C2001[a1]) != 0
    || (!a2 ? (result = 0) : (result = (unsigned __int16)(a2 & word_4BBF9A[a1])), result) )
  {
    result = 1;
  }
  return result;
}
// 4BBF9A: using guessed type __int16 word_4BBF9A[];

//----- (00478DE1) --------------------------------------------------------
int __cdecl _setmbcp(int CodePage)
{
  int v1; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // edx
  _DWORD *v5; // eax
  bool v6; // cc
  char *v7; // ecx
  unsigned __int8 v8; // dl
  unsigned int i; // eax
  int v10; // esi
  char *v11; // ebx
  unsigned __int8 *v12; // ecx
  unsigned __int8 v13; // dl
  unsigned int v14; // eax
  unsigned int v15; // edi
  char v16; // dl
  int v17; // eax
  _DWORD *v18; // esi
  unsigned int j; // eax
  unsigned int v21; // [esp+Ch] [ebp-18h] BYREF
  char v22; // [esp+12h] [ebp-12h]
  char v23; // [esp+13h] [ebp-11h] BYREF
  unsigned int v24; // [esp+20h] [ebp-4h]
  int CodePagea; // [esp+2Ch] [ebp+8h]

  _lock(25);
  v1 = getSystemCP_0(CodePage);
  v2 = v1;
  CodePagea = v1;
  if ( v1 == dword_4C1EE0 )
  {
LABEL_2:
    v3 = 0;
    goto LABEL_34;
  }
  if ( !v1 )
  {
LABEL_31:
    setSBCS_0();
LABEL_32:
    setSBUpLow();
    goto LABEL_2;
  }
  v4 = 0;
  v5 = &unk_4BD0C0;
  do
  {
    if ( *v5 == v2 )
    {
      v24 = 0;
      memset(&unk_4C2000, 0, 0x100u);
      v10 = 48 * v4;
      *((_BYTE *)&unk_4C2000 + 256) = 0;
      v11 = (char *)&unk_4BD0D0 + 48 * v4;
      do
      {
        v12 = (unsigned __int8 *)v11;
        if ( *v11 )
        {
          do
          {
            v13 = v12[1];
            if ( !v13 )
              break;
            v14 = *v12;
            v15 = v13;
            if ( v14 <= v13 )
            {
              v16 = byte_4BD0B8[v24];
              do
                byte_4C2001[v14++] |= v16;
              while ( v14 <= v15 );
            }
            v12 += 2;
          }
          while ( *v12 );
        }
        ++v24;
        v11 += 8;
      }
      while ( v24 < 4 );
      dword_4C1EFC = 1;
      dword_4C1EE0 = CodePagea;
      v17 = CPtoLCID_0(CodePagea);
      v18 = (_DWORD *)((char *)&unk_4BD0C4 + v10);
      dword_4C1EF0[0] = *v18++;
      dword_4C1EF0[1] = *v18;
      dword_4C2104 = v17;
      dword_4C1EF0[2] = v18[1];
      goto LABEL_32;
    }
    v5 += 12;
    ++v4;
  }
  while ( (int)v5 < (int)&off_4BD1B0 );
  if ( dword_4A7174(v2, &v21) == 1 )
  {
    dword_4C2104 = 0;
    v6 = v21 <= 1;
    memset(&unk_4C2000, 0, 0x100u);
    *((_BYTE *)&unk_4C2000 + 256) = 0;
    dword_4C1EE0 = v2;
    if ( v6 )
    {
      dword_4C1EFC = 0;
    }
    else
    {
      if ( v22 )
      {
        v7 = &v23;
        do
        {
          v8 = *v7;
          if ( !*v7 )
            break;
          for ( i = (unsigned __int8)*(v7 - 1); i <= v8; ++i )
            byte_4C2001[i] |= 4u;
          v7 += 2;
        }
        while ( *(v7 - 1) );
      }
      for ( j = 1; j < 0xFF; ++j )
        byte_4C2001[j] |= 8u;
      dword_4C2104 = CPtoLCID_0(v2);
      dword_4C1EFC = 1;
    }
    dword_4C1EF0[0] = 0;
    dword_4C1EF0[1] = 0;
    dword_4C1EF0[2] = 0;
    goto LABEL_32;
  }
  if ( dword_4C1E90 )
    goto LABEL_31;
  v3 = -1;
LABEL_34:
  sub_46FA37(25);
  return v3;
}
// 4A7174: using guessed type int (__stdcall *dword_4A7174)(_DWORD, _DWORD);
// 4BD1B0: using guessed type char **off_4BD1B0;
// 4C1E90: using guessed type int dword_4C1E90;
// 4C1EFC: using guessed type int dword_4C1EFC;
// 4C2104: using guessed type int dword_4C2104;

//----- (00478F8E) --------------------------------------------------------
int __cdecl getSystemCP_0(int a1)
{
  int result; // eax

  result = a1;
  dword_4C1E90 = 0;
  switch ( a1 )
  {
    case -2:
      dword_4C1E90 = 1;
      result = dword_4A72B0();
      break;
    case -3:
      dword_4C1E90 = 1;
      result = dword_4A715C();
      break;
    case -4:
      result = dword_4C1C1C;
      dword_4C1E90 = 1;
      break;
  }
  return result;
}
// 4A715C: using guessed type int (*dword_4A715C)(void);
// 4A72B0: using guessed type int (*dword_4A72B0)(void);
// 4C1C1C: using guessed type int dword_4C1C1C;
// 4C1E90: using guessed type int dword_4C1E90;

//----- (00478FD8) --------------------------------------------------------
int __cdecl CPtoLCID_0(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}

//----- (0047900B) --------------------------------------------------------
int setSBCS_0()
{
  int result; // eax

  memset(&unk_4C2000, 0, 0x100u);
  *((_BYTE *)&unk_4C2000 + 256) = 0;
  result = 0;
  dword_4C1EE0 = 0;
  dword_4C1EFC = 0;
  dword_4C2104 = 0;
  dword_4C1EF0[0] = 0;
  dword_4C1EF0[1] = 0;
  dword_4C1EF0[2] = 0;
  return result;
}
// 4C1EE0: using guessed type int dword_4C1EE0;
// 4C1EFC: using guessed type int dword_4C1EFC;
// 4C2104: using guessed type int dword_4C2104;

//----- (00479034) --------------------------------------------------------
unsigned int setSBUpLow()
{
  unsigned int i; // eax
  unsigned __int8 v1; // al
  char *v2; // edx
  unsigned int v3; // ecx
  unsigned int result; // eax
  WORD *j; // ecx
  char v6; // dl
  char v7; // cl
  WORD v8[254]; // [esp+4h] [ebp-514h] BYREF
  CHAR v9[252]; // [esp+204h] [ebp-314h] BYREF
  CHAR v10[252]; // [esp+304h] [ebp-214h] BYREF
  CHAR v11[252]; // [esp+404h] [ebp-114h] BYREF
  int v12; // [esp+504h] [ebp-14h] BYREF
  unsigned __int8 v13; // [esp+50Ah] [ebp-Eh]
  char v14; // [esp+50Bh] [ebp-Dh] BYREF

  if ( dword_4A7174(dword_4C1EE0, &v12) == 1 )
  {
    for ( i = 0; i < 0x100; ++i )
      v11[i] = i;
    v1 = v13;
    v11[0] = 32;
    if ( v13 )
    {
      v2 = &v14;
      do
      {
        v3 = (unsigned __int8)*v2;
        if ( v1 <= v3 )
          memset(&v11[v1], 0x20u, v3 - v1 + 1);
        v2 += 2;
        v1 = *(v2 - 1);
      }
      while ( v1 );
    }
    __crtGetStringTypeA_0(1u, v11, 256, v8, dword_4C1EE0, dword_4C2104, 0);
    __crtLCMapStringA_0(dword_4C2104, 0x100u, v11, 256, v10, 256, dword_4C1EE0, 0);
    __crtLCMapStringA_0(dword_4C2104, 0x200u, v11, 256, v9, 256, dword_4C1EE0, 0);
    result = 0;
    for ( j = v8; ; ++j )
    {
      if ( (*j & 1) != 0 )
      {
        byte_4C2001[result] |= 0x10u;
        v6 = v10[result];
      }
      else
      {
        if ( (*j & 2) == 0 )
        {
          byte_4C1F00[result] = 0;
          goto LABEL_16;
        }
        byte_4C2001[result] |= 0x20u;
        v6 = v9[result];
      }
      byte_4C1F00[result] = v6;
LABEL_16:
      if ( ++result >= 0x100 )
        return result;
    }
  }
  for ( result = 0; result < 0x100; ++result )
  {
    if ( result >= 0x41 && result <= 0x5A )
    {
      byte_4C2001[result] |= 0x10u;
      v7 = result + 32;
LABEL_22:
      byte_4C1F00[result] = v7;
      continue;
    }
    if ( result >= 0x61 && result <= 0x7A )
    {
      byte_4C2001[result] |= 0x20u;
      v7 = result - 32;
      goto LABEL_22;
    }
    byte_4C1F00[result] = 0;
  }
  return result;
}
// 4A7174: using guessed type int (__stdcall *dword_4A7174)(_DWORD, _DWORD);
// 4C2104: using guessed type int dword_4C2104;

//----- (004791C9) --------------------------------------------------------
int sub_4791C9()
{
  int result; // eax

  if ( !dword_4C3280 )
  {
    result = _setmbcp(-3);
    dword_4C3280 = 1;
  }
  return result;
}
// 4C3280: using guessed type int dword_4C3280;

//----- (004791E5) --------------------------------------------------------
int __cdecl __crtMessageBoxA_0(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // edi
  int (__stdcall *v6)(int, char *); // esi

  v3 = 0;
  if ( !dword_4C1E94 )
  {
    v4 = dword_4A70DC(aUser32Dll);
    v5 = v4;
    if ( !v4 )
      return 0;
    v6 = (int (__stdcall *)(int, char *))dword_4A70D8;
    dword_4C1E94 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))dword_4A70D8(v4, aMessageboxa);
    if ( !dword_4C1E94 )
      return 0;
    dword_4C1E98 = (int (*)(void))v6(v5, aGetactivewindo);
    dword_4C1E9C = (int (__stdcall *)(_DWORD))v6(v5, aGetlastactivep);
  }
  if ( dword_4C1E98 )
  {
    v3 = dword_4C1E98();
    if ( v3 )
    {
      if ( dword_4C1E9C )
        v3 = dword_4C1E9C(v3);
    }
  }
  return dword_4C1E94(v3, a1, a2, a3);
}
// 4A70D8: using guessed type int (__stdcall *dword_4A70D8)(_DWORD, _DWORD);
// 4A70DC: using guessed type int (__stdcall *dword_4A70DC)(_DWORD);
// 4C1E94: using guessed type int (__stdcall *dword_4C1E94)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C1E98: using guessed type int (*dword_4C1E98)(void);
// 4C1E9C: using guessed type int (__stdcall *dword_4C1E9C)(_DWORD);

//----- (0047926E) --------------------------------------------------------
int _alloc_osfhnd()
{
  int v0; // edi
  int v1; // ebx
  int *v2; // ebp
  unsigned int v3; // esi
  unsigned int i; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v0 = -1;
  _lock(18);
  v1 = 0;
  v8 = 0;
  v9 = 0;
  v2 = dword_4C2120;
  while ( 1 )
  {
    v3 = *v2;
    if ( !*v2 )
      break;
    for ( i = v3 + 1152; v3 < i; i = *v2 + 1152 )
    {
      if ( (*(_BYTE *)(v3 + 4) & 1) == 0 )
      {
        if ( !*(_DWORD *)(v3 + 8) )
        {
          _lock(17);
          if ( !*(_DWORD *)(v3 + 8) )
          {
            dword_4A71EC(v3 + 12);
            ++*(_DWORD *)(v3 + 8);
          }
          sub_46FA37(17);
        }
        dword_4A71E4(v3 + 12);
        if ( (*(_BYTE *)(v3 + 4) & 1) == 0 )
        {
          *(_DWORD *)v3 = -1;
          v0 = v9 + (int)(v3 - *v2) / 36;
          if ( v0 != -1 )
            goto LABEL_22;
          v1 = v8;
          break;
        }
        dword_4A71E0(v3 + 12);
        v1 = v8;
      }
      v3 += 36;
    }
    v9 += 32;
    ++v2;
    v8 = ++v1;
    if ( (int)v2 >= (int)&dword_4C2220 )
      goto LABEL_22;
  }
  v5 = sub_46D9FD(0x480u);
  if ( v5 )
  {
    dword_4C2220 += 32;
    v6 = v5 + 1152;
    dword_4C2120[v1] = v5;
    while ( v5 < v6 )
    {
      *(_BYTE *)(v5 + 4) = 0;
      *(_DWORD *)v5 = -1;
      *(_DWORD *)(v5 + 8) = 0;
      *(_BYTE *)(v5 + 5) = 10;
      v5 += 36;
      v6 = dword_4C2120[v1] + 1152;
    }
    v0 = 32 * v1;
    _lock_fhandle(32 * v1);
  }
LABEL_22:
  sub_46FA37(18);
  return v0;
}
// 4A71E0: using guessed type int (__stdcall *dword_4A71E0)(_DWORD);
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);
// 4A71EC: using guessed type int (__stdcall *dword_4A71EC)(_DWORD);
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (00479391) --------------------------------------------------------
int __cdecl _set_osfhnd(int a1, HANDLE hHandle)
{
  int result; // eax

  if ( a1 < (unsigned int)dword_4C2220 && *(_DWORD *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F)) == -1 )
  {
    if ( dword_4B9E64 == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          dword_4A7248(-11, hHandle);
        }
        else if ( a1 == 2 )
        {
          dword_4A7248(-12, hHandle);
        }
      }
      else
      {
        dword_4A7248(-10, hHandle);
      }
    }
    *(_DWORD *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F)) = hHandle;
    result = 0;
  }
  else
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  return result;
}
// 4A7248: using guessed type int (__stdcall *dword_4A7248)(_DWORD, _DWORD);
// 4B9E64: using guessed type int dword_4B9E64;
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (0047940D) --------------------------------------------------------
int __cdecl _free_osfhnd(int a1)
{
  int v1; // eax
  int result; // eax

  if ( a1 >= (unsigned int)dword_4C2220
    || (v1 = 36 * (a1 & 0x1F) + dword_4C2120[a1 >> 5], (*(_BYTE *)(v1 + 4) & 1) == 0)
    || *(_DWORD *)v1 == -1 )
  {
    *sub_46D641() = 9;
    *sub_46D64A() = 0;
    result = -1;
  }
  else
  {
    if ( dword_4B9E64 == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          dword_4A7248(-11, 0);
        }
        else if ( a1 == 2 )
        {
          dword_4A7248(-12, 0);
        }
      }
      else
      {
        dword_4A7248(-10, 0);
      }
    }
    *(_DWORD *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F)) = -1;
    result = 0;
  }
  return result;
}
// 4A7248: using guessed type int (__stdcall *dword_4A7248)(_DWORD, _DWORD);
// 4B9E64: using guessed type int dword_4B9E64;
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (0047948C) --------------------------------------------------------
intptr_t __cdecl _get_osfhandle(int FileHandle)
{
  int v1; // eax

  if ( FileHandle < (unsigned int)dword_4C2220 )
  {
    v1 = dword_4C2120[FileHandle >> 5] + 36 * (FileHandle & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  *sub_46D641() = 9;
  *sub_46D64A() = 0;
  return -1;
}
// 4C2120: using guessed type int dword_4C2120[];
// 4C2220: using guessed type int dword_4C2220;

//----- (00479575) --------------------------------------------------------
int __cdecl _lock_fhandle(int a1)
{
  int v1; // edi
  int v2; // esi

  v1 = 36 * (a1 & 0x1F);
  v2 = v1 + dword_4C2120[a1 >> 5];
  if ( !*(_DWORD *)(v2 + 8) )
  {
    _lock(17);
    if ( !*(_DWORD *)(v2 + 8) )
    {
      dword_4A71EC(v2 + 12);
      ++*(_DWORD *)(v2 + 8);
    }
    sub_46FA37(17);
  }
  return dword_4A71E4(dword_4C2120[a1 >> 5] + v1 + 12);
}
// 4A71E4: using guessed type int (__stdcall *dword_4A71E4)(_DWORD);
// 4A71EC: using guessed type int (__stdcall *dword_4A71EC)(_DWORD);
// 4C2120: using guessed type int dword_4C2120[];

//----- (004795D4) --------------------------------------------------------
int __cdecl _unlock_fhandle(int a1)
{
  return dword_4A71E0(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F) + 12);
}
// 4A71E0: using guessed type int (__stdcall *dword_4A71E0)(_DWORD);
// 4C2120: using guessed type int dword_4C2120[];

//----- (0047960D) --------------------------------------------------------
int _sopen(const char *FileName, int OpenFlag, int ShareFlag, ...)
{
  unsigned int v3; // ecx
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  void *v8; // esi
  unsigned int v9; // eax
  int v10; // esi
  int v11; // eax
  char v12; // cl
  int v13; // esi
  bool v14; // zf
  _DWORD v15[2]; // [esp+Ch] [ebp-1Ch] BYREF
  int v16; // [esp+14h] [ebp-14h]
  LONG v17; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  int v19; // [esp+20h] [ebp-8h]
  unsigned __int8 v20; // [esp+27h] [ebp-1h]
  char FileName_3; // [esp+33h] [ebp+Bh]
  int v22; // [esp+3Ch] [ebp+14h]
  va_list va; // [esp+40h] [ebp+18h] BYREF

  va_start(va, ShareFlag);
  v22 = va_arg(va, _DWORD);
  v15[0] = 12;
  v15[1] = 0;
  if ( (OpenFlag & 0x80u) == 0 )
  {
    v20 = 0;
    v16 = 1;
  }
  else
  {
    v16 = 0;
    v20 = 16;
  }
  if ( (OpenFlag & 0x8000) == 0 && ((OpenFlag & 0x4000) != 0 || dword_4C1EC8 != 0x8000) )
    v20 |= 0x80u;
  if ( (OpenFlag & 3) != 0 )
  {
    if ( (OpenFlag & 3) == 1 )
    {
      v18 = 0x40000000;
    }
    else
    {
      if ( (OpenFlag & 3) != 2 )
        goto LABEL_34;
      v18 = -1073741824;
    }
  }
  else
  {
    v18 = 0x80000000;
  }
  switch ( ShareFlag )
  {
    case 16:
      v17 = 0;
      break;
    case 32:
      v17 = 1;
      break;
    case 48:
      v17 = 2;
      break;
    case 64:
      v17 = 3;
      break;
    default:
LABEL_34:
      *sub_46D641() = 22;
      *sub_46D64A() = 0;
      return -1;
  }
  v3 = OpenFlag & 0x700;
  if ( v3 > 0x400 )
  {
    if ( v3 != 1280 )
    {
      if ( v3 == 1536 )
        goto LABEL_35;
      if ( v3 != 1792 )
        goto LABEL_34;
    }
    v19 = 1;
    goto LABEL_37;
  }
  if ( v3 == 1024 || (OpenFlag & 0x700) == 0 )
  {
    v19 = 3;
    goto LABEL_37;
  }
  if ( v3 == 256 )
  {
    v19 = 4;
    goto LABEL_37;
  }
  if ( v3 == 512 )
  {
LABEL_35:
    v19 = 5;
    goto LABEL_37;
  }
  if ( v3 != 768 )
    goto LABEL_34;
  v19 = 2;
LABEL_37:
  v5 = 128;
  if ( (OpenFlag & 0x100) != 0 && (v22 & ~(_BYTE)dword_4C1B18 & 0x80u) == 0 )
    v5 = 1;
  if ( (OpenFlag & 0x40) != 0 )
  {
    v5 |= 0x4000000u;
    BYTE2(v18) |= 1u;
  }
  if ( (OpenFlag & 0x1000) != 0 )
    v5 |= 0x100u;
  if ( (OpenFlag & 0x20) != 0 )
  {
    v5 |= 0x8000000u;
  }
  else if ( (OpenFlag & 0x10) != 0 )
  {
    v5 |= 0x10000000u;
  }
  v6 = _alloc_osfhnd();
  if ( v6 == -1 )
  {
    *sub_46D641() = 24;
    *sub_46D64A() = 0;
    return -1;
  }
  v7 = dword_4A7284(FileName, v18, v17, v15, v19, v5, 0);
  v8 = (void *)v7;
  if ( v7 == -1 )
    goto LABEL_51;
  v11 = dword_4A7184(v7);
  if ( v11 )
  {
    if ( v11 == 2 )
    {
      v20 |= 0x40u;
    }
    else if ( v11 == 3 )
    {
      v20 |= 8u;
    }
    _set_osfhnd(v6, v8);
    v12 = v20 | 1;
    v13 = 36 * (v6 & 0x1F);
    v14 = ((v20 | 1) & 0x48) == 0;
    FileName_3 = (v20 | 1) & 0x48;
    *(_BYTE *)(dword_4C2120[v6 >> 5] + v13 + 4) = v20 | 1;
    if ( v14 && v12 < 0 && (OpenFlag & 2) != 0 )
    {
      v17 = _lseek_lk(v6, -1, 2u);
      if ( v17 == -1 )
      {
        if ( *sub_46D64A() != 131 )
        {
LABEL_63:
          _close(v6);
          v10 = -1;
          goto LABEL_72;
        }
      }
      else
      {
        HIBYTE(ShareFlag) = 0;
        if ( !_read_lk(v6, (char *)&ShareFlag + 3, 1u)
          && HIBYTE(ShareFlag) == 26
          && _chsize_lk(4 * (v6 >> 5) + 4989216, v6, v17) == -1
          || _lseek_lk(v6, 0, 0) == -1 )
        {
          goto LABEL_63;
        }
      }
    }
    if ( !FileName_3 && (OpenFlag & 8) != 0 )
      *(_BYTE *)(dword_4C2120[v6 >> 5] + v13 + 4) |= 0x20u;
    v10 = v6;
    goto LABEL_72;
  }
  dword_4A729C(v8);
LABEL_51:
  v9 = ((int (__cdecl *)())dword_4A7260)();
  _dosmaperr(v9);
  v10 = -1;
LABEL_72:
  _unlock_fhandle(v6);
  return v10;
}
// 4A7184: using guessed type int (__stdcall *dword_4A7184)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7284: using guessed type int (__stdcall *dword_4A7284)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4C1B18: using guessed type int dword_4C1B18;
// 4C1EC8: using guessed type int dword_4C1EC8;
// 4C2120: using guessed type int dword_4C2120[];

//----- (004798F3) --------------------------------------------------------
int __cdecl sub_4798F3(int a1, __int16 a2, int a3, char a4)
{
  unsigned int v4; // ecx
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  void *v9; // esi
  unsigned int v10; // eax
  int v11; // esi
  int v12; // eax
  char v13; // cl
  int v14; // esi
  bool v15; // zf
  int v16[2]; // [esp+Ch] [ebp-1Ch] BYREF
  int v17; // [esp+14h] [ebp-14h]
  LONG v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]
  unsigned __int8 v21; // [esp+27h] [ebp-1h]
  char v22; // [esp+33h] [ebp+Bh]

  v16[0] = 12;
  v16[1] = 0;
  if ( (a2 & 0x80u) == 0 )
  {
    v21 = 0;
    v17 = 1;
  }
  else
  {
    v17 = 0;
    v21 = 16;
  }
  if ( (a2 & 0x8000) == 0 && ((a2 & 0x4000) != 0 || dword_4C1EC8 != 0x8000) )
    v21 |= 0x80u;
  if ( (a2 & 3) != 0 )
  {
    if ( (a2 & 3) == 1 )
    {
      v19 = 0x40000000;
    }
    else
    {
      if ( (a2 & 3) != 2 )
        goto LABEL_34;
      v19 = -1073741824;
    }
  }
  else
  {
    v19 = 0x80000000;
  }
  switch ( a3 )
  {
    case 16:
      v18 = 0;
      break;
    case 32:
      v18 = 1;
      break;
    case 48:
      v18 = 2;
      break;
    case 64:
      v18 = 3;
      break;
    default:
LABEL_34:
      *sub_46D641() = 22;
      *sub_46D64A() = 0;
      return -1;
  }
  v4 = a2 & 0x700;
  if ( v4 > 0x400 )
  {
    if ( v4 != 1280 )
    {
      if ( v4 == 1536 )
        goto LABEL_35;
      if ( v4 != 1792 )
        goto LABEL_34;
    }
    v20 = 1;
    goto LABEL_37;
  }
  if ( v4 == 1024 || (a2 & 0x700) == 0 )
  {
    v20 = 3;
    goto LABEL_37;
  }
  if ( v4 == 256 )
  {
    v20 = 4;
    goto LABEL_37;
  }
  if ( v4 == 512 )
  {
LABEL_35:
    v20 = 5;
    goto LABEL_37;
  }
  if ( v4 != 768 )
    goto LABEL_34;
  v20 = 2;
LABEL_37:
  v6 = 128;
  if ( (a2 & 0x100) != 0 && (a4 & ~(_BYTE)dword_4C1B18 & 0x80u) == 0 )
    v6 = 1;
  if ( (a2 & 0x40) != 0 )
  {
    v6 |= 0x4000000u;
    BYTE2(v19) |= 1u;
  }
  if ( (a2 & 0x1000) != 0 )
    v6 |= 0x100u;
  if ( (a2 & 0x20) != 0 )
  {
    v6 |= 0x8000000u;
  }
  else if ( (a2 & 0x10) != 0 )
  {
    v6 |= 0x10000000u;
  }
  v7 = _alloc_osfhnd();
  if ( v7 == -1 )
  {
    *sub_46D641() = 24;
    *sub_46D64A() = 0;
    return -1;
  }
  v8 = dword_4A7150(a1, v19, v18, v16, v20, v6, 0);
  v9 = (void *)v8;
  if ( v8 == -1 )
    goto LABEL_51;
  v12 = dword_4A7184(v8);
  if ( v12 )
  {
    if ( v12 == 2 )
    {
      v21 |= 0x40u;
    }
    else if ( v12 == 3 )
    {
      v21 |= 8u;
    }
    _set_osfhnd(v7, v9);
    v13 = v21 | 1;
    v14 = 36 * (v7 & 0x1F);
    v15 = ((v21 | 1) & 0x48) == 0;
    v22 = (v21 | 1) & 0x48;
    *(_BYTE *)(dword_4C2120[v7 >> 5] + v14 + 4) = v21 | 1;
    if ( v15 && v13 < 0 && (a2 & 2) != 0 )
    {
      v18 = _lseek_lk(v7, -1, 2u);
      if ( v18 == -1 )
      {
        if ( *sub_46D64A() != 131 )
        {
LABEL_63:
          _close(v7);
          v11 = -1;
          goto LABEL_72;
        }
      }
      else
      {
        a3 = 0;
        if ( !_read_lk(v7, &a3, 1u) && (_WORD)a3 == 26 && _chsize_lk(4 * (v7 >> 5) + 4989216, v7, v18) == -1
          || _lseek_lk(v7, 0, 0) == -1 )
        {
          goto LABEL_63;
        }
      }
    }
    if ( !v22 && (a2 & 8) != 0 )
      *(_BYTE *)(dword_4C2120[v7 >> 5] + v14 + 4) |= 0x20u;
    v11 = v7;
    goto LABEL_72;
  }
  dword_4A729C(v9);
LABEL_51:
  v10 = ((int (__cdecl *)())dword_4A7260)();
  _dosmaperr(v10);
  v11 = -1;
LABEL_72:
  _unlock_fhandle(v7);
  return v11;
}
// 4A7150: using guessed type int (__stdcall *dword_4A7150)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7184: using guessed type int (__stdcall *dword_4A7184)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A729C: using guessed type int (__stdcall *dword_4A729C)(_DWORD);
// 4C1B18: using guessed type int dword_4C1B18;
// 4C1EC8: using guessed type int dword_4C1EC8;
// 4C2120: using guessed type int dword_4C2120[];

//----- (00479D45) --------------------------------------------------------
BOOL __stdcall ctrlevent_capture(DWORD a1)
{
  void (__cdecl *v1)(int); // esi
  int *v2; // eax
  int v3; // edi
  BOOL result; // eax
  int v5; // [esp-4h] [ebp-10h]

  _lock(1);
  if ( a1 )
  {
    v1 = (void (__cdecl *)(int))dword_4C1EA8;
    v2 = &dword_4C1EA8;
    v5 = 21;
  }
  else
  {
    v1 = (void (__cdecl *)(int))dword_4C1EA4;
    v2 = &dword_4C1EA4;
    v5 = 2;
  }
  v3 = v5;
  if ( v1 )
  {
    if ( v1 == (void (__cdecl *)(int))1 )
    {
      sub_46FA37(1);
    }
    else
    {
      *v2 = 0;
      sub_46FA37(1);
      v1(v3);
    }
    result = 1;
  }
  else
  {
    sub_46FA37(1);
    result = 0;
  }
  return result;
}
// 4C1EA4: using guessed type int dword_4C1EA4;
// 4C1EA8: using guessed type int dword_4C1EA8;

//----- (00479DA7) --------------------------------------------------------
int __cdecl raise(int Signal)
{
  void (__cdecl *v2)(int, int); // ebx
  int *v3; // edi
  int *v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]

  v11 = 0;
  switch ( Signal )
  {
    case 2:
      v2 = (void (__cdecl *)(int, int))dword_4C1EA4;
      v3 = &dword_4C1EA4;
      break;
    case 4:
    case 8:
    case 11:
      v4 = _getptd();
      v3 = (int *)(siglookup(Signal, v4[20]) + 8);
      v2 = (void (__cdecl *)(int, int))*v3;
      goto LABEL_15;
    case 15:
      v2 = (void (__cdecl *)(int, int))dword_4C1EB0;
      v3 = &dword_4C1EB0;
      break;
    case 21:
      v2 = (void (__cdecl *)(int, int))dword_4C1EA8;
      v3 = &dword_4C1EA8;
      break;
    case 22:
      v2 = (void (__cdecl *)(int, int))dword_4C1EAC;
      v3 = &dword_4C1EAC;
      break;
    default:
      return -1;
  }
  v11 = 1;
  _lock(1);
  v4 = (int *)Signal;
LABEL_15:
  if ( v2 != (void (__cdecl *)(int, int))1 )
  {
    v5 = 0;
    if ( !v2 )
    {
      if ( v11 )
        sub_46FA37(1);
      sub_46E4BD(3);
    }
    if ( Signal == 8 || Signal == 11 || Signal == 4 )
    {
      v10 = v4[21];
      v4[21] = v5;
      if ( Signal != 8 )
        goto LABEL_32;
      v6 = v4[22];
      v4[22] = 140;
      v9 = v6;
    }
    if ( Signal == 8 )
    {
      v7 = dword_4BC7D0;
      if ( dword_4BC7D0 < dword_4BC7D0 + dword_4BC7D4 )
      {
        v8 = 12 * dword_4BC7D0;
        do
        {
          v8 += 12;
          *(_DWORD *)(v4[20] + v8 - 4) = 0;
          ++v7;
        }
        while ( v7 < dword_4BC7D0 + dword_4BC7D4 );
      }
LABEL_33:
      if ( v11 )
        sub_46FA37(1);
      if ( Signal == 8 )
      {
        v2(8, v4[22]);
      }
      else
      {
        ((void (__cdecl *)(int))v2)(Signal);
        if ( Signal != 11 && Signal != 4 )
          return 0;
      }
      v4[21] = v10;
      if ( Signal == 8 )
        v4[22] = v9;
      return 0;
    }
LABEL_32:
    *v3 = v5;
    goto LABEL_33;
  }
  if ( v11 )
    sub_46FA37(1);
  return 0;
}
// 479E8F: variable 'v5' is possibly undefined
// 479F17: variable 'v10' is possibly undefined
// 479F1F: variable 'v9' is possibly undefined
// 4BC7D0: using guessed type int dword_4BC7D0;
// 4BC7D4: using guessed type int dword_4BC7D4;
// 4C1EA4: using guessed type int dword_4C1EA4;
// 4C1EA8: using guessed type int dword_4C1EA8;
// 4C1EAC: using guessed type int dword_4C1EAC;
// 4C1EB0: using guessed type int dword_4C1EB0;

//----- (00479F29) --------------------------------------------------------
unsigned int __cdecl siglookup(int a1, unsigned int a2)
{
  unsigned int result; // eax

  result = a2;
  if ( *(_DWORD *)(a2 + 4) != a1 )
  {
    do
      result += 12;
    while ( result < a2 + 12 * dword_4BC7DC && *(_DWORD *)(result + 4) != a1 );
  }
  if ( result >= a2 + 12 * dword_4BC7DC || *(_DWORD *)(result + 4) != a1 )
    result = 0;
  return result;
}
// 4BC7DC: using guessed type int dword_4BC7DC;

//----- (00479F6F) --------------------------------------------------------
int *sub_479F6F()
{
  return _getptd() + 21;
}

//----- (00479F78) --------------------------------------------------------
int __cdecl __addl_0(unsigned int a1, unsigned int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = 0;
  v4 = a1 + a2;
  if ( a1 + a2 < a1 || v4 < a2 )
    result = 1;
  *a3 = v4;
  return result;
}

//----- (00479F99) --------------------------------------------------------
int __cdecl __add_12_0(unsigned int *a1, unsigned int *a2)
{
  if ( __addl_0(*a1, *a2, a1) && __addl_0(a1[1], 1u, a1 + 1) )
    ++a1[2];
  if ( __addl_0(a1[1], a2[1], a1 + 1) )
    ++a1[2];
  return __addl_0(a1[2], a2[2], a1 + 2);
}

//----- (00479FF7) --------------------------------------------------------
_DWORD *__cdecl __shl_12(_DWORD *a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edi
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = a1;
  v2 = a1[1];
  v3 = *a1;
  *a1 *= 2;
  v4 = (v3 >> 31) | (2 * v2);
  v5 = a1[2];
  a1[1] = v4;
  a1[2] = (v2 >> 31) | (2 * v5);
  return result;
}

//----- (0047A025) --------------------------------------------------------
int *__cdecl __shr_12(int *a1)
{
  int *result; // eax
  unsigned int v2; // edx
  int v3; // edi
  int v4; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[1];
  a1[1] = *(__int64 *)(a1 + 1) >> 1;
  v4 = (v3 << 31) | ((unsigned int)*a1 >> 1);
  a1[2] = v2 >> 1;
  *a1 = v4;
  return result;
}

//----- (0047A052) --------------------------------------------------------
__int16 __cdecl __mtold12_0(char *a1, int a2, int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // eax
  __int16 result; // ax
  unsigned int v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int v12; // [esp+28h] [ebp+10h]

  v11 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = *(_DWORD *)(a3 + 8);
      __shl_12((_DWORD *)a3);
      __shl_12((_DWORD *)a3);
      __add_12_0((unsigned int *)a3, &v8);
      __shl_12((_DWORD *)a3);
      v9 = 0;
      v10 = 0;
      v8 = *a1;
      __add_12_0((unsigned int *)a3, &v8);
      ++a1;
      --v12;
    }
    while ( v12 );
  }
  while ( !*(_DWORD *)(a3 + 8) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 8) = HIWORD(v4);
    v5 = (v4 << 16) | HIWORD(*(_DWORD *)a3);
    v6 = *(_DWORD *)a3 << 16;
    v11 += 65520;
    *(_DWORD *)(a3 + 4) = v5;
    *(_DWORD *)a3 = v6;
  }
  while ( (*(_DWORD *)(a3 + 8) & 0x8000) == 0 )
  {
    __shl_12((_DWORD *)a3);
    v11 += 0xFFFF;
  }
  result = v11;
  *(_WORD *)(a3 + 10) = v11;
  return result;
}

//----- (0047A119) --------------------------------------------------------
int __cdecl __strgtold12_0(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7)
{
  char *v7; // edi
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char *v12; // eax
  char *v14; // eax
  int v15; // eax
  char *v16; // ecx
  int v17; // esi
  int v18; // eax
  bool v20; // zf
  int v21; // eax
  int v22; // eax
  int v23; // eax
  char *v24; // ebx
  unsigned int v25; // esi
  __int16 v26; // ax
  __int16 v27; // dx
  __int16 v28; // ax
  int result; // eax
  int v30; // [esp-4h] [ebp-6Ch]
  int v31; // [esp-4h] [ebp-6Ch]
  char v32[11]; // [esp+Ch] [ebp-5Ch] BYREF
  char v33; // [esp+23h] [ebp-45h]
  _WORD v34[3]; // [esp+28h] [ebp-40h] BYREF
  unsigned int v35; // [esp+2Eh] [ebp-3Ah]
  int v36; // [esp+32h] [ebp-36h]
  int v37; // [esp+38h] [ebp-30h]
  int v38; // [esp+3Ch] [ebp-2Ch]
  int v39; // [esp+40h] [ebp-28h]
  int v40; // [esp+44h] [ebp-24h]
  int v41; // [esp+48h] [ebp-20h]
  int v42; // [esp+4Ch] [ebp-1Ch]
  int v43; // [esp+50h] [ebp-18h]
  int v44; // [esp+54h] [ebp-14h]
  int v45; // [esp+58h] [ebp-10h]
  char *v46; // [esp+5Ch] [ebp-Ch]
  int v47; // [esp+60h] [ebp-8h]
  unsigned int v48; // [esp+64h] [ebp-4h]

  v7 = a3;
  v46 = v32;
  v8 = 0;
  v39 = 0;
  v43 = 1;
  v48 = 0;
  v45 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v37 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  while ( 1 )
  {
    v9 = *v7;
    if ( *v7 != 32 && v9 != 9 && v9 != 10 && v9 != 13 )
      break;
    ++v7;
  }
  while ( 2 )
  {
    v10 = *v7++;
    switch ( v8 )
    {
      case 0:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_4BC1A0 )
          goto LABEL_12;
        if ( v10 == 43 )
        {
          v39 = 0;
          v8 = 2;
          continue;
        }
        if ( v10 == 45 )
        {
          v39 = 0x8000;
          v8 = 2;
          continue;
        }
        if ( v10 != 48 )
          goto LABEL_108;
        goto LABEL_35;
      case 1:
        v45 = 1;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_4BC1A0 )
          goto LABEL_46;
        if ( v10 == 43 || v10 == 45 )
          goto LABEL_30;
        if ( v10 != 48 )
          goto LABEL_25;
        goto LABEL_35;
      case 2:
        if ( v10 >= 49 && v10 <= 57 )
        {
LABEL_10:
          v30 = 3;
LABEL_80:
          v8 = v30;
LABEL_81:
          --v7;
        }
        else
        {
          if ( v10 == byte_4BC1A0 )
          {
LABEL_12:
            v31 = 5;
            goto LABEL_89;
          }
          if ( v10 != 48 )
          {
LABEL_93:
            v7 = a3;
            goto LABEL_110;
          }
LABEL_35:
          v8 = 1;
        }
        continue;
      case 3:
        v45 = 1;
        while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][(unsigned __int8)v10] & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 >= 0x19 )
          {
            ++v47;
          }
          else
          {
            v12 = v46;
            ++v48;
            ++v46;
            *v12 = v10 - 48;
          }
          v10 = *v7++;
        }
        if ( v10 != byte_4BC1A0 )
          goto LABEL_57;
LABEL_46:
        v8 = 4;
        continue;
      case 4:
        v45 = 1;
        v40 = 1;
        if ( !v48 )
        {
          while ( v10 == 48 )
          {
            --v47;
            v10 = *v7++;
          }
        }
        while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][(unsigned __int8)v10] & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 < 0x19 )
          {
            v14 = v46;
            ++v48;
            ++v46;
            --v47;
            *v14 = v10 - 48;
          }
          v10 = *v7++;
        }
LABEL_57:
        if ( v10 == 43 || v10 == 45 )
        {
LABEL_30:
          --v7;
          v31 = 11;
        }
        else
        {
LABEL_25:
          if ( v10 <= 67 || v10 > 69 && (v10 <= 99 || v10 > 101) )
          {
LABEL_108:
            --v7;
            goto LABEL_110;
          }
          v31 = 6;
        }
        goto LABEL_89;
      case 5:
        v40 = 1;
        if ( (int)dword_4BC19C <= 1 )
          v15 = off_4BBF90[0][(unsigned __int8)v10] & 4;
        else
          v15 = _isctype_0((unsigned __int8)v10, 4);
        if ( !v15 )
          goto LABEL_93;
        v8 = 4;
        goto LABEL_81;
      case 6:
        v16 = v7 - 2;
        a3 = v7 - 2;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 43 )
          goto LABEL_88;
        if ( v10 == 45 )
          goto LABEL_87;
        if ( v10 != 48 )
          goto LABEL_109;
LABEL_70:
        v31 = 8;
        goto LABEL_89;
      case 7:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 48 )
          goto LABEL_70;
        goto LABEL_93;
      case 8:
        v41 = 1;
        while ( v10 == 48 )
          v10 = *v7++;
        if ( v10 < 49 || v10 > 57 )
          goto LABEL_108;
LABEL_79:
        v30 = 9;
        goto LABEL_80;
      case 9:
        v41 = 1;
        v17 = 0;
        while ( 2 )
        {
          if ( (int)dword_4BC19C <= 1 )
            v18 = off_4BBF90[0][(unsigned __int8)v10] & 4;
          else
            v18 = _isctype_0((unsigned __int8)v10, 4);
          if ( v18 )
          {
            v17 = v10 + 10 * v17 - 48;
            if ( v17 <= 5200 )
            {
              v10 = *v7++;
              continue;
            }
            v17 = 5201;
          }
          break;
        }
        v42 = v17;
        while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][(unsigned __int8)v10] & 4 : _isctype_0((unsigned __int8)v10, 4) )
          v10 = *v7++;
        goto LABEL_108;
      case 11:
        if ( !a7 )
        {
          --v7;
          v8 = 10;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_110;
          continue;
        }
        v16 = v7 - 1;
        a3 = v7 - 1;
        if ( v10 == 43 )
        {
LABEL_88:
          v31 = 7;
LABEL_89:
          v8 = v31;
          continue;
        }
        if ( v10 == 45 )
        {
LABEL_87:
          v43 = -1;
          v8 = 7;
          continue;
        }
LABEL_109:
        v7 = v16;
LABEL_110:
        v20 = v45 == 0;
        *a2 = v7;
        if ( v20 )
        {
          v27 = 0;
          v26 = 0;
          v25 = 0;
          v24 = 0;
          v44 = 4;
        }
        else
        {
          if ( v48 <= 0x18 )
          {
            v21 = (int)v46;
          }
          else
          {
            if ( v33 >= 5 )
              ++v33;
            v48 = 24;
            v21 = (int)(v46 - 1);
            ++v47;
          }
          if ( v48 )
          {
            while ( !*(_BYTE *)--v21 )
            {
              --v48;
              ++v47;
            }
            __mtold12_0(v32, v48, (int)v34);
            v22 = v42;
            if ( v43 < 0 )
              v22 = -v42;
            v23 = v47 + v22;
            if ( !v41 )
              v23 += a5;
            if ( !v40 )
              v23 -= a6;
            if ( v23 > 5200 )
            {
              v38 = 1;
              goto LABEL_127;
            }
            if ( v23 >= -5200 )
            {
              __multtenpow12_0(v34, v23, a4);
              v27 = v34[0];
              v24 = *(char **)&v34[1];
              v25 = v35;
              v26 = v36;
            }
            else
            {
              v37 = 1;
LABEL_127:
              v24 = a3;
              v25 = (unsigned int)a3;
              v26 = (__int16)a3;
              v27 = (__int16)a3;
            }
          }
          else
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
          }
          if ( v38 )
          {
            v24 = 0;
            v26 = 0x7FFF;
            v25 = 0x80000000;
            v27 = 0;
            v44 = 2;
          }
          else if ( v37 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
            v44 = 1;
          }
        }
        v28 = v39 | v26;
        *(_DWORD *)(a1 + 6) = v25;
        *(_DWORD *)(a1 + 2) = v24;
        *(_WORD *)(a1 + 10) = v28;
        result = v44;
        *(_WORD *)a1 = v27;
        return result;
      default:
        goto LABEL_91;
    }
  }
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (0047A626) --------------------------------------------------------
int __cdecl _I10_OUTPUT_0(__int64 a1, int a2, int a3, char a4, int a5)
{
  int v5; // ebx
  __int16 v6; // cx
  unsigned __int16 v7; // dx
  int v8; // edi
  int v9; // esi
  bool v10; // zf
  int v11; // edi
  int v12; // esi
  int v13; // esi
  int v14; // eax
  char v15; // al
  _BYTE *v16; // ecx
  char v17; // cl
  _BYTE *v18; // eax
  bool v19; // cc
  _BYTE *v20; // ecx
  char v21; // al
  char v23[12]; // [esp+Ch] [ebp-1Ch] BYREF
  _BYTE v24[12]; // [esp+18h] [ebp-10h] BYREF
  int v25; // [esp+24h] [ebp-4h]

  v5 = a5;
  v6 = a2 & 0x8000;
  v23[0] = -52;
  v23[1] = -52;
  v23[2] = -52;
  v23[3] = -52;
  v23[4] = -52;
  v23[5] = -52;
  v23[6] = -52;
  v23[7] = -52;
  v23[8] = -52;
  v23[9] = -52;
  v23[10] = -5;
  v23[11] = 63;
  v25 = 1;
  v7 = a2 & 0x7FFF;
  if ( (a2 & 0x8000u) == 0 )
    *(_BYTE *)(a5 + 2) = 32;
  else
    *(_BYTE *)(a5 + 2) = 45;
  v8 = HIDWORD(a1);
  if ( !v7 && !a1 )
    goto LABEL_6;
  if ( v7 == 0x7FFF )
  {
    *(_WORD *)v5 = 1;
    if ( v8 == 0x80000000 && !(_DWORD)a1 || (v8 & 0x40000000) != 0 )
    {
      if ( v6 && v8 == -1073741824 )
      {
        if ( !(_DWORD)a1 )
        {
LABEL_17:
          sub_476F50();
          *(_BYTE *)(v5 + 3) = 5;
          return 0;
        }
      }
      else if ( v8 == 0x80000000 && !(_DWORD)a1 )
      {
        goto LABEL_17;
      }
    }
    sub_476F50();
    *(_BYTE *)(v5 + 3) = 6;
    return 0;
  }
  *(_WORD *)v24 = 0;
  *(_WORD *)&v24[10] = v7;
  v9 = (77 * (HIBYTE(v7) + 2 * HIBYTE(HIDWORD(a1))) + 19728 * v7 - 323162868) >> 16;
  *(_QWORD *)&v24[2] = a1;
  __multtenpow12_0(v24, -(__int16)v9, 1);
  if ( *(_WORD *)&v24[10] >= 0x3FFFu )
  {
    LOWORD(v9) = v9 + 1;
    __ld12mul_0((int)v24, (int)v23);
  }
  v10 = (a4 & 1) == 0;
  *(_WORD *)v5 = v9;
  if ( v10 )
  {
    v11 = a3;
    goto LABEL_26;
  }
  v11 = (__int16)v9 + a3;
  if ( v11 > 0 )
  {
LABEL_26:
    if ( v11 > 21 )
      v11 = 21;
    v12 = *(unsigned __int16 *)&v24[10] - 16382;
    *(_WORD *)&v24[10] = 0;
    a5 = 8;
    do
    {
      __shl_12(v24);
      --a5;
    }
    while ( a5 );
    if ( v12 < 0 )
    {
      v13 = (unsigned __int8)-(char)v12;
      if ( v13 > 0 )
      {
        do
        {
          __shr_12((int *)v24);
          --v13;
        }
        while ( v13 );
      }
    }
    v14 = v5 + 4;
    a5 = v5 + 4;
    if ( v11 + 1 > 0 )
    {
      a3 = v11 + 1;
      do
      {
        a1 = *(_QWORD *)v24;
        a2 = *(_DWORD *)&v24[8];
        __shl_12(v24);
        __shl_12(v24);
        __add_12_0((unsigned int *)v24, (unsigned int *)&a1);
        __shl_12(v24);
        v15 = v24[11];
        v16 = (_BYTE *)a5;
        v24[11] = 0;
        ++a5;
        v10 = a3-- == 1;
        *v16 = v15 + 48;
      }
      while ( !v10 );
      v14 = a5;
    }
    v17 = *(_BYTE *)(v14 - 1);
    v18 = (_BYTE *)(v14 - 2);
    v19 = v17 < 53;
    v20 = (_BYTE *)(v5 + 4);
    if ( v19 )
    {
      while ( v18 >= v20 )
      {
        if ( *v18 != 48 )
        {
          if ( v18 >= v20 )
            goto LABEL_44;
          break;
        }
        --v18;
      }
      *(_WORD *)v5 = 0;
      *(_BYTE *)(v5 + 2) = 32;
      *(_BYTE *)(v5 + 3) = 1;
      *v20 = 48;
      goto LABEL_51;
    }
    while ( v18 >= v20 )
    {
      if ( *v18 != 57 )
      {
        if ( v18 >= v20 )
          goto LABEL_43;
        break;
      }
      *v18-- = 48;
    }
    ++v18;
    ++*(_WORD *)v5;
LABEL_43:
    ++*v18;
LABEL_44:
    v21 = (_BYTE)v18 - v5 - 3;
    *(_BYTE *)(v5 + 3) = v21;
    *(_BYTE *)(v21 + v5 + 4) = 0;
    return v25;
  }
LABEL_6:
  *(_WORD *)v5 = 0;
  *(_BYTE *)(v5 + 2) = 32;
  *(_BYTE *)(v5 + 3) = 1;
  *(_BYTE *)(v5 + 4) = 48;
LABEL_51:
  *(_BYTE *)(v5 + 5) = 0;
  return 1;
}

//----- (0047AC2A) --------------------------------------------------------
int __cdecl sub_47AC2A(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int *a4, int a5)
{
  void (__stdcall *v5)(int *); // ebx
  char **v6; // eax
  unsigned __int8 *v7; // esi
  unsigned __int8 v8; // al
  char *v9; // esi
  int v11; // [esp+Ch] [ebp-8h]
  unsigned int v12; // [esp+10h] [ebp-4h] BYREF

  v12 = a2;
  dword_4A7204(&dword_4C3248);
  v5 = (void (__stdcall *)(int *))dword_4A720C;
  if ( dword_4C3244 )
  {
    dword_4A720C(&dword_4C3248);
    _lock(19);
    v11 = 1;
  }
  else
  {
    v11 = 0;
  }
  v6 = (char **)a5;
  if ( !a5 )
    v6 = off_4BD1B0;
  a5 = (int)v6;
  if ( v12 )
  {
    v7 = a3;
    do
    {
      v8 = *v7;
      if ( !*v7 )
        break;
      if ( v8 == 37 )
      {
        dword_4C1ED8 = 0;
        v9 = (char *)(v7 + 1);
        if ( *v9 == 35 )
        {
          dword_4C1ED8 = 1;
          ++v9;
        }
        _expandtime(*v9, a4, (char **)&a1, &v12, a5);
        v7 = (unsigned __int8 *)(v9 + 1);
      }
      else
      {
        if ( off_4BBF90[0][v8] < 0 && v12 > 1 )
        {
          *a1++ = v8;
          ++v7;
          --v12;
        }
        *a1++ = *v7++;
        --v12;
      }
    }
    while ( v12 );
  }
  if ( v11 )
    sub_46FA37(19);
  else
    v5(&dword_4C3248);
  if ( !v12 )
    return 0;
  *a1 = 0;
  return a2 - v12;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BD1B0: using guessed type char **off_4BD1B0;
// 4C1ED8: using guessed type int dword_4C1ED8;
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (0047AD24) --------------------------------------------------------
void __cdecl _expandtime(char a1, int *a2, char **a3, unsigned int *a4, int a5)
{
  int v5; // edx
  int *v6; // eax
  int v7; // ecx
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int v11; // eax
  unsigned int v12; // [esp-Ch] [ebp-18h]
  char **v13; // [esp-8h] [ebp-14h]
  char **v14; // [esp-8h] [ebp-14h]
  unsigned int *v15; // [esp-4h] [ebp-10h]
  unsigned int *v16; // [esp-4h] [ebp-10h]

  if ( a1 <= 90 )
  {
    if ( a1 != 90 )
    {
      if ( a1 > 77 )
      {
        if ( a1 == 83 )
        {
          dword_4C1EDC = dword_4C1ED8;
          _store_num(*a2, 2u, a3, a4);
          return;
        }
        if ( a1 == 85 )
        {
          dword_4C1EDC = dword_4C1ED8;
          v6 = a2;
          v8 = a2[6];
        }
        else
        {
          if ( a1 != 87 )
          {
            if ( a1 == 88 )
            {
              dword_4C1ED8 = 0;
              _store_winword(*(void **)(a5 + 168), (int)a2, (int)a3, (int)a4, a5);
            }
            else if ( a1 == 89 )
            {
              dword_4C1EDC = dword_4C1ED8;
              _store_num(a2[5] % 100 + 100 * (a2[5] / 100 + 19), 4u, a3, a4);
            }
            return;
          }
          dword_4C1EDC = dword_4C1ED8;
          v6 = a2;
          v7 = a2[6];
          if ( v7 )
            v8 = v7 - 1;
          else
            v8 = 6;
        }
        v9 = v6[7];
        if ( v9 >= v8 )
        {
          v10 = v9 / 7;
          if ( v9 % 7 >= v8 )
            ++v10;
        }
        else
        {
          v10 = 0;
        }
        _store_num(v10, 2u, a3, a4);
      }
      else
      {
        switch ( a1 )
        {
          case 'M':
            dword_4C1EDC = dword_4C1ED8;
            _store_num(a2[1], 2u, a3, a4);
            break;
          case '%':
            *(*a3)++ = 37;
            --*a4;
            break;
          case 'A':
            _store_str(*(_BYTE **)(a5 + 4 * a2[6] + 28), a3, a4);
            break;
          case 'B':
            _store_str(*(_BYTE **)(a5 + 4 * a2[4] + 104), a3, a4);
            break;
          case 'H':
            dword_4C1EDC = dword_4C1ED8;
            _store_num(a2[2], 2u, a3, a4);
            break;
          case 'I':
            dword_4C1EDC = dword_4C1ED8;
            v5 = a2[2] % 12;
            if ( !v5 )
              v5 = 12;
            v15 = a4;
            v13 = a3;
            goto LABEL_13;
          default:
            return;
        }
      }
      return;
    }
LABEL_59:
    __tzset();
    _store_str((&off_4BC72C)[a2[8] != 0], a3, a4);
    return;
  }
  if ( a1 <= 109 )
  {
    switch ( a1 )
    {
      case 'm':
        v16 = a4;
        dword_4C1EDC = dword_4C1ED8;
        v14 = a3;
        v11 = a2[4];
        v12 = 2;
        break;
      case 'a':
        _store_str(*(_BYTE **)(a5 + 4 * a2[6]), a3, a4);
        return;
      case 'b':
        _store_str(*(_BYTE **)(a5 + 4 * a2[4] + 56), a3, a4);
        return;
      case 'c':
        if ( dword_4C1ED8 )
        {
          dword_4C1ED8 = 0;
          _store_winword(*(void **)(a5 + 164), (int)a2, (int)a3, (int)a4, a5);
        }
        else
        {
          _store_winword(*(void **)(a5 + 160), (int)a2, (int)a3, (int)a4, a5);
        }
        if ( *a4 )
        {
          *(*a3)++ = 32;
          --*a4;
          _store_winword(*(void **)(a5 + 168), (int)a2, (int)a3, (int)a4, a5);
        }
        return;
      case 'd':
        dword_4C1EDC = dword_4C1ED8;
        _store_num(a2[3], 2u, a3, a4);
        return;
      case 'j':
        v16 = a4;
        dword_4C1EDC = dword_4C1ED8;
        v14 = a3;
        v11 = a2[7];
        v12 = 3;
        break;
      default:
        return;
    }
    _store_num(v11 + 1, v12, v14, v16);
    return;
  }
  switch ( a1 )
  {
    case 'p':
      if ( a2[2] > 11 )
        _store_str(*(_BYTE **)(a5 + 156), a3, a4);
      else
        _store_str(*(_BYTE **)(a5 + 152), a3, a4);
      return;
    case 'w':
      dword_4C1EDC = dword_4C1ED8;
      _store_num(a2[6], 1u, a3, a4);
      return;
    case 'x':
      if ( dword_4C1ED8 )
      {
        dword_4C1ED8 = 0;
        _store_winword(*(void **)(a5 + 164), (int)a2, (int)a3, (int)a4, a5);
      }
      else
      {
        _store_winword(*(void **)(a5 + 160), (int)a2, (int)a3, (int)a4, a5);
      }
      return;
    case 'y':
      v15 = a4;
      dword_4C1EDC = dword_4C1ED8;
      v13 = a3;
      v5 = a2[5] % 100;
LABEL_13:
      _store_num(v5, 2u, v13, v15);
      return;
    case 'z':
      goto LABEL_59;
  }
}
// 4C1ED8: using guessed type int dword_4C1ED8;
// 4C1EDC: using guessed type int dword_4C1EDC;

//----- (0047B113) --------------------------------------------------------
void __cdecl _store_str(_BYTE *a1, _DWORD *a2, _DWORD *a3)
{
  if ( *a3 )
  {
    do
    {
      if ( !*a1 )
        break;
      *(_BYTE *)(*a2)++ = *a1++;
    }
    while ( (*a3)-- != 1 );
  }
}

//----- (0047B13A) --------------------------------------------------------
char *__cdecl _store_num(int a1, unsigned int a2, char **a3, unsigned int *a4)
{
  char *result; // eax
  unsigned int v5; // ecx
  char *v6; // [esp+4h] [ebp-4h]

  result = 0;
  v6 = 0;
  if ( dword_4C1EDC )
    return _store_number(a1, a3, a4);
  if ( a2 >= *a4 )
  {
    *a4 = 0;
  }
  else
  {
    v5 = a2 - 1;
    if ( a2 )
    {
      do
      {
        (*a3)[v5] = a1 % 10 + 48;
        ++v6;
        --v5;
        a1 /= 10;
      }
      while ( v5 != -1 );
    }
    result = v6;
    *a3 = &(*a3)[(_DWORD)v6];
    *a4 -= (unsigned int)v6;
  }
  return result;
}
// 4C1EDC: using guessed type int dword_4C1EDC;

//----- (0047B1A9) --------------------------------------------------------
char *__cdecl _store_number(int a1, char **a2, _DWORD *a3)
{
  char *v3; // ecx
  char *result; // eax
  char *v5; // ecx
  char v6; // dl

  v3 = *a2;
  do
  {
    if ( *a3 <= 1u )
      break;
    *v3++ = a1 % 10 + 48;
    --*a3;
    a1 /= 10;
  }
  while ( a1 > 0 );
  result = *a2;
  *a2 = v3;
  v5 = v3 - 1;
  do
  {
    v6 = *v5;
    *v5-- = *result;
    *result++ = v6;
  }
  while ( result < v5 );
  return result;
}

//----- (0047B1F2) --------------------------------------------------------
void __cdecl _store_winword(void *String1, int a2, int a3, int a4, int a5)
{
  const char *v5; // ebx
  int v8; // ecx
  const char *v9; // eax
  char v10; // dl
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  const char *v15; // ebx
  unsigned __int8 v16; // al
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  unsigned __int8 *v20; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  char *String1a; // [esp+18h] [ebp+8h]
  const char *v25; // [esp+20h] [ebp+10h]
  const char *v26; // [esp+20h] [ebp+10h]
  char v27; // [esp+24h] [ebp+14h]

  v5 = (const char *)String1;
  while ( *v5 )
  {
    v8 = 0;
    if ( !*(_DWORD *)a4 )
      return;
    dword_4C1EDC = 0;
    v25 = v5 + 1;
    do
    {
      v9 = v25;
      v10 = *v5;
      ++v8;
      ++v25;
    }
    while ( *v9 == *v5 );
    v26 = v25 - 1;
    String1a = (char *)v8;
    if ( v10 > 100 )
    {
      switch ( v10 )
      {
        case 'h':
          v23 = v8 - 1;
          if ( v23 )
          {
            if ( v23 != 1 )
            {
LABEL_12:
              if ( off_4BBF90[0][(unsigned __int8)v10] < 0 )
              {
                ++v5;
                *(_BYTE *)(*(_DWORD *)a3)++ = v10;
                --*(_DWORD *)a4;
              }
              *(_BYTE *)(*(_DWORD *)a3)++ = *v5++;
              --*(_DWORD *)a4;
              continue;
            }
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 73;
          break;
        case 'm':
          v22 = v8 - 1;
          if ( v22 )
          {
            if ( v22 != 1 )
              goto LABEL_12;
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 77;
          break;
        case 's':
          v21 = v8 - 1;
          if ( v21 )
          {
            if ( v21 != 1 )
              goto LABEL_12;
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 83;
          break;
        case 't':
          if ( *(int *)(a2 + 8) > 11 )
            v20 = *(unsigned __int8 **)(a5 + 156);
          else
            v20 = *(unsigned __int8 **)(a5 + 152);
          if ( v8 > 0 )
          {
            do
            {
              if ( !*(_DWORD *)a4 )
                break;
              if ( off_4BBF90[0][*v20] < 0 && *(_DWORD *)a4 > 1u )
              {
                *(_BYTE *)(*(_DWORD *)a3)++ = *v20++;
                --*(_DWORD *)a4;
              }
              *(_BYTE *)(*(_DWORD *)a3)++ = *v20++;
              --*(_DWORD *)a4;
              --String1a;
            }
            while ( (int)String1a > 0 );
          }
          goto LABEL_73;
        case 'y':
          if ( v8 == 2 )
          {
            v27 = 121;
          }
          else
          {
            if ( v8 != 4 )
              goto LABEL_12;
            v27 = 89;
          }
          break;
        default:
          goto LABEL_12;
      }
    }
    else
    {
      switch ( v10 )
      {
        case 'd':
          v17 = v8 - 1;
          if ( v17 )
          {
            v18 = v17 - 1;
            if ( v18 )
            {
              v19 = v18 - 1;
              if ( v19 )
              {
                if ( v19 != 1 )
                  goto LABEL_12;
                v27 = 65;
              }
              else
              {
                v27 = 97;
              }
              break;
            }
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 100;
          break;
        case '\'':
          if ( (v8 & 1) != 0 )
          {
            for ( v5 += v8; ; ++v5 )
            {
              v16 = *v5;
              if ( !*v5 || !*(_DWORD *)a4 )
                break;
              if ( v16 == 39 )
              {
                ++v5;
                goto LABEL_15;
              }
              if ( off_4BBF90[0][v16] < 0 && *(_DWORD *)a4 > 1u )
              {
                *(_BYTE *)(*(_DWORD *)a3)++ = v16;
                ++v5;
                --*(_DWORD *)a4;
              }
              *(_BYTE *)(*(_DWORD *)a3)++ = *v5;
              --*(_DWORD *)a4;
            }
          }
          else
          {
            v5 += v8;
          }
          continue;
        case 'A':
          goto LABEL_30;
        case 'H':
          v14 = v8 - 1;
          if ( v14 )
          {
            if ( v14 != 1 )
              goto LABEL_12;
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 72;
          break;
        case 'M':
          v11 = v8 - 1;
          if ( v11 )
          {
            v12 = v11 - 1;
            if ( v12 )
            {
              v13 = v12 - 1;
              if ( v13 )
              {
                if ( v13 != 1 )
                  goto LABEL_12;
                v27 = 66;
              }
              else
              {
                v27 = 98;
              }
              break;
            }
          }
          else
          {
            dword_4C1EDC = 1;
          }
          v27 = 109;
          break;
        case 'a':
LABEL_30:
          if ( !_strcmpi(v5, String2) )
          {
            v15 = v5 + 5;
            goto LABEL_34;
          }
          if ( !_strcmpi(v5, aAP) )
          {
            v15 = v5 + 3;
LABEL_34:
            v26 = v15;
          }
          v27 = 112;
          break;
        default:
          goto LABEL_12;
      }
    }
    _expandtime(v27, a2, a3, a4, a5);
LABEL_73:
    v5 = v26;
LABEL_15:
    ;
  }
}
// 47AD24: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4C1EDC: using guessed type int dword_4C1EDC;

//----- (0047B4C1) --------------------------------------------------------
int __cdecl __getlocaleinfo(int a1, LCID Locale, LCTYPE LCType, int a4)
{
  char *v4; // edi
  size_t v5; // esi
  size_t v6; // eax
  int v7; // esi
  CHAR *v8; // eax
  char *v9; // eax
  WCHAR *v11; // esi
  unsigned __int8 v12; // bl
  int v13; // eax
  char Source[128]; // [esp+Ch] [ebp-80h] BYREF
  int v15; // [esp+94h] [ebp+8h]

  if ( a1 == 1 )
  {
    v4 = Source;
    v15 = 0;
    v5 = __crtGetLocaleInfoA(Locale, LCType, Source, 128, 0);
    if ( !v5 )
    {
      if ( ((int (__cdecl *)())dword_4A7260)() != 122 )
        return -1;
      v6 = __crtGetLocaleInfoA(Locale, LCType, 0, 0, 0);
      v7 = v6;
      if ( !v6 )
        return -1;
      v8 = (CHAR *)sub_46D9FD(v6);
      v4 = v8;
      if ( !v8 )
        return -1;
      v15 = 1;
      v5 = __crtGetLocaleInfoA(Locale, LCType, v8, v7, 0);
      if ( !v5 )
        goto LABEL_9;
    }
    v9 = (char *)sub_46D9FD(v5);
    *(_DWORD *)a4 = v9;
    if ( !v9 )
    {
      if ( !v15 )
        return -1;
LABEL_9:
      sub_46D360((unsigned int)v4);
      return -1;
    }
    strncpy(v9, v4, v5);
    if ( v15 )
      sub_46D360((unsigned int)v4);
  }
  else
  {
    if ( a1 )
      return -1;
    v11 = word_4C1EB8;
    if ( !__crtGetLocaleInfoW(Locale, LCType, word_4C1EB8, 4, 0) )
      return -1;
    *(_BYTE *)a4 = 0;
    do
    {
      v12 = *(_BYTE *)v11;
      if ( (int)dword_4BC19C <= 1 )
        v13 = off_4BBF90[0][v12] & 4;
      else
        v13 = _isctype_0(v12, 4);
      if ( !v13 )
        break;
      ++v11;
      *(_BYTE *)a4 = v12 + 10 * *(_BYTE *)a4 - 48;
    }
    while ( (int)v11 < (int)&unk_4C1EC0 );
  }
  return 0;
}
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (0047B5FF) --------------------------------------------------------
int __cdecl __crtGetStringTypeW(DWORD dwInfoType, LPCWSTR lpWideCharStr, int cchWideChar, LPWORD Dst, UINT CodePage, LCID Locale)
{
  int v6; // eax
  int v8; // eax
  size_t v9; // esi
  int v10; // eax
  void *v11; // esp
  int v12; // eax
  void *v13; // esp
  LCID v14; // eax
  _WORD *v15; // esi
  _WORD v16[6]; // [esp+0h] [ebp-38h] BYREF
  _WORD *v17; // [esp+Ch] [ebp-2Ch]
  int v18; // [esp+10h] [ebp-28h]
  _WORD *v19; // [esp+14h] [ebp-24h]
  int v20; // [esp+18h] [ebp-20h]
  int v21; // [esp+1Ch] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  v6 = dword_4C1EC4;
  if ( !dword_4C1EC4 )
  {
    if ( dword_4A7178(1, &unk_4AF64C, 1, &v21) )
    {
      v6 = 1;
    }
    else
    {
      if ( !dword_4A717C(0, 1, &unk_4AF648, 1, &v21) )
        return 0;
      v6 = 2;
    }
    dword_4C1EC4 = v6;
  }
  if ( v6 == 1 )
    return dword_4A7178(dwInfoType, lpWideCharStr, cchWideChar, Dst);
  if ( v6 == 2 )
  {
    if ( !CodePage )
      CodePage = dword_4C1C1C;
    v8 = dword_4A71B4(CodePage, 544, lpWideCharStr, cchWideChar, 0, 0, 0, 0);
    v9 = v8;
    v18 = v8;
    if ( v8 )
    {
      v10 = v8 + 3;
      LOBYTE(v10) = v10 & 0xFC;
      v11 = alloca(v10);
      ms_exc.old_esp = (DWORD)v16;
      v17 = v16;
      memset(v16, 0, v9);
      ms_exc.registration.TryLevel = -1;
      if ( v17 )
      {
        if ( dword_4A71B4(CodePage, 544, lpWideCharStr, cchWideChar, v17, v9, 0, 0) )
        {
          v12 = 2 * v9 + 5;
          LOBYTE(v12) = v12 & 0xFC;
          v13 = alloca(v12);
          ms_exc.old_esp = (DWORD)v16;
          v19 = v16;
          ms_exc.registration.TryLevel = -1;
          if ( v16 )
          {
            v14 = Locale;
            if ( !Locale )
              v14 = dword_4C1C0C;
            v15 = &v16[cchWideChar];
            *v15 = -1;
            *(v15 - 1) = -1;
            v20 = dword_4A717C(v14, dwInfoType, v17, v18, v16);
            if ( *(v15 - 1) != 0xFFFF && *v15 == 0xFFFF )
            {
              sub_46CAB0((unsigned int)Dst, v16, 2 * cchWideChar);
              return v20;
            }
          }
        }
      }
    }
  }
  return 0;
}
// 4A7178: using guessed type int (__stdcall *dword_4A7178)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A717C: using guessed type int (__stdcall *dword_4A717C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C1EC4: using guessed type int dword_4C1EC4;

//----- (0047B7C4) --------------------------------------------------------
char *__cdecl _itoa(int Value, char *Buffer, int Radix)
{
  if ( Radix == 10 && Value < 0 )
    xtoa(Value, Buffer, 0xAu, 1);
  else
    xtoa(Value, Buffer, Radix, 0);
  return Buffer;
}

//----- (0047B7F1) --------------------------------------------------------
char __cdecl xtoa(unsigned int a1, char *a2, unsigned int a3, int a4)
{
  char *v4; // ecx
  unsigned int v5; // esi
  char *v6; // edi
  int v7; // ebx
  bool v8; // cc
  char v9; // bl
  char *v10; // ecx
  char result; // al

  v4 = a2;
  if ( a4 )
  {
    *a2 = 45;
    v4 = a2 + 1;
    v5 = -a1;
  }
  else
  {
    v5 = a1;
  }
  v6 = v4;
  do
  {
    v7 = v5 % a3;
    v8 = v5 % a3 <= 9;
    v5 /= a3;
    if ( v8 )
      v9 = v7 + 48;
    else
      v9 = v7 + 87;
    *v4++ = v9;
  }
  while ( v5 );
  *v4 = 0;
  v10 = v4 - 1;
  do
  {
    result = *v10;
    *v10 = *v6;
    *v6 = result;
    --v10;
    ++v6;
  }
  while ( v6 < v10 );
  return result;
}

//----- (0047B8C3) --------------------------------------------------------
char *__stdcall x64toa(__int64 a1, char *a2, unsigned int a3, int a4)
{
  char *v4; // esi
  int v5; // ebx
  unsigned int v6; // edi
  unsigned __int64 v7; // rax
  char *v8; // esi
  char v9; // cl
  char *result; // eax
  char *v11; // [esp+1Ch] [ebp+10h]
  unsigned int v12; // [esp+24h] [ebp+18h]

  v4 = a2;
  if ( a4 )
  {
    *a2 = 45;
    v4 = a2 + 1;
    v5 = -(int)a1;
    v6 = (unsigned __int64)-a1 >> 32;
  }
  else
  {
    v6 = HIDWORD(a1);
    v5 = a1;
  }
  v11 = v4;
  do
  {
    v12 = __PAIR64__(v6, v5) % a3;
    v7 = __PAIR64__(v6, v5) / a3;
    v6 = HIDWORD(v7);
    v5 = v7;
    if ( v12 <= 9 )
      LOBYTE(v7) = v12 + 48;
    else
      LOBYTE(v7) = v12 + 87;
    *v4++ = v7;
  }
  while ( HIDWORD(v7) || v5 );
  *v4 = 0;
  v8 = v4 - 1;
  do
  {
    v9 = *v8;
    *v8 = *v11;
    *v11 = v9;
    --v8;
    result = v11 + 1;
    v11 = result;
  }
  while ( result < v8 );
  return result;
}

//----- (0047B970) --------------------------------------------------------
int __cdecl _strcmpi(const char *String1, const char *String2)
{
  int result; // eax
  char v5; // t0
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  int v9; // [esp-4h] [ebp-14h]
  int v10; // [esp+0h] [ebp-10h]

  if ( *((_DWORD *)&unk_4C1C04 + 2) )
  {
    _InterlockedIncrement(&dword_4C3248);
    if ( dword_4C3244 > 0 )
    {
      _InterlockedDecrement(&dword_4C3248);
      _lock(19);
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    v6 = 255;
    v7 = 0;
    while ( (_BYTE)v6 )
    {
      LOBYTE(v6) = *String2++;
      LOBYTE(v7) = *String1++;
      if ( (_BYTE)v6 != (_BYTE)v7 )
      {
        v9 = v6;
        v7 = tolower_0(v7);
        v6 = tolower_0(v9);
        if ( (_BYTE)v7 != (_BYTE)v6 )
        {
          v6 = -((unsigned __int8)v7 < (unsigned __int8)v6) - (((unsigned __int8)v7 < (unsigned __int8)v6) - 1);
          break;
        }
      }
    }
    v8 = v6;
    if ( v10 )
      sub_46FA37(19);
    else
      _InterlockedDecrement(&dword_4C3248);
    result = v8;
  }
  else
  {
    LOBYTE(result) = -1;
    while ( (_BYTE)result )
    {
      LOBYTE(result) = *String2++;
      BYTE1(result) = *String1++;
      if ( BYTE1(result) != (_BYTE)result )
      {
        v5 = BYTE1(result);
        BYTE1(result) = ((unsigned __int8)(result - 65) < 0x1Au ? 0x20 : 0) + result;
        LOBYTE(result) = ((unsigned __int8)(v5 - 65) < 0x1Au ? 0x20 : 0) + v5;
        if ( (_BYTE)result != BYTE1(result) )
        {
          LOBYTE(result) = -((unsigned __int8)result < BYTE1(result)) - (((unsigned __int8)result < BYTE1(result)) - 1);
          break;
        }
      }
    }
    result = (char)result;
  }
  return result;
}
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (0047BA40) --------------------------------------------------------
int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount)
{
  int v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  bool v8; // cf
  unsigned int v9; // eax
  unsigned int v10; // ebx
  bool v11; // cf
  int v12; // ebx
  int v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]
  int v16; // [esp+0h] [ebp-10h]

  v3 = MaxCount;
  if ( MaxCount )
  {
    if ( *((_DWORD *)&unk_4C1C04 + 2) )
    {
      _InterlockedIncrement(&dword_4C3248);
      if ( dword_4C3244 > 0 )
      {
        _InterlockedDecrement(&dword_4C3248);
        _lock(19);
        v16 = 1;
        v3 = MaxCount;
      }
      else
      {
        v16 = 0;
      }
      v9 = 0;
      v10 = 0;
      do
      {
        LOBYTE(v9) = *String1;
        LOBYTE(v10) = *String2;
        if ( !v9 || !v10 )
          break;
        ++String1;
        ++String2;
        v15 = v3;
        v14 = v9;
        v10 = tolower_0(v10);
        v9 = tolower_0(v14);
        v11 = v9 < v10;
        if ( v9 != v10 )
          goto LABEL_25;
        v3 = v15 - 1;
      }
      while ( v15 != 1 );
      v3 = 0;
      v11 = v9 < v10;
      if ( v9 == v10 )
        goto LABEL_27;
LABEL_25:
      v3 = -1;
      if ( !v11 )
        v3 = 1;
LABEL_27:
      if ( v16 )
      {
        v12 = v3;
        sub_46FA37(19);
        v3 = v12;
      }
      else
      {
        _InterlockedDecrement(&dword_4C3248);
      }
    }
    else
    {
      do
      {
        v6 = *String1;
        v7 = *String2;
        if ( !*String1 || !v7 )
          break;
        ++String1;
        ++String2;
        if ( v6 >= 0x41u && v6 <= 0x5Au )
          v6 += 32;
        if ( v7 >= 0x41u && v7 <= 0x5Au )
          v7 += 32;
        v8 = v6 < v7;
        if ( v6 != v7 )
          goto LABEL_14;
        --v3;
      }
      while ( v3 );
      v3 = 0;
      v8 = v6 < v7;
      if ( v6 == v7 )
        return v3;
LABEL_14:
      v3 = -1;
      if ( !v8 )
        v3 = 1;
    }
  }
  return v3;
}
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (0047BB41) --------------------------------------------------------
int __cdecl _mbsnbicoll_0(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount)
{
  int result; // eax
  int v4; // eax

  if ( !MaxCount )
    return 0;
  v4 = __crtCompareStringA_0(dword_4C2104, 1u, (PCNZCH)Str1, MaxCount, (PCNZCH)Str2, MaxCount, dword_4C1EE0);
  if ( v4 )
    result = v4 - 2;
  else
    result = 0x7FFFFFFF;
  return result;
}
// 4C2104: using guessed type int dword_4C2104;

//----- (0047BB80) --------------------------------------------------------
int __wtomb_environ_0()
{
  int *v0; // esi
  int v1; // eax
  int (__stdcall *v2)(int, _DWORD, int, int, int, size_t, _DWORD, _DWORD); // ebx
  size_t v3; // eax
  size_t v4; // ebp
  int v5; // eax
  char *v7; // [esp+40h] [ebp-4h]

  v0 = (int *)dword_4C1B40;
  v1 = *(_DWORD *)dword_4C1B40;
  if ( !*(_DWORD *)dword_4C1B40 )
    return 0;
  v2 = dword_4A71B4;
  while ( 1 )
  {
    v3 = v2(1, 0, v1, -1, 0, 0, 0, 0);
    v4 = v3;
    if ( !v3 )
      break;
    v5 = sub_46D9FD(v3);
    v7 = (char *)v5;
    if ( !v5 || !v2(1, 0, *v0, -1, v5, v4, 0, 0) )
      break;
    __crtsetenv_0(v7, 0);
    v1 = v0[1];
    ++v0;
    if ( !v1 )
      return 0;
  }
  return -1;
}
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1B40: using guessed type int dword_4C1B40;

//----- (0047BC47) --------------------------------------------------------
int __usercall _chsize_lk@<eax>(int a1@<edi>, int FileHandle, LONG lDistanceToMove)
{
  int v3; // esi
  int v4; // eax
  int v5; // edi
  DWORD v6; // eax
  int v7; // eax
  intptr_t v8; // eax
  int v9; // eax
  int v10; // edi
  char v13[4096]; // [esp+8h] [ebp-1004h] BYREF
  LONG v14; // [esp+1008h] [ebp-4h]
  int v15; // [esp+1018h] [ebp+Ch]

  v3 = 0;
  v14 = _lseek_lk(FileHandle, 0, 1u);
  if ( v14 == -1 )
    return -1;
  v4 = _lseek_lk(FileHandle, 0, 2u);
  if ( v4 == -1 )
    return -1;
  v5 = lDistanceToMove - v4;
  if ( lDistanceToMove - v4 <= 0 )
  {
    if ( lDistanceToMove - v4 < 0 )
    {
      _lseek_lk(FileHandle, lDistanceToMove, 0);
      v8 = _get_osfhandle(FileHandle);
      v9 = dword_4A7254(v8);
      v3 = (v9 != 0) - 1;
      if ( !v9 )
      {
        *sub_46D641() = 13;
        v10 = ((int (__cdecl *)(int))dword_4A7260)(a1);
        *sub_46D64A() = v10;
      }
    }
  }
  else
  {
    memset(v13, 0, sizeof(v13));
    v15 = _setmode_lk(FileHandle, 0x8000);
    while ( 1 )
    {
      v6 = 4096;
      if ( v5 < 4096 )
        v6 = v5;
      v7 = _write_lk(FileHandle, v13, v6);
      if ( v7 == -1 )
        break;
      v5 -= v7;
      if ( v5 <= 0 )
        goto LABEL_13;
    }
    if ( *sub_46D64A() == 5 )
      *sub_46D641() = 13;
    v3 = -1;
LABEL_13:
    _setmode_lk(FileHandle, v15);
  }
  _lseek_lk(FileHandle, v14, 0);
  return v3;
}
// 47BC47: could not find valid save-restore pair for edi
// 4A7254: using guessed type int (__stdcall *dword_4A7254)(_DWORD);
// 4A7260: using guessed type int (__cdecl *dword_4A7260)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047BD6C) --------------------------------------------------------
int __cdecl __ld12mul_0(int a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // di
  int result; // eax
  int v8; // ecx
  int v9; // edi
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // ebx
  _BYTE v13[12]; // [esp+Ch] [ebp-24h] BYREF
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h]
  int v16; // [esp+20h] [ebp-10h]
  unsigned __int16 *v17; // [esp+24h] [ebp-Ch]
  unsigned __int16 *v18; // [esp+28h] [ebp-8h]
  _WORD *v19; // [esp+2Ch] [ebp-4h]
  int v20; // [esp+38h] [ebp+8h]
  int v21; // [esp+38h] [ebp+8h]
  int i; // [esp+3Ch] [ebp+Ch]

  v4 = *(_WORD *)(a2 + 10);
  v15 = 0;
  *(_DWORD *)v13 = 0;
  *(_DWORD *)&v13[4] = 0;
  *(_DWORD *)&v13[8] = 0;
  v5 = *(_WORD *)(a1 + 10);
  v6 = v5 ^ v4;
  result = v5 & 0x7FFF;
  v8 = v4 & 0x7FFF;
  v9 = v6 & 0x8000;
  v10 = v8 + result;
  v20 = v8 + result;
  if ( (unsigned __int16)result < 0x7FFFu && (unsigned __int16)v8 < 0x7FFFu && v10 <= 0xBFFDu )
  {
    if ( v10 <= 0x3FBFu )
    {
      result = 0;
LABEL_16:
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      return result;
    }
    if ( (_WORD)result || (++v20, (*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0) )
    {
      result = 0;
    }
    else
    {
      result = 0;
      if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
        goto LABEL_45;
    }
    if ( !(_WORD)v8 )
    {
      ++v20;
      if ( (*(_DWORD *)(a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD *)(a2 + 4) && !*(_DWORD *)a2 )
        goto LABEL_16;
    }
    v16 = 0;
    v19 = &v13[4];
    for ( i = 5; i > 0; --i )
    {
      v18 = (unsigned __int16 *)(a1 + 2 * v16);
      v17 = (unsigned __int16 *)(a2 + 8);
      v14 = i;
      do
      {
        if ( __addl_0(*((_DWORD *)v19 - 1), *v17 * *v18, (unsigned int *)v19 - 1) )
          ++*v19;
        ++v18;
        --v17;
        --v14;
      }
      while ( v14 );
      ++v19;
      ++v16;
    }
    v21 = v20 + 49154;
    if ( (__int16)v21 <= 0 )
      goto LABEL_49;
    do
    {
      if ( v13[11] < 0 )
        break;
      __shl_12(v13);
      v21 += 0xFFFF;
    }
    while ( (__int16)v21 > 0 );
    if ( (__int16)v21 <= 0 )
    {
LABEL_49:
      v21 += 0xFFFF;
      if ( (v21 & 0x8000u) != 0 )
      {
        v11 = -(__int16)v21;
        v21 -= (__int16)v21;
        v12 = v11;
        do
        {
          if ( (v13[0] & 1) != 0 )
            ++v15;
          __shr_12((int *)v13);
          --v12;
        }
        while ( v12 );
        if ( v15 )
          v13[0] |= 1u;
      }
    }
    if ( *(_WORD *)v13 > 0x8000u || (*(_DWORD *)v13 & 0x1FFFF) == 98304 )
    {
      if ( *(_DWORD *)&v13[2] == -1 )
      {
        *(_DWORD *)&v13[2] = 0;
        if ( *(_DWORD *)&v13[6] == -1 )
        {
          *(_DWORD *)&v13[6] = 0;
          if ( *(_WORD *)&v13[10] == 0xFFFF )
          {
            ++v21;
            *(_WORD *)&v13[10] = 0x8000;
          }
          else
          {
            ++*(_WORD *)&v13[10];
          }
        }
        else
        {
          ++*(_DWORD *)&v13[6];
        }
      }
      else
      {
        ++*(_DWORD *)&v13[2];
      }
    }
    result = v21;
    if ( (unsigned __int16)v21 < 0x7FFFu )
    {
      result = v9 | v21;
      *(_WORD *)a1 = *(_WORD *)&v13[2];
      *(_DWORD *)(a1 + 2) = *(_DWORD *)&v13[4];
      *(_DWORD *)(a1 + 6) = *(_DWORD *)&v13[8];
LABEL_45:
      *(_WORD *)(a1 + 10) = result;
      return result;
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = (_WORD)v9 != 0 ? -32768 : 2147450880;
  return result;
}
// 47BE35: conditional instruction was optimized away because of '%arg_4.4>=1'

//----- (0047BF8C) --------------------------------------------------------
void __cdecl __multtenpow12_0(_WORD *a1, int a2, int a3)
{
  char *v3; // ebx
  char v4; // al
  int v5; // eax
  char *v6; // esi
  _DWORD *v7; // esi
  __int64 v8; // [esp+4h] [ebp-Ch] BYREF
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (char *)&unk_4BD2B0 - 96;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      a2 = -a2;
      v3 = (char *)&unk_4BD410 - 96;
    }
    if ( !a3 )
      *a1 = 0;
    while ( a2 )
    {
      v4 = a2;
      v3 += 84;
      a2 >>= 3;
      v5 = v4 & 7;
      if ( v5 )
      {
        v6 = &v3[12 * v5];
        if ( *(_WORD *)v6 >= 0x8000u )
        {
          LODWORD(v8) = *(_DWORD *)v6;
          v7 = v6 + 4;
          HIDWORD(v8) = *v7;
          v9 = v7[1];
          --*(_DWORD *)((char *)&v8 + 2);
          v6 = (char *)&v8;
        }
        __ld12mul_0((int)a1, (int)v6);
      }
    }
  }
}

//----- (0047C008) --------------------------------------------------------
int __cdecl __crtGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpWideCharStr, int cchWideChar, UINT CodePage)
{
  int v5; // eax
  int result; // eax
  int v7; // eax
  int v8; // eax
  void *v9; // esp
  int v10; // [esp-4h] [ebp-34h]
  _DWORD v11[5]; // [esp+0h] [ebp-30h] BYREF
  int v12; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  v5 = dword_4C1ECC;
  if ( !dword_4C1ECC )
  {
    if ( dword_4A7148(0, 1, 0, 0) )
    {
      v10 = 1;
    }
    else
    {
      if ( !dword_4A7168(0, 1, 0, 0) )
        return 0;
      v10 = 2;
    }
    v5 = v10;
    dword_4C1ECC = v10;
  }
  if ( v5 == 1 )
    return dword_4A7148(Locale, LCType, lpWideCharStr, cchWideChar);
  if ( v5 != 2 )
    return 0;
  if ( !CodePage )
    CodePage = dword_4C1C1C;
  v7 = dword_4A7168(Locale, LCType, 0, 0);
  v12 = v7;
  if ( !v7 )
    return 0;
  v8 = v7 + 3;
  LOBYTE(v8) = v8 & 0xFC;
  v9 = alloca(v8);
  ms_exc.old_esp = (DWORD)v11;
  v11[4] = v11;
  ms_exc.registration.TryLevel = -1;
  if ( !v11 || !dword_4A7168(Locale, LCType, v11, v12) )
    return 0;
  if ( cchWideChar )
    result = dword_4A71B0(CodePage, 1, v11, -1, lpWideCharStr, cchWideChar);
  else
    result = dword_4A71B0(CodePage, 1, v11, -1, 0, 0);
  return result;
}
// 4A7148: using guessed type int (__stdcall *dword_4A7148)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7168: using guessed type int (__stdcall *dword_4A7168)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B0: using guessed type int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1ECC: using guessed type int dword_4C1ECC;

//----- (0047C11B) --------------------------------------------------------
int __cdecl __crtGetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpMultiByteStr, int cbMultiByte, UINT CodePage)
{
  int v5; // eax
  int result; // eax
  int v7; // eax
  int v8; // eax
  void *v9; // esp
  int v10; // [esp-4h] [ebp-34h]
  _DWORD v11[5]; // [esp+0h] [ebp-30h] BYREF
  int v12; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  v5 = dword_4C1ED0;
  if ( !dword_4C1ED0 )
  {
    if ( dword_4A7148(0, 1, 0, 0) )
    {
      v10 = 1;
    }
    else
    {
      if ( !dword_4A7168(0, 1, 0, 0) )
        return 0;
      v10 = 2;
    }
    v5 = v10;
    dword_4C1ED0 = v10;
  }
  if ( v5 == 2 )
    return dword_4A7168(Locale, LCType, lpMultiByteStr, cbMultiByte);
  if ( v5 != 1 )
    return 0;
  if ( !CodePage )
    CodePage = dword_4C1C1C;
  v7 = dword_4A7148(Locale, LCType, 0, 0);
  v12 = v7;
  if ( !v7 )
    return 0;
  v8 = 2 * v7 + 3;
  LOBYTE(v8) = v8 & 0xFC;
  v9 = alloca(v8);
  ms_exc.old_esp = (DWORD)v11;
  v11[4] = v11;
  ms_exc.registration.TryLevel = -1;
  if ( !v11 || !dword_4A7148(Locale, LCType, v11, v12) )
    return 0;
  if ( cbMultiByte )
    result = dword_4A71B4(CodePage, 544, v11, -1, lpMultiByteStr, cbMultiByte, 0, 0);
  else
    result = dword_4A71B4(CodePage, 544, v11, -1, 0, 0, 0, 0);
  return result;
}
// 4A7148: using guessed type int (__stdcall *dword_4A7148)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A7168: using guessed type int (__stdcall *dword_4A7168)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4A71B4: using guessed type int (__stdcall *dword_4A71B4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1ED0: using guessed type int dword_4C1ED0;

//----- (0047C239) --------------------------------------------------------
int __cdecl __crtCompareStringA_0(LCID Locale, DWORD dwCmpFlags, PCNZCH lpMultiByteStr, int cbMultiByte, PCNZCH lpString2, int cchCount2, UINT CodePage)
{
  int v7; // esi
  char *v9; // eax
  unsigned __int8 v10; // dl
  char *i; // eax
  unsigned __int8 v12; // dl
  int v13; // eax
  int v14; // eax
  void *v15; // esp
  int (__stdcall *v16)(UINT, int, PCNZCH, int, _DWORD, _DWORD); // esi
  int v17; // eax
  int v18; // esi
  int v19; // eax
  void *v20; // esp
  int v21; // [esp-Ch] [ebp-58h]
  _BYTE v23[16]; // [esp+0h] [ebp-4Ch] BYREF
  unsigned int v24; // [esp+10h] [ebp-3Ch] BYREF
  char v25[14]; // [esp+16h] [ebp-36h] BYREF
  _BYTE *v26; // [esp+24h] [ebp-28h]
  _BYTE *v27; // [esp+28h] [ebp-24h]
  int v28; // [esp+2Ch] [ebp-20h]
  int v29; // [esp+30h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  if ( !dword_4C1ED4 )
  {
    if ( dword_4A7140(0, 0, &unk_4AF64C, 1, &unk_4AF64C, 1) )
    {
      dword_4C1ED4 = 1;
    }
    else
    {
      if ( !dword_4A7144(0, 0, &unk_4AF648, 1, &unk_4AF648, 1) )
        return 0;
      dword_4C1ED4 = 2;
    }
  }
  v7 = cbMultiByte;
  if ( cbMultiByte > 0 )
    v7 = (int)sub_47C4B6(lpMultiByteStr, (_BYTE *)cbMultiByte);
  if ( cchCount2 > 0 )
    cchCount2 = (int)sub_47C4B6(lpString2, (_BYTE *)cchCount2);
  if ( dword_4C1ED4 == 2 )
    return dword_4A7144(Locale, dwCmpFlags, lpMultiByteStr, v7, lpString2, cchCount2);
  if ( dword_4C1ED4 == 1 )
  {
    if ( !CodePage )
      CodePage = dword_4C1C1C;
    if ( !v7 || !cchCount2 )
    {
      if ( v7 == cchCount2 )
        return 2;
      if ( cchCount2 > 1 )
        return 1;
      if ( v7 > 1 )
        return 3;
      if ( !dword_4A7174(CodePage, &v24) )
        return 0;
      if ( v7 > 0 )
      {
        if ( v24 >= 2 )
        {
          v9 = v25;
          if ( v25[0] )
          {
            while ( 1 )
            {
              v10 = v9[1];
              if ( !v10 )
                break;
              if ( (unsigned int)*lpMultiByteStr >= (unsigned __int8)*v9 && (unsigned int)*lpMultiByteStr <= v10 )
                return 2;
              v9 += 2;
              if ( !*v9 )
                return 3;
            }
          }
        }
        return 3;
      }
      if ( cchCount2 > 0 )
      {
        if ( v24 >= 2 )
        {
          for ( i = v25; *i; i += 2 )
          {
            v12 = i[1];
            if ( !v12 )
              break;
            if ( (unsigned int)*lpString2 >= (unsigned __int8)*i && (unsigned int)*lpString2 <= v12 )
              return 2;
          }
        }
        return 1;
      }
    }
    v13 = dword_4A71B0(CodePage, 9, lpMultiByteStr, v7, 0, 0);
    v29 = v13;
    if ( v13 )
    {
      v14 = 2 * v13 + 3;
      LOBYTE(v14) = v14 & 0xFC;
      v15 = alloca(v14);
      ms_exc.old_esp = (DWORD)v23;
      v27 = v23;
      ms_exc.registration.TryLevel = -1;
      if ( v23 )
      {
        v21 = v7;
        v16 = (int (__stdcall *)(UINT, int, PCNZCH, int, _DWORD, _DWORD))dword_4A71B0;
        if ( dword_4A71B0(CodePage, 1, lpMultiByteStr, v21, v27, v29) )
        {
          v17 = v16(CodePage, 9, lpString2, cchCount2, 0, 0);
          v18 = v17;
          v28 = v17;
          if ( v17 )
          {
            v19 = 2 * v17 + 3;
            LOBYTE(v19) = v19 & 0xFC;
            v20 = alloca(v19);
            ms_exc.old_esp = (DWORD)v23;
            v26 = v23;
            ms_exc.registration.TryLevel = -1;
            if ( v23 )
            {
              if ( dword_4A71B0(CodePage, 1, lpString2, cchCount2, v23, v18) )
                return dword_4A7140(Locale, dwCmpFlags, v27, v29, v23, v18);
            }
          }
        }
      }
    }
  }
  return 0;
}
// 4A7140: using guessed type int (__stdcall *dword_4A7140)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7144: using guessed type int (__stdcall *dword_4A7144)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A7174: using guessed type int (__stdcall *dword_4A7174)(_DWORD, _DWORD);
// 4A71B0: using guessed type int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4C1ED4: using guessed type int dword_4C1ED4;

//----- (0047C4B6) --------------------------------------------------------
_BYTE *__cdecl sub_47C4B6(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *result; // eax

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = a2;
  else
    result = (_BYTE *)(v2 - a1);
  return result;
}

//----- (0047C4E1) --------------------------------------------------------
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int a2)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // esi
  char **v4; // eax
  BOOL v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  size_t v14; // eax
  int v15; // esi
  unsigned __int8 *v16; // eax
  unsigned int v17; // [esp-4h] [ebp-18h]
  unsigned __int8 *v18; // [esp+Ch] [ebp-8h]
  void *v19; // [esp+10h] [ebp-4h]

  if ( !lpMultiByteStr )
    return -1;
  v2 = _mbschr((const unsigned __int8 *)lpMultiByteStr, 0x3Du);
  v3 = v2;
  v18 = v2;
  if ( !v2 || lpMultiByteStr == (char *)v2 )
    return -1;
  v4 = (char **)dword_4C1B38;
  v5 = v3[1] == 0;
  if ( dword_4C1B38 == dword_4C1B3C )
  {
    v4 = copy_environ_0((_DWORD *)dword_4C1B38);
    dword_4C1B38 = (int)v4;
  }
  if ( !v4 )
  {
    if ( a2 && dword_4C1B40 )
    {
      if ( __wtomb_environ_0() )
        return -1;
    }
    else
    {
      if ( v5 )
        return 0;
      v7 = (_DWORD *)sub_46D9FD(4u);
      dword_4C1B38 = (int)v7;
      if ( !v7 )
        return -1;
      *v7 = 0;
      if ( !dword_4C1B40 )
      {
        v8 = (_DWORD *)sub_46D9FD(4u);
        dword_4C1B40 = (int)v8;
        if ( !v8 )
          return -1;
        *v8 = 0;
      }
    }
  }
  v9 = (_DWORD *)dword_4C1B38;
  v19 = (void *)dword_4C1B38;
  v10 = findenv_0(lpMultiByteStr, v3 - (unsigned __int8 *)lpMultiByteStr);
  v11 = v10;
  if ( v10 >= 0 && *v9 )
  {
    if ( !v5 )
    {
      v9[v10] = lpMultiByteStr;
      goto LABEL_31;
    }
    v17 = v9[v10];
    v12 = &v9[v10];
    sub_46D360(v17);
    while ( *v12 )
    {
      ++v11;
      *v12 = v12[1];
      ++v12;
    }
    v13 = sub_46DC4A(v19, 4 * v11);
    if ( !v13 )
    {
LABEL_31:
      if ( a2 )
      {
        v14 = strlen(lpMultiByteStr);
        v15 = sub_46D9FD(v14 + 2);
        if ( v15 )
        {
          sub_476F50();
          v16 = &v18[v15 - (_DWORD)lpMultiByteStr];
          *v16 = 0;
          dword_4A7208(v15, !v5 ? (unsigned int)(v16 + 1) : 0);
          sub_46D360(v15);
        }
      }
      return 0;
    }
LABEL_30:
    dword_4C1B38 = (int)v13;
    goto LABEL_31;
  }
  if ( !v5 )
  {
    if ( v10 < 0 )
      v11 = -v10;
    v13 = sub_46DC4A(v9, 4 * v11 + 8);
    if ( !v13 )
      return -1;
    v13[v11] = lpMultiByteStr;
    v13[v11 + 1] = 0;
    goto LABEL_30;
  }
  return 0;
}
// 47BB80: using guessed type int __wtomb_environ_0(void);
// 4A7208: using guessed type int (__stdcall *dword_4A7208)(_DWORD, _DWORD);
// 4C1B38: using guessed type int dword_4C1B38;
// 4C1B3C: using guessed type int dword_4C1B3C;
// 4C1B40: using guessed type int dword_4C1B40;

//----- (0047C668) --------------------------------------------------------
int __cdecl findenv_0(PCNZCH lpMultiByteStr, int cchCount2)
{
  _DWORD *v2; // esi
  const unsigned __int8 *v3; // eax
  char v4; // al

  v2 = (_DWORD *)dword_4C1B38;
  v3 = *(const unsigned __int8 **)dword_4C1B38;
  if ( !*(_DWORD *)dword_4C1B38 )
    return -(((int)v2 - dword_4C1B38) >> 2);
  while ( 1 )
  {
    if ( !_mbsnbicoll_0((const unsigned __int8 *)lpMultiByteStr, v3, cchCount2) )
    {
      v4 = *(_BYTE *)(*v2 + cchCount2);
      if ( v4 == 61 || !v4 )
        break;
    }
    v3 = (const unsigned __int8 *)v2[1];
    ++v2;
    if ( !v3 )
      return -(((int)v2 - dword_4C1B38) >> 2);
  }
  return ((int)v2 - dword_4C1B38) >> 2;
}
// 4C1B38: using guessed type int dword_4C1B38;

//----- (0047C6C0) --------------------------------------------------------
char **__cdecl copy_environ_0(_DWORD *a1)
{
  int v1; // ecx
  int *v3; // eax
  int v4; // edx
  char **v5; // esi
  char **v6; // ebp
  const char *v7; // eax
  const char **v8; // ebx

  v1 = 0;
  if ( !a1 )
    return 0;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      v4 = *v3;
      ++v1;
      ++v3;
    }
    while ( v4 );
  }
  v5 = (char **)sub_46D9FD(4 * v1 + 4);
  v6 = v5;
  if ( !v5 )
    _amsg_exit(9u);
  v7 = (const char *)*a1;
  v8 = (const char **)a1;
  while ( v7 )
  {
    ++v8;
    *v5 = _strdup_0(v7);
    v7 = *v8;
    ++v5;
  }
  *v5 = 0;
  return v6;
}

//----- (0047C780) --------------------------------------------------------
int __cdecl _setmode_lk(int a1, int a2)
{
  char *v2; // edx
  char v3; // cl
  char v4; // cl
  int v5; // eax

  v2 = (char *)(dword_4C2120[a1 >> 5] + 36 * (a1 & 0x1F) + 4);
  v3 = *v2;
  if ( a2 == 0x8000 )
  {
    v4 = v3 & 0x7F;
LABEL_5:
    v5 = -((*v2 & 0x80) != 0);
    *v2 = v4;
    LOWORD(v5) = v5 & 0xC000;
    return v5 + 0x8000;
  }
  if ( a2 == 0x4000 )
  {
    v4 = v3 | 0x80;
    goto LABEL_5;
  }
  *sub_46D641() = 22;
  return -1;
}
// 4C2120: using guessed type int dword_4C2120[];

//----- (0047C7E1) --------------------------------------------------------
unsigned __int8 *__cdecl _mbschr(const unsigned __int8 *Str, unsigned int C)
{
  const unsigned __int8 *i; // esi
  unsigned __int16 v4; // bx
  unsigned __int8 v5; // al

  if ( !dword_4C1EFC )
    return (unsigned __int8 *)strchr((const char *)Str, C);
  _lock(25);
  for ( i = Str; ; ++i )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( (byte_4C2001[(unsigned __int8)v4] & 4) != 0 )
    {
      v5 = *++i;
      if ( !v5 )
      {
        sub_46FA37(25);
        return 0;
      }
      if ( C == (v5 | (v4 << 8)) )
      {
        sub_46FA37(25);
        return (unsigned __int8 *)(i - 1);
      }
    }
    else if ( C == *i )
    {
      break;
    }
  }
  sub_46FA37(25);
  return (unsigned __int8 *)(v4 == C ? (unsigned int)i : 0);
}
// 4C1EFC: using guessed type int dword_4C1EFC;

//----- (0047C878) --------------------------------------------------------
char *__cdecl _strdup_0(const char *Source)
{
  size_t v1; // eax
  char *result; // eax

  if ( !Source )
    return 0;
  v1 = strlen(Source);
  if ( !sub_46D9FD(v1 + 1) )
    return 0;
  sub_476F50();
  return result;
}

//----- (0047CA10) --------------------------------------------------------
char __usercall png_create_write_struct@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  return sub_47CA40(a1, a2, a3, a4, a5, a6, 0, 0, 0);
}

//----- (0047CA40) --------------------------------------------------------
char __usercall sub_47CA40@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int (__cdecl *a8)(char *, size_t), void (__cdecl *a9)(char *, unsigned int))
{
  char v9; // fps
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // esi
  int *v13; // esi
  char *v14; // eax
  char v15; // bl
  char v16; // al
  struct _EXCEPTION_REGISTRATION_RECORD *v18; // [esp-Ch] [ebp-6Ch]
  int v19; // [esp-8h] [ebp-68h]
  struct _EXCEPTION_REGISTRATION_RECORD *v20; // [esp-4h] [ebp-64h]
  int v21; // [esp+0h] [ebp-60h]
  char Buffer[80]; // [esp+Ch] [ebp-54h] BYREF
  _DWORD *v23; // [esp+5Ch] [ebp-4h]
  int savedregs; // [esp+60h] [ebp+0h] BYREF

  v10 = sub_487C10(1, a8, a7);
  v11 = v10;
  v23 = v10;
  if ( v10 )
  {
    sub_484D00((int)v10);
    if ( _setjmp3(a1, (int)&savedregs, a2, (int)v11, v11, 0, v20, v21) )
    {
      v12 = v23;
      sub_487DA0((int)v23, v23[43]);
      v23[43] = 0;
      sub_487CB0((unsigned int)v12, a9, a7);
      LOBYTE(v10) = 0;
      return (char)v10;
    }
    v13 = v23;
    sub_487E90(v23, a7, (int)a8, (int)a9);
    sub_484330(v23, a4, a5, a6);
    v14 = a125_0;
    do
    {
      if ( v14[a3 - (_DWORD)a125_0] != *v14 )
        v13[27] |= 0x20000u;
      v15 = *v14++;
    }
    while ( v15 );
    if ( (v13[27] & 0x20000) != 0 )
    {
      if ( !a3 )
        goto LABEL_16;
      v16 = *(_BYTE *)a3;
      if ( *(_BYTE *)a3 != a125_0[0]
        || v16 == 49 && *(_BYTE *)(a3 + 2) != a125_0[2]
        || v16 == 48 && *(char *)(a3 + 2) < 57 )
      {
        sprintf_0(Buffer, "Application was compiled with png.h from libpng-%.20s", (const char *)a3);
        sub_4840E0((int)v13, Buffer);
LABEL_16:
        sprintf_0(Buffer, "Application  is  running with png.c from libpng-%.20s", a125_0);
        sub_4840E0((int)v13, Buffer);
        v13[27] = 0;
        sub_484040(v13, aIncompatibleLi);
      }
    }
    v13[44] = 0x2000;
    v13[43] = sub_487D00(v13, 0x2000u);
    v13[37] = (int)sub_484520;
    v13[38] = (int)sub_4845A0;
    v13[39] = (int)v13;
    switch ( sub_466C10(v13 + 29, a114, 56) )
    {
      case -6:
        sub_484040(v13, aZlibVersionErr);
      case -4:
      case -2:
        sub_484040(v13, aZlibMemoryErro);
      case 0:
        v13[32] = v13[43];
        v13[33] = v13[44];
        sub_4843F0(v13, 0, 0);
        if ( _setjmp3(v15, (int)&savedregs, a3, (int)v13, v13, 0, v18, v19) )
        {
          _NMSG_WRITE_0(0xAu);
          raise(22);
          sub_46E4BD(3);
          LOBYTE(v10) = _abstract_sw(v9);
        }
        else
        {
          LOBYTE(v10) = (_BYTE)v23;
        }
        break;
      default:
        sub_484040(v13, aUnknownZlibErr);
    }
  }
  return (char)v10;
}
// 47CB32: conditional instruction was optimized away because of 'edi.4!=0'
// 47CA74: variable 'v20' is possibly undefined
// 47CA74: variable 'v21' is possibly undefined
// 47CC1A: variable 'v18' is possibly undefined
// 47CC1A: variable 'v19' is possibly undefined

//----- (0047CC80) --------------------------------------------------------
int __cdecl sub_47CC80(int *a1, char *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char *v6; // edi
  char Buffer[80]; // [esp+10h] [ebp-50h] BYREF

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a3 < 0x260 || a4 < 0x120 )
  {
    a1[17] = 0;
    if ( v6 )
    {
      sprintf_0(Buffer, "Application was compiled with png.h from libpng-%.20s", v6);
      sub_4840E0((int)a1, Buffer);
    }
    sprintf_0(Buffer, "Application  is  running with png.c from libpng-%.20s", a125_0);
    sub_4840E0((int)a1, Buffer);
  }
  if ( v5 < 0x260 )
  {
    a1[16] = 0;
    a1[27] = 0;
    sub_484040(a1, aThePngStructAl);
  }
  if ( v4 < 0x120 )
  {
    a1[16] = 0;
    a1[27] = 0;
    sub_484040(a1, aTheInfoStructA);
  }
  return sub_47CD60(&a1, v6, v5);
}

//----- (0047CD60) --------------------------------------------------------
int __cdecl sub_47CD60(_DWORD **a1, _BYTE *a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  char *v4; // eax
  _DWORD *v6; // eax
  int v7; // edx
  char v9[64]; // [esp+Ch] [ebp-40h] BYREF

  v3 = *a1;
  if ( *a2 == a125_0[0] )
  {
    v4 = a125_0;
    while ( *v4++ )
    {
      if ( v4[a2 - a125_0] != *v4 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v3[17] = 0;
    sub_4840E0((int)v3, aApplicationUse);
  }
  qmemcpy(v9, v3, sizeof(v9));
  if ( a3 < 0x260 )
  {
    sub_487C90((unsigned int)v3);
    v6 = sub_487BF0(1);
    *a1 = v6;
    v3 = v6;
  }
  memset(v3, 0, 0x260u);
  qmemcpy(v3, v9, 0x40u);
  v3[44] = 0x2000;
  v3[43] = sub_487D00(v3, 0x2000u);
  v3[37] = sub_484520;
  v3[38] = sub_4845A0;
  v3[39] = v3;
  switch ( sub_466C10(v3 + 29, a114, 56) )
  {
    case -6:
      sub_484040(v3, aZlibVersion);
    case -4:
    case -2:
      sub_484040(v3, aZlibMemory);
    case 0:
      v7 = v3[44];
      v3[32] = v3[43];
      v3[33] = v7;
      return sub_4843F0(v3, 0, 0);
    default:
      sub_484040(v3, aUnknownZlibErr);
  }
}

//----- (0047CEB0) --------------------------------------------------------
char __cdecl sub_47CEB0(int a1, _DWORD *a2)
{
  _DWORD *v2; // ebp
  int v3; // esi
  unsigned int v4; // ebx
  int v5; // eax
  _DWORD *v6; // ebx
  unsigned int v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax

  v2 = a2;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 300) < 8u )
  {
    v4 = *(unsigned __int8 *)(a1 + 300);
    sub_484380((int *)a1, (int)a2 + v4 + 32, 8 - v4);
    *(_BYTE *)(v3 + 300) = 8;
    if ( sub_484480((int)(v2 + 8), v4, 8 - v4) )
    {
      if ( v4 < 4 )
      {
        if ( sub_484480((int)(v2 + 8), v4, 8 - v4 - 4) )
          sub_484040((int *)v3, aNotAPngFile);
      }
      sub_484040((int *)v3, aPngFileCorrupt);
    }
    if ( v4 < 3 )
    {
      v5 = *(_DWORD *)(v3 + 104);
      BYTE1(v5) |= 0x10u;
      *(_DWORD *)(v3 + 104) = v5;
    }
  }
  v6 = (_DWORD *)(v3 + 284);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            sub_484380((int *)v3, (int)&a1, 4);
            v7 = sub_487ED0((unsigned __int8 *)&a1);
            sub_4845C0(v3);
            sub_487F50((int *)v3, (unsigned __int8 *)(v3 + 284), 4u);
            if ( v7 > 0x7FFFFFFF )
              sub_484040((int *)v3, aInvalidChunkLe);
            if ( *v6 != *(_DWORD *)aIhdr )
              break;
            sub_488470(v3, (int)v2, v7);
          }
          if ( *v6 != *(_DWORD *)aIend )
            break;
          sub_488780((int *)v3, (int)v2, v7);
        }
        if ( !sub_484C80(v3, (_DWORD *)(v3 + 284)) )
          break;
        if ( *v6 == *(_DWORD *)aIdat )
        {
          v8 = *(_DWORD *)(v3 + 104);
          LOBYTE(v8) = v8 | 4;
          *(_DWORD *)(v3 + 104) = v8;
        }
        sub_48A480(v3, (int)v2, v7);
        if ( *v6 == *(_DWORD *)aPlte )
        {
          v9 = *(_DWORD *)(v3 + 104);
          LOBYTE(v9) = v9 | 2;
          *(_DWORD *)(v3 + 104) = v9;
        }
        else if ( *v6 == *(_DWORD *)aIdat )
        {
          v10 = *(_DWORD *)(v3 + 104);
          if ( (v10 & 1) == 0 )
            sub_484040((int *)v3, aMissingIhdrBef);
          if ( *(_BYTE *)(v3 + 294) == 3 && (v10 & 2) == 0 )
            sub_484040((int *)v3, aMissingPlteBef);
          return v10;
        }
      }
      if ( *v6 != *(_DWORD *)aPlte )
        break;
      sub_4885E0(v3, (int)v2, v7);
    }
    if ( *v6 == *(_DWORD *)aIdat )
      break;
    if ( *v6 == *(_DWORD *)aBkgd )
    {
      sub_4897A0(v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aChrm )
    {
      sub_488A90((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aGama )
    {
      sub_4887D0((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aHist )
    {
      sub_4899A0(v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aOffs )
    {
      sub_489BE0((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aPcal )
    {
      sub_489CD0((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aScal )
    {
      sub_489F40((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aPhys )
    {
      sub_489AF0((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aSbit )
    {
      sub_488920(v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aSrgb )
    {
      sub_488F90((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aIccp )
    {
      sub_4891A0((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aSplt )
    {
      sub_489360((int *)v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aText )
    {
      sub_48A200(v3, v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aTime )
    {
      sub_48A110(v3, v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aTrns )
    {
      sub_489560(v3, (int)v2, v7);
    }
    else if ( *v6 == *(_DWORD *)aZtxt )
    {
      sub_48A320(v3, v2, v7);
    }
    else
    {
      sub_48A480(v3, (int)v2, v7);
    }
  }
  v11 = *(_DWORD *)(v3 + 104);
  if ( (v11 & 1) == 0 )
    sub_484040((int *)v3, aMissingIhdrBef);
  if ( *(_BYTE *)(v3 + 294) == 3 && (v11 & 2) == 0 )
    sub_484040((int *)v3, aMissingPlteBef);
  v10 = *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 268) = v7;
  LOBYTE(v10) = v10 | 4;
  *(_DWORD *)(v3 + 104) = v10;
  return v10;
}

//----- (0047D270) --------------------------------------------------------
unsigned int __cdecl sub_47D270(int a1, int a2)
{
  if ( (*(_BYTE *)(a1 + 108) & 0x40) != 0 )
    sub_4840E0(a1, aIgnoringExtraP);
  else
    sub_48B240(a1);
  return sub_47FBD0(a1, a2);
}

//----- (0047D2E0) --------------------------------------------------------
char *__usercall sub_47D2E0@<eax>(int a1@<ebx>, int a2, char *a3, char *a4)
{
  int v4; // esi
  char *v5; // eax
  int v6; // ecx
  char *result; // eax
  int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned __int8 *v12; // edx
  int v13; // eax
  const char *v14; // eax
  int v15; // eax
  int v16; // ecx
  unsigned __int8 v17; // al
  unsigned int v18; // eax
  unsigned __int8 *v19; // ecx

  v4 = a2;
  if ( (*(_BYTE *)(a2 + 108) & 0x40) == 0 )
    sub_48B240(a2);
  if ( *(_BYTE *)(v4 + 291) && (*(_BYTE *)(v4 + 112) & 2) != 0 )
  {
    switch ( *(_BYTE *)(v4 + 292) )
    {
      case 0:
        if ( (*(_BYTE *)(v4 + 228) & 7) == 0 )
          goto LABEL_32;
        v5 = a4;
        if ( !a4 )
          goto LABEL_10;
        v6 = dword_4B0484[0];
        goto LABEL_9;
      case 1:
        if ( (*(_BYTE *)(v4 + 228) & 7) == 0 && *(_DWORD *)(v4 + 200) >= 5u )
          goto LABEL_32;
        if ( a4 )
          sub_48A660(v4, a4, dword_4B0488);
        goto LABEL_10;
      case 2:
        if ( (*(_BYTE *)(v4 + 228) & 7) == 4 )
          goto LABEL_32;
        if ( !a4 || (*(_DWORD *)(v4 + 228) & 4) == 0 )
          goto LABEL_10;
        sub_48A660(v4, a4, dword_4B048C);
        return sub_48AF90(a1, v4);
      case 3:
        if ( (*(_BYTE *)(v4 + 228) & 3) == 0 && *(_DWORD *)(v4 + 200) >= 3u )
          goto LABEL_32;
        v5 = a4;
        if ( !a4 )
          goto LABEL_10;
        v6 = dword_4B0490;
        goto LABEL_9;
      case 4:
        if ( (*(_BYTE *)(v4 + 228) & 3) == 2 )
          goto LABEL_32;
        if ( !a4 || (*(_DWORD *)(v4 + 228) & 2) == 0 )
          goto LABEL_10;
        sub_48A660(v4, a4, dword_4B0494);
        return sub_48AF90(a1, v4);
      case 5:
        if ( (*(_BYTE *)(v4 + 228) & 1) == 0 && *(_DWORD *)(v4 + 200) >= 2u )
          goto LABEL_32;
        v5 = a4;
        if ( !a4 )
          goto LABEL_10;
        v6 = dword_4B0498;
LABEL_9:
        sub_48A660(v4, v5, v6);
LABEL_10:
        result = sub_48AF90(a1, v4);
        break;
      case 6:
        if ( (*(_BYTE *)(v4 + 228) & 1) != 0 )
          goto LABEL_32;
        goto LABEL_10;
      default:
        goto LABEL_32;
    }
  }
  else
  {
LABEL_32:
    if ( (*(_BYTE *)(v4 + 104) & 4) == 0 )
      sub_484040((int *)v4, aInvalidAttempt);
    v8 = *(_DWORD *)(v4 + 220);
    *(_DWORD *)(v4 + 128) = *(_DWORD *)(v4 + 236);
    *(_DWORD *)(v4 + 132) = v8;
    while ( 1 )
    {
      if ( !*(_DWORD *)(v4 + 120) )
      {
        while ( !*(_DWORD *)(v4 + 268) )
        {
          sub_487F80(v4, 0);
          sub_484380((int *)v4, (int)&a2, 4);
          v9 = sub_487ED0((unsigned __int8 *)&a2);
          *(_DWORD *)(v4 + 268) = v9;
          if ( v9 > 0x7FFFFFFF )
            sub_484040((int *)v4, aInvalidChunkLe);
          sub_4845C0(v4);
          sub_487F50((int *)v4, (unsigned __int8 *)(v4 + 284), 4u);
          if ( *(_DWORD *)(v4 + 284) != *(_DWORD *)aIdat )
            sub_484040((int *)v4, aNotEnoughImage);
        }
        v10 = *(_DWORD *)(v4 + 176);
        v11 = *(_DWORD *)(v4 + 268);
        v12 = *(unsigned __int8 **)(v4 + 172);
        *(_DWORD *)(v4 + 120) = v10;
        *(_DWORD *)(v4 + 116) = v12;
        if ( v10 > v11 )
          *(_DWORD *)(v4 + 120) = v11;
        sub_487F50((int *)v4, v12, *(_DWORD *)(v4 + 120));
        *(_DWORD *)(v4 + 268) -= *(_DWORD *)(v4 + 120);
      }
      v13 = sub_466C30((unsigned __int8 **)(v4 + 116), 1);
      if ( v13 == 1 )
        break;
      if ( v13 )
      {
        v14 = *(const char **)(v4 + 140);
        if ( !v14 )
          v14 = aDecompressionE;
        sub_484040((int *)v4, v14);
      }
      if ( !*(_DWORD *)(v4 + 132) )
        goto LABEL_57;
    }
    if ( *(_DWORD *)(v4 + 132) || *(_DWORD *)(v4 + 120) || *(_DWORD *)(v4 + 268) )
      sub_484040((int *)v4, aExtraCompresse);
    v15 = *(_DWORD *)(v4 + 108);
    LOBYTE(v15) = v15 | 0x20;
    *(_DWORD *)(v4 + 104) |= 8u;
    *(_DWORD *)(v4 + 108) = v15;
LABEL_57:
    v16 = *(_DWORD *)(v4 + 224);
    *(_BYTE *)(v4 + 264) = *(_BYTE *)(v4 + 294);
    *(_BYTE *)(v4 + 265) = *(_BYTE *)(v4 + 295);
    v17 = *(_BYTE *)(v4 + 297);
    *(_BYTE *)(v4 + 267) = v17;
    v18 = v16 * v17 + 7;
    *(_BYTE *)(v4 + 266) = *(_BYTE *)(v4 + 298);
    *(_DWORD *)(v4 + 256) = v16;
    v19 = *(unsigned __int8 **)(v4 + 236);
    *(_DWORD *)(v4 + 260) = v18 >> 3;
    if ( *v19 )
      sub_48ADB0(v4, v4 + 256, v19 + 1, (unsigned __int8 *)(*(_DWORD *)(v4 + 232) + 1), *v19);
    sub_487E20(v4, *(void **)(v4 + 232), *(const void **)(v4 + 236), *(_DWORD *)(v4 + 216) + 1);
    if ( (*(_BYTE *)(v4 + 560) & 4) != 0 && *(_BYTE *)(v4 + 568) == 64 )
      sub_4833A0((int *)(v4 + 256), *(_DWORD *)(v4 + 236) + 1);
    if ( *(_DWORD *)(v4 + 112) )
      sub_47FD60(v4);
    if ( *(_BYTE *)(v4 + 291) && (*(_BYTE *)(v4 + 112) & 2) != 0 )
    {
      if ( *(_BYTE *)(v4 + 292) < 6u )
        sub_48A980(v4);
      if ( a4 )
        sub_48A660(v4, a4, dword_4B0484[*(unsigned __int8 *)(v4 + 292)]);
      if ( a3 )
        sub_48A660(v4, a3, dword_4B0468[*(unsigned __int8 *)(v4 + 292)]);
    }
    else
    {
      if ( a3 )
        sub_48A660(v4, a3, 255);
      if ( a4 )
        sub_48A660(v4, a4, 255);
    }
    sub_48AF90(a1, v4);
    result = *(char **)(v4 + 408);
    if ( result )
      result = (char *)((int (__cdecl *)(int, _DWORD, _DWORD))result)(
                         v4,
                         *(_DWORD *)(v4 + 228),
                         *(unsigned __int8 *)(v4 + 292));
  }
  return result;
}
// 4B0484: using guessed type int dword_4B0484[];
// 4B0488: using guessed type int dword_4B0488;
// 4B048C: using guessed type int dword_4B048C;
// 4B0490: using guessed type int dword_4B0490;
// 4B0494: using guessed type int dword_4B0494;
// 4B0498: using guessed type int dword_4B0498;

//----- (0047D800) --------------------------------------------------------
int __cdecl sub_47D800(int a1, char **a2)
{
  int result; // eax
  int v4; // ebp
  char **v5; // esi
  int v6; // edi
  int v7; // [esp+Ch] [ebp+4h]

  result = sub_47E0A0(a1);
  v4 = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(a1 + 208) = v4;
  if ( result > 0 )
  {
    v7 = result;
    do
    {
      v5 = a2;
      if ( v4 )
      {
        v6 = v4;
        do
        {
          sub_47D2E0(a1, a1, *v5++, 0);
          --v6;
        }
        while ( v6 );
      }
      result = --v7;
    }
    while ( v7 );
  }
  return result;
}

//----- (0047D860) --------------------------------------------------------
void __cdecl sub_47D860(int a1, _DWORD *a2)
{
  int v2; // esi
  _DWORD *v3; // ebp
  _DWORD *v4; // ebx
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax

  v2 = a1;
  sub_487F80(a1, 0);
  v3 = a2;
  v4 = (_DWORD *)(v2 + 284);
  do
  {
    sub_484380((int *)v2, (int)&a1, 4);
    v5 = sub_487ED0((unsigned __int8 *)&a1);
    sub_4845C0(v2);
    sub_487F50((int *)v2, (unsigned __int8 *)(v2 + 284), 4u);
    if ( v5 > 0x7FFFFFFF )
      sub_484040((int *)v2, aInvalidChunkLe);
    if ( *v4 == *(_DWORD *)aIhdr )
    {
      sub_488470(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aIend )
    {
      sub_488780((int *)v2, (int)v3, v5);
    }
    else if ( sub_484C80(v2, (_DWORD *)(v2 + 284)) )
    {
      if ( *v4 == *(_DWORD *)aIdat )
      {
        if ( v5 || (*(_BYTE *)(v2 + 104) & 8) != 0 )
          sub_484040((int *)v2, aTooManyIdatSFo);
      }
      else
      {
        v6 = *(_DWORD *)(v2 + 104);
        LOBYTE(v6) = v6 | 8;
        *(_DWORD *)(v2 + 104) = v6;
      }
      sub_48A480(v2, (int)v3, v5);
      if ( *v4 == *(_DWORD *)aPlte )
      {
        v7 = *(_DWORD *)(v2 + 104);
        LOBYTE(v7) = v7 | 2;
        *(_DWORD *)(v2 + 104) = v7;
      }
    }
    else if ( *v4 == *(_DWORD *)aIdat )
    {
      if ( v5 || (*(_BYTE *)(v2 + 104) & 8) != 0 )
        sub_484040((int *)v2, aTooManyIdatSFo);
      sub_487F80(v2, 0);
    }
    else if ( *v4 == *(_DWORD *)aPlte )
    {
      sub_4885E0(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aBkgd )
    {
      sub_4897A0(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aChrm )
    {
      sub_488A90((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aGama )
    {
      sub_4887D0((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aHist )
    {
      sub_4899A0(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aOffs )
    {
      sub_489BE0((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aPcal )
    {
      sub_489CD0((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aScal )
    {
      sub_489F40((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aPhys )
    {
      sub_489AF0((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aSbit )
    {
      sub_488920(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aSrgb )
    {
      sub_488F90((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aIccp )
    {
      sub_4891A0((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aSplt )
    {
      sub_489360((int *)v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aText )
    {
      sub_48A200(v2, v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aTime )
    {
      sub_48A110(v2, v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aTrns )
    {
      sub_489560(v2, (int)v3, v5);
    }
    else if ( *v4 == *(_DWORD *)aZtxt )
    {
      sub_48A320(v2, v3, v5);
    }
    else
    {
      sub_48A480(v2, (int)v3, v5);
    }
  }
  while ( (*(_BYTE *)(v2 + 104) & 0x10) == 0 );
}

//----- (0047DB30) --------------------------------------------------------
void __cdecl sub_47DB30(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3; // esi
  unsigned int v4; // edi
  void (__cdecl *v5)(char *, unsigned int); // ebx
  int v6; // ebp
  unsigned int v7; // [esp+10h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v7 = 0;
  if ( a1 )
    v3 = *a1;
  if ( a2 )
    v4 = *a2;
  if ( a3 )
    v7 = *a3;
  v5 = *(void (__cdecl **)(char *, unsigned int))(v3 + 588);
  v6 = *(_DWORD *)(v3 + 580);
  sub_47DBF0(v3, v4, v7);
  if ( v4 )
  {
    sub_484760(v3, v4, 0x4000, -1);
    sub_487CB0(v4, v5, v6);
    *a2 = 0;
  }
  if ( v7 )
  {
    sub_484760(v3, v7, 0x4000, -1);
    sub_487CB0(v7, v5, v6);
    *a3 = 0;
  }
  if ( v3 )
  {
    sub_487CB0(v3, v5, v6);
    *a1 = 0;
  }
}

//----- (0047DBF0) --------------------------------------------------------
int __cdecl sub_47DBF0(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // esi
  int i; // edi
  int v8; // esi
  int j; // edi
  int v10; // esi
  int k; // edi
  int v12; // eax
  int v13; // edx
  int v14; // ebp
  int v15; // esi
  int result; // eax
  char v17[64]; // [esp+10h] [ebp-40h] BYREF
  int v18; // [esp+58h] [ebp+8h]

  if ( a2 )
    sub_484B20(a1, a2);
  if ( a3 )
    sub_484B20(a1, a3);
  sub_487DA0(a1, *(_DWORD *)(a1 + 172));
  sub_487DA0(a1, *(_DWORD *)(a1 + 592));
  sub_487DA0(a1, *(_DWORD *)(a1 + 232));
  sub_487DA0(a1, *(_DWORD *)(a1 + 492));
  sub_487DA0(a1, *(_DWORD *)(a1 + 496));
  sub_487DA0(a1, *(_DWORD *)(a1 + 356));
  sub_487DA0(a1, *(_DWORD *)(a1 + 360));
  sub_487DA0(a1, *(_DWORD *)(a1 + 364));
  if ( (*(_DWORD *)(a1 + 532) & 0x1000) != 0 )
    sub_4845A0(a1, *(_DWORD *)(a1 + 276));
  v3 = *(_DWORD *)(a1 + 532);
  BYTE1(v3) &= 0xEFu;
  *(_DWORD *)(a1 + 532) = v3;
  if ( (v3 & 0x2000) != 0 )
    sub_487DA0(a1, *(_DWORD *)(a1 + 392));
  v4 = *(_DWORD *)(a1 + 532);
  BYTE1(v4) &= 0xDFu;
  *(_DWORD *)(a1 + 532) = v4;
  if ( (v4 & 8) != 0 )
    sub_487DA0(a1, *(_DWORD *)(a1 + 500));
  v5 = *(_DWORD *)(a1 + 368);
  *(_DWORD *)(a1 + 532) &= 0xFFFFFFF7;
  if ( v5 )
  {
    v6 = 1 << (8 - *(_BYTE *)(a1 + 344));
    for ( i = 0; i < v6; ++i )
      sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * i));
    sub_487DA0(a1, *(_DWORD *)(a1 + 368));
  }
  if ( *(_DWORD *)(a1 + 372) )
  {
    v8 = 1 << (8 - *(_BYTE *)(a1 + 344));
    for ( j = 0; j < v8; ++j )
      sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * j));
    sub_487DA0(a1, *(_DWORD *)(a1 + 372));
  }
  if ( *(_DWORD *)(a1 + 376) )
  {
    v10 = 1 << (8 - *(_BYTE *)(a1 + 344));
    for ( k = 0; k < v10; ++k )
      sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a1 + 376) + 4 * k));
    sub_487DA0(a1, *(_DWORD *)(a1 + 376));
  }
  sub_487DA0(a1, *(_DWORD *)(a1 + 528));
  sub_466AB0((_DWORD *)(a1 + 116));
  sub_487DA0(a1, *(_DWORD *)(a1 + 432));
  sub_487DA0(a1, *(_DWORD *)(a1 + 484));
  v12 = *(_DWORD *)(a1 + 588);
  v13 = *(_DWORD *)(a1 + 64);
  v14 = *(_DWORD *)(a1 + 72);
  qmemcpy(v17, (const void *)a1, sizeof(v17));
  v15 = *(_DWORD *)(a1 + 68);
  v18 = v12;
  result = 0;
  memset((void *)a1, 0, 0x260u);
  *(_DWORD *)(a1 + 68) = v15;
  *(_DWORD *)(a1 + 588) = v18;
  qmemcpy((void *)a1, v17, 0x40u);
  *(_DWORD *)(a1 + 72) = v14;
  *(_DWORD *)(a1 + 64) = v13;
  return result;
}

//----- (0047E000) --------------------------------------------------------
int __cdecl sub_47E000(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 112) |= 1u;
  return result;
}

//----- (0047E010) --------------------------------------------------------
int __cdecl sub_47E010(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 295) == 16 )
    *(_DWORD *)(a1 + 112) |= 0x10u;
  return result;
}

//----- (0047E030) --------------------------------------------------------
int __cdecl sub_47E030(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  if ( *(_BYTE *)(a1 + 295) < 8u )
  {
    v2 = *(_DWORD *)(a1 + 112);
    *(_BYTE *)(a1 + 296) = 8;
    *(_DWORD *)(a1 + 112) = v2 | 4;
  }
  return result;
}

//----- (0047E050) --------------------------------------------------------
int __cdecl sub_47E050(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 295) < 8u )
    *(_DWORD *)(a1 + 112) |= 0x10000u;
  return result;
}

//----- (0047E070) --------------------------------------------------------
int __cdecl sub_47E070(int a1, int a2)
{
  int result; // eax

  result = a1 + 385;
  *(_DWORD *)(a1 + 112) |= 8u;
  *(_DWORD *)(a1 + 385) = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 389) = *(_BYTE *)(a2 + 4);
  return result;
}

//----- (0047E0A0) --------------------------------------------------------
int __cdecl sub_47E0A0(int a1)
{
  if ( !*(_BYTE *)(a1 + 291) )
    return 1;
  *(_DWORD *)(a1 + 112) |= 2u;
  return 7;
}

//----- (0047E0D0) --------------------------------------------------------
int __cdecl sub_47E0D0(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // ecx
  char v6; // cl

  result = a1;
  v4 = *(_DWORD *)(a1 + 112);
  BYTE1(v4) |= 0x80u;
  *(_DWORD *)(a1 + 112) = v4;
  *(_WORD *)(a1 + 302) = a2;
  v5 = *(_DWORD *)(a1 + 108);
  if ( a3 == 1 )
    LOBYTE(v5) = v5 | 0x80;
  else
    LOBYTE(v5) = v5 & 0x7F;
  *(_DWORD *)(a1 + 108) = v5;
  v6 = *(_BYTE *)(a1 + 294);
  if ( v6 == 2 )
    *(_BYTE *)(a1 + 299) = 4;
  if ( !v6 && *(_BYTE *)(a1 + 295) >= 8u )
    *(_BYTE *)(a1 + 299) = 2;
  return result;
}

//----- (0047E130) --------------------------------------------------------
int __cdecl sub_47E130(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 112) |= 0x20000u;
  return result;
}

//----- (0047E140) --------------------------------------------------------
int __cdecl sub_47E140(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 112) |= 0x80000u;
  return result;
}

//----- (0047E150) --------------------------------------------------------
int __cdecl sub_47E150(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 112) |= 0x20u;
  return result;
}

//----- (0047E160) --------------------------------------------------------
char __cdecl sub_47E160(int a1, char *a2)
{
  char *i; // eax
  int v3; // ecx
  char v4; // dl
  int v5; // ecx
  unsigned int v6; // ecx
  char v7; // dl
  unsigned int v8; // esi
  char v9; // dl

  LOBYTE(i) = *(_BYTE *)(a1 + 8);
  if ( (_BYTE)i )
  {
    if ( (_BYTE)i == 4 )
    {
      if ( *(_BYTE *)(a1 + 9) == 8 )
      {
        v5 = *(_DWORD *)(a1 + 4);
        i = a2;
        if ( v5 )
        {
          v6 = (unsigned int)(v5 + 1) >> 1;
          do
          {
            v7 = *i;
            i += 2;
            *(i - 2) = ~v7;
            --v6;
          }
          while ( v6 );
        }
      }
      else if ( *(_BYTE *)(a1 + 9) == 16 )
      {
        v8 = *(_DWORD *)(a1 + 4);
        if ( v8 )
        {
          i = a2 + 1;
          do
          {
            v9 = *(i - 1);
            i += 4;
            *(i - 5) = ~v9;
            *(i - 4) = ~*(i - 4);
          }
          while ( (unsigned int)&i[-1 - (_DWORD)a2] < v8 );
        }
      }
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 4);
    for ( i = a2; v3; --v3 )
    {
      v4 = *i++;
      *(i - 1) = ~v4;
    }
  }
  return (char)i;
}
// 47E1AD: conditional instruction was optimized away because of 'al.1==4'

//----- (0047E1F0) --------------------------------------------------------
void __cdecl sub_47E1F0(int a1, char *a2)
{
  int v3; // esi
  char v4; // cl

  if ( *(_BYTE *)(a1 + 9) == 16 && *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
  {
    v3 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
    do
    {
      v4 = *a2;
      *a2 = a2[1];
      a2[1] = v4;
      a2 += 2;
      --v3;
    }
    while ( v3 );
  }
}

//----- (0047E220) --------------------------------------------------------
unsigned __int8 *__cdecl sub_47E220(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *result; // eax
  unsigned __int8 v3; // dl
  unsigned int v4; // ecx
  _BYTE *v5; // esi
  int v6; // edx

  result = a1;
  v3 = a1[9];
  if ( v3 < 8u )
  {
    result = a2;
    v4 = (unsigned int)&a2[*((_DWORD *)a1 + 1)];
    switch ( v3 )
    {
      case 1u:
        v5 = &unk_4BD8A4;
        break;
      case 2u:
        v5 = &unk_4BD9A4;
        break;
      case 4u:
        v5 = &unk_4BDAA4;
        break;
      default:
        return result;
    }
    if ( (unsigned int)a2 < v4 )
    {
      do
      {
        v6 = *result++;
        *(result - 1) = v5[v6];
      }
      while ( (unsigned int)result < v4 );
    }
  }
  return result;
}

//----- (0047E270) --------------------------------------------------------
char __cdecl sub_47E270(int a1, char *a2, char a3)
{
  char v3; // dl
  unsigned int v4; // edi
  char *v5; // eax
  char *v6; // ecx
  _BYTE *v7; // edx
  _BYTE *v8; // eax
  unsigned int v9; // esi
  char v10; // cl
  _BYTE *v11; // edx
  _BYTE *v12; // eax
  char v13; // cl
  unsigned int v14; // esi
  char v15; // dl
  _BYTE *v16; // eax
  _BYTE *v17; // ecx
  char v18; // dl
  _BYTE *v19; // edx
  _BYTE *v20; // eax
  unsigned int v21; // esi
  char v22; // cl
  _BYTE *v23; // eax
  _BYTE *v24; // edx
  char v25; // cl
  char v26; // cl
  char v27; // cl
  char v28; // cl
  unsigned int v29; // esi
  char v30; // dl
  _BYTE *v31; // eax
  _BYTE *v32; // ecx
  char v33; // dl
  char v34; // dl
  char v35; // dl
  char v36; // dl
  unsigned int v37; // esi
  char v38; // bl
  char v39; // al
  unsigned int v40; // esi
  _BYTE *v41; // edx
  _BYTE *v42; // eax
  unsigned int v43; // esi
  char v44; // cl
  _BYTE *v45; // eax
  unsigned int v46; // esi
  char v47; // dl
  _BYTE *v48; // eax
  _BYTE *v49; // ecx

  v3 = *(_BYTE *)(a1 + 10);
  v4 = *(_DWORD *)a1;
  v5 = a2;
  v6 = a2;
  if ( v3 == 4 )
  {
    if ( *(_BYTE *)(a1 + 9) == 8 )
    {
      if ( a3 >= 0 )
      {
        if ( v4 )
        {
          v14 = *(_DWORD *)a1;
          do
          {
            v15 = v5[1];
            v16 = v5 + 1;
            *v6 = v15;
            v17 = v6 + 1;
            v18 = *++v16;
            *v17++ = v18;
            *v17 = v16[1];
            v6 = v17 + 1;
            v5 = v16 + 2;
            --v14;
          }
          while ( v14 );
        }
      }
      else
      {
        v7 = a2 + 3;
        v8 = a2 + 4;
        if ( v4 > 1 )
        {
          v9 = v4 - 1;
          do
          {
            *v7 = *v8;
            v10 = v8[1];
            v11 = v7 + 1;
            v12 = v8 + 1;
            *v11 = v10;
            v13 = v12[1];
            ++v11;
            v8 = v12 + 3;
            *v11 = v13;
            v7 = v11 + 1;
            --v9;
          }
          while ( v9 );
        }
      }
      *(_DWORD *)(a1 + 4) = 3 * v4;
      LOBYTE(v5) = *(_BYTE *)(a1 + 8) & 0xFB;
      *(_BYTE *)(a1 + 11) = 24;
      *(_BYTE *)(a1 + 10) = 3;
      *(_BYTE *)(a1 + 8) = (_BYTE)v5;
    }
    else
    {
      if ( a3 >= 0 )
      {
        if ( v4 )
        {
          v29 = *(_DWORD *)a1;
          do
          {
            v30 = v5[2];
            v31 = v5 + 2;
            *v6 = v30;
            v32 = v6 + 1;
            v33 = *++v31;
            *v32++ = v33;
            v34 = *++v31;
            *v32++ = v34;
            v35 = *++v31;
            *v32++ = v35;
            v36 = *++v31;
            *v32++ = v36;
            *v32 = v31[1];
            v6 = v32 + 1;
            v5 = v31 + 2;
            --v29;
          }
          while ( v29 );
        }
      }
      else
      {
        v19 = a2 + 8;
        v20 = a2 + 6;
        if ( v4 > 1 )
        {
          v21 = v4 - 1;
          do
          {
            *v20 = *v19;
            v22 = v19[1];
            v23 = v20 + 1;
            v24 = v19 + 1;
            *v23 = v22;
            v25 = v24[1];
            ++v23;
            ++v24;
            *v23 = v25;
            v26 = v24[1];
            ++v23;
            ++v24;
            *v23 = v26;
            v27 = v24[1];
            ++v23;
            ++v24;
            *v23 = v27;
            v28 = v24[1];
            ++v23;
            v19 = v24 + 4;
            *v23 = v28;
            v20 = v23 + 1;
            --v21;
          }
          while ( v21 );
        }
      }
      *(_DWORD *)(a1 + 4) = 6 * v4;
      LOBYTE(v5) = *(_BYTE *)(a1 + 8) & 0xFB;
      *(_BYTE *)(a1 + 11) = 48;
      *(_BYTE *)(a1 + 10) = 3;
      *(_BYTE *)(a1 + 8) = (_BYTE)v5;
    }
  }
  else if ( v3 == 2 )
  {
    if ( *(_BYTE *)(a1 + 9) == 8 )
    {
      if ( a3 >= 0 )
      {
        if ( v4 )
        {
          v40 = *(_DWORD *)a1;
          do
          {
            *v6++ = v5[1];
            v5 += 2;
            --v40;
          }
          while ( v40 );
        }
      }
      else if ( v4 )
      {
        v37 = *(_DWORD *)a1;
        do
        {
          v38 = *v5;
          v5 += 2;
          *v6++ = v38;
          --v37;
        }
        while ( v37 );
      }
      v39 = *(_BYTE *)(a1 + 8);
      *(_DWORD *)(a1 + 4) = v4;
      LOBYTE(v5) = v39 & 0xFB;
      *(_BYTE *)(a1 + 11) = 8;
      *(_BYTE *)(a1 + 10) = 1;
      *(_BYTE *)(a1 + 8) = (_BYTE)v5;
    }
    else
    {
      if ( a3 >= 0 )
      {
        if ( v4 )
        {
          v46 = *(_DWORD *)a1;
          do
          {
            v47 = v5[2];
            v48 = v5 + 2;
            *v6 = v47;
            v49 = v6 + 1;
            *v49 = v48[1];
            v6 = v49 + 1;
            v5 = v48 + 2;
            --v46;
          }
          while ( v46 );
        }
      }
      else
      {
        v41 = a2 + 4;
        v42 = a2 + 2;
        if ( v4 > 1 )
        {
          v43 = v4 - 1;
          do
          {
            *v42 = *v41;
            v44 = v41[1];
            v45 = v42 + 1;
            v41 += 4;
            *v45 = v44;
            v42 = v45 + 1;
            --v43;
          }
          while ( v43 );
        }
      }
      *(_BYTE *)(a1 + 11) = 16;
      *(_DWORD *)(a1 + 4) = 2 * v4;
      LOBYTE(v5) = *(_BYTE *)(a1 + 8) & 0xFB;
      *(_BYTE *)(a1 + 10) = 1;
      *(_BYTE *)(a1 + 8) = (_BYTE)v5;
    }
  }
  return (char)v5;
}

//----- (0047E480) --------------------------------------------------------
char __cdecl sub_47E480(int *a1, char *a2)
{
  char *v2; // eax
  char v3; // dl
  int v4; // ecx
  int v5; // esi
  char v6; // dl
  int v7; // esi
  char v8; // dl
  int v9; // esi
  char v10; // cl
  char v11; // dl
  char v12; // cl
  int v13; // esi
  char v14; // cl
  char v15; // dl
  char v16; // cl

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v2 = a2;
        if ( v4 )
        {
          v5 = *a1;
          do
          {
            v6 = *v2;
            *v2 = v2[2];
            v2[2] = v6;
            v2 += 3;
            --v5;
          }
          while ( v5 );
        }
      }
      else if ( v3 == 6 )
      {
        v2 = a2;
        if ( v4 )
        {
          v7 = *a1;
          do
          {
            v8 = *v2;
            *v2 = v2[2];
            v2[2] = v8;
            v2 += 4;
            --v7;
          }
          while ( v7 );
        }
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          v9 = *a1;
          v2 = a2 + 1;
          do
          {
            v10 = *(v2 - 1);
            *(v2 - 1) = v2[3];
            v11 = v2[4];
            v2[3] = v10;
            v12 = *v2;
            *v2 = v11;
            v2[4] = v12;
            v2 += 6;
            --v9;
          }
          while ( v9 );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        v13 = *a1;
        v2 = a2 + 1;
        do
        {
          v14 = *(v2 - 1);
          *(v2 - 1) = v2[3];
          v15 = v2[4];
          v2[3] = v14;
          v16 = *v2;
          *v2 = v15;
          v2[4] = v16;
          v2 += 8;
          --v13;
        }
        while ( v13 );
      }
    }
  }
  return (char)v2;
}

//----- (0047E630) --------------------------------------------------------
int __cdecl sub_47E630(int a1, int a2, int a3, int a4, double a5)
{
  int result; // eax
  int v6; // ebp
  __int16 v7; // bx
  __int16 v8; // cx
  int v9; // ecx

  if ( !a3 )
    return sub_4840E0(a1, aApplicationMus);
  result = a1;
  v6 = *(_DWORD *)(a1 + 112) | 0x80;
  *(_DWORD *)(a1 + 112) = v6;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(a2 + 4);
  v7 = *(_WORD *)(a2 + 8);
  *(_BYTE *)(a1 + 304) = a3;
  *(_WORD *)(a1 + 320) = v7;
  *(float *)(a1 + 308) = a5;
  *(_DWORD *)(a1 + 112) = v6 | (a4 != 0 ? 0x100 : 0);
  if ( a4 )
  {
    if ( (*(_BYTE *)(a1 + 294) & 2) != 0 )
      return result;
LABEL_8:
    v9 = *(_DWORD *)(a1 + 104);
    BYTE1(v9) |= 8u;
    *(_DWORD *)(a1 + 104) = v9;
    return result;
  }
  v8 = *(_WORD *)(a2 + 2);
  if ( v8 == *(_WORD *)(a2 + 4) && v8 == *(_WORD *)(a2 + 6) )
    goto LABEL_8;
  return result;
}

//----- (0047E6E0) --------------------------------------------------------
int __cdecl sub_47E6E0(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 112);
  BYTE1(v2) |= 4u;
  *(_DWORD *)(a1 + 112) = v2;
  return result;
}

//----- (0047E6F0) --------------------------------------------------------
int __cdecl sub_47E6F0(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 112) |= 0x40000u;
  return result;
}

//----- (0047EFD0) --------------------------------------------------------
int __cdecl sub_47EFD0(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 112);
  BYTE1(v2) |= 0x10u;
  *(_DWORD *)(a1 + 112) = v2;
  return result;
}

//----- (0047F010) --------------------------------------------------------
int __cdecl sub_47F010(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  v2 = *(_DWORD *)(a1 + 112);
  BYTE1(v2) |= 0x40u;
  *(_DWORD *)(a1 + 112) = v2;
  return result;
}

//----- (0047F060) --------------------------------------------------------
int __cdecl sub_47F060(int a1, int a2, int a3, int a4)
{
  int result; // eax
  unsigned int v5; // ecx
  unsigned int v6; // esi

  if ( a2 == 1 )
  {
    result = *(_DWORD *)(a1 + 112) | 0x600000;
  }
  else if ( a2 == 2 )
  {
    result = *(_DWORD *)(a1 + 112) | 0x400000;
  }
  else
  {
    result = a2 - 3;
    if ( a2 != 3 )
      goto LABEL_8;
    result = *(_DWORD *)(a1 + 112) | 0x200000;
  }
  *(_DWORD *)(a1 + 112) = result;
LABEL_8:
  if ( *(_BYTE *)(a1 + 294) == 3 )
  {
    result = *(_DWORD *)(a1 + 112);
    BYTE1(result) |= 0x10u;
    *(_DWORD *)(a1 + 112) = result;
  }
  if ( a3 < 0 || a4 < 0 )
    goto LABEL_15;
  if ( a3 + a4 >= 100000 )
  {
    result = sub_4840E0(a1, byte_4BDC24);
LABEL_15:
    LOWORD(v5) = 6968;
    LOWORD(v6) = 23434;
    goto LABEL_16;
  }
  result = -1404600320 * a4;
  v5 = (a3 << 15) / 0x186A0u;
  v6 = (a4 << 15) / 0x186A0u;
LABEL_16:
  *(_WORD *)(a1 + 554) = v5;
  *(_WORD *)(a1 + 556) = v6;
  *(_WORD *)(a1 + 558) = 0x8000 - v6 - v5;
  return result;
}

//----- (0047F140) --------------------------------------------------------
char __cdecl sub_47F140(int a1)
{
  int v2; // ebx
  int v3; // ecx
  __int16 v4; // ax
  unsigned __int8 *v5; // eax
  int v6; // ebp
  int v7; // ecx
  char v8; // al
  int v9; // eax
  int v10; // ebp
  int v11; // ebp
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // cx
  int v14; // edi
  int v15; // edx
  unsigned __int8 v16; // bl
  double v17; // st7
  double v18; // st7
  double v19; // st7
  double v20; // st7
  double v21; // st7
  double v22; // st7
  int v23; // edi
  _BYTE *v24; // ecx
  unsigned __int8 v25; // dl
  __int16 v26; // ax
  __int16 v27; // dx
  unsigned int v28; // edx
  unsigned int v29; // edx
  double v30; // st7
  __int64 v31; // rax
  unsigned __int16 v32; // cx
  unsigned __int16 v33; // di
  __int16 v34; // cx
  int v35; // ecx
  int v36; // eax
  int v37; // edx
  int v38; // eax
  int v39; // ebp
  int v40; // edi
  unsigned __int8 v41; // dl
  unsigned __int8 *v42; // eax
  unsigned __int8 v43; // cl
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  int v47; // eax
  int v48; // ebx
  int v49; // ecx
  int v50; // edx
  int v51; // edi
  _BYTE *v52; // edx
  unsigned __int8 v54; // [esp+Dh] [ebp-33h]
  unsigned __int8 v55; // [esp+Eh] [ebp-32h]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+18h] [ebp-28h]
  char v58; // [esp+18h] [ebp-28h]
  double v59; // [esp+20h] [ebp-20h]
  int v60; // [esp+20h] [ebp-20h]
  double v61; // [esp+28h] [ebp-18h]
  double v62; // [esp+28h] [ebp-18h]
  double v63; // [esp+30h] [ebp-10h]
  double v64; // [esp+38h] [ebp-8h]
  __int16 v65; // [esp+44h] [ebp+4h]
  __int16 v66; // [esp+44h] [ebp+4h]
  char v67; // [esp+44h] [ebp+4h]
  char v68; // [esp+46h] [ebp+6h]

  v2 = *(_DWORD *)(a1 + 112);
  v3 = *(unsigned __int8 *)(a1 + 294);
  v56 = v3;
  if ( (v2 & 0x100) != 0 && (v2 & 0x1000) != 0 )
  {
    if ( (v3 & 2) != 0 )
    {
      if ( v3 == 3 )
      {
        v5 = (unsigned __int8 *)(*(_DWORD *)(a1 + 276) + 3 * *(unsigned __int8 *)(a1 + 312));
        *(_WORD *)(a1 + 314) = *v5;
        *(_WORD *)(a1 + 316) = v5[1];
        *(_WORD *)(a1 + 318) = v5[2];
      }
    }
    else
    {
      switch ( *(_BYTE *)(a1 + 295) )
      {
        case 1:
          v4 = 255 * *(_WORD *)(a1 + 320);
          goto LABEL_6;
        case 2:
          v4 = 85 * *(_WORD *)(a1 + 320);
          goto LABEL_6;
        case 4:
          v4 = 17 * *(_WORD *)(a1 + 320);
LABEL_6:
          *(_WORD *)(a1 + 320) = v4;
          goto LABEL_7;
        case 8:
        case 0x10:
          v4 = *(_WORD *)(a1 + 320);
LABEL_7:
          *(_WORD *)(a1 + 318) = v4;
          *(_WORD *)(a1 + 316) = v4;
          *(_WORD *)(a1 + 314) = v4;
          break;
        default:
          break;
      }
    }
  }
  *(_DWORD *)(a1 + 322) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 326) = *(_DWORD *)(a1 + 316);
  *(_WORD *)(a1 + 330) = *(_WORD *)(a1 + 320);
  if ( v3 == 3 && *(_WORD *)(a1 + 282) && fabs(*(float *)(a1 + 352) * *(float *)(a1 + 348) - dbl_4A91C8) < dbl_4B02E0 )
  {
    v6 = 0;
    v7 = 0;
    if ( !*(_WORD *)(a1 + 282) )
      goto LABEL_22;
    do
    {
      v8 = *(_BYTE *)(*(_DWORD *)(a1 + 392) + v7);
      if ( v8 && v8 != -1 )
        v6 = 1;
      ++v7;
    }
    while ( v7 < *(unsigned __int16 *)(a1 + 282) );
    if ( !v6 )
    {
LABEL_22:
      BYTE1(v2) &= 0xDFu;
      *(_DWORD *)(a1 + 112) = v2;
    }
  }
  v9 = *(_DWORD *)(a1 + 112);
  if ( (v9 & 0x602000) != 0 )
  {
    sub_482D40(a1);
    if ( *(char *)(a1 + 112) < 0 )
    {
      if ( v56 != 3 )
      {
        v30 = (double)(unsigned int)((1 << *(_BYTE *)(a1 + 295)) - 1);
        v61 = (double)*(unsigned __int16 *)(a1 + 320) / v30;
        sub_4A2150(v61);
        *(_WORD *)(a1 + 330) = (__int64)(v61 * v30 + dbl_4AD770);
        sub_4A2150(v61);
        v31 = (__int64)(v61 * v30 + dbl_4AD770);
        v32 = *(_WORD *)(a1 + 314);
        v33 = *(_WORD *)(a1 + 316);
        *(_WORD *)(a1 + 320) = v31;
        if ( v32 == v33 && v32 == *(_WORD *)(a1 + 318) && v32 == (_WORD)v31 )
        {
          v34 = *(_WORD *)(a1 + 330);
          *(_WORD *)(a1 + 318) = v31;
          *(_WORD *)(a1 + 328) = v34;
          *(_WORD *)(a1 + 326) = v34;
          *(_WORD *)(a1 + 324) = v34;
          *(_WORD *)(a1 + 316) = v31;
          *(_WORD *)(a1 + 314) = v31;
        }
        else
        {
          v62 = (double)v32 / v30;
          sub_4A2150(v62);
          *(_WORD *)(a1 + 324) = (__int64)(v62 * v30 + dbl_4AD770);
          v63 = (double)v33 / v30;
          sub_4A2150(v63);
          *(_WORD *)(a1 + 326) = (__int64)(v63 * v30 + dbl_4AD770);
          v64 = (double)*(unsigned __int16 *)(a1 + 318) / v30;
          sub_4A2150(v64);
          *(_WORD *)(a1 + 328) = (__int64)(v64 * v30 + dbl_4AD770);
          sub_4A2150(v62);
          *(_WORD *)(a1 + 314) = (__int64)(v62 * v30 + dbl_4AD770);
          sub_4A2150(v63);
          *(_WORD *)(a1 + 316) = (__int64)(v63 * v30 + dbl_4AD770);
          sub_4A2150(v64);
          *(_WORD *)(a1 + 318) = (__int64)(v64 * v30 + dbl_4AD770);
        }
        goto LABEL_67;
      }
      v10 = *(unsigned __int16 *)(a1 + 280);
      v57 = (unsigned __int16)v10;
      if ( *(_BYTE *)(a1 + 304) == 2 )
      {
        v11 = *(_DWORD *)(a1 + 356);
        v12 = *(_WORD *)(a1 + 314);
        LOBYTE(v65) = *(_BYTE *)(v12 + v11);
        v13 = *(_WORD *)(a1 + 316);
        v14 = *(unsigned __int16 *)(a1 + 318);
        HIBYTE(v65) = *(_BYTE *)(v13 + v11);
        v68 = *(_BYTE *)(v14 + v11);
        v15 = *(_DWORD *)(a1 + 364);
        v10 = v57;
        v16 = *(_BYTE *)(v15 + v12);
        v54 = *(_BYTE *)(v15 + v13);
        v55 = *(_BYTE *)(v15 + v14);
        goto LABEL_38;
      }
      if ( *(_BYTE *)(a1 + 304) != 1 )
      {
        if ( *(_BYTE *)(a1 + 304) == 2 )
        {
          v59 = dbl_4A91C8 / (*(float *)(a1 + 352) * *(float *)(a1 + 348));
          goto LABEL_34;
        }
        if ( *(_BYTE *)(a1 + 304) == 3 )
        {
          v59 = dbl_4A91C8 / (*(float *)(a1 + 352) * *(float *)(a1 + 308));
LABEL_34:
          if ( fabs(v59 - dbl_4A91C8) >= dbl_4B02E0 )
          {
            v17 = (double)*(unsigned __int16 *)(a1 + 314) * dbl_4B02F8;
            sub_4A2150(v17);
            LOBYTE(v65) = (__int64)(v17 * dbl_4B02F0 + dbl_4AD770);
            v18 = (double)*(unsigned __int16 *)(a1 + 316) * dbl_4B02F8;
            sub_4A2150(v18);
            HIBYTE(v65) = (__int64)(v18 * dbl_4B02F0 + dbl_4AD770);
            v19 = (double)*(unsigned __int16 *)(a1 + 318) * dbl_4B02F8;
            sub_4A2150(v19);
            v68 = (__int64)(v19 * dbl_4B02F0 + dbl_4AD770);
          }
          else
          {
            LOBYTE(v65) = *(_BYTE *)(a1 + 314);
            HIBYTE(v65) = *(_BYTE *)(a1 + 316);
            v68 = *(_BYTE *)(a1 + 318);
          }
          v20 = (double)*(unsigned __int16 *)(a1 + 314) * dbl_4B02F8;
          sub_4A2150(v20);
          v16 = (__int64)(v20 * dbl_4B02F0 + dbl_4AD770);
          v21 = (double)*(unsigned __int16 *)(a1 + 316) * dbl_4B02F8;
          sub_4A2150(v21);
          v54 = (__int64)(v21 * dbl_4B02F0 + dbl_4AD770);
          v22 = (double)*(unsigned __int16 *)(a1 + 318) * dbl_4B02F8;
          sub_4A2150(v22);
          v55 = (__int64)(v22 * dbl_4B02F0 + dbl_4AD770);
LABEL_38:
          v23 = 0;
          if ( v10 > 0 )
          {
            v24 = (_BYTE *)(*(_DWORD *)(a1 + 276) + 2);
            do
            {
              if ( v23 >= *(unsigned __int16 *)(a1 + 282)
                || (v25 = *(_BYTE *)(*(_DWORD *)(a1 + 392) + v23), v25 == 0xFF) )
              {
                *(v24 - 2) = *(_BYTE *)((unsigned __int8)*(v24 - 2) + *(_DWORD *)(a1 + 356));
                *(v24 - 1) = *(_BYTE *)((unsigned __int8)*(v24 - 1) + *(_DWORD *)(a1 + 356));
                *v24 = *(_BYTE *)((unsigned __int8)*v24 + *(_DWORD *)(a1 + 356));
              }
              else if ( v25 )
              {
                v26 = v25 * *(unsigned __int8 *)((unsigned __int8)*(v24 - 2) + *(_DWORD *)(a1 + 364));
                *(v24 - 2) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v26
                                                                           + v16 * (255 - v25)
                                                                           + 128
                                                                           + ((unsigned __int16)(v26
                                                                                               + v16 * (255 - v25)
                                                                                               + 128) >> 8)) >> 8)
                                      + *(_DWORD *)(a1 + 360));
                v27 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v23);
                v28 = (unsigned __int16)(v27 * *(unsigned __int8 *)((unsigned __int8)*(v24 - 1) + *(_DWORD *)(a1 + 364))
                                       + v54 * (255 - v27)
                                       + 128);
                *(v24 - 1) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v28 + (v28 >> 8)) >> 8)
                                      + *(_DWORD *)(a1 + 360));
                LOWORD(v28) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v23);
                v10 = v57;
                v29 = (unsigned __int16)(v28 * *(unsigned __int8 *)((unsigned __int8)*v24 + *(_DWORD *)(a1 + 364))
                                       + v55 * (255 - v28)
                                       + 128);
                *v24 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v29 + (v29 >> 8)) >> 8) + *(_DWORD *)(a1 + 360));
              }
              else
              {
                *((_WORD *)v24 - 1) = v65;
                *v24 = v68;
              }
              ++v23;
              v24 += 3;
            }
            while ( v23 < v10 );
          }
          goto LABEL_67;
        }
      }
      v59 = 1.0;
      goto LABEL_34;
    }
    if ( v56 == 3 )
    {
      v35 = *(unsigned __int16 *)(a1 + 280);
      if ( (_WORD)v35 )
      {
        v36 = *(_DWORD *)(a1 + 276) + 2;
        do
        {
          v37 = *(unsigned __int8 *)(v36 - 2);
          v36 += 3;
          *(_BYTE *)(v36 - 5) = *(_BYTE *)(v37 + *(_DWORD *)(a1 + 356));
          *(_BYTE *)(v36 - 4) = *(_BYTE *)(*(unsigned __int8 *)(v36 - 4) + *(_DWORD *)(a1 + 356));
          --v35;
          *(_BYTE *)(v36 - 3) = *(_BYTE *)(*(unsigned __int8 *)(v36 - 3) + *(_DWORD *)(a1 + 356));
        }
        while ( v35 );
      }
    }
  }
  else if ( (v9 & 0x80u) != 0 && v56 == 3 )
  {
    v38 = *(_DWORD *)(a1 + 276);
    v39 = *(unsigned __int16 *)(a1 + 282);
    v40 = 0;
    HIBYTE(v66) = *(_BYTE *)(a1 + 316);
    v41 = *(_BYTE *)(a1 + 318);
    v60 = (unsigned __int16)v39;
    LOBYTE(v66) = *(_BYTE *)(a1 + 314);
    if ( (_WORD)v39 )
    {
      v42 = (unsigned __int8 *)(v38 + 2);
      do
      {
        v43 = *(_BYTE *)(*(_DWORD *)(a1 + 392) + v40);
        if ( v43 )
        {
          if ( v43 != 0xFF )
          {
            v44 = (unsigned __int16)((unsigned __int8)v66 * (255 - v43) + v43 * *(v42 - 2) + 128);
            *(v42 - 2) = (unsigned __int16)(v44 + (v44 >> 8)) >> 8;
            LOWORD(v44) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v40);
            v45 = (unsigned __int16)(HIBYTE(v66) * (255 - v44) + v44 * *(v42 - 1) + 128);
            *(v42 - 1) = (unsigned __int16)(v45 + (v45 >> 8)) >> 8;
            LOWORD(v45) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 392) + v40);
            v39 = v60;
            v46 = (unsigned __int16)(v41 * (255 - v45) + v45 * *v42 + 128);
            *v42 = (unsigned __int16)(v46 + (v46 >> 8)) >> 8;
          }
        }
        else
        {
          *((_WORD *)v42 - 1) = v66;
          *v42 = v41;
        }
        ++v40;
        v42 += 3;
      }
      while ( v40 < v39 );
    }
  }
LABEL_67:
  LOBYTE(v47) = *(_BYTE *)(a1 + 112);
  if ( (v47 & 8) != 0 && v56 == 3 )
  {
    v48 = 8 - *(unsigned __int8 *)(a1 + 380);
    v49 = 8 - *(unsigned __int8 *)(a1 + 381);
    v67 = 8 - *(_BYTE *)(a1 + 381);
    v50 = 8 - *(unsigned __int8 *)(a1 + 382);
    v47 = 0;
    v58 = 8 - *(_BYTE *)(a1 + 382);
    if ( v48 < 0 || v48 > 8 )
      LOBYTE(v48) = 0;
    if ( v49 < 0 || v49 > 8 )
      v67 = 0;
    if ( v50 < 0 || v50 > 8 )
      v58 = 0;
    if ( *(_WORD *)(a1 + 280) )
    {
      v51 = *(unsigned __int16 *)(a1 + 280);
      do
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 276) + v47) >>= v48;
        *(_BYTE *)(*(_DWORD *)(a1 + 276) + v47 + 1) >>= v67;
        v52 = (_BYTE *)(*(_DWORD *)(a1 + 276) + v47 + 2);
        v47 += 3;
        *v52 >>= v58;
        --v51;
      }
      while ( v51 );
    }
  }
  return v47;
}
// 4A2150: using guessed type double __usercall sub_4A2150@<st0>(double@<st0>);
// 4A91C8: using guessed type double dbl_4A91C8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B02E0: using guessed type double dbl_4B02E0;
// 4B02F0: using guessed type double dbl_4B02F0;
// 4B02F8: using guessed type double dbl_4B02F8;

//----- (0047FBD0) --------------------------------------------------------
unsigned int __cdecl sub_47FBD0(int a1, int a2)
{
  char v2; // dl
  char v3; // dl
  char v4; // dl
  char v5; // dl
  char v6; // dl
  unsigned __int8 v7; // dl
  unsigned __int8 v8; // al
  unsigned __int8 v9; // al
  unsigned int result; // eax

  if ( (*(_DWORD *)(a1 + 112) & 0x1000) != 0 )
  {
    v2 = *(_BYTE *)(a2 + 25);
    if ( v2 == 3 )
    {
      *(_BYTE *)(a2 + 25) = *(_WORD *)(a1 + 282) != 0 ? 6 : 2;
    }
    else
    {
      if ( *(_WORD *)(a1 + 282) )
        *(_BYTE *)(a2 + 25) = v2 | 4;
      if ( *(_BYTE *)(a2 + 24) >= 8u )
        goto LABEL_8;
    }
    *(_BYTE *)(a2 + 24) = 8;
LABEL_8:
    *(_WORD *)(a2 + 22) = 0;
  }
  if ( *(char *)(a1 + 112) < 0 )
  {
    v3 = *(_BYTE *)(a2 + 25) & 0xFB;
    *(_WORD *)(a2 + 22) = 0;
    *(_BYTE *)(a2 + 25) = v3;
    *(_DWORD *)(a2 + 90) = *(_DWORD *)(a1 + 312);
    *(_DWORD *)(a2 + 94) = *(_DWORD *)(a1 + 316);
    *(_WORD *)(a2 + 98) = *(_WORD *)(a1 + 320);
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x2000) != 0 )
  {
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 348);
    *(_DWORD *)(a2 + 252) = *(_DWORD *)(a1 + 564);
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x400) != 0 && *(_BYTE *)(a2 + 24) == 16 )
    *(_BYTE *)(a2 + 24) = 8;
  if ( (*(_BYTE *)(a1 + 112) & 0x40) != 0 )
  {
    v4 = *(_BYTE *)(a2 + 25);
    if ( (v4 == 2 || v4 == 6) && *(_DWORD *)(a1 + 492) && *(_BYTE *)(a2 + 24) == 8 )
      *(_BYTE *)(a2 + 25) = 3;
  }
  if ( (*(_BYTE *)(a1 + 112) & 4) != 0 && *(_BYTE *)(a2 + 24) < 8u )
    *(_BYTE *)(a2 + 24) = 8;
  if ( (*(_DWORD *)(a1 + 112) & 0x4000) != 0 )
    *(_BYTE *)(a2 + 25) |= 2u;
  if ( (*(_DWORD *)(a1 + 112) & 0x600000) != 0 )
    *(_BYTE *)(a2 + 25) &= 0xFDu;
  v5 = *(_BYTE *)(a2 + 25);
  if ( v5 == 3 || (v5 & 2) == 0 )
    *(_BYTE *)(a2 + 29) = 1;
  else
    *(_BYTE *)(a2 + 29) = 3;
  if ( (*(_DWORD *)(a1 + 112) & 0x40000) != 0 )
    *(_BYTE *)(a2 + 25) = v5 & 0xFB;
  v6 = *(_BYTE *)(a2 + 25);
  if ( (v6 & 4) != 0 )
    ++*(_BYTE *)(a2 + 29);
  if ( (*(_DWORD *)(a1 + 112) & 0x8000) != 0 && (v6 == 2 || !v6) )
    ++*(_BYTE *)(a2 + 29);
  if ( (*(_DWORD *)(a1 + 112) & 0x100000) != 0 )
  {
    v7 = *(_BYTE *)(a1 + 100);
    if ( *(_BYTE *)(a2 + 24) < v7 )
      *(_BYTE *)(a2 + 24) = v7;
    v8 = *(_BYTE *)(a1 + 101);
    if ( *(_BYTE *)(a2 + 29) < v8 )
      *(_BYTE *)(a2 + 29) = v8;
  }
  v9 = *(_BYTE *)(a2 + 29) * *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a2 + 30) = v9;
  result = (*(_DWORD *)a2 * (unsigned int)v9 + 7) >> 3;
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

//----- (0047FD60) --------------------------------------------------------
void __cdecl sub_47FD60(int a1)
{
  int v1; // eax
  int v2; // eax
  void (__cdecl *v3)(int, int, int); // eax
  char v4; // al
  char v5; // al
  int v6; // ecx
  unsigned __int8 v7; // al
  char Buffer[52]; // [esp+4h] [ebp-34h] BYREF

  if ( !*(_DWORD *)(a1 + 236) )
  {
    sprintf_0(Buffer, "NULL row buffer for row %ld, pass %d", *(_DWORD *)(a1 + 228), *(unsigned __int8 *)(a1 + 292));
    sub_484040((int *)a1, Buffer);
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x1000) != 0 )
  {
    if ( *(_BYTE *)(a1 + 264) == 3 )
    {
      sub_482660(
        (int *)(a1 + 256),
        *(_DWORD *)(a1 + 236) + 1,
        *(_DWORD *)(a1 + 276),
        *(_DWORD *)(a1 + 392),
        *(unsigned __int16 *)(a1 + 282));
    }
    else if ( *(_WORD *)(a1 + 282) )
    {
      sub_482890((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1, (_WORD *)(a1 + 396));
    }
    else
    {
      sub_482890((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1, 0);
    }
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x40000) != 0 )
    sub_47E270(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1), 128);
  if ( (*(_DWORD *)(a1 + 112) & 0x600000) != 0
    && sub_480A90(a1, (int *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1)) )
  {
    v1 = *(_DWORD *)(a1 + 112);
    *(_BYTE *)(a1 + 552) = 1;
    if ( v1 == 0x400000 )
      sub_4840E0(a1, aPngDoRgbToGray);
    if ( *(_DWORD *)(a1 + 112) == 0x200000 )
      sub_484040((int *)a1, aPngDoRgbToGray);
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x4000) != 0 && (*(_DWORD *)(a1 + 104) & 0x800) == 0 )
    sub_480950((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( *(char *)(a1 + 112) < 0 && (*(_WORD *)(a1 + 282) || (*(_BYTE *)(a1 + 294) & 4) != 0) )
    sub_481270(
      a1 + 396,
      (int *)(a1 + 256),
      (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1),
      (_WORD *)(a1 + 396),
      (_BYTE *)(a1 + 312),
      (_WORD *)(a1 + 322),
      *(_DWORD *)(a1 + 356),
      *(_DWORD *)(a1 + 360),
      *(_DWORD *)(a1 + 364),
      *(_DWORD *)(a1 + 368),
      *(_DWORD *)(a1 + 372),
      *(_DWORD *)(a1 + 376),
      *(_DWORD *)(a1 + 344));
  v2 = *(_DWORD *)(a1 + 112);
  if ( (v2 & 0x2000) != 0
    && ((v2 & 0x80u) == 0 || !*(_WORD *)(a1 + 282) && (*(_BYTE *)(a1 + 294) & 4) == 0)
    && *(_BYTE *)(a1 + 294) != 3 )
  {
    sub_482270(
      (int *)(a1 + 256),
      (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1),
      *(_DWORD *)(a1 + 356),
      *(_DWORD *)(a1 + 368),
      *(_DWORD *)(a1 + 344));
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x400) != 0 )
    sub_4804C0(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_BYTE *)(a1 + 112) & 0x40) != 0 )
  {
    sub_482C20((int *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), *(_DWORD *)(a1 + 492), *(_DWORD *)(a1 + 496));
    if ( !*(_DWORD *)(a1 + 260) )
      sub_484040((int *)a1, aPngDoDitherRet);
  }
  if ( (*(_BYTE *)(a1 + 112) & 0x20) != 0 )
    sub_47E160(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_BYTE *)(a1 + 112) & 8) != 0 )
    sub_4802E0((int *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), (unsigned __int8 *)(a1 + 385));
  if ( (*(_BYTE *)(a1 + 112) & 4) != 0 )
    sub_4801B0((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
    sub_47E480((int *)(a1 + 256), (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
    sub_47E220((unsigned __int8 *)(a1 + 256), (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x4000) != 0 && (*(_DWORD *)(a1 + 104) & 0x800) != 0 )
    sub_480950((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (BYTE1(*(_DWORD *)(a1 + 112)) & 0x80u) != 0 )
    sub_4806E0(a1 + 256, *(_DWORD *)(a1 + 236) + 1, *(unsigned __int16 *)(a1 + 302), *(_DWORD *)(a1 + 108));
  if ( (*(_DWORD *)(a1 + 112) & 0x80000) != 0 )
    sub_480610((char *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_DWORD *)(a1 + 112) & 0x20000) != 0 )
    sub_480510((char *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
  if ( (*(_BYTE *)(a1 + 112) & 0x10) != 0 )
    sub_47E1F0(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
  if ( (*(_DWORD *)(a1 + 112) & 0x100000) != 0 )
  {
    v3 = *(void (__cdecl **)(int, int, int))(a1 + 88);
    if ( v3 )
      v3(a1, a1 + 256, *(_DWORD *)(a1 + 236) + 1);
    v4 = *(_BYTE *)(a1 + 100);
    if ( v4 )
      *(_BYTE *)(a1 + 265) = v4;
    v5 = *(_BYTE *)(a1 + 101);
    if ( v5 )
      *(_BYTE *)(a1 + 266) = v5;
    v6 = *(_DWORD *)(a1 + 256);
    v7 = *(_BYTE *)(a1 + 265) * *(_BYTE *)(a1 + 266);
    *(_BYTE *)(a1 + 267) = v7;
    *(_DWORD *)(a1 + 260) = ((unsigned int)v7 * v6 + 7) >> 3;
  }
}

//----- (004801B0) --------------------------------------------------------
char __cdecl sub_4801B0(int *a1, int a2)
{
  int *v2; // edx
  int v3; // eax
  int v4; // esi
  _BYTE *v5; // edi
  _BYTE *v6; // ebp
  int v7; // eax
  _BYTE *v8; // edi
  _BYTE *v9; // ebp
  int v10; // eax
  int v11; // edx
  _BYTE *v12; // edi
  _BYTE *v13; // ebp
  int v14; // eax
  int v15; // edx
  char v16; // cl
  int v18; // [esp+8h] [ebp+8h]

  v2 = a1;
  LOBYTE(v3) = *((_BYTE *)a1 + 9);
  if ( (unsigned __int8)v3 < 8u )
  {
    v4 = *a1;
    if ( *((_BYTE *)a1 + 9) == 1 )
    {
      v12 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 3));
      v13 = (_BYTE *)(v4 + a2 - 1);
      v14 = 7 - ((v4 - 1) & 7);
      if ( v4 )
      {
        v15 = *a1;
        do
        {
          *v13 = (*v12 >> v14) & 1;
          if ( v14 == 7 )
          {
            v14 = 0;
            --v12;
          }
          else
          {
            ++v14;
          }
          --v13;
          --v15;
        }
        while ( v15 );
        goto LABEL_25;
      }
    }
    else
    {
      if ( *((_BYTE *)a1 + 9) != 2 )
      {
        if ( *((_BYTE *)a1 + 9) == 4 )
        {
          v5 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 1));
          v6 = (_BYTE *)(v4 + a2 - 1);
          v7 = 4 - 4 * ((v4 - 1) & 1);
          if ( v4 )
          {
            v18 = *a1;
            do
            {
              *v6 = (*v5 >> v7) & 0xF;
              if ( v7 == 4 )
              {
                v7 = 0;
                --v5;
              }
              else
              {
                v7 = 4;
              }
              --v6;
              --v18;
            }
            while ( v18 );
          }
        }
        goto LABEL_26;
      }
      v8 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 2));
      v9 = (_BYTE *)(v4 + a2 - 1);
      v10 = 6 - 2 * ((v4 - 1) & 3);
      if ( v4 )
      {
        v11 = *a1;
        do
        {
          *v9 = (*v8 >> v10) & 3;
          if ( v10 == 6 )
          {
            v10 = 0;
            --v8;
          }
          else
          {
            v10 += 2;
          }
          --v9;
          --v11;
        }
        while ( v11 );
LABEL_25:
        v2 = a1;
        goto LABEL_26;
      }
    }
LABEL_26:
    v16 = 8 * *((_BYTE *)v2 + 10);
    v3 = v4 * *((unsigned __int8 *)v2 + 10);
    *((_BYTE *)v2 + 9) = 8;
    *((_BYTE *)v2 + 11) = v16;
    v2[1] = v3;
  }
  return v3;
}

//----- (004802E0) --------------------------------------------------------
char __cdecl sub_4802E0(int *a1, _BYTE *a2, unsigned __int8 *a3)
{
  int i; // eax
  int v5; // ebp
  int v6; // ecx
  int v7; // edx
  int v8; // edi
  int *v9; // edx
  int v10; // ebx
  int v11; // edi
  _BYTE *j; // esi
  unsigned int v13; // ebp
  _BYTE *v14; // esi
  unsigned int k; // ebx
  unsigned int v16; // ebp
  unsigned __int8 *v17; // esi
  unsigned int l; // ebx
  int v20[4]; // [esp+10h] [ebp-10h] BYREF
  __int16 v21; // [esp+24h] [ebp+4h]
  int v22; // [esp+2Ch] [ebp+Ch]

  LOBYTE(i) = *((_BYTE *)a1 + 8);
  if ( (_BYTE)i != 3 )
  {
    v5 = *a1;
    v21 = 0;
    if ( (i & 2) != 0 )
    {
      v6 = *((unsigned __int8 *)a1 + 9);
      i = v6 - *a3;
      v7 = a3[2];
      v20[1] = v6 - a3[1];
      v20[0] = i;
      v20[2] = v6 - v7;
      v8 = 3;
    }
    else
    {
      v8 = 1;
      v6 = *((unsigned __int8 *)a1 + 9);
      LOBYTE(i) = *((_BYTE *)a1 + 9) - a3[3];
      v20[0] = v6 - a3[3];
    }
    if ( (a1[2] & 4) != 0 )
    {
      v20[v8] = v6 - a3[4];
      LOBYTE(i) = v20[0];
      ++v8;
    }
    if ( v8 > 0 )
    {
      v9 = v20;
      v22 = v8;
      do
      {
        if ( *v9 > 0 )
        {
          v21 = 1;
        }
        else
        {
          *v9 = 0;
          LOBYTE(i) = v20[0];
        }
        ++v9;
        --v22;
      }
      while ( v22 );
      if ( v21 )
      {
        switch ( v6 )
        {
          case 2:
            v10 = a1[1];
            for ( i = (int)a2; v10; --v10 )
            {
              *(_BYTE *)i = (*(_BYTE *)i >> 1) & 0x55;
              ++i;
            }
            break;
          case 4:
            v11 = a1[1];
            for ( j = a2; v11; --v11 )
            {
              *j = ((15 >> i) | (240 >> i) & 0xF0) & (*j >> i);
              ++j;
            }
            break;
          case 8:
            v13 = v8 * v5;
            v14 = a2;
            for ( k = 0; k < v13; *(v14 - 1) = i )
            {
              LOBYTE(i) = *v14++ >> LOBYTE(v20[k % v8]);
              ++k;
            }
            break;
          case 16:
            v16 = v8 * v5;
            v17 = a2;
            for ( l = 0; l < v16; *(v17 - 1) = i )
            {
              LOWORD(i) = (unsigned __int16)(v17[1] + (*v17 << 8)) >> LOWORD(v20[l % v8]);
              v17 += 2;
              ++l;
              *(v17 - 2) = BYTE1(i);
            }
            break;
          default:
            return i;
        }
      }
    }
  }
  return i;
}

//----- (004804C0) --------------------------------------------------------
void __cdecl sub_4804C0(int a1, char *a2)
{
  char *v2; // ecx
  char *v3; // edx
  int v4; // edi
  char v5; // al
  unsigned __int8 v6; // al
  char v7; // cl
  int v8; // eax

  if ( *(_BYTE *)(a1 + 9) == 16 )
  {
    v2 = a2;
    v3 = a2;
    if ( *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
    {
      v4 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
      do
      {
        v5 = *v2;
        v2 += 2;
        *v3++ = v5;
        --v4;
      }
      while ( v4 );
    }
    v6 = *(_BYTE *)(a1 + 10);
    *(_BYTE *)(a1 + 9) = 8;
    v7 = 8 * v6;
    v8 = *(_DWORD *)a1 * v6;
    *(_BYTE *)(a1 + 11) = v7;
    *(_DWORD *)(a1 + 4) = v8;
  }
}

//----- (00480510) --------------------------------------------------------
char *__cdecl sub_480510(char *a1, int a2)
{
  char *result; // eax
  char v3; // cl
  int v4; // edx
  int v5; // eax
  char *v6; // ecx
  int v7; // esi
  char v8; // dl
  char *v9; // eax
  char *v10; // ecx
  char v11; // bl
  char v12; // bl
  char *v13; // ecx
  int v14; // esi
  char v15; // dl
  char *v16; // eax
  char v17; // bl
  char *v18; // ecx
  char v19; // bl
  char v20; // bl
  char v21; // bl
  char v22; // bl
  char v23; // bl
  int v24; // eax
  char *v25; // ecx
  int v26; // esi
  char v27; // dl
  char *v28; // ecx
  int v29; // esi
  char v30; // dl
  char *v31; // eax
  char v32; // bl
  char *v33; // ecx
  char v34; // bl
  char v35; // [esp+11h] [ebp+9h]
  char v36; // [esp+11h] [ebp+9h]

  result = a1;
  v3 = a1[8];
  v4 = *(_DWORD *)a1;
  if ( v3 == 6 )
  {
    v5 = *((_DWORD *)a1 + 1);
    if ( a1[9] == 8 )
    {
      result = (char *)(a2 + v5);
      v6 = result;
      if ( v4 )
      {
        v7 = *(_DWORD *)a1;
        do
        {
          v8 = *(result - 1);
          v9 = result - 2;
          v10 = v6 - 1;
          v11 = *v9--;
          *v10-- = v11;
          v12 = *v9;
          result = v9 - 1;
          *v10-- = v12;
          *v10 = *result;
          v6 = v10 - 1;
          --v7;
          *v6 = v8;
        }
        while ( v7 );
      }
    }
    else
    {
      result = (char *)(a2 + v5);
      v13 = result;
      if ( v4 )
      {
        v14 = *(_DWORD *)a1;
        do
        {
          v15 = *(result - 1);
          v16 = result - 2;
          v17 = *v16--;
          v35 = v17;
          v18 = v13 - 1;
          v19 = *v16--;
          *v18-- = v19;
          v20 = *v16--;
          *v18-- = v20;
          v21 = *v16--;
          *v18-- = v21;
          v22 = *v16--;
          *v18-- = v22;
          v23 = *v16;
          result = v16 - 1;
          *v18-- = v23;
          *v18-- = *result;
          *v18 = v15;
          v13 = v18 - 1;
          --v14;
          *v13 = v35;
        }
        while ( v14 );
      }
    }
  }
  else if ( v3 == 4 )
  {
    v24 = *((_DWORD *)a1 + 1);
    if ( a1[9] == 8 )
    {
      result = (char *)(a2 + v24);
      v25 = result;
      if ( v4 )
      {
        v26 = *(_DWORD *)a1;
        do
        {
          v27 = *(result - 1);
          result -= 2;
          v25 -= 2;
          --v26;
          v25[1] = *result;
          *v25 = v27;
        }
        while ( v26 );
      }
    }
    else
    {
      result = (char *)(a2 + v24);
      v28 = result;
      if ( v4 )
      {
        v29 = *(_DWORD *)a1;
        do
        {
          v30 = *(result - 1);
          v31 = result - 2;
          v32 = *v31--;
          v36 = v32;
          v33 = v28 - 1;
          v34 = *v31;
          result = v31 - 1;
          *v33-- = v34;
          *v33-- = *result;
          *v33 = v30;
          v28 = v33 - 1;
          --v29;
          *v28 = v36;
        }
        while ( v29 );
      }
    }
  }
  return result;
}

//----- (00480610) --------------------------------------------------------
char *__cdecl sub_480610(char *a1, int a2)
{
  char *result; // eax
  char v3; // cl
  int v4; // edx
  int v5; // eax
  char v6; // bl
  int v7; // esi
  char *v8; // ecx
  char v9; // dl
  char *v10; // eax
  char v11; // bl
  int v12; // eax
  char *v13; // ecx
  int v14; // esi
  char v15; // bl
  char *v16; // ecx
  int v17; // esi
  char *v18; // ecx
  char v19; // dl
  char *v20; // eax
  char v21; // bl

  result = a1;
  v3 = a1[8];
  v4 = *(_DWORD *)a1;
  if ( v3 == 6 )
  {
    v5 = *((_DWORD *)a1 + 1);
    if ( a1[9] == 8 )
    {
      for ( result = (char *)(a2 + v5); v4; result[3] = -1 - v6 )
      {
        v6 = *(result - 1);
        result -= 4;
        --v4;
      }
    }
    else
    {
      result = (char *)(a2 + v5);
      if ( v4 )
      {
        v7 = *(_DWORD *)a1;
        do
        {
          v8 = result - 1;
          v9 = -1 - *(result - 1);
          v10 = result - 2;
          *v8 = v9;
          v11 = *v10;
          result = v10 - 6;
          --v7;
          *(v8 - 1) = -1 - v11;
        }
        while ( v7 );
      }
    }
  }
  else if ( v3 == 4 )
  {
    v12 = *((_DWORD *)a1 + 1);
    if ( a1[9] == 8 )
    {
      result = (char *)(a2 + v12);
      v13 = result;
      if ( v4 )
      {
        v14 = *(_DWORD *)a1;
        do
        {
          v15 = *(result - 1);
          v16 = v13 - 1;
          result -= 2;
          *v16 = -1 - v15;
          v13 = v16 - 1;
          --v14;
          *v13 = *result;
        }
        while ( v14 );
      }
    }
    else
    {
      result = (char *)(a2 + v12);
      if ( v4 )
      {
        v17 = *(_DWORD *)a1;
        do
        {
          v18 = result - 1;
          v19 = -1 - *(result - 1);
          v20 = result - 2;
          *v18 = v19;
          v21 = *v20;
          result = v20 - 2;
          --v17;
          *(v18 - 1) = -1 - v21;
        }
        while ( v17 );
      }
    }
  }
  return result;
}

//----- (004806E0) --------------------------------------------------------
char __cdecl sub_4806E0(int a1, int a2, unsigned int a3, char a4)
{
  char *v4; // eax
  unsigned int v5; // esi
  unsigned int v6; // ebx
  char *v7; // edi
  unsigned int v8; // ecx
  char *v9; // eax
  unsigned int v10; // ecx
  char v11; // bl
  char *v12; // eax
  char *v13; // edi
  char *v14; // eax
  char *v15; // edi
  char v16; // cl
  char v17; // cl
  char *v18; // eax
  int v19; // ecx
  char *v20; // edi
  unsigned int v21; // ecx
  char *v22; // eax
  char *v23; // edi
  char v24; // bl
  char v25; // bl
  char *v26; // ecx
  unsigned int v27; // edi
  char v28; // bl
  char *v29; // eax
  char *v30; // ecx
  char v31; // bl
  int v32; // eax
  char *v33; // ecx
  char *v34; // eax
  unsigned int v35; // edi
  char *v36; // eax
  char *v37; // ecx
  char v38; // bl
  char v39; // bl
  char v40; // bl
  char v41; // bl
  char v42; // bl
  char *v43; // ecx
  unsigned int v44; // edi
  char v45; // bl
  char *v46; // eax
  char *v47; // ecx
  char v48; // bl
  char v49; // bl
  char v50; // bl
  char v51; // bl
  unsigned int v53; // [esp+18h] [ebp+8h]
  unsigned int v54; // [esp+18h] [ebp+8h]

  LOBYTE(v4) = *(_BYTE *)(a1 + 8);
  v5 = *(_DWORD *)a1;
  v6 = a3 >> 8;
  if ( (_BYTE)v4 )
  {
    if ( (_BYTE)v4 == 2 )
    {
      LOBYTE(v4) = *(_BYTE *)(a1 + 9);
      if ( (_BYTE)v4 == 8 )
      {
        if ( a4 >= 0 )
        {
          v26 = (char *)(a2 + 2 * v5 + v5);
          v4 = &v26[v5];
          if ( v5 )
          {
            v27 = *(_DWORD *)a1;
            do
            {
              v28 = *(v26 - 1);
              v29 = v4 - 1;
              v30 = v26 - 2;
              *v29 = v28;
              v31 = *v30;
              --v29;
              v26 = v30 - 1;
              *v29-- = v31;
              *v29 = *v26;
              v4 = v29 - 1;
              --v27;
              *v4 = a3;
            }
            while ( v27 );
          }
          *(_BYTE *)(a1 + 10) = 4;
          *(_BYTE *)(a1 + 11) = 32;
          *(_DWORD *)(a1 + 4) = 4 * v5;
        }
        else
        {
          v19 = a2 + 2 * v5;
          v20 = (char *)(v19 + v5);
          v4 = (char *)(v19 + v5 + v5);
          if ( v5 > 1 )
          {
            v21 = v5 - 1;
            do
            {
              v22 = v4 - 1;
              v23 = v20 - 1;
              *v22 = a3;
              v24 = *v23;
              --v22;
              --v23;
              *v22 = v24;
              v25 = *v23;
              --v22;
              v20 = v23 - 1;
              *v22 = v25;
              v4 = v22 - 1;
              --v21;
              *v4 = *v20;
            }
            while ( v21 );
          }
          *(v4 - 1) = a3;
          *(_BYTE *)(a1 + 10) = 4;
          *(_BYTE *)(a1 + 11) = 32;
          *(_DWORD *)(a1 + 4) = 4 * v5;
        }
      }
      else if ( (_BYTE)v4 == 16 )
      {
        v32 = a2 + 2 * v5;
        if ( a4 >= 0 )
        {
          v43 = (char *)(v32 + v5);
          v4 = (char *)(v32 + v5 + v5);
          if ( v5 )
          {
            v44 = *(_DWORD *)a1;
            do
            {
              v45 = *(v43 - 1);
              v46 = v4 - 1;
              v47 = v43 - 2;
              *v46 = v45;
              v48 = *v47;
              --v46;
              --v47;
              *v46 = v48;
              v49 = *v47;
              --v46;
              --v47;
              *v46 = v49;
              v50 = *v47;
              --v46;
              --v47;
              *v46 = v50;
              v51 = *v47;
              --v46;
              v43 = v47 - 1;
              *v46-- = v51;
              *v46-- = *v43;
              *v46 = BYTE1(a3);
              v4 = v46 - 1;
              --v44;
              *v4 = a3;
            }
            while ( v44 );
          }
        }
        else
        {
          v33 = (char *)(v32 + v5);
          v34 = (char *)(v32 + v5 + v5);
          if ( v5 > 1 )
          {
            v35 = v5 - 1;
            do
            {
              v36 = v34 - 1;
              *v36-- = v6;
              v37 = v33 - 1;
              *v36-- = a3;
              v38 = *v37--;
              *v36-- = v38;
              v39 = *v37--;
              *v36-- = v39;
              v40 = *v37--;
              *v36-- = v40;
              v41 = *v37--;
              *v36-- = v41;
              v42 = *v37;
              v33 = v37 - 1;
              *v36 = v42;
              v34 = v36 - 1;
              --v35;
              *v34 = *v33;
              LOBYTE(v6) = BYTE1(a3);
            }
            while ( v35 );
          }
          v4 = v34 - 1;
          *v4 = v6;
          *(v4 - 1) = a3;
        }
        *(_BYTE *)(a1 + 10) = 4;
        *(_BYTE *)(a1 + 11) = 64;
        *(_DWORD *)(a1 + 4) = 8 * v5;
      }
    }
  }
  else
  {
    LOBYTE(v4) = *(_BYTE *)(a1 + 9);
    if ( (_BYTE)v4 == 8 )
    {
      v7 = (char *)(v5 + a2);
      v4 = (char *)(v5 + a2 + v5);
      if ( a4 >= 0 )
      {
        if ( v5 )
        {
          v10 = *(_DWORD *)a1;
          do
          {
            v11 = *--v7;
            v12 = v4 - 1;
            *v12 = v11;
            v4 = v12 - 1;
            --v10;
            *v4 = a3;
          }
          while ( v10 );
        }
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 16;
        *(_DWORD *)(a1 + 4) = 2 * v5;
      }
      else
      {
        if ( v5 > 1 )
        {
          v8 = v5 - 1;
          do
          {
            v9 = v4 - 1;
            --v7;
            *v9 = a3;
            v4 = v9 - 1;
            --v8;
            *v4 = *v7;
          }
          while ( v8 );
        }
        *(v4 - 1) = a3;
        *(_BYTE *)(a1 + 10) = 2;
        *(_BYTE *)(a1 + 11) = 16;
        *(_DWORD *)(a1 + 4) = 2 * v5;
      }
    }
    else if ( (_BYTE)v4 == 16 )
    {
      v13 = (char *)(v5 + a2);
      v4 = (char *)(v5 + a2 + v5);
      if ( a4 >= 0 )
      {
        if ( v5 )
        {
          v54 = *(_DWORD *)a1;
          do
          {
            v17 = *(v13 - 1);
            v18 = v4 - 1;
            v13 -= 2;
            *v18-- = v17;
            *v18-- = *v13;
            *v18 = BYTE1(a3);
            v4 = v18 - 1;
            *v4 = a3;
            --v54;
          }
          while ( v54 );
        }
      }
      else
      {
        if ( v5 > 1 )
        {
          v53 = v5 - 1;
          do
          {
            v14 = v4 - 1;
            *v14-- = BYTE1(a3);
            v15 = v13 - 1;
            *v14-- = a3;
            v16 = *v15;
            v13 = v15 - 1;
            *v14 = v16;
            v4 = v14 - 1;
            *v4 = *v13;
            --v53;
          }
          while ( v53 );
        }
        *(_WORD *)(--v4 - 1) = a3;
      }
      *(_BYTE *)(a1 + 10) = 2;
      *(_BYTE *)(a1 + 11) = 32;
      *(_DWORD *)(a1 + 4) = 4 * v5;
    }
  }
  return (char)v4;
}

//----- (00480950) --------------------------------------------------------
void __cdecl sub_480950(int *a1, int a2)
{
  unsigned __int8 v2; // cl
  int v3; // esi
  char v4; // al
  _BYTE *v5; // ecx
  _BYTE *v6; // eax
  int v7; // ebp
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  _BYTE *v10; // eax
  int v11; // ebp
  _BYTE *v12; // eax
  _BYTE *v13; // ecx
  _BYTE *v14; // eax
  int v15; // ebp
  char v16; // bl
  _BYTE *v17; // eax
  _BYTE *v18; // ecx
  _BYTE *v19; // ecx
  _BYTE *v20; // eax
  int v21; // ebp
  char v22; // bl
  _BYTE *v23; // eax
  _BYTE *v24; // ecx
  char v25; // bl
  char v26; // cl
  unsigned __int8 v27; // al

  v2 = *((_BYTE *)a1 + 9);
  v3 = *a1;
  if ( v2 >= 8u )
  {
    v4 = *((_BYTE *)a1 + 8);
    if ( (v4 & 2) == 0 )
    {
      if ( v4 )
      {
        if ( v4 == 4 )
        {
          if ( v2 == 8 )
          {
            v13 = (_BYTE *)(a2 + 2 * v3 - 1);
            v14 = &v13[2 * v3];
            if ( v3 )
            {
              v15 = *a1;
              do
              {
                *v14 = *v13;
                v16 = *(v13 - 1);
                v17 = v14 - 1;
                v18 = v13 - 1;
                *v17-- = v16;
                *v17-- = *v18;
                *v17 = *v18;
                v14 = v17 - 1;
                v13 = v18 - 1;
                --v15;
              }
              while ( v15 );
            }
          }
          else
          {
            v19 = (_BYTE *)(a2 + 4 * v3 - 1);
            v20 = &v19[4 * v3];
            if ( v3 )
            {
              v21 = *a1;
              do
              {
                *v20 = *v19;
                v22 = *(v19 - 1);
                v23 = v20 - 1;
                v24 = v19 - 1;
                *v23 = v22;
                v25 = *(v24 - 1);
                --v23;
                --v24;
                *v23-- = v25;
                *v23-- = *(v24 - 1);
                *v23-- = *v24;
                *v23-- = *(v24 - 1);
                *v23-- = *v24;
                *v23 = *(v24 - 1);
                v20 = v23 - 1;
                v19 = v24 - 2;
                --v21;
              }
              while ( v21 );
            }
          }
        }
      }
      else if ( v2 == 8 )
      {
        v5 = (_BYTE *)(v3 + a2 - 1);
        v6 = &v5[2 * v3];
        if ( v3 )
        {
          v7 = *a1;
          do
          {
            *v6 = *v5;
            v8 = v6 - 1;
            *v8-- = *v5;
            *v8 = *v5;
            v6 = v8 - 1;
            --v5;
            --v7;
          }
          while ( v7 );
        }
      }
      else
      {
        v9 = (_BYTE *)(a2 + 2 * v3 - 1);
        v10 = &v9[4 * v3];
        if ( v3 )
        {
          v11 = *a1;
          do
          {
            *v10 = *v9;
            v12 = v10 - 1;
            *v12-- = *(v9 - 1);
            *v12-- = *v9;
            *v12-- = *(v9 - 1);
            *v12-- = *v9;
            *v12 = *(v9 - 1);
            v10 = v12 - 1;
            v9 -= 2;
            --v11;
          }
          while ( v11 );
        }
      }
      v26 = *((_BYTE *)a1 + 10) + 2;
      *((_BYTE *)a1 + 8) |= 2u;
      v27 = v26 * *((_BYTE *)a1 + 9);
      *((_BYTE *)a1 + 11) = v27;
      *((_BYTE *)a1 + 10) = v26;
      a1[1] = (v3 * (unsigned int)v27 + 7) >> 3;
    }
  }
}

//----- (00480A90) --------------------------------------------------------
int __cdecl sub_480A90(int a1, int *a2, _BYTE *a3)
{
  int v3; // ecx
  char v4; // al
  int v6; // ebp
  int v7; // ebx
  unsigned __int8 *v8; // esi
  unsigned __int8 *v9; // edi
  int v10; // esi
  int v11; // ecx
  unsigned __int8 *v12; // edi
  unsigned __int8 v13; // al
  int v14; // ecx
  int v15; // ecx
  _BYTE *v16; // esi
  bool v17; // zf
  unsigned __int8 *v18; // esi
  _BYTE *v19; // edi
  unsigned __int8 v20; // al
  unsigned __int8 *v21; // esi
  unsigned __int8 v22; // cl
  _BYTE *v23; // edi
  unsigned __int16 v24; // cx
  unsigned __int16 v25; // ax
  _BYTE *v26; // edi
  unsigned __int16 v27; // cx
  unsigned __int16 v28; // si
  __int16 v29; // cx
  unsigned int v30; // eax
  _BYTE *v31; // esi
  unsigned __int16 v32; // ax
  unsigned __int16 v33; // cx
  unsigned __int16 v34; // di
  _BYTE *v35; // esi
  unsigned __int16 v36; // ax
  unsigned int v37; // eax
  int v38; // edi
  int v39; // eax
  unsigned __int8 *v40; // esi
  int v41; // ecx
  unsigned __int8 v42; // al
  int v43; // ecx
  _BYTE *v44; // esi
  int v45; // eax
  _BYTE *v46; // edi
  unsigned __int8 v47; // al
  unsigned __int8 v48; // cl
  unsigned __int8 *v49; // esi
  unsigned __int8 v50; // dl
  _BYTE *v51; // esi
  int v52; // eax
  _BYTE *v53; // edi
  _BYTE *v54; // ebp
  unsigned __int16 v55; // cx
  unsigned __int16 v56; // ax
  _BYTE *v57; // ebp
  unsigned __int16 v58; // di
  unsigned __int16 v59; // bx
  _BYTE *v60; // ebp
  __int16 v61; // cx
  unsigned int v62; // eax
  _BYTE *v63; // esi
  _BYTE *v64; // ecx
  unsigned __int16 v65; // ax
  unsigned __int16 v66; // dx
  unsigned __int16 v67; // di
  _BYTE *v68; // ecx
  unsigned __int16 v69; // ax
  _BYTE *v70; // ecx
  unsigned int v71; // eax
  _BYTE *v72; // esi
  char v73; // al
  char v74; // bl
  char v75; // cl
  char v76; // al
  unsigned __int8 v77; // al
  int v79; // [esp+8h] [ebp-24h]
  int v80; // [esp+Ch] [ebp-20h]
  _BYTE *v81; // [esp+10h] [ebp-1Ch]
  int v82; // [esp+14h] [ebp-18h]
  unsigned __int8 v83; // [esp+18h] [ebp-14h]
  int v84; // [esp+18h] [ebp-14h]
  int v85; // [esp+18h] [ebp-14h]
  int v86; // [esp+18h] [ebp-14h]
  unsigned __int8 v87; // [esp+1Ch] [ebp-10h]
  unsigned __int8 v88; // [esp+1Ch] [ebp-10h]
  _BYTE *v89; // [esp+1Ch] [ebp-10h]
  int v90; // [esp+1Ch] [ebp-10h]
  _BYTE *v91; // [esp+1Ch] [ebp-10h]
  int v92; // [esp+20h] [ebp-Ch]
  unsigned __int16 v93; // [esp+20h] [ebp-Ch]
  _BYTE *v94; // [esp+20h] [ebp-Ch]
  unsigned __int8 v95; // [esp+20h] [ebp-Ch]
  int v96; // [esp+20h] [ebp-Ch]
  int v97; // [esp+24h] [ebp-8h]
  unsigned __int8 v98; // [esp+28h] [ebp-4h]
  unsigned __int8 v99; // [esp+28h] [ebp-4h]
  int v100; // [esp+30h] [ebp+4h]
  unsigned __int8 v101; // [esp+38h] [ebp+Ch]
  int v102; // [esp+38h] [ebp+Ch]
  unsigned __int8 *v103; // [esp+38h] [ebp+Ch]
  int v104; // [esp+38h] [ebp+Ch]

  HIWORD(v3) = 0;
  v4 = *((_BYTE *)a2 + 8);
  v80 = *a2;
  v79 = 0;
  if ( (v4 & 2) == 0 )
    return 0;
  LOWORD(v3) = *(_WORD *)(a1 + 554);
  v6 = *(unsigned __int16 *)(a1 + 556);
  v7 = *(unsigned __int16 *)(a1 + 558);
  v100 = v3;
  v97 = (unsigned __int16)v6;
  v82 = (unsigned __int16)v7;
  if ( v4 != 2 )
    goto LABEL_37;
  if ( *((_BYTE *)a2 + 9) != 8 )
  {
    if ( *(_DWORD *)(a1 + 376) && *(_DWORD *)(a1 + 372) )
    {
      v23 = a3;
      v89 = a3;
      if ( v80 )
      {
        v85 = *a2;
        do
        {
          HIBYTE(v25) = *v23;
          HIBYTE(v24) = v23[2];
          LOBYTE(v25) = v23[1];
          LOBYTE(v24) = v23[3];
          v93 = v24;
          v26 = v23 + 4;
          HIBYTE(v27) = *v26;
          LOBYTE(v27) = v26[1];
          v23 = v26 + 2;
          v28 = v27;
          if ( v25 != v93 || v25 != v27 )
          {
            v29 = *(_WORD *)(a1 + 344);
            v6 = v97;
            v7 = v82;
            v30 = (unsigned __int16)((v82
                                    * *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                      + 4 * ((unsigned __int8)v28 >> v29))
                                                          + 2 * HIBYTE(v28))
                                    + v97
                                    * *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                      + 4 * ((unsigned __int8)v93 >> v29))
                                                          + 2 * HIBYTE(v93))
                                    + v100
                                    * (unsigned int)*(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                                    + 4 * ((unsigned __int8)v25 >> v29))
                                                                        + 2 * HIBYTE(v25))) >> 15);
            v25 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * ((unsigned __int8)v30 >> v29)) + 2 * (v30 >> 8));
            v79 |= 1u;
          }
          *v89 = HIBYTE(v25);
          v89[1] = v25;
          v17 = v85 == 1;
          v89 += 2;
          --v85;
        }
        while ( !v17 );
      }
    }
    else
    {
      v31 = a3;
      v94 = a3;
      if ( *a2 )
      {
        v90 = *a2;
        do
        {
          HIBYTE(v32) = *v31;
          HIBYTE(v33) = v31[2];
          LOBYTE(v32) = v31[1];
          LOBYTE(v33) = v31[3];
          v34 = v32;
          v35 = v31 + 4;
          HIBYTE(v36) = *v35;
          LOBYTE(v36) = v35[1];
          v31 = v35 + 2;
          if ( v34 != v33 || v34 != v36 )
            v79 |= 1u;
          v37 = (v100 * v34 + v6 * v33 + v7 * (unsigned int)v36) >> 15;
          *v94 = BYTE1(v37);
          v94[1] = v37;
          v17 = v90 == 1;
          v94 += 2;
          --v90;
        }
        while ( !v17 );
      }
    }
    goto LABEL_37;
  }
  if ( !*(_DWORD *)(a1 + 360) || !*(_DWORD *)(a1 + 364) )
  {
    v18 = a3;
    v19 = a3;
    if ( v80 )
    {
      v84 = *a2;
      do
      {
        v20 = *v18;
        v88 = v18[1];
        v21 = v18 + 2;
        v22 = *v21;
        v18 = v21 + 1;
        if ( v20 == v88 && v20 == v22 )
        {
          *v19 = *(v18 - 1);
        }
        else
        {
          v79 |= 1u;
          *v19 = (v100 * v20 + v6 * v88 + v7 * (unsigned int)v22) >> 15;
        }
        ++v19;
        --v84;
      }
      while ( v84 );
    }
    goto LABEL_37;
  }
  v8 = a3;
  v9 = a3;
  v81 = a3;
  if ( v80 )
  {
    v92 = *a2;
    do
    {
      v10 = *(_DWORD *)(a1 + 364);
      v11 = *v9;
      v12 = v9 + 1;
      v13 = *(_BYTE *)(v11 + v10);
      v14 = *v12++;
      v87 = *(_BYTE *)(v14 + v10);
      v15 = *v12;
      v9 = v12 + 1;
      v83 = *(_BYTE *)(v15 + v10);
      if ( v13 == v87 && v13 == v83 )
      {
        v16 = v81;
        *v81 = *(v9 - 1);
      }
      else
      {
        v79 |= 1u;
        v16 = v81;
        *v81 = *(_BYTE *)(((v100 * v13 + v6 * v87 + v7 * (unsigned int)v83) >> 15) + *(_DWORD *)(a1 + 360));
      }
      v17 = v92 == 1;
      v81 = v16 + 1;
      --v92;
    }
    while ( !v17 );
LABEL_37:
    v8 = a3;
  }
  if ( *((_BYTE *)a2 + 8) == 6 )
  {
    if ( *((_BYTE *)a2 + 9) == 8 )
    {
      if ( *(_DWORD *)(a1 + 360) && *(_DWORD *)(a1 + 364) )
      {
        v91 = v8;
        if ( v80 )
        {
          v86 = v80;
          do
          {
            v38 = *(_DWORD *)(a1 + 364);
            v39 = *v8;
            v40 = v8 + 1;
            v41 = *v40++;
            v42 = *(_BYTE *)(v39 + v38);
            v98 = v42;
            v95 = *(_BYTE *)(v41 + v38);
            v43 = *v40;
            v44 = v40 + 1;
            v101 = *(_BYTE *)(v43 + v38);
            if ( v42 != v95 || v42 != v101 )
            {
              v45 = v79;
              LOBYTE(v45) = v79 | 1;
              v79 = v45;
            }
            *v91 = *(_BYTE *)(((v100 * v98 + v6 * v95 + v7 * (unsigned int)v101) >> 15) + *(_DWORD *)(a1 + 360));
            v91[1] = *v44;
            v8 = v44 + 1;
            v91 += 2;
            --v86;
          }
          while ( v86 );
        }
      }
      else
      {
        v46 = v8;
        if ( v80 )
        {
          v102 = v80;
          do
          {
            v47 = *v8;
            v48 = v8[1];
            v99 = v47;
            v49 = v8 + 2;
            v50 = *v49;
            v51 = v49 + 1;
            if ( v47 != v48 || v47 != v50 )
            {
              v52 = v79;
              LOBYTE(v52) = v79 | 1;
              v79 = v52;
            }
            *v46 = (unsigned __int16)(v7 * v50 + v6 * (v99 + v48)) >> 8;
            v53 = v46 + 1;
            *v53 = *v51;
            v46 = v53 + 1;
            v8 = v51 + 1;
            --v102;
          }
          while ( v102 );
        }
      }
    }
    else if ( *(_DWORD *)(a1 + 376) && *(_DWORD *)(a1 + 372) )
    {
      v54 = v8;
      v103 = v8;
      if ( v80 )
      {
        v96 = v80;
        do
        {
          HIBYTE(v56) = *v54;
          HIBYTE(v55) = v54[2];
          LOBYTE(v56) = v54[1];
          LOBYTE(v55) = v54[3];
          v57 = v54 + 4;
          v58 = v55;
          HIBYTE(v59) = *v57;
          LOBYTE(v59) = v57[1];
          v60 = v57 + 2;
          if ( v56 != v55 || v56 != v59 )
          {
            v61 = *(_WORD *)(a1 + 344);
            v62 = (unsigned __int16)((v82
                                    * *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                      + 4 * ((unsigned __int8)v59 >> v61))
                                                          + 2 * HIBYTE(v59))
                                    + v97
                                    * *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                      + 4 * ((unsigned __int8)v58 >> v61))
                                                          + 2 * HIBYTE(v58))
                                    + v100
                                    * (unsigned int)*(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)(a1 + 376)
                                                                                    + 4 * ((unsigned __int8)v56 >> v61))
                                                                        + 2 * HIBYTE(v56))) >> 15);
            v8 = v103;
            v56 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * ((unsigned __int8)v62 >> v61)) + 2 * (v62 >> 8));
            v79 |= 1u;
          }
          v63 = v8 + 1;
          *(v63 - 1) = HIBYTE(v56);
          *v63++ = v56;
          *v63++ = *v60;
          *v63 = v60[1];
          v8 = v63 + 1;
          v54 = v60 + 2;
          v103 = v8;
          --v96;
        }
        while ( v96 );
      }
    }
    else
    {
      v64 = v8;
      if ( v80 )
      {
        v104 = v80;
        do
        {
          LOBYTE(v66) = v64[1];
          LOBYTE(v65) = v64[3];
          HIBYTE(v66) = *v64;
          HIBYTE(v65) = v64[2];
          v67 = v65;
          v68 = v64 + 4;
          LOBYTE(v69) = v68[1];
          HIBYTE(v69) = *v68;
          v70 = v68 + 2;
          if ( v66 != v67 || v66 != v69 )
          {
            v79 |= 1u;
            v7 = v82;
          }
          v71 = (v100 * v66 + v6 * v67 + v7 * (unsigned int)v69) >> 15;
          *v8 = BYTE1(v71);
          v72 = v8 + 1;
          *v72++ = v71;
          *v72++ = *v70;
          *v72 = v70[1];
          v8 = v72 + 1;
          v64 = v70 + 2;
          --v104;
        }
        while ( v104 );
      }
    }
  }
  v73 = *((_BYTE *)a2 + 10) - 2;
  v74 = a2[2] & 0xFD;
  *((_BYTE *)a2 + 10) = v73;
  v75 = v73;
  v76 = *((_BYTE *)a2 + 9);
  *((_BYTE *)a2 + 8) = v74;
  v77 = v75 * v76;
  *((_BYTE *)a2 + 11) = v77;
  a2[1] = (v80 * (unsigned int)v77 + 7) >> 3;
  return v79;
}

//----- (00481270) --------------------------------------------------------
void __usercall sub_481270(int a1@<edx>, int *a2, unsigned __int8 *a3, _WORD *a4, _BYTE *a5, _WORD *a6, int a7, int a8, int a9, int a10, int a11, int a12, char a13)
{
  int v13; // ecx
  _BYTE *v14; // ebp
  int v15; // ebx
  char v16; // al
  _BYTE *v17; // esi
  int v18; // edx
  int v19; // edi
  char v20; // al
  char v21; // bl
  _BYTE *v22; // esi
  int v23; // edx
  char v24; // al
  char v25; // bl
  int v26; // edi
  char v27; // al
  char v28; // bl
  _BYTE *v29; // esi
  int v30; // edx
  char v31; // al
  char v32; // bl
  int v33; // edi
  char v34; // al
  char v35; // bl
  unsigned __int8 *v36; // ecx
  int v37; // esi
  unsigned __int8 v38; // al
  _BYTE *i; // eax
  unsigned __int8 *v40; // eax
  int v41; // edi
  __int16 v42; // cx
  _BYTE *v43; // eax
  char v44; // dl
  int v45; // ecx
  char v46; // dl
  int v47; // ecx
  _BYTE *v48; // eax
  _BYTE *v49; // ecx
  unsigned __int8 *v50; // eax
  int v51; // ebp
  unsigned __int8 v52; // bl
  unsigned __int8 v53; // bl
  int v54; // ebx
  unsigned __int8 v55; // dl
  unsigned __int8 *v56; // eax
  unsigned __int8 *v57; // ecx
  _BYTE *v58; // esi
  __int16 v59; // ax
  unsigned int v60; // eax
  unsigned __int8 *v61; // ecx
  _BYTE *v62; // esi
  int v63; // ebp
  unsigned __int8 v64; // al
  unsigned int v65; // eax
  unsigned __int8 *v66; // edx
  _BYTE *v67; // esi
  unsigned __int8 *v68; // edx
  __int16 v69; // ax
  __int16 v70; // ax
  int v71; // eax
  int v72; // ebp
  unsigned int v73; // eax
  unsigned __int8 *v74; // esi
  unsigned __int8 *v75; // ecx
  __int16 v76; // ax
  int v77; // eax
  int v78; // ebx
  unsigned int v79; // eax
  int v80; // edx
  int v81; // ecx
  unsigned __int8 *v82; // edi
  _BYTE *v83; // ebx
  _BYTE *v84; // esi
  unsigned __int8 *v85; // edi
  unsigned __int8 v86; // al
  __int16 v87; // cx
  unsigned int v88; // edx
  unsigned int v89; // eax
  unsigned __int8 *v90; // edi
  _BYTE *v91; // esi
  unsigned __int8 *v92; // edi
  unsigned __int8 v93; // al
  int v94; // ecx
  __int16 v95; // cx
  unsigned int v96; // eax
  char v97; // bp
  _BYTE *v98; // eax
  _BYTE *v99; // edx
  unsigned __int8 *v100; // esi
  __int16 v101; // di
  char v102; // bl
  char v103; // bl
  __int16 v104; // ax
  int v105; // edi
  char v106; // bl
  unsigned int v107; // ecx
  __int16 v108; // ax
  unsigned __int16 v109; // bp
  unsigned int v110; // eax
  int v111; // ebx
  unsigned int v112; // eax
  _BYTE *v114; // edi
  unsigned __int8 *v115; // ebp
  unsigned __int16 v116; // cx
  unsigned int v117; // eax
  unsigned __int16 v118; // ax
  unsigned __int16 v119; // si
  int v120; // ebx
  unsigned int v121; // ecx
  unsigned int v122; // eax
  unsigned int v123; // esi
  char v124; // al
  char v125; // bl
  unsigned __int8 v126; // al
  int v127; // [esp+Ch] [ebp-4h]
  int v128; // [esp+18h] [ebp+8h]
  int v129; // [esp+18h] [ebp+8h]
  int v130; // [esp+18h] [ebp+8h]
  int v131; // [esp+18h] [ebp+8h]
  int v132; // [esp+18h] [ebp+8h]
  int v133; // [esp+18h] [ebp+8h]
  int v134; // [esp+18h] [ebp+8h]
  int v135; // [esp+18h] [ebp+8h]
  int v136; // [esp+18h] [ebp+8h]
  int v137; // [esp+28h] [ebp+18h]
  int v138; // [esp+28h] [ebp+18h]

  HIWORD(v13) = HIWORD(a2);
  v14 = a5;
  v15 = *a2;
  v127 = *a2;
  if ( a5 )
  {
    v16 = *((_BYTE *)a2 + 8);
    if ( (v16 & 4) == 0 || v16 != 3 && a4 )
    {
      switch ( *((_BYTE *)a2 + 8) )
      {
        case 0:
          switch ( *((_BYTE *)a2 + 9) )
          {
            case 1:
              v17 = a3;
              v18 = 7;
              if ( v15 )
              {
                v19 = *a2;
                do
                {
                  if ( ((*v17 >> v18) & 1) == a4[4] )
                  {
                    v20 = *v17 & (32639 >> (7 - v18));
                    *v17 = v20;
                    v21 = v14[8];
                    v14 = a5;
                    *v17 = v20 | (v21 << v18);
                  }
                  if ( v18 )
                  {
                    --v18;
                  }
                  else
                  {
                    v18 = 7;
                    ++v17;
                  }
                  --v19;
                }
                while ( v19 );
              }
              break;
            case 2:
              v22 = a3;
              v23 = 6;
              if ( a7 )
              {
                if ( v15 )
                {
                  v128 = *a2;
                  do
                  {
                    if ( ((*v22 >> v23) & 3) == a4[4] )
                    {
                      v24 = *v22 & (16191 >> (6 - v23));
                      *v22 = v24;
                      v25 = a5[8] << v23;
                    }
                    else
                    {
                      v25 = *v22 & (16191 >> (6 - v23));
                      v24 = *(_BYTE *)(((*v22 >> v23) & 3 | (4
                                                           * ((*v22 >> v23) & 3 | (4
                                                                                 * ((*v22 >> v23) & 3 | (4 * ((*v22 >> v23) & 3)))))))
                                     + a7) >> 6 << v23;
                    }
                    *v22 = v24 | v25;
                    if ( v23 )
                    {
                      v23 -= 2;
                    }
                    else
                    {
                      v23 = 6;
                      ++v22;
                    }
                    --v128;
                  }
                  while ( v128 );
                }
              }
              else if ( v15 )
              {
                v26 = *a2;
                do
                {
                  if ( ((*v22 >> v23) & 3) == a4[4] )
                  {
                    v27 = *v22 & (16191 >> (6 - v23));
                    *v22 = v27;
                    v28 = v14[8];
                    v14 = a5;
                    *v22 = v27 | (v28 << v23);
                  }
                  if ( v23 )
                  {
                    v23 -= 2;
                  }
                  else
                  {
                    v23 = 6;
                    ++v22;
                  }
                  --v26;
                }
                while ( v26 );
              }
              break;
            case 4:
              v29 = a3;
              v30 = 4;
              if ( a7 )
              {
                if ( v15 )
                {
                  v129 = *a2;
                  do
                  {
                    if ( ((*v29 >> v30) & 0xF) == a4[4] )
                    {
                      v31 = *v29 & (3855 >> (4 - v30));
                      *v29 = v31;
                      v32 = a5[8] << v30;
                    }
                    else
                    {
                      v32 = *v29 & (3855 >> (4 - v30));
                      v31 = *(_BYTE *)(((*v29 >> v30) & 0xF | (16 * ((*v29 >> v30) & 0xF))) + a7) >> 4 << v30;
                    }
                    *v29 = v31 | v32;
                    if ( v30 )
                    {
                      v30 -= 4;
                    }
                    else
                    {
                      v30 = 4;
                      ++v29;
                    }
                    --v129;
                  }
                  while ( v129 );
                }
              }
              else if ( v15 )
              {
                v33 = *a2;
                do
                {
                  if ( ((*v29 >> v30) & 0xF) == a4[4] )
                  {
                    v34 = *v29 & (3855 >> (4 - v30));
                    *v29 = v34;
                    v35 = v14[8];
                    v14 = a5;
                    *v29 = v34 | (v35 << v30);
                  }
                  if ( v30 )
                  {
                    v30 -= 4;
                  }
                  else
                  {
                    v30 = 4;
                    ++v29;
                  }
                  --v33;
                }
                while ( v33 );
              }
              break;
            case 8:
              if ( a7 )
              {
                v36 = a3;
                if ( v15 )
                {
                  v37 = *a2;
                  do
                  {
                    if ( *v36 == a4[4] )
                      v38 = a5[8];
                    else
                      v38 = *(_BYTE *)(*v36 + a7);
                    *v36++ = v38;
                    --v37;
                  }
                  while ( v37 );
                }
              }
              else
              {
                for ( i = a3; v15; --v15 )
                {
                  if ( (unsigned __int8)*i == a4[4] )
                    *i = a5[8];
                  ++i;
                }
              }
              break;
            case 0x10:
              v40 = a3;
              if ( a10 )
              {
                if ( v15 )
                {
                  v41 = *a2;
                  do
                  {
                    if ( v40[1] + (*v40 << 8) == a4[4] )
                    {
                      *v40 = a5[9];
                      LOBYTE(v42) = a5[8];
                    }
                    else
                    {
                      v42 = *(_WORD *)(*(_DWORD *)(a10 + 4 * (v40[1] >> a13)) + 2 * *v40);
                      *v40 = HIBYTE(v42);
                    }
                    v40[1] = v42;
                    v40 += 2;
                    --v41;
                  }
                  while ( v41 );
                }
              }
              else
              {
                for ( ; v15; --v15 )
                {
                  if ( v40[1] + (*v40 << 8) == a4[4] )
                  {
                    *v40 = a5[9];
                    v40[1] = a5[8];
                  }
                  v40 += 2;
                }
              }
              break;
            default:
              goto LABEL_208;
          }
          goto LABEL_208;
        case 2:
          if ( *((_BYTE *)a2 + 9) == 8 )
          {
            if ( a7 )
            {
              if ( v15 )
              {
                v43 = a3 + 2;
                do
                {
                  if ( (unsigned __int8)*(v43 - 2) == a4[1]
                    && (unsigned __int8)*(v43 - 1) == a4[2]
                    && (unsigned __int8)*v43 == a4[3] )
                  {
                    *(v43 - 2) = a5[2];
                    *(v43 - 1) = a5[4];
                    v44 = a5[6];
                  }
                  else
                  {
                    v45 = (unsigned __int8)*(v43 - 1);
                    *(v43 - 2) = *(_BYTE *)((unsigned __int8)*(v43 - 2) + a7);
                    v46 = *(_BYTE *)(v45 + a7);
                    v47 = (unsigned __int8)*v43;
                    *(v43 - 1) = v46;
                    v44 = *(_BYTE *)(v47 + a7);
                  }
                  *v43 = v44;
                  v43 += 3;
                  --v15;
                }
                while ( v15 );
              }
            }
            else if ( v15 )
            {
              v48 = a3 + 2;
              do
              {
                if ( (unsigned __int8)*(v48 - 2) == a4[1]
                  && (unsigned __int8)*(v48 - 1) == a4[2]
                  && (unsigned __int8)*v48 == a4[3] )
                {
                  *(v48 - 2) = a5[2];
                  *(v48 - 1) = a5[4];
                  *v48 = a5[6];
                }
                v48 += 3;
                --v15;
              }
              while ( v15 );
            }
          }
          else if ( a10 )
          {
            if ( v15 )
            {
              v49 = a5;
              v50 = a3 + 2;
              v51 = *a2;
              do
              {
                if ( *(v50 - 1) + (*(v50 - 2) << 8) == a4[1]
                  && v50[1] + (*v50 << 8) == a4[2]
                  && v50[3] + (v50[2] << 8) == a4[3] )
                {
                  *(v50 - 2) = v49[3];
                  *(v50 - 1) = v49[2];
                  *v50 = v49[5];
                  v50[1] = v49[4];
                  v50[2] = v49[7];
                  v50[3] = v49[6];
                }
                else
                {
                  v52 = HIBYTE(*(_WORD *)(*(_DWORD *)(a10 + 4 * (*(v50 - 1) >> a13)) + 2 * *(v50 - 2)));
                  *(v50 - 1) = *(_WORD *)(*(_DWORD *)(a10 + 4 * (*(v50 - 1) >> a13)) + 2 * *(v50 - 2));
                  *(v50 - 2) = v52;
                  v53 = HIBYTE(*(_WORD *)(*(_DWORD *)(a10 + 4 * (v50[1] >> a13)) + 2 * *v50));
                  v50[1] = *(_WORD *)(*(_DWORD *)(a10 + 4 * (v50[1] >> a13)) + 2 * *v50);
                  *v50 = v53;
                  v54 = v50[3] >> a13;
                  v55 = HIBYTE(*(_WORD *)(*(_DWORD *)(a10 + 4 * v54) + 2 * v50[2]));
                  v50[3] = *(_WORD *)(*(_DWORD *)(a10 + 4 * v54) + 2 * v50[2]);
                  v49 = a5;
                  v50[2] = v55;
                }
                v50 += 6;
                --v51;
              }
              while ( v51 );
            }
          }
          else if ( v15 )
          {
            v56 = a3 + 2;
            do
            {
              LOWORD(v13) = *(v56 - 2);
              LOWORD(a1) = *(v56 - 1);
              v13 = a1 + (v13 << 8);
              if ( (_WORD)v13 == a4[1] )
              {
                LOWORD(v13) = *v56;
                LOWORD(a1) = v56[1];
                v13 = a1 + (v13 << 8);
                if ( (_WORD)v13 == a4[2] )
                {
                  LOWORD(v13) = v56[2];
                  LOWORD(a1) = v56[3];
                  v13 = a1 + (v13 << 8);
                  if ( (_WORD)v13 == a4[3] )
                  {
                    *(v56 - 2) = a5[3];
                    *(v56 - 1) = a5[2];
                    *v56 = a5[5];
                    v56[1] = a5[4];
                    v13 = (unsigned __int8)a5[7];
                    v56[2] = v13;
                    v56[3] = a5[6];
                  }
                }
              }
              v56 += 6;
              --v15;
            }
            while ( v15 );
          }
          goto LABEL_208;
        case 4:
          if ( *((_BYTE *)a2 + 9) == 8 )
          {
            if ( a9 && a8 && a7 )
            {
              v57 = a3;
              v58 = a3;
              if ( v15 )
              {
                v130 = *a2;
                do
                {
                  v59 = v57[1];
                  if ( v59 == 255 )
                  {
                    *v58 = *(_BYTE *)(*v57 + a7);
                  }
                  else if ( v57[1] )
                  {
                    v60 = (unsigned __int16)(a6[4] * (255 - v59) + v59 * *(unsigned __int8 *)(*v57 + a9) + 128);
                    *v58 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v60 + (v60 >> 8)) >> 8) + a8);
                  }
                  else
                  {
                    *v58 = a5[8];
                  }
                  v57 += 2;
                  ++v58;
                  --v130;
                }
                while ( v130 );
              }
            }
            else
            {
              v61 = a3;
              v62 = a3;
              if ( v15 )
              {
                v63 = *a2;
                do
                {
                  v64 = v61[1];
                  if ( v64 == 0xFF )
                  {
                    *v62 = *v61;
                  }
                  else if ( v64 )
                  {
                    v65 = (unsigned __int16)(a6[4] * (255 - v64) + v64 * *v61 + 128);
                    *v62 = (unsigned __int16)(v65 + (v65 >> 8)) >> 8;
                  }
                  else
                  {
                    *v62 = a5[8];
                  }
                  v61 += 2;
                  ++v62;
                  --v63;
                }
                while ( v63 );
              }
            }
            goto LABEL_208;
          }
          if ( !a10 || !a11 || !a12 )
          {
            v74 = a3;
            if ( v15 )
            {
              v75 = a3 + 3;
              v132 = *a2;
              do
              {
                v76 = *v75 + (*(v75 - 1) << 8);
                if ( v76 == -1 )
                {
                  *(_WORD *)v74 = *(_WORD *)(v75 - 3);
                }
                else if ( v76 )
                {
                  v77 = (unsigned __int16)(*v75 + (*(v75 - 1) << 8));
                  v78 = (0xFFFF - v77) * (unsigned __int16)a6[4];
                  v14 = a5;
                  v79 = (v77 * (unsigned __int16)(*(v75 - 2) + (*(v75 - 3) << 8))
                       + v78
                       + 0x8000
                       + ((v77 * (unsigned int)(unsigned __int16)(*(v75 - 2) + (*(v75 - 3) << 8)) + v78 + 0x8000) >> 16)) >> 16;
                  v74[1] = v79;
                  *v74 = BYTE1(v79);
                }
                else
                {
                  *v74 = v14[9];
                  v74[1] = v14[8];
                }
                v75 += 4;
                v74 += 2;
                --v132;
              }
              while ( v132 );
            }
            goto LABEL_208;
          }
          v66 = a3;
          v67 = a3;
          if ( !v15 )
          {
LABEL_208:
            v124 = *((_BYTE *)a2 + 8);
            if ( (v124 & 4) != 0 )
            {
              v125 = *((_BYTE *)a2 + 10) - 1;
              *((_BYTE *)a2 + 8) = v124 & 0xFB;
              v126 = v125 * *((_BYTE *)a2 + 9);
              *((_BYTE *)a2 + 11) = v126;
              *((_BYTE *)a2 + 10) = v125;
              a2[1] = (v127 * (unsigned int)v126 + 7) >> 3;
            }
            return;
          }
          v131 = *a2;
          v68 = v66 + 1;
          while ( 1 )
          {
            v69 = v68[2] + (v68[1] << 8);
            if ( v69 == -1 )
              break;
            if ( v69 )
            {
              v71 = (unsigned __int16)(v68[2] + (v68[1] << 8));
              v72 = v71 * *(unsigned __int16 *)(*(_DWORD *)(a12 + 4 * (*v68 >> a13)) + 2 * *(v68 - 1));
              v73 = ((0xFFFF - v71) * (unsigned __int16)a6[4]
                   + v72
                   + 0x8000
                   + (((0xFFFF - v71) * (unsigned int)(unsigned __int16)a6[4] + v72 + 0x8000) >> 16)) >> 16;
              v70 = *(_WORD *)(*(_DWORD *)(a11 + 4 * ((unsigned __int8)v73 >> a13)) + 2 * (v73 >> 8));
              goto LABEL_151;
            }
            *v67 = v14[9];
            v67[1] = v14[8];
LABEL_152:
            v68 += 4;
            v67 += 2;
            if ( !--v131 )
              goto LABEL_208;
          }
          v70 = *(_WORD *)(*(_DWORD *)(a10 + 4 * (*v68 >> a13)) + 2 * *(v68 - 1));
LABEL_151:
          v14 = a5;
          *v67 = HIBYTE(v70);
          v67[1] = v70;
          goto LABEL_152;
        case 6:
          if ( *((_BYTE *)a2 + 9) == 8 )
          {
            v80 = a9;
            if ( a9 && a8 && (v81 = a7) != 0 )
            {
              if ( v15 )
              {
                v82 = a3;
                v133 = *a2;
                v83 = a5;
                v84 = v82 + 2;
                v85 = v82 + 1;
                do
                {
                  v86 = v85[2];
                  if ( v86 == 0xFF )
                  {
                    *(v84 - 2) = *(_BYTE *)(*(v85 - 1) + v81);
                    *(v84 - 1) = *(_BYTE *)(*v85 + v81);
                    *v84 = *(_BYTE *)(v85[1] + v81);
                  }
                  else if ( v86 )
                  {
                    v87 = 255 - v86;
                    v88 = (unsigned __int16)(v86 * *(unsigned __int8 *)(*(v85 - 1) + v80) + v87 * a6[1] + 128);
                    *(v84 - 2) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v88 + (v88 >> 8)) >> 8) + a8);
                    *(v84 - 1) = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v86 * *(unsigned __int8 *)(*v85 + a9)
                                                                               + v87 * a6[2]
                                                                               + 128
                                                                               + ((unsigned __int16)(v86 * *(unsigned __int8 *)(*v85 + a9) + v87 * a6[2] + 128) >> 8)) >> 8)
                                          + a8);
                    v80 = a9;
                    v83 = a5;
                    v89 = (unsigned __int16)(v86 * *(unsigned __int8 *)(v85[1] + a9) + v87 * a6[3] + 128);
                    *v84 = *(_BYTE *)((unsigned __int8)((unsigned __int16)(v89 + (v89 >> 8)) >> 8) + a8);
                    v81 = a7;
                  }
                  else
                  {
                    *(v84 - 2) = v83[2];
                    *(v84 - 1) = v83[4];
                    *v84 = v83[6];
                  }
                  v85 += 4;
                  v84 += 3;
                  --v133;
                }
                while ( v133 );
              }
            }
            else if ( v15 )
            {
              v90 = a3;
              v134 = *a2;
              v91 = v90 + 2;
              v92 = v90 + 1;
              do
              {
                v93 = v92[2];
                if ( v93 == 0xFF )
                {
                  *(v91 - 2) = *(v92 - 1);
                  *(v91 - 1) = *v92;
                  *v91 = v92[1];
                }
                else
                {
                  if ( v93 )
                  {
                    v95 = 255 - v93;
                    *(v91 - 2) = (unsigned __int16)(v93 * *(v92 - 1)
                                                  + v95 * *((_WORD *)a5 + 1)
                                                  + 128
                                                  + ((unsigned __int16)(v93 * *(v92 - 1) + v95 * *((_WORD *)a5 + 1) + 128) >> 8)) >> 8;
                    v14 = a5;
                    *(v91 - 1) = (unsigned __int16)(v95 * *((_WORD *)a5 + 2)
                                                  + v93 * *v92
                                                  + 128
                                                  + ((unsigned __int16)(v95 * *((_WORD *)a5 + 2) + v93 * *v92 + 128) >> 8)) >> 8;
                    v96 = (unsigned __int16)(v93 * v92[1] + v95 * *((_WORD *)a5 + 3) + 128);
                    v94 = (int)(v96 + (v96 >> 8)) >> 8;
                  }
                  else
                  {
                    *(v91 - 2) = v14[2];
                    *(v91 - 1) = v14[4];
                    LOBYTE(v94) = v14[6];
                  }
                  *v91 = v94;
                }
                v92 += 4;
                v91 += 3;
                --v134;
              }
              while ( v134 );
            }
            goto LABEL_208;
          }
          if ( !a10 || !a11 || !a12 )
          {
            if ( v15 )
            {
              v136 = *a2;
              v114 = a3 + 2;
              v115 = a3 + 7;
              do
              {
                v116 = *v115 + (*(v115 - 1) << 8);
                if ( v116 == 0xFFFF )
                {
                  *(_DWORD *)(v114 - 2) = *(_DWORD *)(v115 - 7);
                  *((_WORD *)v114 + 1) = *(_WORD *)(v115 - 3);
                }
                else
                {
                  if ( v116 )
                  {
                    v118 = *(v115 - 4) + (*(v115 - 5) << 8);
                    v119 = *(v115 - 2) + (*(v115 - 3) << 8);
                    v138 = (unsigned __int16)(*v115 + (*(v115 - 1) << 8));
                    v120 = v138 * (unsigned __int16)(*(v115 - 6) + (*(v115 - 7) << 8));
                    v121 = (v120
                          + (0xFFFF - v116) * *((unsigned __int16 *)a5 + 1)
                          + 0x8000
                          + ((v120 + (0xFFFF - v116) * (unsigned int)*((unsigned __int16 *)a5 + 1) + 0x8000) >> 16)) >> 16;
                    *(v114 - 1) = v121;
                    *(v114 - 2) = BYTE1(v121);
                    v122 = (0xFFFF - v138) * *((unsigned __int16 *)a5 + 2) + v138 * v118 + 0x8000;
                    v114[1] = (v122 + HIWORD(v122)) >> 16;
                    *v114 = (v122 + HIWORD(v122)) >> 24;
                    v123 = (0xFFFF - v138) * *((unsigned __int16 *)a5 + 3) + v138 * v119 + 0x8000;
                    v117 = (v123 + HIWORD(v123)) >> 16;
                    v114[2] = (v123 + HIWORD(v123)) >> 24;
                  }
                  else
                  {
                    *(v114 - 2) = a5[3];
                    *(v114 - 1) = a5[2];
                    *v114 = a5[5];
                    v114[1] = a5[4];
                    v114[2] = a5[7];
                    LOBYTE(v117) = a5[6];
                  }
                  v114[3] = v117;
                }
                v115 += 8;
                v114 += 6;
                --v136;
              }
              while ( v136 );
            }
            goto LABEL_208;
          }
          if ( !v15 )
            goto LABEL_208;
          v97 = a13;
          v98 = a5;
          v137 = *a2;
          v99 = a3 + 2;
          v100 = a3 + 1;
          break;
        default:
          goto LABEL_208;
      }
      while ( 1 )
      {
        v101 = v100[6] + (v100[5] << 8);
        if ( v101 == -1 )
          break;
        if ( v101 )
        {
          v105 = (unsigned __int16)(v100[6] + (v100[5] << 8));
          v106 = v97;
          v135 = 0xFFFF - v105;
          v107 = (0xFFFF - v105) * (unsigned __int16)a6[1]
               + v105 * *(unsigned __int16 *)(*(_DWORD *)(a12 + 4 * (*v100 >> v97)) + 2 * *(v100 - 1))
               + 0x8000;
          v108 = *(_WORD *)(*(_DWORD *)(a11 + 4 * ((unsigned __int8)((v107 + HIWORD(v107)) >> 16) >> a13))
                          + 2 * ((unsigned __int16)((v107 + HIWORD(v107)) >> 16) >> 8));
          *(v99 - 1) = v108;
          *(v99 - 2) = HIBYTE(v108);
          v109 = *(_WORD *)(*(_DWORD *)(a12 + 4 * (v100[2] >> v97)) + 2 * v100[1]);
          v110 = (v135 * (unsigned __int16)a6[2]
                + v105 * v109
                + 0x8000
                + ((v135 * (unsigned __int16)a6[2] + v105 * (unsigned int)v109 + 0x8000) >> 16)) >> 16;
          LOWORD(v110) = *(_WORD *)(*(_DWORD *)(a11 + 4 * ((unsigned __int8)v110 >> a13)) + 2 * (v110 >> 8));
          v99[1] = v110;
          *v99 = BYTE1(v110);
          v111 = v105 * *(unsigned __int16 *)(*(_DWORD *)(a12 + 4 * (v100[4] >> v106)) + 2 * v100[3]);
          v112 = (v111
                + v135 * (unsigned __int16)a6[3]
                + 0x8000
                + ((v111 + v135 * (unsigned int)(unsigned __int16)a6[3] + 0x8000) >> 16)) >> 16;
          v97 = a13;
          LOWORD(v112) = *(_WORD *)(*(_DWORD *)(a11 + 4 * ((unsigned __int8)v112 >> a13)) + 2 * (v112 >> 8));
          v99[3] = v112;
          v99[2] = BYTE1(v112);
          goto LABEL_196;
        }
        *(v99 - 2) = v98[3];
        *(v99 - 1) = v98[2];
        *v99 = v98[5];
        v99[1] = v98[4];
        v99[2] = v98[7];
        v99[3] = v98[6];
LABEL_197:
        v100 += 8;
        v99 += 6;
        if ( !--v137 )
          goto LABEL_208;
      }
      v102 = HIBYTE(*(_WORD *)(*(_DWORD *)(a10 + 4 * (*v100 >> v97)) + 2 * *(v100 - 1)));
      *(v99 - 1) = *(_WORD *)(*(_DWORD *)(a10 + 4 * (*v100 >> v97)) + 2 * *(v100 - 1));
      *(v99 - 2) = v102;
      v103 = HIBYTE(*(_WORD *)(*(_DWORD *)(a10 + 4 * (v100[2] >> v97)) + 2 * v100[1]));
      v99[1] = *(_WORD *)(*(_DWORD *)(a10 + 4 * (v100[2] >> v97)) + 2 * v100[1]);
      *v99 = v103;
      v104 = *(_WORD *)(*(_DWORD *)(a10 + 4 * (v100[4] >> v97)) + 2 * v100[3]);
      v99[3] = v104;
      v99[2] = HIBYTE(v104);
LABEL_196:
      v98 = a5;
      goto LABEL_197;
    }
  }
}

//----- (00482270) --------------------------------------------------------
char __cdecl sub_482270(int *a1, unsigned __int8 *a2, int a3, int a4, char a5)
{
  int *v5; // ebp
  int v6; // esi
  unsigned __int8 *v7; // eax
  int v8; // ecx
  bool v10; // zf
  int v11; // edx
  unsigned __int8 *v12; // eax
  int v13; // edx
  int v14; // edx
  int v15; // edi
  unsigned int v16; // ecx
  unsigned __int8 *v17; // eax
  unsigned int v18; // ebx
  int v19; // ecx
  int v20; // edx
  unsigned __int8 *v21; // eax
  int v22; // edx
  int v23; // edi
  unsigned int v24; // ecx
  unsigned __int8 *v25; // eax
  unsigned int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // edi
  unsigned int v30; // ecx
  char v31; // al
  int v32; // edx
  int v33; // esi
  char v34; // dl
  _BYTE *v35; // edx
  unsigned int v36; // esi
  int v37; // edx
  int v38; // edi
  unsigned int v39; // ecx
  unsigned int v41; // [esp+10h] [ebp-8h]
  int v42; // [esp+14h] [ebp-4h]
  unsigned __int8 *v43; // [esp+24h] [ebp+Ch]

  v5 = a1;
  v6 = a4;
  LOBYTE(v7) = *((_BYTE *)a1 + 9);
  v8 = *a1;
  v42 = *a1;
  if ( (unsigned __int8)v7 <= 8u && a3 || (_BYTE)v7 == 16 && a4 )
  {
    switch ( *((_BYTE *)a1 + 8) )
    {
      case 0:
        v10 = (_BYTE)v7 == 2;
        v7 = a2;
        if ( v10 )
        {
          v43 = a2;
          if ( v8 )
          {
            v41 = (unsigned int)(v8 + 3) >> 2;
            do
            {
              v31 = *v7;
              v32 = v31 & 0xC;
              v33 = v31 & 0x30;
              *v43 = *(_BYTE *)((v31 & 0xC0 | ((v31 & 0xC0 | ((v31 & 0xC0 | ((v31 & 0xC0) >> 2)) >> 2)) >> 2)) + a3) & 0xC0 | ((unsigned __int8)(*(_BYTE *)((v33 | (4 * v33) | ((v33 | (v33 >> 2)) >> 2)) + a3) & 0xC3 | ((unsigned __int8)((*(_BYTE *)((v31 & 3 | (4 * (v31 & 3 | (4 * (v31 & 3 | (4 * (v31 & 3))))))) + a3) >> 2) | *(_BYTE *)((v32 | (v32 >> 2) | (4 * (v32 | (4 * v32)))) + a3) & 0xCF) >> 2)) >> 2);
              v7 = ++v43;
              --v41;
            }
            while ( v41 );
            v6 = a4;
            v8 = v42;
            v5 = a1;
            v7 = a2;
          }
        }
        v34 = *((_BYTE *)v5 + 9);
        if ( v34 == 4 )
        {
          v35 = v7;
          if ( v8 )
          {
            v36 = (unsigned int)(v8 + 1) >> 1;
            do
            {
              LOBYTE(v7) = *(_BYTE *)((*v35 & 0xF | (16 * (*v35 & 0xF))) + a3) >> 4;
              *v35 = (unsigned __int8)v7 | *(_BYTE *)((*v35 & 0xF0 | ((*v35 & 0xF0) >> 4)) + a3) & 0xF0;
              ++v35;
              --v36;
            }
            while ( v36 );
          }
        }
        else if ( v34 == 8 )
        {
          for ( ; v8; *(v7 - 1) = *(_BYTE *)(v37 + a3) )
          {
            v37 = *v7++;
            --v8;
          }
        }
        else if ( v34 == 16 && v8 )
        {
          v38 = v8;
          do
          {
            v39 = v7[1];
            v7 += 2;
            LOWORD(v39) = *(_WORD *)(*(_DWORD *)(v6 + 4 * (v39 >> a5)) + 2 * *(v7 - 2));
            *(v7 - 1) = v39;
            *(v7 - 2) = BYTE1(v39);
            --v38;
          }
          while ( v38 );
        }
        break;
      case 2:
        v10 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v10 )
        {
          for ( ; v8; *(v7 - 1) = *(_BYTE *)(v14 + a3) )
          {
            v11 = *v7;
            v12 = v7 + 1;
            *(v12 - 1) = *(_BYTE *)(v11 + a3);
            v13 = *v12++;
            *(v12 - 1) = *(_BYTE *)(v13 + a3);
            v14 = *v12;
            v7 = v12 + 1;
            --v8;
          }
        }
        else if ( v8 )
        {
          v15 = *a1;
          do
          {
            v16 = v7[1];
            v17 = v7 + 2;
            v18 = v16 >> a5;
            v19 = *(v17 - 2);
            v7 = v17 + 4;
            LOWORD(v19) = *(_WORD *)(*(_DWORD *)(a4 + 4 * v18) + 2 * v19);
            *(v7 - 5) = v19;
            *(v7 - 6) = BYTE1(v19);
            LOBYTE(v18) = HIBYTE(*(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 3) >> a5)) + 2 * *(v7 - 4)));
            *(v7 - 3) = *(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 3) >> a5)) + 2 * *(v7 - 4));
            *(v7 - 4) = v18;
            LOWORD(v19) = *(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 1) >> a5)) + 2 * *(v7 - 2));
            *(v7 - 1) = v19;
            *(v7 - 2) = BYTE1(v19);
            --v15;
          }
          while ( v15 );
        }
        break;
      case 4:
        v10 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v10 )
        {
          for ( ; v8; *(v7 - 2) = *(_BYTE *)(v28 + a3) )
          {
            v28 = *v7;
            v7 += 2;
            --v8;
          }
        }
        else if ( v8 )
        {
          v29 = *a1;
          do
          {
            v30 = v7[1];
            v7 += 4;
            LOWORD(v30) = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v30 >> a5)) + 2 * *(v7 - 4));
            *(v7 - 3) = v30;
            *(v7 - 4) = BYTE1(v30);
            --v29;
          }
          while ( v29 );
        }
        break;
      case 6:
        v10 = (_BYTE)v7 == 8;
        v7 = a2;
        if ( v10 )
        {
          for ( ; v8; *(v7 - 2) = *(_BYTE *)(*(v7 - 2) + a3) )
          {
            v20 = *v7;
            v21 = v7 + 1;
            *(v21 - 1) = *(_BYTE *)(v20 + a3);
            v22 = *v21;
            v7 = v21 + 3;
            *(v7 - 3) = *(_BYTE *)(v22 + a3);
            --v8;
          }
        }
        else if ( v8 )
        {
          v23 = *a1;
          do
          {
            v24 = v7[1];
            v25 = v7 + 2;
            v26 = v24 >> a5;
            v27 = *(v25 - 2);
            v7 = v25 + 6;
            LOWORD(v27) = *(_WORD *)(*(_DWORD *)(a4 + 4 * v26) + 2 * v27);
            *(v7 - 7) = v27;
            *(v7 - 8) = BYTE1(v27);
            LOBYTE(v26) = HIBYTE(*(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 5) >> a5)) + 2 * *(v7 - 6)));
            *(v7 - 5) = *(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 5) >> a5)) + 2 * *(v7 - 6));
            *(v7 - 6) = v26;
            LOWORD(v27) = *(_WORD *)(*(_DWORD *)(a4 + 4 * (*(v7 - 3) >> a5)) + 2 * *(v7 - 4));
            *(v7 - 3) = v27;
            *(v7 - 4) = BYTE1(v27);
            --v23;
          }
          while ( v23 );
        }
        break;
      default:
        return (char)v7;
    }
  }
  return (char)v7;
}

//----- (00482660) --------------------------------------------------------
char __cdecl sub_482660(int *a1, int a2, int a3, int a4, int a5)
{
  int *v5; // ebx
  int v6; // eax
  int v7; // edx
  _BYTE *v9; // esi
  _BYTE *v10; // ebp
  _BYTE *v11; // esi
  _BYTE *v12; // ebp
  _BYTE *v13; // esi
  _BYTE *v14; // ebp
  unsigned __int8 *v15; // ecx
  int v16; // esi
  int v17; // ebp
  int v18; // esi
  int v19; // eax
  int v20; // esi
  int v21; // esi
  int v22; // ebp
  int v23; // eax
  int v24; // esi
  int v26; // [esp+18h] [ebp+8h]
  int v27; // [esp+18h] [ebp+8h]
  int v28; // [esp+18h] [ebp+8h]

  v5 = a1;
  LOBYTE(v6) = *((_BYTE *)a1 + 8);
  v7 = *a1;
  if ( (_BYTE)v6 != 3 )
    return v6;
  LOBYTE(v6) = *((_BYTE *)a1 + 9);
  if ( (unsigned __int8)v6 < 8u )
  {
    if ( *((_BYTE *)a1 + 9) == 1 )
    {
      v13 = (_BYTE *)(a2 + ((unsigned int)(v7 - 1) >> 3));
      v6 = 7 - (((_BYTE)v7 - 1) & 7);
      v14 = (_BYTE *)(v7 + a2 - 1);
      if ( v7 )
      {
        v28 = *a1;
        do
        {
          *v14 = (*v13 >> v6) & 1;
          if ( v6 == 7 )
          {
            v6 = 0;
            --v13;
          }
          else
          {
            ++v6;
          }
          --v14;
          --v28;
        }
        while ( v28 );
        goto LABEL_26;
      }
    }
    else
    {
      if ( *((_BYTE *)a1 + 9) != 2 )
      {
        LOBYTE(v6) = *((_BYTE *)a1 + 9) - 4;
        if ( *((_BYTE *)a1 + 9) != 4 )
          goto LABEL_27;
        v9 = (_BYTE *)(a2 + ((unsigned int)(v7 - 1) >> 1));
        v6 = 4 * (*a1 & 1);
        v10 = (_BYTE *)(v7 + a2 - 1);
        if ( !v7 )
          goto LABEL_27;
        v26 = *a1;
        do
        {
          *v10 = (*v9 >> v6) & 0xF;
          if ( v6 == 4 )
          {
            v6 = 0;
            --v9;
          }
          else
          {
            v6 += 4;
          }
          --v10;
          --v26;
        }
        while ( v26 );
        goto LABEL_26;
      }
      v11 = (_BYTE *)(a2 + ((unsigned int)(v7 - 1) >> 2));
      v6 = 2 * (3 - (((_BYTE)v7 - 1) & 3));
      v12 = (_BYTE *)(v7 + a2 - 1);
      if ( v7 )
      {
        v27 = *a1;
        do
        {
          *v12 = (*v11 >> v6) & 3;
          if ( v6 == 6 )
          {
            v6 = 0;
            --v11;
          }
          else
          {
            v6 += 2;
          }
          --v12;
          --v27;
        }
        while ( v27 );
LABEL_26:
        v5 = a1;
        goto LABEL_27;
      }
    }
LABEL_27:
    *((_BYTE *)v5 + 9) = 8;
    *((_BYTE *)v5 + 11) = 8;
    v5[1] = v7;
  }
  if ( *((_BYTE *)v5 + 9) == 8 )
  {
    v15 = (unsigned __int8 *)(v7 + a2 - 1);
    if ( a4 )
    {
      v16 = 4 * v7;
      v6 = 4 * v7 + a2 - 1;
      if ( v7 )
      {
        v17 = v7;
        do
        {
          v18 = *v15;
          if ( v18 < a5 )
            *(_BYTE *)v6 = *(_BYTE *)(v18 + a4);
          else
            *(_BYTE *)v6 = -1;
          v19 = v6 - 2;
          *(_BYTE *)(v19-- + 1) = *(_BYTE *)(*v15 + a3 + 2 * *v15 + 2);
          *(_BYTE *)(v19 + 1) = *(_BYTE *)(*v15 + a3 + 2 * *v15 + 1);
          v6 = v19 - 1;
          v20 = *v15--;
          --v17;
          *(_BYTE *)(v6 + 1) = *(_BYTE *)(v20 + a3 + 2 * v20);
        }
        while ( v17 );
        v16 = 4 * v7;
      }
      v5[1] = v16;
      *((_BYTE *)v5 + 9) = 8;
      *((_BYTE *)v5 + 11) = 32;
      *((_BYTE *)v5 + 8) = 6;
      *((_BYTE *)v5 + 10) = 4;
    }
    else
    {
      v21 = 3 * v7;
      v6 = 3 * v7 + a2 - 1;
      if ( v7 )
      {
        v22 = v7;
        do
        {
          v23 = v6 - 1;
          *(_BYTE *)(v23-- + 1) = *(_BYTE *)(*v15 + a3 + 2 * *v15 + 2);
          *(_BYTE *)(v23 + 1) = *(_BYTE *)(*v15 + a3 + 2 * *v15 + 1);
          v6 = v23 - 1;
          v24 = *v15--;
          --v22;
          *(_BYTE *)(v6 + 1) = *(_BYTE *)(v24 + a3 + 2 * v24);
        }
        while ( v22 );
        v21 = 3 * v7;
      }
      *((_BYTE *)v5 + 9) = 8;
      *((_BYTE *)v5 + 11) = 24;
      v5[1] = v21;
      *((_BYTE *)v5 + 8) = 2;
      *((_BYTE *)v5 + 10) = 3;
    }
  }
  return v6;
}

//----- (00482890) --------------------------------------------------------
char __cdecl sub_482890(int *a1, int a2, _WORD *a3)
{
  int *v3; // edx
  int v4; // eax
  int v5; // esi
  _WORD *v6; // ecx
  unsigned __int16 v7; // bx
  unsigned __int8 *v9; // edi
  int v10; // edx
  bool v11; // zf
  unsigned __int8 *v12; // edi
  int v13; // edx
  char v14; // al
  _BYTE *v15; // edi
  char v16; // al
  _BYTE *v17; // edi
  _BYTE *v18; // eax
  int v19; // ebp
  _BYTE *v20; // eax
  char v21; // al
  unsigned __int8 v22; // al
  int v23; // eax
  _BYTE *v24; // ecx
  _BYTE *v25; // eax
  int v26; // ebp
  int v27; // edi
  unsigned __int16 v28; // bx
  _BYTE *v29; // eax
  _BYTE *v30; // eax
  char v31; // al
  char v32; // al
  _BYTE *v33; // ecx
  _BYTE *v34; // eax
  int v35; // ebp
  _BYTE *v36; // eax
  char v37; // bl
  _BYTE *v38; // ecx
  _BYTE *v39; // ecx
  _BYTE *v40; // eax
  __int16 v41; // bx
  __int16 v42; // bx
  __int16 v43; // bx
  _BYTE *v44; // eax
  _BYTE *v45; // eax
  char v46; // bl
  _BYTE *v47; // ecx
  char v48; // bl
  char v49; // bl
  char v50; // bl
  char v51; // al
  int v53; // [esp+10h] [ebp-4h]
  int v54; // [esp+10h] [ebp-4h]
  int v55; // [esp+10h] [ebp-4h]
  int v56; // [esp+18h] [ebp+4h]
  _BYTE *v57; // [esp+1Ch] [ebp+8h]
  _BYTE *v58; // [esp+1Ch] [ebp+8h]
  _BYTE *v59; // [esp+1Ch] [ebp+8h]

  v3 = a1;
  LOBYTE(v4) = *((_BYTE *)a1 + 8);
  v5 = *a1;
  if ( (_BYTE)v4 )
  {
    if ( (_BYTE)v4 == 2 && a3 )
    {
      v32 = *((_BYTE *)a1 + 9);
      if ( v32 == 8 )
      {
        v33 = (_BYTE *)(a1[1] + a2 - 1);
        v34 = (_BYTE *)(a2 + 4 * v5 - 1);
        if ( v5 )
        {
          v35 = *a1;
          do
          {
            if ( (unsigned __int8)*(v33 - 2) == a3[1]
              && (unsigned __int8)*(v33 - 1) == a3[2]
              && (unsigned __int8)*v33 == a3[3] )
            {
              *v34 = 0;
            }
            else
            {
              *v34 = -1;
            }
            v36 = v34 - 1;
            *v36 = *v33;
            v37 = *(v33 - 1);
            --v36;
            v38 = v33 - 1;
            *v36-- = v37;
            *v36 = *(v38 - 1);
            v34 = v36 - 1;
            v33 = v38 - 2;
            --v35;
          }
          while ( v35 );
        }
      }
      else if ( v32 == 16 )
      {
        v39 = (_BYTE *)(a1[1] + a2 - 1);
        v40 = (_BYTE *)(a2 + 8 * v5 - 1);
        if ( v5 )
        {
          v56 = *a1;
          do
          {
            HIBYTE(v41) = *(v39 - 5);
            LOBYTE(v41) = *(v39 - 4);
            if ( v41 == a3[1]
              && (HIBYTE(v42) = *(v39 - 3), LOBYTE(v42) = *(v39 - 2), v42 == a3[2])
              && (HIBYTE(v43) = *(v39 - 1), LOBYTE(v43) = *v39, v43 == a3[3]) )
            {
              *v40 = 0;
              v44 = v40 - 1;
              *v44 = 0;
            }
            else
            {
              *v40 = -1;
              v44 = v40 - 1;
              *v44 = -1;
            }
            v45 = v44 - 1;
            *v45 = *v39;
            v46 = *(v39 - 1);
            --v45;
            v47 = v39 - 1;
            *v45 = v46;
            v48 = *(v47 - 1);
            --v45;
            --v47;
            *v45 = v48;
            v49 = *(v47 - 1);
            --v45;
            --v47;
            *v45 = v49;
            v50 = *(v47 - 1);
            --v45;
            --v47;
            *v45-- = v50;
            *v45 = *(v47 - 1);
            v40 = v45 - 1;
            v39 = v47 - 2;
            --v56;
          }
          while ( v56 );
        }
      }
      v51 = *((_BYTE *)v3 + 9);
      *((_BYTE *)v3 + 8) = 6;
      *((_BYTE *)v3 + 10) = 4;
      v22 = 4 * v51;
      goto LABEL_70;
    }
    return v4;
  }
  v6 = a3;
  if ( a3 )
    v7 = a3[4];
  else
    v7 = 0;
  LOBYTE(v4) = *((_BYTE *)a1 + 9);
  if ( (unsigned __int8)v4 < 8u )
  {
    if ( *((_BYTE *)a1 + 9) == 1 )
    {
      v7 *= 255;
      v59 = (_BYTE *)(v5 + a2 - 1);
      v15 = (_BYTE *)(a2 + ((unsigned int)(v5 - 1) >> 3));
      v4 = 7 - (((_BYTE)v5 - 1) & 7);
      if ( v5 )
      {
        v55 = *a1;
        do
        {
          *v59 = -(((*v15 >> v4) & 1) != 0);
          if ( v4 == 7 )
          {
            v4 = 0;
            --v15;
          }
          else
          {
            ++v4;
          }
          v11 = v55 == 1;
          --v59;
          --v55;
        }
        while ( !v11 );
LABEL_29:
        v3 = a1;
        goto LABEL_30;
      }
    }
    else
    {
      if ( *((_BYTE *)a1 + 9) == 2 )
      {
        v7 *= 85;
        v4 = ((_BYTE)v5 - 1) & 3;
        v12 = (unsigned __int8 *)(a2 + ((unsigned int)(v5 - 1) >> 2));
        v13 = 2 * (3 - v4);
        v58 = (_BYTE *)(v5 + a2 - 1);
        if ( v5 )
        {
          v54 = *a1;
          do
          {
            v14 = (*v12 >> v13) & 3;
            *v58 = v14 | (4 * (v14 | (4 * (v14 | (4 * v14)))));
            if ( v13 == 6 )
            {
              v13 = 0;
              --v12;
            }
            else
            {
              v13 += 2;
            }
            LOBYTE(v4) = v54 - 1;
            v11 = v54 == 1;
            --v58;
            --v54;
          }
          while ( !v11 );
        }
        goto LABEL_29;
      }
      LOBYTE(v4) = *((_BYTE *)a1 + 9) - 4;
      if ( *((_BYTE *)a1 + 9) == 4 )
      {
        v7 *= 17;
        v4 = 4 * (((_BYTE)v5 - 1) & 1);
        v9 = (unsigned __int8 *)(a2 + ((unsigned int)(v5 - 1) >> 1));
        v10 = 4 - v4;
        v57 = (_BYTE *)(v5 + a2 - 1);
        if ( v5 )
        {
          v53 = *a1;
          do
          {
            *v57 = (*v9 >> v10) & 0xF | (16 * ((*v9 >> v10) & 0xF));
            if ( v10 == 4 )
            {
              v10 = 0;
              --v9;
            }
            else
            {
              v10 = 4;
            }
            LOBYTE(v4) = v53 - 1;
            v11 = v53 == 1;
            --v57;
            --v53;
          }
          while ( !v11 );
        }
        goto LABEL_29;
      }
    }
LABEL_30:
    v6 = a3;
    *((_BYTE *)v3 + 9) = 8;
    *((_BYTE *)v3 + 11) = 8;
    v3[1] = v5;
  }
  if ( v6 )
  {
    v16 = *((_BYTE *)v3 + 9);
    if ( v16 == 8 )
    {
      v17 = (_BYTE *)(v5 + a2 - 1);
      v18 = (_BYTE *)(a2 + 2 * v5 - 1);
      if ( v5 )
      {
        v19 = v5;
        do
        {
          if ( (unsigned __int8)*v17 == v7 )
            *v18 = 0;
          else
            *v18 = -1;
          v20 = v18 - 1;
          *v20 = *v17;
          v18 = v20 - 1;
          --v17;
          --v19;
        }
        while ( v19 );
        v21 = *((_BYTE *)v3 + 9);
        *((_BYTE *)v3 + 8) = 4;
        *((_BYTE *)v3 + 10) = 2;
        v22 = 2 * v21;
        goto LABEL_70;
      }
    }
    else if ( v16 == 16 )
    {
      v23 = v3[1];
      v24 = (_BYTE *)(v23 + a2 - 1);
      v25 = (_BYTE *)(a2 + 2 * v23 - 1);
      if ( v5 )
      {
        v26 = v5;
        v27 = v7;
        do
        {
          HIBYTE(v28) = *(v24 - 1);
          LOBYTE(v28) = *v24;
          if ( v28 == v27 )
          {
            *v25 = 0;
            v29 = v25 - 1;
            *v29 = 0;
          }
          else
          {
            *v25 = -1;
            v29 = v25 - 1;
            *v29 = -1;
          }
          v30 = v29 - 1;
          *v30-- = *v24;
          *v30 = *(v24 - 1);
          v25 = v30 - 1;
          v24 -= 2;
          --v26;
        }
        while ( v26 );
      }
    }
    v31 = *((_BYTE *)v3 + 9);
    *((_BYTE *)v3 + 8) = 4;
    *((_BYTE *)v3 + 10) = 2;
    v22 = 2 * v31;
LABEL_70:
    *((_BYTE *)v3 + 11) = v22;
    v4 = (v5 * (unsigned int)v22) >> 3;
    v3[1] = v4;
  }
  return v4;
}

//----- (00482C20) --------------------------------------------------------
char __cdecl sub_482C20(int *a1, _BYTE *a2, int a3, int a4)
{
  int *v4; // edx
  unsigned __int8 *i; // eax
  int v6; // ebx
  _BYTE *v7; // ecx
  _BYTE *v8; // edi
  char v9; // al
  char v10; // dl
  unsigned __int8 *v11; // ecx
  int v12; // esi
  int v13; // edx
  unsigned __int8 v14; // al
  _BYTE *v15; // ecx
  _BYTE *v16; // edi
  char v17; // al
  char v18; // dl
  unsigned __int8 *v19; // ecx
  int v20; // esi
  int v21; // edx
  int v22; // ecx
  int v24; // [esp+10h] [ebp-4h]

  v4 = a1;
  LOBYTE(i) = *((_BYTE *)a1 + 8);
  v6 = *a1;
  v24 = *a1;
  if ( (_BYTE)i == 2 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v7 = a2;
    v8 = a2;
    if ( !v6 )
    {
LABEL_7:
      v14 = *((_BYTE *)v4 + 9);
      *((_BYTE *)v4 + 11) = v14;
      i = (unsigned __int8 *)((v6 * (unsigned int)v14 + 7) >> 3);
      *((_BYTE *)v4 + 8) = 3;
      *((_BYTE *)v4 + 10) = 1;
      v4[1] = (int)i;
      return (char)i;
    }
    do
    {
      v9 = *v7;
      v10 = v7[1];
      v11 = v7 + 2;
      v12 = v10 & 0xF8;
      v13 = *v11;
      v7 = v11 + 1;
      ++v8;
      --v6;
      *(v8 - 1) = *(_BYTE *)(((v13 >> 3) & 0x1F | (4 * (v12 | (32 * (v9 & 0xF8))))) + a3);
    }
    while ( v6 );
LABEL_6:
    v6 = v24;
    v4 = a1;
    goto LABEL_7;
  }
  if ( (_BYTE)i == 6 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v15 = a2;
    v16 = a2;
    if ( !v6 )
      goto LABEL_7;
    do
    {
      v17 = *v15;
      v18 = v15[1];
      v19 = v15 + 2;
      v20 = v18 & 0xF8;
      v21 = *v19;
      v15 = v19 + 2;
      ++v16;
      --v6;
      *(v16 - 1) = *(_BYTE *)(((v21 >> 3) & 0x1F | (4 * (v20 | (32 * (v17 & 0xF8))))) + a3);
    }
    while ( v6 );
    goto LABEL_6;
  }
  if ( (_BYTE)i == 3 )
  {
    if ( a4 )
    {
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        for ( i = a2; v6; *(i - 1) = *(_BYTE *)(v22 + a4) )
        {
          v22 = *i++;
          --v6;
        }
      }
    }
  }
  return (char)i;
}

//----- (00482D40) --------------------------------------------------------
void __cdecl sub_482D40(int a1)
{
  int v1; // edi
  double v2; // st7
  int v3; // edi
  double v4; // st7
  int v5; // edi
  double v6; // st7
  int v7; // eax
  int v8; // ebx
  int v9; // edi
  unsigned int v10; // edi
  double v11; // st7
  __int16 v12; // ax
  int v13; // eax
  unsigned int v14; // ebx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // ebx
  int v18; // eax
  int v19; // edi
  unsigned int v20; // ebx
  double v21; // st7
  __int64 v22; // rax
  int v23; // edx
  int v24; // edi
  unsigned int v25; // ebx
  double v26; // st7
  __int64 v27; // rax
  int v28; // edx
  int v29; // edi
  unsigned int v30; // ebx
  double v31; // st7
  __int64 v32; // rax
  int v33; // edx
  int v34; // [esp+Ch] [ebp-34h]
  int v35; // [esp+Ch] [ebp-34h]
  int v36; // [esp+Ch] [ebp-34h]
  int v37; // [esp+Ch] [ebp-34h]
  int v38; // [esp+10h] [ebp-30h]
  int v39; // [esp+10h] [ebp-30h]
  int v40; // [esp+10h] [ebp-30h]
  int v41; // [esp+10h] [ebp-30h]
  int v42; // [esp+14h] [ebp-2Ch]
  int i; // [esp+18h] [ebp-28h]
  int j; // [esp+18h] [ebp-28h]
  char v45; // [esp+1Ch] [ebp-24h]
  unsigned int v46; // [esp+20h] [ebp-20h]
  __int16 v47; // [esp+24h] [ebp-1Ch]
  unsigned int v48; // [esp+28h] [ebp-18h]

  if ( *(float *)(a1 + 348) == dbl_4A91B8 )
    return;
  if ( *(_BYTE *)(a1 + 295) <= 8u )
  {
    v1 = 0;
    *(_DWORD *)(a1 + 356) = sub_487D00((int *)a1, 0x100u);
    v38 = 0;
    do
    {
      v2 = (double)v38 * dbl_4B02F8;
      sub_4A2150(v2);
      v38 = ++v1;
      *(_BYTE *)(*(_DWORD *)(a1 + 356) + v1 - 1) = (__int64)(v2 * dbl_4B02F0 + dbl_4AD770);
    }
    while ( v1 < 256 );
    if ( (*(_DWORD *)(a1 + 112) & 0x600080) != 0 )
    {
      v3 = 0;
      *(_DWORD *)(a1 + 364) = sub_487D00((int *)a1, 0x100u);
      v39 = 0;
      do
      {
        v4 = (double)v39 * dbl_4B02F8;
        sub_4A2150(v4);
        v39 = ++v3;
        *(_BYTE *)(v3 + *(_DWORD *)(a1 + 364) - 1) = (__int64)(v4 * dbl_4B02F0 + dbl_4AD770);
      }
      while ( v3 < 256 );
      *(_DWORD *)(a1 + 360) = sub_487D00((int *)a1, 0x100u);
      v5 = 0;
      v40 = 0;
      do
      {
        v6 = (double)v40 * dbl_4B02F8;
        sub_4A2150(v6);
        v40 = ++v5;
        *(_BYTE *)(*(_DWORD *)(a1 + 360) + v5 - 1) = (__int64)(v6 * dbl_4B02F0 + dbl_4AD770);
      }
      while ( v5 < 256 );
    }
    return;
  }
  if ( (*(_BYTE *)(a1 + 294) & 2) != 0 )
  {
    v7 = *(unsigned __int8 *)(a1 + 380);
    if ( *(unsigned __int8 *)(a1 + 381) > v7 )
      v7 = *(unsigned __int8 *)(a1 + 381);
    if ( *(unsigned __int8 *)(a1 + 382) > v7 )
      v7 = *(unsigned __int8 *)(a1 + 382);
  }
  else
  {
    v7 = *(unsigned __int8 *)(a1 + 383);
  }
  if ( v7 <= 0 )
  {
    v41 = 0;
    v8 = 0;
  }
  else
  {
    v8 = 16 - v7;
    v41 = 16 - v7;
  }
  if ( (*(_DWORD *)(a1 + 112) & 0x400) != 0 && v8 < 5 )
  {
    v41 = 5;
  }
  else if ( v8 <= 8 )
  {
    if ( v8 >= 0 )
      goto LABEL_28;
    v41 = 0;
  }
  else
  {
    v41 = 8;
  }
  v8 = v41;
LABEL_28:
  v9 = 1 << (8 - v8);
  v45 = 8 - v8;
  *(_DWORD *)(a1 + 344) = (unsigned __int8)v8;
  v42 = v9;
  *(_DWORD *)(a1 + 368) = sub_487D00((int *)a1, 4 * v9);
  v34 = 0;
  if ( (*(_DWORD *)(a1 + 112) & 0x480) != 0 )
  {
    if ( v9 > 0 )
    {
      do
        *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v34++) = sub_487D00((int *)a1, 0x200u);
      while ( v34 < v9 );
    }
    v10 = 0;
    v35 = 0;
    v46 = v42 << 8;
    do
    {
      v11 = ((double)v35 + dbl_4AD770) * dbl_4B0310;
      sub_4A2150(v11);
      v48 = (__int64)(v11 * (double)(unsigned int)(v42 << 8));
      if ( v10 <= v48 )
      {
        LOBYTE(v12) = 0;
        HIBYTE(v12) = v35;
        v47 = v35 | v12;
        v13 = 255 >> v8;
        for ( i = 255 >> v8; ; v13 = i )
        {
          v14 = v10 >> v45;
          v15 = *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * (v10++ & v13));
          *(_WORD *)(v15 + 2 * v14) = v47;
          if ( v10 > v48 )
            break;
        }
        v8 = v41;
      }
      ++v35;
    }
    while ( v35 < 256 );
    if ( v10 >= v46 )
      goto LABEL_50;
    v16 = 255 >> v8;
    for ( j = 255 >> v8; ; v16 = j )
    {
      v17 = v10 >> v45;
      v18 = *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * (v10++ & v16));
      *(_WORD *)(v18 + 2 * v17) = -1;
      if ( v10 >= v46 )
        break;
    }
  }
  else
  {
    if ( v9 <= 0 )
      goto LABEL_51;
    while ( 1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v34) = sub_487D00((int *)a1, 0x200u);
      v19 = 0;
      v20 = (unsigned int)(v34 * dword_4BDBA4[v8]) >> 4;
      do
      {
        v21 = (double)v20 * dbl_4B0308;
        sub_4A2150(v21);
        v22 = (__int64)(v21 * dbl_4B0300 + dbl_4AD770);
        v23 = v34;
        v19 += 2;
        v20 += 256;
        *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 368) + 4 * v34) + v19 - 2) = v22;
      }
      while ( v19 < 512 );
      ++v34;
      if ( v23 + 1 >= v42 )
        break;
      v8 = v41;
    }
  }
  v8 = v41;
LABEL_50:
  v9 = v42;
LABEL_51:
  if ( (*(_DWORD *)(a1 + 112) & 0x600080) != 0 )
  {
    *(_DWORD *)(a1 + 376) = sub_487D00((int *)a1, 4 * v9);
    v36 = 0;
    if ( v9 > 0 )
    {
      do
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 376) + 4 * v36) = sub_487D00((int *)a1, 0x200u);
        v24 = 0;
        v25 = (unsigned int)(v36 * dword_4BDBA4[v8]) >> 4;
        do
        {
          v26 = (double)v25 * dbl_4B0308;
          sub_4A2150(v26);
          v27 = (__int64)(v26 * dbl_4B0300 + dbl_4AD770);
          v28 = v36;
          v24 += 2;
          v25 += 256;
          *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 376) + 4 * v36) + v24 - 2) = v27;
        }
        while ( v24 < 512 );
        v8 = v41;
        ++v36;
      }
      while ( v28 + 1 < v42 );
      v9 = v42;
    }
    *(_DWORD *)(a1 + 372) = sub_487D00((int *)a1, 4 * v9);
    v37 = 0;
    if ( v9 > 0 )
    {
      while ( 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * v37) = sub_487D00((int *)a1, 0x200u);
        v29 = 0;
        v30 = (unsigned int)(v37 * dword_4BDBA4[v8]) >> 4;
        do
        {
          v31 = (double)v30 * dbl_4B0308;
          sub_4A2150(v31);
          v32 = (__int64)(v31 * dbl_4B0300 + dbl_4AD770);
          v33 = v37;
          v29 += 2;
          v30 += 256;
          *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 372) + 4 * v37) + v29 - 2) = v32;
        }
        while ( v29 < 512 );
        ++v37;
        if ( v33 + 1 >= v42 )
          break;
        v8 = v41;
      }
    }
  }
}
// 4A2150: using guessed type double __usercall sub_4A2150@<st0>(double@<st0>);
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B02F0: using guessed type double dbl_4B02F0;
// 4B02F8: using guessed type double dbl_4B02F8;
// 4B0300: using guessed type double dbl_4B0300;
// 4B0308: using guessed type double dbl_4B0308;
// 4B0310: using guessed type double dbl_4B0310;

//----- (004833A0) --------------------------------------------------------
char __cdecl sub_4833A0(int *a1, int a2)
{
  _BYTE *v2; // eax
  char v3; // cl
  int v4; // edx
  int v5; // esi
  char v6; // cl
  int v7; // edi
  int v8; // esi
  __int16 v9; // cx
  __int16 v10; // bx
  __int16 v11; // dx
  __int16 v12; // dx
  __int16 v13; // cx

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v5 = 3;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v5 = 4;
      }
      if ( v4 )
      {
        v2 = (_BYTE *)(a2 + 2);
        do
        {
          v6 = *(v2 - 1);
          *(v2 - 2) += v6;
          *v2 += v6;
          v2 += v5;
          --v4;
        }
        while ( v4 );
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        v7 = 6;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v7 = 8;
      }
      if ( v4 )
      {
        v8 = *a1;
        v2 = (_BYTE *)(a2 + 1);
        do
        {
          HIBYTE(v9) = v2[1];
          HIBYTE(v10) = v2[3];
          LOBYTE(v9) = v2[2];
          LOBYTE(v10) = v2[4];
          HIBYTE(v11) = *(v2 - 1);
          LOBYTE(v11) = *v2;
          v12 = v9 + v11;
          v13 = v9 + v10;
          v2[4] = v13;
          *v2 = v12;
          *(v2 - 1) = HIBYTE(v12);
          v2[3] = HIBYTE(v13);
          v2 += v7;
          --v8;
        }
        while ( v8 );
      }
    }
  }
  return (char)v2;
}

//----- (00483470) --------------------------------------------------------
int __cdecl sub_483470(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 && a2 )
    result = a3 & *(_DWORD *)(a2 + 8);
  else
    result = 0;
  return result;
}

//----- (00483490) --------------------------------------------------------
int __cdecl sub_483490(int a1, int a2)
{
  int result; // eax

  if ( a1 && a2 )
    result = *(_DWORD *)(a2 + 12);
  else
    result = 0;
  return result;
}

//----- (00483790) --------------------------------------------------------
int __cdecl sub_483790(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 0x20) == 0 || !a3 )
    return 0;
  *a3 = a2 + 90;
  return 32;
}

//----- (00483DE0) --------------------------------------------------------
int __cdecl sub_483DE0(int a1, int a2, _DWORD *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 2) == 0 || !a3 )
    return 0;
  *a3 = a2 + 68;
  return 2;
}

//----- (00484040) --------------------------------------------------------
void __cdecl __noreturn sub_484040(int *a1, const char *a2)
{
  const char *v2; // esi
  int v3; // ecx
  int i; // eax
  signed int v5; // ecx
  signed int v6; // eax
  void (__cdecl *v7)(int *, const char *); // eax
  char v8[16]; // [esp+8h] [ebp-10h] BYREF

  v2 = a2;
  v3 = a1[27];
  if ( (v3 & 0xC0000) == 0 )
    goto LABEL_14;
  if ( *a2 == 35 )
  {
    for ( i = 1; i < 15; ++i )
    {
      if ( a2[i] == 32 )
        break;
    }
    if ( (v3 & 0x80000) == 0 )
    {
      v2 = &a2[i];
      goto LABEL_14;
    }
    v5 = 0;
    v6 = i - 1;
    if ( v6 > 0 )
    {
      qmemcpy(v8, a2 + 1, v6);
      v5 = v6;
    }
    v8[v5] = 0;
  }
  else
  {
    if ( (v3 & 0x80000) == 0 )
      goto LABEL_14;
    v8[0] = 48;
    v8[1] = 0;
  }
  v2 = v8;
LABEL_14:
  v7 = (void (__cdecl *)(int *, const char *))a1[16];
  if ( v7 )
    v7(a1, v2);
  sub_484220(a1, v2);
}

//----- (004840E0) --------------------------------------------------------
int __cdecl sub_4840E0(int a1, _BYTE *a2)
{
  int i; // eax
  int (__cdecl *v3)(int, _BYTE *); // ecx
  int result; // eax

  i = 0;
  if ( (*(_DWORD *)(a1 + 108) & 0xC0000) != 0 && *a2 == 35 )
  {
    for ( i = 1; i < 15; ++i )
    {
      if ( a2[i] == 32 )
        break;
    }
  }
  v3 = *(int (__cdecl **)(int, _BYTE *))(a1 + 68);
  if ( v3 )
    result = v3(a1, &a2[i]);
  else
    result = sub_4842B0(a1, &a2[i]);
  return result;
}

//----- (00484130) --------------------------------------------------------
void __cdecl __noreturn sub_484130(int *a1, const void *a2)
{
  char v2[84]; // [esp+4h] [ebp-54h] BYREF

  sub_484160((int)a1, (int)v2, a2);
  sub_484040(a1, v2);
}

//----- (00484160) --------------------------------------------------------
_BYTE *__cdecl sub_484160(int a1, int a2, const void *a3)
{
  _BYTE *result; // eax
  int i; // esi
  int v5; // ecx
  _BYTE *v6; // eax
  _BYTE *v7; // eax

  result = 0;
  for ( i = 0; i < 4; ++i )
  {
    v5 = *(unsigned __int8 *)(i + a1 + 284);
    if ( v5 < 41 || v5 > 122 || v5 > 90 && v5 < 97 )
    {
      result[a2] = 91;
      v6 = result + 2;
      v6[a2 - 1] = byte_4B0324[(v5 >> 4) & 0xF];
      v6[a2] = byte_4B0324[v5 & 0xF];
      result = v6 + 1;
      result[a2] = 93;
    }
    else
    {
      result[a2] = v5;
    }
    ++result;
  }
  if ( a3 )
  {
    result[a2] = 58;
    v7 = result + 1;
    v7[a2] = 32;
    result = &v7[a2 + 1];
    qmemcpy(result, a3, 0x40u);
    result[63] = 0;
  }
  else
  {
    result[a2] = 0;
  }
  return result;
}

//----- (004841F0) --------------------------------------------------------
int __cdecl sub_4841F0(int a1, const void *a2)
{
  char v3[84]; // [esp+4h] [ebp-54h] BYREF

  sub_484160(a1, (int)v3, a2);
  return sub_4840E0(a1, v3);
}

//----- (00484220) --------------------------------------------------------
void __cdecl __noreturn sub_484220(jmp_buf Buf, const char *a2)
{
  int v2; // ecx
  const char *v3; // eax
  char v4; // [esp+3h] [ebp-11h]
  char v5[16]; // [esp+4h] [ebp-10h] BYREF

  if ( *a2 == 35 )
  {
    v2 = 0;
    v3 = a2;
    do
    {
      v3[v5 - a2] = v3[1];
      if ( *v3 == 32 )
        break;
      ++v2;
      ++v3;
    }
    while ( v2 < 15 );
    if ( v2 <= 1 || v2 >= 15 )
    {
      fprintf(&Stream, "libpng error: %s, offset=%d\n", a2, v2);
    }
    else
    {
      *(&v4 + v2) = 0;
      fprintf(&Stream, "libpng error no. %s: %s\n", v5, &a2[v2]);
    }
  }
  else
  {
    fprintf(&Stream, "libpng error: %s\n", a2);
  }
  longjmp(Buf, 1);
}

//----- (004842B0) --------------------------------------------------------
int __cdecl sub_4842B0(int a1, const char *a2)
{
  int v2; // ecx
  const char *v3; // eax
  char v5; // [esp+3h] [ebp-11h]
  char v6[16]; // [esp+4h] [ebp-10h] BYREF

  if ( *a2 != 35 )
    return fprintf(&Stream, "libpng warning: %s\n", a2);
  v2 = 0;
  v3 = a2;
  do
  {
    v3[v6 - a2] = v3[1];
    if ( *v3 == 32 )
      break;
    ++v2;
    ++v3;
  }
  while ( v2 < 15 );
  if ( v2 <= 1 || v2 >= 15 )
    return fprintf(&Stream, "libpng warning: %s\n", a2);
  *(&v5 + v2) = 0;
  return fprintf(&Stream, "libpng warning no. %s: %s\n", v6, &a2[v2]);
}

//----- (00484330) --------------------------------------------------------
_DWORD *__cdecl sub_484330(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[18] = a2;
  a1[16] = a3;
  a1[17] = a4;
  return result;
}

//----- (00484380) --------------------------------------------------------
int __cdecl sub_484380(int *a1, int a2, int a3)
{
  int (__cdecl *v3)(int *, int, int); // eax

  v3 = (int (__cdecl *)(int *, int, int))a1[20];
  if ( !v3 )
    sub_484040(a1, aCallToNullRead);
  return v3(a1, a2, a3);
}

//----- (004843B0) --------------------------------------------------------
size_t __cdecl sub_4843B0(int a1, void *a2, size_t a3)
{
  size_t result; // eax

  result = sub_46F02A(a2, 1u, a3, *(FILE **)(a1 + 84));
  if ( result != a3 )
    sub_484040((int *)a1, aReadError);
  return result;
}

//----- (004843F0) --------------------------------------------------------
int __cdecl sub_4843F0(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  a1[21] = a2;
  if ( a3 )
    a1[20] = a3;
  else
    a1[20] = sub_4843B0;
  result = a1[19];
  if ( result )
  {
    a1[19] = 0;
    sub_4840E0((int)a1, aItSAnErrorToSe);
    result = sub_4840E0((int)a1, aSameStructureR);
  }
  a1[83] = 0;
  return result;
}

//----- (00484480) --------------------------------------------------------
int __cdecl sub_484480(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ecx
  char v5[8]; // [esp+0h] [ebp-8h] BYREF

  v3 = a3;
  v5[0] = -119;
  v5[1] = 80;
  v5[2] = 78;
  v5[3] = 71;
  v5[4] = 13;
  v5[5] = 10;
  v5[6] = 26;
  v5[7] = 10;
  if ( a3 <= 8 )
  {
    if ( !a3 )
      return 0;
  }
  else
  {
    v3 = 8;
  }
  if ( a2 > 7 )
    return 0;
  if ( a2 + v3 > 8 )
    v3 = 8 - a2;
  return memcmp((const char *)(a1 + a2), &v5[a2], v3);
}

//----- (00484520) --------------------------------------------------------
int __cdecl sub_484520(int *a1, int a2, int a3)
{
  int v3; // ebx
  int result; // eax

  v3 = a1[27];
  a1[27] = v3 | 0x100000;
  result = sub_487D00(a1, a3 * a2);
  a1[27] = v3;
  if ( result )
  {
    memset((void *)result, 0, 0x8000u);
    memset((void *)(result + 0x8000), 0, a3 * a2 - 0x8000);
  }
  return result;
}

//----- (004845A0) --------------------------------------------------------
void __cdecl sub_4845A0(int a1, unsigned int a2)
{
  sub_487DA0(a1, a2);
}

//----- (004845C0) --------------------------------------------------------
int __cdecl sub_4845C0(int a1)
{
  int result; // eax

  result = sub_4A1DE0(0, 0, 0);
  *(_DWORD *)(a1 + 272) = result;
  return result;
}

//----- (004845E0) --------------------------------------------------------
int __cdecl sub_4845E0(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 108);
  if ( (*(_BYTE *)(a1 + 284) & 0x20) == 0 )
  {
    if ( (result & 0x800) != 0 )
      return result;
    goto LABEL_5;
  }
  result = *(_DWORD *)(a1 + 108) & 0x300;
  if ( result != 768 )
  {
LABEL_5:
    result = sub_4A1DE0(*(_DWORD *)(a1 + 272), a2, a3);
    *(_DWORD *)(a1 + 272) = result;
  }
  return result;
}

//----- (00484630) --------------------------------------------------------
void *__cdecl sub_484630(void *a1)
{
  void *result; // eax

  result = a1;
  if ( a1 )
  {
    result = sub_487C10(2, *((int (__cdecl **)(char *, size_t))a1 + 146), *((_DWORD *)a1 + 145));
    a1 = result;
    if ( result )
    {
      sub_4846C0((unsigned int *)&a1, 0x120u);
      result = a1;
    }
  }
  return result;
}

//----- (004846C0) --------------------------------------------------------
int __cdecl sub_4846C0(unsigned int *a1, unsigned int a2)
{
  void *v2; // edi
  int result; // eax

  v2 = (void *)*a1;
  if ( a2 < 0x120 )
  {
    sub_487C90(*a1);
    v2 = sub_487BF0(2);
    *a1 = (unsigned int)v2;
  }
  result = 0;
  memset(v2, 0, 0x120u);
  return result;
}

//----- (00484760) --------------------------------------------------------
void __cdecl sub_484760(int a1, int a2, int a3, int a4)
{
  int v4; // ebp
  int v5; // eax
  unsigned int v6; // eax
  int i; // ebp
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // ebp
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // ebp
  int v17; // eax
  int v18; // ebp
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ebp
  int v23; // eax
  int v24; // eax
  int j; // ebp
  int v26; // eax

  if ( !a1 || !a2 )
    return;
  v4 = a3;
  if ( ((unsigned __int16)a3 & *(_WORD *)(a2 + 184) & 0x4000) != 0 )
  {
    if ( a4 == -1 )
    {
      for ( i = 0; i < *(_DWORD *)(a2 + 48); ++i )
        sub_484760(a1, a2, 0x4000, i);
      sub_487DA0(a1, *(_DWORD *)(a2 + 56));
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 48) = 0;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 56);
      if ( !v5 )
        goto LABEL_12;
      v6 = *(_DWORD *)(v5 + 16 * a4 + 4);
      if ( v6 )
      {
        sub_487DA0(a1, v6);
        *(_DWORD *)(*(_DWORD *)(a2 + 56) + 16 * a4 + 4) = 0;
      }
    }
    v4 = a3;
  }
LABEL_12:
  if ( ((unsigned __int16)v4 & *(_WORD *)(a2 + 184) & 0x2000) != 0 )
  {
    sub_487DA0(a1, *(_DWORD *)(a2 + 76));
    v8 = *(_DWORD *)(a2 + 8);
    LOBYTE(v8) = v8 & 0xEF;
    *(_DWORD *)(a2 + 76) = 0;
    *(_DWORD *)(a2 + 8) = v8;
  }
  v9 = v4 & *(_DWORD *)(a2 + 184);
  if ( (v9 & 0x100) != 0 )
  {
    v10 = *(_DWORD *)(a2 + 8);
    BYTE1(v10) &= 0xBFu;
    *(_DWORD *)(a2 + 8) = v10;
  }
  if ( (v9 & 0x80u) != 0 )
  {
    sub_487DA0(a1, *(_DWORD *)(a2 + 160));
    sub_487DA0(a1, *(_DWORD *)(a2 + 172));
    v11 = *(_DWORD *)(a2 + 176);
    *(_DWORD *)(a2 + 160) = 0;
    *(_DWORD *)(a2 + 172) = 0;
    if ( v11 )
    {
      v12 = 0;
      if ( *(_BYTE *)(a2 + 181) )
      {
        do
        {
          sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a2 + 176) + 4 * v12));
          *(_DWORD *)(*(_DWORD *)(a2 + 176) + 4 * v12++) = 0;
        }
        while ( v12 < *(unsigned __int8 *)(a2 + 181) );
      }
      sub_487DA0(a1, *(_DWORD *)(a2 + 176));
      v4 = a3;
      *(_DWORD *)(a2 + 176) = 0;
    }
    v13 = *(_DWORD *)(a2 + 8);
    BYTE1(v13) &= 0xFBu;
    *(_DWORD *)(a2 + 8) = v13;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x10) != 0 )
  {
    sub_487DA0(a1, *(_DWORD *)(a2 + 196));
    sub_487DA0(a1, *(_DWORD *)(a2 + 200));
    v14 = *(_DWORD *)(a2 + 8);
    BYTE1(v14) &= 0xEFu;
    *(_DWORD *)(a2 + 196) = 0;
    *(_DWORD *)(a2 + 200) = 0;
    *(_DWORD *)(a2 + 8) = v14;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x20) != 0 )
  {
    if ( a4 == -1 )
    {
      v17 = *(_DWORD *)(a2 + 216);
      if ( v17 )
      {
        v18 = 0;
        if ( v17 > 0 )
        {
          do
            sub_484760(a1, a2, 32, v18++);
          while ( v18 < *(_DWORD *)(a2 + 216) );
        }
        sub_487DA0(a1, *(_DWORD *)(a2 + 212));
        v4 = a3;
        *(_DWORD *)(a2 + 212) = 0;
        *(_DWORD *)(a2 + 216) = 0;
      }
      v19 = *(_DWORD *)(a2 + 8);
      BYTE1(v19) &= 0xDFu;
      *(_DWORD *)(a2 + 8) = v19;
    }
    else
    {
      v15 = *(_DWORD *)(a2 + 212);
      if ( v15 )
      {
        v16 = 16 * a4;
        sub_487DA0(a1, *(_DWORD *)(v15 + 16 * a4));
        sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a2 + 212) + 16 * a4 + 8));
        *(_DWORD *)(*(_DWORD *)(a2 + 212) + v16) = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 212) + v16 + 8) = 0;
        v4 = a3;
      }
    }
  }
  if ( ((unsigned __int16)v4 & *(_WORD *)(a2 + 184) & 0x200) == 0 )
    goto LABEL_42;
  if ( a4 == -1 )
  {
    v21 = *(_DWORD *)(a2 + 192);
    if ( v21 )
    {
      v22 = 0;
      if ( v21 > 0 )
      {
        do
          sub_484760(a1, a2, 512, v22++);
        while ( v22 < *(_DWORD *)(a2 + 192) );
      }
      sub_487DA0(a1, *(_DWORD *)(a2 + 188));
      *(_DWORD *)(a2 + 188) = 0;
      *(_DWORD *)(a2 + 192) = 0;
      goto LABEL_41;
    }
  }
  else
  {
    v20 = *(_DWORD *)(a2 + 188);
    if ( v20 )
    {
      sub_487DA0(a1, *(_DWORD *)(v20 + 20 * a4 + 8));
      *(_DWORD *)(*(_DWORD *)(a2 + 188) + 20 * a4 + 8) = 0;
LABEL_41:
      v4 = a3;
      goto LABEL_42;
    }
  }
LABEL_42:
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 8) != 0 )
  {
    sub_487DA0(a1, *(_DWORD *)(a2 + 124));
    v23 = *(_DWORD *)(a2 + 8);
    LOBYTE(v23) = v23 & 0xBF;
    *(_DWORD *)(a2 + 124) = 0;
    *(_DWORD *)(a2 + 8) = v23;
  }
  if ( ((unsigned __int16)v4 & *(_WORD *)(a2 + 184) & 0x1000) != 0 )
  {
    sub_4845A0(a1, *(_DWORD *)(a2 + 16));
    v24 = *(_DWORD *)(a2 + 8);
    LOBYTE(v24) = v24 & 0xF7;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 8) = v24;
    *(_WORD *)(a2 + 20) = 0;
  }
  if ( ((unsigned __int8)v4 & *(_BYTE *)(a2 + 184) & 0x40) != 0 )
  {
    if ( *(_DWORD *)(a2 + 248) )
    {
      for ( j = 0; j < *(_DWORD *)(a2 + 4); ++j )
      {
        sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a2 + 248) + 4 * j));
        *(_DWORD *)(*(_DWORD *)(a2 + 248) + 4 * j) = 0;
      }
      sub_487DA0(a1, *(_DWORD *)(a2 + 248));
      v4 = a3;
      *(_DWORD *)(a2 + 248) = 0;
    }
    v26 = *(_DWORD *)(a2 + 8);
    BYTE1(v26) &= 0x7Fu;
    *(_DWORD *)(a2 + 8) = v26;
  }
  if ( a4 != -1 )
    v4 &= 0xFFFFBDDF;
  *(_DWORD *)(a2 + 184) &= ~v4;
}

//----- (00484B20) --------------------------------------------------------
int __cdecl sub_484B20(int a1, int a2)
{
  sub_484760(a1, a2, 0x7FFF, -1);
  if ( *(_DWORD *)(a1 + 544) )
  {
    sub_487DA0(a1, *(_DWORD *)(a1 + 548));
    *(_DWORD *)(a1 + 548) = 0;
    *(_DWORD *)(a1 + 544) = 0;
  }
  return sub_4846C0((unsigned int *)&a2, 0x120u);
}

//----- (00484C80) --------------------------------------------------------
int __cdecl sub_484C80(int a1, _DWORD *a2)
{
  int v2; // eax
  int i; // ecx

  if ( !a1 && !a2 )
    return 0;
  v2 = *(_DWORD *)(a1 + 544);
  if ( v2 <= 0 )
    return 0;
  for ( i = 5 * v2 + *(_DWORD *)(a1 + 548) - 5; *a2 != *(_DWORD *)i; i -= 5 )
  {
    if ( !--v2 )
      return 0;
  }
  return *(unsigned __int8 *)(i + 4);
}
// 484CA9: conditional instruction was optimized away because of 'eax.4>=1'

//----- (00484D00) --------------------------------------------------------
int __cdecl sub_484D00(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  *(_DWORD *)(a1 + 572) = 0;
  *(_BYTE *)(a1 + 569) = 0;
  v2 = *(_DWORD *)(a1 + 576);
  LOBYTE(v2) = 0;
  *(_DWORD *)(a1 + 576) = v2;
  return result;
}

//----- (00484D40) --------------------------------------------------------
__int16 __cdecl sub_484D40(int *a1, int a2)
{
  int v2; // eax
  int v3; // eax
  unsigned int v4; // edi
  int v5; // eax
  char v6; // cl

  v2 = a1[26];
  if ( (v2 & 0x400) == 0 )
  {
    sub_48B610((int)a1);
    if ( (a1[26] & 0x1000) != 0 && a1[140] )
    {
      sub_4840E0((int)a1, aMngFeaturesAre);
      a1[140] = 0;
    }
    sub_48B680(
      (int)a1,
      *(_DWORD *)a2,
      *(_DWORD *)(a2 + 4),
      *(unsigned __int8 *)(a2 + 24),
      *(unsigned __int8 *)(a2 + 25),
      *(unsigned __int8 *)(a2 + 26),
      *(unsigned __int8 *)(a2 + 27),
      *(unsigned __int8 *)(a2 + 28));
    if ( (*(_BYTE *)(a2 + 8) & 1) != 0 )
      sub_48BB20((int)a1, *(float *)(a2 + 40));
    if ( (*(_DWORD *)(a2 + 8) & 0x800) != 0 )
      sub_48BB90(a1, *(unsigned __int8 *)(a2 + 44));
    if ( (*(_DWORD *)(a2 + 8) & 0x1000) != 0 )
      sub_48BBD0(a1, *(unsigned __int8 **)(a2 + 196), 0, *(_DWORD *)(a2 + 200), *(_DWORD *)(a2 + 204));
    if ( (*(_BYTE *)(a2 + 8) & 2) != 0 )
      sub_48C1B0((int)a1, (_BYTE *)(a2 + 68), *(unsigned __int8 *)(a2 + 25));
    if ( (*(_BYTE *)(a2 + 8) & 4) != 0 )
      sub_48C270(
        (int)a1,
        *(float *)(a2 + 128),
        *(float *)(a2 + 132),
        *(float *)(a2 + 136),
        *(float *)(a2 + 140),
        *(float *)(a2 + 144),
        *(float *)(a2 + 148),
        *(float *)(a2 + 152),
        *(float *)(a2 + 156));
    v3 = *(_DWORD *)(a2 + 192);
    if ( v3 )
    {
      v4 = *(_DWORD *)(a2 + 188);
      if ( v4 < v4 + 20 * v3 )
      {
        do
        {
          v5 = sub_484C80((int)a1, (_DWORD *)v4);
          if ( v5 != 1 )
          {
            v6 = *(_BYTE *)(v4 + 16);
            if ( v6 )
            {
              if ( (v6 & 2) == 0 && ((*(_BYTE *)(v4 + 3) & 0x20) != 0 || v5 == 3 || (a1[27] & 0x10000) != 0) )
                sub_48B530(a1, (unsigned __int8 *)v4, *(unsigned __int8 **)(v4 + 8), *(_DWORD *)(v4 + 12));
            }
          }
          v4 += 20;
        }
        while ( v4 < *(_DWORD *)(a2 + 188) + 20 * *(_DWORD *)(a2 + 192) );
      }
    }
    v2 = a1[26];
    BYTE1(v2) |= 4u;
    a1[26] = v2;
  }
  return v2;
}

//----- (00484F20) --------------------------------------------------------
unsigned int __cdecl sub_484F20(int *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // ecx
  int v4; // edi
  int v5; // ebx
  int v6; // ebx
  int v7; // edi
  int v8; // eax
  int v9; // ecx
  unsigned int result; // eax
  unsigned int v11; // edi
  int v12; // eax
  char v13; // cl

  sub_484D40(a1, a2);
  if ( (*(_BYTE *)(a2 + 8) & 8) != 0 )
  {
    sub_48BA00((int)a1, *(_DWORD *)(a2 + 16), *(unsigned __int16 *)(a2 + 20));
  }
  else if ( *(_BYTE *)(a2 + 25) == 3 )
  {
    sub_484040(a1, aValidPaletteRe);
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    if ( (a1[28] & 0x80000) != 0 && *(_BYTE *)(a2 + 25) == 3 )
    {
      v2 = 0;
      if ( *(_WORD *)(a2 + 22) )
      {
        do
        {
          v3 = (_BYTE *)(v2 + *(_DWORD *)(a2 + 76));
          ++v2;
          *v3 = -1 - *v3;
        }
        while ( v2 < *(unsigned __int16 *)(a2 + 22) );
      }
    }
    sub_48C770(
      (int)a1,
      *(unsigned __int8 **)(a2 + 76),
      (unsigned __int16 *)(a2 + 80),
      *(unsigned __int16 *)(a2 + 22),
      *(unsigned __int8 *)(a2 + 25));
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x20) != 0 )
    sub_48C8D0((int)a1, (unsigned __int8 *)(a2 + 90), *(unsigned __int8 *)(a2 + 25));
  if ( (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
    sub_48CA10((int)a1, *(unsigned __int16 **)(a2 + 124), *(unsigned __int16 *)(a2 + 20));
  if ( (*(_DWORD *)(a2 + 8) & 0x100) != 0 )
    sub_48CE00(a1, *(_DWORD *)(a2 + 100), *(_DWORD *)(a2 + 104), *(unsigned __int8 *)(a2 + 108));
  if ( (*(_DWORD *)(a2 + 8) & 0x400) != 0 )
    sub_48CE60(
      a1,
      *(const char **)(a2 + 160),
      *(_DWORD *)(a2 + 164),
      *(_DWORD *)(a2 + 168),
      *(unsigned __int8 *)(a2 + 180),
      *(unsigned __int8 *)(a2 + 181),
      *(char **)(a2 + 172),
      *(unsigned __int8 ***)(a2 + 176));
  if ( (*(_DWORD *)(a2 + 8) & 0x4000) != 0 )
    sub_48CFD0(a1, *(_BYTE *)(a2 + 220), *(double *)(a2 + 224), *(double *)(a2 + 232));
  if ( *(char *)(a2 + 8) < 0 )
    sub_48D090(a1, *(_DWORD *)(a2 + 112), *(_DWORD *)(a2 + 116), *(unsigned __int8 *)(a2 + 120));
  if ( (*(_DWORD *)(a2 + 8) & 0x200) != 0 )
  {
    sub_48D0F0(a1, (_BYTE *)(a2 + 60));
    a1[26] |= 0x200u;
  }
  if ( (*(_DWORD *)(a2 + 8) & 0x2000) != 0 )
  {
    v4 = 0;
    if ( *(int *)(a2 + 216) > 0 )
    {
      v5 = 0;
      do
      {
        sub_48C030(a1, *(_DWORD *)(a2 + 212) + v5);
        ++v4;
        v5 += 16;
      }
      while ( v4 < *(_DWORD *)(a2 + 216) );
    }
  }
  v6 = 0;
  if ( *(int *)(a2 + 48) > 0 )
  {
    v7 = 0;
    while ( 1 )
    {
      v8 = v7 + *(_DWORD *)(a2 + 56);
      v9 = *(_DWORD *)v8;
      if ( *(int *)v8 > 0 )
        break;
      if ( *(_DWORD *)v8 )
      {
        if ( v9 == -1 )
        {
          sub_48CC40(a1, *(unsigned __int8 **)(v8 + 4), *(const char **)(v8 + 8));
          goto LABEL_37;
        }
      }
      else
      {
        sub_48CCF0(a1, *(unsigned __int8 **)(v8 + 4), *(const char **)(v8 + 8), 0, v9);
        *(_DWORD *)(v7 + *(_DWORD *)(a2 + 56)) = -2;
      }
LABEL_38:
      ++v6;
      v7 += 16;
      if ( v6 >= *(_DWORD *)(a2 + 48) )
        goto LABEL_39;
    }
    sub_4840E0((int)a1, aUnableToWriteI);
LABEL_37:
    *(_DWORD *)(v7 + *(_DWORD *)(a2 + 56)) = -3;
    goto LABEL_38;
  }
LABEL_39:
  result = *(_DWORD *)(a2 + 192);
  if ( result )
  {
    v11 = *(_DWORD *)(a2 + 188);
    result = v11 + 20 * result;
    if ( v11 < result )
    {
      do
      {
        v12 = sub_484C80((int)a1, (_DWORD *)v11);
        if ( v12 != 1 )
        {
          v13 = *(_BYTE *)(v11 + 16);
          if ( v13 )
          {
            if ( (v13 & 2) != 0
              && (v13 & 4) == 0
              && ((*(_BYTE *)(v11 + 3) & 0x20) != 0 || v12 == 3 || (a1[27] & 0x10000) != 0) )
            {
              sub_48B530(a1, (unsigned __int8 *)v11, *(unsigned __int8 **)(v11 + 8), *(_DWORD *)(v11 + 12));
            }
          }
        }
        v11 += 20;
        result = 5 * *(_DWORD *)(a2 + 192);
      }
      while ( v11 < *(_DWORD *)(a2 + 188) + 20 * *(_DWORD *)(a2 + 192) );
    }
  }
  return result;
}

//----- (00485200) --------------------------------------------------------
int __cdecl sub_485200(int a1, int a2)
{
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  char v8; // cl

  if ( (*(_BYTE *)(a1 + 104) & 4) == 0 )
    sub_484040((int *)a1, aNoIdatsWritten);
  if ( a2 )
  {
    if ( (*(_DWORD *)(a2 + 8) & 0x200) != 0 && (*(_DWORD *)(a1 + 104) & 0x200) == 0 )
      sub_48D0F0((int *)a1, (_BYTE *)(a2 + 60));
    v2 = 0;
    if ( *(int *)(a2 + 48) > 0 )
    {
      v3 = 0;
      do
      {
        v4 = *(_DWORD *)(a2 + 56) + v3;
        if ( *(int *)v4 <= 0 )
        {
          if ( *(int *)v4 < 0 )
          {
            if ( *(_DWORD *)v4 == -1 )
            {
              sub_48CC40((int *)a1, *(unsigned __int8 **)(v4 + 4), *(const char **)(v4 + 8));
              *(_DWORD *)(*(_DWORD *)(a2 + 56) + v3) = -3;
            }
          }
          else
          {
            sub_48CCF0((int *)a1, *(unsigned __int8 **)(v4 + 4), *(const char **)(v4 + 8), 0, *(_DWORD *)v4);
            *(_DWORD *)(*(_DWORD *)(a2 + 56) + v3) = -2;
          }
        }
        else
        {
          sub_4840E0(a1, aUnableToWriteI);
          *(_DWORD *)(*(_DWORD *)(a2 + 56) + v3) = -3;
        }
        ++v2;
        v3 += 16;
      }
      while ( v2 < *(_DWORD *)(a2 + 48) );
    }
    v5 = *(_DWORD *)(a2 + 192);
    if ( v5 )
    {
      v6 = *(_DWORD *)(a2 + 188);
      if ( v6 < v6 + 20 * v5 )
      {
        do
        {
          v7 = sub_484C80(a1, (_DWORD *)v6);
          if ( v7 != 1 )
          {
            v8 = *(_BYTE *)(v6 + 16);
            if ( v8 )
            {
              if ( (v8 & 8) != 0
                && ((*(_BYTE *)(v6 + 3) & 0x20) != 0 || v7 == 3 || (*(_DWORD *)(a1 + 108) & 0x10000) != 0) )
              {
                sub_48B530((int *)a1, (unsigned __int8 *)v6, *(unsigned __int8 **)(v6 + 8), *(_DWORD *)(v6 + 12));
              }
            }
          }
          v6 += 20;
        }
        while ( v6 < *(_DWORD *)(a2 + 188) + 20 * *(_DWORD *)(a2 + 192) );
      }
    }
  }
  *(_DWORD *)(a1 + 104) |= 8u;
  return sub_48BAF0((int *)a1);
}

//----- (00485360) --------------------------------------------------------
char __cdecl sub_485360(int a1, char *a2)
{
  char result; // al

  *(_WORD *)a1 = *((_WORD *)a2 + 10) + 1900;
  *(_BYTE *)(a1 + 2) = a2[16] + 1;
  *(_BYTE *)(a1 + 3) = a2[12];
  *(_BYTE *)(a1 + 4) = a2[8];
  *(_BYTE *)(a1 + 5) = a2[4];
  result = *a2;
  *(_BYTE *)(a1 + 6) = *a2;
  return result;
}

//----- (004853C0) --------------------------------------------------------
char __usercall sub_4853C0@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  return sub_4853F0(a1, a2, a3, a4, a5, a6, 0, 0, 0);
}

//----- (004853F0) --------------------------------------------------------
char __usercall sub_4853F0@<al>(char a1@<bl>, int a2@<edi>, int a3, int a4, int a5, int a6, int a7, int (__cdecl *a8)(char *, size_t), int a9)
{
  char v9; // fps
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // esi
  int *v13; // esi
  char *v14; // eax
  char v15; // bl
  char v16; // al
  struct _EXCEPTION_REGISTRATION_RECORD *v18; // [esp-2Ch] [ebp-8Ch]
  int v19; // [esp-28h] [ebp-88h]
  struct _EXCEPTION_REGISTRATION_RECORD *v20; // [esp-4h] [ebp-64h]
  int v21; // [esp+0h] [ebp-60h]
  char Buffer[80]; // [esp+Ch] [ebp-54h] BYREF
  _DWORD *v23; // [esp+5Ch] [ebp-4h]
  int savedregs; // [esp+60h] [ebp+0h] BYREF

  v10 = sub_487C10(1, a8, a7);
  v11 = v10;
  v23 = v10;
  if ( v10 )
  {
    sub_484D00((int)v10);
    if ( _setjmp3(a1, (int)&savedregs, a2, (int)v11, v11, 0, v20, v21) )
    {
      v12 = v23;
      sub_487DA0((int)v23, v23[43]);
      v23[43] = 0;
      sub_487C90((unsigned int)v12);
      LOBYTE(v10) = 0;
      return (char)v10;
    }
    v13 = v23;
    sub_487E90(v23, a7, (int)a8, a9);
    sub_484330(v23, a4, a5, a6);
    v14 = a125_0;
    do
    {
      if ( v14[a3 - (_DWORD)a125_0] != *v14 )
        v13[27] |= 0x20000u;
      v15 = *v14++;
    }
    while ( v15 );
    if ( (v13[27] & 0x20000) != 0 )
    {
      if ( !a3 )
        goto LABEL_16;
      v16 = *(_BYTE *)a3;
      if ( *(_BYTE *)a3 != a125_0[0]
        || v16 == 49 && *(_BYTE *)(a3 + 2) != a125_0[2]
        || v16 == 48 && *(char *)(a3 + 2) < 57 )
      {
        sprintf_0(Buffer, "Application was compiled with png.h from libpng-%.20s", (const char *)a3);
        sub_4840E0((int)v13, Buffer);
LABEL_16:
        sprintf_0(Buffer, "Application  is  running with png.c from libpng-%.20s", a125_0);
        sub_4840E0((int)v13, Buffer);
        v13[27] = 0;
        sub_484040(v13, aIncompatibleLi);
      }
    }
    v13[44] = 0x2000;
    v13[43] = sub_487D00(v13, 0x2000u);
    sub_487B80(v13, 0, 0, 0);
    sub_485F10((int)v13, 0, 1, 0, 0);
    if ( _setjmp3(v15, (int)&savedregs, a3, (int)v13, v13, 0, v18, v19) )
    {
      _NMSG_WRITE_0(0xAu);
      raise(22);
      sub_46E4BD(3);
      LOBYTE(v10) = _abstract_sw(v9);
    }
    else
    {
      LOBYTE(v10) = (_BYTE)v23;
    }
  }
  return (char)v10;
}
// 4854DA: conditional instruction was optimized away because of 'edi.4!=0'
// 485424: variable 'v20' is possibly undefined
// 485424: variable 'v21' is possibly undefined
// 485562: variable 'v18' is possibly undefined
// 485562: variable 'v19' is possibly undefined

//----- (004855A0) --------------------------------------------------------
void __cdecl sub_4855A0(int *a1, char *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // esi
  char *v6; // edi
  char Buffer[80]; // [esp+10h] [ebp-50h] BYREF

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( a3 < 0x260 || a4 < 0x120 )
  {
    a1[17] = 0;
    if ( v6 )
    {
      sprintf_0(Buffer, "Application was compiled with png.h from libpng-%.20s", v6);
      sub_4840E0((int)a1, Buffer);
    }
    sprintf_0(Buffer, "Application  is  running with png.c from libpng-%.20s", a125_0);
    sub_4840E0((int)a1, Buffer);
  }
  if ( v5 < 0x260 )
  {
    a1[16] = 0;
    a1[27] = 0;
    sub_484040(a1, aThePngStructAl_0);
  }
  if ( v4 < 0x120 )
  {
    a1[16] = 0;
    a1[27] = 0;
    sub_484040(a1, aTheInfoStructA_0);
  }
  sub_485680(&a1, v6, v5);
}

//----- (00485680) --------------------------------------------------------
void __cdecl sub_485680(_DWORD **a1, _BYTE *a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  char *v4; // eax
  char v6[64]; // [esp+10h] [ebp-40h] BYREF

  v3 = *a1;
  if ( *a2 == a125_0[0] )
  {
    v4 = a125_0;
    while ( *v4++ )
    {
      if ( v4[a2 - a125_0] != *v4 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v3[17] = 0;
    sub_4840E0((int)v3, aApplicationUse_0);
  }
  qmemcpy(v6, v3, sizeof(v6));
  if ( a3 < 0x260 )
  {
    sub_487C90((unsigned int)v3);
    v3 = sub_487BF0(1);
    *a1 = v3;
  }
  memset(v3, 0, 0x260u);
  sub_484D00((int)v3);
  qmemcpy(v3, v6, 0x40u);
  sub_487B80(v3, 0, 0, 0);
  v3[44] = 0x2000;
  v3[43] = sub_487D00(v3, 0x2000u);
  sub_485F10((int)v3, 0, 1, 0, 0);
}

//----- (00485790) --------------------------------------------------------
int __cdecl sub_485790(int a1, const void **a2)
{
  int result; // eax
  unsigned int v4; // esi
  const void **i; // edi
  int v6; // [esp+8h] [ebp+4h]

  result = sub_47E0A0(a1);
  if ( result > 0 )
  {
    v6 = result;
    do
    {
      v4 = 0;
      for ( i = a2; v4 < *(_DWORD *)(a1 + 204); ++i )
      {
        sub_4857F0(a1, *i);
        ++v4;
      }
      result = --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (004857F0) --------------------------------------------------------
char __cdecl sub_4857F0(int a1, const void *a2)
{
  char v2; // al
  char v3; // dl
  unsigned __int8 v4; // al
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // ecx
  int (__cdecl *v8)(int, _DWORD, _DWORD); // eax

  if ( !*(_DWORD *)(a1 + 228) && !*(_BYTE *)(a1 + 292) )
  {
    if ( (*(_DWORD *)(a1 + 104) & 0x400) == 0 )
      sub_484040((int *)a1, aPngWriteInfoWa);
    sub_48D190(a1);
  }
  if ( *(_BYTE *)(a1 + 291) && (*(_BYTE *)(a1 + 112) & 2) != 0 )
  {
    switch ( *(_BYTE *)(a1 + 292) )
    {
      case 0:
        if ( (*(_BYTE *)(a1 + 228) & 7) != 0 )
          goto LABEL_29;
        break;
      case 1:
        if ( (*(_BYTE *)(a1 + 228) & 7) != 0 || *(_DWORD *)(a1 + 200) < 5u )
          goto LABEL_29;
        break;
      case 2:
        if ( (*(_BYTE *)(a1 + 228) & 7) != 4 )
          goto LABEL_29;
        break;
      case 3:
        if ( (*(_BYTE *)(a1 + 228) & 3) != 0 || *(_DWORD *)(a1 + 200) < 3u )
          goto LABEL_29;
        break;
      case 4:
        if ( (*(_BYTE *)(a1 + 228) & 3) != 2 )
          goto LABEL_29;
        break;
      case 5:
        if ( (*(_BYTE *)(a1 + 228) & 1) != 0 || *(_DWORD *)(a1 + 200) < 2u )
          goto LABEL_29;
        break;
      case 6:
        if ( (*(_BYTE *)(a1 + 228) & 1) != 0 )
          break;
        goto LABEL_29;
      default:
        break;
    }
  }
  v2 = *(_BYTE *)(a1 + 296);
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a1 + 294);
  v3 = *(_BYTE *)(a1 + 299);
  *(_BYTE *)(a1 + 265) = v2;
  v4 = v3 * v2;
  v5 = *(_DWORD *)(a1 + 212);
  *(_BYTE *)(a1 + 267) = v4;
  v6 = v5 * v4 + 7;
  *(_DWORD *)(a1 + 256) = v5;
  v7 = *(_DWORD *)(a1 + 236);
  *(_BYTE *)(a1 + 266) = v3;
  v6 >>= 3;
  *(_DWORD *)(a1 + 260) = v6;
  sub_487E20(a1, (void *)(v7 + 1), a2, v6);
  if ( *(_BYTE *)(a1 + 291)
    && *(_BYTE *)(a1 + 292) < 6u
    && (*(_BYTE *)(a1 + 112) & 2) != 0
    && (sub_48D4F0(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), *(unsigned __int8 *)(a1 + 292)),
        !*(_DWORD *)(a1 + 256)) )
  {
LABEL_29:
    LOBYTE(v8) = sub_48D330(a1);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 112) )
      sub_48E420(a1);
    if ( (*(_BYTE *)(a1 + 560) & 4) != 0 && *(_BYTE *)(a1 + 568) == 64 )
      sub_48EB40((int *)(a1 + 256), *(_DWORD *)(a1 + 236) + 1);
    sub_48D780(a1, a1 + 256);
    v8 = *(int (__cdecl **)(int, _DWORD, _DWORD))(a1 + 412);
    if ( v8 )
      LOBYTE(v8) = v8(a1, *(_DWORD *)(a1 + 228), *(unsigned __int8 *)(a1 + 292));
  }
  return (char)v8;
}

//----- (00485A70) --------------------------------------------------------
int (__cdecl *__cdecl sub_485A70(int a1))(int)
{
  int (__cdecl *result)(int); // eax
  int v2; // ecx
  int v3; // eax
  int v4; // ecx
  int v5; // ecx

  result = *(int (__cdecl **)(int))(a1 + 228);
  if ( (unsigned int)result < *(_DWORD *)(a1 + 208) )
  {
    while ( 1 )
    {
      if ( sub_467670(a1 + 116, 2) )
      {
        if ( *(_DWORD *)(a1 + 140) )
          sub_484040((int *)a1, *(const char **)(a1 + 140));
        sub_484040((int *)a1, aZlibError);
      }
      if ( *(_DWORD *)(a1 + 132) )
        break;
      sub_48BAC0((int *)a1, *(unsigned __int8 **)(a1 + 172), *(_DWORD *)(a1 + 176));
      v2 = *(_DWORD *)(a1 + 176);
      *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
      *(_DWORD *)(a1 + 132) = v2;
    }
    v3 = *(_DWORD *)(a1 + 176);
    v4 = *(_DWORD *)(a1 + 132);
    if ( v3 != v4 )
    {
      sub_48BAC0((int *)a1, *(unsigned __int8 **)(a1 + 172), v3 - v4);
      v5 = *(_DWORD *)(a1 + 176);
      *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
      *(_DWORD *)(a1 + 132) = v5;
    }
    *(_DWORD *)(a1 + 340) = 0;
    result = sub_487B40(a1);
  }
  return result;
}

//----- (00485B50) --------------------------------------------------------
int __cdecl sub_485B50(int a1, int a2, int a3)
{
  return sub_485B55(a1, a2, a3);
}
// 485B55: using guessed type _DWORD __cdecl sub_485B55(_DWORD, _DWORD, _DWORD);

//----- (00485B55) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_485B55(int a1@<eax>, _DWORD *a2, unsigned int *a3)
{
  _DWORD *v3; // esi
  void (__cdecl *v4)(char *, unsigned int); // ebx
  int v5; // ebp
  unsigned int v6; // edi

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( a1 )
  {
    v3 = *(_DWORD **)a1;
    v4 = *(void (__cdecl **)(char *, unsigned int))(*(_DWORD *)a1 + 588);
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 580);
  }
  if ( a3 )
  {
    v6 = *a3;
    if ( *a3 )
    {
      sub_484760((int)v3, v6, 0x7FFF, -1);
      if ( v3[136] )
      {
        sub_487DA0((int)v3, v3[137]);
        v3[137] = 0;
        v3[136] = 0;
      }
      sub_487CB0(v6, v4, v5);
      *a3 = 0;
    }
  }
  if ( v3 )
  {
    sub_485BF0(v3);
    sub_487CB0((unsigned int)v3, v4, v5);
    *a2 = 0;
  }
}
// 485BEF: positive sp value 4 has been found
// 485B55: could not find valid save-restore pair for ebx

//----- (00485BF0) --------------------------------------------------------
int __cdecl sub_485BF0(_DWORD *a1)
{
  int v2; // eax
  int v3; // edx
  int v4; // ebp
  int v5; // esi
  int result; // eax
  char v7[64]; // [esp+10h] [ebp-40h] BYREF
  int v8; // [esp+54h] [ebp+4h]

  sub_4679D0((int)(a1 + 29));
  sub_487DA0((int)a1, a1[43]);
  sub_487DA0((int)a1, a1[59]);
  sub_487DA0((int)a1, a1[58]);
  sub_487DA0((int)a1, a1[60]);
  sub_487DA0((int)a1, a1[61]);
  sub_487DA0((int)a1, a1[62]);
  sub_487DA0((int)a1, a1[63]);
  sub_487DA0((int)a1, a1[132]);
  sub_487DA0((int)a1, a1[127]);
  sub_487DA0((int)a1, a1[128]);
  sub_487DA0((int)a1, a1[129]);
  sub_487DA0((int)a1, a1[130]);
  sub_487DA0((int)a1, a1[131]);
  v2 = a1[147];
  v3 = a1[16];
  v4 = a1[18];
  qmemcpy(v7, a1, sizeof(v7));
  v5 = a1[17];
  v8 = v2;
  result = 0;
  memset(a1, 0, 0x260u);
  a1[16] = v3;
  a1[147] = v8;
  a1[17] = v5;
  a1[18] = v4;
  qmemcpy(a1, v7, 0x40u);
  return result;
}

//----- (00485F10) --------------------------------------------------------
void __cdecl sub_485F10(int a1, int a2, int a3, double *a4, double *a5)
{
  int v5; // eax
  signed int v6; // ebx
  double *v7; // ebp
  signed int i; // eax
  signed int j; // eax
  signed int k; // edi
  double v11; // st7
  int l; // eax
  int v13; // edi
  double *v14; // ebx

  v5 = a2;
  if ( a2 < 3 )
  {
    if ( !a2 )
      v5 = 1;
    v6 = a3;
    v7 = a4;
    if ( a3 < 0 || !a4 || v5 == 1 )
      v6 = 0;
    *(_BYTE *)(a1 + 505) = v6;
    *(_BYTE *)(a1 + 504) = v5;
    if ( v6 > 0 )
    {
      if ( !*(_DWORD *)(a1 + 508) )
      {
        *(_DWORD *)(a1 + 508) = sub_487D00((int *)a1, v6);
        for ( i = 0; i < v6; *(_BYTE *)(*(_DWORD *)(a1 + 508) + i - 1) = -1 )
          ++i;
      }
      if ( !*(_DWORD *)(a1 + 512) )
      {
        *(_DWORD *)(a1 + 512) = sub_487D00((int *)a1, 2 * v6);
        *(_DWORD *)(a1 + 516) = sub_487D00((int *)a1, 2 * v6);
        for ( j = 0; j < v6; *(_WORD *)(*(_DWORD *)(a1 + 516) + 2 * j - 2) = 256 )
        {
          ++j;
          *(_WORD *)(*(_DWORD *)(a1 + 512) + 2 * j - 2) = 256;
        }
      }
      for ( k = 0; k < v6; ++k )
      {
        if ( *v7 >= dbl_4A91B8 )
        {
          v11 = dbl_4B04D8;
          *(_WORD *)(*(_DWORD *)(a1 + 516) + 2 * k) = (__int64)(*v7 * dbl_4B04D8 + dbl_4AD770);
          *(_WORD *)(*(_DWORD *)(a1 + 512) + 2 * k) = (__int64)(v11 / *v7 + dbl_4AD770);
        }
        else
        {
          *(_WORD *)(*(_DWORD *)(a1 + 512) + 2 * k) = 256;
          *(_WORD *)(*(_DWORD *)(a1 + 516) + 2 * k) = 256;
        }
        ++v7;
      }
    }
    if ( !*(_DWORD *)(a1 + 520) )
    {
      *(_DWORD *)(a1 + 520) = sub_487D00((int *)a1, 0xAu);
      *(_DWORD *)(a1 + 524) = sub_487D00((int *)a1, 0xAu);
      for ( l = 0; l < 10; *(_WORD *)(*(_DWORD *)(a1 + 524) + l - 2) = 8 )
      {
        l += 2;
        *(_WORD *)(*(_DWORD *)(a1 + 520) + l - 2) = 8;
      }
    }
    v13 = 0;
    v14 = a5;
    do
    {
      if ( a5 && *v14 >= dbl_4A91B8 )
      {
        if ( *v14 >= dbl_4A91C8 )
        {
          *(_WORD *)(*(_DWORD *)(a1 + 524) + v13) = (__int64)(dbl_4B04D0 / *v14 + dbl_4AD770);
          *(_WORD *)(*(_DWORD *)(a1 + 520) + v13) = (__int64)(*v14 * dbl_4B04D0 + dbl_4AD770);
        }
      }
      else
      {
        *(_WORD *)(*(_DWORD *)(a1 + 520) + v13) = 8;
        *(_WORD *)(*(_DWORD *)(a1 + 524) + v13) = 8;
      }
      v13 += 2;
      ++v14;
    }
    while ( v13 < 10 );
  }
  else
  {
    sub_4840E0(a1, aUnknownFilterH);
  }
}
// 485F86: conditional instruction was optimized away because of 'ebx.4>=1'
// 485FC6: conditional instruction was optimized away because of 'ebx.4>=1'
// 485FEB: conditional instruction was optimized away because of 'ebx.4>=1'
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B04D0: using guessed type double dbl_4B04D0;
// 4B04D8: using guessed type double dbl_4B04D8;

//----- (00486330) --------------------------------------------------------
int __cdecl sub_486330(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_DWORD *)(a2 + 90) = *(_DWORD *)a3;
      *(_DWORD *)(a2 + 94) = *(_DWORD *)(a3 + 4);
      *(_WORD *)(a2 + 98) = *(_WORD *)(a3 + 8);
      *(_DWORD *)(a2 + 8) |= 0x20u;
    }
  }
  return result;
}

//----- (00486370) --------------------------------------------------------
void __cdecl sub_486370(int a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10; // st7
  __int64 v11; // rax
  double v12; // st7
  __int64 v13; // rax
  double v14; // st7
  __int64 v15; // rax
  double v16; // st7
  __int64 v17; // rax
  double v18; // st7
  __int64 v19; // rax
  double v20; // st7
  __int64 v21; // rax
  double v22; // st7

  if ( a1 && a2 )
  {
    if ( a3 < dbl_4A91B8
      || a4 < dbl_4A91B8
      || a5 < dbl_4A91B8
      || a6 < dbl_4A91B8
      || a7 < dbl_4A91B8
      || a8 < dbl_4A91B8
      || a9 < dbl_4A91B8
      || a10 < dbl_4A91B8 )
    {
      sub_4840E0(a1, aIgnoringAttemp_0);
    }
    else if ( a3 > dbl_4B04E0
           || a4 > dbl_4B04E0
           || a5 > dbl_4B04E0
           || a6 > dbl_4B04E0
           || a7 > dbl_4B04E0
           || a8 > dbl_4B04E0
           || a9 > dbl_4B04E0
           || a10 > dbl_4B04E0 )
    {
      sub_4840E0(a1, aIgnoringAttemp);
    }
    else
    {
      *(float *)(a2 + 128) = a3;
      *(float *)(a2 + 132) = a4;
      *(float *)(a2 + 136) = a5;
      *(float *)(a2 + 140) = a6;
      *(float *)(a2 + 144) = a7;
      *(float *)(a2 + 148) = a8;
      *(float *)(a2 + 152) = a9;
      *(float *)(a2 + 156) = a10;
      v10 = a4 * dbl_4B02E8;
      *(_DWORD *)(a2 + 256) = (__int64)(a3 * dbl_4B02E8 + dbl_4AD770);
      v11 = (__int64)(v10 + dbl_4AD770);
      v12 = a5 * dbl_4B02E8;
      *(_DWORD *)(a2 + 260) = v11;
      v13 = (__int64)(v12 + dbl_4AD770);
      v14 = a6 * dbl_4B02E8;
      *(_DWORD *)(a2 + 264) = v13;
      v15 = (__int64)(v14 + dbl_4AD770);
      v16 = a7 * dbl_4B02E8;
      *(_DWORD *)(a2 + 268) = v15;
      v17 = (__int64)(v16 + dbl_4AD770);
      v18 = a8 * dbl_4B02E8;
      *(_DWORD *)(a2 + 272) = v17;
      v19 = (__int64)(v18 + dbl_4AD770);
      v20 = a9 * dbl_4B02E8;
      *(_DWORD *)(a2 + 276) = v19;
      v21 = (__int64)(v20 + dbl_4AD770);
      v22 = a10 * dbl_4B02E8;
      *(_DWORD *)(a2 + 280) = v21;
      *(_DWORD *)(a2 + 284) = (__int64)(v22 + dbl_4AD770);
      LODWORD(v21) = *(_DWORD *)(a2 + 8);
      LOBYTE(v21) = v21 | 4;
      *(_DWORD *)(a2 + 8) = v21;
    }
  }
}
// 4A91B8: using guessed type double dbl_4A91B8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B02E8: using guessed type double dbl_4B02E8;
// 4B04E0: using guessed type double dbl_4B04E0;

//----- (00486630) --------------------------------------------------------
char __cdecl sub_486630(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // eax
  double v11; // st7
  double v12; // st7
  double v14; // [esp+10h] [ebp-38h]
  double v15; // [esp+18h] [ebp-30h]
  double v16; // [esp+20h] [ebp-28h]
  double v17; // [esp+28h] [ebp-20h]
  double v18; // [esp+30h] [ebp-18h]
  double v19; // [esp+38h] [ebp-10h]
  double v20; // [esp+40h] [ebp-8h]

  LOBYTE(v10) = a1;
  if ( a1 && a2 )
  {
    if ( a3 < 0 || a4 < 0 || a5 < 0 || a6 < 0 || a7 < 0 || a8 < 0 || a9 < 0 || a10 < 0 )
    {
      LOBYTE(v10) = sub_4840E0(a1, aIgnoringAttemp_0);
    }
    else
    {
      v14 = (double)a3;
      if ( v14 > dbl_4B04F0
        || (v15 = (double)a4, v15 > dbl_4B04F0)
        || (v16 = (double)a5, v16 > dbl_4B04F0)
        || (v17 = (double)a6, v17 > dbl_4B04F0)
        || (v18 = (double)a7, v18 > dbl_4B04F0)
        || (v19 = (double)a8, v19 > dbl_4B04F0)
        || (v20 = (double)a9, v20 > dbl_4B04F0)
        || (v11 = (double)a10, v11 > dbl_4B04F0) )
      {
        LOBYTE(v10) = sub_4840E0(a1, aIgnoringAttemp);
      }
      else
      {
        *(float *)(a2 + 128) = v14 * dbl_4B04E8;
        *(float *)(a2 + 132) = v15 * dbl_4B04E8;
        *(float *)(a2 + 136) = v16 * dbl_4B04E8;
        *(float *)(a2 + 140) = v17 * dbl_4B04E8;
        *(float *)(a2 + 144) = v18 * dbl_4B04E8;
        *(_DWORD *)(a2 + 276) = a8;
        *(float *)(a2 + 148) = v19 * dbl_4B04E8;
        *(float *)(a2 + 152) = v20 * dbl_4B04E8;
        *(_DWORD *)(a2 + 256) = a3;
        v12 = v11 * dbl_4B04E8;
        *(_DWORD *)(a2 + 260) = a4;
        *(float *)(a2 + 156) = v12;
        *(_DWORD *)(a2 + 264) = a5;
        v10 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 280) = a9;
        *(_DWORD *)(a2 + 268) = a6;
        LOBYTE(v10) = v10 | 4;
        *(_DWORD *)(a2 + 272) = a7;
        *(_DWORD *)(a2 + 284) = a10;
        *(_DWORD *)(a2 + 8) = v10;
      }
    }
  }
  return v10;
}
// 4B04E8: using guessed type double dbl_4B04E8;
// 4B04F0: using guessed type double dbl_4B04F0;

//----- (00486880) --------------------------------------------------------
void __cdecl sub_486880(int a1, int a2, double a3)
{
  double v3; // st7
  bool v4; // c3
  int v5; // eax

  if ( a1 && a2 )
  {
    if ( a3 <= dbl_4B04E0 )
    {
      v3 = a3;
    }
    else
    {
      sub_4840E0(a1, aLimitingGammaT);
      v3 = dbl_4B04E0;
    }
    *(float *)(a2 + 40) = v3;
    v4 = v3 == dbl_4A91B8;
    *(_DWORD *)(a2 + 252) = (__int64)(v3 * dbl_4B02E8 + dbl_4AD770);
    v5 = *(_DWORD *)(a2 + 8);
    LOBYTE(v5) = v5 | 1;
    *(_DWORD *)(a2 + 8) = v5;
    if ( v4 )
      sub_4840E0(a1, aSettingGamma0);
  }
}
// 4A91B8: using guessed type double dbl_4A91B8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B02E8: using guessed type double dbl_4B02E8;
// 4B04E0: using guessed type double dbl_4B04E0;

//----- (00486900) --------------------------------------------------------
void __cdecl sub_486900(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( a3 < 0 )
    {
      sub_4840E0(a1, aSettingNegativ);
      v3 = 0;
    }
    v4 = *(_DWORD *)(a2 + 8) | 1;
    *(_DWORD *)(a2 + 252) = v3;
    *(float *)(a2 + 40) = (double)v3 * dbl_4B04E8;
    *(_DWORD *)(a2 + 8) = v4;
    if ( !v3 )
      sub_4840E0(a1, aSettingGamma0);
  }
}
// 4B04E8: using guessed type double dbl_4B04E8;

//----- (00486980) --------------------------------------------------------
void __cdecl sub_486980(int *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax

  if ( a1 && a2 )
  {
    if ( *(_WORD *)(a2 + 20) )
    {
      sub_484760((int)a1, a2, 8, 0);
      v3 = sub_487DF0(a1, 0x200u);
      a1[125] = v3;
      if ( v3 )
      {
        v4 = 0;
        if ( *(_WORD *)(a2 + 20) )
        {
          do
          {
            *(_WORD *)(a1[125] + 2 * v4) = *(_WORD *)(a3 + 2 * v4);
            ++v4;
          }
          while ( v4 < *(unsigned __int16 *)(a2 + 20) );
        }
        v5 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 124) = a1[125];
        v6 = *(_DWORD *)(a2 + 184);
        LOBYTE(v6) = v6 | 8;
        *(_DWORD *)(a2 + 8) = v5 | 0x40;
        *(_DWORD *)(a2 + 184) = v6;
      }
      else
      {
        sub_4840E0((int)a1, aInsufficientMe);
      }
    }
    else
    {
      sub_4840E0((int)a1, aPaletteSize0Hi);
    }
  }
}

//----- (00486A30) --------------------------------------------------------
void __cdecl sub_486A30(int *a1, int a2, unsigned int a3, unsigned int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // eax
  unsigned __int8 v10; // cl

  if ( !a1 || !a2 )
    return;
  if ( !a3 || !a4 )
    sub_484040(a1, aImageWidthOrHe);
  if ( a3 > 0x7FFFFFFF || a4 > 0x7FFFFFFF )
    sub_484040(a1, aInvalidImageSi);
  if ( a5 != 1 && a5 != 2 && a5 != 4 && a5 != 8 && a5 != 16 )
    sub_484040(a1, aInvalidBitDept);
  if ( a6 < 0 || a6 == 1 || a6 == 5 || a6 > 6 )
    sub_484040(a1, aInvalidColorTy);
  if ( a6 != 3 )
  {
    if ( a6 != 2 && a6 != 4 && a6 != 6 || a5 >= 8 )
      goto LABEL_28;
LABEL_27:
    sub_484040(a1, aInvalidColorTy_0);
  }
  if ( a5 > 8 )
    goto LABEL_27;
LABEL_28:
  if ( a7 >= 2 )
    sub_484040(a1, aUnknownInterla);
  if ( a8 )
    sub_484040(a1, aUnknownCompres_1);
  v9 = (int)a1;
  if ( (a1[26] & 0x1000) != 0 && a1[140] )
  {
    sub_4840E0((int)a1, aMngFeaturesAre);
    v9 = (int)a1;
  }
  if ( a9 )
  {
    if ( (*(_BYTE *)(v9 + 560) & 4) == 0 || a9 != 64 || (*(_DWORD *)(v9 + 104) & 0x1000) != 0 || a6 != 2 && a6 != 6 )
      sub_484040((int *)v9, aUnknownFilterM);
    if ( (*(_DWORD *)(v9 + 104) & 0x1000) != 0 )
      sub_4840E0(v9, aInvalidFilterM);
  }
  *(_DWORD *)(a2 + 4) = a4;
  *(_BYTE *)(a2 + 26) = 0;
  *(_DWORD *)a2 = a3;
  *(_BYTE *)(a2 + 24) = a5;
  *(_BYTE *)(a2 + 25) = a6;
  *(_BYTE *)(a2 + 27) = a9;
  *(_BYTE *)(a2 + 28) = a7;
  if ( (_BYTE)a6 == 3 || (a6 & 2) == 0 )
    *(_BYTE *)(a2 + 29) = 1;
  else
    *(_BYTE *)(a2 + 29) = 3;
  if ( (a6 & 4) != 0 )
    ++*(_BYTE *)(a2 + 29);
  v10 = a5 * *(_BYTE *)(a2 + 29);
  *(_BYTE *)(a2 + 30) = v10;
  if ( a3 <= 0x7FFFFFFFu / ((v10 + 7) >> 3) - 64 )
  {
    *(_DWORD *)(a2 + 12) = (a3 * v10 + 7) >> 3;
  }
  else
  {
    sub_4840E0((int)a1, aWidthTooLargeT);
    *(_DWORD *)(a2 + 12) = 0;
  }
}

//----- (00486C50) --------------------------------------------------------
int __cdecl sub_486C50(int a1, int a2, int a3, int a4, char a5)
{
  int result; // eax
  int v6; // ecx

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_DWORD *)(a2 + 100) = a3;
      *(_BYTE *)(a2 + 108) = a5;
      v6 = *(_DWORD *)(a2 + 8);
      BYTE1(v6) |= 1u;
      *(_DWORD *)(a2 + 104) = a4;
      *(_DWORD *)(a2 + 8) = v6;
    }
  }
  return result;
}

//----- (00486C80) --------------------------------------------------------
void __cdecl sub_486C80(int *a1, int a2, const char *a3, int a4, int a5, char a6, int a7, const char *a8, int a9)
{
  size_t v9; // kr04_4
  char *v10; // eax
  size_t v11; // kr08_4
  char *v12; // eax
  int v13; // eax
  int v14; // ebx
  size_t v15; // kr0C_4
  int v16; // edx
  int v17; // ecx
  int v18; // eax

  if ( a1 && a2 )
  {
    v9 = strlen(a3) + 1;
    v10 = (char *)sub_487DF0(a1, v9);
    *(_DWORD *)(a2 + 160) = v10;
    if ( v10 )
    {
      qmemcpy(v10, a3, v9);
      *(_DWORD *)(a2 + 164) = a4;
      *(_BYTE *)(a2 + 180) = a6;
      *(_BYTE *)(a2 + 181) = a7;
      *(_DWORD *)(a2 + 168) = a5;
      v11 = strlen(a8) + 1;
      v12 = (char *)sub_487DF0(a1, v11);
      *(_DWORD *)(a2 + 172) = v12;
      if ( v12 )
      {
        qmemcpy(v12, a8, v11);
        v13 = sub_487DF0(a1, 4 * a7 + 4);
        *(_DWORD *)(a2 + 176) = v13;
        if ( v13 )
        {
          v14 = 0;
          *(_DWORD *)(v13 + 4 * a7) = 0;
          if ( a7 <= 0 )
          {
LABEL_12:
            v17 = *(_DWORD *)(a2 + 8);
            v18 = *(_DWORD *)(a2 + 184);
            BYTE1(v17) |= 4u;
            LOBYTE(v18) = v18 | 0x80;
            *(_DWORD *)(a2 + 8) = v17;
            *(_DWORD *)(a2 + 184) = v18;
          }
          else
          {
            while ( 1 )
            {
              v15 = strlen(*(const char **)(a9 + 4 * v14)) + 1;
              *(_DWORD *)(*(_DWORD *)(a2 + 176) + 4 * v14) = sub_487DF0(a1, v15);
              v16 = *(_DWORD *)(a2 + 176);
              if ( !*(_DWORD *)(v16 + 4 * v14) )
                break;
              qmemcpy(*(void **)(v16 + 4 * v14), *(const void **)(a9 + 4 * v14), v15);
              if ( ++v14 >= a7 )
                goto LABEL_12;
            }
            sub_4840E0((int)a1, aInsufficientMe_3);
          }
        }
        else
        {
          sub_4840E0((int)a1, aInsufficientMe_2);
        }
      }
      else
      {
        sub_4840E0((int)a1, aInsufficientMe_1);
      }
    }
    else
    {
      sub_4840E0((int)a1, aInsufficientMe_0);
    }
  }
}

//----- (00486E30) --------------------------------------------------------
int __cdecl sub_486E30(int a1, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  int v8; // ecx

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_BYTE *)(a2 + 220) = a3;
      *(_DWORD *)(a2 + 224) = a4;
      *(_DWORD *)(a2 + 228) = a5;
      *(_DWORD *)(a2 + 232) = a6;
      *(_DWORD *)(a2 + 236) = a7;
      v8 = *(_DWORD *)(a2 + 8);
      BYTE1(v8) |= 0x40u;
      *(_DWORD *)(a2 + 8) = v8;
    }
  }
  return result;
}

//----- (00486E80) --------------------------------------------------------
int __cdecl sub_486E80(int a1, int a2, int a3, int a4, char a5)
{
  int result; // eax
  int v6; // ecx

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_DWORD *)(a2 + 112) = a3;
      *(_BYTE *)(a2 + 120) = a5;
      v6 = *(_DWORD *)(a2 + 8);
      LOBYTE(v6) = v6 | 0x80;
      *(_DWORD *)(a2 + 116) = a4;
      *(_DWORD *)(a2 + 8) = v6;
    }
  }
  return result;
}

//----- (00486EB0) --------------------------------------------------------
void __cdecl sub_486EB0(int a1, int a2, const void *a3, int a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // eax

  if ( a1 && a2 )
  {
    sub_484760(a1, a2, 4096, 0);
    v4 = sub_484520((int *)a1, 256, 3);
    *(_DWORD *)(a1 + 276) = v4;
    if ( !v4 )
      sub_484040((int *)a1, aUnableToMalloc);
    qmemcpy(*(void **)(a1 + 276), a3, 3 * a4);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 276);
    *(_WORD *)(a1 + 280) = a4;
    v5 = *(_DWORD *)(a2 + 184);
    *(_WORD *)(a2 + 20) = a4;
    v6 = *(_DWORD *)(a2 + 8);
    BYTE1(v5) |= 0x10u;
    LOBYTE(v6) = v6 | 8;
    *(_DWORD *)(a2 + 184) = v5;
    *(_DWORD *)(a2 + 8) = v6;
  }
}

//----- (00486F60) --------------------------------------------------------
int __cdecl sub_486F60(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_DWORD *)(a2 + 68) = *(_DWORD *)a3;
      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a3 + 4);
      *(_DWORD *)(a2 + 8) |= 2u;
    }
  }
  return result;
}

//----- (00486F90) --------------------------------------------------------
int __cdecl sub_486F90(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // ecx

  result = a1;
  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      *(_BYTE *)(a2 + 44) = a3;
      v4 = *(_DWORD *)(a2 + 8);
      BYTE1(v4) |= 8u;
      *(_DWORD *)(a2 + 8) = v4;
    }
  }
  return result;
}

//----- (00486FC0) --------------------------------------------------------
void __cdecl sub_486FC0(int a1, int a2, char a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      sub_486F90(a1, a2, a3);
      sub_486880(a1, a2, 0.4545499980449677);
      sub_486900(a1, a2, 45455);
      sub_486630(a1, a2, 31270, 32900, 64000, 33000, 30000, 60000, 15000, 6000);
      sub_486370(
        a1,
        a2,
        0.3127000033855438,
        0.3289999961853027,
        0.6399999856948853,
        0.3300000131130219,
        0.300000011920929,
        0.6000000238418579,
        0.1500000059604645,
        0.05999999865889549);
    }
  }
}

//----- (00487090) --------------------------------------------------------
void __cdecl sub_487090(int *a1, int a2, const char *a3, char a4, const void *a5, size_t a6)
{
  char *v7; // ebp
  void *v8; // eax
  int v9; // ecx
  int v10; // eax
  void *v11; // [esp+10h] [ebp+8h]

  if ( a1 && a2 && a3 )
  {
    if ( a5 )
    {
      v7 = (char *)sub_487D00(a1, strlen(a3) + 1);
      strcpy(v7, a3);
      v8 = (void *)sub_487D00(a1, a6);
      qmemcpy(v8, a5, a6);
      v11 = v8;
      sub_484760((int)a1, a2, 16, 0);
      *(_DWORD *)(a2 + 204) = a6;
      v9 = *(_DWORD *)(a2 + 184);
      *(_BYTE *)(a2 + 208) = a4;
      v10 = *(_DWORD *)(a2 + 8);
      BYTE1(v10) |= 0x10u;
      *(_DWORD *)(a2 + 196) = v7;
      *(_DWORD *)(a2 + 200) = v11;
      *(_DWORD *)(a2 + 184) = v9 | 0x10;
      *(_DWORD *)(a2 + 8) = v10;
    }
  }
}

//----- (004871C0) --------------------------------------------------------
int __cdecl sub_4871C0(int *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ebp
  int v5; // esi
  int v6; // edi
  int v7; // eax
  const void *v8; // ebx
  int v9; // eax
  void *v10; // eax
  int v12; // eax
  int v13; // eax
  const char **v14; // esi
  const char *v15; // edi
  int *v16; // ebx
  unsigned int v17; // kr04_4
  int v18; // edx
  unsigned int v19; // edi
  unsigned int v20; // kr08_4
  unsigned int v21; // ebp
  char *v22; // eax
  void *v23; // edi
  int *v24; // edx
  bool v25; // cc
  int v26; // [esp+14h] [ebp-4h]
  const void **v27; // [esp+24h] [ebp+Ch]

  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v5 = a4;
      if ( a4 )
      {
        v6 = a2[13];
        v7 = a4 + a2[12];
        if ( v7 > v6 )
        {
          v8 = (const void *)a2[14];
          if ( v8 )
          {
            v9 = v7 + 8;
            a2[13] = v9;
            v10 = (void *)sub_487DF0(a1, 16 * v9);
            a2[14] = v10;
            if ( !v10 )
            {
              sub_487DA0((int)a1, (unsigned int)v8);
              return 1;
            }
            qmemcpy(v10, v8, 16 * v6);
            sub_487DA0((int)a1, (unsigned int)v8);
            v5 = a4;
          }
          else
          {
            a2[12] = 0;
            a2[13] = a4 + 8;
            v12 = sub_487DF0(a1, 16 * (a4 + 8));
            a2[14] = v12;
            if ( !v12 )
              return 1;
            v13 = a2[46];
            BYTE1(v13) |= 0x40u;
            a2[46] = v13;
          }
        }
        v26 = 0;
        if ( v5 > 0 )
        {
          v14 = (const char **)(a3 + 8);
          v27 = (const void **)(a3 + 8);
          do
          {
            v15 = *(v14 - 1);
            v16 = (int *)(v4[14] + 16 * v4[12]);
            if ( v15 )
            {
              v17 = strlen(v15) + 1;
              v18 = (int)*(v14 - 2);
              v19 = v17 - 1;
              if ( v18 > 0 )
              {
                sub_4840E0((int)a1, aItxtChunkNotSu);
              }
              else
              {
                if ( *v14 && **v14 )
                {
                  v20 = strlen(*v14) + 1;
                  v19 = v17 - 1;
                  *v16 = v18;
                  v21 = v20 - 1;
                }
                else
                {
                  v21 = 0;
                  *v16 = -1;
                }
                v22 = (char *)sub_487DF0(a1, v19 + v21 + 4);
                v16[1] = (int)v22;
                if ( !v22 )
                  return 1;
                qmemcpy(v22, *(v14 - 1), v19);
                *(_BYTE *)(v17 - 1 + v16[1]) = 0;
                v23 = (void *)(v17 + v16[1]);
                v16[2] = (int)v23;
                if ( v21 )
                  qmemcpy(v23, *v27, v21);
                *(_BYTE *)(v16[2] + v21) = 0;
                v16[3] = v21;
                v4 = a2;
                v24 = (int *)(a2[14] + 16 * a2[12]);
                v14 = (const char **)v27;
                *v24 = *v16;
                v24[1] = v16[1];
                v24[2] = v16[2];
                v24[3] = v16[3];
                ++a2[12];
              }
            }
            v14 += 4;
            v25 = ++v26 < a4;
            v27 = (const void **)v14;
          }
          while ( v25 );
        }
      }
    }
  }
  return 0;
}

//----- (004873F0) --------------------------------------------------------
void __cdecl sub_4873F0(int a1, _DWORD *a2, _DWORD *a3)
{
  if ( a1 && a2 && (*(_DWORD *)(a1 + 104) & 0x200) == 0 )
  {
    a2[15] = *a3;
    a2[16] = a3[1];
    a2[2] |= 0x200u;
  }
}

//----- (00487430) --------------------------------------------------------
void __cdecl sub_487430(int *a1, int a2, const void *a3, unsigned int a4, int a5)
{
  __int16 v5; // bp
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( a1 && a2 )
  {
    v5 = a4;
    if ( a3 )
    {
      sub_484760((int)a1, a2, 0x2000, 0);
      v6 = sub_487D00(a1, 0x100u);
      *(_DWORD *)(a2 + 76) = v6;
      a1[98] = v6;
      qmemcpy(*(void **)(a2 + 76), a3, a4);
      v7 = *(_DWORD *)(a2 + 184);
      BYTE1(v7) |= 0x20u;
      *(_DWORD *)(a2 + 184) = v7;
    }
    if ( a5 )
    {
      *(_DWORD *)(a2 + 80) = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 84) = *(_DWORD *)(a5 + 4);
      *(_WORD *)(a2 + 88) = *(_WORD *)(a5 + 8);
      if ( !a4 )
        v5 = 1;
    }
    v8 = *(_DWORD *)(a2 + 8);
    *(_WORD *)(a2 + 22) = v5;
    LOBYTE(v8) = v8 | 0x10;
    *(_DWORD *)(a2 + 8) = v8;
  }
}

//----- (004874E0) --------------------------------------------------------
char __cdecl sub_4874E0(int *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  char *v5; // ebp
  int v6; // eax
  _DWORD *v7; // ebp
  char *v8; // ebx
  char *v9; // edx
  void *v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // edx
  int v15; // [esp+Ch] [ebp-8h]
  char *v16; // [esp+10h] [ebp-4h]

  v4 = (_DWORD *)a2;
  v5 = (char *)sub_487DF0(a1, 16 * (*(_DWORD *)(a2 + 216) + a4));
  v16 = v5;
  if ( v5 )
  {
    qmemcpy(v5, *(const void **)(a2 + 212), 16 * *(_DWORD *)(a2 + 216));
    sub_487DA0((int)a1, *(_DWORD *)(a2 + 212));
    *(_DWORD *)(a2 + 212) = 0;
    v15 = 0;
    if ( a4 > 0 )
    {
      v7 = (_DWORD *)(a3 + 12);
      do
      {
        v8 = &v16[16 * *(_DWORD *)(a2 + 216) + 16 * v15];
        v9 = (char *)sub_487D00(a1, strlen((const char *)*(v7 - 3)) + 1);
        *(_DWORD *)v8 = v9;
        strcpy(v9, (const char *)*(v7 - 3));
        v10 = (void *)sub_487D00(a1, 16 * *v7);
        *((_DWORD *)v8 + 2) = v10;
        qmemcpy(v10, (const void *)*(v7 - 1), 16 * *v7);
        v11 = *v7;
        v7 += 4;
        *((_DWORD *)v8 + 3) = v11;
        v8[4] = *((_BYTE *)v7 - 24);
        ++v15;
      }
      while ( v15 < a4 );
      v4 = (_DWORD *)a2;
      v5 = v16;
    }
    v12 = v4[2];
    v13 = a4 + v4[54];
    v6 = v4[46];
    BYTE1(v12) |= 0x20u;
    LOBYTE(v6) = v6 | 0x20;
    v4[53] = v5;
    v4[54] = v13;
    v4[2] = v12;
    v4[46] = v6;
  }
  else
  {
    LOBYTE(v6) = sub_4840E0((int)a1, aNoMemoryForSpl);
  }
  return v6;
}

//----- (00487660) --------------------------------------------------------
void __cdecl sub_487660(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  char *v5; // ebp
  size_t *v6; // ebp
  char *v7; // ebx
  void *v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // [esp+Ch] [ebp-8h]
  char *v12; // [esp+10h] [ebp-4h]

  if ( a1 )
  {
    v4 = (_DWORD *)a2;
    if ( a2 )
    {
      if ( a4 )
      {
        v5 = (char *)sub_487DF0((int *)a1, 20 * (a4 + *(_DWORD *)(a2 + 192)));
        v12 = v5;
        if ( v5 )
        {
          qmemcpy(v5, *(const void **)(a2 + 188), 4 * ((unsigned int)(20 * *(_DWORD *)(a2 + 192)) >> 2));
          sub_487DA0(a1, *(_DWORD *)(a2 + 188));
          *(_DWORD *)(a2 + 188) = 0;
          v11 = 0;
          if ( a4 > 0 )
          {
            v6 = (size_t *)(a3 + 12);
            do
            {
              v7 = &v12[20 * v11 + 20 * v4[48]];
              strcpy(v7, (const char *)v6 - 12);
              v8 = (void *)sub_487D00((int *)a1, *v6);
              *((_DWORD *)v7 + 2) = v8;
              if ( v8 )
              {
                qmemcpy(v8, (const void *)*(v6 - 1), *v6);
                *((_DWORD *)v7 + 3) = *v6;
                v7[16] = *(_BYTE *)(a1 + 104);
              }
              else
              {
                sub_4840E0(a1, aOutOfMemoryWhi_0);
              }
              v4 = (_DWORD *)a2;
              v6 += 5;
              ++v11;
            }
            while ( v11 < a4 );
            v5 = v12;
          }
          v9 = a4 + v4[48];
          v10 = v4[46];
          BYTE1(v10) |= 2u;
          v4[47] = v5;
          v4[48] = v9;
          v4[46] = v10;
        }
        else
        {
          sub_4840E0(a1, aOutOfMemoryWhi_0);
        }
      }
    }
  }
}

//----- (00487AD0) --------------------------------------------------------
int __cdecl sub_487AD0(int *a1, int a2, int a3)
{
  int (__cdecl *v3)(int *, int, int); // eax

  v3 = (int (__cdecl *)(int *, int, int))a1[19];
  if ( !v3 )
    sub_484040(a1, aCallToNullWrit);
  return v3(a1, a2, a3);
}

//----- (00487B00) --------------------------------------------------------
size_t __cdecl sub_487B00(int a1, void *a2, size_t a3)
{
  size_t result; // eax

  result = sub_46F141(a2, 1u, a3, *(FILE **)(a1 + 84));
  if ( result != a3 )
    sub_484040((int *)a1, aWriteError);
  return result;
}

//----- (00487B40) --------------------------------------------------------
int (__cdecl *__cdecl sub_487B40(int a1))(int)
{
  int (__cdecl *result)(int); // eax

  result = *(int (__cdecl **)(int))(a1 + 332);
  if ( result )
    result = (int (__cdecl *)(int))result(a1);
  return result;
}

//----- (00487B60) --------------------------------------------------------
int __cdecl sub_487B60(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 84);
  if ( result )
    result = fflush(*(FILE **)(a1 + 84));
  return result;
}

//----- (00487B80) --------------------------------------------------------
int __cdecl sub_487B80(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  a1[21] = a2;
  if ( a3 )
    a1[19] = a3;
  else
    a1[19] = sub_487B00;
  if ( a4 )
    a1[83] = a4;
  else
    a1[83] = sub_487B60;
  result = a1[20];
  if ( result )
  {
    a1[20] = 0;
    sub_4840E0((int)a1, aAttemptedToSet);
    result = sub_4840E0((int)a1, aTheSameStructu);
  }
  return result;
}

//----- (00487BF0) --------------------------------------------------------
void *__cdecl sub_487BF0(int a1)
{
  return sub_487C10(a1, 0, 0);
}

//----- (00487C10) --------------------------------------------------------
void *__cdecl sub_487C10(int a1, int (__cdecl *a2)(char *, size_t), int a3)
{
  size_t v3; // esi
  void *result; // eax
  char v5[580]; // [esp+8h] [ebp-260h] BYREF
  int v6; // [esp+24Ch] [ebp-1Ch]

  if ( a1 == 2 )
  {
    v3 = 288;
  }
  else
  {
    if ( a1 != 1 )
      return 0;
    v3 = 608;
  }
  if ( a2 )
  {
    v6 = a3;
    result = (void *)a2(v5, v3);
  }
  else
  {
    result = (void *)sub_46D9FD(v3);
  }
  if ( result )
    memset(result, 0, v3);
  return result;
}

//----- (00487C90) --------------------------------------------------------
void __cdecl sub_487C90(unsigned int a1)
{
  sub_487CB0(a1, 0, 0);
}

//----- (00487CB0) --------------------------------------------------------
void __cdecl sub_487CB0(unsigned int a1, void (__cdecl *a2)(char *, unsigned int), int a3)
{
  char v3[580]; // [esp+0h] [ebp-260h] BYREF
  int v4; // [esp+244h] [ebp-1Ch]

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = a3;
      a2(v3, a1);
    }
    else
    {
      sub_46D360(a1);
    }
  }
}

//----- (00487D00) --------------------------------------------------------
int __cdecl sub_487D00(int *a1, size_t a2)
{
  int (__cdecl *v2)(int *, size_t); // eax
  int result; // eax

  if ( !a1 || !a2 )
    return 0;
  v2 = (int (__cdecl *)(int *, size_t))a1[146];
  if ( !v2 )
    return sub_487D60(a1, a2);
  result = v2(a1, a2);
  if ( !result && (a1[27] & 0x100000) == 0 )
    sub_484040(a1, aOutOfMemory);
  return result;
}

//----- (00487D60) --------------------------------------------------------
int __cdecl sub_487D60(int *a1, size_t a2)
{
  int v2; // esi

  v2 = sub_46D9FD(a2);
  if ( !v2 && (a1[27] & 0x100000) == 0 )
    sub_484040(a1, aOutOfMemory_0);
  return v2;
}

//----- (00487DA0) --------------------------------------------------------
void __cdecl sub_487DA0(int a1, unsigned int a2)
{
  void (__cdecl *v2)(int, unsigned int); // eax

  if ( a1 && a2 )
  {
    v2 = *(void (__cdecl **)(int, unsigned int))(a1 + 588);
    if ( v2 )
      v2(a1, a2);
    else
      sub_487DD0(a1, a2);
  }
}

//----- (00487DD0) --------------------------------------------------------
void __cdecl sub_487DD0(int a1, unsigned int a2)
{
  if ( a1 )
  {
    if ( a2 )
      sub_46D360(a2);
  }
}

//----- (00487DF0) --------------------------------------------------------
int __cdecl sub_487DF0(int *a1, size_t a2)
{
  int v2; // edi
  int result; // eax

  v2 = a1[27];
  a1[27] = v2 | 0x100000;
  result = sub_487D00(a1, a2);
  a1[27] = v2;
  return result;
}

//----- (00487E20) --------------------------------------------------------
void *__cdecl sub_487E20(int a1, void *a2, const void *a3, unsigned int a4)
{
  qmemcpy(a2, a3, a4);
  return a2;
}

//----- (00487E50) --------------------------------------------------------
char *__usercall sub_487E50@<eax>(int a1@<ebx>, int a2, char *a3, char a4, unsigned int a5)
{
  int v5; // eax

  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v5 = a1 << 16;
  LOWORD(v5) = a1;
  memset32(a3, v5, a5 >> 2);
  memset(&a3[4 * (a5 >> 2)], a4, a5 & 3);
  return a3;
}

//----- (00487E90) --------------------------------------------------------
_DWORD *__cdecl sub_487E90(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  a1[145] = a2;
  a1[146] = a3;
  a1[147] = a4;
  return result;
}

//----- (00487ED0) --------------------------------------------------------
int __cdecl sub_487ED0(unsigned __int8 *a1)
{
  return a1[3] + ((a1[2] + ((a1[1] + (*a1 << 8)) << 8)) << 8);
}

//----- (00487F00) --------------------------------------------------------
int __cdecl sub_487F00(unsigned __int8 *a1)
{
  return a1[3] + ((a1[2] + ((a1[1] + (*a1 << 8)) << 8)) << 8);
}

//----- (00487F30) --------------------------------------------------------
int __usercall sub_487F30@<eax>(int a1@<eax>, unsigned __int8 *a2)
{
  int v2; // ecx

  HIWORD(v2) = HIWORD(a2);
  LOWORD(a1) = *a2;
  LOWORD(v2) = a2[1];
  return v2 + (a1 << 8);
}

//----- (00487F50) --------------------------------------------------------
int __cdecl sub_487F50(int *a1, unsigned __int8 *a2, unsigned int a3)
{
  sub_484380(a1, (int)a2, a3);
  return sub_4845E0((int)a1, a2, a3);
}

//----- (00487F80) --------------------------------------------------------
int __cdecl sub_487F80(int a1, unsigned int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // ebx

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 176);
  if ( a2 > v3 )
  {
    do
    {
      sub_487F50((int *)a1, *(unsigned __int8 **)(a1 + 172), *(_DWORD *)(a1 + 176));
      v2 -= v3;
    }
    while ( v2 > v3 );
  }
  if ( v2 )
    sub_487F50((int *)a1, *(unsigned __int8 **)(a1 + 172), v2);
  if ( !sub_488030(a1) )
    return 0;
  if ( ((*(_BYTE *)(a1 + 284) & 0x20) == 0 || (*(_DWORD *)(a1 + 108) & 0x200) != 0)
    && ((*(_BYTE *)(a1 + 284) & 0x20) != 0 || (*(_DWORD *)(a1 + 108) & 0x400) == 0) )
  {
    sub_484130((int *)a1, aCrcError);
  }
  sub_4841F0(a1, aCrcError);
  return 1;
}

//----- (00488030) --------------------------------------------------------
BOOL __cdecl sub_488030(int a1)
{
  int v1; // esi
  int v2; // edi
  BOOL result; // eax

  v1 = a1;
  v2 = 1;
  if ( (*(_BYTE *)(a1 + 284) & 0x20) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 108) & 0x300) != 768 )
      goto LABEL_6;
  }
  else if ( (*(_DWORD *)(a1 + 108) & 0x800) == 0 )
  {
    goto LABEL_6;
  }
  v2 = 0;
LABEL_6:
  sub_484380((int *)a1, (int)&a1, 4);
  if ( v2 )
    result = sub_487ED0((unsigned __int8 *)&a1) != *(_DWORD *)(v1 + 272);
  else
    result = 0;
  return result;
}

//----- (004880A0) --------------------------------------------------------
char *__cdecl sub_4880A0(int a1, int a2, char *a3, int a4, unsigned int a5, unsigned int *a6)
{
  char *v6; // ebx
  unsigned int v8; // edi
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v12; // esi
  char *v13; // eax
  const void *v14; // edi
  int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  char *v18; // edi
  char *v19; // edi
  char *v20; // esi
  char v21; // cl
  char *result; // eax
  unsigned int v23; // [esp+4h] [ebp-38h]
  char Buffer[52]; // [esp+8h] [ebp-34h] BYREF
  unsigned int v25; // [esp+40h] [ebp+4h]
  int v26; // [esp+44h] [ebp+8h]

  v6 = 0;
  if ( !a2 )
  {
    v8 = a5;
    v9 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
    *(_DWORD *)(a1 + 116) = &a3[a5];
    *(_DWORD *)(a1 + 132) = v9;
    *(_DWORD *)(a1 + 120) = a4 - a5;
    v25 = 0;
    if ( a4 != a5 )
    {
      while ( 1 )
      {
        v10 = sub_466C30((unsigned __int8 **)(a1 + 116), 1);
        v26 = v10;
        if ( v10 )
        {
          if ( v10 != 1 )
            break;
        }
        v11 = *(_DWORD *)(a1 + 132);
        if ( !v11 || v10 == 1 )
        {
          if ( v6 )
          {
            v14 = v6;
            v23 = (unsigned int)v6;
            v6 = (char *)sub_487DF0((int *)a1, v25 - v11 + *(_DWORD *)(a1 + 176) + 1);
            if ( !v6 )
            {
              sub_487DA0(a1, (unsigned int)v14);
              sub_487DA0(a1, (unsigned int)a3);
              sub_484040((int *)a1, aNotEnoughMemor_0);
            }
            qmemcpy(v6, v14, v25);
            sub_487DA0(a1, v23);
            qmemcpy(&v6[v25], *(const void **)(a1 + 172), *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 132));
            v25 += *(_DWORD *)(a1 + 176) - *(_DWORD *)(a1 + 132);
            v6[v25] = 0;
          }
          else
          {
            v12 = *(_DWORD *)(a1 + 176) + v8 - v11;
            v25 = v12;
            v13 = (char *)sub_487DF0((int *)a1, v12 + 1);
            v6 = v13;
            if ( !v13 )
            {
              sub_487DA0(a1, (unsigned int)a3);
              sub_484040((int *)a1, aNotEnoughMemor);
            }
            qmemcpy(&v13[v8], *(const void **)(a1 + 172), v12 - v8);
            qmemcpy(v13, a3, a5);
            v13[v12] = 0;
          }
          if ( v26 == 1 )
            goto LABEL_39;
          v15 = *(_DWORD *)(a1 + 172);
          v8 = a5;
          *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 176);
          v10 = v26;
          *(_DWORD *)(a1 + 128) = v15;
        }
        if ( !*(_DWORD *)(a1 + 120) )
          goto LABEL_28;
      }
      if ( *(_DWORD *)(a1 + 140) )
        sub_4840E0(a1, *(_BYTE **)(a1 + 140));
      else
        sub_4840E0(a1, aErrorDecodingC);
      sub_466A60((_DWORD *)(a1 + 116));
      *(_DWORD *)(a1 + 120) = 0;
      if ( !v6 )
      {
        v25 = v8 + 32;
        v6 = (char *)sub_487DF0((int *)a1, v8 + 32);
        if ( !v6 )
        {
          sub_487DA0(a1, (unsigned int)a3);
          sub_484040((int *)a1, aNotEnoughMemor_1);
        }
        qmemcpy(v6, a3, v8);
        v8 = a5;
      }
      v6[v25 - 1] = 0;
      v16 = a3 - v6 + a4 - 1;
      v25 = v16;
      if ( v16 >= 0x1F )
      {
        v25 = 31;
        v16 = 31;
      }
      v17 = v16 + 1;
      v18 = &v6[v8];
      qmemcpy(v18, aErrorDecodingC, 4 * (v17 >> 2));
      v20 = &aErrorDecodingC[4 * (v17 >> 2)];
      v19 = &v18[4 * (v17 >> 2)];
      v21 = v17;
      v10 = v26;
      qmemcpy(v19, v20, v21 & 3);
      v8 = a5;
LABEL_28:
      switch ( v10 )
      {
        case 1:
          goto LABEL_39;
        case -5:
          sprintf_0(Buffer, "Buffer error in compressed datastream in %s chunk", a1 + 284);
LABEL_34:
          sub_4840E0(a1, Buffer);
          v25 = v8;
          if ( !v6 )
          {
            v6 = (char *)sub_487DF0((int *)a1, v8 + 1);
            if ( !v6 )
            {
              sub_487DA0(a1, (unsigned int)a3);
              sub_484040((int *)a1, aNotEnoughMemor_2);
            }
            qmemcpy(v6, a3, v8);
            v8 = a5;
          }
          v6[v8] = 0;
LABEL_39:
          sub_466A60((_DWORD *)(a1 + 116));
          *(_DWORD *)(a1 + 120) = 0;
          sub_487DA0(a1, (unsigned int)a3);
          result = v6;
          *a6 = v25;
          return result;
        case -3:
          sprintf_0(Buffer, "Data error in compressed datastream in %s chunk", a1 + 284);
          goto LABEL_34;
      }
    }
    sprintf_0(Buffer, "Incomplete compressed datastream in %s chunk", a1 + 284);
    goto LABEL_34;
  }
  sprintf_0(Buffer, "Unknown zTXt compression type %d", a2);
  sub_4840E0(a1, Buffer);
  result = a3;
  a3[a5] = 0;
  *a6 = a5;
  return result;
}

//----- (00488470) --------------------------------------------------------
void __cdecl sub_488470(int a1, int a2, int a3)
{
  int v4; // eax
  unsigned __int8 v5; // dl
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // di
  int v8; // ecx
  unsigned __int8 v9; // al
  int v10; // [esp+10h] [ebp-14h]
  unsigned __int8 v11[4]; // [esp+14h] [ebp-10h] BYREF
  unsigned __int8 v12[8]; // [esp+18h] [ebp-Ch] BYREF
  unsigned __int8 v13; // [esp+20h] [ebp-4h]
  unsigned int v14; // [esp+28h] [ebp+4h]
  int v15; // [esp+30h] [ebp+Ch]

  if ( (*(_BYTE *)(a1 + 104) & 1) != 0 )
    sub_484040((int *)a1, aOutOfPlaceIhdr);
  if ( a3 != 13 )
    sub_484040((int *)a1, aInvalidIhdrChu);
  *(_DWORD *)(a1 + 104) |= 1u;
  sub_487F50((int *)a1, v11, 0xDu);
  sub_487F80(a1, 0);
  v15 = sub_487ED0(v11);
  v4 = sub_487ED0(v12);
  v5 = v12[4];
  v6 = v12[7];
  v7 = v12[6];
  v14 = v4;
  v8 = v12[5];
  v10 = v13;
  *(_BYTE *)(a1 + 291) = v13;
  *(_DWORD *)(a1 + 200) = v15;
  *(_DWORD *)(a1 + 204) = v4;
  *(_BYTE *)(a1 + 295) = v5;
  *(_BYTE *)(a1 + 294) = v8;
  *(_BYTE *)(a1 + 568) = v6;
  switch ( (char)v8 )
  {
    case 0:
    case 3:
      *(_BYTE *)(a1 + 298) = 1;
      break;
    case 2:
      *(_BYTE *)(a1 + 298) = 3;
      break;
    case 4:
      *(_BYTE *)(a1 + 298) = 2;
      break;
    case 6:
      *(_BYTE *)(a1 + 298) = 4;
      break;
    default:
      break;
  }
  v9 = v5 * *(_BYTE *)(a1 + 298);
  *(_BYTE *)(a1 + 297) = v9;
  *(_DWORD *)(a1 + 216) = (v15 * (unsigned int)v9 + 7) >> 3;
  sub_486A30((int *)a1, a2, v15, v14, v5, v8, v10, v7, v6);
}

//----- (004885E0) --------------------------------------------------------
char __cdecl sub_4885E0(int a1, int a2, signed int a3)
{
  int v3; // eax
  char result; // al
  char v5; // cl
  int v6; // ebx
  char *v7; // edi
  int v8; // ebp
  unsigned __int8 v9; // al
  unsigned __int8 v10; // cl
  unsigned __int8 v11[4]; // [esp+Ch] [ebp-304h] BYREF
  char v12[2]; // [esp+10h] [ebp-300h] BYREF
  char v13; // [esp+12h] [ebp-2FEh] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_0);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0(a1, aInvalidPlteAft);
    result = sub_487F80(a1, a3);
  }
  else
  {
    if ( (v3 & 2) != 0 )
      sub_484040((int *)a1, aDuplicatePlteC);
    *(_DWORD *)(a1 + 104) |= 2u;
    v5 = *(_BYTE *)(a1 + 294);
    if ( (v5 & 2) != 0 )
    {
      if ( (unsigned int)a3 > 0x300 || a3 % 3u )
      {
        if ( v5 == 3 )
          sub_484040((int *)a1, aInvalidPalette);
        sub_4840E0(a1, aInvalidPalette);
        result = sub_487F80(a1, a3);
      }
      else
      {
        v6 = a3 / 3;
        if ( a3 / 3 > 0 )
        {
          v7 = &v13;
          v8 = a3 / 3;
          do
          {
            sub_487F50((int *)a1, v11, 3u);
            v9 = v11[1];
            v10 = v11[2];
            *(v7 - 2) = v11[0];
            *(v7 - 1) = v9;
            *v7 = v10;
            v7 += 3;
            --v8;
          }
          while ( v8 );
        }
        sub_487F80(a1, 0);
        sub_486EB0(a1, a2, v12, v6);
        result = *(_BYTE *)(a1 + 294);
        if ( result == 3 && a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
        {
          if ( *(_WORD *)(a1 + 282) > (unsigned __int16)v6 )
          {
            result = sub_4840E0(a1, aTruncatingInco);
            *(_WORD *)(a1 + 282) = v6;
          }
          if ( *(_WORD *)(a2 + 22) > (unsigned __int16)v6 )
          {
            result = sub_4840E0(a1, aTruncatingInco_0);
            *(_WORD *)(a2 + 22) = v6;
          }
        }
      }
    }
    else
    {
      sub_4840E0(a1, aIgnoringPlteCh);
      result = sub_487F80(a1, a3);
    }
  }
  return result;
}

//----- (00488780) --------------------------------------------------------
int __cdecl sub_488780(int *a1, int a2, unsigned int a3)
{
  int v3; // eax

  v3 = a1[26];
  if ( (v3 & 1) == 0 || (v3 & 4) == 0 )
    sub_484040(a1, aNoImageInFile);
  a1[26] |= 0x18u;
  if ( a3 )
    sub_4840E0((int)a1, aIncorrectIendC);
  return sub_487F80((int)a1, a3);
}

//----- (004887D0) --------------------------------------------------------
void __cdecl sub_4887D0(int *a1, int a2, signed int a3)
{
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  int v8; // edi
  double v9; // st7

  v3 = a2;
  v4 = (int)a1;
  v5 = a1[26];
  if ( (v5 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_1);
  if ( (v5 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidGamaAft);
    sub_487F80(v4, a3);
    return;
  }
  if ( (v5 & 2) != 0 )
  {
    sub_4840E0((int)a1, aOutOfPlaceGama);
  }
  else if ( a2 )
  {
    v7 = *(_DWORD *)(a2 + 8);
    if ( (v7 & 1) != 0 && (v7 & 0x800) == 0 )
    {
      sub_4840E0((int)a1, aDuplicateGamaC);
      sub_487F80(v4, a3);
      return;
    }
  }
  v6 = a3;
  if ( a3 == 4 )
  {
    sub_487F50((int *)v4, (unsigned __int8 *)&a1, 4u);
    if ( !sub_487F80(v4, 0) )
    {
      v8 = sub_487ED0((unsigned __int8 *)&a1);
      a3 = v8;
      if ( v8 )
      {
        if ( (*(_DWORD *)(v3 + 8) & 0x800) != 0 && (v8 < 45000 || v8 > 46000) )
        {
          sub_4840E0(v4, aIgnoringIncorr);
          fprintf(&Stream, "gamma = (%d/100000)\n", v8);
        }
        else
        {
          v9 = (double)a3 * flt_4B04F8;
          *(float *)(v4 + 348) = v9;
          sub_486880(v4, v3, v9);
          sub_486900(v4, v3, v8);
        }
      }
      else
      {
        sub_4840E0(v4, aIgnoringGamaCh);
      }
    }
  }
  else
  {
    sub_4840E0(v4, aIncorrectGamaC);
    sub_487F80(v4, v6);
  }
}
// 4B04F8: using guessed type float flt_4B04F8;

//----- (00488920) --------------------------------------------------------
int __cdecl sub_488920(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // eax
  int result; // eax
  unsigned __int8 v6; // cl
  char v7; // dl
  unsigned __int8 v8; // [esp+10h] [ebp-4h] BYREF
  char v9; // [esp+11h] [ebp-3h]
  char v10; // [esp+12h] [ebp-2h]
  char v11; // [esp+13h] [ebp-1h]

  v11 = 0;
  v3 = *(_DWORD *)(a1 + 104);
  v10 = 0;
  v9 = 0;
  v8 = 0;
  if ( (v3 & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_2);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0(a1, aInvalidSbitAft);
    return sub_487F80(a1, a3);
  }
  if ( (v3 & 2) != 0 )
  {
    sub_4840E0(a1, aOutOfPlaceSbit);
  }
  else if ( a2 && (*(_BYTE *)(a2 + 8) & 2) != 0 )
  {
    sub_4840E0(a1, aDuplicateSbitC);
    return sub_487F80(a1, a3);
  }
  v4 = 3;
  if ( *(_BYTE *)(a1 + 294) != 3 )
    v4 = *(unsigned __int8 *)(a1 + 298);
  if ( a3 == v4 )
  {
    sub_487F50((int *)a1, &v8, v4);
    result = sub_487F80(a1, 0);
    if ( !result )
    {
      v6 = v8;
      if ( (*(_BYTE *)(a1 + 294) & 2) != 0 )
      {
        *(_BYTE *)(a1 + 381) = v9;
        v7 = v11;
        *(_BYTE *)(a1 + 380) = v6;
        *(_BYTE *)(a1 + 382) = v10;
        *(_BYTE *)(a1 + 384) = v7;
      }
      else
      {
        *(_BYTE *)(a1 + 383) = v8;
        *(_BYTE *)(a1 + 381) = v6;
        *(_BYTE *)(a1 + 380) = v6;
        *(_BYTE *)(a1 + 382) = v6;
        *(_BYTE *)(a1 + 384) = v9;
      }
      result = sub_486F60(a1, a2, a1 + 380);
    }
  }
  else
  {
    sub_4840E0(a1, aIncorrectSbitC);
    result = sub_487F80(a1, a3);
  }
  return result;
}

//----- (00488A90) --------------------------------------------------------
int __cdecl sub_488A90(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // eax
  int v14; // ebx
  int v15; // ecx
  unsigned __int8 v16[4]; // [esp+4Ch] [ebp-3Ch] BYREF
  int v17; // [esp+50h] [ebp-38h]
  int v18; // [esp+54h] [ebp-34h]
  int v19; // [esp+58h] [ebp-30h]
  int v20; // [esp+5Ch] [ebp-2Ch]
  int v21; // [esp+60h] [ebp-28h]
  int v22; // [esp+64h] [ebp-24h]
  float v23; // [esp+68h] [ebp-20h]
  float v24; // [esp+6Ch] [ebp-1Ch]
  float v25; // [esp+70h] [ebp-18h]
  float v26; // [esp+74h] [ebp-14h]
  float v27; // [esp+78h] [ebp-10h]
  float v28; // [esp+7Ch] [ebp-Ch]
  float v29; // [esp+80h] [ebp-8h]
  float v30; // [esp+84h] [ebp-4h]

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_3);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidChrmAft);
    return sub_487F80((int)a1, a3);
  }
  if ( (v3 & 2) != 0 )
  {
    sub_4840E0((int)a1, aMissingPlteBef_0);
  }
  else if ( a2 )
  {
    v5 = *(_DWORD *)(a2 + 8);
    if ( (v5 & 4) != 0 && (v5 & 0x800) == 0 )
    {
      sub_4840E0((int)a1, aDuplicateChrmC);
      return sub_487F80((int)a1, a3);
    }
  }
  if ( a3 == 32 )
  {
    sub_487F50(a1, v16, 4u);
    v6 = sub_487ED0(v16);
    sub_487F50(a1, v16, 4u);
    v7 = sub_487ED0(v16);
    if ( v6 > 0x13880 || v7 > 0x13880 || v7 + v6 > 0x186A0 )
    {
      sub_4840E0((int)a1, aInvalidChrmWhi);
      result = sub_487F80((int)a1, 0x18u);
    }
    else
    {
      v22 = v6;
      v21 = v7;
      sub_487F50(a1, v16, 4u);
      v8 = sub_487ED0(v16);
      sub_487F50(a1, v16, 4u);
      v9 = sub_487ED0(v16);
      if ( v8 > 0x13880 || v9 > 0x13880 || v9 + v8 > 0x186A0 )
      {
        sub_4840E0((int)a1, aInvalidChrmRed);
        result = sub_487F80((int)a1, 0x10u);
      }
      else
      {
        v20 = v8;
        v19 = v9;
        sub_487F50(a1, v16, 4u);
        v10 = sub_487ED0(v16);
        sub_487F50(a1, v16, 4u);
        v11 = sub_487ED0(v16);
        if ( v10 > 0x13880 || v11 > 0x13880 || v11 + v10 > 0x186A0 )
        {
          sub_4840E0((int)a1, aInvalidChrmGre);
          result = sub_487F80((int)a1, 8u);
        }
        else
        {
          v18 = v10;
          v17 = v11;
          sub_487F50(a1, v16, 4u);
          v12 = sub_487ED0(v16);
          v24 = *(float *)&v12;
          sub_487F50(a1, v16, 4u);
          v13 = sub_487ED0(v16);
          v14 = v13;
          v23 = *(float *)&v13;
          if ( v12 > 0x13880 || v13 > 0x13880 || v13 + v12 > 0x186A0 )
          {
            sub_4840E0((int)a1, aInvalidChrmBlu);
            result = sub_487F80((int)a1, 0);
          }
          else
          {
            v15 = *(_DWORD *)(a2 + 8);
            v30 = (double)v22 * flt_4B04F8;
            v29 = (double)v21 * flt_4B04F8;
            v28 = (double)v20 * flt_4B04F8;
            v27 = (double)v19 * flt_4B04F8;
            v26 = (double)v18 * flt_4B04F8;
            v25 = (double)v17 * flt_4B04F8;
            v24 = (double)SLODWORD(v24) * flt_4B04F8;
            v23 = (double)SLODWORD(v23) * flt_4B04F8;
            if ( (v15 & 0x800) != 0 )
            {
              if ( (int)abs32(v22 - 31270) > 1000
                || (int)abs32(v21 - 32900) > 1000
                || (int)abs32(v20 - 64000) > 1000
                || (int)abs32(v19 - 33000) > 1000
                || (int)abs32(v18 - 30000) > 1000
                || (int)abs32(v17 - 60000) > 1000
                || (int)abs32(v12 - 15000) > 1000
                || (int)abs32(v13 - 6000) > 1000 )
              {
                sub_4840E0((int)a1, aIgnoringIncorr_0);
                fprintf(&Stream, "wx=%f, wy=%f, rx=%f, ry=%f\n", v30, v29, v28, v27);
                fprintf(&Stream, "gx=%f, gy=%f, bx=%f, by=%f\n", v26, v25, v24, v23);
              }
              result = sub_487F80((int)a1, 0);
            }
            else
            {
              sub_486370((int)a1, a2, v30, v29, v28, v27, v26, v25, v24, v23);
              sub_486630((int)a1, a2, v22, v21, v20, v19, v18, v17, v12, v14);
              result = sub_487F80((int)a1, 0);
            }
          }
        }
      }
    }
  }
  else
  {
    sub_4840E0((int)a1, aIncorrectChrmC);
    result = sub_487F80((int)a1, a3);
  }
  return result;
}
// 4B04F8: using guessed type float flt_4B04F8;

//----- (00488F90) --------------------------------------------------------
void __cdecl sub_488F90(int *a1, int a2, unsigned int a3)
{
  int v3; // esi
  int *v4; // edi
  int v5; // eax
  unsigned int v6; // ebx
  char v7; // bl
  int v8; // eax

  v3 = a2;
  v4 = a1;
  v5 = a1[26];
  if ( (v5 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_4);
  if ( (v5 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidSrgbAft);
    sub_487F80((int)v4, a3);
    return;
  }
  if ( (v5 & 2) != 0 )
  {
    sub_4840E0((int)a1, aOutOfPlaceSrgb);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x800) != 0 )
  {
    sub_4840E0((int)a1, aDuplicateSrgbC);
    sub_487F80((int)v4, a3);
    return;
  }
  v6 = a3;
  if ( a3 == 1 )
  {
    sub_487F50(v4, (unsigned __int8 *)&a1, 1u);
    if ( !sub_487F80((int)v4, 0) )
    {
      v7 = (char)a1;
      if ( (unsigned __int8)a1 < 4u )
      {
        if ( (*(_BYTE *)(v3 + 8) & 1) != 0 )
        {
          v8 = *(_DWORD *)(v3 + 252);
          if ( v8 < 45000 || v8 > 46000 )
          {
            sub_4840E0((int)v4, aIgnoringIncorr);
            fprintf(&Stream, "incorrect gamma=(%d/100000)\n", v4[141]);
          }
        }
        if ( (*(_BYTE *)(v3 + 8) & 4) != 0
          && ((int)abs32(*(_DWORD *)(v3 + 256) - 31270) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 260) - 32900) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 264) - 64000) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 268) - 33000) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 272) - 30000) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 276) - 60000) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 280) - 15000) > 1000
           || (int)abs32(*(_DWORD *)(v3 + 284) - 6000) > 1000) )
        {
          sub_4840E0((int)v4, aIgnoringIncorr_0);
        }
        sub_486FC0((int)v4, v3, v7);
      }
      else
      {
        sub_4840E0((int)v4, aUnknownSrgbInt);
      }
    }
  }
  else
  {
    sub_4840E0((int)v4, aIncorrectSrgbC);
    sub_487F80((int)v4, v6);
  }
}

//----- (004891A0) --------------------------------------------------------
void __cdecl sub_4891A0(int *a1, int a2, unsigned int a3)
{
  int v4; // eax
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // esi
  unsigned __int8 *v8; // esi
  unsigned __int8 v9; // al
  _BYTE *v10; // esi
  unsigned int v11; // esi
  char *v12; // ebx
  size_t v13; // eax
  char *v14; // esi
  unsigned __int16 v15; // cx
  unsigned int v16; // ecx
  unsigned int v17; // [esp+10h] [ebp-4h] BYREF
  unsigned __int8 v18; // [esp+18h] [ebp+4h]

  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_5);
  if ( (v4 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidIccpAft);
    sub_487F80((int)a1, a3);
    return;
  }
  if ( (v4 & 2) != 0 )
  {
    sub_4840E0((int)a1, aOutOfPlaceIccp);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x1000) != 0 )
  {
    sub_4840E0((int)a1, aDuplicateIccpC);
    sub_487F80((int)a1, a3);
    return;
  }
  v5 = (unsigned __int8 *)sub_487D00(a1, a3 + 1);
  sub_487F50(a1, v5, a3);
  if ( sub_487F80((int)a1, 0) )
  {
    sub_487DA0((int)a1, (unsigned int)v5);
    return;
  }
  v6 = v5;
  v5[a3] = 0;
  if ( *v5 )
  {
    while ( *++v6 )
      ;
  }
  v8 = v6 + 1;
  if ( v8 >= &v5[a3] )
  {
    sub_487DA0((int)a1, (unsigned int)v5);
    sub_4840E0((int)a1, aMalformedIccpC);
    return;
  }
  v9 = *v8;
  v10 = v8 + 1;
  v18 = v9;
  if ( v9 )
  {
    sub_4840E0((int)a1, aIgnoringNonzer);
    v18 = 0;
  }
  v11 = v10 - v5;
  v12 = sub_4880A0((int)a1, v18, (char *)v5, a3, v11, &v17);
  v13 = v17 - v11;
  if ( v11 > v17 || v13 < 4 )
  {
    sub_487DA0((int)a1, (unsigned int)v12);
    sub_4840E0((int)a1, aProfileSizeFie);
  }
  else
  {
    v14 = &v12[v11];
    HIBYTE(v15) = *v14;
    LOBYTE(v15) = v14[1];
    v16 = (unsigned __int8)v14[3] | (((unsigned __int8)v14[2] | (v15 << 8)) << 8);
    if ( v16 < v13 )
    {
      v13 = v16;
LABEL_22:
      sub_487090(a1, a2, v12, v18, v14, v13);
      sub_487DA0((int)a1, (unsigned int)v12);
      return;
    }
    if ( v16 <= v13 )
      goto LABEL_22;
    sub_487DA0((int)a1, (unsigned int)v12);
    sub_4840E0((int)a1, aIgnoringTrunca);
  }
}

//----- (00489360) --------------------------------------------------------
void __cdecl sub_489360(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // esi
  char *v7; // esi
  unsigned __int8 *v8; // esi
  signed int v9; // ecx
  int v10; // edi
  int v11; // ebp
  _WORD *v12; // edi
  int v13; // eax
  __int16 v14; // dx
  unsigned __int8 *v15; // esi
  __int16 v16; // cx
  unsigned __int8 *v17; // esi
  int v18; // eax
  unsigned __int8 *v19; // esi
  int v20; // eax
  int v21; // eax
  unsigned __int8 *v22; // [esp+10h] [ebp-10h] BYREF
  char v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+18h] [ebp-8h]
  int v25; // [esp+1Ch] [ebp-4h]
  int v26; // [esp+2Ch] [ebp+Ch]

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_6);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidSpltAft);
    sub_487F80((int)a1, a3);
  }
  else
  {
    v4 = (unsigned __int8 *)sub_487D00(a1, a3 + 1);
    sub_487F50(a1, v4, a3);
    if ( sub_487F80((int)a1, 0) )
    {
      sub_487DA0((int)a1, (unsigned int)v4);
    }
    else
    {
      v5 = v4;
      v4[a3] = 0;
      if ( *v4 )
      {
        while ( *++v5 )
          ;
      }
      v7 = (char *)(v5 + 1);
      if ( v7 <= (char *)&v4[a3] )
      {
        v23 = *v7;
        v8 = (unsigned __int8 *)(v7 + 1);
        v9 = a3 + v4 - v8;
        v10 = v23 != 8 ? 10 : 6;
        if ( v9 % v10 )
        {
          sub_487DA0((int)a1, (unsigned int)v4);
          sub_4840E0((int)a1, aSpltChunkHasBa);
        }
        else
        {
          v25 = v9 / v10;
          v24 = sub_487D00(a1, 10 * (v9 / v10));
          v11 = 0;
          if ( v25 > 0 )
          {
            v26 = 0;
            do
            {
              v13 = v26;
              v12 = (_WORD *)(v26 + v24);
              LOBYTE(v13) = v23;
              if ( v23 == 8 )
              {
                v14 = *v8;
                v15 = v8 + 1;
                *v12 = v14;
                LOWORD(v13) = *v15++;
                v12[1] = v13;
                v16 = *v15++;
                v12[2] = v16;
                v12[3] = *v15;
                v17 = v15 + 1;
              }
              else
              {
                v18 = sub_487F30(v13, v8);
                v19 = v8 + 2;
                *v12 = v18;
                v20 = sub_487F30(v18, v19);
                v19 += 2;
                v12[1] = v20;
                v21 = sub_487F30(v20, v19);
                v19 += 2;
                v12[2] = v21;
                v13 = sub_487F30(v21, v19);
                v12[3] = v13;
                v17 = v19 + 2;
              }
              v12[4] = sub_487F30(v13, v17);
              v8 = v17 + 2;
              ++v11;
              v26 += 10;
            }
            while ( v11 < v25 );
          }
          v22 = v4;
          sub_4874E0(a1, a2, (int)&v22, 1);
          sub_487DA0((int)a1, (unsigned int)v4);
          sub_487DA0((int)a1, v24);
        }
      }
      else
      {
        sub_487DA0((int)a1, (unsigned int)v4);
        sub_4840E0((int)a1, aMalformedSpltC);
      }
    }
  }
}

//----- (00489560) --------------------------------------------------------
void __cdecl sub_489560(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  char v4; // al
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  unsigned __int8 v8[2]; // [esp+Ch] [ebp-108h] BYREF
  unsigned __int8 v9[2]; // [esp+Eh] [ebp-106h] BYREF
  unsigned __int8 v10[4]; // [esp+10h] [ebp-104h] BYREF
  unsigned __int8 v11[256]; // [esp+14h] [ebp-100h] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_7);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0(a1, aInvalidTrnsAft);
    sub_487F80(a1, a3);
    return;
  }
  if ( a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    sub_4840E0(a1, aDuplicateTrnsC);
LABEL_26:
    sub_487F80(a1, a3);
    return;
  }
  v4 = *(_BYTE *)(a1 + 294);
  if ( v4 == 3 )
  {
    v5 = a3;
    if ( (*(_BYTE *)(a1 + 104) & 2) == 0 )
    {
      sub_4840E0(a1, aMissingPlteBef_1);
LABEL_13:
      if ( !a3 )
      {
        sub_4840E0(a1, aZeroLengthTrns);
        sub_487F80(a1, 0);
        return;
      }
      sub_487F50((int *)a1, v11, a3);
      *(_WORD *)(a1 + 282) = a3;
      goto LABEL_23;
    }
    if ( a3 <= *(unsigned __int16 *)(a1 + 280) )
      goto LABEL_13;
LABEL_21:
    sub_4840E0(a1, aIncorrectTrnsC);
    sub_487F80(a1, v5);
    return;
  }
  if ( v4 == 2 )
  {
    v5 = a3;
    if ( a3 != 6 )
      goto LABEL_21;
    v6 = sub_487F50((int *)a1, v8, 6u);
    *(_WORD *)(a1 + 282) = 1;
    *(_WORD *)(a1 + 398) = sub_487F30(v6, v8);
    v7 = sub_487F30((int)v9, v9);
    *(_WORD *)(a1 + 400) = v7;
    *(_WORD *)(a1 + 402) = sub_487F30(v7, v10);
  }
  else
  {
    if ( v4 )
    {
      sub_4840E0(a1, aTrnsChunkNotAl);
      goto LABEL_26;
    }
    v5 = a3;
    if ( a3 != 2 )
      goto LABEL_21;
    sub_487F50((int *)a1, v8, 2u);
    *(_WORD *)(a1 + 282) = 1;
    *(_WORD *)(a1 + 404) = sub_487F30((int)v8, v8);
  }
LABEL_23:
  if ( !sub_487F80(a1, 0) )
    sub_487430((int *)a1, a2, v11, *(unsigned __int16 *)(a1 + 282), a1 + 396);
}

//----- (004897A0) --------------------------------------------------------
int __cdecl sub_4897A0(int a1, int a2, unsigned int a3)
{
  int v3; // eax
  char v4; // al
  unsigned int v5; // eax
  int result; // eax
  int v7; // eax
  unsigned __int8 v8; // al
  unsigned __int16 v9; // cx
  unsigned __int8 *v10; // eax
  __int16 v11; // ax
  int v12; // eax
  int v13; // [esp+Ch] [ebp-8h] BYREF
  unsigned __int8 v14[4]; // [esp+10h] [ebp-4h] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_8);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0(a1, aInvalidBkgdAft);
    return sub_487F80(a1, a3);
  }
  if ( *(_BYTE *)(a1 + 294) == 3 && (v3 & 2) == 0 )
  {
    sub_4840E0(a1, aMissingPlteBef_2);
    return sub_487F80(a1, a3);
  }
  if ( a2 && (*(_BYTE *)(a2 + 8) & 0x20) != 0 )
  {
    sub_4840E0(a1, aDuplicateBkgdC);
    return sub_487F80(a1, a3);
  }
  v4 = *(_BYTE *)(a1 + 294);
  if ( v4 == 3 )
    v5 = 1;
  else
    v5 = 2 * (v4 & 2 | 1);
  if ( a3 != v5 )
  {
    sub_4840E0(a1, aIncorrectBkgdC);
    return sub_487F80(a1, a3);
  }
  sub_487F50((int *)a1, (unsigned __int8 *)&v13, v5);
  result = sub_487F80(a1, 0);
  if ( !result )
  {
    v7 = *(unsigned __int8 *)(a1 + 294);
    if ( (_BYTE)v7 == 3 )
    {
      v8 = v13;
      *(_BYTE *)(a1 + 312) = v13;
      v9 = *(_WORD *)(a2 + 20);
      if ( v9 )
      {
        if ( v8 > v9 )
          return sub_4840E0(a1, aIncorrectBkgdC_0);
        v10 = (unsigned __int8 *)(*(_DWORD *)(a1 + 276) + 3 * v8);
        *(_WORD *)(a1 + 314) = *v10;
        *(_WORD *)(a1 + 316) = v10[1];
        *(_WORD *)(a1 + 318) = v10[2];
      }
    }
    else if ( (v7 & 2) != 0 )
    {
      v12 = sub_487F30(v7, (unsigned __int8 *)&v13);
      *(_WORD *)(a1 + 314) = v12;
      *(_WORD *)(a1 + 316) = sub_487F30(v12, (unsigned __int8 *)&v13 + 2);
      *(_WORD *)(a1 + 318) = sub_487F30((int)v14, v14);
    }
    else
    {
      v11 = sub_487F30((int)&v13, (unsigned __int8 *)&v13);
      *(_WORD *)(a1 + 320) = v11;
      *(_WORD *)(a1 + 318) = v11;
      *(_WORD *)(a1 + 316) = v11;
      *(_WORD *)(a1 + 314) = v11;
    }
    result = sub_486330(a1, a2, a1 + 312);
  }
  return result;
}

//----- (004899A0) --------------------------------------------------------
void __cdecl sub_4899A0(int a1, int a2, signed int a3)
{
  int v3; // eax
  char *v4; // edi
  int v5; // ebx
  unsigned __int8 v6[2]; // [esp+Eh] [ebp-202h] BYREF
  char v7[512]; // [esp+10h] [ebp-200h] BYREF

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_9);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0(a1, aInvalidHistAft);
    sub_487F80(a1, a3);
  }
  else if ( (v3 & 2) != 0 )
  {
    if ( a2 && (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
    {
      sub_4840E0(a1, aDuplicateHistC);
      sub_487F80(a1, a3);
    }
    else if ( a3 / 2 == *(unsigned __int16 *)(a1 + 280) )
    {
      if ( a3 / 2 > 0 )
      {
        v4 = v7;
        v5 = a3 / 2;
        do
        {
          sub_487F50((int *)a1, v6, 2u);
          *(_WORD *)v4 = sub_487F30((int)v6, v6);
          v4 += 2;
          --v5;
        }
        while ( v5 );
      }
      if ( !sub_487F80(a1, 0) )
        sub_486980((int *)a1, a2, (int)v7);
    }
    else
    {
      sub_4840E0(a1, aIncorrectHistC);
      sub_487F80(a1, a3);
    }
  }
  else
  {
    sub_4840E0(a1, aMissingPlteBef_3);
    sub_487F80(a1, a3);
  }
}

//----- (00489AF0) --------------------------------------------------------
int __cdecl sub_489AF0(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // edi
  int v6; // eax
  unsigned __int8 v7[4]; // [esp+Ch] [ebp-Ch] BYREF
  unsigned __int8 v8[8]; // [esp+10h] [ebp-8h] BYREF

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_10);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidPhysAft);
    result = sub_487F80((int)a1, a3);
  }
  else if ( a2 && *(char *)(a2 + 8) < 0 )
  {
    sub_4840E0((int)a1, aDuplicatePhysC);
    result = sub_487F80((int)a1, a3);
  }
  else if ( a3 == 9 )
  {
    sub_487F50(a1, v7, 9u);
    result = sub_487F80((int)a1, 0);
    if ( !result )
    {
      v5 = sub_487ED0(v7);
      v6 = sub_487ED0(v8);
      result = sub_486E80((int)a1, a2, v5, v6, v8[4]);
    }
  }
  else
  {
    sub_4840E0((int)a1, aIncorrectPhysC);
    result = sub_487F80((int)a1, a3);
  }
  return result;
}

//----- (00489BE0) --------------------------------------------------------
int __cdecl sub_489BE0(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // edi
  int v6; // eax
  unsigned __int8 v7[4]; // [esp+Ch] [ebp-Ch] BYREF
  unsigned __int8 v8[8]; // [esp+10h] [ebp-8h] BYREF

  v3 = a1[26];
  if ( (v3 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_11);
  if ( (v3 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidOffsAft);
    result = sub_487F80((int)a1, a3);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x100) != 0 )
  {
    sub_4840E0((int)a1, aDuplicateOffsC);
    result = sub_487F80((int)a1, a3);
  }
  else if ( a3 == 9 )
  {
    sub_487F50(a1, v7, 9u);
    result = sub_487F80((int)a1, 0);
    if ( !result )
    {
      v5 = sub_487F00(v7);
      v6 = sub_487F00(v8);
      result = sub_486C50((int)a1, a2, v5, v6, v8[4]);
    }
  }
  else
  {
    sub_4840E0((int)a1, aIncorrectOffsC);
    result = sub_487F80((int)a1, a3);
  }
  return result;
}

//----- (00489CD0) --------------------------------------------------------
void __cdecl sub_489CD0(int *a1, int a2, unsigned int a3)
{
  int v4; // eax
  unsigned __int8 *v5; // eax
  const char *v6; // ebp
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // esi
  int v10; // eax
  unsigned __int8 v11; // cl
  char v12; // al
  const char *v13; // esi
  int v15; // ebx
  int v16; // eax
  int v17; // edx
  _DWORD *v18; // ecx
  const char *v20; // [esp+10h] [ebp-10h]
  char v21; // [esp+14h] [ebp-Ch]
  int v22; // [esp+18h] [ebp-8h]
  int v23; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v24; // [esp+24h] [ebp+4h]
  unsigned __int8 v25; // [esp+2Ch] [ebp+Ch]
  unsigned int v26; // [esp+2Ch] [ebp+Ch]

  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_12);
  if ( (v4 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidPcalAft);
    sub_487F80((int)a1, a3);
    return;
  }
  if ( a2 && (*(_DWORD *)(a2 + 8) & 0x400) != 0 )
  {
    sub_4840E0((int)a1, aDuplicatePcalC);
    sub_487F80((int)a1, a3);
    return;
  }
  v5 = (unsigned __int8 *)sub_487DF0(a1, a3 + 1);
  v6 = (const char *)v5;
  if ( !v5 )
  {
    sub_4840E0((int)a1, aNoMemoryForPca);
    return;
  }
  sub_487F50(a1, v5, a3);
  if ( sub_487F80((int)a1, 0) )
  {
    sub_487DA0((int)a1, (unsigned int)v6);
    return;
  }
  v7 = (unsigned __int8 *)&v6[a3];
  v8 = (unsigned __int8 *)v6;
  v24 = v7;
  *v7 = 0;
  if ( *v6 )
  {
    while ( *++v8 )
      ;
  }
  if ( v7 <= v8 + 12 )
  {
    sub_4840E0((int)a1, aInvalidPcalDat);
LABEL_28:
    sub_487DA0((int)a1, (unsigned int)v6);
    return;
  }
  v23 = sub_487F00(v8 + 1);
  v10 = sub_487F00(v8 + 5);
  v11 = v8[10];
  v22 = v10;
  v12 = v8[9];
  v13 = (const char *)(v8 + 11);
  v21 = v12;
  v25 = v11;
  v20 = v13;
  switch ( v12 )
  {
    case 0:
      if ( v11 == 2 )
        break;
LABEL_27:
      sub_4840E0((int)a1, aInvalidPcalPar);
      goto LABEL_28;
    case 1:
      if ( v11 != 3 )
        goto LABEL_27;
      break;
    case 2:
      if ( v11 != 3 )
        goto LABEL_27;
      break;
    case 3:
      if ( v11 == 4 )
        break;
      goto LABEL_27;
    default:
      sub_4840E0((int)a1, aUnrecognizedEq);
      break;
  }
  if ( *v13 )
  {
    while ( *++v13 )
      ;
  }
  v15 = v25;
  v16 = sub_487DF0(a1, 4 * v25);
  v26 = v16;
  if ( v16 )
  {
    v17 = 0;
    if ( v15 <= 0 )
    {
LABEL_42:
      sub_486C80(a1, a2, v6, v23, v22, v21, v15, v20, v16);
      sub_487DA0((int)a1, (unsigned int)v6);
      sub_487DA0((int)a1, v26);
    }
    else
    {
      v18 = (_DWORD *)v16;
      while ( 1 )
      {
        *v18 = ++v13;
        if ( *v13 )
          break;
LABEL_39:
        if ( v13 > (const char *)v24 )
          goto LABEL_43;
        ++v17;
        ++v18;
        if ( v17 >= v15 )
        {
          v16 = v26;
          goto LABEL_42;
        }
      }
      while ( v13 <= (const char *)v24 )
      {
        if ( !*++v13 )
          goto LABEL_39;
      }
LABEL_43:
      sub_4840E0((int)a1, aInvalidPcalDat);
      sub_487DA0((int)a1, (unsigned int)v6);
      sub_487DA0((int)a1, v26);
    }
  }
  else
  {
    sub_487DA0((int)a1, (unsigned int)v6);
    sub_4840E0((int)a1, aNoMemoryForPca_0);
  }
}
// 489E40: conditional instruction was optimized away because of 'al.1>=4u'

//----- (00489F40) --------------------------------------------------------
void __cdecl sub_489F40(int *a1, int a2, unsigned int a3)
{
  int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  unsigned __int8 *v6; // eax
  char *v7; // esi
  char *v8; // ebp
  char *v9; // ebx
  char *v11; // ebx
  double v12; // [esp+10h] [ebp-10h]
  double v13; // [esp+18h] [ebp-8h]

  v3 = a1;
  v4 = a1[26];
  if ( (v4 & 1) == 0 )
    sub_484040(a1, aMissingIhdrBef_13);
  if ( (v4 & 4) != 0 )
  {
    sub_4840E0((int)a1, aInvalidScalAft);
    sub_487F80((int)v3, a3);
  }
  else if ( a2 && (*(_DWORD *)(a2 + 8) & 0x4000) != 0 )
  {
    sub_4840E0((int)a1, aDuplicateScalC);
    sub_487F80((int)v3, a3);
  }
  else
  {
    v5 = a3;
    v6 = (unsigned __int8 *)sub_487DF0(a1, a3 + 1);
    v7 = (char *)v6;
    if ( v6 )
    {
      sub_487F50(v3, v6, v5);
      if ( sub_487F80((int)v3, 0) )
      {
        sub_487DA0((int)v3, (unsigned int)v7);
      }
      else
      {
        v8 = &v7[v5];
        v7[v5] = 0;
        v13 = sub_4A23A9(v7 + 1, &a1);
        if ( *(_BYTE *)a1 )
        {
          sub_4840E0((int)v3, aMalformedWidth);
        }
        else
        {
          v9 = v7;
          if ( *v7 )
          {
            while ( *++v9 )
              ;
          }
          v11 = v9 + 1;
          v12 = sub_4A23A9(v11, &a1);
          if ( *(_BYTE *)a1 )
          {
            sub_4840E0((int)v3, aMalformedHeigh);
          }
          else if ( v8 < v11 || v13 <= dbl_4A91B8 || v12 <= dbl_4A91B8 )
          {
            sub_4840E0((int)v3, aInvalidScalDat);
            sub_487DA0((int)v3, (unsigned int)v7);
          }
          else
          {
            sub_486E30((int)v3, a2, *v7, SLODWORD(v13), SHIDWORD(v13), SLODWORD(v12), SHIDWORD(v12));
            sub_487DA0((int)v3, (unsigned int)v7);
          }
        }
      }
    }
    else
    {
      sub_4840E0((int)v3, aOutOfMemoryWhi);
    }
  }
}
// 4A91B8: using guessed type double dbl_4A91B8;

//----- (0048A110) --------------------------------------------------------
void __cdecl sub_48A110(int a1, _DWORD *a2, unsigned int a3)
{
  int v3; // eax
  unsigned __int8 v4[2]; // [esp+Ch] [ebp-10h] BYREF
  __int16 v5; // [esp+Eh] [ebp-Eh]
  char v6; // [esp+10h] [ebp-Ch]
  char v7; // [esp+11h] [ebp-Bh]
  char v8; // [esp+12h] [ebp-Ah]
  int v9; // [esp+14h] [ebp-8h] BYREF
  char v10; // [esp+18h] [ebp-4h]
  char v11; // [esp+19h] [ebp-3h]
  char v12; // [esp+1Ah] [ebp-2h]

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_484040((int *)a1, aOutOfPlaceTime);
  if ( a2 && (a2[2] & 0x200) != 0 )
  {
    sub_4840E0(a1, aDuplicateTimeC);
    sub_487F80(a1, a3);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 104);
    if ( (v3 & 4) != 0 )
    {
      LOBYTE(v3) = v3 | 8;
      *(_DWORD *)(a1 + 104) = v3;
    }
    if ( a3 == 7 )
    {
      sub_487F50((int *)a1, v4, 7u);
      if ( !sub_487F80(a1, 0) )
      {
        v10 = v6;
        v12 = v8;
        v11 = v7;
        HIWORD(v9) = v5;
        LOWORD(v9) = sub_487F30((unsigned __int8)v5, v4);
        sub_4873F0(a1, a2, &v9);
      }
    }
    else
    {
      sub_4840E0(a1, aIncorrectTimeC);
      sub_487F80(a1, a3);
    }
  }
}

//----- (0048A200) --------------------------------------------------------
void __cdecl sub_48A200(int a1, _DWORD *a2, unsigned int a3)
{
  int v3; // eax
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ebp
  const char *v6; // edi
  _DWORD *v8; // esi
  int v9; // edi

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_14);
  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 4) != 0 )
  {
    LOBYTE(v3) = v3 | 8;
    *(_DWORD *)(a1 + 104) = v3;
  }
  v4 = (unsigned __int8 *)sub_487DF0((int *)a1, a3 + 1);
  v5 = v4;
  if ( v4 )
  {
    sub_487F50((int *)a1, v4, a3);
    if ( sub_487F80(a1, 0) )
    {
      sub_487DA0(a1, (unsigned int)v5);
    }
    else
    {
      v6 = (const char *)v5;
      v5[a3] = 0;
      if ( *v5 )
      {
        while ( *++v6 )
          ;
      }
      if ( v6 != (const char *)&v5[a3] )
        ++v6;
      v8 = (_DWORD *)sub_487DF0((int *)a1, 0x10u);
      if ( v8 )
      {
        *v8 = -1;
        v8[1] = v5;
        v8[2] = v6;
        v8[3] = strlen(v6);
        v9 = sub_4871C0((int *)a1, a2, (int)v8, 1);
        sub_487DA0(a1, (unsigned int)v5);
        sub_487DA0(a1, (unsigned int)v8);
        if ( v9 )
          sub_4840E0(a1, aInsufficientMe_4);
      }
      else
      {
        sub_4840E0(a1, aNotEnoughMemor_3);
        sub_487DA0(a1, (unsigned int)v5);
      }
    }
  }
  else
  {
    sub_4840E0(a1, aNoMemoryToProc);
  }
}

//----- (0048A320) --------------------------------------------------------
void __cdecl sub_48A320(int a1, _DWORD *a2, unsigned int a3)
{
  int v4; // eax
  unsigned __int8 *v5; // eax
  char *v6; // ebx
  char *v7; // edi
  int v9; // ebp
  char *v10; // edi
  char *v11; // ebx
  int *v12; // edi
  int v13; // ebp
  int v14; // [esp+10h] [ebp-4h] BYREF
  int v15; // [esp+18h] [ebp+4h]

  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
    sub_484040((int *)a1, aMissingIhdrBef_15);
  v4 = *(_DWORD *)(a1 + 104);
  if ( (v4 & 4) != 0 )
  {
    LOBYTE(v4) = v4 | 8;
    *(_DWORD *)(a1 + 104) = v4;
  }
  v5 = (unsigned __int8 *)sub_487DF0((int *)a1, a3 + 1);
  v6 = (char *)v5;
  if ( v5 )
  {
    sub_487F50((int *)a1, v5, a3);
    if ( sub_487F80(a1, 0) )
    {
      sub_487DA0(a1, (unsigned int)v6);
    }
    else
    {
      v7 = v6;
      v6[a3] = 0;
      if ( *v6 )
      {
        while ( *++v7 )
          ;
      }
      if ( v7 == &v6[a3] )
      {
        v9 = -1;
        sub_4840E0(a1, aZeroLengthZtxt);
      }
      else
      {
        v9 = v7[1];
        v10 = v7 + 1;
        if ( v9 )
        {
          sub_4840E0(a1, aUnknownCompres_2);
          v9 = 0;
        }
        v7 = v10 + 1;
      }
      v15 = v7 - v6;
      v11 = sub_4880A0(a1, v9, v6, a3, v7 - v6, (unsigned int *)&v14);
      v12 = (int *)sub_487DF0((int *)a1, 0x10u);
      if ( v12 )
      {
        *v12 = v9;
        v12[1] = (int)v11;
        v12[2] = (int)&v11[v15];
        v12[3] = v14;
        v13 = sub_4871C0((int *)a1, a2, (int)v12, 1);
        sub_487DA0(a1, (unsigned int)v12);
        sub_487DA0(a1, (unsigned int)v11);
        if ( v13 )
          sub_484040((int *)a1, aInsufficientMe_5);
      }
      else
      {
        sub_4840E0(a1, aNotEnoughMemor_4);
        sub_487DA0(a1, (unsigned int)v11);
      }
    }
  }
  else
  {
    sub_4840E0(a1, aOutOfMemoryPro);
  }
}

//----- (0048A480) --------------------------------------------------------
int __cdecl sub_48A480(int a1, int a2, size_t a3)
{
  int v3; // eax
  int (__cdecl *v4)(int, char *); // eax
  char v6[8]; // [esp+10h] [ebp-14h] BYREF
  unsigned __int8 *v7; // [esp+18h] [ebp-Ch]
  size_t v8; // [esp+1Ch] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 104);
  if ( (v3 & 4) != 0 && *(_DWORD *)(a1 + 284) != *(_DWORD *)aIdat )
  {
    LOBYTE(v3) = v3 | 8;
    *(_DWORD *)(a1 + 104) = v3;
  }
  sub_48A5F0((int *)a1, (unsigned __int8 *)(a1 + 284));
  if ( (*(_BYTE *)(a1 + 284) & 0x20) == 0 && sub_484C80(a1, (_DWORD *)(a1 + 284)) != 3 && !*(_DWORD *)(a1 + 540) )
    sub_484130((int *)a1, aUnknownCritica);
  if ( (BYTE1(*(_DWORD *)(a1 + 108)) & 0x80u) != 0 )
  {
    strcpy(v6, (const char *)(a1 + 284));
    v7 = (unsigned __int8 *)sub_487D00((int *)a1, a3);
    v8 = a3;
    sub_487F50((int *)a1, v7, a3);
    v4 = *(int (__cdecl **)(int, char *))(a1 + 540);
    if ( v4 )
    {
      if ( v4(a1, v6) > 0 )
      {
LABEL_15:
        sub_487DA0(a1, (unsigned int)v7);
        return sub_487F80(a1, 0);
      }
      if ( (*(_BYTE *)(a1 + 284) & 0x20) == 0 && sub_484C80(a1, (_DWORD *)(a1 + 284)) != 3 )
      {
        sub_487DA0(a1, (unsigned int)v7);
        sub_484130((int *)a1, aUnknownCritica);
      }
    }
    sub_487660(a1, a2, (int)v6, 1);
    goto LABEL_15;
  }
  return sub_487F80(a1, a3);
}

//----- (0048A5F0) --------------------------------------------------------
unsigned __int8 __cdecl sub_48A5F0(int *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  unsigned __int8 result; // al

  v2 = *a2;
  if ( *a2 < 0x29u
    || v2 > 0x7Au
    || v2 > 0x5Au && v2 < 0x61u
    || (v3 = a2[1], v3 < 0x29u)
    || v3 > 0x7Au
    || v3 > 0x5Au && v3 < 0x61u
    || (v4 = a2[2], v4 < 0x29u)
    || v4 > 0x7Au
    || v4 > 0x5Au && v4 < 0x61u
    || (result = a2[3], result < 0x29u)
    || result > 0x7Au
    || result > 0x5Au && result < 0x61u )
  {
    sub_484130(a1, aInvalidChunkTy);
  }
  return result;
}

//----- (0048A660) --------------------------------------------------------
char __cdecl sub_48A660(int a1, char *a2, int a3)
{
  unsigned int v3; // eax
  char *v4; // edi
  int v5; // ebp
  char *v6; // edx
  _BYTE *v7; // esi
  int v8; // ecx
  unsigned __int8 *v9; // edi
  int v10; // ebp
  int v11; // edx
  _BYTE *v12; // esi
  int v13; // ecx
  unsigned __int8 *v14; // edi
  int v15; // ebp
  int v16; // edx
  _BYTE *v17; // edi
  int v18; // ecx
  unsigned __int8 *v19; // esi
  int v20; // ebp
  int v21; // edx
  int v23; // [esp+10h] [ebp-8h]
  int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+10h] [ebp-8h]
  int v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+14h] [ebp-4h]
  int v28; // [esp+14h] [ebp-4h]
  int v29; // [esp+1Ch] [ebp+4h]
  int v30; // [esp+1Ch] [ebp+4h]
  int v31; // [esp+1Ch] [ebp+4h]
  int v32; // [esp+1Ch] [ebp+4h]
  int v33; // [esp+20h] [ebp+8h]
  int v34; // [esp+20h] [ebp+8h]
  int v35; // [esp+20h] [ebp+8h]

  if ( a3 == 255 )
  {
    v3 = (*(_DWORD *)(a1 + 200) * (unsigned int)*(unsigned __int8 *)(a1 + 267) + 7) >> 3;
    qmemcpy(
      a2,
      (const void *)(*(_DWORD *)(a1 + 236) + 1),
      4 * ((*(_DWORD *)(a1 + 200) * (unsigned int)*(unsigned __int8 *)(a1 + 267) + 7) >> 5) + (v3 & 3));
  }
  else
  {
    LOBYTE(v3) = a1;
    switch ( *(_BYTE *)(a1 + 267) )
    {
      case 1:
        v17 = a2;
        v18 = *(_DWORD *)(a1 + 200);
        v19 = (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1);
        v35 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          v20 = 0;
          v32 = 7;
          v28 = 1;
        }
        else
        {
          v20 = 7;
          v32 = 0;
          v28 = -1;
        }
        v21 = v20;
        if ( v18 )
        {
          v25 = v18;
          do
          {
            if ( (v35 & a3) != 0 )
              *v17 = (((*v19 >> v21) & 1) << v21) | *v17 & (32639 >> (7 - v21));
            if ( v21 == v32 )
            {
              ++v19;
              v21 = v20;
              ++v17;
            }
            else
            {
              v21 += v28;
            }
            if ( v35 == 1 )
              v35 = 128;
            else
              v35 >>= 1;
            LOBYTE(v3) = --v25;
          }
          while ( v25 );
        }
        break;
      case 2:
        v12 = a2;
        v13 = *(_DWORD *)(a1 + 200);
        v14 = (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1);
        v34 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          v15 = 0;
          v31 = 6;
          v27 = 2;
        }
        else
        {
          v15 = 6;
          v31 = 0;
          v27 = -2;
        }
        v16 = v15;
        if ( v13 )
        {
          v24 = v13;
          do
          {
            if ( (v34 & a3) != 0 )
              *v12 = (((*v14 >> v16) & 3) << v16) | *v12 & (16191 >> (6 - v16));
            if ( v16 == v31 )
            {
              ++v14;
              v16 = v15;
              ++v12;
            }
            else
            {
              v16 += v27;
            }
            if ( v34 == 1 )
              v34 = 128;
            else
              v34 >>= 1;
            LOBYTE(v3) = --v24;
          }
          while ( v24 );
        }
        break;
      case 4:
        v7 = a2;
        v8 = *(_DWORD *)(a1 + 200);
        v9 = (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1);
        v33 = 128;
        if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
        {
          LOBYTE(v3) = 4;
          v10 = 0;
          v30 = 4;
          v23 = 4;
        }
        else
        {
          v10 = 4;
          v30 = 0;
          v23 = -4;
        }
        v11 = v10;
        if ( v8 )
        {
          v26 = v8;
          do
          {
            if ( (v33 & a3) != 0 )
              *v7 = (((*v9 >> v11) & 0xF) << v11) | *v7 & (3855 >> (4 - v11));
            if ( v11 == v30 )
            {
              ++v9;
              v11 = v10;
              ++v7;
            }
            else
            {
              v11 += v23;
            }
            if ( v33 == 1 )
              v33 = 128;
            else
              v33 >>= 1;
            LOBYTE(v3) = --v26;
          }
          while ( v26 );
        }
        break;
      default:
        v4 = a2;
        v5 = *(unsigned __int8 *)(a1 + 267) >> 3;
        v6 = (char *)(*(_DWORD *)(a1 + 236) + 1);
        LOBYTE(v3) = 0x80;
        if ( *(_DWORD *)(a1 + 200) )
        {
          v29 = *(_DWORD *)(a1 + 200);
          do
          {
            if ( ((unsigned __int8)v3 & (unsigned __int8)a3) != 0 )
              qmemcpy(v4, v6, v5);
            v6 += v5;
            v4 = &a2[v5];
            a2 += v5;
            if ( (_BYTE)v3 == 1 )
              LOBYTE(v3) = 0x80;
            else
              LOBYTE(v3) = (unsigned __int8)v3 >> 1;
            --v29;
          }
          while ( v29 );
        }
        break;
    }
  }
  return v3;
}

//----- (0048A980) --------------------------------------------------------
int __cdecl sub_48A980(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // ecx
  int v4; // ebp
  int *v5; // edi
  int v6; // eax
  int v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // edx
  char *v10; // ebp
  char *v11; // ebx
  char *v12; // edi
  bool v13; // zf
  int v14; // edx
  _BYTE *v15; // edi
  int v16; // edx
  int v17; // esi
  char v18; // al
  _BYTE *v20; // edi
  int v21; // edx
  int v22; // esi
  char v23; // al
  _BYTE *v24; // edi
  int v25; // edx
  int v26; // esi
  char v27; // al
  int v28; // [esp+Ch] [ebp-24h]
  int v29; // [esp+10h] [ebp-20h]
  int v30; // [esp+14h] [ebp-1Ch]
  int v31; // [esp+18h] [ebp-18h]
  int v32; // [esp+18h] [ebp-18h]
  int v33; // [esp+18h] [ebp-18h]
  _BYTE *v34; // [esp+1Ch] [ebp-14h]
  _BYTE *v35; // [esp+1Ch] [ebp-14h]
  _BYTE *v36; // [esp+1Ch] [ebp-14h]
  unsigned int v37; // [esp+20h] [ebp-10h]
  int v38; // [esp+20h] [ebp-10h]
  int v39; // [esp+20h] [ebp-10h]
  int v40; // [esp+20h] [ebp-10h]
  int v41; // [esp+24h] [ebp-Ch]
  unsigned int v42; // [esp+24h] [ebp-Ch]
  unsigned int v43; // [esp+24h] [ebp-Ch]
  int v44[2]; // [esp+28h] [ebp-8h] BYREF
  int v45; // [esp+34h] [ebp+4h]
  char v46; // [esp+34h] [ebp+4h]
  char v47; // [esp+34h] [ebp+4h]
  int v48; // [esp+34h] [ebp+4h]

  result = a1;
  v2 = *(_DWORD *)(a1 + 112);
  v3 = *(_DWORD *)(a1 + 236) + 1;
  v4 = 0;
  v5 = (int *)(a1 + 256);
  v29 = a1 + 256;
  if ( *(_DWORD *)(a1 + 236) != -1 && a1 != -256 )
  {
    v6 = *v5;
    v7 = dword_4B0414[*(unsigned __int8 *)(a1 + 292)] * *v5;
    v30 = dword_4B0414[*(unsigned __int8 *)(a1 + 292)];
    v8 = *(unsigned __int8 *)(a1 + 267);
    v28 = v7;
    switch ( v8 )
    {
      case 1u:
        v24 = (_BYTE *)(v3 + ((unsigned int)(v7 - 1) >> 3));
        v36 = (_BYTE *)(v3 + ((unsigned int)(v6 - 1) >> 3));
        if ( (v2 & 0x10000) != 0 )
        {
          v25 = ((_BYTE)v6 - 1) & 7;
          v26 = ((_BYTE)v7 - 1) & 7;
          v48 = v25;
          v40 = 7;
          v33 = -1;
        }
        else
        {
          v25 = 7 - (((_BYTE)v6 - 1) & 7);
          v40 = 0;
          v48 = v25;
          v26 = 7 - (((_BYTE)v7 - 1) & 7);
          v4 = 7;
          v33 = 1;
        }
        v43 = 0;
        if ( v6 )
        {
          do
          {
            v27 = (*v36 >> v25) & 1;
            if ( v30 > 0 )
            {
              v44[0] = v30;
              do
              {
                *v24 = (v27 << v26) | *v24 & (32639 >> (7 - v26));
                if ( v26 == v4 )
                {
                  v26 = v40;
                  --v24;
                }
                else
                {
                  v26 += v33;
                }
                --v44[0];
              }
              while ( v44[0] );
              v25 = v48;
              v7 = v28;
            }
            if ( v25 == v4 )
            {
              v25 = v40;
              v48 = v40;
              --v36;
            }
            else
            {
              v25 += v33;
              v48 = v25;
            }
            ++v43;
          }
          while ( v43 < *(_DWORD *)v29 );
        }
        break;
      case 2u:
        v20 = (_BYTE *)(v3 + ((unsigned int)(v7 - 1) >> 2));
        v35 = (_BYTE *)(v3 + ((unsigned int)(v6 - 1) >> 2));
        if ( (v2 & 0x10000) != 0 )
        {
          v21 = (2 * (_BYTE)v6 - 1) & 6;
          v22 = (2 * (_BYTE)v7 - 1) & 6;
          v39 = 6;
          v32 = -2;
        }
        else
        {
          v39 = 0;
          v4 = 6;
          v21 = 2 * (3 - (((_BYTE)v6 - 1) & 3));
          v22 = 2 * (3 - (((_BYTE)v7 - 1) & 3));
          v32 = 2;
        }
        v42 = 0;
        if ( v6 )
        {
          do
          {
            v23 = (*v35 >> v21) & 3;
            v47 = v23;
            if ( v30 > 0 )
            {
              v44[0] = v30;
              while ( 1 )
              {
                *v20 = (v23 << v22) | *v20 & (16191 >> (6 - v22));
                if ( v22 == v4 )
                {
                  v22 = v39;
                  --v20;
                }
                else
                {
                  v22 += v32;
                }
                if ( !--v44[0] )
                  break;
                v23 = v47;
              }
              v7 = v28;
            }
            if ( v21 == v4 )
            {
              v21 = v39;
              --v35;
            }
            else
            {
              v21 += v32;
            }
            ++v42;
          }
          while ( v42 < *(_DWORD *)v29 );
        }
        break;
      case 4u:
        v15 = (_BYTE *)(v3 + ((unsigned int)(v7 - 1) >> 1));
        v34 = (_BYTE *)(v3 + ((unsigned int)(v6 - 1) >> 1));
        if ( (v2 & 0x10000) != 0 )
        {
          v16 = (-1 - 4 * (_BYTE)v6) & 4;
          v17 = (-1 - 4 * (_BYTE)v7) & 4;
          v31 = 4;
          v38 = -4;
        }
        else
        {
          v31 = 0;
          v16 = 4 - 4 * (((_BYTE)v6 - 1) & 1);
          v4 = 4;
          v17 = 4 - 4 * (((_BYTE)v7 - 1) & 1);
          v38 = 4;
        }
        v44[0] = 0;
        if ( v6 )
        {
          do
          {
            v18 = (*v34 >> v16) & 0xF;
            v46 = v18;
            if ( v30 > 0 )
            {
              v41 = v30;
              while ( 1 )
              {
                *v15 = (v18 << v17) | *v15 & (3855 >> (4 - v17));
                if ( v17 == v4 )
                {
                  v17 = v31;
                  --v15;
                }
                else
                {
                  v17 += v38;
                }
                if ( !--v41 )
                  break;
                v18 = v46;
              }
              v7 = v28;
            }
            if ( v16 == v4 )
            {
              v16 = v31;
              --v34;
            }
            else
            {
              v16 += v38;
            }
          }
          while ( (unsigned int)++v44[0] < *(_DWORD *)v29 );
        }
        break;
      default:
        v9 = v8 >> 3;
        v37 = 0;
        v10 = (char *)(v3 + v9 * (v6 - 1));
        v11 = (char *)(v3 + v9 * (v7 - 1));
        if ( v6 )
        {
          do
          {
            qmemcpy(v44, v10, v9);
            if ( v30 > 0 )
            {
              v45 = v30;
              do
              {
                qmemcpy(v11, v44, 4 * (v9 >> 2));
                v12 = &v11[4 * (v9 >> 2)];
                v11 -= v9;
                v13 = v45 == 1;
                qmemcpy(v12, &v44[v9 >> 2], v9 & 3);
                --v45;
              }
              while ( !v13 );
            }
            v10 -= v9;
            ++v37;
          }
          while ( v37 < *(_DWORD *)v29 );
        }
        v7 = v28;
        break;
    }
    result = v29;
    v14 = *(unsigned __int8 *)(v29 + 11);
    *(_DWORD *)v29 = v7;
    *(_DWORD *)(v29 + 4) = (unsigned int)(v7 * v14 + 7) >> 3;
  }
  return result;
}

//----- (0048ADB0) --------------------------------------------------------
char __cdecl sub_48ADB0(int a1, int a2, _BYTE *a3, unsigned __int8 *a4, int a5)
{
  unsigned int v5; // eax
  unsigned int v6; // esi
  _BYTE *v7; // ecx
  _BYTE *v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // esi
  unsigned int i; // ecx
  _BYTE *v12; // ecx
  unsigned __int8 *v13; // esi
  unsigned __int8 *v14; // edi
  unsigned int v15; // edx
  int v16; // ebp
  unsigned int v17; // ebp
  _BYTE *v18; // edi
  unsigned __int8 *v19; // edx
  unsigned __int8 *v20; // esi
  unsigned int v21; // ecx
  unsigned __int8 *v22; // ebp
  int v23; // ebx
  int v24; // edi
  int v25; // edx
  int v26; // ecx
  int v27; // ebp
  int v28; // eax
  unsigned __int8 *v30; // [esp+14h] [ebp+4h]
  int v31; // [esp+18h] [ebp+8h]
  unsigned int v32; // [esp+20h] [ebp+10h]
  unsigned __int8 *v33; // [esp+24h] [ebp+14h]

  LOBYTE(v5) = a5;
  switch ( a5 )
  {
    case 0:
      return v5;
    case 1:
      v6 = *(_DWORD *)(a2 + 4);
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v7 = &a3[v5];
      if ( v5 < v6 )
      {
        v8 = a3;
        v9 = v6 - v5;
        do
        {
          LOBYTE(v5) = *v8;
          *v7++ += *v8++;
          --v9;
        }
        while ( v9 );
      }
      break;
    case 2:
      v5 = (unsigned int)a3;
      v10 = *(_DWORD *)(a2 + 4);
      for ( i = 0; i < v10; ++i )
        *(_BYTE *)v5++ += a4[i];
      break;
    case 3:
      v12 = a3;
      v13 = a4;
      v14 = a3;
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v15 = *(_DWORD *)(a2 + 4) - v5;
      if ( v5 )
      {
        v16 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
        do
        {
          LOBYTE(v5) = *v13++ >> 1;
          *v12++ += v5;
          --v16;
        }
        while ( v16 );
      }
      if ( v15 )
      {
        v17 = v15;
        do
        {
          v5 = (*v13 + *v14++) / 2;
          *v12 += v5;
          ++v13;
          ++v12;
          --v17;
        }
        while ( v17 );
      }
      break;
    case 4:
      v18 = a3;
      v19 = a3;
      v20 = a4;
      v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
      v21 = *(_DWORD *)(a2 + 4) - v5;
      v22 = a4;
      if ( v5 )
      {
        do
        {
          *v18++ += *v20++;
          --v5;
        }
        while ( v5 );
        a3 = v18;
      }
      if ( v21 )
      {
        v32 = v21;
        while ( 1 )
        {
          v23 = *v20;
          v24 = *v19;
          v33 = v19 + 1;
          v25 = *v22;
          ++v20;
          v26 = v24 - v25;
          v30 = v22 + 1;
          if ( v23 - v25 >= 0 )
            v31 = v23 - v25;
          else
            v31 = v25 - v23;
          v27 = v24 - v25;
          if ( v26 < 0 )
            v27 = v25 - v24;
          v28 = v26 + v23 - v25;
          if ( v28 < 0 )
            v28 = -v28;
          if ( v31 > v27 || v31 > v28 )
          {
            if ( v27 <= v28 )
              LOBYTE(v25) = v23;
          }
          else
          {
            LOBYTE(v25) = v24;
          }
          *a3++ += v25;
          LOBYTE(v5) = --v32;
          if ( !v32 )
            break;
          v19 = v33;
          v22 = v30;
        }
      }
      break;
    default:
      LOBYTE(v5) = sub_4840E0(a1, aIgnoringBadAda);
      *a3 = 0;
      break;
  }
  return v5;
}

//----- (0048AF90) --------------------------------------------------------
char *__usercall sub_48AF90@<eax>(int a1@<ebx>, int a2)
{
  int v2; // esi
  unsigned int v3; // ecx
  char *result; // eax
  char *v5; // ecx
  unsigned int v6; // eax
  unsigned __int8 v7; // bl
  int v8; // ebp
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned __int8 *v12; // edx
  int v13; // eax
  const char *v14; // eax
  int v15; // eax
  unsigned __int8 v16[4]; // [esp+10h] [ebp-4h] BYREF

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 208);
  result = (char *)(*(_DWORD *)(a2 + 228) + 1);
  *(_DWORD *)(a2 + 228) = result;
  if ( (unsigned int)result >= v3 )
  {
    if ( !*(_BYTE *)(v2 + 291) )
      goto LABEL_9;
    v5 = *(char **)(v2 + 232);
    v6 = *(_DWORD *)(v2 + 216) + 1;
    *(_DWORD *)(v2 + 228) = 0;
    result = sub_487E50(a1, v2, v5, 0, v6);
    v7 = *(_BYTE *)(v2 + 292) + 1;
    *(_BYTE *)(v2 + 292) = v7;
    if ( v7 < 7u )
    {
      v8 = *(_DWORD *)(v2 + 112) & 2;
      a2 = *(unsigned __int8 *)(v2 + 297);
      do
      {
        result = (char *)((*(_DWORD *)(v2 + 200) - dword_4B03F8[v7] + dword_4B0414[v7] - 1)
                        / (unsigned int)dword_4B0414[v7]);
        v9 = (_DWORD)result * a2 + 7;
        *(_DWORD *)(v2 + 224) = result;
        *(_DWORD *)(v2 + 220) = (v9 >> 3) + 1;
        if ( v8 )
          break;
        *(_DWORD *)(v2 + 208) = (*(_DWORD *)(v2 + 204) - dword_4B0430[v7] + dword_4B044C[v7] - 1)
                              / (unsigned int)dword_4B044C[v7];
        result = *(char **)(v2 + 224);
        if ( result )
          break;
        *(_BYTE *)(v2 + 292) = ++v7;
      }
      while ( v7 < 7u );
    }
    if ( *(_BYTE *)(v2 + 292) >= 7u )
    {
LABEL_9:
      if ( (*(_BYTE *)(v2 + 108) & 0x20) == 0 )
      {
        *(_DWORD *)(v2 + 132) = 1;
        *(_DWORD *)(v2 + 128) = &a2;
        while ( 1 )
        {
          if ( !*(_DWORD *)(v2 + 120) )
          {
            while ( !*(_DWORD *)(v2 + 268) )
            {
              sub_487F80(v2, 0);
              sub_484380((int *)v2, (int)v16, 4);
              *(_DWORD *)(v2 + 268) = sub_487ED0(v16);
              sub_4845C0(v2);
              sub_487F50((int *)v2, (unsigned __int8 *)(v2 + 284), 4u);
              if ( *(_DWORD *)(v2 + 284) != *(_DWORD *)aIdat )
                sub_484040((int *)v2, aNotEnoughImage);
            }
            v10 = *(_DWORD *)(v2 + 176);
            v11 = *(_DWORD *)(v2 + 268);
            v12 = *(unsigned __int8 **)(v2 + 172);
            *(_DWORD *)(v2 + 120) = v10;
            *(_DWORD *)(v2 + 116) = v12;
            if ( v10 > v11 )
              *(_DWORD *)(v2 + 120) = v11;
            sub_487F50((int *)v2, v12, *(_DWORD *)(v2 + 120));
            *(_DWORD *)(v2 + 268) -= *(_DWORD *)(v2 + 120);
          }
          v13 = sub_466C30((unsigned __int8 **)(v2 + 116), 1);
          if ( v13 == 1 )
            break;
          if ( v13 )
          {
            v14 = *(const char **)(v2 + 140);
            if ( !v14 )
              v14 = aDecompressionE_0;
            sub_484040((int *)v2, v14);
          }
          if ( !*(_DWORD *)(v2 + 132) )
          {
            sub_4840E0(v2, aExtraCompresse_0);
            goto LABEL_31;
          }
        }
        if ( !*(_DWORD *)(v2 + 132) || *(_DWORD *)(v2 + 120) || *(_DWORD *)(v2 + 268) )
          sub_4840E0(v2, aExtraCompresse);
LABEL_31:
        v15 = *(_DWORD *)(v2 + 108) | 0x20;
        *(_DWORD *)(v2 + 104) |= 8u;
        *(_DWORD *)(v2 + 108) = v15;
        *(_DWORD *)(v2 + 132) = 0;
      }
      if ( *(_DWORD *)(v2 + 268) || *(_DWORD *)(v2 + 120) )
        sub_4840E0(v2, aExtraCompressi);
      sub_466A60((_DWORD *)(v2 + 116));
      result = (char *)(*(_DWORD *)(v2 + 104) | 8);
      *(_DWORD *)(v2 + 104) = result;
    }
  }
  return result;
}
// 4B0430: using guessed type int dword_4B0430[];

//----- (0048B240) --------------------------------------------------------
int __cdecl sub_48B240(int a1)
{
  int v1; // edi
  unsigned int v2; // eax
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  int v5; // ebx
  int v6; // eax
  char v7; // cl
  char v8; // cl
  int v9; // ecx
  char v10; // cl
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  char *v14; // eax
  int v15; // ecx
  int result; // eax

  *(_DWORD *)(a1 + 120) = 0;
  sub_47F140(a1);
  if ( *(_BYTE *)(a1 + 291) )
  {
    if ( (*(_BYTE *)(a1 + 112) & 2) != 0 )
      *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
    else
      *(_DWORD *)(a1 + 208) = (unsigned int)(*(_DWORD *)(a1 + 204) - dword_4B0430[0] + dword_4B044C[0] - 1)
                            / dword_4B044C[0];
    v1 = *(_DWORD *)(a1 + 200);
    v2 = (v1 - dword_4B03F8[*(unsigned __int8 *)(a1 + 292)] + dword_4B0414[*(unsigned __int8 *)(a1 + 292)] - 1)
       / (unsigned int)dword_4B0414[*(unsigned __int8 *)(a1 + 292)];
    v3 = v2 * *(unsigned __int8 *)(a1 + 297) + 7;
    *(_DWORD *)(a1 + 224) = v2;
    v4 = v3 >> 3;
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 200);
    v4 = *(_DWORD *)(a1 + 216);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 224) = v1;
  }
  v5 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 220) = v4 + 1;
  v6 = *(unsigned __int8 *)(a1 + 297);
  if ( (v5 & 4) != 0 && *(_BYTE *)(a1 + 295) < 8u )
    v6 = 8;
  if ( (v5 & 0x1000) != 0 )
  {
    v7 = *(_BYTE *)(a1 + 294);
    if ( v7 == 3 )
    {
      v6 = *(_WORD *)(a1 + 282) != 0 ? 32 : 24;
    }
    else if ( v7 )
    {
      if ( v7 == 2 && *(_WORD *)(a1 + 282) )
        v6 = 4 * v6 / 3;
    }
    else
    {
      if ( v6 < 8 )
        v6 = 8;
      if ( *(_WORD *)(a1 + 282) )
        v6 *= 2;
    }
  }
  if ( (v5 & 0x8000) != 0 )
  {
    v8 = *(_BYTE *)(a1 + 294);
    if ( v8 == 3 )
    {
      v6 = 32;
      goto LABEL_29;
    }
    if ( v8 )
    {
      if ( v8 != 2 )
        goto LABEL_29;
      v9 = v6 > 32 ? 64 : 32;
    }
    else
    {
      v9 = v6 > 8 ? 32 : 16;
    }
    v6 = v9;
  }
LABEL_29:
  if ( (v5 & 0x4000) != 0 )
  {
    if ( *(_WORD *)(a1 + 282) && (v5 & 0x1000) != 0 || (v5 & 0x8000) != 0 || (v10 = *(_BYTE *)(a1 + 294), v10 == 4) )
    {
      v6 = v6 > 16 ? 64 : 32;
    }
    else
    {
      if ( v6 > 8 )
        v11 = v10 != 6 ? 48 : 64;
      else
        v11 = v10 != 6 ? 24 : 32;
      v6 = v11;
    }
  }
  if ( (v5 & 0x100000) != 0 )
  {
    v12 = *(unsigned __int8 *)(a1 + 100);
    if ( v12 * *(unsigned __int8 *)(a1 + 101) > v6 )
      v6 = v12 * *(unsigned __int8 *)(a1 + 101);
  }
  v13 = sub_487D00((int *)a1, ((v6 * ((v1 + 7) & 0xFFFFFFF8) + 7) >> 3) + ((v6 + 7) >> 3) + 65);
  *(_DWORD *)(a1 + 592) = v13;
  *(_DWORD *)(a1 + 236) = v13 + 32;
  v14 = (char *)sub_487D00((int *)a1, *(_DWORD *)(a1 + 216) + 1);
  v15 = *(_DWORD *)(a1 + 216);
  *(_DWORD *)(a1 + 232) = v14;
  sub_487E50(v5, a1, v14, 0, v15 + 1);
  result = *(_DWORD *)(a1 + 108);
  LOBYTE(result) = result | 0x40;
  *(_DWORD *)(a1 + 108) = result;
  return result;
}
// 4B0430: using guessed type int dword_4B0430[];

//----- (0048B4B0) --------------------------------------------------------
int __cdecl png_save_uint_32(_BYTE *a1, int a2)
{
  int result; // eax

  result = a2;
  *a1 = HIBYTE(a2);
  a1[1] = BYTE2(a2);
  a1[2] = BYTE1(a2);
  a1[3] = a2;
  return result;
}

//----- (0048B4E0) --------------------------------------------------------
int __cdecl sub_48B4E0(_BYTE *a1, int a2)
{
  int result; // eax

  result = a2;
  *a1 = HIBYTE(a2);
  a1[1] = BYTE2(a2);
  a1[2] = BYTE1(a2);
  a1[3] = a2;
  return result;
}

//----- (0048B510) --------------------------------------------------------
int __cdecl sub_48B510(_BYTE *a1, int a2)
{
  int result; // eax

  result = a2;
  *a1 = BYTE1(a2);
  a1[1] = a2;
  return result;
}

//----- (0048B530) --------------------------------------------------------
int __cdecl sub_48B530(int *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  sub_48B560(a1, a2, a4);
  sub_48B5B0(a1, a3, a4);
  return sub_48B5E0(a1);
}

//----- (0048B560) --------------------------------------------------------
int __cdecl sub_48B560(int *a1, unsigned __int8 *a2, int a3)
{
  png_save_uint_32(&a3, a3);
  sub_487AD0(a1, (int)&a3, 4);
  sub_487AD0(a1, (int)a2, 4);
  sub_4845C0((int)a1);
  return sub_4845E0((int)a1, a2, 4u);
}

//----- (0048B5B0) --------------------------------------------------------
int __cdecl sub_48B5B0(int *a1, unsigned __int8 *a2, unsigned int a3)
{
  int result; // eax

  if ( a2 )
  {
    if ( a3 )
    {
      sub_4845E0((int)a1, a2, a3);
      result = sub_487AD0(a1, (int)a2, a3);
    }
  }
  return result;
}

//----- (0048B5E0) --------------------------------------------------------
int __cdecl sub_48B5E0(int *a1)
{
  int *v1; // esi

  v1 = a1;
  png_save_uint_32(&a1, a1[68]);
  return sub_487AD0(v1, (int)&a1, 4);
}

//----- (0048B610) --------------------------------------------------------
char __cdecl sub_48B610(int a1)
{
  int v1; // eax
  int v2; // eax
  char v4[8]; // [esp+4h] [ebp-8h] BYREF

  v4[5] = 10;
  v4[7] = 10;
  v1 = *(unsigned __int8 *)(a1 + 300);
  v4[0] = -119;
  v4[1] = 80;
  v4[2] = 78;
  v4[3] = 71;
  v4[4] = 13;
  v4[6] = 26;
  sub_487AD0((int *)a1, (int)&v4[v1], 8 - v1);
  LOBYTE(v2) = *(_BYTE *)(a1 + 300);
  if ( (unsigned __int8)v2 < 3u )
  {
    v2 = *(_DWORD *)(a1 + 104);
    BYTE1(v2) |= 0x10u;
    *(_DWORD *)(a1 + 104) = v2;
  }
  return v2;
}

//----- (0048B680) --------------------------------------------------------
int __cdecl sub_48B680(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  char v9; // al
  char v10; // dl
  char v11; // al
  int v12; // eax
  int result; // eax
  const char *v14; // [esp-4h] [ebp-20h]
  unsigned __int8 v15[4]; // [esp+Ch] [ebp-10h] BYREF
  char v16[12]; // [esp+10h] [ebp-Ch] BYREF

  switch ( a5 )
  {
    case 0:
      switch ( a4 )
      {
        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
          goto LABEL_9;
        default:
          v14 = aInvalidBitDept_0;
          goto LABEL_20;
      }
    case 2:
      v8 = a1;
      if ( a4 != 8 && a4 != 16 )
        sub_484040((int *)a1, aInvalidBitDept_1);
      *(_BYTE *)(a1 + 298) = 3;
      break;
    case 3:
      switch ( a4 )
      {
        case 1:
        case 2:
        case 4:
        case 8:
LABEL_9:
          v8 = a1;
          *(_BYTE *)(a1 + 298) = 1;
          goto LABEL_21;
        default:
          v14 = aInvalidBitDept_2;
          goto LABEL_20;
      }
    case 4:
      v8 = a1;
      if ( a4 != 8 && a4 != 16 )
        sub_484040((int *)a1, aInvalidBitDept_3);
      *(_BYTE *)(a1 + 298) = 2;
      break;
    case 6:
      v8 = a1;
      if ( a4 != 8 && a4 != 16 )
        sub_484040((int *)a1, aInvalidBitDept_4);
      *(_BYTE *)(a1 + 298) = 4;
      break;
    default:
      v14 = aInvalidImageCo;
LABEL_20:
      sub_484040((int *)a1, v14);
  }
LABEL_21:
  if ( a6 )
  {
    sub_4840E0(v8, aInvalidCompres);
    LOBYTE(a6) = 0;
  }
  if ( ((*(_BYTE *)(v8 + 560) & 4) == 0 || (*(_DWORD *)(v8 + 104) & 0x1000) != 0 || a5 != 2 && a5 != 6 || a7 != 64)
    && a7 )
  {
    sub_4840E0(v8, aInvalidFilterT);
    LOBYTE(a7) = 0;
  }
  v9 = a8;
  if ( a8 && a8 != 1 )
  {
    sub_4840E0(v8, aInvalidInterla);
    LOBYTE(a8) = 1;
    v9 = 1;
  }
  *(_BYTE *)(v8 + 291) = v9;
  *(_BYTE *)(v8 + 294) = a5;
  v10 = *(_BYTE *)(v8 + 298);
  *(_BYTE *)(v8 + 568) = a7;
  *(_BYTE *)(v8 + 297) = a4 * v10;
  *(_DWORD *)(v8 + 200) = a2;
  *(_DWORD *)(v8 + 212) = a2;
  *(_BYTE *)(v8 + 295) = a4;
  *(_DWORD *)(v8 + 204) = a3;
  *(_DWORD *)(v8 + 216) = (a2 * (unsigned int)(unsigned __int8)(a4 * v10) + 7) >> 3;
  *(_BYTE *)(v8 + 296) = a4;
  *(_BYTE *)(v8 + 299) = v10;
  png_save_uint_32(v15, a2);
  png_save_uint_32(v16, a3);
  v16[6] = a6;
  v16[5] = a5;
  v16[4] = a4;
  v16[7] = a7;
  v16[8] = a8;
  sub_48B530((int *)v8, (unsigned __int8 *)aIhdr, v15, 0xDu);
  v11 = *(_BYTE *)(v8 + 293);
  *(_DWORD *)(v8 + 148) = sub_484520;
  *(_DWORD *)(v8 + 152) = sub_4845A0;
  *(_DWORD *)(v8 + 156) = v8;
  if ( !v11 )
  {
    if ( *(_BYTE *)(v8 + 294) == 3 || *(_BYTE *)(v8 + 295) < 8u )
      *(_BYTE *)(v8 + 293) = 8;
    else
      *(_BYTE *)(v8 + 293) = -8;
  }
  v12 = *(_DWORD *)(v8 + 108);
  if ( (v12 & 1) == 0 )
    *(_DWORD *)(v8 + 196) = *(_BYTE *)(v8 + 293) != 8;
  if ( (v12 & 2) == 0 )
    *(_DWORD *)(v8 + 180) = -1;
  if ( (v12 & 4) == 0 )
    *(_DWORD *)(v8 + 192) = 8;
  if ( (v12 & 8) == 0 )
    *(_DWORD *)(v8 + 188) = 15;
  if ( (v12 & 0x10) == 0 )
    *(_DWORD *)(v8 + 184) = 8;
  sub_467220(
    (_DWORD *)(v8 + 116),
    *(_DWORD *)(v8 + 180),
    *(_DWORD *)(v8 + 184),
    *(_DWORD *)(v8 + 188),
    *(_DWORD *)(v8 + 192),
    *(_DWORD *)(v8 + 196),
    a114,
    56);
  result = *(_DWORD *)(v8 + 176);
  *(_DWORD *)(v8 + 128) = *(_DWORD *)(v8 + 172);
  *(_DWORD *)(v8 + 132) = result;
  *(_DWORD *)(v8 + 104) = 1;
  return result;
}

//----- (0048BA00) --------------------------------------------------------
int __cdecl sub_48BA00(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ebp
  int *v4; // edi
  int result; // eax
  char *v6; // esi
  char v7; // al
  char v8; // cl
  int v9; // [esp-8h] [ebp-10h]
  char *v10; // [esp-4h] [ebp-Ch]

  v3 = a3;
  v4 = (int *)a1;
  if ( (*(_BYTE *)(a1 + 560) & 1) == 0 && !a3 || a3 > 0x100 )
  {
    v10 = aInvalidNumberO;
    v9 = a1;
    if ( *(_BYTE *)(a1 + 294) == 3 )
      sub_484040((int *)a1, aInvalidNumberO);
    return sub_4840E0(v9, v10);
  }
  if ( (*(_BYTE *)(a1 + 294) & 2) == 0 )
  {
    v10 = aIgnoringReques;
    v9 = a1;
    return sub_4840E0(v9, v10);
  }
  *(_WORD *)(a1 + 280) = a3;
  sub_48B560(v4, (unsigned __int8 *)aPlte, 3 * v3);
  if ( v3 )
  {
    v6 = (char *)(a2 + 2);
    do
    {
      v7 = *(v6 - 1);
      v8 = *v6;
      LOBYTE(a1) = *(v6 - 2);
      BYTE1(a1) = v7;
      BYTE2(a1) = v8;
      sub_48B5B0(v4, (unsigned __int8 *)&a1, 3u);
      v6 += 3;
      --v3;
    }
    while ( v3 );
  }
  sub_48B5E0(v4);
  result = v4[26];
  LOBYTE(result) = result | 2;
  v4[26] = result;
  return result;
}

//----- (0048BAC0) --------------------------------------------------------
int __cdecl sub_48BAC0(int *a1, unsigned __int8 *a2, unsigned int a3)
{
  int result; // eax

  sub_48B530(a1, (unsigned __int8 *)aIdat, a2, a3);
  result = a1[26];
  LOBYTE(result) = result | 4;
  a1[26] = result;
  return result;
}

//----- (0048BAF0) --------------------------------------------------------
int __cdecl sub_48BAF0(int *a1)
{
  int result; // eax

  sub_48B530(a1, (unsigned __int8 *)aIend, 0, 0);
  result = a1[26];
  LOBYTE(result) = result | 0x10;
  a1[26] = result;
  return result;
}

//----- (0048BB20) --------------------------------------------------------
int __cdecl sub_48BB20(int a1, double a2)
{
  png_save_uint_32(&a2, (__int64)(a2 * dbl_4B02E8 + dbl_4AD770));
  return sub_48B530((int *)a1, (unsigned __int8 *)aGama, (unsigned __int8 *)&a2, 4u);
}
// 4AD770: using guessed type double dbl_4AD770;
// 4B02E8: using guessed type double dbl_4B02E8;

//----- (0048BB90) --------------------------------------------------------
int __cdecl sub_48BB90(int *a1, int a2)
{
  char v2; // bl

  v2 = a2;
  if ( a2 >= 4 )
    sub_4840E0((int)a1, aInvalidSrgbRen);
  LOBYTE(a2) = v2;
  return sub_48B530(a1, (unsigned __int8 *)aSrgb, (unsigned __int8 *)&a2, 1u);
}

//----- (0048BBD0) --------------------------------------------------------
void __cdecl sub_48BBD0(int *a1, unsigned __int8 *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebx
  int v6; // esi
  _DWORD v7[5]; // [esp+8h] [ebp-14h] BYREF

  if ( a2 && (v5 = sub_48CA90(a1, (const char *)a2, (unsigned int *)&a2)) != 0 )
  {
    if ( a3 )
      sub_4840E0((int)a1, aUnknownCompres_3);
    if ( a4 )
    {
      v6 = a5;
      if ( a5 )
        v6 = sub_48BCB0((int)a1, a4, a5, 0, v7);
    }
    else
    {
      v6 = 0;
    }
    sub_48B560(a1, (unsigned __int8 *)aIccp, v5 + v6 + 2);
    a2[v5 + 1] = 0;
    sub_48B5B0(a1, a2, v5 + 2);
    if ( v6 )
      sub_48BF70((int)a1, (int)v7);
    sub_48B5E0(a1);
    sub_487DA0((int)a1, (unsigned int)a2);
  }
  else
  {
    sub_4840E0((int)a1, aEmptyKeywordIn);
  }
}

//----- (0048BCB0) --------------------------------------------------------
int __cdecl sub_48BCB0(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int result; // eax
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // edi
  const void *v10; // esi
  int v11; // eax
  void *v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // edi
  const void *v17; // esi
  int v18; // eax
  void *v19; // eax
  int v20; // edx
  unsigned int v21; // ecx
  unsigned int v22; // ebx
  char Buffer[52]; // [esp+4h] [ebp-34h] BYREF

  a5[3] = 0;
  a5[2] = 0;
  a5[4] = 0;
  *a5 = 0;
  if ( a4 == -1 )
  {
    *a5 = a2;
    result = a3;
    a5[1] = a3;
  }
  else
  {
    if ( a4 >= 3 )
    {
      sprintf_0(Buffer, "Unknown compression type %d", a4);
      sub_4840E0(a1, Buffer);
    }
    v6 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)(a1 + 120) = a3;
    v7 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)(a1 + 116) = a2;
    *(_DWORD *)(a1 + 132) = v6;
    *(_DWORD *)(a1 + 128) = v7;
    do
    {
      if ( sub_467670(a1 + 116, 0) )
      {
        if ( *(_DWORD *)(a1 + 140) )
          sub_484040((int *)a1, *(const char **)(a1 + 140));
        sub_484040((int *)a1, aZlibError);
      }
      if ( !*(_DWORD *)(a1 + 132) )
      {
        if ( !*(_DWORD *)(a1 + 120) )
          break;
        v8 = a5[2];
        v9 = a5[3];
        if ( v8 >= v9 )
        {
          v10 = (const void *)a5[4];
          v11 = v8 + 4;
          a5[3] = v11;
          if ( v10 )
          {
            v12 = (void *)sub_487D00((int *)a1, 4 * v11);
            a5[4] = v12;
            qmemcpy(v12, v10, 4 * v9);
            sub_487DA0(a1, (unsigned int)v10);
          }
          else
          {
            a5[4] = sub_487D00((int *)a1, 4 * v11);
          }
        }
        *(_DWORD *)(a5[4] + 4 * a5[2]) = sub_487D00((int *)a1, *(_DWORD *)(a1 + 176));
        qmemcpy(*(void **)(a5[4] + 4 * a5[2]++), *(const void **)(a1 + 172), *(_DWORD *)(a1 + 176));
        v13 = *(_DWORD *)(a1 + 172);
        *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 176);
        *(_DWORD *)(a1 + 128) = v13;
      }
    }
    while ( *(_DWORD *)(a1 + 120) );
    while ( 1 )
    {
      v14 = sub_467670(a1 + 116, 4);
      if ( v14 )
        break;
      if ( !*(_DWORD *)(a1 + 132) )
      {
        v15 = a5[2];
        v16 = a5[3];
        if ( v15 >= v16 )
        {
          v17 = (const void *)a5[4];
          v18 = v15 + 4;
          a5[3] = v18;
          if ( v17 )
          {
            v19 = (void *)sub_487D00((int *)a1, 4 * v18);
            a5[4] = v19;
            qmemcpy(v19, v17, 4 * v16);
            sub_487DA0(a1, (unsigned int)v17);
          }
          else
          {
            a5[4] = sub_487D00((int *)a1, 4 * v18);
          }
        }
        *(_DWORD *)(a5[4] + 4 * a5[2]) = sub_487D00((int *)a1, *(_DWORD *)(a1 + 176));
        qmemcpy(*(void **)(a5[4] + 4 * a5[2]++), *(const void **)(a1 + 172), *(_DWORD *)(a1 + 176));
        v20 = *(_DWORD *)(a1 + 172);
        *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 176);
        *(_DWORD *)(a1 + 128) = v20;
      }
    }
    if ( v14 != 1 )
    {
      if ( *(_DWORD *)(a1 + 140) )
        sub_484040((int *)a1, *(const char **)(a1 + 140));
      sub_484040((int *)a1, aZlibError);
    }
    v21 = *(_DWORD *)(a1 + 176);
    v22 = *(_DWORD *)(a1 + 132);
    result = v21 * a5[2];
    if ( v22 < v21 )
      result += v21 - v22;
  }
  return result;
}

//----- (0048BF70) --------------------------------------------------------
int __cdecl sub_48BF70(int a1, int a2)
{
  int i; // edi
  unsigned int v4; // ecx
  unsigned int v5; // eax

  if ( *(_DWORD *)a2 )
    return sub_48B5B0((int *)a1, *(unsigned __int8 **)a2, *(_DWORD *)(a2 + 4));
  for ( i = 0; i < *(_DWORD *)(a2 + 8); ++i )
  {
    sub_48B5B0((int *)a1, *(unsigned __int8 **)(*(_DWORD *)(a2 + 16) + 4 * i), *(_DWORD *)(a1 + 176));
    sub_487DA0(a1, *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * i));
    *(_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * i) = 0;
  }
  if ( *(_DWORD *)(a2 + 12) )
    sub_487DA0(a1, *(_DWORD *)(a2 + 16));
  *(_DWORD *)(a2 + 16) = 0;
  v4 = *(_DWORD *)(a1 + 132);
  v5 = *(_DWORD *)(a1 + 176);
  if ( v4 < v5 )
    sub_48B5B0((int *)a1, *(unsigned __int8 **)(a1 + 172), v5 - v4);
  return sub_467520((_DWORD *)(a1 + 116));
}

//----- (0048C030) --------------------------------------------------------
void __cdecl sub_48C030(int *a1, unsigned int a2)
{
  unsigned int v2; // edi
  int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // ebp
  unsigned __int16 *v6; // esi
  unsigned int v7; // [esp+10h] [ebp-10h]
  unsigned __int8 v8[2]; // [esp+14h] [ebp-Ch] BYREF
  char v9[2]; // [esp+16h] [ebp-Ah] BYREF
  char v10[2]; // [esp+18h] [ebp-8h] BYREF
  char v11[2]; // [esp+1Ah] [ebp-6h] BYREF
  char v12[4]; // [esp+1Ch] [ebp-4h] BYREF

  v2 = a2;
  v7 = *(_BYTE *)(a2 + 4) != 8 ? 10 : 6;
  v3 = *(_DWORD *)(a2 + 12) * v7;
  if ( *(_DWORD *)a2 && (v4 = sub_48CA90(a1, *(const char **)a2, &a2), (v5 = v4) != 0) )
  {
    sub_48B560(a1, (unsigned __int8 *)aSplt, v3 + v4 + 2);
    sub_48B5B0(a1, (unsigned __int8 *)a2, v5 + 1);
    sub_48B5B0(a1, (unsigned __int8 *)(v2 + 4), 1u);
    v6 = *(unsigned __int16 **)(v2 + 8);
    if ( v6 < &v6[5 * *(_DWORD *)(v2 + 12)] )
    {
      do
      {
        if ( *(_BYTE *)(v2 + 4) == 8 )
        {
          v8[0] = *(_BYTE *)v6;
          v8[1] = *((_BYTE *)v6 + 2);
          v9[0] = *((_BYTE *)v6 + 4);
          v9[1] = *((_BYTE *)v6 + 6);
          sub_48B510(v10, v6[4]);
        }
        else
        {
          sub_48B510(v8, *v6);
          sub_48B510(v9, v6[1]);
          sub_48B510(v10, v6[2]);
          sub_48B510(v11, v6[3]);
          sub_48B510(v12, v6[4]);
        }
        sub_48B5B0(a1, v8, v7);
        v6 += 5;
      }
      while ( (unsigned int)v6 < *(_DWORD *)(v2 + 8) + 10 * *(_DWORD *)(v2 + 12) );
    }
    sub_48B5E0(a1);
    sub_487DA0((int)a1, a2);
  }
  else
  {
    sub_4840E0((int)a1, aEmptyKeywordIn_0);
  }
}

//----- (0048C1B0) --------------------------------------------------------
int __cdecl sub_48C1B0(int a1, _BYTE *a2, int a3)
{
  char v3; // cl
  int v4; // edi
  unsigned __int8 v5; // bl
  _BYTE *v6; // esi
  unsigned __int8 v7; // dl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // al
  unsigned int v10; // eax
  unsigned __int8 v11; // al
  unsigned __int8 v12; // cl

  v3 = a3;
  if ( (a3 & 2) != 0 )
  {
    v4 = a1;
    v5 = 8;
    if ( a3 != 3 )
      v5 = *(_BYTE *)(a1 + 296);
    v6 = a2;
    v7 = *a2;
    if ( !*a2 )
      return sub_4840E0(v4, aInvalidSbitDep);
    if ( v7 > v5 )
      return sub_4840E0(v4, aInvalidSbitDep);
    v8 = a2[1];
    if ( !v8 )
      return sub_4840E0(v4, aInvalidSbitDep);
    if ( v8 > v5 )
      return sub_4840E0(v4, aInvalidSbitDep);
    v9 = a2[2];
    if ( !v9 || v9 > v5 )
      return sub_4840E0(v4, aInvalidSbitDep);
    BYTE1(a2) = a2[1];
    v3 = a3;
    BYTE2(a2) = v9;
    LOBYTE(a2) = v7;
    v10 = 3;
  }
  else
  {
    v6 = a2;
    v4 = a1;
    v11 = a2[3];
    if ( !v11 || v11 > *(_BYTE *)(a1 + 296) )
      return sub_4840E0(v4, aInvalidSbitDep);
    LOBYTE(a2) = a2[3];
    v10 = 1;
  }
  if ( (v3 & 4) == 0 )
    return sub_48B530((int *)v4, (unsigned __int8 *)aSbit, (unsigned __int8 *)&a2, v10);
  v12 = v6[4];
  if ( v12 && v12 <= *(_BYTE *)(v4 + 296) )
  {
    *((_BYTE *)&a2 + v10++) = v12;
    return sub_48B530((int *)v4, (unsigned __int8 *)aSbit, (unsigned __int8 *)&a2, v10);
  }
  return sub_4840E0(v4, aInvalidSbitDep);
}

//----- (0048C270) --------------------------------------------------------
int __cdecl sub_48C270(int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int result; // eax
  unsigned __int8 v10[4]; // [esp+0h] [ebp-20h] BYREF
  char v11[4]; // [esp+4h] [ebp-1Ch] BYREF
  char v12[4]; // [esp+8h] [ebp-18h] BYREF
  char v13[4]; // [esp+Ch] [ebp-14h] BYREF
  char v14[4]; // [esp+10h] [ebp-10h] BYREF
  char v15[4]; // [esp+14h] [ebp-Ch] BYREF
  char v16[4]; // [esp+18h] [ebp-8h] BYREF
  char v17[4]; // [esp+1Ch] [ebp-4h] BYREF

  if ( a2 < dbl_4A91B8 || a2 > dbl_4B0500 || a3 < dbl_4A91B8 || a3 > dbl_4B0500 || a2 + a3 > dbl_4A91C8 )
  {
    sub_4840E0(a1, aInvalidChrmWhi_0);
    result = fprintf(&Stream, "white_x=%f, white_y=%f\n", a2, a3);
  }
  else
  {
    png_save_uint_32(v10, (__int64)(a2 * dbl_4B02E8 + dbl_4AD770));
    png_save_uint_32(v11, (__int64)(a3 * dbl_4B02E8 + dbl_4AD770));
    if ( a4 < dbl_4A91B8 || a4 > dbl_4B0500 || a5 < dbl_4A91B8 || a5 > dbl_4B0500 || a4 + a5 > dbl_4A91C8 )
    {
      result = sub_4840E0(a1, aInvalidChrmRed_0);
    }
    else
    {
      png_save_uint_32(v12, (__int64)(a4 * dbl_4B02E8 + dbl_4AD770));
      png_save_uint_32(v13, (__int64)(a5 * dbl_4B02E8 + dbl_4AD770));
      if ( a6 < dbl_4A91B8 || a6 > dbl_4B0500 || a7 < dbl_4A91B8 || a7 > dbl_4B0500 || a6 + a7 > dbl_4A91C8 )
      {
        result = sub_4840E0(a1, aInvalidChrmGre_0);
      }
      else
      {
        png_save_uint_32(v14, (__int64)(a6 * dbl_4B02E8 + dbl_4AD770));
        png_save_uint_32(v15, (__int64)(a7 * dbl_4B02E8 + dbl_4AD770));
        if ( a8 < dbl_4A91B8 || a8 > dbl_4B0500 || a9 < dbl_4A91B8 || a9 > dbl_4B0500 || a8 + a9 > dbl_4A91C8 )
        {
          result = sub_4840E0(a1, aInvalidChrmBlu_0);
        }
        else
        {
          png_save_uint_32(v16, (__int64)(a8 * dbl_4B02E8 + dbl_4AD770));
          png_save_uint_32(v17, (__int64)(a9 * dbl_4B02E8 + dbl_4AD770));
          result = sub_48B530((int *)a1, (unsigned __int8 *)aChrm, v10, 0x20u);
        }
      }
    }
  }
  return result;
}
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4AD770: using guessed type double dbl_4AD770;
// 4B02E8: using guessed type double dbl_4B02E8;
// 4B0500: using guessed type double dbl_4B0500;

//----- (0048C770) --------------------------------------------------------
int __cdecl sub_48C770(int a1, unsigned __int8 *a2, unsigned __int16 *a3, signed int a4, int a5)
{
  int v5; // eax
  int result; // eax
  unsigned __int8 v7[2]; // [esp+4h] [ebp-8h] BYREF
  char v8[2]; // [esp+6h] [ebp-6h] BYREF
  char v9[4]; // [esp+8h] [ebp-4h] BYREF

  HIWORD(v5) = HIWORD(a5);
  if ( a5 == 3 )
  {
    if ( a4 <= 0 || a4 > *(unsigned __int16 *)(a1 + 280) )
      result = sub_4840E0(a1, aInvalidNumberO_0);
    else
      result = sub_48B530((int *)a1, (unsigned __int8 *)aTrns, a2, a4);
  }
  else if ( a5 )
  {
    if ( a5 == 2 )
    {
      sub_48B510(v7, a3[1]);
      sub_48B510(v8, a3[2]);
      sub_48B510(v9, a3[3]);
      if ( *(_BYTE *)(a1 + 295) == 8 && v7[0] | (unsigned __int8)(v8[0] | v9[0]) )
        result = sub_4840E0(a1, aIgnoringAttemp_2);
      else
        result = sub_48B530((int *)a1, (unsigned __int8 *)aTrns, v7, 6u);
    }
    else
    {
      result = sub_4840E0(a1, aCanTWriteTrnsW);
    }
  }
  else
  {
    LOWORD(v5) = a3[4];
    if ( (unsigned __int16)v5 < 1 << *(_BYTE *)(a1 + 295) )
    {
      sub_48B510(v7, v5);
      result = sub_48B530((int *)a1, (unsigned __int8 *)aTrns, v7, 2u);
    }
    else
    {
      result = sub_4840E0(a1, aIgnoringAttemp_1);
    }
  }
  return result;
}

//----- (0048C8D0) --------------------------------------------------------
int __cdecl sub_48C8D0(int a1, unsigned __int8 *a2, int a3)
{
  unsigned __int16 v3; // cx
  int result; // eax
  int v5; // eax
  unsigned __int8 v6[2]; // [esp+8h] [ebp-8h] BYREF
  char v7[2]; // [esp+Ah] [ebp-6h] BYREF
  char v8[4]; // [esp+Ch] [ebp-4h] BYREF

  if ( a3 == 3 )
  {
    v3 = *(_WORD *)(a1 + 280);
    if ( !v3 && (*(_BYTE *)(a1 + 560) & 1) != 0 || *a2 <= v3 )
    {
      v6[0] = *a2;
      result = sub_48B530((int *)a1, (unsigned __int8 *)aBkgd, v6, 1u);
    }
    else
    {
      result = sub_4840E0(a1, aInvalidBackgro);
    }
  }
  else if ( (a3 & 2) != 0 )
  {
    sub_48B510(v6, *((unsigned __int16 *)a2 + 1));
    sub_48B510(v7, *((unsigned __int16 *)a2 + 2));
    sub_48B510(v8, *((unsigned __int16 *)a2 + 3));
    if ( *(_BYTE *)(a1 + 295) == 8 && v6[0] | (unsigned __int8)(v7[0] | v8[0]) )
      result = sub_4840E0(a1, aIgnoringAttemp_3);
    else
      result = sub_48B530((int *)a1, (unsigned __int8 *)aBkgd, v6, 6u);
  }
  else
  {
    v5 = *((unsigned __int16 *)a2 + 4);
    if ( (unsigned __int16)v5 < 1 << *(_BYTE *)(a1 + 295) )
    {
      sub_48B510(v6, v5);
      result = sub_48B530((int *)a1, (unsigned __int8 *)aBkgd, v6, 2u);
    }
    else
    {
      result = sub_4840E0(a1, aIgnoringAttemp_4);
    }
  }
  return result;
}

//----- (0048CA10) --------------------------------------------------------
int __cdecl sub_48CA10(int a1, unsigned __int16 *a2, int a3)
{
  int v3; // ebx
  int *v4; // edi
  unsigned __int16 *v6; // esi

  v3 = a3;
  v4 = (int *)a1;
  if ( a3 > *(unsigned __int16 *)(a1 + 280) )
    return sub_4840E0(a1, aInvalidNumberO_1);
  sub_48B560((int *)a1, (unsigned __int8 *)aHist, 2 * a3);
  if ( v3 > 0 )
  {
    v6 = a2;
    do
    {
      sub_48B510(&a1, *v6);
      sub_48B5B0(v4, (unsigned __int8 *)&a1, 2u);
      ++v6;
      --v3;
    }
    while ( v3 );
  }
  return sub_48B5E0(v4);
}

//----- (0048CA90) --------------------------------------------------------
unsigned int __cdecl sub_48CA90(int *a1, const char *a2, unsigned int *a3)
{
  char *v3; // ebx
  unsigned int v4; // kr04_4
  unsigned int v5; // edi
  int v6; // eax
  char *v7; // esi
  char v8; // al
  char v9; // al
  _BYTE *v10; // esi
  char v11; // al
  char *v12; // esi
  char v13; // al
  char v14; // al
  _BYTE *v15; // ecx
  int i; // edx
  unsigned int result; // eax
  int v18; // [esp+Ch] [ebp-2Ch]
  char Buffer[40]; // [esp+10h] [ebp-28h] BYREF

  v3 = (char *)a2;
  v18 = 0;
  *a3 = 0;
  if ( !a2 || (v4 = strlen(a2) + 1, v5 = v4 - 1, v4 == 1) )
  {
    sub_4840E0((int)a1, aZeroLengthKeyw_0);
    result = 0;
  }
  else
  {
    v6 = sub_487D00(a1, v4 - 1 + 2);
    *a3 = v6;
    v7 = (char *)v6;
    if ( *a2 )
    {
      do
      {
        v8 = *v3;
        if ( *v3 < 32 || v8 == 127 )
        {
          sprintf_0(Buffer, "invalid keyword character 0x%02X", v8);
          sub_4840E0((int)a1, Buffer);
          *v7 = 32;
        }
        else
        {
          *v7 = v8;
        }
        v9 = *++v3;
        ++v7;
      }
      while ( v9 );
    }
    *v7 = 0;
    v10 = (_BYTE *)(*a3 + v5 - 1);
    if ( *v10 == 32 )
    {
      sub_4840E0((int)a1, aTrailingSpaces);
      if ( *v10 == 32 )
      {
        do
        {
          *v10 = 0;
          v11 = *--v10;
          --v5;
        }
        while ( v11 == 32 );
      }
    }
    v12 = (char *)*a3;
    if ( *(_BYTE *)*a3 == 32 )
    {
      sub_4840E0((int)a1, aLeadingSpacesR);
      if ( *v12 == 32 )
      {
        do
        {
          v13 = *++v12;
          --v5;
        }
        while ( v13 == 32 );
      }
    }
    v14 = *v12;
    v15 = (_BYTE *)*a3;
    for ( i = 0; v14; ++v12 )
    {
      if ( v14 == 32 )
      {
        if ( i )
        {
          --v5;
          v18 = 1;
        }
        else
        {
          *v15++ = 32;
          i = 1;
        }
      }
      else
      {
        *v15++ = v14;
        i = 0;
      }
      v14 = v12[1];
    }
    *v15 = 0;
    if ( v18 )
      sub_4840E0((int)a1, aExtraInteriorS);
    if ( v5 )
    {
      if ( v5 > 0x4F )
      {
        sub_4840E0((int)a1, aKeywordLengthM);
        a3[79] = 0;
        v5 = 79;
      }
      result = v5;
    }
    else
    {
      sub_487DA0((int)a1, *a3);
      *a3 = 0;
      sub_4840E0((int)a1, aZeroLengthKeyw);
      result = 0;
    }
  }
  return result;
}
// 48CB9A: conditional instruction was optimized away because of 'al.1==20'

//----- (0048CC40) --------------------------------------------------------
void __cdecl sub_48CC40(int *a1, unsigned __int8 *a2, const char *a3)
{
  unsigned int v3; // ebp
  unsigned __int8 *v4; // edi
  unsigned int v5; // esi

  if ( a2 && (v3 = sub_48CA90(a1, (const char *)a2, (unsigned int *)&a2)) != 0 )
  {
    v4 = (unsigned __int8 *)a3;
    if ( a3 && *a3 )
    {
      v4 = (unsigned __int8 *)a3;
      v5 = strlen(a3);
    }
    else
    {
      v5 = 0;
    }
    sub_48B560(a1, (unsigned __int8 *)aText, v5 + v3 + 1);
    sub_48B5B0(a1, a2, v3 + 1);
    if ( v5 )
      sub_48B5B0(a1, v4, v5);
    sub_48B5E0(a1);
    sub_487DA0((int)a1, (unsigned int)a2);
  }
  else
  {
    sub_4840E0((int)a1, aEmptyKeywordIn_1);
  }
}

//----- (0048CCF0) --------------------------------------------------------
void __cdecl sub_48CCF0(int *a1, unsigned __int8 *a2, const char *a3, int a4, int a5)
{
  int *v5; // esi
  unsigned int v6; // ebx
  int v7; // ebp
  int v8; // ecx
  const char *v9; // edi
  bool v10; // zf
  int v11; // edi
  int v12; // eax
  unsigned __int8 *v13; // [esp+Ch] [ebp-18h] BYREF
  _DWORD v14[5]; // [esp+10h] [ebp-14h] BYREF

  v5 = a1;
  if ( a2 && (v6 = sub_48CA90(a1, (const char *)a2, (unsigned int *)&v13)) != 0 )
  {
    v7 = (int)a3;
    if ( a3 && *a3 && (v8 = -1, a5 != -1) )
    {
      v9 = a3;
      do
      {
        if ( !v8 )
          break;
        v10 = *v9++ == 0;
        --v8;
      }
      while ( !v10 );
      v11 = -v8 - 2;
      sub_487DA0((int)v5, (unsigned int)v13);
      v12 = sub_48BCB0((int)v5, v7, v11, a5, v14);
      sub_48B560(v5, (unsigned __int8 *)aZtxt, v6 + v12 + 2);
      sub_48B5B0(v5, a2, v6 + 1);
      LOBYTE(a1) = a5;
      sub_48B5B0(v5, (unsigned __int8 *)&a1, 1u);
      sub_48BF70((int)v5, (int)v14);
      sub_48B5E0(v5);
    }
    else
    {
      sub_48CC40(v5, v13, a3);
      sub_487DA0((int)v5, (unsigned int)v13);
    }
  }
  else
  {
    sub_4840E0((int)v5, aEmptyKeywordIn_2);
  }
}

//----- (0048CE00) --------------------------------------------------------
int __cdecl sub_48CE00(int *a1, int a2, int a3, int a4)
{
  unsigned __int8 v5[4]; // [esp+8h] [ebp-Ch] BYREF
  char v6[8]; // [esp+Ch] [ebp-8h] BYREF

  if ( a4 >= 2 )
    sub_4840E0((int)a1, aUnrecognizedUn);
  sub_48B4E0(v5, a2);
  sub_48B4E0(v6, a3);
  v6[4] = a4;
  return sub_48B530(a1, (unsigned __int8 *)aOffs, v5, 9u);
}

//----- (0048CE60) --------------------------------------------------------
int __cdecl sub_48CE60(int *a1, const char *a2, int a3, int a4, int a5, int a6, char *a7, unsigned __int8 **a8)
{
  int v9; // ebx
  unsigned int v10; // edi
  int v11; // eax
  int v12; // esi
  unsigned int *v13; // edx
  char *v14; // ecx
  unsigned int v15; // eax
  unsigned __int8 **v16; // esi
  unsigned __int8 *v18; // [esp+10h] [ebp-18h] BYREF
  unsigned int v19; // [esp+14h] [ebp-14h]
  unsigned int v20; // [esp+18h] [ebp-10h]
  unsigned __int8 v21[4]; // [esp+1Ch] [ebp-Ch] BYREF
  char v22[8]; // [esp+20h] [ebp-8h] BYREF
  int v23; // [esp+2Ch] [ebp+4h]
  unsigned int v24; // [esp+30h] [ebp+8h]
  char *i; // [esp+40h] [ebp+18h]

  if ( a5 >= 4 )
    sub_4840E0((int)a1, aUnrecognizedEq);
  v9 = a6;
  v20 = sub_48CA90(a1, a2, (unsigned int *)&v18) + 1;
  v10 = (a6 != 0) + strlen(a7);
  v19 = v10;
  v23 = v10 + v20 + 10;
  v11 = sub_487D00(a1, 4 * a6);
  v12 = 0;
  v24 = v11;
  if ( a6 > 0 )
  {
    v13 = (unsigned int *)v11;
    v14 = (char *)a8 - v11;
    for ( i = (char *)a8 - v11; ; v14 = i )
    {
      v15 = strlen(*(const char **)((char *)v13 + (_DWORD)v14)) + (v12 != v9 - 1);
      *v13 = v15;
      ++v12;
      ++v13;
      v23 += v15;
      if ( v12 >= v9 )
        break;
    }
    v10 = v19;
  }
  sub_48B560(a1, (unsigned __int8 *)aPcal, v23);
  sub_48B5B0(a1, v18, v20);
  sub_48B4E0(v21, a3);
  sub_48B4E0(v22, a4);
  v22[4] = a5;
  v22[5] = v9;
  sub_48B5B0(a1, v21, 0xAu);
  sub_48B5B0(a1, (unsigned __int8 *)a7, v10);
  sub_487DA0((int)a1, (unsigned int)v18);
  if ( v9 > 0 )
  {
    v16 = a8;
    do
    {
      sub_48B5B0(a1, *v16, *(unsigned int *)((char *)v16 + v24 - (_DWORD)a8));
      ++v16;
      --v9;
    }
    while ( v9 );
  }
  sub_487DA0((int)a1, v24);
  return sub_48B5E0(a1);
}

//----- (0048CFD0) --------------------------------------------------------
int __cdecl sub_48CFD0(int *a1, char a2, double a3, double a4)
{
  char Buffer[32]; // [esp+8h] [ebp-40h] BYREF
  char v6[32]; // [esp+28h] [ebp-20h] BYREF

  sprintf_0(Buffer, "%12.12e", a3);
  sprintf_0(v6, "%12.12e", a4);
  sub_48B560(a1, (unsigned __int8 *)aScal, strlen(v6) + 1 + strlen(Buffer) + 1);
  sub_48B5B0(a1, (unsigned __int8 *)&a2, 1u);
  sub_48B5B0(a1, (unsigned __int8 *)Buffer, strlen(Buffer) + 1);
  sub_48B5B0(a1, (unsigned __int8 *)v6, strlen(v6));
  return sub_48B5E0(a1);
}

//----- (0048D090) --------------------------------------------------------
int __cdecl sub_48D090(int *a1, int a2, int a3, int a4)
{
  unsigned __int8 v5[4]; // [esp+8h] [ebp-Ch] BYREF
  char v6[8]; // [esp+Ch] [ebp-8h] BYREF

  if ( a4 >= 2 )
    sub_4840E0((int)a1, aUnrecognizedUn_0);
  png_save_uint_32(v5, a2);
  png_save_uint_32(v6, a3);
  v6[4] = a4;
  return sub_48B530(a1, (unsigned __int8 *)aPhys, v5, 9u);
}

//----- (0048D0F0) --------------------------------------------------------
int __cdecl sub_48D0F0(int *a1, _BYTE *a2)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 v4; // cl
  unsigned __int8 v5; // al
  unsigned __int8 v6; // dl
  unsigned __int8 v8[8]; // [esp+4h] [ebp-8h] BYREF

  v2 = a2[2];
  if ( v2 > 0xCu )
    return sub_4840E0((int)a1, aInvalidTimeSpe);
  if ( !v2 )
    return sub_4840E0((int)a1, aInvalidTimeSpe);
  v3 = a2[3];
  if ( v3 > 0x1Fu || !v3 || a2[4] > 0x17u || a2[6] > 0x3Cu )
    return sub_4840E0((int)a1, aInvalidTimeSpe);
  sub_48B510(v8, *(unsigned __int16 *)a2);
  v4 = a2[4];
  v5 = a2[3];
  v8[2] = a2[2];
  v6 = a2[5];
  v8[4] = v4;
  v8[5] = v6;
  v8[3] = v5;
  v8[6] = a2[6];
  return sub_48B530(a1, (unsigned __int8 *)aTime, v8, 7u);
}

//----- (0048D190) --------------------------------------------------------
unsigned int __cdecl sub_48D190(int a1)
{
  size_t v1; // ebx
  _BYTE *v2; // eax
  _BYTE *v3; // eax
  void *v4; // edi
  _BYTE *v5; // eax
  _BYTE *v6; // eax
  _BYTE *v7; // eax
  unsigned int result; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // edx

  v1 = ((*(_DWORD *)(a1 + 200) * *(unsigned __int8 *)(a1 + 296) * (unsigned int)*(unsigned __int8 *)(a1 + 299) + 7) >> 3)
     + 1;
  v2 = (_BYTE *)sub_487D00((int *)a1, v1);
  *(_DWORD *)(a1 + 236) = v2;
  *v2 = 0;
  if ( (*(_BYTE *)(a1 + 293) & 0x10) != 0 )
  {
    v3 = (_BYTE *)sub_487D00((int *)a1, *(_DWORD *)(a1 + 216) + 1);
    *(_DWORD *)(a1 + 240) = v3;
    *v3 = 1;
  }
  if ( (*(_BYTE *)(a1 + 293) & 0xE0) != 0 )
  {
    v4 = (void *)sub_487D00((int *)a1, v1);
    *(_DWORD *)(a1 + 232) = v4;
    memset(v4, 0, v1);
    if ( (*(_BYTE *)(a1 + 293) & 0x20) != 0 )
    {
      v5 = (_BYTE *)sub_487D00((int *)a1, *(_DWORD *)(a1 + 216) + 1);
      *(_DWORD *)(a1 + 244) = v5;
      *v5 = 2;
    }
    if ( (*(_BYTE *)(a1 + 293) & 0x40) != 0 )
    {
      v6 = (_BYTE *)sub_487D00((int *)a1, *(_DWORD *)(a1 + 216) + 1);
      *(_DWORD *)(a1 + 248) = v6;
      *v6 = 3;
    }
    if ( *(char *)(a1 + 293) < 0 )
    {
      v7 = (_BYTE *)sub_487D00((int *)a1, *(_DWORD *)(a1 + 216) + 1);
      *(_DWORD *)(a1 + 252) = v7;
      *v7 = 4;
    }
  }
  if ( !*(_BYTE *)(a1 + 291) )
  {
    result = *(_DWORD *)(a1 + 200);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(a1 + 204);
    goto LABEL_15;
  }
  result = *(_DWORD *)(a1 + 204);
  if ( (*(_BYTE *)(a1 + 112) & 2) == 0 )
  {
    v9 = *(_DWORD *)(a1 + 200);
    *(_DWORD *)(a1 + 208) = (result - dword_4B0430[0] + dword_4B044C[0] - 1) / dword_4B044C[0];
    result = (unsigned int)(v9 - dword_4B03F8[0] + dword_4B0414[0] - 1) / dword_4B0414[0];
LABEL_15:
    *(_DWORD *)(a1 + 212) = result;
    goto LABEL_16;
  }
  v10 = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(a1 + 208) = result;
  *(_DWORD *)(a1 + 212) = v10;
LABEL_16:
  v11 = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 176);
  *(_DWORD *)(a1 + 128) = v11;
  return result;
}
// 4B0430: using guessed type int dword_4B0430[];

//----- (0048D330) --------------------------------------------------------
char __cdecl sub_48D330(int a1)
{
  unsigned int v1; // ecx
  unsigned int v2; // eax
  char v3; // al
  unsigned __int8 v4; // bl
  int v5; // ebp
  int v6; // ecx
  int v7; // edx
  unsigned int v8; // edi
  int v9; // edx
  int v10; // ecx
  unsigned int v11; // eax
  void *v12; // edi
  int v13; // eax
  int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // eax

  v1 = *(_DWORD *)(a1 + 208);
  v2 = *(_DWORD *)(a1 + 228) + 1;
  *(_DWORD *)(a1 + 228) = v2;
  if ( v2 >= v1 )
  {
    if ( !*(_BYTE *)(a1 + 291) )
      goto LABEL_26;
    v3 = *(_BYTE *)(a1 + 112);
    *(_DWORD *)(a1 + 228) = 0;
    if ( (v3 & 2) != 0 )
    {
      ++*(_BYTE *)(a1 + 292);
    }
    else
    {
      v4 = *(_BYTE *)(a1 + 292) + 1;
      *(_BYTE *)(a1 + 292) = v4;
      if ( v4 < 7u )
      {
        v5 = *(_DWORD *)(a1 + 200);
        do
        {
          v6 = v4;
          v7 = *(_DWORD *)(a1 + 204);
          *(_DWORD *)(a1 + 212) = (v5 - dword_4B03F8[v6] + dword_4B0414[v6] - 1) / (unsigned int)dword_4B0414[v6];
          v8 = dword_4B044C[v6];
          v9 = v7 - dword_4B0430[v6];
          v10 = *(_DWORD *)(a1 + 212);
          v11 = (v9 + v8 - 1) / v8;
          *(_DWORD *)(a1 + 208) = v11;
          if ( v10 && v11 )
            break;
          *(_BYTE *)(a1 + 292) = ++v4;
        }
        while ( v4 < 7u );
      }
    }
    LOBYTE(v2) = *(_BYTE *)(a1 + 292);
    if ( (unsigned __int8)v2 < 7u )
    {
      v12 = *(void **)(a1 + 232);
      if ( v12 )
      {
        LOBYTE(v2) = 0;
        memset(
          v12,
          0,
          ((*(_DWORD *)(a1 + 200) * *(unsigned __int8 *)(a1 + 296) * (unsigned int)*(unsigned __int8 *)(a1 + 299) + 7) >> 3)
        + 1);
      }
    }
    else
    {
LABEL_26:
      while ( 1 )
      {
        v13 = sub_467670(a1 + 116, 4);
        if ( v13 )
          break;
        if ( !*(_DWORD *)(a1 + 132) )
        {
          sub_48BAC0((int *)a1, *(unsigned __int8 **)(a1 + 172), *(_DWORD *)(a1 + 176));
          v14 = *(_DWORD *)(a1 + 176);
          *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
          *(_DWORD *)(a1 + 132) = v14;
        }
      }
      if ( v13 != 1 )
      {
        if ( *(_DWORD *)(a1 + 140) )
          sub_484040((int *)a1, *(const char **)(a1 + 140));
        sub_484040((int *)a1, aZlibError);
      }
      v15 = *(_DWORD *)(a1 + 132);
      v16 = *(_DWORD *)(a1 + 176);
      if ( v15 < v16 )
        sub_48BAC0((int *)a1, *(unsigned __int8 **)(a1 + 172), v16 - v15);
      LOBYTE(v2) = sub_467520((_DWORD *)(a1 + 116));
    }
  }
  return v2;
}
// 4B0430: using guessed type int dword_4B0430[];

//----- (0048D4F0) --------------------------------------------------------
unsigned int __cdecl sub_48D4F0(int a1, _BYTE *a2, int a3)
{
  unsigned int result; // eax
  int v4; // ebx
  unsigned int v5; // ecx
  unsigned int v6; // edx
  char *v7; // edi
  int v8; // ebp
  unsigned int v9; // ecx
  unsigned int v10; // eax
  char *v11; // esi
  char v12; // dl
  unsigned int v13; // ecx
  char *v14; // edi
  char *v15; // esi
  _BYTE *v16; // edi
  int v17; // esi
  unsigned int v18; // eax
  int v19; // ecx
  _BYTE *v20; // eax
  _BYTE *v21; // edi
  int v22; // esi
  unsigned int v23; // eax
  _BYTE *v24; // edi
  unsigned int v25; // eax
  int v26; // esi
  unsigned int v27; // ecx
  unsigned int v28; // [esp+0h] [ebp-4h]
  unsigned int v29; // [esp+0h] [ebp-4h]
  unsigned int v30; // [esp+0h] [ebp-4h]
  unsigned int v31; // [esp+0h] [ebp-4h]
  char *v32; // [esp+8h] [ebp+4h]
  int v33; // [esp+Ch] [ebp+8h]
  int v34; // [esp+Ch] [ebp+8h]
  int v35; // [esp+Ch] [ebp+8h]
  unsigned int i; // [esp+10h] [ebp+Ch]
  _BYTE *v37; // [esp+10h] [ebp+Ch]
  _BYTE *v38; // [esp+10h] [ebp+Ch]
  _BYTE *v39; // [esp+10h] [ebp+Ch]

  result = a3;
  if ( a3 < 6 )
  {
    v4 = a1;
    v5 = *(unsigned __int8 *)(a1 + 11);
    switch ( v5 )
    {
      case 1u:
        v24 = a2;
        v8 = a3;
        v31 = *(_DWORD *)a1;
        v39 = a2;
        v35 = 0;
        v25 = dword_4B03F8[result];
        v26 = 7;
        if ( v25 < *(_DWORD *)a1 )
        {
          do
          {
            v19 = ((((unsigned __int8)v24[v25 >> 3] >> (7 - (v25 & 7))) & 1) << v26) | v35;
            v35 = v19;
            if ( v26 )
            {
              --v26;
            }
            else
            {
              v26 = 7;
              *v39 = v19;
              LOBYTE(v19) = 0;
              ++v39;
              v35 = 0;
            }
            v25 += dword_4B0414[v8];
          }
          while ( v25 < v31 );
          if ( v26 == 7 )
            goto LABEL_32;
          v20 = v39;
          goto LABEL_31;
        }
        break;
      case 2u:
        v21 = a2;
        v8 = a3;
        v30 = *(_DWORD *)a1;
        v38 = a2;
        v22 = 6;
        v23 = dword_4B03F8[result];
        v34 = 0;
        if ( v23 < *(_DWORD *)a1 )
        {
          do
          {
            v19 = ((((unsigned __int8)v21[v23 >> 2] >> (6 - 2 * (v23 & 3))) & 3) << v22) | v34;
            v34 = v19;
            if ( v22 )
            {
              v22 -= 2;
            }
            else
            {
              v22 = 6;
              *v38 = v19;
              LOBYTE(v19) = 0;
              ++v38;
              v34 = 0;
            }
            v23 += dword_4B0414[v8];
          }
          while ( v23 < v30 );
          if ( v22 == 6 )
            goto LABEL_32;
          v20 = v38;
          goto LABEL_31;
        }
        break;
      case 4u:
        v16 = a2;
        v8 = a3;
        v29 = *(_DWORD *)a1;
        v37 = a2;
        v17 = 4;
        v18 = dword_4B03F8[result];
        v33 = 0;
        if ( v18 < *(_DWORD *)a1 )
        {
          do
          {
            v19 = ((((unsigned __int8)v16[v18 >> 1] >> (4 - 4 * (v18 & 1))) & 0xF) << v17) | v33;
            v33 = v19;
            if ( v17 )
            {
              v17 -= 4;
            }
            else
            {
              v17 = 4;
              *v37 = v19;
              LOBYTE(v19) = 0;
              ++v37;
              v33 = 0;
            }
            v18 += dword_4B0414[v8];
          }
          while ( v18 < v29 );
          if ( v17 == 4 )
            goto LABEL_32;
          v20 = v37;
LABEL_31:
          *v20 = v19;
LABEL_32:
          v4 = a1;
          break;
        }
        break;
      default:
        v6 = *(_DWORD *)a1;
        v7 = a2;
        v8 = a3;
        v28 = v6;
        v9 = v5 >> 3;
        v10 = dword_4B03F8[a3];
        v32 = a2;
        for ( i = v9; v10 < v6; v32 = v7 )
        {
          v11 = &a2[v9 * v10];
          if ( v7 != v11 )
          {
            v12 = v9;
            v13 = v9 >> 2;
            qmemcpy(v7, v11, 4 * v13);
            v15 = &v11[4 * v13];
            v14 = &v7[4 * v13];
            LOBYTE(v13) = v12;
            v6 = v28;
            qmemcpy(v14, v15, v13 & 3);
            v9 = i;
            v7 = v32;
          }
          v7 += v9;
          v10 += dword_4B0414[v8];
        }
        break;
    }
    result = (*(_DWORD *)v4 - dword_4B03F8[v8] + dword_4B0414[v8] - 1) / (unsigned int)dword_4B0414[v8];
    v27 = result * *(unsigned __int8 *)(v4 + 11) + 7;
    *(_DWORD *)v4 = result;
    *(_DWORD *)(v4 + 4) = v27 >> 3;
  }
  return result;
}

//----- (0048D780) --------------------------------------------------------
char __cdecl sub_48D780(int a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // ebp
  char v4; // cl
  _BYTE *v5; // esi
  __int64 v6; // rax
  int v7; // edi
  unsigned int v8; // eax
  unsigned int i; // esi
  int v10; // ecx
  int v11; // ecx
  unsigned int v12; // edx
  unsigned int v13; // esi
  int v14; // ebp
  int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // ebp
  char *v18; // esi
  _BYTE *v19; // eax
  char *v20; // ecx
  char v21; // dl
  unsigned int v22; // edi
  char v23; // dl
  unsigned int v24; // edi
  unsigned int v25; // esi
  unsigned int v26; // eax
  int k; // edx
  unsigned __int16 v28; // cx
  int v29; // edx
  unsigned int v30; // ecx
  unsigned int v31; // ebp
  unsigned int v32; // esi
  unsigned int v33; // ecx
  int v34; // edx
  int v35; // edi
  int v36; // edx
  unsigned int v37; // eax
  _BYTE *v38; // edx
  unsigned __int8 *v39; // ecx
  unsigned __int8 *v40; // esi
  unsigned __int8 v41; // al
  int v42; // edi
  unsigned __int8 v43; // al
  int v44; // edi
  unsigned int v45; // edx
  int v46; // ecx
  unsigned int j; // esi
  unsigned __int16 v48; // ax
  int v49; // ecx
  unsigned int v50; // eax
  unsigned int v51; // esi
  _BYTE *v52; // eax
  _BYTE *v53; // ecx
  char v54; // dl
  int v55; // edx
  unsigned int v56; // esi
  unsigned int v57; // ecx
  int v58; // ebp
  int v59; // edx
  unsigned int v60; // eax
  _BYTE *v61; // ecx
  unsigned __int8 *l; // edx
  unsigned __int8 v63; // al
  int v64; // esi
  unsigned int v65; // edx
  unsigned int v66; // edi
  int m; // ecx
  unsigned __int16 v68; // ax
  int v69; // ecx
  unsigned int v70; // eax
  unsigned int v71; // eax
  _BYTE *v72; // ecx
  unsigned __int8 *v73; // ebp
  _BYTE *v74; // edi
  _BYTE *v75; // esi
  int v76; // edx
  unsigned int v77; // esi
  unsigned int v78; // eax
  unsigned __int16 v79; // cx
  int v80; // edx
  unsigned int v81; // ecx
  unsigned __int8 *v82; // ebp
  unsigned __int8 *v83; // ecx
  _BYTE *v84; // edi
  _BYTE *v85; // esi
  unsigned __int8 v86; // al
  int v87; // edx
  __int64 v88; // rax
  unsigned __int8 v89; // al
  int v90; // edx
  int v91; // ecx
  unsigned int v92; // edx
  unsigned int ii; // esi
  unsigned __int16 v94; // ax
  int v95; // ecx
  unsigned int v96; // eax
  unsigned int v97; // ebp
  _BYTE *v98; // ebx
  _BYTE *v99; // esi
  int v100; // edi
  char v101; // dl
  unsigned __int8 *v102; // edi
  int v103; // edx
  int v104; // ebp
  int v105; // eax
  int v106; // ecx
  int v107; // ebp
  int v108; // eax
  _BYTE *v109; // ebp
  unsigned __int8 *v110; // edi
  _BYTE *v111; // edx
  unsigned __int8 v112; // al
  int v113; // ecx
  int v114; // esi
  int v115; // esi
  char v116; // dl
  int v117; // ecx
  int v118; // ebp
  int v119; // eax
  char v120; // cl
  unsigned __int8 v121; // al
  int v122; // ecx
  unsigned int v123; // esi
  unsigned int v124; // edx
  unsigned int v125; // esi
  int n; // ecx
  unsigned __int16 v127; // ax
  int v128; // ecx
  unsigned int v129; // eax
  int jj; // eax
  _BYTE *v131; // ecx
  char v133; // [esp+13h] [ebp-2Dh]
  int v134; // [esp+14h] [ebp-2Ch]
  unsigned int v135; // [esp+18h] [ebp-28h]
  unsigned int v136; // [esp+1Ch] [ebp-24h]
  _BYTE *v137; // [esp+20h] [ebp-20h]
  _BYTE *v138; // [esp+24h] [ebp-1Ch]
  _BYTE *v139; // [esp+24h] [ebp-1Ch]
  _BYTE *v140; // [esp+24h] [ebp-1Ch]
  int v141; // [esp+28h] [ebp-18h]
  char v142; // [esp+28h] [ebp-18h]
  _BYTE *v143; // [esp+28h] [ebp-18h]
  int v144; // [esp+2Ch] [ebp-14h]
  int v145; // [esp+2Ch] [ebp-14h]
  int v146; // [esp+2Ch] [ebp-14h]
  unsigned int v147; // [esp+30h] [ebp-10h]
  unsigned int v148; // [esp+30h] [ebp-10h]
  unsigned int v149; // [esp+30h] [ebp-10h]
  _BYTE *v150; // [esp+30h] [ebp-10h]
  unsigned int v151; // [esp+34h] [ebp-Ch]
  unsigned int v152; // [esp+34h] [ebp-Ch]
  int v153; // [esp+34h] [ebp-Ch]
  int v154; // [esp+34h] [ebp-Ch]
  int v155; // [esp+34h] [ebp-Ch]
  int v156; // [esp+38h] [ebp-8h]
  unsigned int v157; // [esp+38h] [ebp-8h]
  unsigned int v158; // [esp+38h] [ebp-8h]
  int v159; // [esp+38h] [ebp-8h]
  int v160; // [esp+38h] [ebp-8h]
  int v161; // [esp+3Ch] [ebp-4h]
  int v162; // [esp+44h] [ebp+4h]
  unsigned int v163; // [esp+44h] [ebp+4h]
  unsigned int v164; // [esp+44h] [ebp+4h]
  unsigned int v165; // [esp+44h] [ebp+4h]
  unsigned int v166; // [esp+48h] [ebp+8h]
  unsigned int v167; // [esp+48h] [ebp+8h]
  _BYTE *v168; // [esp+48h] [ebp+8h]
  unsigned int v169; // [esp+48h] [ebp+8h]

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_BYTE *)(a1 + 293);
  v134 = *(unsigned __int8 *)(a1 + 505);
  v5 = *(_BYTE **)(a1 + 236);
  v6 = *(unsigned __int8 *)(a2 + 11) + 7;
  v133 = v4;
  v136 = v3;
  v7 = ((BYTE4(v6) & 7) + (int)v6) >> 3;
  v144 = v7;
  v141 = *(_DWORD *)(a1 + 232);
  v138 = v5;
  v137 = v5;
  v135 = 0x7FFFFFFF;
  if ( (v4 & 8) != 0 && v4 != 8 )
  {
    v8 = 0;
    for ( i = 0; i < v3; ++i )
    {
      if ( (unsigned __int8)v138[i + 1] >= 0x80u )
        v10 = 256 - (unsigned __int8)v138[i + 1];
      else
        v10 = (unsigned __int8)v138[i + 1];
      v8 += v10;
    }
    if ( *(_BYTE *)(a1 + 504) == 2 )
    {
      v11 = 0;
      v12 = (unsigned __int16)v8;
      v13 = (v8 >> 10) & 0x3FFFC0;
      if ( *(_BYTE *)(a1 + 505) )
      {
        do
        {
          if ( !*(_BYTE *)(*(_DWORD *)(a1 + 508) + v11) )
          {
            v14 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 512) + 2 * v11);
            v12 = (v12 * v14) >> 8;
            v13 = (v13 * v14) >> 8;
          }
          ++v11;
        }
        while ( v11 < v134 );
      }
      v15 = **(unsigned __int16 **)(a1 + 520);
      v16 = (v13 * (unsigned __int16)v15) >> 3;
      if ( v16 <= 0x3FFFC0 )
        v8 = (v16 << 10) + ((v12 * v15) >> 3);
      else
        v8 = 0x7FFFFFFF;
    }
    v4 = v133;
    v5 = *(_BYTE **)(a1 + 236);
    v135 = v8;
  }
  if ( v4 == 16 )
  {
    v17 = 0;
    v18 = v5 + 1;
    v19 = (_BYTE *)(*(_DWORD *)(a1 + 240) + 1);
    v20 = v18;
    if ( v7 )
    {
      v17 = v7;
      do
      {
        v21 = *v20++;
        *v19++ = v21;
        --v7;
      }
      while ( v7 );
    }
    if ( v17 < v136 )
    {
      v22 = v136 - v17;
      do
      {
        v23 = *v20++ - *v18++;
        *v19++ = v23;
        --v22;
      }
      while ( v22 );
    }
    v137 = *(_BYTE **)(a1 + 240);
  }
  else
  {
    if ( (v4 & 0x10) != 0 )
    {
      v31 = 0;
      v151 = v135;
      if ( *(_BYTE *)(a1 + 504) == 2 )
      {
        v32 = (unsigned __int16)v135;
        v33 = (v135 >> 10) & 0x3FFFC0;
        v34 = 0;
        if ( *(_BYTE *)(a1 + 505) )
        {
          do
          {
            if ( *(_BYTE *)(*(_DWORD *)(a1 + 508) + v34) == 1 )
            {
              v35 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 516) + 2 * v34);
              v32 = (v32 * v35) >> 8;
              v33 = (v33 * v35) >> 8;
            }
            ++v34;
          }
          while ( v34 < v134 );
        }
        v36 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 524) + 2);
        v37 = (v33 * (unsigned __int16)v36) >> 3;
        if ( v37 <= 0x3FFFC0 )
          v151 = (v37 << 10) + ((v32 * v36) >> 3);
        else
          v151 = 0x7FFFFFFF;
      }
      v147 = 0;
      v38 = v138 + 1;
      v39 = (unsigned __int8 *)(*(_DWORD *)(a1 + 240) + 1);
      v40 = v138 + 1;
      if ( v144 )
      {
        v156 = v144;
        v147 = v144;
        do
        {
          v41 = *v40;
          *v39 = *v40;
          if ( v41 >= 0x80u )
            v42 = 256 - v41;
          else
            v42 = v41;
          v31 += v42;
          ++v40;
          ++v39;
          --v156;
        }
        while ( v156 );
      }
      for ( ; v147 < *(_DWORD *)(a2 + 4); ++v147 )
      {
        v43 = *v40 - *v38;
        *v39 = v43;
        if ( v43 >= 0x80u )
          v44 = 256 - v43;
        else
          v44 = v43;
        v31 += v44;
        if ( v31 > v151 )
          break;
        ++v40;
        ++v38;
        ++v39;
      }
      if ( *(_BYTE *)(a1 + 504) == 2 )
      {
        v45 = (unsigned __int16)v31;
        v46 = 0;
        for ( j = (v31 >> 10) & 0x3FFFC0; v46 < v134; ++v46 )
        {
          if ( *(_BYTE *)(v46 + *(_DWORD *)(a1 + 508)) == 1 )
          {
            v48 = *(_WORD *)(*(_DWORD *)(a1 + 516) + 2 * v46);
            v45 = (v48 * v45) >> 8;
            j = (v48 * j) >> 8;
          }
        }
        v49 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 524) + 2);
        v50 = (j * (unsigned __int16)v49) >> 3;
        if ( v50 <= 0x3FFFC0 )
          v31 = (v50 << 10) + ((v45 * v49) >> 3);
        else
          v31 = 0x7FFFFFFF;
      }
      if ( v31 < v135 )
      {
        v135 = v31;
        v137 = *(_BYTE **)(a1 + 240);
      }
    }
    if ( v133 == 32 )
    {
      v51 = 0;
      v52 = (_BYTE *)(*(_DWORD *)(a1 + 244) + 1);
      if ( v136 )
      {
        v53 = (_BYTE *)(v141 + 1);
        do
        {
          v54 = v138[++v51] - *v53++;
          *v52++ = v54;
        }
        while ( v51 < v136 );
      }
      v137 = *(_BYTE **)(a1 + 244);
      goto LABEL_69;
    }
  }
  if ( (v133 & 0x20) != 0 )
  {
    v24 = 0;
    v166 = v135;
    if ( *(_BYTE *)(a1 + 504) == 2 )
    {
      v25 = (unsigned __int16)v135;
      v26 = (v135 >> 10) & 0x3FFFC0;
      for ( k = 0; k < v134; ++k )
      {
        if ( *(_BYTE *)(k + *(_DWORD *)(a1 + 508)) == 2 )
        {
          v28 = *(_WORD *)(*(_DWORD *)(a1 + 516) + 2 * k);
          v25 = (v28 * v25) >> 8;
          v26 = (v28 * v26) >> 8;
        }
      }
      v29 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 524) + 4);
      v30 = (v26 * (unsigned __int16)v29) >> 3;
      if ( v30 <= 0x3FFFC0 )
        v166 = (v30 << 10) + ((v25 * v29) >> 3);
      else
        v166 = 0x7FFFFFFF;
    }
    v157 = 0;
    v61 = v138 + 1;
    for ( l = (unsigned __int8 *)(*(_DWORD *)(a1 + 244) + 1); v157 < v136; ++v157 )
    {
      v63 = *v61 - v61[v141 - (_DWORD)v138];
      *l++ = v63;
      ++v61;
      if ( v63 >= 0x80u )
        v64 = 256 - v63;
      else
        v64 = v63;
      v24 += v64;
      if ( v24 > v166 )
        break;
    }
    if ( *(_BYTE *)(a1 + 504) == 2 )
    {
      v65 = (unsigned __int16)v24;
      v66 = (v24 >> 10) & 0x3FFFC0;
      for ( m = 0; m < v134; ++m )
      {
        if ( *(_BYTE *)(m + *(_DWORD *)(a1 + 508)) == 2 )
        {
          v68 = *(_WORD *)(*(_DWORD *)(a1 + 512) + 2 * m);
          v65 = (v68 * v65) >> 8;
          v66 = (v68 * v66) >> 8;
        }
      }
      v69 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 520) + 4);
      v70 = (v66 * (unsigned __int16)v69) >> 3;
      if ( v70 <= 0x3FFFC0 )
        v24 = (v70 << 10) + ((v65 * v69) >> 3);
      else
        v24 = 0x7FFFFFFF;
    }
    if ( v24 < v135 )
    {
      v135 = v24;
      v137 = *(_BYTE **)(a1 + 244);
    }
  }
  if ( v133 == 64 )
  {
    v71 = 0;
    v72 = (_BYTE *)(*(_DWORD *)(a1 + 248) + 1);
    v73 = v138 + 1;
    v74 = v138 + 1;
    v75 = (_BYTE *)(v141 + 1);
    if ( v144 )
    {
      v162 = v144;
      do
      {
        *v72++ = *v74++ - (*v75++ >> 1);
        --v162;
      }
      while ( v162 );
      v71 = v144;
    }
    if ( v71 < v136 )
    {
      v163 = v136 - v71;
      do
      {
        *v72++ = *v74++ - (*v73++ + (unsigned __int8)*v75++) / 2;
        --v163;
      }
      while ( v163 );
    }
    v137 = *(_BYTE **)(v2 + 248);
LABEL_103:
    if ( v133 < 0 )
    {
      v76 = 0;
      v164 = 0;
      v158 = v135;
      if ( *(_BYTE *)(v2 + 504) == 2 )
      {
        v77 = (unsigned __int16)v135;
        v78 = (v135 >> 10) & 0x3FFFC0;
        if ( v134 > 0 )
        {
          do
          {
            if ( *(_BYTE *)(v76 + *(_DWORD *)(v2 + 508)) == 4 )
            {
              v79 = *(_WORD *)(*(_DWORD *)(v2 + 516) + 2 * v76);
              v77 = (v79 * v77) >> 8;
              v78 = (v79 * v78) >> 8;
            }
            ++v76;
          }
          while ( v76 < v134 );
        }
        v80 = *(unsigned __int16 *)(*(_DWORD *)(v2 + 524) + 8);
        v81 = (v78 * (unsigned __int16)v80) >> 3;
        if ( v81 <= 0x3FFFC0 )
          v158 = (v81 << 10) + ((v77 * v80) >> 3);
        else
          v158 = 0x7FFFFFFF;
      }
      v169 = 0;
      v109 = v138 + 1;
      v110 = (unsigned __int8 *)(*(_DWORD *)(v2 + 252) + 1);
      v139 = v109;
      v150 = v109;
      v111 = (_BYTE *)(v141 + 1);
      if ( v144 )
      {
        v154 = v144;
        v169 = v144;
        do
        {
          v112 = *v109 - *v111;
          *v110++ = v112;
          ++v111;
          ++v109;
          if ( v112 >= 0x80u )
            v113 = 256 - v112;
          else
            v113 = v112;
          v164 += v113;
          --v154;
        }
        while ( v154 );
        v150 = v109;
        v109 = v139;
      }
      if ( v169 >= v136 )
      {
        v123 = v164;
      }
      else
      {
        v114 = v141 + 1 - (_DWORD)v109;
        v155 = v114;
        while ( 1 )
        {
          v143 = v111 + 1;
          v161 = (unsigned __int8)*v111;
          v115 = (unsigned __int8)v109[v114];
          v116 = *v109;
          v117 = (unsigned __int8)*v109 - v115;
          v140 = v109 + 1;
          if ( v161 - v115 >= 0 )
            v146 = v161 - v115;
          else
            v146 = v115 - v161;
          v118 = (unsigned __int8)*v109 - v115;
          if ( v117 < 0 )
            v118 = -v117;
          v119 = v117 + v161 - v115;
          if ( v119 < 0 )
            v119 = -v119;
          if ( v146 > v118 || v146 > v119 )
          {
            v120 = v161;
            if ( v118 > v119 )
              v120 = v115;
          }
          else
          {
            v120 = v116;
          }
          v121 = *v150 - v120;
          *v110++ = v121;
          ++v150;
          v122 = v121 >= 0x80u ? 256 - v121 : v121;
          v123 = v122 + v164;
          v164 += v122;
          if ( v164 > v158 )
            break;
          if ( ++v169 >= v136 )
            break;
          v114 = v155;
          v109 = v140;
          v111 = v143;
        }
      }
      if ( *(_BYTE *)(v2 + 504) == 2 )
      {
        v124 = (unsigned __int16)v123;
        v125 = (v123 >> 10) & 0x3FFFC0;
        for ( n = 0; n < v134; ++n )
        {
          if ( *(_BYTE *)(n + *(_DWORD *)(v2 + 508)) == 4 )
          {
            v127 = *(_WORD *)(*(_DWORD *)(v2 + 512) + 2 * n);
            v124 = (v127 * v124) >> 8;
            v125 = (v127 * v125) >> 8;
          }
        }
        v128 = *(unsigned __int16 *)(*(_DWORD *)(v2 + 520) + 8);
        v129 = (v125 * (unsigned __int16)v128) >> 3;
        if ( v129 <= 0x3FFFC0 )
          v165 = (v129 << 10) + ((v124 * v128) >> 3);
        else
          v165 = 0x7FFFFFFF;
        v123 = v165;
      }
      if ( v123 < v135 )
        v137 = *(_BYTE **)(v2 + 252);
    }
    sub_48E340(v2, (int)v137);
    goto LABEL_196;
  }
LABEL_69:
  if ( (v133 & 0x40) != 0 )
  {
    v55 = 0;
    v167 = 0;
    v152 = v135;
    if ( *(_BYTE *)(a1 + 504) == 2 )
    {
      v56 = (unsigned __int16)v135;
      v57 = (v135 >> 10) & 0x3FFFC0;
      if ( v134 > 0 )
      {
        do
        {
          if ( *(_BYTE *)(v55 + *(_DWORD *)(a1 + 508)) == 3 )
          {
            v58 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 516) + 2 * v55);
            v56 = (v56 * v58) >> 8;
            v57 = (v57 * v58) >> 8;
          }
          ++v55;
        }
        while ( v55 < v134 );
      }
      v59 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 524) + 6);
      v60 = (v57 * (unsigned __int16)v59) >> 3;
      if ( v60 <= 0x3FFFC0 )
        v152 = (v60 << 10) + ((v56 * v59) >> 3);
      else
        v152 = 0x7FFFFFFF;
    }
    v148 = 0;
    v82 = v138 + 1;
    v83 = (unsigned __int8 *)(*(_DWORD *)(a1 + 248) + 1);
    v84 = v138 + 1;
    v85 = (_BYTE *)(v141 + 1);
    if ( v144 )
    {
      v159 = v144;
      v148 = v144;
      do
      {
        v86 = *v84 - (*v85 >> 1);
        *v83++ = v86;
        ++v85;
        ++v84;
        if ( v86 >= 0x80u )
          v87 = 256 - v86;
        else
          v87 = v86;
        v167 += v87;
        --v159;
      }
      while ( v159 );
    }
    for ( ; v148 < v136; ++v148 )
    {
      v88 = (unsigned __int8)*v85 + *v82;
      v89 = *v84 - (((int)v88 - HIDWORD(v88)) >> 1);
      *v83++ = v89;
      ++v82;
      ++v85;
      ++v84;
      if ( v89 >= 0x80u )
        v90 = 256 - v89;
      else
        v90 = v89;
      v167 += v90;
      if ( v167 > v152 )
        break;
    }
    if ( *(_BYTE *)(a1 + 504) == 2 )
    {
      v91 = 0;
      v92 = (unsigned __int16)v167;
      for ( ii = (v167 >> 10) & 0x3FFFC0; v91 < v134; ++v91 )
      {
        if ( !*(_BYTE *)(v91 + *(_DWORD *)(a1 + 508)) )
        {
          v94 = *(_WORD *)(*(_DWORD *)(a1 + 512) + 2 * v91);
          v92 = (v94 * v92) >> 8;
          ii = (v94 * ii) >> 8;
        }
      }
      v95 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 520) + 6);
      v96 = (ii * (unsigned __int16)v95) >> 3;
      if ( v96 <= 0x3FFFC0 )
        v167 = (v96 << 10) + ((v92 * v95) >> 3);
      else
        v167 = 0x7FFFFFFF;
    }
    if ( v167 < v135 )
    {
      v135 = v167;
      v137 = *(_BYTE **)(a1 + 248);
    }
  }
  if ( v133 != (char)0x80 )
    goto LABEL_103;
  v97 = 0;
  v98 = (_BYTE *)(*(_DWORD *)(a1 + 252) + 1);
  v168 = v138 + 1;
  v99 = (_BYTE *)(v141 + 1);
  if ( v144 )
  {
    v100 = v144;
    v97 = v144;
    do
    {
      v101 = *v168 - *v99;
      ++v98;
      ++v99;
      *(v98 - 1) = v101;
      --v100;
      ++v168;
    }
    while ( v100 );
  }
  v102 = v138 + 1;
  if ( v97 < v136 )
  {
    v153 = v141 - (_DWORD)v138;
    v149 = v136 - v97;
    do
    {
      v103 = v102[v153];
      v104 = (unsigned __int8)*v99++;
      v145 = *v102;
      v105 = v104 - v103;
      ++v102;
      v106 = v145 - v103;
      v142 = v104;
      if ( v104 - v103 >= 0 )
        v160 = v104 - v103;
      else
        v160 = v103 - v104;
      v107 = v145 - v103;
      if ( v106 < 0 )
        v107 = v103 - v145;
      v108 = v106 + v105;
      if ( v108 < 0 )
        v108 = -v108;
      if ( v160 > v107 || v160 > v108 )
      {
        if ( v107 <= v108 )
          LOBYTE(v103) = v142;
      }
      else
      {
        LOBYTE(v103) = v145;
      }
      *v98++ = *v168++ - v103;
      --v149;
    }
    while ( v149 );
  }
  v2 = a1;
  v137 = *(_BYTE **)(a1 + 252);
  sub_48E340(a1, (int)v137);
LABEL_196:
  LOBYTE(jj) = *(_BYTE *)(v2 + 505);
  if ( (_BYTE)jj )
  {
    for ( jj = 1; jj < v134; *v131 = *(v131 - 1) )
    {
      v131 = (_BYTE *)(jj + *(_DWORD *)(v2 + 508));
      ++jj;
    }
    *(_BYTE *)(*(_DWORD *)(v2 + 508) + jj) = *v137;
  }
  return jj;
}

//----- (0048E340) --------------------------------------------------------
int (__cdecl *__cdecl sub_48E340(int a1, int a2))(int)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int (__cdecl *result)(int); // eax
  unsigned int v7; // edi

  v2 = *(_DWORD *)(a1 + 260) + 1;
  *(_DWORD *)(a1 + 116) = a2;
  *(_DWORD *)(a1 + 120) = v2;
  do
  {
    if ( sub_467670(a1 + 116, 0) )
    {
      if ( *(_DWORD *)(a1 + 140) )
        sub_484040((int *)a1, *(const char **)(a1 + 140));
      sub_484040((int *)a1, aZlibError);
    }
    if ( !*(_DWORD *)(a1 + 132) )
    {
      sub_48BAC0((int *)a1, *(unsigned __int8 **)(a1 + 172), *(_DWORD *)(a1 + 176));
      v3 = *(_DWORD *)(a1 + 176);
      *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 172);
      *(_DWORD *)(a1 + 132) = v3;
    }
  }
  while ( *(_DWORD *)(a1 + 120) );
  v4 = *(_DWORD *)(a1 + 232);
  if ( v4 )
  {
    v5 = *(_DWORD *)(a1 + 236);
    *(_DWORD *)(a1 + 236) = v4;
    *(_DWORD *)(a1 + 232) = v5;
  }
  sub_48D330(a1);
  result = *(int (__cdecl **)(int))(a1 + 336);
  v7 = *(_DWORD *)(a1 + 340) + 1;
  *(_DWORD *)(a1 + 340) = v7;
  if ( result && v7 >= (unsigned int)result )
    result = sub_485A70(a1);
  return result;
}

//----- (0048E420) --------------------------------------------------------
void __cdecl sub_48E420(int a1)
{
  void (__cdecl *v1)(int, int, int); // eax

  if ( a1 )
  {
    if ( (*(_DWORD *)(a1 + 112) & 0x100000) != 0 )
    {
      v1 = *(void (__cdecl **)(int, int, int))(a1 + 92);
      if ( v1 )
        v1(a1, a1 + 256, *(_DWORD *)(a1 + 236) + 1);
    }
    if ( (BYTE1(*(_DWORD *)(a1 + 112)) & 0x80u) != 0 )
      sub_47E270(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1), *(_DWORD *)(a1 + 108));
    if ( (*(_DWORD *)(a1 + 112) & 0x10000) != 0 )
      sub_47E220((unsigned __int8 *)(a1 + 256), (unsigned __int8 *)(*(_DWORD *)(a1 + 236) + 1));
    if ( (*(_BYTE *)(a1 + 112) & 4) != 0 )
      sub_48E580((int *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), *(unsigned __int8 *)(a1 + 295));
    if ( (*(_BYTE *)(a1 + 112) & 0x10) != 0 )
      sub_47E1F0(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
    if ( (*(_BYTE *)(a1 + 112) & 8) != 0 )
      sub_48E690(a1 + 256, (_BYTE *)(*(_DWORD *)(a1 + 236) + 1), (unsigned __int8 *)(a1 + 385));
    if ( (*(_DWORD *)(a1 + 112) & 0x80000) != 0 )
      sub_48EA30((_BYTE *)(a1 + 256), (_BYTE *)(*(_DWORD *)(a1 + 236) + 1));
    if ( (*(_DWORD *)(a1 + 112) & 0x20000) != 0 )
      sub_48E920((char *)(a1 + 256), (char *)(*(_DWORD *)(a1 + 236) + 1));
    if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
      sub_47E480((int *)(a1 + 256), (char *)(*(_DWORD *)(a1 + 236) + 1));
    if ( (*(_BYTE *)(a1 + 112) & 0x20) != 0 )
      sub_47E160(a1 + 256, (char *)(*(_DWORD *)(a1 + 236) + 1));
  }
}

//----- (0048E580) --------------------------------------------------------
unsigned int __cdecl sub_48E580(int *a1, _BYTE *a2, int a3)
{
  int v3; // esi
  _BYTE *v4; // edi
  int v5; // edx
  _BYTE *v6; // ebp
  int v7; // ecx
  int v8; // esi
  _BYTE *v9; // edi
  int v10; // edx
  _BYTE *v11; // ebp
  int v12; // ecx
  int v13; // edi
  _BYTE *v14; // esi
  char v15; // dl
  _BYTE *v16; // ebp
  int v17; // ecx
  unsigned __int8 v18; // al
  unsigned int result; // eax

  if ( *((_BYTE *)a1 + 9) == 8 && *((_BYTE *)a1 + 10) == 1 )
  {
    switch ( a3 )
    {
      case 1:
        v13 = *a1;
        v14 = a2;
        v15 = 0;
        v16 = a2;
        v17 = 128;
        if ( *a1 )
        {
          do
          {
            if ( *v16 )
              v15 |= v17;
            ++v16;
            if ( v17 <= 1 )
            {
              *v14++ = v15;
              v17 = 128;
              v15 = 0;
            }
            else
            {
              v17 >>= 1;
            }
            --v13;
          }
          while ( v13 );
          if ( v17 != 128 )
            *v14 = v15;
        }
        break;
      case 2:
        v8 = *a1;
        v9 = a2;
        v10 = 0;
        v11 = a2;
        v12 = 6;
        if ( *a1 )
        {
          do
          {
            v10 |= (*v11 & 3) << v12;
            if ( v12 )
            {
              v12 -= 2;
            }
            else
            {
              *v9++ = v10;
              v12 = 6;
              v10 = 0;
            }
            ++v11;
            --v8;
          }
          while ( v8 );
          if ( v12 != 6 )
            *v9 = v10;
        }
        break;
      case 4:
        v3 = *a1;
        v4 = a2;
        v5 = 0;
        v6 = a2;
        v7 = 4;
        if ( *a1 )
        {
          do
          {
            v5 |= (*v6 & 0xF) << v7;
            if ( v7 )
            {
              v7 -= 4;
            }
            else
            {
              *v4++ = v5;
              v7 = 4;
              v5 = 0;
            }
            ++v6;
            --v3;
          }
          while ( v3 );
          if ( v7 != 4 )
            *v4 = v5;
        }
        break;
    }
    *((_BYTE *)a1 + 9) = a3;
    v18 = *((_BYTE *)a1 + 10) * a3;
    *((_BYTE *)a1 + 11) = v18;
    result = (*a1 * (unsigned int)v18 + 7) >> 3;
    a1[1] = result;
  }
  return result;
}

//----- (0048E690) --------------------------------------------------------
int __cdecl sub_48E690(int a1, _BYTE *a2, unsigned __int8 *a3)
{
  int result; // eax
  char v4; // cl
  unsigned __int8 v5; // dl
  unsigned __int8 *v6; // ecx
  int v7; // eax
  unsigned int v8; // ebp
  int v9; // ebx
  int v10; // edi
  int v11; // ebx
  int v12; // esi
  unsigned __int8 v13; // cl
  int v14; // esi
  int v15; // ecx
  unsigned __int16 v16; // bx
  int v17; // esi
  int v18; // ebp
  int v19; // edx
  char v20; // bl
  char v21; // cl
  int v22; // ebx
  _BYTE *v23; // esi
  unsigned int v24; // ecx
  unsigned __int16 v25; // bx
  int v26; // eax
  int v27; // edx
  unsigned __int8 *v28; // edi
  unsigned int v29; // ecx
  int v30; // eax
  __int16 v31; // bx
  int v32; // eax
  int v33; // ecx
  int v34; // ebp
  _BYTE *v35; // edi
  int v36; // [esp+10h] [ebp-28h]
  unsigned int v37; // [esp+10h] [ebp-28h]
  int v38; // [esp+10h] [ebp-28h]
  unsigned int v39; // [esp+14h] [ebp-24h]
  int v40[4]; // [esp+18h] [ebp-20h]
  int v41[4]; // [esp+28h] [ebp-10h]
  char v42; // [esp+3Ch] [ebp+4h]
  int v43; // [esp+3Ch] [ebp+4h]
  int v44; // [esp+3Ch] [ebp+4h]
  int v45; // [esp+40h] [ebp+8h]
  unsigned int v46; // [esp+40h] [ebp+8h]
  unsigned int v47; // [esp+40h] [ebp+8h]
  unsigned int v48; // [esp+44h] [ebp+Ch]
  unsigned __int16 v49; // [esp+44h] [ebp+Ch]
  unsigned __int16 v50; // [esp+44h] [ebp+Ch]

  result = a1;
  v4 = *(_BYTE *)(a1 + 8);
  if ( v4 != 3 )
  {
    v5 = *(_BYTE *)(a1 + 9);
    if ( (v4 & 2) != 0 )
    {
      v6 = a3;
      v7 = *(unsigned __int8 *)(a1 + 9);
      v8 = 3;
      v9 = a3[1];
      v10 = v7 - *a3;
      v40[0] = *a3;
      v40[1] = v9;
      v41[0] = v10;
      v41[1] = v5 - v9;
      v11 = v5 - a3[2];
      v40[2] = a3[2];
      v41[2] = v11;
    }
    else
    {
      v6 = a3;
      v7 = *(unsigned __int8 *)(a1 + 9);
      v8 = 1;
      v10 = v7 - a3[3];
      v40[0] = a3[3];
      v41[0] = v10;
    }
    HIWORD(v12) = HIWORD(a1);
    v48 = v8;
    if ( (*(_BYTE *)(a1 + 8) & 4) != 0 )
    {
      v12 = v6[4];
      v40[v8] = v12;
      v41[v8] = v7 - v12;
      v10 = v41[0];
      v48 = ++v8;
    }
    if ( v5 >= 8u )
    {
      if ( v5 == 8 )
      {
        v23 = a2;
        v24 = 0;
        v46 = 0;
        result = v8 * *(_DWORD *)a1;
        v37 = result;
        if ( result )
        {
          do
          {
            v25 = (unsigned __int8)*v23;
            v50 = v25;
            *v23 = 0;
            v26 = v41[v24 % v8];
            v27 = v40[v24 % v8];
            if ( v26 > -v27 )
            {
              v43 = -v26;
              while ( 1 )
              {
                if ( v26 <= 0 )
                  v25 >>= v43;
                else
                  LOBYTE(v25) = (_BYTE)v25 << v26;
                v26 -= v27;
                *v23 |= v25;
                LOBYTE(v43) = v43 + v27;
                if ( v26 <= -v27 )
                  break;
                v25 = v50;
              }
              v24 = v46;
            }
            result = v37;
            ++v24;
            ++v23;
            v46 = v24;
          }
          while ( v24 < v37 );
        }
      }
      else
      {
        v28 = a2;
        v29 = 0;
        result = v8 * *(_DWORD *)a1;
        v39 = result;
        v47 = 0;
        if ( result )
        {
          do
          {
            HIWORD(v30) = (v29 / v8) >> 16;
            LOWORD(v12) = *v28;
            LOWORD(v30) = v28[1];
            v31 = 0;
            v12 = v30 + (v12 << 8);
            v32 = v41[v29 % v8];
            v38 = v40[v29 % v8];
            if ( v32 > -v38 )
            {
              v33 = -v32;
              v44 = -v32;
              do
              {
                if ( v32 <= 0 )
                  LOWORD(v34) = (unsigned __int16)v12 >> v33;
                else
                  v34 = v12 << v32;
                v31 |= v34;
                v32 -= v38;
                LOBYTE(v33) = v44 + v38;
                LOBYTE(v44) = v44 + v38;
              }
              while ( v32 > -v38 );
              v8 = v48;
              v29 = v47;
            }
            result = v39;
            *v28 = HIBYTE(v31);
            v35 = v28 + 1;
            *v35 = v31;
            v28 = v35 + 1;
            v47 = ++v29;
          }
          while ( v29 < v39 );
        }
      }
    }
    else
    {
      v13 = v6[3];
      result = (int)a2;
      v14 = *(_DWORD *)(a1 + 4);
      if ( v13 == 1 && v5 == 2 )
      {
        v42 = 85;
      }
      else if ( v5 != 4 || (v42 = 17, v13 != 3) )
      {
        v42 = -1;
      }
      if ( v14 )
      {
        v45 = v14;
        v15 = -v40[0];
        do
        {
          v16 = *(unsigned __int8 *)result;
          v49 = v16;
          *(_BYTE *)result = 0;
          v17 = v10;
          if ( v10 > v15 )
          {
            v18 = -v10;
            v19 = -v40[0];
            v36 = -v40[0];
            while ( 1 )
            {
              v20 = v17 <= 0 ? v42 & (v16 >> v18) : (_BYTE)v16 << v17;
              LOBYTE(v18) = v18 - v19;
              v21 = v20 | *(_BYTE *)result;
              v22 = v40[0];
              *(_BYTE *)result = v21;
              v15 = v36;
              v17 -= v22;
              if ( v17 <= v36 )
                break;
              v16 = v49;
            }
          }
          ++result;
          --v45;
        }
        while ( v45 );
      }
    }
  }
  return result;
}

//----- (0048E920) --------------------------------------------------------
char *__cdecl sub_48E920(char *a1, char *a2)
{
  char *result; // eax
  char v3; // cl
  char *v4; // ecx
  int v5; // esi
  char v6; // dl
  char *v7; // eax
  _BYTE *v8; // ecx
  char v9; // bl
  char v10; // bl
  int v11; // esi
  char *i; // ecx
  char v13; // dl
  char *v14; // eax
  _BYTE *v15; // ecx
  char v16; // bl
  char v17; // bl
  char v18; // bl
  char v19; // bl
  char v20; // bl
  char v21; // bl
  char *v22; // ecx
  int v23; // esi
  char v24; // dl
  _BYTE *v25; // ecx
  int v26; // esi
  char *j; // ecx
  char v28; // dl
  char *v29; // eax
  _BYTE *v30; // ecx
  char v31; // bl
  char v32; // bl
  char v33; // [esp+11h] [ebp+9h]
  char v34; // [esp+11h] [ebp+9h]

  result = a1;
  v3 = a1[8];
  if ( v3 == 6 )
  {
    if ( a1[9] == 8 )
    {
      result = a2;
      v4 = a2;
      if ( *(_DWORD *)a1 )
      {
        v5 = *(_DWORD *)a1;
        do
        {
          v6 = *result;
          *v4 = result[1];
          v7 = result + 2;
          v8 = v4 + 2;
          v9 = *v7++;
          *(v8++ - 1) = v9;
          v10 = *v7;
          result = v7 + 1;
          *(v8 - 1) = v10;
          *v8 = v6;
          v4 = v8 + 1;
          --v5;
        }
        while ( v5 );
      }
    }
    else
    {
      v11 = *(_DWORD *)a1;
      result = a2;
      for ( i = a2; v11; --v11 )
      {
        v13 = *result;
        v33 = result[1];
        v14 = result + 2;
        v15 = i + 1;
        v16 = *v14++;
        *(v15++ - 1) = v16;
        v17 = *v14++;
        *(v15++ - 1) = v17;
        v18 = *v14++;
        *(v15++ - 1) = v18;
        v19 = *v14++;
        *(v15++ - 1) = v19;
        v20 = *v14++;
        *(v15++ - 1) = v20;
        v21 = *v14;
        result = v14 + 1;
        *(v15 - 1) = v21;
        *v15++ = v13;
        *v15 = v33;
        i = v15 + 1;
      }
    }
  }
  else if ( v3 == 4 )
  {
    if ( a1[9] == 8 )
    {
      result = a2;
      v22 = a2;
      if ( *(_DWORD *)a1 )
      {
        v23 = *(_DWORD *)a1;
        do
        {
          v24 = *result;
          *v22 = result[1];
          v25 = v22 + 1;
          result += 2;
          *v25 = v24;
          v22 = v25 + 1;
          --v23;
        }
        while ( v23 );
      }
    }
    else
    {
      v26 = *(_DWORD *)a1;
      result = a2;
      for ( j = a2; v26; --v26 )
      {
        v28 = *result;
        v34 = result[1];
        v29 = result + 2;
        v30 = j + 1;
        v31 = *v29++;
        *(v30++ - 1) = v31;
        v32 = *v29;
        result = v29 + 1;
        *(v30 - 1) = v32;
        *v30++ = v28;
        *v30 = v34;
        j = v30 + 1;
      }
    }
  }
  return result;
}

//----- (0048EA30) --------------------------------------------------------
_BYTE *__cdecl sub_48EA30(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  char v3; // cl
  int v4; // edx
  _BYTE *v5; // ecx
  int v6; // esi
  char v7; // dl
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  char v10; // dl
  int v11; // esi
  char v12; // dl
  _BYTE *v13; // eax
  _BYTE *v14; // ecx
  char v15; // dl
  char v16; // dl
  char v17; // dl
  char v18; // dl
  char v19; // bl
  int v20; // edx
  _BYTE *v21; // ecx
  int v22; // esi
  _BYTE *v23; // eax
  int v24; // esi
  char v25; // dl
  _BYTE *v26; // eax
  _BYTE *v27; // ecx
  char v28; // bl

  result = a1;
  v3 = a1[8];
  if ( v3 == 6 )
  {
    v4 = *(_DWORD *)a1;
    result = a2;
    v5 = a2;
    if ( a1[9] == 8 )
    {
      if ( v4 )
      {
        v6 = *(_DWORD *)a1;
        do
        {
          *result = *v5;
          v7 = v5[1];
          v8 = result + 1;
          v9 = v5 + 1;
          *v8 = v7;
          v10 = v9[1];
          ++v8;
          ++v9;
          *v8++ = v10;
          *v8 = -1 - v9[1];
          result = v8 + 1;
          v5 = v9 + 2;
          --v6;
        }
        while ( v6 );
      }
    }
    else if ( v4 )
    {
      v11 = *(_DWORD *)a1;
      do
      {
        *result = *v5;
        v12 = v5[1];
        v13 = result + 1;
        v14 = v5 + 1;
        *v13 = v12;
        v15 = v14[1];
        ++v13;
        ++v14;
        *v13 = v15;
        v16 = v14[1];
        ++v13;
        ++v14;
        *v13 = v16;
        v17 = v14[1];
        ++v13;
        ++v14;
        *v13 = v17;
        v18 = v14[1];
        ++v13;
        ++v14;
        *v13 = v18;
        v19 = v14[1];
        ++v13;
        ++v14;
        *v13++ = -1 - v19;
        *v13 = -1 - v14[1];
        result = v13 + 1;
        v5 = v14 + 2;
        --v11;
      }
      while ( v11 );
    }
  }
  else if ( v3 == 4 )
  {
    v20 = *(_DWORD *)a1;
    result = a2;
    v21 = a2;
    if ( a1[9] == 8 )
    {
      if ( v20 )
      {
        v22 = *(_DWORD *)a1;
        do
        {
          *result = *v21;
          v23 = result + 1;
          *v23 = -1 - v21[1];
          result = v23 + 1;
          v21 += 2;
          --v22;
        }
        while ( v22 );
      }
    }
    else if ( v20 )
    {
      v24 = *(_DWORD *)a1;
      do
      {
        *result = *v21;
        v25 = v21[1];
        v26 = result + 1;
        v27 = v21 + 1;
        *v26 = v25;
        v28 = v27[1];
        ++v26;
        ++v27;
        *v26++ = -1 - v28;
        *v26 = -1 - v27[1];
        result = v26 + 1;
        v21 = v27 + 2;
        --v24;
      }
      while ( v24 );
    }
  }
  return result;
}

//----- (0048EB40) --------------------------------------------------------
char __cdecl sub_48EB40(int *a1, int a2)
{
  _BYTE *v2; // eax
  char v3; // cl
  int v4; // edx
  int v5; // esi
  char v6; // cl
  int v7; // edi
  int v8; // esi
  __int16 v9; // cx
  __int16 v10; // bx
  __int16 v11; // dx
  __int16 v12; // dx
  __int16 v13; // cx

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v5 = 3;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v5 = 4;
      }
      if ( v4 )
      {
        v2 = (_BYTE *)(a2 + 2);
        do
        {
          v6 = *(v2 - 1);
          *(v2 - 2) -= v6;
          *v2 -= v6;
          v2 += v5;
          --v4;
        }
        while ( v4 );
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        v7 = 6;
      }
      else
      {
        if ( v3 != 6 )
          return (char)v2;
        v7 = 8;
      }
      if ( v4 )
      {
        v8 = *a1;
        v2 = (_BYTE *)(a2 + 1);
        do
        {
          HIBYTE(v9) = v2[1];
          HIBYTE(v10) = v2[3];
          LOBYTE(v9) = v2[2];
          LOBYTE(v10) = v2[4];
          HIBYTE(v11) = *(v2 - 1);
          LOBYTE(v11) = *v2;
          v12 = v11 - v9;
          v13 = v10 - v9;
          v2[4] = v13;
          *v2 = v12;
          *(v2 - 1) = HIBYTE(v12);
          v2[3] = HIBYTE(v13);
          v2 += v7;
          --v8;
        }
        while ( v8 );
      }
    }
  }
  return (char)v2;
}

//----- (0048EC10) --------------------------------------------------------
int __cdecl sub_48EC10(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ebx
  int v5; // ecx
  _DWORD *v6; // eax
  int result; // eax

  a1[1] = 0;
  if ( a2 != 62 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = 62;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 432 )
  {
    *(_DWORD *)(*a1 + 20) = 21;
    *(_DWORD *)(*a1 + 24) = 432;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  v4 = a1[3];
  memset(a1, 0, 0x1B0u);
  *a1 = v3;
  a1[3] = v4;
  *((_BYTE *)a1 + 16) = 1;
  sub_492AB0(a1);
  a1[2] = 0;
  a1[6] = 0;
  a1[36] = 0;
  a1[37] = 0;
  v5 = 4;
  a1[38] = 0;
  a1[39] = 0;
  v6 = a1 + 44;
  do
  {
    *(v6 - 4) = 0;
    *v6++ = 0;
    --v5;
  }
  while ( v5 );
  a1[67] = 0;
  sub_48F770((int)a1);
  result = sub_4924B0((int)a1);
  a1[5] = 200;
  return result;
}

//----- (0048ECF0) --------------------------------------------------------
int __cdecl sub_48ECF0(int a1)
{
  return sub_493710(a1);
}

//----- (0048ED10) --------------------------------------------------------
int __cdecl sub_48ED10(_DWORD *a1, char a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[5];
  if ( v2 != 200 && v2 != 201 )
  {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_48ED80(a1);
  if ( result == 1 )
    return 1;
  if ( result == 2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(*a1 + 20) = 51;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_4936D0((int)a1);
    result = 2;
  }
  return result;
}

//----- (0048ED80) --------------------------------------------------------
int __cdecl sub_48ED80(_DWORD *a1)
{
  int v1; // edi
  int result; // eax

  v1 = 0;
  switch ( a1[5] )
  {
    case 0xC8:
      (*(void (__cdecl **)(_DWORD *))(a1[100] + 4))(a1);
      (*(void (__cdecl **)(_DWORD *))(a1[6] + 8))(a1);
      a1[5] = 201;
      goto LABEL_3;
    case 0xC9:
LABEL_3:
      v1 = (*(int (__cdecl **)(_DWORD *))a1[100])(a1);
      if ( v1 != 1 )
        goto LABEL_8;
      sub_48EE40((int)a1);
      result = 1;
      a1[5] = 202;
      break;
    case 0xCA:
      return 1;
    case 0xCB:
    case 0xCC:
    case 0xCD:
    case 0xCE:
    case 0xCF:
    case 0xD0:
    case 0xD2:
      return (*(int (__cdecl **)(_DWORD *))a1[100])(a1);
    default:
      *(_DWORD *)(*a1 + 20) = 20;
      *(_DWORD *)(*a1 + 24) = a1[5];
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
LABEL_8:
      result = v1;
      break;
  }
  return result;
}

//----- (0048EE40) --------------------------------------------------------
int __cdecl sub_48EE40(int a1)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax
  int result; // eax

  switch ( *(_DWORD *)(a1 + 36) )
  {
    case 1:
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = 1;
      break;
    case 3:
      if ( !*(_BYTE *)(a1 + 256) )
      {
        if ( *(_BYTE *)(a1 + 264) )
        {
          if ( *(_BYTE *)(a1 + 265) )
          {
            if ( *(_BYTE *)(a1 + 265) != 1 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 114;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 265);
              (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
            }
            goto LABEL_25;
          }
LABEL_23:
          *(_DWORD *)(a1 + 40) = 2;
          *(_DWORD *)(a1 + 44) = 2;
          break;
        }
        v1 = *(int **)(a1 + 196);
        v2 = *v1;
        v3 = v1[21];
        v4 = v1[42];
        if ( *v1 == 1 )
        {
          if ( v3 == 2 && v4 == 3 )
          {
            *(_DWORD *)(a1 + 40) = 3;
            *(_DWORD *)(a1 + 44) = 2;
            break;
          }
        }
        else if ( v2 == 82 && v3 == 71 && v4 == 66 )
        {
          goto LABEL_23;
        }
        v5 = *(_DWORD **)a1;
        v5[6] = v2;
        v5 += 6;
        v5[1] = v3;
        v5[2] = v4;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 111;
        (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      }
LABEL_25:
      *(_DWORD *)(a1 + 40) = 3;
      *(_DWORD *)(a1 + 44) = 2;
      break;
    case 4:
      if ( *(_BYTE *)(a1 + 264) && *(_BYTE *)(a1 + 265) )
      {
        if ( *(_BYTE *)(a1 + 265) != 2 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 114;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 265);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 40) = 5;
        *(_DWORD *)(a1 + 44) = 4;
      }
      else
      {
        *(_DWORD *)(a1 + 40) = 4;
        *(_DWORD *)(a1 + 44) = 4;
      }
      break;
    default:
      *(_DWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      break;
  }
  result = 1;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 52) = 1;
  *(_DWORD *)(a1 + 60) = 1072693248;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 73) = 1;
  *(_BYTE *)(a1 + 74) = 0;
  *(_DWORD *)(a1 + 76) = 2;
  *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 256;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 89) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  return result;
}

//----- (0048F080) --------------------------------------------------------
char __cdecl sub_48F080(int a1)
{
  int v1; // eax
  int v2; // eax
  char result; // al

  v1 = *(_DWORD *)(a1 + 20);
  if ( (v1 == 205 || v1 == 206) && !*(_BYTE *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 120) < *(_DWORD *)(a1 + 96) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 67;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 384) + 4))(a1);
    *(_DWORD *)(a1 + 20) = 210;
  }
  else if ( v1 == 207 )
  {
    *(_DWORD *)(a1 + 20) = 210;
  }
  else if ( v1 != 210 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 400);
  if ( *(_BYTE *)(v2 + 17) )
  {
LABEL_14:
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 24) + 24))(a1);
    sub_4936D0(a1);
    result = 1;
  }
  else
  {
    while ( (*(int (__cdecl **)(int))v2)(a1) )
    {
      v2 = *(_DWORD *)(a1 + 400);
      if ( *(_BYTE *)(v2 + 17) )
        goto LABEL_14;
    }
    result = 0;
  }
  return result;
}

//----- (0048F140) --------------------------------------------------------
char __cdecl sub_48F140(int a1)
{
  char result; // al
  int v2; // eax
  void (__cdecl **v3)(int); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx

  if ( *(_DWORD *)(a1 + 20) == 202 )
  {
    sub_493A90(a1);
    if ( *(_BYTE *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 20) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 20) = 203;
  }
  v2 = *(_DWORD *)(a1 + 20);
  if ( v2 == 203 )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 16) )
    {
      while ( 1 )
      {
        v3 = *(void (__cdecl ***)(int))(a1 + 8);
        if ( v3 )
          (*v3)(a1);
        v4 = (**(int (__cdecl ***)(int))(a1 + 400))(a1);
        if ( !v4 )
          break;
        if ( v4 == 2 )
          goto LABEL_17;
        v5 = *(_DWORD *)(a1 + 8);
        if ( v5 && (v4 == 3 || v4 == 1) )
        {
          ++*(_DWORD *)(v5 + 4);
          v6 = *(_DWORD *)(a1 + 8);
          v7 = *(_DWORD *)(v6 + 8);
          if ( *(_DWORD *)(v6 + 4) >= v7 )
            *(_DWORD *)(v6 + 8) = v7 + *(_DWORD *)(a1 + 284);
        }
      }
      result = 0;
    }
    else
    {
LABEL_17:
      *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 124);
      result = sub_48F220(a1);
    }
  }
  else
  {
    if ( v2 != 204 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    result = sub_48F220(a1);
  }
  return result;
}

//----- (0048F220) --------------------------------------------------------
char __cdecl sub_48F220(int a1)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // edx
  char result; // al

  if ( *(_DWORD *)(a1 + 20) != 204 )
  {
    (**(void (__cdecl ***)(int))(a1 + 384))(a1);
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 20) = 204;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 384) + 8) )
  {
    v1 = (unsigned int *)(a1 + 120);
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 < *(_DWORD *)(a1 + 96) )
        break;
LABEL_10:
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 384) + 4))(a1);
      (**(void (__cdecl ***)(int))(a1 + 384))(a1);
      v5 = *(_DWORD *)(a1 + 384);
      *v1 = 0;
      if ( !*(_BYTE *)(v5 + 8) )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = v2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 96);
        (**(void (__cdecl ***)(int))(a1 + 8))(a1);
      }
      v4 = *v1;
      (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(*(_DWORD *)(a1 + 388) + 4))(a1, 0, a1 + 120, 0);
      v2 = *v1;
      if ( *v1 == v4 )
        break;
      if ( v2 >= *(_DWORD *)(a1 + 96) )
        goto LABEL_10;
    }
    result = 0;
  }
  else
  {
LABEL_11:
    *(_DWORD *)(a1 + 20) = (*(_BYTE *)(a1 + 65) != 0) + 205;
    result = 1;
  }
  return result;
}

//----- (0048F2F0) --------------------------------------------------------
_DWORD *__cdecl sub_48F2F0(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // [esp-4h] [ebp-8h]

  v3 = a1;
  if ( a1[5] != 205 )
  {
    v8 = a1;
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*v3 + 24) = v3[5];
    (*(void (__cdecl **)(_DWORD *))*v3)(v8);
  }
  v4 = v3[30];
  if ( v4 < v3[24] )
  {
    v6 = v3[2];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = v4;
      *(_DWORD *)(v3[2] + 8) = v3[24];
      (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
    }
    v7 = v3[97];
    a1 = 0;
    (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, a3);
    result = a1;
    v3[30] += a1;
  }
  else
  {
    *(_DWORD *)(*v3 + 20) = 123;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
    result = 0;
  }
  return result;
}

//----- (0048F560) --------------------------------------------------------
char __cdecl sub_48F560(_DWORD *a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx

  v2 = a1[95];
  *(_DWORD *)(*a1 + 20) = 121;
  *(_DWORD *)(*a1 + 24) = v2;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while ( 1 )
  {
    if ( v2 < 192 )
    {
LABEL_3:
      v3 = 2;
      goto LABEL_12;
    }
    if ( v2 < 208 || v2 > 215 || v2 == (((_BYTE)a2 + 1) & 7) + 208 || v2 == (((_BYTE)a2 + 2) & 7) + 208 )
    {
      v3 = 3;
    }
    else
    {
      if ( v2 == (((_BYTE)a2 - 1) & 7) + 208 || v2 == (((_BYTE)a2 - 2) & 7) + 208 )
        goto LABEL_3;
      v3 = 1;
    }
LABEL_12:
    *(_DWORD *)(*a1 + 20) = 97;
    *(_DWORD *)(*a1 + 24) = v2;
    *(_DWORD *)(*a1 + 28) = v3;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    v4 = v3 - 1;
    if ( !v4 )
      break;
    v5 = v4 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
        return 1;
    }
    else
    {
      if ( !sub_48F660(a1) )
        return 0;
      v2 = a1[95];
    }
  }
  a1[95] = 0;
  return 1;
}

//----- (0048F660) --------------------------------------------------------
char __cdecl sub_48F660(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // edi
  unsigned __int8 *i; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v3 = *v2;
  for ( i = v2[1]; ; v2[1] = i )
  {
    if ( !i )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v3 = *v2;
      i = v2[1];
    }
    --i;
    v5 = *v3++;
    if ( v5 == 255 )
      goto LABEL_10;
    do
    {
      ++*(_DWORD *)(a1[101] + 20);
      *v2 = v3;
      v2[1] = i;
      if ( !i )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v3 = *v2;
        i = v2[1];
      }
      --i;
      v6 = *v3++;
    }
    while ( v6 != 255 );
    do
    {
LABEL_10:
      if ( !i )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v3 = *v2;
        i = v2[1];
      }
      --i;
      v7 = *v3++;
      v9 = v7;
    }
    while ( v7 == 255 );
    if ( v7 )
      break;
    *(_DWORD *)(a1[101] + 20) += 2;
    *v2 = v3;
  }
  if ( *(_DWORD *)(a1[101] + 20) )
  {
    *(_DWORD *)(*a1 + 20) = 116;
    *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[101] + 20);
    *(_DWORD *)(*a1 + 28) = v7;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    v7 = v9;
    *(_DWORD *)(a1[101] + 20) = 0;
  }
  a1[95] = v7;
  *v2 = v3;
  v2[1] = i;
  return 1;
}

//----- (0048F770) --------------------------------------------------------
int __cdecl sub_48F770(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ecx
  int v3; // edx

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 168);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_490FA0;
  v1[1] = sub_48FD30;
  v1[2] = sub_490F10;
  v1[6] = sub_48FC90;
  v1[23] = 0;
  v2 = v1 + 24;
  v3 = 16;
  do
  {
    *(v2 - 17) = sub_48FC90;
    *v2++ = 0;
    --v3;
  }
  while ( v3 );
  v1[7] = sub_48F7E0;
  v1[21] = sub_48F7E0;
  return sub_490FA0((_DWORD *)a1);
}

//----- (0048F7E0) --------------------------------------------------------
char __cdecl sub_48F7E0(int a1)
{
  char **v1; // ebx
  unsigned __int8 *v2; // esi
  char *v3; // edi
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // esi
  char *v6; // edi
  int v7; // ebp
  unsigned __int8 *v8; // esi
  int v9; // edx
  char *v10; // edi
  int v11; // ebp
  unsigned int v12; // eax
  unsigned int i; // ebp
  int v14; // edx
  int v16; // [esp+10h] [ebp-18h]
  int v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+14h] [ebp-14h]
  char v19[16]; // [esp+18h] [ebp-10h] BYREF

  v1 = *(char ***)(a1 + 24);
  v2 = (unsigned __int8 *)v1[1];
  v3 = *v1;
  if ( !v2 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v1[3])(a1) )
      return 0;
    v3 = *v1;
    v2 = (unsigned __int8 *)v1[1];
  }
  LOBYTE(v4) = 0;
  v5 = v2 - 1;
  HIBYTE(v4) = *v3;
  v6 = v3 + 1;
  v7 = v4;
  if ( !v5 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v1[3])(a1) )
    {
      v6 = *v1;
      v5 = (unsigned __int8 *)v1[1];
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v8 = v5 - 1;
  v9 = (unsigned __int8)*v6;
  v10 = v6 + 1;
  v11 = v9 + v7 - 2;
  v17 = v11;
  if ( v11 < 14 )
  {
    v12 = v11 <= 0 ? 0 : v11;
    v16 = v12;
  }
  else
  {
    v12 = 14;
    v16 = 14;
  }
  for ( i = 0; i < v12; ++i )
  {
    if ( !v8 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v1[3])(a1) )
        return 0;
      v10 = *v1;
      v8 = (unsigned __int8 *)v1[1];
      v12 = v16;
    }
    --v8;
    v19[i] = *v10++;
  }
  v14 = v17 - v12;
  v18 = v17 - v12;
  if ( *(_DWORD *)(a1 + 380) == 224 )
  {
    sub_48F920(a1, v19, v12, v14);
  }
  else if ( *(_DWORD *)(a1 + 380) == 238 )
  {
    sub_48FBB0((_BYTE *)a1, v19, v12, v14);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 380);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *v1 = v10;
  v1[1] = (char *)v8;
  if ( v18 > 0 )
    (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 24) + 16))(a1, v18);
  return 1;
}

//----- (0048F920) --------------------------------------------------------
int __cdecl sub_48F920(int a1, _BYTE *a2, unsigned int a3, int a4)
{
  int v4; // ebp
  char v5; // al
  _DWORD *v6; // eax
  int v7; // ebp
  int result; // eax

  v4 = a3 + a4;
  if ( a3 >= 0xE && *a2 == 74 && a2[1] == 70 && a2[2] == 73 && a2[3] == 70 && !a2[4] )
  {
    *(_BYTE *)(a1 + 256) = 1;
    *(_BYTE *)(a1 + 257) = a2[5];
    *(_BYTE *)(a1 + 258) = a2[6];
    *(_BYTE *)(a1 + 259) = a2[7];
    v5 = *(_BYTE *)(a1 + 257);
    *(_WORD *)(a1 + 260) = (unsigned __int8)a2[9] + ((unsigned __int8)a2[8] << 8);
    *(_WORD *)(a1 + 262) = (unsigned __int8)a2[11] + ((unsigned __int8)a2[10] << 8);
    if ( v5 != 1 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 119;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 257);
      *(_DWORD *)(*(_DWORD *)a1 + 28) = *(unsigned __int8 *)(a1 + 258);
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
    }
    v6 = (_DWORD *)(*(_DWORD *)a1 + 24);
    *v6 = *(unsigned __int8 *)(a1 + 257);
    v6[1] = *(unsigned __int8 *)(a1 + 258);
    v6[2] = *(unsigned __int16 *)(a1 + 260);
    v6[3] = *(unsigned __int16 *)(a1 + 262);
    v6[4] = *(unsigned __int8 *)(a1 + 259);
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 87;
    (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    if ( *((_WORD *)a2 + 6) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 90;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = (unsigned __int8)a2[12];
      *(_DWORD *)(*(_DWORD *)a1 + 28) = (unsigned __int8)a2[13];
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    }
    v7 = v4 - 14;
    result = 3 * (unsigned __int8)a2[13] * (unsigned __int8)a2[12];
    if ( v7 != result )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 88;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v7;
      result = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    }
  }
  else if ( a3 >= 6 && *a2 == 74 && a2[1] == 70 && a2[2] == 88 && a2[3] == 88 && !a2[4] )
  {
    if ( a2[5] == 16 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 108;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
      result = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    }
    else if ( a2[5] == 17 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 109;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
      result = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    }
    else
    {
      if ( a2[5] == 19 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 89;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = (unsigned __int8)a2[5];
        *(_DWORD *)(*(_DWORD *)a1 + 28) = v4;
      }
      result = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 77;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
    result = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  }
  return result;
}

//----- (0048FBB0) --------------------------------------------------------
int __cdecl sub_48FBB0(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4)
{
  int v4; // ebp
  int v5; // edx
  int v6; // ebx
  _DWORD *v7; // ecx
  int result; // eax
  int v9; // [esp+Ch] [ebp+Ch]

  if ( a3 >= 0xC && *a2 == 65 && a2[1] == 100 && a2[2] == 111 && a2[3] == 98 && a2[4] == 101 )
  {
    v4 = (unsigned __int8)a2[10] + ((unsigned __int8)a2[9] << 8);
    v5 = (unsigned __int8)a2[5];
    v6 = (unsigned __int8)a2[6];
    v9 = (unsigned __int8)a2[11];
    v7 = *(_DWORD **)a1;
    v7[7] = (unsigned __int8)a2[8] + ((unsigned __int8)a2[7] << 8);
    v7 += 6;
    *v7 = v6 + (v5 << 8);
    v7[2] = v4;
    v7[3] = v9;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 76;
    result = (*(int (__cdecl **)(_BYTE *, int))(*(_DWORD *)a1 + 4))(a1, 1);
    a1[264] = 1;
    a1[265] = v9;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 78;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = a4 + a3;
    result = (*(int (__cdecl **)(_BYTE *, int))(*(_DWORD *)a1 + 4))(a1, 1);
  }
  return result;
}

//----- (0048FC90) --------------------------------------------------------
char __cdecl sub_48FC90(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  unsigned __int16 v5; // ax
  unsigned __int8 *v6; // ebp
  unsigned __int8 *v7; // ebx
  int v9; // [esp+14h] [ebp+4h]
  int v10; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  LOBYTE(v5) = 0;
  v6 = v3 - 1;
  HIBYTE(v5) = *v4;
  v7 = v4 + 1;
  v9 = v5;
  if ( !v6 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    {
      v7 = *v2;
      v6 = v2[1];
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v10 = v9 + *v7 - 2;
  *(_DWORD *)(*a1 + 20) = 91;
  *(_DWORD *)(*a1 + 24) = a1[95];
  *(_DWORD *)(*a1 + 28) = v10;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *v2 = v7 + 1;
  v2[1] = v6 - 1;
  if ( v10 > 0 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[6] + 16))(a1, v10);
  return 1;
}

//----- (0048FD30) --------------------------------------------------------
int __cdecl sub_48FD30(_DWORD *a1)
{
  int v1; // eax
  char v2; // al

  while ( 1 )
  {
    if ( a1[95] )
      goto LABEL_6;
    if ( *(_BYTE *)(a1[101] + 12) )
      break;
    if ( !sub_490E70(a1) )
      return 0;
LABEL_6:
    v1 = a1[95];
    switch ( v1 )
    {
      case 1:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        *(_DWORD *)(*a1 + 20) = 92;
        *(_DWORD *)(*a1 + 24) = a1[95];
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[95] = 0;
        continue;
      case 192:
      case 193:
        v2 = sub_490140((int)a1, 0, 0);
        goto LABEL_12;
      case 194:
        v2 = sub_490140((int)a1, 1, 0);
        goto LABEL_12;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        *(_DWORD *)(*a1 + 20) = 60;
        *(_DWORD *)(*a1 + 24) = a1[95];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[95] = 0;
        continue;
      case 196:
        if ( !sub_490780(a1) )
          return 0;
        a1[95] = 0;
        continue;
      case 201:
        v2 = sub_490140((int)a1, 0, 1);
        goto LABEL_12;
      case 202:
        v2 = sub_490140((int)a1, 1, 1);
        goto LABEL_12;
      case 204:
      case 220:
        if ( !sub_48FC90(a1) )
          return 0;
        a1[95] = 0;
        continue;
      case 216:
        v2 = sub_490080((int)a1);
LABEL_12:
        if ( !v2 )
          return 0;
        a1[95] = 0;
        break;
      case 217:
        *(_DWORD *)(*a1 + 20) = 85;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[95] = 0;
        return 2;
      case 218:
        if ( !sub_490470(a1) )
          return 0;
        a1[95] = 0;
        return 1;
      case 219:
        if ( !sub_490AF0(a1) )
          return 0;
        a1[95] = 0;
        continue;
      case 221:
        if ( !sub_490D80(a1) )
          return 0;
        a1[95] = 0;
        continue;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[101] + 4 * v1 - 868))(a1) )
          return 0;
        a1[95] = 0;
        continue;
      case 254:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[101] + 24))(a1) )
          return 0;
        a1[95] = 0;
        continue;
      default:
        *(_DWORD *)(*a1 + 20) = 68;
        *(_DWORD *)(*a1 + 24) = a1[95];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[95] = 0;
        continue;
    }
  }
  if ( sub_48F660(a1) )
    goto LABEL_6;
  return 0;
}

//----- (00490080) --------------------------------------------------------
char __cdecl sub_490080(int a1)
{
  _BYTE *v1; // eax
  int v2; // edx

  *(_DWORD *)(*(_DWORD *)a1 + 20) = 102;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 404) + 12) && *(_DWORD *)(a1 + 20) != 201 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 61;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = (_BYTE *)(a1 + 218);
  do
  {
    *(v1 - 16) = 0;
    *v1 = 1;
    v1[16] = 5;
    ++v1;
  }
  while ( (int)&v1[-218 - a1] < 16 );
  v2 = *(_DWORD *)(a1 + 404);
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 266) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 257) = 1;
  *(_BYTE *)(a1 + 258) = 1;
  *(_BYTE *)(a1 + 259) = 0;
  *(_WORD *)(a1 + 260) = 1;
  *(_WORD *)(a1 + 262) = 1;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 265) = 0;
  *(_BYTE *)(v2 + 12) = 1;
  return 1;
}

//----- (00490140) --------------------------------------------------------
char __cdecl sub_490140(int a1, char a2, char a3)
{
  unsigned __int8 **v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned __int16 v7; // dx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // ebx
  int v11; // ecx
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // ebx
  int v14; // ecx
  unsigned __int8 *v15; // edi
  unsigned __int16 v16; // dx
  unsigned __int8 *v17; // ebx
  unsigned __int8 *v18; // edi
  unsigned __int8 *v19; // ebx
  int v20; // ecx
  unsigned __int8 *v21; // edi
  unsigned __int16 v22; // cx
  unsigned __int8 *v23; // ebx
  unsigned __int8 *v24; // edi
  unsigned __int8 *v25; // ebx
  int v26; // ecx
  unsigned __int8 *v27; // edi
  int v28; // ecx
  _DWORD *v29; // eax
  unsigned __int8 *v30; // ebx
  unsigned __int8 *v31; // edi
  _DWORD *v32; // ebp
  unsigned __int8 *v33; // ebx
  int v34; // edx
  unsigned __int8 *v35; // edi
  unsigned __int8 *v36; // ebx
  int v37; // eax
  unsigned __int8 *v38; // edi
  _DWORD *v39; // eax
  unsigned __int8 **v41; // [esp+14h] [ebp+4h]
  int v42; // [esp+18h] [ebp+8h]
  int v43; // [esp+18h] [ebp+8h]
  int v44; // [esp+18h] [ebp+8h]
  int i; // [esp+18h] [ebp+8h]

  v4 = *(unsigned __int8 ***)(a1 + 24);
  v41 = v4;
  v5 = v4[1];
  v6 = *v4;
  *(_BYTE *)(a1 + 200) = a2;
  *(_BYTE *)(a1 + 201) = a3;
  if ( !v5 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v6 = *v4;
    v5 = v4[1];
  }
  LOBYTE(v7) = 0;
  v8 = v5 - 1;
  HIBYTE(v7) = *v6;
  v9 = v6 + 1;
  v42 = v7;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v9 = *v4;
    v8 = v4[1];
  }
  v10 = v8 - 1;
  v11 = *v9 + v42;
  v12 = v9 + 1;
  v43 = v11;
  if ( !v10 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v12 = *v4;
    v10 = v4[1];
  }
  v13 = v10 - 1;
  v14 = *v12;
  v15 = v12 + 1;
  *(_DWORD *)(a1 + 192) = v14;
  if ( !v13 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v15 = *v4;
    v13 = v4[1];
  }
  LOBYTE(v16) = 0;
  v17 = v13 - 1;
  HIBYTE(v16) = *v15;
  v18 = v15 + 1;
  *(_DWORD *)(a1 + 32) = v16;
  if ( !v17 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v18 = *v4;
    v17 = v4[1];
  }
  v19 = v17 - 1;
  v20 = *v18 + *(_DWORD *)(a1 + 32);
  v21 = v18 + 1;
  *(_DWORD *)(a1 + 32) = v20;
  if ( !v19 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v21 = *v4;
    v19 = v4[1];
  }
  LOBYTE(v22) = 0;
  v23 = v19 - 1;
  HIBYTE(v22) = *v21;
  v24 = v21 + 1;
  *(_DWORD *)(a1 + 28) = v22;
  if ( !v23 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v24 = *v4;
    v23 = v4[1];
  }
  v25 = v23 - 1;
  v26 = *v24 + *(_DWORD *)(a1 + 28);
  v27 = v24 + 1;
  *(_DWORD *)(a1 + 28) = v26;
  if ( v25 )
    goto LABEL_25;
  if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
    return 0;
  v27 = *v4;
  v25 = v4[1];
LABEL_25:
  v28 = *(_DWORD *)(a1 + 380);
  *(_DWORD *)(a1 + 36) = *v27;
  v29 = (_DWORD *)(*(_DWORD *)a1 + 24);
  v44 = v43 - 8;
  *v29 = v28;
  v29[1] = *(_DWORD *)(a1 + 28);
  v29[2] = *(_DWORD *)(a1 + 32);
  v29[3] = *(_DWORD *)(a1 + 36);
  v30 = v25 - 1;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 100;
  v31 = v27 + 1;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 404) + 13) && *(_DWORD *)(a1 + 20) != 201 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 58;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 32) || !*(_DWORD *)(a1 + 28) || *(int *)(a1 + 36) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 32;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( v44 != 3 * *(_DWORD *)(a1 + 36) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 196) )
    *(_DWORD *)(a1 + 196) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84 * *(_DWORD *)(a1 + 36));
  v32 = *(_DWORD **)(a1 + 196);
  for ( i = 0; i < *(_DWORD *)(a1 + 36); ++i )
  {
    v32[1] = i;
    if ( !v30 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v41[3])(a1) )
        return 0;
      v31 = *v41;
      v30 = v41[1];
    }
    v33 = v30 - 1;
    v34 = *v31;
    v35 = v31 + 1;
    *v32 = v34;
    if ( !v33 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v41[3])(a1) )
        return 0;
      v35 = *v41;
      v33 = v41[1];
    }
    v36 = v33 - 1;
    v37 = *v35;
    v38 = v35 + 1;
    v32[3] = v37 & 0xF;
    v32[2] = (v37 >> 4) & 0xF;
    if ( !v36 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v41[3])(a1) )
        return 0;
      v38 = *v41;
      v36 = v41[1];
    }
    v30 = v36 - 1;
    v32[4] = *v38;
    v39 = (_DWORD *)(*(_DWORD *)a1 + 24);
    v31 = v38 + 1;
    *v39 = *v32;
    v39[1] = v32[2];
    v39[2] = v32[3];
    v39[3] = v32[4];
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 101;
    (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    v32 += 21;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 404) + 13) = 1;
  *v41 = v31;
  v41[1] = v30;
  return 1;
}

//----- (00490470) --------------------------------------------------------
char __cdecl sub_490470(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  unsigned __int16 v5; // cx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // ebx
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 *v12; // ebx
  unsigned __int8 *v13; // ebp
  int v14; // eax
  unsigned __int8 *v15; // ebx
  int v16; // eax
  unsigned __int8 *v17; // ebp
  int v18; // ecx
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // ebx
  _DWORD *v22; // eax
  bool v23; // cc
  unsigned __int8 *v24; // ebx
  int v25; // eax
  unsigned __int8 *v26; // ebp
  unsigned __int8 *v27; // ebx
  int v28; // eax
  unsigned __int8 *v29; // ebp
  int v30; // edx
  int v31; // ecx
  _DWORD *v32; // eax
  int v34; // [esp+10h] [ebp-14h]
  int v35; // [esp+10h] [ebp-14h]
  int v36; // [esp+10h] [ebp-14h]
  _DWORD *v37; // [esp+14h] [ebp-10h]
  int v38; // [esp+18h] [ebp-Ch]
  int v39; // [esp+1Ch] [ebp-8h]
  unsigned __int8 **v40; // [esp+20h] [ebp-4h]
  unsigned __int8 *v41; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v40 = v2;
  v3 = *v2;
  v4 = v2[1];
  if ( !*(_BYTE *)(a1[101] + 13) )
  {
    *(_DWORD *)(*a1 + 20) = 62;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  LOBYTE(v5) = 0;
  v6 = v4 - 1;
  HIBYTE(v5) = *v3;
  v7 = v3 + 1;
  v34 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
  }
  v8 = v6 - 1;
  v9 = *v7 + v34;
  v10 = v7 + 1;
  v35 = v9;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  v11 = *v10;
  *(_DWORD *)(*a1 + 20) = 103;
  v12 = v8 - 1;
  *(_DWORD *)(*a1 + 24) = v11;
  v38 = v11;
  v13 = v10 + 1;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v14 = v38;
  if ( v35 != 2 * v38 + 6 || v38 < 1 || v38 > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v14 = v38;
  }
  a1[73] = v14;
  v39 = 0;
  if ( v14 > 0 )
  {
    v37 = a1 + 74;
    do
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v13 = *v2;
        v12 = v2[1];
      }
      v15 = v12 - 1;
      v16 = *v13;
      v17 = v13 + 1;
      v36 = v16;
      if ( !v15 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v17 = *v2;
        v15 = v2[1];
      }
      v18 = a1[9];
      v19 = (_DWORD *)a1[49];
      v41 = v15 - 1;
      v20 = 0;
      v21 = *v17;
      v13 = v17 + 1;
      if ( v18 <= 0 )
      {
LABEL_27:
        *(_DWORD *)(*a1 + 20) = 5;
        *(_DWORD *)(*a1 + 24) = v36;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      else
      {
        while ( v36 != *v19 )
        {
          ++v20;
          v19 += 21;
          if ( v20 >= v18 )
            goto LABEL_27;
        }
      }
      *v37 = v19;
      v19[5] = (v21 >> 4) & 0xF;
      v19[6] = v21 & 0xF;
      v22 = (_DWORD *)*a1;
      v22[6] = v36;
      v22 += 6;
      v22[1] = v19[5];
      v22[2] = v19[6];
      *(_DWORD *)(*a1 + 20) = 104;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      v12 = v41;
      v2 = v40;
      v23 = ++v39 < v38;
      ++v37;
    }
    while ( v23 );
  }
  if ( !v12 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v13 = *v2;
    v12 = v2[1];
  }
  v24 = v12 - 1;
  v25 = *v13;
  v26 = v13 + 1;
  a1[91] = v25;
  if ( !v24 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v26 = *v2;
    v24 = v2[1];
  }
  v27 = v24 - 1;
  v28 = *v26;
  v29 = v26 + 1;
  a1[92] = v28;
  if ( v27 )
  {
LABEL_38:
    v30 = a1[91];
    v31 = *v29;
    a1[94] = v31 & 0xF;
    v32 = (_DWORD *)(*a1 + 24);
    a1[93] = (v31 >> 4) & 0xF;
    *v32 = v30;
    v32[1] = a1[92];
    v32[2] = a1[93];
    v32[3] = a1[94];
    *(_DWORD *)(*a1 + 20) = 105;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    *(_DWORD *)(a1[101] + 16) = 0;
    ++a1[31];
    *v2 = v29 + 1;
    v2[1] = v27 - 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v29 = *v2;
    v27 = v2[1];
    goto LABEL_38;
  }
  return 0;
}

//----- (00490780) --------------------------------------------------------
char __cdecl sub_490780(_DWORD *a1)
{
  char **v1; // edi
  unsigned __int8 *v2; // esi
  char *v3; // ebx
  unsigned __int8 *v4; // esi
  int v5; // eax
  char *v6; // ebx
  unsigned __int8 *v7; // esi
  int v8; // edx
  char *v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  unsigned __int8 *v13; // esi
  int j; // edi
  unsigned __int8 v15; // dl
  _DWORD *v16; // eax
  int v17; // edx
  unsigned __int8 v18; // cl
  int v19; // edx
  unsigned __int8 v20; // cl
  int v21; // edx
  unsigned __int8 v22; // cl
  int v23; // edx
  _DWORD *v24; // eax
  int v25; // ecx
  unsigned __int8 v26; // dl
  int v27; // ecx
  unsigned __int8 v28; // dl
  int v29; // ecx
  unsigned __int8 v30; // dl
  int v31; // ecx
  int v32; // edi
  int v33; // eax
  int v34; // eax
  int v35; // esi
  int v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  unsigned __int8 *v41; // [esp+10h] [ebp-128h]
  int v42; // [esp+14h] [ebp-124h]
  int i; // [esp+14h] [ebp-124h]
  int v44; // [esp+14h] [ebp-124h]
  int v45; // [esp+18h] [ebp-120h]
  int k; // [esp+18h] [ebp-120h]
  char **v47; // [esp+1Ch] [ebp-11Ch]
  int v48; // [esp+20h] [ebp-118h]
  int v49; // [esp+24h] [ebp-114h]
  int v50; // [esp+28h] [ebp-110h]
  int v51; // [esp+2Ch] [ebp-10Ch]
  unsigned __int8 v52; // [esp+30h] [ebp-108h]
  int v53; // [esp+34h] [ebp-104h]
  char v54[256]; // [esp+38h] [ebp-100h] BYREF

  v1 = (char **)a1[6];
  v47 = v1;
  v2 = (unsigned __int8 *)v1[1];
  v3 = *v1;
  if ( !v2 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v3 = *v1;
    v2 = (unsigned __int8 *)v1[1];
  }
  v5 = 0;
  v4 = v2 - 1;
  BYTE1(v5) = *v3;
  v6 = v3 + 1;
  v42 = (unsigned __int16)v5;
  if ( !v4 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    {
      v6 = *v1;
      v5 = v42;
      v4 = (unsigned __int8 *)v1[1];
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v7 = v4 - 1;
  v8 = (unsigned __int8)*v6;
  v9 = v6 + 1;
  v10 = v8 + v5 - 2;
  for ( i = v10; i > 16; v1 = v47 )
  {
    if ( !v7 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v9 = *v1;
      v7 = (unsigned __int8 *)v1[1];
    }
    v11 = (unsigned __int8)*v9;
    *(_DWORD *)(*a1 + 20) = 80;
    v12 = *a1;
    v53 = v11;
    v13 = v7 - 1;
    *(_DWORD *)(v12 + 24) = v11;
    ++v9;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    LOBYTE(v48) = 0;
    v45 = 0;
    for ( j = 1; j <= 16; ++j )
    {
      if ( !v13 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v47[3])(a1) )
          return 0;
        v9 = *v47;
        v13 = (unsigned __int8 *)v47[1];
      }
      v15 = *v9;
      *((_BYTE *)&v48 + j) = *v9;
      --v13;
      ++v9;
      v41 = v13;
      v45 += v15;
    }
    v44 = i - 17;
    v16 = (_DWORD *)(*a1 + 24);
    v17 = BYTE2(v48);
    *v16 = BYTE1(v48);
    v18 = HIBYTE(v48);
    v16[1] = v17;
    v19 = (unsigned __int8)v49;
    v16[2] = v18;
    v20 = BYTE1(v49);
    v16[3] = v19;
    v21 = BYTE2(v49);
    v16[4] = v20;
    v22 = HIBYTE(v49);
    v16[5] = v21;
    v23 = (unsigned __int8)v50;
    v16[6] = v22;
    v16[7] = v23;
    *(_DWORD *)(*a1 + 20) = 86;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v24 = (_DWORD *)(*a1 + 24);
    v25 = BYTE2(v50);
    *v24 = BYTE1(v50);
    v26 = HIBYTE(v50);
    v24[1] = v25;
    v27 = (unsigned __int8)v51;
    v24[2] = v26;
    v28 = BYTE1(v51);
    v24[3] = v27;
    v29 = BYTE2(v51);
    v24[4] = v28;
    v30 = HIBYTE(v51);
    v24[5] = v29;
    v31 = v52;
    v24[6] = v30;
    v24[7] = v31;
    *(_DWORD *)(*a1 + 20) = 86;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v32 = v45;
    if ( v45 > 256 || v45 > v44 )
    {
      *(_DWORD *)(*a1 + 20) = 8;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v33 = 0;
    for ( k = 0; v33 < v32; k = v33 )
    {
      if ( !v13 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v47[3])(a1) )
          return 0;
        v9 = *v47;
        v13 = (unsigned __int8 *)v47[1];
        v33 = k;
      }
      --v13;
      v54[v33++] = *v9++;
      v41 = v13;
    }
    v34 = v53;
    i = v44 - v32;
    if ( (v53 & 0x10) != 0 )
    {
      v34 = v53 - 16;
      v35 = (int)&a1[v53 + 28];
    }
    else
    {
      v35 = (int)&a1[v53 + 40];
    }
    if ( v34 < 0 || v34 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 30;
      *(_DWORD *)(*a1 + 24) = v34;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !*(_DWORD *)v35 )
      *(_DWORD *)v35 = sub_493750((int)a1);
    v36 = *(_DWORD *)v35;
    v37 = v49;
    *(_DWORD *)v36 = v48;
    v38 = v50;
    *(_DWORD *)(v36 + 4) = v37;
    v39 = v51;
    *(_DWORD *)(v36 + 8) = v38;
    LOBYTE(v38) = v52;
    *(_DWORD *)(v36 + 12) = v39;
    *(_BYTE *)(v36 + 16) = v38;
    v10 = i;
    qmemcpy((void *)(*(_DWORD *)v35 + 17), v54, 0x100u);
    v7 = v41;
  }
  if ( v10 )
  {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  *v1 = v9;
  v1[1] = (char *)v7;
  return 1;
}

//----- (00490AF0) --------------------------------------------------------
char __cdecl sub_490AF0(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // ebp
  int v6; // eax
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebp
  int v9; // ecx
  unsigned __int8 *v10; // ebx
  int v11; // eax
  bool v12; // zf
  int v13; // edx
  int v14; // esi
  int v15; // eax
  int *v16; // esi
  unsigned __int8 **v17; // esi
  __int16 v18; // cx
  unsigned __int8 *v19; // ebp
  unsigned __int8 *v20; // ebx
  __int16 v21; // dx
  __int16 v22; // ax
  int v23; // ecx
  unsigned __int16 *v24; // esi
  _DWORD *v25; // eax
  int v26; // ecx
  unsigned __int8 **v28; // [esp+10h] [ebp-14h]
  __int16 v29; // [esp+14h] [ebp-10h]
  __int16 v30; // [esp+14h] [ebp-10h]
  int *v31; // [esp+18h] [ebp-Ch]
  int v32; // [esp+18h] [ebp-Ch]
  int v33; // [esp+1Ch] [ebp-8h]
  int v34; // [esp+20h] [ebp-4h]
  int v35; // [esp+28h] [ebp+4h]
  int v36; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v28 = v2;
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  v6 = 0;
  v5 = v3 - 1;
  BYTE1(v6) = *v4;
  v7 = v4 + 1;
  v35 = (unsigned __int16)v6;
  if ( !v5 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    {
      v7 = *v2;
      v5 = v2[1];
      v6 = v35;
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v8 = v5 - 1;
  v9 = *v7;
  v10 = v7 + 1;
  v11 = v9 + v6 - 2;
  v12 = v11 == 0;
  v36 = v11;
  if ( v11 > 0 )
  {
    do
    {
      if ( !v8 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v10 = *v2;
        v8 = v2[1];
      }
      v13 = *v10;
      *(_DWORD *)(*a1 + 20) = 81;
      v14 = v13 & 0xF;
      --v8;
      *(_DWORD *)(*a1 + 24) = v14;
      *(_DWORD *)(*a1 + 28) = v13 >> 4;
      ++v10;
      v33 = v13 >> 4;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      if ( v14 >= 4 )
      {
        *(_DWORD *)(*a1 + 20) = 31;
        *(_DWORD *)(*a1 + 24) = v14;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      if ( !a1[v14 + 36] )
        a1[v14 + 36] = sub_493730((int)a1);
      v15 = a1[v14 + 36];
      v16 = &dword_4B0ABC;
      v34 = v15;
      v31 = &dword_4B0ABC;
      do
      {
        if ( v33 )
        {
          if ( v8 )
          {
            v17 = v28;
          }
          else
          {
            v17 = v28;
            if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v28[3])(a1) )
              return 0;
            v10 = *v28;
            v8 = v28[1];
          }
          LOBYTE(v18) = 0;
          v19 = v8 - 1;
          HIBYTE(v18) = *v10;
          v20 = v10 + 1;
          v29 = v18;
          if ( !v19 )
          {
            if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v17[3])(a1) )
              return 0;
            v20 = *v17;
            v19 = v17[1];
          }
          v16 = v31;
          v8 = v19 - 1;
          v21 = *v20;
          v10 = v20 + 1;
          v30 = v21 + v29;
        }
        else
        {
          if ( !v8 )
          {
            if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v28[3])(a1) )
              return 0;
            v10 = *v28;
            v8 = v28[1];
          }
          --v8;
          v22 = *v10++;
          v30 = v22;
        }
        v23 = *v16++;
        *(_WORD *)(v34 + 2 * v23) = v30;
        v31 = v16;
      }
      while ( (int)v16 < (int)&unk_4B0BBC );
      if ( *(int *)(*a1 + 104) >= 2 )
      {
        v24 = (unsigned __int16 *)(v34 + 4);
        v32 = 8;
        do
        {
          v25 = (_DWORD *)(*a1 + 24);
          *v25 = *(v24 - 2);
          v25[1] = *(v24 - 1);
          v25[2] = *v24;
          v25[3] = v24[1];
          v25[4] = v24[2];
          v25[5] = v24[3];
          v25[6] = v24[4];
          v25[7] = v24[5];
          *(_DWORD *)(*a1 + 20) = 93;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
          v24 += 8;
          --v32;
        }
        while ( v32 );
      }
      v26 = v36 - 65;
      v36 -= 65;
      if ( v33 )
        v36 = v26 - 64;
      v2 = v28;
    }
    while ( v36 > 0 );
    v12 = v36 == 0;
  }
  if ( !v12 )
  {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  *v2 = v10;
  v2[1] = v8;
  return 1;
}
// 4B0ABC: using guessed type int dword_4B0ABC;

//----- (00490D80) --------------------------------------------------------
char __cdecl sub_490D80(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // edi
  int v6; // eax
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned __int16 v11; // cx
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // ebx
  int v15; // [esp+14h] [ebp+4h]
  int v16; // [esp+14h] [ebp+4h]
  int v17; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  v6 = 0;
  v5 = v3 - 1;
  BYTE1(v6) = *v4;
  v7 = v4 + 1;
  v15 = (unsigned __int16)v6;
  if ( !v5 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v5 = v2[1];
    v6 = v15;
  }
  v8 = v5 - 1;
  v9 = *v7 + v6;
  v10 = v7 + 1;
  if ( v9 != 4 )
  {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  LOBYTE(v11) = 0;
  v12 = v8 - 1;
  HIBYTE(v11) = *v10;
  v13 = v10 + 1;
  v16 = v11;
  if ( v12 )
  {
LABEL_15:
    v17 = *v13 + v16;
    *(_DWORD *)(*a1 + 20) = 82;
    *(_DWORD *)(*a1 + 24) = v17;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    a1[63] = v17;
    v2[1] = v12 - 1;
    *v2 = v13 + 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v13 = *v2;
    v12 = v2[1];
    goto LABEL_15;
  }
  return 0;
}

//----- (00490E70) --------------------------------------------------------
char __cdecl sub_490E70(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // edi
  int v6; // ecx
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // ebx
  int v12; // [esp+14h] [ebp+4h]
  int v13; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[6];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  v5 = v3 - 1;
  v6 = *v4;
  v7 = v4 + 1;
  v12 = v6;
  if ( v5 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v7 = *v2;
  v5 = v2[1];
  v6 = v12;
LABEL_7:
  v8 = v5 - 1;
  v9 = *v7;
  v10 = v7 + 1;
  v13 = v9;
  if ( v6 != 255 || v9 != 216 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = v6;
    *(_DWORD *)(*a1 + 28) = v9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v9 = v13;
  }
  a1[95] = v9;
  v2[1] = v8;
  *v2 = v10;
  return 1;
}

//----- (00490F10) --------------------------------------------------------
char __cdecl sub_490F10(_DWORD *a1)
{
  char result; // al

  if ( a1[95] || (result = sub_48F660(a1)) != 0 )
  {
    if ( a1[95] == *(_DWORD *)(a1[101] + 16) + 208 )
    {
      *(_DWORD *)(*a1 + 20) = 98;
      *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[101] + 16);
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
      a1[95] = 0;
LABEL_5:
      result = 1;
      *(_DWORD *)(a1[101] + 16) = ((unsigned __int8)*(_DWORD *)(a1[101] + 16) + 1) & 7;
      return result;
    }
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[6] + 20))(a1, *(_DWORD *)(a1[101] + 16));
    if ( result )
      goto LABEL_5;
  }
  return result;
}

//----- (00490FA0) --------------------------------------------------------
int __cdecl sub_490FA0(_DWORD *a1)
{
  int result; // eax

  result = a1[101];
  a1[49] = 0;
  a1[31] = 0;
  a1[95] = 0;
  *(_BYTE *)(result + 12) = 0;
  *(_BYTE *)(result + 13) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 160) = 0;
  return result;
}

//----- (004910B0) --------------------------------------------------------
char __cdecl sub_4910B0(int a1)
{
  int v1; // ecx
  _DWORD *v2; // edx
  unsigned __int8 **v3; // edi
  _DWORD *v4; // esi
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned __int8 *v7; // ebp
  int v8; // ebx
  unsigned __int8 *v9; // eax
  int v10; // ebx
  int v11; // eax
  unsigned int v12; // edi
  int v13; // eax
  char v14; // dl
  unsigned __int8 *v15; // ebx
  unsigned int v16; // edx
  unsigned int v17; // edi
  _DWORD **v18; // edi
  _DWORD *i; // eax
  unsigned __int8 *v21; // [esp+10h] [ebp-14h]
  unsigned int v22; // [esp+14h] [ebp-10h]
  unsigned __int8 **v23; // [esp+18h] [ebp-Ch]
  int v24; // [esp+1Ch] [ebp-8h]
  _DWORD *v25; // [esp+20h] [ebp-4h]

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 404);
  v3 = *(unsigned __int8 ***)(a1 + 24);
  v25 = v2;
  v4 = (_DWORD *)v2[40];
  v24 = 0;
  v5 = *v3;
  v6 = v3[1];
  v23 = v3;
  v21 = *v3;
  if ( v4 )
  {
    v17 = v2[41];
    v22 = v4[3];
    v15 = (unsigned __int8 *)(v4[4] + v17);
    v16 = v22;
LABEL_17:
    while ( v17 < v16 )
    {
      *v23 = v5;
      v23[1] = v6;
      v25[41] = v17;
      if ( !v6 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v23[3])(v1) )
          return 0;
        v6 = v23[1];
        v21 = *v23;
        v5 = *v23;
        v1 = a1;
      }
      v16 = v22;
      while ( v6 )
      {
        *v15 = *v5;
        v16 = v22;
        ++v15;
        ++v5;
        --v6;
        ++v17;
        v21 = v5;
        if ( v17 >= v22 )
          goto LABEL_26;
      }
    }
LABEL_26:
    if ( v4 )
    {
      v18 = *(_DWORD ***)(v1 + 268);
      if ( v18 )
      {
        for ( i = *v18; i; i = (_DWORD *)*i )
          v18 = (_DWORD **)i;
        *v18 = v4;
      }
      else
      {
        *(_DWORD *)(v1 + 268) = v4;
      }
      v15 = (unsigned __int8 *)v4[4];
      v24 = v4[2] - v16;
    }
    goto LABEL_34;
  }
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a1) )
      return 0;
    v6 = v3[1];
    v5 = *v3;
    v1 = a1;
  }
  v8 = 0;
  v7 = v6 - 1;
  BYTE1(v8) = *v5;
  v9 = v5 + 1;
  if ( v7 )
    goto LABEL_8;
  if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(v1) )
    return 0;
  v1 = a1;
  v7 = v3[1];
  v9 = *v3;
LABEL_8:
  v6 = v7 - 1;
  v10 = *v9 + v8 - 2;
  v21 = v9 + 1;
  v24 = v10;
  if ( v10 >= 0 )
  {
    v11 = *(_DWORD *)(v1 + 380);
    if ( v11 == 254 )
    {
      v12 = v25[23];
      v22 = v12;
    }
    else
    {
      v22 = v25[v11 - 200];
      v12 = v22;
    }
    if ( v10 < v12 )
    {
      v22 = v10;
      v12 = v10;
    }
    v13 = (*(int (__cdecl **)(int, int, unsigned int))(*(_DWORD *)(v1 + 4) + 4))(v1, 1, v12 + 20);
    v1 = a1;
    v4 = (_DWORD *)v13;
    *(_DWORD *)v13 = 0;
    v14 = *(_BYTE *)(a1 + 380);
    *(_DWORD *)(v13 + 8) = v10;
    v15 = (unsigned __int8 *)(v13 + 20);
    *(_BYTE *)(v13 + 4) = v14;
    v16 = v22;
    *(_DWORD *)(v13 + 12) = v12;
    *(_DWORD *)(v13 + 16) = v13 + 20;
    v25[40] = v13;
    v25[41] = 0;
    v5 = v21;
    v17 = 0;
    goto LABEL_17;
  }
  v15 = 0;
  v16 = 0;
LABEL_34:
  v25[40] = 0;
  if ( *(_DWORD *)(v1 + 380) == 224 )
  {
    sub_48F920(v1, v15, v16, v24);
  }
  else if ( *(_DWORD *)(v1 + 380) == 238 )
  {
    sub_48FBB0((_BYTE *)v1, v15, v16, v24);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)v1 + 20) = 91;
    *(_DWORD *)(*(_DWORD *)v1 + 24) = *(_DWORD *)(v1 + 380);
    *(_DWORD *)(*(_DWORD *)v1 + 28) = v24 + v16;
    (*(void (__cdecl **)(int, int))(*(_DWORD *)v1 + 4))(v1, 1);
  }
  *v23 = v21;
  v23[1] = v6;
  if ( v24 > 0 )
    (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 24) + 16))(a1, v24);
  return 1;
}

//----- (00491390) --------------------------------------------------------
int (__cdecl **__cdecl jpeg_std_error(int (__cdecl **a1)(int a1)))(int a1)
{
  int (__cdecl **result)(int); // eax

  result = a1;
  *a1 = sub_4913E0;
  a1[1] = (int (__cdecl *)(int))sub_491430;
  a1[2] = sub_491400;
  a1[3] = (int (__cdecl *)(int))sub_491470;
  a1[4] = (int (__cdecl *)(int))sub_491520;
  a1[26] = 0;
  a1[27] = 0;
  a1[5] = 0;
  a1[28] = (int (__cdecl *)(int))off_4B0508;
  a1[29] = (int (__cdecl *)(int))123;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  return result;
}
// 4B0508: using guessed type char *off_4B0508[124];

//----- (004913E0) --------------------------------------------------------
int __cdecl sub_4913E0(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  sub_493710(a1);
  sub_46E4AC(1);
  return sub_491400(a1);
}
// 491400: using guessed type _DWORD __cdecl sub_491400(_DWORD);

//----- (00491400) --------------------------------------------------------
int __cdecl sub_491400(int a1)
{
  char v2[200]; // [esp+0h] [ebp-C8h] BYREF

  (*(void (__cdecl **)(int, char *))(*(_DWORD *)a1 + 12))(a1, v2);
  return fprintf(&Stream, "%s\n", v2);
}

//----- (00491430) --------------------------------------------------------
int __cdecl sub_491430(int *a1, int a2)
{
  int result; // eax
  int v3; // esi

  result = a2;
  v3 = *a1;
  if ( a2 >= 0 )
  {
    if ( *(_DWORD *)(v3 + 104) >= a2 )
      result = (*(int (__cdecl **)(int *))(v3 + 8))(a1);
  }
  else
  {
    if ( !*(_DWORD *)(v3 + 108) || *(int *)(v3 + 104) >= 3 )
      (*(void (__cdecl **)(int *))(v3 + 8))(a1);
    result = *(_DWORD *)(v3 + 108) + 1;
    *(_DWORD *)(v3 + 108) = result;
  }
  return result;
}

//----- (00491470) --------------------------------------------------------
int __cdecl sub_491470(int a1, char *Buffer)
{
  _DWORD *v2; // eax
  int v3; // ecx
  const char *v4; // edx
  int v5; // esi
  int v6; // edx
  char v7; // cl
  char *v8; // esi
  bool v9; // zf
  int result; // eax

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( v3 <= 0 || v3 > v2[29] )
  {
    v5 = v2[30];
    if ( !v5 )
      goto LABEL_9;
    v6 = v2[31];
    if ( v3 < v6 || v3 > v2[32] )
      goto LABEL_9;
    v4 = *(const char **)(v5 + 4 * (v3 - v6));
  }
  else
  {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if ( !v4 )
  {
LABEL_9:
    v2[6] = v3;
    v4 = *(const char **)v2[28];
  }
  v7 = *v4;
  v8 = (char *)(v4 + 1);
  if ( !*v4 )
    goto LABEL_13;
  while ( 1 )
  {
    v9 = v7 == 37;
    v7 = *v8;
    if ( v9 )
      break;
    ++v8;
    if ( !v7 )
      goto LABEL_13;
  }
  if ( v7 == 115 )
    result = sprintf_0(Buffer, v4, v2 + 6);
  else
LABEL_13:
    result = sprintf_0(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  return result;
}

//----- (00491520) --------------------------------------------------------
int __cdecl sub_491520(int *a1)
{
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

//----- (00491540) --------------------------------------------------------
_DWORD *__cdecl sub_491540(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ebp
  int v5; // ecx
  _DWORD *result; // eax

  a1[1] = 0;
  if ( a2 != 62 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = 62;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 360 )
  {
    *(_DWORD *)(*a1 + 20) = 21;
    *(_DWORD *)(*a1 + 24) = 360;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  v4 = a1[3];
  memset(a1, 0, 0x168u);
  *a1 = v3;
  a1[3] = v4;
  *((_BYTE *)a1 + 16) = 0;
  sub_492AB0(a1);
  a1[2] = 0;
  a1[6] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[20] = 0;
  v5 = 4;
  a1[21] = 0;
  result = a1 + 26;
  do
  {
    *(result - 4) = 0;
    *result++ = 0;
    --v5;
  }
  while ( v5 );
  a1[12] = 0;
  a1[88] = 0;
  a1[13] = 1072693248;
  a1[5] = 100;
  return result;
}

//----- (00491610) --------------------------------------------------------
int __cdecl sub_491610(int a1)
{
  return sub_493710(a1);
}

//----- (00491630) --------------------------------------------------------
int __cdecl sub_491630(int a1, char a2)
{
  int v2; // esi
  int v3; // ecx
  int result; // eax
  int v5; // esi
  int v6; // ecx

  v2 = 4;
  v3 = a1 + 72;
  do
  {
    if ( *(_DWORD *)v3 )
      *(_BYTE *)(*(_DWORD *)v3 + 128) = a2;
    v3 += 4;
    --v2;
  }
  while ( v2 );
  result = a1 + 104;
  v5 = 4;
  do
  {
    v6 = *(_DWORD *)(result - 16);
    if ( v6 )
      *(_BYTE *)(v6 + 273) = a2;
    if ( *(_DWORD *)result )
      *(_BYTE *)(*(_DWORD *)result + 273) = a2;
    result += 4;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (00491680) --------------------------------------------------------
char __cdecl sub_491680(_DWORD *a1)
{
  int v1; // eax
  int i; // eax
  unsigned int j; // edi
  int v4; // eax

  v1 = a1[5];
  if ( v1 == 101 || v1 == 102 )
  {
    if ( a1[52] < a1[8] )
    {
      *(_DWORD *)(*a1 + 20) = 67;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    (*(void (__cdecl **)(_DWORD *))(a1[79] + 8))(a1);
  }
  else if ( v1 != 103 )
  {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  for ( i = a1[79]; !*(_BYTE *)(i + 13); i = a1[79] )
  {
    (*(void (__cdecl **)(_DWORD *))i)(a1);
    for ( j = 0; j < a1[56]; ++j )
    {
      v4 = a1[2];
      if ( v4 )
      {
        *(_DWORD *)(v4 + 4) = j;
        *(_DWORD *)(a1[2] + 8) = a1[56];
        (*(void (__cdecl **)(_DWORD *))a1[2])(a1);
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD))(a1[82] + 4))(a1, 0) )
      {
        *(_DWORD *)(*a1 + 20) = 24;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    (*(void (__cdecl **)(_DWORD *))(a1[79] + 8))(a1);
  }
  (*(void (__cdecl **)(_DWORD *))(a1[83] + 12))(a1);
  (*(void (__cdecl **)(_DWORD *))(a1[6] + 16))(a1);
  return sub_4936D0((int)a1);
}

//----- (004918E0) --------------------------------------------------------
int __cdecl sub_4918E0(_DWORD *a1, char a2)
{
  int result; // eax
  char v3; // dl

  if ( a1[5] != 100 )
  {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 )
    sub_491630((int)a1, 0);
  (*(void (__cdecl **)(_DWORD *))(*a1 + 16))(a1);
  (*(void (__cdecl **)(_DWORD *))(a1[6] + 8))(a1);
  sub_494880((int)a1);
  result = (*(int (__cdecl **)(_DWORD *))a1[79])(a1);
  v3 = *((_BYTE *)a1 + 176);
  a1[52] = 0;
  a1[5] = (v3 != 0) + 101;
  return result;
}

//----- (00491960) --------------------------------------------------------
_DWORD *__cdecl sub_491960(_DWORD *a1, int a2, unsigned int a3)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  _DWORD *result; // eax
  _DWORD *v9; // [esp-4h] [ebp-8h]

  v3 = a1;
  if ( a1[5] != 101 )
  {
    v9 = a1;
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*v3 + 24) = v3[5];
    (*(void (__cdecl **)(_DWORD *))*v3)(v9);
  }
  if ( v3[52] >= v3[8] )
  {
    *(_DWORD *)(*v3 + 20) = 123;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
  }
  v4 = v3[2];
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = v3[52];
    *(_DWORD *)(v3[2] + 8) = v3[8];
    (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
  }
  v5 = v3[79];
  if ( *(_BYTE *)(v5 + 12) )
    (*(void (__cdecl **)(_DWORD *))(v5 + 4))(v3);
  v6 = a3;
  if ( a3 > v3[8] - v3[52] )
    v6 = v3[8] - v3[52];
  v7 = v3[80];
  a1 = 0;
  (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, v6);
  result = a1;
  v3[52] += a1;
  return result;
}

//----- (00491B00) --------------------------------------------------------
int __cdecl sub_491B00(_DWORD *a1, int a2, _DWORD *a3, int a4, char a5)
{
  int i; // esi
  int v7; // edx
  int result; // eax

  if ( a1[5] != 100 )
  {
    *(_DWORD *)(*a1 + 20) = 20;
    *(_DWORD *)(*a1 + 24) = a1[5];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 < 0 || a2 >= 4 )
  {
    *(_DWORD *)(*a1 + 20) = 31;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !a1[a2 + 18] )
    a1[a2 + 18] = sub_493730((int)a1);
  for ( i = 0; i < 128; *(_WORD *)(result + i - 2) = v7 )
  {
    v7 = (*a3 * a4 + 50) / 100;
    if ( v7 > 0 )
    {
      if ( v7 > 0x7FFF )
        v7 = 0x7FFF;
    }
    else
    {
      v7 = 1;
    }
    if ( a5 && v7 > 255 )
      LOWORD(v7) = 255;
    result = a1[a2 + 18];
    i += 2;
    ++a3;
  }
  *(_BYTE *)(a1[a2 + 18] + 128) = 0;
  return result;
}

//----- (00491BE0) --------------------------------------------------------
int __cdecl jpeg_set_linear_quality(_DWORD *a1, int a2, char a3)
{
  sub_491B00(a1, 0, dword_4B06FC, a2, a3);
  return sub_491B00(a1, 1, dword_4B07FC, a2, a3);
}

//----- (00491C20) --------------------------------------------------------
int __cdecl sub_491C20(int a1)
{
  int v1; // ecx

  v1 = a1;
  if ( a1 <= 0 )
    return 5000;
  if ( a1 > 100 )
  {
    v1 = 100;
    return 2 * (100 - v1);
  }
  if ( a1 >= 50 )
    return 2 * (100 - v1);
  return 5000 / a1;
}

//----- (00491C60) --------------------------------------------------------
int __cdecl sub_491C60(_DWORD *a1, int a2, char a3)
{
  int v3; // eax

  v3 = sub_491C20(a2);
  return jpeg_set_linear_quality(a1, v3, a3);
}

//----- (00491C80) --------------------------------------------------------
_DWORD *__cdecl sub_491C80(int a1)
{
  _BYTE *v1; // eax
  int v2; // eax

  if ( *(_DWORD *)(a1 + 20) != 100 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 68) )
    *(_DWORD *)(a1 + 68) = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 840);
  *(_DWORD *)(a1 + 56) = 8;
  sub_491C60((_DWORD *)a1, 75, 1);
  sub_491D80((int *)a1);
  v1 = (_BYTE *)(a1 + 136);
  do
  {
    *(v1 - 16) = 0;
    *v1 = 1;
    v1[16] = 5;
    ++v1;
  }
  while ( (int)&v1[-136 - a1] < 16 );
  v2 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 177) = 0;
  *(_BYTE *)(a1 + 178) = 0;
  if ( v2 > 8 )
    *(_BYTE *)(a1 + 178) = 1;
  *(_BYTE *)(a1 + 179) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 197) = 1;
  *(_BYTE *)(a1 + 198) = 1;
  *(_BYTE *)(a1 + 199) = 0;
  *(_WORD *)(a1 + 200) = 1;
  *(_WORD *)(a1 + 202) = 1;
  return sub_491E80((_DWORD *)a1);
}

//----- (00491D80) --------------------------------------------------------
int __cdecl sub_491D80(int *a1)
{
  sub_491DE0((int)a1, a1 + 22, (int)&unk_4B08FC, &unk_4B0910);
  sub_491DE0((int)a1, a1 + 26, (int)&unk_4B093C, &unk_4B0950);
  sub_491DE0((int)a1, a1 + 23, (int)&unk_4B091C, &unk_4B0930);
  return sub_491DE0((int)a1, a1 + 27, (int)&unk_4B09F4, &unk_4B0A08);
}

//----- (00491DE0) --------------------------------------------------------
int __cdecl sub_491DE0(int a1, int *a2, int a3, const void *a4)
{
  int v4; // edx
  signed int v5; // esi
  int i; // eax
  int result; // eax

  if ( !*a2 )
    *a2 = sub_493750(a1);
  v4 = *a2;
  *(_DWORD *)v4 = *(_DWORD *)a3;
  *(_DWORD *)(v4 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  v5 = 0;
  *(_BYTE *)(v4 + 16) = *(_BYTE *)(a3 + 16);
  for ( i = 1; i <= 16; ++i )
    v5 += *(unsigned __int8 *)(i + a3);
  if ( v5 < 1 || v5 > 256 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  qmemcpy((void *)(*a2 + 17), a4, v5);
  result = *a2;
  *(_BYTE *)(*a2 + 273) = 0;
  return result;
}

//----- (00491E80) --------------------------------------------------------
_DWORD *__cdecl sub_491E80(_DWORD *a1)
{
  _DWORD *result; // eax

  switch ( a1[10] )
  {
    case 0:
      result = sub_491F00((int)a1, 0);
      break;
    case 1:
      result = sub_491F00((int)a1, 1);
      break;
    case 2:
    case 3:
      result = sub_491F00((int)a1, 3);
      break;
    case 4:
      result = sub_491F00((int)a1, 4);
      break;
    case 5:
      result = sub_491F00((int)a1, 5);
      break;
    default:
      *(_DWORD *)(*a1 + 20) = 9;
      result = (_DWORD *)(*(int (__cdecl **)(_DWORD *))*a1)(a1);
      break;
  }
  return result;
}

//----- (00491F00) --------------------------------------------------------
_DWORD *__cdecl sub_491F00(int a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  int v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // esi
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int *v19; // eax

  if ( *(_DWORD *)(a1 + 20) != 100 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_BYTE *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 204) = 0;
  switch ( a2 )
  {
    case 0:
      v16 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 60) = v16;
      if ( v16 < 1 || v16 > 10 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 26;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 60);
        *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      result = *(_DWORD **)(a1 + 60);
      v17 = 0;
      if ( (int)result > 0 )
      {
        v18 = 0;
        do
        {
          v19 = (int *)(*(_DWORD *)(a1 + 68) + v18);
          v18 += 84;
          *v19 = v17;
          v19[2] = 1;
          v19[3] = 1;
          v19[4] = 0;
          v19[5] = 0;
          v19[6] = 0;
          result = *(_DWORD **)(a1 + 60);
          ++v17;
        }
        while ( v17 < (int)result );
      }
      break;
    case 1:
      result = 0;
      *(_BYTE *)(a1 + 196) = 1;
      *(_DWORD *)(a1 + 60) = 1;
      v3 = *(_DWORD **)(a1 + 68);
      *v3 = 1;
      v3[2] = 1;
      v3[3] = 1;
      v3[4] = 0;
      v3[5] = 0;
      v3[6] = 0;
      break;
    case 2:
      v4 = *(_DWORD **)(a1 + 68);
      *(_BYTE *)(a1 + 204) = 1;
      *(_DWORD *)(a1 + 60) = 3;
      *v4 = 82;
      v4[2] = 1;
      v4[3] = 1;
      v4[4] = 0;
      v4[5] = 0;
      v4[6] = 0;
      result = (_DWORD *)(*(_DWORD *)(a1 + 68) + 84);
      *result = 71;
      result[2] = 1;
      result[3] = 1;
      result[4] = 0;
      result[5] = 0;
      result[6] = 0;
      v5 = *(_DWORD **)(a1 + 68);
      v5[42] = 66;
      v5 += 42;
      v5[2] = 1;
      v5[3] = 1;
      v5[4] = 0;
      v5[5] = 0;
      v5[6] = 0;
      break;
    case 3:
      v6 = *(_DWORD **)(a1 + 68);
      *(_BYTE *)(a1 + 196) = 1;
      *(_DWORD *)(a1 + 60) = 3;
      *v6 = 1;
      v6[2] = 2;
      v6[3] = 2;
      v6[4] = 0;
      v6[5] = 0;
      v6[6] = 0;
      v7 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(v7 + 84) = 2;
      result = (_DWORD *)(v7 + 84);
      result[2] = 1;
      result[3] = 1;
      result[4] = 1;
      result[5] = 1;
      result[6] = 1;
      v8 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 168);
      *v8 = 3;
      v8[2] = 1;
      v8[3] = 1;
      v8[4] = 1;
      v8[5] = 1;
      v8[6] = 1;
      break;
    case 4:
      v9 = *(_DWORD **)(a1 + 68);
      *(_BYTE *)(a1 + 204) = 1;
      *(_DWORD *)(a1 + 60) = 4;
      *v9 = 67;
      v9[2] = 1;
      v9[3] = 1;
      v9[4] = 0;
      v9[5] = 0;
      v9[6] = 0;
      v10 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 84);
      *v10 = 77;
      v10[2] = 1;
      v10[3] = 1;
      v10[4] = 0;
      v10[5] = 0;
      v10[6] = 0;
      v11 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(v11 + 168) = 89;
      result = (_DWORD *)(v11 + 168);
      result[2] = 1;
      result[3] = 1;
      result[4] = 0;
      result[5] = 0;
      result[6] = 0;
      v12 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 252);
      *v12 = 75;
      v12[2] = 1;
      v12[3] = 1;
      v12[4] = 0;
      v12[5] = 0;
      v12[6] = 0;
      break;
    case 5:
      v13 = *(_DWORD **)(a1 + 68);
      *(_BYTE *)(a1 + 204) = 1;
      *(_DWORD *)(a1 + 60) = 4;
      *v13 = 1;
      v13[2] = 2;
      v13[3] = 2;
      v13[4] = 0;
      v13[5] = 0;
      v13[6] = 0;
      v14 = *(_DWORD **)(a1 + 68);
      v14[21] = 2;
      v14 += 21;
      v14[2] = 1;
      v14[3] = 1;
      v14[4] = 1;
      v14[5] = 1;
      v14[6] = 1;
      result = (_DWORD *)(*(_DWORD *)(a1 + 68) + 168);
      *result = 3;
      result[2] = 1;
      result[3] = 1;
      result[4] = 1;
      result[5] = 1;
      result[6] = 1;
      v15 = *(_DWORD **)(a1 + 68);
      v15[63] = 4;
      v15 += 63;
      v15[2] = 2;
      v15[3] = 2;
      v15[4] = 0;
      v15[5] = 0;
      v15[6] = 0;
      break;
    default:
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
      result = (_DWORD *)(**(int (__cdecl ***)(int))a1)(a1);
      break;
  }
  return result;
}

//----- (004923B0) --------------------------------------------------------
_DWORD *__cdecl sub_4923B0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  a1[1] = a2;
  a1[5] = a3;
  a1[6] = a4;
  *a1 = 1;
  a1[7] = a5;
  a1[8] = a6;
  return a1 + 9;
}

//----- (004923F0) --------------------------------------------------------
_DWORD *__cdecl sub_4923F0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  _DWORD *result; // eax

  v6 = 0;
  if ( a2 <= 0 )
    return a1;
  result = a1;
  do
  {
    *result = 1;
    result[1] = v6;
    result[5] = a3;
    result[6] = a4;
    result[7] = a5;
    result[8] = a6;
    result += 9;
    ++v6;
  }
  while ( v6 < a2 );
  return result;
}

//----- (00492440) --------------------------------------------------------
int *__cdecl sub_492440(int *a1, int a2, int a3, int a4)
{
  int v4; // ecx
  _DWORD *v5; // esi

  if ( a2 > 4 )
    return sub_4923F0(a1, a2, 0, 0, a3, a4);
  v4 = 0;
  *a1 = a2;
  if ( a2 > 0 )
  {
    v5 = a1 + 1;
    do
      *v5++ = v4++;
    while ( v4 < a2 );
  }
  a1[6] = 0;
  a1[5] = 0;
  a1[7] = a3;
  a1[8] = a4;
  return a1 + 9;
}

//----- (004924B0) --------------------------------------------------------
int __cdecl sub_4924B0(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 400) = result;
  *(_DWORD *)result = sub_4927C0;
  *(_DWORD *)(result + 4) = sub_492A70;
  *(_DWORD *)(result + 8) = sub_492500;
  *(_DWORD *)(result + 12) = sub_4927A0;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_BYTE *)(result + 20) = 1;
  return result;
}
// 4927A0: using guessed type int sub_4927A0();
// 492A70: using guessed type int sub_492A70();

//----- (00492500) --------------------------------------------------------
_DWORD *__cdecl sub_492500(int a1)
{
  _DWORD *result; // eax

  sub_492540((int *)a1);
  sub_4926F0(a1);
  (**(void (__cdecl ***)(int))(a1 + 408))(a1);
  (**(void (__cdecl ***)(int))(a1 + 392))(a1);
  result = *(_DWORD **)(a1 + 400);
  *result = *(_DWORD *)(*(_DWORD *)(a1 + 392) + 4);
  return result;
}

//----- (00492540) --------------------------------------------------------
int __cdecl sub_492540(int *a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  int result; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  int v11; // edx
  unsigned int v12; // ebp
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  bool v18; // cc
  int *v19; // [esp+Ch] [ebp-4h]
  int v20; // [esp+14h] [ebp+4h]

  v2 = a1[73];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)a1[74];
    a1[78] = v3[7];
    a1[79] = v3[8];
    v4 = v3[3];
    v3[16] = v3[9];
    result = v3[8] / v4;
    v6 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[17] = 1;
    if ( !v6 )
      v6 = v4;
    v3[18] = v6;
    a1[80] = 1;
    a1[81] = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[73];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    v7 = sub_493EC0(a1[7], 8 * a1[68]);
    v8 = a1[69];
    a1[78] = v7;
    a1[79] = sub_493EC0(a1[8], 8 * v8);
    result = a1[73];
    a1[80] = 0;
    v20 = 0;
    if ( result > 0 )
    {
      v19 = a1 + 74;
      do
      {
        v9 = (_DWORD *)*v19;
        v10 = *(_DWORD *)(*v19 + 8);
        v9[16] = v10 * *(_DWORD *)(*v19 + 36);
        v11 = v9[7] % v10;
        v12 = v9[3];
        v9[13] = v10;
        v9[14] = v12;
        v13 = v10 * v12;
        v9[15] = v10 * v12;
        if ( !v11 )
          v11 = v10;
        v14 = v9[8];
        v9[17] = v11;
        v15 = v14 % v12;
        if ( !(v14 % v12) )
          v15 = v12;
        v9[18] = v15;
        if ( v13 + a1[80] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 13;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v10 * v12) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            a1[a1[80] + 81] = v20;
            --v17;
            ++a1[80];
          }
          while ( v17 );
        }
        result = v20 + 1;
        v18 = ++v20 < a1[73];
        ++v19;
      }
      while ( v18 );
    }
  }
  return result;
}

//----- (004926F0) --------------------------------------------------------
int __cdecl sub_4926F0(int a1)
{
  int result; // eax
  int v3; // ebp
  int v4; // esi
  void *v5; // eax
  bool v6; // cc
  int v7; // [esp+4h] [ebp-4h]
  int *v8; // [esp+Ch] [ebp+4h]

  v7 = 0;
  result = *(_DWORD *)(a1 + 292);
  if ( result > 0 )
  {
    v8 = (int *)(a1 + 296);
    do
    {
      v3 = *v8;
      if ( !*(_DWORD *)(*v8 + 76) )
      {
        v4 = *(_DWORD *)(v3 + 16);
        if ( v4 < 0 || v4 >= 4 || !*(_DWORD *)(a1 + 4 * v4 + 144) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 52;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v5 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
        qmemcpy(v5, *(const void **)(a1 + 4 * v4 + 144), 0x82u);
        *(_DWORD *)(v3 + 76) = v5;
      }
      result = v7 + 1;
      v6 = ++v7 < *(_DWORD *)(a1 + 292);
      ++v8;
    }
    while ( v6 );
  }
  return result;
}

//----- (004927C0) --------------------------------------------------------
int __cdecl sub_4927C0(_DWORD *a1)
{
  _BYTE *v1; // edi
  int result; // eax
  int v3; // ebx
  char v4; // al
  int v5; // eax

  v1 = (_BYTE *)a1[100];
  if ( v1[17] )
    return 2;
  v3 = (*(int (__cdecl **)(_DWORD *))(a1[101] + 4))(a1);
  if ( v3 == 1 )
  {
    if ( v1[20] )
    {
      sub_492880((int)a1);
      result = 1;
      v1[20] = 0;
      return result;
    }
    if ( !v1[16] )
    {
      *(_DWORD *)(*a1 + 20) = 35;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_492500((int)a1);
  }
  else if ( v3 == 2 )
  {
    v4 = v1[20];
    v1[17] = 1;
    if ( v4 )
    {
      if ( *(_BYTE *)(a1[101] + 13) )
      {
        *(_DWORD *)(*a1 + 20) = 59;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        return v3;
      }
    }
    else
    {
      v5 = a1[31];
      if ( a1[33] > v5 )
      {
        a1[33] = v5;
        return v3;
      }
    }
  }
  return v3;
}

//----- (00492880) --------------------------------------------------------
char __cdecl sub_492880(int a1)
{
  int v1; // ecx
  int v2; // ebp
  int *v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ebp
  int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax

  if ( *(int *)(a1 + 32) > 65500 || *(int *)(a1 + 28) > 65500 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 41;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 65500;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_DWORD *)(a1 + 192) != 8 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 15;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 192);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(int *)(a1 + 36) > 10 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 26;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = *(_DWORD *)(a1 + 36);
  v2 = 0;
  *(_DWORD *)(a1 + 272) = 1;
  *(_DWORD *)(a1 + 276) = 1;
  if ( v1 > 0 )
  {
    v3 = (int *)(*(_DWORD *)(a1 + 196) + 12);
    do
    {
      v4 = *(v3 - 1);
      if ( v4 <= 0 || v4 > 4 || *v3 <= 0 || *v3 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v5 = *(_DWORD *)(a1 + 272);
      if ( v5 <= *(v3 - 1) )
        v5 = *(v3 - 1);
      *(_DWORD *)(a1 + 272) = v5;
      v6 = *(_DWORD *)(a1 + 276);
      if ( v6 <= *v3 )
        v6 = *v3;
      *(_DWORD *)(a1 + 276) = v6;
      ++v2;
      v3 += 21;
    }
    while ( v2 < *(_DWORD *)(a1 + 36) );
  }
  v7 = *(_DWORD *)(a1 + 36);
  v8 = *(_DWORD *)(a1 + 196);
  v9 = 0;
  *(_DWORD *)(a1 + 280) = 8;
  if ( v7 > 0 )
  {
    v10 = v8 + 28;
    do
    {
      v11 = *(_DWORD *)(v10 - 20);
      *(_DWORD *)(v10 + 8) = 8;
      v12 = sub_493EC0(*(_DWORD *)(a1 + 28) * v11, 8 * *(_DWORD *)(a1 + 272));
      v13 = *(_DWORD *)(v10 - 16);
      *(_DWORD *)v10 = v12;
      v14 = sub_493EC0(*(_DWORD *)(a1 + 32) * v13, 8 * *(_DWORD *)(a1 + 276));
      v15 = *(_DWORD *)(v10 - 20);
      *(_DWORD *)(v10 + 4) = v14;
      *(_DWORD *)(v10 + 12) = sub_493EC0(*(_DWORD *)(a1 + 28) * v15, *(_DWORD *)(a1 + 272));
      *(_DWORD *)(v10 + 16) = sub_493EC0(*(_DWORD *)(a1 + 32) * *(_DWORD *)(v10 - 16), *(_DWORD *)(a1 + 276));
      *(_BYTE *)(v10 + 20) = 1;
      *(_DWORD *)(v10 + 48) = 0;
      ++v9;
      v10 += 84;
    }
    while ( v9 < *(_DWORD *)(a1 + 36) );
  }
  v16 = sub_493EC0(*(_DWORD *)(a1 + 32), 8 * *(_DWORD *)(a1 + 276));
  v17 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 284) = v16;
  v18 = *(_DWORD *)(a1 + 292);
  *(_BYTE *)(*(_DWORD *)(a1 + 400) + 16) = v18 < v17 || (LOBYTE(v18) = *(_BYTE *)(a1 + 200), (_BYTE)v18);
  return v18;
}

//----- (00492AB0) --------------------------------------------------------
const char *__cdecl sub_492AB0(_DWORD *a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // esi
  int v3; // ecx
  _DWORD *v4; // eax
  const char *result; // eax
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v1 = a1;
  a1[1] = 0;
  v6 = sub_4949B0();
  v2 = (_DWORD *)sub_494940((int)v1, 0x54u);
  if ( !v2 )
  {
    nullsub_13(v1);
    *(_DWORD *)(*v1 + 20) = 54;
    *(_DWORD *)(*v1 + 24) = 0;
    (*(void (__cdecl **)(_DWORD *))*v1)(v1);
  }
  *v2 = sub_492BF0;
  v2[1] = sub_492D40;
  v2[2] = sub_492DF0;
  v2[3] = sub_492EA0;
  v2[4] = sub_492F50;
  v2[5] = sub_492FC0;
  v2[6] = sub_493030;
  v2[7] = sub_4931B0;
  v2[8] = sub_4933A0;
  v2[9] = sub_493590;
  v2[10] = sub_493690;
  v2[12] = 1000000000;
  v3 = 2;
  v2[11] = v6;
  v4 = v2 + 16;
  do
  {
    *(v4 - 2) = 0;
    *v4-- = 0;
    --v3;
  }
  while ( v3 );
  v2[17] = 0;
  v2[18] = 0;
  v2[19] = 84;
  v1[1] = v2;
  result = sub_478C35(aJpegmem);
  if ( result )
  {
    LOBYTE(a1) = 120;
    result = (const char *)sscanf(result, "%ld%c", &v6, &a1);
    if ( (int)result > 0 )
    {
      if ( (_BYTE)a1 == 109 || (_BYTE)a1 == 77 )
      {
        result = (const char *)(1000000 * v6);
        v2[11] = 1000000 * v6;
      }
      else
      {
        result = (const char *)(1000 * v6);
        v2[11] = 1000 * v6;
      }
    }
  }
  return result;
}
// 493690: using guessed type int sub_493690();
// 4949C0: using guessed type int __cdecl nullsub_13(_DWORD);

//----- (00492BF0) --------------------------------------------------------
int __cdecl sub_492BF0(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v4; // edi
  _DWORD *v5; // ebp
  _DWORD *i; // eax
  unsigned int v7; // edi
  unsigned int v8; // esi
  int v9; // ecx
  int v11; // [esp+14h] [ebp+4h]

  v4 = a3;
  v11 = a1[1];
  if ( a3 > 0x3B9AC9F0 )
    sub_492D20((int)a1, 1);
  if ( (a3 & 7) != 0 )
  {
    v4 = 8 - (a3 & 7) + a3;
    a3 = v4;
  }
  if ( a2 < 0 || a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v5 = 0;
  i = *(_DWORD **)(v11 + 4 * a2 + 52);
  if ( i )
  {
    while ( i[2] < v4 )
    {
      v5 = i;
      i = (_DWORD *)*i;
      if ( !i )
        goto LABEL_13;
    }
  }
  else
  {
LABEL_13:
    v7 = v4 + 16;
    if ( v5 )
      v8 = dword_4B0AB4[a2];
    else
      v8 = dword_4B0AAC[a2];
    if ( v8 > 1000000000 - v7 )
      v8 = 1000000000 - v7;
    for ( i = (_DWORD *)sub_494940((int)a1, v8 + v7); !i; i = (_DWORD *)sub_494940((int)a1, v8 + v7) )
    {
      v8 >>= 1;
      if ( v8 < 0x32 )
        sub_492D20((int)a1, 2);
    }
    *(_DWORD *)(v11 + 76) += v8 + v7;
    *i = 0;
    i[1] = 0;
    i[2] = a3 + v8;
    if ( v5 )
      *v5 = i;
    else
      *(_DWORD *)(v11 + 4 * a2 + 52) = i;
    v4 = a3;
  }
  v9 = i[1];
  i[1] = v4 + v9;
  i[2] -= v4;
  return (int)i + v9 + 16;
}
// 492C6C: conditional instruction was optimized away because of 'eax.4!=0'
// 4B0AAC: using guessed type int dword_4B0AAC[];
// 4B0AB4: using guessed type int dword_4B0AB4[];

//----- (00492D20) --------------------------------------------------------
int __cdecl sub_492D20(int a1, int a2)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 54;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a2;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

//----- (00492D40) --------------------------------------------------------
_DWORD *__cdecl sub_492D40(_DWORD *a1, int a2, unsigned int a3)
{
  unsigned int v3; // edi
  int v4; // ebx
  _DWORD *v5; // esi
  int v6; // edx

  v3 = a3;
  v4 = a1[1];
  if ( a3 > 0x3B9AC9F0 )
    sub_492D20((int)a1, 3);
  if ( (a3 & 7) != 0 )
    v3 = 8 - (a3 & 7) + a3;
  if ( a2 < 0 || a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v5 = (_DWORD *)sub_494960((int)a1, v3 + 16);
  if ( !v5 )
    sub_492D20((int)a1, 4);
  *(_DWORD *)(v4 + 76) += v3 + 16;
  v6 = *(_DWORD *)(v4 + 4 * a2 + 60);
  v5[1] = v3;
  *v5 = v6;
  v5[2] = 0;
  *(_DWORD *)(v4 + 4 * a2 + 60) = v5;
  return v5 + 4;
}

//----- (00492DF0) --------------------------------------------------------
int __cdecl sub_492DF0(_DWORD *a1, int a2, unsigned int a3, unsigned int a4)
{
  int v5; // edi
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  unsigned int v10; // edx
  _DWORD *v11; // ecx
  int v12; // [esp+1Ch] [ebp+Ch]

  v5 = a1[1];
  v6 = 0x3B9AC9F0 / a3;
  if ( (int)(0x3B9AC9F0 / a3) <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 70;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)v6 >= (int)a4 )
    v6 = a4;
  *(_DWORD *)(v5 + 80) = v6;
  result = sub_492BF0(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v6 >= a4 - v8 )
        v6 = a4 - v8;
      v9 = sub_492D40(a1, a2, a3 * v6);
      if ( v6 )
      {
        v10 = v6;
        v11 = (_DWORD *)(v12 + 4 * v8);
        v8 += v6;
        do
        {
          *v11++ = v9;
          v9 = (_DWORD *)((char *)v9 + a3);
          --v10;
        }
        while ( v10 );
      }
    }
    while ( v8 < a4 );
    result = v12;
  }
  return result;
}

//----- (00492EA0) --------------------------------------------------------
int __cdecl sub_492EA0(_DWORD *a1, int a2, int a3, signed int a4)
{
  int v4; // edi
  signed int v5; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  signed int v10; // edx
  _DWORD *v11; // ecx
  int v12; // [esp+20h] [ebp+10h]

  v4 = a1[1];
  v5 = 0x3B9AC9F0u / (a3 << 7);
  if ( v5 <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 70;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( v5 >= a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 80) = v5;
  result = sub_492BF0(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v5 >= a4 - v8 )
        v5 = a4 - v8;
      v9 = sub_492D40(a1, a2, (a3 * v5) << 7);
      if ( v5 )
      {
        v10 = v5;
        v11 = (_DWORD *)(v12 + 4 * v8);
        v8 += v5;
        do
        {
          *v11++ = v9;
          v9 += 32 * a3;
          --v10;
        }
        while ( v10 );
      }
    }
    while ( v8 < a4 );
    result = v12;
  }
  return result;
}

//----- (00492F50) --------------------------------------------------------
int __cdecl sub_492F50(_DWORD *a1, int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_492BF0(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(v6 + 68) = result;
  return result;
}

//----- (00492FC0) --------------------------------------------------------
int __cdecl sub_492FC0(_DWORD *a1, int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_492BF0(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 72);
  *(_DWORD *)(v6 + 72) = result;
  return result;
}

//----- (00493030) --------------------------------------------------------
int __cdecl sub_493030(_DWORD *a1)
{
  int v1; // esi
  _DWORD *v2; // ebx
  int v3; // edi
  _DWORD *i; // eax
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  signed int v8; // edi
  int j; // esi
  int k; // esi

  v1 = 0;
  v2 = (_DWORD *)a1[1];
  v3 = 0;
  for ( i = (_DWORD *)v2[17]; i; i = (_DWORD *)i[9] )
  {
    if ( !*i )
    {
      v5 = i[2];
      v1 += v5 * i[3];
      v3 += v5 * i[1];
    }
  }
  for ( result = v2[18]; result; result = *(_DWORD *)(result + 36) )
  {
    if ( !*(_DWORD *)result )
    {
      v7 = *(_DWORD *)(result + 8);
      v1 += (v7 * *(_DWORD *)(result + 12)) << 7;
      v3 += (v7 * *(_DWORD *)(result + 4)) << 7;
    }
  }
  if ( v1 > 0 )
  {
    result = sub_494980((int)a1, v1, v3);
    if ( result < v3 )
    {
      result /= v1;
      v8 = result;
      if ( result <= 0 )
        v8 = 1;
    }
    else
    {
      v8 = 1000000000;
    }
    for ( j = v2[17]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( !*(_DWORD *)j )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(j + 4) - 1) / *(_DWORD *)(j + 12) + 1) > v8 )
        {
          *(_DWORD *)(j + 16) = v8 * *(_DWORD *)(j + 12);
          sub_494990((int)a1);
          *(_BYTE *)(j + 34) = 1;
        }
        else
        {
          *(_DWORD *)(j + 16) = *(_DWORD *)(j + 4);
        }
        *(_DWORD *)j = sub_492DF0(a1, 1, *(_DWORD *)(j + 8), *(_DWORD *)(j + 16));
        result = 0;
        *(_DWORD *)(j + 20) = v2[20];
        *(_DWORD *)(j + 24) = 0;
        *(_DWORD *)(j + 28) = 0;
        *(_BYTE *)(j + 33) = 0;
      }
    }
    for ( k = v2[18]; k; k = *(_DWORD *)(k + 36) )
    {
      if ( !*(_DWORD *)k )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(k + 4) - 1) / *(_DWORD *)(k + 12) + 1) > v8 )
        {
          *(_DWORD *)(k + 16) = v8 * *(_DWORD *)(k + 12);
          sub_494990((int)a1);
          *(_BYTE *)(k + 34) = 1;
        }
        else
        {
          *(_DWORD *)(k + 16) = *(_DWORD *)(k + 4);
        }
        *(_DWORD *)k = sub_492EA0(a1, 1, *(_DWORD *)(k + 8), *(_DWORD *)(k + 16));
        result = 0;
        *(_DWORD *)(k + 20) = v2[20];
        *(_DWORD *)(k + 24) = 0;
        *(_DWORD *)(k + 28) = 0;
        *(_BYTE *)(k + 33) = 0;
      }
    }
  }
  return result;
}

//----- (004931B0) --------------------------------------------------------
int __cdecl sub_4931B0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebp
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // edi
  unsigned int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 69;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_493300(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    sub_493300(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = *(_DWORD *)(a2 + 8);
    v11 = v8 - v9;
    for ( i = v5 - v9; v11 < i; ++v11 )
      sub_493F70(*(void **)(*(_DWORD *)a2 + 4 * v11), v10);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

//----- (00493300) --------------------------------------------------------
int __cdecl sub_493300(int a1, int a2, char a3)
{
  int v4; // edi
  int v5; // ebp
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  int v9; // ebp
  int v10; // [esp+18h] [ebp+8h]

  v4 = 0;
  v5 = *(_DWORD *)(a2 + 8);
  result = *(_DWORD *)(a2 + 16);
  v7 = v5 * *(_DWORD *)(a2 + 24);
  v10 = v5;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v4;
      if ( *(_DWORD *)(a2 + 20) < result )
        result = *(_DWORD *)(a2 + 20);
      v8 = v4 + *(_DWORD *)(a2 + 24);
      if ( result >= *(_DWORD *)(a2 + 28) - v8 )
        result = *(_DWORD *)(a2 + 28) - v8;
      if ( result >= *(_DWORD *)(a2 + 4) - v8 )
        result = *(_DWORD *)(a2 + 4) - v8;
      if ( result <= 0 )
        break;
      v9 = v5 * result;
      if ( a3 )
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v4),
          v7,
          v9);
      else
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v4),
          v7,
          v9);
      result = *(_DWORD *)(a2 + 16);
      v4 += *(_DWORD *)(a2 + 20);
      v7 += v9;
      if ( v4 >= result )
        break;
      v5 = v10;
    }
  }
  return result;
}

//----- (004933A0) --------------------------------------------------------
int __cdecl sub_4933A0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ebx
  unsigned int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 69;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_4934F0(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    sub_4934F0(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = v8 - v9;
    v11 = v5 - v9;
    for ( i = *(_DWORD *)(a2 + 8) << 7; v10 < v11; ++v10 )
      sub_493F70(*(void **)(*(_DWORD *)a2 + 4 * v10), i);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 22;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

//----- (004934F0) --------------------------------------------------------
int __cdecl sub_4934F0(int a1, int a2, char a3)
{
  int v4; // edi
  int result; // eax
  int v6; // ebp
  int v7; // ebx
  int v8; // ecx
  int v9; // ebp
  int v10; // [esp+18h] [ebp+8h]

  v4 = 0;
  result = *(_DWORD *)(a2 + 16);
  v10 = *(_DWORD *)(a2 + 8) << 7;
  v6 = v10;
  v7 = *(_DWORD *)(a2 + 24) * v10;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v4;
      if ( *(_DWORD *)(a2 + 20) < result )
        result = *(_DWORD *)(a2 + 20);
      v8 = *(_DWORD *)(a2 + 24) + v4;
      if ( result >= *(_DWORD *)(a2 + 28) - v8 )
        result = *(_DWORD *)(a2 + 28) - v8;
      if ( result >= *(_DWORD *)(a2 + 4) - v8 )
        result = *(_DWORD *)(a2 + 4) - v8;
      if ( result <= 0 )
        break;
      v9 = v6 * result;
      if ( a3 )
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v4),
          v7,
          v9);
      else
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v4),
          v7,
          v9);
      result = *(_DWORD *)(a2 + 16);
      v4 += *(_DWORD *)(a2 + 20);
      v7 += v9;
      if ( v4 >= result )
        break;
      v6 = v10;
    }
  }
  return result;
}

//----- (00493590) --------------------------------------------------------
_DWORD *__cdecl sub_493590(_DWORD *a1, int a2)
{
  int v2; // ebp
  _DWORD *v3; // esi
  int i; // edi
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  int v8; // ebp
  _DWORD *result; // eax
  _DWORD *v10; // edi
  int v11; // ebp

  v2 = a2;
  v3 = (_DWORD *)a1[1];
  if ( a2 < 0 || a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 == 1 )
  {
    for ( i = v3[17]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( *(_BYTE *)(i + 34) )
      {
        *(_BYTE *)(i + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
      }
    }
    v5 = v3[18];
    for ( v3[17] = 0; v5; v5 = *(_DWORD *)(v5 + 36) )
    {
      if ( *(_BYTE *)(v5 + 34) )
      {
        *(_BYTE *)(v5 + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(v5 + 48))(a1, v5 + 40);
      }
    }
    v3[18] = 0;
  }
  v6 = (_DWORD *)v3[a2 + 15];
  v3[a2 + 15] = 0;
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      v8 = v6[2] + v6[1] + 16;
      sub_494970((int)a1, (unsigned int)v6);
      v6 = v7;
      v3[19] -= v8;
    }
    while ( v7 );
    v2 = a2;
  }
  result = (_DWORD *)v3[v2 + 13];
  v3[v2 + 13] = 0;
  if ( result )
  {
    do
    {
      v10 = (_DWORD *)*result;
      v11 = result[2] + result[1] + 16;
      sub_494950((int)a1, (unsigned int)result);
      result = v10;
      v3[19] -= v11;
    }
    while ( v10 );
  }
  return result;
}

//----- (004936D0) --------------------------------------------------------
char __cdecl sub_4936D0(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
  {
    (*(void (__cdecl **)(int, int))(v1 + 36))(a1, 1);
    LOBYTE(v1) = *(_BYTE *)(a1 + 16);
    if ( (_BYTE)v1 )
    {
      *(_DWORD *)(a1 + 20) = 200;
      *(_DWORD *)(a1 + 268) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 20) = 100;
    }
  }
  return v1;
}

//----- (00493710) --------------------------------------------------------
int __cdecl sub_493710(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = (*(int (__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

//----- (00493730) --------------------------------------------------------
int __cdecl sub_493730(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

//----- (00493750) --------------------------------------------------------
int __cdecl sub_493750(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

//----- (00493770) --------------------------------------------------------
char __cdecl sub_493770(int a1)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  int i; // eax
  int v12; // ebx
  _DWORD *v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v19; // [esp-10h] [ebp-18h]
  int v20; // [esp-10h] [ebp-18h]
  int v21; // [esp-10h] [ebp-18h]
  int v22; // [esp+Ch] [ebp+4h]

  if ( *(_DWORD *)(a1 + 20) != 202 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 20);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 52);
  if ( 8 * v2 > v3 )
  {
    if ( 4 * v2 > v3 )
    {
      if ( 2 * v2 > v3 )
      {
        v7 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 96) = v7;
        *(_DWORD *)(a1 + 280) = 8;
      }
      else
      {
        v6 = sub_493EC0(*(_DWORD *)(a1 + 28), 2);
        v21 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 92) = v6;
        *(_DWORD *)(a1 + 96) = sub_493EC0(v21, 2);
        *(_DWORD *)(a1 + 280) = 4;
      }
    }
    else
    {
      v5 = sub_493EC0(*(_DWORD *)(a1 + 28), 4);
      v20 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 92) = v5;
      *(_DWORD *)(a1 + 96) = sub_493EC0(v20, 4);
      *(_DWORD *)(a1 + 280) = 2;
    }
  }
  else
  {
    v4 = sub_493EC0(*(_DWORD *)(a1 + 28), 8);
    v19 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 92) = v4;
    *(_DWORD *)(a1 + 96) = sub_493EC0(v19, 8);
    *(_DWORD *)(a1 + 280) = 1;
  }
  v8 = *(_DWORD *)(a1 + 196);
  v22 = 0;
  if ( *(int *)(a1 + 36) > 0 )
  {
    v9 = (_DWORD *)(v8 + 12);
    do
    {
      v10 = *(_DWORD *)(a1 + 280);
      for ( i = v10; i < 8; i *= 2 )
      {
        if ( 2 * i * *(v9 - 1) > v10 * *(_DWORD *)(a1 + 272) )
          break;
        if ( 2 * i * *v9 > v10 * *(_DWORD *)(a1 + 276) )
          break;
      }
      v9[6] = i;
      v9 += 21;
      ++v22;
    }
    while ( v22 < *(_DWORD *)(a1 + 36) );
  }
  v12 = 0;
  if ( *(int *)(a1 + 36) > 0 )
  {
    v13 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    do
    {
      v14 = sub_493EC0(*(_DWORD *)(a1 + 28) * *v13 * *(v13 - 7), 8 * *(_DWORD *)(a1 + 272));
      v15 = *(v13 - 6);
      v13[1] = v14;
      v13[2] = sub_493EC0(*(_DWORD *)(a1 + 32) * *v13 * v15, 8 * *(_DWORD *)(a1 + 276));
      ++v12;
      v13 += 21;
    }
    while ( v12 < *(_DWORD *)(a1 + 36) );
  }
  switch ( *(_DWORD *)(a1 + 44) )
  {
    case 1:
      *(_DWORD *)(a1 + 100) = 1;
      break;
    case 2:
    case 3:
      *(_DWORD *)(a1 + 100) = 3;
      break;
    case 4:
    case 5:
      *(_DWORD *)(a1 + 100) = 4;
      break;
    default:
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 36);
      break;
  }
  v16 = 1;
  if ( !*(_BYTE *)(a1 + 74) )
    v16 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 104) = v16;
  LOBYTE(v17) = sub_493990(a1);
  if ( (_BYTE)v17 )
  {
    v17 = *(_DWORD *)(a1 + 276);
    *(_DWORD *)(a1 + 108) = v17;
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 1;
  }
  return v17;
}

//----- (00493990) --------------------------------------------------------
char __cdecl sub_493990(int a1)
{
  _DWORD *v1; // ecx
  char result; // al
  int v3; // edx

  if ( *(_BYTE *)(a1 + 72)
    || *(_BYTE *)(a1 + 266)
    || *(_DWORD *)(a1 + 40) != 3
    || *(_DWORD *)(a1 + 36) != 3
    || *(_DWORD *)(a1 + 44) != 2
    || *(_DWORD *)(a1 + 100) != 3
    || (v1 = *(_DWORD **)(a1 + 196), v1[2] != 2)
    || (result = 1, v1[23] != 1)
    || v1[44] != 1
    || (int)v1[3] > 2
    || v1[24] != 1
    || v1[45] != 1
    || (v3 = *(_DWORD *)(a1 + 280), v1[9] != v3)
    || v1[30] != v3
    || v1[51] != v3 )
  {
    result = 0;
  }
  return result;
}

//----- (00493A90) --------------------------------------------------------
int __cdecl sub_493A90(int a1)
{
  int v1; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 384) = v1;
  *(_DWORD *)v1 = sub_493D30;
  *(_DWORD *)(v1 + 4) = sub_493E90;
  *(_BYTE *)(v1 + 8) = 0;
  return sub_493AD0(a1);
}

//----- (00493AD0) --------------------------------------------------------
int __cdecl sub_493AD0(int a1)
{
  int v2; // edi
  char v3; // al
  int result; // eax
  int v5; // ecx
  int v6; // eax
  char v7; // [esp+10h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 384);
  sub_493770(a1);
  sub_493CB0(a1);
  *(_DWORD *)(v2 + 12) = 0;
  *(_BYTE *)(v2 + 16) = sub_493990(a1);
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  v3 = *(_BYTE *)(a1 + 74);
  if ( !v3 || !*(_BYTE *)(a1 + 64) )
  {
    *(_BYTE *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 89) = 0;
    *(_BYTE *)(a1 + 90) = 0;
  }
  if ( v3 )
  {
    if ( *(_BYTE *)(a1 + 65) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_DWORD *)(a1 + 100) == 3 )
    {
      if ( *(_DWORD *)(a1 + 116) )
      {
        *(_BYTE *)(a1 + 89) = 1;
      }
      else if ( *(_BYTE *)(a1 + 80) )
      {
        *(_BYTE *)(a1 + 90) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 88) = 1;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 88) = 1;
      *(_BYTE *)(a1 + 89) = 0;
      *(_BYTE *)(a1 + 90) = 0;
      *(_DWORD *)(a1 + 116) = 0;
    }
    if ( *(_BYTE *)(a1 + 88) )
    {
      sub_49A760((_DWORD *)a1);
      *(_DWORD *)(v2 + 20) = *(_DWORD *)(a1 + 424);
    }
    if ( *(_BYTE *)(a1 + 90) || *(_BYTE *)(a1 + 89) )
    {
      sub_499360(a1);
      *(_DWORD *)(v2 + 24) = *(_DWORD *)(a1 + 424);
    }
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(v2 + 16) )
    {
      sub_498D70(a1);
    }
    else
    {
      sub_498700(a1);
      sub_497F80(a1);
    }
    sub_497C10(a1, *(_BYTE *)(a1 + 90));
  }
  sub_497950(a1);
  if ( *(_BYTE *)(a1 + 201) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 200) )
  {
    sub_496BF0(a1);
  }
  else
  {
    sub_496550(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 16) || (v7 = 0, *(_BYTE *)(a1 + 64)) )
    v7 = 1;
  sub_4950B0(a1, v7);
  if ( !*(_BYTE *)(a1 + 65) )
    sub_4949D0(a1, 0);
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 400) + 8))(a1);
  v5 = *(_DWORD *)(a1 + 8);
  if ( v5 && !*(_BYTE *)(a1 + 64) && *(_BYTE *)(*(_DWORD *)(a1 + 400) + 16) )
  {
    v6 = *(_DWORD *)(a1 + 36);
    if ( *(_BYTE *)(a1 + 200) )
      v6 = 3 * v6 + 2;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = v6 * *(_DWORD *)(a1 + 284);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = (*(_BYTE *)(a1 + 90) != 0) + 2;
    result = *(_DWORD *)(v2 + 12) + 1;
    *(_DWORD *)(v2 + 12) = result;
  }
  return result;
}

//----- (00493CB0) --------------------------------------------------------
int __cdecl sub_493CB0(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // edx
  int result; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1408) + 256;
  v2 = 0;
  *(_DWORD *)(a1 + 288) = v1;
  memset((void *)(v1 - 256), 0, 0x100u);
  do
  {
    *(_BYTE *)(v2 + v1) = v2;
    ++v2;
  }
  while ( v2 <= 255 );
  v3 = v1 + 128;
  memset((void *)(v3 + 128), 0xFFu, 0x180u);
  result = 0;
  memset((void *)(v3 + 512), 0, 0x180u);
  qmemcpy((void *)(v3 + 896), *(const void **)(a1 + 288), 0x80u);
  return result;
}

//----- (00493D30) --------------------------------------------------------
char __cdecl sub_493D30(int a1)
{
  int v1; // edi
  int v2; // eax
  int v3; // eax

  v1 = *(_DWORD *)(a1 + 384);
  if ( *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void (__cdecl ***)(int, _DWORD))(a1 + 424))(a1, 0);
    (**(void (__cdecl ***)(int, int))(a1 + 396))(a1, 2);
    (**(void (__cdecl ***)(int, int))(a1 + 388))(a1, 2);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) && !*(_DWORD *)(a1 + 116) )
    {
      if ( *(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 90) )
      {
        *(_DWORD *)(a1 + 424) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      }
      else if ( *(_BYTE *)(a1 + 88) )
      {
        *(_DWORD *)(a1 + 424) = *(_DWORD *)(v1 + 20);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void (__cdecl ***)(int))(a1 + 412))(a1);
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 392) + 8))(a1);
    if ( !*(_BYTE *)(a1 + 65) )
    {
      if ( !*(_BYTE *)(v1 + 16) )
        (**(void (__cdecl ***)(int))(a1 + 420))(a1);
      v2 = (**(int (__cdecl ***)(int))(a1 + 416))(a1);
      if ( *(_BYTE *)(a1 + 74) )
      {
        LOBYTE(v2) = *(_BYTE *)(v1 + 8);
        (**(void (__cdecl ***)(int, int))(a1 + 424))(a1, v2);
      }
      (**(void (__cdecl ***)(int, int))(a1 + 396))(a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      (**(void (__cdecl ***)(int, _DWORD))(a1 + 388))(a1, 0);
    }
  }
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = *(_DWORD *)(v1 + 12) + (*(_BYTE *)(v1 + 8) != 0) + 1;
    LOBYTE(v3) = *(_BYTE *)(a1 + 64);
    if ( (_BYTE)v3 )
    {
      LOBYTE(v3) = *(_BYTE *)(*(_DWORD *)(a1 + 400) + 17);
      if ( !(_BYTE)v3 )
      {
        v3 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(v3 + 16) += (*(_BYTE *)(a1 + 90) != 0) + 1;
      }
    }
  }
  return v3;
}

//----- (00493E90) --------------------------------------------------------
int __cdecl sub_493E90(int a1)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 384);
  if ( *(_BYTE *)(a1 + 74) )
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 424) + 8))(a1);
  result = *(_DWORD *)(v1 + 12) + 1;
  *(_DWORD *)(v1 + 12) = result;
  return result;
}

//----- (00493EC0) --------------------------------------------------------
int __cdecl sub_493EC0(int a1, int a2)
{
  return (a1 + a2 - 1) / a2;
}

//----- (00493ED0) --------------------------------------------------------
int __cdecl sub_493ED0(int a1, int a2)
{
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

//----- (00493EF0) --------------------------------------------------------
const void **__cdecl sub_493EF0(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // ebx
  const void **result; // eax
  void **v8; // edx

  v6 = a5;
  result = (const void **)(a1 + 4 * a2);
  v8 = (void **)(a3 + 4 * a4);
  if ( a5 > 0 )
  {
    do
    {
      qmemcpy(*v8++, *result++, a6);
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (00493F40) --------------------------------------------------------
int __cdecl sub_493F40(const void *a1, void *a2, int a3)
{
  int result; // eax

  result = a3 << 7;
  qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
  return result;
}

//----- (00493F70) --------------------------------------------------------
int __cdecl sub_493F70(void *a1, unsigned int a2)
{
  int result; // eax

  result = 0;
  memset(a1, 0, a2);
  return result;
}

//----- (00493F90) --------------------------------------------------------
char (__cdecl **__cdecl sub_493F90(int a1))(int a1)
{
  char (__cdecl **result)(int); // eax

  result = (char (__cdecl **)(int))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32);
  *(_DWORD *)(a1 + 332) = result;
  *result = sub_4940E0;
  result[1] = (char (__cdecl *)(int))sub_494280;
  result[2] = (char (__cdecl *)(int))sub_494520;
  result[3] = (char (__cdecl *)(int))sub_4947E0;
  result[4] = (char (__cdecl *)(int))sub_494800;
  result[5] = (char (__cdecl *)(int))sub_493FF0;
  result[6] = (char (__cdecl *)(int))sub_4940C0;
  result[7] = 0;
  return result;
}
// 4947E0: using guessed type int sub_4947E0();

//----- (00493FF0) --------------------------------------------------------
int __cdecl sub_493FF0(_DWORD *a1, char a2, unsigned int a3)
{
  if ( a3 > 0xFFFD )
  {
    *(_DWORD *)(*a1 + 20) = 11;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  sub_494030(a1, a2);
  return sub_494090(a1, a3 + 2);
}

//----- (00494030) --------------------------------------------------------
int __cdecl sub_494030(_DWORD *a1, char a2)
{
  sub_494050(a1, 255);
  return sub_494050(a1, a2);
}

//----- (00494050) --------------------------------------------------------
int __cdecl sub_494050(_DWORD *a1, char a2)
{
  int result; // eax
  int v3; // ecx

  result = a1[6];
  **(_BYTE **)result = a2;
  v3 = *(_DWORD *)(result + 4) - 1;
  ++*(_DWORD *)result;
  *(_DWORD *)(result + 4) = v3;
  if ( !v3 )
  {
    result = (*(int (__cdecl **)(_DWORD *))(result + 12))(a1);
    if ( !(_BYTE)result )
    {
      *(_DWORD *)(*a1 + 20) = 24;
      result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  return result;
}

//----- (00494090) --------------------------------------------------------
int __cdecl sub_494090(_DWORD *a1, __int16 a2)
{
  sub_494050(a1, SHIBYTE(a2));
  return sub_494050(a1, a2);
}

//----- (004940C0) --------------------------------------------------------
int __cdecl sub_4940C0(_DWORD *a1, char a2)
{
  return sub_494050(a1, a2);
}

//----- (004940E0) --------------------------------------------------------
char __cdecl sub_4940E0(int a1)
{
  int v1; // edi
  char result; // al

  v1 = *(_DWORD *)(a1 + 332);
  sub_494030((_DWORD *)a1, 216);
  *(_DWORD *)(v1 + 28) = 0;
  if ( *(_BYTE *)(a1 + 196) )
    sub_494130(a1);
  result = *(_BYTE *)(a1 + 204);
  if ( result )
    result = sub_4941E0((_DWORD *)a1);
  return result;
}

//----- (00494130) --------------------------------------------------------
int __cdecl sub_494130(int a1)
{
  sub_494030((_DWORD *)a1, 224);
  sub_494090((_DWORD *)a1, 16);
  sub_494050((_DWORD *)a1, 74);
  sub_494050((_DWORD *)a1, 70);
  sub_494050((_DWORD *)a1, 73);
  sub_494050((_DWORD *)a1, 70);
  sub_494050((_DWORD *)a1, 0);
  sub_494050((_DWORD *)a1, *(_BYTE *)(a1 + 197));
  sub_494050((_DWORD *)a1, *(_BYTE *)(a1 + 198));
  sub_494050((_DWORD *)a1, *(_BYTE *)(a1 + 199));
  sub_494090((_DWORD *)a1, *(_WORD *)(a1 + 200));
  sub_494090((_DWORD *)a1, *(_WORD *)(a1 + 202));
  sub_494050((_DWORD *)a1, 0);
  return sub_494050((_DWORD *)a1, 0);
}

//----- (004941E0) --------------------------------------------------------
int __cdecl sub_4941E0(_DWORD *a1)
{
  sub_494030(a1, 238);
  sub_494090(a1, 14);
  sub_494050(a1, 65);
  sub_494050(a1, 100);
  sub_494050(a1, 111);
  sub_494050(a1, 98);
  sub_494050(a1, 101);
  sub_494090(a1, 100);
  sub_494090(a1, 0);
  sub_494090(a1, 0);
  if ( a1[16] == 3 )
    return sub_494050(a1, 1);
  if ( a1[16] == 5 )
    return sub_494050(a1, 2);
  return sub_494050(a1, 0);
}

//----- (00494280) --------------------------------------------------------
int __cdecl sub_494280(int a1)
{
  int v1; // ebp
  int v2; // edi
  int *v3; // ebx
  int v4; // ecx
  char v5; // bl
  int *v6; // eax

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 60) > 0 )
  {
    v3 = (int *)(*(_DWORD *)(a1 + 68) + 16);
    do
    {
      v1 += sub_494380((_DWORD *)a1, *v3);
      ++v2;
      v3 += 21;
    }
    while ( v2 < *(_DWORD *)(a1 + 60) );
  }
  if ( *(_BYTE *)(a1 + 177) || *(_BYTE *)(a1 + 212) || *(_DWORD *)(a1 + 56) != 8 )
  {
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 60);
    v5 = 1;
    if ( v4 > 0 )
    {
      v6 = (int *)(*(_DWORD *)(a1 + 68) + 24);
      do
      {
        if ( *(v6 - 1) > 1 || *v6 > 1 )
          v5 = 0;
        v6 += 21;
        --v4;
      }
      while ( v4 );
    }
    if ( v1 && v5 )
    {
      v5 = 0;
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 75;
      (*(void (__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 4))(a1, 0);
    }
  }
  if ( *(_BYTE *)(a1 + 177) )
    return sub_494460((_DWORD *)a1, 201);
  if ( *(_BYTE *)(a1 + 212) )
    return sub_494460((_DWORD *)a1, 194);
  if ( v5 )
    return sub_494460((_DWORD *)a1, 192);
  return sub_494460((_DWORD *)a1, 193);
}

//----- (00494380) --------------------------------------------------------
int __cdecl sub_494380(_DWORD *a1, int a2)
{
  int v3; // ebp
  _WORD *v4; // eax
  int v5; // ecx
  int *v6; // edi
  __int16 v7; // si
  int v9; // [esp+14h] [ebp+4h]

  v9 = a1[a2 + 18];
  if ( !v9 )
  {
    *(_DWORD *)(*a1 + 20) = 52;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = 0;
  v4 = (_WORD *)v9;
  v5 = 64;
  do
  {
    if ( *v4 > 0xFFu )
      v3 = 1;
    ++v4;
    --v5;
  }
  while ( v5 );
  if ( !*(_BYTE *)(v9 + 128) )
  {
    sub_494030(a1, 219);
    sub_494090(a1, v3 != 0 ? 131 : 67);
    sub_494050(a1, a2 + 16 * v3);
    v6 = dword_4B0ABC;
    do
    {
      v7 = *(_WORD *)(v9 + 2 * *v6);
      if ( v3 )
        sub_494050(a1, SHIBYTE(v7));
      sub_494050(a1, v7);
      ++v6;
    }
    while ( (int)v6 < (int)&unk_4B0BBC );
    *(_BYTE *)(v9 + 128) = 1;
  }
  return v3;
}
// 4B0ABC: using guessed type int dword_4B0ABC[];

//----- (00494460) --------------------------------------------------------
int __cdecl sub_494460(_DWORD *a1, char a2)
{
  int result; // eax
  int v3; // edi
  int i; // ebx

  sub_494030(a1, a2);
  sub_494090(a1, 3 * a1[15] + 8);
  if ( (int)a1[8] > 0xFFFF || (int)a1[7] > 0xFFFF )
  {
    *(_DWORD *)(*a1 + 20) = 41;
    *(_DWORD *)(*a1 + 24) = 0xFFFF;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  sub_494050(a1, a1[14]);
  sub_494090(a1, a1[8]);
  sub_494090(a1, a1[7]);
  sub_494050(a1, a1[15]);
  result = a1[15];
  v3 = a1[17];
  for ( i = 0; i < result; v3 += 84 )
  {
    sub_494050(a1, *(_DWORD *)v3);
    sub_494050(a1, *(_DWORD *)(v3 + 12) + 16 * *(_BYTE *)(v3 + 8));
    sub_494050(a1, *(_DWORD *)(v3 + 16));
    result = a1[15];
    ++i;
  }
  return result;
}

//----- (00494520) --------------------------------------------------------
int __cdecl sub_494520(int a1)
{
  char v2; // al
  int v3; // edi
  int v4; // ebp
  int *v5; // ebx
  int v6; // edi
  int v8; // [esp+10h] [ebp+4h]

  v2 = *(_BYTE *)(a1 + 177);
  v3 = *(_DWORD *)(a1 + 332);
  v8 = v3;
  if ( v2 )
  {
    nullsub_12(a1);
  }
  else
  {
    v4 = 0;
    if ( *(int *)(a1 + 228) > 0 )
    {
      v5 = (int *)(a1 + 232);
      do
      {
        v6 = *v5;
        if ( *(_BYTE *)(a1 + 212) )
        {
          if ( *(_DWORD *)(a1 + 300) )
          {
            sub_494600((_DWORD *)a1, *(_DWORD *)(v6 + 24), 1);
          }
          else if ( !*(_DWORD *)(a1 + 308) )
          {
            sub_494600((_DWORD *)a1, *(_DWORD *)(v6 + 20), 0);
          }
        }
        else
        {
          sub_494600((_DWORD *)a1, *(_DWORD *)(v6 + 20), 0);
          sub_494600((_DWORD *)a1, *(_DWORD *)(v6 + 24), 1);
        }
        ++v4;
        ++v5;
      }
      while ( v4 < *(_DWORD *)(a1 + 228) );
      v3 = v8;
    }
  }
  if ( *(_DWORD *)(a1 + 188) != *(_DWORD *)(v3 + 28) )
  {
    sub_4946D0((_DWORD *)a1);
    *(_DWORD *)(v3 + 28) = *(_DWORD *)(a1 + 188);
  }
  return sub_494700(a1);
}
// 4946C0: using guessed type int __cdecl nullsub_12(_DWORD);

//----- (00494600) --------------------------------------------------------
char __cdecl sub_494600(_DWORD *a1, int a2, char a3)
{
  int v3; // ebx
  int v4; // edi
  char result; // al
  int v6; // ebp
  int i; // eax
  int j; // ebx
  int k; // ebx

  v3 = a2;
  if ( a3 )
  {
    v4 = a1[a2 + 26];
    v3 = a2 + 16;
  }
  else
  {
    v4 = a1[a2 + 22];
  }
  if ( !v4 )
  {
    *(_DWORD *)(*a1 + 20) = 50;
    *(_DWORD *)(*a1 + 24) = v3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = *(_BYTE *)(v4 + 273);
  if ( !result )
  {
    sub_494030(a1, 196);
    v6 = 0;
    for ( i = 1; i <= 16; ++i )
      v6 += *(unsigned __int8 *)(i + v4);
    sub_494090(a1, v6 + 19);
    sub_494050(a1, v3);
    for ( j = 1; j <= 16; ++j )
      result = sub_494050(a1, *(_BYTE *)(j + v4));
    for ( k = 0; k < v6; ++k )
      result = sub_494050(a1, *(_BYTE *)(v4 + k + 17));
    *(_BYTE *)(v4 + 273) = 1;
  }
  return result;
}

//----- (004946D0) --------------------------------------------------------
int __cdecl sub_4946D0(_DWORD *a1)
{
  sub_494030(a1, 221);
  sub_494090(a1, 4);
  return sub_494090(a1, a1[47]);
}

//----- (00494700) --------------------------------------------------------
int __cdecl sub_494700(int a1)
{
  int v2; // ebp
  _DWORD *v3; // ebx
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // edi

  sub_494030((_DWORD *)a1, 218);
  sub_494090((_DWORD *)a1, 2 * *(_DWORD *)(a1 + 228) + 6);
  sub_494050((_DWORD *)a1, *(_DWORD *)(a1 + 228));
  v2 = 0;
  if ( *(int *)(a1 + 228) > 0 )
  {
    v3 = (_DWORD *)(a1 + 232);
    do
    {
      v4 = (_DWORD *)*v3;
      sub_494050((_DWORD *)a1, *(_DWORD *)*v3);
      v5 = v4[5];
      v6 = v4[6];
      if ( *(_BYTE *)(a1 + 212) )
      {
        if ( *(_DWORD *)(a1 + 300) || (LOBYTE(v6) = 0, *(_DWORD *)(a1 + 308)) && !*(_BYTE *)(a1 + 177) )
          LOBYTE(v5) = 0;
      }
      sub_494050((_DWORD *)a1, v6 + 16 * v5);
      ++v2;
      ++v3;
    }
    while ( v2 < *(_DWORD *)(a1 + 228) );
  }
  sub_494050((_DWORD *)a1, *(_DWORD *)(a1 + 300));
  sub_494050((_DWORD *)a1, *(_DWORD *)(a1 + 304));
  return sub_494050((_DWORD *)a1, *(_DWORD *)(a1 + 312) + 16 * *(_BYTE *)(a1 + 308));
}

//----- (00494800) --------------------------------------------------------
int __cdecl sub_494800(int a1)
{
  int v1; // esi
  _DWORD *v2; // ebx
  int v3; // esi
  _DWORD *v4; // ebx

  sub_494030((_DWORD *)a1, 216);
  v1 = 0;
  v2 = (_DWORD *)(a1 + 72);
  do
  {
    if ( *v2 )
      sub_494380((_DWORD *)a1, v1);
    ++v1;
    ++v2;
  }
  while ( v1 < 4 );
  if ( !*(_BYTE *)(a1 + 177) )
  {
    v3 = 0;
    v4 = (_DWORD *)(a1 + 104);
    do
    {
      if ( *(v4 - 4) )
        sub_494600((_DWORD *)a1, v3, 0);
      if ( *v4 )
        sub_494600((_DWORD *)a1, v3, 1);
      ++v3;
      ++v4;
    }
    while ( v3 < 4 );
  }
  return sub_494030((_DWORD *)a1, 217);
}

//----- (00494880) --------------------------------------------------------
int __cdecl sub_494880(int a1)
{
  bool v1; // al

  sub_49F4A0(a1, 0);
  if ( !*(_BYTE *)(a1 + 176) )
  {
    sub_49ED10(a1);
    sub_49E2F0(a1);
    sub_49DD30(a1, 0);
  }
  sub_49D760(a1);
  if ( *(_BYTE *)(a1 + 177) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 212) )
  {
    sub_49CB50(a1);
  }
  else
  {
    sub_49C1F0(a1);
  }
  v1 = *(int *)(a1 + 168) > 1 || *(_BYTE *)(a1 + 178);
  sub_49B540(a1, v1);
  sub_49B3B0(a1, 0);
  sub_493F90(a1);
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  return (**(int (__cdecl ***)(int))(a1 + 332))(a1);
}

//----- (00494940) --------------------------------------------------------
int __cdecl sub_494940(int a1, size_t a2)
{
  return sub_46D9FD(a2);
}

//----- (00494950) --------------------------------------------------------
void __cdecl sub_494950(int a1, unsigned int a2)
{
  sub_46D360(a2);
}

//----- (00494960) --------------------------------------------------------
int __cdecl sub_494960(int a1, size_t a2)
{
  return sub_46D9FD(a2);
}

//----- (00494970) --------------------------------------------------------
void __cdecl sub_494970(int a1, unsigned int a2)
{
  sub_46D360(a2);
}

//----- (00494980) --------------------------------------------------------
int __cdecl sub_494980(int a1, int a2, int a3)
{
  return a3;
}

//----- (00494990) --------------------------------------------------------
int __cdecl sub_494990(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 49;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

//----- (004949B0) --------------------------------------------------------
int sub_4949B0()
{
  return 0;
}

//----- (004949D0) --------------------------------------------------------
int __cdecl sub_4949D0(int a1, char a2)
{
  _DWORD *v2; // ebx
  int v3; // eax
  int v4; // ebp
  int result; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // ebx
  int v8; // [esp+14h] [ebp+8h]

  v2 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 388) = v2;
  *v2 = sub_494B50;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v3 = *(_DWORD *)(a1 + 280);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 416) + 8) )
  {
    if ( v3 < 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    sub_494AA0(a1);
    v3 = *(_DWORD *)(a1 + 280) + 2;
  }
  v4 = 0;
  v8 = v3;
  result = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 36) > 0 )
  {
    v6 = (_DWORD *)(result + 36);
    v7 = v2 + 2;
    do
    {
      *v7 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
              a1,
              1,
              *v6 * *(v6 - 2),
              v8 * (*v6 * *(v6 - 6) / *(_DWORD *)(a1 + 280)));
      result = *(_DWORD *)(a1 + 36);
      ++v4;
      ++v7;
      v6 += 21;
    }
    while ( v4 < result );
  }
  return result;
}
// 494B50: using guessed type int sub_494B50();

//----- (00494AA0) --------------------------------------------------------
int __cdecl sub_494AA0(int a1)
{
  int v2; // edi
  int v3; // ebp
  int v4; // eax
  int v5; // ebx
  int result; // eax
  _DWORD *v7; // ebp
  int v8; // edi
  int v9; // eax
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int v12; // [esp+1Ch] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 388);
  v3 = *(_DWORD *)(a1 + 280);
  v11 = v2;
  v4 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD *)(a1 + 36));
  *(_DWORD *)(v2 + 56) = v4;
  v5 = 0;
  *(_DWORD *)(v2 + 60) = v4 + 4 * *(_DWORD *)(a1 + 36);
  result = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 36) > 0 )
  {
    v12 = v3 + 4;
    v7 = (_DWORD *)(result + 12);
    do
    {
      v8 = *v7 * v7[6] / *(_DWORD *)(a1 + 280) * v12;
      v10 = *v7 * v7[6] / *(_DWORD *)(a1 + 280);
      ++v5;
      v7 += 21;
      v9 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * v8) + 4 * v10;
      *(_DWORD *)(*(_DWORD *)(v11 + 56) + 4 * v5 - 4) = v9;
      *(_DWORD *)(*(_DWORD *)(v11 + 60) + 4 * v5 - 4) = v9 + 4 * v8;
      result = *(_DWORD *)(a1 + 36);
    }
    while ( v5 < result );
  }
  return result;
}

//----- (00494BD0) --------------------------------------------------------
_DWORD *__cdecl sub_494BD0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // ebp
  _DWORD *v3; // ecx
  _DWORD *result; // eax
  _DWORD *v5; // edx
  int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // ecx
  int v9; // edi
  _DWORD *v10; // edx
  int v11; // ebx
  _DWORD *v12; // esi
  int v13; // ebx
  _DWORD *v14; // edx
  char *v15; // ecx
  int v16; // edi
  int v17; // ebp
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // eax
  int v22; // [esp+8h] [ebp-20h]
  int *v23; // [esp+Ch] [ebp-1Ch]
  _DWORD *v24; // [esp+10h] [ebp-18h]
  int v25; // [esp+14h] [ebp-14h]
  int v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  _DWORD *v28; // [esp+20h] [ebp-8h]
  char *v29; // [esp+24h] [ebp-4h]

  v1 = a1;
  v2 = 0;
  v22 = 0;
  v3 = (_DWORD *)a1[97];
  v26 = a1[70];
  result = (_DWORD *)a1[49];
  v28 = v3;
  if ( (int)a1[9] > 0 )
  {
    v5 = result + 3;
    v24 = result + 3;
    v23 = v3 + 2;
    while ( 1 )
    {
      v6 = *v5 * v5[6] / v1[70];
      v7 = *(_DWORD **)(v3[14] + 4 * v2);
      v8 = *(_DWORD **)(v3[15] + 4 * v2);
      v27 = v7;
      v9 = *v23;
      if ( v6 * (v26 + 2) > 0 )
      {
        v10 = v8;
        v29 = (char *)((char *)v7 - (char *)v8);
        v25 = v6 * (v26 + 2);
        do
        {
          v11 = *(_DWORD *)((char *)v10 + v9 - (_DWORD)v8);
          *v10 = v11;
          *(_DWORD *)((char *)v10++ + (_DWORD)v29) = v11;
          --v25;
        }
        while ( v25 );
        v7 = v27;
        v2 = v22;
      }
      if ( 2 * v6 > 0 )
      {
        v12 = &v8[v26 * v6];
        v13 = v9 - (_DWORD)v8;
        v14 = (_DWORD *)(v9 + 4 * v6 * (v26 - 2));
        v15 = (char *)v8 - v9;
        v16 = 2 * v6;
        do
        {
          v17 = *(_DWORD *)((char *)v12++ + v13);
          *(_DWORD *)((char *)v14 + (_DWORD)v15) = v17;
          *(v12 - 1) = *v14++;
          --v16;
        }
        while ( v16 );
        v7 = v27;
        v2 = v22;
      }
      if ( v6 > 0 )
      {
        v18 = 0;
        v19 = 4 * v6;
        v20 = v6;
        do
        {
          v21 = v18 - v19;
          v18 += 4;
          --v20;
          *(_DWORD *)((char *)v7 + v21) = *v7;
        }
        while ( v20 );
      }
      result = a1;
      v22 = ++v2;
      ++v23;
      v24 += 21;
      if ( v2 >= a1[9] )
        break;
      v3 = v28;
      v1 = a1;
      v5 = v24;
    }
  }
  return result;
}

//----- (00494D20) --------------------------------------------------------
unsigned int __cdecl sub_494D20(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // esi
  unsigned int result; // eax
  unsigned int v6; // ebp

  v4 = a1[97];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[98] + 12))(a1, v4 + 8);
    if ( !result )
      return result;
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = a1[70];
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int, int, int, int))(a1[99] + 4))(
    a1,
    v4 + 8,
    v4 + 52,
    v6,
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 52);
  if ( result >= v6 )
  {
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = 0;
  }
  return result;
}

//----- (00494D90) --------------------------------------------------------
unsigned int __cdecl sub_494D90(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4)
{
  int v4; // esi
  unsigned int result; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ecx

  v4 = a1[97];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[98] + 12))(a1, *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56));
    if ( !result )
      return result;
    v6 = *(_DWORD *)(v4 + 76);
    *(_BYTE *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 76) = v6 + 1;
  }
  v7 = *(_DWORD *)(v4 + 68);
  if ( !v7 )
  {
LABEL_9:
    v9 = *(_DWORD *)(v4 + 76);
    *(_DWORD *)(v4 + 52) = 0;
    *(_DWORD *)(v4 + 72) = a1[70] - 1;
    if ( v9 == a1[71] )
      sub_494FE0(a1);
    *(_DWORD *)(v4 + 68) = 1;
    goto LABEL_12;
  }
  v8 = v7 - 1;
  if ( v8 )
  {
    result = v8 - 1;
    if ( result )
      return result;
    (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[99] + 4))(
      a1,
      *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
      v4 + 52,
      *(_DWORD *)(v4 + 72),
      a2,
      a3,
      a4);
    result = *(_DWORD *)(v4 + 72);
    if ( *(_DWORD *)(v4 + 52) < result )
      return result;
    result = (unsigned int)a3;
    *(_DWORD *)(v4 + 68) = 0;
    if ( *a3 >= a4 )
      return result;
    goto LABEL_9;
  }
LABEL_12:
  (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[99] + 4))(
    a1,
    *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
    v4 + 52,
    *(_DWORD *)(v4 + 72),
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 72);
  if ( *(_DWORD *)(v4 + 52) >= result )
  {
    if ( *(_DWORD *)(v4 + 76) == 1 )
      sub_494ED0(a1);
    v10 = *(_DWORD *)(v4 + 64);
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 64) = v10 ^ 1;
    result = a1[70] + 1;
    *(_DWORD *)(v4 + 52) = result;
    v11 = a1[70];
    *(_DWORD *)(v4 + 68) = 2;
    *(_DWORD *)(v4 + 72) = v11 + 2;
  }
  return result;
}

//----- (00494ED0) --------------------------------------------------------
int __cdecl sub_494ED0(_DWORD *a1)
{
  _DWORD *v1; // edi
  int v2; // ecx
  int v3; // esi
  int result; // eax
  _DWORD *v5; // ebp
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int v11; // edx
  int v12; // ebp
  _DWORD *v13; // eax
  int v14; // [esp+Ch] [ebp-20h]
  int v15; // [esp+10h] [ebp-1Ch]
  int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  _DWORD *v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+20h] [ebp-Ch]
  int v20; // [esp+24h] [ebp-8h]
  int v21; // [esp+28h] [ebp-4h]

  v1 = a1;
  v2 = 0;
  v3 = a1[97];
  v20 = a1[70];
  result = a1[9];
  v19 = v3;
  v17 = 0;
  if ( result > 0 )
  {
    v5 = (_DWORD *)(a1[49] + 12);
    v18 = v5;
    while ( 1 )
    {
      v6 = *v5 * v5[6] / v1[70];
      v7 = *(_DWORD *)(*(_DWORD *)(v3 + 56) + 4 * v2);
      v21 = v7;
      v8 = *(_DWORD *)(*(_DWORD *)(v3 + 60) + 4 * v2);
      if ( v6 > 0 )
      {
        v9 = 0;
        v14 = 4 * v6;
        v16 = *v5 * v5[6] / v1[70];
        v15 = v8 + 4 * v6 * (v20 + 2);
        v10 = v8 + 4 * v6 * (v20 + 1);
        v11 = v7 - v8;
        while ( 1 )
        {
          v12 = *(_DWORD *)(v11 + v10);
          v10 += 4;
          *(_DWORD *)(v9 - v14 + v7) = v12;
          *(_DWORD *)(v9 - v14 + v8) = *(_DWORD *)(v10 - 4);
          v13 = (_DWORD *)(v9 + v8);
          v9 += 4;
          v15 += 4;
          *(_DWORD *)(v11 + v15 - 4) = *(_DWORD *)((char *)v13 + v11);
          *(_DWORD *)(v15 - 4) = *v13;
          if ( !--v16 )
            break;
          v7 = v21;
        }
        v2 = v17;
        v1 = a1;
        v5 = v18;
      }
      result = v1[9];
      ++v2;
      v5 += 21;
      v17 = v2;
      v18 = v5;
      if ( v2 >= result )
        break;
      v3 = v19;
    }
  }
  return result;
}

//----- (00494FE0) --------------------------------------------------------
_DWORD *__cdecl sub_494FE0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // ebp
  _DWORD *result; // eax
  _DWORD *v4; // ebx
  int v5; // edi
  unsigned int v6; // esi
  int v7; // edx
  _DWORD *v8; // ecx
  int v9; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = 0;
  v9 = a1[97];
  result = (_DWORD *)a1[9];
  if ( (int)result > 0 )
  {
    v4 = (_DWORD *)(a1[49] + 12);
    while ( 1 )
    {
      v5 = *v4 * v4[6] / v1[70];
      v6 = v4[8] % (unsigned int)(*v4 * v4[6]);
      if ( !v6 )
        v6 = *v4 * v4[6];
      if ( !v2 )
        *(_DWORD *)(v9 + 72) = (int)(v6 - 1) / v5 + 1;
      v7 = 2 * v5;
      result = *(_DWORD **)(*(_DWORD *)(v9 + 4 * *(_DWORD *)(v9 + 64) + 56) + 4 * v2);
      if ( 2 * v5 > 0 )
      {
        v8 = &result[v6];
        result = v8;
        do
        {
          *result++ = *(v8 - 1);
          --v7;
        }
        while ( v7 );
      }
      ++v2;
      v4 += 21;
      if ( v2 >= a1[9] )
        break;
      v1 = a1;
    }
  }
  return result;
}

//----- (00495080) --------------------------------------------------------
int __cdecl sub_495080(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD *)(a1 + 396) + 4))(
           a1,
           0,
           0,
           0,
           a2,
           a3,
           a4);
}

//----- (004950B0) --------------------------------------------------------
int __cdecl sub_4950B0(int a1, char a2)
{
  _DWORD *v3; // ebp
  int result; // eax
  int *v5; // edi
  _DWORD *v6; // ebp
  int v7; // ecx
  int v8; // ebx
  int v9; // eax
  int *v10; // ecx
  int v11; // edx
  int v12; // [esp-Ch] [ebp-18h]
  int v13; // [esp-8h] [ebp-14h]
  _DWORD *v14; // [esp+10h] [ebp+4h]
  int v15; // [esp+14h] [ebp+8h]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 116);
  *(_DWORD *)(a1 + 392) = v3;
  v14 = v3;
  *v3 = sub_4951C0;
  v3[2] = sub_495240;
  v3[28] = 0;
  if ( a2 )
  {
    result = *(_DWORD *)(a1 + 36);
    v15 = 0;
    if ( result > 0 )
    {
      v5 = (int *)(*(_DWORD *)(a1 + 196) + 12);
      v6 = v3 + 18;
      do
      {
        v7 = *v5;
        if ( *(_BYTE *)(a1 + 200) )
          v7 *= 3;
        v8 = *(_DWORD *)(a1 + 4);
        v13 = v7;
        v12 = sub_493ED0(v5[5], *v5);
        v9 = sub_493ED0(v5[4], *(v5 - 1));
        *v6 = (*(int (__cdecl **)(int, int, int, int, int, int))(v8 + 20))(a1, 1, 1, v9, v12, v13);
        result = v15 + 1;
        ++v6;
        v5 += 21;
        ++v15;
      }
      while ( v15 < *(_DWORD *)(a1 + 36) );
      v3 = v14;
    }
    v3[1] = sub_4954F0;
    v3[3] = sub_495710;
    v3[4] = v3 + 18;
  }
  else
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v10 = v3 + 8;
    v11 = 10;
    do
    {
      *v10++ = result;
      result += 128;
      --v11;
    }
    while ( v11 );
    v3[1] = sub_4954E0;
    v3[3] = sub_495290;
    v3[4] = 0;
  }
  return result;
}

//----- (004951C0) --------------------------------------------------------
_DWORD *__cdecl sub_4951C0(_DWORD *a1)
{
  a1[32] = 0;
  return sub_4951E0(a1);
}

//----- (004951E0) --------------------------------------------------------
_DWORD *__cdecl sub_4951E0(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax
  int v3; // ecx

  v1 = 1;
  result = (_DWORD *)a1[98];
  if ( (int)a1[73] <= 1 )
  {
    v3 = a1[74];
    if ( a1[32] < (unsigned int)(a1[71] - 1) )
    {
      result[7] = *(_DWORD *)(v3 + 12);
      result[5] = 0;
      result[6] = 0;
      return result;
    }
    v1 = *(_DWORD *)(v3 + 72);
  }
  result[7] = v1;
  result[5] = 0;
  result[6] = 0;
  return result;
}

//----- (00495240) --------------------------------------------------------
char __cdecl sub_495240(int a1)
{
  int v1; // edi
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 392);
  v2 = *(_DWORD *)(v1 + 16);
  if ( !v2 )
    goto LABEL_6;
  LOBYTE(v2) = *(_BYTE *)(a1 + 73);
  if ( !(_BYTE)v2 || (LOBYTE(v2) = sub_4958C0(a1), !(_BYTE)v2) )
  {
    *(_DWORD *)(v1 + 12) = sub_495710;
LABEL_6:
    *(_DWORD *)(a1 + 136) = 0;
    return v2;
  }
  *(_DWORD *)(v1 + 12) = sub_4959E0;
  *(_DWORD *)(a1 + 136) = 0;
  return v2;
}

//----- (00495290) --------------------------------------------------------
int __cdecl sub_495290(_DWORD *a1, int a2)
{
  _DWORD *v2; // ebp
  int v3; // esi
  unsigned int v4; // ebx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // ecx
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // ebx
  int v13; // eax
  _DWORD *v14; // ebp
  bool v15; // cc
  int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // edx
  int result; // eax
  int v20; // [esp+10h] [ebp-34h]
  unsigned int v21; // [esp+14h] [ebp-30h]
  int v22; // [esp+18h] [ebp-2Ch]
  int v23; // [esp+1Ch] [ebp-28h]
  _DWORD *v24; // [esp+20h] [ebp-24h]
  int v25; // [esp+24h] [ebp-20h]
  int v26; // [esp+28h] [ebp-1Ch]
  int i; // [esp+2Ch] [ebp-18h]
  int v28; // [esp+30h] [ebp-14h]
  unsigned int v29; // [esp+34h] [ebp-10h]
  unsigned int v30; // [esp+38h] [ebp-Ch]
  void (__cdecl *v31)(_DWORD *, _DWORD *, _DWORD, int, int); // [esp+3Ch] [ebp-8h]
  int v32; // [esp+40h] [ebp-4h]

  v2 = a1;
  v3 = a1[98];
  v4 = a1[78] - 1;
  v22 = v3;
  v30 = a1[71] - 1;
  v5 = *(_DWORD *)(v3 + 24);
  v29 = v4;
  v20 = v5;
  if ( v5 >= *(_DWORD *)(v3 + 28) )
  {
LABEL_25:
    v17 = v2[71];
    v18 = v2[32] + 1;
    ++v2[34];
    v2[32] = v18;
    if ( v18 >= v17 )
    {
      (*(void (__cdecl **)(_DWORD *))(v2[100] + 12))(v2);
      result = 4;
    }
    else
    {
      sub_4951E0(v2);
      result = 3;
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 20);
      v21 = v6;
      if ( v6 <= v4 )
        break;
LABEL_24:
      v16 = *(_DWORD *)(v3 + 28);
      ++v5;
      *(_DWORD *)(v3 + 20) = 0;
      v20 = v5;
      if ( v5 >= v16 )
        goto LABEL_25;
    }
    while ( 1 )
    {
      sub_493F70(*(void **)(v3 + 32), v2[80] << 7);
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, int))(v2[102] + 4))(v2, v3 + 32) )
        break;
      v7 = 0;
      v23 = 0;
      v28 = 0;
      if ( (int)v2[73] > 0 )
      {
        v24 = v2 + 74;
        do
        {
          v8 = (_DWORD *)*v24;
          if ( *(_BYTE *)(*v24 + 48) )
          {
            v9 = v8[1];
            v31 = *(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, int))(v2[103] + 4 * v9 + 4);
            if ( v6 >= v4 )
              v10 = v8[17];
            else
              v10 = v8[13];
            v25 = v10;
            v11 = v21 * v8[16];
            v12 = *(_DWORD *)(a2 + 4 * v9) + 4 * v20 * v8[9];
            v13 = 0;
            v32 = v11;
            for ( i = 0; v13 < v8[14]; i = v13 )
            {
              if ( (v2[32] < v30 || v13 + v20 < v8[18]) && v25 > 0 )
              {
                v26 = v25;
                v14 = (_DWORD *)(v22 + 4 * v7 + 32);
                do
                {
                  v31(a1, v8, *v14, v12, v11);
                  v11 += v8[9];
                  ++v14;
                  --v26;
                }
                while ( v26 );
                v11 = v32;
                v7 = v23;
                v2 = a1;
                v13 = i;
              }
              v7 += v8[13];
              ++v13;
              v23 = v7;
              v12 += 4 * v8[9];
            }
          }
          else
          {
            v7 += v8[15];
            v23 = v7;
          }
          v4 = v29;
          v6 = v21;
          v15 = ++v28 < v2[73];
          ++v24;
        }
        while ( v15 );
      }
      v21 = ++v6;
      if ( v6 > v4 )
      {
        v5 = v20;
        v3 = v22;
        goto LABEL_24;
      }
      v3 = v22;
    }
    *(_DWORD *)(v22 + 20) = v6;
    *(_DWORD *)(v22 + 24) = v20;
    result = 0;
  }
  return result;
}

//----- (004954E0) --------------------------------------------------------
int sub_4954E0()
{
  return 0;
}

//----- (004954F0) --------------------------------------------------------
int __cdecl sub_4954F0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  unsigned int v5; // ebp
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  _DWORD *v9; // ebp
  int v10; // eax
  int v11; // edx
  int *v12; // esi
  bool v13; // cc
  int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // eax
  int result; // eax
  _DWORD *v18; // [esp+10h] [ebp-30h]
  int v19; // [esp+10h] [ebp-30h]
  _DWORD *v20; // [esp+14h] [ebp-2Ch]
  char *v21; // [esp+18h] [ebp-28h]
  char *v22; // [esp+18h] [ebp-28h]
  int v23; // [esp+1Ch] [ebp-24h]
  int v24; // [esp+20h] [ebp-20h]
  _DWORD *v25; // [esp+24h] [ebp-1Ch]
  int v26; // [esp+28h] [ebp-18h]
  int v27; // [esp+2Ch] [ebp-14h]
  char v28[16]; // [esp+30h] [ebp-10h] BYREF

  v1 = a1;
  v2 = 0;
  v3 = (_DWORD *)a1[98];
  v25 = v3;
  if ( (int)a1[73] > 0 )
  {
    v21 = v28;
    v18 = a1 + 74;
    do
    {
      ++v2;
      *(_DWORD *)v21 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(a1[1] + 32))(
                         a1,
                         v3[*(_DWORD *)(*v18 + 4) + 18],
                         *(_DWORD *)(*v18 + 12) * a1[32],
                         *(_DWORD *)(*v18 + 12),
                         1);
      ++v18;
      v21 += 4;
    }
    while ( v2 < a1[73] );
  }
  v4 = v3[6];
  v19 = v4;
  if ( v4 >= v3[7] )
  {
LABEL_22:
    v15 = v1[71];
    v16 = v1[32] + 1;
    v1[32] = v16;
    if ( v16 >= v15 )
    {
      (*(void (__cdecl **)(_DWORD *))(v1[100] + 12))(v1);
      result = 4;
    }
    else
    {
      sub_4951E0(v1);
      result = 3;
    }
  }
  else
  {
    while ( 1 )
    {
      v5 = v3[5];
      v26 = v5;
      if ( v5 < v1[78] )
        break;
LABEL_21:
      v14 = v3[7];
      ++v4;
      v3[5] = 0;
      v19 = v4;
      if ( v4 >= v14 )
        goto LABEL_22;
    }
    while ( 1 )
    {
      v6 = 0;
      v24 = 0;
      if ( (int)v1[73] > 0 )
      {
        v22 = v28;
        v20 = v1 + 74;
        do
        {
          v23 = 0;
          v7 = *v20;
          v8 = *(_DWORD *)(*v20 + 52);
          if ( *(int *)(*v20 + 56) > 0 )
          {
            v27 = (v5 * *(_DWORD *)(*v20 + 52)) << 7;
            v9 = (_DWORD *)(*(_DWORD *)v22 + 4 * v19);
            do
            {
              v10 = v27 + *v9;
              v11 = 0;
              if ( v8 > 0 )
              {
                v12 = &v25[v6 + 8];
                do
                {
                  *v12 = v10;
                  v8 = *(_DWORD *)(v7 + 52);
                  ++v6;
                  ++v12;
                  v10 += 128;
                  ++v11;
                }
                while ( v11 < v8 );
                v1 = a1;
              }
              ++v9;
              ++v23;
            }
            while ( v23 < *(_DWORD *)(v7 + 56) );
            v5 = v26;
          }
          v13 = ++v24 < v1[73];
          ++v20;
          v22 += 4;
        }
        while ( v13 );
        v3 = v25;
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(v1[102] + 4))(v1, v3 + 8) )
        break;
      v26 = ++v5;
      if ( v5 >= v1[78] )
      {
        v4 = v19;
        goto LABEL_21;
      }
    }
    v3[5] = v5;
    v3[6] = v19;
    result = 0;
  }
  return result;
}

//----- (00495710) --------------------------------------------------------
int __cdecl sub_495710(int a1, _DWORD *a2)
{
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // ebp
  int v9; // eax
  int *v10; // ebp
  int v11; // edx
  int v12; // ebp
  int v13; // edi
  bool v14; // zf
  bool v15; // cc
  unsigned int v16; // edx
  unsigned int v17; // eax
  int v19; // [esp+8h] [ebp-20h]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  _DWORD *v22; // [esp+14h] [ebp-14h]
  _DWORD *v23; // [esp+18h] [ebp-10h]
  unsigned int v24; // [esp+1Ch] [ebp-Ch]
  int v25; // [esp+20h] [ebp-8h]
  void (__cdecl *v26)(int, int, int, int, int); // [esp+24h] [ebp-4h]
  int v27; // [esp+2Ch] [ebp+4h]
  unsigned int i; // [esp+30h] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 392);
  v24 = *(_DWORD *)(a1 + 284) - 1;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 124);
    v5 = *(_DWORD *)(a1 + 132);
    if ( v4 >= v5 && (v4 != v5 || *(_DWORD *)(a1 + 128) > *(_DWORD *)(a1 + 136)) )
      break;
    if ( !(**(int (__cdecl ***)(int))(a1 + 400))(a1) )
      return 0;
  }
  v6 = *(_DWORD *)(a1 + 196);
  v21 = 0;
  if ( *(int *)(a1 + 36) > 0 )
  {
    v7 = a2;
    v8 = (_DWORD *)(v3 + 72);
    v23 = a2;
    v22 = v8;
    v25 = 4 - (_DWORD)a2;
    do
    {
      if ( *(_BYTE *)(v6 + 48) )
      {
        v9 = (*(int (__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 4) + 32))(
               a1,
               *v8,
               *(_DWORD *)(v6 + 12) * *(_DWORD *)(a1 + 136),
               *(_DWORD *)(v6 + 12),
               0);
        v10 = (int *)v9;
        if ( *(_DWORD *)(a1 + 136) >= v24 )
        {
          v11 = *(_DWORD *)(v6 + 32) % *(_DWORD *)(v6 + 12);
          if ( !v11 )
            v11 = *(_DWORD *)(v6 + 12);
        }
        else
        {
          v11 = *(_DWORD *)(v6 + 12);
        }
        v26 = *(void (__cdecl **)(int, int, int, int, int))((char *)v7 + v25 + *(_DWORD *)(a1 + 412));
        v27 = *v7;
        if ( v11 > 0 )
        {
          v19 = v9;
          v20 = v11;
          do
          {
            v12 = *v10;
            v13 = 0;
            for ( i = 0; i < *(_DWORD *)(v6 + 28); ++i )
            {
              v26(a1, v6, v12, v27, v13);
              v13 += *(_DWORD *)(v6 + 36);
              v12 += 128;
            }
            v10 = (int *)(v19 + 4);
            v14 = v20 == 1;
            v27 += 4 * *(_DWORD *)(v6 + 36);
            v19 += 4;
            --v20;
          }
          while ( !v14 );
          v7 = v23;
        }
      }
      v8 = v22 + 1;
      ++v7;
      v6 += 84;
      v15 = ++v21 < *(_DWORD *)(a1 + 36);
      ++v22;
      v23 = v7;
    }
    while ( v15 );
  }
  v16 = *(_DWORD *)(a1 + 284);
  v17 = *(_DWORD *)(a1 + 136) + 1;
  *(_DWORD *)(a1 + 136) = v17;
  return 4 - (v17 < v16);
}

//----- (004958C0) --------------------------------------------------------
char __cdecl sub_4958C0(int a1)
{
  int v2; // esi
  int v3; // ebx
  int v4; // esi
  _WORD *v5; // eax
  int *v6; // ecx
  _DWORD *v7; // eax
  int v8; // ebp
  int v10; // [esp+10h] [ebp-8h]
  _WORD **i; // [esp+14h] [ebp-4h]
  char v12; // [esp+1Ch] [ebp+4h]

  v12 = 0;
  v2 = *(_DWORD *)(a1 + 392);
  if ( *(_BYTE *)(a1 + 200) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 140) )
    {
      if ( !*(_DWORD *)(v2 + 112) )
        *(_DWORD *)(v2 + 112) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD *)(a1 + 36));
      v4 = *(_DWORD *)(v2 + 112);
      if ( *(int *)(a1 + 36) <= 0 )
        return v12;
      v10 = 0;
      for ( i = (_WORD **)(*(_DWORD *)(a1 + 196) + 76); ; i += 21 )
      {
        v5 = *i;
        if ( !*i )
          break;
        if ( !*v5 )
          break;
        if ( !v5[1] )
          break;
        if ( !v5[8] )
          break;
        if ( !v5[16] )
          break;
        if ( !v5[9] )
          break;
        if ( !v5[2] )
          break;
        v6 = (int *)(v10 + *(_DWORD *)(a1 + 140));
        if ( *v6 < 0 )
          break;
        v7 = v6 + 1;
        v8 = 5;
        do
        {
          *(_DWORD *)((char *)v7 + v4 - (_DWORD)v6) = *v7;
          if ( *v7 )
            v12 = 1;
          ++v7;
          --v8;
        }
        while ( v8 );
        v4 += 24;
        ++v3;
        v10 += 256;
        if ( v3 >= *(_DWORD *)(a1 + 36) )
          return v12;
      }
    }
  }
  return 0;
}

//----- (004959E0) --------------------------------------------------------
int __cdecl sub_4959E0(_DWORD *a1, int *a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  unsigned int v6; // ebp
  int v7; // edx
  int v8; // ebx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // eax
  int v13; // esi
  unsigned __int16 *v14; // eax
  int v15; // eax
  __int16 *v16; // edx
  __int16 *v17; // ecx
  __int16 *v18; // eax
  int v19; // esi
  int v20; // edi
  int v21; // ebp
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // eax
  bool v42; // cc
  unsigned int v43; // edx
  unsigned int v44; // edi
  char v45; // [esp+12h] [ebp-102h]
  char v46; // [esp+13h] [ebp-101h]
  int v47; // [esp+14h] [ebp-100h]
  _DWORD *v48; // [esp+18h] [ebp-FCh]
  int v49; // [esp+1Ch] [ebp-F8h]
  _DWORD *v50; // [esp+20h] [ebp-F4h]
  int v51; // [esp+24h] [ebp-F0h]
  int v52; // [esp+28h] [ebp-ECh]
  __int16 *v53; // [esp+2Ch] [ebp-E8h]
  int v54; // [esp+30h] [ebp-E4h]
  int v55; // [esp+34h] [ebp-E0h]
  int v56; // [esp+38h] [ebp-DCh]
  int v57; // [esp+3Ch] [ebp-D8h]
  int v58; // [esp+40h] [ebp-D4h]
  unsigned int v59; // [esp+44h] [ebp-D0h]
  int v60; // [esp+48h] [ebp-CCh]
  int v61; // [esp+4Ch] [ebp-C8h]
  __int16 *v62; // [esp+50h] [ebp-C4h]
  int v63; // [esp+54h] [ebp-C0h]
  __int16 *v64; // [esp+58h] [ebp-BCh]
  int v65; // [esp+5Ch] [ebp-B8h]
  int v66; // [esp+60h] [ebp-B4h]
  int v68; // [esp+68h] [ebp-ACh]
  int v69; // [esp+6Ch] [ebp-A8h]
  int v70; // [esp+70h] [ebp-A4h]
  int v71; // [esp+74h] [ebp-A0h]
  unsigned int v72; // [esp+78h] [ebp-9Ch]
  int v73; // [esp+7Ch] [ebp-98h]
  int v74; // [esp+80h] [ebp-94h]
  int v75; // [esp+84h] [ebp-90h]
  void (__cdecl *v76)(_DWORD *, int, char *, int, int); // [esp+88h] [ebp-8Ch]
  unsigned int i; // [esp+8Ch] [ebp-88h]
  int v78; // [esp+90h] [ebp-84h]
  char v79[2]; // [esp+94h] [ebp-80h] BYREF
  __int16 v80; // [esp+96h] [ebp-7Eh]
  __int16 v81; // [esp+98h] [ebp-7Ch]
  __int16 v82; // [esp+A4h] [ebp-70h]
  __int16 v83; // [esp+A6h] [ebp-6Eh]
  __int16 v84; // [esp+B4h] [ebp-60h]

  v2 = a1;
  v3 = a1[31];
  v4 = a1[33];
  v5 = a1[98];
  v6 = a1[71] - 1;
  v75 = v5;
  for ( i = v6; v3 <= v4; v4 = a1[33] )
  {
    v7 = a1[100];
    if ( *(_BYTE *)(v7 + 17)
      || v3 == v4 && __PAIR64__(a1[32], a1[91]) >= __PAIR64__(a1[34], 1) && a1[32] != a1[34] + (a1[91] == 0) )
    {
      break;
    }
    if ( !(*(int (__cdecl **)(_DWORD *))v7)(a1) )
      return 0;
    v3 = a1[31];
  }
  v8 = a1[49];
  v55 = v8;
  v69 = 0;
  if ( (int)a1[9] > 0 )
  {
    v65 = 0;
    v48 = (_DWORD *)(v5 + 72);
    v78 = -68 - v5;
    do
    {
      if ( *(_BYTE *)(v8 + 48) )
      {
        v9 = v2[34];
        v10 = *(_DWORD *)(v8 + 12);
        if ( v9 >= v6 )
        {
          v11 = *(_DWORD *)(v8 + 32) % v10;
          v47 = v11;
          if ( !v11 )
          {
            v47 = *(_DWORD *)(v8 + 12);
            v11 = v47;
          }
          v45 = 1;
        }
        else
        {
          v45 = 0;
          v47 = *(_DWORD *)(v8 + 12);
          v11 = 2 * v10;
        }
        if ( v9 )
        {
          v46 = 0;
          v13 = (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                  a1,
                  *v48,
                  v10 * (v9 - 1),
                  v10 + v11,
                  0)
              + 4 * *(_DWORD *)(v8 + 12);
          v57 = v13;
        }
        else
        {
          v57 = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v48, 0, v11, 0);
          v46 = 1;
          v13 = v57;
        }
        v50 = (_DWORD *)(v65 + *(_DWORD *)(v75 + 112));
        v14 = *(unsigned __int16 **)(v8 + 76);
        v49 = *v14;
        v68 = v14[1];
        v70 = v14[8];
        v74 = v14[16];
        v73 = v14[9];
        v71 = v14[2];
        v76 = *(void (__cdecl **)(_DWORD *, int, char *, int, int))((char *)v48 + v78 + a1[103]);
        v61 = *a2;
        v15 = 0;
        v63 = 0;
        if ( v47 > 0 )
        {
          while ( 1 )
          {
            v16 = *(__int16 **)(v13 + 4 * v15);
            v53 = v16;
            if ( !v46 || (v17 = *(__int16 **)(v13 + 4 * v15), v15) )
              v17 = *(__int16 **)(v13 + 4 * v15 - 4);
            v18 = (__int16 *)(v45 && v15 == v47 - 1 ? *(_DWORD *)(v13 + 4 * v15) : *(_DWORD *)(v13 + 4 * v15 + 4));
            v19 = *v16;
            v51 = v19;
            v20 = *v17;
            v21 = *v18;
            v58 = v20;
            v54 = v20;
            v66 = v19;
            v60 = v21;
            v52 = v21;
            v56 = 0;
            v72 = *(_DWORD *)(v8 + 28) - 1;
            v59 = 0;
            v62 = v18 + 64;
            v64 = v17 + 64;
            do
            {
              sub_493F40(v53, v79, 1);
              if ( v59 < v72 )
              {
                v58 = *v64;
                v19 = v53[64];
                v60 = *v62;
              }
              v22 = v50[1];
              if ( v22 && !v80 )
              {
                v23 = 36 * v49 * (v66 - v19);
                if ( v23 < 0 )
                {
                  v25 = ((v68 << 7) - v23) / (v68 << 8);
                  if ( v22 > 0 && v25 >= 1 << v22 )
                    v25 = (1 << v22) - 1;
                  v24 = -v25;
                }
                else
                {
                  v24 = (v23 + (v68 << 7)) / (v68 << 8);
                  if ( v22 > 0 && v24 >= 1 << v22 )
                    v24 = (1 << v22) - 1;
                }
                v8 = v55;
                v80 = v24;
              }
              v26 = v50[2];
              if ( v26 && !v82 )
              {
                v27 = 36 * v49 * (v54 - v52);
                if ( v27 < 0 )
                {
                  v29 = ((v70 << 7) - v27) / (v70 << 8);
                  if ( v26 > 0 && v29 >= 1 << v26 )
                    v29 = (1 << v26) - 1;
                  v28 = -v29;
                }
                else
                {
                  v28 = (v27 + (v70 << 7)) / (v70 << 8);
                  if ( v26 > 0 && v28 >= 1 << v26 )
                    v28 = (1 << v26) - 1;
                }
                v8 = v55;
                v82 = v28;
              }
              v30 = v50[3];
              if ( v30 && !v84 )
              {
                v31 = 9 * v49 * (v54 + v52 - 2 * v51);
                if ( v31 < 0 )
                {
                  v33 = ((v74 << 7) - v31) / (v74 << 8);
                  if ( v30 > 0 && v33 >= 1 << v30 )
                    v33 = (1 << v30) - 1;
                  v32 = -v33;
                }
                else
                {
                  v32 = (v31 + (v74 << 7)) / (v74 << 8);
                  if ( v30 > 0 && v32 >= 1 << v30 )
                    v32 = (1 << v30) - 1;
                }
                v8 = v55;
                v84 = v32;
              }
              v34 = v50[4];
              if ( v34 && !v83 )
              {
                v35 = 5 * v49 * (v20 + v60 - v21 - v58);
                if ( v35 < 0 )
                {
                  v37 = ((v73 << 7) - v35) / (v73 << 8);
                  if ( v34 > 0 && v37 >= 1 << v34 )
                    v37 = (1 << v34) - 1;
                  v36 = -v37;
                }
                else
                {
                  v36 = (v35 + (v73 << 7)) / (v73 << 8);
                  if ( v34 > 0 && v36 >= 1 << v34 )
                    v36 = (1 << v34) - 1;
                }
                v83 = v36;
              }
              v38 = v50[5];
              if ( v38 && !v81 )
              {
                v39 = 9 * v49 * (v66 + v19 - 2 * v51);
                if ( v39 < 0 )
                {
                  v41 = ((v71 << 7) - v39) / (v71 << 8);
                  if ( v38 > 0 && v41 >= 1 << v38 )
                    v41 = (1 << v38) - 1;
                  v40 = -v41;
                }
                else
                {
                  v40 = (v39 + (v71 << 7)) / (v71 << 8);
                  if ( v38 > 0 && v40 >= 1 << v38 )
                    v40 = (1 << v38) - 1;
                }
                v81 = v40;
              }
              v76(a1, v8, v79, v61, v56);
              v20 = v54;
              v21 = v52;
              v54 = v58;
              v52 = v60;
              v66 = v51;
              v53 += 64;
              v62 += 64;
              v56 += *(_DWORD *)(v8 + 36);
              v51 = v19;
              v42 = v59 + 1 <= v72;
              v64 += 64;
              ++v59;
            }
            while ( v42 );
            v61 += 4 * *(_DWORD *)(v8 + 36);
            if ( ++v63 >= v47 )
              break;
            v15 = v63;
            v13 = v57;
          }
        }
        v6 = i;
        v2 = a1;
      }
      v65 += 24;
      v8 += 84;
      v42 = ++v69 < v2[9];
      ++v48;
      ++a2;
      v55 = v8;
    }
    while ( v42 );
  }
  v43 = v2[71];
  v44 = v2[34] + 1;
  v2[34] = v44;
  return 4 - (v44 < v43);
}

//----- (00496060) --------------------------------------------------------
unsigned __int8 __cdecl sub_496060(int (__cdecl ***a1)(_DWORD, _DWORD, _DWORD), unsigned __int8 a2, int a3, int a4)
{
  int (__cdecl ***v4)(_DWORD, _DWORD, _DWORD); // edi
  unsigned __int8 *v5; // ebp
  int v6; // ebx
  int v7; // esi
  int v8; // ebp
  int v9; // eax
  int v10; // ebp
  int v11; // eax
  unsigned int v12; // ecx
  char *v13; // edi
  int v14; // ebx
  int v15; // edi
  int v16; // esi
  int i; // ebp
  char *v18; // eax
  int v19; // ecx
  int v20; // edi
  int v21; // eax
  _DWORD *v22; // ecx
  unsigned __int8 *v23; // esi
  int v24; // eax
  int v25; // ecx
  int v26; // ebp
  unsigned __int8 *v27; // edi
  int v28; // ebx
  int v29; // eax
  int v30; // esi
  unsigned __int8 *v31; // edx
  int *v32; // eax
  unsigned __int8 result; // al
  int j; // edi
  int v35; // [esp+Ch] [ebp-524h]
  int v36; // [esp+Ch] [ebp-524h]
  unsigned __int8 *v37; // [esp+10h] [ebp-520h]
  int v38; // [esp+14h] [ebp-51Ch]
  char *v39; // [esp+18h] [ebp-518h]
  _DWORD *v40; // [esp+1Ch] [ebp-514h]
  int v41; // [esp+20h] [ebp-510h]
  int v42; // [esp+24h] [ebp-50Ch]
  char v43[1288]; // [esp+28h] [ebp-508h] BYREF

  if ( a3 >= 0 && a3 < 4 )
  {
    v4 = a1;
  }
  else
  {
    v4 = a1;
    (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))50;
    (*a1)[6] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3;
    ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
  }
  if ( a2 )
  {
    v5 = (unsigned __int8 *)v4[a3 + 40];
    v37 = v5;
  }
  else
  {
    v37 = (unsigned __int8 *)v4[a3 + 44];
    v5 = v37;
  }
  if ( !v5 )
  {
    (*v4)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))50;
    (*v4)[6] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3;
    ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**v4)(v4);
  }
  if ( !*(_DWORD *)a4 )
    *(_DWORD *)a4 = (*v4[1])(v4, 1, 1424);
  v6 = 1;
  v40 = *(_DWORD **)a4;
  v7 = 0;
  *(_DWORD *)(*(_DWORD *)a4 + 140) = v5;
  v35 = 1;
  while ( 1 )
  {
    v8 = v5[v6];
    if ( v7 + v8 > 256 )
    {
      (*v4)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
      ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**v4)(v4);
    }
    v9 = v8;
    v10 = v8 - 1;
    if ( v9 )
    {
      BYTE1(v6) = v6;
      v11 = v6 << 16;
      LOWORD(v11) = v6;
      v12 = (unsigned int)(v10 + 1) >> 2;
      memset32(&v43[v7], v11, v12);
      v13 = &v43[4 * v12 + v7];
      v6 = v35;
      v7 += v10 + 1;
      memset(v13, v11, ((_BYTE)v10 + 1) & 3);
      v4 = a1;
    }
    v35 = ++v6;
    if ( v6 > 16 )
      break;
    v5 = v37;
  }
  v43[v7] = 0;
  v14 = v7;
  v15 = 0;
  v16 = 0;
  v42 = v14;
  for ( i = v43[0]; v43[v16]; ++i )
  {
    if ( v43[v16] == i )
    {
      v18 = &v43[4 * v16 + 260];
      do
      {
        v19 = v43[++v16];
        *(_DWORD *)v18 = v15;
        v18 += 4;
        ++v15;
      }
      while ( v19 == i );
    }
    if ( v15 >= 1 << i )
    {
      (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
      ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
    }
    v15 *= 2;
  }
  v20 = 0;
  v21 = 1;
  v22 = v40 + 1;
  do
  {
    v23 = v37;
    if ( v37[v21] )
    {
      v22[18] = v20 - *(_DWORD *)&v43[4 * v20 + 260];
      v20 += v37[v21];
      *v22 = *(_DWORD *)&v43[4 * v20 + 256];
    }
    else
    {
      *v22 = -1;
    }
    ++v21;
    ++v22;
  }
  while ( v21 <= 16 );
  v24 = 0;
  v40[17] = 0xFFFFF;
  memset(v40 + 36, 0, 0x400u);
  v25 = 7;
  v36 = 0;
  v26 = 1;
  v41 = 7;
  do
  {
    v38 = 1;
    if ( v23[v26] )
    {
      v27 = &v23[v24 + 17];
      v28 = 1 << v25;
      v39 = &v43[4 * v24 + 260];
      do
      {
        v29 = *(_DWORD *)v39 << v25;
        if ( v28 > 0 )
        {
          v30 = v28;
          v31 = (unsigned __int8 *)v40 + v29 + 1168;
          v32 = &v40[v29 + 36];
          do
          {
            *v32 = v26;
            *v31 = *v27;
            ++v32;
            ++v31;
            --v30;
          }
          while ( v30 );
          v25 = v41;
          v23 = v37;
        }
        ++v38;
        ++v36;
        v39 += 4;
        ++v27;
      }
      while ( v38 <= v23[v26] );
      v14 = v42;
      v24 = v36;
    }
    ++v26;
    v41 = --v25;
  }
  while ( v25 >= 0 );
  result = a2;
  if ( a2 )
  {
    for ( j = 0; j < v14; ++j )
    {
      result = v23[j + 17];
      if ( result > 0xFu )
      {
        (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
        result = ((int (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
      }
    }
  }
  return result;
}
// 496120: conditional instruction was optimized away because of 'ebp.4<100u'

//----- (00496340) --------------------------------------------------------
char __cdecl sub_496340(unsigned __int8 **a1, int a2, int a3, int a4)
{
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // edi
  unsigned __int8 **v7; // eax
  int v8; // eax
  unsigned __int8 **v9; // eax
  int v10; // eax
  char v12; // dl

  v4 = a1[4];
  v5 = *a1;
  v6 = a1[1];
  if ( *((_DWORD *)v4 + 95) )
    goto LABEL_17;
  while ( a3 < 25 )
  {
    if ( !v6 )
    {
      if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)v4 + 6) + 12))(v4) )
        return 0;
      v7 = (unsigned __int8 **)*((_DWORD *)v4 + 6);
      v5 = *v7;
      v6 = v7[1];
    }
    --v6;
    v8 = *v5++;
    if ( v8 == 255 )
    {
      do
      {
        if ( !v6 )
        {
          if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)v4 + 6) + 12))(v4) )
            return 0;
          v9 = (unsigned __int8 **)*((_DWORD *)v4 + 6);
          v5 = *v9;
          v6 = v9[1];
        }
        --v6;
        v10 = *v5++;
      }
      while ( v10 == 255 );
      if ( v10 )
      {
        *((_DWORD *)v4 + 95) = v10;
LABEL_17:
        if ( a4 > a3 )
        {
          if ( !*(_BYTE *)(*((_DWORD *)v4 + 102) + 8) )
          {
            *(_DWORD *)(*(_DWORD *)v4 + 20) = 117;
            (*(void (__cdecl **)(unsigned __int8 *, int))(*(_DWORD *)v4 + 4))(v4, -1);
            *(_BYTE *)(*((_DWORD *)v4 + 102) + 8) = 1;
          }
          v12 = a3;
          a3 = 25;
          a2 <<= 25 - v12;
        }
        break;
      }
      v8 = 255;
    }
    a2 = v8 | (a2 << 8);
    a3 += 8;
  }
  a1[1] = v6;
  *a1 = v5;
  a1[2] = (unsigned __int8 *)a2;
  a1[3] = (unsigned __int8 *)a3;
  return 1;
}

//----- (00496460) --------------------------------------------------------
int __cdecl sub_496460(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int *v10; // edi
  int v11; // esi
  int v12; // esi

  v5 = a3;
  if ( a3 >= a5 )
  {
    v7 = a2;
  }
  else
  {
    if ( !sub_496340((unsigned __int8 **)a1, a2, a3, a5) )
      return -1;
    v7 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
  }
  v8 = v5 - a5;
  v9 = a4;
  v10 = (int *)(a4 + 4 * a5);
  v11 = ((1 << a5) - 1) & (v7 >> v8);
  if ( v11 > *v10 )
  {
    do
    {
      v12 = 2 * v11;
      if ( v8 < 1 )
      {
        if ( !sub_496340((unsigned __int8 **)a1, v7, v8, 1) )
          return -1;
        v7 = *(_DWORD *)(a1 + 8);
        v8 = *(_DWORD *)(a1 + 12);
      }
      --v8;
      ++v10;
      v11 = (v7 >> v8) & 1 | v12;
      ++a5;
    }
    while ( v11 > *v10 );
    v9 = a4;
  }
  *(_DWORD *)(a1 + 12) = v8;
  *(_DWORD *)(a1 + 8) = v7;
  if ( a5 <= 16 )
    return *(unsigned __int8 *)(*(_DWORD *)(v9 + 140) + *(_DWORD *)(v9 + 4 * a5 + 72) + v11 + 17);
  *(_DWORD *)(**(_DWORD **)(a1 + 16) + 20) = 118;
  (*(void (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 16) + 4))(*(_DWORD *)(a1 + 16), -1);
  return 0;
}

//----- (00496550) --------------------------------------------------------
_DWORD *__cdecl sub_496550(int a1)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax
  int v3; // ecx

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 172);
  *(_DWORD *)(a1 + 408) = v1;
  *v1 = sub_496590;
  v1[1] = sub_4966E0;
  result = v1 + 10;
  v3 = 4;
  do
  {
    result[4] = 0;
    *result++ = 0;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (00496590) --------------------------------------------------------
int __cdecl sub_496590(_DWORD *a1)
{
  int v2; // edi
  _DWORD *v3; // ebx
  int v4; // ebp
  int v5; // ecx
  _DWORD *v6; // edx
  _DWORD *v7; // ebp
  int v8; // eax
  int result; // eax
  _DWORD *v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+18h] [ebp+4h]

  v2 = a1[102];
  if ( a1[91] || a1[92] != 63 || a1[93] || a1[94] )
  {
    *(_DWORD *)(*a1 + 20) = 122;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v11 = 0;
  if ( (int)a1[73] > 0 )
  {
    v3 = a1 + 74;
    v10 = (_DWORD *)(v2 + 20);
    do
    {
      v4 = *(_DWORD *)(*v3 + 24);
      sub_496060(
        (int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1,
        1u,
        *(_DWORD *)(*v3 + 20),
        v2 + 4 * *(_DWORD *)(*v3 + 20) + 40);
      sub_496060((int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0, v4, v2 + 4 * v4 + 56);
      *v10++ = 0;
      ++v3;
      ++v11;
    }
    while ( v11 < a1[73] );
  }
  v5 = 0;
  if ( (int)a1[80] > 0 )
  {
    v6 = (_DWORD *)(v2 + 112);
    v7 = a1 + 81;
    do
    {
      v8 = a1[*v7 + 74];
      *(v6 - 10) = *(_DWORD *)(v2 + 4 * *(_DWORD *)(v8 + 20) + 40);
      *v6 = *(_DWORD *)(v2 + 4 * *(_DWORD *)(v8 + 24) + 56);
      if ( *(_BYTE *)(v8 + 48) )
      {
        *(_BYTE *)(v5 + v2 + 152) = 1;
        *(_BYTE *)(v5 + v2 + 162) = *(_DWORD *)(v8 + 36) > 1;
      }
      else
      {
        *(_BYTE *)(v5 + v2 + 162) = 0;
        *(_BYTE *)(v5 + v2 + 152) = 0;
      }
      ++v5;
      ++v7;
      ++v6;
    }
    while ( v5 < a1[80] );
  }
  result = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_BYTE *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 36) = a1[63];
  return result;
}

//----- (004966E0) --------------------------------------------------------
char __cdecl sub_4966E0(_DWORD *a1, _WORD **a2)
{
  _DWORD *v2; // edi
  int v3; // esi
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int *v8; // ecx
  int v9; // ebx
  int v10; // edi
  _WORD *v11; // ebp
  int v12; // ecx
  int v13; // esi
  int v14; // ecx
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // ebp
  int v19; // ecx
  int v20; // esi
  int v21; // ecx
  int v22; // esi
  int v23; // ecx
  int v24; // esi
  int v25; // ebp
  int v26; // edi
  int i; // edi
  int v28; // ecx
  int v29; // esi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // esi
  int v34; // edi
  int v35; // ecx
  int v36; // edx
  int v37; // eax
  int v38; // edx
  int v39; // [esp+10h] [ebp-3Ch]
  int *v41; // [esp+18h] [ebp-34h]
  _DWORD *v42; // [esp+1Ch] [ebp-30h]
  int v43; // [esp+20h] [ebp-2Ch]
  _WORD *v44; // [esp+24h] [ebp-28h]
  int v45; // [esp+28h] [ebp-24h]
  int v46; // [esp+2Ch] [ebp-20h]
  int v47; // [esp+30h] [ebp-1Ch]
  int v48; // [esp+34h] [ebp-18h]
  unsigned __int8 *v49; // [esp+38h] [ebp-14h] BYREF
  int v50; // [esp+3Ch] [ebp-10h]
  int v51; // [esp+40h] [ebp-Ch]
  int v52; // [esp+44h] [ebp-8h]
  _DWORD *v53; // [esp+48h] [ebp-4h]
  int v54; // [esp+54h] [ebp+8h]

  v2 = a1;
  v3 = a1[102];
  v43 = v3;
  if ( a1[63] && !*(_DWORD *)(v3 + 36) && !sub_496B20(a1) )
    return 0;
  if ( *(_BYTE *)(v3 + 8) )
    goto LABEL_72;
  v5 = a1[6];
  v53 = a1;
  v39 = 0;
  v49 = *(unsigned __int8 **)v5;
  v50 = *(_DWORD *)(v5 + 4);
  v6 = *(_DWORD *)(v3 + 12);
  v7 = *(_DWORD *)(v3 + 16);
  v45 = *(_DWORD *)(v3 + 20);
  v46 = *(_DWORD *)(v3 + 24);
  v47 = *(_DWORD *)(v3 + 28);
  v48 = *(_DWORD *)(v3 + 32);
  if ( (int)a1[80] <= 0 )
    goto LABEL_71;
  v8 = (int *)(v3 + 112);
  v42 = a1 + 81;
  v41 = (int *)(v3 + 112);
  while ( 2 )
  {
    v9 = *v8;
    v10 = *(v8 - 10);
    v11 = *a2;
    v54 = *v8;
    v44 = *a2;
    if ( v7 < 8 )
    {
      if ( !sub_496340(&v49, v6, v7, 0) )
        return 0;
      v7 = v52;
      v6 = v51;
      if ( v52 < 8 )
      {
        v12 = 1;
LABEL_16:
        v15 = sub_496460((int)&v49, v6, v7, v10, v12);
        if ( v15 < 0 )
          return 0;
        v6 = v51;
        v7 = v52;
        goto LABEL_18;
      }
    }
    v13 = (unsigned __int8)(v6 >> (v7 - 8));
    v14 = *(_DWORD *)(v10 + 4 * v13 + 144);
    if ( !v14 )
    {
      v12 = 9;
      goto LABEL_16;
    }
    v7 -= v14;
    v15 = *(unsigned __int8 *)(v13 + v10 + 1168);
LABEL_18:
    if ( v15 )
    {
      if ( v7 < v15 )
      {
        if ( !sub_496340(&v49, v6, v7, v15) )
          return 0;
        v6 = v51;
        v7 = v52;
      }
      v7 -= v15;
      v16 = (v6 >> v7) & ((1 << v15) - 1);
      if ( v16 >= dword_4B0BFC[v15] )
        v15 = (v6 >> v7) & ((1 << v15) - 1);
      else
        v15 = v16 + dword_4B0C3C[v15];
      v9 = v54;
    }
    if ( *(_BYTE *)(v39 + v43 + 152) )
    {
      v17 = *(&v45 + *v42) + v15;
      *(&v45 + *v42) = v17;
      *v11 = v17;
    }
    if ( *(_BYTE *)(v39 + v43 + 162) )
    {
      v18 = 1;
      while ( 1 )
      {
        if ( v7 < 8 )
        {
          if ( !sub_496340(&v49, v6, v7, 0) )
            return 0;
          v7 = v52;
          v6 = v51;
          if ( v52 < 8 )
            break;
        }
        v20 = (unsigned __int8)(v6 >> (v7 - 8));
        v21 = *(_DWORD *)(v9 + 4 * v20 + 144);
        if ( !v21 )
        {
          v19 = 9;
          goto LABEL_37;
        }
        v7 -= v21;
        v22 = *(unsigned __int8 *)(v20 + v9 + 1168);
LABEL_39:
        v23 = v22 >> 4;
        v24 = v22 & 0xF;
        if ( v24 )
        {
          v25 = v23 + v18;
          if ( v7 < v24 )
          {
            if ( !sub_496340(&v49, v6, v7, v24) )
              return 0;
            v6 = v51;
            v7 = v52;
          }
          v7 -= v24;
          v26 = (v6 >> v7) & ((1 << v24) - 1);
          if ( v26 >= dword_4B0BFC[v24] )
            v24 = (v6 >> v7) & ((1 << v24) - 1);
          else
            LOWORD(v24) = v26 + dword_4B0C3C[v24];
          v9 = v54;
          v44[dword_4B0ABC[v25]] = v24;
        }
        else
        {
          if ( v23 != 15 )
            goto LABEL_69;
          v25 = v18 + 15;
        }
        v18 = v25 + 1;
        if ( v18 >= 64 )
          goto LABEL_69;
      }
      v19 = 1;
LABEL_37:
      v22 = sub_496460((int)&v49, v6, v7, v9, v19);
      if ( v22 < 0 )
        return 0;
      v6 = v51;
      v7 = v52;
      goto LABEL_39;
    }
    for ( i = 1; i < 64; i = v34 + 1 )
    {
      if ( v7 >= 8 )
        goto LABEL_56;
      if ( !sub_496340(&v49, v6, v7, 0) )
        return 0;
      v7 = v52;
      v6 = v51;
      if ( v52 >= 8 )
      {
LABEL_56:
        v29 = (unsigned __int8)(v6 >> (v7 - 8));
        v30 = *(_DWORD *)(v9 + 4 * v29 + 144);
        if ( v30 )
        {
          v7 -= v30;
          v31 = *(unsigned __int8 *)(v29 + v9 + 1168);
          goto LABEL_61;
        }
        v28 = 9;
      }
      else
      {
        v28 = 1;
      }
      v31 = sub_496460((int)&v49, v6, v7, v9, v28);
      if ( v31 < 0 )
        return 0;
      v6 = v51;
      v7 = v52;
LABEL_61:
      v32 = v31 >> 4;
      v33 = v31 & 0xF;
      if ( v33 )
      {
        v34 = v32 + i;
        if ( v7 < v33 )
        {
          if ( !sub_496340(&v49, v6, v7, v33) )
            return 0;
          v6 = v51;
          v7 = v52;
        }
        v7 -= v33;
      }
      else
      {
        if ( v32 != 15 )
          break;
        v34 = i + 15;
      }
    }
LABEL_69:
    ++a2;
    ++v39;
    ++v41;
    ++v42;
    if ( v39 < a1[80] )
    {
      v8 = v41;
      continue;
    }
    break;
  }
  v2 = a1;
  v3 = v43;
LABEL_71:
  *(_DWORD *)v2[6] = v49;
  *(_DWORD *)(v2[6] + 4) = v50;
  v35 = v47;
  *(_DWORD *)(v3 + 12) = v6;
  v36 = v45;
  *(_DWORD *)(v3 + 16) = v7;
  v37 = v46;
  *(_DWORD *)(v3 + 20) = v36;
  v38 = v48;
  *(_DWORD *)(v3 + 24) = v37;
  *(_DWORD *)(v3 + 28) = v35;
  *(_DWORD *)(v3 + 32) = v38;
LABEL_72:
  --*(_DWORD *)(v3 + 36);
  return 1;
}
// 4B0ABC: using guessed type int dword_4B0ABC[];

//----- (00496B20) --------------------------------------------------------
char __cdecl sub_496B20(_DWORD *a1)
{
  int v1; // edi
  char result; // al
  int v3; // eax
  _DWORD *v4; // ecx

  v1 = a1[102];
  *(_DWORD *)(a1[101] + 20) += *(_DWORD *)(v1 + 16) / 8;
  *(_DWORD *)(v1 + 16) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[101] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[73] > 0 )
    {
      v4 = (_DWORD *)(v1 + 20);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[73] );
    }
    *(_DWORD *)(v1 + 36) = a1[63];
    if ( !a1[95] )
      *(_BYTE *)(v1 + 8) = 0;
    result = 1;
  }
  return result;
}

//----- (00496BF0) --------------------------------------------------------
void __cdecl sub_496BF0(int a1)
{
  int (__cdecl **v1)(int *); // eax

  v1 = (int (__cdecl **)(int *))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 408) = v1;
  *v1 = sub_496C60;
  JUMPOUT(0x496C0C);
}
// 496C06: control flows out of bounds to 496C0C

//----- (00496C60) --------------------------------------------------------
int __cdecl sub_496C60(int *a1)
{
  int v2; // eax
  int v3; // edi
  bool v4; // bl
  char v5; // cl
  int v6; // edx
  int v7; // eax
  int v8; // ebx
  int *v9; // ebp
  int v10; // edi
  int *v11; // ebp
  bool v12; // cc
  int result; // eax
  _DWORD *v14; // ebx
  int *v15; // ebp
  int v16; // eax
  int v17; // eax
  int *v18; // edi
  int v19; // eax
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+10h] [ebp-Ch]
  _DWORD *v22; // [esp+14h] [ebp-8h]
  int v23; // [esp+18h] [ebp-4h]
  bool v24; // [esp+20h] [ebp+4h]

  v2 = a1[91];
  v3 = a1[102];
  v23 = v3;
  v4 = v2 == 0;
  v5 = 0;
  v24 = v2 == 0;
  if ( v2 )
  {
    v6 = a1[92];
    if ( v2 > v6 || v6 >= 64 )
      v5 = 1;
    if ( a1[73] != 1 )
      goto LABEL_8;
  }
  else if ( a1[92] )
  {
LABEL_8:
    v5 = 1;
    goto LABEL_9;
  }
LABEL_9:
  v7 = a1[93];
  if ( v7 && a1[94] != v7 - 1 )
    v5 = 1;
  if ( a1[94] > 13 || v5 )
  {
    *(_DWORD *)(*a1 + 20) = 16;
    *(_DWORD *)(*a1 + 24) = a1[91];
    *(_DWORD *)(*a1 + 28) = a1[92];
    *(_DWORD *)(*a1 + 32) = a1[93];
    *(_DWORD *)(*a1 + 36) = a1[94];
    (*(void (__cdecl **)(int *))*a1)(a1);
  }
  v20 = 0;
  if ( a1[73] > 0 )
  {
    v22 = a1 + 74;
    do
    {
      v8 = *(_DWORD *)(*v22 + 4);
      v9 = (int *)(a1[35] + (v8 << 8));
      if ( !v24 && *v9 < 0 )
      {
        *(_DWORD *)(*a1 + 20) = 115;
        *(_DWORD *)(*a1 + 24) = v8;
        *(_DWORD *)(*a1 + 28) = 0;
        (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
      }
      v10 = a1[91];
      if ( v10 <= a1[92] )
      {
        v11 = &v9[v10];
        do
        {
          if ( a1[93] != (*v11 < 0 ? 0 : *v11) )
          {
            *(_DWORD *)(*a1 + 20) = 115;
            *(_DWORD *)(*a1 + 24) = v8;
            *(_DWORD *)(*a1 + 28) = v10;
            (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
          }
          ++v10;
          *v11++ = a1[94];
        }
        while ( v10 <= a1[92] );
      }
      v12 = ++v20 < a1[73];
      ++v22;
    }
    while ( v12 );
    v3 = v23;
    v4 = v24;
  }
  if ( a1[93] )
  {
    if ( v4 )
      *(_DWORD *)(v3 + 4) = sub_497400;
    else
      *(_DWORD *)(v3 + 4) = sub_497500;
  }
  else if ( v4 )
  {
    *(_DWORD *)(v3 + 4) = sub_496EE0;
  }
  else
  {
    *(_DWORD *)(v3 + 4) = sub_4971A0;
  }
  result = a1[73];
  v21 = 0;
  if ( result > 0 )
  {
    v14 = (_DWORD *)(v3 + 24);
    v15 = a1 + 74;
    do
    {
      v16 = *v15;
      if ( v24 )
      {
        if ( !a1[93] )
          sub_496060(
            (int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1,
            1u,
            *(_DWORD *)(v16 + 20),
            v3 + 4 * *(_DWORD *)(v16 + 20) + 44);
      }
      else
      {
        v17 = *(_DWORD *)(v16 + 24);
        v18 = (int *)(v3 + 4 * v17 + 44);
        sub_496060((int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0, v17, (int)v18);
        v19 = *v18;
        v3 = v23;
        *(_DWORD *)(v23 + 60) = v19;
      }
      *v14 = 0;
      result = v21 + 1;
      ++v15;
      ++v14;
      v21 = result;
    }
    while ( result < a1[73] );
  }
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 40) = a1[63];
  return result;
}

//----- (00496EE0) --------------------------------------------------------
char __cdecl sub_496EE0(_DWORD *a1, _WORD **a2)
{
  int v3; // edx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // esi
  int v13; // edx
  int v14; // esi
  int v15; // [esp+10h] [ebp-3Ch]
  int v16; // [esp+14h] [ebp-38h]
  int v17; // [esp+18h] [ebp-34h]
  int v18; // [esp+1Ch] [ebp-30h]
  _WORD *v19; // [esp+20h] [ebp-2Ch]
  unsigned __int8 *v20; // [esp+24h] [ebp-28h] BYREF
  int v21; // [esp+28h] [ebp-24h]
  int v22; // [esp+2Ch] [ebp-20h]
  int v23; // [esp+30h] [ebp-1Ch]
  _DWORD *v24; // [esp+34h] [ebp-18h]
  int v25[5]; // [esp+38h] [ebp-14h] BYREF
  int *v27; // [esp+54h] [ebp+8h]

  v3 = a1[102];
  v18 = a1[94];
  v15 = v3;
  if ( a1[63] && !*(_DWORD *)(v3 + 40) )
  {
    if ( !sub_497110(a1) )
      return 0;
    v3 = v15;
  }
  if ( !*(_BYTE *)(v3 + 8) )
  {
    v5 = a1[6];
    v24 = a1;
    v16 = 0;
    v20 = *(unsigned __int8 **)v5;
    v21 = *(_DWORD *)(v5 + 4);
    v6 = *(_DWORD *)(v3 + 12);
    v7 = *(_DWORD *)(v3 + 16);
    qmemcpy(v25, (const void *)(v3 + 20), sizeof(v25));
    if ( (int)a1[80] > 0 )
    {
      v27 = a1 + 81;
      while ( 1 )
      {
        v19 = *a2;
        v17 = *v27;
        v8 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(a1[*v27 + 74] + 20) + 44);
        if ( v7 < 8 )
        {
          if ( !sub_496340(&v20, v6, v7, 0) )
            return 0;
          v7 = v23;
          v6 = v22;
          if ( v23 < 8 )
            break;
        }
        v10 = (unsigned __int8)(v6 >> (v7 - 8));
        v11 = *(_DWORD *)(v8 + 4 * v10 + 144);
        if ( !v11 )
        {
          v9 = 9;
          goto LABEL_16;
        }
        v7 -= v11;
        v12 = *(unsigned __int8 *)(v10 + v8 + 1168);
LABEL_18:
        if ( v12 )
        {
          if ( v7 < v12 )
          {
            if ( !sub_496340(&v20, v6, v7, v12) )
              return 0;
            v6 = v22;
            v7 = v23;
          }
          v7 -= v12;
          v13 = (v6 >> v7) & ((1 << v12) - 1);
          if ( v13 >= dword_4B0C7C[v12] )
            v12 = (v6 >> v7) & ((1 << v12) - 1);
          else
            v12 = v13 + dword_4B0CBC[v12];
        }
        v14 = v25[v17 + 1] + v12;
        v25[v17 + 1] = v14;
        ++v16;
        *v19 = v14 << v18;
        ++a2;
        v3 = v15;
        ++v27;
        if ( v16 >= a1[80] )
          goto LABEL_26;
      }
      v9 = 1;
LABEL_16:
      v12 = sub_496460((int)&v20, v6, v7, v8, v9);
      if ( v12 < 0 )
        return 0;
      v6 = v22;
      v7 = v23;
      goto LABEL_18;
    }
LABEL_26:
    *(_DWORD *)a1[6] = v20;
    *(_DWORD *)(a1[6] + 4) = v21;
    *(_DWORD *)(v3 + 12) = v6;
    *(_DWORD *)(v3 + 16) = v7;
    qmemcpy((void *)(v3 + 20), v25, 0x14u);
  }
  --*(_DWORD *)(v3 + 40);
  return 1;
}

//----- (00497110) --------------------------------------------------------
char __cdecl sub_497110(_DWORD *a1)
{
  int v1; // edi
  char result; // al
  int v3; // eax
  _DWORD *v4; // ecx

  v1 = a1[102];
  *(_DWORD *)(a1[101] + 20) += *(_DWORD *)(v1 + 16) / 8;
  *(_DWORD *)(v1 + 16) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[101] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[73] > 0 )
    {
      v4 = (_DWORD *)(v1 + 24);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[73] );
    }
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 40) = a1[63];
    if ( !a1[95] )
      *(_BYTE *)(v1 + 8) = 0;
    result = 1;
  }
  return result;
}

//----- (004971A0) --------------------------------------------------------
char __cdecl sub_4971A0(_DWORD *a1, int *a2)
{
  _DWORD *v2; // esi
  int v3; // ebx
  char result; // al
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // edi
  int v10; // eax
  int v11; // ebp
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // esi
  int v16; // ebx
  int v17; // esi
  int v18; // edx
  int v19; // esi
  int v20; // ebp
  int v21; // [esp+10h] [ebp-28h]
  int v22; // [esp+14h] [ebp-24h]
  int v23; // [esp+18h] [ebp-20h]
  int v24; // [esp+1Ch] [ebp-1Ch]
  int v25; // [esp+20h] [ebp-18h]
  unsigned __int8 *v26; // [esp+24h] [ebp-14h] BYREF
  int v27; // [esp+28h] [ebp-10h]
  int v28; // [esp+2Ch] [ebp-Ch]
  int v29; // [esp+30h] [ebp-8h]
  _DWORD *v30; // [esp+34h] [ebp-4h]
  int v31; // [esp+40h] [ebp+8h]
  int v32; // [esp+40h] [ebp+8h]

  v2 = a1;
  v3 = a1[102];
  v22 = a1[92];
  v23 = v3;
  v24 = a1[94];
  if ( a1[63] )
  {
    if ( !*(_DWORD *)(v3 + 40) )
    {
      result = sub_497110(a1);
      if ( !result )
        return result;
    }
  }
  if ( *(_BYTE *)(v3 + 8) )
    goto LABEL_38;
  v5 = *(_DWORD *)(v3 + 20);
  v21 = v5;
  if ( v5 )
  {
    v6 = *(_DWORD *)(v3 + 40) - 1;
    *(_DWORD *)(v3 + 20) = v5 - 1;
    *(_DWORD *)(v3 + 40) = v6;
    return 1;
  }
  v7 = a1[6];
  v30 = a1;
  v26 = *(unsigned __int8 **)v7;
  v8 = *a2;
  v27 = *(_DWORD *)(v7 + 4);
  v9 = *(_DWORD *)(v3 + 12);
  v10 = *(_DWORD *)(v3 + 16);
  v11 = *(_DWORD *)(v3 + 60);
  v25 = v8;
  v31 = a1[91];
  if ( v31 > v22 )
    goto LABEL_37;
  while ( 1 )
  {
    if ( v10 >= 8 )
      goto LABEL_12;
    if ( !sub_496340(&v26, v9, v10, 0) )
      return 0;
    v10 = v29;
    v9 = v28;
    if ( v29 >= 8 )
    {
LABEL_12:
      v13 = (unsigned __int8)(v9 >> (v10 - 8));
      v14 = *(_DWORD *)(v11 + 4 * v13 + 144);
      if ( v14 )
      {
        v10 -= v14;
        v15 = *(unsigned __int8 *)(v13 + v11 + 1168);
        goto LABEL_17;
      }
      v12 = 9;
    }
    else
    {
      v12 = 1;
    }
    v15 = sub_496460((int)&v26, v9, v10, v11, v12);
    if ( v15 < 0 )
      return 0;
    v9 = v28;
    v10 = v29;
LABEL_17:
    v16 = v15 >> 4;
    v17 = v15 & 0xF;
    if ( v17 )
    {
      v32 = v16 + v31;
      if ( v10 < v17 )
      {
        if ( !sub_496340(&v26, v9, v10, v17) )
          return 0;
        v9 = v28;
        v10 = v29;
      }
      v10 -= v17;
      v18 = (v9 >> v10) & ((1 << v17) - 1);
      if ( v18 >= dword_4B0C7C[v17] )
        v19 = (v9 >> v10) & ((1 << v17) - 1);
      else
        v19 = v18 + dword_4B0CBC[v17];
      *(_WORD *)(v25 + 2 * dword_4B0ABC[v32]) = v19 << v24;
      goto LABEL_27;
    }
    if ( v16 != 15 )
      break;
    v32 = v31 + 15;
LABEL_27:
    v31 = v32 + 1;
    if ( v31 > v22 )
      goto LABEL_36;
  }
  v20 = 1 << v16;
  if ( v16 )
  {
    if ( v10 < v16 )
    {
      if ( !sub_496340(&v26, v9, v10, v16) )
        return 0;
      v9 = v28;
      v10 = v29;
    }
    v10 -= v16;
    v20 += ((1 << v16) - 1) & (v9 >> v10);
  }
  v21 = v20 - 1;
LABEL_36:
  v5 = v21;
  v3 = v23;
  v2 = a1;
LABEL_37:
  *(_DWORD *)v2[6] = v26;
  *(_DWORD *)(v2[6] + 4) = v27;
  *(_DWORD *)(v3 + 12) = v9;
  *(_DWORD *)(v3 + 16) = v10;
  *(_DWORD *)(v3 + 20) = v5;
LABEL_38:
  --*(_DWORD *)(v3 + 40);
  return 1;
}
// 4B0ABC: using guessed type int dword_4B0ABC[];

//----- (00497400) --------------------------------------------------------
char __cdecl sub_497400(_DWORD *a1, _WORD **a2)
{
  _DWORD *v3; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int i; // ecx
  _WORD *v9; // ebp
  int v10; // eax
  int v11; // [esp+10h] [ebp-18h]
  unsigned __int8 *v12; // [esp+14h] [ebp-14h] BYREF
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  _DWORD *v16; // [esp+24h] [ebp-4h]

  v3 = (_DWORD *)a1[102];
  v11 = 1 << a1[94];
  if ( a1[63] && !v3[10] && !sub_497110(a1) )
    return 0;
  v5 = a1[6];
  v16 = a1;
  v6 = 0;
  v12 = *(unsigned __int8 **)v5;
  v13 = *(_DWORD *)(v5 + 4);
  v7 = v3[3];
  for ( i = v3[4]; v6 < a1[80]; ++a2 )
  {
    v9 = *a2;
    if ( i < 1 )
    {
      if ( !sub_496340(&v12, v7, i, 1) )
        return 0;
      v7 = v14;
      i = v15;
    }
    if ( ((v7 >> --i) & 1) != 0 )
      *v9 |= v11;
    ++v6;
  }
  *(_DWORD *)a1[6] = v12;
  *(_DWORD *)(a1[6] + 4) = v13;
  v3[3] = v7;
  v10 = v3[10];
  v3[4] = i;
  v3[10] = v10 - 1;
  return 1;
}

//----- (00497500) --------------------------------------------------------
char __cdecl sub_497500(_DWORD *a1, int *a2)
{
  _DWORD *v2; // ebp
  int v3; // ecx
  int v4; // edi
  char result; // al
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // edx
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ebp
  int v15; // ecx
  int v16; // ebp
  int v17; // edx
  __int16 *v18; // edi
  __int16 v19; // ax
  __int16 v20; // ax
  bool v21; // cc
  int v22; // eax
  int v23; // edi
  int v24; // ecx
  int v25; // edi
  __int16 *v26; // edi
  __int16 v27; // ax
  __int16 v28; // cx
  int v29; // ecx
  _DWORD *v30; // eax
  int v31; // edx
  _DWORD *v32; // [esp+10h] [ebp-144h]
  _DWORD *v33; // [esp+10h] [ebp-144h]
  int v34; // [esp+14h] [ebp-140h]
  int v35; // [esp+18h] [ebp-13Ch]
  int v36; // [esp+1Ch] [ebp-138h]
  int v37; // [esp+20h] [ebp-134h]
  int v38; // [esp+24h] [ebp-130h]
  int v39; // [esp+28h] [ebp-12Ch]
  unsigned __int8 *v40; // [esp+2Ch] [ebp-128h] BYREF
  int v41; // [esp+30h] [ebp-124h]
  int v42; // [esp+34h] [ebp-120h]
  int v43; // [esp+38h] [ebp-11Ch]
  _DWORD *v44; // [esp+3Ch] [ebp-118h]
  int v45; // [esp+40h] [ebp-114h]
  int v46; // [esp+44h] [ebp-110h]
  int v47; // [esp+48h] [ebp-10Ch]
  int *v48; // [esp+4Ch] [ebp-108h]
  int v49; // [esp+50h] [ebp-104h]
  _DWORD v50[64]; // [esp+54h] [ebp-100h] BYREF

  v2 = a1;
  v3 = a1[94];
  v37 = a1[92];
  v4 = a1[102];
  v38 = v4;
  v45 = 1 << v3;
  v46 = -1 << v3;
  if ( a1[63] )
  {
    if ( !*(_DWORD *)(v4 + 40) )
    {
      result = sub_497110(a1);
      if ( !result )
        return result;
    }
  }
  if ( *(_BYTE *)(v4 + 8) )
  {
LABEL_68:
    --*(_DWORD *)(v4 + 40);
    return 1;
  }
  v6 = a1[6];
  v44 = a1;
  v47 = 0;
  v40 = *(unsigned __int8 **)v6;
  v41 = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(v4 + 20);
  v8 = *(_DWORD *)(v4 + 12);
  v9 = *a2;
  v10 = *(_DWORD *)(v4 + 16);
  v49 = *(_DWORD *)(v4 + 60);
  v35 = v7;
  v39 = v9;
  v34 = a1[91];
  if ( v7 )
  {
LABEL_52:
    if ( v35 )
    {
      if ( v34 <= v37 )
      {
        v33 = (_DWORD *)(4 * v34 + 4917948);
        do
        {
          v26 = (__int16 *)(v39 + 2 * *v33);
          if ( *v26 )
          {
            if ( v10 < 1 )
            {
              if ( !sub_496340(&v40, v8, v10, 1) )
                goto LABEL_69;
              v8 = v42;
              v10 = v43;
            }
            if ( ((v8 >> --v10) & 1) != 0 )
            {
              v27 = *v26;
              v28 = v45;
              if ( (*v26 & v45) == 0 )
              {
                if ( v27 < 0 )
                  v28 = v46;
                *v26 = v28 + v27;
              }
            }
          }
          v21 = ++v34 <= v37;
          ++v33;
        }
        while ( v21 );
        v4 = v38;
      }
      --v35;
    }
    goto LABEL_67;
  }
  if ( a1[91] > v37 )
  {
LABEL_67:
    *(_DWORD *)v2[6] = v40;
    *(_DWORD *)(v2[6] + 4) = v41;
    *(_DWORD *)(v4 + 12) = v8;
    *(_DWORD *)(v4 + 16) = v10;
    *(_DWORD *)(v4 + 20) = v35;
    goto LABEL_68;
  }
  v48 = v50;
  while ( 1 )
  {
    if ( v10 >= 8 )
      goto LABEL_12;
    if ( !sub_496340(&v40, v8, v10, 0) )
      goto LABEL_69;
    v10 = v43;
    v8 = v42;
    if ( v43 >= 8 )
    {
LABEL_12:
      v12 = (unsigned __int8)(v8 >> (v10 - 8));
      v13 = *(_DWORD *)(v49 + 4 * v12 + 144);
      if ( v13 )
      {
        v10 -= v13;
        v14 = *(unsigned __int8 *)(v12 + v49 + 1168);
        goto LABEL_17;
      }
      v11 = 9;
    }
    else
    {
      v11 = 1;
    }
    v14 = sub_496460((int)&v40, v8, v10, v49, v11);
    if ( v14 < 0 )
      goto LABEL_69;
    v8 = v42;
    v10 = v43;
LABEL_17:
    v15 = v14 >> 4;
    v16 = v14 & 0xF;
    v36 = v15;
    if ( !v16 )
      break;
    if ( v16 != 1 )
    {
      *(_DWORD *)(*a1 + 20) = 118;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    }
    if ( v10 < 1 )
    {
      if ( !sub_496340(&v40, v8, v10, 1) )
        goto LABEL_69;
      v8 = v42;
      v10 = v43;
    }
    --v10;
    v17 = v34;
    if ( ((v8 >> v10) & 1) != 0 )
      v16 = v45;
    else
      v16 = v46;
    v15 = v36;
    v32 = (_DWORD *)(4 * v34 + 4917948);
LABEL_30:
    while ( 1 )
    {
      v18 = (__int16 *)(v39 + 2 * *v32);
      if ( *v18 )
      {
        if ( v10 < 1 )
        {
          if ( !sub_496340(&v40, v8, v10, 1) )
            goto LABEL_69;
          v8 = v42;
          v10 = v43;
        }
        if ( ((v8 >> --v10) & 1) != 0 )
        {
          v19 = *v18;
          if ( (*v18 & v45) == 0 )
          {
            if ( v19 < 0 )
              v20 = v46 + v19;
            else
              v20 = v45 + v19;
            *v18 = v20;
          }
        }
      }
      else
      {
        v36 = v15 - 1;
        if ( v15 - 1 < 0 )
          break;
      }
      v17 = v34 + 1;
      v21 = ++v34 <= v37;
      ++v32;
      if ( !v21 )
        break;
      v15 = v36;
    }
    if ( v16 )
    {
      v22 = dword_4B0ABC[v17];
      v23 = v47;
      *(_WORD *)(v39 + 2 * v22) = v16;
      v24 = (int)v48;
      *v48 = v22;
      v47 = v23 + 1;
      v48 = (int *)(v24 + 4);
    }
    v34 = v17 + 1;
    if ( v17 + 1 > v37 )
    {
      v2 = a1;
      v4 = v38;
      goto LABEL_67;
    }
  }
  if ( v15 == 15 )
  {
    v17 = v34;
    v32 = (_DWORD *)(4 * v34 + 4917948);
    goto LABEL_30;
  }
  v25 = 1 << v15;
  v35 = 1 << v15;
  if ( !v15 )
    goto LABEL_51;
  if ( v10 >= v15 )
    goto LABEL_50;
  if ( sub_496340(&v40, v8, v10, v15) )
  {
    v8 = v42;
    v10 = v43;
LABEL_50:
    v10 -= v36;
    v35 += (v25 - 1) & (v8 >> v10);
LABEL_51:
    v2 = a1;
    v4 = v38;
    goto LABEL_52;
  }
LABEL_69:
  v29 = v47;
  if ( v47 > 0 )
  {
    v30 = &v50[v47];
    do
    {
      v31 = *--v30;
      --v29;
      *(_WORD *)(v39 + 2 * v31) = 0;
    }
    while ( v29 );
  }
  return 0;
}
// 4B0ABC: using guessed type int dword_4B0ABC[];

//----- (00497950) --------------------------------------------------------
int (__cdecl **__cdecl sub_497950(int a1))(int *a1)
{
  int (__cdecl **result)(int *); // eax
  int v3; // ebx
  _DWORD *v4; // ebp
  void *v5; // eax
  _DWORD *v6; // [esp+Ch] [ebp+4h]

  result = (int (__cdecl **)(int *))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  *(_DWORD *)(a1 + 412) = result;
  *result = sub_4979D0;
  v3 = 0;
  if ( *(int *)(a1 + 36) > 0 )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 80);
    v4 = result + 11;
    do
    {
      v5 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
      *v6 = v5;
      memset(v5, 0, 0x100u);
      *v4 = -1;
      result = *(int (__cdecl ***)(int *))(a1 + 36);
      ++v3;
      ++v4;
      v6 += 21;
    }
    while ( v3 < (int)result );
  }
  return result;
}

//----- (004979D0) --------------------------------------------------------
int __cdecl sub_4979D0(int *a1)
{
  int *v1; // edi
  int v2; // ebx
  int result; // eax
  int v4; // esi
  int *v5; // ebp
  int v6; // eax
  int v7; // eax
  char *v8; // edx
  int v9; // edi
  char *v10; // ebx
  double *v11; // esi
  int v12; // edx
  unsigned __int16 *v13; // ecx
  double *v14; // eax
  unsigned __int16 v15; // bp
  int v16; // ecx
  __int16 *v17; // eax
  int v18; // edx
  int v19; // ebp
  unsigned __int16 v20; // bx
  int v21; // ecx
  char *v22; // eax
  int v23; // edx
  unsigned __int16 v24; // bp
  bool v25; // cc
  int v26; // [esp+Ch] [ebp-18h]
  void *v27; // [esp+10h] [ebp-14h]
  int v28; // [esp+14h] [ebp-10h]
  int v29; // [esp+18h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-8h]

  v1 = a1;
  v2 = 0;
  result = a1[103];
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if ( a1[9] > 0 )
  {
    v4 = a1[49] + 36;
    v5 = (int *)(result + 44);
    v30 = v4;
    v29 = result + 44;
    do
    {
      switch ( *(_DWORD *)v4 )
      {
        case 1:
          v2 = 0;
          v27 = sub_4A14D0;
          v26 = 0;
          break;
        case 2:
          v2 = 0;
          v27 = sub_4A12A0;
          v26 = 0;
          break;
        case 4:
          v2 = 0;
          v27 = sub_4A0EF0;
          v26 = 0;
          break;
        case 8:
          v6 = v1[17];
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                v2 = 2;
                v27 = sub_4A0AB0;
                v26 = 2;
              }
              else
              {
                *(_DWORD *)(*v1 + 20) = 48;
                (*(void (__cdecl **)(int *))*v1)(v1);
              }
            }
            else
            {
              v2 = 1;
              v27 = sub_4A05F0;
              v26 = 1;
            }
          }
          else
          {
            v2 = 0;
            v27 = sub_4A0000;
            v26 = 0;
          }
          break;
        default:
          *(_DWORD *)(*v1 + 20) = 7;
          *(_DWORD *)(*v1 + 24) = *(_DWORD *)v4;
          (*(void (__cdecl **)(int *))*v1)(v1);
          break;
      }
      *(v5 - 10) = (int)v27;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( *v5 != v2 )
        {
          v8 = *(char **)(v4 + 40);
          if ( v8 )
          {
            *v5 = v2;
            if ( v2 )
            {
              if ( v2 == 1 )
              {
                v16 = *(_DWORD *)(v4 + 44);
                v17 = (__int16 *)&unk_4B0D00;
                v18 = v8 - (char *)&unk_4B0D00;
                do
                {
                  v19 = *v17;
                  v16 += 4;
                  v20 = *(__int16 *)((char *)v17++ + v18);
                  *(_DWORD *)(v16 - 4) = (v19 * v20 + 2048) >> 12;
                }
                while ( (int)v17 < (int)&unk_4B0D80 );
                v2 = v26;
              }
              else
              {
                v9 = *(_DWORD *)(v4 + 44);
                v10 = v8;
                v11 = (double *)&unk_4B0D80;
                do
                {
                  v12 = v9;
                  v13 = (unsigned __int16 *)v10;
                  v9 += 32;
                  v14 = (double *)&unk_4B0D80;
                  v10 += 16;
                  do
                  {
                    ++v14;
                    v15 = *v13++;
                    v12 += 4;
                    *(float *)(v12 - 4) = (double)v15 * *(v14 - 1) * *v11;
                  }
                  while ( (int)v14 < (int)&unk_4B0DC0 );
                  ++v11;
                }
                while ( (int)v11 < (int)&unk_4B0DC0 );
                v2 = v26;
                v1 = a1;
                v4 = v30;
              }
            }
            else
            {
              v21 = *(_DWORD *)(v4 + 44);
              v22 = v8;
              v23 = 64;
              do
              {
                v21 += 4;
                v24 = *(_WORD *)v22;
                v22 += 2;
                *(_DWORD *)(v21 - 4) = v24;
                --v23;
              }
              while ( v23 );
            }
          }
        }
      }
      result = v28 + 1;
      v5 = (int *)(v29 + 4);
      v4 += 84;
      v25 = ++v28 < v1[9];
      v29 += 4;
      v30 = v4;
    }
    while ( v25 );
  }
  return result;
}
// 497AF8: conditional instruction was optimized away because of 'ebx.4==2'

//----- (00497C10) --------------------------------------------------------
char __cdecl sub_497C10(int a1, char a2)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v8; // [esp-8h] [ebp-10h]

  v2 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 396) = v2;
  *v2 = sub_497CA0;
  v2[2] = 0;
  v2[3] = 0;
  LOBYTE(v3) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v3 )
  {
    v4 = *(_DWORD *)(a1 + 276);
    v2[4] = v4;
    if ( a2 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      v8 = v4;
      v6 = sub_493ED0(*(_DWORD *)(a1 + 96), v4);
      v3 = (*(int (__cdecl **)(int, int, _DWORD, int, int, int))(v5 + 16))(
             a1,
             1,
             0,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v6,
             v8);
      v2[2] = v3;
    }
    else
    {
      v3 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
             a1,
             1,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v4);
      v2[3] = v3;
    }
  }
  return v3;
}
// 497CA0: using guessed type int sub_497CA0();

//----- (00497DA0) --------------------------------------------------------
int __cdecl sub_497DA0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebx
  int v8; // esi
  int v9; // edi
  unsigned int v10; // eax
  int v11; // ecx
  int result; // eax

  v7 = a6;
  v8 = a1;
  v9 = *(_DWORD *)(a1 + 396);
  v10 = a7 - *a6;
  if ( v10 > *(_DWORD *)(v9 + 16) )
    v10 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD *)(a1 + 416);
  a1 = 0;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, int *, unsigned int))(v11 + 4))(
    v8,
    a2,
    a3,
    a4,
    *(_DWORD *)(v9 + 12),
    &a1,
    v10);
  (*(void (__cdecl **)(int, _DWORD, int, int))(*(_DWORD *)(v8 + 424) + 4))(v8, *(_DWORD *)(v9 + 12), a5 + 4 * *v7, a1);
  result = a1 + *v7;
  *v7 = result;
  return result;
}

//----- (00497E20) --------------------------------------------------------
unsigned int __cdecl sub_497E20(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  _DWORD *v7; // esi
  unsigned int *v8; // ebx
  unsigned int v9; // ebp
  unsigned int v10; // eax
  unsigned int result; // eax
  int v12; // ecx
  unsigned int v13; // [esp+10h] [ebp+4h]

  v7 = (_DWORD *)a1[99];
  v8 = v7 + 6;
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, int))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 1);
  v9 = *v8;
  (*(void (__cdecl **)(_DWORD *, int, int, int, _DWORD, _DWORD *, _DWORD))(a1[104] + 4))(
    a1,
    a2,
    a3,
    a4,
    v7[3],
    v7 + 6,
    v7[4]);
  v10 = *v8;
  if ( *v8 > v9 )
  {
    v13 = v10 - v9;
    (*(void (__cdecl **)(_DWORD *, unsigned int, _DWORD, unsigned int))(a1[106] + 4))(a1, v7[3] + 4 * v9, 0, v10 - v9);
    *a6 += v13;
  }
  result = v7[4];
  if ( *v8 >= result )
  {
    v12 = v7[5];
    *v8 = 0;
    v7[5] = result + v12;
  }
  return result;
}

//----- (00497ED0) --------------------------------------------------------
unsigned int __cdecl sub_497ED0(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // esi
  unsigned int v8; // edi
  int v9; // edx
  unsigned int result; // eax
  unsigned int v11; // ecx
  int v12; // ecx

  v7 = (_DWORD *)a1[99];
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, _DWORD))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 0);
  v8 = v7[4] - v7[6];
  if ( v8 > a7 - *a6 )
    v8 = a7 - *a6;
  v9 = v7[5];
  if ( v8 > a1[24] - v9 )
    v8 = a1[24] - v9;
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int))(a1[106] + 4))(a1, v7[3] + 4 * v7[6], a5 + 4 * *a6, v8);
  *a6 += v8;
  result = v7[4];
  v11 = v8 + v7[6];
  v7[6] = v11;
  if ( v11 >= result )
  {
    v12 = v7[5];
    v7[6] = 0;
    v7[5] = result + v12;
  }
  return result;
}

//----- (00497F80) --------------------------------------------------------
int __cdecl sub_497F80(int a1)
{
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  char v16; // [esp+24h] [ebp+4h]

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  *(_DWORD *)(a1 + 416) = v2;
  v13 = v2;
  *(_DWORD *)v2 = sub_498180;
  *(_DWORD *)(v2 + 4) = sub_4981A0;
  *(_BYTE *)(v2 + 8) = 0;
  if ( *(_BYTE *)(a1 + 266) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_BYTE *)(a1 + 72) || (v16 = 1, *(int *)(a1 + 280) <= 1) )
    v16 = 0;
  result = *(_DWORD *)(a1 + 36);
  v14 = 0;
  if ( result > 0 )
  {
    v4 = *(_DWORD *)(a1 + 196) + 36;
    v5 = (_DWORD *)(v2 + 52);
    do
    {
      v6 = *(_DWORD *)(a1 + 280);
      v15 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 28) / v6;
      v7 = *(_DWORD *)(a1 + 276);
      v8 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 24) / v6;
      v9 = *(_DWORD *)(a1 + 272);
      v5[12] = v8;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( v15 != v9 || v8 != v7 )
        {
          if ( 2 * v15 == v9 )
          {
            if ( v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
                *v5 = sub_4984D0;
              else
                *v5 = sub_4983E0;
LABEL_29:
              v10 = *(_DWORD *)(a1 + 4);
              v12 = *(_DWORD *)(a1 + 276);
              v11 = sub_493ED0(*(_DWORD *)(a1 + 92), *(_DWORD *)(a1 + 272));
              *(v5 - 10) = (*(int (__cdecl **)(int, int, int, int))(v10 + 8))(a1, 1, v11, v12);
              goto LABEL_30;
            }
            if ( 2 * v15 == v9 && 2 * v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
              {
                *v5 = sub_4985A0;
                *(_BYTE *)(v13 + 8) = 1;
              }
              else
              {
                *v5 = sub_498440;
              }
              goto LABEL_29;
            }
          }
          if ( v9 % v15 || v7 % v8 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 38;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            *v5 = sub_4982C0;
            *(_BYTE *)(v14 + v13 + 140) = v9 / v15;
            *(_BYTE *)(v14 + v13 + 150) = v7 / v8;
          }
          goto LABEL_29;
        }
        *v5 = sub_4982A0;
      }
      else
      {
        *v5 = sub_4982B0;
      }
LABEL_30:
      result = v14 + 1;
      ++v5;
      v4 += 84;
      ++v14;
    }
    while ( v14 < *(_DWORD *)(a1 + 36) );
  }
  return result;
}
// 498440: using guessed type int sub_498440();

//----- (00498180) --------------------------------------------------------
int __cdecl sub_498180(_DWORD *a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1[104];
  *(_DWORD *)(v1 + 92) = a1[69];
  result = a1[24];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

//----- (004981A0) --------------------------------------------------------
_DWORD *__cdecl sub_4981A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v8; // ebx
  int v9; // eax
  int v11; // esi
  bool v12; // cc
  unsigned int v13; // esi
  signed int v14; // ecx
  _DWORD *result; // eax
  int v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+18h] [ebp+4h]

  v8 = a1[104];
  if ( *(_DWORD *)(v8 + 92) >= a1[69] )
  {
    v9 = a1[9];
    v16 = 0;
    v17 = a1[49];
    if ( v9 > 0 )
    {
      v11 = v8 + 12;
      do
      {
        (*(void (__cdecl **)(_DWORD *, int, int, int))(v11 + 40))(a1, v17, *a2 + 4 * *a3 * *(_DWORD *)(v11 + 88), v11);
        v11 += 4;
        ++a2;
        v12 = ++v16 < a1[9];
        v17 += 84;
      }
      while ( v12 );
    }
    *(_DWORD *)(v8 + 92) = 0;
  }
  v13 = a1[69] - *(_DWORD *)(v8 + 92);
  if ( v13 > *(_DWORD *)(v8 + 96) )
    v13 = *(_DWORD *)(v8 + 96);
  if ( v13 > a7 - *a6 )
    v13 = a7 - *a6;
  (*(void (__cdecl **)(_DWORD *, int, _DWORD, int, unsigned int))(a1[105] + 4))(
    a1,
    v8 + 12,
    *(_DWORD *)(v8 + 92),
    a5 + 4 * *a6,
    v13);
  *a6 += v13;
  v14 = v13 + *(_DWORD *)(v8 + 92);
  *(_DWORD *)(v8 + 96) -= v13;
  *(_DWORD *)(v8 + 92) = v14;
  result = (_DWORD *)a1[69];
  if ( v14 >= (int)result )
  {
    result = a3;
    ++*a3;
  }
  return result;
}

//----- (004982A0) --------------------------------------------------------
_DWORD *__cdecl sub_4982A0(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax

  result = a4;
  *a4 = a3;
  return result;
}

//----- (004982B0) --------------------------------------------------------
_DWORD *__cdecl sub_4982B0(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax

  result = a4;
  *a4 = 0;
  return result;
}

//----- (004982C0) --------------------------------------------------------
int __cdecl sub_4982C0(int a1, int a2, char **a3, int *a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // edi
  int v7; // edx
  int result; // eax
  char *v9; // esi
  char *v10; // ecx
  unsigned int v11; // ebp
  char v12; // al
  int v13; // eax
  void **v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+10h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-8h]
  int v17; // [esp+18h] [ebp-4h]
  int v18; // [esp+24h] [ebp+8h]

  v4 = a1;
  v5 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a1 + 416);
  v17 = *a4;
  v6 = *(unsigned __int8 *)(v5 + 140);
  v7 = *(unsigned __int8 *)(v5 + 150);
  result = 0;
  v16 = v6;
  v15 = v7;
  v18 = 0;
  if ( *(int *)(a1 + 276) > 0 )
  {
    v14 = (void **)*a4;
    do
    {
      v9 = (char *)*v14;
      v10 = *a3;
      v11 = (unsigned int)*v14 + *(_DWORD *)(v4 + 92);
      if ( (unsigned int)*v14 < v11 )
      {
        do
        {
          v12 = *v10++;
          if ( v6 > 0 )
          {
            LOBYTE(v4) = v12;
            BYTE1(v4) = v12;
            v13 = v4 << 16;
            LOWORD(v13) = v4;
            v4 = a1;
            memset32(v9, v13, (unsigned int)v6 >> 2);
            v7 = v15;
            memset(&v9[4 * ((unsigned int)v6 >> 2)], v13, v6 & 3);
            v6 = v16;
            v9 += v16;
          }
        }
        while ( (unsigned int)v9 < v11 );
        result = v18;
      }
      if ( v7 > 1 )
      {
        sub_493EF0(v17, result, v17, result + 1, v7 - 1, *(_DWORD *)(v4 + 92));
        v7 = v15;
        result = v18;
      }
      result += v7;
      ++a3;
      v18 = result;
      v14 += v7;
    }
    while ( result < *(_DWORD *)(v4 + 276) );
  }
  return result;
}

//----- (004983E0) --------------------------------------------------------
int __cdecl sub_4983E0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v4; // edi
  int result; // eax
  int v6; // ebp
  _BYTE *v7; // eax
  char *v8; // esi
  unsigned int v9; // ecx
  char v10; // dl
  _BYTE *v11; // eax
  int v12; // [esp+18h] [ebp+10h]

  v4 = *a4;
  v12 = 0;
  result = *(_DWORD *)(a1 + 276);
  if ( result > 0 )
  {
    v6 = a3 - (_DWORD)v4;
    do
    {
      v7 = *v4;
      v8 = *(_BYTE **)((char *)v4 + v6);
      v9 = (unsigned int)&(*v4)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v4 < v9 )
      {
        do
        {
          v10 = *v8++;
          *v7 = v10;
          v11 = v7 + 1;
          *v11 = v10;
          v7 = v11 + 1;
        }
        while ( (unsigned int)v7 < v9 );
      }
      result = v12 + 1;
      ++v4;
      ++v12;
    }
    while ( v12 < *(_DWORD *)(a1 + 276) );
  }
  return result;
}

//----- (004984D0) --------------------------------------------------------
int __cdecl sub_4984D0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v5; // edi
  int result; // eax
  int v7; // esi
  unsigned __int8 *v8; // ecx
  _BYTE *v9; // eax
  int v10; // edx
  unsigned __int8 *v11; // ecx
  _BYTE *v12; // eax
  int v13; // ebp
  int v14; // edx
  _BYTE *v15; // eax
  int v16; // edx
  int v17; // [esp+10h] [ebp+Ch]
  int v18; // [esp+14h] [ebp+10h]

  v18 = 0;
  v5 = *a4;
  result = *(_DWORD *)(a1 + 276);
  if ( result > 0 )
  {
    v7 = a3 - (_DWORD)v5;
    v17 = a3 - (_DWORD)v5;
    do
    {
      v8 = *(_BYTE **)((char *)v5 + v7);
      v9 = *v5;
      v10 = *v8;
      v11 = v8 + 1;
      *v9++ = v10;
      *v9 = (3 * v10 + *v11 + 2) >> 2;
      v12 = v9 + 1;
      if ( *(_DWORD *)(a2 + 40) != 2 )
      {
        v13 = *(_DWORD *)(a2 + 40) - 2;
        do
        {
          v14 = *v11++;
          *v12 = (*(v11 - 2) + 3 * v14 + 1) >> 2;
          v15 = v12 + 1;
          *v15 = (*v11 + 3 * v14 + 2) >> 2;
          v12 = v15 + 1;
          --v13;
        }
        while ( v13 );
        v7 = v17;
      }
      v16 = *v11;
      ++v5;
      *v12 = (*(v11 - 1) + 3 * v16 + 1) >> 2;
      v12[1] = v16;
      result = v18 + 1;
      v18 = result;
    }
    while ( result < *(_DWORD *)(a1 + 276) );
  }
  return result;
}

//----- (004985A0) --------------------------------------------------------
int __cdecl sub_4985A0(int a1, int a2, int a3, int *a4)
{
  int v4; // esi
  int result; // eax
  int v6; // edi
  int v7; // ecx
  _BYTE **i; // eax
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // edi
  _BYTE *v11; // ecx
  int v12; // esi
  unsigned __int8 *v13; // edi
  int v14; // eax
  unsigned __int8 *v15; // edi
  unsigned __int8 *v16; // ebp
  _BYTE *v17; // ecx
  int v18; // edx
  int v19; // esi
  _BYTE *v20; // ecx
  int v21; // [esp+4h] [ebp-14h]
  int v22; // [esp+8h] [ebp-10h]
  int v23; // [esp+Ch] [ebp-Ch]
  int v24; // [esp+10h] [ebp-8h]
  _BYTE **v25; // [esp+14h] [ebp-4h]
  int v26; // [esp+28h] [ebp+10h]

  v4 = 0;
  result = 0;
  v24 = *a4;
  v21 = 0;
  v26 = 0;
  if ( *(int *)(a1 + 276) > 0 )
  {
    v6 = a3;
    do
    {
      v7 = 0;
      v23 = 0;
      for ( i = (_BYTE **)(v24 + 4 * result); ; i = v25 )
      {
        v9 = *(unsigned __int8 **)(v6 + 4 * v4);
        v10 = (unsigned __int8 *)(v7 ? *(_DWORD *)(v6 + 4 * v4 + 4) : *(_DWORD *)(v6 + 4 * v4 - 4));
        v11 = *i;
        v25 = i + 1;
        ++v21;
        v12 = *v10 + 3 * *v9;
        v13 = v10 + 1;
        v14 = *v13 + 3 * v9[1];
        *v11 = (4 * v12 + 8) >> 4;
        v15 = v13 + 1;
        v16 = v9 + 2;
        *++v11 = (v12 + v14 + 2 * v12 + 7) >> 4;
        v17 = v11 + 1;
        v18 = v12;
        v19 = v14;
        if ( *(_DWORD *)(a2 + 40) == 2 )
        {
          v4 = v26;
          v6 = a3;
        }
        else
        {
          v22 = *(_DWORD *)(a2 + 40) - 2;
          do
          {
            v14 = *v15++ + 3 * *v16++;
            *v17 = (3 * v19 + v18 + 8) >> 4;
            v20 = v17 + 1;
            *v20 = (3 * v19 + v14 + 7) >> 4;
            v17 = v20 + 1;
            v18 = v19;
            v19 = v14;
            --v22;
          }
          while ( v22 );
          v6 = a3;
          v4 = v26;
        }
        *v17 = (v14 + v18 + 2 * v14 + 8) >> 4;
        v17[1] = (4 * v14 + 7) >> 4;
        v7 = ++v23;
        if ( v23 >= 2 )
          break;
      }
      result = v21;
      v26 = ++v4;
    }
    while ( v21 < *(_DWORD *)(a1 + 276) );
  }
  return result;
}

//----- (00498700) --------------------------------------------------------
char __cdecl sub_498700(int a1)
{
  _DWORD *v1; // edi
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 420) = v1;
  *v1 = nullsub_14;
  switch ( *(_DWORD *)(a1 + 40) )
  {
    case 1:
      if ( *(_DWORD *)(a1 + 36) != 1 )
        goto LABEL_9;
      break;
    case 2:
    case 3:
      if ( *(_DWORD *)(a1 + 36) != 3 )
        goto LABEL_9;
      break;
    case 4:
    case 5:
      if ( *(_DWORD *)(a1 + 36) != 4 )
        goto LABEL_9;
      break;
    default:
      if ( *(int *)(a1 + 36) < 1 )
      {
LABEL_9:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      break;
  }
  if ( *(_DWORD *)(a1 + 44) != 1 )
  {
    if ( *(_DWORD *)(a1 + 44) == 2 )
    {
      v3 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 100) = 3;
      switch ( v3 )
      {
        case 3:
          v1[1] = sub_498990;
          sub_4988D0(a1);
          goto LABEL_33;
        case 1:
          v1[1] = sub_498B80;
          goto LABEL_33;
        case 2:
          v1[1] = sub_498AC0;
          goto LABEL_33;
      }
    }
    else if ( *(_DWORD *)(a1 + 44) == 4 )
    {
      v2 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 100) = 4;
      if ( v2 == 5 )
      {
        v1[1] = sub_498BF0;
        sub_4988D0(a1);
        goto LABEL_33;
      }
      if ( v2 == 4 )
      {
        v1[1] = sub_498AC0;
        goto LABEL_33;
      }
    }
    else if ( *(_DWORD *)(a1 + 44) == *(_DWORD *)(a1 + 40) )
    {
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 36);
      v1[1] = sub_498AC0;
      goto LABEL_33;
    }
    goto LABEL_29;
  }
  v4 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 100) = 1;
  if ( v4 != 1 && v4 != 3 )
  {
LABEL_29:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
    (**(void (__cdecl ***)(int))a1)(a1);
    goto LABEL_33;
  }
  v1[1] = sub_498B50;
  v5 = 1;
  if ( *(int *)(a1 + 36) > 1 )
  {
    v6 = 84;
    do
    {
      ++v5;
      *(_BYTE *)(*(_DWORD *)(a1 + 196) + v6 + 48) = 0;
      v6 += 84;
    }
    while ( v5 < *(_DWORD *)(a1 + 36) );
  }
LABEL_33:
  LOBYTE(v7) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v7 )
  {
    *(_DWORD *)(a1 + 104) = 1;
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 104) = v7;
  }
  return v7;
}
// 498D60: using guessed type int nullsub_14();

//----- (004988D0) --------------------------------------------------------
int __cdecl sub_4988D0(int a1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // edi
  int v4; // edx
  int i; // ecx
  int v6; // [esp+14h] [ebp+4h]

  v1 = *(_DWORD **)(a1 + 420);
  v1[2] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[3] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v6 = 5990656;
  v3 = -14831872;
  v4 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    *(_DWORD *)(result + v1[2]) = v4 >> 16;
    v4 += 91881;
    *(_DWORD *)(result + v1[3]) = v3 >> 16;
    v3 += 116130;
    *(_DWORD *)(result + v1[4]) = v6;
    *(_DWORD *)(result + v1[5]) = i;
    result += 4;
    v6 -= 46802;
  }
  return result;
}

//----- (00498990) --------------------------------------------------------
int __cdecl sub_498990(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int result; // eax
  _DWORD *v8; // esi
  int v9; // edi
  int v10; // ebp
  unsigned __int8 *v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // esi
  int v15; // ebp
  int v16; // esi
  int v17; // edi
  int v18; // ebp
  bool v19; // zf
  int v20; // [esp+0h] [ebp-20h]
  int v21; // [esp+4h] [ebp-1Ch]
  int v22; // [esp+8h] [ebp-18h]
  int v23; // [esp+Ch] [ebp-14h]
  int v24; // [esp+10h] [ebp-10h]
  int v25; // [esp+14h] [ebp-Ch]
  int v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+1Ch] [ebp-4h]
  int v28; // [esp+24h] [ebp+4h]
  int v29; // [esp+24h] [ebp+4h]
  int v30; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[105];
  v20 = a1[23];
  v6 = a1[72];
  v25 = v6;
  v22 = v5[2];
  v26 = v5[3];
  v24 = v5[4];
  v23 = v5[5];
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v8 = a2;
    v9 = 4 * a3;
    do
    {
      v10 = *(_DWORD *)(*v8 + v9);
      v11 = *(unsigned __int8 **)(v9 + v8[1]);
      a4 += 4;
      v12 = *(_DWORD *)(v8[2] + v9);
      v9 += 4;
      v28 = v12;
      v13 = *(_DWORD *)(a4 - 4);
      v27 = v9;
      if ( v20 )
      {
        v14 = v10 - (_DWORD)v11;
        v15 = v28 - (_DWORD)v11;
        v30 = v14;
        v21 = v28 - (_DWORD)v11;
        v29 = v20;
        while ( 1 )
        {
          v13 += 3;
          v16 = v11[v14];
          v17 = *v11;
          v18 = v11[v15];
          *(_BYTE *)(v13 - 3) = *(_BYTE *)(v16 + *(_DWORD *)(v22 + 4 * v18) + v6);
          v6 = v25;
          *(_BYTE *)(v13 - 2) = *(_BYTE *)(v16 + ((*(_DWORD *)(v24 + 4 * v18) + *(_DWORD *)(v23 + 4 * v17)) >> 16) + v25);
          ++v11;
          v19 = v29-- == 1;
          *(_BYTE *)(v13 - 1) = *(_BYTE *)(v16 + *(_DWORD *)(v26 + 4 * v17) + v25);
          if ( v19 )
            break;
          v14 = v30;
          v15 = v21;
        }
        v8 = a2;
        v9 = v27;
      }
      result = --a5;
    }
    while ( a5 );
  }
  return result;
}

//----- (00498AC0) --------------------------------------------------------
int __cdecl sub_498AC0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5)
{
  int v5; // edx
  int v6; // edi
  int result; // eax
  int v8; // esi
  _DWORD *v9; // ebp
  char *v10; // ecx
  _BYTE *v11; // eax
  char v12; // bl
  bool v13; // zf
  int v14; // [esp+4h] [ebp-4h]
  int v15; // [esp+Ch] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 36);
  v6 = *(_DWORD *)(a1 + 92);
  v14 = v6;
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v15 = 4 * a3;
    do
    {
      v8 = 0;
      if ( v5 > 0 )
      {
        v9 = a2;
        do
        {
          v10 = *(char **)(*v9 + v15);
          v11 = (_BYTE *)(v8 + *a4);
          if ( v6 )
          {
            do
            {
              v12 = *v10++;
              *v11 = v12;
              v11 += v5;
              --v6;
            }
            while ( v6 );
            v6 = v14;
          }
          ++v8;
          ++v9;
        }
        while ( v8 < v5 );
      }
      result = a5 - 1;
      v13 = a5 == 1;
      v15 += 4;
      ++a4;
      --a5;
    }
    while ( !v13 );
  }
  return result;
}

//----- (00498B50) --------------------------------------------------------
const void **__cdecl sub_498B50(int a1, int *a2, int a3, int a4, int a5)
{
  return sub_493EF0(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 92));
}

//----- (00498B80) --------------------------------------------------------
int __cdecl sub_498B80(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  unsigned int v5; // edi
  int result; // eax
  int v8; // ebx
  unsigned int v9; // edx
  int v10; // esi
  _BYTE *i; // eax
  char v12; // cl
  int v13; // [esp+8h] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 92);
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v8 = 4 * a3;
    v13 = a5;
    do
    {
      v8 += 4;
      a4 += 4;
      v9 = 0;
      v10 = *(_DWORD *)(*a2 + v8 - 4);
      for ( i = *(_BYTE **)(a4 - 4); v9 < v5; ++v9 )
      {
        v12 = *(_BYTE *)(v9 + v10);
        i[2] = v12;
        i[1] = v12;
        *i = v12;
        i += 3;
      }
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (00498BF0) --------------------------------------------------------
int __cdecl sub_498BF0(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int result; // eax
  _DWORD *v8; // edi
  int v9; // esi
  int v10; // ebp
  unsigned __int8 *v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // esi
  int v15; // ebp
  int v16; // esi
  int v17; // edi
  int v18; // ebp
  int v19; // [esp+0h] [ebp-24h]
  int v20; // [esp+4h] [ebp-20h]
  int v21; // [esp+8h] [ebp-1Ch]
  int v22; // [esp+Ch] [ebp-18h]
  int v23; // [esp+10h] [ebp-14h]
  int v24; // [esp+14h] [ebp-10h]
  int v25; // [esp+18h] [ebp-Ch]
  int v26; // [esp+1Ch] [ebp-8h]
  int v27; // [esp+20h] [ebp-4h]
  int v28; // [esp+28h] [ebp+4h]
  int v29; // [esp+28h] [ebp+4h]
  int v30; // [esp+30h] [ebp+Ch]
  int v31; // [esp+30h] [ebp+Ch]

  v5 = (_DWORD *)a1[105];
  v19 = a1[23];
  v6 = a1[72];
  v25 = v6;
  v22 = v5[2];
  v26 = v5[3];
  v24 = v5[4];
  v23 = v5[5];
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v8 = a2;
    v9 = 4 * a3;
    do
    {
      v10 = *(_DWORD *)(*v8 + v9);
      v11 = *(unsigned __int8 **)(v9 + v8[1]);
      a4 += 4;
      v12 = *(_DWORD *)(v8[2] + v9);
      v9 += 4;
      v28 = v12;
      v27 = v9;
      v30 = *(_DWORD *)(v9 + v8[3] - 4);
      v13 = *(_DWORD *)(a4 - 4);
      if ( v19 )
      {
        v14 = v10 - (_DWORD)v11;
        v15 = v28 - (_DWORD)v11;
        v20 = v14;
        v21 = v28 - (_DWORD)v11;
        v31 = v30 - (_DWORD)v11;
        v29 = v19;
        while ( 1 )
        {
          v13 += 4;
          v16 = v11[v14];
          v17 = *v11;
          v18 = v11[v15];
          *(_BYTE *)(v13 - 4) = *(_BYTE *)(v6 - *(_DWORD *)(v22 + 4 * v18) - v16 + 255);
          v6 = v25;
          *(_BYTE *)(v13 - 3) = *(_BYTE *)(v25
                                         - ((*(_DWORD *)(v24 + 4 * v18) + *(_DWORD *)(v23 + 4 * v17)) >> 16)
                                         - v16
                                         + 255);
          ++v11;
          *(_BYTE *)(v13 - 2) = *(_BYTE *)(v25 - *(_DWORD *)(v26 + 4 * v17) - v16 + 255);
          *(_BYTE *)(v13 - 1) = v11[v31 - 1];
          if ( !--v29 )
            break;
          v14 = v20;
          v15 = v21;
        }
        v8 = a2;
        v9 = v27;
      }
      result = --a5;
    }
    while ( a5 );
  }
  return result;
}

//----- (00498D70) --------------------------------------------------------
int __cdecl sub_498D70(int a1)
{
  int v1; // esi
  int v2; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 416) = v1;
  *(_DWORD *)v1 = sub_498EC0;
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100);
  if ( *(_DWORD *)(a1 + 276) == 2 )
  {
    v2 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = sub_498EE0;
    *(_DWORD *)(v1 + 12) = sub_499150;
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v2);
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_498FB0;
    *(_DWORD *)(v1 + 12) = sub_498FF0;
    *(_DWORD *)(v1 + 32) = 0;
  }
  return sub_498E00(a1);
}
// 498EC0: using guessed type int sub_498EC0();

//----- (00498E00) --------------------------------------------------------
int __cdecl sub_498E00(int a1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // edi
  int v4; // edx
  int i; // ecx
  int v6; // [esp+14h] [ebp+4h]

  v1 = *(_DWORD **)(a1 + 416);
  v1[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[6] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[7] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v6 = 5990656;
  v3 = -14831872;
  v4 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    *(_DWORD *)(result + v1[4]) = v4 >> 16;
    v4 += 91881;
    *(_DWORD *)(result + v1[5]) = v3 >> 16;
    v3 += 116130;
    *(_DWORD *)(result + v1[6]) = v6;
    *(_DWORD *)(result + v1[7]) = i;
    result += 4;
    v6 -= 46802;
  }
  return result;
}

//----- (00498EE0) --------------------------------------------------------
char __cdecl sub_498EE0(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebp
  int v8; // esi
  _DWORD *v9; // ebx
  unsigned int v10; // edi
  int v11; // eax
  char result; // al
  int v13; // [esp+10h] [ebp-8h] BYREF
  int v14; // [esp+14h] [ebp-4h]

  v7 = a3;
  v8 = *(_DWORD *)(a1 + 416);
  if ( *(_BYTE *)(v8 + 36) )
  {
    v9 = a6;
    sub_493EF0(v8 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v8 + 40));
    v10 = 1;
    *(_BYTE *)(v8 + 36) = 0;
  }
  else
  {
    v10 = 2;
    if ( *(_DWORD *)(v8 + 44) < 2u )
      v10 = *(_DWORD *)(v8 + 44);
    v9 = a6;
    v11 = *a6;
    if ( v10 > a7 - *a6 )
      v10 = a7 - *a6;
    v13 = *(_DWORD *)(a5 + 4 * v11);
    if ( v10 <= 1 )
    {
      v14 = *(_DWORD *)(v8 + 32);
      *(_BYTE *)(v8 + 36) = 1;
    }
    else
    {
      v14 = *(_DWORD *)(a5 + 4 * v11 + 4);
    }
    v7 = a3;
    (*(void (__cdecl **)(int, int, _DWORD, int *))(v8 + 12))(a1, a2, *a3, &v13);
  }
  *v9 += v10;
  result = *(_BYTE *)(v8 + 36);
  *(_DWORD *)(v8 + 44) -= v10;
  if ( !result )
    ++*v7;
  return result;
}

//----- (00498FB0) --------------------------------------------------------
int __cdecl sub_498FB0(int a1, int a2, int *a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax

  (*(void (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 416) + 12))(a1, a2, *a3, a5 + 4 * *a6);
  ++*a6;
  result = *a3 + 1;
  *a3 = result;
  return result;
}

//----- (00498FF0) --------------------------------------------------------
_BYTE *__cdecl sub_498FF0(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4)
{
  _DWORD *v4; // ebp
  _DWORD *v5; // eax
  int v6; // ecx
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // esi
  unsigned __int8 *v9; // ebx
  _BYTE *result; // eax
  int v11; // ebp
  int v12; // edx
  int v13; // esi
  int v14; // edx
  int v15; // ebp
  unsigned __int8 *v16; // edi
  int v17; // ebx
  int v18; // ebp
  int v19; // ebp
  int v20; // edx
  int v21; // esi
  int v22; // ebp
  int v23; // edi
  unsigned __int8 *v24; // [esp+10h] [ebp-14h]
  int v25; // [esp+14h] [ebp-10h]
  int v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  int v28; // [esp+20h] [ebp-4h]
  int v29; // [esp+2Ch] [ebp+8h]
  int v30; // [esp+30h] [ebp+Ch]
  unsigned __int8 *v31; // [esp+34h] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[104];
  v6 = a1[72];
  v28 = v5[4];
  v27 = v5[5];
  v26 = v5[6];
  v25 = v5[7];
  v7 = *(unsigned __int8 **)(*a2 + 4 * a3);
  v8 = *(unsigned __int8 **)(a2[1] + 4 * a3);
  v9 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  result = *a4;
  if ( a1[23] >> 1 )
  {
    v29 = a1[23] >> 1;
    do
    {
      v11 = *v8;
      v12 = *v9;
      v24 = v8 + 1;
      v31 = v9 + 1;
      result += 6;
      v30 = *(_DWORD *)(v28 + 4 * v12);
      v13 = *(_DWORD *)(v26 + 4 * v12) + *(_DWORD *)(v25 + 4 * v11);
      v14 = *(_DWORD *)(v27 + 4 * v11);
      v15 = *v7;
      v13 >>= 16;
      v16 = v7 + 1;
      *(result - 6) = *(_BYTE *)(v15 + v30 + v6);
      *(result - 5) = *(_BYTE *)(v13 + v15 + v6);
      *(result - 4) = *(_BYTE *)(v6 + v14 + v15);
      v17 = *v16;
      v7 = v16 + 1;
      v18 = v14 + v17;
      *(result - 3) = *(_BYTE *)(v17 + v30 + v6);
      *(result - 2) = *(_BYTE *)(v17 + v13 + v6);
      v9 = v31;
      v8 = v24;
      *(result - 1) = *(_BYTE *)(v6 + v18);
      --v29;
    }
    while ( v29 );
    v4 = a1;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v19 = *v8;
    v20 = *v9;
    v21 = *(_DWORD *)(v26 + 4 * v20) + *(_DWORD *)(v25 + 4 * v19);
    v22 = *(_DWORD *)(v27 + 4 * v19);
    v23 = *v7;
    *result = *(_BYTE *)(v23 + *(_DWORD *)(v28 + 4 * v20) + v6);
    result[1] = *(_BYTE *)(v23 + (v21 >> 16) + v6);
    result[2] = *(_BYTE *)(v22 + v23 + v6);
  }
  return result;
}

//----- (00499150) --------------------------------------------------------
char __cdecl sub_499150(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  _DWORD *v5; // ecx
  int v6; // eax
  int v9; // esi
  unsigned __int8 *v10; // edi
  unsigned __int8 *v11; // ebp
  _BYTE *v12; // ecx
  _BYTE *v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // ebp
  _BYTE *v17; // esi
  int v18; // edi
  int v19; // edx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // edx
  int v24; // ebx
  int v25; // edi
  int v26; // edx
  int v27; // ebp
  int v28; // ecx
  int v30; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v31; // [esp+14h] [ebp-18h]
  unsigned __int8 *v32; // [esp+18h] [ebp-14h]
  int v33; // [esp+1Ch] [ebp-10h]
  int v34; // [esp+20h] [ebp-Ch]
  int v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+28h] [ebp-4h]
  int v37; // [esp+30h] [ebp+4h]
  unsigned __int8 *v38; // [esp+34h] [ebp+8h]
  unsigned __int8 *v39; // [esp+38h] [ebp+Ch]
  int v40; // [esp+3Ch] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[104];
  v6 = a1[72];
  v33 = v5[4];
  v36 = v5[5];
  v35 = v5[6];
  v34 = v5[7];
  v9 = *a2 + 8 * a3;
  v38 = *(unsigned __int8 **)v9;
  v39 = *(unsigned __int8 **)(v9 + 4);
  v10 = *(unsigned __int8 **)(a2[1] + 4 * a3);
  v11 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  v12 = *(_BYTE **)a4;
  v13 = *(_BYTE **)(a4 + 4);
  if ( a1[23] >> 1 )
  {
    v30 = a1[23] >> 1;
    while ( 1 )
    {
      v14 = *v10;
      v15 = *v11;
      v31 = v10 + 1;
      v32 = v11 + 1;
      v16 = *(_DWORD *)(v33 + 4 * v15);
      v17 = v13 + 3;
      v12 += 6;
      v18 = (*(_DWORD *)(v35 + 4 * v15) + *(_DWORD *)(v34 + 4 * v14)) >> 16;
      v40 = *(_DWORD *)(v36 + 4 * v14);
      v19 = *v38;
      *(v12 - 6) = *(_BYTE *)(v19 + v16 + v6);
      *(v12 - 5) = *(_BYTE *)(v19 + v18 + v6);
      *(v12 - 4) = *(_BYTE *)(v40 + v19 + v6);
      v20 = v38[1];
      v38 += 2;
      *(v12 - 3) = *(_BYTE *)(v20 + v16 + v6);
      *(v12 - 2) = *(_BYTE *)(v20 + v18 + v6);
      *(v12 - 1) = *(_BYTE *)(v40 + v20 + v6);
      v21 = *v39;
      *(v17 - 3) = *(_BYTE *)(v21 + v16 + v6);
      *(v17 - 2) = *(_BYTE *)(v21 + v18 + v6);
      *(v17 - 1) = *(_BYTE *)(v40 + v21 + v6);
      v22 = v39[1];
      v39 += 2;
      *v17 = *(_BYTE *)(v22 + v16 + v6);
      v17[1] = *(_BYTE *)(v22 + v18 + v6);
      v17[2] = *(_BYTE *)(v40 + v22 + v6);
      v13 = v17 + 3;
      if ( !--v30 )
        break;
      v10 = v31;
      v11 = v32;
    }
    v4 = a1;
    v10 = v31;
    v11 = v32;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v23 = *v10;
    v24 = *v11;
    v37 = *(_DWORD *)(v33 + 4 * v24);
    v25 = *(_DWORD *)(v35 + 4 * v24) + *(_DWORD *)(v34 + 4 * v23);
    v26 = *(_DWORD *)(v36 + 4 * v23);
    v27 = *v38;
    v25 >>= 16;
    *v12 = *(_BYTE *)(v27 + v37 + v6);
    v12[1] = *(_BYTE *)(v25 + v27 + v6);
    v12[2] = *(_BYTE *)(v6 + v26 + v27);
    v28 = *v39;
    *v13 = *(_BYTE *)(v28 + v37 + v6);
    v13[1] = *(_BYTE *)(v28 + v25 + v6);
    LOBYTE(v6) = *(_BYTE *)(v26 + v28 + v6);
    v13[2] = v6;
  }
  return v6;
}

//----- (00499360) --------------------------------------------------------
_DWORD *__cdecl sub_499360(int a1)
{
  int v1; // edi
  int i; // ebp
  int v3; // ebp
  _DWORD *result; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 424) = v1;
  *(_DWORD *)v1 = sub_499530;
  *(_DWORD *)(v1 + 12) = sub_49A750;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 47;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v1 + 24) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  for ( i = 0;
        i < 128;
        *(_DWORD *)(*(_DWORD *)(v1 + 24) + i - 4) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                                                      a1,
                                                      1,
                                                      4096) )
  {
    i += 4;
  }
  *(_BYTE *)(v1 + 28) = 1;
  if ( *(_BYTE *)(a1 + 90) )
  {
    v3 = *(_DWORD *)(a1 + 84);
    if ( v3 < 8 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( v3 > 256 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 57;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(v1 + 16) = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, v3, 3);
    *(_DWORD *)(v1 + 20) = v3;
  }
  else
  {
    *(_DWORD *)(v1 + 16) = 0;
  }
  result = *(_DWORD **)(a1 + 76);
  if ( result )
    *(_DWORD *)(a1 + 76) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                             a1,
                             1,
                             6 * (*(_DWORD *)(a1 + 92) + 2));
    result = sub_499490(a1);
  }
  return result;
}

//----- (00499490) --------------------------------------------------------
_DWORD *__cdecl sub_499490(int a1)
{
  int v1; // esi
  _DWORD *result; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // ebx
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  int v8; // edx
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // edi
  int v12; // esi

  v1 = *(_DWORD *)(a1 + 424);
  result = (_DWORD *)((**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020);
  v3 = 16;
  *(_DWORD *)(v1 + 40) = result;
  v4 = 0;
  v5 = 0;
  v6 = result;
  v7 = result;
  v8 = 16;
  do
  {
    *v6 = v4;
    *v7 = v5;
    ++v6;
    --v7;
    ++v4;
    --v5;
    --v3;
  }
  while ( v3 );
  v9 = result + 16;
  v10 = result - 16;
  do
  {
    *v9 = v4;
    ++v8;
    *v10 = -v4;
    ++v9;
    --v10;
    v4 += (v8 & 1) == 0;
  }
  while ( v8 < 48 );
  if ( v8 <= 255 )
  {
    v11 = &result[v8];
    result -= v8;
    v12 = 256 - v8;
    do
    {
      *v11 = v4;
      *result = -v4;
      ++v11;
      --result;
      --v12;
    }
    while ( v12 );
  }
  return result;
}

//----- (00499530) --------------------------------------------------------
char __cdecl sub_499530(_DWORD *a1, char a2)
{
  int v3; // edi
  int v4; // ebp
  unsigned int v5; // ebp
  char result; // al
  void **v7; // esi
  int v8; // ebp
  void **v9; // [esp+10h] [ebp+4h]

  v3 = a1[106];
  v9 = *(void ***)(v3 + 24);
  if ( a1[19] )
    a1[19] = 2;
  if ( a2 )
  {
    *(_DWORD *)(v3 + 4) = sub_499650;
    *(_DWORD *)(v3 + 8) = sub_499EF0;
    *(_BYTE *)(v3 + 28) = 1;
  }
  else
  {
    if ( a1[19] == 2 )
      *(_DWORD *)(v3 + 4) = sub_499C10;
    else
      *(_DWORD *)(v3 + 4) = sub_4996D0;
    *(_DWORD *)(v3 + 8) = nullsub_15;
    v4 = a1[28];
    if ( v4 < 1 )
    {
      *(_DWORD *)(*a1 + 20) = 56;
      *(_DWORD *)(*a1 + 24) = 1;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( v4 > 256 )
    {
      *(_DWORD *)(*a1 + 20) = 57;
      *(_DWORD *)(*a1 + 24) = 256;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( a1[19] == 2 )
    {
      v5 = 6 * (a1[23] + 2);
      if ( !*(_DWORD *)(v3 + 32) )
        *(_DWORD *)(v3 + 32) = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, 6 * (a1[23] + 2));
      sub_493F70(*(void **)(v3 + 32), v5);
      if ( !*(_DWORD *)(v3 + 40) )
        sub_499490((int)a1);
      *(_BYTE *)(v3 + 36) = 0;
    }
  }
  result = *(_BYTE *)(v3 + 28);
  if ( result )
  {
    v7 = v9;
    v8 = 32;
    do
    {
      result = sub_493F70(*v7++, 0x1000u);
      --v8;
    }
    while ( v8 );
    *(_BYTE *)(v3 + 28) = 0;
  }
  return result;
}
// 49A740: using guessed type int nullsub_15();

//----- (00499650) --------------------------------------------------------
int __cdecl sub_499650(int a1, unsigned __int8 **a2, int a3, int a4)
{
  int v4; // ebp
  int result; // eax
  int v6; // esi
  unsigned __int8 *v8; // ecx
  int v9; // edi
  int v10; // edx
  int v11; // eax
  _WORD *v12; // eax
  int v13; // [esp+Ch] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 92);
  result = a4;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 424) + 24);
  if ( a4 > 0 )
  {
    v13 = a4;
    do
    {
      v8 = *a2;
      if ( v4 )
      {
        v9 = v4;
        do
        {
          v10 = (v8[2] >> 3) + 32 * (v8[1] >> 2);
          v11 = *(_DWORD *)(v6 + 4 * (*v8 >> 3));
          ++*(_WORD *)(v11 + 2 * v10);
          v12 = (_WORD *)(v11 + 2 * v10);
          if ( !*v12 )
            *v12 = -1;
          v8 += 3;
          --v9;
        }
        while ( v9 );
      }
      ++a2;
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (004996D0) --------------------------------------------------------
_DWORD *__cdecl sub_4996D0(int a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax
  int v5; // edx
  int v6; // ecx
  unsigned __int8 *v7; // esi
  _BYTE *v8; // ebp
  int v9; // eax
  int v10; // ecx
  int v11; // ebx
  unsigned __int8 *v12; // esi
  int v13; // edx
  int v14; // edi
  bool v15; // zf
  _BYTE *v16; // edi
  int v17; // [esp+4h] [ebp-Ch]
  int v18; // [esp+8h] [ebp-8h]
  int v19; // [esp+Ch] [ebp-4h]
  int v20; // [esp+18h] [ebp+8h]
  int v21; // [esp+20h] [ebp+10h]

  result = (_DWORD *)a1;
  v17 = *(_DWORD *)(*(_DWORD *)(a1 + 424) + 24);
  v5 = *(_DWORD *)(a1 + 92);
  v18 = v5;
  if ( a4 > 0 )
  {
    result = a3;
    v6 = a2 - (_DWORD)a3;
    v19 = a2 - (_DWORD)a3;
    v20 = a4;
    do
    {
      v7 = *(unsigned __int8 **)((char *)result + v6);
      v8 = (_BYTE *)*result;
      if ( v5 )
      {
        v21 = v5;
        do
        {
          v9 = *v7 >> 3;
          v10 = v7[1] >> 2;
          v11 = *(_DWORD *)(v17 + 4 * v9);
          v12 = v7 + 2;
          v13 = *v12 >> 3;
          v14 = v13 + 32 * v10;
          v7 = v12 + 1;
          v15 = *(_WORD *)(v11 + 2 * v14) == 0;
          v16 = (_BYTE *)(v11 + 2 * v14);
          if ( v15 )
            sub_4997A0(a1, v9, v10, v13);
          *v8++ = *v16 - 1;
          --v21;
        }
        while ( v21 );
        v5 = v18;
        result = a3;
        v6 = v19;
      }
      ++result;
      v15 = v20 == 1;
      a3 = result;
      --v20;
    }
    while ( !v15 );
  }
  return result;
}

//----- (004997A0) --------------------------------------------------------
int __cdecl sub_4997A0(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  char *v5; // edx
  int v6; // eax
  _DWORD *v7; // ebp
  int v8; // edi
  int v9; // ecx
  int v10; // esi
  _WORD *v11; // eax
  int result; // eax
  int v13; // [esp+10h] [ebp-184h]
  int v14; // [esp+10h] [ebp-184h]
  char v15[128]; // [esp+14h] [ebp-180h] BYREF
  char v16[256]; // [esp+94h] [ebp-100h] BYREF
  int v17; // [esp+1A0h] [ebp+Ch]
  int v18; // [esp+1A0h] [ebp+Ch]
  int v19; // [esp+1A4h] [ebp+10h]
  int v20; // [esp+1A4h] [ebp+10h]

  v19 = a4 >> 2;
  v17 = a3 >> 3;
  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 424) + 24);
  v4 = sub_4998C0(a1, 32 * (a2 >> 2) + 4, 32 * v17 + 2, 32 * v19 + 4, (int)v16);
  sub_499AB0(a1, 32 * (a2 >> 2) + 4, 32 * v17 + 2, 32 * v19 + 4, v4, (int)v16, v15);
  v5 = v15;
  v20 = 4 * v19;
  v6 = v13;
  v18 = 8 * v17;
  v14 = 4;
  v7 = (_DWORD *)(v6 + 16 * (a2 >> 2));
  do
  {
    v8 = 8;
    v9 = 2 * (v20 + 32 * v18);
    do
    {
      v10 = 4;
      v11 = (_WORD *)(v9 + *v7);
      do
      {
        *v11++ = (unsigned __int8)*v5++ + 1;
        --v10;
      }
      while ( v10 );
      v9 += 64;
      --v8;
    }
    while ( v8 );
    ++v7;
    result = --v14;
  }
  while ( v14 );
  return result;
}

//----- (004998C0) --------------------------------------------------------
int __cdecl sub_4998C0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  int v8; // esi
  int *v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // ebx
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  bool v21; // cc
  int result; // eax
  int v23; // ecx
  char *v24; // edx
  int v25; // [esp+10h] [ebp-42Ch]
  char *v26; // [esp+14h] [ebp-428h]
  int v27; // [esp+18h] [ebp-424h]
  int v28; // [esp+1Ch] [ebp-420h]
  int v29; // [esp+20h] [ebp-41Ch]
  int v30; // [esp+24h] [ebp-418h]
  int v31; // [esp+38h] [ebp-404h]
  char v32[1024]; // [esp+3Ch] [ebp-400h] BYREF

  v27 = 0x7FFFFFFF;
  v5 = a3 + 28;
  v28 = *(_DWORD *)(a1 + 112);
  v6 = a2;
  v7 = v28;
  v25 = 0;
  v8 = (2 * a2 + 24) >> 1;
  if ( v28 > 0 )
  {
    v9 = *(int **)(a1 + 116);
    v26 = v32;
    v29 = *v9;
    v31 = v9[1];
    v30 = v9[2];
    while ( 1 )
    {
      v10 = *(unsigned __int8 *)(v29 + v25);
      if ( v10 < v6 )
        break;
      v16 = v6 + 24;
      if ( v10 > v6 + 24 )
      {
        v11 = 2 * (v10 - v16) * 2 * (v10 - v16);
        goto LABEL_6;
      }
      v11 = 0;
      if ( v10 > v8 )
        goto LABEL_6;
      v12 = v10 - v16;
LABEL_7:
      v13 = *(unsigned __int8 *)(v31 + v25);
      v14 = 2 * v12 * 2 * v12;
      if ( v13 < a3 )
      {
        v11 += 3 * (v13 - a3) * 3 * (v13 - a3);
        v15 = v13 - v5;
        goto LABEL_16;
      }
      if ( v13 > v5 )
      {
        v11 += 3 * (v13 - v5) * 3 * (v13 - v5);
LABEL_15:
        v15 = v13 - a3;
        goto LABEL_16;
      }
      if ( v13 > (a3 + a3 + 28) >> 1 )
        goto LABEL_15;
      v15 = v13 - v5;
LABEL_16:
      v17 = 3 * v15 * 3 * v15 + v14;
      v18 = *(unsigned __int8 *)(v30 + v25);
      if ( v18 >= a4 )
      {
        if ( v18 <= a4 + 24 )
        {
          if ( v18 > (2 * a4 + 24) >> 1 )
            v19 = v18 - a4;
          else
            v19 = v18 - (a4 + 24);
        }
        else
        {
          v11 += (v18 - (a4 + 24)) * (v18 - (a4 + 24));
          v19 = v18 - a4;
        }
      }
      else
      {
        v11 += (v18 - a4) * (v18 - a4);
        v19 = v18 - (a4 + 24);
      }
      v20 = v19 * v19 + v17;
      *(_DWORD *)v26 = v11;
      if ( v20 < v27 )
        v27 = v20;
      v7 = v28;
      v21 = ++v25 < v28;
      v26 += 4;
      if ( !v21 )
        goto LABEL_28;
      v6 = a2;
      v8 = (2 * a2 + 24) >> 1;
    }
    v11 = 2 * (v10 - v6) * 2 * (v10 - v6);
    v6 += 24;
LABEL_6:
    v12 = v10 - v6;
    goto LABEL_7;
  }
LABEL_28:
  result = 0;
  v23 = 0;
  if ( v7 > 0 )
  {
    v24 = v32;
    do
    {
      if ( *(_DWORD *)v24 <= v27 )
      {
        *(_BYTE *)(result + a5) = v23;
        ++result;
      }
      ++v23;
      v24 += 4;
    }
    while ( v23 < v7 );
  }
  return result;
}

//----- (00499AB0) --------------------------------------------------------
int __cdecl sub_499AB0(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7)
{
  int result; // eax
  int v8; // edx
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  int v12; // ecx
  int v13; // ebp
  int v14; // edi
  _BYTE *v15; // ebx
  int *v16; // esi
  int v17; // ebp
  int v18; // eax
  int v19; // ecx
  int v20; // ebp
  bool v21; // zf
  int v22; // [esp+4h] [ebp-220h]
  int v23; // [esp+8h] [ebp-21Ch]
  int i; // [esp+Ch] [ebp-218h]
  int v25; // [esp+10h] [ebp-214h]
  int v26; // [esp+14h] [ebp-210h]
  int v27; // [esp+18h] [ebp-20Ch]
  int v28; // [esp+1Ch] [ebp-208h]
  int v29; // [esp+20h] [ebp-204h]
  _DWORD v30[128]; // [esp+24h] [ebp-200h] BYREF

  memset32(v30, 0x7FFFFFFF, 0x80u);
  result = 0;
  for ( i = 0; i < a5; ++i )
  {
    v22 = 4;
    v8 = *(unsigned __int8 *)(result + a6);
    v9 = *(_DWORD **)(a1 + 116);
    v10 = 2 * (a2 - *(unsigned __int8 *)(v8 + *v9));
    v11 = 3 * (a3 - *(unsigned __int8 *)(v9[1] + v8));
    v12 = a4 - *(unsigned __int8 *)(v9[2] + v8);
    v13 = 9 * (a3 - *(unsigned __int8 *)(v9[1] + v8)) + 18;
    v14 = v10 * v10 + v11 * v11 + v12 * v12;
    v15 = a7;
    v16 = v30;
    v17 = 8 * v13;
    v28 = v17;
    v29 = 16 * (v12 + 4);
    v27 = 32 * (v10 + 8);
    while ( 1 )
    {
      v18 = v14;
      v26 = v17;
      v23 = v14;
      v25 = 8;
      do
      {
        v19 = v29;
        v20 = 4;
        do
        {
          if ( v18 < *v16 )
          {
            *v16 = v18;
            *v15 = v8;
          }
          v18 += v19;
          v19 += 128;
          ++v16;
          ++v15;
          --v20;
        }
        while ( v20 );
        v18 = v26 + v23;
        v26 += 288;
        v21 = v25 == 1;
        v23 = v18;
        --v25;
      }
      while ( !v21 );
      v14 += v27;
      v27 += 512;
      if ( !--v22 )
        break;
      v17 = v28;
    }
    result = i + 1;
  }
  return result;
}

//----- (00499C10) --------------------------------------------------------
int __cdecl sub_499C10(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // esi
  int v5; // ecx
  int *v6; // eax
  int result; // eax
  _DWORD *v8; // ebx
  int v9; // ebp
  unsigned __int8 *v10; // eax
  _BYTE *v11; // edi
  _WORD *v12; // ebx
  int v13; // ebp
  int v14; // edi
  int v15; // esi
  int v16; // esi
  int v17; // edi
  int v18; // ebp
  int v19; // ecx
  int v20; // edx
  bool v21; // zf
  unsigned __int16 *v22; // ecx
  int v23; // eax
  int v24; // esi
  int v25; // edi
  int v26; // edx
  int v27; // eax
  int v28; // ebp
  __int16 v29; // cx
  int v30; // esi
  int v31; // eax
  __int16 v32; // cx
  int v33; // edi
  int v34; // eax
  __int16 v35; // cx
  int v36; // ebp
  int v37; // [esp+4h] [ebp-58h]
  __int16 v38; // [esp+8h] [ebp-54h]
  __int16 v39; // [esp+Ch] [ebp-50h]
  __int16 v40; // [esp+10h] [ebp-4Ch]
  int v41; // [esp+14h] [ebp-48h]
  __int16 v42; // [esp+18h] [ebp-44h]
  __int16 v43; // [esp+1Ch] [ebp-40h]
  __int16 v44; // [esp+20h] [ebp-3Ch]
  int v45; // [esp+24h] [ebp-38h]
  int v46; // [esp+28h] [ebp-34h]
  int v47; // [esp+2Ch] [ebp-30h]
  _DWORD *v48; // [esp+30h] [ebp-2Ch]
  int v49; // [esp+34h] [ebp-28h]
  int i; // [esp+38h] [ebp-24h]
  int v51; // [esp+3Ch] [ebp-20h]
  unsigned __int16 *v52; // [esp+48h] [ebp-14h]
  int v53; // [esp+4Ch] [ebp-10h]
  int v54; // [esp+50h] [ebp-Ch]
  int v55; // [esp+54h] [ebp-8h]
  int v56; // [esp+58h] [ebp-4h]
  _BYTE *v57; // [esp+64h] [ebp+8h]
  int v58; // [esp+68h] [ebp+Ch]
  int v59; // [esp+6Ch] [ebp+10h]

  v4 = a1[106];
  v41 = a1[72];
  v47 = v4;
  v51 = *(_DWORD *)(v4 + 24);
  v5 = a1[23];
  v6 = (int *)a1[29];
  v37 = *(_DWORD *)(v4 + 40);
  v56 = v5;
  v53 = *v6;
  v54 = v6[1];
  v55 = v6[2];
  result = a4;
  if ( a4 > 0 )
  {
    v49 = a4;
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v48 = a3;
    for ( i = a2 - (_DWORD)a3; ; v9 = i )
    {
      v10 = *(unsigned __int8 **)((char *)v8 + v9);
      v11 = (_BYTE *)*v8;
      v58 = (int)v10;
      v57 = (_BYTE *)*v8;
      if ( *(_BYTE *)(v4 + 36) )
      {
        v45 = -1;
        v59 = -3;
        *(_BYTE *)(v4 + 36) = 0;
        v58 = (int)&v10[2 * v5 - 3 + v5];
        v57 = &v11[v5 - 1];
        v12 = (_WORD *)(*(_DWORD *)(v4 + 32) + 2 * (3 * v5 + 3));
        v10 = (unsigned __int8 *)v58;
      }
      else
      {
        v12 = *(_WORD **)(v4 + 32);
        v45 = 1;
        v59 = 3;
        *(_BYTE *)(v4 + 36) = 1;
      }
      v44 = 0;
      v43 = 0;
      v42 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v40 = 0;
      v39 = 0;
      v38 = 0;
      if ( v5 )
      {
        v46 = v5;
        while ( 1 )
        {
          v16 = *(unsigned __int8 *)(*v10 + *(_DWORD *)(v37 + 4 * (((__int16)v12[v59] + v15 + 8) >> 4)) + v41);
          v17 = *(unsigned __int8 *)(v10[1] + *(_DWORD *)(v37 + 4 * (((__int16)v12[v59 + 1] + v14 + 8) >> 4)) + v41);
          v18 = *(unsigned __int8 *)(v10[2] + *(_DWORD *)(v37 + 4 * (((__int16)v12[v59 + 2] + v13 + 8) >> 4)) + v41);
          v19 = (v18 >> 3) + 32 * (v17 >> 2);
          v20 = *(_DWORD *)(v51 + 4 * (v16 >> 3));
          v21 = *(_WORD *)(v20 + 2 * v19) == 0;
          v22 = (unsigned __int16 *)(v20 + 2 * v19);
          v52 = v22;
          if ( v21 )
          {
            sub_4997A0((int)a1, v16 >> 3, v17 >> 2, v18 >> 3);
            v22 = v52;
          }
          v23 = *v22 - 1;
          *v57 = v23;
          v24 = v16 - *(unsigned __int8 *)(v23 + v53);
          v25 = v17 - *(unsigned __int8 *)(v23 + v54);
          v26 = *(unsigned __int8 *)(v23 + v55);
          v27 = 2 * v24;
          v28 = v18 - v26;
          v29 = v24;
          v24 *= 3;
          LOWORD(v26) = v24 + v38;
          v30 = v27 + v24;
          *v12 = v26;
          LOWORD(v26) = v30 + v42;
          v15 = v27 + v30;
          v42 = v29;
          v31 = 2 * v25;
          v38 = v26;
          v32 = v25;
          v25 *= 3;
          LOWORD(v26) = v25 + v39;
          v33 = v31 + v25;
          v12[1] = v26;
          LOWORD(v26) = v33 + v43;
          v14 = v31 + v33;
          v43 = v32;
          v34 = 2 * v28;
          v39 = v26;
          v35 = v28;
          v28 *= 3;
          LOWORD(v26) = v28 + v40;
          v36 = v34 + v28;
          v12[2] = v26;
          LOWORD(v26) = v36 + v44;
          v44 = v35;
          v13 = v34 + v36;
          v40 = v26;
          v58 += v59;
          v12 += v59;
          v21 = v46 == 1;
          v57 += v45;
          --v46;
          if ( v21 )
            break;
          v10 = (unsigned __int8 *)v58;
        }
        v5 = v56;
        v4 = v47;
      }
      else
      {
        v4 = v47;
      }
      *v12 = v38;
      v12[1] = v39;
      v12[2] = v40;
      v8 = v48 + 1;
      result = v49 - 1;
      v21 = v49 == 1;
      ++v48;
      --v49;
      if ( v21 )
        break;
    }
  }
  return result;
}

//----- (00499EF0) --------------------------------------------------------
int __cdecl sub_499EF0(int a1)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 424);
  *(_DWORD *)(a1 + 116) = *(_DWORD *)(v1 + 16);
  result = sub_499F20(a1, *(_DWORD *)(v1 + 20));
  *(_BYTE *)(v1 + 28) = 1;
  return result;
}

//----- (00499F20) --------------------------------------------------------
int __cdecl sub_499F20(int a1, int a2)
{
  int *v2; // esi
  int v3; // ebx
  int v4; // ebp
  int v5; // edx

  v2 = (int *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32 * a2);
  v3 = 0;
  *v2 = 0;
  v2[1] = 31;
  v2[2] = 0;
  v2[3] = 63;
  v2[4] = 0;
  v2[5] = 31;
  sub_499FB0(a1, v2);
  v4 = sub_49A400(a1, (int)v2, 1, a2);
  if ( v4 > 0 )
  {
    do
    {
      sub_49A5B0(a1, v2, v3++);
      v2 += 8;
    }
    while ( v3 < v4 );
  }
  v5 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 112) = v4;
  *(_DWORD *)(v5 + 20) = 96;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
}

//----- (00499FB0) --------------------------------------------------------
int __cdecl sub_499FB0(int a1, int *a2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // edi
  int v5; // ebp
  int v6; // ebx
  int v7; // edx
  int v8; // edx
  _WORD *v9; // ecx
  int v10; // eax
  _DWORD *v12; // ecx
  int v13; // edx
  _WORD *v14; // ecx
  int v15; // eax
  bool v17; // cc
  int v18; // esi
  int v19; // edi
  _DWORD *v20; // edx
  int v21; // ecx
  _WORD *v22; // eax
  int v24; // esi
  int v25; // edi
  _DWORD *v26; // edx
  _WORD *v27; // eax
  int v28; // ecx
  int v30; // eax
  int v31; // edi
  int v32; // edx
  _DWORD *v33; // esi
  int v34; // ecx
  _WORD *v35; // eax
  int v36; // eax
  int v37; // ebx
  int result; // eax
  int v39; // ebp
  int v40; // edx
  _WORD *v41; // eax
  int v42; // ecx
  bool v43; // zf
  int v44; // [esp+10h] [ebp-20h]
  int v45; // [esp+14h] [ebp-1Ch]
  int v46; // [esp+18h] [ebp-18h]
  int v47; // [esp+1Ch] [ebp-14h]
  int v48; // [esp+20h] [ebp-10h]
  int v49; // [esp+20h] [ebp-10h]
  int v50; // [esp+20h] [ebp-10h]
  int v51; // [esp+20h] [ebp-10h]
  int v52; // [esp+20h] [ebp-10h]
  int v53; // [esp+20h] [ebp-10h]
  int v54; // [esp+24h] [ebp-Ch]
  int v55; // [esp+24h] [ebp-Ch]
  int v56; // [esp+28h] [ebp-8h]
  _DWORD *v57; // [esp+2Ch] [ebp-4h]
  _DWORD *v58; // [esp+2Ch] [ebp-4h]
  _DWORD *v59; // [esp+2Ch] [ebp-4h]
  int v60; // [esp+34h] [ebp+4h]

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  v54 = *(_DWORD *)(*(_DWORD *)(a1 + 424) + 24);
  v7 = *a2;
  v44 = *a2;
  v45 = v2;
  v60 = v3;
  v46 = v4;
  v47 = v5;
  v56 = v6;
  if ( *a2 < v2 )
  {
    v48 = *a2;
    if ( *a2 <= v2 )
    {
      v57 = (_DWORD *)(v54 + 4 * v7);
      while ( v3 > v4 )
      {
LABEL_12:
        ++v48;
        ++v57;
        if ( v48 > v2 )
          goto LABEL_15;
      }
      v8 = *v57 + 2 * (v5 + 32 * v3);
      while ( 1 )
      {
        v9 = (_WORD *)v8;
        v10 = a2[4];
        if ( v5 <= v6 )
          break;
LABEL_10:
        ++v3;
        v8 += 64;
        if ( v3 > v4 )
        {
          v7 = *a2;
          v2 = a2[1];
          v3 = a2[2];
          goto LABEL_12;
        }
      }
      while ( !*v9++ )
      {
        if ( ++v10 > v6 )
        {
          v4 = a2[3];
          goto LABEL_10;
        }
      }
      v4 = a2[3];
      v3 = a2[2];
      *a2 = v48;
      v2 = v45;
      v44 = v48;
      v7 = v48;
    }
LABEL_15:
    if ( v2 > v7 )
    {
      v49 = v2;
      v12 = (_DWORD *)(v54 + 4 * v2);
      v58 = v12;
      while ( v3 > v4 )
      {
LABEL_25:
        v12 = v58 - 1;
        v17 = --v49 < v7;
        --v58;
        if ( v17 )
          goto LABEL_28;
      }
      v13 = *v12 + 2 * (v5 + 32 * v3);
      while ( 1 )
      {
        v14 = (_WORD *)v13;
        v15 = v5;
        if ( v5 <= v6 )
          break;
LABEL_23:
        ++v3;
        v13 += 64;
        if ( v3 > v4 )
        {
          v7 = v44;
          v3 = v60;
          goto LABEL_25;
        }
      }
      while ( !*v14++ )
      {
        if ( ++v15 > v6 )
        {
          v4 = v46;
          goto LABEL_23;
        }
      }
      v4 = v46;
      v3 = v60;
      v45 = v49;
      a2[1] = v49;
    }
  }
LABEL_28:
  if ( v3 < v4 )
  {
    v50 = v3;
    if ( v3 <= v4 )
    {
      v18 = 2 * (v5 + 32 * v3);
      while ( 1 )
      {
        v19 = v44;
        if ( v44 <= v45 )
          break;
LABEL_37:
        v18 += 64;
        if ( ++v50 > v46 )
          goto LABEL_40;
      }
      v20 = (_DWORD *)(v54 + 4 * v44);
      while ( 1 )
      {
        v21 = v5;
        v22 = (_WORD *)(v18 + *v20);
        if ( v47 <= v6 )
          break;
LABEL_36:
        v5 = v47;
        ++v19;
        ++v20;
        if ( v19 > v45 )
          goto LABEL_37;
      }
      while ( !*v22++ )
      {
        if ( ++v21 > v6 )
          goto LABEL_36;
      }
      v5 = v47;
      v60 = v50;
      a2[2] = v50;
LABEL_40:
      v4 = v46;
      v3 = v60;
    }
    if ( v4 > v3 )
    {
      v51 = v4;
      v24 = 2 * (v5 + 32 * v4);
      while ( 1 )
      {
        v25 = v44;
        if ( v44 <= v45 )
          break;
LABEL_49:
        v24 -= 64;
        if ( --v51 < v60 )
          goto LABEL_52;
      }
      v26 = (_DWORD *)(v54 + 4 * v44);
      while ( 1 )
      {
        v27 = (_WORD *)(*v26 + v24);
        v28 = v5;
        if ( v47 <= v6 )
          break;
LABEL_48:
        v5 = v47;
        ++v25;
        ++v26;
        if ( v25 > v45 )
          goto LABEL_49;
      }
      while ( !*v27++ )
      {
        if ( ++v28 > v6 )
          goto LABEL_48;
      }
      v5 = v47;
      v46 = v51;
      a2[3] = v51;
    }
  }
LABEL_52:
  if ( v5 < v6 )
  {
    v30 = v5;
    v52 = v5;
    if ( v5 <= v6 )
    {
      while ( 1 )
      {
        v31 = v44;
        if ( v44 <= v45 )
          break;
LABEL_61:
        v52 = ++v30;
        if ( v30 > v6 )
          goto LABEL_64;
      }
      v32 = 2 * (v30 + 32 * v60);
      v33 = (_DWORD *)(v54 + 4 * v44);
      while ( 1 )
      {
        v34 = v60;
        v35 = (_WORD *)(v32 + *v33);
        if ( v60 <= v46 )
          break;
LABEL_59:
        ++v31;
        ++v33;
        if ( v31 > v45 )
        {
          v6 = v56;
          v30 = v52;
          goto LABEL_61;
        }
      }
      while ( !*v35 )
      {
        ++v34;
        v35 += 32;
        if ( v34 > v46 )
          goto LABEL_59;
      }
      v5 = v52;
      v6 = v56;
      v47 = v52;
      a2[4] = v52;
    }
LABEL_64:
    if ( v6 > v5 )
    {
      v36 = v6;
      do
      {
        if ( v44 <= v45 )
          JUMPOUT(0x49A2D0);
        --v36;
      }
      while ( v36 >= v5 );
    }
  }
  v37 = v6 - v5;
  a2[6] = 16 * (v45 - v44) * 16 * (v45 - v44) + 12 * (v46 - v60) * 12 * (v46 - v60) + 8 * v37 * 8 * v37;
  result = v44;
  v39 = 0;
  if ( v44 > v45 )
  {
    a2[7] = 0;
  }
  else
  {
    v53 = v45 - v44 + 1;
    v59 = (_DWORD *)(v54 + 4 * v44);
    do
    {
      if ( v60 <= v46 )
      {
        v40 = *v59 + 2 * (v47 + 32 * v60);
        v55 = v46 - v60 + 1;
        do
        {
          v41 = (_WORD *)v40;
          if ( v47 <= v56 )
          {
            v42 = v37 + 1;
            do
            {
              if ( *v41 )
                ++v39;
              ++v41;
              --v42;
            }
            while ( v42 );
          }
          v40 += 64;
          --v55;
        }
        while ( v55 );
      }
      result = v53 - 1;
      v43 = v53 == 1;
      ++v59;
      --v53;
    }
    while ( !v43 );
    a2[7] = v39;
  }
  return result;
}
// 49A2CE: control flows out of bounds to 49A2D0

//----- (0049A400) --------------------------------------------------------
int __cdecl sub_49A400(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int v6; // ecx
  _DWORD *v7; // esi
  int *v8; // eax
  int *v9; // ecx
  int v10; // ebp
  int v11; // edi
  int v12; // ebp
  int v13; // eax
  int v14; // eax
  int v15; // eax
  bool v16; // cc
  int v18; // [esp+10h] [ebp-4h]

  v4 = a4;
  v5 = a3;
  if ( a3 < a4 )
  {
    v18 = 2 * a3;
    v6 = a2;
    v7 = (_DWORD *)(32 * a3 + a2 + 12);
    while ( 1 )
    {
      v8 = v18 > v4 ? sub_49A580(v6, v5) : sub_49A540(v6, v5);
      v9 = v8;
      if ( !v8 )
        break;
      *(v7 - 2) = v8[1];
      *v7 = v8[3];
      v7[2] = v8[5];
      *(v7 - 3) = *v8;
      *(v7 - 1) = v8[2];
      v7[1] = v8[4];
      v10 = 1;
      v11 = 12 * (v8[3] - v8[2]);
      if ( 16 * (v8[1] - *v8) > v11 )
      {
        v11 = 16 * (v8[1] - *v8);
        v10 = 0;
      }
      if ( 8 * (v8[5] - v8[4]) > v11 )
        v10 = 2;
      if ( v10 )
      {
        v12 = v10 - 1;
        if ( v12 )
        {
          if ( v12 == 1 )
          {
            v13 = (v8[5] + v8[4]) / 2;
            v9[5] = v13;
            v7[1] = v13 + 1;
          }
        }
        else
        {
          v14 = (v8[2] + v8[3]) / 2;
          v9[3] = v14;
          *(v7 - 1) = v14 + 1;
        }
      }
      else
      {
        v15 = (v8[1] + *v8) / 2;
        v9[1] = v15;
        *(v7 - 3) = v15 + 1;
      }
      sub_499FB0(a1, v9);
      sub_499FB0(a1, v7 - 3);
      v4 = a4;
      v5 = a3 + 1;
      v7 += 8;
      v16 = ++a3 < a4;
      v18 += 2;
      if ( !v16 )
        break;
      v6 = a2;
    }
  }
  return v5;
}

//----- (0049A540) --------------------------------------------------------
int *__cdecl sub_49A540(int a1, int a2)
{
  int v2; // esi
  int *result; // eax
  int *v4; // ecx
  int v5; // edi

  v2 = 0;
  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a1 + 28);
    v5 = a2;
    do
    {
      if ( *v4 > v2 && *(v4 - 1) > 0 )
      {
        result = v4 - 7;
        v2 = *v4;
      }
      v4 += 8;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (0049A580) --------------------------------------------------------
int *__cdecl sub_49A580(int a1, int a2)
{
  int v2; // esi
  int *result; // eax
  int *v4; // ecx
  int v5; // edi

  v2 = 0;
  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a1 + 24);
    v5 = a2;
    do
    {
      if ( *v4 > v2 )
      {
        result = v4 - 6;
        v2 = *v4;
      }
      v4 += 8;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (0049A5B0) --------------------------------------------------------
int __cdecl sub_49A5B0(int a1, int *a2, int a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // ecx
  int v6; // esi
  int v7; // ebp
  int v8; // eax
  int v9; // edx
  unsigned __int16 *v10; // ebx
  int v11; // eax
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  bool v15; // zf
  int result; // eax
  int v17; // [esp+10h] [ebp-30h]
  int v18; // [esp+14h] [ebp-2Ch]
  int v19; // [esp+18h] [ebp-28h]
  int v20; // [esp+1Ch] [ebp-24h]
  int v21; // [esp+20h] [ebp-20h]
  unsigned __int16 *v22; // [esp+24h] [ebp-1Ch]
  int v23; // [esp+28h] [ebp-18h]
  int v24; // [esp+2Ch] [ebp-14h]
  int v25; // [esp+30h] [ebp-10h]
  int v26; // [esp+34h] [ebp-Ch]
  int v27; // [esp+3Ch] [ebp-4h]
  _DWORD *v28; // [esp+48h] [ebp+8h]

  v3 = a1;
  v4 = 0;
  v18 = 0;
  v5 = a2[1];
  v6 = a2[2];
  v7 = a2[4];
  v25 = a2[3];
  v8 = *a2;
  v19 = 0;
  v20 = 0;
  v27 = v6;
  v26 = v7;
  v21 = a2[5];
  if ( *a2 <= v5 )
  {
    v17 = 8 * v8 + 4;
    v24 = v5 - v8 + 1;
    v28 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 424) + 24) + 4 * v8);
    do
    {
      if ( v6 <= v25 )
      {
        v9 = 4 * v6 + 2;
        v10 = (unsigned __int16 *)(*v28 + 2 * (v7 + 32 * v6));
        v11 = v25 - v6 + 1;
        v22 = v10;
        v23 = v11;
        do
        {
          if ( v7 <= v21 )
          {
            v12 = 8 * v7 + 4;
            v13 = v21 - v7 + 1;
            do
            {
              v14 = *v10++;
              if ( (_WORD)v14 )
              {
                v18 += v14 * v17;
                v4 += v14;
                v19 += v14 * v9;
                v7 = v26;
                v20 += v14 * v12;
              }
              v12 += 8;
              --v13;
            }
            while ( v13 );
            v11 = v23;
            v6 = v27;
          }
          v9 += 4;
          v10 = v22 + 32;
          --v11;
          v22 += 32;
          v23 = v11;
        }
        while ( v11 );
        v3 = a1;
      }
      v15 = v24 == 1;
      ++v28;
      v17 += 8;
      --v24;
    }
    while ( !v15 );
  }
  *(_BYTE *)(**(_DWORD **)(v3 + 116) + a3) = ((v4 >> 1) + v18) / v4;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 4) + a3) = ((v4 >> 1) + v19) / v4;
  result = ((v4 >> 1) + v20) / v4;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 8) + a3) = result;
  return result;
}

//----- (0049A750) --------------------------------------------------------
int __cdecl sub_49A750(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(*(_DWORD *)(a1 + 424) + 28) = 1;
  return result;
}

//----- (0049A760) --------------------------------------------------------
int __cdecl sub_49A760(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 88);
  a1[106] = v1;
  *v1 = sub_49AC10;
  v1[2] = nullsub_16;
  v1[3] = sub_49B390;
  v1[17] = 0;
  v1[13] = 0;
  if ( (int)a1[25] > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[21] > 256 )
  {
    *(_DWORD *)(*a1 + 20) = 57;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  sub_49A800(a1);
  sub_49AA70(a1);
  result = a1[19];
  if ( result == 2 )
    result = sub_49ABD0(a1);
  return result;
}
// 49B380: using guessed type int nullsub_16();

//----- (0049A800) --------------------------------------------------------
int __cdecl sub_49A800(_DWORD *a1)
{
  _DWORD *v2; // edi
  int *v3; // esi
  int v4; // ebp
  _DWORD *v5; // eax
  int v6; // ecx
  int result; // eax
  _DWORD *v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // eax
  char v12; // al
  int i; // edx
  int v14; // ecx
  int v15; // ebp
  bool v16; // cc
  int v17; // [esp+10h] [ebp-20h]
  int *v18; // [esp+14h] [ebp-1Ch]
  int v19; // [esp+18h] [ebp-18h]
  int v20; // [esp+1Ch] [ebp-14h]
  int v21; // [esp+20h] [ebp-10h]
  int v22; // [esp+24h] [ebp-Ch]
  int v23; // [esp+28h] [ebp-8h]
  _DWORD *v24; // [esp+2Ch] [ebp-4h]
  int v25; // [esp+34h] [ebp+4h]

  v2 = (_DWORD *)a1[106];
  v24 = v2;
  v3 = v2 + 8;
  v4 = sub_49A960(a1, v2 + 8);
  v21 = v4;
  if ( a1[25] == 3 )
  {
    v5 = (_DWORD *)*a1;
    v5[6] = v4;
    v5 += 6;
    v5[1] = *v3;
    v5[2] = v2[9];
    v5[3] = v2[10];
    *(_DWORD *)(*a1 + 20) = 94;
  }
  else
  {
    *(_DWORD *)(*a1 + 20) = 95;
    *(_DWORD *)(*a1 + 24) = v4;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v6 = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v4, a1[25]);
  result = v4;
  v23 = v6;
  v20 = v4;
  v17 = 0;
  if ( (int)a1[25] <= 0 )
  {
    v2[4] = v6;
    v2[5] = v4;
  }
  else
  {
    v8 = (_DWORD *)v6;
    v18 = v3;
    do
    {
      v9 = *v18;
      v22 = *v18;
      v10 = result / *v18;
      v11 = 0;
      v19 = 0;
      if ( *v18 > 0 )
      {
        v25 = 0;
        do
        {
          v12 = sub_49AA50((int)a1, v17, v11, v9 - 1);
          for ( i = v25; i < v4; i += v20 )
          {
            v14 = 0;
            if ( v10 > 0 )
            {
              do
              {
                v15 = v14 + *v8;
                ++v14;
                *(_BYTE *)(i + v15) = v12;
              }
              while ( v14 < v10 );
              v4 = v21;
            }
          }
          v11 = v19 + 1;
          v25 += v10;
          v9 = v22;
          ++v19;
        }
        while ( v19 < v22 );
      }
      ++v18;
      result = v10;
      ++v8;
      v16 = v17 + 1 < a1[25];
      v20 = v10;
      ++v17;
    }
    while ( v16 );
    result = (int)v24;
    v24[5] = v4;
    v24[4] = v23;
  }
  return result;
}

//----- (0049A960) --------------------------------------------------------
int __cdecl sub_49A960(_DWORD *a1, void *a2)
{
  int v2; // ebp
  signed int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // ebx
  signed int v8; // edx
  signed int v9; // ebp
  int v10; // esi
  int v11; // edi
  char v13; // [esp+13h] [ebp-Dh]
  signed int *v14; // [esp+14h] [ebp-Ch]
  signed int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]

  v2 = 1;
  v3 = a1[25];
  v15 = v3;
  v16 = a1[21];
  do
  {
    v4 = ++v2;
    if ( v3 > 1 )
    {
      v5 = v3 - 1;
      do
      {
        v4 *= v2;
        --v5;
      }
      while ( v5 );
    }
  }
  while ( v4 <= a1[21] );
  v6 = v2 - 1;
  if ( v6 < 2 )
  {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = v4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v7 = 1;
  if ( v3 > 0 )
  {
    v8 = v3;
    memset32(a2, v6, v3);
    do
    {
      v7 *= v6;
      --v8;
    }
    while ( v8 );
  }
  while ( 2 )
  {
    v9 = 0;
    v13 = 0;
    if ( v3 > 0 )
    {
      v14 = (signed int *)&unk_4B0EC0;
      while ( 1 )
      {
        v10 = a1[11] == 2 ? *v14 : v9;
        v11 = *((_DWORD *)a2 + v10);
        if ( (v11 + 1) * (v7 / v11) > v16 )
          break;
        v7 = (v11 + 1) * (v7 / v11);
        ++v9;
        *((_DWORD *)a2 + v10) = v11 + 1;
        v13 = 1;
        ++v14;
        if ( v9 >= v15 )
          goto LABEL_12;
      }
      if ( v13 )
      {
LABEL_12:
        v3 = v15;
        continue;
      }
    }
    return v7;
  }
}

//----- (0049AA50) --------------------------------------------------------
int __cdecl sub_49AA50(int a1, int a2, int a3, int a4)
{
  return (255 * a3 + a4 / 2) / a4;
}

//----- (0049AA70) --------------------------------------------------------
int __cdecl sub_49AA70(_DWORD *a1)
{
  int v1; // esi
  int v2; // ebx
  int result; // eax
  int v4; // edi
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  int v8; // ebp
  int v9; // ecx
  int i; // esi
  int v11; // eax
  _BYTE *v12; // esi
  int v13; // [esp+Ch] [ebp-14h]
  int *v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  _BYTE *v16; // [esp+18h] [ebp-8h]
  int v17; // [esp+1Ch] [ebp-4h]

  v1 = (int)a1;
  v2 = a1[106];
  v17 = v2;
  if ( a1[19] == 1 )
  {
    v13 = 510;
    *(_BYTE *)(v2 + 28) = 1;
  }
  else
  {
    v13 = 0;
    *(_BYTE *)(v2 + 28) = 0;
  }
  *(_DWORD *)(v2 + 24) = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v13 + 256, a1[25]);
  result = *(_DWORD *)(v2 + 20);
  v4 = 0;
  if ( (int)a1[25] > 0 )
  {
    v14 = (int *)(v2 + 32);
    while ( 1 )
    {
      v5 = *v14;
      v15 = result / *v14;
      if ( v13 )
        *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4 * v4) += 255;
      v6 = *(_DWORD *)(v2 + 24);
      v7 = 0;
      v8 = v5 - 1;
      v16 = *(_BYTE **)(v6 + 4 * v4);
      v9 = sub_49ABB0(v1, v4, 0, v8);
      for ( i = 0; i <= 255; ++i )
      {
        for ( ; i > v9; v9 = sub_49ABB0((int)a1, v4, v7, v8) )
          ++v7;
        v16[i] = v7 * v15;
      }
      if ( v13 )
      {
        v11 = 1;
        v12 = v16 - 1;
        do
        {
          ++v11;
          *v12 = *v16;
          v16[v11 + 254] = v16[255];
          --v12;
        }
        while ( v11 <= 255 );
      }
      result = (int)a1;
      ++v4;
      ++v14;
      if ( v4 >= a1[25] )
        break;
      result = v15;
      v2 = v17;
      v1 = (int)a1;
    }
  }
  return result;
}

//----- (0049ABB0) --------------------------------------------------------
int __cdecl sub_49ABB0(int a1, int a2, int a3, int a4)
{
  return (a4 + 510 * a3 + 255) / (2 * a4);
}

//----- (0049ABD0) --------------------------------------------------------
int __cdecl sub_49ABD0(_DWORD *a1)
{
  int v1; // edi
  int result; // eax
  int v3; // ebp
  _DWORD *v4; // ebx

  v1 = 0;
  result = a1[106];
  v3 = 2 * a1[23] + 4;
  if ( (int)a1[25] > 0 )
  {
    v4 = (_DWORD *)(result + 68);
    do
    {
      *v4 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v3);
      result = a1[25];
      ++v1;
      ++v4;
    }
    while ( v1 < result );
  }
  return result;
}

//----- (0049AC10) --------------------------------------------------------
int __cdecl sub_49AC10(_DWORD *a1)
{
  int v1; // edi
  int result; // eax
  int v3; // eax
  int v4; // eax
  void **v5; // ebx
  int v6; // edi
  unsigned int i; // ebp
  char v8; // al

  v1 = a1[106];
  a1[29] = *(_DWORD *)(v1 + 16);
  result = a1[19];
  a1[28] = *(_DWORD *)(v1 + 20);
  if ( result )
  {
    v3 = result - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v4 = *(_DWORD *)(v1 + 68);
        v5 = (void **)(v1 + 68);
        *(_DWORD *)(v1 + 4) = sub_49B1B0;
        *(_BYTE *)(v1 + 84) = 0;
        if ( !v4 )
          sub_49ABD0(a1);
        result = a1[25];
        v6 = 0;
        for ( i = 2 * a1[23] + 4; v6 < result; ++v5 )
        {
          sub_493F70(*v5, i);
          result = a1[25];
          ++v6;
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 48;
        result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      if ( a1[25] == 3 )
        *(_DWORD *)(v1 + 4) = sub_49B080;
      else
        *(_DWORD *)(v1 + 4) = sub_49AF50;
      v8 = *(_BYTE *)(v1 + 28);
      *(_DWORD *)(v1 + 48) = 0;
      if ( !v8 )
        sub_49AA70(a1);
      result = *(_DWORD *)(v1 + 52);
      if ( !result )
        result = sub_49AD00((int)a1);
    }
  }
  else if ( a1[25] == 3 )
  {
    *(_DWORD *)(v1 + 4) = sub_49AE90;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_49ADD0;
  }
  return result;
}

//----- (0049AD00) --------------------------------------------------------
int __cdecl sub_49AD00(int a1)
{
  int result; // eax
  int v2; // ebp
  int v3; // esi
  int *v4; // edi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax

  result = *(_DWORD *)(a1 + 100);
  v2 = *(_DWORD *)(a1 + 424);
  v3 = 0;
  if ( result > 0 )
  {
    v4 = (int *)(v2 + 52);
    do
    {
      v5 = 0;
      if ( v3 <= 0 )
        goto LABEL_9;
      v6 = (_DWORD *)(v2 + 32);
      while ( *(v4 - 5) != *v6 )
      {
        ++v5;
        ++v6;
        if ( v5 >= v3 )
          goto LABEL_9;
      }
      v7 = *(_DWORD *)(v2 + 4 * v5 + 52);
      if ( !v7 )
LABEL_9:
        v7 = sub_49AD60(a1, *(v4 - 5));
      *v4 = v7;
      result = *(_DWORD *)(a1 + 100);
      ++v3;
      ++v4;
    }
    while ( v3 < result );
  }
  return result;
}

//----- (0049AD60) --------------------------------------------------------
int __cdecl sub_49AD60(int a1, int a2)
{
  int v2; // ebp
  unsigned __int8 *v3; // edi
  int v4; // esi
  int i; // ecx
  int v6; // eax

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3 = (unsigned __int8 *)&unk_4B0DC0;
  v4 = v2;
  do
  {
    for ( i = 0; i < 16; ++i )
    {
      v4 += 4;
      v6 = (65025 - 510 * v3[i]) / ((a2 << 9) - 512);
      *(_DWORD *)(v4 - 4) = v6;
    }
    v3 += 16;
  }
  while ( (int)v3 < (int)&unk_4B0EC0 );
  return v2;
}

//----- (0049ADD0) --------------------------------------------------------
int __cdecl sub_49ADD0(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  int result; // eax
  _DWORD *v7; // edx
  int v8; // ebx
  unsigned __int8 *v9; // esi
  char v10; // cl
  int *v11; // eax
  int v12; // ebx
  bool v13; // zf
  int *v14; // [esp+8h] [ebp-10h]
  int v15; // [esp+Ch] [ebp-Ch]
  int v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]
  _BYTE *v18; // [esp+1Ch] [ebp+4h]
  int v19; // [esp+20h] [ebp+8h]
  int v20; // [esp+28h] [ebp+10h]

  v4 = a1[23];
  v5 = a1[25];
  result = a4;
  v17 = v4;
  v14 = *(int **)(a1[106] + 24);
  v15 = v5;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a2 - (_DWORD)a3;
    v16 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v7 + v8);
      v18 = (_BYTE *)*v7;
      if ( v4 )
      {
        v20 = v4;
        do
        {
          v10 = 0;
          if ( v5 > 0 )
          {
            v11 = v14;
            do
            {
              v12 = *v11++;
              v10 += *(_BYTE *)(v12 + *v9++);
              --v5;
            }
            while ( v5 );
            v5 = v15;
          }
          *v18++ = v10;
          --v20;
        }
        while ( v20 );
        v8 = v16;
        v7 = a3;
        v4 = v17;
      }
      ++v7;
      result = v19 - 1;
      v13 = v19 == 1;
      a3 = v7;
      --v19;
    }
    while ( !v13 );
  }
  return result;
}

//----- (0049AE90) --------------------------------------------------------
int __cdecl sub_49AE90(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // edi
  int *v5; // eax
  int result; // eax
  _DWORD *v7; // ecx
  int v8; // edx
  unsigned __int8 *v9; // eax
  _BYTE *v10; // esi
  int v11; // edx
  unsigned __int8 *v12; // eax
  char v13; // cl
  char v14; // bl
  bool v15; // zf
  int v16; // [esp+4h] [ebp-10h]
  int v17; // [esp+8h] [ebp-Ch]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]
  _DWORD *v20; // [esp+18h] [ebp+4h]
  int v21; // [esp+20h] [ebp+Ch]

  v4 = *(_DWORD *)(a1 + 92);
  v19 = v4;
  v5 = *(int **)(*(_DWORD *)(a1 + 424) + 24);
  v16 = *v5;
  v17 = v5[1];
  v18 = v5[2];
  result = a4;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a2 - (_DWORD)a3;
    v20 = a3;
    v21 = a2 - (_DWORD)a3;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v7 + v8);
      v10 = (_BYTE *)*v7;
      if ( v4 )
      {
        do
        {
          v11 = *v9;
          v12 = v9 + 1;
          v13 = *(_BYTE *)(*v12++ + v17) + *(_BYTE *)(v11 + v16);
          v14 = *(_BYTE *)(*v12 + v18);
          v9 = v12 + 1;
          *v10++ = v14 + v13;
          --v4;
        }
        while ( v4 );
        v4 = v19;
        v7 = v20;
        v8 = v21;
      }
      ++v7;
      result = a4 - 1;
      v15 = a4 == 1;
      v20 = v7;
      --a4;
    }
    while ( !v15 );
  }
  return result;
}

//----- (0049AF50) --------------------------------------------------------
int __cdecl sub_49AF50(_DWORD *a1, int a2, void **a3, int a4)
{
  _DWORD *v4; // edi
  int result; // eax
  void **v6; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // esi
  int v10; // ebp
  _BYTE *v11; // ecx
  unsigned __int8 *v12; // eax
  int v13; // edi
  int v14; // esi
  bool v15; // zf
  int v16; // [esp+4h] [ebp-1Ch]
  _DWORD *v17; // [esp+8h] [ebp-18h]
  void **v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  char v22; // [esp+1Ch] [ebp-4h]
  unsigned int v23; // [esp+24h] [ebp+4h]
  int v24; // [esp+28h] [ebp+8h]
  unsigned int v25; // [esp+2Ch] [ebp+Ch]
  _DWORD *v26; // [esp+30h] [ebp+10h]

  v4 = (_DWORD *)a1[106];
  result = a4;
  v17 = v4;
  v16 = a1[25];
  v23 = a1[23];
  if ( a4 > 0 )
  {
    v6 = a3;
    v18 = a3;
    v21 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      sub_493F70(*v6, v23);
      v7 = v4[12];
      v8 = 0;
      v22 = v7;
      v24 = 0;
      if ( v16 > 0 )
      {
        v9 = v7 << 6;
        v20 = v9;
        v26 = v4 + 13;
        while ( 1 )
        {
          v10 = *(_DWORD *)(v4[6] + 4 * v8);
          v11 = *v6;
          v12 = (unsigned __int8 *)(*(char **)((char *)v6 + v21) + v8);
          v13 = v9 + *v26;
          v14 = 0;
          if ( v23 )
          {
            v25 = v23;
            do
            {
              *v11 += *(_BYTE *)(*v12 + *(_DWORD *)(v13 + 4 * v14) + v10);
              v12 += v16;
              ++v11;
              v14 = ((_BYTE)v14 + 1) & 0xF;
              --v25;
            }
            while ( v25 );
            v8 = v24;
            v6 = v18;
          }
          v24 = ++v8;
          ++v26;
          if ( v8 >= v16 )
            break;
          v9 = v20;
          v4 = v17;
        }
        v4 = v17;
        LOBYTE(v7) = v22;
      }
      ++v6;
      result = v19 - 1;
      v15 = v19 == 1;
      v4[12] = ((_BYTE)v7 + 1) & 0xF;
      v18 = v6;
      --v19;
    }
    while ( !v15 );
  }
  return result;
}

//----- (0049B080) --------------------------------------------------------
int __cdecl sub_49B080(int a1, int a2, _BYTE **a3, int a4)
{
  _DWORD *v4; // edx
  int *v5; // eax
  int v6; // esi
  int result; // eax
  _BYTE **v8; // ebx
  int v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // edi
  int v12; // ebp
  int v13; // esi
  int v14; // ebx
  unsigned __int8 *v15; // eax
  char v16; // dl
  char v17; // cl
  bool v18; // zf
  int v19; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  _DWORD *v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+24h] [ebp-4h]
  _BYTE *v28; // [esp+2Ch] [ebp+4h]
  int v29; // [esp+30h] [ebp+8h]
  int v30; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD **)(a1 + 424);
  v20 = *(_DWORD *)(a1 + 92);
  v5 = (int *)v4[6];
  v26 = v4;
  v22 = *v5;
  v6 = v5[1];
  result = v5[2];
  v23 = v6;
  v25 = result;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v19 = a2 - (_DWORD)a3;
    v29 = a4;
    while ( 1 )
    {
      v27 = v4[12];
      v10 = *(_BYTE **)((char *)v8 + v9);
      v28 = *v8;
      v11 = (v27 << 6) + v4[13];
      v12 = (v27 << 6) + v4[14];
      v24 = (v27 << 6) + v4[15];
      v13 = 0;
      v21 = v12;
      if ( v20 )
      {
        v30 = v20;
        while ( 1 )
        {
          v14 = *v10 + *(_DWORD *)(v11 + 4 * v13);
          v15 = v10 + 1;
          v16 = *(_BYTE *)(*v15++ + *(_DWORD *)(v12 + 4 * v13) + v23);
          v17 = *(_BYTE *)(*v15 + *(_DWORD *)(v24 + 4 * v13) + v25) + v16 + *(_BYTE *)(v14 + v22);
          v10 = v15 + 1;
          *v28 = v17;
          v13 = ((_BYTE)v13 + 1) & 0xF;
          v18 = v30 == 1;
          ++v28;
          --v30;
          if ( v18 )
            break;
          v12 = v21;
        }
        v4 = v26;
        v8 = a3;
      }
      a3 = ++v8;
      v4[12] = ((_BYTE)v27 + 1) & 0xF;
      result = --v29;
      if ( !v29 )
        break;
      v9 = v19;
    }
  }
  return result;
}

//----- (0049B1B0) --------------------------------------------------------
int __cdecl sub_49B1B0(_DWORD *a1, int a2, void **a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // edx
  int result; // eax
  void **v8; // edi
  int v9; // edx
  _BYTE *v10; // ebp
  unsigned __int8 *v11; // ecx
  int v12; // edi
  _WORD *v13; // esi
  int v14; // eax
  __int16 v15; // bx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  bool v20; // zf
  int v21; // [esp+8h] [ebp-30h]
  void **v22; // [esp+Ch] [ebp-2Ch]
  __int16 v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  unsigned int v25; // [esp+18h] [ebp-20h]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+24h] [ebp-14h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+2Ch] [ebp-Ch]
  int v31; // [esp+30h] [ebp-8h]
  int v32; // [esp+34h] [ebp-4h]
  unsigned int v33; // [esp+3Ch] [ebp+4h]
  __int16 v34; // [esp+40h] [ebp+8h]
  unsigned __int8 *v35; // [esp+44h] [ebp+Ch]
  _DWORD *v36; // [esp+48h] [ebp+10h]

  v4 = a1[106];
  v5 = a1[25];
  v6 = a1[72];
  result = a4;
  v27 = v4;
  v21 = v5;
  v33 = a1[23];
  v30 = v6;
  if ( a4 > 0 )
  {
    v8 = a3;
    v22 = a3;
    v29 = a2 - (_DWORD)a3;
    v28 = a4;
    do
    {
      sub_493F70(*v8, v33);
      v9 = 0;
      v26 = 0;
      if ( v5 > 0 )
      {
        v36 = (_DWORD *)(v4 + 68);
        do
        {
          v10 = *v8;
          v11 = (unsigned __int8 *)(*(char **)((char *)v8 + v29) + v9);
          v35 = v11;
          if ( *(_BYTE *)(v4 + 84) )
          {
            v10 += v33 - 1;
            v11 += v5 * (v33 - 1);
            v12 = -1;
            v24 = -v5;
            v35 = v11;
            v13 = (_WORD *)(*v36 + 2 * v33 + 2);
          }
          else
          {
            v24 = v5;
            v12 = 1;
            v13 = (_WORD *)*v36;
          }
          v31 = *(_DWORD *)(*(_DWORD *)(v4 + 24) + 4 * v9);
          v14 = *(_DWORD *)(v4 + 16);
          v15 = 0;
          v34 = 0;
          v32 = *(_DWORD *)(v14 + 4 * v9);
          v16 = 0;
          v23 = 0;
          if ( v33 )
          {
            v25 = v33;
            do
            {
              v17 = *(unsigned __int8 *)(*v11 + (((__int16)v13[v12] + v16 + 8) >> 4) + v30);
              v18 = *(unsigned __int8 *)(v17 + v31);
              *v10 += v18;
              v10 += v12;
              v19 = v17 - *(unsigned __int8 *)(v18 + v32);
              *v13 = 3 * v19 + v34;
              v15 = 5 * v19 + v23;
              v23 = v19;
              v16 = 7 * v19;
              v34 = v15;
              v11 = &v35[v24];
              v20 = v25 == 1;
              v35 += v24;
              v13 += v12;
              --v25;
            }
            while ( !v20 );
            v9 = v26;
          }
          v8 = v22;
          ++v9;
          *v13 = v15;
          v4 = v27;
          v26 = v9;
          ++v36;
          v5 = v21;
        }
        while ( v9 < v21 );
      }
      *(_BYTE *)(v4 + 84) = *(_BYTE *)(v4 + 84) == 0;
      ++v8;
      result = v28 - 1;
      v20 = v28 == 1;
      v22 = v8;
      --v28;
    }
    while ( !v20 );
  }
  return result;
}

//----- (0049B390) --------------------------------------------------------
int __cdecl sub_49B390(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

//----- (0049B3B0) --------------------------------------------------------
int (__cdecl **__cdecl sub_49B3B0(int a1, char a2))(int a1, int a2)
{
  int (__cdecl **result)(int, int); // eax
  int v3; // ebp
  _DWORD *v4; // edi
  _DWORD *v5; // ebx

  result = (int (__cdecl **)(int, int))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 320) = result;
  *result = sub_49B440;
  if ( !*(_BYTE *)(a1 + 176) )
  {
    if ( a2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (int (__cdecl **)(int, int))(**(int (__cdecl ***)(int))a1)(a1);
    }
    else
    {
      v3 = 0;
      if ( *(int *)(a1 + 60) > 0 )
      {
        v4 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 28);
        v5 = result + 6;
        do
        {
          *v5 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, 8 * *v4, 8 * *(v4 - 4));
          result = *(int (__cdecl ***)(int, int))(a1 + 60);
          ++v3;
          ++v5;
          v4 += 21;
        }
        while ( v3 < (int)result );
      }
    }
  }
  return result;
}

//----- (0049B440) --------------------------------------------------------
int __cdecl sub_49B440(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 320);
  if ( !*(_BYTE *)(a1 + 176) )
  {
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(_BYTE *)(result + 16) = 0;
    *(_DWORD *)(result + 20) = a2;
    if ( a2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (**(int (__cdecl ***)(int))a1)(a1);
    }
    else
    {
      *(_DWORD *)(result + 4) = sub_49B490;
    }
  }
  return result;
}

//----- (0049B490) --------------------------------------------------------
char __cdecl sub_49B490(_DWORD *a1, int a2, unsigned int *a3, int a4)
{
  int v4; // esi
  unsigned int v5; // eax
  unsigned int *v6; // ebp
  bool v7; // zf
  unsigned int v8; // edx

  v4 = a1[80];
  v5 = *(_DWORD *)(v4 + 8);
  if ( v5 < a1[56] )
  {
    v6 = (unsigned int *)(v4 + 12);
    do
    {
      v7 = *v6 == 8;
      if ( *v6 < 8 )
      {
        (*(void (__cdecl **)(_DWORD *, int, unsigned int *, int, int, int, int))(a1[81] + 4))(
          a1,
          a2,
          a3,
          a4,
          v4 + 24,
          v4 + 12,
          8);
        v5 = *v6;
        v7 = *v6 == 8;
      }
      if ( !v7 )
        break;
      v7 = (*(unsigned __int8 (__cdecl **)(_DWORD *, int))(a1[82] + 4))(a1, v4 + 24) == 0;
      LOBYTE(v5) = *(_BYTE *)(v4 + 16);
      if ( v7 )
      {
        if ( !(_BYTE)v5 )
        {
          v5 = *a3 - 1;
          *a3 = v5;
          *(_BYTE *)(v4 + 16) = 1;
        }
        return v5;
      }
      if ( (_BYTE)v5 )
      {
        ++*a3;
        *(_BYTE *)(v4 + 16) = 0;
      }
      v8 = *(_DWORD *)(v4 + 8);
      *v6 = 0;
      *(_DWORD *)(v4 + 8) = ++v8;
      LOBYTE(v5) = v8;
    }
    while ( v8 < a1[56] );
  }
  return v5;
}

//----- (0049B540) --------------------------------------------------------
int __cdecl sub_49B540(int a1, char a2)
{
  _DWORD *v2; // ebx
  int result; // eax
  int *v4; // esi
  _DWORD *v5; // ebx
  int v6; // ebp
  int v7; // eax
  int *v8; // ecx
  int v9; // edx
  int v10; // [esp-10h] [ebp-18h]
  int v11; // [esp+10h] [ebp+8h]

  v2 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 104);
  *(_DWORD *)(a1 + 328) = v2;
  *v2 = sub_49B610;
  if ( a2 )
  {
    result = *(_DWORD *)(a1 + 68);
    v11 = 0;
    if ( *(int *)(a1 + 60) > 0 )
    {
      v4 = (int *)(result + 12);
      v5 = v2 + 16;
      do
      {
        v6 = *(_DWORD *)(a1 + 4);
        v10 = sub_493ED0(v4[5], *v4);
        v7 = sub_493ED0(v4[4], *(v4 - 1));
        *v5 = (*(int (__cdecl **)(int, int, _DWORD, int, int))(v6 + 20))(a1, 1, 0, v7, v10);
        result = v11 + 1;
        ++v5;
        v4 += 21;
        ++v11;
      }
      while ( v11 < *(_DWORD *)(a1 + 60) );
    }
  }
  else
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v8 = v2 + 6;
    v9 = 10;
    do
    {
      *v8++ = result;
      result += 128;
      --v9;
    }
    while ( v9 );
    v2[16] = 0;
  }
  return result;
}

//----- (0049B610) --------------------------------------------------------
int __cdecl sub_49B610(_DWORD *a1, int a2)
{
  _DWORD *v2; // edi
  int result; // eax

  v2 = (_DWORD *)a1[82];
  v2[2] = 0;
  sub_49B6C0(a1);
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      result = v2[16];
      if ( !result )
      {
        *(_DWORD *)(*a1 + 20) = 4;
        result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
      }
      v2[1] = sub_49BBC0;
    }
    else if ( a2 == 3 )
    {
      result = v2[16];
      if ( !result )
      {
        *(_DWORD *)(*a1 + 20) = 4;
        result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
      }
      v2[1] = sub_49B970;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 4;
      result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  else
  {
    result = v2[16];
    if ( result )
    {
      *(_DWORD *)(*a1 + 20) = 4;
      result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v2[1] = sub_49B710;
  }
  return result;
}

//----- (0049B6C0) --------------------------------------------------------
_DWORD *__cdecl sub_49B6C0(_DWORD *a1)
{
  int v1; // edx
  _DWORD *result; // eax
  int v3; // ecx

  v1 = 1;
  result = (_DWORD *)a1[82];
  if ( (int)a1[57] <= 1 )
  {
    v3 = a1[58];
    if ( result[2] < (unsigned int)(a1[56] - 1) )
    {
      result[5] = *(_DWORD *)(v3 + 12);
      result[3] = 0;
      result[4] = 0;
      return result;
    }
    v1 = *(_DWORD *)(v3 + 72);
  }
  result[5] = v1;
  result[3] = 0;
  result[4] = 0;
  return result;
}

//----- (0049B710) --------------------------------------------------------
char __cdecl sub_49B710(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // ebp
  unsigned int v4; // ecx
  int v5; // eax
  unsigned int v6; // ebx
  int v7; // edi
  _DWORD *v8; // esi
  _DWORD *v9; // esi
  int v10; // ebx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  _WORD **v14; // eax
  _WORD *v15; // ecx
  _WORD *v16; // edx
  bool v17; // cc
  int v18; // ecx
  char result; // al
  int v20; // [esp+10h] [ebp-28h]
  unsigned int v21; // [esp+14h] [ebp-24h]
  _WORD **v22; // [esp+18h] [ebp-20h]
  int v23; // [esp+18h] [ebp-20h]
  int v24; // [esp+1Ch] [ebp-1Ch]
  int v25; // [esp+20h] [ebp-18h]
  unsigned int v26; // [esp+24h] [ebp-14h]
  int v27; // [esp+28h] [ebp-10h]
  _DWORD *v28; // [esp+2Ch] [ebp-Ch]
  int v29; // [esp+30h] [ebp-8h]
  unsigned int v30; // [esp+34h] [ebp-4h]

  v2 = a1;
  v3 = (_DWORD *)a1[82];
  v4 = a1[62] - 1;
  v26 = v4;
  v30 = a1[56] - 1;
  v5 = v3[4];
  v20 = v5;
  if ( v5 >= v3[5] )
  {
LABEL_30:
    ++v3[2];
    sub_49B6C0(v2);
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v6 = v3[3];
      v21 = v6;
      if ( v6 <= v4 )
        break;
LABEL_29:
      v18 = v3[5];
      ++v5;
      v3[3] = 0;
      v20 = v5;
      if ( v5 >= v18 )
        goto LABEL_30;
      v4 = v26;
    }
    while ( 1 )
    {
      v7 = 0;
      v27 = 0;
      if ( (int)v2[57] > 0 )
      {
        v8 = v2 + 58;
        v28 = v8;
        do
        {
          v9 = (_DWORD *)*v8;
          if ( v6 >= v26 )
            v10 = v9[17];
          else
            v10 = v9[13];
          v11 = v21 * v9[16];
          v24 = 8 * v20;
          v29 = v11;
          v25 = 0;
          if ( (int)v9[14] > 0 )
          {
            while ( 1 )
            {
              if ( v3[2] < v30 || v20 + v25 < v9[18] )
              {
                (*(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD, int, int, int))(a1[86] + 4))(
                  a1,
                  v9,
                  *(_DWORD *)(a2 + 4 * v9[1]),
                  v3[v7 + 6],
                  v24,
                  v11,
                  v10);
                v13 = v9[13];
                if ( v10 < v13 )
                {
                  sub_493F70((void *)v3[v10 + 6 + v7], (v13 + 0x1FFFFFF * v10) << 7);
                  v23 = v10;
                  if ( v10 < v9[13] )
                  {
                    v14 = (_WORD **)&v3[v10 + 6 + v7];
                    do
                    {
                      v15 = *(v14 - 1);
                      v16 = *v14++;
                      *v16 = *v15;
                      ++v23;
                    }
                    while ( v23 < v9[13] );
                  }
                }
              }
              else
              {
                sub_493F70((void *)v3[v7 + 6], v9[13] << 7);
                v12 = 0;
                if ( (int)v9[13] > 0 )
                {
                  v22 = (_WORD **)&v3[v7 + 6];
                  do
                  {
                    ++v12;
                    **v22++ = *(_WORD *)v3[v7 + 5];
                  }
                  while ( v12 < v9[13] );
                }
              }
              v7 += v9[13];
              v24 += 8;
              if ( ++v25 >= v9[14] )
                break;
              v11 = v29;
            }
          }
          v6 = v21;
          v8 = v28 + 1;
          v17 = ++v27 < a1[57];
          ++v28;
        }
        while ( v17 );
        v2 = a1;
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(v2[87] + 4))(v2, v3 + 6) )
        break;
      v21 = ++v6;
      if ( v6 > v26 )
      {
        v5 = v20;
        goto LABEL_29;
      }
    }
    v3[4] = v20;
    v3[3] = v6;
    result = 0;
  }
  return result;
}

//----- (0049B970) --------------------------------------------------------
char __cdecl sub_49B970(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // edi
  _DWORD *v4; // esi
  unsigned int v5; // ebx
  int v6; // eax
  int v7; // ecx
  unsigned int v8; // ebx
  unsigned int v9; // ebp
  int v10; // edi
  _DWORD *v11; // ebp
  int v12; // esi
  _WORD *v13; // esi
  __int16 v14; // cx
  int v15; // eax
  bool v16; // zf
  unsigned int v17; // ebx
  void **v18; // ecx
  char *v19; // edi
  int v20; // ebx
  unsigned int v21; // ecx
  int v22; // ebp
  unsigned int v23; // ecx
  int v24; // edx
  __int16 v25; // si
  _WORD *v26; // eax
  bool v27; // cc
  int v29; // [esp+Ch] [ebp-30h]
  unsigned int v30; // [esp+Ch] [ebp-30h]
  _DWORD *v31; // [esp+10h] [ebp-2Ch]
  int v32; // [esp+14h] [ebp-28h]
  void **i; // [esp+14h] [ebp-28h]
  int v34; // [esp+18h] [ebp-24h]
  _DWORD *v35; // [esp+1Ch] [ebp-20h]
  int v37; // [esp+24h] [ebp-18h]
  int v38; // [esp+24h] [ebp-18h]
  unsigned int v39; // [esp+28h] [ebp-14h]
  int v40; // [esp+2Ch] [ebp-10h]
  int v41; // [esp+30h] [ebp-Ch]
  int v42; // [esp+34h] [ebp-8h]
  int v43; // [esp+38h] [ebp-4h]

  v2 = a1;
  v3 = a1[82];
  v4 = (_DWORD *)a1[17];
  v5 = a1[56] - 1;
  v40 = v3;
  v39 = v5;
  v42 = 0;
  v31 = v4;
  if ( (int)a1[15] > 0 )
  {
    v35 = (_DWORD *)(v3 + 64);
    while ( 1 )
    {
      v6 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(v2[1] + 32))(
             v2,
             *v35,
             *(_DWORD *)(v3 + 8) * v4[3],
             v4[3],
             1);
      v7 = v4[3];
      v41 = v6;
      if ( *(_DWORD *)(v3 + 8) >= v5 )
      {
        v29 = v4[8] % (unsigned int)v7;
        if ( !v29 )
          v29 = v4[3];
        v7 = v29;
      }
      else
      {
        v29 = v4[3];
      }
      v8 = v4[7];
      v9 = v4[2];
      v34 = v9;
      v10 = v8 % v9;
      if ( (int)(v8 % v9) > 0 )
        v10 = v9 - v10;
      if ( v7 > 0 )
      {
        v11 = (_DWORD *)v6;
        v32 = 0;
        v37 = v7;
        do
        {
          v12 = *v11;
          (*(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD, int, _DWORD, unsigned int))(a1[86] + 4))(
            a1,
            v31,
            *a2,
            *v11,
            v32,
            0,
            v8);
          if ( v10 > 0 )
          {
            v13 = (_WORD *)((v8 << 7) + v12);
            sub_493F70(v13, v10 << 7);
            v14 = *(v13 - 64);
            v15 = v10;
            do
            {
              *v13 = v14;
              v13 += 64;
              --v15;
            }
            while ( v15 );
          }
          ++v11;
          v16 = v37 == 1;
          v32 += 8;
          --v37;
        }
        while ( !v16 );
        v7 = v29;
        v4 = v31;
        v9 = v34;
      }
      if ( *(_DWORD *)(v40 + 8) == v39 )
      {
        v17 = v10 + v8;
        v38 = v7;
        v43 = v17 / v9;
        if ( v7 < v4[3] )
        {
          v18 = (void **)(v41 + 4 * v7);
          v30 = v17 << 7;
          for ( i = v18; ; v18 = i )
          {
            v19 = (char *)*v18;
            v20 = (int)*(v18 - 1);
            sub_493F70(*v18, v30);
            if ( v43 )
            {
              v21 = v9;
              v22 = v43;
              v23 = v21 << 7;
              do
              {
                v24 = v34;
                v25 = *(_WORD *)(v23 + v20 - 128);
                if ( v34 > 0 )
                {
                  v26 = v19;
                  do
                  {
                    *v26 = v25;
                    v26 += 64;
                    --v24;
                  }
                  while ( v24 );
                }
                v19 += v23;
                v20 += v23;
                --v22;
              }
              while ( v22 );
              v4 = v31;
              v9 = v34;
            }
            v27 = ++v38 < v4[3];
            ++i;
            if ( !v27 )
              break;
          }
        }
      }
      v2 = a1;
      v4 += 21;
      ++v42;
      ++v35;
      ++a2;
      v31 = v4;
      if ( v42 >= a1[15] )
        break;
      v3 = v40;
      v5 = v39;
      v2 = a1;
    }
  }
  return sub_49BBC0(v2);
}
// 49BA8B: conditional instruction was optimized away because of 'edi.4>=1'

//----- (0049BBC0) --------------------------------------------------------
char __cdecl sub_49BBC0(_DWORD *a1)
{
  _DWORD *v1; // esi
  int v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  unsigned int v5; // ebp
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  _DWORD *v9; // ebp
  int v10; // eax
  int v11; // edx
  int *v12; // esi
  bool v13; // cc
  int v14; // ecx
  char result; // al
  _DWORD *v16; // [esp+10h] [ebp-30h]
  int v17; // [esp+10h] [ebp-30h]
  _DWORD *v18; // [esp+14h] [ebp-2Ch]
  char *v19; // [esp+18h] [ebp-28h]
  char *v20; // [esp+18h] [ebp-28h]
  int v21; // [esp+1Ch] [ebp-24h]
  int v22; // [esp+20h] [ebp-20h]
  _DWORD *v23; // [esp+24h] [ebp-1Ch]
  int v24; // [esp+28h] [ebp-18h]
  int v25; // [esp+2Ch] [ebp-14h]
  char v26[16]; // [esp+30h] [ebp-10h] BYREF

  v1 = a1;
  v2 = 0;
  v3 = (_DWORD *)a1[82];
  v23 = v3;
  if ( (int)a1[57] > 0 )
  {
    v19 = v26;
    v16 = a1 + 58;
    do
    {
      ++v2;
      *(_DWORD *)v19 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, _DWORD))(a1[1] + 32))(
                         a1,
                         v3[*(_DWORD *)(*v16 + 4) + 16],
                         *(_DWORD *)(*v16 + 12) * v3[2],
                         *(_DWORD *)(*v16 + 12),
                         0);
      ++v16;
      v19 += 4;
    }
    while ( v2 < a1[57] );
  }
  v4 = v3[4];
  v17 = v4;
  if ( v4 >= v3[5] )
  {
LABEL_22:
    ++v3[2];
    sub_49B6C0(v1);
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      v5 = v3[3];
      v24 = v5;
      if ( v5 < v1[62] )
        break;
LABEL_21:
      v14 = v3[5];
      ++v4;
      v3[3] = 0;
      v17 = v4;
      if ( v4 >= v14 )
        goto LABEL_22;
    }
    while ( 1 )
    {
      v6 = 0;
      v22 = 0;
      if ( (int)v1[57] > 0 )
      {
        v20 = v26;
        v18 = v1 + 58;
        do
        {
          v21 = 0;
          v7 = *v18;
          v8 = *(_DWORD *)(*v18 + 52);
          if ( *(int *)(*v18 + 56) > 0 )
          {
            v25 = (v5 * *(_DWORD *)(*v18 + 52)) << 7;
            v9 = (_DWORD *)(*(_DWORD *)v20 + 4 * v17);
            do
            {
              v10 = v25 + *v9;
              v11 = 0;
              if ( v8 > 0 )
              {
                v12 = &v23[v6 + 6];
                do
                {
                  *v12 = v10;
                  v8 = *(_DWORD *)(v7 + 52);
                  ++v6;
                  ++v12;
                  v10 += 128;
                  ++v11;
                }
                while ( v11 < v8 );
                v1 = a1;
              }
              ++v9;
              ++v21;
            }
            while ( v21 < *(_DWORD *)(v7 + 56) );
            v5 = v24;
          }
          v13 = ++v22 < v1[57];
          ++v18;
          v20 += 4;
        }
        while ( v13 );
        v3 = v23;
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(v1[87] + 4))(v1, v3 + 6) )
        break;
      v24 = ++v5;
      if ( v5 >= v1[62] )
      {
        v4 = v17;
        goto LABEL_21;
      }
    }
    v3[3] = v5;
    v3[4] = v17;
    result = 0;
  }
  return result;
}

//----- (0049BDB0) --------------------------------------------------------
int __cdecl sub_49BDB0(int (__cdecl ***a1)(_DWORD, _DWORD, _DWORD), char a2, int a3, int *a4)
{
  int (__cdecl ***v4)(_DWORD, _DWORD, _DWORD); // edi
  int v5; // ebx
  int v6; // esi
  int v7; // ebp
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  unsigned int v11; // ecx
  char *v12; // edi
  int v13; // edi
  int v14; // esi
  int i; // ebp
  _DWORD *v16; // eax
  int v17; // ecx
  int v18; // ebp
  int v19; // eax
  int v20; // edi
  int result; // eax
  _DWORD *v22; // ebx
  int v23; // esi
  char v24; // dl
  int v25; // [esp+10h] [ebp-518h]
  int v26; // [esp+10h] [ebp-518h]
  unsigned __int8 *v27; // [esp+14h] [ebp-514h]
  int v28; // [esp+18h] [ebp-510h]
  int v29; // [esp+1Ch] [ebp-50Ch]
  char v30[260]; // [esp+20h] [ebp-508h] BYREF
  _DWORD v31[257]; // [esp+124h] [ebp-404h] BYREF

  if ( a3 >= 0 && a3 < 4 )
  {
    v4 = a1;
  }
  else
  {
    v4 = a1;
    (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))50;
    (*a1)[6] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3;
    ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
  }
  if ( a2 )
    v27 = (unsigned __int8 *)v4[a3 + 22];
  else
    v27 = (unsigned __int8 *)v4[a3 + 26];
  if ( !v27 )
  {
    (*v4)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))50;
    (*v4)[6] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3;
    ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**v4)(v4);
  }
  if ( !*a4 )
    *a4 = (*v4[1])(v4, 1, 1280);
  v5 = 1;
  v28 = *a4;
  v6 = 0;
  v25 = 1;
  do
  {
    v7 = v27[v5];
    if ( v6 + v7 > 256 )
    {
      (*v4)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
      ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**v4)(v4);
    }
    v8 = v7;
    v9 = v7 - 1;
    if ( v8 )
    {
      BYTE1(v5) = v5;
      v10 = v5 << 16;
      LOWORD(v10) = v5;
      v11 = (unsigned int)(v9 + 1) >> 2;
      memset32(&v30[v6], v10, v11);
      v12 = &v30[4 * v11 + v6];
      v5 = v25;
      v6 += v9 + 1;
      memset(v12, v10, ((_BYTE)v9 + 1) & 3);
      v4 = a1;
    }
    v25 = ++v5;
  }
  while ( v5 <= 16 );
  v30[v6] = 0;
  v26 = v6;
  v13 = 0;
  v14 = 0;
  for ( i = v30[0]; v30[v14]; ++i )
  {
    if ( v30[v14] == i )
    {
      v16 = &v31[v14];
      do
      {
        v17 = v30[++v14];
        *v16++ = v13++;
      }
      while ( v17 == i );
    }
    if ( v13 >= 1 << i )
    {
      (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
      ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
    }
    v13 *= 2;
  }
  v18 = v28 + 1024;
  memset((void *)(v28 + 1024), 0, 0x100u);
  v19 = -(a2 != 0);
  v20 = 0;
  LOBYTE(v19) = v19 & 0x10;
  v29 = v19 + 255;
  result = v26;
  if ( v26 > 0 )
  {
    v22 = v31;
    do
    {
      v23 = v27[v20 + 17];
      if ( v23 > v29 || *(_BYTE *)(v23 + v18) )
      {
        (*a1)[5] = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))8;
        ((void (__cdecl *)(int (__cdecl ***)(_DWORD, _DWORD, _DWORD)))**a1)(a1);
      }
      v24 = v30[v20++];
      *(_DWORD *)(v28 + 4 * v23) = *v22;
      result = v26;
      ++v22;
      *(_BYTE *)(v23 + v18) = v24;
    }
    while ( v20 < v26 );
  }
  return result;
}

//----- (0049BFC0) --------------------------------------------------------
int __cdecl sub_49BFC0(int a1, int a2, int *a3)
{
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  int *v6; // esi
  int v7; // edx
  int v8; // ebx
  int v9; // ecx
  int *v10; // edi
  int v11; // ecx
  int v12; // edi
  int v13; // edi
  int v14; // esi
  int v15; // eax
  int *v16; // edi
  int v17; // ebp
  int v18; // esi
  int i; // edx
  char j; // cl
  int v21; // eax
  int v24; // esi
  int v25; // eax
  int v26; // edx
  int v27; // eax
  int v28; // edx
  int result; // eax
  int *v30; // ecx
  char v31; // [esp+Fh] [ebp-82Dh]
  int v32[8]; // [esp+10h] [ebp-82Ch] BYREF
  char v33; // [esp+30h] [ebp-80Ch]
  int v34[257]; // [esp+34h] [ebp-808h] BYREF
  int v35[257]; // [esp+438h] [ebp-404h] BYREF

  memset(v32, 0, sizeof(v32));
  v33 = 0;
  a3[256] = 1;
  memset(v34, 0, sizeof(v34));
  memset(v35, 0xFFu, sizeof(v35));
  while ( 1 )
  {
    v3 = -1;
    v4 = 1000000000;
    v5 = 0;
    v6 = a3;
    do
    {
      if ( *v6 && *v6 <= v4 )
      {
        v4 = *v6;
        v3 = v5;
      }
      ++v5;
      ++v6;
    }
    while ( v5 <= 256 );
    v7 = -1;
    v8 = 1000000000;
    v9 = 0;
    v10 = a3;
    do
    {
      if ( *v10 && *v10 <= v8 && v9 != v3 )
      {
        v8 = *v10;
        v7 = v9;
      }
      ++v9;
      ++v10;
    }
    while ( v9 <= 256 );
    if ( v7 < 0 )
      break;
    v11 = v35[v3];
    v12 = v34[v3] + 1;
    a3[v3] += a3[v7];
    a3[v7] = 0;
    for ( v34[v3] = v12; v11 >= 0; v34[v3] = v13 + 1 )
    {
      v3 = v11;
      v13 = v34[v11];
      v11 = v35[v11];
    }
    v14 = v34[v7];
    v35[v3] = v7;
    v15 = v35[v7];
    for ( v34[v7] = v14 + 1; v15 >= 0; v15 = v35[v15] )
      ++v34[v15];
  }
  v16 = v34;
  v17 = 257;
  do
  {
    v18 = *v16;
    if ( *v16 )
    {
      if ( v18 > 32 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 39;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      ++*((_BYTE *)v32 + v18);
    }
    ++v16;
    --v17;
  }
  while ( v17 );
  for ( i = 32; i > 16; --i )
  {
    for ( j = *((_BYTE *)v32 + i); j; j = *((_BYTE *)v32 + i) )
    {
      v21 = i - 2;
      if ( !*((_BYTE *)v32 + i - 2) )
      {
        while ( !*(&v31 + v21--) )
          ;
      }
      *((_BYTE *)v32 + i) = j - 2;
      ++*(&v31 + i);
      *((_BYTE *)v32 + v21 + 1) += 2;
      --*((_BYTE *)v32 + v21);
    }
  }
  if ( !*((_BYTE *)v32 + i) )
  {
    while ( !*(&v31 + i--) )
      ;
  }
  v24 = 1;
  --*((_BYTE *)v32 + i);
  v25 = v32[1];
  *(_DWORD *)a2 = v32[0];
  v26 = v32[2];
  *(_DWORD *)(a2 + 4) = v25;
  v27 = v32[3];
  *(_DWORD *)(a2 + 8) = v26;
  LOBYTE(v26) = v32[4];
  *(_DWORD *)(a2 + 12) = v27;
  *(_BYTE *)(a2 + 16) = v26;
  v28 = 0;
  do
  {
    result = 0;
    v30 = v34;
    do
    {
      if ( *v30 == v24 )
      {
        *(_BYTE *)(v28 + a2 + 17) = result;
        ++v28;
      }
      ++result;
      ++v30;
    }
    while ( result <= 255 );
    ++v24;
  }
  while ( v24 <= 32 );
  *(_BYTE *)(a2 + 273) = 0;
  return result;
}

//----- (0049C1F0) --------------------------------------------------------
_DWORD *__cdecl sub_49C1F0(int a1)
{
  int (__cdecl **v1)(int, char); // eax
  _DWORD *result; // eax
  int v3; // ecx

  v1 = (int (__cdecl **)(int, char))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 108);
  *(_DWORD *)(a1 + 348) = v1;
  *v1 = sub_49C230;
  result = v1 + 11;
  v3 = 4;
  do
  {
    result[4] = 0;
    *result = 0;
    result[12] = 0;
    result[8] = 0;
    ++result;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (0049C230) --------------------------------------------------------
int __cdecl sub_49C230(int a1, char a2)
{
  _DWORD *v3; // ebp
  int v4; // edi
  int v5; // ebx
  int result; // eax
  int v7; // [esp+8h] [ebp-8h]
  _DWORD *v8; // [esp+Ch] [ebp-4h]
  int v9; // [esp+14h] [ebp+4h]

  v3 = *(_DWORD **)(a1 + 348);
  if ( a2 )
  {
    v3[1] = sub_49C8A0;
    v3[2] = sub_49CA60;
  }
  else
  {
    v3[1] = sub_49C3A0;
    v3[2] = sub_49C820;
  }
  v7 = 0;
  if ( *(int *)(a1 + 228) > 0 )
  {
    v8 = v3 + 5;
    v9 = a1 + 232;
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)v9 + 20);
      v5 = *(_DWORD *)(*(_DWORD *)v9 + 24);
      if ( a2 )
      {
        if ( v4 < 0 || v4 >= 4 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        if ( v5 < 0 || v5 >= 4 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v5;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        if ( !v3[v4 + 19] )
          v3[v4 + 19] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
        memset((void *)v3[v4 + 19], 0, 0x404u);
        if ( !v3[v5 + 23] )
          v3[v5 + 23] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
        memset((void *)v3[v5 + 23], 0, 0x404u);
      }
      else
      {
        sub_49BDB0((int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 1, v4, &v3[v4 + 11]);
        sub_49BDB0((int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, 0, v5, &v3[v5 + 15]);
      }
      *v8++ = 0;
      ++v7;
      v9 += 4;
    }
    while ( v7 < *(_DWORD *)(a1 + 228) );
  }
  v3[3] = 0;
  v3[4] = 0;
  result = *(_DWORD *)(a1 + 188);
  v3[10] = 0;
  v3[9] = result;
  return result;
}
// 49C8A0: using guessed type int sub_49C8A0();

//----- (0049C3A0) --------------------------------------------------------
char __cdecl sub_49C3A0(_DWORD *a1, __int16 **a2)
{
  int *v3; // eax
  _DWORD *v4; // ebp
  int v5; // edx
  int v6; // eax
  int v9; // ecx
  int *v10; // edi
  __int16 *v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // [esp+10h] [ebp-28h]
  int v15; // [esp+14h] [ebp-24h] BYREF
  int v16; // [esp+18h] [ebp-20h]
  char v17[24]; // [esp+1Ch] [ebp-1Ch] BYREF
  _DWORD *v18; // [esp+34h] [ebp-4h]
  _DWORD *v19; // [esp+3Ch] [ebp+4h]

  v3 = (int *)a1[6];
  v4 = (_DWORD *)a1[87];
  v15 = *v3;
  v5 = v3[1];
  v6 = a1[47];
  v16 = v5;
  qmemcpy(v17, v4 + 3, sizeof(v17));
  v18 = a1;
  if ( v6 && !v4[9] && !sub_49C760(&v15, v4[10]) )
    return 0;
  v14 = 0;
  if ( (int)a1[64] > 0 )
  {
    v19 = a1 + 65;
    do
    {
      v9 = a1[*v19 + 58];
      v10 = (int *)&v17[4 * *v19 + 8];
      if ( !sub_49C4D0((int)&v15, *a2, *v10, v4[*(_DWORD *)(v9 + 20) + 11], v4[*(_DWORD *)(v9 + 24) + 15]) )
        return 0;
      v11 = *a2++;
      *v10 = *v11;
      ++v14;
      ++v19;
    }
    while ( v14 < a1[64] );
  }
  *(_DWORD *)a1[6] = v15;
  *(_DWORD *)(a1[6] + 4) = v16;
  qmemcpy(v4 + 3, v17, 0x18u);
  v12 = a1[47];
  if ( v12 )
  {
    if ( !v4[9] )
    {
      v13 = v4[10];
      v4[9] = v12;
      v4[10] = ((_BYTE)v13 + 1) & 7;
    }
    --v4[9];
  }
  return 1;
}

//----- (0049C4D0) --------------------------------------------------------
char __cdecl sub_49C4D0(int a1, __int16 *a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // eax
  int v8; // esi
  char result; // al
  _DWORD *v10; // eax
  int v11; // esi
  int v12; // edi
  int v13; // edi
  int v14; // ebx
  _DWORD *v15; // [esp+14h] [ebp+4h]
  int v16; // [esp+1Ch] [ebp+Ch]

  v5 = *a2 - a3;
  v6 = v5;
  if ( v5 < 0 )
  {
    v6 = a3 - *a2;
    --v5;
  }
  v8 = 0;
  if ( v6 )
  {
    do
    {
      ++v8;
      v6 >>= 1;
    }
    while ( v6 );
    if ( v8 > 11 )
    {
      *(_DWORD *)(**(_DWORD **)(a1 + 32) + 20) = 6;
      (***(void (__cdecl ****)(_DWORD))(a1 + 32))(*(_DWORD *)(a1 + 32));
    }
  }
  result = sub_49C660(a1, *(_DWORD *)(a4 + 4 * v8), *(char *)(v8 + a4 + 1024));
  if ( result )
  {
    if ( !v8 || (result = sub_49C660(a1, v5, v8)) != 0 )
    {
      v10 = &unk_4B0AC0;
      v11 = 0;
      v15 = &unk_4B0AC0;
      do
      {
        v12 = a2[*v10];
        if ( a2[*v10] )
        {
          if ( v11 > 15 )
          {
            while ( sub_49C660(a1, *(_DWORD *)(a5 + 960), *(char *)(a5 + 1264)) )
            {
              v11 -= 16;
              if ( v11 <= 15 )
                goto LABEL_16;
            }
            return 0;
          }
LABEL_16:
          v16 = v12;
          if ( v12 < 0 )
          {
            v12 = -v12;
            --v16;
          }
          v13 = v12 >> 1;
          v14 = 1;
          if ( v13 )
          {
            do
            {
              ++v14;
              v13 >>= 1;
            }
            while ( v13 );
            if ( v14 > 10 )
            {
              *(_DWORD *)(**(_DWORD **)(a1 + 32) + 20) = 6;
              (***(void (__cdecl ****)(_DWORD))(a1 + 32))(*(_DWORD *)(a1 + 32));
            }
          }
          if ( !sub_49C660(a1, *(_DWORD *)(a5 + 4 * (v14 + 16 * v11)), *(char *)(v14 + 16 * v11 + a5 + 1024))
            || !sub_49C660(a1, v16, v14) )
          {
            return 0;
          }
          v10 = v15;
          v11 = 0;
        }
        else
        {
          ++v11;
        }
        v15 = ++v10;
      }
      while ( (int)v10 < (int)&unk_4B0BBC );
      if ( v11 > 0 && !sub_49C660(a1, *(_DWORD *)a5, *(char *)(a5 + 1024)) )
        return 0;
      result = 1;
    }
  }
  return result;
}

//----- (0049C660) --------------------------------------------------------
char __cdecl sub_49C660(int a1, int a2, int a3)
{
  int v4; // ebp
  int v5; // ebp
  int v6; // edi
  int v7; // eax
  int v8; // eax
  char result; // al
  unsigned __int8 v10; // [esp+16h] [ebp+6h]

  v4 = *(_DWORD *)(a1 + 12);
  if ( !a3 )
  {
    *(_DWORD *)(**(_DWORD **)(a1 + 32) + 20) = 40;
    (***(void (__cdecl ****)(_DWORD))(a1 + 32))(*(_DWORD *)(a1 + 32));
  }
  v5 = a3 + v4;
  v6 = *(_DWORD *)(a1 + 8) | ((a2 & ((1 << a3) - 1)) << (24 - v5));
  v10 = BYTE2(v6);
  if ( v5 < 8 )
  {
LABEL_10:
    *(_DWORD *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 12) = v5;
    result = 1;
  }
  else
  {
    while ( 1 )
    {
      **(_BYTE **)a1 = v10;
      v7 = *(_DWORD *)(a1 + 4) - 1;
      ++*(_DWORD *)a1;
      *(_DWORD *)(a1 + 4) = v7;
      if ( !v7 && !sub_49C730((_DWORD *)a1) )
        break;
      if ( v10 == 255 )
      {
        **(_BYTE **)a1 = 0;
        v8 = *(_DWORD *)(a1 + 4) - 1;
        ++*(_DWORD *)a1;
        *(_DWORD *)(a1 + 4) = v8;
        if ( !v8 && !sub_49C730((_DWORD *)a1) )
          break;
      }
      v5 -= 8;
      v6 <<= 8;
      v10 = BYTE2(v6);
      if ( v5 < 8 )
        goto LABEL_10;
    }
    result = 0;
  }
  return result;
}

//----- (0049C730) --------------------------------------------------------
char __cdecl sub_49C730(_DWORD *a1)
{
  int v1; // esi
  char result; // al
  int v3; // [esp-4h] [ebp-Ch]

  v3 = a1[8];
  v1 = *(_DWORD *)(v3 + 24);
  result = (*(int (__cdecl **)(int))(v1 + 12))(v3);
  if ( result )
  {
    *a1 = *(_DWORD *)v1;
    a1[1] = *(_DWORD *)(v1 + 4);
    result = 1;
  }
  return result;
}

//----- (0049C760) --------------------------------------------------------
char __cdecl sub_49C760(_DWORD *a1, char a2)
{
  char result; // al
  int v3; // eax
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // ecx

  result = sub_49C7F0((int)a1);
  if ( result )
  {
    *(_BYTE *)*a1 = -1;
    v3 = a1[1] - 1;
    ++*a1;
    a1[1] = v3;
    if ( v3 || (result = sub_49C730(a1)) != 0 )
    {
      *(_BYTE *)*a1 = a2 - 48;
      v4 = a1[1] - 1;
      ++*a1;
      a1[1] = v4;
      if ( v4 || (result = sub_49C730(a1)) != 0 )
      {
        v5 = 0;
        if ( *(int *)(a1[8] + 228) > 0 )
        {
          v6 = a1 + 4;
          do
          {
            *v6 = 0;
            ++v5;
            ++v6;
          }
          while ( v5 < *(_DWORD *)(a1[8] + 228) );
        }
        result = 1;
      }
    }
  }
  return result;
}

//----- (0049C7F0) --------------------------------------------------------
char __cdecl sub_49C7F0(int a1)
{
  char result; // al

  result = sub_49C660(a1, 127, 7);
  if ( result )
  {
    result = 1;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return result;
}

//----- (0049C820) --------------------------------------------------------
int __cdecl sub_49C820(_DWORD *a1)
{
  int *v1; // eax
  char *v2; // ebp
  int result; // eax
  int v4; // [esp+10h] [ebp-24h] BYREF
  int v5; // [esp+14h] [ebp-20h]
  char v6[24]; // [esp+18h] [ebp-1Ch] BYREF
  _DWORD *v7; // [esp+30h] [ebp-4h]

  v1 = (int *)a1[6];
  v2 = (char *)(a1[87] + 12);
  v4 = *v1;
  v5 = v1[1];
  qmemcpy(v6, v2, sizeof(v6));
  v7 = a1;
  if ( !sub_49C7F0((int)&v4) )
  {
    *(_DWORD *)(*a1 + 20) = 24;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  *(_DWORD *)a1[6] = v4;
  result = a1[6];
  *(_DWORD *)(result + 4) = v5;
  qmemcpy(v2, v6, 0x18u);
  return result;
}

//----- (0049C980) --------------------------------------------------------
int __cdecl sub_49C980(int a1, __int16 *a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  int v6; // esi
  _DWORD *v7; // ebp
  int v8; // edi
  int result; // eax
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // esi

  v5 = *a2 - a3;
  if ( v5 < 0 )
    v5 = a3 - *a2;
  v6 = 0;
  if ( v5 )
  {
    do
    {
      ++v6;
      v5 >>= 1;
    }
    while ( v5 );
    if ( v6 > 11 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
  }
  v7 = &unk_4B0AC0;
  v8 = 0;
  ++*(_DWORD *)(a4 + 4 * v6);
  do
  {
    result = a2[*v7];
    if ( a2[*v7] )
    {
      if ( v8 > 15 )
      {
        v10 = (unsigned int)v8 >> 4;
        v8 += -16 * ((unsigned int)v8 >> 4);
        do
        {
          --v10;
          ++a5[240];
        }
        while ( v10 );
      }
      if ( result < 0 )
        result = -result;
      v11 = result >> 1;
      v12 = 1;
      if ( v11 )
      {
        do
        {
          ++v12;
          v11 >>= 1;
        }
        while ( v11 );
        if ( v12 > 10 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
      }
      result = (int)&a5[16 * v8 + v12];
      v8 = 0;
      ++*(_DWORD *)result;
    }
    else
    {
      ++v8;
    }
    ++v7;
  }
  while ( (int)v7 < (int)&unk_4B0BBC );
  if ( v8 > 0 )
    ++*a5;
  return result;
}

//----- (0049CA60) --------------------------------------------------------
int __cdecl sub_49CA60(int a1)
{
  int v2; // ecx
  int result; // eax
  int v4; // edi
  int v5; // ebp
  bool v6; // cc
  int v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+18h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 228);
  v7 = *(_DWORD *)(a1 + 348);
  result = 0;
  v9 = 0;
  v10 = 0;
  v8 = 0;
  if ( v2 > 0 )
  {
    v11 = a1 + 232;
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)v11 + 20);
      v5 = *(_DWORD *)(*(_DWORD *)v11 + 24);
      if ( !*((_BYTE *)&v9 + v4) )
      {
        if ( !*(_DWORD *)(a1 + 4 * v4 + 88) )
          *(_DWORD *)(a1 + 4 * v4 + 88) = sub_493750(a1);
        sub_49BFC0(a1, *(_DWORD *)(a1 + 4 * v4 + 88), *(int **)(v7 + 4 * v4 + 76));
        *((_BYTE *)&v9 + v4) = 1;
      }
      if ( !*((_BYTE *)&v10 + v5) )
      {
        if ( !*(_DWORD *)(a1 + 4 * v5 + 104) )
          *(_DWORD *)(a1 + 4 * v5 + 104) = sub_493750(a1);
        sub_49BFC0(a1, *(_DWORD *)(a1 + 4 * v5 + 104), *(int **)(v7 + 4 * v5 + 92));
        *((_BYTE *)&v10 + v5) = 1;
      }
      result = v8 + 1;
      v6 = ++v8 < *(_DWORD *)(a1 + 228);
      v11 += 4;
    }
    while ( v6 );
  }
  return result;
}

//----- (0049CB50) --------------------------------------------------------
int (__cdecl **__cdecl sub_49CB50(int a1))(int a1, char a2)
{
  int (__cdecl **result)(int, char); // eax
  _DWORD *v2; // ecx
  int v3; // edx

  result = (int (__cdecl **)(int, char))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 108);
  *(_DWORD *)(a1 + 348) = result;
  *result = sub_49CB90;
  v2 = result + 23;
  v3 = 4;
  do
  {
    *(v2 - 4) = 0;
    *v2++ = 0;
    --v3;
  }
  while ( v3 );
  result[16] = 0;
  return result;
}

//----- (0049CB90) --------------------------------------------------------
int __cdecl sub_49CB90(int a1, char a2)
{
  int v3; // ebp
  int v4; // edx
  int v5; // eax
  int *v6; // ebx
  int v7; // eax
  int v8; // edi
  bool v9; // cc
  int result; // eax
  bool v11; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]
  _DWORD *v13; // [esp+1Ch] [ebp+4h]

  v3 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v3 + 32) = a1;
  *(_BYTE *)(v3 + 12) = a2;
  v4 = *(_DWORD *)(a1 + 300);
  v11 = v4 == 0;
  if ( *(_DWORD *)(a1 + 308) )
  {
    if ( v4 )
    {
      v5 = *(_DWORD *)(v3 + 64);
      *(_DWORD *)(v3 + 4) = sub_49D410;
      if ( !v5 )
        *(_DWORD *)(v3 + 64) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1000);
    }
    else
    {
      *(_DWORD *)(v3 + 4) = sub_49D350;
    }
  }
  else if ( v4 )
  {
    *(_DWORD *)(v3 + 4) = sub_49D170;
  }
  else
  {
    *(_DWORD *)(v3 + 4) = sub_49CD10;
  }
  if ( a2 )
    *(_DWORD *)(v3 + 8) = sub_49D680;
  else
    *(_DWORD *)(v3 + 8) = sub_49D640;
  v12 = 0;
  if ( *(int *)(a1 + 228) > 0 )
  {
    v6 = (int *)(a1 + 232);
    v13 = (_DWORD *)(v3 + 36);
    while ( 1 )
    {
      v7 = *v6;
      *v13 = 0;
      if ( !v11 )
        break;
      if ( !*(_DWORD *)(a1 + 308) )
      {
        v8 = *(_DWORD *)(v7 + 20);
        goto LABEL_18;
      }
LABEL_26:
      ++v6;
      v9 = ++v12 < *(_DWORD *)(a1 + 228);
      ++v13;
      if ( !v9 )
        goto LABEL_27;
    }
    v8 = *(_DWORD *)(v7 + 24);
    *(_DWORD *)(v3 + 52) = v8;
LABEL_18:
    if ( a2 )
    {
      if ( v8 < 0 || v8 >= 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 50;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v8;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      if ( !*(_DWORD *)(v3 + 4 * v8 + 92) )
        *(_DWORD *)(v3 + 4 * v8 + 92) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1028);
      memset(*(void **)(v3 + 4 * v8 + 92), 0, 0x404u);
    }
    else
    {
      sub_49BDB0((int (__cdecl ***)(_DWORD, _DWORD, _DWORD))a1, v11, v8, (int *)(v3 + 4 * v8 + 76));
    }
    goto LABEL_26;
  }
LABEL_27:
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 28) = 0;
  result = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 68) = result;
  return result;
}

//----- (0049CD10) --------------------------------------------------------
char __cdecl sub_49CD10(int a1, __int16 **a2)
{
  _DWORD *v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int v9; // esi
  bool v10; // cc
  int v11; // ebp
  int v12; // edx
  int v14; // [esp+Ch] [ebp-Ch]
  char v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]
  _DWORD *v17; // [esp+1Ch] [ebp+4h]

  v3 = *(_DWORD **)(a1 + 348);
  v4 = *(_DWORD *)(a1 + 312);
  v3[4] = **(_DWORD **)(a1 + 24);
  v3[5] = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  if ( *(_DWORD *)(a1 + 188) && !v3[17] )
    sub_49CFE0((int)v3, v3[18]);
  v14 = 0;
  if ( *(int *)(a1 + 256) > 0 )
  {
    v15 = v4;
    v17 = (_DWORD *)(a1 + 260);
    do
    {
      v5 = **a2 >> v15;
      v6 = v3[*v17 + 9];
      v16 = *(_DWORD *)(a1 + 4 * *v17 + 232);
      v3[*v17 + 9] = v5;
      v7 = v5 - v6;
      v8 = v5 - v6;
      if ( v5 - v6 < 0 )
      {
        v7 = v6 - v5;
        --v8;
      }
      v9 = 0;
      if ( v7 )
      {
        do
        {
          ++v9;
          v7 >>= 1;
        }
        while ( v7 );
        if ( v9 > 11 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
      }
      sub_49CF90((int)v3, *(_DWORD *)(v16 + 20), v9);
      if ( v9 )
        sub_49CE70((int)v3, v8, v9);
      v10 = ++v14 < *(_DWORD *)(a1 + 256);
      ++v17;
      ++a2;
    }
    while ( v10 );
  }
  **(_DWORD **)(a1 + 24) = v3[4];
  *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4) = v3[5];
  v11 = *(_DWORD *)(a1 + 188);
  if ( v11 )
  {
    if ( !v3[17] )
    {
      v12 = v3[18];
      v3[17] = v11;
      v3[18] = ((_BYTE)v12 + 1) & 7;
    }
    --v3[17];
  }
  return 1;
}

//----- (0049CE70) --------------------------------------------------------
char __cdecl sub_49CE70(int a1, int a2, int a3)
{
  int v4; // ebp
  char result; // al
  int v6; // ebp
  int v7; // edi
  int v8; // eax
  int v9; // eax
  bool v10; // zf
  unsigned __int8 v11; // [esp+12h] [ebp+6h]
  unsigned int v12; // [esp+18h] [ebp+Ch]

  v4 = *(_DWORD *)(a1 + 28);
  if ( !a3 )
  {
    *(_DWORD *)(**(_DWORD **)(a1 + 32) + 20) = 40;
    (***(void (__cdecl ****)(_DWORD))(a1 + 32))(*(_DWORD *)(a1 + 32));
  }
  result = *(_BYTE *)(a1 + 12);
  if ( !result )
  {
    result = a2;
    v6 = a3 + v4;
    v7 = *(_DWORD *)(a1 + 24) | ((a2 & ((1 << a3) - 1)) << (24 - v6));
    v11 = BYTE2(v7);
    if ( v6 >= 8 )
    {
      v12 = (unsigned int)v6 >> 3;
      v6 -= 8 * ((unsigned int)v6 >> 3);
      do
      {
        **(_BYTE **)(a1 + 16) = v11;
        v8 = *(_DWORD *)(a1 + 20) - 1;
        ++*(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 20) = v8;
        if ( !v8 )
          sub_49CF50((_DWORD *)a1);
        if ( v11 == 255 )
        {
          **(_BYTE **)(a1 + 16) = 0;
          v9 = *(_DWORD *)(a1 + 20) - 1;
          ++*(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 20) = v9;
          if ( !v9 )
            sub_49CF50((_DWORD *)a1);
        }
        v7 <<= 8;
        result = v12 - 1;
        v10 = v12 == 1;
        v11 = BYTE2(v7);
        --v12;
      }
      while ( !v10 );
    }
    *(_DWORD *)(a1 + 24) = v7;
    *(_DWORD *)(a1 + 28) = v6;
  }
  return result;
}

//----- (0049CF50) --------------------------------------------------------
int __cdecl sub_49CF50(_DWORD *a1)
{
  int *v1; // edi
  int result; // eax
  int v3; // [esp-4h] [ebp-Ch]

  v3 = a1[8];
  v1 = *(int **)(v3 + 24);
  if ( !((unsigned __int8 (__cdecl *)(int))v1[3])(v3) )
  {
    *(_DWORD *)(*(_DWORD *)a1[8] + 20) = 24;
    (**(void (__cdecl ***)(_DWORD))a1[8])(a1[8]);
  }
  result = *v1;
  a1[4] = *v1;
  a1[5] = v1[1];
  return result;
}

//----- (0049CF90) --------------------------------------------------------
char __cdecl sub_49CF90(int a1, int a2, int a3)
{
  _DWORD *v3; // eax

  if ( *(_BYTE *)(a1 + 12) )
  {
    v3 = (_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 92) + 4 * a3);
    ++*v3;
  }
  else
  {
    LOBYTE(v3) = sub_49CE70(
                   a1,
                   *(_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 76) + 4 * a3),
                   *(char *)(*(_DWORD *)(a1 + 4 * a2 + 76) + a3 + 1024));
  }
  return (char)v3;
}

//----- (0049CFE0) --------------------------------------------------------
int __cdecl sub_49CFE0(int a1, char a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // ecx
  int result; // eax
  _DWORD *v6; // ecx

  sub_49D0B0(a1);
  if ( !*(_BYTE *)(a1 + 12) )
  {
    sub_49D090(a1);
    **(_BYTE **)(a1 + 16) = -1;
    v2 = *(_DWORD *)(a1 + 20) - 1;
    ++*(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v2;
    if ( !v2 )
      sub_49CF50((_DWORD *)a1);
    **(_BYTE **)(a1 + 16) = a2 - 48;
    v3 = *(_DWORD *)(a1 + 20) - 1;
    ++*(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) = v3;
    if ( !v3 )
      sub_49CF50((_DWORD *)a1);
  }
  v4 = *(_DWORD *)(a1 + 32);
  result = *(_DWORD *)(v4 + 300);
  if ( result )
  {
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 60) = 0;
  }
  else
  {
    result = 0;
    if ( *(int *)(v4 + 228) > 0 )
    {
      v6 = (_DWORD *)(a1 + 36);
      do
      {
        *v6 = 0;
        ++result;
        ++v6;
      }
      while ( result < *(_DWORD *)(*(_DWORD *)(a1 + 32) + 228) );
    }
  }
  return result;
}

//----- (0049D090) --------------------------------------------------------
int __cdecl sub_49D090(int a1)
{
  int result; // eax

  sub_49CE70(a1, 127, 7);
  result = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  return result;
}

//----- (0049D0B0) --------------------------------------------------------
char __cdecl sub_49D0B0(int a1)
{
  int v1; // eax
  int v2; // edi
  int v3; // eax
  char *v5; // [esp-Ch] [ebp-10h]
  int v6; // [esp-8h] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 )
  {
    v2 = 0;
    v3 = v1 >> 1;
    if ( v3 )
    {
      do
      {
        ++v2;
        v3 >>= 1;
      }
      while ( v3 );
      if ( v2 > 14 )
      {
        *(_DWORD *)(**(_DWORD **)(a1 + 32) + 20) = 40;
        (***(void (__cdecl ****)(_DWORD))(a1 + 32))(*(_DWORD *)(a1 + 32));
      }
    }
    sub_49CF90(a1, *(_DWORD *)(a1 + 52), 16 * v2);
    if ( v2 )
      sub_49CE70(a1, *(_DWORD *)(a1 + 56), v2);
    v6 = *(_DWORD *)(a1 + 60);
    v5 = *(char **)(a1 + 64);
    *(_DWORD *)(a1 + 56) = 0;
    LOBYTE(v1) = sub_49D130(a1, v5, v6);
    *(_DWORD *)(a1 + 60) = 0;
  }
  return v1;
}

//----- (0049D130) --------------------------------------------------------
char __cdecl sub_49D130(int a1, char *a2, int a3)
{
  char result; // al
  int i; // edi

  result = *(_BYTE *)(a1 + 12);
  if ( !result )
  {
    for ( i = a3; i; --i )
      result = sub_49CE70(a1, *a2++, 1);
  }
  return result;
}

//----- (0049D170) --------------------------------------------------------
char __cdecl sub_49D170(int a1, int *a2)
{
  int v2; // ebx
  _DWORD *v3; // esi
  int v4; // ebp
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // edi
  int v9; // edi
  int v10; // ebp
  unsigned int v11; // ebx
  int v12; // edi
  int v13; // ebx
  bool v14; // zf
  int v15; // eax
  int v16; // eax
  _DWORD *v18; // [esp+10h] [ebp-10h]
  int v19; // [esp+14h] [ebp-Ch]
  char v20; // [esp+18h] [ebp-8h]
  int v21; // [esp+1Ch] [ebp-4h]
  int v22; // [esp+28h] [ebp+8h]

  v2 = a1;
  v3 = *(_DWORD **)(a1 + 348);
  v4 = *(_DWORD *)(a1 + 312);
  v5 = *(_DWORD *)(a1 + 304);
  v3[4] = **(_DWORD **)(a1 + 24);
  v20 = v4;
  v3[5] = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  if ( *(_DWORD *)(a1 + 188) && !v3[17] )
    sub_49CFE0((int)v3, v3[18]);
  v6 = 0;
  v21 = *a2;
  v7 = *(_DWORD *)(a1 + 300);
  v22 = 0;
  if ( v7 <= v5 )
  {
    v18 = (_DWORD *)(4 * v7 + 4917948);
    v19 = v5 - v7 + 1;
    while ( 1 )
    {
      v8 = *(__int16 *)(v21 + 2 * *v18);
      if ( *(_WORD *)(v21 + 2 * *v18) )
      {
        if ( v8 >= 0 )
        {
          v9 = v8 >> v4;
          v10 = v9;
        }
        else
        {
          v9 = -v8 >> v4;
          v10 = ~v9;
        }
        if ( v9 )
        {
          if ( v3[14] )
          {
            sub_49D0B0((int)v3);
            v6 = v22;
          }
          if ( v6 > 15 )
          {
            v11 = (unsigned int)v6 >> 4;
            v22 += -16 * ((unsigned int)v6 >> 4);
            do
            {
              sub_49CF90((int)v3, v3[13], 240);
              --v11;
            }
            while ( v11 );
          }
          v12 = v9 >> 1;
          v13 = 1;
          if ( v12 )
          {
            do
            {
              ++v13;
              v12 >>= 1;
            }
            while ( v12 );
            if ( v13 > 10 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 6;
              (**(void (__cdecl ***)(int))a1)(a1);
            }
          }
          sub_49CF90((int)v3, v3[13], v13 + 16 * v22);
          sub_49CE70((int)v3, v10, v13);
          v2 = a1;
          v22 = 0;
          v6 = 0;
        }
        else
        {
          v22 = ++v6;
        }
      }
      else
      {
        v22 = ++v6;
      }
      v14 = v19 == 1;
      ++v18;
      --v19;
      if ( v14 )
        break;
      LOBYTE(v4) = v20;
    }
    if ( v6 > 0 )
    {
      v15 = v3[14] + 1;
      v3[14] = v15;
      if ( v15 == 0x7FFF )
        sub_49D0B0((int)v3);
    }
  }
  **(_DWORD **)(v2 + 24) = v3[4];
  *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4) = v3[5];
  v16 = *(_DWORD *)(v2 + 188);
  if ( v16 )
  {
    if ( !v3[17] )
    {
      v3[17] = v16;
      v3[18] = ((unsigned __int8)v3[18] + 1) & 7;
    }
    --v3[17];
  }
  return 1;
}

//----- (0049D350) --------------------------------------------------------
char __cdecl sub_49D350(int a1, __int16 **a2)
{
  _DWORD *v3; // edi
  int v4; // edx
  int i; // ebx
  int v7; // esi
  int v8; // edx
  int v10; // [esp+Ch] [ebp+4h]

  v3 = *(_DWORD **)(a1 + 348);
  v4 = **(_DWORD **)(a1 + 24);
  v10 = *(_DWORD *)(a1 + 312);
  v3[4] = v4;
  v3[5] = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  if ( *(_DWORD *)(a1 + 188) && !v3[17] )
    sub_49CFE0((int)v3, v3[18]);
  for ( i = 0; i < *(_DWORD *)(a1 + 256); ++a2 )
  {
    sub_49CE70((int)v3, **a2 >> v10, 1);
    ++i;
  }
  **(_DWORD **)(a1 + 24) = v3[4];
  *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4) = v3[5];
  v7 = *(_DWORD *)(a1 + 188);
  if ( v7 )
  {
    if ( !v3[17] )
    {
      v8 = v3[18];
      v3[17] = v7;
      v3[18] = ((_BYTE)v8 + 1) & 7;
    }
    --v3[17];
  }
  return 1;
}

//----- (0049D410) --------------------------------------------------------
char __cdecl sub_49D410(int a1, int *a2)
{
  int v2; // edx
  _DWORD *v3; // esi
  int v4; // ebp
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  char *v9; // edi
  int v10; // eax
  int v11; // ebx
  int v12; // ebp
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // ebx
  int v16; // edx
  int v18; // [esp+10h] [ebp-114h]
  int v19; // [esp+14h] [ebp-110h]
  int v20; // [esp+18h] [ebp-10Ch]
  int v21; // [esp+1Ch] [ebp-108h]
  int i; // [esp+20h] [ebp-104h]
  int v23[64]; // [esp+24h] [ebp-100h]

  v2 = a1;
  v3 = *(_DWORD **)(a1 + 348);
  v4 = *(_DWORD *)(a1 + 312);
  v19 = *(_DWORD *)(a1 + 304);
  v3[4] = **(_DWORD **)(a1 + 24);
  v3[5] = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  if ( *(_DWORD *)(a1 + 188) && !v3[17] )
  {
    sub_49CFE0((int)v3, v3[18]);
    v2 = a1;
  }
  v5 = *(_DWORD *)(v2 + 300);
  v20 = 0;
  v6 = *a2;
  for ( i = *a2; v5 <= v19; ++v5 )
  {
    v7 = *(__int16 *)(v6 + 2 * dword_4B0ABC[v5]);
    if ( v7 < 0 )
      v7 = -v7;
    v8 = v7 >> v4;
    v23[v5] = v8;
    if ( v8 == 1 )
      v20 = v5;
  }
  v9 = (char *)(v3[15] + v3[16]);
  v10 = *(_DWORD *)(v2 + 300);
  v11 = 0;
  v12 = 0;
  v18 = v10;
  if ( v10 <= v19 )
  {
    do
    {
      v13 = v23[v10];
      v21 = v13;
      if ( v13 )
      {
        if ( v11 > 15 )
        {
          while ( v10 <= v20 )
          {
            sub_49D0B0((int)v3);
            sub_49CF90((int)v3, v3[13], 240);
            v11 -= 16;
            sub_49D130((int)v3, v9, v12);
            v9 = (char *)v3[16];
            v12 = 0;
            if ( v11 <= 15 )
            {
              v2 = a1;
              v13 = v21;
              v10 = v18;
              goto LABEL_20;
            }
            v13 = v21;
            v10 = v18;
          }
          v2 = a1;
        }
LABEL_20:
        if ( v13 <= 1 )
        {
          sub_49D0B0((int)v3);
          sub_49CF90((int)v3, v3[13], 16 * v11 + 1);
          sub_49CE70((int)v3, *(_WORD *)(i + 2 * dword_4B0ABC[v18]) >= 0, 1);
          sub_49D130((int)v3, v9, v12);
          v9 = (char *)v3[16];
          v2 = a1;
          v10 = v18;
          v12 = 0;
          v11 = 0;
        }
        else
        {
          v9[v12++] = v13 & 1;
        }
      }
      else
      {
        ++v11;
      }
      v18 = ++v10;
    }
    while ( v10 <= v19 );
    if ( v11 > 0 || v12 )
    {
      v14 = v3[14] + 1;
      v15 = v12 + v3[15];
      v3[14] = v14;
      v3[15] = v15;
      if ( v14 == 0x7FFF || v15 > 0x3A9 )
      {
        sub_49D0B0((int)v3);
        v2 = a1;
      }
    }
  }
  **(_DWORD **)(v2 + 24) = v3[4];
  *(_DWORD *)(*(_DWORD *)(v2 + 24) + 4) = v3[5];
  v16 = *(_DWORD *)(v2 + 188);
  if ( v16 )
  {
    if ( !v3[17] )
    {
      v3[17] = v16;
      v3[18] = ((unsigned __int8)v3[18] + 1) & 7;
    }
    --v3[17];
  }
  return 1;
}
// 4B0ABC: using guessed type int dword_4B0ABC[];

//----- (0049D640) --------------------------------------------------------
int __cdecl sub_49D640(int a1)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v1 + 16) = **(_DWORD **)(a1 + 24);
  *(_DWORD *)(v1 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 4);
  sub_49D0B0(v1);
  sub_49D090(v1);
  **(_DWORD **)(a1 + 24) = *(_DWORD *)(v1 + 16);
  result = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 4) = *(_DWORD *)(v1 + 20);
  return result;
}

//----- (0049D680) --------------------------------------------------------
int __cdecl sub_49D680(_DWORD *a1)
{
  int v2; // edi
  int v3; // edx
  int result; // eax
  bool v5; // cl
  int v6; // eax
  int v7; // ebp
  int *v8; // edi
  int *i; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]
  bool v14; // [esp+1Ch] [ebp+4h]

  v13 = a1[87];
  sub_49D0B0(v13);
  v2 = a1[75];
  v3 = a1[57];
  result = 0;
  v12 = 0;
  v5 = v2 == 0;
  v14 = v2 == 0;
  v11 = 0;
  if ( v3 > 0 )
  {
    for ( i = a1 + 58; ; ++i )
    {
      v6 = *i;
      if ( !v5 )
        break;
      if ( !a1[77] )
      {
        v7 = *(_DWORD *)(v6 + 20);
        goto LABEL_7;
      }
LABEL_13:
      result = v11 + 1;
      if ( ++v11 >= a1[57] )
        return result;
    }
    v7 = *(_DWORD *)(v6 + 24);
LABEL_7:
    if ( !*((_BYTE *)&v12 + v7) )
    {
      v8 = &a1[v7 + 22];
      if ( !v5 )
        v8 = &a1[v7 + 26];
      if ( !*v8 )
        *v8 = sub_493750((int)a1);
      sub_49BFC0((int)a1, *v8, *(int **)(v13 + 4 * v7 + 92));
      v5 = v14;
      *((_BYTE *)&v12 + v7) = 1;
    }
    goto LABEL_13;
  }
  return result;
}

//----- (0049D760) --------------------------------------------------------
_DWORD *__cdecl sub_49D760(int a1)
{
  int (__cdecl **v1)(int *); // edi
  int v2; // eax
  int v3; // eax
  _DWORD *result; // eax
  int v5; // ecx

  v1 = (int (__cdecl **)(int *))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 344) = v1;
  *v1 = sub_49D800;
  v2 = *(_DWORD *)(a1 + 184);
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v1[1] = (int (__cdecl *)(int *))sub_49DB70;
        v1[7] = (int (__cdecl *)(int *))sub_4A1B60;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    else
    {
      v1[1] = (int (__cdecl *)(int *))sub_49D9D0;
      v1[2] = (int (__cdecl *)(int *))sub_4A1910;
    }
  }
  else
  {
    v1[1] = (int (__cdecl *)(int *))sub_49D9D0;
    v1[2] = (int (__cdecl *)(int *))sub_4A1510;
  }
  result = v1 + 8;
  v5 = 4;
  do
  {
    *(result - 5) = 0;
    *result++ = 0;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (0049D800) --------------------------------------------------------
int __cdecl sub_49D800(int *a1)
{
  int *v1; // edi
  int v2; // ebp
  int result; // eax
  int v4; // esi
  int v5; // eax
  unsigned __int16 *v6; // ebx
  int v7; // eax
  int v8; // edi
  double *v9; // esi
  int v10; // edx
  unsigned __int16 *v11; // ecx
  double *v12; // eax
  unsigned __int16 v13; // bp
  int v14; // esi
  __int16 *v15; // eax
  int v16; // ecx
  int v17; // ebx
  unsigned __int16 v18; // dx
  int v19; // esi
  unsigned __int16 *v20; // eax
  int v21; // ecx
  unsigned __int16 v22; // dx
  bool v23; // cc
  int *v24; // [esp+8h] [ebp-10h]
  int v25; // [esp+Ch] [ebp-Ch]
  int v26; // [esp+14h] [ebp-4h]

  v1 = a1;
  v25 = 0;
  v2 = a1[86];
  result = a1[17];
  v26 = v2;
  if ( a1[15] > 0 )
  {
    v24 = (int *)(result + 16);
    do
    {
      v4 = *v24;
      if ( *v24 < 0 || v4 >= 4 || !v1[v4 + 18] )
      {
        *(_DWORD *)(*v1 + 20) = 52;
        *(_DWORD *)(*v1 + 24) = v4;
        (*(void (__cdecl **)(int *))*v1)(v1);
      }
      v5 = v1[46];
      v6 = (unsigned __int16 *)v1[v4 + 18];
      if ( v5 )
      {
        v7 = v5 - 1;
        if ( v7 )
        {
          if ( v7 == 1 )
          {
            if ( !*(_DWORD *)(v2 + 4 * v4 + 32) )
              *(_DWORD *)(v2 + 4 * v4 + 32) = (*(int (__cdecl **)(int *, int, int))v1[1])(v1, 1, 256);
            v8 = *(_DWORD *)(v2 + 4 * v4 + 32);
            v9 = (double *)&unk_4B0F50;
            do
            {
              v10 = v8;
              v11 = v6;
              v8 += 32;
              v12 = (double *)&unk_4B0F50;
              v6 += 8;
              do
              {
                ++v12;
                v13 = *v11++;
                v10 += 4;
                *(float *)(v10 - 4) = dbl_4A91C8 / ((double)v13 * *(v12 - 1) * *v9 * dbl_4B04D0);
              }
              while ( (int)v12 < (int)&flt_4B0F90 );
              ++v9;
            }
            while ( (int)v9 < (int)&flt_4B0F90 );
            v2 = v26;
            v1 = a1;
          }
          else
          {
            *(_DWORD *)(*v1 + 20) = 48;
            (*(void (__cdecl **)(int *))*v1)(v1);
          }
        }
        else
        {
          if ( !*(_DWORD *)(v2 + 4 * v4 + 12) )
            *(_DWORD *)(v2 + 4 * v4 + 12) = (*(int (__cdecl **)(int *, int, int))v1[1])(v1, 1, 256);
          v14 = *(_DWORD *)(v2 + 4 * v4 + 12);
          v15 = (__int16 *)&unk_4B0ED0;
          v16 = (char *)v6 - (char *)&unk_4B0ED0;
          do
          {
            v17 = *v15;
            v14 += 4;
            v18 = *(__int16 *)((char *)v15++ + v16);
            *(_DWORD *)(v14 - 4) = (v17 * v18 + 1024) >> 11;
          }
          while ( (int)v15 < (int)&unk_4B0F50 );
        }
      }
      else
      {
        if ( !*(_DWORD *)(v2 + 4 * v4 + 12) )
          *(_DWORD *)(v2 + 4 * v4 + 12) = (*(int (__cdecl **)(int *, int, int))v1[1])(v1, 1, 256);
        v19 = *(_DWORD *)(v2 + 4 * v4 + 12);
        v20 = v6;
        v21 = 64;
        do
        {
          v19 += 4;
          v22 = *v20++;
          *(_DWORD *)(v19 - 4) = 8 * v22;
          --v21;
        }
        while ( v21 );
      }
      result = v25 + 1;
      v23 = ++v25 < v1[15];
      v24 += 21;
    }
    while ( v23 );
  }
  return result;
}
// 4A91C8: using guessed type double dbl_4A91C8;
// 4B04D0: using guessed type double dbl_4B04D0;
// 4B0F90: using guessed type float flt_4B0F90;

//----- (0049D9D0) --------------------------------------------------------
int __cdecl sub_49D9D0(int a1, int a2, int a3, _WORD *a4, int a5, int a6, int a7)
{
  int v7; // eax
  int result; // eax
  _DWORD *v10; // esi
  char *v11; // ecx
  int v12; // edi
  unsigned __int8 *v13; // eax
  char *v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // edx
  _WORD *v21; // edi
  int *v22; // esi
  int v23; // ebx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // eax
  int v28; // eax
  bool v29; // zf
  int v30; // [esp+0h] [ebp-10Ch]
  void (__cdecl *v31)(char *); // [esp+4h] [ebp-108h]
  int v32; // [esp+8h] [ebp-104h]
  char v33[256]; // [esp+Ch] [ebp-100h] BYREF
  _DWORD *v34; // [esp+118h] [ebp+Ch]

  v7 = *(_DWORD *)(a1 + 344);
  v31 = *(void (__cdecl **)(char *))(v7 + 8);
  v32 = *(_DWORD *)(v7 + 4 * *(_DWORD *)(a2 + 16) + 12);
  result = a7;
  v34 = (_DWORD *)(a3 + 4 * a5);
  if ( a7 )
  {
    v30 = a7;
    do
    {
      v10 = v34;
      v11 = v33;
      v12 = 8;
      do
      {
        v13 = (unsigned __int8 *)(a6 + *v10++);
        v14 = v11 + 8;
        v15 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v15;
        v14 += 4;
        v16 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v16;
        v14 += 4;
        v17 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v17;
        v14 += 4;
        v18 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v18;
        v14 += 4;
        v19 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v19;
        v14 += 4;
        v20 = *v13++ - 128;
        *((_DWORD *)v14 - 2) = v20;
        v11 = v14 + 4;
        *((_DWORD *)v11 - 2) = *v13 - 128;
        --v12;
        *((_DWORD *)v11 - 1) = v13[1] - 128;
      }
      while ( v12 );
      v31(v33);
      v21 = a4;
      v22 = (int *)v33;
      v23 = 64;
      do
      {
        v24 = *v22;
        v25 = *(int *)((char *)v22 + v32 - (_DWORD)v33);
        if ( *v22 >= 0 )
        {
          v28 = (v25 >> 1) + v24;
          if ( v28 < v25 )
            LOWORD(v27) = 0;
          else
            v27 = v28 / v25;
        }
        else
        {
          v26 = (v25 >> 1) - v24;
          if ( v26 < v25 )
            LOWORD(v27) = 0;
          else
            v27 = -(v26 / v25);
        }
        *v21 = v27;
        ++v22;
        ++v21;
        --v23;
      }
      while ( v23 );
      result = v30 - 1;
      v29 = v30 == 1;
      a4 = v21;
      a6 += 8;
      --v30;
    }
    while ( !v29 );
  }
  return result;
}

//----- (0049DB70) --------------------------------------------------------
int __cdecl sub_49DB70(int a1, int a2, int a3, _WORD *a4, int a5, int a6, int a7)
{
  int v7; // eax
  int result; // eax
  _DWORD *v10; // esi
  char *v11; // ecx
  int v12; // ebp
  unsigned __int8 *v13; // eax
  int v14; // edx
  char *v15; // ecx
  int v16; // edx
  int v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // edx
  float *v21; // esi
  int v22; // ebp
  __int64 v23; // rax
  bool v24; // zf
  int v25; // [esp+4h] [ebp-10Ch]
  void (__cdecl *v26)(char *); // [esp+8h] [ebp-108h]
  int v27; // [esp+Ch] [ebp-104h]
  char v28[256]; // [esp+10h] [ebp-100h] BYREF
  _DWORD *v29; // [esp+11Ch] [ebp+Ch]

  v7 = *(_DWORD *)(a1 + 344);
  v26 = *(void (__cdecl **)(char *))(v7 + 28);
  v27 = *(_DWORD *)(v7 + 4 * *(_DWORD *)(a2 + 16) + 32);
  result = a7;
  v29 = (_DWORD *)(a3 + 4 * a5);
  if ( a7 )
  {
    v25 = a7;
    do
    {
      v10 = v29;
      v11 = v28;
      v12 = 8;
      do
      {
        v13 = (unsigned __int8 *)(*v10++ + a6);
        v14 = *v13++ - 128;
        v15 = v11 + 12;
        *((float *)v15 - 3) = (float)v14;
        v16 = *v13++ - 128;
        v15 += 8;
        *((float *)v15 - 4) = (float)v16;
        v17 = *v13++ - 128;
        v15 += 8;
        *((float *)v15 - 5) = (float)v17;
        v11 = v15 + 4;
        v18 = *v13++ - 128;
        *((float *)v11 - 5) = (float)v18;
        v19 = *v13++ - 128;
        *((float *)v11 - 4) = (float)v19;
        v20 = *v13++ - 128;
        *((float *)v11 - 3) = (float)v20;
        *((float *)v11 - 2) = (float)(*v13 - 128);
        --v12;
        *((float *)v11 - 1) = (float)(v13[1] - 128);
      }
      while ( v12 );
      v26(v28);
      v21 = (float *)v28;
      v22 = 64;
      do
      {
        v23 = (__int64)(*(float *)((char *)v21 + v27 - (_DWORD)v28) * *v21 + flt_4B0F90);
        ++v21;
        *a4++ = v23 - 0x4000;
        --v22;
      }
      while ( v22 );
      result = v25 - 1;
      v24 = v25 == 1;
      a6 += 8;
      --v25;
    }
    while ( !v24 );
  }
  return result;
}
// 4B0F90: using guessed type float flt_4B0F90;

//----- (0049DD30) --------------------------------------------------------
_DWORD *__cdecl sub_49DD30(int a1, char a2)
{
  _DWORD *result; // eax
  int v3; // ebp
  _DWORD *v4; // edi
  _DWORD *v5; // ebx

  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  result = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 324) = result;
  *result = sub_49DDE0;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 340) + 8) )
  {
    result[1] = sub_49DFF0;
    result = (_DWORD *)sub_49E1C0(a1);
  }
  else
  {
    result[1] = sub_49DE30;
    v3 = 0;
    if ( *(int *)(a1 + 60) > 0 )
    {
      v4 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 8);
      v5 = result + 2;
      do
      {
        *v5 = (*(int (__cdecl **)(int, int, int, _DWORD))(*(_DWORD *)(a1 + 4) + 8))(
                a1,
                1,
                8 * *(_DWORD *)(a1 + 216) * v4[5] / *v4,
                *(_DWORD *)(a1 + 220));
        result = *(_DWORD **)(a1 + 60);
        ++v3;
        ++v5;
        v4 += 21;
      }
      while ( v3 < (int)result );
    }
  }
  return result;
}
// 49DDE0: using guessed type int sub_49DDE0();

//----- (0049DE30) --------------------------------------------------------
unsigned int *__cdecl sub_49DE30(_DWORD *a1, int a2, int *a3, unsigned int *a4, int *a5, unsigned int *a6, unsigned int a7)
{
  int v7; // ecx
  unsigned int *result; // eax
  int *i; // edi
  unsigned int v10; // ebx
  int *v11; // ebp
  signed int v12; // edx
  unsigned int v13; // ecx
  int j; // ebx
  int v15; // ebp
  int *v16; // ebx
  _DWORD *v17; // edi

  v7 = *a3;
  result = a4;
  for ( i = (int *)a1[81]; *a3 < (unsigned int)a4; result = a4 )
  {
    result = a6;
    if ( *a6 >= a7 )
      break;
    v10 = a1[55] - i[13];
    if ( v10 >= (unsigned int)a4 - v7 )
      v10 = (unsigned int)a4 - v7;
    v11 = i + 2;
    (*(void (__cdecl **)(_DWORD *, int, int *, int, unsigned int))(a1[84] + 4))(a1, a2 + 4 * v7, i + 2, i[13], v10);
    *a3 += v10;
    v12 = v10 + i[13];
    v13 = i[12] - v10;
    i[13] = v12;
    i[12] = v13;
    if ( !v13 && v12 < a1[55] )
    {
      for ( j = 0; j < a1[15]; ++v11 )
      {
        sub_49DFB0(*v11, a1[7], i[13], a1[55]);
        ++j;
      }
      i[13] = a1[55];
    }
    if ( i[13] == a1[55] )
    {
      (*(void (__cdecl **)(_DWORD *, int *, _DWORD, int *, unsigned int))(a1[85] + 4))(a1, i + 2, 0, a5, *a6);
      i[13] = 0;
      ++*a6;
    }
    if ( !i[12] && *a6 < a7 )
    {
      v15 = 0;
      if ( (int)a1[15] > 0 )
      {
        v16 = a5;
        v17 = (_DWORD *)(a1[17] + 12);
        do
        {
          sub_49DFB0(*v16, 8 * v17[4], *a6 * *v17, a7 * *v17);
          ++v15;
          ++v16;
          v17 += 21;
        }
        while ( v15 < a1[15] );
      }
      result = a6;
      *a6 = a7;
      return result;
    }
    v7 = *a3;
  }
  return result;
}

//----- (0049DFB0) --------------------------------------------------------
const void **__cdecl sub_49DFB0(int a1, unsigned int a2, int a3, int a4)
{
  int i; // esi
  const void **result; // eax

  for ( i = a3; i < a4; ++i )
    result = sub_493EF0(a1, a3 - 1, a1, i, 1, a2);
  return result;
}

//----- (0049DFF0) --------------------------------------------------------
unsigned int __cdecl sub_49DFF0(unsigned int *a1, int a2, unsigned int *a3, unsigned int a4, int a5, unsigned int *a6, unsigned int a7)
{
  unsigned int *v7; // ebx
  _DWORD *v9; // edi
  unsigned int result; // eax
  unsigned int v11; // edx
  int v12; // ecx
  unsigned int v13; // ebp
  int v14; // ebx
  int v15; // ebp
  bool v16; // cc
  unsigned int v17; // eax
  signed int v18; // ebp
  int *v19; // ebx
  int v20; // ecx
  int *v21; // [esp+10h] [ebp-Ch]
  int v22; // [esp+14h] [ebp-8h]
  int v23; // [esp+18h] [ebp-4h]
  unsigned int v24; // [esp+20h] [ebp+4h]

  v7 = a6;
  v9 = (_DWORD *)a1[81];
  v23 = 3 * a1[55];
  for ( result = a7; *v7 < a7; result = a7 )
  {
    v11 = *a3;
    if ( *a3 >= a4 )
    {
      result = v9[12];
      if ( result )
        return result;
      if ( v9[13] < v9[15] )
      {
        v18 = 0;
        if ( (int)a1[15] > 0 )
        {
          v19 = v9 + 2;
          do
          {
            sub_49DFB0(*v19, a1[7], v9[13], v9[15]);
            ++v18;
            ++v19;
          }
          while ( v18 < (int)a1[15] );
          v7 = a6;
        }
        v9[13] = v9[15];
      }
    }
    else
    {
      v12 = v9[13];
      v13 = v9[15] - v12;
      v24 = v13;
      if ( v13 >= a4 - v11 )
      {
        v24 = a4 - v11;
        v13 = a4 - v11;
      }
      (*(void (__cdecl **)(unsigned int *, unsigned int, _DWORD *, int, unsigned int))(a1[84] + 4))(
        a1,
        a2 + 4 * v11,
        v9 + 2,
        v12,
        v13);
      if ( v9[12] == a1[8] )
      {
        v22 = 0;
        if ( (int)a1[15] > 0 )
        {
          v21 = v9 + 2;
          do
          {
            v14 = 1;
            if ( (int)a1[55] >= 1 )
            {
              v15 = -1;
              do
              {
                sub_493EF0(*v21, 0, *v21, v15, 1, a1[7]);
                ++v14;
                --v15;
              }
              while ( v14 <= (int)a1[55] );
              v13 = v24;
            }
            v16 = ++v22 < (int)a1[15];
            ++v21;
          }
          while ( v16 );
        }
      }
      v7 = a6;
      *a3 += v13;
      v17 = v9[12] - v13;
      v9[13] += v13;
      v9[12] = v17;
    }
    if ( v9[13] == v9[15] )
    {
      (*(void (__cdecl **)(unsigned int *, _DWORD *, _DWORD, int, unsigned int))(a1[85] + 4))(
        a1,
        v9 + 2,
        v9[14],
        a5,
        *v7);
      ++*v7;
      v20 = a1[55] + v9[14];
      v9[14] = v20;
      if ( v20 >= v23 )
        v9[14] = 0;
      if ( v9[13] >= v23 )
        v9[13] = 0;
      v9[15] = v9[13] + a1[55];
    }
  }
  return result;
}

//----- (0049E1C0) --------------------------------------------------------
int __cdecl sub_49E1C0(int a1)
{
  int v2; // ebx
  int v3; // edi
  int result; // eax
  unsigned int v5; // esi
  _DWORD *v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // ecx
  int *v9; // edx
  int v10; // esi
  int v11; // edi
  bool v12; // cc
  _DWORD *v13; // [esp+Ch] [ebp-18h]
  int v14; // [esp+10h] [ebp-14h]
  int v15; // [esp+14h] [ebp-10h]
  _DWORD *v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+28h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 220);
  v3 = *(_DWORD *)(a1 + 324);
  v17 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 20 * v2 * *(_DWORD *)(a1 + 60));
  result = *(_DWORD *)(a1 + 68);
  v15 = 0;
  if ( *(int *)(a1 + 60) > 0 )
  {
    v5 = 12 * v2;
    v6 = (_DWORD *)(result + 8);
    v13 = (_DWORD *)(result + 8);
    v16 = (_DWORD *)(v3 + 8);
    while ( 1 )
    {
      v7 = (_DWORD *)(*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
                       a1,
                       1,
                       8 * *(_DWORD *)(a1 + 216) * v6[5] / *v6,
                       3 * v2);
      qmemcpy((void *)(v17 + 4 * v2), v7, v5);
      if ( v2 > 0 )
      {
        v8 = (_DWORD *)(v17 + 16 * v2);
        v9 = &v7[2 * v2];
        v10 = v17 - (_DWORD)v7;
        v14 = v2;
        do
        {
          v11 = *v9++;
          *(_DWORD *)((char *)v7 + v10) = v11;
          *v8++ = *v7++;
          --v14;
        }
        while ( v14 );
      }
      *v16 = v17 + 4 * v2;
      v17 += 20 * v2;
      ++v16;
      result = v15 + 1;
      v12 = ++v15 < *(_DWORD *)(a1 + 60);
      v13 += 21;
      if ( !v12 )
        break;
      v6 = v13;
      v5 = 12 * v2;
    }
  }
  return result;
}

//----- (0049E2F0) --------------------------------------------------------
char __cdecl sub_49E2F0(int a1)
{
  int v2; // ebx
  _DWORD *v3; // ebp
  _DWORD *v4; // edi
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  char v9; // [esp+Bh] [ebp-5h]
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+14h] [ebp+4h]

  v9 = 1;
  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 52);
  *(_DWORD *)(a1 + 340) = v2;
  v11 = v2;
  *(_DWORD *)v2 = nullsub_17;
  *(_DWORD *)(v2 + 4) = sub_49E480;
  *(_BYTE *)(v2 + 8) = 0;
  if ( *(_BYTE *)(a1 + 179) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v10 = 0;
  if ( *(int *)(a1 + 60) > 0 )
  {
    v3 = (_DWORD *)(*(_DWORD *)(a1 + 68) + 12);
    v4 = (_DWORD *)(v2 + 12);
    do
    {
      v5 = *(v3 - 1);
      v6 = *(_DWORD *)(a1 + 216);
      if ( v5 == v6 && *v3 == *(_DWORD *)(a1 + 220) )
      {
        if ( *(_DWORD *)(a1 + 180) )
        {
          *v4 = sub_49EB70;
          *(_BYTE *)(v2 + 8) = 1;
        }
        else
        {
          *v4 = sub_49E6A0;
        }
      }
      else
      {
        if ( 2 * v5 != v6 )
          goto LABEL_18;
        if ( *v3 == *(_DWORD *)(a1 + 220) )
        {
          v2 = v11;
          v9 = 0;
          *v4 = sub_49E6F0;
        }
        else
        {
          v2 = v11;
          if ( 2 * v5 != v6 || 2 * *v3 != *(_DWORD *)(a1 + 220) )
          {
LABEL_18:
            if ( v6 % v5 || *(_DWORD *)(a1 + 220) % *v3 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 38;
              (**(void (__cdecl ***)(int))a1)(a1);
            }
            else
            {
              v9 = 0;
              *v4 = sub_49E510;
            }
            goto LABEL_22;
          }
          if ( *(_DWORD *)(a1 + 180) )
          {
            *v4 = sub_49E880;
            *(_BYTE *)(v11 + 8) = 1;
          }
          else
          {
            *v4 = sub_49E7A0;
          }
        }
      }
LABEL_22:
      ++v4;
      v3 += 21;
      ++v10;
    }
    while ( v10 < *(_DWORD *)(a1 + 60) );
  }
  v7 = *(_DWORD *)(a1 + 180);
  if ( v7 )
  {
    LOBYTE(v7) = v9;
    if ( !v9 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 99;
      LOBYTE(v7) = (*(int (__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 4))(a1, 0);
    }
  }
  return v7;
}
// 49E470: using guessed type int nullsub_17();
// 49E6A0: using guessed type int sub_49E6A0();

//----- (0049E480) --------------------------------------------------------
int __cdecl sub_49E480(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebp
  int v8; // edi
  _DWORD *v9; // esi
  void (__cdecl **v10)(_DWORD *, int, int, int); // ebp
  int i; // eax
  int v12; // [esp+14h] [ebp+4h]

  result = a1[15];
  v7 = a1[85];
  v8 = a1[17];
  v12 = 0;
  if ( result > 0 )
  {
    v9 = a2;
    v10 = (void (__cdecl **)(_DWORD *, int, int, int))(v7 + 12);
    for ( i = a4 - (_DWORD)a2; ; i = a4 - (_DWORD)a2 )
    {
      (*v10)(a1, v8, 4 * a3 + *v9, *(_DWORD *)((char *)v9 + i) + 4 * a5 * *(_DWORD *)(v8 + 12));
      result = v12 + 1;
      ++v9;
      ++v10;
      v8 += 84;
      if ( ++v12 >= a1[15] )
        break;
    }
  }
  return result;
}

//----- (0049E510) --------------------------------------------------------
int __cdecl sub_49E510(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ebp
  int v5; // esi
  int result; // eax
  int v7; // ebx
  int v8; // ebp
  _DWORD *v9; // edi
  unsigned __int8 *v10; // eax
  int v11; // ecx
  _BYTE *v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h]
  int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+28h] [ebp-4h]
  _DWORD *v17; // [esp+30h] [ebp+4h]
  int v19; // [esp+3Ch] [ebp+10h]

  v4 = 8 * a2[7];
  v16 = v4;
  v5 = a1[54] / a2[2];
  v14 = a1[55] / a2[3];
  sub_49E640((int)a2, a3, a1[55], a1[7], v4 * v5);
  result = a2[3];
  v15 = 0;
  if ( result > 0 )
  {
    v17 = a3;
    do
    {
      v7 = 0;
      v12 = (_BYTE *)*a4;
      if ( v4 )
      {
        v13 = v4;
        do
        {
          v8 = 0;
          if ( v14 > 0 )
          {
            v9 = v17;
            v19 = v14;
            do
            {
              v10 = (unsigned __int8 *)(v7 + *v9);
              if ( v5 > 0 )
              {
                v11 = v5;
                do
                {
                  v8 += *v10++;
                  --v11;
                }
                while ( v11 );
              }
              ++v9;
              --v19;
            }
            while ( v19 );
          }
          v7 += v5;
          *v12++ = (v8 + v5 * v14 / 2) / (v5 * v14);
          --v13;
        }
        while ( v13 );
        v4 = v16;
      }
      ++a4;
      v17 += v14;
      result = ++v15;
    }
    while ( v15 < a2[3] );
  }
  return result;
}

//----- (0049E640) --------------------------------------------------------
void __usercall sub_49E640(int a1@<ebx>, _DWORD *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp
  char *v7; // edi
  int v8; // eax
  int v9; // [esp+14h] [ebp+10h]

  v5 = a5 - a4;
  if ( a5 - a4 > 0 && a3 > 0 )
  {
    v9 = a3;
    do
    {
      v7 = (char *)(*a2++ + a4);
      LOBYTE(a1) = *(v7 - 1);
      BYTE1(a1) = a1;
      v8 = a1 << 16;
      LOWORD(v8) = a1;
      memset32(v7, v8, v5 >> 2);
      memset(&v7[4 * (v5 >> 2)], a1, v5 & 3);
      --v9;
    }
    while ( v9 );
  }
}

//----- (0049E6F0) --------------------------------------------------------
int __usercall sub_49E6F0@<eax>(int a1@<ebx>, int a2, int a3, unsigned __int8 **a4, int a5)
{
  int v5; // ebp
  int v6; // edi
  int result; // eax
  unsigned __int8 **v8; // edx
  int v9; // ebx
  _BYTE *v10; // ecx
  unsigned __int8 *v11; // eax
  int v12; // esi
  int v13; // ebx
  int v14; // ebp
  int v15; // ebp
  bool v16; // cc
  int v17; // [esp+Ch] [ebp-4h]
  int v18; // [esp+14h] [ebp+4h]
  int v19; // [esp+20h] [ebp+10h]

  v5 = a3;
  v6 = 8 * *(_DWORD *)(a3 + 28);
  v17 = v6;
  sub_49E640(a1, a4, *(_DWORD *)(a2 + 220), *(_DWORD *)(a2 + 28), 16 * *(_DWORD *)(a3 + 28));
  result = *(_DWORD *)(a3 + 12);
  v18 = 0;
  if ( result > 0 )
  {
    v8 = a4;
    v9 = a5 - (_DWORD)a4;
    v19 = a5 - (_DWORD)a4;
    do
    {
      v10 = *(unsigned __int8 **)((char *)v8 + v9);
      v11 = *v8;
      v12 = 0;
      if ( v6 )
      {
        do
        {
          v13 = *v11;
          v14 = v12;
          v12 ^= 1u;
          v15 = v11[1] + v14;
          v11 += 2;
          *v10++ = (v15 + v13) >> 1;
          --v6;
        }
        while ( v6 );
        v6 = v17;
        v5 = a3;
        v8 = a4;
        v9 = v19;
      }
      result = v18 + 1;
      ++v8;
      v16 = ++v18 < *(_DWORD *)(v5 + 12);
      a4 = v8;
    }
    while ( v16 );
  }
  return result;
}

//----- (0049E7A0) --------------------------------------------------------
int __cdecl sub_49E7A0(int a1, int a2, unsigned __int8 **a3, _DWORD *a4)
{
  int v4; // ebp
  int v5; // ebx
  int result; // eax
  unsigned __int8 **v7; // edx
  unsigned __int8 *v8; // eax
  _BYTE *v9; // esi
  unsigned __int8 *v10; // ecx
  int v11; // edi
  int v12; // edx
  int v13; // ebp
  int v14; // ebx
  int v15; // ebx
  bool v16; // cc
  unsigned __int8 **v17; // [esp+Ch] [ebp-Ch]
  int v18; // [esp+10h] [ebp-8h]
  int v19; // [esp+14h] [ebp-4h]
  int v21; // [esp+24h] [ebp+Ch]

  v4 = a2;
  v5 = 8 * *(_DWORD *)(a2 + 28);
  v19 = v5;
  sub_49E640(v5, a3, *(_DWORD *)(a1 + 220), *(_DWORD *)(a1 + 28), 16 * *(_DWORD *)(a2 + 28));
  result = *(_DWORD *)(a2 + 12);
  v18 = 0;
  if ( result > 0 )
  {
    v7 = a3;
    v17 = a3;
    do
    {
      v8 = *v7;
      v9 = (_BYTE *)*a4;
      v10 = v7[1];
      v11 = 1;
      if ( v5 )
      {
        v21 = v5;
        do
        {
          v12 = *v8;
          v13 = v8[1] + v10[1];
          v8 += 2;
          v14 = *v10;
          v10 += 2;
          v15 = v11 + v14;
          v11 ^= 3u;
          *v9++ = (v13 + v15 + v12) >> 2;
          --v21;
        }
        while ( v21 );
        v5 = v19;
        v4 = a2;
        v7 = v17;
      }
      v7 += 2;
      result = v18 + 1;
      v16 = v18 + 1 < *(_DWORD *)(v4 + 12);
      v17 = v7;
      ++v18;
      ++a4;
    }
    while ( v16 );
  }
  return result;
}

//----- (0049E880) --------------------------------------------------------
unsigned __int8 **__cdecl sub_49E880(int *a1, int a2, int a3, _BYTE **a4)
{
  int v4; // esi
  int v5; // eax
  int v6; // edx
  unsigned __int8 **result; // eax
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // esi
  unsigned __int8 *v11; // edi
  int v12; // edx
  _BYTE *v13; // eax
  unsigned __int8 *v14; // ecx
  unsigned __int8 *v15; // esi
  unsigned __int8 *v16; // eax
  int v17; // edx
  int v18; // edx
  bool v19; // zf
  bool v20; // cc
  int v21; // [esp+10h] [ebp-2Ch]
  unsigned __int8 *v22; // [esp+20h] [ebp-1Ch]
  int v23; // [esp+20h] [ebp-1Ch]
  int v24; // [esp+24h] [ebp-18h]
  int v25; // [esp+28h] [ebp-14h]
  int v26; // [esp+38h] [ebp-4h]
  int v27; // [esp+40h] [ebp+4h]
  _BYTE *v28; // [esp+48h] [ebp+Ch]

  v4 = 8 * *(_DWORD *)(a2 + 28);
  sub_49E640(a3 - 4, (_DWORD *)(a3 - 4), a1[55] + 2, a1[7], 16 * *(_DWORD *)(a2 + 28));
  v5 = a1[45];
  v25 = 0;
  v6 = 80 * v5;
  v27 = 16 * v5;
  result = *(unsigned __int8 ***)(a2 + 12);
  v21 = 0x4000 - v6;
  if ( (int)result > 0 )
  {
    result = (unsigned __int8 **)(a3 - 4);
    v26 = v4 - 2;
    v24 = a3 - 4;
    do
    {
      v8 = result[1];
      v9 = result[3];
      v10 = result[2];
      v22 = *result + 2;
      v11 = v9 + 2;
      v12 = v27
          * (*v9 + **result + *v22 + 2 * (*v9 + **result + *v10 + (*result)[1] + v9[1] + *v8 + v8[2] + v10[2]) + v9[2])
          + v21 * (*v10 + v10[1] + *v8 + v8[1])
          + 0x8000;
      v13 = *a4;
      v14 = v10 + 2;
      v15 = v22;
      *v13 = BYTE2(v12);
      v28 = v13 + 1;
      v16 = v8 + 2;
      if ( v26 )
      {
        v23 = v26;
        do
        {
          v16 += 2;
          v17 = *(v14 - 1) + v15[1] + v11[1];
          v14 += 2;
          v15 += 2;
          v18 = *v11 + *(v16 - 3) + v17;
          v11 += 2;
          *v28 = (v21 * (*(v16 - 2) + *(v14 - 2) + *(v16 - 1) + *(v14 - 1))
                + v27 * (*v11 + *v15 + *(v15 - 3) + *(v11 - 3) + 2 * (*v14 + *v16 + (unsigned int)*(v15 - 2) + v18))
                + 0x8000) >> 16;
          v19 = v23 == 1;
          ++v28;
          --v23;
        }
        while ( !v19 );
      }
      *v28 = (v27
            * (v11[1]
             + v15[1]
             + *(v11 - 1)
             + 2 * (v11[1] + v15[1] + v14[1] + *(v16 - 1) + *(v14 - 1) + v16[1] + *v11 + *v15)
             + *(v15 - 1))
            + v21 * (v14[1] + *v14 + v16[1] + (unsigned int)*v16)
            + 0x8000) >> 16;
      result = (unsigned __int8 **)(v24 + 8);
      v20 = v25 + 1 < *(_DWORD *)(a2 + 12);
      v24 += 8;
      ++v25;
      ++a4;
    }
    while ( v20 );
  }
  return result;
}

//----- (0049EB70) --------------------------------------------------------
_DWORD *__cdecl sub_49EB70(int *a1, int a2, int a3, _BYTE **a4)
{
  int v4; // esi
  int v5; // eax
  int v6; // ecx
  _DWORD *result; // eax
  unsigned __int8 *v8; // edi
  unsigned __int8 *v9; // ecx
  int v10; // esi
  int v11; // edx
  unsigned __int8 *v12; // ebp
  unsigned __int8 *v13; // edi
  unsigned __int8 *v14; // ecx
  int v15; // eax
  int v16; // edx
  _BYTE *v17; // esi
  int v18; // edx
  _BYTE *v19; // esi
  int v20; // eax
  int v21; // ebx
  int v22; // esi
  int v23; // edx
  int v24; // ebx
  bool v25; // zf
  bool v26; // cc
  int v27; // [esp+10h] [ebp-18h]
  int v28; // [esp+14h] [ebp-14h]
  int v29; // [esp+18h] [ebp-10h]
  int v30; // [esp+1Ch] [ebp-Ch]
  int v31; // [esp+20h] [ebp-8h]
  int v32; // [esp+24h] [ebp-4h]
  int v33; // [esp+2Ch] [ebp+4h]
  int v34; // [esp+2Ch] [ebp+4h]
  _BYTE *v35; // [esp+34h] [ebp+Ch]

  v4 = 8 * *(_DWORD *)(a2 + 28);
  sub_49E640(a2, (_DWORD *)(a3 - 4), a1[55] + 2, a1[7], v4);
  v5 = a1[45];
  v6 = 128 - v5;
  v27 = v5 << 6;
  result = *(_DWORD **)(a2 + 12);
  v28 = v6 << 9;
  v30 = 0;
  if ( (int)result > 0 )
  {
    result = (_DWORD *)(a3 + 4);
    v32 = v4 - 2;
    v31 = a3 + 4;
    do
    {
      v8 = (unsigned __int8 *)*(result - 2);
      v9 = (unsigned __int8 *)*(result - 1);
      v10 = *v9;
      v11 = *(unsigned __int8 *)*result + v10 + *v8;
      v12 = (unsigned __int8 *)(*result + 1);
      v13 = v8 + 1;
      v14 = v9 + 1;
      v33 = v11;
      v15 = *v14 + *v13 + *v12;
      v16 = v27 * (v15 + 2 * v11 - v10) + v28 * v10 + 0x8000;
      v17 = *a4;
      *v17 = BYTE2(v16);
      v18 = v33;
      v19 = v17 + 1;
      v34 = v15;
      v35 = v19;
      if ( v32 )
      {
        v29 = v32;
        do
        {
          v20 = *v14;
          v21 = v13[1];
          ++v14;
          ++v13;
          v22 = v20;
          ++v12;
          v23 = v18 - v20;
          v15 = *v14 + v21 + *v12;
          v24 = v34;
          v34 = v15;
          *v35 = (unsigned int)(v27 * (v24 + v15 + v23) + v28 * v22 + 0x8000) >> 16;
          v18 = v24;
          v19 = v35 + 1;
          v25 = v29 == 1;
          ++v35;
          --v29;
        }
        while ( !v25 );
      }
      *v19 = (v27 * (v18 + 2 * v15 - *v14) + v28 * (unsigned int)*v14 + 0x8000) >> 16;
      result = (_DWORD *)(v31 + 4);
      v26 = ++v30 < *(_DWORD *)(a2 + 12);
      ++a4;
      v31 += 4;
    }
    while ( v26 );
  }
  return result;
}

//----- (0049ED10) --------------------------------------------------------
int __cdecl sub_49ED10(int a1)
{
  int *(__cdecl **v1)(int); // edi
  int result; // eax

  v1 = (int *(__cdecl **)(int))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 12);
  *(_DWORD *)(a1 + 336) = v1;
  *v1 = (int *(__cdecl *)(int))nullsub_18;
  switch ( *(_DWORD *)(a1 + 40) )
  {
    case 1:
      if ( *(_DWORD *)(a1 + 36) != 1 )
        goto LABEL_9;
      break;
    case 2:
    case 3:
      if ( *(_DWORD *)(a1 + 36) != 3 )
        goto LABEL_9;
      break;
    case 4:
    case 5:
      if ( *(_DWORD *)(a1 + 36) != 4 )
        goto LABEL_9;
      break;
    default:
      if ( *(int *)(a1 + 36) < 1 )
      {
LABEL_9:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 9;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      break;
  }
  result = *(_DWORD *)(a1 + 64);
  switch ( result )
  {
    case 1:
      if ( *(_DWORD *)(a1 + 60) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      result = *(_DWORD *)(a1 + 40);
      switch ( result )
      {
        case 1:
          v1[1] = (int *(__cdecl *)(int))sub_49F380;
          break;
        case 2:
          *v1 = sub_49EF50;
          v1[1] = (int *(__cdecl *)(int))sub_49F160;
          break;
        case 3:
          v1[1] = (int *(__cdecl *)(int))sub_49F380;
          break;
        default:
          goto LABEL_38;
      }
      return result;
    case 2:
      if ( *(_DWORD *)(a1 + 60) != 3 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      if ( *(_DWORD *)(a1 + 40) == 2 )
        goto LABEL_42;
      goto LABEL_38;
    case 3:
      if ( *(_DWORD *)(a1 + 60) != 3 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      result = *(_DWORD *)(a1 + 40);
      if ( result == 2 )
      {
        *v1 = sub_49EF50;
        v1[1] = (int *(__cdecl *)(int))sub_49F030;
        return result;
      }
      if ( result != 3 )
        goto LABEL_38;
      goto LABEL_42;
    case 4:
      if ( *(_DWORD *)(a1 + 60) != 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      if ( *(_DWORD *)(a1 + 40) != 4 )
        goto LABEL_38;
      goto LABEL_42;
    case 5:
      if ( *(_DWORD *)(a1 + 60) != 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 10;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      result = *(_DWORD *)(a1 + 40);
      if ( result == 4 )
      {
        *v1 = sub_49EF50;
        v1[1] = (int *(__cdecl *)(int))sub_49F210;
      }
      else if ( result == 5 )
      {
LABEL_42:
        v1[1] = (int *(__cdecl *)(int))sub_49F3F0;
      }
      else
      {
LABEL_38:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      return result;
    default:
      if ( result != *(_DWORD *)(a1 + 40) || (result = *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 60) != result) )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 27;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      goto LABEL_42;
  }
}
// 49F3F0: using guessed type int __cdecl sub_49F3F0(int);
// 49F490: using guessed type int nullsub_18();

//----- (0049EF50) --------------------------------------------------------
int *__cdecl sub_49EF50(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int v7; // ecx
  int *result; // eax
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+1Ch] [ebp+4h]

  v1 = *(_DWORD *)(a1 + 336);
  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 0x2000);
  *(_DWORD *)(v1 + 8) = v2;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v10 = 0;
  v9 = 0;
  v11 = 8421375;
  v7 = 0x8000;
  result = (int *)(v2 + 2048);
  do
  {
    *(result - 512) = v3;
    *(result - 256) = v6;
    *result = v7;
    result[256] = v5;
    result[512] = v4;
    result[768] = v11;
    result[1024] = v9;
    result[1280] = v10;
    v7 += 7471;
    v11 += 0x8000;
    v3 += 19595;
    v9 -= 27439;
    ++result;
    v6 += 38470;
    v5 -= 11059;
    v4 -= 21709;
    v10 -= 5329;
  }
  while ( v7 <= 1937873 );
  return result;
}

//----- (0049F030) --------------------------------------------------------
int __cdecl sub_49F030(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5)
{
  int result; // eax
  int v6; // edx
  _DWORD *v7; // edi
  unsigned __int8 *v8; // esi
  int v9; // ebx
  _BYTE *v10; // ecx
  int v11; // edx
  int v12; // ebp
  int v13; // [esp+0h] [ebp-10h]
  int v14; // [esp+4h] [ebp-Ch]
  int v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+Ch] [ebp-4h]
  int v17; // [esp+14h] [ebp+4h]
  int v18; // [esp+14h] [ebp+4h]
  int v19; // [esp+20h] [ebp+10h]

  v13 = *(_DWORD *)(a1 + 28);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 336) + 8);
  if ( a5 - 1 >= 0 )
  {
    v6 = 4 * a4;
    v7 = a3;
    do
    {
      v8 = *a2;
      v17 = *(_DWORD *)(v6 + v7[2]);
      ++a2;
      v9 = *(_DWORD *)(v6 + *v7);
      v10 = *(_BYTE **)(v6 + v7[1]);
      v6 += 4;
      v16 = v6;
      if ( v13 )
      {
        v19 = v9 - (_DWORD)v10;
        v15 = v17 - (_DWORD)v10;
        v18 = v13;
        do
        {
          v11 = *v8;
          v8 += 3;
          v12 = *(v8 - 2);
          v14 = *(v8 - 1);
          v10[v19] = (unsigned int)(*(_DWORD *)(result + 4 * v11)
                                  + *(_DWORD *)(result + 4 * v12 + 1024)
                                  + *(_DWORD *)(result + 4 * v14 + 2048)) >> 16;
          *v10 = (unsigned int)(*(_DWORD *)(result + 4 * v11 + 3072)
                              + *(_DWORD *)(result + 4 * v12 + 4096)
                              + *(_DWORD *)(result + 4 * v14 + 5120)) >> 16;
          (v10++)[v15] = (unsigned int)(*(_DWORD *)(result + 4 * v11 + 5120)
                                      + *(_DWORD *)(result + 4 * v12 + 6144)
                                      + *(_DWORD *)(result + 4 * v14 + 7168)) >> 16;
          --v18;
        }
        while ( v18 );
        v7 = a3;
        v6 = v16;
      }
      --a5;
    }
    while ( a5 );
  }
  return result;
}

//----- (0049F160) --------------------------------------------------------
int __cdecl sub_49F160(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5)
{
  unsigned int v5; // edx
  int v6; // esi
  int result; // eax
  int v8; // edi
  unsigned __int8 *v9; // eax
  unsigned int v10; // ecx
  int v11; // edx
  unsigned int v12; // [esp+4h] [ebp-4h]
  int v13; // [esp+Ch] [ebp+4h]
  int v14; // [esp+1Ch] [ebp+14h]

  v5 = *(_DWORD *)(a1 + 28);
  v12 = v5;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 336) + 8);
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v8 = 4 * a4;
    v13 = a5;
    do
    {
      v8 += 4;
      v9 = *a2++;
      v14 = *(_DWORD *)(*a3 + v8 - 4);
      v10 = 0;
      if ( v5 )
      {
        do
        {
          v11 = *v9;
          v9 += 3;
          *(_BYTE *)(v10 + v14) = (unsigned int)(*(_DWORD *)(v6 + 4 * v11)
                                               + *(_DWORD *)(v6 + 4 * *(v9 - 2) + 1024)
                                               + *(_DWORD *)(v6 + 4 * *(v9 - 1) + 2048)) >> 16;
          v5 = v12;
          ++v10;
        }
        while ( v10 < v12 );
      }
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (0049F210) --------------------------------------------------------
int __cdecl sub_49F210(int a1, unsigned __int8 **a2, _DWORD *a3, int a4, int a5)
{
  int result; // eax
  int v6; // ecx
  _DWORD *v7; // esi
  unsigned __int8 *v8; // edx
  _BYTE *v9; // ebp
  int v10; // edi
  int v11; // ecx
  int v12; // esi
  int v13; // edi
  int v14; // [esp+0h] [ebp-14h]
  int v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+4h] [ebp-10h]
  int v17; // [esp+8h] [ebp-Ch]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]
  unsigned __int8 *v20; // [esp+18h] [ebp+4h]
  int v21; // [esp+24h] [ebp+10h]
  int v22; // [esp+28h] [ebp+14h]
  int v23; // [esp+28h] [ebp+14h]

  v14 = *(_DWORD *)(a1 + 28);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 336) + 8);
  if ( a5 - 1 >= 0 )
  {
    v6 = 4 * a4;
    v7 = a3;
    v21 = a5;
    do
    {
      v8 = *a2;
      v15 = *(_DWORD *)(v7[2] + v6);
      ++a2;
      v20 = v8;
      v9 = *(_BYTE **)(v6 + *v7);
      v22 = *(_DWORD *)(v6 + v7[3]);
      v10 = *(_DWORD *)(v6 + v7[1]);
      v6 += 4;
      v19 = v6;
      if ( v14 )
      {
        v18 = v10 - (_DWORD)v9;
        v17 = v22 - (_DWORD)v9;
        v23 = v14;
        v16 = v15 - (_DWORD)v9;
        while ( 1 )
        {
          v11 = 255 - *v8;
          v12 = 255 - v8[1];
          v13 = 255 - v8[2];
          v9[v17] = v8[3];
          v20 += 4;
          *v9 = (unsigned int)(*(_DWORD *)(result + 4 * v11)
                             + *(_DWORD *)(result + 4 * v12 + 1024)
                             + *(_DWORD *)(result + 4 * v13 + 2048)) >> 16;
          v9[v18] = (unsigned int)(*(_DWORD *)(result + 4 * v11 + 3072)
                                 + *(_DWORD *)(result + 4 * v12 + 4096)
                                 + *(_DWORD *)(result + 4 * v13 + 5120)) >> 16;
          (v9++)[v16] = (unsigned int)(*(_DWORD *)(result + 4 * v11 + 5120)
                                     + *(_DWORD *)(result + 4 * v12 + 6144)
                                     + *(_DWORD *)(result + 4 * v13 + 7168)) >> 16;
          if ( !--v23 )
            break;
          v8 = v20;
        }
        v7 = a3;
        v6 = v19;
      }
      --v21;
    }
    while ( v21 );
  }
  return result;
}

//----- (0049F380) --------------------------------------------------------
int __cdecl sub_49F380(int a1, _BYTE **a2, _DWORD *a3, int a4, int a5)
{
  unsigned int v5; // edi
  int result; // eax
  int v8; // ebp
  _BYTE *v9; // ecx
  int v10; // esi
  unsigned int i; // eax
  int v12; // [esp+4h] [ebp-4h]
  int v13; // [esp+Ch] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 28);
  v12 = *(_DWORD *)(a1 + 36);
  result = a5 - 1;
  if ( a5 - 1 >= 0 )
  {
    v8 = 4 * a4;
    v13 = a5;
    do
    {
      v9 = *a2++;
      v8 += 4;
      v10 = *(_DWORD *)(*a3 + v8 - 4);
      for ( i = 0; i < v5; ++i )
      {
        *(_BYTE *)(i + v10) = *v9;
        v9 += v12;
      }
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (0049F3F4) --------------------------------------------------------
int __usercall sub_49F3F4@<eax>(int a1@<eax>, int a2, _DWORD *a3, _DWORD *a4, int a5, int a6)
{
  int v6; // ebp
  unsigned int v7; // edi
  int result; // eax
  int v9; // edx
  int v10; // ebx
  _DWORD *v11; // edx
  int v12; // esi
  unsigned int v13; // eax
  char *v14; // ecx
  char v15; // bl
  bool v16; // zf
  int v17; // [esp+Ch] [ebp+4h]
  int v18; // [esp+18h] [ebp+10h]
  int v19; // [esp+1Ch] [ebp+14h]

  v6 = *(_DWORD *)(a1 + 60);
  v7 = *(_DWORD *)(a1 + 28);
  result = a6 - 1;
  if ( a6 - 1 >= 0 )
  {
    v9 = 4 * a5;
    v18 = a6;
    v17 = v9;
    do
    {
      v10 = 0;
      v19 = 0;
      if ( v6 > 0 )
      {
        v11 = a4;
        do
        {
          v12 = *(_DWORD *)(*v11 + v17);
          v13 = 0;
          if ( v7 )
          {
            v14 = (char *)(v10 + *a3);
            do
            {
              v15 = *v14;
              v14 += v6;
              *(_BYTE *)(v13 + v12) = v15;
              ++v13;
            }
            while ( v13 < v7 );
            v10 = v19;
          }
          ++v10;
          ++v11;
          v19 = v10;
        }
        while ( v10 < v6 );
      }
      ++a3;
      result = v18 - 1;
      v16 = v18 == 1;
      v17 += 4;
      --v18;
    }
    while ( !v16 );
  }
  return result;
}

//----- (0049F4A0) --------------------------------------------------------
int __cdecl sub_49F4A0(int a1, char a2)
{
  int v2; // edi
  int result; // eax

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32);
  *(_DWORD *)(a1 + 316) = v2;
  *(_DWORD *)v2 = sub_49FAE0;
  *(_DWORD *)(v2 + 4) = sub_49FF50;
  *(_DWORD *)(v2 + 8) = sub_49FF80;
  *(_BYTE *)(v2 + 13) = 0;
  sub_49F560((_DWORD *)a1);
  result = *(_DWORD *)(a1 + 172);
  if ( result )
  {
    result = sub_49F730(a1);
  }
  else
  {
    *(_BYTE *)(a1 + 212) = 0;
    *(_DWORD *)(a1 + 168) = 1;
  }
  if ( *(_BYTE *)(a1 + 212) )
    *(_BYTE *)(a1 + 178) = 1;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 178) )
      *(_DWORD *)(v2 + 16) = 1;
    else
      *(_DWORD *)(v2 + 16) = 2;
  }
  else
  {
    *(_DWORD *)(v2 + 16) = 0;
  }
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  if ( *(_BYTE *)(a1 + 178) )
    *(_DWORD *)(v2 + 24) = 2 * *(_DWORD *)(a1 + 168);
  else
    *(_DWORD *)(v2 + 24) = *(_DWORD *)(a1 + 168);
  return result;
}
// 49FAE0: using guessed type int sub_49FAE0();

//----- (0049F560) --------------------------------------------------------
int __cdecl sub_49F560(_DWORD *a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ebp
  int *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ebp
  int v9; // edi
  int v10; // ecx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int result; // eax

  if ( !a1[8] || !a1[7] || (int)a1[15] <= 0 || (int)a1[9] <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 32;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[8] > 65500 || (int)a1[7] > 65500 )
  {
    *(_DWORD *)(*a1 + 20) = 41;
    *(_DWORD *)(*a1 + 24) = 65500;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a1[14] != 8 )
  {
    *(_DWORD *)(*a1 + 20) = 15;
    *(_DWORD *)(*a1 + 24) = a1[14];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[15] > 10 )
  {
    *(_DWORD *)(*a1 + 20) = 26;
    *(_DWORD *)(*a1 + 24) = a1[15];
    *(_DWORD *)(*a1 + 28) = 10;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v1 = a1[15];
  v2 = a1[17];
  v3 = 0;
  a1[54] = 1;
  a1[55] = 1;
  if ( v1 > 0 )
  {
    v4 = (int *)(v2 + 12);
    do
    {
      v5 = *(v4 - 1);
      if ( v5 <= 0 || v5 > 4 || *v4 <= 0 || *v4 > 4 )
      {
        *(_DWORD *)(*a1 + 20) = 18;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      v6 = a1[54];
      if ( v6 <= *(v4 - 1) )
        v6 = *(v4 - 1);
      a1[54] = v6;
      v7 = a1[55];
      if ( v7 <= *v4 )
        v7 = *v4;
      a1[55] = v7;
      ++v3;
      v4 += 21;
    }
    while ( v3 < a1[15] );
  }
  v8 = 0;
  if ( (int)a1[15] > 0 )
  {
    v9 = a1[17] + 36;
    do
    {
      v10 = *(_DWORD *)(v9 - 28);
      *(_DWORD *)(v9 - 32) = v8;
      *(_DWORD *)v9 = 8;
      *(_DWORD *)(v9 - 8) = sub_493EC0(a1[7] * v10, 8 * a1[54]);
      v11 = sub_493EC0(a1[8] * *(_DWORD *)(v9 - 24), 8 * a1[55]);
      v12 = *(_DWORD *)(v9 - 28);
      *(_DWORD *)(v9 - 4) = v11;
      v13 = sub_493EC0(a1[7] * v12, a1[54]);
      v14 = *(_DWORD *)(v9 - 24);
      *(_DWORD *)(v9 + 4) = v13;
      *(_DWORD *)(v9 + 8) = sub_493EC0(a1[8] * v14, a1[55]);
      *(_BYTE *)(v9 + 12) = 1;
      ++v8;
      v9 += 84;
    }
    while ( v8 < a1[15] );
  }
  result = sub_493EC0(a1[8], 8 * a1[55]);
  a1[56] = result;
  return result;
}

//----- (0049F730) --------------------------------------------------------
int __cdecl sub_49F730(int a1)
{
  int *v1; // ebp
  signed int v2; // ecx
  int v3; // ecx
  int v4; // edi
  int v5; // ebx
  int v6; // edi
  int *v7; // ebx
  int v8; // ebp
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  _DWORD *v12; // ebx
  int *v13; // edi
  int v14; // ebx
  int *v15; // edi
  int v16; // ebp
  bool v17; // zf
  _DWORD *v18; // ebp
  int v19; // ebx
  char *v20; // edi
  bool v21; // cc
  int result; // eax
  int v23; // edi
  int *v24; // ebx
  int i; // edi
  int v26; // [esp+10h] [ebp-A2Ch]
  int *v27; // [esp+14h] [ebp-A28h]
  int v28; // [esp+18h] [ebp-A24h]
  int v29; // [esp+18h] [ebp-A24h]
  int v30; // [esp+1Ch] [ebp-A20h]
  _DWORD *v31; // [esp+20h] [ebp-A1Ch]
  int v32; // [esp+24h] [ebp-A18h]
  int v33; // [esp+28h] [ebp-A14h]
  int v34; // [esp+2Ch] [ebp-A10h]
  char v35[12]; // [esp+30h] [ebp-A0Ch] BYREF
  char v36[2560]; // [esp+3Ch] [ebp-A00h] BYREF

  if ( *(int *)(a1 + 168) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 0;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = *(int **)(a1 + 172);
  v27 = v1;
  if ( v1[5] || v1[6] != 63 )
  {
    v3 = *(_DWORD *)(a1 + 60);
    *(_BYTE *)(a1 + 212) = 1;
    if ( v3 > 0 )
      memset(v36, 0xFFu, v3 << 8);
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 60);
    *(_BYTE *)(a1 + 212) = 0;
    if ( v2 > 0 )
      memset(v35, 0, v2);
  }
  v26 = 1;
  if ( *(int *)(a1 + 168) >= 1 )
  {
    while ( 1 )
    {
      v4 = *v1;
      v28 = *v1;
      if ( *v1 <= 0 || v4 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 26;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
        *(_DWORD *)(*(_DWORD *)a1 + 28) = 4;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v5 = 0;
      if ( v4 > 0 )
      {
        do
        {
          v6 = v1[1];
          if ( v6 < 0 || v6 >= *(_DWORD *)(a1 + 60) )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          if ( v5 > 0 && v6 <= *v1 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          ++v5;
          ++v1;
        }
        while ( v5 < v28 );
        v1 = v27;
        v4 = v28;
      }
      v7 = v27;
      v8 = v1[5];
      v33 = v8;
      v9 = v27[6];
      v10 = v27[7];
      v11 = v27[8];
      v29 = v9;
      v34 = v10;
      v30 = v11;
      if ( !*(_BYTE *)(a1 + 212) )
      {
        if ( v8 || v9 != 63 || v10 || v11 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        if ( v4 > 0 )
        {
          v18 = v27 + 1;
          v19 = v4;
          do
          {
            v20 = &v35[*v18];
            if ( *v20 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 19;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
              (**(void (__cdecl ***)(int))a1)(a1);
            }
            ++v18;
            --v19;
            *v20 = 1;
          }
          while ( v19 );
LABEL_67:
          v7 = v27;
        }
        goto LABEL_68;
      }
      if ( v8 < 0 || v8 >= 64 || v9 < v8 || v9 >= 64 || v10 < 0 || v10 > 10 || v11 < 0 || v11 > 10 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
        *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
        (**(void (__cdecl ***)(int))a1)(a1);
        v9 = v29;
      }
      if ( v8 )
      {
        if ( v4 == 1 )
          goto LABEL_39;
      }
      else if ( !v9 )
      {
        goto LABEL_39;
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
      (**(void (__cdecl ***)(int))a1)(a1);
LABEL_39:
      if ( v4 > 0 )
      {
        v12 = v27 + 1;
        v32 = v4;
        v31 = v27 + 1;
        while ( 1 )
        {
          v13 = (int *)&v36[256 * *v12];
          if ( v8 && *v13 < 0 )
          {
            v14 = v26;
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v26;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            v14 = v26;
          }
          if ( v8 <= v29 )
            break;
LABEL_55:
          v12 = v31 + 1;
          v17 = v32 == 1;
          ++v31;
          --v32;
          if ( v17 )
            goto LABEL_67;
        }
        v15 = &v13[v8];
        v16 = v29 - v33 + 1;
        while ( 2 )
        {
          if ( *v15 >= 0 )
          {
            if ( v34 != *v15 || v30 != v34 - 1 )
            {
LABEL_52:
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 17;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = v14;
              (**(void (__cdecl ***)(int))a1)(a1);
            }
          }
          else if ( v34 )
          {
            goto LABEL_52;
          }
          *v15++ = v30;
          if ( !--v16 )
          {
            v8 = v33;
            goto LABEL_55;
          }
          continue;
        }
      }
LABEL_68:
      v21 = v26 + 1 <= *(_DWORD *)(a1 + 168);
      v27 = v7 + 9;
      ++v26;
      if ( !v21 )
        break;
      v1 = v7 + 9;
    }
  }
  if ( *(_BYTE *)(a1 + 212) )
  {
    result = *(_DWORD *)(a1 + 60);
    v23 = 0;
    if ( result > 0 )
    {
      v24 = (int *)v36;
      do
      {
        if ( *v24 < 0 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        result = *(_DWORD *)(a1 + 60);
        ++v23;
        v24 += 64;
      }
      while ( v23 < result );
    }
  }
  else
  {
    result = *(_DWORD *)(a1 + 60);
    for ( i = 0; i < result; ++i )
    {
      if ( !v35[i] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      result = *(_DWORD *)(a1 + 60);
    }
  }
  return result;
}

//----- (0049FC80) --------------------------------------------------------
_DWORD *__cdecl sub_49FC80(_DWORD *a1)
{
  int v1; // edi
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // ebp
  int *v7; // ebx
  int v8; // ecx
  _DWORD *result; // eax
  int v10; // edx
  int v11; // ecx

  v1 = 0;
  v2 = a1[43];
  if ( v2 )
  {
    v3 = 9 * *(_DWORD *)(a1[79] + 28);
    a1[57] = *(_DWORD *)(v2 + 36 * *(_DWORD *)(a1[79] + 28));
    v4 = *(_DWORD *)(v2 + 4 * v3);
    v5 = (_DWORD *)(v2 + 4 * v3);
    if ( v4 > 0 )
    {
      v6 = a1 + 58;
      v7 = v5 + 1;
      do
      {
        v8 = *v7++;
        ++v6;
        ++v1;
        *(v6 - 1) = a1[17] + 84 * v8;
      }
      while ( v1 < *v5 );
    }
    a1[75] = v5[5];
    a1[76] = v5[6];
    result = (_DWORD *)v5[7];
    a1[77] = result;
    a1[78] = v5[8];
  }
  else
  {
    if ( (int)a1[15] > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[15];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    result = (_DWORD *)a1[15];
    v10 = 0;
    a1[57] = result;
    if ( (int)result > 0 )
    {
      v11 = 0;
      result = a1 + 58;
      do
      {
        ++v10;
        *result++ = v11 + a1[17];
        v11 += 84;
      }
      while ( v10 < a1[15] );
    }
    a1[75] = 0;
    a1[77] = 0;
    a1[78] = 0;
    a1[76] = 63;
  }
  return result;
}

//----- (0049FD80) --------------------------------------------------------
int __cdecl sub_49FD80(int *a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // ecx
  unsigned int v9; // edi
  unsigned int v10; // eax
  unsigned int v11; // ebp
  int v12; // edx
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  bool v18; // cc
  int result; // eax
  int v20; // [esp-10h] [ebp-20h]
  int v21; // [esp-Ch] [ebp-1Ch]
  int *v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+14h] [ebp+4h]

  v2 = a1[57];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)a1[58];
    a1[62] = v3[7];
    a1[63] = v3[8];
    v4 = v3[3];
    v5 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[16] = 8;
    v3[17] = 1;
    if ( !v5 )
      v5 = v4;
    v3[18] = v5;
    a1[64] = 1;
    a1[65] = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = a1[57];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    v6 = sub_493EC0(a1[7], 8 * a1[54]);
    v21 = 8 * a1[55];
    v20 = a1[8];
    a1[62] = v6;
    a1[63] = sub_493EC0(v20, v21);
    v7 = a1[57];
    a1[64] = 0;
    v23 = 0;
    if ( v7 > 0 )
    {
      v22 = a1 + 58;
      do
      {
        v8 = (_DWORD *)*v22;
        v9 = *(_DWORD *)(*v22 + 8);
        v10 = *(_DWORD *)(*v22 + 28);
        v11 = *(_DWORD *)(*v22 + 12);
        v8[13] = v9;
        v8[16] = 8 * v9;
        v12 = v10 % v9;
        v13 = v9 * v11;
        v8[14] = v11;
        v8[15] = v9 * v11;
        if ( !(v10 % v9) )
          v12 = v9;
        v14 = v8[8];
        v8[17] = v12;
        v15 = v14 % v11;
        if ( !(v14 % v11) )
          v15 = v11;
        v8[18] = v15;
        if ( v13 + a1[64] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 13;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v9 * v11) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            a1[a1[64] + 65] = v23;
            --v17;
            ++a1[64];
          }
          while ( v17 );
        }
        v18 = ++v23 < a1[57];
        ++v22;
      }
      while ( v18 );
    }
  }
  result = a1[48];
  if ( result > 0 )
  {
    result *= a1[62];
    if ( result >= 0xFFFF )
      result = 0xFFFF;
    a1[47] = result;
  }
  return result;
}

//----- (0049FF50) --------------------------------------------------------
int __cdecl sub_49FF50(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 316) + 12) = 0;
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 332) + 4))(a1);
  return (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 332) + 8))(a1);
}

//----- (0049FF80) --------------------------------------------------------
int __cdecl sub_49FF80(int a1)
{
  _DWORD *v1; // esi
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax
  int v6; // eax

  v1 = *(_DWORD **)(a1 + 316);
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 348) + 8))(a1);
  v2 = v1[4];
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( !v3 )
    {
      v6 = v1[5];
      v1[4] = 2;
      result = v6 + 1;
      v1[5] = result;
      return result;
    }
    if ( v3 == 1 )
    {
      if ( *(_BYTE *)(a1 + 178) )
      {
        v4 = v1[7];
        v1[4] = 1;
        v1[7] = v4 + 1;
        result = v1[5] + 1;
        v1[5] = result;
        return result;
      }
      goto LABEL_8;
    }
  }
  else
  {
    v1[4] = 2;
    if ( !*(_BYTE *)(a1 + 178) )
    {
LABEL_8:
      ++v1[7];
      goto LABEL_9;
    }
  }
LABEL_9:
  result = v1[5] + 1;
  v1[5] = result;
  return result;
}

//----- (004A0000) --------------------------------------------------------
int __cdecl sub_4A0000(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // eax
  __int16 *v6; // edi
  int v7; // ebp
  char *v8; // ecx
  int v9; // edx
  int v10; // esi
  int v11; // edx
  int v12; // ebp
  int v13; // ebx
  int v14; // ebp
  int v15; // edx
  int v16; // esi
  int v17; // edx
  int v18; // esi
  int v19; // edx
  int v20; // edi
  int v21; // eax
  int v22; // ebx
  int v23; // esi
  int v24; // edi
  int v25; // edx
  int v26; // ebx
  char *v27; // edx
  _BYTE *v28; // ecx
  char v29; // al
  int v30; // esi
  int v31; // eax
  int v32; // ebp
  int v33; // ebx
  int v34; // eax
  int v35; // esi
  int v36; // ebp
  int v37; // edi
  int v38; // eax
  int v39; // esi
  int v40; // edi
  int v41; // ebp
  int v42; // ebp
  int v43; // eax
  int v44; // ebx
  int v45; // eax
  bool v46; // zf
  int result; // eax
  int v48; // [esp+10h] [ebp-138h]
  int v49; // [esp+10h] [ebp-138h]
  int v50; // [esp+14h] [ebp-134h]
  int v51; // [esp+14h] [ebp-134h]
  int v52; // [esp+14h] [ebp-134h]
  int v53; // [esp+18h] [ebp-130h]
  int v54; // [esp+18h] [ebp-130h]
  __int16 *v55; // [esp+1Ch] [ebp-12Ch]
  int v56; // [esp+1Ch] [ebp-12Ch]
  _DWORD *v57; // [esp+20h] [ebp-128h]
  int v58; // [esp+20h] [ebp-128h]
  int v59; // [esp+24h] [ebp-124h]
  int v60; // [esp+24h] [ebp-124h]
  int v61; // [esp+28h] [ebp-120h]
  int v63; // [esp+2Ch] [ebp-11Ch]
  int v64; // [esp+2Ch] [ebp-11Ch]
  __int16 v65; // [esp+30h] [ebp-118h]
  int v66; // [esp+30h] [ebp-118h]
  int v67; // [esp+34h] [ebp-114h]
  int v68; // [esp+34h] [ebp-114h]
  int v69; // [esp+38h] [ebp-110h]
  int v70; // [esp+38h] [ebp-110h]
  int v71; // [esp+3Ch] [ebp-10Ch]
  int v72; // [esp+40h] [ebp-108h]
  int v73; // [esp+44h] [ebp-104h]
  char v74[256]; // [esp+48h] [ebp-100h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  v6 = a3;
  v7 = *(_DWORD *)(a1 + 288) + 128;
  v71 = v7;
  v55 = a3;
  v57 = v5;
  v8 = v74;
  v61 = 8;
  do
  {
    v65 = v6[8];
    if ( v65 || v6[16] || v6[24] || v6[32] || v6[40] || v6[48] || v6[56] )
    {
      v10 = v5[16] * v6[16];
      v11 = v5[48] * v6[48];
      v12 = 4433 * (v11 + v10);
      v13 = v12 - 15137 * v11;
      v14 = v12 + 6270 * v10;
      v48 = v5[32] * v6[32];
      v15 = *v5 * *v6;
      v16 = (v15 + v48) << 13;
      v72 = v16 + v14;
      v17 = (v15 - v48) << 13;
      v73 = v16 - v14;
      v67 = v17 + v13;
      v18 = v5[40] * v6[40];
      v69 = v17 - v13;
      v19 = v5[56] * v6[56];
      v20 = v5[24] * v6[24];
      v50 = v65 * v5[8];
      v63 = 9633 * (v18 + v50 + v19 + v20);
      v53 = -7373 * (v19 + v50);
      v21 = -20995 * (v18 + v20);
      v49 = v63 - 16069 * (v19 + v20);
      v22 = v63 - 3196 * (v18 + v50);
      v23 = v21 + v22 + 16819 * v18;
      v24 = v21 + v49 + 25172 * v20;
      v25 = v49 + v53 + 2446 * v19;
      v26 = v53 + v50 + v22 + 12298 * v50;
      *((_DWORD *)v8 + 56) = (v72 - v26 + 1024) >> 11;
      *(_DWORD *)v8 = (v72 + v26 + 1024) >> 11;
      *((_DWORD *)v8 + 48) = (v67 - v24 + 1024) >> 11;
      *((_DWORD *)v8 + 8) = (v67 + v24 + 1024) >> 11;
      *((_DWORD *)v8 + 40) = (v69 - v23 + 1024) >> 11;
      *((_DWORD *)v8 + 16) = (v69 + v23 + 1024) >> 11;
      *((_DWORD *)v8 + 32) = (v73 - v25 + 1024) >> 11;
      v6 = v55 + 1;
      *((_DWORD *)v8 + 24) = (v73 + v25 + 1024) >> 11;
      ++v55;
      v5 = v57 + 1;
      v7 = v71;
      ++v57;
      v8 += 4;
    }
    else
    {
      v9 = 4 * *v5++ * *v6++;
      *(_DWORD *)v8 = v9;
      *((_DWORD *)v8 + 8) = v9;
      *((_DWORD *)v8 + 16) = v9;
      *((_DWORD *)v8 + 24) = v9;
      *((_DWORD *)v8 + 32) = v9;
      *((_DWORD *)v8 + 40) = v9;
      *((_DWORD *)v8 + 48) = v9;
      *((_DWORD *)v8 + 56) = v9;
      v55 = v6;
      v57 = v5;
      v8 += 4;
    }
    --v61;
  }
  while ( v61 );
  v27 = v74;
  v66 = 8;
  do
  {
    v28 = (_BYTE *)(a5 + *a4);
    if ( *((_DWORD *)v27 + 1)
      || *((_DWORD *)v27 + 2)
      || *((_DWORD *)v27 + 3)
      || *((_DWORD *)v27 + 4)
      || *((_DWORD *)v27 + 5)
      || *((_DWORD *)v27 + 6)
      || *((_DWORD *)v27 + 7) )
    {
      v30 = *((_DWORD *)v27 + 2);
      v31 = *((_DWORD *)v27 + 6);
      v32 = 4433 * (v31 + v30);
      v33 = v32 - 15137 * v31;
      v34 = 3135 * v30;
      v35 = *((_DWORD *)v27 + 4);
      v36 = v32 + 2 * v34;
      v37 = (*(_DWORD *)v27 + v35) << 13;
      v38 = (*(_DWORD *)v27 - v35) << 13;
      v39 = v37 + v36;
      v40 = v37 - v36;
      v68 = v38 + v33;
      v41 = *((_DWORD *)v27 + 7);
      v70 = v38 - v33;
      v51 = *((_DWORD *)v27 + 5);
      v54 = v41 + *((_DWORD *)v27 + 1);
      v58 = *((_DWORD *)v27 + 3);
      v42 = v58 + v41;
      v59 = *((_DWORD *)v27 + 1) + v51;
      v64 = 9633 * (v42 + v59);
      v54 *= -7373;
      v43 = -20995 * (v58 + v51);
      v60 = v64 - 3196 * v59;
      v56 = v64 - 16069 * v42 + v54 + 2446 * *((_DWORD *)v27 + 7);
      v52 = v43 + v60 + 16819 * v51;
      v44 = v43 + v64 - 16069 * v42 + 25172 * v58;
      v7 = v71;
      v45 = v54 + *((_DWORD *)v27 + 1) + v60 + 12298 * *((_DWORD *)v27 + 1);
      *v28 = *(_BYTE *)((((v39 + v45 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[7] = *(_BYTE *)((((v39 - v45 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[1] = *(_BYTE *)((((v68 + v44 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[6] = *(_BYTE *)((((v68 - v44 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[2] = *(_BYTE *)((((v70 + v52 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[5] = *(_BYTE *)((((v70 - v52 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[3] = *(_BYTE *)((((v40 + v56 + 0x20000) >> 18) & 0x3FF) + v71);
      v28[4] = *(_BYTE *)((((v40 - v56 + 0x20000) >> 18) & 0x3FF) + v71);
    }
    else
    {
      v29 = *(_BYTE *)((((*(_DWORD *)v27 + 16) >> 5) & 0x3FF) + v7);
      *v28 = v29;
      v28[1] = v29;
      v28[2] = v29;
      v28[3] = v29;
      v28[4] = v29;
      v28[5] = v29;
      v28[6] = v29;
      v28[7] = v29;
    }
    v27 += 32;
    result = v66 - 1;
    v46 = v66 == 1;
    ++a4;
    --v66;
  }
  while ( !v46 );
  return result;
}

//----- (004A05F0) --------------------------------------------------------
int __cdecl sub_4A05F0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  _DWORD *v6; // ecx
  char *v7; // eax
  int v8; // edi
  int v9; // esi
  int v10; // esi
  int v11; // ebx
  int v12; // ebp
  int v13; // esi
  int v14; // ebx
  int v15; // esi
  int v16; // ebx
  int v17; // ebx
  int v18; // ebp
  int v19; // esi
  char *v20; // ecx
  _BYTE *v21; // eax
  char v22; // dl
  int v23; // ebx
  int v24; // esi
  int v25; // ebx
  int v26; // edx
  int v27; // edx
  int v28; // ebp
  int v29; // esi
  int v30; // ebx
  int v31; // edx
  int v32; // esi
  int v33; // esi
  int v34; // esi
  int v35; // edx
  bool v36; // zf
  int result; // eax
  int v38; // [esp+10h] [ebp-128h]
  int v39; // [esp+10h] [ebp-128h]
  int v40; // [esp+10h] [ebp-128h]
  int v41; // [esp+10h] [ebp-128h]
  int v42; // [esp+10h] [ebp-128h]
  int v43; // [esp+14h] [ebp-124h]
  int v44; // [esp+14h] [ebp-124h]
  int v45; // [esp+14h] [ebp-124h]
  int v46; // [esp+14h] [ebp-124h]
  int v47; // [esp+18h] [ebp-120h]
  int v48; // [esp+18h] [ebp-120h]
  int v49; // [esp+18h] [ebp-120h]
  int v50; // [esp+1Ch] [ebp-11Ch]
  int v51; // [esp+1Ch] [ebp-11Ch]
  int v52; // [esp+1Ch] [ebp-11Ch]
  int v53; // [esp+20h] [ebp-118h]
  int v54; // [esp+20h] [ebp-118h]
  int v55; // [esp+24h] [ebp-114h]
  int v56; // [esp+24h] [ebp-114h]
  int v57; // [esp+28h] [ebp-110h]
  int v59; // [esp+2Ch] [ebp-10Ch]
  int v60; // [esp+2Ch] [ebp-10Ch]
  int v61; // [esp+2Ch] [ebp-10Ch]
  int v62; // [esp+30h] [ebp-108h]
  int v63; // [esp+30h] [ebp-108h]
  int v64; // [esp+34h] [ebp-104h]
  int v65; // [esp+34h] [ebp-104h]
  char v66[256]; // [esp+38h] [ebp-100h] BYREF

  v6 = *(_DWORD **)(a2 + 80);
  v7 = v66;
  v8 = *(_DWORD *)(a1 + 288) + 128;
  v57 = 8;
  do
  {
    if ( a3[8] || a3[16] || a3[24] || a3[32] || a3[40] || a3[48] || a3[56] )
    {
      v10 = *v6 * *a3;
      v53 = v6[32] * a3[32];
      v11 = v6[16] * a3[16];
      v43 = v6[48] * a3[48];
      v59 = v10 - v53;
      v12 = v43 + v11;
      v13 = v10 + v53;
      v14 = ((362 * (v11 - v43)) >> 8) - (v43 + v11);
      v55 = v13 + v12;
      v44 = v13 - v12;
      v54 = v59 - v14;
      v15 = a3[8] * v6[8];
      v60 = v14 + v59;
      v38 = v6[24] * a3[24];
      v16 = v6[40] * a3[40];
      v47 = v6[56] * a3[56];
      v64 = v16 + v38;
      v17 = v16 - v38;
      v39 = v15 + v47;
      v62 = v15 - v47;
      v48 = v64 + v15 + v47;
      v18 = 473 * (v17 + v62);
      v19 = (v18 >> 8) + ((-669 * v17) >> 8) - v48;
      v40 = ((362 * (v39 - v64)) >> 8) - v19;
      v50 = v40 + ((277 * v62) >> 8) - (v18 >> 8);
      *(_DWORD *)v7 = v55 + v48;
      *((_DWORD *)v7 + 56) = v55 - v48;
      *((_DWORD *)v7 + 48) = v60 - v19;
      *((_DWORD *)v7 + 8) = v19 + v60;
      *((_DWORD *)v7 + 40) = v54 - v40;
      *((_DWORD *)v7 + 16) = v40 + v54;
      *((_DWORD *)v7 + 32) = v50 + v44;
      *((_DWORD *)v7 + 24) = v44 - v50;
    }
    else
    {
      v9 = *v6 * *a3;
      *(_DWORD *)v7 = v9;
      *((_DWORD *)v7 + 8) = v9;
      *((_DWORD *)v7 + 16) = v9;
      *((_DWORD *)v7 + 24) = v9;
      *((_DWORD *)v7 + 32) = v9;
      *((_DWORD *)v7 + 40) = v9;
      *((_DWORD *)v7 + 48) = v9;
      *((_DWORD *)v7 + 56) = v9;
    }
    ++a3;
    ++v6;
    v7 += 4;
    --v57;
  }
  while ( v57 );
  v20 = v66;
  v56 = 8;
  do
  {
    v51 = *((_DWORD *)v20 + 1);
    v21 = (_BYTE *)(a5 + *a4);
    if ( v51
      || *((_DWORD *)v20 + 2)
      || *((_DWORD *)v20 + 3)
      || *((_DWORD *)v20 + 4)
      || *((_DWORD *)v20 + 5)
      || *((_DWORD *)v20 + 6)
      || *((_DWORD *)v20 + 7) )
    {
      v23 = *((_DWORD *)v20 + 4);
      v24 = *(_DWORD *)v20 + v23;
      v25 = *(_DWORD *)v20 - v23;
      v26 = *((_DWORD *)v20 + 2);
      v45 = v26 + *((_DWORD *)v20 + 6);
      v27 = ((362 * (v26 - *((_DWORD *)v20 + 6))) >> 8) - v45;
      v28 = v24 + v45;
      v46 = v24 - v45;
      v29 = v27 + v25;
      v30 = v25 - v27;
      v31 = *((_DWORD *)v20 + 5);
      v61 = v29;
      v32 = *((_DWORD *)v20 + 3);
      v65 = v31 + v32;
      v33 = v31 - v32;
      v41 = v51 + *((_DWORD *)v20 + 7);
      v63 = v51 - *((_DWORD *)v20 + 7);
      v49 = v65 + v41;
      v52 = (473 * (v33 + v63)) >> 8;
      v34 = v52 + ((-669 * v33) >> 8) - (v65 + v41);
      v42 = ((362 * (v41 - v65)) >> 8) - v34;
      v35 = v42 + ((277 * v63) >> 8) - v52;
      *v21 = *(_BYTE *)((((v28 + v49) >> 5) & 0x3FF) + v8);
      v21[7] = *(_BYTE *)(v8 + (((v28 - v49) >> 5) & 0x3FF));
      v21[1] = *(_BYTE *)((((v34 + v61) >> 5) & 0x3FF) + v8);
      v21[6] = *(_BYTE *)(v8 + (((v61 - v34) >> 5) & 0x3FF));
      v21[2] = *(_BYTE *)((((v30 + v42) >> 5) & 0x3FF) + v8);
      v21[5] = *(_BYTE *)((((v30 - v42) >> 5) & 0x3FF) + v8);
      v21[4] = *(_BYTE *)((((v35 + v46) >> 5) & 0x3FF) + v8);
      v21[3] = *(_BYTE *)((((v46 - v35) >> 5) & 0x3FF) + v8);
    }
    else
    {
      v22 = *(_BYTE *)(((*(int *)v20 >> 5) & 0x3FF) + v8);
      *v21 = v22;
      v21[1] = v22;
      v21[2] = v22;
      v21[3] = v22;
      v21[4] = v22;
      v21[5] = v22;
      v21[6] = v22;
      v21[7] = v22;
    }
    v20 += 32;
    result = v56 - 1;
    v36 = v56 == 1;
    ++a4;
    --v56;
  }
  while ( !v36 );
  return result;
}

//----- (004A0AB0) --------------------------------------------------------
int __cdecl sub_4A0AB0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  float *v6; // edx
  int v7; // ebx
  float *v8; // eax
  int v9; // edi
  __int16 v10; // si
  double v11; // st7
  double v12; // st7
  double v13; // st6
  double v14; // st7
  double v15; // st6
  double v16; // st7
  double v17; // st6
  double v18; // st5
  double v19; // st4
  double v20; // st6
  double v21; // st5
  float *v23; // esi
  double v24; // st7
  _BYTE *v25; // edi
  double v26; // st6
  double v27; // st7
  double v28; // st6
  double v29; // st5
  double v30; // st4
  bool v31; // zf
  int result; // eax
  float v33; // [esp+10h] [ebp-120h]
  float v34; // [esp+10h] [ebp-120h]
  float v35; // [esp+10h] [ebp-120h]
  float v36; // [esp+14h] [ebp-11Ch]
  float v37; // [esp+14h] [ebp-11Ch]
  float v38; // [esp+14h] [ebp-11Ch]
  float v39; // [esp+14h] [ebp-11Ch]
  float v40; // [esp+14h] [ebp-11Ch]
  float v41; // [esp+14h] [ebp-11Ch]
  float v42; // [esp+18h] [ebp-118h]
  float v43; // [esp+18h] [ebp-118h]
  float v44; // [esp+18h] [ebp-118h]
  float v45; // [esp+18h] [ebp-118h]
  float v46; // [esp+18h] [ebp-118h]
  float v47; // [esp+1Ch] [ebp-114h]
  float v48; // [esp+1Ch] [ebp-114h]
  float v49; // [esp+1Ch] [ebp-114h]
  float v50; // [esp+20h] [ebp-110h]
  float v51; // [esp+20h] [ebp-110h]
  float v52; // [esp+20h] [ebp-110h]
  float v53; // [esp+24h] [ebp-10Ch]
  float v54; // [esp+24h] [ebp-10Ch]
  int v55; // [esp+24h] [ebp-10Ch]
  float v56; // [esp+28h] [ebp-108h]
  float v57; // [esp+28h] [ebp-108h]
  float v58; // [esp+2Ch] [ebp-104h]
  float v59; // [esp+2Ch] [ebp-104h]
  char v60; // [esp+30h] [ebp-100h] BYREF
  char v61; // [esp+38h] [ebp-F8h] BYREF

  v6 = *(float **)(a2 + 80);
  v7 = *(_DWORD *)(a1 + 288) + 128;
  v8 = (float *)&v60;
  v9 = 8;
  do
  {
    v10 = a3[8];
    if ( v10 || a3[16] || a3[24] || a3[32] || a3[40] || a3[48] || a3[56] )
    {
      v12 = (double)*a3 * *v6;
      v53 = (double)a3[16] * v6[16];
      v13 = (double)a3[32] * v6[32];
      v50 = (double)a3[48] * v6[48];
      v42 = v13 + v12;
      v14 = v12 - v13;
      v15 = v50 + v53;
      v36 = (v53 - v50) * flt_4B0FA0 - v15;
      v58 = v15 + v42;
      v51 = v42 - v15;
      v54 = v36 + v14;
      v16 = v14 - v36;
      v17 = v6[8] * (double)v10;
      v18 = (double)a3[24] * v6[24];
      v19 = (double)a3[40] * v6[40];
      v47 = (double)a3[56] * v6[56];
      v33 = v19 + v18;
      v43 = v19 - v18;
      v37 = v47 + v17;
      v20 = v17 - v47;
      v48 = v37 + v33;
      v21 = (v20 + v43) * flt_4B0F9C;
      v56 = v21 - v43 * flt_4B0F98 - v48;
      v38 = (v37 - v33) * flt_4B0FA0 - v56;
      v44 = v20 * flt_4B0F94 - v21 + v38;
      *v8 = v48 + v58;
      v8[56] = v58 - v48;
      v8[8] = v56 + v54;
      v8[48] = v54 - v56;
      v8[16] = v38 + v16;
      v8[40] = v16 - v38;
      v8[32] = v44 + v51;
      v8[24] = v51 - v44;
    }
    else
    {
      v11 = (double)*a3 * *v6;
      *v8 = v11;
      v8[8] = v11;
      v8[16] = v11;
      v8[24] = v11;
      v8[32] = v11;
      v8[40] = v11;
      v8[48] = v11;
      v8[56] = v11;
    }
    ++a3;
    ++v6;
    ++v8;
    --v9;
  }
  while ( v9 );
  v23 = (float *)&v61;
  v55 = 8;
  do
  {
    v24 = v23[2] + *(v23 - 2);
    v25 = (_BYTE *)(a5 + *a4);
    v34 = *(v23 - 2) - v23[2];
    v26 = v23[4] + *v23;
    v39 = (*v23 - v23[4]) * flt_4B0FA0 - v26;
    v59 = v26 + v24;
    v27 = v24 - v26;
    v28 = v39 + v34;
    v52 = v34 - v39;
    v29 = v23[3] + v23[1];
    v30 = v23[3] - v23[1];
    v40 = v23[5] + *(v23 - 1);
    v35 = *(v23 - 1) - v23[5];
    v49 = v40 + v29;
    v45 = (v35 + v30) * flt_4B0F9C;
    v57 = v45 - v30 * flt_4B0F98 - v49;
    v41 = (v40 - v29) * flt_4B0FA0 - v57;
    v46 = v35 * flt_4B0F94 - v45 + v41;
    *v25 = *(_BYTE *)((((int)((__int64)(v49 + v59) + 4) >> 3) & 0x3FF) + v7);
    v25[7] = *(_BYTE *)((((int)((__int64)(v59 - v49) + 4) >> 3) & 0x3FF) + v7);
    v25[1] = *(_BYTE *)((((int)((__int64)(v57 + v28) + 4) >> 3) & 0x3FF) + v7);
    v25[6] = *(_BYTE *)((((int)((__int64)(v28 - v57) + 4) >> 3) & 0x3FF) + v7);
    v25[2] = *(_BYTE *)((((int)((__int64)(v41 + v52) + 4) >> 3) & 0x3FF) + v7);
    v25[5] = *(_BYTE *)((((int)((__int64)(v52 - v41) + 4) >> 3) & 0x3FF) + v7);
    v25[4] = *(_BYTE *)((((int)((__int64)(v46 + v27) + 4) >> 3) & 0x3FF) + v7);
    v23 += 8;
    ++a4;
    result = v55 - 1;
    v31 = v55 == 1;
    v25[3] = *(_BYTE *)((((int)((__int64)(v27 - v46) + 4) >> 3) & 0x3FF) + v7);
    --v55;
  }
  while ( !v31 );
  return result;
}
// 4B0F94: using guessed type float flt_4B0F94;
// 4B0F98: using guessed type float flt_4B0F98;
// 4B0F9C: using guessed type float flt_4B0F9C;
// 4B0FA0: using guessed type float flt_4B0FA0;

//----- (004A0EF0) --------------------------------------------------------
int __cdecl sub_4A0EF0(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // edi
  int result; // eax
  __int16 *v7; // ebx
  int v8; // esi
  char *v9; // edx
  __int16 v10; // bp
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int v18; // ebp
  int v19; // ecx
  int v20; // eax
  char *v21; // edx
  int v22; // ecx
  _BYTE *v23; // esi
  char v24; // cl
  int v25; // edi
  int v26; // eax
  int v27; // ebx
  int v28; // esi
  int v29; // edi
  int v30; // ebp
  int v31; // ecx
  bool v32; // zf
  char *v33; // [esp+10h] [ebp-98h]
  int v35; // [esp+14h] [ebp-94h]
  int v36; // [esp+14h] [ebp-94h]
  int v37; // [esp+18h] [ebp-90h]
  _BYTE *v38; // [esp+18h] [ebp-90h]
  int v39; // [esp+1Ch] [ebp-8Ch]
  int v40; // [esp+20h] [ebp-88h]
  int v41; // [esp+24h] [ebp-84h]
  int v42; // [esp+24h] [ebp-84h]
  char v43; // [esp+28h] [ebp-80h] BYREF
  char v44[96]; // [esp+48h] [ebp-60h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  result = *(_DWORD *)(a1 + 288) + 128;
  v7 = (__int16 *)(a3 + 96);
  v8 = 8;
  v39 = result;
  v35 = 8;
  v9 = v44;
  v33 = v44;
  do
  {
    if ( v8 != 4 )
    {
      v10 = *(v7 - 40);
      if ( v10 || *(v7 - 32) || *(v7 - 24) || *(v7 - 8) || *v7 || v7[8] )
      {
        v12 = (*v5 * *(v7 - 48)) << 14;
        v13 = 15137 * v5[16] * *(v7 - 32) - 6270 * *v7 * v5[48];
        v40 = v12 - v13;
        v37 = v13 + v12;
        v14 = v5[40] * *(v7 - 8);
        v41 = v5[24] * *(v7 - 24);
        v15 = v10 * v5[8];
        v16 = 8697 * v15 + 11893 * v14 - 17799 * v41 - 1730 * v5[56] * v7[8];
        v17 = 7373 * v41 + 20995 * v15 - 4926 * v14 - 4176 * v5[56] * v7[8];
        v9 = v33;
        *((_DWORD *)v33 + 16) = (v37 - v17 + 2048) >> 12;
        v18 = (v37 + v17 + 2048) >> 12;
        v19 = v40 + v16 + 2048;
        v20 = v40 - v16;
        v8 = v35;
        *((_DWORD *)v33 + 8) = (v20 + 2048) >> 12;
        result = v39;
        *((_DWORD *)v33 - 8) = v18;
        *(_DWORD *)v33 = v19 >> 12;
      }
      else
      {
        v11 = 4 * *v5 * *(v7 - 48);
        *((_DWORD *)v9 - 8) = v11;
        *(_DWORD *)v9 = v11;
        *((_DWORD *)v9 + 8) = v11;
        *((_DWORD *)v9 + 16) = v11;
      }
    }
    ++v7;
    ++v5;
    v9 += 4;
    --v8;
    v33 = v9;
    v35 = v8;
  }
  while ( v8 > 0 );
  v21 = &v43;
  v36 = 4;
  do
  {
    v22 = *((_DWORD *)v21 + 1);
    v23 = (_BYTE *)(a5 + *a4);
    v38 = v23;
    if ( v22
      || *((_DWORD *)v21 + 2)
      || *((_DWORD *)v21 + 3)
      || *((_DWORD *)v21 + 5)
      || *((_DWORD *)v21 + 6)
      || *((_DWORD *)v21 + 7) )
    {
      v25 = *(_DWORD *)v21 << 14;
      v26 = *((_DWORD *)v21 + 5);
      v27 = 15137 * *((_DWORD *)v21 + 2) - 6270 * *((_DWORD *)v21 + 6);
      v28 = v27 + v25;
      v29 = v25 - v27;
      v42 = *((_DWORD *)v21 + 3);
      v30 = 8697 * v22 + 11893 * v26 - 17799 * v42 - 1730 * *((_DWORD *)v21 + 7);
      v31 = 7373 * v42 + 20995 * v22 - 4926 * v26 - 4176 * *((_DWORD *)v21 + 7);
      *v38 = *(_BYTE *)((((v28 + v31 + 0x40000) >> 19) & 0x3FF) + v39);
      result = v39;
      v38[3] = *(_BYTE *)((((v28 - v31 + 0x40000) >> 19) & 0x3FF) + v39);
      v38[1] = *(_BYTE *)((((v29 + v30 + 0x40000) >> 19) & 0x3FF) + v39);
      v38[2] = *(_BYTE *)((((v29 - v30 + 0x40000) >> 19) & 0x3FF) + v39);
    }
    else
    {
      v24 = *(_BYTE *)((((*(_DWORD *)v21 + 16) >> 5) & 0x3FF) + result);
      *v23 = v24;
      v23[1] = v24;
      v23[2] = v24;
      v23[3] = v24;
    }
    v21 += 32;
    v32 = v36 == 1;
    ++a4;
    --v36;
  }
  while ( !v32 );
  return result;
}

//----- (004A12A0) --------------------------------------------------------
int __cdecl sub_4A12A0(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  char *v5; // ecx
  int v6; // ebp
  int v7; // edx
  __int16 *v8; // edi
  char *v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // esi
  int v14; // eax
  char *v15; // ecx
  _BYTE *v16; // edi
  int v17; // esi
  char v18; // al
  int v19; // eax
  int v20; // esi
  bool v21; // zf
  int result; // eax
  int v23; // [esp+Ch] [ebp-44h]
  char v24[64]; // [esp+10h] [ebp-40h] BYREF
  int v25; // [esp+54h] [ebp+4h]
  int v27; // [esp+58h] [ebp+8h]

  v5 = *(char **)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 288) + 128;
  v7 = 8;
  v23 = v6;
  v25 = 8;
  v8 = (__int16 *)(a3 + 48);
  v9 = (char *)(v24 - v5);
  do
  {
    if ( v7 != 6 && v7 != 4 && v7 != 2 )
    {
      if ( *(v8 - 16) || *v8 || v8[16] || v8[32] )
      {
        v11 = (*(_DWORD *)v5 * *(v8 - 24)) << 15;
        v12 = 6967 * *((_DWORD *)v5 + 40) * v8[16]
            - 5906 * *((_DWORD *)v5 + 56) * v8[32]
            + 29692 * *(v8 - 16) * *((_DWORD *)v5 + 8)
            - 10426 * *v8 * *((_DWORD *)v5 + 24);
        v6 = v23;
        v13 = v12 + v11 + 4096;
        v14 = v11 - v12;
        v7 = v25;
        *(_DWORD *)&v5[(_DWORD)v9] = v13 >> 13;
        *(_DWORD *)&v5[(_DWORD)v9 + 32] = (v14 + 4096) >> 13;
      }
      else
      {
        v10 = 4 * *(_DWORD *)v5 * *(v8 - 24);
        *(_DWORD *)&v5[(_DWORD)v9] = v10;
        *(_DWORD *)&v5[(_DWORD)v9 + 32] = v10;
      }
    }
    ++v8;
    v5 += 4;
    v25 = --v7;
  }
  while ( v7 > 0 );
  v15 = v24;
  v27 = 2;
  do
  {
    v16 = (_BYTE *)(*a4 + a5);
    v17 = *((_DWORD *)v15 + 1);
    if ( v17 || *((_DWORD *)v15 + 3) || *((_DWORD *)v15 + 5) || *((_DWORD *)v15 + 7) )
    {
      v19 = *(_DWORD *)v15 << 15;
      v6 = v23;
      v20 = 6967 * *((_DWORD *)v15 + 5) - 10426 * *((_DWORD *)v15 + 3) - 5906 * *((_DWORD *)v15 + 7) + 29692 * v17;
      *v16 = *(_BYTE *)((((v20 + v19 + 0x80000) >> 20) & 0x3FF) + v23);
      v18 = *(_BYTE *)((((v19 - v20 + 0x80000) >> 20) & 0x3FF) + v23);
    }
    else
    {
      v18 = *(_BYTE *)((((*(_DWORD *)v15 + 16) >> 5) & 0x3FF) + v6);
      *v16 = v18;
    }
    v16[1] = v18;
    v15 += 32;
    result = v27 - 1;
    v21 = v27 == 1;
    ++a4;
    --v27;
  }
  while ( !v21 );
  return result;
}

//----- (004A14D0) --------------------------------------------------------
char __cdecl sub_4A14D0(int a1, int a2, _WORD *a3, _DWORD *a4, int a5)
{
  int v5; // eax
  char result; // al

  HIWORD(v5) = HIWORD(a2);
  LOWORD(v5) = *a3;
  result = *(_BYTE *)((((v5 * **(_DWORD **)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD *)(a1 + 288) + 128);
  *(_BYTE *)(*a4 + a5) = result;
  return result;
}

//----- (004A1510) --------------------------------------------------------
int *__cdecl sub_4A1510(int a1)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  int v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // edi
  int v9; // esi
  int v10; // ecx
  int v11; // ebp
  int v12; // edi
  int v13; // ecx
  int v14; // ecx
  int v15; // ebx
  int v16; // ebp
  int v17; // ebx
  int *result; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // esi
  int v23; // ebx
  int v24; // edx
  int v25; // ecx
  int v26; // edi
  int v27; // esi
  int v28; // ecx
  int v29; // ebp
  int v30; // edi
  int v31; // ecx
  int v32; // ecx
  int v33; // [esp+10h] [ebp-18h]
  int v34; // [esp+10h] [ebp-18h]
  int v35; // [esp+14h] [ebp-14h]
  int v36; // [esp+14h] [ebp-14h]
  int v37; // [esp+18h] [ebp-10h]
  int v38; // [esp+18h] [ebp-10h]
  int v39; // [esp+18h] [ebp-10h]
  int v40; // [esp+18h] [ebp-10h]
  int v41; // [esp+18h] [ebp-10h]
  int v42; // [esp+18h] [ebp-10h]
  int v43; // [esp+1Ch] [ebp-Ch]
  int v44; // [esp+1Ch] [ebp-Ch]
  int v45; // [esp+1Ch] [ebp-Ch]
  int v46; // [esp+1Ch] [ebp-Ch]
  int v47; // [esp+1Ch] [ebp-Ch]
  int v48; // [esp+1Ch] [ebp-Ch]
  int v49; // [esp+20h] [ebp-8h]
  int v50; // [esp+20h] [ebp-8h]
  int v51; // [esp+24h] [ebp-4h]
  int v52; // [esp+2Ch] [ebp+4h]

  v1 = (int *)(a1 + 8);
  v51 = 8;
  do
  {
    v2 = v1[5];
    v3 = *(v1 - 2);
    v4 = *(v1 - 1);
    v5 = v3 + v2;
    v6 = v3 - v2;
    v7 = v1[4];
    v8 = v4 + v7;
    v9 = v4 - v7;
    v10 = v1[3];
    v43 = v8;
    v11 = v10 + *v1;
    v12 = *v1 - v10;
    v13 = v1[1];
    v37 = v13 + v1[2];
    v33 = v13 - v1[2];
    v14 = v5 + v37;
    v49 = v5 - v37;
    v38 = v43 + v11;
    v15 = v43 - v11;
    v16 = v14 + v43 + v11;
    v44 = v15;
    *(v1 - 2) = 4 * v16;
    v17 = v49 + v15;
    v1[2] = 4 * (v14 - v38);
    *v1 = (4433 * v17 + 6270 * v49 + 1024) >> 11;
    v1[4] = (4433 * v17 - 15137 * v44 + 1024) >> 11;
    v39 = 9633 * (v33 + v9 + v12 + v6);
    v1 += 8;
    v35 = v39 - 16069 * (v33 + v9);
    v45 = v39 - 3196 * (v12 + v6);
    *(v1 - 3) = (v35 + 2446 * v33 - 7373 * (v6 + v33) + 1024) >> 11;
    *(v1 - 5) = (v45 + 16819 * v12 - 20995 * (v12 + v9) + 1024) >> 11;
    *(v1 - 7) = (v35 + 25172 * v9 - 20995 * (v12 + v9) + 1024) >> 11;
    *(v1 - 9) = (v6 + v45 + 12298 * v6 - 7373 * (v6 + v33) + 1024) >> 11;
    --v51;
  }
  while ( v51 );
  v52 = 8;
  result = (int *)(a1 + 64);
  do
  {
    v20 = result[40];
    v21 = *(result - 16);
    v22 = *(result - 8);
    v23 = v21 + v20;
    v24 = v21 - v20;
    v25 = result[32];
    v26 = v22 + v25;
    v27 = v22 - v25;
    v28 = result[24];
    v46 = v26;
    v29 = v28 + *result;
    v30 = *result - v28;
    v31 = result[8];
    v40 = v31 + result[16];
    v34 = v31 - result[16];
    v32 = v23 + v40;
    v50 = v23 - v40;
    v41 = v46 + v29;
    v47 = v46 - v29;
    *(result - 16) = (v32 + v41 + 2) >> 2;
    result[16] = (v32 - v41 + 2) >> 2;
    *result = (4433 * (v50 + v47) + 6270 * v50 + 0x4000) >> 15;
    result[32] = (4433 * (v50 + v47) - 15137 * v47 + 0x4000) >> 15;
    v42 = 9633 * (v34 + v27 + v30 + v24);
    ++result;
    v36 = v42 - 16069 * (v34 + v27);
    v48 = v42 - 3196 * (v30 + v24);
    result[39] = (v36 + 2446 * v34 - 7373 * (v24 + v34) + 0x4000) >> 15;
    result[23] = (v48 + 16819 * v30 - 20995 * (v30 + v27) + 0x4000) >> 15;
    result[7] = (v36 + 25172 * v27 - 20995 * (v30 + v27) + 0x4000) >> 15;
    *(result - 9) = (v24 + v48 + 12298 * v24 - 7373 * (v24 + v34) + 0x4000) >> 15;
    --v52;
  }
  while ( v52 );
  return result;
}

//----- (004A1910) --------------------------------------------------------
_DWORD *__cdecl sub_4A1910(int a1)
{
  _DWORD *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  int v5; // esi
  int v6; // edx
  int v7; // ecx
  int v8; // ebx
  int v9; // ebp
  int v10; // ecx
  int v11; // ecx
  int v12; // esi
  int v13; // ecx
  int v14; // ebx
  int v15; // ecx
  int v16; // esi
  int v17; // edi
  int v18; // ebx
  int v19; // edx
  _DWORD *result; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // edi
  int v25; // esi
  int v26; // edx
  int v27; // ecx
  int v28; // ebx
  int v29; // ebp
  int v30; // ecx
  int v31; // ecx
  int v32; // esi
  int v33; // ecx
  int v34; // ebx
  int v35; // ecx
  int v36; // esi
  int v37; // edi
  int v38; // ebx
  int v39; // edx
  int v40; // [esp+10h] [ebp-14h]
  int v41; // [esp+10h] [ebp-14h]
  int v42; // [esp+14h] [ebp-10h]
  int v43; // [esp+14h] [ebp-10h]
  int v44; // [esp+18h] [ebp-Ch]
  int v45; // [esp+18h] [ebp-Ch]
  int v46; // [esp+1Ch] [ebp-8h]
  int v47; // [esp+1Ch] [ebp-8h]
  int v48; // [esp+20h] [ebp-4h]
  int v49; // [esp+28h] [ebp+4h]

  v1 = (_DWORD *)(a1 + 8);
  v48 = 8;
  do
  {
    v2 = v1[5];
    v3 = *(v1 - 2);
    v4 = v1[4];
    v5 = v3 + v2;
    v6 = v3 - v2;
    v7 = *(v1 - 1);
    v8 = v7 + v4;
    v9 = v7 - v4;
    v40 = *v1 + v1[3];
    v42 = *v1 - v1[3];
    v10 = v1[1];
    v44 = v10 + v1[2];
    v46 = v10 - v1[2];
    v11 = v44 + v5;
    v12 = v5 - v44;
    *(v1 - 2) = v11 + v8 + v40;
    v1[2] = v11 - (v8 + v40);
    v13 = (181 * (v8 + v12 - v40)) >> 8;
    v1[4] = v12 - v13;
    *v1 = v13 + v12;
    v14 = (98 * (v42 + v46 - (v6 + v9))) >> 8;
    v15 = v14 + ((139 * (v42 + v46)) >> 8);
    v16 = v14 + ((334 * (v6 + v9)) >> 8);
    v17 = (181 * (v9 + v42)) >> 8;
    v18 = v17 + v6;
    v19 = v6 - v17;
    v1[1] = v19 - v15;
    v1[3] = v19 + v15;
    *(v1 - 1) = v18 + v16;
    v1[5] = v18 - v16;
    v1 += 8;
    --v48;
  }
  while ( v48 );
  v49 = 8;
  result = (_DWORD *)(a1 + 64);
  do
  {
    v22 = result[40];
    v23 = *(result - 16);
    v24 = result[32];
    v25 = v23 + v22;
    v26 = v23 - v22;
    v27 = *(result - 8);
    v28 = v27 + v24;
    v29 = v27 - v24;
    v41 = *result + result[24];
    v43 = *result - result[24];
    v30 = result[8];
    v45 = v30 + result[16];
    v47 = v30 - result[16];
    v31 = v45 + v25;
    v32 = v25 - v45;
    *(result - 16) = v31 + v28 + v41;
    result[16] = v31 - (v28 + v41);
    v33 = (181 * (v28 + v32 - v41)) >> 8;
    result[32] = v32 - v33;
    *result = v33 + v32;
    v34 = (98 * (v43 + v47 - (v26 + v29))) >> 8;
    v35 = v34 + ((139 * (v43 + v47)) >> 8);
    v36 = v34 + ((334 * (v26 + v29)) >> 8);
    v37 = (181 * (v29 + v43)) >> 8;
    v38 = v37 + v26;
    v39 = v26 - v37;
    result[8] = v39 - v35;
    result[24] = v39 + v35;
    *(result - 8) = v38 + v36;
    result[40] = v38 - v36;
    ++result;
    --v49;
  }
  while ( v49 );
  return result;
}

//----- (004A1B60) --------------------------------------------------------
float *__cdecl sub_4A1B60(int a1)
{
  int v2; // ecx
  float *v3; // eax
  double v4; // st7
  double v5; // st6
  double v6; // st7
  double v7; // st6
  double v8; // st6
  double v9; // st7
  double v10; // st7
  double v11; // st6
  double v12; // st6
  float *result; // eax
  int v14; // ecx
  double v15; // st7
  double v16; // st6
  double v17; // st7
  double v18; // st6
  double v19; // st6
  double v20; // st7
  double v21; // st7
  double v22; // st6
  double v23; // st6
  float v24; // [esp+0h] [ebp-18h]
  float v25; // [esp+0h] [ebp-18h]
  float v26; // [esp+4h] [ebp-14h]
  float v27; // [esp+4h] [ebp-14h]
  float v28; // [esp+4h] [ebp-14h]
  float v29; // [esp+4h] [ebp-14h]
  float v30; // [esp+8h] [ebp-10h]
  float v31; // [esp+8h] [ebp-10h]
  float v32; // [esp+8h] [ebp-10h]
  float v33; // [esp+8h] [ebp-10h]
  float v34; // [esp+8h] [ebp-10h]
  float v35; // [esp+8h] [ebp-10h]
  float v36; // [esp+Ch] [ebp-Ch]
  float v37; // [esp+Ch] [ebp-Ch]
  float v38; // [esp+10h] [ebp-8h]
  float v39; // [esp+10h] [ebp-8h]
  float v40; // [esp+10h] [ebp-8h]
  float v41; // [esp+10h] [ebp-8h]
  float v42; // [esp+14h] [ebp-4h]
  float v43; // [esp+14h] [ebp-4h]
  float v44; // [esp+1Ch] [ebp+4h]
  float v45; // [esp+1Ch] [ebp+4h]

  v2 = 8;
  v3 = (float *)(a1 + 8);
  do
  {
    v4 = v3[5] + *(v3 - 2);
    v44 = *(v3 - 2) - v3[5];
    v26 = v3[4] + *(v3 - 1);
    v38 = *(v3 - 1) - v3[4];
    v30 = *v3 + v3[3];
    v36 = *v3 - v3[3];
    v5 = v3[2] + v3[1];
    v42 = v3[1] - v3[2];
    v24 = v5 + v4;
    v6 = v4 - v5;
    v7 = v30 + v26;
    *(v3 - 2) = v7 + v24;
    v3[2] = v24 - v7;
    v8 = (v26 - v30 + v6) * flt_4B0FB0;
    *v3 = v8 + v6;
    v3[4] = v6 - v8;
    v9 = v42 + v36;
    v31 = v38 + v44;
    v27 = (v9 - v31) * flt_4B0FAC;
    v10 = v9 * flt_4B0FA8 + v27;
    v32 = v31 * flt_4B0FA4 + v27;
    v11 = (v36 + v38) * flt_4B0FB0;
    v39 = v11 + v44;
    v12 = v44 - v11;
    v3[3] = v12 + v10;
    v3[1] = v12 - v10;
    v3 += 8;
    --v2;
    *(v3 - 9) = v39 + v32;
    *(v3 - 3) = v39 - v32;
  }
  while ( v2 );
  result = (float *)(a1 + 64);
  v14 = 8;
  do
  {
    v15 = *(result - 16) + result[40];
    v45 = *(result - 16) - result[40];
    v28 = *(result - 8) + result[32];
    v40 = *(result - 8) - result[32];
    v33 = *result + result[24];
    v37 = *result - result[24];
    v16 = result[16] + result[8];
    v43 = result[8] - result[16];
    v25 = v16 + v15;
    v17 = v15 - v16;
    v18 = v33 + v28;
    *(result - 16) = v18 + v25;
    result[16] = v25 - v18;
    v19 = (v28 - v33 + v17) * flt_4B0FB0;
    *result = v19 + v17;
    result[32] = v17 - v19;
    v20 = v43 + v37;
    v34 = v40 + v45;
    v29 = (v20 - v34) * flt_4B0FAC;
    v21 = v20 * flt_4B0FA8 + v29;
    v35 = v34 * flt_4B0FA4 + v29;
    v22 = (v37 + v40) * flt_4B0FB0;
    v41 = v22 + v45;
    v23 = v45 - v22;
    result[24] = v23 + v21;
    result[8] = v23 - v21;
    ++result;
    --v14;
    *(result - 9) = v41 + v35;
    result[39] = v41 - v35;
  }
  while ( v14 );
  return result;
}
// 4B0FA4: using guessed type float flt_4B0FA4;
// 4B0FA8: using guessed type float flt_4B0FA8;
// 4B0FAC: using guessed type float flt_4B0FAC;
// 4B0FB0: using guessed type float flt_4B0FB0;

//----- (004A1DE0) --------------------------------------------------------
int __cdecl sub_4A1DE0(int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // ecx
  unsigned int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // ebx
  unsigned int v11; // edx
  int v12; // eax
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ebx
  unsigned int v17; // edx
  int v18; // eax
  int v19; // ebx
  unsigned int v20; // eax
  int v21; // edx
  int v22; // ebx
  unsigned int v23; // edx
  unsigned int v24; // eax

  v3 = a2;
  if ( !a2 )
    return 0;
  v5 = a3;
  v6 = ~a1;
  if ( a3 >= 8 )
  {
    v7 = a3 >> 3;
    do
    {
      v5 -= 8;
      v8 = (v6 >> 8) ^ dword_4B0FB4[*v3 ^ (unsigned __int8)v6];
      v9 = v3 + 1;
      v10 = v9[1];
      v11 = (v8 >> 8) ^ dword_4B0FB4[*v9++ ^ (unsigned __int8)v8];
      v12 = v10 ^ (unsigned __int8)v11;
      v13 = v9[1];
      v14 = (v11 >> 8) ^ dword_4B0FB4[v12];
      ++v9;
      v15 = v13 ^ (unsigned __int8)v14;
      v16 = v9[1];
      v17 = (v14 >> 8) ^ dword_4B0FB4[v15];
      ++v9;
      v18 = v16 ^ (unsigned __int8)v17;
      v19 = v9[1];
      v20 = (v17 >> 8) ^ dword_4B0FB4[v18];
      ++v9;
      v21 = v19 ^ (unsigned __int8)v20;
      v22 = v9[1];
      v23 = (v20 >> 8) ^ dword_4B0FB4[v21];
      ++v9;
      v24 = (v23 >> 8) ^ dword_4B0FB4[v22 ^ (unsigned __int8)v23];
      v6 = dword_4B0FB4[v9[1] ^ (unsigned __int8)v24] ^ (v24 >> 8);
      v3 = v9 + 2;
      --v7;
    }
    while ( v7 );
  }
  for ( ; v5; --v5 )
    v6 = dword_4B0FB4[*v3++ ^ (unsigned __int8)v6] ^ (v6 >> 8);
  return ~v6;
}

//----- (004A1F20) --------------------------------------------------------
int __cdecl _memicmp(const void *Buf1, const void *Buf2, size_t Size)
{
  int v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  int v12; // [esp-8h] [ebp-18h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+0h] [ebp-10h]

  v3 = Size;
  if ( Size )
  {
    if ( *((_DWORD *)&unk_4C1C04 + 2) )
    {
      _InterlockedIncrement(&dword_4C3248);
      if ( dword_4C3244 > 0 )
      {
        _InterlockedDecrement(&dword_4C3248);
        _lock(19);
        v14 = 1;
        v3 = Size;
      }
      else
      {
        v14 = 0;
      }
      v8 = 0;
      v9 = 0;
      while ( 1 )
      {
        LOBYTE(v8) = *(_BYTE *)Buf1;
        Buf1 = (char *)Buf1 + 1;
        LOBYTE(v9) = *(_BYTE *)Buf2;
        Buf2 = (char *)Buf2 + 1;
        if ( (_BYTE)v8 != (_BYTE)v9 )
        {
          v13 = v3;
          v12 = v8;
          v9 = tolower_0(v9);
          v8 = tolower_0(v12);
          v3 = v13;
          if ( (_BYTE)v8 != (_BYTE)v9 )
            break;
        }
        if ( !--v3 )
          goto LABEL_25;
      }
      v3 = -1;
      if ( (unsigned __int8)v8 >= (unsigned __int8)v9 )
        v3 = 1;
LABEL_25:
      if ( v14 )
      {
        v10 = v3;
        sub_46FA37(19);
        v3 = v10;
      }
      else
      {
        _InterlockedDecrement(&dword_4C3248);
      }
    }
    else
    {
      while ( 1 )
      {
        v6 = *(_BYTE *)Buf1;
        Buf1 = (char *)Buf1 + 1;
        v7 = *(_BYTE *)Buf2;
        Buf2 = (char *)Buf2 + 1;
        if ( v6 != v7 )
        {
          if ( v6 >= 0x41u && v6 <= 0x5Au )
            v6 += 32;
          if ( v7 >= 0x41u && v7 <= 0x5Au )
            v7 += 32;
          if ( v6 != v7 )
            break;
        }
        if ( !--v3 )
          return v3;
      }
      v3 = -1;
      if ( v6 >= v7 )
        v3 = 1;
    }
  }
  return v3;
}
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (004A2011) --------------------------------------------------------
char *__cdecl _strlwr(char *String)
{
  char *result; // eax
  char *j; // edx
  char v3; // cl
  char *i; // edx
  char v5; // cl
  size_t v6; // eax
  int v7; // ebx
  CHAR *v8; // eax
  unsigned int v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v9 = 0;
  if ( dword_4C1C0C )
  {
    dword_4A7204(&dword_4C3248);
    if ( dword_4C3244 )
    {
      dword_4A720C(&dword_4C3248);
      _lock(19);
      v10 = 1;
    }
    else
    {
      v10 = 0;
    }
    if ( dword_4C1C0C )
    {
      v6 = __crtLCMapStringA_0(dword_4C1C0C, 0x100u, String, -1, 0, 0, 0, 1);
      v7 = v6;
      if ( v6 )
      {
        v8 = (CHAR *)sub_46D9FD(v6);
        v9 = (unsigned int)v8;
        if ( v8 )
        {
          if ( __crtLCMapStringA_0(dword_4C1C0C, 0x100u, String, -1, v8, v7, 0, 1) )
            sub_476F50();
        }
      }
      if ( v10 )
        sub_46FA37(19);
      else
        dword_4A720C(&dword_4C3248);
      sub_46D360(v9);
      result = String;
    }
    else
    {
      if ( v10 )
        sub_46FA37(19);
      else
        dword_4A720C(&dword_4C3248);
      result = String;
      for ( i = String; *i; ++i )
      {
        v5 = *i;
        if ( *i >= 65 && v5 <= 90 )
          *i = v5 + 32;
      }
    }
  }
  else
  {
    result = String;
    for ( j = String; *j; ++j )
    {
      v3 = *j;
      if ( *j >= 65 && v3 <= 90 )
        *j = v3 + 32;
    }
  }
  return result;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4C1C0C: using guessed type int dword_4C1C0C;
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (004A2150) --------------------------------------------------------
int __usercall sub_4A2150@<eax>(unsigned __int64 a1@<st1>, unsigned __int64 a2@<st0>)
{
  return sub_4A2172(a2, HIDWORD(a2), a1, HIDWORD(a1));
}
// 4A2172: using guessed type _DWORD __cdecl sub_4A2172(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A2172) --------------------------------------------------------
#error "4A2202: call analysis failed (funcsize=130)"

//----- (004A2345) --------------------------------------------------------
void __usercall test_whether_TOS_is_int(double a1@<st0>)
{
  _ST6 = a1;
  __asm { frndint }
  if ( _ST6 == a1 )
  {
    _ST6 = a1 * dbl_4C0FF0;
    __asm { frndint }
  }
}
// 4C0FF0: using guessed type double dbl_4C0FF0;

//----- (004A236D) --------------------------------------------------------
int fprintf(FILE *const Stream, const char *const Format, ...)
{
  int v2; // edi
  int v3; // ebx
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, Format);
  _lock_file(Stream);
  v2 = _stbuf_0((int)Stream);
  v3 = sub_472811(Stream, (char *)Format, (int)va);
  _ftbuf(v2, (int)Stream);
  sub_473E59((unsigned int)Stream);
  return v3;
}

//----- (004A23A9) --------------------------------------------------------
double __cdecl sub_4A23A9(char *Str, _DWORD *a2)
{
  char *i; // esi
  int v4; // eax
  int v5; // edx
  double result; // st7
  double v7; // st7
  int *v8; // eax
  char v9[24]; // [esp+8h] [ebp-20h] BYREF
  double v10; // [esp+20h] [ebp-8h]

  for ( i = Str; (int)dword_4BC19C <= 1 ? off_4BBF90[0][(unsigned __int8)*i] & 8 : _isctype_0((unsigned __int8)*i, 8); ++i )
    ;
  strlen(i);
  v4 = _fltin2((int)v9, i);
  if ( a2 )
    *a2 = &i[*(_DWORD *)(v4 + 4)];
  v5 = *(_DWORD *)v4;
  if ( (*(_DWORD *)v4 & 0x240) == 0 )
  {
    if ( (v5 & 0x81) != 0 )
    {
      v7 = dbl_4C1090;
      if ( *i == 45 )
        v7 = -dbl_4C1090;
    }
    else
    {
      if ( (v5 & 0x100) == 0 )
        return *(double *)(v4 + 16);
      v7 = 0.0;
    }
    v10 = v7;
    v8 = sub_46D641();
    result = v10;
    *v8 = 34;
    return result;
  }
  result = 0.0;
  if ( a2 )
    *a2 = Str;
  return result;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4C1090: using guessed type double dbl_4C1090;

//----- (004A2453) --------------------------------------------------------
int sscanf(const char *const Buffer, const char *const Format, ...)
{
  FILE v3; // [esp+0h] [ebp-20h] BYREF
  va_list va; // [esp+30h] [ebp+10h] BYREF

  va_start(va, Format);
  v3._flag = 73;
  v3._base = (char *)Buffer;
  v3._ptr = (char *)Buffer;
  v3._cnt = strlen(Buffer);
  return _input(&v3, (int)Format, (int)va);
}

//----- (004A25EE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall _ffexpm1@<eax>(char a1@<ch>, int _EBP@<ebp>)
{
  int result; // eax
  int v3; // [esp-4h] [ebp-4h]

  __asm
  {
    fld     st
    fabs
    fld     ds:tbyte_4C101E
    fcompp
    fstsw   word ptr [ebp-0A0h]
  }
  if ( (*(_BYTE *)(_EBP - 159) & 0x41) != 0 )
  {
    result = v3;
    __asm
    {
      ftst
      fstsw   word ptr [ebp-0A0h]
    }
    if ( (*(_BYTE *)(_EBP - 159) & 1) != 0 )
    {
      *(_BYTE *)(_EBP - 144) = 4;
      __asm
      {
        fstp    st
        fldz
      }
    }
    else
    {
      __asm
      {
        fstp    st
        fld     ds:tbyte_4C1000
      }
      if ( a1 )
        __asm { fchs }
    }
  }
  else
  {
    __asm
    {
      fld     st
      frndint
      ftst
      fstsw   word ptr [ebp-0A0h]
      fxch    st(1)
      fsub    st, st(1)
      ftst
      fstsw   word ptr [ebp-0A0h]
      fabs
      f2xm1
    }
  }
  return result;
}
// 4A25A1: positive sp value 4 has been found
// 4A25EE: inconsistent fpu stack
// 4A25A0: variable 'v3' is possibly undefined

//----- (004A2631) --------------------------------------------------------
// DDK Windows 32bit
double __usercall isintTOS@<st0>(double result@<st0>)
{
  _ST6 = result;
  __asm { frndint }
  if ( _ST6 == result )
  {
    _ST5 = result * dbl_4C1032;
    __asm { frndint }
  }
  return result;
}
// 4C1032: using guessed type double dbl_4C1032;

//----- (004A2859) --------------------------------------------------------
void __usercall sub_4A2859(int a1@<ebp>)
{
  *(_BYTE *)(a1 - 144) = 1;
}

//----- (004A2870) --------------------------------------------------------
void sub_4A2870()
{
  JUMPOUT(0x4A2890);
}
// 4A2885: control flows out of bounds to 4A2890

//----- (004A2887) --------------------------------------------------------
// Microsoft VisualC 2-10/net runtime
double __usercall _startOneArgErrorHandling@<st0>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, double a4@<st0>, __int16 a5, int a6, int a7, int a8)
{
  int v9[6]; // [esp+0h] [ebp-20h] BYREF
  double v10; // [esp+18h] [ebp-8h]

  v9[0] = a1;
  v10 = a4;
  v9[1] = a3;
  v9[2] = a7;
  v9[3] = a8;
  _87except(a2, (int)v9, &a5);
  return v10;
}

//----- (004A28D0) --------------------------------------------------------
double __usercall sub_4A28D0@<st0>(double a1@<st0>)
{
  _ST6 = a1;
  __asm { frndint }
  return __F2XM1__(-(_ST6 - a1)) + 1.0;
}

//----- (004A28E5) --------------------------------------------------------
void sub_4A28E5()
{
  ;
}

//----- (004A2915) --------------------------------------------------------
// Microsoft VisualC 2-10/net runtime
double __fastcall _fload_withFB(int a1, _DWORD *a2)
{
  double result; // st7

  if ( (a2[1] & 0x7FF00000) != 2146435072 )
    return *(double *)a2;
  *(_QWORD *)&result = *(_QWORD *)a2 << 11;
  return result;
}

//----- (004A29B9) --------------------------------------------------------
#error "4A29FE: call analysis failed (funcsize=54)"

//----- (004A2A5C) --------------------------------------------------------
int __cdecl _powhlp(double a1, double a2, int a3)
{
  double v4; // st7
  int v5; // esi
  char v6; // c0
  double v7; // st7
  int v8; // ecx

  v4 = a1;
  v5 = 0;
  if ( v6 )
    v4 = -a1;
  if ( HIDWORD(a2) != 2146435072 )
  {
    if ( a2 == -INFINITY )
    {
      if ( v4 > dbl_4A91C8 )
        goto LABEL_17;
      if ( v4 >= dbl_4A91C8 )
        goto LABEL_7;
LABEL_15:
      v7 = dbl_4BC660;
LABEL_28:
      *(double *)a3 = v7;
      return v5;
    }
LABEL_12:
    if ( HIDWORD(a1) == 2146435072 )
    {
      if ( LODWORD(a1) )
        return v5;
      if ( a2 > dbl_4A91B8 )
        goto LABEL_15;
      if ( a2 < dbl_4A91B8 )
        goto LABEL_17;
    }
    else
    {
      if ( a1 != -INFINITY )
        return v5;
      v8 = _d_inttype(a2);
      if ( a2 > dbl_4A91B8 )
      {
        v7 = dbl_4BC660;
        if ( v8 == 1 )
          v7 = -dbl_4BC660;
        goto LABEL_28;
      }
      if ( a2 < dbl_4A91B8 )
      {
        if ( v8 == 1 )
          v7 = dbl_4BC680;
        else
          v7 = 0.0;
        goto LABEL_28;
      }
    }
    v7 = 1.0;
    goto LABEL_28;
  }
  if ( LODWORD(a2) )
    goto LABEL_12;
  if ( v4 > dbl_4A91C8 )
    goto LABEL_15;
  if ( v4 < dbl_4A91C8 )
  {
LABEL_17:
    v7 = 0.0;
    goto LABEL_28;
  }
LABEL_7:
  v5 = 1;
  *(double *)a3 = dbl_4BC668;
  return v5;
}
// 4A2A75: variable 'v6' is possibly undefined
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4BC660: using guessed type double dbl_4BC660;
// 4BC668: using guessed type double dbl_4BC668;
// 4BC680: using guessed type double dbl_4BC680;

//----- (004A2B8C) --------------------------------------------------------
int __cdecl _d_inttype(double a1)
{
  int v2; // [esp+4h] [ebp-Ch]
  double v3; // [esp+18h] [ebp+8h]

  if ( (_fpclass(a1) & 0x90) != 0 || sub_4747E1(a1) != a1 )
    return 0;
  v3 = a1 / dbl_4B1408;
  if ( sub_4747E1(v3) == v3 )
    v2 = 2;
  else
    v2 = 1;
  return v2;
}
// 4B1408: using guessed type double dbl_4B1408;

//----- (004A2BF4) --------------------------------------------------------
int __cdecl _fltin2(int a1, char *a2)
{
  int v2; // edi
  char v3; // bl
  int v4; // eax
  int result; // eax
  char *v6; // ecx
  double v7; // st7
  unsigned __int16 v8[6]; // [esp+Ch] [ebp-18h] BYREF
  double v9; // [esp+18h] [ebp-Ch] BYREF
  char *v10; // [esp+20h] [ebp-4h] BYREF

  v2 = 0;
  v3 = __strgtold12_0((int)v8, &v10, a2, 0, 0, 0, 0);
  if ( (v3 & 4) != 0 )
  {
    v2 = 512;
    v9 = 0.0;
  }
  else
  {
    v4 = sub_476C92(v8, &v9);
    if ( (v3 & 2) != 0 || v4 == 1 )
      v2 = 128;
    if ( (v3 & 1) != 0 || v4 == 2 )
      v2 |= 0x100u;
  }
  result = a1;
  v6 = (char *)(v10 - a2);
  v7 = v9;
  *(_DWORD *)a1 = v2;
  *(double *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 4) = v6;
  return result;
}

//----- (004A2C73) --------------------------------------------------------
int __cdecl _input(FILE *File, int a2, int a3)
{
  unsigned __int8 *v3; // esi
  unsigned __int8 v4; // al
  FILE *v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int i; // eax
  int v10; // eax
  int v11; // edi
  int v12; // ebx
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16; // ebx
  int v17; // ebx
  char *v18; // esi
  FILE *v19; // edi
  int v26; // eax
  char *v30; // edi
  int v31; // eax
  unsigned int v32; // edx
  unsigned __int8 v33; // al
  unsigned __int8 v34; // cl
  unsigned __int8 v35; // al
  int v36; // esi
  _WORD *v37; // esi
  int v39; // eax
  int v40; // eax
  __int64 v41; // rax
  int v42; // eax
  __int64 v43; // rax
  int v44; // eax
  int v45; // edi
  int v46; // eax
  int v47; // ebx
  int v48; // eax
  int v49; // eax
  int v50; // ecx
  int result; // eax
  int v52; // [esp-4h] [ebp-1D4h]
  char v53; // [esp+Ch] [ebp-1C4h] BYREF
  char v54; // [esp+Dh] [ebp-1C3h] BYREF
  char v55[32]; // [esp+16Ch] [ebp-64h] BYREF
  int v56; // [esp+18Ch] [ebp-44h]
  char Dest[2]; // [esp+192h] [ebp-3Eh] BYREF
  int v58; // [esp+194h] [ebp-3Ch]
  wchar_t Source; // [esp+198h] [ebp-38h] BYREF
  char v60; // [esp+19Bh] [ebp-35h]
  int v61; // [esp+19Ch] [ebp-34h]
  _WORD *v62; // [esp+1A0h] [ebp-30h]
  _WORD *v63; // [esp+1A4h] [ebp-2Ch]
  __int64 v64; // [esp+1A8h] [ebp-28h]
  int v65; // [esp+1B0h] [ebp-20h]
  int v66; // [esp+1B4h] [ebp-1Ch]
  char v67; // [esp+1B8h] [ebp-18h]
  char v68; // [esp+1B9h] [ebp-17h]
  char v69; // [esp+1BAh] [ebp-16h]
  char v70; // [esp+1BBh] [ebp-15h]
  int C; // [esp+1BCh] [ebp-14h]
  char v72; // [esp+1C1h] [ebp-Fh]
  char v73; // [esp+1C2h] [ebp-Eh]
  char v74; // [esp+1C3h] [ebp-Dh]
  int v75; // [esp+1C4h] [ebp-Ch]
  char v76; // [esp+1CBh] [ebp-5h]
  int v77; // [esp+1CCh] [ebp-4h] BYREF
  char *v78; // [esp+1DCh] [ebp+Ch]
  unsigned __int8 *v79; // [esp+1DCh] [ebp+Ch]

  v70 = 0;
  v3 = (unsigned __int8 *)a2;
  v4 = *(_BYTE *)a2;
  v77 = 0;
  v61 = 0;
  if ( !v4 )
    goto LABEL_256;
  v5 = File;
  while ( 2 )
  {
    if ( (int)dword_4BC19C <= 1 )
      v6 = off_4BBF90[0][v4] & 8;
    else
      v6 = _isctype_0(v4, 8);
    if ( v6 )
    {
      --v77;
      v7 = _whiteout_0((int)&v77, v5);
      sub_4A36E9(v7, v5);
      v8 = *++v3;
      for ( i = isspace(v8); i; i = isspace(v10) )
        v10 = *++v3;
    }
    if ( *v3 != 37 )
    {
      ++v77;
      v47 = sub_4A36CF(v5);
      v48 = *v3++;
      C = v47;
      v79 = v3;
      if ( v48 == v47 )
      {
        if ( off_4BBF90[0][(unsigned __int8)v47] >= 0 )
          goto LABEL_247;
        ++v77;
        v49 = sub_4A36CF(v5);
        v50 = *v3++;
        v79 = v3;
        if ( v50 == v49 )
        {
          --v77;
          goto LABEL_247;
        }
        --v77;
        sub_4A36E9(v49, v5);
        --v77;
        sub_4A36E9(v47, v5);
      }
      else
      {
        --v77;
        sub_4A36E9(v47, v5);
      }
      break;
    }
    v60 = 0;
    v67 = 0;
    v68 = 0;
    v73 = 0;
    v72 = 0;
    v69 = 0;
    v11 = 0;
    v76 = 0;
    v66 = 0;
    v65 = 0;
    v75 = 0;
    v74 = 1;
    v62 = 0;
    do
    {
      v12 = *++v3;
      if ( (int)dword_4BC19C <= 1 )
        v13 = off_4BBF90[0][(unsigned __int8)v12] & 4;
      else
        v13 = _isctype_0((unsigned __int8)v12, 4);
      if ( v13 )
      {
        ++v65;
        v75 = v12 + 10 * v75 - 48;
        continue;
      }
      if ( v12 <= 78 )
      {
        switch ( v12 )
        {
          case 'N':
            continue;
          case '*':
            ++v73;
            continue;
          case 'F':
            continue;
          case 'I':
            if ( v3[1] == 54 && v3[2] == 52 )
            {
              v62 = (_WORD *)((char *)v62 + 1);
              v64 = 0i64;
              v3 += 2;
              continue;
            }
            break;
          case 'L':
            ++v74;
            continue;
        }
LABEL_32:
        ++v72;
        continue;
      }
      if ( v12 == 104 )
      {
        --v74;
        --v76;
      }
      else
      {
        if ( v12 == 108 )
        {
          ++v74;
        }
        else if ( v12 != 119 )
        {
          goto LABEL_32;
        }
        ++v76;
      }
    }
    while ( !v72 );
    v78 = (char *)v3;
    if ( !v73 )
    {
      v56 = a3;
      a3 += 4;
      v63 = *(_WORD **)(a3 - 4);
    }
    v72 = 0;
    if ( !v76 )
    {
      if ( *v3 == 83 || *v3 == 67 )
        v76 = 1;
      else
        v76 = -1;
    }
    v58 = *v3 | 0x20;
    v14 = v58;
    if ( v58 != 110 )
    {
      if ( v58 == 99 || v58 == 123 )
      {
        ++v77;
        v15 = sub_4A36CF(File);
      }
      else
      {
        v15 = _whiteout_0((int)&v77, File);
      }
      C = v15;
    }
    if ( v65 && !v75 )
    {
LABEL_253:
      --v77;
      sub_4A36E9(C, File);
      break;
    }
    if ( v14 > 111 )
    {
      switch ( v14 )
      {
        case 'p':
          v74 = 1;
          goto LABEL_181;
        case 's':
          if ( v76 > 0 )
            v69 = 1;
          v30 = asc_4C1098;
          break;
        case 'u':
          goto LABEL_181;
        case 'x':
LABEL_63:
          v16 = C;
          if ( C == 45 )
          {
            v68 = 1;
          }
          else if ( C != 43 )
          {
LABEL_129:
            if ( v16 != 48 )
              goto LABEL_189;
            ++v77;
            v31 = sub_4A36CF(File);
            v16 = v31;
            C = v31;
            if ( (_BYTE)v31 == 120 || (_BYTE)v31 == 88 )
            {
              ++v77;
              v16 = sub_4A36CF(File);
              C = v16;
              v52 = 120;
              goto LABEL_134;
            }
            v66 = 1;
            if ( v14 != 120 )
            {
              v52 = 111;
LABEL_134:
              v14 = v52;
              goto LABEL_189;
            }
            --v77;
            sub_4A36E9(v31, File);
            v16 = 48;
            goto LABEL_188;
          }
          if ( --v75 || !v65 )
          {
            ++v77;
            v16 = sub_4A36CF(File);
            C = v16;
          }
          else
          {
            v72 = 1;
          }
          goto LABEL_129;
        case '{':
          if ( v76 > 0 )
            v69 = 1;
          v30 = v78 + 1;
          v78 = v30;
          if ( *v30 != 94 )
          {
LABEL_141:
            memset(v55, 0, sizeof(v55));
            if ( v58 == 123 && *v30 == 93 )
            {
              LOBYTE(v32) = 93;
              ++v30;
              v55[11] = 32;
            }
            else
            {
              LOBYTE(v32) = v60;
            }
            while ( 1 )
            {
              v33 = *v30;
              if ( *v30 == 93 )
                break;
              ++v30;
              if ( v33 == 45 && (_BYTE)v32 && (v34 = *v30, *v30 != 93) )
              {
                ++v30;
                if ( (unsigned __int8)v32 >= v34 )
                {
                  v35 = v32;
                  LOBYTE(v32) = v34;
                }
                else
                {
                  v35 = v34;
                }
                if ( (unsigned __int8)v32 <= v35 )
                {
                  v32 = (unsigned __int8)v32;
                  v36 = v35 - (unsigned __int8)v32 + 1;
                  do
                  {
                    v55[v32 >> 3] |= 1 << (v32 & 7);
                    ++v32;
                    --v36;
                  }
                  while ( v36 );
                }
                LOBYTE(v32) = 0;
              }
              else
              {
                LOBYTE(v32) = v33;
                v55[v33 >> 3] |= 1 << (v33 & 7);
              }
            }
            if ( *v30 )
            {
              if ( v58 == 123 )
                v78 = v30;
              v37 = v63;
              --v77;
              v62 = v63;
              sub_4A36E9(C, File);
              while ( 1 )
              {
                if ( v65 )
                {
                  if ( !v75-- )
                    break;
                }
                ++v77;
                v39 = sub_4A36CF(File);
                C = v39;
                if ( v39 == -1 || ((1 << (v39 & 7)) & (v67 ^ v55[v39 >> 3])) == 0 )
                {
                  --v77;
                  sub_4A36E9(v39, File);
                  break;
                }
                if ( v73 )
                {
                  v62 = (_WORD *)((char *)v62 + 1);
                }
                else
                {
                  if ( v69 )
                  {
                    LOBYTE(Source) = v39;
                    if ( off_4BBF90[0][(unsigned __int8)v39] < 0 )
                    {
                      ++v77;
                      HIBYTE(Source) = sub_4A36CF(File);
                    }
                    wcstombs(Dest, &Source, dword_4BC19C);
                    *v37++ = *(_WORD *)Dest;
                  }
                  else
                  {
                    *(_BYTE *)v37 = v39;
                    v37 = (_WORD *)((char *)v37 + 1);
                  }
                  v63 = v37;
                }
              }
              if ( v62 != v37 )
              {
                if ( !v73 )
                {
                  ++v61;
                  if ( v58 != 99 )
                  {
                    if ( v69 )
                      *v63 = 0;
                    else
                      *(_BYTE *)v63 = 0;
                  }
                }
                goto LABEL_242;
              }
            }
            goto LABEL_256;
          }
          ++v30;
          break;
        default:
LABEL_117:
          if ( (unsigned __int8)*v78 == C )
          {
            --v70;
            if ( !v73 )
              a3 = v56;
            goto LABEL_242;
          }
          goto LABEL_253;
      }
LABEL_140:
      v67 = -1;
      goto LABEL_141;
    }
    switch ( v14 )
    {
      case 'o':
LABEL_181:
        v16 = C;
        if ( C == 45 )
        {
          v68 = 1;
        }
        else if ( C != 43 )
        {
          goto LABEL_189;
        }
        if ( !--v75 && v65 )
        {
          v72 = 1;
          goto LABEL_189;
        }
        ++v77;
        v16 = sub_4A36CF(File);
LABEL_188:
        C = v16;
LABEL_189:
        if ( v62 )
        {
          if ( !v72 )
          {
            while ( 1 )
            {
              if ( v14 == 120 )
              {
                if ( (int)dword_4BC19C <= 1 )
                  v40 = off_4BBF90[0][v16] & 0x80;
                else
                  v40 = _isctype_0(v16, 128);
                if ( !v40 )
                  goto LABEL_209;
                LODWORD(v41) = sub_4A4B60(v64, 4u);
                v64 = v41;
                v16 = _hextodec_0(v16);
                C = v16;
              }
              else
              {
                if ( (int)dword_4BC19C <= 1 )
                  v42 = off_4BBF90[0][v16] & 4;
                else
                  v42 = _isctype_0(v16, 4);
                if ( !v42 )
                {
LABEL_209:
                  --v77;
                  sub_4A36E9(v16, File);
                  break;
                }
                if ( v14 == 111 )
                {
                  if ( v16 >= 56 )
                    goto LABEL_209;
                  LODWORD(v43) = sub_4A4B60(v64, 3u);
                }
                else
                {
                  v43 = 10 * v64;
                }
                v64 = v43;
              }
              ++v66;
              v64 += v16 - 48;
              if ( v65 )
              {
                if ( !--v75 )
                  break;
              }
              ++v77;
              v16 = sub_4A36CF(File);
              C = v16;
            }
          }
          if ( v68 )
            v64 = -v64;
        }
        else
        {
          if ( !v72 )
          {
            while ( 1 )
            {
              if ( v14 == 120 || v14 == 112 )
              {
                if ( (int)dword_4BC19C <= 1 )
                  v46 = off_4BBF90[0][v16] & 0x80;
                else
                  v46 = _isctype_0(v16, 128);
                if ( !v46 )
                {
LABEL_231:
                  --v77;
                  sub_4A36E9(v16, File);
                  break;
                }
                v45 = 16 * v11;
                v16 = _hextodec_0(v16);
                C = v16;
              }
              else
              {
                if ( (int)dword_4BC19C <= 1 )
                  v44 = off_4BBF90[0][v16] & 4;
                else
                  v44 = _isctype_0(v16, 4);
                if ( !v44 )
                  goto LABEL_231;
                if ( v14 == 111 )
                {
                  if ( v16 >= 56 )
                    goto LABEL_231;
                  v45 = 8 * v11;
                }
                else
                {
                  v45 = 10 * v11;
                }
              }
              ++v66;
              v11 = v45 + v16 - 48;
              if ( v65 )
              {
                if ( !--v75 )
                  break;
              }
              ++v77;
              v16 = sub_4A36CF(File);
              C = v16;
            }
          }
          if ( v68 )
            v11 = -v11;
        }
        if ( v66 )
        {
          if ( v73 )
            goto LABEL_242;
          ++v61;
          goto LABEL_237;
        }
        goto LABEL_256;
      case 'c':
        if ( !v65 )
        {
          ++v75;
          v65 = 1;
        }
        if ( v76 > 0 )
          v69 = 1;
        v30 = asc_4C10A0;
        goto LABEL_140;
      case 'd':
        goto LABEL_181;
    }
    if ( v14 <= 100 )
      goto LABEL_117;
    if ( v14 <= 103 )
    {
      v17 = C;
      v18 = &v53;
      if ( C == 45 )
      {
        v53 = 45;
        v18 = &v54;
      }
      else if ( C != 43 )
      {
        v19 = File;
        goto LABEL_70;
      }
      v19 = File;
      --v75;
      ++v77;
      v17 = sub_4A36CF(File);
      C = v17;
LABEL_70:
      if ( !v65 || v75 > 349 )
        v75 = 349;
      while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][v17] & 4 : _isctype_0(v17, 4) )
      {
        if ( !v75-- )
          break;
        ++v66;
        *v18++ = v17;
        ++v77;
        v17 = sub_4A36CF(v19);
        C = v17;
      }
      if ( byte_4BC1A0 == (_BYTE)v17 )
      {
        if ( v75-- )
        {
          ++v77;
          v17 = sub_4A36CF(v19);
          *v18 = byte_4BC1A0;
          C = v17;
          ++v18;
          while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][v17] & 4 : _isctype_0(v17, 4) )
          {
            if ( !v75-- )
              break;
            ++v66;
            *v18++ = v17;
            ++v77;
            v17 = sub_4A36CF(v19);
            C = v17;
          }
        }
      }
      if ( v66 && (v17 == 101 || v17 == 69) )
      {
        if ( v75-- )
        {
          *v18++ = 101;
          ++v77;
          v26 = sub_4A36CF(v19);
          v17 = v26;
          C = v26;
          if ( v26 == 45 )
          {
            *v18++ = 45;
            goto LABEL_95;
          }
          if ( v26 == 43 )
          {
LABEL_95:
            if ( !v75-- )
            {
              v75 = 0;
              goto LABEL_98;
            }
            goto LABEL_97;
          }
LABEL_98:
          while ( (int)dword_4BC19C <= 1 ? off_4BBF90[0][v17] & 4 : _isctype_0(v17, 4) )
          {
            if ( !v75-- )
              break;
            ++v66;
            *v18++ = v17;
LABEL_97:
            ++v77;
            v17 = sub_4A36CF(v19);
            C = v17;
          }
        }
      }
      --v77;
      sub_4A36E9(v17, v19);
      if ( v66 )
      {
        if ( !v73 )
        {
          ++v61;
          *v18 = 0;
          off_4B9F50(v74 - 1, v63, &v53);
        }
        goto LABEL_242;
      }
      break;
    }
    if ( v14 == 105 )
    {
      v14 = 100;
      goto LABEL_63;
    }
    if ( v14 != 110 )
      goto LABEL_117;
    v11 = v77;
    if ( v73 )
      goto LABEL_242;
LABEL_237:
    if ( v62 )
    {
      *(_QWORD *)v63 = v64;
    }
    else if ( v74 )
    {
      *(_DWORD *)v63 = v11;
    }
    else
    {
      *v63 = v11;
    }
LABEL_242:
    ++v70;
    v79 = (unsigned __int8 *)(v78 + 1);
    v3 = v79;
LABEL_247:
    if ( C == -1 )
    {
      if ( *v3 == 37 && v79[1] == 110 )
      {
        v3 = v79;
        goto LABEL_251;
      }
LABEL_257:
      result = v61;
      if ( !v61 && !v70 )
        result = -1;
      return result;
    }
LABEL_251:
    v4 = *v3;
    if ( *v3 )
    {
      v5 = File;
      continue;
    }
    break;
  }
LABEL_256:
  if ( C == -1 )
    goto LABEL_257;
  return v61;
}
// 4A359B: conditional instruction was optimized away because of 'esi.4 in (==64|6F..72|>=74)'
// 4A3410: variable 'v41' is possibly undefined
// 4A3470: variable 'v43' is possibly undefined
// 4B9F50: using guessed type int (__cdecl *off_4B9F50)(_DWORD, _DWORD, _DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4BC1A0: using guessed type char byte_4BC1A0;

//----- (004A3698) --------------------------------------------------------
int __cdecl _hextodec_0(int C)
{
  int v1; // esi
  int v2; // eax

  v1 = C;
  if ( (int)dword_4BC19C <= 1 )
    v2 = off_4BBF90[0][C] & 4;
  else
    v2 = _isctype_0(C, 4);
  if ( !v2 )
    v1 = (C & 0xFFFFFFDF) - 7;
  return v1;
}
// 4BBF90: using guessed type __int16 *off_4BBF90[2];

//----- (004A36CF) --------------------------------------------------------
int __cdecl sub_4A36CF(FILE *File)
{
  if ( --File->_cnt < 0 )
    return _filbuf(File);
  return *(unsigned __int8 *)File->_ptr++;
}

//----- (004A36E9) --------------------------------------------------------
int __cdecl sub_4A36E9(int Character, FILE *Stream)
{
  int result; // eax

  if ( Character != -1 )
    result = ungetc_0(Character, Stream);
  return result;
}

//----- (004A3700) --------------------------------------------------------
int __cdecl _whiteout_0(int a1, FILE *File)
{
  int v2; // edi

  do
  {
    ++*(_DWORD *)a1;
    v2 = sub_4A36CF(File);
  }
  while ( isspace(v2) );
  return v2;
}

//----- (004A3730) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
double __cdecl fdiv_main_routine(_TBYTE a1, _TBYTE a2)
{
  double v2; // st7
  double v3; // st6
  unsigned int v4; // eax
  double result; // st7

  v2 = *(double *)&a2;
  v3 = *(double *)&a1;
  while ( !__CFADD__(DWORD1(a1), DWORD1(a1)) )
  {
    if ( !*(_QWORD *)&a1 || (HIWORD(a1) & 0x7FFF) != 0 )
      return v2 / v3;
    if ( (HIWORD(a2) & 0x7FFF) != 0 )
    {
      if ( (HIWORD(a2) & 0x7FFF) == 0x7FFF || !__CFADD__(DWORD1(a2), DWORD1(a2)) )
        return v2 / v3;
    }
    else if ( __CFADD__(DWORD1(a2), DWORD1(a2)) )
    {
      return v2 / v3;
    }
    *(double *)&a1 = v3 * flt_4C10C8;
    v2 = *(double *)&a2;
  }
  v4 = (2 * DWORD1(a1)) ^ 0xE000000;
  if ( (v4 & 0xE000000) != 0 )
    return v2 / v3;
  if ( !byte_4C10B0[v4 >> 28] )
    return v2 / v3;
  if ( (HIWORD(a1) & 0x7FFF) == 0 || (HIWORD(a1) & 0x7FFF) == 0x7FFF )
    return v2 / v3;
  if ( (HIWORD(a2) & 0x7FFF) == 1 )
    result = v2 * flt_4C10C4 / (v3 * flt_4C10C4);
  else
    result = v2 * flt_4C10C0 / (v3 * flt_4C10C0);
  return result;
}
// 4C10C0: using guessed type float flt_4C10C0;
// 4C10C4: using guessed type float flt_4C10C4;
// 4C10C8: using guessed type float flt_4C10C8;

//----- (004A38BE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A38BE()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fxch    st(1)
    fstp    [esp+arg_8]; _TBYTE
    fld     st
    fstp    tbyte ptr [esp+0]; _TBYTE
    fstp    [esp+arg_1C]
  }
  fdiv_main_routine(v0, v1);
  __asm { fld     [esp+arg_1C] }
}
// 4A38D9: positive sp value 2C has been found
// 4A38BE: inconsistent fpu stack
// 4A38CD: variable 'v0' is possibly undefined
// 4A38CD: variable 'v1' is possibly undefined

//----- (004A38DA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A38DA()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    tbyte ptr [esp+0]; _TBYTE
    fstp    [esp+arg_8]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
}
// 4A38E9: positive sp value 2C has been found
// 4A38DA: inconsistent fpu stack
// 4A38E1: variable 'v0' is possibly undefined
// 4A38E1: variable 'v1' is possibly undefined

//----- (004A38EA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A38EA()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    [esp+arg_8]; _TBYTE
    fstp    tbyte ptr [esp+0]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
  __asm { fld     [esp+arg_8] }
}
// 4A38FD: positive sp value 2C has been found
// 4A38EA: inconsistent fpu stack
// 4A38F1: variable 'v0' is possibly undefined
// 4A38F1: variable 'v1' is possibly undefined

//----- (004A38FE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A38FE()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    [esp+arg_8]; _TBYTE
    fstp    tbyte ptr [esp+0]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
}
// 4A390D: positive sp value 2C has been found
// 4A38FE: inconsistent fpu stack
// 4A3905: variable 'v0' is possibly undefined
// 4A3905: variable 'v1' is possibly undefined

//----- (004A390E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A390E()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    [esp+arg_8]; _TBYTE
    fxch    st(1)
    fld     st
    fstp    tbyte ptr [esp+0]; _TBYTE
    fstp    [esp+arg_1C]
  }
  fdiv_main_routine(v0, v1);
  __asm
  {
    fxch    st(1)
    fld     [esp+arg_1C]
    fxch    st(2)
  }
}
// 4A392D: positive sp value 2C has been found
// 4A390E: inconsistent fpu stack
// 4A391D: variable 'v0' is possibly undefined
// 4A391D: variable 'v1' is possibly undefined

//----- (004A3933) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A3933()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    tbyte ptr [esp+0]; _TBYTE
    fxch    st(1)
    fstp    [esp+arg_8]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
  __asm
  {
    fxch    st(1)
    fld     [esp+arg_8]
    fxch    st(2)
  }
}
// 4A394C: positive sp value 2C has been found
// 4A3933: inconsistent fpu stack
// 4A393C: variable 'v0' is possibly undefined
// 4A393C: variable 'v1' is possibly undefined

//----- (004A3AE6) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A3AE6()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    [esp+arg_8]; _TBYTE
    fxch    st(3)
    fstp    tbyte ptr [esp+0]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
  __asm { fxch    st(3) }
}
// 4A3AF9: positive sp value 2C has been found
// 4A3AE6: inconsistent fpu stack
// 4A3AEF: variable 'v0' is possibly undefined
// 4A3AEF: variable 'v1' is possibly undefined

//----- (004A3AFA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A3AFA()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    [esp+arg_8]; _TBYTE
    fxch    st(4)
    fld     st
    fstp    tbyte ptr [esp+0]; _TBYTE
    fstp    [esp+arg_1C]
  }
  fdiv_main_routine(v0, v1);
  __asm
  {
    fxch    st(4)
    fld     [esp+arg_1C]
    fxch    st(5)
  }
}
// 4A3B19: positive sp value 2C has been found
// 4A3AFA: inconsistent fpu stack
// 4A3B09: variable 'v0' is possibly undefined
// 4A3B09: variable 'v1' is possibly undefined

//----- (004A3B1F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl sub_4A3B1F()
{
  _TBYTE v0; // [esp-2Ch] [ebp-2Ch]
  _TBYTE v1; // [esp-20h] [ebp-20h]

  __asm
  {
    fstp    tbyte ptr [esp+0]; _TBYTE
    fxch    st(4)
    fstp    [esp+arg_8]; _TBYTE
  }
  fdiv_main_routine(v0, v1);
  __asm
  {
    fxch    st(4)
    fld     [esp+arg_8]
    fxch    st(5)
  }
}
// 4A3B38: positive sp value 2C has been found
// 4A3B1F: inconsistent fpu stack
// 4A3B28: variable 'v0' is possibly undefined
// 4A3B28: variable 'v1' is possibly undefined

//----- (004A3F21) --------------------------------------------------------
void __usercall __spoils<edx,ecx,st0> sub_4A3F21(double a1@<st1>, double a2@<st0>)
{
  _TBYTE v2; // [esp+0h] [ebp-30h]
  _TBYTE v3; // [esp+Ch] [ebp-24h]

  *(double *)&v3 = a1;
  *(double *)&v2 = a2;
  fdiv_main_routine(v2, v3);
}
// 4A3F2C: variable 'v2' is possibly undefined
// 4A3F2C: variable 'v3' is possibly undefined

//----- (004A3F36) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
unsigned int __usercall _fprem_common@<eax>(char a1@<dl>, __int128 a2, int a3, int a4, __int128 a5)
{
  unsigned int result; // eax
  int v6; // ecx
  double v7; // st7
  __int16 v8; // fps
  double v9; // st6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  __int16 v13; // fps

  result = *(_DWORD *)((char *)&a2 + 6) ^ 0x700;
  if ( ((*(_DWORD *)((char *)&a2 + 6) ^ 0x700) & 0x700) == 0 )
  {
    result = (result >> 11) & 0xF;
    if ( byte_4C10CC[result] )
    {
      result = *(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000;
      if ( (*(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000) != 2147418112 )
      {
        result = *(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000;
        if ( (*(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000) != 0 && result != 2147418112 )
        {
          result = 2 * DWORD1(a5);
          if ( !(2 * DWORD1(a5)) )
          {
            result = 2 * DWORD1(a2);
            if ( !(2 * DWORD1(a2)) )
            {
              if ( (WORD4(a5) & 0x7FFFu) > (WORD4(a2) & 0x7FFFu) + 63 )
              {
                v6 = ((BYTE8(a5) - BYTE8(a2)) & 0x3F | 0x20) + 1;
                v7 = fabs(*(long double *)&a2);
                v9 = fabs(*(long double *)&a5);
                do
                {
                  v10 = v9 < v7;
                  v11 = 0;
                  v12 = v9 == v7;
                  result = v8 & 0x100;
                  if ( (v8 & 0x100) == 0 )
                    v9 = v9 - v7;
                  v7 = v7 * dbl_4C10FC;
                  --v6;
                }
                while ( v6 );
              }
              else
              {
                while ( 1 )
                {
                  result = (WORD4(a2) & 0x7FFF) + 10;
                  if ( (int)((WORD4(a5) & 0x7FFF) - result) < 0 )
                    break;
                  *(double *)&a5 = __FPREM__(*(long double *)&a5, *(long double *)&a2);
                }
              }
            }
          }
        }
      }
    }
  }
  if ( (a1 & 3) != 0 )
  {
    result = v13 & 0x4300;
    __asm
    {
      fnstenv [esp+28h+var_28]
      fldenv  [esp+28h+var_28]
    }
  }
  return result;
}
// 4C10FC: using guessed type double dbl_4C10FC;

//----- (004A413C) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
unsigned int __usercall __spoils<ecx,st0> _adj_fprem@<eax>(double a1@<st1>, double a2@<st0>)
{
  unsigned int result; // eax
  char v3; // dl
  _BYTE v4[20]; // [esp+0h] [ebp-34h]
  int v5; // [esp+14h] [ebp-20h]
  __int128 v6; // [esp+18h] [ebp-1Ch]

  *(double *)&v6 = a1;
  *(double *)v4 = a2;
  if ( (*(_DWORD *)&v4[6] & 0x7FFF0000) != 0 )
    return _fprem_common(0, *(__int128 *)v4, *(int *)&v4[16], v5, v6);
  result = *(_DWORD *)&v4[4] | *(_DWORD *)v4;
  if ( a2 != 0.0 )
  {
    *(double *)&v4[12] = a2;
    v3 = 2;
    if ( (WORD4(v6) & 0x7FFFu) <= 0x7FBE )
    {
      v3 = 3;
      *(double *)&v6 = a1 * dbl_4C10E4;
    }
    *(double *)v4 = a2 * dbl_4C10E4;
    result = _fprem_common(v3, *(__int128 *)v4, HIDWORD(*(unsigned __int64 *)&a2), v5, v6);
  }
  return result;
}
// 4A414D: variable 'v4' is possibly undefined
// 4A4154: variable 'v5' is possibly undefined
// 4A4154: variable 'v6' is possibly undefined
// 4C10E4: using guessed type double dbl_4C10E4;

//----- (004A41EE) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
unsigned int __usercall _fprem1_common@<eax>(char a1@<dl>, __int128 a2, int a3, int a4, __int128 a5)
{
  unsigned int result; // eax
  unsigned int v6; // eax
  int v7; // ecx
  double v8; // st7
  __int16 v9; // fps
  double v10; // st6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  __int16 v14; // fps

  result = *(_DWORD *)((char *)&a2 + 6) ^ 0x700;
  if ( ((*(_DWORD *)((char *)&a2 + 6) ^ 0x700) & 0x700) == 0 )
  {
    result = (result >> 11) & 0xF;
    if ( byte_4C10CC[result] )
    {
      result = *(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000;
      if ( (*(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000) != 2147418112 )
      {
        result = *(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000;
        if ( (*(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000) != 0 && result != 2147418112 )
        {
          result = 2 * DWORD1(a5);
          if ( !(2 * DWORD1(a5)) )
          {
            result = 2 * DWORD1(a2);
            if ( !(2 * DWORD1(a2)) )
            {
              v6 = (WORD4(a2) & 0x7FFF) + 63;
              if ( (WORD4(a5) & 0x7FFFu) > v6 )
              {
                v7 = ((BYTE8(a5) - BYTE8(a2)) & 0x3F | 0x20) + 1;
                v8 = fabs(*(long double *)&a2);
                v10 = fabs(*(long double *)&a5);
                do
                {
                  v11 = v10 < v8;
                  v12 = 0;
                  v13 = v10 == v8;
                  result = v9 & 0x100;
                  if ( (v9 & 0x100) == 0 )
                    v10 = v10 - v8;
                  v8 = v8 * dbl_4C10FC;
                  --v7;
                }
                while ( v7 );
              }
              else
              {
                while ( 1 )
                {
                  result = (WORD4(a2) & 0x7FFF) + 10;
                  if ( (int)((WORD4(a5) & 0x7FFF) - result) < 0 )
                    break;
                  *(double *)&a5 = __FPREM__(*(long double *)&a5, *(long double *)&a2);
                }
              }
            }
          }
        }
      }
    }
  }
  if ( (a1 & 3) != 0 )
  {
    result = v14 & 0x4300;
    __asm
    {
      fnstenv [esp+28h+var_28]
      fldenv  [esp+28h+var_28]
    }
  }
  return result;
}
// 4C10FC: using guessed type double dbl_4C10FC;

//----- (004A43F4) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
unsigned int __usercall __spoils<ecx,st0> _adj_fprem1@<eax>(double a1@<st1>, double a2@<st0>)
{
  unsigned int result; // eax
  char v3; // dl
  _BYTE v4[20]; // [esp+0h] [ebp-34h]
  int v5; // [esp+14h] [ebp-20h]
  __int128 v6; // [esp+18h] [ebp-1Ch]

  *(double *)&v6 = a1;
  *(double *)v4 = a2;
  if ( (*(_DWORD *)&v4[6] & 0x7FFF0000) != 0 )
    return _fprem1_common(0, *(__int128 *)v4, *(int *)&v4[16], v5, v6);
  result = *(_DWORD *)&v4[4] | *(_DWORD *)v4;
  if ( a2 != 0.0 )
  {
    *(double *)&v4[12] = a2;
    v3 = 2;
    if ( (WORD4(v6) & 0x7FFFu) <= 0x7FBE )
    {
      v3 = 3;
      *(double *)&v6 = a1 * dbl_4C10E4;
    }
    *(double *)v4 = a2 * dbl_4C10E4;
    result = _fprem1_common(v3, *(__int128 *)v4, HIDWORD(*(unsigned __int64 *)&a2), v5, v6);
  }
  return result;
}
// 4A4408: variable 'v4' is possibly undefined
// 4A440F: variable 'v5' is possibly undefined
// 4A440F: variable 'v6' is possibly undefined
// 4C10E4: using guessed type double dbl_4C10E4;

//----- (004A44BB) --------------------------------------------------------
void __cdecl _87except(int a1, int a2, __int16 *a3)
{
  __int16 v3; // cx
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  DWORD v11; // ebx
  __int16 v12; // fps
  int v16; // [esp-4h] [ebp-68h]
  char v17[40]; // [esp+Ch] [ebp-58h] BYREF
  double v18; // [esp+34h] [ebp-30h]
  unsigned int v19; // [esp+44h] [ebp-20h]

  v3 = *a3;
  v5 = *(_DWORD *)a2 - 1;
  v4 = *(_DWORD *)a2 == 1;
  a3 = (__int16 *)(unsigned __int16)*a3;
  if ( v4 )
    goto LABEL_13;
  v6 = v5 - 1;
  if ( !v6 )
  {
    v16 = 4;
    goto LABEL_14;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v16 = 17;
    goto LABEL_14;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    v16 = 18;
    goto LABEL_14;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_13:
    v16 = 8;
LABEL_14:
    v11 = v16;
    if ( !_handle_exc(v16, (double *)(a2 + 24), v3) )
    {
      if ( a1 == 16 || a1 == 22 || a1 == 29 )
      {
        v18 = *(double *)(a2 + 16);
        v19 = v19 & 0xFFFFFFE3 | 3;
      }
      else
      {
        v19 &= 0xFFFFFFFE;
      }
      _raise_exc(v12, (ULONG_PTR)v17, (int)&a3, v11, a1, a2 + 8, a2 + 24);
    }
    goto LABEL_21;
  }
  v10 = v9 - 2;
  if ( !v10 )
  {
    *(_DWORD *)a2 = 1;
    goto LABEL_21;
  }
  if ( v10 == 1 )
  {
    v16 = 16;
    goto LABEL_14;
  }
LABEL_21:
  _ctrlfp(v3);
  if ( *(_DWORD *)a2 == 8 || dword_4BD0B0 || !sub_478C32() )
    _set_errno_from_matherr(*(_DWORD *)a2);
}
// 4A455E: variable 'v3' is possibly undefined
// 4BD0B0: using guessed type int dword_4BD0B0;

//----- (004A458B) --------------------------------------------------------
double __cdecl _copysign(double Number, double Sign)
{
  double v3; // [esp+0h] [ebp-8h]

  LODWORD(v3) = LODWORD(Number);
  HIDWORD(v3) = HIDWORD(Sign) ^ (HIDWORD(Number) ^ HIDWORD(Sign)) & 0x7FFFFFFF;
  return v3;
}

//----- (004A49A5) --------------------------------------------------------
int __cdecl _fpclass(double X)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+4h] [ebp-4h]

  if ( (HIWORD(X) & 0x7FF0) == 32752 )
  {
    v1 = _sptype(SLODWORD(X), SHIDWORD(X)) - 1;
    if ( v1 )
    {
      v2 = v1 - 1;
      if ( v2 )
      {
        if ( v2 == 1 )
          v6 = 2;
        else
          v6 = 1;
      }
      else
      {
        v6 = 4;
      }
      result = v6;
    }
    else
    {
      result = 512;
    }
  }
  else if ( (HIWORD(X) & 0x7FF0) == 0 && ((HIDWORD(X) & 0xFFFFF) != 0 || LODWORD(X)) )
  {
    v4 = -((HIWORD(X) & 0x8000) != 0);
    LOBYTE(v4) = v4 & 0x90;
    result = v4 + 128;
  }
  else
  {
    v5 = -((HIWORD(X) & 0x8000) != 0);
    if ( X == dbl_4A91B8 )
    {
      LOBYTE(v5) = v5 & 0xE0;
      result = v5 + 64;
    }
    else
    {
      LOBYTE(v5) = v5 & 8;
      result = v5 + 256;
    }
  }
  return result;
}
// 4A91B8: using guessed type double dbl_4A91B8;

//----- (004A4A37) --------------------------------------------------------
size_t __cdecl wcstombs(char *Dest, const wchar_t *Source, size_t MaxCount)
{
  void (__stdcall *v3)(int *); // edi
  int v4; // ebx
  unsigned int MaxCounta; // [esp+1Ch] [ebp+10h]

  dword_4A7204(&dword_4C3248);
  v3 = (void (__stdcall *)(int *))dword_4A720C;
  v4 = 0;
  if ( dword_4C3244 )
  {
    dword_4A720C(&dword_4C3248);
    _lock(19);
    v4 = 1;
  }
  MaxCounta = _mbtowc_lk((LPWSTR)Dest, (LPCSTR)Source, MaxCount);
  if ( v4 )
    sub_46FA37(19);
  else
    v3(&dword_4C3248);
  return MaxCounta;
}
// 4A7204: using guessed type int (__stdcall *dword_4A7204)(_DWORD);
// 4A720C: using guessed type int (__stdcall *dword_4A720C)(_DWORD);
// 4C3244: using guessed type int dword_4C3244;
// 4C3248: using guessed type int dword_4C3248;

//----- (004A4A94) --------------------------------------------------------
unsigned int __cdecl _mbtowc_lk(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a3)
{
  unsigned __int8 v3; // al
  unsigned int result; // eax
  bool v5; // zf

  if ( !lpMultiByteStr || !a3 )
    return 0;
  v3 = *lpMultiByteStr;
  if ( !*lpMultiByteStr )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = 0;
    return 0;
  }
  if ( !dword_4C1C0C )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = v3;
    return 1;
  }
  if ( off_4BBF90[0][v3] >= 0 )
  {
    if ( dword_4A71B0(dword_4C1C1C, 9, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )
      return 1;
    goto LABEL_18;
  }
  result = dword_4BC19C;
  if ( (int)dword_4BC19C > 1 )
  {
    if ( a3 >= (int)dword_4BC19C )
    {
      v5 = dword_4A71B0(dword_4C1C1C, 9, lpMultiByteStr, dword_4BC19C, lpWideCharStr, lpWideCharStr != 0) == 0;
      result = dword_4BC19C;
      if ( !v5 )
        return result;
      goto LABEL_16;
    }
LABEL_18:
    *sub_46D641() = 42;
    return -1;
  }
LABEL_16:
  if ( a3 < result || !lpMultiByteStr[1] )
    goto LABEL_18;
  return result;
}
// 4A71B0: using guessed type int (__stdcall *dword_4A71B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BBF90: using guessed type __int16 *off_4BBF90[2];
// 4C1C0C: using guessed type int dword_4C1C0C;

//----- (004A4B60) --------------------------------------------------------
int __usercall sub_4A4B60@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  __int64 v2; // rax

  if ( a2 >= 0x40u )
  {
    LODWORD(v2) = 0;
  }
  else if ( a2 >= 0x20u )
  {
    LODWORD(v2) = 0;
  }
  else
  {
    v2 = a1 << (a2 & 0x1F);
  }
  return v2;
}

//----- (004A4BA8) --------------------------------------------------------
int __cdecl ungetc_0(int Character, FILE *Stream)
{
  int v2; // eax
  int v4; // eax

  if ( Character == -1 )
    return -1;
  v2 = Stream->_flag;
  if ( (v2 & 1) == 0 && ((v2 & 0x80u) == 0 || (v2 & 2) != 0) )
    return -1;
  if ( !Stream->_base )
    _getbuf_0(Stream);
  if ( Stream->_ptr == Stream->_base )
  {
    if ( Stream->_cnt )
      return -1;
    ++Stream->_ptr;
  }
  if ( (Stream->_flag & 0x40) != 0 )
  {
    if ( *--Stream->_ptr != (_BYTE)Character )
    {
      ++Stream->_ptr;
      return -1;
    }
  }
  else
  {
    *--Stream->_ptr = Character;
  }
  v4 = Stream->_flag;
  ++Stream->_cnt;
  LOBYTE(v4) = v4 & 0xEF | 1;
  Stream->_flag = v4;
  return (unsigned __int8)Character;
}

//----- (004A4C16) --------------------------------------------------------
double __cdecl ldexp(double a1, double Sign)
{
  __int16 v2; // cx
  int v3; // edi
  __int16 v4; // cx
  int v5; // eax
  double v7; // st7
  int v8; // eax
  unsigned __int64 v9; // st7
  double v10; // st7
  unsigned __int64 v11; // st7
  double v12; // st7
  __int16 v13; // cx
  _BYTE v14[20]; // [esp+4h] [ebp-2Ch]
  double v15; // [esp+10h] [ebp-20h]
  double v16; // [esp+10h] [ebp-20h]
  __int16 v17; // [esp+18h] [ebp-18h]
  int v18; // [esp+18h] [ebp-18h]
  int v19; // [esp+18h] [ebp-18h]
  double v20; // [esp+24h] [ebp-Ch]
  int v21; // [esp+2Ch] [ebp-4h] BYREF

  v3 = _ctrlfp(v2);
  v4 = -1;
  if ( (HIWORD(a1) & 0x7FF0) == 32752 )
  {
    v5 = _sptype(SLODWORD(a1), SHIDWORD(a1));
    v4 = v17;
    if ( v5 <= 0 )
      return sub_474170(
               8,
               25,
               LODWORD(a1),
               HIDWORD(a1),
               COERCE_UNSIGNED_INT64((double)SLODWORD(Sign)),
               HIDWORD(COERCE_UNSIGNED_INT64((double)SLODWORD(Sign))),
               COERCE_UNSIGNED_INT64(a1 + dbl_4A91C8),
               HIDWORD(COERCE_UNSIGNED_INT64(a1 + dbl_4A91C8)),
               v3);
    if ( v5 > 2 )
    {
      if ( v5 == 3 )
      {
        *(double *)&v14[12] = (double)SLODWORD(Sign);
        *(double *)&v14[4] = a1;
        *(_DWORD *)v14 = 25;
        return _handle_qnan2(*(double *)v14, *(double *)&v14[8], HIDWORD(COERCE_UNSIGNED_INT64((double)SLODWORD(Sign))));
      }
      return sub_474170(
               8,
               25,
               LODWORD(a1),
               HIDWORD(a1),
               COERCE_UNSIGNED_INT64((double)SLODWORD(Sign)),
               HIDWORD(COERCE_UNSIGNED_INT64((double)SLODWORD(Sign))),
               COERCE_UNSIGNED_INT64(a1 + dbl_4A91C8),
               HIDWORD(COERCE_UNSIGNED_INT64(a1 + dbl_4A91C8)),
               v3);
    }
    goto LABEL_8;
  }
  if ( a1 == dbl_4A91B8 )
  {
LABEL_8:
    _ctrlfp(v4);
    return a1;
  }
  v7 = _decomp(a1, (int)&v21);
  v8 = v21 + LODWORD(Sign);
  if ( v21 + LODWORD(Sign) > 2560 )
  {
    v18 = v3;
    v15 = _copysign(dbl_4BC660, v7);
    *(double *)&v9 = (double)SLODWORD(Sign);
    return sub_474170(17, 25, LODWORD(a1), HIDWORD(a1), v9, HIDWORD(v9), LODWORD(v15), HIDWORD(v15), v18);
  }
  if ( v8 > 1024 )
  {
    v10 = _set_exp(v7, v8 - 1536);
    v18 = v3;
    v15 = v10;
    *(double *)&v9 = (double)SLODWORD(Sign);
    return sub_474170(17, 25, LODWORD(a1), HIDWORD(a1), v9, HIDWORD(v9), LODWORD(v15), HIDWORD(v15), v18);
  }
  if ( v8 < -2557 )
  {
    v19 = v3;
    v16 = 0.0;
    *(double *)&v11 = (double)SLODWORD(Sign);
    return sub_474170(18, 25, LODWORD(a1), HIDWORD(a1), v11, HIDWORD(v11), LODWORD(v16), HIDWORD(v16), v19);
  }
  if ( v8 < -1021 )
  {
    v12 = _set_exp(v7, v8 + 1536);
    v19 = v3;
    v16 = v12;
    *(double *)&v11 = (double)SLODWORD(Sign);
    return sub_474170(18, 25, LODWORD(a1), HIDWORD(a1), v11, HIDWORD(v11), LODWORD(v16), HIDWORD(v16), v19);
  }
  v20 = _set_exp(v7, v8);
  _ctrlfp(v13);
  return v20;
}
// 4A4C29: variable 'v2' is possibly undefined
// 4A4C4F: variable 'v17' is possibly undefined
// 4A4DED: variable 'v13' is possibly undefined
// 474170: using guessed type double __cdecl sub_474170(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4A91B8: using guessed type double dbl_4A91B8;
// 4A91C8: using guessed type double dbl_4A91C8;
// 4BC660: using guessed type double dbl_4BC660;

//----- (004A54A0) --------------------------------------------------------
int __usercall sub_4A54A0@<eax>(int a1@<ebp>)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = (_DWORD *)(*(_DWORD *)(a1 - 16) + 280);
  sub_40B7D0(*v1);
  result = 0;
  *v1 = 0;
  v1[2] = 0;
  v1[1] = 0;
  return result;
}
// 40B7D0: using guessed type int __thiscall sub_40B7D0(_DWORD);

//----- (004A54AE) --------------------------------------------------------
void __usercall sub_4A54AE(int a1@<ebp>)
{
  sub_415030(*(_DWORD *)(a1 - 16) + 556, a1);
}

//----- (004A54BC) --------------------------------------------------------
int __usercall sub_4A54BC@<eax>(int a1@<ebp>)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = (_DWORD *)(*(_DWORD *)(a1 - 16) + 564);
  sub_40B7D0(*(_DWORD *)(*(_DWORD *)(a1 - 16) + 568));
  result = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[2] = 0;
  return result;
}
// 40B7D0: using guessed type int __thiscall sub_40B7D0(_DWORD);

//----- (004A5780) --------------------------------------------------------
int __cdecl sub_4A5780(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5790) --------------------------------------------------------
int __cdecl sub_4A5790(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57A0) --------------------------------------------------------
int __cdecl sub_4A57A0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57B0) --------------------------------------------------------
int __cdecl sub_4A57B0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57C0) --------------------------------------------------------
int __cdecl sub_4A57C0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57D0) --------------------------------------------------------
int __cdecl sub_4A57D0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57E0) --------------------------------------------------------
int __cdecl sub_4A57E0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A57F0) --------------------------------------------------------
int __cdecl sub_4A57F0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5800) --------------------------------------------------------
int __cdecl sub_4A5800(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5810) --------------------------------------------------------
int __cdecl sub_4A5810(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5820) --------------------------------------------------------
int __cdecl sub_4A5820(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5830) --------------------------------------------------------
int __cdecl sub_4A5830(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5840) --------------------------------------------------------
int __cdecl sub_4A5840(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5850) --------------------------------------------------------
int __cdecl sub_4A5850(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5860) --------------------------------------------------------
int __cdecl sub_4A5860(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5870) --------------------------------------------------------
int __cdecl sub_4A5870(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5880) --------------------------------------------------------
int __cdecl sub_4A5880(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5890) --------------------------------------------------------
int __cdecl sub_4A5890(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A58A0) --------------------------------------------------------
int __cdecl sub_4A58A0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A58B0) --------------------------------------------------------
int __cdecl sub_4A58B0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A58C0) --------------------------------------------------------
int __cdecl sub_4A58C0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A58D0) --------------------------------------------------------
int __cdecl sub_4A58D0(int a1, int a2, int a3, int a4)
{
  return __CxxFrameHandler(a1, a2, a3, a4);
}
// 46CE7D: using guessed type _DWORD __cdecl __CxxFrameHandler(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C801E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_4C801E()
{
  int v0; // edx
  char v1; // [esp-14h] [ebp-14h]

  sub_4C803A();
  ((void (*)(void))loc_4C9012)();
  *(_BYTE *)(v0 + 2536) += v1;
  sub_4C803A();
}
// 4C8020: positive sp value 24 has been found
// 4C801E: could not find valid save-restore pair for ebx
// 4C801E: could not find valid save-restore pair for ebp
// 4C801E: could not find valid save-restore pair for edi
// 4C801E: could not find valid save-restore pair for esi
// 4C802A: variable 'v1' is possibly undefined
// 4C802A: variable 'v0' is possibly undefined

//----- (004C803A) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_4C803A()
{
  __asm { retn }
}
// 4C803B: positive sp value 4 has been found

//----- (004C8200) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_4C8200()
{
  int v1; // [esp-8h] [ebp-8h]

  return v1;
}
// 4C8205: positive sp value 8 has been found
// 4C8203: variable 'v1' is possibly undefined

//----- (004C8207) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_4C8207(int a1@<edx>, int a2@<ebp>)
{
  int v2; // ecx
  _DWORD v3[3]; // [esp-10h] [ebp-10h] BYREF
  int v4; // [esp-4h] [ebp-4h]

  v2 = v4;
  v4 = a1;
  v3[1] = (char *)&loc_40231D + a2;
  v3[0] = NtCurrentTeb()->NtTib.ExceptionList;
  __writefsdword(0, (unsigned int)v3);
  __asm { retn }
}
// 4C8208: positive sp value 4 has been found

// nfuncs=2077 queued=1980 decompiled=1980 lumina nreq=0 worse=0 better=0
#error "There were 21 decompilation failure(s) on 1980 function(s)"
