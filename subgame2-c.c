/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

ARENA *__thiscall Create(ARENA *this, char *name);
void __thiscall ArenaShutdownArena(int this);
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team);
points_data *__thiscall ArenaAddPlayer(ARENA *arena, PLAYER *p);
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player);
int __thiscall sub_402560(_DWORD); // weak
int __cdecl sub_403F60(const void *, const void *); // idb
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset);
int __thiscall sub_404050(int this, int a2);
int __thiscall sub_404120(int this, int a2);
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3); // idb
void __thiscall ResetFlagGame(struct ARENA *arenaa);
int __thiscall DLL_CALL_GET_NEW_FREQ(_DWORD player);
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4);
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius);
void __thiscall sub_404980(char *this, int a2, int a3, int a4);
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4);
void __thiscall LoadArenaSettings_0_0(struct ARENA *arenaa);
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this); // idb
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa); // idb
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3); // idb
int __thiscall sub_405360(int this, int a2);
int __thiscall SoccerGameSomething(ARENA *this, int a2); // idb
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4); // idb
void __thiscall GetScore(ARENA *arenaa, int a2);
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena); // idb
int __thiscall GetTotalPlayingPlayers(ARENA *arena); // idb
void __thiscall sub_4059D0(int *this, int a2, char *a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct); // idb
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3);
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3);
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText);
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage);
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand);
void __thiscall j_lpfnFixExport10(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr); // idb
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize);
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size);
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len);
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len);
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int buf, int a3, int a4, int len);
int __thiscall GetBillerLastReconnectTime(_DWORD *this);
// signed int __usercall IsBillingServerDisconnected@<eax>(BILLING_SERVER_STRUCT *billingServerStruct@<ecx>, int a2@<ebp>);
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename); // idb
void __thiscall WriteCfgFile(struct struc_2 *struc2);
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4);
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count);
char *__thiscall sub_4066B0(int *this, char *a2, char *a3, char *a4, char *a5, size_t a6);
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source);
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source);
void __thiscall sub_406B30(int this);
int __thiscall sub_406BE0(_DWORD *this);
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer);
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize);
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key);
int __cdecl sub_406ED0(char *level_file); // idb
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll);
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile);
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2);
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile);
int __thiscall sub_407260(_DWORD *this);
int __thiscall sub_407270(_DWORD *this, int a2);
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer);
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number);
int __thiscall sub_407420(int this, int a2);
int __cdecl CompareFunc(_DWORD, _DWORD); // idb
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src);
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int);
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer);
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName);
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
void __cdecl config_read_helper_3(char *a1);
signed int __cdecl CRC32(char *buffer, int fileSize);
int __cdecl sub_408270(int a1);
void *__cdecl emalloc(int bytes);
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3);
void __stdcall efree(LPVOID ptr);
SOCKET *__thiscall ConnectSocket(SOCKET *this, char *cp, int a3, unsigned int buf);
int __thiscall CloseSocketWrapper(SOCKET *this);
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3);
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed); // idb
PINGSOCKET *__thiscall ListenOnPort(PINGSOCKET *socket, __int16 port, void *callback);
void __thiscall ProcessZonePings(int Socket, int ZonePopulation);
PLAYER *__thiscall CreateNewPlayer(PLAYER *this, struct in_addr in, __int16 a3, NetData *nd);
void __thiscall DisconnectPlayer(PLAYER *p); // idb
void __thiscall PlayerHandleGamePacket(PLAYER *p, BYTE *pkt, DWORD pkt_sz);
void __thiscall GenerateWarning(struct PLAYER *player, int a2);
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr);
int __thiscall CheckUserStopPlaying(PLAYER *player);
void __thiscall sub_40D8D0(int this);
void __thiscall PlayerChangeFrequency(struct PLAYER *player, signed int NewFrequency);
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship);
int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD); // weak
// int __userpurge sub_40DF06@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, _BYTE *a5, void *buf, int buf_sz);
int __thiscall PlayerSendPacket(PLAYER *player, void *buf, int buf_sz, BOOL bSendReliable); // idb
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6);
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4);
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend);
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6);
int __thiscall sub_40E280(_DWORD *this, void *buf, int buf_sz, BOOL bSendReliable, int a5, int a6);
int __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, struct_ARENA *a6);
int __thiscall sub_40E360(void *this, int a2, int buf, int buf_sz, int bSendReliable, int a6, int a7);
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte);
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2);
void __thiscall SendArenaMessagePlayer(PLAYER *playerr, const char *a2, char SoundByte);
int __thiscall SendFile(int *this, char *filename);
// void __userpurge PlayerFindSuitableArena(PLAYER *p@<ecx>, DWORD join_type, char *arena_preference, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __thiscall SendWeaponPacket(PLAYER *player);
void __thiscall SendResetScoresPacket(PLAYER *player);
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player);
signed int __thiscall SendPlayerScoreUpdateAll(void *player);
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2);
void __cdecl LoadArenaSettings(struct_ArenaSettings *ArenaSettings, struct_ArenaSettings *a2, const char *a3);
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3);
int __cdecl main(int argc, const char **argv, const char **envp);
signed int __cdecl ServerInitialize();
void __cdecl NewConnectionRequest(struct in_addr in, __int16 port);
int __cdecl sub_412EF0(int, int, int); // idb
void __cdecl ServerMainloop();
int __cdecl IncreaseRadarValueShowHomeOverFourThousand();
void __cdecl ServerUninitialize();
// void __usercall sub_413B50(int a1@<ebp>, int a2@<edi>, unsigned int a3@<esi>, int a4, int a5);
void FormatMessageArena(ARENA *arena, const char *Format, ...);
void WriteSubGameLog(const char *Format, ...);
bool __cdecl IsOffensiveName(char *a1);
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2); // idb
int __cdecl ProtocolViolation();
// void __usercall process_text_packet(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, Player *p, DWORD msg_type, DWORD target_index, char *msg, DWORD arg5);
void __thiscall init_new_player(PLAYER *this);
char *__cdecl fix_dll_loader(const char *a1, const char *a2);
// void __userpurge create_arena(ARENA *a1@<ecx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_415800(int a1, int a2);
int __cdecl sub_415820();
int __stdcall HackedRecvFrom(int a1, int a2, int a3, int a4, int a5, int a6);
// void __userpurge sub_415850(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6, int a7);
// void __userpurge sub_415870(int a1@<ebp>, int a2, int a3, int a4, int a5);
// void __userpurge sub_4158A0(int a1@<ebx>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11);
// void __userpurge sub_415920(int a1@<ebp>, int a2, int a3, int a4, int a5);
// void __usercall CommandHandler_2(char *a1@<ebx>, PLAYER *a2@<ebp>, int a3@<edi>, unsigned int a4@<esi>, int a5, int a6, int a7, int a8, char a9);
int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_419A51(char a1@<zf>);
// int __userpurge sub_419A70@<eax>(int a1@<edx>, PLAYER *a2@<ecx>, int a3@<ebp>, void *a4, int a5, BOOL a6);
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3);
unsigned int __cdecl LoadServerIni();
void __cdecl LoadTemplateSSS();
int __cdecl sub_41AA20();
void __cdecl LoadAdvertisements();
void __cdecl CleanUpMemory();
int __cdecl InitWinsock();
int j_WSACleanup(void); // weak
int *__thiscall setup_stuff_and_socket(int *this, int lpfnNewConnectionRequest, int lpfnOnEachPacket, int a4, int a5, int dwSendBufSz, int dwRecvBufSz, int optval);
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment);
int __thiscall SetPacketAttachmentEncryptMode(int this, int a2);
struct CONNECTION *__thiscall SomethingBillerServer(PACKET_ATTACHMENT *packetAttachment, const char *name, u_short hostshort, int a4, int a5);
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename);
char *__thiscall PlayerReadPackets(struct PACKET_ATTACHMENT *packetAttachment, int *RecvLength, int *RemoteIP, int *RemotePort);
signed int __thiscall PlayerDoNetworkOps(struct_v9 *this); // idb
void __thiscall PlayerHandlePacket(PLAYER *p, BYTE *packet, DWORD dwBytesRead, DWORD dwIPAddress, int wSrcPort);
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5);
// int __userpurge sub_41BD80@<eax>(int p@<ecx>, int a2@<ebp>, int a3, int a4);
int __thiscall sub_41BFA0(_DWORD *this);
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls);
signed int __thiscall sub_41C000(void *this, signed int a2);
void __thiscall SendPacketsToEverybody(struct PACKET_ATTACHMENT *packetAttachment);
int __cdecl DifferentCompareFunction(_DWORD connection, int ConnectionsArray);
int __thiscall encrypt_init(char *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
void *__thiscall sub_41C360(int this);
int __thiscall sub_41C510(int this);
int __thiscall sub_41C520(int this);
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2);
// void __userpurge WriteToNetwork(int a1@<ecx>, char *buf, int len, int a4, int a5, int a6, int a7, int a8, int a9, char a10);
void __thiscall NetDataHandleCorePacket(NETDATA *nd, void *packet, int packet_sz, int a4);
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection);
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4);
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename);
int __thiscall SendHugeChunkPacketAllocated(int this, int a2, int a3, int a4);
int __stdcall sub_41D4C3(int, int, int); // weak
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4);
int __thiscall sub_41D560(int this, _DWORD *a2, _DWORD *a3);
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart);
int __thiscall sub_41D5C0(int this);
void __thiscall SendPacketCluster(struct CONNECTION *encryptionn, const void *buf, unsigned int len);
// void __usercall sub_41D6D0(int a1@<ecx>, int a2@<ebp>, int a3@<edi>);
int __thiscall sub_41D720(int this, int a2, int a3);
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5);
void __thiscall sub_41D780(int this);
char *__cdecl get_text_ip(struct in_addr in); // idb
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename);
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize);
// int __cdecl compress(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall send(SOCKET s, const char *buf, int len, int flags); idb
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen); idb
// struct hostent *__stdcall gethostbyname(const char *name); idb
// unsigned __int32 __stdcall inet_addr(const char *cp); idb
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen); idb
// u_long __stdcall ntohl(u_long netlong); idb
// u_short __stdcall ntohs(u_short netshort); idb
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen); idb
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp); idb
// SOCKET __stdcall socket(int af, int type, int protocol); idb
// int __stdcall closesocket(SOCKET s); idb
// int __stdcall recv(SOCKET s, char *buf, int len, int flags); idb
int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen); // idb
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); idb
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); idb
// char *__stdcall inet_ntoa(struct in_addr in); idb
int __cdecl srand(int a1);
// int rand(void); idb
// _DWORD printf(const char *, ...); weak
// time_t __cdecl time(time_t *); idb
// _DWORD sprintf(_DWORD, const char *, ...); weak
// char *__cdecl strrchr(const char *, int); idb
// _DWORD __cdecl fclose(_DWORD); weak
// _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl fopen(_DWORD, _DWORD); weak
// char *__cdecl strncpy(char *, const char *, size_t); idb
// _DWORD __cdecl fwrite(LPCVOID lpBuffer, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t); idb
// int __cdecl operator delete(void *); idb
// void *__cdecl operator new(unsigned int); weak
// int __cdecl atoi(const char *); idb
// int __cdecl isalpha(int); idb
// int __cdecl isdigit(int); idb
// int __cdecl isspace(int); idb
// _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD); weak
// _DWORD fprintf(_DWORD, const char *, ...); weak
// int __cdecl fseek(int, LONG lDistanceToMove, int); idb
// int __cdecl _chsize(_DWORD, _DWORD); weak
// char *__cdecl strstr(const char *, const char *); idb
// int __cdecl toupper(int); idb
// void __cdecl exit(int); idb
// void *__cdecl malloc(size_t); idb
// void *__cdecl realloc(void *, size_t); idb
// void __cdecl free(void *); idb
char *__cdecl RunCommandPrompt(char *argumentsPointer);
// _DWORD _spawnlp(_DWORD, _DWORD, ...); weak
// clock_t clock(void); idb
// _DWORD __cdecl fflush(_DWORD); weak
// _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD); weak
// char *__cdecl asctime(const struct tm *); idb
// struct tm *__cdecl localtime(const time_t *); idb
// double __cdecl difftime(time_t, time_t); idb
// _DWORD __cdecl _filelength(_DWORD); weak
void sub_422060();
void sub_4220CE();
void sub_4220F0();
void sub_42215E();
// _DWORD __cdecl _spawnvpe(_DWORD, char *, _DWORD, _DWORD); weak
// _DWORD __cdecl _spawnve(_DWORD, char *lpFileName, _DWORD, _DWORD); weak
// int __cdecl _access(LPCSTR lpFileName, char); idb
// char *__cdecl getenv(const char *); idb
bool __cdecl DateFunction(_DWORD *a1);
// _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl unknown_libname_5(int, int, int); weak
// void abort(void); idb
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_427220(int a1, int a2);
int __cdecl sub_427240(int a1, int a2);
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *Str);
int __cdecl sub_4272A0(int a1, int a2);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _fileno(_DWORD); weak
// int __cdecl _strcmpi(const char *, const char *); idb
// char *__cdecl _strupr(char *); idb
int __cdecl getch();
int __cdecl console_input_wrapper();
// _DWORD __cdecl _getextendedkeycode(_DWORD); weak
// int __cdecl _memicmp(const void *, const void *, unsigned int); idb
// int __initconin(void); weak
// int unknown_libname_14(); weak
// int __stdcall GetObjectA(HGDIOBJ, int, LPVOID); idb
// BOOL __stdcall DeleteObject(HGDIOBJ); idb
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize); idb
// BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName); idb
// BOOL __stdcall CloseHandle(HANDLE hObject); idb
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime); idb
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); idb
// UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName); idb
// DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); idb
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect); idb
// BOOL __stdcall VirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode); idb
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); idb
// LPSTR GetCommandLineA(void); idb
// BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle); idb
// void __stdcall Sleep(DWORD dwMilliseconds); idb
// BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents); idb
// BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead); idb
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode); idb
// BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode); idb
// BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead); idb
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName); idb
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); idb
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); idb
// HANDLE __stdcall LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT); idb
unsigned int __thiscall sub_100010E0(int *this, unsigned __int8 *a2, int a3);
unsigned int __thiscall sub_10001120(int *this, const char *a2);
_DWORD *__thiscall sub_10001240(_DWORD *this, const char *a2);
_DWORD *__thiscall sub_10001320(_DWORD *this);
void *__thiscall ReadsScrty1File(void *this, int a2, int a3, int a4, int a5);
int __thiscall sub_10001A50(int *this);
int __thiscall ReadScrty1File(void *this, char *FileName, int a3, int a4);
int __thiscall sub_10001D90(_DWORD *this);
int __thiscall ReadScrty1FileOffset(void *this, int a2, int a3);
bool __thiscall sub_10001F70(void *this);
int __thiscall sub_10002090(_DWORD *this);
char __thiscall sub_100024F0(_DWORD *this, char *a2, int a3);
_BOOL1 __thiscall sub_100027F0(void *this);
int __thiscall sub_10002830(void *this);
int __thiscall sub_100028D0(void *this);
unsigned int __thiscall sub_10002A10(_BYTE *this, int a2, _BYTE *a3);
void __thiscall sub_10002B80(_BYTE *this);
int __cdecl sub_10002CC0(int a1);
int __fastcall sub_10002D10(int *a1, int a2);
int __thiscall sub_10002D60(void *this);
int __cdecl sub_10002D70(int a1);
char *__fastcall sub_10002E30(_BYTE *a1, int a2, char *a3, char a4, int a5);
char *__fastcall strncpyt(void *dst, void *src, int len);
char *__fastcall sub_10003060(const char *a1, const char *a2, signed int a3);
char *__fastcall sub_100030E0(char *a1, const char *a2);
char __fastcall sub_10003220(char *a1, int a2, char a3);
char *__thiscall sub_10003240(char *this);
_BYTE *__thiscall sub_10003260(_BYTE *this);
char *__fastcall sub_10003280(char *a1);
int __thiscall sub_100033A0(_DWORD *this);
int sub_10003E70(const char **a1, char *a2, ...);
void __cdecl sub_10005120(int a1, int a2);
const char **sub_10005140(const char **a1, char *a2, ...);
char __fastcall sub_100052C0(const char *a1, const char *a2, char *a3, const char *a4, char a5);
void __fastcall sub_10005390(int a1, int a2, unsigned int a3, int a4);
_DWORD *__thiscall sub_10005460(_DWORD *this, int a2);
int __thiscall sub_10005490(_DWORD *this);
int __thiscall sub_100054B0(_DWORD *this, int a2);
int __thiscall sub_10005590(unsigned int *this);
int __thiscall sub_10005630(_DWORD *this);
int __thiscall sub_10005650(_DWORD *this);
_DWORD *__thiscall sub_10005670(_DWORD *this);
int __thiscall sub_10005690(int *this);
int __thiscall sub_100056A0(void *this);
u_long __thiscall sub_100056B0(u_long netlong);
int __thiscall sub_100056C0(void *this);
int sub_100056D1();
_DWORD *__thiscall sub_100056E0(_DWORD *this);
int __thiscall sub_10005700(int *this);
char __thiscall sub_10005750(_DWORD *this, int a2, int a3);
void __thiscall sub_100057B0(_DWORD *this, int a2);
char __thiscall sub_100057F0(int *this);
_DWORD *__thiscall sub_10005850(_DWORD *this, _DWORD *a2);
char __thiscall sub_100058A0(int *this, int a2);
char __thiscall sub_10005980(int *this, int *a2);
char __thiscall sub_10005BD0(int *this, int a2);
_BOOL1 __thiscall sub_10005DA0(int *this, _DWORD *a2);
char __thiscall sub_10005E60(int *this, int a2, int a3);
char __thiscall sub_10006000(int *this, int a2);
int __thiscall sub_10006100(_DWORD *this, int a2, int a3);
int __thiscall sub_100061C0(_DWORD *this, int a2, int a3);
u_long *__thiscall sub_10006280(u_long *this, _BYTE *a2, u_long a3);
u_long *__thiscall sub_10006300(u_long *this, void *src);
char *__thiscall sub_10006410(_DWORD *this, char *a2);
char *__thiscall sub_10006450(_DWORD *this, char *a2);
char *__fastcall sub_10006490(char *a1, unsigned int a2);
__int32 __fastcall sub_100064D0(char *a1, const char **a2);
_BYTE *__thiscall sub_100065C0(_DWORD *this);
int __fastcall sub_100065F0(int a1, int a2, unsigned int a3);
_BOOL1 __thiscall sub_10006880(int *this, int a2, int a3);
int __thiscall sub_10006A60(_DWORD *this, void *a2, signed int a3);
signed int __thiscall sub_10006AA0(_DWORD *this, void *a2, signed int a3, int a4);
int __thiscall sub_10006C10(char *this, _DWORD *a2);
int __thiscall sub_10006C80(_DWORD *this, _DWORD *a2);
int __thiscall sub_10006CD0(int *this);
char __thiscall sub_10006CF0(int *this, _DWORD *a2);
_DWORD *__thiscall sub_10006DA0(_DWORD *this);
char __thiscall sub_10006DC0(_BYTE *this);
int *__thiscall sub_10006DF0(int *this, int a2);
int __thiscall sub_10006FB0(int *this);
char __thiscall sub_10007060(_DWORD *this);
int __thiscall sub_10007160(_DWORD *this, void *a2, signed int a3, _DWORD *a4);
signed int __thiscall sub_10007240(int *this, void *a2, signed int a3, int *a4, int a5);
void *__thiscall sub_10007470(void *this);
int sub_100074E0();
void sub_10007540(void); // idb
int __thiscall sub_10007550(int this);
int __thiscall sub_100075A0(int this);
char __thiscall sub_10007650(int this, _DWORD *a2);
int __thiscall sub_100076D0(_DWORD *this, _DWORD *a2, char a3);
char __thiscall sub_10007740(_DWORD *this, _DWORD *a2);
char __thiscall sub_100077B0(_DWORD *this, char a2);
char __thiscall sub_10008030(_DWORD *this, int a2);
char __thiscall sub_100080F0(int *this, int a2);
int __thiscall sub_10008170(int this);
int __thiscall sub_10008190(int *this, int a2);
void *sub_1000821E();
int sub_10008230();
int sub_100082E0();
long double sub_10008340();
long double sub_100083C0();
__int64 sub_10008440();
__int64 __thiscall sub_100084C0(_DWORD *this, double a2);
int __thiscall sub_10008500(_DWORD *this);
_BOOL1 __thiscall sub_10008570(_DWORD *this, int a2);
char *__thiscall sub_100085E0(_DWORD *this, int a2);
int __thiscall sub_10008660(_DWORD *this);
int __thiscall sub_100086D0(_DWORD *this, int a2);
long double __thiscall sub_100086E0(unsigned int *this);
// void *__thiscall unknown_libname_56(void *this, int a2);
// _DWORD *__userpurge sub_10008800@<eax>(void **a1@<ecx>, int a2@<ebx>, int a3);
char __thiscall ContinuumEncrypt(void *this, int a2, int a3, unsigned int a4);
unsigned int __thiscall ContinuumDecrypt(void *this, int a2, int a3, unsigned int a4);
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2);
size_t __thiscall sub_1000A060(void *this, char *a2, _BYTE *a3, size_t a4);
size_t __thiscall sub_1000A150(void *this, void *a2, int *a3, size_t a4);
char __thiscall sub_1000A270(_DWORD *this, const char *a2);
bool __thiscall sub_1000A300(int this, int a2);
_DWORD *__thiscall sub_1000A370(_DWORD *this);
_DWORD *__thiscall sub_1000A420(_DWORD *this);
int __thiscall sub_1000A440(_DWORD *this);
int __thiscall sub_1000A470(void *this, LPCSTR lpFileName);
char __thiscall sub_1000A860(unsigned __int16 *this, int a2, int a3, int a4, int a5);
void *__thiscall sub_1000A9F0(void *this, unsigned __int8 *a2, unsigned int a3, int a4, void *a5);
int __thiscall sub_1000AA50(_DWORD *this, _WORD *a2, unsigned int a3, int a4);
char __thiscall sub_1000AAA0(_DWORD *this, int *a2, int a3, int a4);
char __thiscall sub_1000AD20(_DWORD *this, const char *a2, _DWORD *a3, _DWORD *a4);
unsigned int __thiscall sub_1000AEA0(char *this);
unsigned int __thiscall sub_1000B3B0(_DWORD *this, int a2, int a3);
char *__thiscall sub_1000B400(char *this, char a2, void *src, char a4);
char __thiscall sub_1000B5B0(char *this, char *a2, char *a3, const char *a4);
int __thiscall sub_1000B6E0(_DWORD *this, char *a2, char a3);
int __thiscall sub_1000B780(char **this);
int sub_1000B7B0();
int sub_1000B7D0(void);
int sub_1000B7F0();
void sub_1000B810(void); // idb
_DWORD *__thiscall sub_1000B8B0(_DWORD *this);
int __stdcall sub_1000B8D0(PLAYER *src);
int __stdcall sub_1000B9A0(char *msg, char msg_type);
LPCSTR __stdcall sub_1000B9F0(int a1, int a2, int a3);
int sub_1000BA20();
char __stdcall sub_1000BA30(char *a1, _DWORD *a2, _DWORD *a3, int a4);
int __stdcall sub_1000BAB0(char *a1, int a2, int a3);
int sub_1000BB60();
int sub_1000BB70();
void __thiscall sub_1000BB80(struct BILLING_SERVER_STRUCT *this, int a2, const char *a3);
int __thiscall WriteDataProxyRemoveLater(struct CONNECTION *this, void *buf, int buf_sz, BOOL bReliable);
_DWORD __stdcall sub_1000BBC0(char *buf, _DWORD len); // weak
void __thiscall sub_1000BBE0(struct CONNECTION *this, char *a2, int a3, int a4);
// void __usercall sub_1000BC00(int a1@<ecx>, int a2@<edi>);
void __thiscall biller_player_login(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr); // idb
int __thiscall sub_1000BD10(struct struc_2 *this, char *lpszSection, char *lpszKey, int DefaultVal);
int __thiscall sub_1000BD30(PLAYER *this, void *buf, int buf_sz, BOOL bSendReliable);
void __thiscall sub_1000BD50(struct PLAYER *this, signed int ship);
void __thiscall sub_1000BD90(int this, signed int a2);
void __thiscall sub_1000BDC0(PLAYER *this);
int __thiscall sub_1000BDE0(int *this, char *filename);
void __thiscall sub_1000BE30(struct PLAYER *this, char *msg, char msg_type);
void __thiscall sub_1000BE50(PLAYER *this, char *reason, char something);
int __thiscall sub_1000BE70(PLAYER *this, void *src, void *buf, char buf_sz);
void __thiscall sub_1000BEF0(PLAYER *this, BYTE *pkt, DWORD pkt_sz);
void __thiscall sub_1000BF10(struct PLAYER *this, int a2);
int __thiscall sub_1000BF30(PLAYER *this, void *buf);
void __thiscall sub_1000BF90(int this, int a2);
void __thiscall sub_1000C000(void *this, char *reason);
char __thiscall sub_1000C0B0(int this, int a2);
char __thiscall sub_1000C130(int this, int a2);
char *__thiscall sub_1000C1B0(PLAYER *this, char a2);
char __fastcall find_player_request(PLAYER *requester, char *target_name);
int __thiscall sub_1000C400(char *this, int a2, void *a3);
int __thiscall sub_1000C480(int this);
int __thiscall sub_1000CF20(char *this, void *a2, unsigned __int8 a3, _DWORD *a4);
char *__thiscall sub_1000D0B0(char *this, int a2);
int __thiscall sub_1000D110(char *this);
int __thiscall sub_1000D170(_DWORD *this);
int __thiscall sub_1000D470(int this);
char __thiscall sub_1000D490(char *this, int a2);
char __thiscall sub_1000D590(char *this, int a2);
int sub_1000D660();
char *__thiscall sub_1000D680(char *this, int a2);
int sub_1000D770(void);
int sub_1000D7F0();
// void unknown_libname_57(void); idb
int sub_1000D820();
// void unknown_libname_58(void); idb
int sub_1000D850();
// void unknown_libname_59(void); idb
int sub_1000D880();
char *__thiscall sub_1000D8A0(char *this, int a2);
void sub_1000DA00(void); // idb
int __thiscall sub_1000DAB0(int this);
char __fastcall sub_1000DBE0(PLAYER *a1, const char *a2);
int __stdcall fix_export_0(char *player, int *requester, s2c_sendto *buf, PLAYER *buf_sz);
int __thiscall sub_10010460(int *this, int a2, int a3);
void __thiscall sub_10010490(int *this, struct PLAYER *a2, double a3, char *msg);
_DWORD *__thiscall sub_10010510(_DWORD *this);
void __thiscall sub_10010530(_DWORD *this, unsigned int a2);
void __thiscall sub_100106E0(_DWORD *this, char a2);
int __thiscall sub_10010810(_DWORD *this, int a2);
_BOOL1 __fastcall sub_10010840(_BYTE *a1);
_BOOL1 __thiscall sub_10010860(_DWORD *this);
void __thiscall sub_100108A0(struct PLAYER *this);
bool __thiscall sub_100108F0(_DWORD *this);
void __thiscall sub_10010970(struct PLAYER *this);
void __thiscall sub_100109B0(struct PLAYER *this);
char __thiscall sub_10010A10(unsigned __int8 *this);
const char *__thiscall sub_10010A70(_DWORD *this);
void __thiscall fix_04(int this, int player, DWORD pkt_sz);
_DWORD *__thiscall sub_100122C0(_BYTE *this);
unsigned int __thiscall sub_10012520(int this);
unsigned int __thiscall sub_100125F0(char *FileName);
void __cdecl loc_10012729();
int __thiscall sub_10012730(void *this);
PLAYER *__thiscall CtmPlayerJustConnected(PLAYER *p);
void __thiscall sub_10012C40(int this, PLAYER *player);
int __thiscall sub_10012DA0(void *this);
int __stdcall sub_10012E80(void *memory);
int __thiscall Fix_44(PLAYER *p, ARENA *arena);
int __thiscall Fix_10(PLAYER *this);
int __thiscall sub_10013250(int this);
void __thiscall sub_100137F0(int this);
// void __userpurge sub_10013980(int a1@<ecx>, int a2@<edi>, unsigned __int8 *buf, unsigned int buf_sz, int a5);
int __thiscall Fix_PlayerInit(int this);
int __cdecl sub_10013B10();
void __cdecl BillingServerRecievedPacket(PLAYER *player, int classptr);
int __stdcall fix_1c(SOCKET Sockett, char *pkt, int a3, int flags, struct sockaddr *from, int *fromlen); // idb
int __fastcall sub_10014C30(unsigned int a1, int a2);
int __stdcall sub_10014CC0(int a1, struct struc_2 *a2);
size_t __stdcall sub_100150F0(int a1, _BYTE *a2, size_t a3, char *a4);
size_t __stdcall sub_10015120(int a1, void *a2, size_t a3);
int __stdcall fix_PacketHandler(int a1, int len);
int __cdecl sub_100151C0(va_list ap, int a2);
int sub_10015390();
int sub_10015450();
_DWORD __stdcall sub_10015510(_DWORD, char *buf); // weak
int __stdcall sub_10015590(int a1, int a2, int a3);
_DWORD *__thiscall sub_10015610(_DWORD *this);
int __thiscall sub_10015620(int this);
int __thiscall sub_10015680(int this);
_DWORD *__thiscall sub_100156A0(_DWORD *this, int a2);
int __thiscall sub_100157A0(int this, int a2);
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD); // weak
u_long __stdcall ntohl_0(u_long netlong); // idb
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_006F(_DWORD);
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0006(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000D(_DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0001(_DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0013(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0010(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0034(_DWORD); // weak
unsigned __int32 __stdcall inet_addr_0(const char *cp); // idb
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0033(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0097(_DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0014();
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0011(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD); // weak
char *__cdecl strncpy_0(char *, const char *, size_t);
void __stdcall _JumpToContinuation(void *, struct EHRegistrationNode *); // idb
// _DWORD __cdecl sub_10015B59(_DWORD, _DWORD); weak
// _DWORD __cdecl sub_10015B60(_DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_60(_DWORD, _DWORD); weak
// int __usercall __CxxFrameHandler_0@<eax>(struct _s_FuncInfo *a1@<eax>, void *a2@<ecx>, int a3@<ebx>, EXCEPTION_RECORD *a4, struct EHRegistrationNode *a5, struct _CONTEXT *a6, void *a7);
void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *, const struct _s_FuncInfo *, void *, int, unsigned __int32); // idb
// int __usercall CatchGuardHandler@<eax>(void *a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5);
// _DWORD __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, _DWORD, struct EHRegistrationNode *); weak
// int __usercall TranslatorGuardHandler@<eax>(void *a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a5);
const struct _s_TryBlockMapEntry *__thiscall _GetRangeOfTrysToCheck(void *this, const struct _s_FuncInfo *a2, int a3, int a4, unsigned int *a5, unsigned int *a6);
int __cdecl _global_unwind2_0(PVOID TargetFrame); // idb
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4);
int __cdecl _local_unwind2_0(int a1, int a2);
int __cdecl _abnormal_termination_0();
// int __userpurge sub_10015EF1@<eax>(int result@<eax>, int a2@<ecx>, int a3@<ebp>, int a4);
void _cinit_0();
void __cdecl sub_10015F3F(UINT a1);
void __cdecl sub_10015F50(UINT a1);
void __cdecl doexit_0(UINT uExitCode, int a2, int a3);
void __cdecl sub_10016018(void (**a1)(void), unsigned int a2);
int __cdecl atol_0(const char *String);
__int32 __stdcall atol_1(const char *); // idb
char *__cdecl strchr_0(const char *Str, int Val);
int __cdecl vsprintf_0(char *, const char *, va_list);
int __cdecl sub_100163DD(int a1);
int (*__cdecl sub_100163ED(int (*a1)()))();
int __cdecl sub_100163FD(int a1);
int (*__cdecl sub_1001640D(int (*a1)()))();
char *__thiscall sub_100164A4(char *this);
_DWORD *__thiscall sub_100164A8(_DWORD *this, int a2);
void *__thiscall sub_100164B3(void *this, int a2);
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
void *__cdecl memcpy_0(void *, const void *, size_t); // idb
int __cdecl toupper_0(int);
int __cdecl tolower_0(int);
// void *__cdecl memchr(const void *, int, size_t); idb
int sprintf_0(char *, const char *, ...);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list); idb
// int __cdecl atexit(void (*)(void)); idb
// void __cdecl _assert(void *, void *, unsigned int); idb
int __cdecl sub_10016FAF(int a1, int a2);
unsigned int sub_10016FF7();
void *_cfltcvt_init_0();
// double __usercall _ftol_0@<st0>(double@<st0>); weak
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *), void (__thiscall *)(void *)); weak
// void __usercall sub_10017122(int a1@<ebp>);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *)); weak
// void __stdcall __ArrayUnwind(void *, unsigned int, _DWORD, void (__thiscall *)(void *)); weak
int __cdecl isalpha_0(int);
void sub_100172AC();
// int __cdecl isalnum(int); idb
char *__cdecl strrchr_0(const char *, int);
int sub_100174D1();
time_t __cdecl time_0(time_t *);
// _DWORD __stdcall _CRT_INIT(_DWORD, _DWORD, _DWORD); weak
int __stdcall FIX_DLL_start(int a1, int a2, int a3);
void __cdecl _amsg_exit_0(int rterrnum);
// int __usercall __InternalCxxFrameHandler_0@<eax>(void *a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6, struct _s_FuncInfo *a7, int a8, PVOID TargetFrame, unsigned __int8 a10);
// void __usercall FindHandler(const struct _s_FuncInfo *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a6, struct _CONTEXT *a7, void *a8, const struct _s_FuncInfo *a9, char a10, int a11, PVOID TargetFrame);
unsigned int __thiscall FindHandlerForForeignException(void *this, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a3, struct _CONTEXT *a4, void *a5, const struct _s_FuncInfo *a6, int a7, int a8, PVOID TargetFrame);
// _DWORD __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *); weak
unsigned int __thiscall sub_10017A9A(void *this, int a2, int a3, int a4, int a5);
// void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8); weak
void *__cdecl sub_10017BC9(_DWORD *a1, struct EHRegistrationNode *a2, int a3, const struct _s_FuncInfo *a4, void *a5, int a6, unsigned __int32 a7);
// int __usercall sub_10017C8F@<eax>(int a1@<ebx>, int a2@<ebp>, _DWORD *a3@<edi>, int a4@<esi>);
// void __usercall BuildCatchObject(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5);
// _DWORD __cdecl unknown_libname_64(_DWORD); weak
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2);
// _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD); weak
// void __usercall sub_10017F9C(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// void __usercall sub_10018002(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
int __cdecl _isctype_0(int, int);
int __cdecl _flsbuf_0(int, FILE *);
int __cdecl _output_0(FILE *File, int, int); // idb
int __cdecl write_char_0(int, FILE *File, int); // idb
int __cdecl write_multi_char_0(int a1, int a2, FILE *a3, _DWORD *a4);
int __cdecl write_string_0(int, int, FILE *File, int); // idb
int __cdecl sub_100189C1(_DWORD *a1);
__int64 __cdecl sub_100189CE(_DWORD *a1);
__int16 __cdecl sub_100189DE(_DWORD *a1);
void __cdecl sub_100189EC(unsigned int a1);
// int __cdecl strcmp(const char *, const char *); idb
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int); // idb
_BYTE *__cdecl strncnt_0(_BYTE *a1, _BYTE *a2);
_DWORD *__cdecl sub_10018D97(unsigned int a1, _DWORD *a2);
int __cdecl sub_10019037(unsigned int a1);
_DWORD *__cdecl sub_10019098(size_t a1);
_DWORD *__cdecl _nh_malloc_0(size_t Size, int a2);
_DWORD *__cdecl sub_100190D6(unsigned int a1);
int __cdecl fflush_0(FILE *);
int __cdecl _flush_0(_DWORD *a1);
int __cdecl flsall_0(int a1);
int fprintf_0(FILE *, const char *, ...);
int __cdecl raise_0(int);
_DWORD *__cdecl siglookup_0(int a1);
int __crtMessageBoxA_0();
// size_t __cdecl strlen(const char *); idb
// char *__cdecl strcpy(char *, const char *); idb
// char *__cdecl strcat(char *, const char *); idb
int __cdecl _stbuf_0(int a1);
int __cdecl _ftbuf_0(int a1, int a2);
// int *__usercall _FF_MSGBANNER_0@<eax>(int a1@<esi>);
// int *__usercall _NMSG_WRITE_0@<eax>(int a1@<esi>, DWORD NumberOfBytesWritten);
unsigned int sub_10019CC7();
int __cdecl _ms_p5_mp_test_fdiv_0();
int __cdecl __loctotime_t_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1001A31E(int a1);
int sub_1001A34B();
int __cdecl sub_1001A493(int a1);
// int __usercall sub_1001A4F0@<eax>(int a1@<ebx>, int a2@<ebp>);
int _ioinit_0();
void _setenvp_0();
int _setargv_0();
_DWORD *__cdecl parse_cmdline_0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5);
_DWORD *__crtGetEnvironmentStringsA_0();
bool __cdecl sub_1001AB9E(int a1, int a2);
bool __cdecl sub_1001ABBA(int a1, int a2);
bool __cdecl sub_1001ABD6(int a1);
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); // idb
int __cdecl _lseek_0(int, int, int);
int __cdecl _write_0(int, const void *, unsigned int);
int __cdecl _getbuf_0(_DWORD *a1);
int __cdecl _isatty_0(int);
int __cdecl wctomb_0(char *, wchar_t);
// int __cdecl __sbh_heap_init(_DWORD); weak
unsigned int __cdecl __sbh_find_block_0(int a1);
_DWORD *__cdecl sub_1001B27A(_DWORD *a1, int a2);
_DWORD *__cdecl __sbh_alloc_block_0(int a1);
// int __sbh_alloc_new_region(void); weak
// _DWORD __cdecl __sbh_alloc_new_group(_DWORD); weak
int __cdecl __sbh_resize_block_0(_DWORD *a1, int a2, int a3);
void **sub_1001C170();
int __cdecl sub_1001C2B4(void **a1);
void __cdecl sub_1001C30A(int a1);
unsigned int __cdecl sub_1001C3CC(unsigned int a1, void ***a2, unsigned int *a3);
void __cdecl sub_1001C423(int a1, int a2, _BYTE *a3);
int __cdecl sub_1001C468(unsigned int a1);
int __cdecl sub_1001C670(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_1001C794(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4);
bool __cdecl sub_1001C9B1(int a1);
int __cdecl _commit_0(int);
int __cdecl _freebuf_0(_iobuf *stream);
unsigned int __cdecl _control87_0(unsigned int, unsigned int);
unsigned int __cdecl sub_1001D070(unsigned int a1, int a2);
char __cdecl _abstract_cw_0(char a1);
char __cdecl _hw_cw_0(int a1);
int __cdecl _ZeroTail_0(int a1, int a2);
int __cdecl _IncMan_0(int a1, int a2);
int __cdecl _RoundMan_0(int a1, int a2);
// void *__cdecl memset(void *, int, size_t); idb
void sub_1001D888();
void sub_1001D891();
void __cdecl _tzset_0();
// _DWORD __cdecl _isindst(_DWORD); weak
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// __int32 __cdecl strtol(const char *, char **, int); idb
char *__cdecl strstr_0(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t); idb
int __cdecl _setmbcp_0(int);
int __cdecl getSystemCP_0(int a1);
int __cdecl CPtoLCID_0(int a1);
int setSBCS_0();
// int setSBUpLow(void); weak
int sub_1001E4BC();
_DWORD *__cdecl _dosmaperr_0(unsigned int a1);
int _alloc_osfhnd_0();
// int __usercall _set_osfhnd_0@<eax>(int a1@<ebx>, int a2, HANDLE hHandle);
int __cdecl _free_osfhnd_0(int a1);
int __cdecl _get_osfhandle_0(int);
int __cdecl fclose_0(FILE *);
int __cdecl __addl_0(unsigned int a1, unsigned int a2, unsigned int *a3);
int __cdecl __add_12_0(unsigned int *a1, unsigned int *a2);
_DWORD *__cdecl __shl_12_0(_DWORD *a1);
int *__cdecl __shr_12_0(int *a1);
__int16 __cdecl __mtold12_0(char *a1, int a2, int a3);
int __cdecl __strgtold12_0(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl _I10_OUTPUT_0(__int128 a1, char a2, int a3);
char *__cdecl getenv_0(const char *);
int __cdecl _close_0(int);
int __cdecl __ld12mul_0(int a1, int a2);
void __cdecl __multtenpow12_0(_WORD *a1, int a2, int a3);
int __cdecl _mbsnbicoll_0(const unsigned __int8 *, const unsigned __int8 *, size_t);
int __wtomb_environ_0();
int __cdecl __crtCompareStringA_0(int a1, int a2, unsigned __int8 *a3, _BYTE *a4, unsigned __int8 *a5, int a6, int a7);
_BYTE *__cdecl sub_1001F82C(_BYTE *a1, _BYTE *a2);
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int); // idb
int __cdecl findenv_0(unsigned __int8 *a1, size_t a2);
_DWORD *__cdecl copy_environ_0(_DWORD *a1);
unsigned __int8 *__cdecl _mbschr_0(const unsigned __int8 *, unsigned int);
char *__cdecl _strdup_0(const char *);
int __cdecl j_FIX_DLL_KERNEL32_dll_RtlUnwind();
unsigned int __cdecl _memicmp_0(const void *a1, const void *a2, unsigned int a3);
// _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD); weak
// int __usercall SEH_10008190@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6);
// int __usercall SEH_1000C480@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6);
// int __usercall SEH_1000D170@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6);
// int __usercall SEH_100125F0@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6);
// int __usercall fix_1c_SEH@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6);
DWORD __stdcall GetPrivateProfileStringA_0(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName); // idb
int __stdcall recvfrom_0(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); // idb

//-------------------------------------------------------------------------
// Data declarations

int dword_400000[1024] =
{
  9460301,
  3,
  4,
  65535,
  184,
  0,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  247078670,
  -855002112,
  1275181089,
  1750344141,
  1881174889,
  1919381362,
  1663069537,
  1869508193,
  1700929652,
  1853190688,
  544106784,
  542330692,
  1701080941,
  168627502,
  36,
  0,
  17744,
  262476,
  894409439,
  0,
  0,
  17760480,
  327947,
  165376,
  726528,
  0,
  130544,
  4096,
  172032,
  4194304,
  4096,
  512,
  4,
  0,
  4,
  0,
  905216,
  1024,
  0,
  3,
  1048576,
  4096,
  1048576,
  4096,
  0,
  16,
  0,
  0,
  901120,
  120,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  901632,
  392,
  0,
  0,
  0,
  0,
  0,
  0,
  2019914798,
  116,
  165045,
  4096,
  165376,
  1024,
  0,
  0,
  0,
  1610612768,
  1633972782,
  24948,
  1872,
  172032,
  2048,
  166400,
  0,
  0,
  0,
  1073741888,
  1952539694,
  97,
  721868,
  176128,
  30720,
  168448,
  0,
  0,
  0,
  -1073741760,
  1633970478,
  24948,
  2318,
  901120,
  2560,
  199168,
  0,
  0,
  0,
  -1073741760,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18934913,
  1431502848,
  1474923350,
  874822795,
  855638017,
  -1328781093,
  -1651965886,
  119818,
  2530697,
  -1990787071,
  16724125,
  2110711808,
  -998047742,
  1975551240,
  -1329283288,
  -914161598,
  -139529473,
  -1913050159,
  16449685,
  -1950250240,
  -1040544777,
  -1510800663,
  -511457141,
  -341511421,
  11898133,
  1778385147,
  -396994784,
  118336,
  -2012429181,
  490282846,
  5068976,
  -1657270402,
  64256,
  28837748,
  -352321536,
  -1950338302,
  1304564789,
  579176704,
  -1996488448,
  21402269,
  -1768060672,
  -16776890,
  -1194816554,
  -858993459,
  -356392457,
  -1902802685,
  -1996488378,
  16713885,
  714967296,
  -1996488448,
  16789149,
  849185024,
  -1996488448,
  16791197,
  580729088,
  251658496,
  51844,
  12422400,
  -2097151749,
  -1070334007,
  270816397,
  -772296974,
  -1066862293,
  -1962917200,
  -1946711103,
  609521146,
  48873748,
  -930372109,
  -511459277,
  -1079708925,
  4370616,
  -218117757,
  735180718,
  -1946711047,
  -2083419142,
  -1359806519,
  -1051735413,
  -1510800663,
  1150143115,
  -511503324,
  -1527558141,
  30230504,
  -2081387776,
  -214234940,
  -396994700,
  162968,
  1342489731,
  32243688,
  -1194816768,
  954437177,
  -356392457,
  -1835693822,
  -2097151674,
  344786116,
  1793249746,
  -397192703,
  29212,
  -1995651965,
  21403269,
  -1836217600,
  1442840902,
  1343384145,
  30114792,
  281314048,
  -889526186,
  -998047743,
  339053316,
  -1929359934,
  -1188027308,
  16064,
  -41172941,
  65640,
  -1410117120,
  202768211,
  -1929359934,
  1781539908,
  -1712828324,
  -2097151542,
  -1019541308,
  411567220,
  1552418027,
  -2054475740,
  65570,
  -2054307013,
  110830,
  14517263,
  -1114832896,
  64256,
  807685261,
  -1402449577,
  1342194352,
  30011368,
  281314048,
  -1309768307,
  1750532097,
  4370596,
  -908400560,
  -998047743,
  -293237492,
  1459618226,
  1118872680,
  -974630912,
  -2097151543,
  -1114829628,
  110830,
  -169322669,
  -2097151450,
  -1065023292,
  703139444,
  1459618119,
  7345128,
  147096320,
  -1292991091,
  -397410303,
  23652,
  -2063285117,
  -1087736384,
  5026360,
  -218117757,
  735180718,
  -1949201415,
  -289567241,
  -1056964175,
  -1510800663,
  -511456629,
  -1952124157,
  1304564789,
  10414336,
  -2097152000,
  -1924135740,
  1746150468,
  4370580,
  -917837744,
  -998047743,
  -293237492,
  -1929379408,
  1343235148,
  -1333499823,
  2087190594,
  -16760144,
  1304563733,
  -1922438400,
  1378886740,
  1118858344,
  434655232,
  -1090518583,
  5026360,
  872401283,
  214205376,
  -772296974,
  -1785857749,
  111086,
  -141835893,
  -1785857397,
  111342,
  -217912895,
  868780965,
  65110976,
  952083699,
  -2097132366,
  -1359806519,
  -114568713,
  -141835893,
  -373163381,
  -1952058622,
  65110984,
  898344179,
  5095956,
  -1326545523,
  -1924136959,
  16449669,
  1080578048,
  -402636112,
  116536,
  -1962097533,
  921626829,
  -846528512,
  3647464,
  446531840,
  -16776960,
  -1194816554,
  -858993459,
  -356392457,
  513116419,
  -16776960,
  -1194292266,
  -858993459,
  -356392201,
  278235395,
  -16776961,
  -1194816554,
  -858993459,
  -356392457,
  345344259,
  -16776961,
  -1194292266,
  -858993459,
  -356392201,
  177048835,
  855638272,
  412453312,
  -1996488449,
  25598621,
  211650816,
  -1996488449,
  16792221,
  1587382528,
  -1996488449,
  16737949,
  -1996388096,
  1099498561,
  205621512,
  -1399945845,
  -1019543551,
  -1499554423,
  -1651965951,
  65390,
  -1657202828,
  109714,
  1307053950,
  -1728052794,
  -1399669257,
  -347996159,
  -1835693306,
  -1996488276,
  16738965,
  -1948844288,
  -858933048,
  -503853876,
  -1996231999,
  16728725,
  -971053056,
  -125108223,
  29759464,
  -122745088,
  -14369399,
  166199296,
  -1962933818,
  -972887816,
  -1357971455,
  683510264,
  -16776961,
  -1194292266,
  -858993459,
  -356392201,
  -1933053,
  -1988100097,
  16725149,
  747997440,
  -1996488449,
  16726173,
  1016957184,
  1711276287,
  -12542583,
  -1651965952,
  65362,
  -10838647,
  -1651965952,
  65366,
  -14639735,
  -687931392,
  -843528053,
  -137573172,
  8751841,
  -956301061,
  16736901,
  256,
  65716480,
  -1786133702,
  65358,
  490278516,
  4427264,
  -1651964299,
  65378,
  2268473,
  108265473,
  -10314359,
  -1115488256,
  109746,
  -1958054654,
  30672517,
  -1634891008,
  989856166,
  859471304,
  -1983693879,
  27696773,
  -1926332928,
  25599621,
  1754303232,
  -1996488659,
  1821412112,
  -1996488659,
  -897383344,
  206604799,
  -1962389367,
  30672533,
  -1065139968,
  2093628176,
  -846507048,
  2768872,
  983402752,
  -16776960,
  -1194816554,
  -858993459,
  -356392457,
  -1946195453,
  1184205261,
  -1996488449,
  16720029,
  1043785728,
  -1956708352,
  1532845765,
  18924673,
  79822848,
  -1869574144,
  -1869574000,
  1394666627,
  1448466827,
  -15957109,
  -315424768,
  -985926093,
  -1922400681,
  16457859,
  -1163183872,
  1962934700,
  581646655,
  1946157312,
  -1961850057,
  89994,
  2093824768,
  -1766094037,
  -1929379514,
  -1031681780,
  547,
  72305805,
  965294731,
  -1996195189,
  2055931001,
  142182664,
  206736230,
  206670182,
  -2092562293,
  1770587328,
  -61830372,
  20464327,
  -1962934272,
  16714891,
  2096184064,
  176393116,
  989856212,
  990999749,
  1302079493,
  1342796800,
  7313384,
  79987456,
  -1275427957,
  -985989119,
  87757172,
  4427260,
  -11531916,
  1122942997,
  965775360,
  21403307,
  -997978368,
  -16777216,
  1304564757,
  -1194816768,
  -858993459,
  -2087984649,
  119826,
  990112449,
  -1902933563,
  251658566,
  36740,
  12291328,
  -2097151749,
  -1070334007,
  270816397,
  -772296974,
  -731317973,
  -1962917200,
  -1946711103,
  609521146,
  48873748,
  -930372109,
  -511459277,
  -1079708925,
  4370616,
  -218117757,
  735180718,
  -1946711047,
  -2083419142,
  -1359806519,
  -1051735413,
  -1510800663,
  1150143115,
  -511503324,
  -1527558141,
  29864936,
  -2081387776,
  -180680508,
  -1953815948,
  83602,
  1184273291,
  1364590593,
  -397274518,
  116916,
  1443939459,
  29727720,
  79987456,
  1184269195,
  -397410303,
  28332,
  1594147971,
  -2091164322,
  -1866260284,
  17886337,
  1431502848,
  1475447638,
  -2036679039,
  67108865,
  -1928396800,
  469,
  -1396275573,
  1284308993,
  -1924132828,
  1360798804,
  472138893,
  613714770,
  308,
  673467533,
  612666192,
  308,
  177113937,
  1375732180,
  -571977392,
  -1962934188,
  -1958992828,
  -2093472692,
  -1053089596,
  1418399861,
  1284183076,
  -784658396,
  25134095,
  -1903493120,
  99994,
  1711595969,
  -1708030839,
  -1962933946,
  25598614,
  1149986304,
  -490662876,
  -2071370236,
  21404722,
  -1701934336,
  1711276422,
  405034123,
  1711595969,
  -1640917879,
  -1962933946,
  25598598,
  1284204032,
  1778716708,
  -1056964588,
  -1989802784,
  -1769263092,
  99994,
  612666214,
  300,
  1711596225,
  -1573747575,
  -1962933946,
  25598606,
  -1769249280,
  65344,
  1711595969,
  -1540254583,
  1711276358,
  -12548353,
  369033216,
  5095956,
  -843528053,
  -137573172,
  -1702458399,
  855638406,
  65716717,
  -2130386751,
  -30,
  815040895,
  83622,
  -2036691317,
  -507445247,
  608486916,
  -1802690272,
  21404209,
  830769920,
  83610,
  556024969,
  -1996207477,
  -1960500148,
  1149831234,
  -2037700316,
  109906,
  -2062792053,
  608995776,
  -1957855699,
  16714886,
  -2049232128,
  -1926529344,
  16457918,
  -1961915648,
  -1065011135,
  6950517,
  606360717,
  -397274774,
  50912,
  -15956341,
  -2092761088,
  -667220793,
  227269500,
  4427256,
  27781096,
  1384549120,
  1157628333,
  -1283659717,
  -15956341,
  -617414656,
  729727109,
  -81740147,
  260767744,
  -2059910773,
  1779332544,
  608472321,
  1343318564,
  13013992,
  210144000,
  1124073727,
  990168963,
  -2392872,
  25598598,
  1566465792,
  281313627,
  -1040187391,
  -1869610996,
  5521592,
  -942217216,
  -1957494783,
  -1400154663,
  5524516,
  579046144,
  1442840832,
  -2081017001,
  -969146417,
  14648335,
  -1153892352,
  109622,
  13862159,
  -1288110080,
  65292,
  13075727,
  -1786052608,
  539,
  -1945119173,
  185,
  1487932811,
  -1070399411,
  66683721,
  620701815,
  1076019341,
  2142583040,
  1946157058,
  957541145,
  162741,
  -351308800,
  2008365320,
  1946157058,
  112645,
  -969211904,
  -1114800268,
  375,
  872401283,
  915638720,
  -234880596,
  735180718,
  -829190663,
  -1962933840,
  -1946711103,
  609521146,
  48873764,
  -930372109,
  -217849469,
  462261156,
  1358954498,
  1118868584,
  300438016,
  -1962933822,
  1304563773,
  214205184,
  -1326533747,
  1150091265,
  1347822628,
  1118902376,
  -1334024192,
  -671154110,
  24610189,
  1347813376,
  1118900328,
  -1334024192,
  -671154110,
  872402819,
  595955190,
  -1929379838,
  150925,
  608471296,
  -1995404516,
  72387345,
  -1962651255,
  1367935056,
  1725051656,
  1712078987,
  -1962131063,
  16714891,
  -595227392,
  -1996488704,
  -81753172,
  -1953824768,
  65292,
  210471233,
  -1996488449,
  277421149,
  -1996205943,
  1351157840,
  273713420,
  340822374,
  -326776986,
  268435456,
  -1263171289,
  -1996488704,
  73653,
  599099648,
  -1996488703,
  75701,
  1673365760,
  -1962934270,
  28074635,
  -1064466176,
  -1996488704,
  201141,
  -726300416,
  -1996488704,
  55477,
  1606256896,
  -1962934271,
  16786051,
  264649472,
  52868,
  465406720,
  989855746,
  -1064562690,
  -1962934272,
  21402243,
  -1768715520,
  855638342,
  -2050323466,
  957120192,
  -2096597959,
  994448065,
  1005878512,
  1078425072,
  16777320,
  -1836873472,
  -1929379514,
  -523124732,
  1978159696,
  -1929379736,
  -2088110580,
  83606,
  35362187,
  -998047744,
  -1981689588,
  -1819606764,
  83606,
  1284358195,
  25756689,
  -1996209783,
  -1989801919,
  -1249309631,
  351,
  1184269195,
  344784897,
  1346670070,
  609520388,
  -1949791460,
  -1959622351,
  1921582193,
  141658884,
  856191625,
  1233872630,
  1250518540,
  -1928819956,
  143765,
  831359232,
  -1962934270,
  1250493512,
  138971908,
  1711819401,
  1712078987,
  957104777,
  28097203,
  -2054287616,
  -1962934272,
  857482364,
  -2054592832,
  549,
  36275593,
  -1989804032,
  763726087,
  1711276034,
  36144521,
  -1249181696,
  539,
  1484582971,
  3838859,
  -801439743,
  -1953679234,
  65598,
  175386937,
  314671936
}; // idb
_UNKNOWN loc_403507; // weak
void nullsub_1; // idb
const char aCom[] = "COM"; // idb
_UNKNOWN loc_42A127; // weak
_UNKNOWN unk_42A140; // weak
char aServer_cfg[11] = "server.cfg"; // weak
int dword_42B534 = 1; // weak
char aDisconnectedYo[109] = "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version."; // weak
char aWarningYouHave[89] = "WARNING: You have been disconnected because server has not been receiving data from you."; // weak
char aWarningYouHa_0[68] = "WARNING: You have been disconnected for too many ship type changes."; // weak
int dword_42D860 = 1; // weak
void *off_42EA3C = &unk_444150; // weak
const CHAR lpfnFixFunctionArray_lpfnFixExport0 = '\x90'; // idb
int (__stdcall *lpfnFixExport1)(_DWORD, _DWORD) = &fix_04; // weak
char lpfnFixExport2[] = { '\x10', ';', '\x01', '\x10' }; // idb
int (*lpfnFixExport3[3])() = { &CtmPlayerJustConnected, &Fix_10, &Fix_PlayerInit }; // weak
int (*lpfnFixExport5)() = &Fix_PlayerInit; // weak
int lpfnFixExport6 = 268516928; // idb
int (__stdcall *lpfnFixExport8)(int, int, int, int) = &sub_100150F0; // weak
int (__stdcall *lpfnFixExport9)(_DWORD, _DWORD, _DWORD) = &sub_10015120; // weak
int (__thiscall *lpfnFixExport11)(_DWORD, _DWORD, _DWORD) = &fix_PacketHandler; // weak
int (__stdcall *lpfnFixExport12)(_DWORD, _DWORD) = &sub_10014CC0; // weak
int (__stdcall *lpfnFixExport13)(_DWORD) = &sub_10012E80; // weak
int (__thiscall *lpfnFixExport14)(_DWORD, _DWORD) = &sub_10012C40; // weak
int (*lpfnFixExport15)(void) = &sub_100151C0; // weak
int (*lpfnFixExport18)(void) = &sub_10015390; // weak
int (__thiscall *DLL_FILE_SERVER_MAIN_LOOP_HOOK_SERVER_PACKET_ATTACHMENT_PARAM)(_DWORD) = &sub_10015450; // weak
int (__thiscall *lpfnFixExport20)(_DWORD, _DWORD, _DWORD, _DWORD) = &sub_10013980; // weak
int rand_seed = 1; // weak
_UNKNOWN unk_42F788; // weak
int (*off_42FA24)(void) = &sub_422060; // weak
int dword_431C8C = 1; // weak
int dword_431D20 = -1; // weak
int dword_431D24 = 0; // weak
int dword_431D28 = 0; // weak
int dword_431D30 = -1; // weak
int dword_431D34 = 0; // weak
int dword_431D38 = 0; // weak
_UNKNOWN unk_432150; // weak
_UNKNOWN unk_432168; // weak
int dword_432780 = -1; // weak
HANDLE hConsoleHandle = (HANDLE)0xFFFFFFFE; // idb
CHAR Default = '\0'; // idb
int dwAdvertise_SendMode = 0; // weak
char lpszDirectory_IP[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
CHAR Filename[256]; // idb
void *dword_432AA8; // idb
int dword_432AAC[255]; // idb
_UNKNOWN unk_432EA8; // weak
_UNKNOWN unk_432EB0; // weak
int dwMisc_DisableSharewareShips; // weak
int dwDirectory_Port; // idb
int dword_432ED8; // weak
void *buf; // idb
int buf_sz[170]; // idb
struct BILLING_SERVER_STRUCT *BillingConnectionStructPointer; // idb
int ArenaArrayLength; // idb
int dword_4332E8; // weak
int dwArena_ArenaMinimumPlayers; // weak
_UNKNOWN unk_4332F0; // weak
int bRecycleServer; // weak
char byte_4332F8; // idb
LPCSTR ServerPacketAttachment; // idb
int dword_438DFC; // idb
int bArena_SpawnKeepScore; // weak
int dwPermission_AllowBadMachineID; // weak
CHAR aServerIni; // idb
int dword_438F08; // weak
int dwBilling_AttemptTime; // weak
char DirectoryNamePassword[]; // idb
int dwComms_MaxQueueToLogIn; // weak
int dword_438F94; // weak
int bServerIsRunning; // weak
void *dword_438FA0; // idb
int dword_438FA4[255]; // idb
int dwArena_ArenaMaxPlayers; // weak
char dwComms_PacketHistoryMax; // idb
char lpszPassword_SupermoderatorPassword[]; // idb
char lpszPassword_ModeratorPassword[]; // idb
int dwMisc_MaxSharewarePlayers; // weak
_UNKNOWN unk_439430; // weak
int MachineIdArrayCount; // weak
char lpsz_Billing_Password[]; // idb
int dword_4399E8; // weak
int TotalSentForEachPacketType[256]; // idb
int dwBilling_Port; // weak
void *memory; // idb
int dwMisc_LogPoints; // weak
int ObscenePointer; // idb
int dword_439E00; // weak
int dwCPU_SlowIterationWarningLevel; // weak
int dwArena_MaxArenasMemory; // weak
int dwPermission_PermissionMode; // weak
int CommsEncryptMode; // weak
int ModeratePointer; // idb
char lpszPassword_VIPPassword[]; // idb
int PermitPointer; // idb
struct BMP_FILE_STRUCT *BMPFile; // idb
int MiscMaxPlayers; // weak
int dwBilling_ReconnectTime; // weak
int dwPermission_MininumSecondsToLogin; // weak
char dword_439E70[32]; // idb
char byte_439E90; // idb
int dword_439EB8; // weak
int dword_439EBC; // weak
char byte_439EC0; // idb
char byte_439FC0[]; // weak
char byte_439FC1[41359]; // idb
char lpszPassword_EnergyPassword[]; // idb
int dwPermission_PermissionMaxPoints; // weak
struct CONNECTION *encryption; // idb
int dwBilling_GroupID; // idb
int dwBilling_ServerID; // idb
int dword_4AD738[]; // weak
int dword_4AD73C[]; // weak
int dword_4AD740[]; // weak
_UNKNOWN unk_4AD744; // weak
int MiscKeepAliveDelay; // weak
int dword_4B061C; // weak
CHAR szSysopPassword[60]; // idb
DWORD ZonePlayerCountt; // idb
DWORD CPUSleepTime; // idb
int TotalSentSizeForEachPacketType[256]; // idb
char DirectoryDescription[]; // idb
CHAR lpszIP_Billing; // idb
int dword_4B0BE8; // weak
int dword_4B0BEC; // weak
char byte_4B0C01[103975]; // idb
int dword_4CA228; // weak
int dword_4CA22C; // weak
int ZonePlayers[]; // weak
_UNKNOWN unk_4CA234; // weak
int dwCPU_SleepPerIteration; // weak
CHAR aMisc_DefaultLevelFile; // idb
CHAR FileName[1216]; // idb
char lpszPermission_AutoPermissionMessage[]; // idb
int ServerListenPort; // idb
int dwMisc_PointUpdateDiff; // weak
char lpszPermission_AutoPermissionIDList[]; // idb
int dwBilling_LogMessages; // weak
int dword_4CBB04; // weak
int dword_4CBB08[]; // weak
int dword_4CBB0C[]; // weak
int dword_4CBB10[]; // weak
int dword_4CBB14[]; // weak
int dword_4CBB18[]; // weak
int dword_4CBB1C[]; // weak
int dword_4CBB20[]; // weak
int dword_4CBB24[]; // weak
int dword_4CBB28[999]; // idb
int dword_4CCAC4[]; // weak
int dword_4CCAC8[]; // weak
int dword_4CCAE4; // weak
int CustomArenaMode; // weak
PLAYER *ZonePlayerList; // idb
_UNKNOWN unk_4D6858; // weak
_UNKNOWN unk_4D6870; // weak
int dwMisc_ServerLog; // weak
int dword_4D68C0; // weak
int dwMisc_MaxSharewareTime; // weak
int dwMisc_MenuKickoutDelay; // weak
int ReservedPointer; // idb
int ArenaArray[]; // weak
int dwPermission_AllowLowBandwidth; // weak
int dwCPU_ProcessMaxTime; // weak
int dwArena_MaxArenas; // weak
int dwMisc_JackpotBroadcastPoints; // weak
int dwMisc_RegisterKickShareware; // weak
int NewsTxtFileChecksum; // weak
int dwMisc_DisableShareware; // weak
int dwComms_IncomingBufferSize; // idb
int dword_4D6C10; // weak
_UNKNOWN unk_4D6C14; // weak
int dwArena_ArenaDesiredPlayers; // weak
int dword_4D6C20[]; // weak
int dwAdvertise_Duration; // weak
int dwBilling_ScoreID; // idb
int big_global_buffer; // idb
int dwComms_OutgoingBufferSize; // idb
const CHAR BillingServerName; // idb
WORLD *SeverListenerPortPlusOneSocket; // idb
void *BillerSocket; // idb
int dword_4D9CB8; // weak
CHAR ShutdownSpawnCmdLine[256]; // idb
int IDBlockPointer; // idb
void *dword_4D9DC4; // idb
int dwAdvertise_DisplayMode; // weak
int ZonePlayerCount; // weak
int dwMisc_DisableSharewareScores; // weak
int dword_4D9DD4; // weak
DWORD NewsTxtFileSize; // idb
LPCSTR dwComms_TransportBufferSize; // idb
int dword_4D9DE0; // weak
int dword_4D9DE4; // weak
int dword_4D9DE8; // weak
int dword_4D9DEC; // weak
int dword_4D9DF0; // weak
int dword_4D9DF4; // weak
int pFILE_points_log; // weak
int pFILE_subgame_log; // weak
int dword_4D9E04; // weak
int dword_4D9E08; // weak
int dword_4D9E28; // weak
int dword_4D9E34; // weak
int (*dword_4D9ECC)(void); // weak
int dword_4D9F08; // weak
struct _TIME_ZONE_INFORMATION stru_4D9F10; // idb
// extern void *GetTickCount; idb
_UNKNOWN loc_1000820B; // weak
_UNKNOWN loc_10015EFA; // weak
_UNKNOWN unk_10019D40; // weak
_UNKNOWN unk_10019D9A; // weak
_UNKNOWN unk_10019DE8; // weak
_UNKNOWN unk_10019E00; // weak
_UNKNOWN unk_1001A105; // weak
_UNKNOWN unknown_libname_67; // weak
_UNKNOWN loc_1001C9D0; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD) = (int (__stdcall *)(_DWORD))0x22984; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetLocalTime)(_DWORD) = (int (__cdecl *)(_DWORD))0x22992; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x229B0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x229BC; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_CreateFileA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x229CE; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadReadPtr)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x229DC; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FlushFileBuffers)(_DWORD) = (int (__stdcall *)(_DWORD))0x22A06; // weak
int (*FIX_DLL_KERNEL32_dll_GetLastError)(void) = (int (*)(void))0x22A1A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileSize)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22A2A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22A38; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_DeleteFileA)(_DWORD) = (int (__stdcall *)(_DWORD))0x22A54; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22A82; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileTime)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22A9C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD) = (int (__stdcall *)(_DWORD))0x22AE8; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22AF4; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_Sleep)(_DWORD) = (int (__cdecl *)(_DWORD))0x22B6C; // weak
int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void) = (int (*)(void))0x22BA0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x22BB0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22BBE; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD) = (int (__stdcall *)(_DWORD))0x22BCE; // weak
int (*FIX_DLL_KERNEL32_dll_GetVersion)(void) = (int (*)(void))0x22C48; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD) = (int (__cdecl *)(_DWORD))0x22C56; // weak
int (*FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency)(void) = (int (*)(void))0x22C70; // weak
int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA = 142476; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_WriteProcessMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22CC0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_OpenProcess)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22CD6; // weak
int (*FIX_DLL_KERNEL32_dll_GetCurrentProcessId)(void) = (int (*)(void))0x22CE4; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22CFA; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x23080; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x2306E; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x2305E; // weak
int (*FIX_DLL_KERNEL32_dll_GetOEMCP)(void) = (int (*)(void))0x23052; // weak
int (*FIX_DLL_KERNEL32_dll_GetACP)(void) = (int (*)(void))0x23048; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x2303C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x23010; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeW)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22FFE; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22FEC; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadCodePtr)(_DWORD) = (int (__stdcall *)(_DWORD))0x22FDC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x23092; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadWritePtr)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22FCC; // weak
int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW)(void) = (int (*)(void))0x22FB2; // weak
int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStrings)(void) = (int (*)(void))0x22F9A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW)(_DWORD) = (int (__cdecl *)(_DWORD))0x22F80; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22F66; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetStartupInfoA)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F54; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileType)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F46; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_SetHandleCount)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F34; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x22F26; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapCreate)(_DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD))0x22F18; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD) = (int (__stdcall *)(_DWORD))0x22F0A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetVersionExA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22EFA; // weak
int (*FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA)(void) = (int (*)(void))0x22EE0; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22ECC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetStdHandle)(_DWORD) = (int (__cdecl *)(_DWORD))0x22EBC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LoadLibraryA)(_DWORD) = (int (__cdecl *)(_DWORD))0x22EAC; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetProcAddress)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0x22E9A; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_ExitProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D62; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_TerminateProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D70; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetCurrentProcess)(_DWORD) = (int (__stdcall *)(_DWORD))0x22D84; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_RaiseException)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22D98; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD) = (int (__stdcall *)(_DWORD))0x22DAA; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_GetSystemTime)(_DWORD) = (int (__cdecl *)(_DWORD))0x22DC4; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x22DE6; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E10; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E26; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E3C; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))0x22E4C; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_HeapReAlloc)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))0x22E5C; // weak
int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))0x22E6A; // weak
int (__cdecl *FIX_DLL_KERNEL32_dll_HeapSize)(_DWORD, _DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))0x22E76; // weak
int dword_1002122C[384] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  270598144,
  811802690,
  1353007236,
  1894211782,
  -1859550968,
  -1318346422,
  -777141876,
  -235937330,
  34607665,
  575812211,
  1117016757,
  1658221303,
  -2095541447,
  -1554336901,
  -1013132355,
  -471927809,
  876815458,
  335610912,
  1959224550,
  1418020004,
  -1253333654,
  -1794538200,
  -170924562,
  -712129108,
  645019219,
  103814673,
  1727428311,
  1186223765,
  -1485129893,
  -2026334439,
  -402720801,
  -943925347,
  1491421380,
  2024237190,
  409012288,
  941828098,
  -638727732,
  -105911922,
  -1721136824,
  -1188321014,
  1255430901,
  1788246711,
  173021809,
  705837619,
  -874718211,
  -341902401,
  -1957127303,
  -1424311493,
  2089249958,
  1556434148,
  1006840866,
  474025056,
  -40899154,
  -573714964,
  -1123308246,
  -1656124056,
  1857453719,
  1324637909,
  775044627,
  242228817,
  -272695393,
  -805511203,
  -1355104485,
  -1887920295,
  -2119593592,
  -1578389046,
  -1053961972,
  -512757426,
  10555520,
  551760066,
  1076187140,
  1617391686,
  -1818721351,
  -1277516805,
  -753089731,
  -211885185,
  311427761,
  852632307,
  1377059381,
  1918263927,
  -1513376278,
  -2054580824,
  -447744658,
  -988949204,
  616772834,
  75568288,
  1682404454,
  1141199908,
  -1208309797,
  -1749514343,
  -142678177,
  -683882723,
  921839315,
  380634769,
  1987470935,
  1446266389,
  -915547828,
  -382732018,
  -1981179448,
  -1448363638,
  1214601284,
  1747417094,
  148969664,
  681785474,
  -614675587,
  -81859777,
  -1680307207,
  -1147491397,
  1515473525,
  2048289335,
  449841905,
  982657715,
  -317719250,
  -850535060,
  -1383350870,
  -1916166680,
  1812429862,
  1279614052,
  746798242,
  213982432,
  -12652769,
  -545468579,
  -1078284389,
  -1611100199,
  2117496343,
  1584680533,
  1051864723,
  519048913
}; // idb
char byte_1002182C[256] =
{
  '\0',
  '^',
  '',
  '',
  'a',
  '?',
  '\xDD',
  '\x83',
  '',
  '\x9C',
  '~',
  ' ',
  '',
  '\xFD',
  '\x1F',
  'A',
  '\x9D',
  '',
  '!',
  '\x7F',
  '\xFC',
  '',
  '@',
  '\x1E',
  '_',
  '\x01',
  '',
  '',
  '>',
  '`',
  '\x82',
  '\xDC',
  '#',
  '}',
  '\x9F',
  '',
  'B',
  '\x1C',
  '\xFE',
  '',
  '',
  '',
  ']',
  '\x03',
  '',
  '\xDE',
  '<',
  'b',
  '',
  '',
  '\x02',
  '\\',
  '',
  '\x81',
  'c',
  '=',
  '|',
  '\"',
  '',
  '\x9E',
  '\x1D',
  'C',
  '',
  '\xFF',
  'F',
  '\x18',
  '',
  '',
  '\'',
  'y',
  '\x9B',
  '',
  '\x84',
  '',
  '8',
  'f',
  '',
  '',
  'Y',
  '\a',
  '\xDB',
  '',
  'g',
  '9',
  '',
  '',
  '\x06',
  'X',
  '\x19',
  'G',
  '',
  '',
  'x',
  '&',
  '',
  '\x9A',
  'e',
  ';',
  '',
  '\x87',
  '\x04',
  'Z',
  '',
  '',
  '',
  '',
  '\x1B',
  'E',
  '',
  '\x98',
  'z',
  '$',
  '',
  '',
  'D',
  '\x1A',
  '\x99',
  '',
  '%',
  '{',
  ':',
  'd',
  '\x86',
  '',
  '[',
  '\x05',
  '',
  '',
  '\x8C',
  '',
  '0',
  'n',
  '',
  '',
  'Q',
  '\x0F',
  'N',
  '\x10',
  '',
  '',
  '/',
  'q',
  '',
  '',
  '\x11',
  'O',
  '',
  '',
  'p',
  '.',
  '',
  '',
  '',
  '\x8D',
  'o',
  '1',
  '',
  '',
  '\x0E',
  'P',
  '',
  '',
  '\x13',
  'M',
  '',
  '\x90',
  'r',
  ',',
  'm',
  '3',
  '',
  '\x8F',
  '\f',
  'R',
  '',
  '',
  '2',
  'l',
  '\x8E',
  '',
  'S',
  '\r',
  '',
  '',
  '',
  '',
  'L',
  '\x12',
  '',
  '',
  '-',
  's',
  '',
  '',
  'v',
  '(',
  '',
  '',
  '\x17',
  'I',
  '\b',
  'V',
  '',
  '',
  'i',
  '7',
  '',
  '\x8B',
  'W',
  '\t',
  '',
  '',
  '6',
  'h',
  '\x8A',
  '',
  '',
  '',
  ')',
  'w',
  '',
  '',
  'H',
  '\x16',
  '',
  '',
  'U',
  '\v',
  '\x88',
  '',
  '4',
  'j',
  '+',
  'u',
  '',
  '',
  'J',
  '\x14',
  '',
  '',
  't',
  '*',
  '',
  '',
  '\x15',
  'K',
  '',
  '',
  '',
  '',
  '\n',
  'T',
  '',
  '\x89',
  'k',
  '5'
}; // idb
void *off_1002192C = &unk_10001210; // weak
void *off_10021930 = &unk_100012E0; // weak
void *off_10021934 = &unk_10001440; // weak
double dbl_10021940 =  1000.0; // weak
double dbl_10021948 =  1.0; // weak
double dbl_10021950 =  1193180.0; // weak
void *off_10021958 = &unk_100170AF; // weak
_UNKNOWN unk_1002197C; // weak
int dword_10021998[] = { 83 }; // weak
_DWORD dword_1002199C[45] =
{
  83,
  83,
  1,
  83,
  83,
  166,
  16,
  83,
  250,
  83,
  333,
  333,
  333,
  333,
  333,
  83,
  83,
  83,
  83,
  83,
  83,
  333,
  1000,
  83,
  1000,
  1000,
  83,
  41,
  333,
  83,
  83,
  83,
  83,
  83,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250,
  250
}; // idb
int (__stdcall *off_10021A50)(int, int, int) = &sub_1000B9F0; // weak
void *off_10021A6C = &unk_100170AF; // weak
int (*off_10021A70[2])() = { &sub_1000D170, &sub_1000C480 }; // weak
int (*off_10021A74)() = &sub_1000C480; // weak
double dbl_10021A78 =  0.1; // weak
double dbl_10021A80 =  10.0; // weak
double dbl_10021A88 =  100.0; // weak
void *(__thiscall *off_10021A94)(type_info *__hidden this, unsigned int) = &type_info::`scalar deleting destructor'; // weak
_UNKNOWN unk_10021A98; // weak
_UNKNOWN unk_10021C28; // weak
_UNKNOWN unk_10021C38; // weak
_UNKNOWN unk_10021C50; // weak
_UNKNOWN unk_10021C70; // weak
char byte_10021C80[8] = { '', '\x7F', '\x01', '\x10', '\xDD', '\x7F', '\x01', '\x10' }; // idb
_UNKNOWN unk_10021C88; // weak
char byte_10021CA0[116] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  'n',
  '\0',
  'u',
  '\0',
  'l',
  '\0',
  'l',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  'n',
  'u',
  'l',
  'l',
  ')',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10021D14; // weak
_UNKNOWN unk_10021D18; // weak
_UNKNOWN unk_10021D20; // weak
_UNKNOWN unk_10022090; // weak
_UNKNOWN unk_10022100; // weak
_UNKNOWN pThrowInfo; // weak
__TI_flags _TI2_AVmemory_exception__ = 0; // weak
_UNKNOWN unk_10022468; // weak
_UNKNOWN unk_10022510; // weak
_UNKNOWN unk_10022570; // weak
_UNKNOWN unk_10022670; // weak
_UNKNOWN unk_100226D0; // weak
_UNKNOWN unk_10024000; // weak
_UNKNOWN loc_1002402B; // weak
_UNKNOWN unk_10024034; // weak
_UNKNOWN loc_10024044; // weak
_UNKNOWN unk_1002404B; // weak
_UNKNOWN loc_10024053; // weak
_UNKNOWN unk_10024058; // weak
_UNKNOWN loc_1002405F; // weak
const char aTx[] = "tx"; // idb
int dword_100243E8 = 1024; // weak
int (*off_10024608)(const char *, ...) = &WriteSubGameLog; // weak
int (__cdecl *off_1002460C)(_DWORD, _DWORD) = &IsFileLastWrittenTime; // weak
int (__cdecl *off_10024610)(_DWORD, _DWORD) = &sub_413B50; // weak
int (__cdecl *off_10024618)(_DWORD) = &efree; // weak
_UNKNOWN unk_1002461C; // weak
char *off_10024650[12] =
{
  "Warbird",
  "Javelin",
  "Spider",
  "Leviathan",
  "Terrier",
  "Weasel",
  "Lancaster",
  "Shark",
  "Repel",
  "Decoy",
  "Burst",
  "Thor"
}; // weak
char *off_1002465C = "Leviathan"; // idb
int dword_10024680[] = { 268585072 }; // weak
char *off_100246F8[8] =
{
  "Warbird",
  "Javelin",
  "Spider",
  "Leviathan",
  "Terrier",
  "Weasel",
  "Lancaster",
  "Shark"
}; // weak
int FIX_DLL_Cmd[22] =
{
  268492176,
  268503808,
  268516112,
  268511056,
  268513088,
  268515952,
  268516928,
  268517888,
  268521712,
  268521760,
  268483616,
  268521808,
  268520640,
  268512896,
  268512320,
  268521920,
  268510496,
  268512928,
  268522384,
  268522576,
  268515712,
  268522768
}; // weak
_UNKNOWN unk_10024A20; // weak
_UNKNOWN unk_10024A24; // weak
const char aBanRem[] = "Ban rem"; // idb
_UNKNOWN loc_1002500A; // weak
_UNKNOWN loc_10025018; // weak
void *off_100251F4 = &unk_454956; // weak
char aProcessDebugger[18] = "Process debugger "; // weak
_DWORD dword_10025D60[4] = { 429065504, 0, 0, 0 }; // idb
int (*off_10025DCC)(void) = &sub_10016FF7; // weak
int dword_10025DE0 = 1; // weak
int (__cdecl *off_10025DE4)(_DWORD) = &sub_10015F50; // weak
int (*off_10025DF0[2])() = { &sub_10017F9C, &sub_10017F9C }; // weak
int (__cdecl *off_10025DF4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_10017F9C; // weak
int dword_10025DF8 = 268590594; // weak
_DWORD dword_10026004 = 1; // idb
char byte_10026008 = '.'; // weak
int dword_10026010 = 268573964; // weak
int dword_10026014 = 268573948; // weak
FILE File = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
FILE stru_10026060 = { NULL, 0, NULL, 2, 2, 0, 0, NULL }; // idb
int dword_100262A0[] = { 2 }; // weak
int dword_100262A4[] = { 268574676 }; // weak
int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &sub_1001D888; // weak
int (__cdecl *off_10026334)(_DWORD) = &sub_1001D888; // weak
int dword_10026338 = 268556424; // weak
int (__cdecl *off_1002633C)(_DWORD) = &sub_1001D888; // weak
int dword_10026340 = 268556424; // weak
int dword_10026344 = 268556424; // weak
_UNKNOWN unk_10026350; // weak
void *off_10026360 = &off_10026360; // weak
int dword_10026364 = 268591968; // weak
int dword_10026370 = -1; // weak
int dword_10028380 = 268591968; // weak
int dword_10028384 = 480; // weak
_UNKNOWN unk_10028390; // weak
int dword_10028394 = 11; // weak
int dword_10028408 = 3; // weak
int dword_1002840C = 7; // weak
int dword_10028410 = 10; // weak
int dword_10028414 = 140; // weak
int dword_10028450 = 28800; // weak
int dword_10028454 = 1; // weak
int dword_10028458 = -3600; // weak
char *off_100284DC = &unk_1002845C; // idb
char *off_100284E0 = &unk_1002849C; // idb
int dword_100284E8 = -1; // weak
int dword_100284EC = 0; // weak
int dword_100284F0 = 0; // weak
int dword_100284F8 = -1; // weak
int dword_100284FC = 0; // weak
int dword_10028500[] = { 0 }; // weak
int dword_10028504[12] = { -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 }; // idb
int dword_10028534[] = { 365 }; // weak
int dword_10028538[14] = { -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364, 0 }; // idb
char byte_10028570[8] = { '\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_10028578; // weak
int dword_1002857C[] = { -2105965984 }; // weak
int dword_10028588[] = { 57254 }; // weak
_UNKNOWN unk_10028668; // weak
int dword_1002866C[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // idb
_UNKNOWN unk_100287D0; // weak
_UNKNOWN unk_10028930; // weak
char LevelFiles[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
__int64 qword_10029250; // weak
double dbl_10029258; // weak
double dbl_10029260; // weak
char byte_10029268; // weak
int dword_1002926C; // weak
void unk_10029270; // idb
int dword_100292F0[]; // weak
int dword_100292F4; // weak
int dword_100292F8; // weak
int dword_100292FC; // weak
int dword_10029300; // weak
int dword_10029308; // weak
int dword_1002930C; // weak
int dword_10029310; // weak
struct SCRTY_1_STEP_STRUCT Step1Bytes[1024];
char byte_1003E318[288]; // idb
char byte_1003E438[139237]; // idb
int dword_10065078; // weak
int dword_1006507C; // weak
char byte_10065080[280]; // idb
int dword_10065198; // weak
char *IPAddressTable;
char *Scrty1FileBytes;
unsigned __int16 ArrayOfWords[];
int dword_101A51A0; // weak
int dword_101A51A8; // weak
char ap[]; // idb
int dword_101A52B0; // weak
int dword_101A52B4; // weak
int dword_101A52E8; // weak
int dword_101A52F0; // weak
_UNKNOWN unk_101A52F4; // weak
_UNKNOWN unk_101A5314; // weak
int dword_101A5334; // weak
int dword_101A5338; // weak
int dword_101A533C; // weak
int dword_101A5340; // weak
int dword_101A5344; // weak
int dword_101A5348; // weak
int dword_101A5350; // weak
int dword_101A5354; // weak
int dword_101A5358; // weak
int dword_101A535C; // weak
int ContinuumEncryptKey; // weak
int dword_101A5368[3]; // idb
int dword_101A5374; // weak
int dword_101A5378; // weak
char byte_101A537C; // weak
char byte_101A537D; // weak
char byte_101A537E; // weak
char byte_101A537F; // weak
char byte_101A5380; // weak
char byte_101A5381; // weak
char byte_101A5382; // weak
char byte_101A5383; // weak
char byte_101A5384; // weak
char byte_101A5385; // weak
char byte_101A5386; // weak
char byte_101A5388; // weak
char byte_101A5389; // weak
char byte_101A538A; // weak
char byte_101A538B; // weak
int dword_101A538C; // weak
int dword_101A5394; // weak
int dword_101A5398[]; // weak
int dword_101A539C[4095]; // idb
int dword_101A9398; // weak
char byte_101A939C; // idb
int dword_101A93E0; // weak
char byte_101A93E4[]; // idb
int dword_101A94E8; // weak
int dword_101A94EC; // weak
int dword_101A94F0; // weak
int dword_101A94F8; // weak
int dword_101A9500; // weak
int dword_101A9504; // weak
int dword_101A9508; // weak
void unk_101A9517; // idb
_UNKNOWN unk_101A9718; // weak
int dword_101B0718; // weak
char byte_101B0720[284]; // idb
char byte_101B083C; // weak
char byte_101B083D[10239]; // idb
char byte_101B303C; // weak
int dword_101B3040; // weak
int dword_101B3044; // weak
int dword_101B3048; // weak
int dword_101B304C; // weak
int dword_101B3050; // weak
char byte_101B3054; // weak
int ContinuumEncryptKeyCounter; // weak
struct SCRTY_1_STEP_STRUCT Step1AndStep2[1024];
int Scrty1Version; // weak
int dword_101C8064; // weak
int dword_101C8068; // weak
int dword_101C806C; // weak
int dword_101C8070; // weak
int dword_101C8074; // weak
int dword_101C8078; // weak
int dword_101C8090; // weak
int dword_101C8094; // weak
int dword_101C809C; // weak
int dword_101C80A0; // weak
int dword_101C80A4; // weak
int dword_101C80AC; // weak
char byte_101C80B4; // weak
int dword_101C80B8; // weak
int dword_101C80BC; // weak
int dword_101C80C4; // weak
int dword_101C80C8; // weak
int dword_101C80D0; // weak
__int16 word_101C80D6; // weak
__int16 word_101C80D8; // weak
__int16 word_101C80DA; // weak
int dword_101C80E0; // weak
char *dword_101C80E4; // idb
int dword_101C80EC; // weak
int dword_101C80F0; // weak
int dword_101C80F4; // weak
int dword_101C80F8; // weak
int dword_101C80FC; // weak
int (__cdecl *dword_101C8100)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_101C8108; // weak
_UNKNOWN unk_101C810C; // weak
int dword_101C8114; // weak
_DWORD dword_101C8124; // idb
int dword_101C812C; // weak
int dword_101C8130; // weak
int dword_101C8134; // weak
int dword_101C8138; // weak
int dword_101C813C; // weak
int (__cdecl *dword_101C8144)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_101C8148)(void); // weak
int (__cdecl *dword_101C814C)(_DWORD); // weak
int dword_101C8150[]; // weak
int (*dword_101C8158)(void); // weak
_UNKNOWN unk_101C816C; // weak
int dword_101C8270; // weak
int dword_101C8274; // weak
int dword_101C8278; // weak
int (__cdecl *dword_101C827C)(_DWORD); // weak
int dword_101C8280; // idb
int dword_101C8284; // weak
int dword_101C82B8; // weak
int dword_101C82C0; // weak
_UNKNOWN unk_101C82C4; // weak
__int16 word_101C8306; // weak
int dword_101C8314; // weak
_UNKNOWN unk_101C8318; // weak
__int16 word_101C835A; // weak
int dword_101C8368; // weak
char *dword_101C836C; // idb
int dword_101C8370; // weak
int dword_101C8374; // weak
int dword_101C8378; // weak
_DWORD dword_101C837C; // idb
_DWORD dword_101C8380[3]; // idb
int dword_101C838C; // weak
_UNKNOWN unk_101C84A0; // weak
char byte_101C84A1[259]; // idb
int dword_101C85A4; // weak
int dword_101C85AC; // weak
int dword_101C85B0; // weak
void *dword_101C85B8; // idb
int dword_101C85BC; // weak
_UNKNOWN dword_101C85C0; // weak
int dword_101C85C4; // weak
int dword_101C85E0[]; // weak
_UNKNOWN unk_101C85E4; // weak
_DWORD dword_101C86E0; // idb
_DWORD dword_101C86E4; // idb
int dword_101C86E8; // weak
int dword_101C86EC; // weak
int dword_101C9700; // weak
int dword_101C9704; // weak
int (__stdcall *dword_101C9708)(_DWORD, _DWORD, _DWORD); // weak
int dword_101C970C; // weak
int dword_101C9710; // weak
int dword_101C9714; // weak
int dword_101C9718; // weak


//----- (00401000) --------------------------------------------------------
// Arena.Create()
ARENA *__thiscall Create(ARENA *this, char *name)
{
  bool v3; // eax
  int (*v4)(void); // esi
  int v5; // eax
  int v6; // esi
  int v7; // eax
  unsigned int v8; // eax
  LPVOID v9; // eax
  char *v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // edi
  int v14; // edi
  unsigned int v15; // eax
  __int64 v16; // rax
  int v17; // eax
  int v18; // ecx
  char *v19; // eax
  char v21[8]; // [esp+10h] [ebp-120h] BYREF
  CHAR Filename[256]; // [esp+30h] [ebp-100h] BYREF

  *(_DWORD *)&this->field_1B8DE[6956] = 0;
  *(_DWORD *)this->field_10026 = 0;
  *(_DWORD *)&this->field_FF10[32] = 0;
  if ( _strcmpi(name, "server") )
  {
    strncpy(this->name, name, 0x20u);
    this->name[31] = 0;
  }
  else
  {
    strcpy(this->name, "unnamed");
  }
  v3 = CustomArenaMode > 0 && this->name[offsetof(ARENA, field_0)];
  v4 = (int (*)(void))GetTickCount;
  this->bHasScrFile = v3;
  *(_DWORD *)&this->field_10026[18028] = 0;
  *(_DWORD *)&this->field_10026[18032] = 0;
  *(_DWORD *)&this->field_10026[18024] = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)this->gap_FF08 = 0;
  *(_DWORD *)&this->field_10026[4] = 0;
  *(_DWORD *)&this->field_10026[8] = 0;
  *(_DWORD *)&this->field_10026[12] = 0;
  *(_DWORD *)&this->field_10026[16] = 0;
  if ( this->bHasScrFile )
  {
    strcpy(v21, this->name);
    strcat(v21, ".scr");
    v5 = fopen(v21, "rb");
    v6 = v5;
    if ( v5 )
    {
      v7 = _fileno(v5);
      v8 = _filelength(v7);
      *(_DWORD *)&this->field_10026[18028] = v8 / 0x12;
      v9 = ExpandMemory(0, 18 * (v8 / 0x12), 1);
      *(_DWORD *)&this->field_10026[18032] = v9;
      fread(v9, 18, *(_DWORD *)&this->field_10026[18028], v6);
      fclose(v6);
    }
    v4 = (int (*)(void))GetTickCount;
  }
  memset(this, 0, 0xFB00u);
  GetModuleFileNameA(0, Filename, 0x100u);
  v10 = strrchr(Filename, 92);
  if ( v10 )
    *v10 = 0;
  else
    Filename[0] = 0;
  if ( this->bHasScrFile )
  {
    sprintf(this->szConfigFile, "%s\\%s.cfg", Filename, this->name);
    sprintf(this->szLevelFile1, "%s.lvl", this->name);
    sprintf(this->szLevelFile2, "%s.lvl", this->name);
    if ( _access(this->szConfigFile, 0) )
      JUMPOUT(0x415980);
    if ( !sub_406ED0(this->szLevelFile2) )
    {
      strcpy(this->szLevelFile1, &aMisc_DefaultLevelFile);
      v4 = (int (*)(void))GetTickCount;
    }
  }
  else
  {
    sprintf(this->szConfigFile, "%s\\server.cfg", Filename);
    strcpy(this->szLevelFile1, &aMisc_DefaultLevelFile);
    strcpy(this->szLevelFile2, &aMisc_DefaultLevelFile);
    v4 = (int (*)(void))GetTickCount;
  }
  printf("Arena Created: (%s) using parameters: %s\n", this->name, this->szConfigFile);
  LoadArenaSettings_0_0(this);
  SomethingThatLoadsZoneMap((struct_ARENA *)this);
  *(_DWORD *)&this->field_FF6A[176] = 0;
  *(_DWORD *)&this->field_FF6A[180] = v4() / 0xAu;
  *(_DWORD *)this->field_FF10 = v4() / 0xAu;
  *(_DWORD *)&this->field_FF10[4] = v4() / 0xAu;
  *(_DWORD *)&this->field_FF10[8] = v4() / 0xAu;
  *(_DWORD *)&this->field_10026[34420] = 0;
  this->nPlayersHere = 0;
  *(_DWORD *)&this->field_10026[20] = 0;
  *(_DWORD *)&this->field_FF10[78] = 0;
  this->ArenaJackpot = 0;
  *(_DWORD *)&this->field_FF6A[160] = 0;
  *(_DWORD *)&this->field_FF6A[164] = 0;
  *(_DWORD *)&this->field_FF6A[168] = 0;
  *(_DWORD *)&this->field_FF6A[172] = 0;
  v11 = *(_DWORD *)&this->field_10026[44136];
  *(_DWORD *)&this->field_10026[42616] = 0;
  *(_DWORD *)&this->field_FF6A[4] = 0;
  if ( v11 && *(int *)&this->field_10026[44140] > 0 )
    v12 = rand() % *(_DWORD *)&this->field_10026[44140] + 1;
  else
    v12 = *(_DWORD *)&this->field_10026[44140];
  *(_DWORD *)this->field_FF6A = v12;
  *(_DWORD *)&this->field_FF10[50] = v4() / 0xAu;
  v13 = rand();
  *(_DWORD *)&this->field_FF10[20] = rand() * v13;
  v14 = rand();
  *(_DWORD *)&this->field_FF10[24] = rand() * v14;
  v15 = v4();
  *(_DWORD *)&this->field_FF10[36] = 0;
  *(_DWORD *)&this->field_FF10[28] = (v15 / 0xA) & 0x7FFFFFFF;
  *(_DWORD *)&this->field_FF10[40] = 0;
  *(_DWORD *)&this->field_FF10[44] = 0;
  *(_WORD *)&this->field_FF10[48] = 0;
  *(_DWORD *)&this->field_FF10[66] = 0;
  *(_DWORD *)&this->field_FF10[74] = 0;
  *(_DWORD *)&this->field_FF10[70] = 0;
  *(_DWORD *)&this->field_FF10[16] = 0;
  v16 = 3435973837i64 * (unsigned int)v4();
  LOBYTE(v16) = this->name[0];
  this->bRecordPointsToLog = 1;
  *(_DWORD *)&this->field_FF10[62] = HIDWORD(v16) >> 3;
  if ( (_BYTE)v16 && !bArena_SpawnKeepScore )
    this->bRecordPointsToLog = 0;
  if ( this->bHasScrFile )
    this->bRecordPointsToLog = 0;
  if ( *(_DWORD *)&this->field_10026[44172] == 2 )
  {
    v17 = *(_DWORD *)&this->field_1B8DE[6952];
    if ( *(_DWORD *)&this->field_10026[42616] < v17 )
    {
      v18 = 0;
      *(_DWORD *)&this->field_10026[42616] = v17;
      if ( v17 > 0 )
      {
        v19 = &this->field_10026[34424];
        do
        {
          *(_DWORD *)v19 = *((_DWORD *)v19 + 2906);
          *((_DWORD *)v19 + 1) = *((_DWORD *)v19 + 2907);
          *((_DWORD *)v19 + 3) = -1;
          *((_DWORD *)v19 + 2) = -1;
          ++v18;
          v19 += 16;
        }
        while ( v18 < *(_DWORD *)&this->field_1B8DE[6952] );
      }
    }
  }
  ArenaScoreReset(this, 0);
  *(_DWORD *)&this->field_10026[20] = 0;
  *(_DWORD *)&this->field_FF10[54] = v4() / 0xAu;
  *(_DWORD *)&this->field_FF10[16] = 0;
  SoccerGameSomething(this, -1);
  return this;
}
// 401252: control flows out of bounds to 415980
// 4DC214: invalid function type has been ignored
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);
// 438E00: using guessed type int bArena_SpawnKeepScore;
// 4D58B0: using guessed type int CustomArenaMode;

//----- (00401590) --------------------------------------------------------
void __thiscall ArenaShutdownArena(int this)
{
  int v2; // esi
  int *v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  unsigned int v10; // kr00_4
  int v11; // eax
  int v12; // eax
  int v13; // esi
  char v14[32]; // [esp+10h] [ebp-20h] BYREF

  v2 = 0;
  if ( *(int *)(this + 65292) > 0 )
  {
    v3 = (int *)(this + 64288);
    do
    {
      if ( !*(_DWORD *)(this + 109754) )
      {
        if ( *(_DWORD *)(this + 65570) )
        {
          v4 = *(_DWORD *)(*v3 + 351);
          if ( v4 >= 0 )
          {
            v5 = *v3 + 547;
            v6 = *(_DWORD *)(this + 83606) + 18 * v4 + 4;
            *(_DWORD *)v6 = *(_DWORD *)v5;
            *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 4);
            *(_DWORD *)(v6 + 8) = *(_DWORD *)(v5 + 8);
            *(_WORD *)(v6 + 12) = *(_WORD *)(v5 + 12);
          }
        }
      }
      v7 = *v3;
      ++v2;
      ++v3;
      *(_DWORD *)(v7 + 28) = 0;
      *(_DWORD *)(*(v3 - 1) + 56) = 1;
    }
    while ( v2 < *(_DWORD *)(this + 65292) );
  }
  v8 = *(_DWORD *)(this + 119818);
  if ( v8 && v8 != big_global_buffer )
    efree(*(LPVOID *)(this + 119818));
  v9 = *(_DWORD *)(this + 111610);
  if ( v9 && v9 != dword_438DFC )
    lpfnFixExport13(*(_DWORD *)(this + 111610));
  if ( *(_DWORD *)(this + 83606) )
  {
    v10 = ((int (*)(void))GetTickCount)();
    v11 = *(_DWORD *)(this + 119826);
    *(_DWORD *)(this + 83598) = v10 / 0xA;
    if ( v11 )
    {
      strcpy(v14, (const char *)(this + 64256));
      strcat(v14, ".scr");
      v12 = fopen(v14, "wb");
      v13 = v12;
      if ( v12 )
      {
        fwrite(*(LPCVOID *)(this + 83606), 18, *(_DWORD *)(this + 83602), v12);
        fclose(v13);
      }
    }
    efree(*(LPVOID *)(this + 83606));
  }
}
// 4DC214: invalid function type has been ignored
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(LPCVOID lpBuffer, _DWORD, _DWORD, _DWORD);
// 42EEC0: using guessed type int (__stdcall *lpfnFixExport13)(_DWORD);

//----- (00401720) --------------------------------------------------------
void __thiscall DropBrick(struct ARENA *arenaa, int XTiles, int YTiles, __int16 Team)
{
  int v5; // ebp
  int v6; // ecx
  int v7; // eax
  int v8; // ebx
  char *v9; // edi
  int v10; // ebx
  char *v11; // edi
  int v12; // [esp+10h] [ebp-110h] BYREF
  int v13; // [esp+14h] [ebp-10Ch] BYREF
  int v14; // [esp+18h] [ebp-108h] BYREF
  int v15; // [esp+1Ch] [ebp-104h] BYREF
  char buf; // [esp+20h] [ebp-100h] BYREF
  int v17; // [esp+21h] [ebp-FFh]
  int v18; // [esp+25h] [ebp-FBh]
  int v19; // [esp+29h] [ebp-F7h]
  int v20; // [esp+2Dh] [ebp-F3h]

  if ( *(int *)&arenaa->field_10026[34420] < 1024 )
  {
    DoBrickDrop(
      *(char **)&arenaa->field_1B8DE[6956],
      XTiles,
      YTiles,
      &v15,
      &v13,
      &v14,
      &v12,
      *(_DWORD *)&arenaa->field_10026[44192]);
    if ( v15 != v14 || v13 != v12 )
    {
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18036] = v15;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18038] = v13;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18040] = v14;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18042] = v12;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18044] = Team;
      *(_WORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18046] = (*(_WORD *)&arenaa->field_FF10[48])++;
      v5 = 0;
      *(_DWORD *)&arenaa->field_10026[16 * *(_DWORD *)&arenaa->field_10026[34420] + 18048] = (((int (*)(void))GetTickCount)()
                                                                                            / 0xAu) & 0x7FFFFFFF;
      v6 = 16 * *(_DWORD *)&arenaa->field_10026[34420];
      buf = 33;
      v17 = *(_DWORD *)&arenaa->field_10026[v6 + 18036];
      v18 = *(_DWORD *)&arenaa->field_10026[v6 + 18040];
      v19 = *(_DWORD *)&arenaa->field_10026[v6 + 18044];
      v7 = *(_DWORD *)&arenaa->field_10026[44332];
      v20 = *(_DWORD *)&arenaa->field_10026[v6 + 18048];
      if ( v7 > 0 )
      {
        do
        {
          v8 = 0;
          if ( arenaa->nPlayersHere > 0 )
          {
            v9 = arenaa->PlayerArray;
            do
            {
              if ( !*(_DWORD *)(*(_DWORD *)v9 + 56) )
                PlayerSendPacket(*(PLAYER **)v9, &buf, 17, 0);
              ++v8;
              v9 += 4;
            }
            while ( v8 < arenaa->nPlayersHere );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)ServerPacketAttachment);
          ++v5;
        }
        while ( v5 < *(_DWORD *)&arenaa->field_10026[44332] );
      }
      v10 = 0;
      if ( arenaa->nPlayersHere > 0 )
      {
        v11 = arenaa->PlayerArray;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v11 + 56) )
            PlayerSendPacket(*(PLAYER **)v11, &buf, 17, 1);
          ++v10;
          v11 += 4;
        }
        while ( v10 < arenaa->nPlayersHere );
      }
      ++*(_DWORD *)&arenaa->field_10026[34420];
    }
  }
}
// 4DC214: invalid function type has been ignored

//----- (00401920) --------------------------------------------------------
// a player is entering an arena for the first time
points_data *__thiscall ArenaAddPlayer(ARENA *arena, PLAYER *p)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  _DWORD *i; // ecx
  int v10; // eax
  char *v11; // eax
  int v12; // ecx
  int v13; // eax
  points_data *v14; // edx
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // edx
  char *v19; // ecx
  int v20; // eax
  int v21; // esi
  int v22; // ecx
  int v23; // edx
  char *v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // esi
  char *v28; // ecx
  char *v29; // eax
  int v30; // edx
  __int16 v31; // di
  int v32; // edi
  char *v33; // esi
  __int16 v34; // cx
  __int16 v35; // dx
  char *v36; // esi
  int v37; // edx
  int v38; // edi
  char v39; // al
  int v40; // ecx
  int v41; // edx
  char *v42; // eax
  _BOOL1 v43; // cc
  int v44; // eax
  int v45; // eax
  __int16 v46; // ax
  unsigned int v47; // eax
  int v48; // edx
  int v49; // eax
  __int16 v50; // dx
  __int16 v51; // cx
  char v52; // al
  __int16 v53; // dx
  __int16 v54; // ax
  int v55; // ecx
  int v56; // edx
  points_data *result; // eax
  int v58; // edx
  int v59; // ecx
  char *v60; // [esp-4h] [ebp-5454h]
  char v61; // [esp+13h] [ebp-543Dh] BYREF
  char *v62; // [esp+14h] [ebp-543Ch]
  int v63; // [esp+18h] [ebp-5438h]
  points_data *v64; // [esp+1Ch] [ebp-5434h]
  const void *v65; // [esp+20h] [ebp-5430h]
  CHAR String; // [esp+24h] [ebp-542Ch] BYREF
  __int16 v67; // [esp+25h] [ebp-542Bh]
  __int16 v68; // [esp+27h] [ebp-5429h]
  __int16 v69; // [esp+29h] [ebp-5427h]
  __int16 v70; // [esp+2Bh] [ebp-5425h]
  char v71; // [esp+34h] [ebp-541Ch] BYREF
  int v72; // [esp+35h] [ebp-541Bh]
  int v73; // [esp+39h] [ebp-5417h]
  int v74; // [esp+3Dh] [ebp-5413h]
  int v75; // [esp+41h] [ebp-540Fh]
  char v76[3]; // [esp+48h] [ebp-5408h] BYREF
  char v77[20]; // [esp+4Bh] [ebp-5405h] BYREF
  char v78[20]; // [esp+5Fh] [ebp-53F1h] BYREF
  int v79; // [esp+73h] [ebp-53DDh]
  int v80; // [esp+77h] [ebp-53D9h]
  __int16 v81; // [esp+7Bh] [ebp-53D5h]
  __int16 v82; // [esp+7Dh] [ebp-53D3h]
  __int16 v83; // [esp+7Fh] [ebp-53D1h]
  __int16 v84; // [esp+81h] [ebp-53CFh]
  __int16 v85; // [esp+83h] [ebp-53CDh]
  int v86; // [esp+85h] [ebp-53CBh]
  char v87; // [esp+A0h] [ebp-53B0h] BYREF
  __int16 v88; // [esp+A1h] [ebp-53AFh]
  char v89[96]; // [esp+A3h] [ebp-53ADh] BYREF
  char v90[128]; // [esp+104h] [ebp-534Ch] BYREF
  char v91[460]; // [esp+184h] [ebp-52CCh] BYREF
  char buf; // [esp+350h] [ebp-5100h] BYREF
  char v93; // [esp+351h] [ebp-50FFh] BYREF
  char v94; // [esp+1350h] [ebp-4100h] BYREF
  char v95[16639]; // [esp+1351h] [ebp-40FFh] BYREF

  if ( arena->bHasScrFile )
  {
    if ( *(_DWORD *)&arena->field_10026[44048] == -1 && !arena->nPlayersHere )
    {
      v3 = p->dwUserID;
      if ( v3 >= 0 )
      {
        v4 = 0;
        switch ( CustomArenaMode )
        {
          case 1:
            goto LABEL_11;
          case 2:
            if ( p->bIsModerator )
              goto LABEL_11;
            break;
          case 3:
            if ( p->bIsSmod )
              goto LABEL_11;
            break;
          case 4:
            if ( p->bIsSysop )
LABEL_11:
              v4 = 1;
            break;
          default:
            break;
        }
        if ( v4 )
        {
          *(_DWORD *)&arena->field_10026[44048] = v3;
          strcpy(arena->szArenaOwner, p->player_name);
          sprintf(&String, "%d", p->dwUserID);
          WritePrivateProfileStringA("Owner", "UserId", &String, arena->szConfigFile);
          WritePrivateProfileStringA("Owner", "Name", p->player_name, arena->szConfigFile);
        }
      }
    }
  }
  v64 = &p->score;
  *(points_data *)&p->field_231[28] = p->score;
  *(_DWORD *)&arena->PlayerArray[4 * arena->nPlayersHere++] = p;
  p->lpCurrentArena = (int)arena;
  *(_DWORD *)&p->field_44[152] = 0;
  *(_DWORD *)&p->field_44[156] = 0;
  *(_DWORD *)&p->yPixels = 0;
  *(_DWORD *)&p->xPixels = 0;
  *(_DWORD *)&p->field_EA[2] = 0;
  *(_WORD *)&p->field_EA[6] = 0;
  *(_WORD *)&p->field_EA[2] = 10000;
  *(_DWORD *)&p->field_44[112] = 0;
  *(_DWORD *)&p->field_117[8] = 0;
  *(_DWORD *)&p->field_117[12] = 0;
  *(_DWORD *)&p->field_117[16] = 0;
  *(_DWORD *)&p->field_231[50] = -1;
  *(_DWORD *)&p->field_44[124] = *(_DWORD *)&arena->field_10026[44092];
  *(_DWORD *)&p->field_2F9[24] = 0;
  *(_DWORD *)&p->field_44[144] = 0;
  *(_DWORD *)&p->field_44[148] = 0;
  *(_DWORD *)&p->field_117[72] = -1;
  if ( arena->bHasScrFile )
  {
    v5 = p->dwUserID;
    if ( v5 >= 0 )
    {
      v6 = *(_DWORD *)&arena->field_10026[18028];
      v7 = *(_DWORD **)&arena->field_10026[18032];
      v8 = 0;
      for ( i = v7; v8 < v6; ++v8 )
      {
        if ( *i == v5 )
          break;
        i = (_DWORD *)((char *)i + 18);
      }
      if ( v8 == v6 )
      {
        v10 = v6 + 1;
        *(_DWORD *)&arena->field_10026[18028] = v10;
        v11 = (char *)ExpandMemory(v7, 18 * v10, 0x10000);
        *(_DWORD *)&arena->field_10026[18032] = v11;
        *(_DWORD *)&v11[18 * v8] = p->dwUserID;
        v12 = 18 * v8 + *(_DWORD *)&arena->field_10026[18032] + 4;
        *(_DWORD *)v12 = 0;
        *(_DWORD *)(v12 + 4) = 0;
        *(_DWORD *)(v12 + 8) = 0;
        *(_WORD *)(v12 + 12) = 0;
      }
      *(_DWORD *)&p->field_117[72] = v8;
      v13 = *(_DWORD *)&arena->field_10026[18032] + 18 * v8 + 4;
      v14 = v64;
      *(_DWORD *)&v64->wins = *(_DWORD *)v13;
      *(_DWORD *)&v14->flags = *(_DWORD *)(v13 + 4);
      *(int *)((char *)&v14->points + 2) = *(_DWORD *)(v13 + 8);
      HIWORD(v14->flag_points) = *(_WORD *)(v13 + 12);
      *(_DWORD *)p->field_231 = *(_DWORD *)v13;
      *(_DWORD *)&p->field_231[4] = *(_DWORD *)(v13 + 4);
      *(_DWORD *)&p->field_231[8] = *(_DWORD *)(v13 + 8);
      *(_WORD *)&p->field_231[12] = *(_WORD *)(v13 + 12);
    }
  }
  if ( *(int *)&arena->field_10026[44180] > 0 )
  {
    v15 = (int)v64;
    v16 = 0;
    p->score.losses = 0;
    p->score.points = 0;
    *(_WORD *)v15 = 0;
    p->score.flag_points = 0;
    p->score.flags = 0;
    v17 = p->dwUserID;
    if ( v17 >= 0 )
    {
      v18 = *(_DWORD *)&arena->field_10026[20];
      if ( v18 > 0 )
      {
        v19 = &arena->field_10026[24];
        while ( *(_DWORD *)v19 != v17 )
        {
          ++v16;
          v19 += 18;
          if ( v16 >= v18 )
            goto LABEL_30;
        }
        *(_DWORD *)v15 = *(_DWORD *)&arena->field_10026[18 * v16 + 28];
        *(_DWORD *)(v15 + 4) = *(_DWORD *)&arena->field_10026[18 * v16 + 32];
        *(_DWORD *)(v15 + 8) = *(_DWORD *)&arena->field_10026[18 * v16 + 36];
        *(_WORD *)(v15 + 12) = *(_WORD *)&arena->field_10026[18 * v16 + 40];
      }
LABEL_30:
      if ( v16 == *(_DWORD *)&arena->field_10026[20] )
      {
        *(_DWORD *)v15 = 0;
        *(_DWORD *)(v15 + 4) = 0;
        *(_DWORD *)(v15 + 8) = 0;
        *(_WORD *)(v15 + 12) = 0;
      }
    }
  }
  v20 = *(_DWORD *)&arena->field_10026[44160];
  if ( v20 > 0 && (unsigned __int16)p->score.losses >= v20 )
    p->dwShip = 8;
  if ( !p->bIsModerator )
  {
    v21 = *(_DWORD *)&arena->field_10026[44296];
    if ( v21 > 0 )
    {
      v22 = arena->nPlayersHere;
      v23 = 0;
      if ( v22 > 0 )
      {
        v24 = arena->PlayerArray;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)v24 + 275) != 8 )
            ++v23;
          v24 += 4;
          --v22;
        }
        while ( v22 );
      }
      if ( v23 > v21 )
        p->dwShip = 8;
    }
  }
  if ( dwMisc_DisableSharewareShips )
  {
    if ( *(_DWORD *)&p->field_44[4] )
    {
      v25 = p->dwShip;
      if ( v25 == 5 || v25 == 6 || v25 == 4 || v25 == 7 )
        p->dwShip = 8;
    }
  }
  if ( *(_DWORD *)&arena->field_FF10[78] )
    p->dwShip = 8;
  v60 = p->player_name;
  if ( p->dwShip == 8 )
  {
    printf("Player spectating game: %s\n", v60);
    *(_DWORD *)p->field_117 = *(_DWORD *)&arena->field_10026[44156];
  }
  else
  {
    printf("Player entering game: %s\n", v60);
    v26 = DLL_CALL_GET_NEW_FREQ(arena);
    *(_DWORD *)p->field_117 = v26;              // Freq
    if ( *(_DWORD *)&arena->field_10026[44200] )
      p->dwShip = v26 % 8;
  }
  PlayerSendPacket(p, &arena->field_10026[42620], 1428, 1);
  if ( *(_DWORD *)&arena->field_10026[44172] == 2 )
  {
    v27 = *(_DWORD *)&arena->field_10026[42616];
    buf = 34;
    v28 = &v93;
    if ( v27 > 0 )
    {
      v29 = &arena->field_10026[34436];
      v30 = v27;
      do
      {
        v31 = *(_WORD *)v29;
        v29 += 16;
        *(_WORD *)v28 = v31;
        v28 += 2;
        --v30;
      }
      while ( v30 );
    }
    PlayerSendPacket(p, &buf, 2 * v27 + 1, 1);
  }
  else
  {
    v32 = 0;
    if ( *(int *)&arena->field_10026[42616] > 0 )
    {
      v33 = &arena->field_10026[34424];
      do
      {
        if ( *((_DWORD *)v33 + 2) == -1 && *(int *)v33 >= 0 && *((int *)v33 + 1) >= 0 )
        {
          v34 = *((_WORD *)v33 + 2);
          v35 = *((_WORD *)v33 + 6);
          v68 = *(_WORD *)v33;
          v69 = v34;
          String = 18;
          v70 = v35;
          v67 = v32;
          PlayerSendPacket(p, &String, 9, 1);
        }
        ++v32;
        v33 += 16;
      }
      while ( v32 < *(_DWORD *)&arena->field_10026[42616] );
    }
  }
  v63 = 0;
  memset(v90, 0, sizeof(v90));
  v36 = v91;
  if ( arena->nPlayersHere > 0 )
  {
    v62 = arena->PlayerArray;
    do
    {
      v37 = (int)v62;
      *v36 = 3;
      v38 = *(_DWORD *)v37;
      *(_WORD *)(v36 + 51) = *(_WORD *)(*(_DWORD *)v37 + 20);
      *(_WORD *)(v36 + 59) = *(_WORD *)(v38 + 611);
      v36[2] = *(_BYTE *)(v38 + 615);
      *(_WORD *)(v36 + 53) = *(_WORD *)(v38 + 279);
      v36[1] = *(_BYTE *)(v38 + 275);
      *(_WORD *)(v36 + 55) = *(_WORD *)(v38 + 547);
      *(_WORD *)(v36 + 57) = *(_WORD *)(v38 + 549);
      *(_DWORD *)(v36 + 43) = *(_DWORD *)(v38 + 553);
      *(_DWORD *)(v36 + 47) = *(_DWORD *)(v38 + 557);
      v36[63] = *(_DWORD *)(v38 + 785) != 0;
      strncpy(v36 + 3, (const char *)(v38 + 375), 0x14u);
      v36[22] = 0;
      strncpy(v36 + 23, (const char *)(v38 + 399), 0x14u);
      v39 = arena->field_10026[44004];
      v36[42] = 0;
      *(_WORD *)(v36 + 61) = 0;
      if ( v39 )
      {
        v40 = *(_DWORD *)&arena->field_10026[42616];
        if ( v40 > 0 )
        {
          v41 = *(__int16 *)(v36 + 51);
          v42 = &arena->field_10026[34432];
          do
          {
            if ( *(_DWORD *)v42 == v41 )
              ++*(_WORD *)(v36 + 61);
            v42 += 16;
            --v40;
          }
          while ( v40 );
        }
      }
      v36 += 64;
      if ( (unsigned int)(v36 - v91 + 64) > 0x1CC )
      {
        PlayerSendPacket(p, v91, v36 - v91, 1);
        v36 = v91;
      }
      v43 = ++v63 < arena->nPlayersHere;
      v62 += 4;
    }
    while ( v43 );
  }
  if ( v36 != v91 )
    PlayerSendPacket(p, v91, v36 - v91, 1);
  v44 = arena->nPlayersHere;
  v63 = 0;
  if ( v44 > 0 )
  {
    v62 = arena->PlayerArray;
    do
    {
      v45 = *(_DWORD *)v62;
      if ( *(_DWORD *)(*(_DWORD *)v62 + 553) + *(_DWORD *)(*(_DWORD *)v62 + 557) >= *(_DWORD *)&arena->field_10026[44056]
        || *(_DWORD *)(v45 + 48) )
      {
        v65 = (const void *)(v45 + 423);
        if ( memcmp(v90, (const void *)(v45 + 423), 0x60u) )
        {
          v46 = *(_WORD *)(v45 + 20);
          v87 = 31;
          v88 = v46;
          qmemcpy(v89, v65, sizeof(v89));
          PlayerSendPacket(p, &v87, 99, 1);
        }
      }
      v43 = ++v63 < arena->nPlayersHere;
      v62 += 4;
    }
    while ( v43 );
  }
  v47 = 16 * *(_DWORD *)&arena->field_10026[34420];
  v94 = 33;
  qmemcpy(v95, &arena->field_10026[18036], v47);
  PlayerSendPacket(p, &v94, v47 + 1, 1);
  lpfnFixExport14(arena, p);
  v61 = 2;
  PlayerSendPacket(p, &v61, 1, 1);
  p->xPixels = -9999;
  p->yPixels = -9999;
  v48 = *(_DWORD *)&arena->field_FF10[24];
  v49 = *(_DWORD *)&arena->field_FF10[28];
  v73 = *(_DWORD *)&arena->field_FF10[20];
  v71 = 24;
  v72 = v48;
  v74 = v49;
  v75 = 0;
  PlayerSendPacket(p, &v71, 17, 1);
  v50 = p->field_14;
  v51 = *(_WORD *)p->field_117;
  v76[1] = p->dwShip;
  v52 = p->bFilterObscene;
  v81 = v50;
  v53 = *(_WORD *)&p->field_231[50];
  v76[2] = v52;
  v54 = p->score.losses;
  v82 = v51;
  v84 = v54;
  v85 = v53;
  v55 = p->score.points;
  v83 = v64->wins;
  v56 = p->score.flag_points;
  v76[0] = 3;
  v79 = v55;
  v80 = v56;
  v86 = 0;
  strncpy(v77, p->player_name, 0x14u);
  v77[19] = 0;
  strncpy(v78, p->field_18F, 0x14u);
  v78[19] = 0;
  SendEverybodyButYourself(p, v76, 0x40u, 1);
  if ( p->score.points + p->score.flag_points >= *(_DWORD *)&arena->field_10026[44056] || *(_DWORD *)&p->field_2C[4] )
  {
    if ( memcmp(v90, &p->field_18F[24], 0x60u) )
    {
      v88 = p->field_14;
      v87 = 31;
      qmemcpy(v89, &p->field_18F[24], sizeof(v89));
      SendEverybodyButYourself(p, &v87, 0x63u, 1);
    }
  }
  result = v64;
  v58 = *(_DWORD *)&v64->flags;
  *(_DWORD *)&p->field_231[14] = *(_DWORD *)&v64->wins;
  v59 = *(int *)((char *)&result->points + 2);
  *(_DWORD *)&p->field_231[18] = v58;
  LOWORD(v58) = HIWORD(result->flag_points);
  *(_DWORD *)&p->field_231[22] = v59;
  *(_WORD *)&p->field_231[26] = v58;
  return result;
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 42EEC4: using guessed type int (__thiscall *lpfnFixExport14)(_DWORD, _DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4D58B0: using guessed type int CustomArenaMode;

//----- (004022D0) --------------------------------------------------------
// Arena.RemovePlayer()
void __thiscall ArenaRemovePlayer(struct ARENA *arenaa, struct PLAYER *player)
{
  struct PLAYER *v2; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  char *v8; // edi
  int v9; // ecx
  struct PLAYER **v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  char *v14; // ecx
  int v15; // eax
  _BOOL1 v16; // zf
  int v17; // edi
  int v18; // edx
  int v19; // eax
  char *v20; // ecx
  char *v21; // edx
  char *v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // eax
  PLAYER *v26; // eax
  int v27; // edi
  int v28; // eax
  char *v29; // ebp
  char *v30; // ecx
  points_data *v31; // ebx

  v2 = player;
  UpdatePowerBallPositionsSomething(player);
  v4 = *(_DWORD *)&v2->field_44[12];
  v5 = *(_DWORD *)&v2->field_44[16];
  v2->lpCurrentArena = 0;
  if ( v4 >= 0 && v5 >= 0 && v4 < 8 && v5 < 8 )
  {
    v6 = 251 * (v5 + 8 * v4);
    v7 = 0;
    v8 = &arenaa->field_0[4 * v6];
    v9 = *((_DWORD *)v8 + 250);
    if ( v9 > 0 )
    {
      v10 = (struct PLAYER **)v8;
      while ( *v10 != v2 )
      {
        ++v7;
        ++v10;
        if ( v7 >= v9 )
          goto LABEL_11;
      }
      v11 = v9 - 1;
      *((_DWORD *)v8 + 250) = v11;
      *(_DWORD *)&v8[4 * v7] = *(_DWORD *)&v8[4 * v11];
    }
  }
LABEL_11:
  v12 = arenaa->nPlayersHere;
  v13 = 0;
  if ( v12 > 0 )
  {
    v14 = arenaa->PlayerArray;
    while ( *(struct PLAYER **)v14 != v2 )
    {
      ++v13;
      v14 += 4;
      if ( v13 >= v12 )
        goto LABEL_17;
    }
    arenaa->nPlayersHere = v12 - 1;
    memcpy(&arenaa->PlayerArray[4 * v13], &arenaa->PlayerArray[4 * v13 + 4], 4 * (v12 - 1 + 0x3FFFFFFF * v13));
  }
LABEL_17:
  v15 = *(_DWORD *)&arenaa->field_10026[44180];
  v16 = v15 == 0;
  if ( v15 > 0 )
  {
    v17 = v2->dwUserID;
    if ( v17 >= 0 )
    {
      v18 = *(_DWORD *)&arenaa->field_10026[20];
      v19 = 0;
      if ( v18 > 0 )
      {
        v20 = &arenaa->field_10026[24];
        while ( *(_DWORD *)v20 != v17 )
        {
          ++v19;
          v20 += 18;
          if ( v19 >= v18 )
            goto LABEL_25;
        }
        v21 = &arenaa->field_10026[18 * v19 + 28];
        *(_DWORD *)v21 = *(_DWORD *)&v2->score.wins;
        *((_DWORD *)v21 + 1) = *(_DWORD *)&v2->score.flags;
        *((_DWORD *)v21 + 2) = *(int *)((char *)&v2->score.points + 2);
        *((_WORD *)v21 + 6) = HIWORD(v2->score.flag_points);
      }
LABEL_25:
      if ( v19 == *(_DWORD *)&arenaa->field_10026[20] && v19 < 1000 )
      {
        v22 = &arenaa->field_0[18 * v19];
        *(_DWORD *)(v22 + 65598) = v2->dwUserID;
        v22 += 65602;
        *(_DWORD *)v22 = *(_DWORD *)&v2->score.wins;
        *((_DWORD *)v22 + 1) = *(_DWORD *)&v2->score.flags;
        *((_DWORD *)v22 + 2) = *(int *)((char *)&v2->score.points + 2);
        *((_WORD *)v22 + 6) = HIWORD(v2->score.flag_points);
        ++*(_DWORD *)&arenaa->field_10026[20];
      }
    }
    v16 = *(_DWORD *)&arenaa->field_10026[44180] == 0;
  }
  if ( v16 )
  {
    if ( arenaa->bHasScrFile )
    {
      v23 = *(_DWORD *)&v2->field_117[72];
      if ( v23 >= 0 )
      {
        v24 = *(_DWORD *)&arenaa->field_10026[18032] + 18 * v23 + 4;
        *(_DWORD *)v24 = *(_DWORD *)&v2->score.wins;
        *(_DWORD *)(v24 + 4) = *(_DWORD *)&v2->score.flags;
        *(_DWORD *)(v24 + 8) = *(int *)((char *)&v2->score.points + 2);
        *(_WORD *)(v24 + 12) = HIWORD(v2->score.flag_points);
      }
    }
  }
  if ( v2->bIsSysop )
  {
    v25 = *(_DWORD *)&v2->field_117[92];
    if ( v25 >= 0 )
    {
      v26 = *(&ZonePlayerList + v25);
      LOWORD(player) = 0x1C;
      if ( v26 )
        PlayerSendPacket(v26, &player, 2, 1);
    }
  }
  if ( ZonePlayerCount > 0 )
  {
    v27 = 0;
    *(_WORD *)((char *)&player + 1) = v2->field_14;
    v28 = arenaa->nPlayersHere;
    LOBYTE(player) = 4;
    if ( v28 > 0 )
    {
      v29 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v29 + 56) )
          PlayerSendPacket(*(PLAYER **)v29, &player, 3, 1);
        ++v27;
        v29 += 4;
      }
      while ( v27 < arenaa->nPlayersHere );
    }
  }
  CarryFlagsSomething(arenaa, *(_DWORD *)&v2->field_14, 0);
  if ( !arenaa->bRecordPointsToLog )
  {
    v30 = &v2->field_231[28];
    v31 = &v2->score;
    *(_DWORD *)&v31->wins = *(_DWORD *)v30;
    *(_DWORD *)&v31->flags = *((_DWORD *)v30 + 1);
    *(int *)((char *)&v31->points + 2) = *((_DWORD *)v30 + 2);
    HIWORD(v31->flag_points) = *((_WORD *)v30 + 6);
  }
}
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (00402560) --------------------------------------------------------
#error "403549: cannot convert to microcode (funcsize=1163)"

//----- (00403F60) --------------------------------------------------------
int __cdecl sub_403F60(const void *a1, const void *a2)
{
  return *(_DWORD *)(*(_DWORD *)a2 + 553)
       + *(_DWORD *)(*(_DWORD *)a2 + 557)
       - *(_DWORD *)(*(_DWORD *)a1 + 557)
       - *(_DWORD *)(*(_DWORD *)a1 + 553);
}

//----- (00403F90) --------------------------------------------------------
void __thiscall ArenaScoreReset(struct ARENA *arenaa, int sendScoreReset)
{
  int v3; // eax
  int v4; // ecx
  char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // ebp
  char *v9; // ebx

  v3 = arenaa->nPlayersHere;
  v4 = 0;
  if ( v3 > 0 )
  {
    v5 = arenaa->PlayerArray;
    do
    {
      v6 = *(_DWORD *)v5;
      ++v4;
      v5 += 4;
      *(_DWORD *)(v6 + 192) = *(_DWORD *)&arenaa->field_10026[44092];
      *(_WORD *)(*((_DWORD *)v5 - 1) + 0x225) = 0;
      *(_WORD *)(*((_DWORD *)v5 - 1) + offsetof(PLAYER, score)) = 0;
      *(_DWORD *)(*((_DWORD *)v5 - 1) + 0x229) = 0;
      *(_DWORD *)(*((_DWORD *)v5 - 1) + 0x22D) = 0;
      *(_WORD *)(*((_DWORD *)v5 - 1) + 0x227) = 0;
    }
    while ( v4 < arenaa->nPlayersHere );
  }
  if ( sendScoreReset )
  {
    v7 = arenaa->nPlayersHere;
    v8 = 0;
    LOBYTE(sendScoreReset) = 0x1A;
    *(_WORD *)((char *)&sendScoreReset + 1) = -1;
    if ( v7 > 0 )
    {
      v9 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v9 + 56) )
          PlayerSendPacket(*(PLAYER **)v9, &sendScoreReset, 3, 1);
        ++v8;
        v9 += 4;
      }
      while ( v8 < arenaa->nPlayersHere );
    }
  }
}

//----- (00404050) --------------------------------------------------------
int __thiscall sub_404050(int this, int a2)
{
  int v3; // eax
  __int16 v4; // dx
  int v5; // esi
  __int16 v6; // ax
  __int64 v7; // rax
  int ReturnXTile; // [esp+Ch] [ebp-8h] BYREF
  int ReturnYTile; // [esp+10h] [ebp-4h] BYREF

  v3 = *(__int16 *)(this + 109490) + *(_DWORD *)(this + 65292) * *(__int16 *)(this + 109492);
  if ( v3 >= 1024 )
    v3 = 1024;
  SomethingWithPrizes((struct ARENA *)this, (int)&ReturnXTile, (int)&ReturnYTile, 512, 512, v3 / 2);
  v4 = 16 * ReturnXTile;
  v5 = 3 * a2 + this + 12 * a2;
  v6 = 16 * ReturnYTile;
  *(_BYTE *)(v5 + 65394) = a2;
  *(_WORD *)(v5 + 65395) = v4;
  *(_WORD *)(v5 + 65397) = v6;
  *(_WORD *)(v5 + 65399) = 0;
  *(_WORD *)(v5 + 65401) = 0;
  *(_WORD *)(v5 + 65403) = -1;
  v7 = 3435973837i64 * (unsigned int)((int (*)(void))GetTickCount)();
  *(_DWORD *)(v5 + 65405) = HIDWORD(v7) >> 3;
  *(_DWORD *)(this + 4 * a2 + 65514) = 0;
  return v7;
}
// 4DC214: invalid function type has been ignored

//----- (00404120) --------------------------------------------------------
int __thiscall sub_404120(int this, int a2)
{
  int result; // eax
  int v4; // esi
  int v5; // ebx
  int v6; // eax
  bool v7; // eax
  int v8; // eax
  __int16 v9; // cx
  __int16 v10; // dx
  int v11; // ebp
  int v12; // eax
  PLAYER **v13; // ebx
  int v14; // [esp+4h] [ebp-10h]
  char buf; // [esp+8h] [ebp-Ch] BYREF
  __int16 v16; // [esp+9h] [ebp-Bh]
  __int16 v17; // [esp+Bh] [ebp-9h]
  __int16 v18; // [esp+Dh] [ebp-7h]
  __int16 v19; // [esp+Fh] [ebp-5h]

  v14 = 0;
  result = *(_DWORD *)(this + 108190);
  if ( result > 0 )
  {
    v4 = this + 99998;
    do
    {
      v5 = *(_DWORD *)v4;
      v7 = 1;
      if ( *(int *)v4 >= 0 )
      {
        v6 = *(_DWORD *)(v4 + 4);
        if ( v6 >= 0 && v5 < 1024 && v6 < 1024 )
          v7 = 0;
      }
      if ( *(_DWORD *)(v4 + 8) == -1 && (a2 || v7) )
      {
        if ( v7 )
        {
          if ( v5 == -1 || !*(_DWORD *)(this + 109758) )
          {
            v8 = *(__int16 *)(this + 109490) + *(_DWORD *)(this + 65292) * *(__int16 *)(this + 109492);
            if ( v8 >= 1024 )
              v8 = 1024;
            SomethingWithPrizes((struct ARENA *)this, v4, v4 + 4, 512, 512, v8 / 2);
          }
          else
          {
            SomethingWithPrizes(
              (struct ARENA *)this,
              v4,
              v4 + 4,
              abs32(v5),
              abs32(*(_DWORD *)(v4 + 4)),
              *(_DWORD *)(this + 109758));
          }
        }
        v9 = *(_WORD *)(v4 + 4);
        v10 = *(_WORD *)(v4 + 12);
        v17 = *(_WORD *)v4;
        v11 = 0;
        v16 = v14;
        v12 = *(_DWORD *)(this + 65292);
        buf = 18;
        v18 = v9;
        v19 = v10;
        if ( v12 > 0 )
        {
          v13 = (PLAYER **)(this + 64288);
          do
          {
            if ( !*(_DWORD *)&(*v13)->field_2C[12] )
              PlayerSendPacket(*v13, &buf, 9, 1);
            ++v11;
            ++v13;
          }
          while ( v11 < *(_DWORD *)(this + 65292) );
        }
      }
      result = v14 + 1;
      v4 += 16;
      ++v14;
    }
    while ( v14 < *(_DWORD *)(this + 108190) );
  }
  return result;
}

//----- (00404280) --------------------------------------------------------
void __thiscall CarryFlagsSomething(ARENA *arenaa, int a2, int a3)
{
  int v3; // ebx
  int v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // eax
  int v8; // ebp
  int v9; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // edx
  int v14; // eax
  int v15; // edx
  char *v16; // ecx
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+10h] [ebp-4h]

  v3 = a2;
  if ( a2 >= 0 && arenaa->field_10026[44004] )
  {
    v5 = (int)*(&ZonePlayerList + a2);
    v6 = -1;
    v7 = -1;
    if ( v5 )
    {
      v8 = *(__int16 *)(v5 + 232) / 16;
      v9 = *(__int16 *)(v5 + 228) / 16;
      if ( *(_DWORD *)&arenaa->field_10026[44188] )
      {
        v17 = 0;
        while ( 1 )
        {
          v10 = *(_DWORD *)&arenaa->field_10026[44188];
          v11 = 2 * (rand() % v10) - v10;
          if ( v11 + v8 > 1 && v11 + v8 < 1024 )
            break;
          if ( ++v17 >= 50 )
            goto LABEL_11;
        }
        v8 += v11;
LABEL_11:
        v18 = 0;
        while ( 1 )
        {
          v12 = *(_DWORD *)&arenaa->field_10026[44188];
          v13 = rand() % (2 * v12) - v12;
          if ( v13 + v9 > 1 && v13 + v9 < 1024 )
            break;
          if ( ++v18 >= 50 )
            goto LABEL_17;
        }
        v9 += v13;
      }
LABEL_17:
      v14 = v9;
      v3 = a2;
      v6 = -abs32(v8);
      v7 = -abs32(v14);
    }
    v15 = 0;
    if ( *(int *)&arenaa->field_10026[42616] > 0 )
    {
      v16 = &arenaa->field_10026[34432];
      do
      {
        if ( *(_DWORD *)v16 == v3 )
        {
          if ( !a3 )
            *((_DWORD *)v16 + 1) = -1;
          *(_DWORD *)v16 = -1;
          *((_DWORD *)v16 - 2) = v6;
          *((_DWORD *)v16 - 1) = v7;
        }
        ++v15;
        v16 += 16;
      }
      while ( v15 < *(_DWORD *)&arenaa->field_10026[42616] );
    }
  }
}

//----- (004043C0) --------------------------------------------------------
// Arena.ResetFlagGame()
void __thiscall ResetFlagGame(struct ARENA *arenaa)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  char *v5; // ecx
  int v6; // edi
  char *v7; // ecx
  char *v8; // eax
  int v9; // edx
  __int16 v10; // bp
  int v11; // ebp
  int v12; // edi
  char *v13; // ebx
  int v14; // eax
  unsigned int v15; // kr00_4
  int v16; // eax
  char *v17; // edi
  char v18; // [esp+10h] [ebp-1008h] BYREF
  __int16 v19; // [esp+11h] [ebp-1007h]
  int v20; // [esp+13h] [ebp-1005h]
  char buf; // [esp+18h] [ebp-1000h] BYREF
  char v22; // [esp+19h] [ebp-FFFh] BYREF

  v2 = 0;
  v3 = *(_DWORD *)&arenaa->field_10026[44172];
  arenaa->ArenaJackpot = 0;
  if ( v3 == 2 )
  {
    v4 = 0;
    if ( *(int *)&arenaa->field_10026[42616] > 0 )
    {
      v5 = &arenaa->field_10026[34436];
      do
      {
        *(_DWORD *)v5 = -1;
        ++v4;
        v5 += 16;
      }
      while ( v4 < *(_DWORD *)&arenaa->field_10026[42616] );
    }
    v6 = *(_DWORD *)&arenaa->field_10026[42616];
    buf = 34;
    v7 = &v22;
    if ( v6 > 0 )
    {
      v8 = &arenaa->field_10026[34436];
      v9 = v6;
      do
      {
        v10 = *(_WORD *)v8;
        v8 += 16;
        *(_WORD *)v7 = v10;
        v7 += 2;
        --v9;
      }
      while ( v9 );
    }
    v11 = 2 * v6 + 1;
    v12 = 0;
    if ( arenaa->nPlayersHere > 0 )
    {
      v13 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v13 + 56) )
          PlayerSendPacket(*(PLAYER **)v13, &buf, v11, 1);
        ++v12;
        v13 += 4;
      }
      while ( v12 < arenaa->nPlayersHere );
    }
  }
  else
  {
    v14 = *(_DWORD *)&arenaa->field_10026[44136];
    *(_DWORD *)&arenaa->field_10026[42616] = 0;
    if ( v14 && *(int *)&arenaa->field_10026[44140] > 0 )
      *(_DWORD *)arenaa->field_FF6A = rand() % *(_DWORD *)&arenaa->field_10026[44140] + 1;
    else
      *(_DWORD *)arenaa->field_FF6A = *(_DWORD *)&arenaa->field_10026[44140];
    v15 = ((int (*)(void))GetTickCount)();
    v16 = arenaa->nPlayersHere;
    v18 = 20;
    *(_DWORD *)&arenaa->field_FF10[50] = v15 / 0xA;
    v19 = -1;
    v20 = 0;
    if ( v16 > 0 )
    {
      v17 = arenaa->PlayerArray;
      do
      {
        if ( !*(_DWORD *)(*(_DWORD *)v17 + 56) )
          PlayerSendPacket(*(PLAYER **)v17, &v18, 7, 1);
        ++v2;
        v17 += 4;
      }
      while ( v2 < arenaa->nPlayersHere );
    }
  }
}
// 4DC214: invalid function type has been ignored

//----- (00404600) --------------------------------------------------------
// Arena.SendPacket()
void __thiscall ArenaSendPacket(struct ARENA *arenaa, char *buf, int len, int a4)
{
  int v5; // edi
  char *v6; // esi

  v5 = 0;
  if ( arenaa->nPlayersHere > 0 )
  {
    v6 = arenaa->PlayerArray;
    do
    {
      if ( !*(_DWORD *)(*(_DWORD *)v6 + 56) )
        PlayerSendPacket(*(PLAYER **)v6, buf, len, a4);
      ++v5;
      v6 += 4;
    }
    while ( v5 < arenaa->nPlayersHere );
  }
}

//----- (00404650) --------------------------------------------------------
void __thiscall SomethingWithPrizes(struct ARENA *arena, int ReturnXTile, int ReturnYTile, int XStart, int YStart, int Radius)
{
  int v6; // ebp
  int v7; // ebx
  int v8; // eax
  int v9; // edi
  int v10; // ebp
  struct ARENA *v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // edx
  int v25; // esi
  int v26; // ecx
  struct ARENA *v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ecx
  char *v31; // eax
  int v33; // [esp+14h] [ebp-Ch]
  int v34; // [esp+18h] [ebp-8h]
  int v35; // [esp+2Ch] [ebp+Ch]
  int v36; // [esp+30h] [ebp+10h]
  int v37; // [esp+34h] [ebp+14h]
  int v38; // [esp+34h] [ebp+14h]
  int v39; // [esp+34h] [ebp+14h]
  int v40; // [esp+34h] [ebp+14h]
  int v41; // [esp+34h] [ebp+14h]
  int v42; // [esp+34h] [ebp+14h]

  v6 = 2 * Radius;
  v7 = YStart - Radius;
  v8 = XStart - YStart;
  v34 = 0;
  v33 = 2 * Radius;
  v36 = YStart - Radius;
  v35 = v8;
  while ( 1 )
  {
    v9 = (v7 + v8 < 0 ? 0 : v7 + v8) + rand() % v6;
    v10 = (v7 < 0 ? 0 : v7) + rand() % v6;
    if ( v9 < 0 || v10 < 0 || v9 >= 1024 || v10 >= 1024 )
    {
      v11 = arena;
      v37 = 1;
    }
    else
    {
      v11 = arena;
      v37 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v10 << 10) + v9);
    }
    v12 = v9 + 1;
    if ( v9 + 1 < 0 || v10 < 0 || v12 >= 1024 || v10 >= 1024 )
      v13 = 1;
    else
      v13 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v10 << 10) + v12);
    v14 = v13 + v37;
    v15 = v9 - 1;
    if ( v9 - 1 < 0 || v10 < 0 || v15 >= 1024 || v10 >= 1024 )
      v16 = 1;
    else
      v16 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v10 << 10) + v15);
    v38 = v16 + v14;
    v17 = v10 + 1;
    if ( v9 < 0 || v17 < 0 || v9 >= 1024 || v17 >= 1024 )
      v18 = 1;
    else
      v18 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v17 << 10) + v9);
    v19 = v18 + v38;
    v20 = v10 - 1;
    if ( v9 < 0 || v20 < 0 || v9 >= 1024 || v20 >= 1024 )
      v21 = 1;
    else
      v21 = *(unsigned __int8 *)(*(_DWORD *)&v11->field_1B8DE[6956] + (v20 << 10) + v9);
    v39 = v21 + v19;
    if ( v12 < 0 || v17 < 0 || v12 >= 1024 || v17 >= 1024 )
      v22 = 1;
    else
      v22 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v17 << 10) + v12);
    v40 = v22 + v39;
    if ( v12 < 0 || v20 < 0 || v12 >= 1024 || v20 >= 1024 )
      v23 = 1;
    else
      v23 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v20 << 10) + v12);
    v24 = v23 + v40;
    v25 = v9 - 1;
    if ( v9 - 1 < 0 || v17 < 0 || v25 >= 1024 || v17 >= 1024 )
      v26 = 1;
    else
      v26 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v17 << 10) + v25);
    v41 = v26 + v24;
    if ( v25 < 0 || v20 < 0 || v25 >= 1024 || v20 >= 1024 )
    {
      v27 = arena;
      v28 = 1;
    }
    else
    {
      v27 = arena;
      v28 = *(unsigned __int8 *)(*(_DWORD *)&arena->field_1B8DE[6956] + (v20 << 10) + v25);
    }
    v29 = *(_DWORD *)&v27->field_10026[42616];
    v42 = v28 + v41;
    v30 = 0;
    if ( v29 > 0 )
    {
      v31 = &v27->field_10026[34428];
      while ( *((_DWORD *)v31 - 1) != v9 || *(_DWORD *)v31 != v10 )
      {
        ++v30;
        v31 += 16;
        if ( v30 >= v29 )
          goto LABEL_64;
      }
      ++v42;
    }
LABEL_64:
    if ( !v42 )
      v34 = 1;
    v7 = --v36;
    v33 += 2;
    if ( v34 )
      break;
    v8 = v35;
    v6 = v33;
  }
  *(_DWORD *)ReturnXTile = v9;
  *(_DWORD *)ReturnYTile = v10;
}

//----- (00404980) --------------------------------------------------------
void __thiscall sub_404980(char *this, int a2, int a3, int a4)
{
  int v4; // eax
  char *v5; // esi
  int v6; // ecx
  char *i; // edx
  int v8; // ecx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = 0;
    v5 = &this[8032 * a3 + 1004 * a4];
    v6 = *((_DWORD *)v5 + 250);
    if ( v6 > 0 )
    {
      for ( i = v5; *(_DWORD *)i != a2; i += 4 )
      {
        if ( ++v4 >= v6 )
          return;
      }
      v8 = v6 - 1;
      *((_DWORD *)v5 + 250) = v8;
      *(_DWORD *)&v5[4 * v4] = *(_DWORD *)&v5[4 * v8];
    }
  }
}

//----- (004049F0) --------------------------------------------------------
void __thiscall AddPlayerToArenaSomething(struct ARENA *arena, struct PLAYER *player, signed int a3, signed int a4)
{
  int v4; // eax
  char *v5; // edx

  if ( a3 >= 0 && a4 >= 0 && a3 < 8 && a4 < 8 )
  {
    v4 = a4 + 8 * a3;
    v5 = &arena->field_0[1004 * v4 + 1000];
    *(_DWORD *)&arena->field_0[1004 * v4 + 4 * (*(_DWORD *)v5)++] = player;
  }
}

//----- (00404A50) --------------------------------------------------------
void __thiscall LoadArenaSettings_0_0(struct ARENA *arenaa)
{
  char *v2; // esi
  int v3; // eax
  int v4; // esi

  v2 = arenaa->szConfigFile;
  if ( _strcmpi(arenaa->szConfigFile, Filename) )
  {
    IsFileLastWrittenTime(v2, (int)arenaa->dwLastConfigReadTime);
    LoadArenaSettings(
      (struct_ArenaSettings *)&arenaa->field_10026[42620],
      (struct_ArenaSettings *)&arenaa->field_10026[44048],
      v2);
  }
  else
  {
    qmemcpy(&arenaa->field_10026[42620], &unk_439430, 0x594u);
    qmemcpy(&arenaa->field_10026[44048], &FileName, 0x4B8u);
  }
  v3 = 0;
  *(_DWORD *)&arenaa->dwLastConfigReadTime[8] = (*(__int16 *)&arenaa->field_10026[43894] << 14) / 96;
  *(_DWORD *)&arenaa->dwLastConfigReadTime[4] = 0;
  do
  {
    v4 = (unsigned __int8)arenaa->field_10026[v3 + 44019] + *(_DWORD *)&arenaa->dwLastConfigReadTime[4];
    ++v3;
    *(_DWORD *)&arenaa->dwLastConfigReadTime[4] = v4;
  }
  while ( v3 < 29 );
}

//----- (00404B10) --------------------------------------------------------
void __thiscall SomethingThatLoadsZoneMap(struct_ARENA *this)
{
  const char *v2; // ebx
  int v3; // esi
  struct BMP_FILE_STRUCT *v4; // edi
  int v5; // ebx
  int v6; // eax
  struct BMP_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct BMP_FILE_STRUCT *v9; // esi
  void *v10; // edi
  int v11; // edi
  int v12; // ebx
  int v13; // ecx
  unsigned int v14; // edx
  int j; // edi
  int k; // esi
  int v17; // ecx
  int v18; // eax
  _BYTE *v19; // eax
  int v20; // [esp+10h] [ebp-2Ch] BYREF
  int TileValuePointer; // [esp+14h] [ebp-28h] BYREF
  struct BMP_FILE_STRUCT *i; // [esp+18h] [ebp-24h]
  int Buffer[4]; // [esp+1Ch] [ebp-20h] BYREF
  char v24; // [esp+2Ch] [ebp-10h]
  int v25; // [esp+38h] [ebp-4h]

  v2 = (char *)this + 111086;
  if ( _strcmpi(&aMisc_DefaultLevelFile, (const char *)this + 111086) )
  {
    Buffer[0] = 42;
    Buffer[1] = 0;
    Buffer[2] = 0;
    Buffer[3] = 0;
    v24 = 0;
    strcpy((char *)Buffer + 1, v2);
    *(_DWORD *)((char *)this + 111610) = CompressFile(
                                           v2,
                                           (int *)((char *)this + 111614),
                                           (int *)((char *)this + 111618),
                                           Buffer,
                                           0x11u,
                                           1,
                                           0);
    v7 = (struct BMP_FILE_STRUCT *)operator new(0x110u);
    i = v7;
    v25 = 0;
    if ( v7 )
    {
      LoadBMPHeader(v7, v2);
      v9 = (struct BMP_FILE_STRUCT *)v8;
      TileValuePointer = v8;
    }
    else
    {
      TileValuePointer = 0;
      v9 = 0;
    }
    v25 = -1;
    *(_DWORD *)((char *)this + 119814) = 0;
    v10 = emalloc(0x100000);
    *(_DWORD *)((char *)this + 119818) = v10;
    memset(v10, 0, 0x100000u);
    v11 = sub_406BE0(v9);
    v12 = 0;
    for ( i = (struct BMP_FILE_STRUCT *)v11; v12 < v11; ++v12 )
    {
      GetTileValue(v9, v12, &v20);
      if ( (v20 & 0xFF000000) == -1442840576 )
      {
        v13 = *(_DWORD *)((char *)this + 119814);
        if ( v13 < 510 )
        {
          *(_DWORD *)((char *)this + 16 * v13 + 111622) = v20 & 0xFFF;
          *(_DWORD *)((char *)this + 16 * (*(_DWORD *)((char *)this + 119814))++ + 111626) = ((unsigned int)v20 >> 12) & 0xFFF;
        }
      }
      else
      {
        *(_BYTE *)((v20 & 0xFFF) + ((((unsigned int)v20 >> 12) & 0xFFF) << 10) + *(_DWORD *)((char *)this + 119818)) = HIBYTE(v20);
        v14 = v20;
        if ( (v20 & 0xFF000000) >= 0xD8000000 )
        {
          for ( j = 0; j < 7; ++j )
          {
            for ( k = 0; k < 7; ++k )
            {
              v17 = j + (v14 & 0xFFF);
              v18 = k + ((v14 >> 12) & 0xFFF);
              if ( v17 < 1024 && v18 < 1024 )
              {
                v19 = (_BYTE *)(*(_DWORD *)((char *)this + 119818) + v17 + (v18 << 10));
                if ( !*v19 )
                {
                  *v19 = -16;
                  v14 = v20;
                }
              }
            }
          }
          v11 = (int)i;
          v9 = (struct BMP_FILE_STRUCT *)TileValuePointer;
        }
      }
    }
    if ( v9 )
    {
      sub_406B30((int)v9);
      operator delete(v9);
    }
  }
  else
  {
    v3 = 0;
    *(_DWORD *)((char *)this + 111610) = dword_438DFC;
    *(_DWORD *)((char *)this + 111614) = dword_4D9DE0;
    *(_DWORD *)((char *)this + 111618) = dword_4399E8;
    *(_DWORD *)((char *)this + 119818) = big_global_buffer;
    *(_DWORD *)((char *)this + 119814) = 0;
    v4 = BMPFile;
    v5 = sub_406BE0(BMPFile);
    if ( v5 > 0 )
    {
      do
      {
        GetTileValue(v4, v3, &TileValuePointer);
        if ( (TileValuePointer & 0xFF000000) == -1442840576 )
        {
          v6 = *(_DWORD *)((char *)this + 119814);
          if ( v6 < 510 )
          {
            *(_DWORD *)((char *)this + 16 * v6 + 111622) = TileValuePointer & 0xFFF;
            *(_DWORD *)((char *)this + 16 * (*(_DWORD *)((char *)this + 119814))++ + 111626) = ((unsigned int)TileValuePointer >> 12) & 0xFFF;
          }
        }
        ++v3;
      }
      while ( v3 < v5 );
    }
  }
}
// 404C9E: variable 'v8' is possibly undefined
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4399E8: using guessed type int dword_4399E8;
// 4D9DE0: using guessed type int dword_4D9DE0;

//----- (00404E20) --------------------------------------------------------
int __thiscall GetDeathPrizeGreenId(ARENA *arenaa)
{
  int v2; // edx
  int v3; // ecx
  int v4; // esi
  int result; // eax
  int v6; // edx

  v2 = rand() % *(_DWORD *)&arenaa->dwLastConfigReadTime[4];
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    if ( arenaa->field_10026[v4 + 44019] )
    {
      if ( v2 >= v3 )
      {
        v3 += (unsigned __int8)arenaa->field_10026[v4 + 44019];
        if ( v2 < v3 )
          break;
      }
    }
    if ( ++v4 >= 29 )
      return 0;
  }
  v6 = rand() % *(__int16 *)&arenaa->field_10026[43924];
  result = v4;
  if ( !v6 )
    result = -v4;
  return result;
}

//----- (00404E80) --------------------------------------------------------
signed int __thiscall ChangeSettings(ARENA *arenaa, PLAYER *player, const CHAR *a3)
{
  const CHAR *v3; // eax
  CHAR v4; // cl
  CHAR *i; // edx
  CHAR v6; // cl
  CHAR v8; // cl
  const CHAR *v9; // eax
  CHAR *j; // edx
  CHAR v11; // cl
  int v12; // ebp
  int v13; // edi
  int v14; // ebx
  char *v15; // esi
  char *v16; // esi
  int v17; // [esp+10h] [ebp-514h]
  int v18; // [esp+14h] [ebp-510h]
  int v20; // [esp+1Ch] [ebp-508h]
  int v21; // [esp+20h] [ebp-504h]
  char v22[256]; // [esp+24h] [ebp-500h] BYREF
  CHAR KeyName[256]; // [esp+124h] [ebp-400h] BYREF
  CHAR String[256]; // [esp+224h] [ebp-300h] BYREF
  CHAR AppName[256]; // [esp+324h] [ebp-200h] BYREF
  char a2[256]; // [esp+424h] [ebp-100h] BYREF

  v3 = a3;
  v4 = *a3;
  for ( i = AppName; v4; ++v3 )
  {
    if ( v4 == 58 )
      break;
    *i = v4;
    v4 = v3[1];
    ++i;
  }
  v6 = *v3;
  *i = 0;
  if ( !v6 )
    return 1;
  v8 = v3[1];
  v9 = v3 + 1;
  for ( j = KeyName; v8; ++v9 )
  {
    if ( v8 == 58 )
      break;
    *j = v8;
    v8 = v9[1];
    ++j;
  }
  v11 = *v9;
  *j = 0;
  if ( !v11 )
    return 1;
  v12 = 0;
  strcpy(String, v9 + 1);
  if ( !player->bIsSysop )
  {
    strcpy(v22, AppName);
    if ( !_strcmpi(v22, "Warbird")
      || !_strcmpi(v22, "Javelin")
      || !_strcmpi(v22, "Spider")
      || !_strcmpi(v22, "Leviathan")
      || !_strcmpi(v22, "Weasel")
      || !_strcmpi(v22, "Terrier")
      || !_strcmpi(v22, "Lancaster")
      || !_strcmpi(v22, "Shark") )
    {
      strcpy(v22, "All");
    }
    v18 = 0;
    v20 = 0;
    v17 = atoi(String);
    v21 = 0;
    if ( dword_4D9DD4 <= 0 )
    {
      v13 = v17;
      v14 = v17;
    }
    else
    {
      v13 = v17;
      v14 = v17;
      v15 = dword_439E70;
      while ( 1 )
      {
        if ( (!_strcmpi(v15, v22) || !_strcmpi(v15, AppName)) && !_strcmpi(v15 + 32, KeyName) && !v15[336] )
        {
          v13 = *((_DWORD *)v15 + 18);
          v14 = *((_DWORD *)v15 + 19);
          v12 = 1;
          v18 = v15[337];
          if ( v13 == -999 || v17 >= v13 && v17 <= v14 )
            break;
        }
        v15 += 338;
        if ( ++v21 >= dword_4D9DD4 )
          goto LABEL_34;
      }
      v20 = 1;
    }
LABEL_34:
    if ( !v12 )
    {
      sprintf(a2, "%s:%s is not a valid user parameter.", AppName, KeyName);
      SendMessage(player, a2, 0);
      return 1;
    }
    if ( !v20 )
    {
      sprintf(a2, "Valid range for parameter %s:%s is (%d through %d)", AppName, KeyName, v13, v14);
      SendMessage(player, a2, 0);
      return 1;
    }
    if ( v18 )
    {
      *(_DWORD *)arenaa->field_10026 = 1;
      if ( !_strcmpi(arenaa->szConfigFile, Filename) )
        bRecycleServer = 1;
    }
  }
  *(_DWORD *)arenaa->gap_FF08 = 1;
  v16 = arenaa->szConfigFile;
  if ( !_strcmpi(arenaa->szConfigFile, Filename) )
    dword_4D6C10 = 1;
  if ( _strcmpi(AppName, "All") )
  {
    WritePrivateProfileStringA(AppName, KeyName, String, v16);
  }
  else
  {
    WritePrivateProfileStringA("Warbird", KeyName, String, v16);
    WritePrivateProfileStringA("Javelin", KeyName, String, v16);
    WritePrivateProfileStringA("Spider", KeyName, String, v16);
    WritePrivateProfileStringA("Leviathan", KeyName, String, v16);
    WritePrivateProfileStringA("Terrier", KeyName, String, v16);
    WritePrivateProfileStringA("Weasel", KeyName, String, v16);
    WritePrivateProfileStringA("Lancaster", KeyName, String, v16);
    WritePrivateProfileStringA("Shark", KeyName, String, v16);
  }
  return 0;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4332F4: using guessed type int bRecycleServer;
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9DD4: using guessed type int dword_4D9DD4;

//----- (00405360) --------------------------------------------------------
int __thiscall sub_405360(int this, int a2)
{
  ArenaScoreReset((struct ARENA *)this, a2);
  *(_DWORD *)(this + 65594) = 0;
  *(_DWORD *)(this + 65350) = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)(this + 65312) = 0;
  return SoccerGameSomething((ARENA *)this, -1);
}
// 4DC214: invalid function type has been ignored

//----- (004053B0) --------------------------------------------------------
int __thiscall SoccerGameSomething(ARENA *this, int a2)
{
  char *v3; // ebx
  int v4; // eax
  char *v5; // ecx
  int v6; // esi
  int v7; // eax
  int result; // eax
  char *v9; // esi
  int v10; // ecx
  int v11; // edi
  char *v12; // ebx
  int v13; // [esp+10h] [ebp-118h]
  char *v14; // [esp+10h] [ebp-118h]
  int v15; // [esp+14h] [ebp-114h]
  char buf; // [esp+18h] [ebp-110h] BYREF
  int v17; // [esp+19h] [ebp-10Fh]
  int v18; // [esp+1Dh] [ebp-10Bh]
  int v19; // [esp+21h] [ebp-107h]
  __int16 v20; // [esp+25h] [ebp-103h]
  char v21; // [esp+27h] [ebp-101h]
  char a2a[256]; // [esp+28h] [ebp-100h] BYREF

  if ( a2 >= 0 )
  {
    v13 = 0;
    if ( this->nPlayersHere > 0 )
    {
      v3 = this->PlayerArray;
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)v3 + 279) == a2 && *(int *)(*(_DWORD *)v3 + 216) > 0 )
        {
          sprintf(a2a, "Soccer game over.  Personal Reward: %d", *(_DWORD *)(*(_DWORD *)v3 + 216));
          UpdatePoints(*(struct PLAYER **)v3, 0, *(_DWORD *)(*(_DWORD *)v3 + 216));
        }
        else
        {
          strcpy(a2a, "Soccer game over.");
        }
        SendMessage(*(struct PLAYER **)v3, a2a, 103);
        if ( !SendPlayerScoreUpdateAll(*(void **)v3) )
          SendPlayerScoreUpdate(*(struct PLAYER **)v3);
        v3 += 4;
        ++v13;
      }
      while ( v13 < this->nPlayersHere );
    }
  }
  v4 = 0;
  if ( this->nPlayersHere > 0 )
  {
    v5 = this->PlayerArray;
    do
    {
      v6 = *(_DWORD *)v5;
      ++v4;
      v5 += 4;
      *(_DWORD *)(v6 + 216) = 0;
    }
    while ( v4 < this->nPlayersHere );
  }
  *(_DWORD *)&this->field_FF6A[160] = 0;
  *(_DWORD *)&this->field_FF6A[164] = 0;
  *(_DWORD *)&this->field_FF6A[168] = 0;
  *(_DWORD *)&this->field_FF6A[172] = 0;
  v7 = *(_DWORD *)&this->field_10026[44372];
  if ( v7 > 0 )
  {
    *(_DWORD *)&this->field_FF6A[160] = v7;
    *(_DWORD *)&this->field_FF6A[164] = v7;
    *(_DWORD *)&this->field_FF6A[168] = v7;
    *(_DWORD *)&this->field_FF6A[172] = v7;
  }
  result = 0;
  v15 = 0;
  if ( *(int *)&this->field_FF6A[4] > 0 )
  {
    v9 = &this->field_FF6A[11];
    v14 = &this->field_FF6A[128];
    do
    {
      *(v9 - 3) = result;
      *((_WORD *)v9 - 1) = 0;
      *(_WORD *)v9 = 0;
      *((_WORD *)v9 + 1) = 0;
      *((_WORD *)v9 + 2) = 0;
      *((_WORD *)v9 + 3) = -1;
      *((_DWORD *)v9 + 2) = 0;
      *(_DWORD *)v14 = 0;
      v17 = *(_DWORD *)(v9 - 3);
      v18 = *(_DWORD *)(v9 + 1);
      v19 = *(_DWORD *)(v9 + 5);
      v20 = *(_WORD *)(v9 + 9);
      v21 = v9[11];
      v10 = this->nPlayersHere;
      v11 = 0;
      buf = 46;
      if ( v10 > 0 )
      {
        v12 = this->PlayerArray;
        do
        {
          if ( !*(_DWORD *)(*(_DWORD *)v12 + 56) )
            PlayerSendPacket(*(PLAYER **)v12, &buf, 16, 1);
          ++v11;
          v12 += 4;
        }
        while ( v11 < this->nPlayersHere );
        result = v15;
      }
      ++result;
      v9 += 15;
      v15 = result;
      v14 += 4;
    }
    while ( result < *(_DWORD *)&this->field_FF6A[4] );
  }
  *(_DWORD *)&this->field_FF6A[4] = 0;
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004055D0) --------------------------------------------------------
int __thiscall SoccerGame2(ARENA *arenaa, int Frequency, int a3, int a4)
{
  int v5; // edi
  int v6; // ebx
  int v7; // ebp
  int result; // eax
  int v9; // eax
  int v10; // edi
  char *v11; // ebx
  char *i; // ecx
  int v13; // edx
  int v14; // ecx
  char *v15; // ecx

  v5 = -1;
  v6 = -1;
  v7 = 0;
  result = SoccerRelatedMath((unsigned __int8)arenaa->field_10026[43992], a3, a4);
  switch ( arenaa->field_10026[43992] )
  {
    case 1:
    case 2:
      v7 = 2;
      v5 = Frequency & 1;
      v6 = result;
      break;
    case 3:
    case 5:
      v7 = 4;
      v5 = Frequency & 3;
      v6 = result;
      break;
    case 4:
    case 6:
      v7 = 4;
      v5 = Frequency & 3;
      switch ( Frequency & 3 )
      {
        case 0:
          v6 = 3;
          break;
        case 1:
          v6 = 2;
          break;
        case 2:
          v6 = 1;
          break;
        case 3:
          v6 = 0;
          break;
        default:
          goto LABEL_9;
      }
      break;
    default:
      break;
  }
LABEL_9:
  if ( v5 >= 0 )
  {
    result = *(_DWORD *)&arenaa->field_10026[44372];
    if ( result <= 0 )
    {
      if ( result < 0 )
      {
        ++*(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
        GetScore(arenaa, 0);
        result = *(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
        if ( result >= -*(_DWORD *)&arenaa->field_10026[44372] )
        {
          v13 = *(_DWORD *)&arenaa->field_10026[44380];
          v14 = 1;
          if ( v13 > 0 )
          {
            result = 0;
            if ( v7 > 0 )
            {
              v15 = &arenaa->field_FF6A[160];
              while ( result == v5 || *(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160] - *(_DWORD *)v15 >= v13 )
              {
                ++result;
                v15 += 4;
                if ( result >= v7 )
                {
                  v14 = 1;
                  goto LABEL_33;
                }
              }
              v14 = 0;
            }
          }
LABEL_33:
          if ( v14 )
            return SoccerGameSomething(arenaa, Frequency);
        }
      }
    }
    else
    {
      v9 = *(_DWORD *)&arenaa->field_FF6A[4 * v6 + 160];
      if ( v9 )
      {
        *(_DWORD *)&arenaa->field_FF6A[4 * v6 + 160] = v9 - 1;
        ++*(_DWORD *)&arenaa->field_FF6A[4 * v5 + 160];
      }
      else
      {
        v10 = 0;
        if ( arenaa->nPlayersHere > 0 )
        {
          v11 = arenaa->PlayerArray;
          do
          {
            SendMessage(*(struct PLAYER **)v11, "Enemy goal had no points to give.", 0);
            ++v10;
            v11 += 4;
          }
          while ( v10 < arenaa->nPlayersHere );
        }
      }
      GetScore(arenaa, 0);
      result = 0;
      if ( v7 > 0 )
      {
        for ( i = &arenaa->field_FF6A[160]; *(_DWORD *)i != *(_DWORD *)&arenaa->field_10026[44372] * v7; i += 4 )
        {
          if ( ++result >= v7 )
            return result;
        }
        return SoccerGameSomething(arenaa, Frequency);
      }
    }
  }
  return result;
}

//----- (004057C0) --------------------------------------------------------
void __thiscall GetScore(ARENA *arenaa, int a2)
{
  char v3; // al
  int v4; // ebx
  char *v5; // esi
  struct PLAYER *v6; // ecx
  int v7; // [esp-8h] [ebp-214h]
  char *v8; // [esp-8h] [ebp-214h]
  int v9; // [esp-4h] [ebp-210h]
  char v10[256]; // [esp+Ch] [ebp-200h] BYREF
  char a2a[256]; // [esp+10Ch] [ebp-100h] BYREF

  if ( *(int *)&arenaa->field_10026[44360] > 0 && *(_DWORD *)&arenaa->field_10026[44372] )
  {
    v3 = arenaa->field_10026[43992];
    if ( v3 == 1 || v3 == 2 )
    {
      v9 = *(_DWORD *)&arenaa->field_FF6A[164];
      v7 = *(_DWORD *)&arenaa->field_FF6A[160];
      if ( *(_DWORD *)&arenaa->field_10026[44200] )
        sprintf(v10, "SCORE: Warbirds:%d  Javelins:%d", v7, v9);
      else
        sprintf(v10, "SCORE: Evens:%d  Odds:%d", v7, v9);
    }
    else if ( *(_DWORD *)&arenaa->field_10026[44200] )
    {
      sprintf(
        v10,
        "SCORE: Warbirds:%d  Javelins:%d  Spiders:%d  Leviathans:%d",
        *(_DWORD *)&arenaa->field_FF6A[160],
        *(_DWORD *)&arenaa->field_FF6A[164],
        *(_DWORD *)&arenaa->field_FF6A[168],
        *(_DWORD *)&arenaa->field_FF6A[172]);
    }
    else
    {
      sprintf(
        v10,
        "SCORE: Team0:%d  Team1:%d  Team2:%d  Team3:%d",
        *(_DWORD *)&arenaa->field_FF6A[160],
        *(_DWORD *)&arenaa->field_FF6A[164],
        *(_DWORD *)&arenaa->field_FF6A[168],
        *(_DWORD *)&arenaa->field_FF6A[172]);
    }
    if ( a2 )
    {
      if ( *(int *)(a2 + 216) <= 0 )
      {
        SendMessage((struct PLAYER *)a2, v10, 0);
      }
      else
      {
        sprintf(a2a, "%s  REWARD:%d", v10, *(_DWORD *)(a2 + 216));
        SendMessage((struct PLAYER *)a2, a2a, 0);
      }
    }
    else
    {
      v4 = 0;
      if ( arenaa->nPlayersHere > 0 )
      {
        v5 = arenaa->PlayerArray;
        do
        {
          v6 = *(struct PLAYER **)v5;
          if ( *(int *)(*(_DWORD *)v5 + 216) <= 0 )
          {
            v8 = v10;
          }
          else
          {
            sprintf(a2a, "%s  REWARD:%d", v10, *(_DWORD *)(*(_DWORD *)v5 + 216));
            v8 = a2a;
            v6 = *(struct PLAYER **)v5;
          }
          SendMessage(v6, v8, 0);
          ++v4;
          v5 += 4;
        }
        while ( v4 < arenaa->nPlayersHere );
      }
    }
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00405970) --------------------------------------------------------
unsigned int __thiscall GetArenaMemoryTotal(ARENA *arena)
{
  int v1; // edx

  v1 = 117;
  if ( *(_DWORD *)&arena->field_1B8DE[6956] != big_global_buffer )
    v1 = 1317;
  return v1 + ((unsigned int)(18 * *(_DWORD *)&arena->field_10026[18028]) >> 10);
}

//----- (004059A0) --------------------------------------------------------
int __thiscall GetTotalPlayingPlayers(ARENA *arena)
{
  int v1; // edx
  int result; // eax
  char *v3; // ecx

  v1 = arena->nPlayersHere;
  result = 0;
  if ( v1 > 0 )
  {
    v3 = arena->PlayerArray;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v3 + offsetof(PLAYER, dwShip)) != 8 )
        ++result;
      v3 += 4;
      --v1;
    }
    while ( v1 );
  }
  return result;
}

//----- (004059D0) --------------------------------------------------------
void __thiscall sub_4059D0(int *this, int a2, char *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  char v9[176]; // [esp+8h] [ebp-B0h] BYREF

  *this = a8;
  this[1] = a9;
  memset(v9, 0, 0xACu);
  v9[172] = 0;
  this[3] = a2;
  this[5] = 0;
  v9[0] = 2;
  strncpy(&v9[13], a3, 0x80u);
  v9[140] = 0;
  JUMPOUT(0x415940);
}
// 405A45: control flows out of bounds to 415940

//----- (00405AB0) --------------------------------------------------------
int __thiscall CleanUpBilling(BILLING_SERVER_STRUCT *billingServerStruct)
{
  struct CONNECTION *v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  char buf; // [esp+1h] [ebp-1h] BYREF

  buf = HIBYTE(billingServerStruct);
  v2 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
  buf = 3;
  WriteData(v2, &buf, 1u, 1);
  v3 = ((int (*)(void))GetTickCount)() / 0xAu;
  for ( result = GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0);
        result > 0;
        result = GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0) )
  {
    result = abs32(((int (*)(void))GetTickCount)() / 0xAu - v3);
    if ( result >= 800 )
      break;
    PlayerDoNetworkOps(*(struct_v9 **)billingServerStruct);
  }
  return result;
}
// 4DC214: invalid function type has been ignored

//----- (00405B30) --------------------------------------------------------
void __thiscall SendBillerUserBannerPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const void *a3)
{
  char buf; // [esp+0h] [ebp-68h] BYREF
  int v4; // [esp+1h] [ebp-67h]
  char v5[96]; // [esp+5h] [ebp-63h] BYREF

  if ( a2 >= 0 )
  {
    v4 = a2;
    buf = 16;
    qmemcpy(v5, a3, sizeof(v5));
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, 0x65u, 1);
  }
}

//----- (00405B70) --------------------------------------------------------
void __thiscall SendBillerUserDemographicsPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  struct CONNECTION *v4; // ecx
  char buf; // [esp+0h] [ebp-304h] BYREF
  int v6; // [esp+1h] [ebp-303h]
  char v7[767]; // [esp+5h] [ebp-2FFh] BYREF

  if ( a1 >= 0 )
  {
    v6 = a1;
    buf = 13;
    qmemcpy(v7, (const void *)a2, 0x2FCu);
    v4 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
    v7[764] = *(_BYTE *)(a2 + 764);
    WriteData(v4, &buf, 0x302u, 1);
  }
}
// 405B70: inconsistent function type and number of purged bytes

//----- (00405BC0) --------------------------------------------------------
void __thiscall SendBillerUnknownPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const char *a3)
{
  char buf; // [esp+10h] [ebp-9h] BYREF
  int v5; // [esp+11h] [ebp-8h]
  int v6; // [esp+15h] [ebp-4h]
  char v7[2039]; // [esp+19h] [ebp+0h] BYREF

  v5 = a1;
  v6 = a2;
  buf = 14;
  strcpy(v7, a3);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(a3) + 10, 1);
}

//----- (00405C40) --------------------------------------------------------
void __thiscall SendBillerUserChannelChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *ChannelName, const char *ChatText)
{
  char buf; // [esp+4h] [ebp-800h] BYREF
  int v6; // [esp+5h] [ebp-7FFh]
  char v7[32]; // [esp+9h] [ebp-7FBh] BYREF
  char v8[2011]; // [esp+29h] [ebp-7DBh] BYREF

  if ( PlayerId >= 0 )
  {
    v6 = PlayerId;
    buf = 20;
    strncpy(v7, ChannelName, 0x20u);
    v7[31] = 0;
    strcpy(v8, ChatText);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(ChatText) + 38, 1);
  }
}

//----- (00405CD0) --------------------------------------------------------
void __thiscall SendBillerWarningPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const char *WarningMessage)
{
  char buf; // [esp+4h] [ebp-400h] BYREF
  int v4; // [esp+5h] [ebp-3FFh]
  char v5[1019]; // [esp+9h] [ebp-3FBh] BYREF

  if ( PlayerId >= 0 )
  {
    v4 = PlayerId;
    buf = 15;
    strcpy(v5, WarningMessage);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(WarningMessage) + 6, 1);
  }
}

//----- (00405D50) --------------------------------------------------------
void __thiscall biller_user_command(struct BILLING_SERVER_STRUCT *billingServerStruct, int a2, const char *UserCommand)
{
  char buf; // [esp+4h] [ebp-400h] BYREF
  int v4; // [esp+5h] [ebp-3FFh]
  char v5[1019]; // [esp+9h] [ebp-3FBh] BYREF

  if ( a2 >= 0 )
  {
    v4 = a2;
    buf = 0x13;
    strcpy(v5, UserCommand);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, strlen(UserCommand) + 6, 1);
  }
}

//----- (00405E70) --------------------------------------------------------
void __thiscall SendBillerUserLogoffPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, __int16 DisconnectReason, __int16 Latency, __int16 Ping, __int16 S2CPacketLoss, __int16 C2SPacketLoss, const void *PlayerScore, unsigned int ExtraSize)
{
  unsigned int v9; // eax
  char buf; // [esp+0h] [ebp-400h] BYREF
  int v11; // [esp+1h] [ebp-3FFh]
  __int16 v12; // [esp+5h] [ebp-3FBh]
  __int16 v13; // [esp+7h] [ebp-3F9h]
  __int16 v14; // [esp+9h] [ebp-3F7h]
  __int16 v15; // [esp+Bh] [ebp-3F5h]
  __int16 v16; // [esp+Dh] [ebp-3F3h]
  char v17[1009]; // [esp+Fh] [ebp-3F1h] BYREF

  if ( PlayerId >= 0 )
  {
    v11 = PlayerId;
    v12 = DisconnectReason;
    v13 = Latency;
    v14 = Ping;
    buf = 5;
    v16 = C2SPacketLoss;
    v15 = S2CPacketLoss;
    v9 = 15;
    if ( PlayerScore )
    {
      qmemcpy(v17, PlayerScore, ExtraSize);
      v9 = ExtraSize + 15;
    }
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, v9, 1);
  }
}

//----- (00405F20) --------------------------------------------------------
void __thiscall SendBillerUserScorePacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, const void *Score, unsigned int Size)
{
  char buf; // [esp+0h] [ebp-400h] BYREF
  int v5; // [esp+1h] [ebp-3FFh]
  char v6[1019]; // [esp+5h] [ebp-3FBh] BYREF

  if ( PlayerId >= 0 )
  {
    v5 = PlayerId;
    buf = 17;
    qmemcpy(v6, Score, Size);
    WriteData(*((struct CONNECTION **)billingServerStruct + 1), &buf, Size + 5, 1);
  }
}

//----- (00405F80) --------------------------------------------------------
void __thiscall SendBillerPlayerNamePacketSomething(struct BILLING_SERVER_STRUCT *billingServerStruct, int a1, int a2, const void *a3, unsigned int len)
{
  char *v6; // ebx
  unsigned int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = (char *)emalloc(lena);
  qmemcpy(v6 + 9, a3, len);
  *(_DWORD *)(v6 + 5) = a2;
  *v6 = 6;
  *(_DWORD *)(v6 + 1) = a1;
  qmemcpy(v6 + 9, a3, len);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), v6, lena, 1);
  efree(v6);
}

//----- (00406010) --------------------------------------------------------
void __thiscall SendBillerUserPrivateChatPacket(struct BILLING_SERVER_STRUCT *billingServerStruct, int PlayerId, int BillingGroupId, const void *a4, unsigned int len)
{
  char *v6; // ebx
  int buf_sz; // [esp+24h] [ebp+10h]

  buf_sz = len + 9;
  v6 = (char *)emalloc(buf_sz);
  qmemcpy(v6 + 9, a4, len);
  *(_DWORD *)(v6 + 5) = BillingGroupId;
  *v6 = 7;
  *(_DWORD *)(v6 + 1) = PlayerId;
  qmemcpy(v6 + 9, a4, len);
  WriteData(*((struct CONNECTION **)billingServerStruct + 1), v6, buf_sz, 1);
  efree(v6);
}

//----- (004060A0) --------------------------------------------------------
void __thiscall SendBillerZoneRevokePermitPacket(struct CONNECTION **this, int buf, int a3, int a4, int len)
{
  char *v6; // ebx
  int lena; // [esp+24h] [ebp+10h]

  lena = len + 9;
  v6 = (char *)emalloc(lena);
  qmemcpy(v6 + 9, (const void *)a4, len);
  *(_DWORD *)(v6 + 5) = a3;
  *v6 = 18;
  *(_DWORD *)(v6 + 1) = buf;
  qmemcpy(v6 + 9, (const void *)a4, len);
  WriteData(this[1], v6, lena, 1);
  efree(v6);
}

//----- (00406130) --------------------------------------------------------
int __thiscall GetBillerLastReconnectTime(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 58);
}

//----- (00406140) --------------------------------------------------------
signed int __usercall IsBillingServerDisconnected@<eax>(BILLING_SERVER_STRUCT *billingServerStruct@<ecx>, int a2@<ebp>)
{
  __int64 v3; // rax
  unsigned int v4; // eax
  struct CONNECTION *v5; // ecx
  int i; // eax
  void (__cdecl *v7)(int, int); // ecx
  char buf; // [esp+Bh] [ebp-9h] BYREF
  int v10; // [esp+Ch] [ebp-8h] BYREF
  char v11[4]; // [esp+10h] [ebp-4h] BYREF

  if ( sub_41C510(*((_DWORD *)billingServerStruct + 1)) != 2
    || GetRelAckDiff(*((struct CONNECTION **)billingServerStruct + 1), 0) >= 255 )
  {
    return 1;
  }
  v3 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *((_DWORD *)billingServerStruct + 4));
  if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 3000 )
  {
    v4 = ((int (*)(void))GetTickCount)();
    v5 = (struct CONNECTION *)*((_DWORD *)billingServerStruct + 1);
    *((_DWORD *)billingServerStruct + 4) = v4 / 0xA;
    buf = 1;
    WriteData(v5, &buf, 1u, 1);
  }
  for ( i = sub_41BD80(*(_DWORD *)billingServerStruct, a2, (int)&v10, (int)v11);
        i;
        i = sub_41BD80(*(_DWORD *)billingServerStruct, a2, (int)&v10, (int)v11) )
  {
    v7 = (void (__cdecl *)(int, int))*((_DWORD *)billingServerStruct + 3);
    if ( v7 )
      v7(i, v10);
  }
  return 0;
}
// 4DC214: invalid function type has been ignored

//----- (00406210) --------------------------------------------------------
struc_2 *__thiscall ReadSettingsSomething(struc_2 *ConfigSETPointer, const char *Filename)
{
  int v3; // esi
  int v4; // eax
  int v5; // edi
  char *v6; // edx
  char v7; // al
  char *v8; // edi
  char *i; // ecx
  char *v10; // eax
  char *v11; // edx
  char j; // cl
  char k; // cl
  char *v14; // eax
  char v15; // cl
  char *l; // edx
  int v18; // [esp+10h] [ebp-204h]
  char v19; // [esp+14h] [ebp-200h] BYREF
  char v20; // [esp+15h] [ebp-1FFh] BYREF

  strcpy((char *)ConfigSETPointer + 177740, Filename);
  *((_DWORD *)ConfigSETPointer + 2432) = 0;
  *((_DWORD *)ConfigSETPointer + 44433) = 0;
  *((_DWORD *)ConfigSETPointer + 44434) = 0;
  v3 = -1;
  v4 = fopen((char *)ConfigSETPointer + 177740, "rt");
  v5 = v4;
  v18 = v4;
  if ( v4 )
  {
    if ( (*(_BYTE *)(v4 + 12) & 0x10) == 0 )
    {
      do
      {
        v19 = 0;
        fgets(&v19, 512, v5);
        if ( v19 == 91 )
        {
          v3 = *((_DWORD *)ConfigSETPointer + 2432);
          *((_DWORD *)ConfigSETPointer + 2432) = v3 + 1;
          v6 = &v20;
          v7 = v20;
          v8 = (char *)ConfigSETPointer + 38 * v3;
          for ( i = v8; v7; ++v6 )
          {
            if ( v7 == 93 )
              break;
            *i = v7;
            v7 = v6[1];
            ++i;
          }
          *i = 0;
          *(_DWORD *)(v8 + 30) = *((_DWORD *)ConfigSETPointer + 44433);
          *(_DWORD *)(v8 + 34) = 0;
          v5 = v18;
        }
        else if ( isalpha(v19) && v3 != -1 )
        {
          v10 = &v19;
          v11 = (char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9732;
          for ( j = v19; j; ++v10 )
          {
            if ( j == 61 )
              break;
            if ( j == 32 )
              break;
            *v11 = j;
            j = v10[1];
            ++v11;
          }
          *v11 = 0;
          for ( k = *v10; k; k = *++v10 )
          {
            if ( k == 61 )
              break;
          }
          if ( *v10 )
          {
            v14 = v10 + 1;
            v15 = *v14;
            for ( l = (char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9772; v15 >= 32; ++v14 )
            {
              *l = v15;
              v15 = v14[1];
              ++l;
            }
            *l = 0;
            config_read_helper_3((char *)ConfigSETPointer + 140 * *((_DWORD *)ConfigSETPointer + 44433) + 9772);
            ++*((_DWORD *)ConfigSETPointer + 44433);
            ++*(_DWORD *)((char *)ConfigSETPointer + 38 * v3 + 34);
          }
        }
      }
      while ( (*(_BYTE *)(v5 + 12) & 0x10) == 0 );
    }
    fclose(v5);
  }
  return ConfigSETPointer;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);

//----- (004063F0) --------------------------------------------------------
void __thiscall WriteCfgFile(struct struc_2 *struc2)
{
  struct struc_2 *v1; // esi
  int v2; // ebp
  _DWORD *v3; // edi
  int v4; // ebx
  const char *v5; // esi
  int v6; // [esp+8h] [ebp-8h]

  v1 = struc2;
  if ( *((_DWORD *)struc2 + 44434) )
  {
    v2 = fopen((char *)struc2 + 177740, "wt");
    if ( v2 )
    {
      v6 = 0;
      if ( *((int *)v1 + 2432) > 0 )
      {
        v3 = (_DWORD *)((char *)v1 + 34);
        do
        {
          if ( (int)*v3 > 0 )
          {
            fprintf(v2, "[%s]\n", (const char *)v3 - 34);
            v4 = 0;
            if ( (int)*v3 > 0 )
            {
              v5 = (char *)v1 + 140 * *(v3 - 1) + 9732;
              do
              {
                fprintf(v2, "%s=%s\n", v5, v5 + 40);
                ++v4;
                v5 += 140;
              }
              while ( v4 < *v3 );
              v1 = struc2;
            }
            fprintf(v2, (const char *)L"\n");
          }
          v3 = (_DWORD *)((char *)v3 + 38);
          ++v6;
        }
        while ( v6 < *((_DWORD *)v1 + 2432) );
      }
      fclose(v2);
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (004064D0) --------------------------------------------------------
int __thiscall GetCFGSettingInteger(struct struc_2 *Str1, const char *Str2, const char *a3, int a4)
{
  struct struc_2 *v4; // ebp
  int *v5; // edi
  int v6; // esi
  int v7; // ebx
  const char *v8; // ebp
  int result; // eax
  int v10; // [esp+10h] [ebp-18h]
  char v12[16]; // [esp+18h] [ebp-10h] BYREF

  v4 = Str1;
  v10 = 0;
  if ( *((int *)Str1 + 2432) <= 0 )
  {
LABEL_10:
    sprintf(v12, "%d", a4);
    FillArenaSettingsStruct(v4, Str2, a3, v12);
    result = a4;
  }
  else
  {
    v5 = (int *)((char *)Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v5 - 34, Str2) )
      {
        v6 = *(v5 - 1);
        v7 = 0;
        if ( *v5 > 0 )
          break;
      }
LABEL_9:
      v5 = (int *)((char *)v5 + 38);
      if ( ++v10 >= *((_DWORD *)v4 + 2432) )
        goto LABEL_10;
    }
    v8 = (char *)v4 + 140 * v6 + 9732;
    while ( _strcmpi(v8, a3) )
    {
      ++v7;
      ++v6;
      v8 += 140;
      if ( v7 >= *v5 )
      {
        v4 = Str1;
        goto LABEL_9;
      }
    }
    result = atoi((const char *)Str1 + 140 * v6 + 9772);
  }
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004065C0) --------------------------------------------------------
void __thiscall GetCFGSettingString(struct struc_2 *Str1, char *Str2, char *a3, char *Source, char *Dest, size_t Count)
{
  struct struc_2 *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  char *v12; // [esp-8h] [ebp-20h]
  size_t v13; // [esp-4h] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-8h]

  v6 = Str1;
  v14 = 0;
  if ( *((int *)Str1 + 2432) <= 0 )
  {
LABEL_10:
    FillArenaSettingsStruct(v6, Str2, a3, Source);
    v11 = Count;
    v13 = Count;
    v12 = Source;
  }
  else
  {
    v7 = (int *)((char *)Str1 + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, Str2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v14 >= *((_DWORD *)v6 + 2432) )
        goto LABEL_10;
    }
    v10 = (char *)v6 + 140 * v8 + 9732;
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = Str1;
        goto LABEL_9;
      }
    }
    v11 = Count;
    v13 = Count;
    v12 = (char *)Str1 + 140 * v8 + 9772;
  }
  strncpy(Dest, v12, v13);
  Dest[v11 - 1] = 0;
}

//----- (004066B0) --------------------------------------------------------
char *__thiscall sub_4066B0(int *this, char *a2, char *a3, char *a4, char *a5, size_t a6)
{
  int *v6; // ebx
  int *v7; // edi
  int v8; // esi
  int v9; // ebp
  const char *v10; // ebx
  size_t v11; // edi
  size_t v14; // [esp-4h] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-8h]

  v6 = this;
  v15 = 0;
  if ( this[2432] <= 0 )
  {
LABEL_10:
    v11 = a6;
    v14 = a6;
  }
  else
  {
    v7 = (int *)((char *)this + 34);
    while ( 1 )
    {
      if ( !_strcmpi((const char *)v7 - 34, a2) )
      {
        v8 = *(v7 - 1);
        v9 = 0;
        if ( *v7 > 0 )
          break;
      }
LABEL_9:
      v7 = (int *)((char *)v7 + 38);
      if ( ++v15 >= v6[2432] )
        goto LABEL_10;
    }
    v10 = (const char *)&v6[35 * v8 + 2433];
    while ( _strcmpi(v10, a3) )
    {
      ++v9;
      ++v8;
      v10 += 140;
      if ( v9 >= *v7 )
      {
        v6 = this;
        goto LABEL_9;
      }
    }
    v11 = a6;
    v14 = a6;
    a4 = (char *)&this[35 * v8 + 2443];
  }
  strncpy(a5, a4, v14);
  a5[v11 - 1] = 0;
  return a5;
}

//----- (00406790) --------------------------------------------------------
void __thiscall FillArenaSettingsStruct(struc_2 *Str1, const char *Str2, const char *a3, const char *Source)
{
  struc_2 *v4; // ebp
  int v5; // esi
  int v6; // eax
  struc_2 *v7; // edi
  int v8; // eax
  char *v9; // esi
  int v10; // ebx
  int v11; // ecx
  char *v12; // esi
  const char *v13; // edi
  char *v14; // ebx
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // [esp+10h] [ebp-Ch]
  char *v18; // [esp+14h] [ebp-8h]
  char *v19; // [esp+20h] [ebp+4h]

  v4 = Str1;
  v5 = 0;
  v6 = *((_DWORD *)Str1 + 2432);
  *((_DWORD *)Str1 + 44434) = 1;
  if ( v6 <= 0 )
  {
LABEL_5:
    strcpy((char *)v4 + 38 * *((_DWORD *)v4 + 2432), Str2);
    *(_DWORD *)((char *)v4 + 38 * *((_DWORD *)v4 + 2432) + 30) = *((_DWORD *)v4 + 44433);
    *(_DWORD *)((char *)v4 + 38 * *((_DWORD *)v4 + 2432) + 34) = 1;
    v8 = 7 * *((_DWORD *)v4 + 44433);
    ++*((_DWORD *)v4 + 2432);
    strcpy((char *)v4 + 20 * v8 + 9732, a3);
    v9 = (char *)v4 + 140 * *((_DWORD *)v4 + 44433) + 9772;
    strncpy(v9, Source, 0x64u);
    v9[99] = 0;
    ++*((_DWORD *)v4 + 44433);
  }
  else
  {
    v7 = Str1;
    while ( _strcmpi((const char *)v7, Str2) )
    {
      ++v5;
      v7 = (struc_2 *)((char *)v7 + 38);
      if ( v5 >= *((_DWORD *)v4 + 2432) )
        goto LABEL_5;
    }
    v17 = v5;
    v10 = 0;
    v11 = 19 * v5;
    v12 = *(char **)((char *)v4 + 38 * v5 + 30);
    v19 = v12;
    v18 = (char *)v4 + 2 * v11;
    if ( *(int *)(v18 + 34) <= 0 )
    {
LABEL_12:
      memcpy(
        (char *)v4 + 140 * (_DWORD)v12 + 9872,
        (char *)v4 + 140 * (_DWORD)v12 + 9732,
        140 * *((_DWORD *)v4 + 44433) - 140 * (_DWORD)v12);
      v14 = (char *)v4 + 140 * (_DWORD)v12 + 9772;
      strcpy((char *)v4 + 140 * (_DWORD)v12 + 9732, a3);
      strncpy(v14, Source, 0x64u);
      v14[99] = 0;
      ++*((_DWORD *)v4 + 44433);
      ++*(_DWORD *)(v18 + 34);
      v15 = 0;
      if ( *((int *)v4 + 2432) > 0 )
      {
        v16 = (_DWORD *)((char *)v4 + 30);
        do
        {
          if ( *v16 >= (int)v19 && v15 != v17 )
            ++*v16;
          ++v15;
          v16 = (_DWORD *)((char *)v16 + 38);
        }
        while ( v15 < *((_DWORD *)v4 + 2432) );
      }
    }
    else
    {
      v13 = (char *)v4 + 140 * (_DWORD)v12 + 9732;
      while ( _strcmpi(v13, a3) )
      {
        ++v10;
        ++v12;
        v13 += 140;
        if ( v10 >= *(_DWORD *)(v18 + 34) )
        {
          v19 = v12;
          goto LABEL_12;
        }
      }
      strcpy((char *)v4 + 140 * (_DWORD)v12 + 9772, Source);
    }
  }
}

//----- (00406A30) --------------------------------------------------------
void __thiscall LoadBMPHeader(struct BMP_FILE_STRUCT *Filename, const char *Source)
{
  int v3; // eax
  int v4; // edi
  int v5; // eax
  unsigned int v6; // eax
  void *v7; // eax
  int v8; // edx
  char v9[2]; // [esp+Ch] [ebp-8h] BYREF
  int v10; // [esp+Eh] [ebp-6h]

  strncpy((char *)Filename, Source, 0x100u);
  *((_BYTE *)Filename + 255) = 0;
  *((_DWORD *)Filename + 66) = 0;
  *((_DWORD *)Filename + 67) = 0;
  v3 = fopen(Filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    *((_DWORD *)Filename + 64) = 0;
    if ( fread(v9, 1, 6, v3) == 6 && v9[0] == 66 && v9[1] == 77 )
      *((_DWORD *)Filename + 64) = v10;
    fseek(v4, *((_DWORD *)Filename + 64), 0);
    v5 = _fileno(v4);
    v6 = (unsigned int)(_filelength(v5) - *((_DWORD *)Filename + 64)) >> 2;
    *((_DWORD *)Filename + 67) = v6;
    v7 = emalloc(4 * v6);
    v8 = *((_DWORD *)Filename + 67);
    *((_DWORD *)Filename + 66) = v7;
    fread(v7, v8, 4, v4);
    fclose(v4);
  }
  *((_DWORD *)Filename + 65) = 0;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00406B30) --------------------------------------------------------
void __thiscall sub_406B30(int this)
{
  int v2; // edi
  int v3; // eax
  void *v4; // esi
  int v5; // [esp-4h] [ebp-Ch]

  if ( *(_DWORD *)(this + 260) )
  {
    if ( *(_DWORD *)(this + 264) )
    {
      v2 = fopen(this, "rb+");
      if ( v2 || (v2 = fopen(this, "wb")) != 0 )
      {
        fseek(v2, *(_DWORD *)(this + 256), 0);
        fwrite(*(LPCVOID *)(this + 264), *(_DWORD *)(this + 268), 4, v2);
        v5 = *(_DWORD *)(this + 256) + 4 * *(_DWORD *)(this + 268);
        v3 = _fileno(v2);
        _chsize(v3, v5);
        fclose(v2);
      }
    }
  }
  v4 = *(void **)(this + 264);
  if ( v4 )
    efree(v4);
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(LPCVOID lpBuffer, _DWORD, _DWORD, _DWORD);
// 41EDC0: using guessed type int __cdecl _chsize(_DWORD, _DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00406BE0) --------------------------------------------------------
int __thiscall sub_406BE0(_DWORD *this)
{
  return this[67];
}

//----- (00406BF0) --------------------------------------------------------
void __thiscall GetTileValue(struct BMP_FILE_STRUCT *BMPFile, int TileCounter, int *TileValuePointer)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi

  v3 = *TileValuePointer ^ ((unsigned __int16)*TileValuePointer ^ (unsigned __int16)*(_DWORD *)(*((_DWORD *)BMPFile + 66)
                                                                                              + 4 * TileCounter)) & 0xFFF;
  *TileValuePointer = v3;
  v4 = v3 ^ (v3 ^ *(_DWORD *)(*((_DWORD *)BMPFile + 66) + 4 * TileCounter)) & 0xFFF000;
  *TileValuePointer = v4;
  v5 = *(_DWORD *)(*((_DWORD *)BMPFile + 66) + 4 * TileCounter);
  *TileValuePointer = v5 ^ (v5 ^ v4) & 0xFFFFFF;
}

//----- (00406C50) --------------------------------------------------------
void __cdecl DoBrickDrop(char *MapAllocatedMemory, int XTiles, int YTiles, int *X1Tile, int *Y1Tile, int *X2Tile, int *Y2Tile, signed int BrickSpanSize)
{
  int v8; // ebx
  char *v9; // esi
  int v10; // ebx
  int i; // edi
  int v12; // edi
  int v13; // ecx
  char *v14; // eax
  int v15; // ecx
  int v16; // esi
  char *v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // eax
  signed int j; // ecx
  int v22; // eax
  signed int v23; // eax
  char *v24; // edi
  char *v25; // ebx

  v8 = XTiles;
  if ( XTiles < 0 )
  {
    v9 = MapAllocatedMemory;
  }
  else
  {
    v9 = MapAllocatedMemory;
    do
    {
      if ( MapAllocatedMemory[1024 * YTiles + v8] )
        break;
      --v8;
    }
    while ( v8 >= 0 );
  }
  v10 = v8 + 1;
  for ( i = XTiles; i < 1024; ++i )
  {
    if ( v9[1024 * YTiles + i] )
      break;
  }
  v12 = i - 1;
  if ( v12 < v10 )
    v12 = v10;
  v13 = YTiles;
  if ( YTiles >= 0 )
  {
    v14 = &v9[1024 * YTiles + XTiles];
    do
    {
      if ( *v14 )
        break;
      --v13;
      v14 -= 1024;
    }
    while ( v13 >= 0 );
  }
  v15 = v13 + 1;
  v16 = YTiles;
  if ( YTiles < 1024 )
  {
    v17 = &MapAllocatedMemory[1024 * YTiles + XTiles];
    do
    {
      if ( *v17 )
        break;
      ++v16;
      v17 += 1024;
    }
    while ( v16 < 1024 );
  }
  v18 = v16 - 1;
  if ( v18 < v15 )
    v18 = v15;
  v19 = BrickSpanSize / 2;
  if ( v12 - v10 >= v18 - v15 )
  {
    if ( v15 <= YTiles - v19 )
      v15 = YTiles - v19;
    v22 = YTiles + v19;
    if ( v18 >= v22 )
      v18 = v22;
    v23 = v18 - v15 + 1;
    if ( v23 < BrickSpanSize )
    {
      v24 = &MapAllocatedMemory[1024 * v15 + XTiles];
      v25 = &MapAllocatedMemory[1024 * v18 + 1024 + XTiles];
      do
      {
        if ( v15 - 1 < 0 || *(v24 - 1024) )
        {
          if ( v18 >= 1023 || *v25 )
            break;
          ++v18;
          v25 += 1024;
        }
        else
        {
          --v15;
          v24 -= 1024;
        }
        ++v23;
      }
      while ( v23 < BrickSpanSize );
    }
    *Y1Tile = v15;
    *Y2Tile = v18;
    *X1Tile = XTiles;
    *X2Tile = XTiles;
  }
  else
  {
    if ( v10 <= XTiles - v19 )
      v10 = XTiles - v19;
    v20 = XTiles + v19;
    if ( v12 >= v20 )
      v12 = v20;
    for ( j = v12 - v10 + 1; j < BrickSpanSize; ++j )
    {
      if ( v10 - 1 < 0 || MapAllocatedMemory[1024 * YTiles - 1 + v10] )
      {
        if ( v12 >= 1023 || MapAllocatedMemory[1024 * YTiles + 1 + v12] )
          break;
        ++v12;
      }
      else
      {
        --v10;
      }
    }
    *X1Tile = v10;
    *X2Tile = v12;
    *Y1Tile = YTiles;
    *Y2Tile = YTiles;
  }
}

//----- (00406E30) --------------------------------------------------------
signed int __cdecl GenerateLVLChecksum(char *MapData, signed int Key)
{
  signed int v2; // edi
  int v3; // ecx
  int v4; // eax
  char *v5; // esi
  unsigned int v6; // ebx
  char *v7; // edx
  char *v8; // ecx
  char v9; // al
  int v11; // [esp+8h] [ebp+4h]

  v2 = Key;
  v3 = Key % 32;
  if ( Key % 32 < 1024 )
  {
    v4 = 1024 - Key % 31;
    v5 = &MapData[1024 * v3 + Key % 31];
    v11 = v4;
    v6 = (unsigned int)(1055 - v3) >> 5;
    do
    {
      v7 = &v5[v4];
      v8 = v5;
      if ( v5 < &v5[v4] )
      {
        do
        {
          v9 = *v8;
          if ( *v8 && (unsigned __int8)v9 < 0xA1u || v9 == -85 )
            Key += (unsigned __int8)*v8 ^ v2;
          v8 += 31;
        }
        while ( v8 < v7 );
        v4 = v11;
      }
      v5 += 0x8000;
      --v6;
    }
    while ( v6 );
  }
  return Key;
}

//----- (00406ED0) --------------------------------------------------------
int __cdecl sub_406ED0(char *level_file)
{
  int v1; // ebx
  int v2; // eax
  int v3; // ebp
  LONG v4; // edi
  int v5; // eax
  LONG v6; // eax
  unsigned int v7; // eax
  int v8; // esi
  int *v9; // edi
  int *v10; // ecx
  int v11; // eax
  int result; // eax
  char v13[2]; // [esp+8h] [ebp-8h] BYREF
  LONG v14; // [esp+Ah] [ebp-6h]

  v1 = 1;
  v2 = fopen(level_file, "rb");
  v3 = v2;
  if ( !v2 )
    return 0;
  v4 = 0;
  if ( fread(v13, 1, 6, v2) == 6 && v13[0] == 66 && v13[1] == 77 )
    v4 = v14;
  v5 = _fileno(v3);
  v6 = _filelength(v5);
  if ( v4 < v6 && v4 >= 0 && (v7 = v6 - v4, v8 = v7 >> 2, 4 * (v7 >> 2) == v7) && (fseek(v3, v4, 0), v8 > 0) )
  {
    v9 = (int *)emalloc(4 * v8);
    fread(v9, v8, 4, v3);
    v10 = v9;
    do
    {
      v11 = *v10;
      if ( (*v10 & 0xFFFu) > 0x400 || (v11 & 0xFFF000u) > (unsigned int)dword_400000 || (v11 & 0xFF000000) == 0 )
        v1 = 0;
      ++v10;
      --v8;
    }
    while ( v8 );
    efree(v9);
    fclose(v3);
    result = v1;
  }
  else
  {
    fclose(v3);
    result = 0;
  }
  return result;
}
// 406F8B: conditional instruction was optimized away because of 'esi.4>=1'
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (00407000) --------------------------------------------------------
void __thiscall InitializeTextFile(struct TEXT_FILE_STRUCT *textFile, const char *Source, int makeUpperCase, int addAll)
{
  *((_DWORD *)textFile + 66) = makeUpperCase;
  *((_DWORD *)textFile + 67) = addAll;
  if ( Source )
  {
    strncpy((char *)textFile, Source, 0x100u);
    *((_BYTE *)textFile + 255) = 0;
  }
  else
  {
    *(_BYTE *)textFile = 0;
  }
  *((_DWORD *)textFile + 65) = 0;
  *((_DWORD *)textFile + 64) = 0;
  LoadTextFile(textFile, 1);
}

//----- (00407060) --------------------------------------------------------
void __thiscall CleanTextFileMemory(TEXT_FILE_STRUCT *textFile)
{
  int i; // edi

  if ( *((_DWORD *)textFile + 64) )
  {
    for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
      efree(*(LPVOID *)(*((_DWORD *)textFile + 64) + 4 * i));
    ExpandMemory(*((LPVOID *)textFile + 64), 0, 1);
    *((_DWORD *)textFile + 64) = 0;
    *((_DWORD *)textFile + 65) = 0;
  }
}

//----- (004070D0) --------------------------------------------------------
void __thiscall LoadTextFile(struct TEXT_FILE_STRUCT *textFile, int a2)
{
  int i; // esi
  int v4; // eax
  int v5; // esi
  char *j; // eax
  char ChatMsgBuffer[512]; // [esp+10h] [ebp-200h] BYREF

  if ( a2 || !*(_BYTE *)textFile || IsFileLastWrittenTime((LPCSTR)textFile, (int)textFile + 272) )
  {
    if ( *((_DWORD *)textFile + 64) )
    {
      for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
        efree(*(LPVOID *)(*((_DWORD *)textFile + 64) + 4 * i));
      ExpandMemory(*((LPVOID *)textFile + 64), 0, 1);
      *((_DWORD *)textFile + 64) = 0;
      *((_DWORD *)textFile + 65) = 0;
    }
    if ( *(_BYTE *)textFile )
    {
      v4 = fopen(textFile, "rt");
      v5 = v4;
      if ( v4 )
      {
        if ( (*(_BYTE *)(v4 + 12) & 0x10) == 0 )
        {
          do
          {
            if ( fgets(ChatMsgBuffer, 512, v5) )
            {
              for ( j = &ChatMsgBuffer[strlen(ChatMsgBuffer)]; j != ChatMsgBuffer; --j )
              {
                if ( *(j - 1) >= 32 )
                  break;
              }
              *j = 0;
              if ( strlen(ChatMsgBuffer) )
                AddLineTextFile(textFile, ChatMsgBuffer);
            }
          }
          while ( (*(_BYTE *)(v5 + 12) & 0x10) == 0 );
        }
        fclose(v5);
      }
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);

//----- (00407200) --------------------------------------------------------
void __thiscall WriteTextFileToFile(struct TEXT_FILE_STRUCT *textFile)
{
  int v2; // ebx
  int i; // esi

  if ( *(_BYTE *)textFile )
  {
    v2 = fopen(textFile, "wt");
    if ( v2 )
    {
      for ( i = 0; i < *((_DWORD *)textFile + 65); ++i )
        fprintf(v2, "%s\n", *(const char **)(*((_DWORD *)textFile + 64) + 4 * i));
      fclose(v2);
    }
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);

//----- (00407260) --------------------------------------------------------
int __thiscall sub_407260(_DWORD *this)
{
  return this[65];
}

//----- (00407270) --------------------------------------------------------
int __thiscall sub_407270(_DWORD *this, int a2)
{
  return *(_DWORD *)(this[64] + 4 * a2);
}

//----- (00407280) --------------------------------------------------------
void __thiscall AddLineTextFile(struct TEXT_FILE_STRUCT *textFile, char *ChatMsgBuffer)
{
  int v3; // esi
  int v4; // eax
  char *v5; // eax
  size_t v6; // ecx
  unsigned int FoundPointer; // [esp+10h] [ebp-4h] BYREF
  char *ElementToFind; // [esp+18h] [ebp+4h]

  v3 = 0;
  v4 = BinarySearch(
         (int)ChatMsgBuffer,
         *((_DWORD *)textFile + 64),
         *((_DWORD *)textFile + 65),
         4,
         CompareFunc,
         &FoundPointer);
  if ( !FoundPointer || !*((_DWORD *)textFile + 67) )
  {
    if ( v4 )
      v3 = (v4 - *((_DWORD *)textFile + 64)) >> 2;
    v5 = (char *)ExpandMemory(*((LPVOID *)textFile + 64), 4 * *((_DWORD *)textFile + 65) + 4, 2048);
    v6 = 4 * (*((_DWORD *)textFile + 65) + 0x3FFFFFFF * v3);
    *((_DWORD *)textFile + 64) = v5;
    memcpy(&v5[4 * v3 + 4], &v5[4 * v3], v6);
    ElementToFind = (char *)emalloc(strlen(ChatMsgBuffer) + 1);
    strcpy(ElementToFind, ChatMsgBuffer);
    *(_DWORD *)(*((_DWORD *)textFile + 64) + 4 * v3) = ElementToFind;
    if ( *((_DWORD *)textFile + 66) )
      _strupr(*(char **)(*((_DWORD *)textFile + 64) + 4 * v3));
    ++*((_DWORD *)textFile + 65);
  }
}

//----- (004073A0) --------------------------------------------------------
void __cdecl ListMachineSomething(struct TEXT_FILE_STRUCT *textFile, int Number)
{
  int v2; // ecx
  int v3; // esi
  int v4; // ecx

  v3 = v2;
  efree(*(LPVOID *)(*(_DWORD *)(v2 + 256) + 4 * (_DWORD)textFile));
  v4 = *(_DWORD *)(v3 + 260) - 1;
  *(_DWORD *)(v3 + 260) = v4;
  memcpy(
    (void *)(4 * (_DWORD)textFile + *(_DWORD *)(v3 + 256)),
    (const void *)(*(_DWORD *)(v3 + 256) + 4 * (_DWORD)textFile + 4),
    4 * (v4 + 0x3FFFFFFF * (_DWORD)textFile));
  *(_DWORD *)(v3 + 256) = ExpandMemory(*(LPVOID *)(v3 + 256), 4 * *(_DWORD *)(v3 + 260), 2048);
}
// 4073A7: variable 'v2' is possibly undefined
// 4073A0: inconsistent function type and number of purged bytes

//----- (00407420) --------------------------------------------------------
int __thiscall sub_407420(int this, int a2)
{
  int v3; // eax
  int result; // eax

  v3 = BinarySearch(a2, *(_DWORD *)(this + 256), *(_DWORD *)(this + 260), 4, CompareFunc, (unsigned int *)&a2);
  if ( a2 )
    result = (v3 - *(_DWORD *)(this + 256)) >> 2;
  else
    result = -1;
  return result;
}

//----- (00407490) --------------------------------------------------------
char *__cdecl GetSplitNextDirectoryIP(char *a1, char *Src)
{
  char *v2; // esi
  int v3; // ecx
  char v4; // al
  char *i; // ecx

  *a1 = 0;
  v2 = Src;
  if ( isspace(*Src) == 32 )
  {
    do
      v3 = *++v2;
    while ( isspace(v3) == 32 );
  }
  v4 = *v2;
  for ( i = a1; v4; ++v2 )
  {
    if ( v4 == 44 )
      break;
    *i = v4;
    v4 = v2[1];
    ++i;
  }
  *i = 0;
  if ( *v2 == 44 )
    ++v2;
  strcpy(Src, v2);
  return a1;
}

//----- (00407510) --------------------------------------------------------
BOOL __cdecl IsFileLastWrittenTime(LPCSTR lpFileName, int dwLastReadTime)
{
  HANDLE v2; // eax
  void *v3; // esi
  struct _FILETIME LastWriteTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME LastAccessTime; // [esp+Ch] [ebp-10h] BYREF
  struct _FILETIME CreationTime; // [esp+14h] [ebp-8h] BYREF

  v2 = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
  v3 = v2;
  if ( v2 != (HANDLE)-1 )
  {
    GetFileTime(v2, &CreationTime, &LastAccessTime, &LastWriteTime);
    CloseHandle(v3);
    v2 = (HANDLE)LastWriteTime.dwLowDateTime;
  }
  if ( *(HANDLE *)dwLastReadTime == v2 )
    return 0;
  *(_DWORD *)dwLastReadTime = v2;
  return 1;
}

//----- (00407580) --------------------------------------------------------
int __cdecl BinarySearch(int ElementToFind, unsigned int Array, int TotalElements, signed int ElementSize, int (__cdecl *CompareFunc)(_DWORD, _DWORD), unsigned int *FoundPointer)
{
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // edi

  v6 = 0;
  result = 0;
  *FoundPointer = 0;
  if ( !TotalElements )
    return result;
  v8 = Array;
  v9 = Array + ElementSize * (TotalElements - 1);
  if ( Array > v9 )
  {
LABEL_9:
    if ( result > 0 )
      v6 += ElementSize;
    return v6;
  }
  while ( 1 )
  {
    v6 = v8 + ElementSize * ((int)(v9 - v8) / ElementSize / 2);
    result = CompareFunc(ElementToFind, v6);
    if ( result < 0 )
    {
      if ( v6 == Array )
        goto LABEL_9;
      v9 = v6 - ElementSize;
      goto LABEL_8;
    }
    if ( result <= 0 )
      break;
    v8 = v6 + ElementSize;
LABEL_8:
    if ( v8 > v9 )
      goto LABEL_9;
  }
  *FoundPointer = 1;
  if ( v6 == Array )
    return Array;
  while ( 1 )
  {
    v6 -= ElementSize;
    if ( CompareFunc(ElementToFind, v6) )
      break;
    if ( v6 == Array )
      return Array;
  }
  return v6 + ElementSize;
}

//----- (00407630) --------------------------------------------------------
unsigned int __cdecl GetPrivateProfileIntWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, unsigned int a3, LPCSTR lpFileName)
{
  UINT v4; // esi
  CHAR String[16]; // [esp+10h] [ebp-10h] BYREF

  v4 = GetPrivateProfileIntA(lpAppName, lpKeyName, -12345678, lpFileName);
  if ( v4 == -12345678 )
  {
    v4 = a3;
    sprintf(String, "%d", a3);
    WritePrivateProfileStringA(lpAppName, lpKeyName, String, lpFileName);
  }
  return v4;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (00407690) --------------------------------------------------------
int __cdecl GetPrivateProfileStringWrapper(LPCSTR lpAppName, LPCSTR lpKeyName, LPSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
{
  int result; // eax

  GetPrivateProfileStringA(lpAppName, lpKeyName, "1x2y3z4", lpReturnedString, nSize, lpFileName);
  result = strcmp(lpReturnedString, "1x2y3z4");
  if ( !result )
  {
    strcpy(lpReturnedString, lpDefault);
    result = WritePrivateProfileStringA(lpAppName, lpKeyName, lpReturnedString, lpFileName);
  }
  return result;
}

//----- (00407730) --------------------------------------------------------
void __cdecl config_read_helper_3(char *a1)
{
  char *v1; // ecx
  char *v2; // esi
  char v3; // dl
  char i; // dl
  char v5; // bl

  v1 = a1;
  v2 = a1;
  if ( *a1 == 32 )
  {
    do
      v3 = *++v1;
    while ( v3 == 32 );
  }
  for ( i = *v1; i; ++v1 )
  {
    if ( i != 32 || (v5 = v1[1], v5 != 32) && v5 )
      *v2++ = i;
    i = v1[1];
  }
  *v2 = 0;
}

//----- (00407780) --------------------------------------------------------
signed int __cdecl CRC32(char *buffer, int fileSize)
{
  char *v2; // ecx
  int v3; // eax
  int v5[256]; // [esp+4h] [ebp-400h]

  v5[0] = 0;
  v5[1] = 1996959894;
  v5[2] = -301047508;
  v5[3] = -1727442502;
  v5[4] = 124634137;
  v5[5] = 1886057615;
  v5[6] = -379345611;
  v5[7] = -1637575261;
  v5[8] = 249268274;
  v5[9] = 2044508324;
  v5[10] = -522852066;
  v5[11] = -1747789432;
  v5[12] = 162941995;
  v5[13] = 2125561021;
  v5[14] = -407360249;
  v5[15] = -1866523247;
  v5[16] = 498536548;
  v5[17] = 1789927666;
  v5[18] = -205950648;
  v5[19] = -2067906082;
  v5[20] = 450548861;
  v5[21] = 1843258603;
  v5[22] = -187386543;
  v5[23] = -2083289657;
  v5[24] = 325883990;
  v5[25] = 1684777152;
  v5[26] = -43845254;
  v5[27] = -1973040660;
  v5[28] = 335633487;
  v5[29] = 1661365465;
  v5[30] = -99664541;
  v5[31] = -1928851979;
  v5[32] = 997073096;
  v5[33] = 1281953886;
  v5[34] = -715111964;
  v5[35] = -1570279054;
  v5[36] = 1006888145;
  v5[37] = 1258607687;
  v5[38] = -770865667;
  v5[39] = -1526024853;
  v5[40] = 901097722;
  v5[41] = 1119000684;
  v5[42] = -608450090;
  v5[43] = -1396901568;
  v5[44] = 853044451;
  v5[45] = 1172266101;
  v5[46] = -589951537;
  v5[47] = -1412350631;
  v5[48] = 651767980;
  v5[49] = 1373503546;
  v5[50] = -925412992;
  v5[51] = -1076862698;
  v5[52] = 565507253;
  v5[53] = 1454621731;
  v5[54] = -809855591;
  v5[55] = -1195530993;
  v5[56] = 671266974;
  v5[57] = 1594198024;
  v5[58] = -972236366;
  v5[59] = -1324619484;
  v5[60] = 795835527;
  v5[61] = 1483230225;
  v5[62] = -1050600021;
  v5[63] = -1234817731;
  v5[64] = 1994146192;
  v5[65] = 31158534;
  v5[66] = -1731059524;
  v5[67] = -271249366;
  v5[68] = 1907459465;
  v5[69] = 112637215;
  v5[70] = -1614814043;
  v5[71] = -390540237;
  v5[72] = 2013776290;
  v5[73] = 251722036;
  v5[74] = -1777751922;
  v5[75] = -519137256;
  v5[76] = 2137656763;
  v5[77] = 141376813;
  v5[78] = -1855689577;
  v5[79] = -429695999;
  v5[80] = 1802195444;
  v5[81] = 476864866;
  v5[82] = -2056965928;
  v5[83] = -228458418;
  v5[84] = 1812370925;
  v5[85] = 453092731;
  v5[86] = -2113342271;
  v5[87] = -183516073;
  v5[88] = 1706088902;
  v5[89] = 314042704;
  v5[90] = -1950435094;
  v5[91] = -54949764;
  v5[92] = 1658658271;
  v5[93] = 366619977;
  v5[94] = -1932296973;
  v5[95] = -69972891;
  v5[96] = 1303535960;
  v5[97] = 984961486;
  v5[98] = -1547960204;
  v5[99] = -725929758;
  v5[100] = 1256170817;
  v5[101] = 1037604311;
  v5[102] = -1529756563;
  v5[103] = -740887301;
  v5[104] = 1131014506;
  v5[105] = 879679996;
  v5[106] = -1385723834;
  v5[107] = -631195440;
  v5[108] = 1141124467;
  v5[109] = 855842277;
  v5[110] = -1442165665;
  v5[111] = -586318647;
  v5[112] = 1342533948;
  v5[113] = 654459306;
  v5[114] = -1106571248;
  v5[115] = -921952122;
  v5[116] = 1466479909;
  v5[117] = 544179635;
  v5[118] = -1184443383;
  v5[119] = -832445281;
  v5[120] = 1591671054;
  v5[121] = 702138776;
  v5[122] = -1328506846;
  v5[123] = -942167884;
  v5[124] = 1504918807;
  v5[125] = 783551873;
  v5[126] = -1212326853;
  v5[127] = -1061524307;
  v5[128] = -306674912;
  v5[129] = -1698712650;
  v5[130] = 62317068;
  v5[131] = 1957810842;
  v5[132] = -355121351;
  v5[133] = -1647151185;
  v5[134] = 81470997;
  v5[135] = 1943803523;
  v5[136] = -480048366;
  v5[137] = -1805370492;
  v5[138] = 225274430;
  v5[139] = 2053790376;
  v5[140] = -468791541;
  v5[141] = -1828061283;
  v5[142] = 167816743;
  v5[143] = 2097651377;
  v5[144] = -267414716;
  v5[145] = -2029476910;
  v5[146] = 503444072;
  v5[147] = 1762050814;
  v5[148] = -144550051;
  v5[149] = -2140837941;
  v5[150] = 426522225;
  v5[151] = 1852507879;
  v5[152] = -19653770;
  v5[153] = -1982649376;
  v5[154] = 282753626;
  v5[155] = 1742555852;
  v5[156] = -105259153;
  v5[157] = -1900089351;
  v5[158] = 397917763;
  v5[159] = 1622183637;
  v5[160] = -690576408;
  v5[161] = -1580100738;
  v5[162] = 953729732;
  v5[163] = 1340076626;
  v5[164] = -776247311;
  v5[165] = -1497606297;
  v5[166] = 1068828381;
  v5[167] = 1219638859;
  v5[168] = -670225446;
  v5[169] = -1358292148;
  v5[170] = 906185462;
  v5[171] = 1090812512;
  v5[172] = -547295293;
  v5[173] = -1469587627;
  v5[174] = 829329135;
  v5[175] = 1181335161;
  v5[176] = -882789492;
  v5[177] = -1134132454;
  v5[178] = 628085408;
  v5[179] = 1382605366;
  v5[180] = -871598187;
  v5[181] = -1156888829;
  v5[182] = 570562233;
  v5[183] = 1426400815;
  v5[184] = -977650754;
  v5[185] = -1296233688;
  v5[186] = 733239954;
  v5[187] = 1555261956;
  v5[188] = -1026031705;
  v5[189] = -1244606671;
  v5[190] = 752459403;
  v5[191] = 1541320221;
  v5[192] = -1687895376;
  v5[193] = -328994266;
  v5[194] = 1969922972;
  v5[195] = 40735498;
  v5[196] = -1677130071;
  v5[197] = -351390145;
  v5[198] = 1913087877;
  v5[199] = 83908371;
  v5[200] = -1782625662;
  v5[201] = -491226604;
  v5[202] = 2075208622;
  v5[203] = 213261112;
  v5[204] = -1831694693;
  v5[205] = -438977011;
  v5[206] = 2094854071;
  v5[207] = 198958881;
  v5[208] = -2032938284;
  v5[209] = -237706686;
  v5[210] = 1759359992;
  v5[211] = 534414190;
  v5[212] = -2118248755;
  v5[213] = -155638181;
  v5[214] = 1873836001;
  v5[215] = 414664567;
  v5[216] = -2012718362;
  v5[217] = -15766928;
  v5[218] = 1711684554;
  v5[219] = 285281116;
  v5[220] = -1889165569;
  v5[221] = -127750551;
  v5[222] = 1634467795;
  v5[223] = 376229701;
  v5[224] = -1609899400;
  v5[225] = -686959890;
  v5[226] = 1308918612;
  v5[227] = 956543938;
  v5[228] = -1486412191;
  v5[229] = -799009033;
  v5[230] = 1231636301;
  v5[231] = 1047427035;
  v5[232] = -1362007478;
  v5[233] = -640263460;
  v5[234] = 1088359270;
  v5[235] = 936918000;
  v5[236] = -1447252397;
  v5[237] = -558129467;
  v5[238] = 1202900863;
  v5[239] = 817233897;
  v5[240] = -1111625188;
  v5[241] = -893730166;
  v2 = buffer;
  v3 = -1;
  v5[242] = 1404277552;
  v5[243] = 615818150;
  v5[244] = -1160759803;
  v5[245] = -841546093;
  v5[246] = 1423857449;
  v5[247] = 601450431;
  v5[248] = -1285129682;
  v5[249] = -1000256840;
  v5[250] = 1567103746;
  v5[251] = 711928724;
  v5[252] = -1274298825;
  v5[253] = -1022587231;
  v5[254] = 1510334235;
  for ( v5[255] = 755167117; v2 < &buffer[fileSize]; ++v2 )
    v3 = v5[(unsigned __int8)*v2 ^ (unsigned __int8)v3] ^ (v3 >> 8) & 0xFFFFFF;
  return ~v3;
}

//----- (00408270) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_408270(int a1)
{
  int result; // eax

  result = fopen(a1, "rb");
  if ( result )
    JUMPOUT(0x408301);
  return result;
}
// 4082FB: positive sp value 4 has been found
// 408298: control flows out of bounds to 408301
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);

//----- (00408310) --------------------------------------------------------
// returns ptr to alloced space, with a preceding dword with the allocced size
// 
// uses virtualalloc if sz is >= half a meg
// 
// ex:
// emalloc(DWORD sz)
//    DWORD *buf = malloc(sz + 4);
//    buf[0] = sz + 4;
//    return &buf[1];
// 
void *__cdecl emalloc(int bytes)
{
  _DWORD *v1; // eax
  void *v2; // esi
  CHAR Text[256]; // [esp+8h] [ebp-100h] BYREF

  if ( bytes + 4 <= 0x80000 )
    v1 = malloc(bytes + 4);
  else
    v1 = VirtualAlloc(0, bytes + 4, MEM_COMMIT, 4u);
  if ( v1 )
  {
    *v1 = bytes + 4;
    v2 = v1 + 1;
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
  {
    sprintf(Text, "Out of memory (Alloc:%d)", bytes);
    MessageBoxA(0, Text, "Error", 0x30u);
    exit(1);
  }
  return v2;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004083A0) --------------------------------------------------------
LPVOID __cdecl ExpandMemory(LPVOID lpAddress, int a2, int a3)
{
  int v3; // ecx
  int v4; // edi
  _DWORD *v5; // eax
  LPVOID v6; // esi
  LPVOID result; // eax
  char *v8; // eax
  int v9; // esi
  signed int v10; // edi
  signed int *v11; // eax
  signed int *v12; // eax
  void *v13; // ebp
  unsigned int v14; // ecx
  int *v15; // [esp+10h] [ebp-104h]
  CHAR Text[256]; // [esp+14h] [ebp-100h] BYREF

  v3 = a3;
  if ( a2 > 0x80000 )
    v3 = 16 * a3;
  v4 = v3 * ((v3 + a2 - 1) / v3);
  if ( lpAddress )
  {
    if ( v4 )
    {
      v9 = *((_DWORD *)lpAddress - 1);
      v10 = v4 + 4;
      v15 = (int *)((char *)lpAddress - 4);
      if ( v10 == v9 )
      {
        result = lpAddress;
      }
      else if ( v9 > 0x80000 || v10 > 0x80000 )
      {
        if ( v10 <= 0x80000 )
          v12 = (signed int *)malloc(v10);
        else
          v12 = (signed int *)VirtualAlloc(0, v10, MEM_COMMIT, PAGE_READWRITE);
        if ( v12 )
        {
          *v12 = v10;
          v13 = v12 + 1;
        }
        else
        {
          v13 = 0;
        }
        if ( !v13 )
        {
          sprintf(Text, "Out of memory (Alloc:%d)", v10 - 4);
          MessageBoxA(0, Text, "Error", 0x30u);
          exit(1);
        }
        v14 = v9 - 4;
        if ( v9 - 4 >= v10 - 4 )
          v14 = v10 - 4;
        qmemcpy(v13, lpAddress, v14);
        if ( *v15 <= 0x80000 )
          free(v15);
        else
          VirtualFree(v15, 0, MEM_RELEASE);
        result = v13;
      }
      else
      {
        v11 = (signed int *)realloc((char *)lpAddress - 4, v10);
        if ( !v11 )
        {
          MessageBoxA(0, "Out of memory (Resize)", "Error", 0x30u);
          exit(1);
        }
        *v11 = v10;
        result = v11 + 1;
      }
    }
    else
    {
      v8 = (char *)lpAddress - 4;
      if ( *((int *)lpAddress - 1) <= 0x80000 )
        free(v8);
      else
        VirtualFree(v8, 0, MEM_RELEASE);
      result = 0;
    }
  }
  else
  {
    if ( v4 + 4 <= 0x80000 )
      v5 = malloc(v4 + 4);
    else
      v5 = VirtualAlloc(0, v4 + 4, 0x1000u, 4u);
    if ( v5 )
    {
      *v5 = v4 + 4;
      v6 = v5 + 1;
    }
    else
    {
      v6 = 0;
    }
    if ( !v6 )
    {
      sprintf(Text, "Out of memory (Alloc:%d)", v4);
      MessageBoxA(0, Text, "Error", 0x30u);
      exit(1);
    }
    result = v6;
  }
  return result;
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (004085C0) --------------------------------------------------------
// see emalloc()
void __stdcall efree(LPVOID ptr)
{
  if ( *((int *)ptr - 1) <= 0x80000 )
    free((char *)ptr - 4);
  else
    VirtualFree((char *)ptr - 4, 0, 0x8000u);
}
// 4085C0: inconsistent function type and number of purged bytes

//----- (004085F0) --------------------------------------------------------
SOCKET *__thiscall ConnectSocket(SOCKET *this, char *cp, int a3, unsigned int buf)
{
  SOCKET v5; // eax
  u_long v6; // eax
  SOCKET v7; // ecx
  unsigned __int32 v8; // edi
  struct hostent *v9; // eax
  unsigned int v10; // kr00_4
  SOCKET v11; // eax
  SOCKET v13; // [esp-14h] [ebp-48h]
  SOCKET v14; // [esp-14h] [ebp-48h]
  SOCKET v15; // [esp-14h] [ebp-48h]
  char optval[4]; // [esp+Ch] [ebp-28h] BYREF
  u_long argp; // [esp+10h] [ebp-24h] BYREF
  struct sockaddr name; // [esp+14h] [ebp-20h] BYREF
  struct sockaddr v19; // [esp+24h] [ebp-10h] BYREF

  v5 = socket(2, 2, 0);
  *this = v5;
  argp = 1;
  ioctlsocket(v5, -2147195266, &argp);
  v13 = *this;
  *(_DWORD *)optval = -1;
  setsockopt(v13, 6, SO_DEBUG, optval, 4);
  v14 = *this;
  *(_DWORD *)optval = 0x8000;
  setsockopt(v14, 0xFFFF, SO_SNDBUF, optval, 4);
  v15 = *this;
  *(_DWORD *)optval = 0x8000;
  setsockopt(v15, 0xFFFF, SO_RCVBUF, optval, 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(buf);
  v6 = ntohl(0);
  v7 = *this;
  *(_DWORD *)&name.sa_data[2] = v6;
  bind(v7, &name, 16);
  v8 = inet_addr(cp);
  if ( v8 == -1 )
  {
    v9 = gethostbyname(cp);
    if ( v9 )
      v8 = **(_DWORD **)v9->h_addr_list;
  }
  v19.sa_family = 2;
  *(_DWORD *)&v19.sa_data[2] = v8;
  *(_WORD *)v19.sa_data = ntohs(a3);
  connect(*this, &v19, 16);
  this[1] = -1;
  this[2] = -1;
  v10 = ((int (*)(void))GetTickCount)();
  v11 = *this;
  buf = v10 / 0xA;
  send(v11, (const char *)&buf, 4, 0);
  return this;
}
// 4DC214: invalid function type has been ignored

//----- (00408740) --------------------------------------------------------
int __thiscall CloseSocketWrapper(SOCKET *this)
{
  return closesocket(*this);
}

//----- (00408750) --------------------------------------------------------
void __thiscall SendDirectoryServerZoneUpdatePacket(void *this, const void *a2, unsigned int a3)
{
  unsigned int v4; // [esp+Ch] [ebp-404h] BYREF
  char buf[4]; // [esp+10h] [ebp-400h] BYREF
  char v6[1020]; // [esp+14h] [ebp-3FCh] BYREF

  if ( a2 && (int)a3 > 0 )
  {
    *(_DWORD *)buf = 0;
    qmemcpy(v6, a2, a3);
    send(*(_DWORD *)this, buf, a3 + 4, 0);
  }
  else
  {
    v4 = ((int (*)(void))GetTickCount)() / 0xAu;
    send(*(_DWORD *)this, (const char *)&v4, 4, 0);
  }
}
// 4DC214: invalid function type has been ignored

//----- (004087D0) --------------------------------------------------------
int __thiscall GetSocketRecvLag(SOCKET Socket, int *TimeElapsed)
{
  int v3; // esi
  char buf[4]; // [esp+Ch] [ebp-200h] BYREF
  int v6; // [esp+10h] [ebp-1FCh]

  do
  {
    if ( recv(*(_DWORD *)Socket, buf, 512, MSG_PEEK) == -1 )
      break;
    v3 = recv(*(_DWORD *)Socket, buf, 512, 0);
    if ( v3 == 8 )
    {
      *(_DWORD *)(Socket + 4) = *(_DWORD *)buf;
      *(_DWORD *)(Socket + 8) = ((int (*)(void))GetTickCount)() / 0xAu - v6;
    }
  }
  while ( v3 != -1 );
  *TimeElapsed = *(_DWORD *)(Socket + 8);
  return *(_DWORD *)(Socket + 4);
}
// 4DC214: invalid function type has been ignored

//----- (00408860) --------------------------------------------------------
// PINGSOCKET.PingSocket()
PINGSOCKET *__thiscall ListenOnPort(PINGSOCKET *socket, __int16 port, void *callback)
{
  SOCKET v4; // eax
  u_long v5; // eax
  int v6; // ecx
  int v8; // [esp-14h] [ebp-2Ch]
  int v9; // [esp-14h] [ebp-2Ch]
  int v10; // [esp-14h] [ebp-2Ch]
  u_long argp; // [esp+4h] [ebp-14h] BYREF
  struct sockaddr name; // [esp+8h] [ebp-10h] BYREF

  socket->fnCallback = (int)callback;
  v4 = ::socket(AF_INET, SOCK_DGRAM, 0);
  socket->socket = v4;
  argp = 1;
  ioctlsocket(v4, -2147195266, &argp);
  v8 = socket->socket;
  callback = (void *)-1;
  setsockopt(v8, 6, 1, (const char *)&callback, 4);
  v9 = socket->socket;
  callback = (void *)0x2000;
  setsockopt(v9, 0xFFFF, SO_SNDBUF, (const char *)&callback, 4);
  v10 = socket->socket;
  callback = (void *)0x2000;
  setsockopt(v10, 0xFFFF, SO_RCVBUF, (const char *)&callback, 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(port);
  v5 = ntohl(0);
  v6 = socket->socket;
  *(_DWORD *)&name.sa_data[2] = v5;
  bind(v6, &name, 16);
  return socket;
}

//----- (00408930) --------------------------------------------------------
void __thiscall ProcessZonePings(int Socket, int ZonePopulation)
{
  int i; // ebp
  unsigned int v4; // eax
  void (__stdcall *v5)(_DWORD, char *, unsigned int); // ecx
  SOCKET v6; // eax
  SOCKET v7; // [esp-18h] [ebp-244h]
  int fromlen; // [esp+10h] [ebp-21Ch] BYREF
  char v9[4]; // [esp+14h] [ebp-218h] BYREF
  int v10; // [esp+18h] [ebp-214h]
  struct sockaddr from; // [esp+1Ch] [ebp-210h] BYREF
  char buf[4]; // [esp+2Ch] [ebp-200h] BYREF
  char v13[508]; // [esp+30h] [ebp-1FCh] BYREF

  for ( i = 0; i < 20; ++i )
  {
    v7 = *(_DWORD *)Socket;
    fromlen = 16;
    v4 = recvfrom(v7, buf, 512, 0, &from, &fromlen);
    if ( v4 == -1 )
      break;
    if ( v4 >= 4 )
    {
      if ( *(_DWORD *)buf )
      {
        v6 = *(_DWORD *)Socket;
        v10 = *(_DWORD *)buf;
        *(_DWORD *)v9 = ZonePopulation;
        sendto(v6, v9, 8, 0, &from, 16);
      }
      else
      {
        v5 = *(void (__stdcall **)(_DWORD, char *, unsigned int))(Socket + 4);
        if ( v5 )
        {
          if ( v4 > 4 )
            v5(*(_DWORD *)&from.sa_data[2], v13, v4 - 4);
        }
      }
    }
  }
}

//----- (004089E0) --------------------------------------------------------
// Player.Player()
PLAYER *__thiscall CreateNewPlayer(PLAYER *this, struct in_addr in, __int16 a3, NetData *nd)
{
  int v5; // edx
  int v6; // eax

  this->hProcess = 0;
  *(_DWORD *)this->field_4 = 0;
  *(_DWORD *)&this->field_4[4] = 0;
  *(_DWORD *)&this->field_4[8] = 0;
  memset(&this->field_44[36], 0, 0x40u);
  this->field_2B7[4] = 0;
  *(_DWORD *)&this->field_44[4] = 0;
  *(_DWORD *)&this->field_44[144] = 0;
  *(_DWORD *)&this->field_2F9[24] = 0;
  *(_DWORD *)&this->field_117[72] = -1;
  *(_DWORD *)this->field_44 = 0;
  *(_DWORD *)&this->field_44[28] = -1;
  *(_DWORD *)&this->field_44[24] = -1;
  *(_DWORD *)&this->field_44[20] = -1;
  this->bIsSilenced = 0;
  *(_DWORD *)&this->field_117[68] = 0;
  *(_DWORD *)&this->field_44[12] = -1;
  *(_DWORD *)&this->field_44[16] = -1;
  *(_DWORD *)&this->field_117[64] = 0;
  *(_DWORD *)&this->field_44[100] = 0;
  *(_DWORD *)&this->field_44[120] = 0;
  *(_DWORD *)&this->field_2C[16] = 0;
  *(_DWORD *)&this->field_44[8] = -1;
  *(_DWORD *)&this->field_117[60] = 0;
  this->connection_id = dword_42B534++;
  *(_DWORD *)&this->field_2F9[12] = 0;
  *(_DWORD *)&this->field_2C[8] = 0;
  *(_DWORD *)&this->field_2C[12] = 0;
  *(_DWORD *)&this->field_44[104] = 0;
  *(_DWORD *)&this->field_EA[19] = 0;
  this->lpNetworkData = (int)nd;
  this->lpCurrentArena = 0;
  *(_DWORD *)this->lpArenaPointer2 = 0;
  memset(&this->lpSomePtr, 0, 0x20u);
  this->Name[0] = 0;
  *(_DWORD *)&this->field_117[8] = 0;
  memset(&this->field_117[20], 0, 0x28u);
  *(_DWORD *)&this->field_319[8] = 1000;
  *(_DWORD *)&this->field_319[12] = 1000;
  *(_DWORD *)this->field_283 = 0;
  this->in_addr = in;
  this->port = a3;
  this->beginlog_file_ptr = 0;
  LOBYTE(this->beginlog_file_name) = 0;
  *(_DWORD *)this->field_117 = -1;
  this->bIsSysop = 0;
  this->bIsModerator = 0;
  this->bIsSmod = 0;
  *(_DWORD *)&this->field_231[50] = -1;
  memset(this->player_name, 0, 0xACu);
  this->dwUserID = -1;
  *(_DWORD *)&this->score.wins = 0;
  *(_DWORD *)&this->score.flags = 0;
  *(int *)((char *)&this->score.points + 2) = 0;
  HIWORD(this->score.flag_points) = 0;
  *(_DWORD *)this->field_231 = 0;
  *(_DWORD *)&this->field_231[4] = 0;
  *(_DWORD *)&this->field_231[8] = 0;
  *(_WORD *)&this->field_231[12] = 0;
  *(_DWORD *)&this->field_117[92] = -1;
  v5 = this->lpNetworkData;
  this->dwShip = 8;
  *(_DWORD *)&this->field_2B7[52] = 0;
  *(_DWORD *)&this->field_2B7[56] = 0;
  *(_DWORD *)&this->field_2C[4] = 0;
  v6 = *(_DWORD *)(v5 + 46);
  *(_DWORD *)&this->field_14 = v6;
  *(&ZonePlayerList + v6) = this;
  *(_DWORD *)&this->field_231[46] = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)&this->field_2F9[4] = time(0);
  *(_DWORD *)&this->field_283[20] = 0;
  *(_DWORD *)&this->field_283[4] = 0;
  *(_DWORD *)&this->field_283[8] = 0;
  *(_DWORD *)&this->field_283[28] = 0;
  *(_DWORD *)&this->field_283[12] = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)&this->field_283[16] = 0;
  *(_DWORD *)&this->field_283[24] = 0;
  *(_DWORD *)&this->field_283[28] = 0;
  *(_DWORD *)&this->field_44[112] = 0;
  *(_DWORD *)&this->field_44[128] = 0;
  *(_DWORD *)&this->field_44[132] = 0;
  *(_DWORD *)&this->field_44[136] = 0;
  *(_DWORD *)&this->field_44[140] = 0;
  this->dwDisconnectReason = 0;
  *(_DWORD *)this->field_319 = 0;
  *(_DWORD *)&this->field_319[4] = 0;
  *(_DWORD *)&this->field_2F9[20] = 0;
  *(_DWORD *)&this->field_44[116] = 0;
  *(_DWORD *)&this->field_2F9[16] = 1;
  return this;
}
// 4DC214: invalid function type has been ignored
// 42B534: using guessed type int dword_42B534;

//----- (00408C30) --------------------------------------------------------
// Player.Disconnect()
void __thiscall DisconnectPlayer(PLAYER *p)
{
  char *v2; // esi
  char *v3; // ebp
  int v4; // ecx
  int v5; // ebp
  char i; // al
  int v7; // ecx
  int v8; // ecx
  int *v9; // esi
  int v10; // ebp
  int v11; // eax
  __int16 Ping[2]; // [esp+10h] [ebp-B0h] BYREF
  __int16 Latency[2]; // [esp+14h] [ebp-ACh] BYREF
  int v14; // [esp+18h] [ebp-A8h]
  char a3; // [esp+1Ch] [ebp-A4h] BYREF
  char v16[35]; // [esp+1Dh] [ebp-A3h] BYREF
  char v17[128]; // [esp+40h] [ebp-80h] BYREF

  if ( p->hProcess )
  {
    TerminateProcess((HANDLE)p->hProcess, 0);
    CloseHandle((HANDLE)p->hProcess);
  }
  if ( p->beginlog_file_ptr )
  {
    fclose(p->beginlog_file_ptr);
    p->beginlog_file_ptr = 0;
  }
  if ( dword_4B061C > 0 && p->score.points + p->score.flag_points >= dword_4B061C )
  {
    v2 = lpszPermission_AutoPermissionIDList;
    while ( *v2 )
    {
      v3 = v17;
      if ( isdigit(*v2) )
      {
        do
        {
          v4 = v2[1];
          *v3++ = *v2++;
        }
        while ( isdigit(v4) );
      }
      *v3 = 0;
      v5 = atoi(v17);
      if ( v5 && BillingConnectionStructPointer )
      {
        a3 = 1;
        strncpy(v16, p->player_name, 0x20u);
        v16[31] = 0;
        SendBillerPlayerNamePacketSomething(BillingConnectionStructPointer, -1, v5, &a3, 0x21u);
      }
      for ( i = *v2; i; i = *++v2 )
      {
        if ( isdigit(i) )
          break;
      }
    }
  }
  v7 = p->lpCurrentArena;
  v14 = 0;
  if ( v7 )
  {
    v14 = *(_DWORD *)(v7 + 109754);
    ArenaRemovePlayer((struct ARENA *)v7, p);
    p->lpCurrentArena = 0;
  }
  sub_41D720(p->lpNetworkData, (int)Latency, (int)Ping);
  v8 = p->lpNetworkData;
  *(_DWORD *)Latency = 1000 - *(_DWORD *)Latency;
  *(_DWORD *)Ping = 1000 - *(_DWORD *)Ping;
  sub_41C360(v8);
  v9 = &p->lpSomePtr;
  v10 = 4;
  *(&ZonePlayerList + *(_DWORD *)&p->field_14) = 0;
  do
  {
    if ( *v9 )
    {
      efree((LPVOID)*v9);
      *v9 = 0;
    }
    v9 += 2;
    --v10;
  }
  while ( v10 );
  if ( BillingConnectionStructPointer )
  {
    v11 = 0;
    if ( dwMisc_DisableSharewareScores && *(_DWORD *)&p->field_44[4] )
      v11 = 1;
    if ( v14
      || (unsigned __int16)p->score.losses + (unsigned __int16)p->score.wins + p->score.points + p->score.flag_points <= 5
      && !*(_DWORD *)&p->field_2F9[20] )
    {
      v11 = 1;
    }
    if ( v11 )
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        p->connection_id,
        p->dwDisconnectReason,
        Latency[0],
        Ping[0],
        10 * *(_WORD *)&p->field_117[51],
        10 * *(_DWORD *)p->field_319 / (*(_DWORD *)&p->field_319[4] + 1),
        0,
        0);
    else
      SendBillerUserLogoffPacket(
        BillingConnectionStructPointer,
        p->connection_id,
        p->dwDisconnectReason,
        Latency[0],
        Ping[0],
        10 * *(_WORD *)&p->field_117[51],
        10 * *(_DWORD *)p->field_319 / (*(_DWORD *)&p->field_319[4] + 1),
        &p->score,
        0xEu);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 4B061C: using guessed type int dword_4B061C;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (00408E90) --------------------------------------------------------
// Player.HandleGamePacket()
void __thiscall PlayerHandleGamePacket(PLAYER *p, BYTE *pkt, DWORD pkt_sz)
{
  BYTE *v3; // ebx
  int v5; // ecx
  int v6; // ecx
  BYTE *v7; // esi
  int v8; // eax
  int v9; // eax
  struct ARENA *v10; // ebp
  int v11; // eax
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // esi
  int v19; // esi
  ARENA *v20; // eax
  DWORD v21; // ecx
  PLAYER *v22; // ebx
  int v23; // ebx
  unsigned int v24; // kr08_4
  unsigned int v25; // kr14_4
  _BOOL1 v26; // cc
  int v27; // ecx
  __int16 v28; // ax
  struct ARENA *v29; // ecx
  int v30; // ecx
  struct ARENA *v31; // ebp
  int v32; // eax
  int v33; // eax
  _DWORD *v34; // esi
  int v35; // edx
  int v36; // ecx
  __int16 *v37; // eax
  struct ARENA *v38; // ebp
  int v39; // eax
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // esi
  const CHAR *v44; // esi
  unsigned int v45; // kr20_4
  CHAR v46; // al
  __int16 v47; // ax
  __int16 v48; // bx
  int v49; // eax
  signed __int8 v50; // al
  int v51; // ecx
  _DWORD *v52; // eax
  int v53; // edx
  unsigned int v54; // eax
  int v55; // edx
  int v56; // edx
  int v57; // ecx
  int v58; // eax
  int v59; // esi
  int *v60; // eax
  int v61; // edx
  int v62; // eax
  int v63; // eax
  int v64; // esi
  int v65; // ecx
  unsigned int v66; // kr30_4
  int v67; // eax
  void *v68; // eax
  int v69; // edx
  int v70; // eax
  char *v71; // ecx
  int v72; // eax
  char *v73; // ecx
  BYTE v74; // dl
  char v75; // al
  BYTE *v76; // ecx
  int v77; // esi
  int v78; // esi
  int v79; // esi
  int v80; // edi
  int v81; // edx
  int v82; // esi
  int v83; // eax
  int v84; // ecx
  unsigned int v85; // kr38_4
  __int16 v86; // cx
  __int64 v87; // rax
  __int64 v88; // rax
  int v89; // eax
  int v90; // edx
  int v91; // eax
  int v92; // eax
  __int16 v93; // ax
  __int16 v94; // dx
  int v95; // eax
  int v96; // eax
  int v97; // eax
  __int16 v98; // ax
  struct ARENA *v99; // ecx
  int v100; // edx
  __int16 v101; // ax
  player_data *v102; // esi
  int v103; // ecx
  __int16 v104; // ax
  int v105; // ecx
  int v106; // eax
  __int16 v107; // ax
  struct ARENA *v108; // ecx
  int v109; // ecx
  int v110; // eax
  int v111; // eax
  int v112; // eax
  struct ARENA *v113; // ecx
  int v114; // eax
  int v115; // eax
  int v116; // eax
  int v117; // edx
  int v118; // eax
  int v119; // ecx
  __int16 v120; // cx
  int v121; // ecx
  int v122; // eax
  int v123; // eax
  int v124; // edi
  int *v125; // edx
  int v126; // eax
  __int16 v127; // ax
  int v128; // ecx
  int v129; // eax
  DWORD v130; // ebx
  int v131; // ecx
  int v132; // edi
  int v133; // ecx
  int v134; // edi
  int v135; // eax
  int v136; // edi
  int v137; // edx
  int v138; // eax
  DWORD v139; // edi
  int v140; // eax
  int v141; // edx
  _DWORD *v142; // ecx
  int v143; // ebx
  _DWORD *v144; // eax
  int v145; // eax
  int v146; // ebx
  int v147; // eax
  int v148; // eax
  int v149; // edx
  int v150; // ecx
  player_data *v151; // esi
  int v152; // eax
  int v153; // edi
  int v154; // ebx
  int v155; // edi
  unsigned int v156; // kr40_4
  PLAYER *v157; // edi
  int v158; // ecx
  __int16 v159; // bx
  int v160; // esi
  int v161; // edi
  __int16 v162; // ax
  __int16 v163; // dx
  ARENA *v164; // ecx
  int v165; // esi
  int v166; // eax
  int v167; // edi
  int v168; // eax
  int v169; // ecx
  int v170; // edx
  BOOL v171; // ecx
  int v172; // ecx
  int v173; // eax
  int v174; // eax
  __int16 v175; // ax
  __int16 v176; // ax
  int v177; // esi
  int v178; // edi
  int v179; // edx
  _DWORD *v180; // eax
  __int16 v181; // dx
  __int16 v182; // cx
  int v183; // edx
  __int16 v184; // cx
  int v185; // ebx
  int v186; // edi
  int v187; // esi
  int v188; // eax
  int v189; // eax
  int v190; // esi
  __int64 v191; // rax
  __int16 v192; // ax
  int v193; // ecx
  int v194; // edx
  int v195; // edi
  _DWORD *v196; // eax
  __int16 v197; // ax
  int v198; // eax
  int v199; // eax
  int v200; // ecx
  signed __int8 v201; // cl
  char v202; // al
  int v203; // eax
  __int16 v204; // cx
  int v205; // edi
  int v206; // esi
  int v207; // eax
  struct ARENA *v208; // ecx
  __int16 v209; // ax
  int v210; // ecx
  int v211; // eax
  __int16 v212; // bx
  int v213; // esi
  int v214; // eax
  PLAYER *v215; // ecx
  int v216; // ebp
  PLAYER *v217; // ecx
  int v218; // eax
  struct ARENA *v219; // ecx
  int *v220; // ebp
  int v221; // esi
  int v222; // eax
  __int16 v223; // dx
  char v224; // al
  __int16 v225; // bx
  int v226; // ebx
  char *v227; // eax
  __int16 v228; // dx
  unsigned int v229; // kr58_4
  int v230; // eax
  char v231; // al
  struct ARENA *v232; // ecx
  int v233; // eax
  int v234; // eax
  int v235; // eax
  unsigned int v236; // kr60_4
  _BYTE *v237; // edx
  int v238; // eax
  int v239; // eax
  unsigned int v240; // kr6C_4
  _BYTE *v241; // edx
  player_data *v242; // edi
  unsigned int v243; // kr78_4
  bool v244; // esi
  player_data *v245; // edi
  int v246; // eax
  int v247; // esi
  unsigned int v248; // kr88_4
  unsigned int v249; // kr90_4
  __int16 v250; // ax
  int v251; // eax
  __int16 v252; // dx
  int v253; // eax
  int v254; // ecx
  int v255; // eax
  int v256; // edi
  int v257; // esi
  int v258; // eax
  int v259; // eax
  bool v260; // eax
  char *v261; // ebx
  int v262; // edi
  char *v263; // esi
  int v264; // ecx
  signed __int8 v265; // al
  const char *v266; // eax
  int v267; // eax
  int *v268; // ecx
  int v269; // edx
  int v270; // esi
  int *v271; // eax
  int v272; // ecx
  int v273; // ebx
  int *v274; // eax
  int v275; // eax
  unsigned int v276; // krA0_4
  struct BILLING_SERVER_STRUCT *v277; // ecx
  int v278; // ecx
  int v279; // eax
  int v280; // ecx
  int v281; // eax
  int v282; // eax
  __int64 v283; // rax
  const char *v284; // [esp-8h] [ebp-6FCh]
  const char *v285; // [esp+0h] [ebp-6F4h]
  int v286; // [esp+4h] [ebp-6F0h]
  int v287; // [esp+8h] [ebp-6ECh]
  int v288; // [esp+Ch] [ebp-6E8h]
  char v289[4]; // [esp+10h] [ebp-6E4h] BYREF
  __int64 player; // [esp+14h] [ebp-6E0h] BYREF
  int v291; // [esp+1Ch] [ebp-6D8h]
  DWORD DiffSinceLastUpdate1; // [esp+20h] [ebp-6D4h]
  player_data *Player; // [esp+24h] [ebp-6D0h]
  char v294; // [esp+28h] [ebp-6CCh] BYREF
  char v295; // [esp+29h] [ebp-6CBh]
  int v296; // [esp+2Ah] [ebp-6CAh]
  int v297; // [esp+2Eh] [ebp-6C6h]
  int v298; // [esp+32h] [ebp-6C2h]
  int v299; // [esp+36h] [ebp-6BEh]
  char v300; // [esp+3Ah] [ebp-6BAh]
  char v301; // [esp+3Bh] [ebp-6B9h]
  int v302; // [esp+3Ch] [ebp-6B8h]
  int v303; // [esp+40h] [ebp-6B4h]
  char buf; // [esp+4Ch] [ebp-6A8h] BYREF
  _BYTE v305[12]; // [esp+4Dh] [ebp-6A7h]
  __int16 v306; // [esp+59h] [ebp-69Bh]
  char v307; // [esp+5Bh] [ebp-699h]
  char v308; // [esp+6Ch] [ebp-688h] BYREF
  char v309; // [esp+6Dh] [ebp-687h]
  int v310; // [esp+6Eh] [ebp-686h]
  char v311; // [esp+7Fh] [ebp-675h]
  char a4; // [esp+90h] [ebp-664h] BYREF
  char v313; // [esp+91h] [ebp-663h]
  char v314; // [esp+92h] [ebp-662h] BYREF
  __int16 v315; // [esp+93h] [ebp-661h]
  char v316[507]; // [esp+95h] [ebp-65Fh] BYREF
  char violation[256]; // [esp+290h] [ebp-464h] BYREF
  char v318; // [esp+390h] [ebp-364h] BYREF
  __int16 v319; // [esp+391h] [ebp-363h]
  char v320[96]; // [esp+393h] [ebp-361h] BYREF
  char v321[256]; // [esp+3F4h] [ebp-300h] BYREF
  char v322[3]; // [esp+4F4h] [ebp-200h] BYREF
  __int16 v323; // [esp+4F7h] [ebp-1FDh]
  char v324[507]; // [esp+4F9h] [ebp-1FBh] BYREF

  v3 = pkt;
  v5 = (char)*pkt;
  LODWORD(player) = v5;
  switch ( v5 )
  {
    case 1:
      if ( p->player_name[offsetof(PLAYER, hProcess)] )
      {
        v231 = pkt[1];
        if ( v231 <= 8 && v231 >= 0 )
        {
          v232 = (struct ARENA *)p->lpCurrentArena;
          if ( v232 )
          {
            ArenaRemovePlayer(v232, p);
            p->lpCurrentArena = 0;
          }
          *(_DWORD *)&p->field_117[92] = -1;
          p->dwShip = (char)pkt[1];
          p->bFilterObscene = (char)pkt[2];
          p->dwXRes = *((__int16 *)pkt + 2);
          p->dwYRes = *((__int16 *)pkt + 3);
          p->bWaveMessages = (char)pkt[3];
          if ( *(_DWORD *)&p->field_2B7[52] )
            p->dwShip = 8;
          *(_DWORD *)&p->field_2F9[16] = 1;
          *(_WORD *)((char *)&player + 1) = p->field_14;
          LOBYTE(v291) = 1;
          PlayerFindSuitableArena(
            p,
            *((__int16 *)pkt + 4),
            (char *)pkt + 10,
            (int)v285,
            v286,
            v287,
            v288,
            *(int *)v289,
            player,
            SHIDWORD(player));
          p->lpCurrentArena = v233;
          *(_DWORD *)p->lpArenaPointer2 = v233;
          JUMPOUT(0x4157B6);
        }
        if ( !p->bIsSmod )
        {
          sprintf(violation, "Packet tampering(%d)", (char)*pkt);
          ProtocolViolation();
          v234 = p->lpCurrentArena;
          if ( v234 )
          {
            if ( *(_DWORD *)(v234 + 109802) )
            {
              p->dwDisconnectReason = 16;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
        }
      }
      return;
    case 2:
      v219 = (struct ARENA *)p->lpCurrentArena;
      if ( v219 )
      {
        ArenaRemovePlayer(v219, p);
        p->lpCurrentArena = 0;
      }
      printf("Player leaving game: %s\n", p->player_name);
      v220 = &p->lpSomePtr;
      v221 = 4;
      do
      {
        if ( *v220 )
        {
          efree((LPVOID)*v220);
          *v220 = 0;
        }
        v220 += 2;
        --v221;
      }
      while ( v221 );
      return;
    case 3:
      *(_DWORD *)&p->field_2F9[16] = 0;
      if ( !p->lpCurrentArena )
        return;
      v74 = pkt[10];
      v75 = 0;
      pkt[10] = 0;
      v76 = pkt;
      v77 = 22;
      do
      {
        v75 ^= *v76++;
        --v77;
      }
      while ( v77 );
      if ( v75 != v74 )
      {
        if ( !p->bIsSysop )
        {
          v78 = *(_DWORD *)&p->field_117[64] + 1;
          *(_DWORD *)&p->field_117[64] = v78;
          if ( v78 >= *(_DWORD *)(p->lpCurrentArena + 109814) )
          {
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
        }
        return;
      }
      if ( (pkt[11] & 0x40) != 0 && !*(_DWORD *)&p->field_2C[16] )
        return;
      if ( *((__int16 *)pkt + 8) > 10000 && !p->bIsSmod && !*(_DWORD *)&p->field_2F9[12] )
        goto LABEL_341;
      if ( (pkt[20] & 0x1F) != 0 )
        *(_DWORD *)&p->field_44[120] = 0;
      v79 = *(_DWORD *)(pkt + 2);
      v80 = p->lpNetworkData;
      v81 = ((*(_DWORD *)(v80 + 14) + ((int (__thiscall *)(BYTE *))GetTickCount)(v76) / 0xAu) & 0x7FFFFFFF) - v79;
      v82 = v81;
      v291 = v81;
      if ( v81 < 0 || v81 > 30000 )
      {
        v82 = 0;
        v291 = 0;
      }
      if ( v82 > *(_DWORD *)(p->lpCurrentArena + 109854) )
        *((_WORD *)pkt + 10) &= 0x7F80u;
      if ( v82 < *(_DWORD *)(p->lpCurrentArena + 109862) || v82 > 800 || p->bIsSysop )
        *(_DWORD *)&p->field_44[116] = ((int (*)(void))GetTickCount)() / 0xAu;
      if ( v82 < *(_DWORD *)(p->lpCurrentArena + 109846) || v82 > 800 || p->bIsSysop )
        ++*(_DWORD *)&p->field_44[128];
      else
        ++*(_DWORD *)&p->field_44[132];
      v83 = *(_DWORD *)&p->field_44[128];
      if ( v83 + *(_DWORD *)&p->field_44[132] > *(_DWORD *)(p->lpCurrentArena + 109850) )
      {
        *(_DWORD *)&p->field_44[136] += v83;
        *(_DWORD *)&p->field_44[140] += *(_DWORD *)&p->field_44[132];
        if ( p->dwShip != 8 )
        {
          v84 = p->lpCurrentArena;
          if ( 1000 * *(_DWORD *)&p->field_44[132] / (*(_DWORD *)&p->field_44[132] + *(_DWORD *)&p->field_44[128]) > *(_DWORD *)(v84 + 109834) )
          {
            if ( v84 )
            {
              a4 = 7;
              v313 = 0;
              v314 = 0;
              v315 = -1;
              strcpy(v316, "You have been put in spectator mode due to high latency (C2S)");
              v85 = strlen("You have been put in spectator mode due to high latency (C2S)") + 1;
              if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                PlayerSendPacket(p, &a4, v85 - 1 + 6, 1);
            }
            SetPlayerShip(p, SHIP_NONE);
            v3 = pkt;
            v82 = v291;
          }
        }
        *(_DWORD *)&p->field_44[128] = 0;
        *(_DWORD *)&p->field_44[132] = 0;
      }
      if ( v82 < 800 && v82 > 0 )
      {
        *(_DWORD *)p->field_319 += v82;
        ++*(_DWORD *)&p->field_319[4];
      }
      v86 = *((_WORD *)v3 + 6);
      if ( v86 >= 0 && *((__int16 *)v3 + 4) >= 0 && p->dwShip != 8 )
      {
        if ( *(_DWORD *)(p->lpCurrentArena + 109878) && rand() % 1000 < *(_DWORD *)&p->field_117[60] )
          *((_WORD *)v3 + 10) &= 0x7F80u;
        v87 = *((__int16 *)v3 + 6) - p->xPixels;
        if ( (int)((HIDWORD(v87) ^ v87) - HIDWORD(v87)) > 512
          || (v88 = *((__int16 *)v3 + 4) - p->yPixels, (int)((HIDWORD(v88) ^ v88) - HIDWORD(v88)) > 512) )
        {
          *(_DWORD *)&p->field_EA[37] = 1;
        }
        if ( (v3[11] & 0x20) != 0 && (p->gap_E6[1] & 0x20) == 0 )
          *(_DWORD *)&p->field_EA[37] = 1;
        qmemcpy(&p->field_44[152], pkt, 0x16u);
        if ( (*(_WORD *)&p->field_EA[6] & 0x1F) == 8 )
        {
          v89 = *(_DWORD *)p->field_283;
          v90 = v89;
          if ( v89 >= 3 )
            v90 = 3;
          if ( v90 >= 0 )
          {
            if ( v89 >= 3 )
              LOBYTE(v89) = 3;
          }
          else
          {
            LOBYTE(v89) = 0;
          }
          *(_WORD *)&p->field_EA[6] = (32 * (v89 & 3)) | *(_WORD *)&p->field_EA[6] & 0xFF9F;
        }
        if ( pkt_sz > 0x16 )
        {
          *(_DWORD *)&p->field_EA[23] = *(_DWORD *)(pkt + 22);
          *(_DWORD *)&p->field_EA[27] = *(_DWORD *)(pkt + 26);
          *(_WORD *)&p->field_EA[31] = *((_WORD *)pkt + 15);
          *(_DWORD *)&p->field_EA[33] = 1;
        }
        sub_40D8D0((int)p);
        *(_DWORD *)&p->field_EA[19] = 1;
        if ( (p->field_EA[6] & 0x1F) != 0 )
          SendWeaponPacket(p);
        return;
      }
      v91 = *(_DWORD *)&p->field_117[92];
      if ( v91 < 0 )
      {
        if ( v86 < 0 || *((__int16 *)v3 + 4) < 0 )
        {
          v93 = p->xPixels;
          v94 = p->yPixels;
          qmemcpy(&p->field_44[152], pkt, 0x16u);
          p->xPixels = v93;
          p->yPixels = v94;
        }
        else
        {
          qmemcpy(&p->field_44[152], pkt, 0x16u);
        }
      }
      else
      {
        v92 = (int)*(&ZonePlayerList + v91);
        if ( !v92 )
          goto LABEL_196;
        p->xPixels = *(_WORD *)(v92 + 232);
        p->yPixels = *(_WORD *)(v92 + 228);
      }
      sub_40D8D0((int)p);
LABEL_196:
      v95 = *(_DWORD *)&p->field_231[50];
      if ( v95 >= 0 )
      {
        v96 = (int)*(&ZonePlayerList + v95);
        if ( v96 )
        {
          p->xPixels = *(_WORD *)(v96 + 232);
          p->yPixels = *(_WORD *)(v96 + 228);
          sub_40D8D0((int)p);
        }
      }
      return;
    case 5:
      if ( !p->lpCurrentArena )
        return;
      UpdatePowerBallPositionsSomething(p);
      *(_DWORD *)&p->field_44[144] = 0;
      v101 = *(_WORD *)(pkt + 1);
      if ( v101 <= 1024 && *(__int16 *)(pkt + 3) <= 20000 && v101 >= 0 )
      {
        DiffSinceLastUpdate1 = 0;
        Player = (player_data *)*(&ZonePlayerList + v101);
        v102 = Player;
        if ( Player && *((_DWORD *)Player + 7) != p->lpCurrentArena )
        {
          v102 = 0;
          Player = 0;
        }
        v103 = p->lpCurrentArena;
        if ( !*(_DWORD *)(v103 + 109726) )
        {
          if ( !v102 )
            goto LABEL_223;
          if ( *(_DWORD *)((char *)v102 + 279) == *(_DWORD *)p->field_117 )
          {
            v104 = p->field_14;
            v289[0] = 22;
            *(_WORD *)&v289[1] = v104;
            ArenaSendPacket((struct ARENA *)v103, v289, 3, 1);
            v105 = p->lpCurrentArena;
            v106 = *(_DWORD *)(v105 + 109746);
            if ( v106 )
            {
              if ( v106 == 1 )
              {
                CarryFlagsSomething((ARENA *)v105, *(_DWORD *)&p->field_14, 1);
                sub_404120(p->lpCurrentArena, 0);
              }
            }
            else
            {
              CarryFlagsSomething((ARENA *)v105, *(_DWORD *)&p->field_14, 0);
            }
          }
        }
        if ( v102 && *(_DWORD *)((char *)v102 + 275) == 8 )
        {
          v107 = p->field_14;
          v108 = (struct ARENA *)p->lpCurrentArena;
          v289[0] = 22;
          *(_WORD *)&v289[1] = v107;
          ArenaSendPacket(v108, v289, 3, 1);
          v109 = p->lpCurrentArena;
          v110 = *(_DWORD *)(v109 + 109746);
          if ( v110 )
          {
            if ( v110 == 1 )
            {
              CarryFlagsSomething((ARENA *)v109, *(_DWORD *)&p->field_14, 1);
              sub_404120(p->lpCurrentArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething((ARENA *)v109, *(_DWORD *)&p->field_14, 0);
          }
        }
LABEL_223:
        v111 = *(_DWORD *)&p->field_2F9[24];
        if ( v111 <= 0 )
        {
          if ( v102 )
          {
            if ( *(int *)((char *)v102 + 785) > 0 )
            {
              v122 = p->lpCurrentArena;
              if ( *(int *)(v122 + 109918) > 0
                && *(__int16 *)(pkt + 3) >= *(_DWORD *)(v122 + 109922)
                && *(_DWORD *)p->field_117 != *(_DWORD *)((char *)v102 + 279) )
              {
                LOBYTE(player) = 45;
                *(_DWORD *)((char *)&player + 1) = *(_DWORD *)(v122 + 109918);
                PlayerSendPacket((PLAYER *)v102, &player, 5, 1);
              }
            }
          }
        }
        else
        {
          v112 = v111 - 1;
          *(_DWORD *)&p->field_2F9[24] = v112;
          if ( v112 )
          {
            v114 = p->lpCurrentArena;
            LOBYTE(player) = 43;
            *(_DWORD *)((char *)&player + 1) = *(_DWORD *)(v114 + 109914);
            PlayerSendPacket(p, &player, 5, 1);
          }
          else
          {
            HIWORD(player) = p->field_14;
            v113 = (struct ARENA *)p->lpCurrentArena;
            LOWORD(player) = 44;
            *(_DWORD *)((char *)&player + 2) = 0;
            ArenaSendPacket(v113, (char *)&player, 8, 1);
          }
          if ( v102 )
          {
            if ( *(int *)((char *)v102 + 785) <= 0 )
            {
              v116 = *((_DWORD *)v102 + 53) + 1;
              *((_DWORD *)v102 + 53) = v116;
              v117 = v116;
              v118 = p->lpCurrentArena;
              v119 = *(_DWORD *)(v118 + 109930);
              if ( v119 > 0 && v117 >= v119 )
              {
                v120 = *((_WORD *)v102 + 10);
                *(_DWORD *)((char *)v102 + 785) = *(_DWORD *)(v118 + 109910);
                HIWORD(player) = v120;
                v121 = p->lpCurrentArena;
                LOWORD(player) = 300;
                *(_DWORD *)((char *)&player + 2) = *(_DWORD *)(v121 + 109914);
                ArenaSendPacket((struct ARENA *)v121, (char *)&player, 8, 1);
              }
            }
            else
            {
              v115 = p->lpCurrentArena;
              LOBYTE(player) = 43;
              *(_DWORD *)((char *)&player + 1) = *(_DWORD *)(v115 + 109914);
              PlayerSendPacket((PLAYER *)v102, &player, 5, 1);
            }
          }
        }
        *(_DWORD *)&p->field_44[124] = *(_DWORD *)(p->lpCurrentArena + 109666);
        v123 = *(_DWORD *)&p->field_44[120] + 1;
        *(_DWORD *)&p->field_44[120] = v123;
        if ( v123 > *(_DWORD *)(p->lpCurrentArena + 109818) && !p->bIsModerator )
        {
          WriteSubGameLog("Played kicked off for too many deaths without firing: %s\n", p->Name);
          p->dwDisconnectReason = 10;
          *(_DWORD *)&p->field_2C[12] = 1;
        }
        v124 = p->lpCurrentArena;
        *(_DWORD *)v289 = 0;
        v291 = 0;
        if ( *(_BYTE *)(v124 + 109578) && *(int *)(v124 + 108190) > 0 )
        {
          v125 = (int *)(v124 + 100006);
          LODWORD(player) = *(_DWORD *)(v124 + 108190);
          do
          {
            v126 = *v125;
            if ( *v125 == *(_DWORD *)&p->field_14 )
              ++*(_DWORD *)v289;
            if ( v126 == *(__int16 *)(pkt + 1) )
              ++v291;
            v125 += 4;
            LODWORD(player) = player - 1;
          }
          while ( (_DWORD)player );
        }
        if ( *(_BYTE *)(v124 + 109578) == 2 && *(int *)v289 > 0 && v291 > 0 )
        {
          v127 = p->field_14;
          v289[0] = 22;
          *(_WORD *)&v289[1] = v127;
          ArenaSendPacket((struct ARENA *)v124, v289, 3, 1);
          v128 = p->lpCurrentArena;
          v129 = *(_DWORD *)(v128 + 109746);
          if ( v129 )
          {
            if ( v129 == 1 )
            {
              CarryFlagsSomething((ARENA *)v128, *(_DWORD *)&p->field_14, 1);
              sub_404120(p->lpCurrentArena, 0);
            }
          }
          else
          {
            CarryFlagsSomething((ARENA *)v128, *(_DWORD *)&p->field_14, 0);
          }
          *(_DWORD *)v289 = 0;
        }
        if ( *(__int16 *)(pkt + 1) == *(_DWORD *)&p->field_14 )
        {
          v130 = -*(__int16 *)(pkt + 3);
          DiffSinceLastUpdate1 = v130;
          printf("%s(%d) killed by self\n", p->player_name, v130);
          FormatMessageArena((ARENA *)p->lpCurrentArena, "%s(%d) killed by self\n", p->player_name, v130);
          v131 = p->lpCurrentArena;
          v132 = *(_DWORD *)&p->field_283[20] + 1;
          *(_DWORD *)&p->field_283[20] = v132;
          if ( v132 > *(_DWORD *)(v131 + 109806) )
          {
            WriteSubGameLog("Played kicked off for too many suicides: %s\n", p->Name);
            p->dwDisconnectReason = 19;
            *(_DWORD *)&p->field_2C[12] = 1;
          }
          CarryFlagsSomething((ARENA *)p->lpCurrentArena, *(_DWORD *)&p->field_14, 0);
          goto LABEL_300;
        }
        *(_DWORD *)&p->field_283[20] = 0;
        if ( !v102 )
        {
          printf("%s killed by UNKNOWN\n", p->player_name);
          CarryFlagsSomething((ARENA *)p->lpCurrentArena, *(_DWORD *)&p->field_14, 0);
LABEL_299:
          dword_4D9E04 = *(_DWORD *)&p->field_14;
LABEL_300:
          LODWORD(player) = -1;
          if ( v102 )
          {
            v151 = Player;
            v152 = 0;
            v153 = *(_DWORD *)((char *)Player + 553);
            v154 = *(_DWORD *)((char *)Player + 557);
            LODWORD(player) = *(_DWORD *)((char *)Player + 279);
            v155 = v154 + v153;
            if ( (int)DiffSinceLastUpdate1 > 0 && v291 > 0 )
              v152 = DiffSinceLastUpdate1 * *(__int16 *)(p->lpCurrentArena + 109484);
            UpdatePoints((struct PLAYER *)Player, DiffSinceLastUpdate1, v152);
            if ( *(int *)((char *)v151 + 553) < 0 )
              *(_DWORD *)((char *)v151 + 553) = 0;
            if ( v155 < dword_4B061C
              && dword_4B061C > 0
              && *(_DWORD *)((char *)Player + 557) + *(_DWORD *)((char *)Player + 553) >= dword_4B061C )
            {
              if ( *((_DWORD *)Player + 7) )
              {
                a4 = 7;
                v313 = 0;
                v314 = 0;
                v315 = -1;
                strcpy(v316, lpszPermission_AutoPermissionMessage);
                v156 = strlen(lpszPermission_AutoPermissionMessage) + 1;
                v157 = (PLAYER *)Player;
                if ( GetRelAckDiff(*((struct CONNECTION **)Player + 10), 0) < 128 )
                  PlayerSendPacket(v157, &a4, v156 - 1 + 6, 1);
              }
            }
          }
          v158 = p->lpCurrentArena;
          ++p->score.losses;
          v159 = DiffSinceLastUpdate1;
          v160 = *(_DWORD *)(v158 + 65382);
          *(_DWORD *)(v158 + 65382) = v160 + (int)(DiffSinceLastUpdate1 * *(_DWORD *)(v158 + 109750)) / 1000;
          if ( dwMisc_JackpotBroadcastPoints > 0 )
          {
            v161 = p->lpCurrentArena;
            v291 = *(_DWORD *)(v161 + 65382) / dwMisc_JackpotBroadcastPoints;
            if ( v160 / dwMisc_JackpotBroadcastPoints < v291 )
            {
              a4 = 2;
              v313 = 0;
              sprintf(
                &v314,
                "Jackpot just passed %d points in %s",
                dwMisc_JackpotBroadcastPoints * (*(_DWORD *)(v161 + 65382) / dwMisc_JackpotBroadcastPoints),
                &BillingServerName);
              if ( BillingConnectionStructPointer )
                SendBillerUserPrivateChatPacket(
                  BillingConnectionStructPointer,
                  -1,
                  dwBilling_GroupID,
                  &a4,
                  strlen(&v314) + 3);
            }
          }
          v162 = p->field_14;
          buf = 6;
          *(_WORD *)&v305[3] = v162;
          v163 = *(_WORD *)(pkt + 1);
          *(_WORD *)&v305[7] = *(_WORD *)v289;
          v164 = (ARENA *)p->lpCurrentArena;
          *(_WORD *)&v305[1] = v163;
          *(_WORD *)&v305[5] = v159;
          v165 = 0;
          v305[0] = GetDeathPrizeGreenId(v164);
          if ( *(_WORD *)&v305[7] || abs16(*(__int16 *)&v305[5]) > 0xA0u )
          {
            ArenaSendPacket((struct ARENA *)p->lpCurrentArena, &buf, 10, 1);
          }
          else
          {
            v166 = p->lpCurrentArena;
            if ( *(_DWORD *)(v166 + 109754) )
            {
              if ( *(int *)(v166 + 65292) > 0 )
              {
                v167 = 64288;
                do
                {
                  v168 = *(_DWORD *)(v167 + v166);
                  v169 = *(_DWORD *)&p->field_14;
                  v171 = 1;
                  if ( *(_DWORD *)(v168 + 611) != v169 )
                  {
                    v170 = *(_DWORD *)(v168 + 20);
                    if ( v170 != v169 && v170 != *(__int16 *)(pkt + 1) )
                      v171 = 0;
                  }
                  PlayerSendPacket((PLAYER *)v168, &buf, 10, v171);
                  v166 = p->lpCurrentArena;
                  ++v165;
                  v167 += 4;
                }
                while ( v165 < *(_DWORD *)(v166 + 65292) );
              }
            }
            else
            {
              v172 = *(_DWORD *)(v166 + 65292);
              v291 = 0;
              if ( v172 > 0 )
                JUMPOUT(0x4159D0);
            }
          }
          v173 = *(_DWORD *)(p->lpCurrentArena + 109734);
          if ( v173 > 0 && (unsigned __int16)p->score.losses >= v173 )
            SetPlayerShip(p, 8);
          if ( dwAdvertise_SendMode == 3 || dwAdvertise_SendMode == 2 )
            SendAdvertisement(p, 0);
          if ( Player )
            SendPlayerScoreUpdateAll(Player);
          SendPlayerScoreUpdateAll(p);
          return;
        }
        v133 = p->lpCurrentArena;
        if ( *(int *)(v133 + 109686) < 0 )
        {
          v135 = *((__int16 *)v102 + 118);
          v136 = *(__int16 *)(v133 + 109470);
          if ( v135 >= 0 )
          {
            v137 = *(__int16 *)(pkt + 3) - v135;
            if ( v137 < v136 )
              v136 = *(__int16 *)(pkt + 3) - v135;
            v138 = -*(__int16 *)(v133 + 109472);
            if ( v136 <= v138 || (v138 = *(__int16 *)(v133 + 109470), v137 >= v138) )
              v137 = v138;
            v134 = v137 + *(__int16 *)(pkt + 3) + *(__int16 *)(v133 + 109474);
          }
          else
          {
            v134 = *(__int16 *)(pkt + 3);
          }
        }
        else
        {
          v134 = *(_DWORD *)(v133 + 109686);
        }
        v139 = *(_DWORD *)(v133 + 109682) * *((__int16 *)v102 + 118) / 100 + v134;
        LODWORD(player) = *(_DWORD *)(v133 + 109670);
        DiffSinceLastUpdate1 = v139;
        if ( (_DWORD)player
          && *(_DWORD *)(v133 + 65292) > *(_DWORD *)(v133 + 109658)
          && *(__int16 *)(pkt + 3) > *(_DWORD *)(v133 + 109674) )
        {
          v140 = *(_DWORD *)(v133 + 108190);
          v141 = 0;
          if ( v140 > 0 )
          {
            v142 = (_DWORD *)(v133 + 100010);
            do
            {
              if ( *v142 == *(_DWORD *)((char *)v102 + 279) )
                ++v141;
              v142 += 4;
              --v140;
            }
            while ( v140 );
          }
          DiffSinceLastUpdate1 = player * v141 + v139;
        }
        v143 = 0;
        v144 = (_DWORD *)((char *)v102 + 108);
        while ( *v144 != p->dwUserID )
        {
          ++v143;
          v144 += 2;
          if ( v143 >= 8 )
          {
            v145 = 0xFFFFFFF;
            goto LABEL_286;
          }
        }
        v283 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *((_DWORD *)v102 + 2 * v143 + 26));
        v145 = (HIDWORD(v283) ^ v283) - HIDWORD(v283);
LABEL_286:
        if ( v145 >= *(_DWORD *)(p->lpCurrentArena + 109678) )
        {
          v146 = p->dwUserID;
          *((_DWORD *)v102 + 2 * *((_DWORD *)v102 + 42) + 26) = ((int (*)(void))GetTickCount)() / 0xAu;
          *((_DWORD *)v102 + 2 * *((_DWORD *)v102 + 42) + 27) = v146;
          *((_DWORD *)v102 + 42) = (*((_DWORD *)v102 + 42) + 1) % 8;
          if ( *(_DWORD *)((char *)v102 + 279) != *(_DWORD *)p->field_117 )
          {
            v147 = *((_DWORD *)v102 + 48);
            if ( v147 <= 0 )
            {
LABEL_291:
              ++*(_WORD *)((char *)v102 + 547);
              FormatMessageArena(
                (ARENA *)p->lpCurrentArena,
                "%s(%d) killed by %s\n",
                p->player_name,
                DiffSinceLastUpdate1,
                (const char *)v102 + 375);
              v148 = p->lpCurrentArena;
              if ( *(_BYTE *)(v148 + 109578) )
              {
                v149 = 0;
                if ( *(int *)(v148 + 108190) > 0 )
                {
                  v150 = 0;
                  do
                  {
                    if ( *(_DWORD *)(v150 + v148 + 100006) == *(_DWORD *)&p->field_14 )
                    {
                      *(_DWORD *)(v150 + v148 + 100006) = *((_DWORD *)v102 + 5);
                      *(_DWORD *)(v150 + p->lpCurrentArena + 100010) = *(_DWORD *)((char *)v102 + 279);
                    }
                    v148 = p->lpCurrentArena;
                    ++v149;
                    v150 += 16;
                  }
                  while ( v149 < *(_DWORD *)(v148 + 108190) );
                }
              }
              goto LABEL_299;
            }
            *((_DWORD *)v102 + 48) = v147 - 1;
          }
        }
        DiffSinceLastUpdate1 = 0;
        goto LABEL_291;
      }
      if ( !p->bIsSmod )
      {
LABEL_341:
        sprintf(violation, "Packet tampering(%d)", (char)*pkt);
        ProtocolViolation();
        v174 = p->lpCurrentArena;
        if ( v174 && *(_DWORD *)(v174 + 109802) )
          goto LABEL_658;
      }
      return;
    case 6:
      if ( p->bIsSilenced || !p->lpCurrentArena )
        return;
      v228 = *(_WORD *)(pkt + 3);
      if ( v228 > 1024 || v228 < 0 )
        goto LABEL_483;
      v229 = strlen((const char *)pkt + 5) + 1;
      if ( v229 - 1 > 0xFA )
      {
        v5 = player;
LABEL_483:
        if ( !p->bIsSmod )
        {
          sprintf(violation, "Packet tampering(%d)", v5);
          ProtocolViolation();
          v230 = p->lpCurrentArena;
          if ( v230 )
          {
            if ( *(_DWORD *)(v230 + 109802) )
              goto LABEL_658;
          }
        }
      }
      else
      {
        process_text_packet(
          (int)pkt,
          (int)p,
          (int)&pkt[v229 + 5],
          (int)(pkt + 5),
          (Player *)p,
          (char)pkt[1],
          v228,
          (char *)pkt + 5,
          (char)pkt[2]);
      }
      return;
    case 7:
      if ( p->lpCurrentArena && p->dwShip != 8 )
      {
        if ( *(__int16 *)(pkt + 9) >= 29
          || (v175 = *(_WORD *)(pkt + 5), v175 < 0)
          || v175 >= 1024
          || (v176 = *(_WORD *)(pkt + 7), v176 < 0)
          || v176 >= 1024 )
        {
          if ( !p->bIsSmod )
          {
            sprintf(violation, "Packet tampering(%d)", v5);
            ProtocolViolation();
            v189 = p->lpCurrentArena;
            if ( v189 )
            {
              if ( *(_DWORD *)(v189 + 109802) )
                goto LABEL_658;
            }
          }
        }
        else
        {
          v177 = *(_DWORD *)(pkt + 1);
          v178 = p->lpNetworkData;
          v179 = ((*(_DWORD *)(v178 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v177;
          if ( v179 < 0 || v179 > 30000 )
            v179 = 0;
          v180 = (_DWORD *)p->lpCurrentArena;
          if ( v179 <= *(_DWORD *)((char *)v180 + 109858) && *(_DWORD *)&p->field_EA[9] != *(_DWORD *)(pkt + 1) )
          {
            buf = 8;
            *(_DWORD *)&p->field_EA[8] = *(_DWORD *)pkt;
            *(_DWORD *)&p->field_EA[12] = *((_DWORD *)pkt + 1);
            *(_WORD *)&p->field_EA[16] = *((_WORD *)pkt + 4);
            p->field_EA[18] = pkt[10];
            v181 = *(_WORD *)(pkt + 7);
            *(_WORD *)&v305[4] = *(_WORD *)(pkt + 5);
            v182 = *(_WORD *)(pkt + 9);
            *(_WORD *)&v305[6] = v181;
            v183 = *(_DWORD *)(pkt + 1);
            *(_WORD *)&v305[8] = v182;
            v184 = p->field_14;
            *(_DWORD *)v305 = v183;
            *(_WORD *)&v305[10] = v184;
            v185 = *(_DWORD *)((char *)v180 + 109882);
            if ( v180 )
            {
              v186 = 0;
              if ( (int)v180[16323] > 0 )
              {
                v187 = 16072;
                do
                {
                  v188 = v180[v187];
                  if ( (PLAYER *)v188 != p && !*(_DWORD *)(v188 + 56) )
                    PlayerSendPacket((PLAYER *)v188, &buf, 13, v185);
                  v180 = (_DWORD *)p->lpCurrentArena;
                  ++v186;
                  ++v187;
                }
                while ( v186 < v180[16323] );
              }
            }
          }
        }
      }
      return;
    case 8:
      if ( p->lpCurrentArena )
      {
        v212 = *(_WORD *)(pkt + 1);
        if ( v212 == -1 || p->dwShip == 8 )
        {
          if ( v212 > 1024 || v212 < -1 )
          {
            if ( !p->bIsSmod )
            {
              sprintf(violation, "Packet tampering(%d)", v5);
              ProtocolViolation();
              v218 = p->lpCurrentArena;
              if ( v218 )
              {
                if ( *(_DWORD *)(v218 + 109802) )
                  goto LABEL_658;
              }
            }
          }
          else
          {
            v213 = *(_DWORD *)&p->field_117[92];
            *(_DWORD *)&p->field_117[92] = v212;
            if ( v212 >= 0 )
            {
              v214 = (int)*(&ZonePlayerList + v212);
              if ( v214 )
              {
                p->xPixels = *(_WORD *)(v214 + 232);
                p->yPixels = *(_WORD *)(v214 + 228);
                sub_40D8D0((int)p);
              }
            }
            if ( p->bIsSysop )
            {
              v289[0] = 28;
              if ( v213 >= 0 )
              {
                v215 = *(&ZonePlayerList + v213);
                v289[1] = 0;
                if ( v215 )
                  PlayerSendPacket(v215, v289, 2, 1);
              }
              v216 = *(_DWORD *)&p->field_117[92];
              if ( v216 >= 0 )
              {
                v217 = *(&ZonePlayerList + v216);
                v289[1] = 1;
                if ( v217 )
                  PlayerSendPacket(v217, v289, 2, 1);
              }
            }
          }
        }
        else
        {
          WriteSubGameLog("WARNING: Spectator request from non-spectator ship, ignoring\n");
        }
      }
      return;
    case 9:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
      v260 = *(_DWORD *)(pkt + 77) == 0;
      *(_DWORD *)&p->field_44[4] = v260;
      pkt[33] = BYTE1(v260);
      pkt[65] = BYTE1(v260);
      v291 = 0;
      v261 = (char *)(pkt + 2);
      Player = (player_data *)(pkt + 2);
      strcpy(&p->field_2B7[4], (const char *)pkt + 2);
      config_read_helper_3((char *)pkt + 2);
      printf("Connection request from: %s\n", (const char *)pkt + 2);
      v262 = 0;
      DiffSinceLastUpdate1 = 0;
      *(_DWORD *)v289 = pkt + 34;
      v263 = strrchr((const char *)pkt + 34, 42);
      if ( !v263 )
        goto LABEL_580;
      if ( _strcmpi(v263 + 1, szSysopPassword) )
      {
        if ( _strcmpi(v263 + 1, lpszPassword_SupermoderatorPassword) )
        {
          if ( _strcmpi(v263 + 1, lpszPassword_ModeratorPassword) )
          {
            if ( _strcmpi(v263 + 1, lpszPassword_VIPPassword) )
              goto LABEL_580;
            v262 = 1;
            DiffSinceLastUpdate1 = 1;
            WriteSubGameLog("%s>  VIP LOGGED IN\n", v261);
          }
          else
          {
            WriteSubGameLog("%s>  MODERATOR LOGGED IN\n", v261);
            v262 = 1;
            DiffSinceLastUpdate1 = 1;
            p->bIsModerator = 1;
          }
        }
        else
        {
          WriteSubGameLog("%s>  SUPER MODERATOR LOGGED IN\n", v261);
          v262 = 1;
          DiffSinceLastUpdate1 = 1;
          p->bIsModerator = 1;
          p->bIsSmod = 1;
        }
      }
      else
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", v261);
        v262 = 1;
        DiffSinceLastUpdate1 = 1;
        p->bIsSysop = 1;
        p->bIsModerator = 1;
        p->bIsSmod = 1;
      }
      *v263 = 0;
LABEL_580:
      if ( !v291 && BillingConnectionStructPointer && sub_407420(ModeratePointer, (int)v261) >= 0 )
      {
        v262 = 1;
        DiffSinceLastUpdate1 = 1;
        p->bIsModerator = 1;
      }
      p->player_name[0] = 0;
      strncpy(p->Name, v261, 0x18u);
      p->field_2B7[3] = 0;
      *(_DWORD *)p->field_2F9 = *(_DWORD *)(pkt + 66);
      *(_DWORD *)&p->field_2F9[8] = *(__int16 *)(pkt + 71);
      v264 = (char)pkt[70];
      *(_DWORD *)p->field_2C = v264;
      if ( v264 == 1 )
        *(_DWORD *)&p->field_2C[8] = 1;
      if ( !dwPermission_AllowLowBandwidth && !v262 )
      {
        v308 = 10;
        v309 = 8;
        v310 = 134;
        PlayerSendPacket(p, &v308, 36, 1);
        WriteSubGameLog("Played kicked off for having slow modem: %s\n", p->Name);
        *(_DWORD *)&p->field_2C[12] = 1;
        return;
      }
      *(_DWORD *)&p->field_44[32] = *(__int16 *)(pkt + 75);
      p->dwClientVersion = 0;
      v265 = *pkt;
      if ( (char)*pkt >= 35 && v265 <= 44 )
        p->dwClientVersion = v265 - 35;
      if ( !dword_4CBB20[1009 * p->dwClientVersion] )
        goto LABEL_593;
      if ( IsOffensiveName(v261) && !p->bIsModerator )
      {
        v294 = 10;
        v295 = 12;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        WriteSubGameLog("Played kicked off, obscene name: %s\n", v261);
        *(_DWORD *)&p->field_2C[12] = 1;
        return;
      }
      if ( dwPermission_PermissionMode == 1 && !p->bIsModerator && (v291 || sub_407420(PermitPointer, (int)v261) < 0) )
      {
LABEL_593:
        v294 = 10;
        v295 = 5;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        *(_DWORD *)&p->field_44[104] = ((int (*)(void))GetTickCount)() / 0xAu;
        return;
      }
      v266 = get_text_ip(p->in_addr);
      if ( IsBannedIPAddress(p->dwClientVersion, v266) )
      {
        v294 = 10;
        v295 = 4;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        WriteSubGameLog("Played kicked off, IP block: %s\n", p->Name);
        *(_DWORD *)&p->field_2C[12] = 1;
        return;
      }
      sprintf(&buf, "%d", *(_DWORD *)p->field_2F9);
      if ( sub_407420(IDBlockPointer, (int)&buf) >= 0 )
      {
        v294 = 10;
        v295 = 4;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        WriteSubGameLog("Played kicked off, ID block: %s\n", p->Name);
        *(_DWORD *)&p->field_2C[12] = 1;
        return;
      }
      v267 = 0;
      if ( MachineIdArrayCount > 0 )
      {
        v268 = dword_4AD738;
        while ( *v268 != *(_DWORD *)p->field_2F9 || p->bIsSysop )
        {
          ++v267;
          v268 += 3;
          if ( v267 >= MachineIdArrayCount )
            goto LABEL_613;
        }
        v294 = 10;
        v295 = 5;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        *(_DWORD *)&p->field_44[104] = ((int (*)(void))GetTickCount)() / 0xAu;
      }
LABEL_613:
      if ( !*(_DWORD *)&p->field_44[4] )
        goto LABEL_624;
      v269 = ZonePlayerCount;
      v270 = 0;
      if ( ZonePlayerCount > 0 )
      {
        v271 = ZonePlayers;
        v272 = ZonePlayerCount;
        do
        {
          if ( *(_DWORD *)(*v271 + 72) )
            ++v270;
          ++v271;
          --v272;
        }
        while ( v272 );
      }
      if ( dwMisc_MaxSharewarePlayers >= 0 && v270 > dwMisc_MaxSharewarePlayers )
      {
        v294 = 10;
        v295 = (dwMisc_MaxSharewarePlayers == 0) + 17;
        v296 = 134;
        v301 = 0;
        PlayerSendPacket(p, &v294, 36, 1);
        WriteSubGameLog("Played kicked off, arena full to demo users: %s\n", p->Name);
        *(_DWORD *)&p->field_2C[12] = 1;
        return;
      }
      if ( v291 )
      {
        memset(p->player_name, 0, 0xACu);
        sprintf(p->player_name, "~Demo%d", *(_DWORD *)&p->field_14);
        strcpy(p->Name, p->player_name);
        p->dwUserID = -1;
        *(_DWORD *)&p->score.wins = 0;
        *(_DWORD *)&p->score.flags = 0;
        *(int *)((char *)&p->score.points + 2) = 0;
        HIWORD(p->score.flag_points) = 0;
LABEL_624:
        v269 = ZonePlayerCount;
      }
      if ( v269 > MiscMaxPlayers && !DiffSinceLastUpdate1 )
      {
        v291 = 0;
        if ( dwMisc_RegisterKickShareware )
        {
          if ( !*(_DWORD *)&p->field_44[4] )
          {
            v273 = 0;
            if ( v269 > 0 )
            {
              v274 = ZonePlayers;
              while ( !*(_DWORD *)(*v274 + 72) )
              {
                ++v273;
                ++v274;
                if ( v273 >= v269 )
                  goto LABEL_638;
              }
              v275 = ZonePlayers[v273];
              v291 = 1;
              LODWORD(player) = v275;
              if ( *(_DWORD *)(v275 + 28) )
              {
                a4 = 7;
                v313 = 0;
                v314 = 0;
                v315 = -1;
                strcpy(v316, "You have been kicked off to make space for a registered user.");
                v276 = strlen("You have been kicked off to make space for a registered user.") + 1;
                if ( GetRelAckDiff(*(struct CONNECTION **)(player + 40), 0) < 128 )
                  PlayerSendPacket((PLAYER *)player, &a4, v276 - 1 + 6, 1);
              }
              *(_DWORD *)(ZonePlayers[v273] + 172) = ((int (*)(void))GetTickCount)() / 0xAu;
            }
          }
        }
LABEL_638:
        if ( !v291 )
        {
          v294 = 10;
          v295 = 3;
          v296 = 134;
          v301 = 0;
          PlayerSendPacket(p, &v294, 36, 1);
          WriteSubGameLog("Played kicked off, arena full: %s\n", p->Name);
          *(_DWORD *)&p->field_2C[12] = 1;
          return;
        }
      }
      v277 = BillingConnectionStructPointer;
      if ( BillingConnectionStructPointer )
      {
        if ( !DiffSinceLastUpdate1 )
        {
          if ( GetRelAckDiff(encryption, 0) > dwComms_MaxQueueToLogIn )
          {
            v294 = 10;
            v295 = 14;
            v296 = 134;
            v301 = 0;
            PlayerSendPacket(p, &v294, 36, 1);
            *(_DWORD *)&p->field_2C[12] = 1;
            return;
          }
          v277 = BillingConnectionStructPointer;
        }
        if ( *(_DWORD *)&p->field_44[4] && dwMisc_DisableShareware )
          j_lpfnFixExport10(
            v277,
            &Default,
            &Default,
            p->in_addr.S_un.S_addr,
            *(_DWORD *)p->field_2F9,
            *(_DWORD *)&p->field_2F9[8],
            pkt[1],
            p->connection_id,
            (int)pkt,
            (void *)p->bIsSysop);
        else
          j_lpfnFixExport10(
            v277,
            Player,
            *(const void **)v289,
            p->in_addr.S_un.S_addr,
            *(_DWORD *)p->field_2F9,
            *(_DWORD *)&p->field_2F9[8],
            pkt[1],
            p->connection_id,
            (int)pkt,
            (void *)p->bIsSysop);
      }
      else if ( sub_407420(ReservedPointer, (int)Player) < 0 || DiffSinceLastUpdate1 )
      {
        memset(p->player_name, 0, 0xACu);
        v294 = 10;
        v295 = 13;
        strcpy(p->player_name, (const char *)Player);
        v296 = 134;
        *(_DWORD *)&p->score.wins = 0;
        *(_DWORD *)&p->score.flags = 0;
        *(int *)((char *)&p->score.points + 2) = 0;
        HIWORD(p->score.flag_points) = 0;
        v278 = p->dwClientVersion;
        v297 = 0;
        v299 = 0;
        v279 = 1009 * v278;
        v300 = 0;
        v301 = 0;
        v280 = dword_4CBB20[1009 * v278];
        v302 = dword_4CBB28[v279];
        v281 = p->bIsModerator;
        v298 = v280;
        v303 = NewsTxtFileChecksum;
        if ( v281 )
        {
          v298 = -1;
          v302 = -1;
        }
        sub_419A70((int)&v294, p, (int)p, &v294, 36, 1);
      }
      else
      {
        v308 = 10;
        v309 = 12;
        v310 = 134;
        v311 = 0;
        PlayerSendPacket(p, &v308, 36, 1);
        *(_DWORD *)&p->field_44[104] = ((int (*)(void))GetTickCount)() / 0xAu;
      }
      return;
    case 11:
      v69 = *(_DWORD *)&p->field_44[32];
      if ( v69 == 132 && (v70 = 1009 * p->dwClientVersion, (v71 = (char *)dword_4CBB10[v70]) != 0) )
      {
        GetMapLvlRequest((struct CONNECTION *)p->lpNetworkData, v71, dword_4CBB1C[v70], 0);
      }
      else if ( v69 == 133 && (v72 = 1009 * p->dwClientVersion, (v73 = (char *)dword_4CBB0C[v72]) != 0) )
      {
        GetMapLvlRequest((struct CONNECTION *)p->lpNetworkData, v73, dword_4CBB18[v72], 0);
      }
      else
      {
        GetMapLvlRequest(
          (struct CONNECTION *)p->lpNetworkData,
          (char *)dword_4CBB08[1009 * p->dwClientVersion],
          dword_4CBB14[1009 * p->dwClientVersion],
          0);
      }
      return;
    case 12:
      v67 = p->lpCurrentArena;
      if ( v67 )
        GetMapLvlRequest((struct CONNECTION *)p->lpNetworkData, *(char **)(v67 + 111610), *(_DWORD *)(v67 + 111614), 0);
      return;
    case 13:
      v68 = emalloc(NewsTxtFileSize);
      qmemcpy(v68, memory, NewsTxtFileSize);
      SendHugeChunkPacketAllocated(p->lpNetworkData, (int)v68, NewsTxtFileSize, 0);
      return;
    case 14:
      v224 = pkt[1];
      if ( v224 >= 4 || v224 < 0 || *((__int16 *)pkt + 1) > 1024 )
      {
        if ( !p->bIsSmod )
          goto LABEL_566;
      }
      else
      {
        if ( !*(_DWORD *)&p->field_331[8 * v224 + 12] )
        {
          v3 = pkt;
          *(_DWORD *)&p->field_331[8 * (char)pkt[1] + 12] = emalloc(pkt_sz - 4);
          *(_DWORD *)&p->field_341[8 * (char)pkt[1]] = pkt_sz - 4;
          qmemcpy(*(void **)&p->field_331[8 * (char)pkt[1] + 12], pkt + 4, pkt_sz - 4);
        }
        v225 = *((_WORD *)v3 + 1);
        if ( v225 != -1 && v225 != -2 && v225 >= 0 )
        {
          LODWORD(player) = *(&ZonePlayerList + v225);
          if ( (_DWORD)player )
          {
            if ( !sub_41D5C0(*(_DWORD *)(player + 40)) )
            {
              v226 = *(_DWORD *)&p->field_341[8 * (char)pkt[1]] + 3;
              v227 = (char *)emalloc(v226);
              *v227 = 12;
              *(_WORD *)(v227 + 1) = p->field_14;
              qmemcpy(
                v227 + 3,
                *(const void **)&p->field_331[8 * (char)pkt[1] + 12],
                *(_DWORD *)&p->field_341[8 * (char)pkt[1]]);
              SendHugeChunkPacketAllocated(*(_DWORD *)(player + 40), (int)v227, v226, 1);
              dword_4D9CB8 += v226;
            }
          }
        }
      }
      return;
    case 15:
      if ( p->lpCurrentArena )
        PlayerChangeFrequency(p, *(__int16 *)(pkt + 1));
      return;
    case 16:
      if ( !p->lpCurrentArena || p->dwShip == 8 )
        return;
      v250 = *(_WORD *)(pkt + 1);
      if ( v250 > 1024 || v250 < -1 )
      {
        if ( !p->bIsSmod )
        {
LABEL_566:
          sprintf(violation, "Packet tampering(%d)", v5);
          goto LABEL_567;
        }
      }
      else
      {
        *(_DWORD *)&p->field_231[50] = v250;
        if ( v250 >= 0 )
        {
          v251 = (int)*(&ZonePlayerList + v250);
          if ( v251 )
          {
            if ( *(_DWORD *)(v251 + 279) != *(_DWORD *)p->field_117 )
            {
              *(_DWORD *)&p->field_231[50] = -1;
              return;
            }
            if ( *(int *)(v251 + 611) >= 0 )
            {
              *(_DWORD *)&p->field_231[50] = -1;
              return;
            }
            p->xPixels = *(_WORD *)(v251 + 232);
            p->yPixels = *(_WORD *)(v251 + 228);
            sub_40D8D0((int)p);
          }
        }
        v252 = p->field_14;
        v253 = *(__int16 *)(pkt + 1);
        *(_WORD *)((char *)&player + 3) = *(_WORD *)&p->field_231[50];
        v254 = *(_DWORD *)&p->field_231[50];
        LOBYTE(player) = 14;
        *(_WORD *)((char *)&player + 1) = v252;
        if ( v253 == v254 )
        {
          v255 = p->lpCurrentArena;
          if ( v255 )
          {
            v256 = 0;
            if ( *(int *)(v255 + 65292) > 0 )
            {
              v257 = 64288;
              do
              {
                v258 = *(_DWORD *)(v257 + v255);
                if ( (PLAYER *)v258 != p && !*(_DWORD *)(v258 + 56) )
                  PlayerSendPacket((PLAYER *)v258, &player, 5, 1);
                v255 = p->lpCurrentArena;
                ++v256;
                v257 += 4;
              }
              while ( v256 < *(_DWORD *)(v255 + 65292) );
            }
          }
        }
        else
        {
          ArenaSendPacket((struct ARENA *)p->lpCurrentArena, (char *)&player, 5, 1);
        }
      }
      return;
    case 19:
      if ( p->lpCurrentArena )
      {
        if ( p->dwShip != 8 )
        {
          v190 = p->lpCurrentArena;
          v191 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&p->field_117[68]);
          if ( (signed int)((HIDWORD(v191) ^ v191) - HIDWORD(v191)) >= *(_DWORD *)(v190 + 109830) )
          {
            v192 = *(_WORD *)(pkt + 1);
            v193 = *(_DWORD *)(v190 + 108190);
            v194 = v192;
            LODWORD(player) = v192;
            if ( v192 <= v193 && v192 >= 0 )
            {
              if ( *(_BYTE *)(v190 + 109578) != 2 )
                goto LABEL_665;
              v195 = 0;
              if ( v193 > 0 )
              {
                v196 = (_DWORD *)(v190 + 100006);
                do
                {
                  if ( *v196 == *(_DWORD *)&p->field_14 )
                    ++v195;
                  v196 += 4;
                  --v193;
                }
                while ( v193 );
                v194 = player;
              }
              if ( v195 <= 0 )
              {
LABEL_665:
                if ( *(_DWORD *)(16 * v194 + v190 + 100006) == -1 )
                {
                  *(_WORD *)((char *)&player + 1) = *(_WORD *)(pkt + 1);
                  v197 = p->field_14;
                  LOBYTE(player) = 19;
                  *(_WORD *)((char *)&player + 3) = v197;
                  ArenaSendPacket((struct ARENA *)v190, (char *)&player, 5, 1);
                  *(_DWORD *)(16 * *(__int16 *)(pkt + 1) + p->lpCurrentArena + 100010) = *(_DWORD *)p->field_117;
                  v198 = p->lpCurrentArena;
                  if ( *(_BYTE *)(v198 + 109578) )
                    *(_DWORD *)(16 * *(__int16 *)(pkt + 1) + v198 + 100006) = *(_DWORD *)&p->field_14;
                }
              }
            }
          }
        }
      }
      return;
    case 20:
      v203 = p->lpCurrentArena;
      if ( v203 )
      {
        v204 = p->field_14;
        v289[0] = 21;
        *(_WORD *)&v289[1] = v204;
        v205 = 0;
        if ( *(int *)(v203 + 65292) > 0 )
        {
          v206 = 64288;
          do
          {
            v207 = *(_DWORD *)(v206 + v203);
            if ( (PLAYER *)v207 != p && !*(_DWORD *)(v207 + 56) )
              PlayerSendPacket((PLAYER *)v207, v289, 3, 1);
            v203 = p->lpCurrentArena;
            ++v205;
            v206 += 4;
          }
          while ( v205 < *(_DWORD *)(v203 + 65292) );
        }
      }
      return;
    case 21:
      v208 = (struct ARENA *)p->lpCurrentArena;
      if ( v208 && v208->field_10026[44004] )
      {
        v209 = p->field_14;
        v289[0] = 22;
        *(_WORD *)&v289[1] = v209;
        ArenaSendPacket(v208, v289, 3, 1);
        v210 = p->lpCurrentArena;
        v211 = *(_DWORD *)(v210 + 109746);
        if ( v211 )
        {
          if ( v211 == 1 )
          {
            CarryFlagsSomething((ARENA *)v210, *(_DWORD *)&p->field_14, 1);
            sub_404120(p->lpCurrentArena, 0);
          }
        }
        else
        {
          CarryFlagsSomething((ARENA *)v210, *(_DWORD *)&p->field_14, 0);
        }
      }
      return;
    case 22:
      v235 = *(_DWORD *)&p->field_44[20];
      if ( v235 < 0 )
      {
        v238 = *(_DWORD *)&p->field_44[28];
        if ( v238 < 0 )
        {
          v244 = p->bIsSysop != 0;
          v245 = (player_data *)(pkt + 1);
          Player = (player_data *)(pkt + 1);
          if ( !_strcmpi((const char *)pkt + 1, "moderate.txt") )
            v244 = 1;
          if ( !_strcmpi((const char *)pkt + 1, "permit.txt") )
            v244 = 1;
          if ( !_strcmpi((const char *)pkt + 1, (const char *)(p->lpCurrentArena + 111342))
            && p->dwUserID == *(_DWORD *)(p->lpCurrentArena + 109622) )
          {
            v244 = 1;
          }
          if ( v244 )
          {
            if ( p->bIsSysop || (int)pkt_sz <= 0x80000 )
            {
              v246 = fopen(pkt + 1, "wb");
              v247 = v246;
              if ( v246 )
              {
                fwrite(pkt + 17, pkt_sz - 17, 1, v246);
                fclose(v247);
              }
              sprintf(violation, "File received: %s", (const char *)v245);
              if ( p->lpCurrentArena )
              {
                a4 = 7;
                v313 = 0;
                v314 = 0;
                v315 = -1;
                strcpy(v316, violation);
                v248 = strlen(violation) + 1;
                if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                  PlayerSendPacket(p, &a4, v248 - 1 + 6, 1);
                v245 = Player;
              }
              if ( !_strcmpi((const char *)v245, (const char *)(p->lpCurrentArena + 111342)) )
              {
                if ( p->lpCurrentArena )
                {
                  a4 = 7;
                  v313 = 0;
                  v314 = 0;
                  v315 = -1;
                  strcpy(v316, "Arena is recycling so the change can take effect.");
                  v249 = strlen("Arena is recycling so the change can take effect.") + 1;
                  if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                    PlayerSendPacket(p, &a4, v249 - 1 + 6, 1);
                }
                v245 = Player;
                *(_DWORD *)(p->lpCurrentArena + 65574) = 1;
              }
              if ( !_strcmpi((const char *)v245, &aMisc_DefaultLevelFile) )
                bRecycleServer = 1;
            }
            else if ( p->lpCurrentArena )
            {
              a4 = 7;
              v313 = 0;
              v314 = 0;
              v315 = -1;
              strcpy(v316, "File has arrived, but is too big (size limit of 512k)");
              v43 = strlen("File has arrived, but is too big (size limit of 512k)") + 6;
              if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                goto LABEL_530;
            }
          }
        }
        else
        {
          v239 = (int)*(&ZonePlayerList + v238);
          v291 = v239;
          if ( v239 && *(_DWORD *)(v239 + 539) == *(_DWORD *)&p->field_44[24] )
          {
            Player = (player_data *)(pkt + 1);
            sprintf(
              violation,
              "File arrived at server, forwarding to %s: %s",
              (const char *)(v239 + 375),
              (const char *)pkt + 1);
            if ( p->lpCurrentArena )
            {
              a4 = 7;
              v313 = 0;
              v314 = 0;
              v315 = -1;
              strcpy(v316, violation);
              v240 = strlen(violation) + 1;
              if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                PlayerSendPacket(p, &a4, v240 - 1 + 6, 1);
            }
            v241 = emalloc(pkt_sz);
            qmemcpy(v241 + 17, pkt + 17, pkt_sz - 17);
            v242 = Player;
            *v241 = 16;
            LODWORD(player) = v241 + 1;
            strcpy(v241 + 1, (const char *)v242);
            SendHugeChunkPacketAllocated(*(_DWORD *)(v291 + 40), (int)v241, pkt_sz, 0);
            *(_DWORD *)&p->field_44[28] = -1;
            *(_DWORD *)&p->field_44[24] = -1;
          }
          else
          {
            sprintf(violation, "File arrived at server, could not forward: %s", (const char *)pkt + 1);
            if ( p->lpCurrentArena )
            {
              a4 = 7;
              v313 = 0;
              v314 = 0;
              v315 = -1;
              strcpy(v316, violation);
              v243 = strlen(violation) + 1;
              if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                PlayerSendPacket(p, &a4, v243 - 1 + 6, 1);
            }
            *(_DWORD *)&p->field_44[28] = -1;
            *(_DWORD *)&p->field_44[24] = -1;
          }
        }
      }
      else
      {
        LODWORD(player) = *(&ZonePlayerList + v235);
        if ( (_DWORD)player && *(_DWORD *)(player + offsetof(PLAYER, bIsSysop)) )
        {
          sprintf(violation, "File arrived, forwarding: %s", (const char *)pkt + 1);
          if ( *(_DWORD *)(player + 28) )
          {
            a4 = 7;
            v313 = 0;
            v314 = 0;
            v315 = -1;
            strcpy(v316, violation);
            v236 = strlen(violation) + 1;
            if ( GetRelAckDiff(*(struct CONNECTION **)(player + 40), 0) < 128 )
              PlayerSendPacket((PLAYER *)player, &a4, v236 - 1 + 6, 1);
          }
          v237 = emalloc(pkt_sz);
          qmemcpy(v237 + 17, pkt + 17, pkt_sz - 17);
          *v237 = 16;
          v291 = (int)(v237 + 1);
          strcpy(v237 + 1, "pulled.dat");
          SendHugeChunkPacketAllocated(*(_DWORD *)(player + 40), (int)v237, pkt_sz, 0);
        }
        *(_DWORD *)&p->field_44[20] = -1;
      }
      return;
    case 23:
      if ( pkt_sz == 766 && BillingConnectionStructPointer )
        SendBillerUserDemographicsPacket(BillingConnectionStructPointer, p->connection_id, (int)(pkt + 1), v285);
      return;
    case 24:
      v199 = p->lpCurrentArena;
      if ( !v199 )
        return;
      v200 = *(_DWORD *)(v199 + 109734);
      if ( v200 > 0 && (unsigned __int16)p->score.losses >= v200 )
        return;
      if ( *(_DWORD *)&p->field_2B7[52] )
        return;
      v201 = pkt[1];
      if ( v201 == p->dwShip )
        return;
      if ( v201 == 8 )
        goto LABEL_408;
      if ( !*(_DWORD *)(v199 + 65374) || p->bIsSmod )
      {
        if ( dwMisc_DisableSharewareShips
          && *(_DWORD *)&p->field_44[4]
          && (v201 == 5 || v201 == 6 || v201 == 4 || v201 == 7) )
        {
          a4 = 7;
          v313 = 0;
          v314 = 0;
          v315 = -1;
          strcpy(v316, "Demo version of SubSpace does not allow the use of that ship type.");
          v43 = strlen("Demo version of SubSpace does not allow the use of that ship type.") + 6;
          if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
            goto LABEL_530;
        }
        else
        {
          sub_41D720(p->lpNetworkData, (int)&p->field_319[8], (int)&p->field_319[12]);
          v199 = p->lpCurrentArena;
          if ( *(_DWORD *)&p->field_319[8] >= *(_DWORD *)(v199 + 109698)
            && *(_DWORD *)&p->field_319[12] >= *(_DWORD *)(v199 + 109690)
            || p->bIsSysop )
          {
LABEL_408:
            *(_DWORD *)&p->field_44[124] = *(_DWORD *)(v199 + 109666);
            v202 = pkt[1];
            if ( v202 > 8 || v202 < 0 )
            {
              if ( !p->bIsSmod )
              {
                sprintf(violation, "Packet tampering(%d)", (char)*pkt);
LABEL_567:
                ProtocolViolation();
                v259 = p->lpCurrentArena;
                if ( v259 )
                {
                  if ( *(_DWORD *)(v259 + 109802) )
                    goto LABEL_658;
                }
              }
            }
            else
            {
              SetPlayerShip(p, v202);
            }
          }
          else if ( v199 )
          {
            a4 = 7;
            v313 = 0;
            v314 = 0;
            v315 = -1;
            strcpy(v316, "Packet loss too high for you to enter the game.");
            v43 = strlen("Packet loss too high for you to enter the game.") + 6;
            if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
              goto LABEL_530;
          }
        }
      }
      return;
    case 25:
      qmemcpy(&p->field_18F[24], pkt + 1, 0x60u);
      if ( BillingConnectionStructPointer )
        SendBillerUserBannerPacket(BillingConnectionStructPointer, p->connection_id, pkt + 1);
      v289[0] = 30;
      v289[1] = 0;
      PlayerSendPacket(p, v289, 2, 1);
      v222 = p->lpCurrentArena;
      if ( v222 && (p->score.flag_points + p->score.points >= *(_DWORD *)(v222 + 109630) || *(_DWORD *)&p->field_2C[4]) )
      {
        v223 = p->field_14;
        v318 = 31;
        v319 = v223;
        qmemcpy(v320, &p->field_18F[24], sizeof(v320));
        ArenaSendPacket((struct ARENA *)v222, &v318, 99, 1);
      }
      return;
    case 26:
      if ( *(_DWORD *)&p->field_44[112] )
      {
        v54 = ((int (*)(void))GetTickCount)();
        v55 = *(_DWORD *)&p->field_44[112];
        *(_DWORD *)&p->field_44[112] = 0;
        LODWORD(player) = v54 / 0xA - v55;
        *(_DWORD *)&p->field_117[12] = *(_DWORD *)&p->field_117[8];
        *(_DWORD *)&p->field_117[16] = *(_DWORD *)(pkt + 1);
        qmemcpy(&p->field_117[20], pkt, 0x28u);
        v50 = pkt[39];
        if ( v50 )
          goto LABEL_76;
        v56 = p->lpCurrentArena;
        if ( v56 && !p->bIsSmod && *(_DWORD *)(v56 + 65336) )
        {
          v57 = *(_DWORD *)(pkt + 9);
          v58 = 1009 * p->dwClientVersion;
          if ( dword_4CBB28[2 * *(_DWORD *)(v56 + 65332) + v58] != v57 )
          {
            v59 = 0;
            v60 = &dword_4CBB28[v58];
            v61 = 500;
            do
            {
              if ( *v60 == v57 )
                v59 = 1;
              v60 += 2;
              --v61;
            }
            while ( v61 );
            if ( v59 )
              v284 = "WARNING: Code checksum mismatch - [%d] old match";
            else
              v284 = "WARNING: Code checksum mismatch - [%d] no possible match";
            sprintf(violation, v284, *(_DWORD *)(pkt + 9));
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
          if ( *(_DWORD *)(p->lpCurrentArena + 65336) != *(_DWORD *)(pkt + 5) )
          {
            sprintf(violation, "WARNING: Parameter checksum mismatch: TimeSinceRequest:%d0 ms", (_DWORD)player);
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
          v62 = *(_DWORD *)(pkt + 13);
          if ( v62 != -12345678 && *(_DWORD *)(p->lpCurrentArena + 65340) != v62 )
          {
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
          v63 = *(__int16 *)(pkt + 25);
          v64 = *(__int16 *)(pkt + 27) + v63;
          v65 = p->lpCurrentArena;
          if ( v64 > *(__int16 *)(v65 + 109550) && p->dwShip != 8 && 1000 * v63 / v64 > *(_DWORD *)(v65 + 109838) )
          {
            if ( v65 )
            {
              a4 = 7;
              v313 = 0;
              v314 = 0;
              v315 = -1;
              strcpy(v316, "You have been put in spectator mode due to high latency (S2C)");
              v66 = strlen("You have been put in spectator mode due to high latency (S2C)") + 1;
              if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
                PlayerSendPacket(p, &a4, v66 - 1 + 6, 1);
            }
            SetPlayerShip(p, 8);
          }
        }
      }
      return;
    case 27:
      GenerateWarning(p, (char)pkt[1]);
      return;
    case 28:
      if ( p->dwShip != SHIP_NONE )
      {
        v47 = *(_WORD *)(pkt + 1);
        if ( v47 < 0 || v47 >= 1024 || (v48 = *(_WORD *)(pkt + 3), v48 < 0) || v48 >= 1024 )
        {
          if ( !p->bIsSmod )
          {
            sprintf(violation, "Packet tampering(%d)", v5);
            ProtocolViolation();
            v49 = p->lpCurrentArena;
            if ( v49 )
            {
              if ( *(_DWORD *)(v49 + 109802) )
                goto LABEL_658;
            }
          }
        }
        else
        {
          DropBrick((struct ARENA *)p->lpCurrentArena, v47, v48, *(_DWORD *)p->field_117);
        }
      }
      return;
    case 29:
      if ( p->bIsSysop || (v41 = p->lpCurrentArena, v42 = *(_DWORD *)(v41 + 109622), p->dwUserID == v42) && v42 >= 0 )
      {
        v44 = (const CHAR *)(pkt + 1);
        if ( pkt[1] )
        {
          do
          {
            if ( v44 - (const CHAR *)pkt >= (int)pkt_sz )
              break;
            ChangeSettings((ARENA *)p->lpCurrentArena, p, v44);
            v45 = strlen(v44) + 1;
            v46 = v44[v45];
            v44 += v45;
          }
          while ( v46 );
        }
        if ( p->lpCurrentArena )
        {
          a4 = 7;
          v313 = 0;
          v314 = 0;
          v315 = -1;
          strcpy(v316, "Settings have been successfully changed.");
          v43 = strlen("Settings have been successfully changed.") + 6;
          if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
            goto LABEL_530;
        }
      }
      else if ( v41 )
      {
        a4 = 7;
        v313 = 0;
        v314 = 0;
        v315 = -1;
        strcpy(v316, "Only the owner of this arena can change the settings.");
        v43 = strlen("Only the owner of this arena can change the settings.") + 6;
        if ( GetRelAckDiff((struct CONNECTION *)p->lpNetworkData, 0) < 128 )
        {
LABEL_530:
          PlayerSendPacket(p, &a4, v43, 1);
          return;
        }
      }
      return;
    case 30:
      v97 = *(_DWORD *)&p->field_2F9[24];
      if ( v97 > 0 )
      {
        *(_DWORD *)&p->field_2F9[24] = v97 - 1;
        *(_DWORD *)&p->field_44[144] = 0;
        if ( *(_DWORD *)&p->field_2F9[24] )
        {
          v100 = p->lpCurrentArena;
          LOBYTE(player) = 43;
          *(_DWORD *)((char *)&player + 1) = *(_DWORD *)(v100 + 109914);
          PlayerSendPacket(p, &player, 5, 1);
        }
        else
        {
          v98 = p->field_14;
          *(_DWORD *)((char *)&player + 2) = 0;
          v99 = (struct ARENA *)p->lpCurrentArena;
          LOWORD(player) = 44;
          HIWORD(player) = v98;
          ArenaSendPacket(v99, (char *)&player, 8, 1);
        }
      }
      return;
    case 31:
      v6 = p->lpCurrentArena;
      if ( v6 )
      {
        v7 = pkt + 1;
        v8 = v6 + 12 * (char)pkt[1] + 3 * (char)pkt[1];
        if ( *(__int16 *)(v8 + 65403) == *(_DWORD *)&p->field_14 && !*(_DWORD *)(v8 + 65405) )
        {
          v9 = v8 + 65394;
          *(_DWORD *)v9 = *(_DWORD *)v7;
          *(_DWORD *)(v9 + 4) = *(_DWORD *)(pkt + 5);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)(pkt + 9);
          *(_WORD *)(v9 + 12) = *(_WORD *)(pkt + 13);
          *(_BYTE *)(v9 + 14) = pkt[15];
          *(_DWORD *)(p->lpCurrentArena + 4 * (char)*v7 + 65514) = ((int (*)(void))GetTickCount)() / 0xAu;
          v10 = (struct ARENA *)p->lpCurrentArena;
          v11 = (char)*v7;
          buf = 46;
          v12 = (int)&v10->field_FF6A[12 * v11 + 8 + 3 * v11];
          *(_DWORD *)v305 = *(_DWORD *)v12;
          *(_DWORD *)&v305[4] = *(_DWORD *)(v12 + 4);
          *(_DWORD *)&v305[8] = *(_DWORD *)(v12 + 8);
          v306 = *(_WORD *)(v12 + 12);
          v307 = *(_BYTE *)(v12 + 14);
          ArenaSendPacket(v10, &buf, 16, 0);
        }
      }
      return;
    case 32:
      v34 = (_DWORD *)p->lpCurrentArena;
      if ( v34 && p->dwShip != 8 )
      {
        v35 = *(_DWORD *)((char *)v34 + 65390);
        v36 = 0;
        if ( v35 <= 0 )
        {
LABEL_46:
          if ( *(_DWORD *)((char *)&v34[3 * (char)pkt[1] + 16351] + 3 * (char)pkt[1] + 1) == *(_DWORD *)(pkt + 2) )
          {
            if ( v34[16323] > *(_DWORD *)((char *)v34 + 109958) )
              *(_DWORD *)&p->field_44[148] += *(_DWORD *)((char *)v34 + 109950);
            *(_DWORD *)(15 * (char)pkt[1] + p->lpCurrentArena + 65405) = 0;
            *(_WORD *)(15 * (char)pkt[1] + p->lpCurrentArena + 65403) = p->field_14;
            *(_WORD *)(15 * (char)pkt[1] + p->lpCurrentArena + 65395) = p->xPixels;
            *(_WORD *)(15 * (char)pkt[1] + p->lpCurrentArena + 65397) = p->yPixels;
            *(_DWORD *)(p->lpCurrentArena + 4 * (char)pkt[1] + 65514) = ((int (*)(void))GetTickCount)() / 0xAu;
            v38 = (struct ARENA *)p->lpCurrentArena;
            v39 = (char)pkt[1];
            buf = 46;
            v40 = (int)&v38->field_FF6A[12 * v39 + 8 + 3 * v39];
            *(_DWORD *)v305 = *(_DWORD *)v40;
            *(_DWORD *)&v305[4] = *(_DWORD *)(v40 + 4);
            *(_DWORD *)&v305[8] = *(_DWORD *)(v40 + 8);
            v306 = *(_WORD *)(v40 + 12);
            v307 = *(_BYTE *)(v40 + 14);
            ArenaSendPacket(v38, &buf, 16, 0);
          }
        }
        else
        {
          v37 = (__int16 *)((char *)v34 + 65403);
          while ( *(_DWORD *)(v37 + 1) || *v37 != *(_DWORD *)&p->field_14 )
          {
            ++v36;
            v37 = (__int16 *)((char *)v37 + 15);
            if ( v36 >= v35 )
              goto LABEL_46;
          }
        }
      }
      return;
    case 33:
      v13 = p->lpCurrentArena;
      if ( v13 )
      {
        v14 = v13 + 12 * (char)pkt[1] + 3 * (char)pkt[1];
        if ( *(__int16 *)(v14 + 65403) == *(_DWORD *)&p->field_14 )
        {
          if ( *(_DWORD *)(v14 + 65405) )
          {
            v15 = *(_DWORD *)(v13 + 65292);
            v16 = 0;
            if ( v15 > 0 )
            {
              v17 = v13 + 64288;
              do
              {
                if ( *(_DWORD *)(*(_DWORD *)v17 + 275) != 8 )
                  ++v16;
                v17 += 4;
                --v15;
              }
              while ( v15 );
            }
            v18 = *(_DWORD *)(v13 + 109942);
            if ( v18 >= 0 )
              v19 = v18 * v16 * v16 / 1000;
            else
              v19 = -v18;
            v291 = v19;
            if ( v19 )
            {
              sprintf(v321, "Team Goal! by %s  Reward:%d", p->player_name, v19);
              sprintf(violation, "Enemy Goal! by %s  Reward:%d", p->player_name, v19);
            }
            else
            {
              sprintf(v321, "Team Goal! by %s", p->player_name);
              sprintf(violation, "Enemy Goal! by %s", p->player_name);
            }
            v20 = (ARENA *)p->lpCurrentArena;
            Player = 0;
            if ( v20->nPlayersHere > 0 )
            {
              v21 = 64288;
              DiffSinceLastUpdate1 = 64288;
              while ( 1 )
              {
                v22 = *(PLAYER **)&v20->field_0[v21];
                if ( *(_DWORD *)v22->field_117 != *(_DWORD *)p->field_117 || v22->dwShip == 8 )
                {
                  if ( v22->lpCurrentArena )
                  {
                    a4 = 7;
                    v313 = 0;
                    v314 = 104;
                    v315 = -1;
                    strcpy(v316, violation);
                    v25 = strlen(violation) + 1;
                    if ( GetRelAckDiff((struct CONNECTION *)v22->lpNetworkData, 0) < 128 )
                      PlayerSendPacket(v22, &a4, v25 - 1 + 6, 1);
                  }
                }
                else
                {
                  v22->score.flag_points += v19;
                  ++*(_WORD *)(*(_DWORD *)(v21 + p->lpCurrentArena) + 551);
                  v23 = *(_DWORD *)(v21 + p->lpCurrentArena);
                  if ( *(_DWORD *)(v23 + 28) )
                  {
                    v322[0] = 7;
                    v322[1] = 0;
                    v322[2] = 104;
                    v323 = -1;
                    strcpy(v324, v321);
                    v24 = strlen(v321) + 1;
                    if ( GetRelAckDiff(*(struct CONNECTION **)(v23 + 40), 0) < 128 )
                      PlayerSendPacket((PLAYER *)v23, v322, v24 - 1 + 6, 1);
                  }
                }
                v20 = (ARENA *)p->lpCurrentArena;
                v21 = DiffSinceLastUpdate1 + 4;
                v26 = (int)Player + 1 < v20->nPlayersHere;
                Player = (player_data *)((char *)Player + 1);
                DiffSinceLastUpdate1 += 4;
                if ( !v26 )
                  break;
                v19 = v291;
              }
              v3 = pkt;
              v19 = v291;
            }
            v27 = p->lpCurrentArena;
            if ( *(_DWORD *)(v27 + 109946) )
              SoccerGame2((ARENA *)v27, *(_DWORD *)p->field_117, *((__int16 *)v3 + 1), *((__int16 *)v3 + 2));
            if ( v19 )
            {
              v28 = *(_WORD *)p->field_117;
              v29 = (struct ARENA *)p->lpCurrentArena;
              LOBYTE(player) = 11;
              *(_WORD *)((char *)&player + 1) = v28;
              *(_DWORD *)((char *)&player + 3) = v19;
              ArenaSendPacket(v29, (char *)&player, 7, 1);
            }
            v30 = p->lpCurrentArena;
            if ( *(int *)(v30 + 65390) > 0 )
            {
              sub_404050(v30, (char)v3[1]);
              *(_DWORD *)(p->lpCurrentArena + 4 * (char)v3[1] + 65514) = ((int (*)(void))GetTickCount)() / 0xAu;
              v31 = (struct ARENA *)p->lpCurrentArena;
              v32 = (char)v3[1];
              buf = 46;
              v33 = (int)&v31->field_FF6A[12 * v32 + 8 + 3 * v32];
              *(_DWORD *)v305 = *(_DWORD *)v33;
              *(_DWORD *)&v305[4] = *(_DWORD *)(v33 + 4);
              *(_DWORD *)&v305[8] = *(_DWORD *)(v33 + 8);
              v306 = *(_WORD *)(v33 + 12);
              v307 = *(_BYTE *)(v33 + 14);
              ArenaSendPacket(v31, &buf, 16, 0);
            }
          }
        }
      }
      return;
    case 34:
      if ( p->lpCurrentArena && !p->bIsSmod )
      {
        v50 = pkt[17];
        if ( v50 )
        {
LABEL_76:
          GenerateWarning(p, v50);
        }
        else
        {
          if ( dword_4CBB28[1009 * p->dwClientVersion] != *(_DWORD *)(pkt + 9) )
          {
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
          v51 = 0;
          v52 = (_DWORD *)(p->lpCurrentArena + 108194);
          v53 = 357;
          do
          {
            v51 += *v52++;
            --v53;
          }
          while ( v53 );
          if ( v51 != *(_DWORD *)(pkt + 5) )
          {
            ProtocolViolation();
            if ( *(_DWORD *)(p->lpCurrentArena + 109802) )
            {
              p->dwDisconnectReason = 3;
              *(_DWORD *)&p->field_2C[12] = 1;
            }
          }
        }
      }
      return;
    default:
      if ( !p->bIsSmod )
      {
        sprintf(violation, "Packet tampering(%d)", v5);
        ProtocolViolation();
        v282 = p->lpCurrentArena;
        if ( v282 )
        {
          if ( *(_DWORD *)(v282 + 109802) )
          {
LABEL_658:
            p->dwDisconnectReason = 16;
            *(_DWORD *)&p->field_2C[12] = 1;
          }
        }
      }
      return;
  }
}
// 40AA9D: control flows out of bounds to 4159D0
// 40B84A: control flows out of bounds to 4157B6
// 4DC214: invalid function type has been ignored
// 40B66A: variable 'v285' is possibly undefined
// 40B83C: variable 'v286' is possibly undefined
// 40B83C: variable 'v287' is possibly undefined
// 40B83C: variable 'v288' is possibly undefined
// 40B844: variable 'v233' is possibly undefined
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(LPCVOID lpBuffer, _DWORD, _DWORD, _DWORD);
// 4327A0: using guessed type int dwAdvertise_SendMode;
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4332F4: using guessed type int bRecycleServer;
// 438F90: using guessed type int dwComms_MaxQueueToLogIn;
// 439428: using guessed type int dwMisc_MaxSharewarePlayers;
// 4399C4: using guessed type int MachineIdArrayCount;
// 439E0C: using guessed type int dwPermission_PermissionMode;
// 439E64: using guessed type int MiscMaxPlayers;
// 4AD738: using guessed type int dword_4AD738[];
// 4B061C: using guessed type int dword_4B061C;
// 4CA230: using guessed type int ZonePlayers[];
// 4CBB08: using guessed type int dword_4CBB08[];
// 4CBB0C: using guessed type int dword_4CBB0C[];
// 4CBB10: using guessed type int dword_4CBB10[];
// 4CBB14: using guessed type int dword_4CBB14[];
// 4CBB18: using guessed type int dword_4CBB18[];
// 4CBB1C: using guessed type int dword_4CBB1C[];
// 4CBB20: using guessed type int dword_4CBB20[];
// 4D6BF0: using guessed type int dwPermission_AllowLowBandwidth;
// 4D6BFC: using guessed type int dwMisc_JackpotBroadcastPoints;
// 4D6C00: using guessed type int dwMisc_RegisterKickShareware;
// 4D6C04: using guessed type int NewsTxtFileChecksum;
// 4D6C08: using guessed type int dwMisc_DisableShareware;
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9E04: using guessed type int dword_4D9E04;

//----- (0040CBE0) --------------------------------------------------------
// Player.GenerateWarning()
void __thiscall GenerateWarning(struct PLAYER *player, int a2)
{
  int v3; // edx
  const char *v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  char violation[256]; // [esp+8h] [ebp-100h] BYREF

  if ( !player->bIsSmod )
  {
    v3 = 1;
    v4 = "Unknown integrity violation";
    switch ( a2 )
    {
      case 0:
        v4 = "Normal integrity";
        goto LABEL_33;
      case 1:
        v4 = "Slow frame detected";
        goto LABEL_33;
      case 2:
        v4 = "Current energy higher than top energy";
        goto LABEL_33;
      case 3:
        v4 = "Top energy higher than max energy";
        goto LABEL_33;
      case 4:
        v4 = "Max energy without getting prizes";
        goto LABEL_33;
      case 5:
        v4 = "Recharge rate higher than max recharge rate";
        goto LABEL_33;
      case 6:
        v4 = "Max recharge rate without getting prizes";
        goto LABEL_33;
      case 7:
        v4 = "Too many burst used";
        goto LABEL_33;
      case 8:
        v4 = "Too many repel used";
        goto LABEL_33;
      case 9:
        v4 = "Too many decoy used";
        goto LABEL_33;
      case 10:
        v4 = "Too many thor used";
        goto LABEL_33;
      case 11:
        v4 = "Too many wall blocks used";
        goto LABEL_33;
      case 12:
        v4 = "Stealth on but never collected";
        goto LABEL_33;
      case 13:
        v4 = "Cloak on but never collected";
        goto LABEL_33;
      case 14:
        v4 = "XRadar on but never collected";
        goto LABEL_33;
      case 15:
        v4 = "AntiWarp on but never collected";
        goto LABEL_33;
      case 16:
        v4 = "Proximity bombs but never collected";
        goto LABEL_33;
      case 17:
        v4 = "Bouncing bullets but never collected";
        goto LABEL_33;
      case 18:
        v4 = "Max guns without getting prizes";
        goto LABEL_33;
      case 19:
        v4 = "Max bombs without getting prizes";
        goto LABEL_33;
      case 20:
        v4 = "Shields or Super on longer than possible";
        goto LABEL_33;
      case 21:
        v3 = 0;
        v4 = "Saved ship weapon limits too high (burst/repel/etc)";
        goto LABEL_33;
      case 22:
        v3 = 0;
        v4 = "Saved ship weapon level too high (guns/bombs)";
        goto LABEL_33;
      case 23:
        v3 = 0;
        v4 = "Login checksum mismatch (program exited)";
        goto LABEL_33;
      case 24:
        v5 = player->lpCurrentArena;
        v6 = *(_DWORD *)&player->field_117[64] + 1;
        *(_DWORD *)&player->field_117[64] = v6;
        if ( v6 < *(_DWORD *)(v5 + 109814) )
          return;
        v4 = "S2C position packet modified";
LABEL_33:
        if ( !*(_DWORD *)&player->field_2F9[16] || !v3 )
        {
          sprintf(violation, "WARNING: %s", v4);
          ProtocolViolation();
          v7 = player->lpCurrentArena;
          if ( v7 )
          {
            if ( *(_DWORD *)(v7 + 109802) )
            {
              player->dwDisconnectReason = 3;
              *(_DWORD *)&player->field_2C[12] = 1;
            }
          }
        }
        break;
      case 25:
        v3 = 0;
        v4 = "Saved ship checksum mismatch";
        goto LABEL_33;
      case 26:
        v4 = "Softice Debugger Running";
        goto LABEL_33;
      case 27:
        v4 = "Data checksum mismatch detected";
        goto LABEL_33;
      case 28:
        v4 = "Parameter mismatch detected";
        goto LABEL_33;
      default:
        goto LABEL_33;
    }
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);

//----- (0040CE10) --------------------------------------------------------
void __thiscall UpdatePowerBallPositionsSomething(struct PLAYER *playerr)
{
  int v2; // ecx
  int v3; // eax
  int v4; // ebx
  int v5; // edi
  struct ARENA *v6; // ecx
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  char buf; // [esp+10h] [ebp-10h] BYREF
  int v10; // [esp+11h] [ebp-Fh]
  int v11; // [esp+15h] [ebp-Bh]
  int v12; // [esp+19h] [ebp-7h]
  __int16 v13; // [esp+1Dh] [ebp-3h]
  char v14; // [esp+1Fh] [ebp-1h]

  v2 = playerr->lpCurrentArena;
  if ( v2 )
  {
    v3 = playerr->xPixels;
    v8 = playerr->yPixels;
    v4 = 0;
    v7 = v3;
    if ( *(int *)(v2 + 65390) > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        if ( !*(_DWORD *)(v5 + v2 + 65405) && *(__int16 *)(v5 + v2 + 65403) == *(_DWORD *)&playerr->field_14 )
        {
          if ( v3 <= 0 || v8 <= 0 )
          {
            sub_404050(v2, v4);
          }
          else
          {
            *(_BYTE *)(v5 + v2 + 65394) = v4;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65395) = v3;
            *(_DWORD *)(playerr->lpCurrentArena + v5 + 65397) = (unsigned __int16)v8;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65401) = 0;
            *(_WORD *)(playerr->lpCurrentArena + v5 + 65403) = playerr->field_14;
            *(_DWORD *)(playerr->lpCurrentArena + v5 + 65405) = ((int (*)(void))GetTickCount)() / 0xAu;
            *(_DWORD *)(playerr->lpCurrentArena + 4 * v4 + 65514) = ((int (*)(void))GetTickCount)() / 0xAu;
            v6 = (struct ARENA *)playerr->lpCurrentArena;
            buf = 46;
            v10 = *(_DWORD *)&v6->field_FF6A[v5 + 8];
            v11 = *(_DWORD *)&v6->field_FF6A[v5 + 12];
            v12 = *(_DWORD *)&v6->field_FF6A[v5 + 16];
            v13 = *(_WORD *)&v6->field_FF6A[v5 + 20];
            v14 = v6->field_FF6A[v5 + 22];
            ArenaSendPacket(v6, &buf, 16, 0);
          }
        }
        v2 = playerr->lpCurrentArena;
        ++v4;
        v5 += 15;
        if ( v4 >= *(_DWORD *)(v2 + 65390) )
          break;
        v3 = v7;
      }
    }
  }
}
// 4DC214: invalid function type has been ignored

//----- (0040CF70) --------------------------------------------------------
int __thiscall CheckUserStopPlaying(PLAYER *player)
{
  int result; // eax
  int (*v3)(void); // ebx
  __int64 v4; // rax
  __int64 v5; // rax
  DWORD v6; // eax
  unsigned int v7; // kr08_4
  int v8; // ebx
  unsigned int v9; // kr10_4
  signed int v10; // esi
  char *v11; // edi
  unsigned int v12; // kr18_4
  __int64 v13; // rax
  unsigned int v14; // kr20_4
  int v15; // esi
  unsigned int v16; // kr28_4
  char *v17; // ebx
  char *v18; // esi
  int v19; // edi
  int v20; // eax
  unsigned int v21; // kr30_4
  int v22; // eax
  int v23; // esi
  int v24; // eax
  int v25; // ecx
  int v26; // edi
  int v27; // eax
  int v28; // esi
  unsigned int v29; // kr38_4
  int v30; // [esp-8h] [ebp-524h]
  const char *v31; // [esp-8h] [ebp-524h]
  char *v32; // [esp-4h] [ebp-520h]
  char v33; // [esp+13h] [ebp-509h] BYREF
  int i; // [esp+14h] [ebp-508h]
  DWORD ExitCode; // [esp+18h] [ebp-504h] BYREF
  char v36; // [esp+1Ch] [ebp-500h] BYREF
  char v37; // [esp+1Dh] [ebp-4FFh]
  char v38; // [esp+1Eh] [ebp-4FEh]
  __int16 v39; // [esp+1Fh] [ebp-4FDh]
  char v40[507]; // [esp+21h] [ebp-4FBh] BYREF
  char violation[256]; // [esp+21Ch] [ebp-300h] BYREF
  char buf[3]; // [esp+31Ch] [ebp-200h] BYREF
  __int16 v43; // [esp+31Fh] [ebp-1FDh]
  char v44[507]; // [esp+321h] [ebp-1FBh] BYREF

  if ( *(int *)&player->field_283[4] > 0 )
    dword_4D9DE8 = 1;
  if ( *(_DWORD *)&player->field_2C[12] )
    return 1;
  v3 = (int (*)(void))GetTickCount;
  if ( *(_DWORD *)&player->field_44[104] )
  {
    v4 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&player->field_44[104]);
    if ( (int)((HIDWORD(v4) ^ v4) - HIDWORD(v4)) > 1000 )
    {
      printf("KickOffTime expired: %s\n", player->Name);
      return 1;
    }
  }
  if ( !player->Name[0] )
  {
    v5 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&player->field_231[46]);
    if ( (int)((HIDWORD(v5) ^ v5) - HIDWORD(v5)) > 300 )
    {
      player->connection_id = -1;
      player->dwDisconnectReason = 17;
      return 1;
    }
  }
  if ( !player->lpCurrentArena )
  {
    if ( (int)abs32(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)(player->lpNetworkData + 58)) > dwMisc_MenuKickoutDelay )
    {
      v32 = player->Name;
      v31 = "Menu kickout delay exceeded: %s\n";
      goto LABEL_74;
    }
LABEL_72:
    if ( sub_41C510(player->lpNetworkData) != 4 )
      return 0;
    v32 = player->Name;
    v31 = "Connection status read as terminated: %s\n";
LABEL_74:
    printf(v31, v32);
    result = 1;
    player->dwDisconnectReason = 1;
    return result;
  }
  if ( player->hProcess && GetExitCodeProcess((HANDLE)player->hProcess, &ExitCode) && ExitCode != 259 )
  {
    TerminateProcess((HANDLE)player->hProcess, 0);
    CloseHandle((HANDLE)player->hProcess);
    v6 = ExitCode;
    player->hProcess = 0;
    *(_DWORD *)player->field_4 = 0;
    *(_DWORD *)&player->field_4[4] = 0;
    *(_DWORD *)&player->field_4[8] = 0;
    sprintf(violation, "SPAWN TERMINATED: %d", v6);
    if ( player->lpCurrentArena )
    {
      buf[0] = 7;
      buf[1] = 0;
      buf[2] = 0;
      v43 = -1;
      strcpy(v44, violation);
      v7 = strlen(violation) + 1;
      if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
        PlayerSendPacket(player, buf, v7 - 1 + 6, 1);
    }
    v8 = fopen("spawn.log", "rt");
    if ( v8 )
    {
      for ( i = 0; i < 40; ++i )
      {
        buf[0] = 0;
        fgets(buf, 256, v8);
        if ( player->lpCurrentArena )
        {
          v36 = 7;
          v37 = 0;
          v38 = 0;
          v39 = -1;
          strcpy(v40, buf);
          v9 = strlen(buf) + 1;
          if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
            PlayerSendPacket(player, &v36, v9 - 1 + 6, 1);
        }
        if ( (*(_BYTE *)(v8 + 12) & 0x10) != 0 )
          break;
      }
      fclose(v8);
    }
    v3 = (int (*)(void))GetTickCount;
  }
  v10 = abs32(v3() / 0xAu - *(_DWORD *)(player->lpNetworkData + 58));
  if ( v10 > *(_DWORD *)(player->lpCurrentArena + 109826) )
    *(_DWORD *)&player->field_117[68] = v3() / 0xAu;
  if ( v10 <= *(_DWORD *)(player->lpCurrentArena + 109822)
    || player->bIsSysop && (int)abs32(v3() / 0xAu - *(_DWORD *)(player->lpNetworkData + 58)) <= 6000 )
  {
    if ( *(_DWORD *)&player->field_44[4] )
    {
      v13 = (int)(v3() / 0xAu - *(_DWORD *)&player->field_231[46]);
      if ( (int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > dwMisc_MaxSharewareTime )
      {
        WriteSubGameLog("Shareware Timer Expired: %s\n", player->Name);
        v39 = player->field_14;
        player->dwDisconnectReason = 22;
        v36 = 7;
        v37 = 0;
        v38 = 0;
        strcpy(
          v40,
          "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.");
        v14 = strlen(
                "DISCONNECTED: Your time for this session has expired. There is no time limit when you play the full version.")
            + 1;
        v11 = &aDisconnectedYo[v14];
        v30 = v14 + 5;
        goto LABEL_82;
      }
    }
    if ( (signed int)abs32(v3() / 0xAu - *(_DWORD *)(player->lpNetworkData + 54)) > *(_DWORD *)&player->field_341[181] )
    {
      v33 = 39;
      WriteData((struct CONNECTION *)player->lpNetworkData, &v33, 1u, 0);
    }
    if ( player->dwShip != 8 )
    {
      if ( *(_DWORD *)&player->field_44[116] )
      {
        v15 = player->lpCurrentArena;
        if ( (signed int)(v3() / 0xAu - *(_DWORD *)&player->field_44[116]) > *(_DWORD *)(v15 + 109866)
          && !player->bIsSysop )
        {
          if ( v15 )
          {
            v36 = 7;
            v37 = 0;
            v38 = 0;
            v39 = -1;
            strcpy(v40, "You have been put in spectator mode due to high latency (spike)");
            v16 = strlen("You have been put in spectator mode due to high latency (spike)") + 1;
            if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
              PlayerSendPacket(player, &v36, v16 - 1 + 6, 1);
          }
          SetPlayerShip(player, 8);
        }
      }
    }
    v17 = &player->field_319[12];
    v18 = &player->field_319[8];
    sub_41D720(player->lpNetworkData, (int)&player->field_319[8], (int)&player->field_319[12]);
    v19 = 0;
    if ( player->dwShip == 8 )
      v19 = *(_DWORD *)(player->lpCurrentArena + 109702);
    v20 = player->lpCurrentArena;
    if ( (*(_DWORD *)v18 < *(_DWORD *)(v20 + 109698) - v19
       || *(_DWORD *)v17 < *(_DWORD *)(v20 + 109690) - v19
       || *(_DWORD *)v17 > *(_DWORD *)(v20 + 109694) + v19 + 1000)
      && !player->bIsSysop )
    {
      if ( player->dwShip == 8 )
      {
        WriteSubGameLog(
          "Packet loss too high S2C:%d%%, C2S:%d%%, kicking out player: %s\n",
          (1000 - *(_DWORD *)v18) / 10,
          (1000 - *(_DWORD *)v17) / 10,
          player->Name);
        v27 = player->lpCurrentArena;
        v28 = *(_DWORD *)v18;
        if ( v28 >= *(_DWORD *)(v27 + 109698) - v19 )
        {
          if ( *(_DWORD *)v17 <= *(_DWORD *)(v27 + 109694) + v19 + 1000 )
            player->dwDisconnectReason = 7;
          else
            player->dwDisconnectReason = 23;
        }
        else
        {
          player->dwDisconnectReason = 6;
        }
        sprintf(
          violation,
          "WARNING: Disconnected because of high packet loss (ServerToYou:%d%%, YouToServer:%d%%)",
          (1000 - v28) / 10,
          (1000 - *(_DWORD *)v17) / 10);
        v39 = player->field_14;
        v36 = 7;
        v37 = 0;
        v38 = 0;
        strcpy(v40, violation);
        v29 = strlen(violation) + 1;
        v11 = &violation[v29];
        v30 = v29 + 5;
        goto LABEL_82;
      }
      if ( v20 )
      {
        v36 = 7;
        v37 = 0;
        v38 = 0;
        v39 = -1;
        strcpy(v40, "You have been put in spectator mode due to high packet loss");
        v21 = strlen("You have been put in spectator mode due to high packet loss") + 1;
        if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
          PlayerSendPacket(player, &v36, v21 - 1 + 6, 1);
      }
      SetPlayerShip(player, 8);
    }
    v22 = *(_DWORD *)v17;
    if ( *(int *)v17 >= 1000 )
      v22 = 1000;
    v23 = *(_DWORD *)&player->field_319[8];
    v24 = v22 - v23;
    *(_DWORD *)&player->field_117[60] = v24;
    if ( v23 > 900 || player->bIsSysop || v24 < 0 )
      *(_DWORD *)&player->field_117[60] = 0;
    if ( v23 < 1000 )
    {
      v25 = *(_DWORD *)&player->field_117[12];
      if ( v25 > 400 && player->dwShip != 8 )
      {
        v26 = 1000 * *(_DWORD *)&player->field_117[16] / v25;
        if ( v23 - v26 > 100 && v26 < *(_DWORD *)(player->lpCurrentArena + 109798) && !player->bIsSysop )
        {
          sprintf(
            violation,
            "S2C weapon packet loss too high(S2CW=%d%%)(S2C=%d%%)",
            (1000 - v26) / 10,
            (1000 - v23) / 10);
          ProtocolViolation();
          player->dwDisconnectReason = 3;
          return 1;
        }
      }
    }
    goto LABEL_72;
  }
  WriteSubGameLog("Kickout delay exceeded: %s\n", player->Name);
  player->dwDisconnectReason = 9;
  v39 = player->field_14;
  v36 = 7;
  v37 = 0;
  v38 = 0;
  strcpy(v40, "WARNING: You have been disconnected because server has not been receiving data from you.");
  v12 = strlen("WARNING: You have been disconnected because server has not been receiving data from you.") + 1;
  v11 = &aWarningYouHave[v12];
  v30 = v12 + 5;
LABEL_82:
  PlayerSendPacket(player, &v36, v30, 0);
  sub_41D6D0(player->lpNetworkData, (int)player, (int)v11);
  return 1;
}
// 4DC214: invalid function type has been ignored
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 4D68C4: using guessed type int dwMisc_MaxSharewareTime;
// 4D68C8: using guessed type int dwMisc_MenuKickoutDelay;
// 4D9DE8: using guessed type int dword_4D9DE8;

//----- (0040D8D0) --------------------------------------------------------
void __thiscall sub_40D8D0(int this)
{
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  __int64 v9; // rax
  int v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // ebx
  struct ARENA *v14; // ecx

  v2 = *(_DWORD *)(this + 28);
  v3 = *(__int16 *)(this + 232) - *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 355) = v3;
  if ( v3 < 0 )
    *(_DWORD *)(this + 355) = 0;
  v4 = 2 * (0x2000 - *(_DWORD *)(v2 + 111606));
  if ( *(_DWORD *)(this + 355) > v4 )
    *(_DWORD *)(this + 355) = v4;
  v5 = *(__int16 *)(this + 228) - *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 363) = v5;
  if ( v5 < 0 )
    *(_DWORD *)(this + 363) = 0;
  v6 = 2 * (0x2000 - *(_DWORD *)(v2 + 111606));
  if ( *(_DWORD *)(this + 363) > v6 )
    *(_DWORD *)(this + 363) = v6;
  v7 = *(_DWORD *)(this + 363);
  *(_DWORD *)(this + 359) = *(_DWORD *)(this + 355) + 2 * *(_DWORD *)(v2 + 111606);
  v8 = v7 + 2 * *(_DWORD *)(v2 + 111606);
  *(_DWORD *)(this + 367) = v8;
  if ( v2 )
  {
    v9 = *(_DWORD *)(this + 355) + *(_DWORD *)(this + 359);
    v10 = (WORD2(v9) & 0xFFF) + v9;
    v11 = *(_DWORD *)(this + 80);
    v12 = v10 >> 12;
    v13 = (v8 + *(_DWORD *)(this + 363)) / 4096;
    if ( v12 != v11 || v13 != *(_DWORD *)(this + 84) )
    {
      sub_404980((char *)v2, this, v11, *(_DWORD *)(this + 84));
      v14 = *(struct ARENA **)(this + 28);
      *(_DWORD *)(this + 80) = v12;
      *(_DWORD *)(this + 84) = v13;
      AddPlayerToArenaSomething(v14, (struct PLAYER *)this, v12, v13);
    }
  }
}

//----- (0040D9E0) --------------------------------------------------------
void __thiscall PlayerChangeFrequency(PLAYER *player, signed int NewFrequency)
{
  signed int v3; // edi
  ARENA *v4; // esi
  char *v5; // ecx
  int v6; // edx
  int v7; // eax
  signed int v8; // ecx
  signed int v9; // eax
  unsigned int v10; // kr08_4
  int v11; // ecx
  int v12; // edx
  char *v13; // eax
  int v14; // ecx
  __int16 v15; // ax
  int v16; // ecx
  __int16 v17; // dx
  char v18; // [esp+10h] [ebp-20Ch] BYREF
  __int16 v19; // [esp+11h] [ebp-20Bh]
  __int16 v20; // [esp+13h] [ebp-209h]
  char v21; // [esp+15h] [ebp-207h]
  char v22; // [esp+18h] [ebp-204h] BYREF
  __int16 v23; // [esp+19h] [ebp-203h]
  int buf[128]; // [esp+1Ch] [ebp-200h] BYREF

  v3 = NewFrequency;
  v4 = (ARENA *)player->lpCurrentArena;
  if ( NewFrequency >= *(_DWORD *)&v4->field_10026[43804] )
    return;
  if ( *(int *)&v4->field_10026[44204] > 0 && !player->bIsSmod )
  {
    memset(buf, 0, 0x100u);
    if ( v4->nPlayersHere > 0 )
    {
      v5 = v4->PlayerArray;
      v6 = v4->nPlayersHere;
      do
      {
        v7 = *(_DWORD *)(*(_DWORD *)v5 + 279);
        if ( v7 < 64 )
          ++buf[v7];
        v5 += 4;
        --v6;
      }
      while ( v6 );
    }
    v8 = *(_DWORD *)player->field_117;
    v9 = *(_DWORD *)&v4->field_10026[44132];
    if ( v8 < v9
      && NewFrequency < v9
      && v9 < 64
      && buf[v8] + *(_DWORD *)&v4->field_10026[44204] - 1 <= buf[NewFrequency] )
    {
      if ( v4 )
      {
        LOWORD(buf[0]) = 7;
        BYTE2(buf[0]) = 0;
        *(_WORD *)((char *)buf + 3) = -1;
        strcpy((char *)&buf[1] + 1, "Changing frequencies would make the teams too uneven.");
        v10 = strlen("Changing frequencies would make the teams too uneven.") + 1;
        if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
          PlayerSendPacket(player, buf, v10 - 1 + 6, 1);
      }
      return;
    }
    v3 = NewFrequency;
  }
  *(_DWORD *)&player->field_44[124] = *(_DWORD *)&v4->field_10026[44092];
  v11 = v4->nPlayersHere;
  v12 = 0;
  if ( v11 > 0 )
  {
    v13 = v4->PlayerArray;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)v13 + 279) == v3 )
        ++v12;
      v13 += 4;
      --v11;
    }
    while ( v11 );
  }
  v14 = (unsigned __int8)v4->field_10026[43993];
  if ( v4->field_10026[43994] )
    v14 = (unsigned __int8)v4->field_10026[43994];
  if ( v12 < v14 || player->bIsSysop )
  {
    v15 = player->field_14;
    *(_DWORD *)player->field_117 = v3;
    v18 = 13;
    v19 = v15;
    v20 = v3;
    v21 = -1;
    if ( *(_DWORD *)&v4->field_10026[44200] && player->dwShip != 8 )
    {
      player->dwShip = v3 % 8;
      v21 = player->dwShip;
    }
    ArenaSendPacket(v4, &v18, 6, 1);
    CarryFlagsSomething((ARENA *)player->lpCurrentArena, *(_DWORD *)&player->field_14, 0);
    UpdatePowerBallPositionsSomething(player);
    v16 = player->lpCurrentArena;
    if ( *(_DWORD *)(v16 + 109962) )
    {
      v17 = player->field_14;
      player->score.losses = 0;
      player->score.wins = 0;
      player->score.points = 0;
      player->score.flag_points = 0;
      player->score.flags = 0;
      *(_DWORD *)&player->field_2F9[20] = 1;
      v22 = 26;
      v23 = v17;
      if ( v16 )
        ArenaSendPacket((struct ARENA *)v16, &v22, 3, 1);
    }
  }
}

//----- (0040DC60) --------------------------------------------------------
void __thiscall SetPlayerShip(struct PLAYER *player, signed int Ship)
{
  __int16 v3; // ax
  struct ARENA *v4; // ecx
  __int16 v5; // ax
  __int16 v6; // dx
  int v7; // ecx
  __int16 v8; // si
  int v9; // esi
  unsigned int v10; // kr08_4
  __int16 v11; // ax
  int v12; // ecx
  int v13; // esi
  unsigned int v14; // kr10_4
  char v15; // [esp+10h] [ebp-210h] BYREF
  char v16; // [esp+11h] [ebp-20Fh]
  __int16 v17; // [esp+12h] [ebp-20Eh]
  __int16 v18; // [esp+14h] [ebp-20Ch]
  char buf; // [esp+18h] [ebp-208h] BYREF
  __int16 v20; // [esp+19h] [ebp-207h]
  __int16 v21; // [esp+1Bh] [ebp-205h]
  char v22; // [esp+20h] [ebp-200h] BYREF
  char v23; // [esp+21h] [ebp-1FFh]
  char v24; // [esp+22h] [ebp-1FEh]
  __int16 v25; // [esp+23h] [ebp-1FDh]
  char v26[507]; // [esp+25h] [ebp-1FBh] BYREF

  if ( *(int *)&player->field_231[50] >= 0 )
  {
    v3 = player->field_14;
    v4 = (struct ARENA *)player->lpCurrentArena;
    buf = 0xE;
    v21 = -1;
    v20 = v3;
    *(_DWORD *)&player->field_231[50] = -1;
    ArenaSendPacket(v4, &buf, 5, 1);
  }
  LOBYTE(v5) = Ship;
  v6 = player->field_14;
  v15 = 29;
  v17 = v6;
  v16 = Ship;
  if ( (_BYTE)Ship == 8 )
  {
    v7 = player->lpCurrentArena;
    v8 = *(_WORD *)(v7 + 109730);
    v18 = v8;
LABEL_18:
    player->dwShip = (char)v5;
    *(_DWORD *)&player->field_231[50] = -1;
    *(_DWORD *)&player->field_117[92] = -1;
    *(_DWORD *)player->field_117 = v8;
    ArenaSendPacket((struct ARENA *)v7, &v15, 6, 1);
    CarryFlagsSomething((ARENA *)player->lpCurrentArena, *(_DWORD *)&player->field_14, 0);
    UpdatePowerBallPositionsSomething(player);
    v12 = player->lpCurrentArena;
    v13 = *(_DWORD *)&player->field_2B7[56] + 1;
    *(_DWORD *)&player->field_2B7[56] = v13;
    if ( v13 > *(_DWORD *)(v12 + 109810) )
    {
      WriteSubGameLog("Played kicked off for too many ship type changes: %s\n", player->Name);
      v25 = player->field_14;
      player->dwDisconnectReason = 15;
      *(_DWORD *)&player->field_2C[12] = 1;
      v22 = 7;
      v23 = 0;
      v24 = 0;
      strcpy(v26, "WARNING: You have been disconnected for too many ship type changes.");
      v14 = strlen("WARNING: You have been disconnected for too many ship type changes.") + 1;
      PlayerSendPacket(player, &v22, v14 + 5, 0);
      sub_41D6D0(player->lpNetworkData, (int)player, (int)&aWarningYouHa_0[v14]);
    }
    return;
  }
  if ( player->dwShip != 8 )
  {
    v7 = player->lpCurrentArena;
    if ( *(_DWORD *)(v7 + 109774) )
    {
      PlayerChangeFrequency(player, Ship);
      return;
    }
    v8 = *(_WORD *)player->field_117;
    v18 = v8;
    goto LABEL_18;
  }
  if ( player->bIsModerator
    || *(int *)(player->lpCurrentArena + 109870) <= 0
    || (v9 = player->lpCurrentArena, GetTotalPlayingPlayers((ARENA *)v9) <= *(_DWORD *)(v9 + 109870)) )
  {
    v11 = DLL_CALL_GET_NEW_FREQ(player->lpCurrentArena);
    v7 = player->lpCurrentArena;
    v8 = v11;
    v18 = v11;
    if ( *(_DWORD *)(v7 + 109774) )
    {
      v5 = v11 % 8;
      v16 = v5;
    }
    else
    {
      LOBYTE(v5) = v16;
    }
    goto LABEL_18;
  }
  if ( v9 )
  {
    v25 = -1;
    v22 = 7;
    v23 = 0;
    v24 = 0;
    strcpy(v26, "There are too many people playing the game right now, try again later.");
    v10 = strlen("There are too many people playing the game right now, try again later.") + 1;
    if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
      PlayerSendPacket(player, &v22, v10 - 1 + 6, 1);
  }
}

//----- (0040DF06) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __userpurge sub_40DF06@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, _BYTE *a5, void *buf, int buf_sz)
{
  _BOOL1 v7; // cf
  int v8; // esi
  char *v9; // eax
  int v11; // [esp+72h] [ebp-4h] BYREF

  v9 = (char *)a1 + *a1;
  v7 = __CFADD__((_BYTE)v9, *(_BYTE *)(a3 - 1955367488));
  *(_BYTE *)(a3 - 1955367488) += (_BYTE)v9;
  v8 = a4 + 1;
  *((_BYTE *)&v11 + 2 * a3 - 117) = 0;
  LOBYTE(v9) = ((_BYTE)v9 - (v7 - 123)) & 0x10;
  if ( a2 == 21 && (a5[19] & 0x1F) != 0 )
  {
    ++*(_DWORD *)(v8 + 287);
    if ( *(_DWORD *)(v8 + 801) < *(_DWORD *)(v9 + 109902) )
    {
      PlayerSendPacket((PLAYER *)v8, a5, (int)buf, 0);
      ++*(_DWORD *)(v8 + 287);
      ++dword_4CA228;
      sub_41D6D0(*(_DWORD *)(v8 + 40), a3, (int)a5);
    }
  }
  return PlayerSendPacket((PLAYER *)v8, a5, (int)buf, 0);
}
// 40DF81: positive sp value 4 has been found
// 4CA228: using guessed type int dword_4CA228;

//----- (0040DF90) --------------------------------------------------------
// Player.SendPacket()
int __thiscall PlayerSendPacket(PLAYER *player, void *buf, int buf_sz, BOOL bSendReliable)
{
  int result; // eax
  int v6; // eax

  if ( bSendReliable
    || (result = *(_DWORD *)&player->field_2F9[16]) == 0
    && ((result = player->lpCurrentArena) == 0
     || *(_DWORD *)(player->lpNetworkData + 2690) <= *(_DWORD *)&player->field_341[189]
     || *(_BYTE *)buf == 5) )
  {
    if ( !WriteData((struct CONNECTION *)player->lpNetworkData, buf, buf_sz, bSendReliable) && bSendReliable )
    {
      WriteSubGameLog(
        "Reliable packet lost(%d) to: %s (pending=%d current=%d diff=%d)\n",
        *(unsigned __int8 *)buf,
        player->player_name,
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, pending_ack)),
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, current_ack)),
        *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, current_ack))
      - *(_DWORD *)(player->lpNetworkData + offsetof(NETDATA, pending_ack)));
      v6 = player->bIsSysop;
      player->dwDisconnectReason = 8;
      *(_DWORD *)&player->field_2C[12] = 1;
      if ( v6 )
        LogReliablePackets((struct CONNECTION *)player->lpNetworkData, "reliable.txt");
    }
    ++TotalSentForEachPacketType[*(char *)buf];
    result = *(char *)buf;
    TotalSentSizeForEachPacketType[result] += buf_sz;
  }
  return result;
}

//----- (0040E060) --------------------------------------------------------
void __thiscall SendToSpectators(struct PLAYER *player, char *buf, int len, int a4, int a5, int a6)
{
  if ( (!a5 || !player->bWaveMessages) && (!a6 || player->dwShip == 8) )
    PlayerSendPacket(player, buf, len, a4);
}

//----- (0040E0A0) --------------------------------------------------------
void __thiscall SendEverybodyButYourself(struct PLAYER *player, const void *buf, unsigned int len, int a4)
{
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // eax

  v5 = player->lpCurrentArena;
  if ( v5 )
  {
    v6 = 0;
    if ( *(int *)(v5 + 65292) > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(_DWORD *)(v7 + v5);
        if ( (struct PLAYER *)v8 != player && !*(_DWORD *)(v8 + 56) )
          PlayerSendPacket((PLAYER *)v8, (void *)buf, len, a4);
        v5 = player->lpCurrentArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < *(_DWORD *)(v5 + 65292) );
    }
  }
}

//----- (0040E100) --------------------------------------------------------
void __thiscall SendReliablePacketToMyFrequency(struct PLAYER *player, const void *buf, unsigned int len, int IsReliableSend)
{
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // eax

  v5 = player->lpCurrentArena;
  if ( v5 )
  {
    v6 = 0;
    if ( *(int *)(v5 + 65292) > 0 )
    {
      v7 = 64288;
      do
      {
        v8 = *(_DWORD *)(v7 + v5);
        if ( (struct PLAYER *)v8 != player && *(_DWORD *)(v8 + 279) == *(_DWORD *)player->field_117 )
          PlayerSendPacket((PLAYER *)v8, (void *)buf, len, IsReliableSend);
        v5 = player->lpCurrentArena;
        ++v6;
        v7 += 4;
      }
      while ( v6 < *(_DWORD *)(v5 + 65292) );
    }
  }
}

//----- (0040E170) --------------------------------------------------------
void __thiscall SomethingWithAttachedPlayer(struct PLAYER *player, const void *buf, unsigned int len, int a4, int a5, int a6)
{
  int v7; // eax
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edx
  int v12; // edx
  signed int v13; // edi
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // [esp+4h] [ebp-4h]

  v7 = player->lpCurrentArena;
  if ( v7 )
  {
    v16 = 0;
    if ( *(int *)(v7 + 65292) > 0 )
    {
      v8 = 64288;
      do
      {
        v9 = *(_DWORD *)(v8 + v7);
        v10 = v9;
        if ( (struct PLAYER *)v9 != player )
        {
          v11 = *(_DWORD *)(v9 + 371);
          if ( v11 >= 0 )
            v10 = (int)*(&ZonePlayerList + v11);
          if ( v10 )
          {
            v12 = *(_DWORD *)(v10 + 611);
            if ( v12 >= 0 )
              v10 = (int)*(&ZonePlayerList + v12);
            if ( v10 )
            {
              if ( *(_DWORD *)(v9 + 631)
                || (v13 = *(_DWORD *)(v7 + 109794),
                    v14 = *(__int16 *)(v10 + 228) - player->yPixels,
                    (int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) <= v13)
                && (v15 = *(__int16 *)(v10 + 232) - player->xPixels, (int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) <= v13) )
              {
                if ( (!a5 || !*(_DWORD *)(v9 + 627)) && (!a6 || *(_DWORD *)(v9 + 275) == 8) )
                  PlayerSendPacket((PLAYER *)v9, (void *)buf, len, a4);
              }
            }
          }
        }
        v7 = player->lpCurrentArena;
        v8 += 4;
        ++v16;
      }
      while ( v16 < *(_DWORD *)(v7 + 65292) );
    }
  }
}

//----- (0040E280) --------------------------------------------------------
int __thiscall sub_40E280(_DWORD *this, void *buf, int buf_sz, BOOL bSendReliable, int a5, int a6)
{
  int result; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // ecx

  result = this[7];
  if ( result )
  {
    v8 = 0;
    if ( *(int *)(result + 65292) > 0 )
    {
      v9 = 64288;
      do
      {
        v10 = *(_DWORD *)(v9 + result);
        if ( (_DWORD *)v10 != this
          && *(_DWORD *)(v10 + 279) == *(_DWORD *)((char *)this + 279)
          && (!a5 || !*(_DWORD *)(v10 + 627))
          && (!a6 || *(_DWORD *)(v10 + 275) == 8) )
        {
          PlayerSendPacket((PLAYER *)v10, buf, buf_sz, bSendReliable);
        }
        result = this[7];
        ++v8;
        v9 += 4;
      }
      while ( v8 < *(_DWORD *)(result + 65292) );
    }
  }
  return result;
}

//----- (0040E310) --------------------------------------------------------
int __stdcall SomethingWithAudioByteAndShip8(int ArenaPlayerIndex, const void *buf, unsigned int len, int a4, int a5, struct_ARENA *a6)
{
  int result; // eax
  PLAYER *v7; // ecx

  result = ArenaPlayerIndex;
  v7 = *(&ZonePlayerList + ArenaPlayerIndex);
  if ( v7 )
  {
    if ( !a5 || (result = v7->bWaveMessages) == 0 )
    {
      result = (int)a6;
      if ( !a6 || v7->dwShip == 8 )
        result = PlayerSendPacket(v7, (void *)buf, len, a4);
    }
  }
  return result;
}

//----- (0040E360) --------------------------------------------------------
int __thiscall sub_40E360(void *this, int a2, int buf, int buf_sz, int bSendReliable, int a6, int a7)
{
  int result; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // esi
  int v11; // ecx

  result = a2;
  v8 = (int)*(&ZonePlayerList + a2);
  if ( v8 )
  {
    result = *(_DWORD *)(v8 + 28);
    if ( result )
    {
      v9 = 0;
      if ( *(int *)(result + 65292) > 0 )
      {
        v10 = 64288;
        do
        {
          v11 = *(_DWORD *)(v10 + result);
          if ( (void *)v11 != this
            && *(_DWORD *)(v11 + 279) == *(_DWORD *)(v8 + 279)
            && (!a6 || !*(_DWORD *)(v11 + 627))
            && (!a7 || *(_DWORD *)(v11 + 275) == 8) )
          {
            PlayerSendPacket((PLAYER *)v11, (void *)buf, buf_sz, bSendReliable);
          }
          result = *(_DWORD *)(v8 + 28);
          ++v9;
          v10 += 4;
        }
        while ( v9 < *(_DWORD *)(result + 65292) );
      }
    }
  }
  return result;
}

//----- (0040E400) --------------------------------------------------------
// Player.SendMessage()
void __thiscall SendMessage(struct PLAYER *player, const char *a2, char SoundByte)
{
  unsigned int v4; // kr08_4
  char buf[3]; // [esp+10h] [ebp-200h] BYREF
  __int16 v6; // [esp+13h] [ebp-1FDh]
  char v7[507]; // [esp+15h] [ebp-1FBh] BYREF

  if ( player->lpCurrentArena )
  {
    buf[2] = SoundByte;
    buf[0] = 7;
    buf[1] = 0;
    v6 = -1;
    strcpy(v7, a2);
    v4 = strlen(a2) + 1;
    if ( GetRelAckDiff((struct CONNECTION *)player->lpNetworkData, 0) < 128 )
      PlayerSendPacket(player, buf, v4 - 1 + 6, 1);
  }
}

//----- (0040E4A0) --------------------------------------------------------
void __thiscall SendChannelMessage(struct PLAYER *player, const char *a2)
{
  char buf[3]; // [esp+4h] [ebp-200h] BYREF
  __int16 v3; // [esp+7h] [ebp-1FDh]
  char v4[507]; // [esp+9h] [ebp-1FBh] BYREF

  if ( player->lpCurrentArena )
  {
    buf[0] = 7;
    buf[1] = 9;
    buf[2] = 0;
    v3 = -1;
    strcpy(v4, a2);
    PlayerSendPacket(player, buf, strlen(a2) + 6, 1);
  }
}

//----- (0040E520) --------------------------------------------------------
void __thiscall SendArenaMessagePlayer(PLAYER *playerr, const char *a2, char SoundByte)
{
  __int16 v4; // cx
  unsigned int v5; // kr08_4
  char buf[512]; // [esp+10h] [ebp-5h] BYREF

  v4 = playerr->field_14;
  buf[2] = SoundByte;
  *(_WORD *)&buf[3] = v4;
  buf[0] = 7;
  buf[1] = 0;
  strcpy(&buf[5], a2);
  v5 = strlen(a2) + 1;
  PlayerSendPacket(playerr, buf, v5 + 5, 0);
  sub_41D6D0(playerr->lpNetworkData, (int)&buf[5], (int)&a2[v5]);
}

//----- (0040E5B0) --------------------------------------------------------
// Player.SendFile()
int __thiscall SendFile(int *this, char *filename)
{
  PLAYER *v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // ebp
  _BYTE *v7; // esi
  int result; // eax
  char buf; // [esp+10h] [ebp-14h] BYREF
  char v11[19]; // [esp+11h] [ebp-13h] BYREF

  v2 = (PLAYER *)this;
  v3 = fopen(filename, "rb");
  v4 = v3;
  if ( v3 )
  {
    v5 = _fileno(v3);
    v6 = _filelength(v5);
    v7 = emalloc(v6 + 17);
    fread(v7 + 17, 1, v6, v4);
    fclose(v4);
    *v7 = 16;
    strncpy(v7 + 1, filename, 0x10u);
    v7[16] = 0;
    result = SendHugeChunkPacketAllocated(this[10], (int)v7, v6 + 17, 0);
  }
  else
  {
    buf = 16;
    strncpy(v11, filename, 0x10u);
    v11[15] = 0;
    result = PlayerSendPacket(v2, &buf, 17, 1);
  }
  return result;
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (0040E680) --------------------------------------------------------
// Player.PlayerFindSuitableArena()
void __userpurge PlayerFindSuitableArena(PLAYER *p@<ecx>, DWORD join_type, char *arena_preference, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ebx
  PLAYER *v11; // edx
  int v12; // ecx
  ARENA *v13; // esi
  char *v14; // ebp
  int *v15; // ebx
  ARENA *v16; // eax
  int v17; // edx
  int v18; // edi
  unsigned int v19; // esi
  int v20; // eax
  int v21; // esi
  int *v22; // edx
  int v23; // edi
  int v24; // esi
  ARENA *v25; // eax
  int v26; // edi
  ARENA **v27; // esi
  ARENA *v28; // eax
  int v29; // esi
  int i; // eax
  int v31; // edx
  int v32; // edi
  int *v33; // esi
  int v34; // ecx
  int v36; // [esp+24h] [ebp+4h]

  v10 = 0;
  v11 = p;
  if ( (join_type & 0x80000000) == 0 )
  {
    v12 = ArenaArrayLength;
    if ( (int)join_type < ArenaArrayLength )
    {
      if ( v11->bIsModerator )
        return;
      v13 = (ARENA *)ArenaArray[join_type];
      if ( !v13->name[offsetof(ARENA, field_0)]
        && *(_DWORD *)(ArenaArray[join_type] + offsetof(ARENA, nPlayersHere)) < *(_DWORD *)&v13->dwMaxPlayers )
      {
        return;
      }
    }
    goto LABEL_53;
  }
  if ( join_type == -1 && (v14 = p->field_18F, p->field_18F[0]) )
  {
    v12 = ArenaArrayLength;
    v36 = 0;
    if ( ArenaArrayLength <= 0 )
      goto LABEL_53;
    v15 = ArenaArray;
    while ( 1 )
    {
      v16 = (ARENA *)*v15;
      if ( !*(_BYTE *)(*v15 + offsetof(ARENA, name)) )
      {
        v17 = v16->nPlayersHere;
        if ( v17 < *(_DWORD *)&v16->dwMaxPlayers )
        {
          v18 = 0;
          if ( v17 > 0 )
            break;
        }
      }
LABEL_18:
      ++v15;
      if ( ++v36 >= v12 )
        goto LABEL_53;
    }
    v19 = offsetof(ARENA, PlayerArray);
    while ( _strcmpi((const char *)(*(_DWORD *)&v16->field_0[v19] + 399), v14) )
    {
      v16 = (ARENA *)*v15;
      ++v18;
      v19 += 4;
      if ( v18 >= *(_DWORD *)(*v15 + offsetof(ARENA, nPlayersHere)) )
      {
        v12 = ArenaArrayLength;
        goto LABEL_18;
      }
    }
  }
  else if ( join_type == -2 )
  {
    v12 = ArenaArrayLength;
    v20 = 0;
    if ( ArenaArrayLength > 0 )
    {
      v21 = *(_DWORD *)v11->lpArenaPointer2;
      v22 = ArenaArray;
      while ( *v22 != v21 )
      {
        ++v20;
        ++v22;
        if ( v20 >= ArenaArrayLength )
          goto LABEL_28;
      }
      v10 = v20;
    }
LABEL_28:
    v23 = 0;
    if ( ArenaArrayLength <= 0 )
      goto LABEL_53;
    v24 = v10 + 1;
    while ( 1 )
    {
      v25 = (ARENA *)ArenaArray[v24 % ArenaArrayLength];
      if ( !v25->name[offsetof(ARENA, field_0)]
        && (p->bIsModerator || v25->nPlayersHere < *(_DWORD *)&v25->dwMaxPlayers) )
      {
        break;
      }
      ++v23;
      ++v24;
      if ( v23 >= ArenaArrayLength )
        goto LABEL_53;
    }
  }
  else
  {
    if ( join_type != -3 )
    {
      v12 = ArenaArrayLength;
      goto LABEL_53;
    }
    v12 = ArenaArrayLength;
    v26 = 0;
    if ( ArenaArrayLength <= 0 )
    {
LABEL_46:
      if ( v26 == v12 && (v11->bIsSmod || v12 < dwArena_MaxArenas && v10 < dwArena_MaxArenasMemory) )
      {
        v28 = (ARENA *)operator new(0x1DC00u);
        if ( !v28 )
          goto LABEL_69;
        goto LABEL_51;
      }
LABEL_53:
      v29 = -1;
      for ( i = 0; i < v12; ++i )
      {
        v31 = ArenaArray[i];
        if ( !*(_BYTE *)(v31 + 64256) && (v29 == -1 || *(_DWORD *)(v31 + 65292) < *(_DWORD *)(ArenaArray[v29] + 65292)) )
          v29 = i;
      }
      if ( v29 != -1 && *(_DWORD *)(ArenaArray[v29] + 65292) < *(_DWORD *)(ArenaArray[v29] + 119822) )
      {
        v32 = 0;
        if ( v12 > 0 )
        {
          v33 = ArenaArray;
          do
          {
            if ( !*(_BYTE *)(*v33 + offsetof(ARENA, name))
              && *(_DWORD *)(*v33 + offsetof(ARENA, nPlayersHere)) < dwArena_ArenaDesiredPlayers )
            {
              break;
            }
            ++v32;
            ++v33;
          }
          while ( v32 < v12 );
        }
        return;
      }
      v28 = (ARENA *)operator new(0x1DC00u);
      if ( !v28 )
      {
LABEL_69:
        v34 = ArenaArrayLength;
        ArenaArray[ArenaArrayLength] = 0;
        ArenaArrayLength = v34 + 1;
        return;
      }
LABEL_51:
      create_arena(v28, (int)v28, (int)arena_preference, a4, a5, a6, a7, a8, a9, a10);
      return;
    }
    v27 = (ARENA **)ArenaArray;
    while ( 1 )
    {
      v10 += GetArenaMemoryTotal(*v27);
      if ( !_strcmpi((*v27)->name, arena_preference) )
        break;
      v12 = ArenaArrayLength;
      ++v26;
      ++v27;
      if ( v26 >= ArenaArrayLength )
        goto LABEL_45;
    }
    if ( !p->bIsModerator && *(_DWORD *)(ArenaArray[v26] + 65292) >= *(_DWORD *)(ArenaArray[v26] + 119822) )
    {
      v12 = ArenaArrayLength;
LABEL_45:
      v11 = p;
      goto LABEL_46;
    }
  }
}
// 40E6D7: conditional instruction was optimized away because of 'edx.4==0'
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 439E08: using guessed type int dwArena_MaxArenasMemory;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6BF8: using guessed type int dwArena_MaxArenas;
// 4D6C18: using guessed type int dwArena_ArenaDesiredPlayers;

//----- (0040E9F0) --------------------------------------------------------
int __thiscall SendWeaponPacket(PLAYER *player)
{
  int v2; // eax
  __int16 v3; // cx
  __int16 v4; // dx
  int v5; // edi
  __int16 v6; // ax
  unsigned int v7; // eax
  int v8; // ebp
  int v9; // edi
  int v10; // edx
  int v11; // ebp
  int v12; // edx
  int v13; // edi
  int v14; // ebp
  int v15; // edx
  __int16 v16; // cx
  __int16 v17; // ax
  char v18; // al
  char *v19; // ecx
  int v20; // edx
  int v21; // eax
  int v22; // ecx
  int v23; // ebp
  __int16 v24; // dx
  __int16 v25; // ax
  int v26; // edi
  __int16 v27; // cx
  unsigned int v28; // eax
  int v29; // ebp
  int v30; // edi
  int v31; // edx
  int v32; // ebp
  int v33; // edx
  int v34; // edx
  int v35; // edi
  int v36; // ebp
  char v37; // al
  char v38; // cl
  __int16 v39; // ax
  __int16 v40; // cx
  int v41; // edi
  __int16 v42; // dx
  unsigned int v43; // eax
  int v44; // ebp
  int v45; // edi
  int v46; // edx
  int v47; // ebp
  int v48; // edx
  char v49; // al
  int v50; // edi
  int v51; // ebp
  int v52; // edx
  __int16 v53; // dx
  char v54; // al
  __int16 v55; // cx
  __int16 v56; // ax
  int v57; // edx
  __int16 v58; // cx
  char v59; // al
  int *v60; // ecx
  unsigned int v61; // eax
  char *v62; // ecx
  __int16 v63; // dx
  int v64; // edx
  int v65; // edi
  __int16 v66; // ax
  _BOOL1 v67; // cc
  _BOOL1 v68; // cc
  int v69; // eax
  int v70; // ebp
  int v71; // esi
  int v72; // edx
  int v73; // ecx
  int v74; // edi
  int v75; // esi
  int v76; // ecx
  int v77; // ebp
  int v78; // edx
  int v79; // eax
  int v80; // eax
  int v81; // edi
  int v82; // eax
  int v83; // ecx
  PLAYER **v84; // eax
  PLAYER *v85; // ebp
  int v86; // eax
  int v87; // eax
  PLAYER *v88; // ecx
  int v89; // eax
  __int64 v90; // rax
  int v91; // esi
  int v92; // eax
  _BOOL1 v93; // zf
  int result; // eax
  unsigned int v95; // [esp+10h] [ebp-DCh]
  int v96; // [esp+14h] [ebp-D8h]
  int v97; // [esp+14h] [ebp-D8h]
  int v98; // [esp+18h] [ebp-D4h]
  int v99; // [esp+18h] [ebp-D4h]
  int v100; // [esp+1Ch] [ebp-D0h]
  int v101; // [esp+20h] [ebp-CCh]
  int v102; // [esp+20h] [ebp-CCh]
  char buf[2]; // [esp+24h] [ebp-C8h] BYREF
  __int16 v104; // [esp+26h] [ebp-C6h]
  __int16 v105; // [esp+28h] [ebp-C4h]
  __int16 v106; // [esp+2Ah] [ebp-C2h]
  __int16 v107; // [esp+2Ch] [ebp-C0h]
  __int16 v108; // [esp+2Eh] [ebp-BEh]
  char v109; // [esp+30h] [ebp-BCh]
  char v110; // [esp+31h] [ebp-BBh]
  char v111; // [esp+32h] [ebp-BAh]
  __int16 v112; // [esp+33h] [ebp-B9h]
  __int16 v113; // [esp+35h] [ebp-B7h]
  int v114; // [esp+37h] [ebp-B5h]
  int v115; // [esp+3Ch] [ebp-B0h]
  int v116; // [esp+40h] [ebp-ACh]
  int v117; // [esp+44h] [ebp-A8h]
  int v118; // [esp+48h] [ebp-A4h]
  int v119; // [esp+4Ch] [ebp-A0h]
  PLAYER **v120; // [esp+50h] [ebp-9Ch]
  int v121; // [esp+54h] [ebp-98h]
  int v122; // [esp+58h] [ebp-94h]
  PLAYER **v123; // [esp+5Ch] [ebp-90h]
  int v124; // [esp+60h] [ebp-8Ch]
  int v125; // [esp+64h] [ebp-88h]
  int v126; // [esp+68h] [ebp-84h]
  int v127; // [esp+6Ch] [ebp-80h] BYREF
  __int16 v128; // [esp+70h] [ebp-7Ch]
  __int16 v129; // [esp+72h] [ebp-7Ah]
  __int16 v130; // [esp+74h] [ebp-78h]
  __int16 v131; // [esp+76h] [ebp-76h]
  __int16 v132; // [esp+78h] [ebp-74h]
  char v133[3]; // [esp+7Ah] [ebp-72h]
  __int16 v134; // [esp+7Dh] [ebp-6Fh]
  int v135; // [esp+7Fh] [ebp-6Dh]

  v2 = *(_DWORD *)&player->field_283[8];
  *(_DWORD *)&player->field_EA[19] = 0;
  if ( v2 )
  {
    v3 = player->yPixels;
    v4 = *(_WORD *)&player->field_44[158];
    v5 = player->lpNetworkData;
    v105 = player->xPixels;
    v6 = *(_WORD *)player->field_EA;
    v112 = v3;
    LOBYTE(v3) = player->field_44[153];
    buf[0] = 5;
    v108 = v4;
    v106 = v6;
    buf[1] = v3;
    v7 = ((int (*)(void))GetTickCount)();
    v8 = *(_DWORD *)(v5 + 14);
    v9 = *(_DWORD *)&player->field_44[154];
    v10 = v8 + v7 / 0xA;
    v11 = player->lpNetworkData;
    v104 = v10;
    v12 = ((*(_DWORD *)(v11 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v9;
    if ( v12 < 0 || v12 > 30000 )
      v12 = 0;
    if ( v12 <= 255 )
    {
      v13 = *(_DWORD *)&player->field_44[154];
      v14 = player->lpNetworkData;
      v15 = ((*(_DWORD *)(v14 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v13;
      if ( v15 < 0 || v15 > 30000 )
        LOBYTE(v15) = 0;
      v111 = v15;
    }
    else
    {
      v111 = -1;
    }
    v16 = *(_WORD *)&player->field_EA[6];
    v107 = 1014;
    v17 = v16 & 0x1F;
    v110 = 0;
    v113 = 0;
    if ( v17 == 3 || v17 == 4 || v17 == 1 || v17 == 2 )
      LOWORD(v114) = v16 ^ (v16 ^ v16 & 0x80 ^ (v16 & 0x1F ^ v114 & 0xFF80) & 0xFC7F) & 0x3FF;
    else
      LOWORD(v114) = 0;
    v18 = 0;
    v19 = buf;
    v109 = 0;
    v20 = 21;
    do
    {
      v18 ^= *v19++;
      --v20;
    }
    while ( v20 );
    v109 = v18;
    if ( !*(_DWORD *)&player->field_2F9[16] )
    {
      v21 = player->lpCurrentArena;
      if ( v21 )
      {
        if ( (v114 & 0x1F) != 0 )
        {
          v22 = *(_DWORD *)&player->field_319[8];
          v23 = *(_DWORD *)&player->field_117[8] + 1;
          *(_DWORD *)&player->field_117[8] = v23;
          if ( v22 < *(_DWORD *)(v21 + 109902) )
          {
            PlayerSendPacket(player, buf, 21, 0);
            ++*(_DWORD *)&player->field_117[8];
            ++dword_4CA228;
            sub_41D6D0(player->lpNetworkData, v23, 0);
          }
        }
        PlayerSendPacket(player, buf, 21, 0);
      }
    }
  }
  if ( player->dwShip < 8 && player->lpCurrentArena )
  {
    if ( *(int *)&player->field_14 > 255 || *(__int16 *)&player->field_EA[2] > 255 || (player->field_EA[6] & 0x1F) != 0 )
    {
      v39 = player->yPixels;
      v40 = *(_WORD *)&player->field_44[158];
      v41 = player->lpNetworkData;
      v128 = player->xPixels;
      v42 = *(_WORD *)player->field_EA;
      *(_WORD *)&v133[1] = v39;
      LOBYTE(v39) = player->field_44[153];
      v95 = 21;
      LOBYTE(v127) = 5;
      v131 = v40;
      v129 = v42;
      BYTE1(v127) = v39;
      v43 = ((int (*)(void))GetTickCount)();
      v44 = *(_DWORD *)(v41 + 14);
      v45 = *(_DWORD *)&player->field_44[154];
      v46 = v44 + v43 / 0xA;
      v47 = player->lpNetworkData;
      HIWORD(v127) = v46;
      v48 = ((*(_DWORD *)(v47 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v45;
      if ( v48 < 0 || v48 > 30000 )
        v48 = 0;
      if ( v48 <= 255 )
      {
        v50 = *(_DWORD *)&player->field_44[154];
        v51 = player->lpNetworkData;
        v52 = ((*(_DWORD *)(v51 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v50;
        if ( v52 < 0 || v52 > 30000 )
          LOBYTE(v52) = 0;
        v49 = v52;
      }
      else
      {
        v49 = -1;
      }
      v53 = player->field_14;
      v133[0] = v49;
      v54 = player->gap_E6[1];
      v55 = *(_WORD *)&player->field_EA[2];
      v130 = v53;
      HIBYTE(v132) = v54;
      v56 = *(_WORD *)&player->field_EA[6];
      v134 = v55;
      LOWORD(v135) = ((unsigned __int8)v56 ^ (unsigned __int8)v135) & 0x1F ^ v135;
      LOWORD(v135) = ((unsigned __int8)v56 ^ (unsigned __int8)v135) & 0x60 ^ v135;
      LOWORD(v135) = ((unsigned __int8)v56 ^ (unsigned __int8)v135) & 0x80 ^ v135;
      LOWORD(v135) = (v56 ^ v135) & 0x300 ^ v135;
      LOWORD(v135) = (v56 ^ v135) & 0x7C00 ^ v135;
      v57 = 21;
      v58 = v56 ^ (v56 ^ v135) & 0x7FFF;
      v59 = 0;
      LOWORD(v135) = v58;
      LOBYTE(v132) = 0;
      v60 = &v127;
      do
      {
        v59 ^= *(_BYTE *)v60;
        v60 = (int *)((char *)v60 + 1);
        --v57;
      }
      while ( v57 );
      LOBYTE(v132) = v59;
    }
    else
    {
      v24 = player->yPixels;
      v25 = *(_WORD *)&player->field_44[158];
      v26 = player->lpNetworkData;
      v128 = player->xPixels;
      v27 = *(_WORD *)player->field_EA;
      v132 = v24;
      LOBYTE(v24) = player->field_44[153];
      v95 = 16;
      LOBYTE(v127) = 40;
      *(_WORD *)v133 = v25;
      v131 = v27;
      BYTE1(v127) = v24;
      v28 = ((int (*)(void))GetTickCount)();
      v29 = *(_DWORD *)(v26 + 14);
      v30 = *(_DWORD *)&player->field_44[154];
      v31 = v29 + v28 / 0xA;
      v32 = player->lpNetworkData;
      HIWORD(v127) = v31;
      v33 = ((*(_DWORD *)(v32 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v30;
      if ( v33 < 0 || v33 > 30000 )
        v33 = 0;
      if ( v33 <= 255 )
      {
        v35 = *(_DWORD *)&player->field_44[154];
        v36 = player->lpNetworkData;
        v34 = ((*(_DWORD *)(v36 + 14) + ((int (*)(void))GetTickCount)() / 0xAu) & 0x7FFFFFFF) - v35;
        if ( v34 < 0 || v34 > 30000 )
          LOBYTE(v34) = 0;
      }
      else
      {
        LOBYTE(v34) = -1;
      }
      v37 = player->gap_E6[1];
      v38 = player->field_EA[2];
      LOBYTE(v129) = v34;
      LOBYTE(v130) = player->field_14;
      HIBYTE(v130) = v37;
      HIBYTE(v129) = v38;
    }
    if ( *(_DWORD *)&player->field_EA[33] )
    {
      v61 = v95;
      v62 = (char *)&v127 + v95;
      *(_DWORD *)v62 = *(_DWORD *)&player->field_EA[23];
      v63 = *(_WORD *)&player->field_EA[31];
      *((_DWORD *)v62 + 1) = *(_DWORD *)&player->field_EA[27];
      *((_WORD *)v62 + 4) = v63;
      v115 = v95 + 10;
    }
    else
    {
      *(_WORD *)((char *)&v127 + v95) = *(_WORD *)&player->field_EA[4];
      v115 = v95 + 2;
      v61 = v95;
    }
    v64 = 0;
    v65 = 0;
    v101 = 0;
    v96 = 0;
    v98 = 0;
    if ( v61 != 21 )
      goto LABEL_79;
    v66 = v135 & 0x1F;
    if ( v66 == 6 || v66 == 3 && (v135 & 0x8000) != 0 || v66 == 4 && (v135 & 0x8000) != 0 || v66 == 5 || v66 == 8 )
    {
      *(_DWORD *)&player->field_EA[37] = 1;
    }
    else if ( v66 == 4 || v66 == 3 )
    {
      if ( SBYTE1(v127) < 5 || SBYTE1(v127) > 35 )
        v96 = *(_DWORD *)(player->lpCurrentArena + 109894);
      if ( SBYTE1(v127) > 5 )
      {
        v67 = SBYTE1(v127) <= 15;
        if ( SBYTE1(v127) >= 15 )
          goto LABEL_71;
        v65 = *(_DWORD *)(player->lpCurrentArena + 109894);
      }
      v67 = SBYTE1(v127) <= 15;
LABEL_71:
      if ( !v67 )
      {
        v68 = SBYTE1(v127) <= 25;
        if ( SBYTE1(v127) >= 25 )
        {
LABEL_75:
          if ( !v68 && SBYTE1(v127) < 35 )
          {
            v64 = *(_DWORD *)(player->lpCurrentArena + 109894);
            v101 = v64;
          }
          goto LABEL_79;
        }
        v98 = *(_DWORD *)(player->lpCurrentArena + 109894);
      }
      v68 = SBYTE1(v127) <= 25;
      goto LABEL_75;
    }
LABEL_79:
    if ( *(_DWORD *)&player->field_EA[37] )
    {
      v69 = player->lpCurrentArena;
      if ( *(int *)(v69 + 65292) > 0 )
      {
        v70 = 64288;
        do
        {
          v71 = *(_DWORD *)(v70 + v69);
          if ( (PLAYER *)v71 != player )
          {
            v72 = *(_DWORD *)(v71 + 631);
            if ( v72
              || !*(_DWORD *)&player->field_2C[16]
              || (v73 = *(_DWORD *)&player->field_44[8], v73 < 0)
              || v73 == *(_DWORD *)(v71 + 20) )
            {
              v74 = v95;
              if ( *(_DWORD *)(v71 + 68)
                || *(_DWORD *)(v71 + 371) == *(_DWORD *)&player->field_14 && (*(_BYTE *)(v69 + 109576) || v72) )
              {
                v74 = v115;
              }
              lpfnFixExport20(v71, &v127, v74, v74);
            }
          }
          v69 = player->lpCurrentArena;
          v70 += 4;
          ++v101;
        }
        while ( v101 < *(_DWORD *)(v69 + 65292) );
      }
    }
    else
    {
      v75 = (*(_DWORD *)&player->field_117[76] - v64) / 2048;
      if ( v75 < 0 )
        v75 = 0;
      v76 = (v65 + *(_DWORD *)&player->field_117[80]) / 2048;
      if ( v76 >= 8 )
        v76 = 7;
      v77 = (*(_DWORD *)&player->field_117[84] - v96) / 2048;
      v100 = v77;
      if ( v77 < 0 )
      {
        v100 = 0;
        v77 = 0;
      }
      v118 = (v98 + *(_DWORD *)&player->field_117[88]) / 2048;
      v78 = v118;
      if ( v118 >= 8 )
      {
        v78 = 7;
        v118 = 7;
      }
      v79 = player->xPixels;
      v125 = v79 + v65;
      v122 = v79 - v101;
      v80 = player->yPixels;
      v124 = v80 + v98;
      v126 = v80 - v96;
      v102 = 128;
      v99 = 128;
      if ( v95 == 21 && (v135 & 0x1F) != 0 )
      {
        v102 = *(_DWORD *)(player->lpCurrentArena + 109890) + 128;
        v99 = v102;
      }
      if ( v75 <= v76 )
      {
        v81 = 1004 * (v77 + 8 * v75);
        v117 = v81;
        v119 = v76 - v75 + 1;
        do
        {
          if ( v77 <= v78 )
          {
            v82 = v81;
            v121 = v81;
            v83 = v78 - v77 + 1;
            v116 = v83;
            do
            {
              v97 = 0;
              v84 = (PLAYER **)(player->lpCurrentArena + v82);
              v123 = v84;
              if ( (int)v84[250] > 0 )
              {
                v120 = v84;
                do
                {
                  v85 = *v84;
                  if ( *v84 != player )
                  {
                    if ( v85->bIsSysop
                      || !*(_DWORD *)&player->field_2C[16]
                      || (v86 = *(_DWORD *)&player->field_44[8], v86 < 0)
                      || v86 == *(_DWORD *)&v85->field_14 )
                    {
                      v87 = *(_DWORD *)&v85->field_117[92];
                      v88 = v85;
                      if ( v87 < 0 || (v88 = *(&ZonePlayerList + v87)) != 0 )
                      {
                        v89 = *(_DWORD *)&v88->field_231[50];
                        if ( v89 < 0 || (v88 = *(&ZonePlayerList + v89)) != 0 )
                        {
                          if ( (int)abs32(v88->yPixels - player->yPixels) > v99 + v85->dwYRes / 2
                            || (v90 = v88->xPixels - player->xPixels,
                                (int)((HIDWORD(v90) ^ v90) - HIDWORD(v90)) > v102 + v85->dwXRes / 2) )
                          {
                            if ( v125 >= *(_DWORD *)&v88->field_117[76]
                              && v122 <= *(_DWORD *)&v88->field_117[80]
                              && v124 >= *(_DWORD *)&v88->field_117[84]
                              && v126 <= *(_DWORD *)&v88->field_117[88]
                              && (v95 == 21 && (v135 & 0x1Fu) > 2
                               || v97 % *(_DWORD *)(player->lpCurrentArena + 109886) == *(_DWORD *)&player->field_117[4]) )
                            {
                              if ( dword_4CBB04 >= 4000 )
                                IncreaseRadarValueShowHomeOverFourThousand();
                              v92 = 26 * dword_4CBB04;
                              qmemcpy((char *)&dword_4B0BEC + 26 * dword_4CBB04, &v127, v95);
                              byte_4B0C01[v92] = v95;
                              *(int *)((char *)&dword_4B0BE8 + v92) = *(_DWORD *)&v85->field_14;
                              ++dword_4CBB04;
                            }
                          }
                          else
                          {
                            v91 = v95;
                            if ( *(_DWORD *)v85->field_44
                              || *(_DWORD *)&v85->field_117[92] == *(_DWORD *)&player->field_14
                              && (*(_BYTE *)(player->lpCurrentArena + 109576) || v85->bIsSysop) )
                            {
                              v91 = v115;
                            }
                            lpfnFixExport20(v85, &v127, v91, v91);
                            ++dword_4D68C0;
                          }
                        }
                      }
                    }
                  }
                  v84 = v120 + 1;
                  v67 = ++v97 < (int)v123[250];
                  ++v120;
                }
                while ( v67 );
                v77 = v100;
                v78 = v118;
                v81 = v117;
                v83 = v116;
              }
              v82 = v121 + 1004;
              --v83;
              v121 += 1004;
              v116 = v83;
            }
            while ( v83 );
          }
          v81 += 8032;
          v93 = v119 == 1;
          v117 = v81;
          --v119;
        }
        while ( !v93 );
      }
      *(_DWORD *)&player->field_117[4] = (*(_DWORD *)&player->field_117[4] + 1)
                                       % *(_DWORD *)(player->lpCurrentArena + 109886);
    }
  }
  result = 0;
  *(_DWORD *)&player->field_EA[37] = 0;
  *(_DWORD *)&player->field_EA[33] = 0;
  return result;
}
// 4DC214: invalid function type has been ignored
// 42EEDC: using guessed type int (__thiscall *lpfnFixExport20)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4B0BE8: using guessed type int dword_4B0BE8;
// 4B0BEC: using guessed type int dword_4B0BEC;
// 4CA228: using guessed type int dword_4CA228;
// 4CBB04: using guessed type int dword_4CBB04;
// 4D68C0: using guessed type int dword_4D68C0;

//----- (0040F500) --------------------------------------------------------
void __thiscall SendResetScoresPacket(PLAYER *player)
{
  __int16 v1; // dx
  struct ARENA *v2; // ecx
  PLAYER *buf; // [esp+0h] [ebp-4h] BYREF

  buf = player;
  v1 = player->field_14;
  player->score.losses = 0;
  player->score.wins = 0;
  player->score.points = 0;
  player->score.flag_points = 0;
  player->score.flags = 0;
  *(_DWORD *)&player->field_2F9[20] = 1;
  v2 = (struct ARENA *)player->lpCurrentArena;
  LOBYTE(buf) = 0x1A;
  *(_WORD *)((char *)&buf + 1) = v1;
  if ( v2 )
    ArenaSendPacket(v2, (char *)&buf, 3, 1);
}

//----- (0040F560) --------------------------------------------------------
void __thiscall SendPlayerScoreUpdate(struct PLAYER *player)
{
  __int16 v1; // ax
  __int16 v2; // dx
  int v3; // eax
  char buf; // [esp+0h] [ebp-10h] BYREF
  __int16 v5; // [esp+1h] [ebp-Fh]
  int v6; // [esp+3h] [ebp-Dh]
  int v7; // [esp+7h] [ebp-9h]
  __int16 v8; // [esp+Bh] [ebp-5h]
  __int16 v9; // [esp+Dh] [ebp-3h]

  v1 = player->field_14;
  v6 = player->score.points;
  v2 = player->score.wins;
  v5 = v1;
  v3 = player->score.flag_points;
  v8 = v2;
  v7 = v3;
  LOWORD(v3) = player->score.losses;
  buf = 9;
  v9 = v3;
  PlayerSendPacket(player, &buf, 15, 1);
}

//----- (0040F5B0) --------------------------------------------------------
signed int __thiscall SendPlayerScoreUpdateAll(void *player)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebp
  int v5; // ecx
  int v6; // eax
  __int16 v7; // cx
  int v8; // ebp
  __int16 v9; // dx
  int v10; // ebp
  int v11; // ebp
  int v12; // edi
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  char buf; // [esp+10h] [ebp-10h] BYREF
  __int16 v18; // [esp+11h] [ebp-Fh]
  int v19; // [esp+13h] [ebp-Dh]
  int v20; // [esp+17h] [ebp-9h]
  __int16 v21; // [esp+1Bh] [ebp-5h]
  __int16 v22; // [esp+1Dh] [ebp-3h]

  v2 = *(_DWORD *)((char *)player + 557);
  v3 = *(_DWORD *)((char *)player + 581);
  v4 = *(_DWORD *)((char *)player + 585);
  v5 = *(_DWORD *)((char *)player + 553);
  if ( v5 + v2 - v3 - v4 <= dwMisc_PointUpdateDiff )
    return 0;
  if ( !dword_4CA22C )
    return 0;
  v6 = *((_DWORD *)player + 7);
  if ( !v6 )
    return 0;
  v19 = v5;
  v7 = *(_WORD *)((char *)player + 547);
  v8 = *(_DWORD *)((char *)player + 547);
  v20 = v2;
  *(_DWORD *)((char *)player + 575) = v8;
  v9 = *(_WORD *)((char *)player + 549);
  v10 = *(_DWORD *)((char *)player + 551);
  buf = 9;
  *(_DWORD *)((char *)player + 579) = v10;
  v21 = v7;
  v11 = *(_DWORD *)((char *)player + 555);
  v22 = v9;
  *(_DWORD *)((char *)player + 583) = v11;
  *(_WORD *)((char *)player + 587) = *(_WORD *)((char *)player + 559);
  v18 = *((_WORD *)player + 10);
  v12 = 0;
  if ( *(int *)(v6 + 65292) > 0 )
  {
    v13 = 64288;
    do
    {
      v14 = *(_DWORD *)(v13 + v6);
      if ( (void *)v14 != player && !*(_DWORD *)(v14 + 56) )
        PlayerSendPacket((PLAYER *)v14, &buf, 15, 0);
      v6 = *((_DWORD *)player + 7);
      ++v12;
      v13 += 4;
    }
    while ( v12 < *(_DWORD *)(v6 + 65292) );
  }
  PlayerSendPacket((PLAYER *)player, &buf, 15, 1);
  if ( BillingConnectionStructPointer )
  {
    v15 = *((_DWORD *)player + 7);
    if ( !*(_DWORD *)(v15 + 109754) )
    {
      if ( *(_DWORD *)(v15 + 65378) )
      {
        if ( (dwMisc_DisableSharewareScores || dwMisc_DisableShareware) && *((_DWORD *)player + 18) )
          return 1;
        SendBillerUserScorePacket(
          BillingConnectionStructPointer,
          *((_DWORD *)player + offsetof(PLAYER, field_4)),
          (char *)player + offsetof(PLAYER, score),
          0xEu);
      }
    }
  }
  return 1;
}
// 4CA22C: using guessed type int dword_4CA22C;
// 4CB8FC: using guessed type int dwMisc_PointUpdateDiff;
// 4D6C08: using guessed type int dwMisc_DisableShareware;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (0040F710) --------------------------------------------------------
void __thiscall SendAdvertisement(struct PLAYER *playerr, int a2)
{
  __int64 v3; // rax
  unsigned int v4; // kr00_4
  int v5; // eax
  int v6; // edx
  int v7; // edx
  int v8; // edx

  if ( a2
    || (v3 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&playerr->lpArenaPointer2[4]),
        (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) >= 3000) )
  {
    v4 = ((int (*)(void))GetTickCount)();
    v5 = *(_DWORD *)&playerr->field_44[4];
    *(_DWORD *)&playerr->lpArenaPointer2[4] = v4 / 0xA;
    if ( v5 )
    {
      if ( dword_4D9DF4 > 0 || dword_4D9DEC > 0 )
      {
        v6 = rand() % (dword_4D9DF4 + dword_4D9DEC);
        if ( v6 >= dword_4D9DF4 )
        {
          v7 = v6 - dword_4D9DF4;
          if ( a2 )
            PlayerSendPacket(playerr, *(&buf + 2 * v7), buf_sz[2 * v7], 1);
          else
            GetMapLvlRequest((struct CONNECTION *)playerr->lpNetworkData, (char *)*(&buf + 2 * v7), buf_sz[2 * v7], 0);
          return;
        }
        if ( a2 )
        {
LABEL_19:
          PlayerSendPacket(playerr, *(&dword_438FA0 + 2 * v6), dword_438FA4[2 * v6], 1);
          return;
        }
LABEL_20:
        GetMapLvlRequest(
          (struct CONNECTION *)playerr->lpNetworkData,
          (char *)*(&dword_438FA0 + 2 * v6),
          dword_438FA4[2 * v6],
          0);
        return;
      }
    }
    else if ( dword_4D9DF4 > 0 || dword_4D9DF0 > 0 )
    {
      v6 = rand() % (dword_4D9DF4 + dword_4D9DF0);
      if ( v6 < dword_4D9DF4 )
      {
        if ( a2 )
          goto LABEL_19;
        goto LABEL_20;
      }
      v8 = v6 - dword_4D9DF4;
      if ( a2 )
        PlayerSendPacket(playerr, *(&dword_432AA8 + 2 * v8), dword_432AAC[2 * v8], 1);
      else
        GetMapLvlRequest(
          (struct CONNECTION *)playerr->lpNetworkData,
          (char *)*(&dword_432AA8 + 2 * v8),
          dword_432AAC[2 * v8],
          0);
    }
  }
}
// 4DC214: invalid function type has been ignored
// 4D9DEC: using guessed type int dword_4D9DEC;
// 4D9DF0: using guessed type int dword_4D9DF0;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0040F8A0) --------------------------------------------------------
// the flow control before some of the get config calls sets the default value for the ships is its variable
// these are vie settings
// 
// when the compiler uses branchless logic for this there are no jumps so it looks
// like strange math. it is really only flow control.
void __cdecl LoadArenaSettings(struct_ArenaSettings *ArenaSettings, struct_ArenaSettings *a2, const char *a3)
{
  struc_2 *v3; // eax
  struct struc_2 *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  const char *v32; // edi
  char *v33; // esi
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  char v39; // al
  int v40; // edx
  char v41; // al
  int v42; // ecx
  char v43; // al
  int v44; // edx
  int v45; // eax
  int *v46; // esi
  int v47; // edi
  char v48; // [esp-4h] [ebp-44h]
  int v49; // [esp-4h] [ebp-44h]
  char *lpszSection[8]; // [esp+14h] [ebp-2Ch]
  int v51; // [esp+3Ch] [ebp-4h]
  int i; // [esp+4Ch] [ebp+Ch]

  v3 = (struc_2 *)operator new(0x2B74Cu);
  v51 = 0;
  if ( v3 )
    v4 = ReadSettingsSomething(v3, a3);
  else
    v4 = 0;
  v51 = -1;
  if ( ArenaSettings )
  {
    memset(ArenaSettings, 0, 0x594u);
    *(_BYTE *)ArenaSettings = 15;
    *((_BYTE *)ArenaSettings + 1399) = 0;
    v48 = GetCFGSettingInteger(v4, "PrizeWeight", "QuickCharge", 80);
    lpfnFixExport12(ArenaSettings, v4);
    *((_BYTE *)ArenaSettings + 1400) = v48;
    v5 = GetCFGSettingInteger(v4, "PrizeWeight", "Energy", 70);
    if ( v5 > 255 )
      LOBYTE(v5) = -1;
    *((_BYTE *)ArenaSettings + 1401) = v5;
    v6 = GetCFGSettingInteger(v4, "PrizeWeight", "Rotation", 60);
    if ( v6 > 255 )
      LOBYTE(v6) = -1;
    *((_BYTE *)ArenaSettings + 1402) = v6;
    v7 = GetCFGSettingInteger(v4, "PrizeWeight", "Stealth", 30);
    if ( v7 > 255 )
      LOBYTE(v7) = -1;
    *((_BYTE *)ArenaSettings + 1403) = v7;
    v8 = GetCFGSettingInteger(v4, "PrizeWeight", "Cloak", 20);
    if ( v8 > 255 )
      LOBYTE(v8) = -1;
    *((_BYTE *)ArenaSettings + 1404) = v8;
    v9 = GetCFGSettingInteger(v4, "PrizeWeight", "AntiWarp", 20);
    if ( v9 > 255 )
      LOBYTE(v9) = -1;
    *((_BYTE *)ArenaSettings + 1419) = v9;
    v10 = GetCFGSettingInteger(v4, "PrizeWeight", "XRadar", 20);
    if ( v10 > 255 )
      LOBYTE(v10) = -1;
    *((_BYTE *)ArenaSettings + 1405) = v10;
    v11 = GetCFGSettingInteger(v4, "PrizeWeight", "Warp", 40);
    if ( v11 > 255 )
      LOBYTE(v11) = -1;
    *((_BYTE *)ArenaSettings + 1406) = v11;
    v12 = GetCFGSettingInteger(v4, "PrizeWeight", "Gun", 60);
    if ( v12 > 255 )
      LOBYTE(v12) = -1;
    *((_BYTE *)ArenaSettings + 1407) = v12;
    v13 = GetCFGSettingInteger(v4, "PrizeWeight", "Bomb", 50);
    if ( v13 > 255 )
      LOBYTE(v13) = -1;
    *((_BYTE *)ArenaSettings + 1408) = v13;
    v14 = GetCFGSettingInteger(v4, "PrizeWeight", "BouncingBullets", 30);
    if ( v14 > 255 )
      LOBYTE(v14) = -1;
    *((_BYTE *)ArenaSettings + 1409) = v14;
    v15 = GetCFGSettingInteger(v4, "PrizeWeight", "Thruster", 70);
    if ( v15 > 255 )
      LOBYTE(v15) = -1;
    *((_BYTE *)ArenaSettings + 1410) = v15;
    v16 = GetCFGSettingInteger(v4, "PrizeWeight", "TopSpeed", 70);
    if ( v16 > 255 )
      LOBYTE(v16) = -1;
    *((_BYTE *)ArenaSettings + 1411) = v16;
    v17 = GetCFGSettingInteger(v4, "PrizeWeight", "Recharge", 60);
    if ( v17 > 255 )
      LOBYTE(v17) = -1;
    *((_BYTE *)ArenaSettings + 1412) = v17;
    v18 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiFire", 30);
    if ( v18 > 255 )
      LOBYTE(v18) = -1;
    *((_BYTE *)ArenaSettings + 1414) = v18;
    v19 = GetCFGSettingInteger(v4, "PrizeWeight", "Proximity", 30);
    if ( v19 > 255 )
      LOBYTE(v19) = -1;
    *((_BYTE *)ArenaSettings + 1415) = v19;
    v20 = GetCFGSettingInteger(v4, "PrizeWeight", "Glue", 20);
    if ( v20 > 255 )
      LOBYTE(v20) = -1;
    *((_BYTE *)ArenaSettings + 1413) = v20;
    v21 = GetCFGSettingInteger(v4, "PrizeWeight", "AllWeapons", 10);
    if ( v21 > 255 )
      LOBYTE(v21) = -1;
    *((_BYTE *)ArenaSettings + 1416) = v21;
    v22 = GetCFGSettingInteger(v4, "PrizeWeight", "Shields", 10);
    if ( v22 > 255 )
      LOBYTE(v22) = -1;
    *((_BYTE *)ArenaSettings + 1417) = v22;
    v23 = GetCFGSettingInteger(v4, "PrizeWeight", "Shrapnel", 40);
    if ( v23 > 255 )
      LOBYTE(v23) = -1;
    *((_BYTE *)ArenaSettings + 1418) = v23;
    v24 = GetCFGSettingInteger(v4, "PrizeWeight", "Repel", 40);
    if ( v24 > 255 )
      LOBYTE(v24) = -1;
    *((_BYTE *)ArenaSettings + 1420) = v24;
    v25 = GetCFGSettingInteger(v4, "PrizeWeight", "Burst", 30);
    if ( v25 > 255 )
      LOBYTE(v25) = -1;
    *((_BYTE *)ArenaSettings + 1421) = v25;
    v26 = GetCFGSettingInteger(v4, "PrizeWeight", "Decoy", 20);
    if ( v26 > 255 )
      LOBYTE(v26) = -1;
    *((_BYTE *)ArenaSettings + 1422) = v26;
    v27 = GetCFGSettingInteger(v4, "PrizeWeight", "Thor", 30);
    if ( v27 > 255 )
      LOBYTE(v27) = -1;
    *((_BYTE *)ArenaSettings + 1423) = v27;
    v28 = GetCFGSettingInteger(v4, "PrizeWeight", "Portal", 30);
    if ( v28 > 255 )
      LOBYTE(v28) = -1;
    *((_BYTE *)ArenaSettings + 1427) = v28;
    v29 = GetCFGSettingInteger(v4, "PrizeWeight", "Brick", 10);
    if ( v29 > 255 )
      LOBYTE(v29) = -1;
    *((_BYTE *)ArenaSettings + 1425) = v29;
    v30 = GetCFGSettingInteger(v4, "PrizeWeight", "Rocket", 10);
    if ( v30 > 255 )
      LOBYTE(v30) = -1;
    *((_BYTE *)ArenaSettings + 1426) = v30;
    v31 = GetCFGSettingInteger(v4, "PrizeWeight", "MultiPrize", 20);
    if ( v31 > 255 )
      LOBYTE(v31) = -1;
    *((_BYTE *)ArenaSettings + 1424) = v31;
    lpszSection[0] = "Warbird";
    lpszSection[1] = "Javelin";
    lpszSection[2] = "Spider";
    lpszSection[3] = "Leviathan";
    lpszSection[4] = "Terrier";
    lpszSection[5] = "Weasel";
    lpszSection[6] = "Lancaster";
    lpszSection[7] = "Shark";
    for ( i = 0; i < 8; ++i )
    {
      v32 = lpszSection[i];
      v33 = (char *)ArenaSettings + 144 * i + 4;
      *(_DWORD *)v33 = GetCFGSettingInteger(v4, v32, "SuperTime", 6000);
      *((_DWORD *)v33 + 1) = GetCFGSettingInteger(v4, v32, "ShieldsTime", 4000);
      *((_WORD *)v33 + 4) = GetCFGSettingInteger(v4, v32, "Gravity", 1500);
      *((_WORD *)v33 + 5) = GetCFGSettingInteger(v4, v32, "GravityTopSpeed", 100);
      *((_WORD *)v33 + 6) = GetCFGSettingInteger(v4, v32, "BulletFireEnergy", 20);
      *((_WORD *)v33 + 7) = GetCFGSettingInteger(v4, v32, "MultiFireEnergy", 30);
      *((_WORD *)v33 + 8) = GetCFGSettingInteger(v4, v32, "BombFireEnergy", 300);
      *((_WORD *)v33 + 9) = GetCFGSettingInteger(v4, v32, "BombFireEnergyUpgrade", 50);
      *((_WORD *)v33 + 10) = GetCFGSettingInteger(v4, v32, "LandmineFireEnergy", 300);
      *((_WORD *)v33 + 11) = GetCFGSettingInteger(v4, v32, "LandmineFireEnergyUpgrade", 150);
      *((_WORD *)v33 + 12) = GetCFGSettingInteger(v4, v32, "BulletSpeed", 2000);
      *((_WORD *)v33 + 13) = GetCFGSettingInteger(v4, v32, "BombSpeed", 2000);
      v34 = -(i != 4);
      LOBYTE(v34) = v34 & 0xFB;
      *((_WORD *)v33 + 40) = GetCFGSettingInteger(v4, v32, "BulletFireDelay", v34 + 30);
      *((_WORD *)v33 + 41) = GetCFGSettingInteger(v4, v32, "MultiFireDelay", 50);
      *((_WORD *)v33 + 42) = GetCFGSettingInteger(v4, v32, "BombFireDelay", 150);
      *((_WORD *)v33 + 43) = GetCFGSettingInteger(v4, v32, "LandmineFireDelay", 125);
      *((_WORD *)v33 + 15) = GetCFGSettingInteger(v4, v32, "MultiFireAngle", 500);
      v35 = -(i != 7);
      LOBYTE(v35) = v35 & 0x38;
      *((_WORD *)v33 + 16) = GetCFGSettingInteger(v4, v32, "CloakEnergy", v35 + 300);
      *((_WORD *)v33 + 17) = GetCFGSettingInteger(v4, v32, "StealthEnergy", i != 7 ? 333 : 300);
      *((_WORD *)v33 + 18) = GetCFGSettingInteger(v4, v32, "AntiWarpEnergy", 100);
      *((_WORD *)v33 + 19) = GetCFGSettingInteger(v4, v32, "XRadarEnergy", 250);
      if ( i )
      {
        if ( i == 7 )
          v49 = 280;
        else
          v49 = 230;
      }
      else
      {
        v49 = 300;
      }
      *((_WORD *)ArenaSettings + 72 * i + 22) = GetCFGSettingInteger(v4, v32, "MaximumRotation", v49);
      if ( i == 7 || (v36 = 17, !i) )
        v36 = 19;
      *((_WORD *)ArenaSettings + 72 * i + 23) = GetCFGSettingInteger(v4, v32, "MaximumThrust", v36);
      *((_WORD *)ArenaSettings + 72 * i + 24) = GetCFGSettingInteger(v4, v32, "MaximumSpeed", i != 1 ? 3250 : 3750);
      *((_WORD *)ArenaSettings + 72 * i + 25) = GetCFGSettingInteger(v4, v32, "MaximumRecharge", 1150);
      *((_WORD *)ArenaSettings + 72 * i + 26) = GetCFGSettingInteger(v4, v32, "MaximumEnergy", i != 7 ? 1700 : 1750);
      *((_WORD *)ArenaSettings + 72 * i + 27) = GetCFGSettingInteger(v4, v32, "InitialRotation", i != 0 ? 200 : 210);
      *((_WORD *)ArenaSettings + 72 * i + 28) = GetCFGSettingInteger(v4, v32, "InitialThrust", 16 - (i != 0));
      v37 = -(i != 1);
      LOBYTE(v37) = v37 & 0x42;
      *((_WORD *)ArenaSettings + 72 * i + 29) = GetCFGSettingInteger(v4, v32, "InitialSpeed", v37 + 2200);
      *((_WORD *)ArenaSettings + 72 * i + 30) = GetCFGSettingInteger(v4, v32, "InitialRecharge", i != 2 ? 400 : 500);
      *((_WORD *)ArenaSettings + 72 * i + 31) = GetCFGSettingInteger(v4, v32, "InitialEnergy", 1000);
      *((_WORD *)ArenaSettings + 72 * i + 32) = GetCFGSettingInteger(v4, v32, "UpgradeRotation", 40);
      *((_WORD *)ArenaSettings + 72 * i + 33) = GetCFGSettingInteger(v4, v32, "UpgradeThrust", 2);
      *((_WORD *)ArenaSettings + 72 * i + 34) = GetCFGSettingInteger(v4, v32, "UpgradeSpeed", 250);
      *((_WORD *)ArenaSettings + 72 * i + 35) = GetCFGSettingInteger(v4, v32, "UpgradeRecharge", 166);
      *((_WORD *)ArenaSettings + 72 * i + 36) = GetCFGSettingInteger(v4, v32, "UpgradeEnergy", 100);
      *((_WORD *)ArenaSettings + 72 * i + 37) = GetCFGSettingInteger(v4, v32, "AfterburnerEnergy", 1200);
      *((_WORD *)ArenaSettings + 72 * i + 38) = GetCFGSettingInteger(v4, v32, "BombThrust", 400);
      *((_WORD *)ArenaSettings + 72 * i + 39) = GetCFGSettingInteger(v4, v32, "BurstSpeed", 3000);
      *((_BYTE *)ArenaSettings + 144 * i + 111) = GetCFGSettingInteger(v4, v32, "BurstShrapnel", 24);
      *((_WORD *)ArenaSettings + 72 * i + 40) = GetCFGSettingInteger(v4, v32, "TurretThrustPenalty", 1);
      *((_WORD *)ArenaSettings + 72 * i + 41) = GetCFGSettingInteger(v4, v32, "TurretSpeedPenalty", 125);
      *((_BYTE *)ArenaSettings + 144 * i + 110) = GetCFGSettingInteger(v4, v32, "TurretLimit", 5);
      *((_WORD *)ArenaSettings + 72 * i + 46) = GetCFGSettingInteger(v4, v32, "RocketTime", 1000);
      *((_WORD *)ArenaSettings + 72 * i + 47) = GetCFGSettingInteger(v4, v32, "InitialBounty", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 112) = GetCFGSettingInteger(v4, v32, "MaxMines", 5);
      *((_BYTE *)ArenaSettings + 144 * i + 113) = GetCFGSettingInteger(v4, v32, "RepelMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 114) = GetCFGSettingInteger(v4, v32, "BurstMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 115) = GetCFGSettingInteger(v4, v32, "DecoyMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 116) = GetCFGSettingInteger(v4, v32, "ThorMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 117) = GetCFGSettingInteger(v4, v32, "BrickMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 118) = GetCFGSettingInteger(v4, v32, "RocketMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 119) = GetCFGSettingInteger(v4, v32, "PortalMax", 3);
      *((_BYTE *)ArenaSettings + 144 * i + 120) = GetCFGSettingInteger(v4, v32, "InitialRepel", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 121) = GetCFGSettingInteger(v4, v32, "InitialBurst", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 122) = GetCFGSettingInteger(v4, v32, "InitialBrick", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 123) = GetCFGSettingInteger(v4, v32, "InitialRocket", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 124) = GetCFGSettingInteger(v4, v32, "InitialThor", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 125) = GetCFGSettingInteger(v4, v32, "InitialDecoy", i == 2);
      *((_BYTE *)ArenaSettings + 144 * i + 126) = GetCFGSettingInteger(v4, v32, "InitialPortal", 0);
      *((_BYTE *)ArenaSettings + 144 * i + 127) = GetCFGSettingInteger(v4, v32, "BombBounceCount", i == 6);
      v38 = i == 2 || i == 7;
      v39 = GetCFGSettingInteger(v4, v32, "CloakStatus", v38);
      v40 = *((_DWORD *)ArenaSettings + 36 * i + 32);
      BYTE1(v40) &= 0xF3u;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = v40 | ((v39 & 3) << 10);
      v41 = GetCFGSettingInteger(v4, v32, "StealthStatus", (i == 2) + 1);
      v42 = *((_DWORD *)ArenaSettings + 36 * i + 32);
      BYTE1(v42) &= 0xCFu;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((v41 & 3) << 12) | v42;
      v43 = GetCFGSettingInteger(v4, v32, "XRadarStatus", 1);
      v44 = *((_DWORD *)ArenaSettings + 36 * i + 32);
      BYTE1(v44) &= 0x3Fu;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((v43 & 3) << 14) | v44;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "AntiWarpStatus", 1) & 3) << 16) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFFFCFFFF;
      *((_WORD *)ArenaSettings + 72 * i + 48) = GetCFGSettingInteger(v4, v32, "DamageFactor", 30);
      *((_WORD *)ArenaSettings + 72 * i + 49) = GetCFGSettingInteger(v4, v32, "PrizeShareLimit", 100);
      *((_WORD *)ArenaSettings + 72 * i + 50) = GetCFGSettingInteger(v4, v32, "AttachBounty", 12);
      *((_DWORD *)ArenaSettings + 36 * i + 32) = *((_DWORD *)ArenaSettings + 36 * i + offsetof(ShipConfig, CloakEnergy)) ^ ((unsigned __int8)GetCFGSettingInteger(v4, v32, "ShrapnelMax", i != 5 ? 8 : 0) ^ (unsigned __int8)*((_DWORD *)ArenaSettings + 36 * i + offsetof(ShipConfig, CloakEnergy))) & 0x1F;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = (32 * (GetCFGSettingInteger(v4, v32, "ShrapnelRate", 2) & 0x1F)) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFFFFFC1F;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "MaxGuns", 3) & 3) << 20) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFFCFFFFF;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "MaxBombs", (i == 3) + 2) & 3) << 24) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFCFFFFFF;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "InitialGuns", (i == 4) + 1) & 3) << 18) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFFF3FFFF;
      v45 = i == 3 || i == 5;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "InitialBombs", v45) & 3) << 22) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFF3FFFFF;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "EmpBomb", i == 5) & 1) << 27) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xF7FFFFFF;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "SeeMines", i == 5) & 1) << 28) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xEFFFFFFF;
      *((_DWORD *)ArenaSettings + 36 * i + 32) = ((GetCFGSettingInteger(v4, v32, "DoubleBarrel", i == 4) & 1) << 26) | *((_DWORD *)ArenaSettings + 36 * i + 32) & 0xFBFFFFFF;
      *((_WORD *)ArenaSettings + 72 * i + 52) = GetCFGSettingInteger(v4, v32, "SoccerBallFriction", 12);
      *((_WORD *)ArenaSettings + 72 * i + 53) = GetCFGSettingInteger(v4, v32, "SoccerBallProximity", 64);
      *((_WORD *)ArenaSettings + 72 * i + 51) = GetCFGSettingInteger(v4, v32, "SoccerThrowTime", 1200);
      *((_WORD *)ArenaSettings + 72 * i + 54) = GetCFGSettingInteger(v4, v32, "SoccerBallSpeed", 2500);
    }
    *((_DWORD *)ArenaSettings + 289) = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageLevel", 200);
    *((_DWORD *)ArenaSettings + 300) = 1000 * GetCFGSettingInteger(v4, "Bullet", "BulletDamageUpgrade", 100);
    *((_DWORD *)ArenaSettings + 291) = GetCFGSettingInteger(v4, "Bullet", "BulletAliveTime", 550);
    *((_DWORD *)ArenaSettings + 290) = 1000 * GetCFGSettingInteger(v4, "Bomb", "BombDamageLevel", 750);
    *((_DWORD *)ArenaSettings + 292) = GetCFGSettingInteger(v4, "Bomb", "BombAliveTime", 6000);
    *((_WORD *)ArenaSettings + 627) = GetCFGSettingInteger(v4, "Bomb", "BombExplodeDelay", 150);
    *((_WORD *)ArenaSettings + 629) = GetCFGSettingInteger(v4, "Bomb", "BombExplodePixels", 80);
    *((_WORD *)ArenaSettings + 634) = GetCFGSettingInteger(v4, "Bomb", "ProximityDistance", 3);
    *((_WORD *)ArenaSettings + 631) = GetCFGSettingInteger(v4, "Bomb", "JitterTime", 72);
    *((_BYTE *)ArenaSettings + 1377) = GetCFGSettingInteger(v4, "Bomb", "BombSafety", 1);
    *((_WORD *)ArenaSettings + 661) = GetCFGSettingInteger(v4, "Bomb", "EBombShutdownTime", 400);
    *((_WORD *)ArenaSettings + 662) = GetCFGSettingInteger(v4, "Bomb", "EBombDamagePercent", 1000);
    *((_WORD *)ArenaSettings + 666) = GetCFGSettingInteger(v4, "Bomb", "BBombDamagePercent", 1000);
    *((_DWORD *)ArenaSettings + 298) = GetCFGSettingInteger(v4, "Mine", "MineAliveTime", 12000);
    *((_BYTE *)ArenaSettings + 1375) = GetCFGSettingInteger(v4, "Mine", "TeamMaxMines", 12);
    *((_DWORD *)ArenaSettings + 308) = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelSpeed", 3000);
    *((_DWORD *)ArenaSettings + 305) = 1000 * GetCFGSettingInteger(v4, "Shrapnel", "InactiveShrapDamage", 3);
    *((_WORD *)ArenaSettings + 667) = GetCFGSettingInteger(v4, "Shrapnel", "ShrapnelDamagePercent", 1000);
    *((_BYTE *)ArenaSettings + 1368) = GetCFGSettingInteger(v4, "Shrapnel", "Random", 1);
    *((_DWORD *)ArenaSettings + 299) = 1000 * GetCFGSettingInteger(v4, "Burst", "BurstDamageLevel", 515);
    *((_WORD *)ArenaSettings + 654) = GetCFGSettingInteger(v4, "Toggle", "AntiWarpPixels", 1500);
    *((_WORD *)ArenaSettings + 658) = GetCFGSettingInteger(v4, "Prize", "MultiPrizeCount", 10);
    *((_WORD *)ArenaSettings + 646) = GetCFGSettingInteger(v4, "Prize", "PrizeFactor", 1000);
    *((_WORD *)ArenaSettings + 647) = GetCFGSettingInteger(v4, "Prize", "PrizeDelay", 300);
    *((_BYTE *)ArenaSettings + 1381) = GetCFGSettingInteger(v4, "Prize", "PrizeHideCount", 30);
    *((_WORD *)ArenaSettings + 648) = GetCFGSettingInteger(v4, "Prize", "MinimumVirtual", 256);
    *((_WORD *)ArenaSettings + 649) = GetCFGSettingInteger(v4, "Prize", "UpgradeVirtual", 6);
    *((_WORD *)ArenaSettings + 650) = GetCFGSettingInteger(v4, "Prize", "PrizeMaxExist", 8000);
    *((_WORD *)ArenaSettings + 651) = GetCFGSettingInteger(v4, "Prize", "PrizeMinExist", 4000);
    *((_WORD *)ArenaSettings + 652) = GetCFGSettingInteger(v4, "Prize", "PrizeNegativeFactor", 300);
    *((_WORD *)ArenaSettings + 630) = GetCFGSettingInteger(v4, "Prize", "DeathPrizeTime", 800);
    *((_WORD *)ArenaSettings + 633) = GetCFGSettingInteger(v4, "Prize", "EngineShutdownTime", 700);
    *((_BYTE *)ArenaSettings + 1379) = GetCFGSettingInteger(v4, "Prize", "TakePrizeReliable", 0);
    *((_WORD *)ArenaSettings + 644) = GetCFGSettingInteger(v4, "Flag", "FlaggerOnRadar", 1);
    *((_WORD *)ArenaSettings + 645) = GetCFGSettingInteger(v4, "Flag", "FlaggerKillMultiplier", 2);
    *((_BYTE *)ArenaSettings + 1388) = GetCFGSettingInteger(v4, "Flag", "FlaggerGunUpgrade", 0);
    *((_BYTE *)ArenaSettings + 1389) = GetCFGSettingInteger(v4, "Flag", "FlaggerBombUpgrade", 0);
    *((_WORD *)ArenaSettings + 670) = GetCFGSettingInteger(v4, "Flag", "FlaggerFireCostPercent", 1000);
    *((_WORD *)ArenaSettings + 671) = GetCFGSettingInteger(v4, "Flag", "FlaggerDamagePercent", 1000);
    *((_WORD *)ArenaSettings + 672) = GetCFGSettingInteger(v4, "Flag", "FlaggerBombFireDelay", 0);
    *((_WORD *)ArenaSettings + 677) = GetCFGSettingInteger(v4, "Flag", "FlaggerSpeedAdjustment", 0);
    *((_WORD *)ArenaSettings + 676) = GetCFGSettingInteger(v4, "Flag", "FlaggerThrustAdjustment", 0);
    *((_BYTE *)ArenaSettings + 1384) = GetCFGSettingInteger(v4, "Flag", "CarryFlags", 1);
    *((_DWORD *)ArenaSettings + 301) = GetCFGSettingInteger(v4, "Flag", "FlagDropDelay", 0);
    *((_WORD *)ArenaSettings + 669) = GetCFGSettingInteger(v4, "Flag", "FlagDropResetReward", 0);
    *((_DWORD *)ArenaSettings + 302) = GetCFGSettingInteger(v4, "Flag", "EnterGameFlaggingDelay", 12000);
    *((_WORD *)ArenaSettings + 656) = GetCFGSettingInteger(v4, "Flag", "FlagBlankDelay", 200);
    *((_WORD *)ArenaSettings + 657) = GetCFGSettingInteger(v4, "Flag", "NoDataFlagDropDelay", 500);
    *((_BYTE *)ArenaSettings + 1369) = GetCFGSettingInteger(v4, "Soccer", "BallBounce", 1);
    *((_BYTE *)ArenaSettings + 1370) = GetCFGSettingInteger(v4, "Soccer", "AllowBombs", 1);
    *((_BYTE *)ArenaSettings + 1371) = GetCFGSettingInteger(v4, "Soccer", "AllowGuns", 1);
    *((_WORD *)ArenaSettings + 673) = GetCFGSettingInteger(v4, "Soccer", "PassDelay", 20);
    *((_BYTE *)ArenaSettings + 1372) = GetCFGSettingInteger(v4, "Soccer", "Mode", 1);
    *((_WORD *)ArenaSettings + 674) = GetCFGSettingInteger(v4, "Soccer", "BallBlankDelay", 200);
    *((_BYTE *)ArenaSettings + 1390) = GetCFGSettingInteger(v4, "Soccer", "UseFlagger", 0);
    *((_BYTE *)ArenaSettings + 1391) = GetCFGSettingInteger(v4, "Soccer", "BallLocation", 0);
    *((_BYTE *)ArenaSettings + 1386) = GetCFGSettingInteger(v4, "Radar", "RadarMode", 0);
    *((_WORD *)ArenaSettings + 663) = GetCFGSettingInteger(v4, "Radar", "RadarNeutralSize", 128);
    *((_WORD *)ArenaSettings + 637) = GetCFGSettingInteger(v4, "Radar", "MapZoomFactor", 10);
    *((_DWORD *)ArenaSettings + 296) = GetCFGSettingInteger(v4, "Team", "MaxFrequency", 9999);
    *((_BYTE *)ArenaSettings + 1373) = GetCFGSettingInteger(v4, "Team", "MaxPerTeam", 6);
    *((_BYTE *)ArenaSettings + 1374) = GetCFGSettingInteger(v4, "Team", "MaxPerPrivateTeam", 0);
    *((_WORD *)ArenaSettings + 638) = GetCFGSettingInteger(v4, "Kill", "MaxBonus", 0);
    *((_WORD *)ArenaSettings + 639) = GetCFGSettingInteger(v4, "Kill", "MaxPenalty", 0);
    *((_WORD *)ArenaSettings + 640) = GetCFGSettingInteger(v4, "Kill", "RewardBase", 0);
    *((_WORD *)ArenaSettings + 635) = GetCFGSettingInteger(v4, "Kill", "BountyIncreaseForKill", 6);
    *((_WORD *)ArenaSettings + 632) = GetCFGSettingInteger(v4, "Kill", "EnterDelay", 200);
    *((_DWORD *)ArenaSettings + 297) = GetCFGSettingInteger(v4, "Repel", "RepelSpeed", 5000);
    *((_WORD *)ArenaSettings + 641) = GetCFGSettingInteger(v4, "Repel", "RepelTime", 225);
    *((_WORD *)ArenaSettings + 642) = GetCFGSettingInteger(v4, "Repel", "RepelDistance", 512);
    *((_BYTE *)ArenaSettings + 1378) = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    *((_BYTE *)ArenaSettings + 1380) = GetCFGSettingInteger(v4, "Message", "AllowAudioMessages", 1);
    *((_BYTE *)ArenaSettings + 1376) = GetCFGSettingInteger(v4, "Wormhole", "GravityBombs", 1);
    *((_DWORD *)ArenaSettings + 306) = GetCFGSettingInteger(v4, "Wormhole", "SwitchTime", 0);
    *((_WORD *)ArenaSettings + 626) = GetCFGSettingInteger(v4, "Latency", "SendRoutePercent", 500);
    *((_WORD *)ArenaSettings + 678) = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketSampleSize", 100);
    *((_WORD *)ArenaSettings + 659) = GetCFGSettingInteger(v4, "Brick", "BrickTime", 12000);
    *((_DWORD *)ArenaSettings + 303) = GetCFGSettingInteger(v4, "Rocket", "RocketThrust", 25);
    *((_DWORD *)ArenaSettings + 304) = GetCFGSettingInteger(v4, "Rocket", "RocketSpeed", 5500);
    *((_WORD *)ArenaSettings + 653) = GetCFGSettingInteger(v4, "Door", "DoorDelay", 400);
    *((_WORD *)ArenaSettings + 655) = GetCFGSettingInteger(v4, "Door", "DoorMode", -1);
    *((_WORD *)ArenaSettings + 664) = GetCFGSettingInteger(v4, "Misc", "WarpPointDelay", 6000);
    *((_DWORD *)ArenaSettings + 293) = GetCFGSettingInteger(v4, "Misc", "DecoyAliveTime", 3000);
    *((_WORD *)ArenaSettings + 636) = GetCFGSettingInteger(v4, "Misc", "BounceFactor", 22);
    *((_WORD *)ArenaSettings + 628) = GetCFGSettingInteger(v4, "Misc", "SendPositionDelay", 10);
    *((_BYTE *)ArenaSettings + 1383) = GetCFGSettingInteger(v4, "Misc", "SlowFrameCheck", 0);
    *((_BYTE *)ArenaSettings + 1385) = GetCFGSettingInteger(v4, "Misc", "AllowSavedShips", 1);
    *((_DWORD *)ArenaSettings + 294) = GetCFGSettingInteger(v4, "Misc", "SafetyLimit", 90000);
    *((_DWORD *)ArenaSettings + 295) = GetCFGSettingInteger(v4, "Misc", "FrequencyShift", 900);
    *((_WORD *)ArenaSettings + 643) = GetCFGSettingInteger(v4, "Misc", "TickerDelay", 1000);
    *((_BYTE *)ArenaSettings + 1382) = GetCFGSettingInteger(v4, "Misc", "ExtraPositionData", 0);
    *((_WORD *)ArenaSettings + 660) = GetCFGSettingInteger(v4, "Misc", "WarpRadiusLimit", 1024);
    *((_DWORD *)ArenaSettings + 307) = GetCFGSettingInteger(v4, "Misc", "ActivateAppShutdownTime", 1500);
    *((_WORD *)ArenaSettings + 665) = GetCFGSettingInteger(v4, "Misc", "NearDeathLevel", 0);
    *((_BYTE *)ArenaSettings + 1387) = GetCFGSettingInteger(v4, "Misc", "VictoryMusic", 1);
    *((_WORD *)ArenaSettings + 668) = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketTime", 40);
    *((_WORD *)ArenaSettings + 675) = GetCFGSettingInteger(v4, "Latency", "S2CNoDataKickoutDelay", 500);
  }
  if ( a2 )
  {
    *((_DWORD *)a2 + 1) = GetCFGSettingInteger(v4, "Custom", "SaveStatsTime", 720000);
    *((_DWORD *)a2 + 4) = GetCFGSettingInteger(v4, "Territory", "RewardDelay", 60000);
    *((_DWORD *)a2 + 5) = GetCFGSettingInteger(v4, "Territory", "RewardBaseFlags", 8);
    *((_DWORD *)a2 + 6) = GetCFGSettingInteger(v4, "Territory", "RewardMinimumPlayers", 5);
    *((_DWORD *)a2 + 7) = GetCFGSettingInteger(v4, "Territory", "RewardPoints", 30);
    *((_DWORD *)a2 + 8) = GetCFGSettingInteger(v4, "Periodic", "RewardDelay", 0);
    *((_DWORD *)a2 + 9) = GetCFGSettingInteger(v4, "Periodic", "RewardMinimumPlayers", 16);
    *((_DWORD *)a2 + 10) = GetCFGSettingInteger(v4, "Periodic", "RewardPoints", 50);
    *((_DWORD *)a2 + 31) = GetCFGSettingInteger(v4, "Flag", "FlagMode", 0);
    *((_DWORD *)a2 + 3) = GetCFGSettingInteger(v4, "Flag", "FlagResetDelay", 1440000);
    *((_DWORD *)a2 + 23) = GetCFGSettingInteger(v4, "Flag", "MaxFlags", 16);
    *((_DWORD *)a2 + 22) = GetCFGSettingInteger(v4, "Flag", "RandomFlags", 0);
    *((_DWORD *)a2 + 24) = GetCFGSettingInteger(v4, "Flag", "FlagReward", 1000);
    *((_DWORD *)a2 + 25) = GetCFGSettingInteger(v4, "Flag", "FlagRewardMode", 0);
    *((_DWORD *)a2 + 34) = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadius", 8);
    *((_DWORD *)a2 + 35) = GetCFGSettingInteger(v4, "Flag", "FlagTerritoryRadiusCentroid", 0);
    *((_DWORD *)a2 + 26) = GetCFGSettingInteger(v4, "Flag", "FriendlyTransfer", 1);
    *((_DWORD *)a2 + 12) = GetCFGSettingInteger(v4, "Kill", "KillPointsPerFlag", 0);
    *((_DWORD *)a2 + 13) = GetCFGSettingInteger(v4, "Kill", "KillPointsMinimumBounty", 50);
    *((_DWORD *)a2 + 11) = GetCFGSettingInteger(v4, "Kill", "DebtKills", 0);
    *((_DWORD *)a2 + 14) = GetCFGSettingInteger(v4, "Kill", "NoRewardKillDelay", 0);
    *((_DWORD *)a2 + 15) = GetCFGSettingInteger(v4, "Kill", "BountyRewardPercent", 0);
    *((_DWORD *)a2 + 16) = GetCFGSettingInteger(v4, "Kill", "FixedKillReward", -1);
    *((_DWORD *)a2 + 32) = GetCFGSettingInteger(v4, "Kill", "JackpotBountyPercent", 0);
    *((_DWORD *)a2 + 39) = GetCFGSettingInteger(v4, "Team", "ForceEvenTeams", 0);
    *((_DWORD *)a2 + 21) = GetCFGSettingInteger(v4, "Team", "DesiredTeams", 2);
    *((_DWORD *)a2 + 27) = GetCFGSettingInteger(v4, "Team", "SpectatorFrequency", 8025);
    *((_DWORD *)a2 + 36) = GetCFGSettingInteger(v4, "Brick", "BrickSpan", 7);
    *((_DWORD *)a2 + 38) = GetCFGSettingInteger(v4, "Misc", "FrequencyShipTypes", 0);
    *((_DWORD *)a2 + 2) = GetCFGSettingInteger(v4, "Misc", "BannerPoints", 5000);
    *((_DWORD *)a2 + 28) = GetCFGSettingInteger(v4, "Misc", "MaxLossesToPlay", 0);
    *((_DWORD *)a2 + 29) = GetCFGSettingInteger(v4, "Misc", "SpectatorQuiet", 0);
    *((_DWORD *)a2 + 33) = GetCFGSettingInteger(v4, "Misc", "TimedGame", 0);
    GetCFGSettingString(
      v4,
      "Misc",
      "SheepMessage",
      "Sheep successfully cloned -- hello Dolly",
      (char *)a2 + 920,
      0x100u);
    *((_DWORD *)a2 + 85) = GetCFGSettingInteger(v4, "Misc", "ResetScoreOnFrequencyChange", 0);
    *((_DWORD *)a2 + 62) = GetCFGSettingInteger(v4, "Misc", "MaxPlaying", 0);
    *((_DWORD *)a2 + 30) = GetCFGSettingInteger(v4, "Message", "BongAllowed", 0);
    *((_DWORD *)a2 + 40) = GetCFGSettingInteger(v4, "Message", "QuickMessageLimit", 8);
    *((_DWORD *)a2 + 41) = GetCFGSettingInteger(v4, "Message", "MessageReliable", 0);
    *((_DWORD *)a2 + 42) = GetCFGSettingInteger(v4, "Message", "MessageTeamReliable", 1);
    *((_DWORD *)a2 + 43) = GetCFGSettingInteger(v4, "Message", "MessageDistance", 17000);
    *((_DWORD *)a2 + 45) = GetCFGSettingInteger(v4, "Security", "SecurityKickOff", 1);
    *((_DWORD *)a2 + 44) = GetCFGSettingInteger(v4, "Security", "S2CKickOutPercentWeapons", 700);
    *((_DWORD *)a2 + 46) = GetCFGSettingInteger(v4, "Security", "SuicideLimit", 10);
    *((_DWORD *)a2 + 47) = GetCFGSettingInteger(v4, "Security", "MaxShipTypeSwitchCount", 40);
    *((_DWORD *)a2 + 48) = GetCFGSettingInteger(v4, "Security", "PacketModificationMax", 3);
    *((_DWORD *)a2 + 49) = GetCFGSettingInteger(v4, "Security", "MaxDeathWithoutFiring", 5);
    *((_DWORD *)a2 + 17) = GetCFGSettingInteger(v4, "PacketLoss", "C2SKickOutPercent", 800);
    *((_DWORD *)a2 + 18) = GetCFGSettingInteger(v4, "PacketLoss", "C2SNegativeKickOutPercent", 50);
    *((_DWORD *)a2 + 19) = GetCFGSettingInteger(v4, "PacketLoss", "S2CKickOutPercent", 800);
    *((_DWORD *)a2 + 20) = GetCFGSettingInteger(v4, "PacketLoss", "SpectatorPercentAdjust", 100);
    *((_DWORD *)a2 + 64) = GetCFGSettingInteger(v4, "PacketLoss", "PacketLossDisableWeapons", 1);
    *((_DWORD *)a2 + 50) = GetCFGSettingInteger(v4, "Latency", "KickOutDelay", 1000);
    *((_DWORD *)a2 + 51) = GetCFGSettingInteger(v4, "Latency", "NoFlagDelay", 300);
    *((_DWORD *)a2 + 52) = GetCFGSettingInteger(v4, "Latency", "NoFlagPenalty", 1000);
    *((_DWORD *)a2 + 53) = GetCFGSettingInteger(v4, "Latency", "SlowPacketKickoutPercent", 200);
    *((_DWORD *)a2 + 54) = GetCFGSettingInteger(v4, "Latency", "ClientSlowPacketKickoutPercent", 200);
    *((_DWORD *)a2 + 56) = GetCFGSettingInteger(v4, "Latency", "SlowPacketTime", 50);
    *((_DWORD *)a2 + 57) = GetCFGSettingInteger(v4, "Latency", "SlowPacketSampleSize", 300);
    *((_DWORD *)a2 + 58) = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForWeapons", 45);
    *((_DWORD *)a2 + 59) = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForPrizes", 80);
    *((_DWORD *)a2 + 60) = GetCFGSettingInteger(v4, "Latency", "MaxLatencyForKickOut", 120);
    *((_DWORD *)a2 + 61) = GetCFGSettingInteger(v4, "Latency", "LatencyKickOutTime", 2200);
    *((_DWORD *)a2 + 63) = GetCFGSettingInteger(v4, "Latency", "CutbackWatermark", 2400);
    *((_DWORD *)a2 + 65) = GetCFGSettingInteger(v4, "Prize", "S2CTakePrizeReliable", 0);
    *((_DWORD *)a2 + 66) = GetCFGSettingInteger(v4, "Routing", "RadarFavor", 3);
    *((_DWORD *)a2 + 67) = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBulletAdjust", 512);
    *((_DWORD *)a2 + 68) = GetCFGSettingInteger(v4, "Routing", "CloseEnoughBombAdjust", 2048);
    *((_DWORD *)a2 + 69) = GetCFGSettingInteger(v4, "Routing", "DeathDistance", 2800);
    *((_DWORD *)a2 + 70) = GetCFGSettingInteger(v4, "Routing", "DoubleSendPercent", 880);
    *((_DWORD *)a2 + 71) = GetCFGSettingInteger(v4, "Routing", "WallResendCount", 2);
    *((_DWORD *)a2 + 78) = GetCFGSettingInteger(v4, "Soccer", "BallCount", 0);
    *((_DWORD *)a2 + 79) = GetCFGSettingInteger(v4, "Soccer", "SendTime", 200);
    *((_DWORD *)a2 + 80) = GetCFGSettingInteger(v4, "Soccer", "Reward", 1000);
    *((_DWORD *)a2 + 81) = GetCFGSettingInteger(v4, "Soccer", "CapturePoints", 0);
    *((_DWORD *)a2 + 84) = GetCFGSettingInteger(v4, "Soccer", "CatchMinimum", 12);
    *((_DWORD *)a2 + 82) = GetCFGSettingInteger(v4, "Soccer", "CatchPoints", 0);
    *((_DWORD *)a2 + 83) = GetCFGSettingInteger(v4, "Soccer", "WinBy", 0);
    *((_DWORD *)a2 + 72) = GetCFGSettingInteger(v4, "King", "DeathCount", 0);
    *((_DWORD *)a2 + 73) = GetCFGSettingInteger(v4, "King", "ExpireTime", 30000);
    *((_DWORD *)a2 + 76) = GetCFGSettingInteger(v4, "King", "RewardFactor", 1000);
    *((_DWORD *)a2 + 74) = GetCFGSettingInteger(v4, "King", "NonCrownAdjustTime", 3000);
    *((_DWORD *)a2 + 75) = GetCFGSettingInteger(v4, "King", "NonCrownMinimumBounty", 100);
    *((_DWORD *)a2 + 77) = GetCFGSettingInteger(v4, "King", "CrownRecoverKills", 3);
    memset((char *)a2 + 344, 0, 0x240u);
    strcpy((char *)a2 + 344, "Recharge");
    *((_DWORD *)a2 + 91) = 1;
    strcpy((char *)a2 + 368, "Energy");
    *((_DWORD *)a2 + 97) = 2;
    strcpy((char *)a2 + 392, "Rotation");
    *((_DWORD *)a2 + 103) = 3;
    strcpy((char *)a2 + 416, "Stealth");
    *((_DWORD *)a2 + 109) = 4;
    strcpy((char *)a2 + 440, "Cloak");
    *((_DWORD *)a2 + 115) = 5;
    strcpy((char *)a2 + 464, "XRadar");
    *((_DWORD *)a2 + 121) = 6;
    strcpy((char *)a2 + 488, "Gun");
    *((_DWORD *)a2 + 127) = 8;
    strcpy((char *)a2 + 512, "Bomb");
    *((_DWORD *)a2 + 133) = 9;
    strcpy((char *)a2 + 536, "Bounce");
    *((_DWORD *)a2 + 139) = 10;
    strcpy((char *)a2 + 560, "Thrust");
    *((_DWORD *)a2 + 145) = 11;
    strcpy((char *)a2 + 584, "Speed");
    *((_DWORD *)a2 + 151) = 12;
    strcpy((char *)a2 + 608, "MultiFire");
    *((_DWORD *)a2 + 157) = 15;
    strcpy((char *)a2 + 632, "Prox");
    *((_DWORD *)a2 + 163) = 16;
    strcpy((char *)a2 + 656, "Super");
    *((_DWORD *)a2 + 169) = 17;
    strcpy((char *)a2 + 680, "Shield");
    *((_DWORD *)a2 + 175) = 18;
    strcpy((char *)a2 + 704, "Shrap");
    *((_DWORD *)a2 + 181) = 19;
    strcpy((char *)a2 + 728, "AntiWarp");
    *((_DWORD *)a2 + 187) = 20;
    strcpy((char *)a2 + 752, "Repel");
    *((_DWORD *)a2 + 193) = 21;
    strcpy((char *)a2 + 776, "Burst");
    *((_DWORD *)a2 + 199) = 22;
    strcpy((char *)a2 + 800, "Decoy");
    *((_DWORD *)a2 + 205) = 23;
    strcpy((char *)a2 + 824, "Thor");
    *((_DWORD *)a2 + 211) = 24;
    strcpy((char *)a2 + 848, "Brick");
    *((_DWORD *)a2 + 217) = 26;
    strcpy((char *)a2 + 872, "Rocket");
    *((_DWORD *)a2 + 223) = 27;
    strcpy((char *)a2 + 896, "Portal");
    *((_DWORD *)a2 + 229) = 28;
    v46 = (int *)((char *)a2 + 360);
    v47 = 24;
    do
    {
      *v46 = GetCFGSettingInteger(v4, "Cost", (const char *)v46 - 16, 0);
      v46 += 6;
      --v47;
    }
    while ( v47 );
    *((_DWORD *)a2 + 37) = GetCFGSettingInteger(v4, "Cost", "PurchaseAnytime", 0);
    *(_DWORD *)a2 = GetCFGSettingInteger(v4, "Owner", "UserId", -1);
    GetCFGSettingString(v4, "Owner", "Name", "None", (char *)a2 + 1176, 0x20u);
  }
  if ( v4 )
  {
    WriteCfgFile(v4);
    operator delete(v4);
  }
}
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 42EEBC: using guessed type int (__stdcall *lpfnFixExport12)(_DWORD, _DWORD);

//----- (00411DE0) --------------------------------------------------------
int __cdecl SoccerRelatedMath(int SoccerMode, int a2, signed int a3)
{
  int result; // eax

  switch ( SoccerMode )
  {
    case 1:
      result = a2 >= 512;
      break;
    case 2:
      result = a3 >= 512;
      break;
    case 3:
    case 4:
      if ( a2 >= 512 )
        result = a3 >= 512 ? 3 : 1;
      else
        result = a3 >= 512 ? 2 : 0;
      break;
    case 5:
    case 6:
      if ( a2 >= a3 )
        result = (a2 >= 1024 - a3) + 2;
      else
        result = a2 >= 1024 - a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00411EA0) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *v3; // eax
  char *v4; // eax
  char *v6; // eax
  unsigned int v7; // ecx
  char v8; // al
  CHAR *v9; // edi
  CHAR *v10; // edx
  char *v11; // eax
  unsigned int v12; // kr04_4
  CHAR *v13; // edi
  char *v14; // esi
  char v15; // cl
  char *v16; // edx
  unsigned int v17; // eax
  int v18; // edi
  const char **v19; // esi
  int v20; // [esp+0h] [ebp-70h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-64h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-20h] BYREF
  int *v23; // [esp+60h] [ebp-10h]
  int v24; // [esp+6Ch] [ebp-4h]

  v23 = &v20;
  v3 = GetCommandLineA();
  v4 = fix_dll_loader(v3, "/SPAWN");
  if ( v4 )
    return (int)RunCommandPrompt(v4 + 7);
  GetModuleFileNameA(0, &aServerIni, 0x100u);
  v6 = strrchr(&aServerIni, 92);
  if ( v6 )
  {
    v10 = v6 + 1;
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = v10;
  }
  else
  {
    v7 = strlen("server.ini") + 1;
    v8 = v7;
    v9 = &aServerIni;
  }
  qmemcpy(v9, "server.ini", 4 * (v7 >> 2) + (v8 & 3));
  GetModuleFileNameA(0, Filename, 0x100u);
  v11 = strrchr(Filename, 92);
  if ( v11 )
  {
    v16 = v11 + 1;
    v17 = strlen("server.cfg") + 1;
    qmemcpy(v16, "server.cfg", 4 * (v17 >> 2));
    v14 = &aServer_cfg[4 * (v17 >> 2)];
    v13 = &v16[4 * (v17 >> 2)];
    v15 = v17;
  }
  else
  {
    v12 = strlen("server.cfg") + 1;
    qmemcpy(Filename, "server.cfg", 4 * (v12 >> 2));
    v14 = &aServer_cfg[4 * (v12 >> 2)];
    v13 = &Filename[4 * (v12 >> 2)];
    v15 = v12;
  }
  qmemcpy(v13, v14, v15 & 3);
  if ( argc > 1 )
  {
    v18 = argc - 1;
    v19 = argv + 1;
    do
    {
      if ( !_strcmpi(*v19, "/nb") )
        dword_42D860 = 0;
      ++v19;
      --v18;
    }
    while ( v18 );
  }
  ShutdownSpawnCmdLine[0] = 0;
  ((void (*)(void))&nullsub_1)();
  bServerIsRunning = 0;
  while ( !bServerIsRunning )
  {
    ServerInitialize();
    v24 = 0;
    ServerMainloop();
    v24 = -1;
    ServerUninitialize();
  }
  ((void (*)(void))&nullsub_1)();
  if ( ShutdownSpawnCmdLine[0] )
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    StartupInfo.cb = 68;
    StartupInfo.lpTitle = "Spawned Command";
    CreateProcessA(0, ShutdownSpawnCmdLine, 0, 0, 0, 0x210u, 0, 0, &StartupInfo, &ProcessInformation);
  }
  return 0;
}
// 408300: invalid function type has been ignored
// 42D860: using guessed type int dword_42D860;
// 438F98: using guessed type int bServerIsRunning;

//----- (004120D0) --------------------------------------------------------
signed int __cdecl ServerInitialize()
{
  int v0; // eax
  int v1; // edi
  int *v2; // esi
  int *v3; // eax
  int v4; // eax
  int v5; // esi
  int v6; // eax
  struct TEXT_FILE_STRUCT *v7; // eax
  int v8; // eax
  struct TEXT_FILE_STRUCT *v9; // eax
  int v10; // eax
  unsigned int v11; // esi
  int v12; // ebx
  int *v13; // eax
  int *v14; // eax
  unsigned int v15; // esi
  int v16; // eax
  void *v17; // ebx
  int *v18; // eax
  int *v19; // eax
  int v20; // eax
  int *v21; // eax
  struct BILLING_SERVER_STRUCT *v22; // eax
  void *v23; // esi
  SOCKET *v24; // eax
  SOCKET *v25; // eax
  SOCKET **v26; // esi
  SOCKET *v27; // eax
  SOCKET *v28; // eax
  struct TEXT_FILE_STRUCT *v29; // eax
  int v30; // eax
  struct TEXT_FILE_STRUCT *v31; // eax
  int v32; // eax
  struct TEXT_FILE_STRUCT *v33; // eax
  int v34; // eax
  struct TEXT_FILE_STRUCT *v35; // eax
  int v36; // eax
  struct TEXT_FILE_STRUCT *v37; // eax
  int v38; // eax
  PINGSOCKET *v39; // eax
  PINGSOCKET *v40; // eax
  int *v41; // eax
  int *v42; // eax
  const wchar_t *v44; // [esp-8h] [ebp-444h]
  int v45; // [esp+14h] [ebp-428h]
  int v46; // [esp+18h] [ebp-424h] BYREF
  int v47[4]; // [esp+1Ch] [ebp-420h] BYREF
  char v48; // [esp+2Ch] [ebp-410h]
  CHAR FileName[512]; // [esp+30h] [ebp-40Ch] BYREF
  char v50[488]; // [esp+230h] [ebp-20Ch] BYREF
  int v51; // [esp+418h] [ebp-24h]
  int v52; // [esp+438h] [ebp-4h]

  ShutdownSpawnCmdLine[0] = 0;
  bRecycleServer = 0;
  pFILE_subgame_log = fopen("subgame.log", "wt");
  WriteSubGameLog("SubSpace Game Server v1.34\n", 1, 34, 98);
  if ( pFILE_subgame_log )
  {
    fclose(pFILE_subgame_log);
    pFILE_subgame_log = 0;
  }
  v0 = clock();
  srand(v0);
  memset(dword_4D6C20, 0, 0x3000u);
  memset(&ZonePlayerList, 0, 0x1004u);
  memset(&byte_4332F8, 0, 0x5B00u);
  MachineIdArrayCount = 0;
  dword_438F94 = 0;
  ZonePlayerCount = 0;
  dword_4CBB04 = 0;
  dword_4D68C0 = 0;
  dword_4CA228 = 0;
  pFILE_points_log = 0;
  dword_4D9DEC = 0;
  dword_4D9DF0 = 0;
  dword_4D9DF4 = 0;
  dword_4D9E08 = 0;
  InitWinsock();
  IsFileLastWrittenTime(&aServerIni, (int)&unk_432EA8);
  LoadServerIni();
  IsFileLastWrittenTime(Filename, (int)&unk_4332F0);
  LoadArenaSettings((struct_ArenaSettings *)&unk_439430, (struct_ArenaSettings *)::FileName, Filename);
  v1 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v2 = ArenaArray;
    do
    {
      if ( !_strcmpi((const char *)(*v2 + 110830), Filename) )
        *(_DWORD *)(*v2 + 65288) = 1;
      ++v1;
      ++v2;
    }
    while ( v1 < ArenaArrayLength );
  }
  LoadTemplateSSS();
  sub_41AA20();
  LoadAdvertisements();
  v47[0] = 16;
  v47[1] = 0;
  v47[2] = 0;
  v47[3] = 0;
  v45 = 0;
  v48 = 0;
  memset(dword_4CBB08, 0, 0x9DA8u);
  do
  {
    if ( v45 )
    {
      sprintf(v50, "version%d\\", v45);
    }
    else if ( _access("version0", 0) == -1 )
    {
      v50[0] = 0;
    }
    else
    {
      sprintf(v50, "version%d\\", 0);
    }
    v3 = &dword_4CBB08[1009 * v45];
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    strcpy(FileName, v50);
    strcat(FileName, "Update.exe");
    if ( _access(FileName, 0) != -1 )
      dword_4CBB08[1009 * v45] = (int)CompressFile(FileName, &dword_4CBB14[1009 * v45], &v46, v47, 0x11u, 0, 0);
    strcpy(FileName, v50);
    strcat(FileName, "Update1.exe");
    if ( _access(FileName, 0) != -1 )
      dword_4CBB0C[1009 * v45] = (int)CompressFile(FileName, &dword_4CBB18[1009 * v45], &v46, v47, 0x11u, 0, 0);
    strcpy(FileName, v50);
    strcat(FileName, "Update2.exe");
    if ( _access(FileName, 0) != -1 )
      dword_4CBB10[1009 * v45] = (int)CompressFile(FileName, &dword_4CBB1C[1009 * v45], &v46, v47, 0x11u, 0, 0);
    strcpy(FileName, v50);
    strcat(FileName, "subspace.exe");
    if ( _access(FileName, 0) != -1 )
    {
      dword_4CBB20[1009 * v45] = GetSubspaceEXEChecksum((int)FileName, FileName);
      if ( v45 )
        v44 = L"S";
      else
        v44 = L"Z";
      _spawnlp(0, FileName, FileName, v44, 0);
      v4 = fopen("scrty", "rb");
      v5 = v4;
      if ( v4 )
      {
        v6 = _fileno(v4);
        if ( _filelength(v6) != 4000 )
        {
          printf("Security file invalid size\n");
          exit(1);
        }
        fread(&dword_4CBB24[1009 * v45], 1, 4000, v5);
        fclose(v5);
      }
      strcpy(FileName, v50);
      strcat(FileName, "ipblock.txt");
      v7 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      v52 = 0;
      if ( v7 )
        InitializeTextFile(v7, FileName, 1, 1);
      else
        v8 = 0;
      dword_4CCAC4[1009 * v45] = v8;
      strcpy(FileName, v50);
      v52 = -1;
      strcat(FileName, "ipallow.txt");
      v9 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
      v52 = 1;
      if ( v9 )
        InitializeTextFile(v9, FileName, 1, 1);
      else
        v10 = 0;
      v52 = -1;
      dword_4CCAC8[1009 * v45] = v10;
    }
    ++v45;
  }
  while ( v45 < 10 );
  memory = CompressFile("news.txt", (int *)&NewsTxtFileSize, &NewsTxtFileChecksum, v47, 0x11u, 1, 0);
  SetConsoleTitleA(&BillingServerName);
  dword_4CA22C = 1;
  memset(TotalSentForEachPacketType, 0, sizeof(TotalSentForEachPacketType));
  memset(TotalSentSizeForEachPacketType, 0, sizeof(TotalSentSizeForEachPacketType));
  memset(&unk_432EB0, 0, 0x20u);
  dword_432ED8 = 0;
  dword_439E00 = 0;
  dword_4332E8 = 0;
  dword_438F08 = 0;
  dword_4D9CB8 = 0;
  BillerSocket = 0;
  dword_4D9DC4 = 0;
  BillingConnectionStructPointer = 0;
  if ( dword_42D860 )
  {
    v11 = ((int (*)(void))GetTickCount)() / 0xAu;
    v12 = ((int (*)(void))GetTickCount)() / 0xAu;
    v46 = v12;
    v13 = (int *)operator new(0x8C5Cu);
    v52 = 2;
    if ( v13 )
      v14 = setup_stuff_and_socket(v13, 0, 0, 16, 0, 0x2000, 0x2000, 1);
    else
      v14 = 0;
    v52 = -1;
    dword_4D9DC4 = v14;
    encryption = 0;
    while ( (int)abs32(((int (*)(void))GetTickCount)() / 0xAu - v12) < dwBilling_AttemptTime )
    {
      if ( !encryption )
      {
        WriteSubGameLog("Attempting to establish link to billing server...\n");
        v15 = ((int (*)(void))GetTickCount)() / 0xAu;
        v16 = rand();
        encryption = SomethingBillerServer(
                       (PACKET_ATTACHMENT *)dword_4D9DC4,
                       &lpszIP_Billing,
                       dwBilling_Port,
                       ((int)(v15 + v16) >> 31) - (((int)(v15 + v16) >> 31) ^ (v15 + v16)),
                       0);
        v11 = ((int (*)(void))GetTickCount)() / 0xAu;
      }
      PlayerDoNetworkOps((struct_v9 *)dword_4D9DC4);
      if ( sub_41C510((int)encryption) == 2 )
        break;
      if ( (int)abs32(((int (*)(void))GetTickCount)() / 0xAu - v11) > 2000 )
      {
        sub_41C360((int)encryption);
        v17 = dword_4D9DC4;
        encryption = 0;
        if ( dword_4D9DC4 )
        {
          CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
          operator delete(v17);
        }
        v18 = (int *)operator new(0x8C5Cu);
        v52 = 3;
        if ( v18 )
          v19 = setup_stuff_and_socket(v18, 0, 0, 16, 0, 0x2000, 0x2000, 1);
        else
          v19 = 0;
        v12 = v46;
        v52 = -1;
        dword_4D9DC4 = v19;
      }
      if ( console_input_wrapper() )
      {
        v20 = getch();
        if ( (!v20 || v20 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          exit(1);
        }
      }
    }
    if ( sub_41C510((int)encryption) == 2 )
    {
      WriteSubGameLog("Billing server connected.\n");
      v21 = (int *)operator new(0x20u);
      v52 = 4;
      if ( v21 )
      {
        sub_4059D0(
          v21,
          lpfnFixExport6,
          (char *)&BillingServerName,
          dwBilling_ServerID,
          dwBilling_GroupID,
          dwBilling_ScoreID,
          (int)lpsz_Billing_Password,
          (int)dword_4D9DC4,
          (int)encryption);
        v51 = -1;
        BillingConnectionStructPointer = v22;
      }
      else
      {
        v52 = -1;
        BillingConnectionStructPointer = 0;
      }
    }
    else
    {
      WriteSubGameLog("ERROR: Could not connect to billing server.\n");
      v23 = dword_4D9DC4;
      BillingConnectionStructPointer = 0;
      if ( dword_4D9DC4 )
      {
        CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
        operator delete(v23);
      }
      dword_4D9DC4 = 0;
      WriteSubGameLog("Starting server in stand-alone mode.\n");
      v24 = (SOCKET *)operator new(0xCu);
      v52 = 5;
      if ( v24 )
        v25 = ConnectSocket(v24, &lpszIP_Billing, dwBilling_Port + 1, 0);
      else
        v25 = 0;
      v52 = -1;
      BillerSocket = v25;
    }
  }
  if ( strlen(lpszDirectory_IP) > 4 )
  {
    strcpy(v50, lpszDirectory_IP);
    v26 = (SOCKET **)&unk_432EB0;
    do
    {
      if ( !GetSplitNextDirectoryIP(FileName, v50) )
        break;
      v27 = (SOCKET *)operator new(0xCu);
      v52 = 6;
      v28 = v27 ? ConnectSocket(v27, FileName, dwDirectory_Port, 0) : 0;
      *v26++ = v28;
      v52 = -1;
    }
    while ( (int)v26 < (int)&dwMisc_DisableSharewareShips );
  }
  v29 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v52 = 7;
  if ( v29 )
    InitializeTextFile(v29, "obscene.txt", 1, 1);
  else
    v30 = 0;
  v52 = -1;
  ObscenePointer = v30;
  v31 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v52 = 8;
  if ( v31 )
    InitializeTextFile(v31, "idblock.txt", 0, 1);
  else
    v32 = 0;
  v52 = -1;
  IDBlockPointer = v32;
  v33 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v52 = 9;
  if ( v33 )
    InitializeTextFile(v33, "permit.txt", 0, 1);
  else
    v34 = 0;
  v52 = -1;
  PermitPointer = v34;
  v35 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v52 = 10;
  if ( v35 )
    InitializeTextFile(v35, "moderate.txt", 0, 1);
  else
    v36 = 0;
  v52 = -1;
  ModeratePointer = v36;
  v37 = (struct TEXT_FILE_STRUCT *)operator new(0x114u);
  v52 = 11;
  if ( v37 )
    InitializeTextFile(v37, "reserved.txt", 0, 1);
  else
    v38 = 0;
  v52 = -1;
  ReservedPointer = v38;
  ServerListenPort = GetPrivateProfileIntWrapper("Misc", "Port", 0x17Eu, &aServerIni);
  v39 = (PINGSOCKET *)operator new(8u);
  v52 = 12;
  if ( v39 )
    v40 = ListenOnPort(v39, ServerListenPort + 1, &nullsub_1);
  else
    v40 = 0;
  v52 = -1;
  SeverListenerPortPlusOneSocket = (WORLD *)v40;
  ArenaArrayLength = 0;
  v41 = (int *)operator new(0x8C5Cu);
  v52 = 13;
  if ( v41 )
    v42 = setup_stuff_and_socket(
            v41,
            (int)NewConnectionRequest,
            (int)sub_412EF0,
            1024,
            ServerListenPort,
            dwComms_OutgoingBufferSize,
            dwComms_IncomingBufferSize,
            *(int *)&dwComms_PacketHistoryMax);
  else
    v42 = 0;
  v52 = -1;
  ServerPacketAttachment = (LPCSTR)v42;
  SetPacketAttachmentEncryptMode((int)v42, CommsEncryptMode);
  return sub_41C000((void *)ServerPacketAttachment, (signed int)dwComms_TransportBufferSize);
}
// 4DC214: invalid function type has been ignored
// F9: found interdependent unknown calls
// 412638: variable 'v8' is possibly undefined
// 4126D3: variable 'v10' is possibly undefined
// 412A29: variable 'v22' is possibly undefined
// 412BB8: variable 'v30' is possibly undefined
// 412BF7: variable 'v32' is possibly undefined
// 412C36: variable 'v34' is possibly undefined
// 412C75: variable 'v36' is possibly undefined
// 412CC3: variable 'v38' is possibly undefined
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 41F5A0: using guessed type _DWORD _spawnlp(_DWORD, _DWORD, ...);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);
// 42D860: using guessed type int dword_42D860;
// 42DA24: using guessed type wchar_t aS_0[2];
// 42DA28: using guessed type wchar_t aZ[2];
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F0C: using guessed type int dwBilling_AttemptTime;
// 438F94: using guessed type int dword_438F94;
// 4399C4: using guessed type int MachineIdArrayCount;
// 439DF0: using guessed type int dwBilling_Port;
// 439E00: using guessed type int dword_439E00;
// 439E10: using guessed type int CommsEncryptMode;
// 4CA228: using guessed type int dword_4CA228;
// 4CA22C: using guessed type int dword_4CA22C;
// 4CBB04: using guessed type int dword_4CBB04;
// 4CBB08: using guessed type int dword_4CBB08[];
// 4CBB0C: using guessed type int dword_4CBB0C[];
// 4CBB10: using guessed type int dword_4CBB10[];
// 4CBB14: using guessed type int dword_4CBB14[];
// 4CBB18: using guessed type int dword_4CBB18[];
// 4CBB1C: using guessed type int dword_4CBB1C[];
// 4CBB20: using guessed type int dword_4CBB20[];
// 4CBB24: using guessed type int dword_4CBB24[];
// 4CCAC4: using guessed type int dword_4CCAC4[];
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68C0: using guessed type int dword_4D68C0;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C04: using guessed type int NewsTxtFileChecksum;
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9DEC: using guessed type int dword_4D9DEC;
// 4D9DF0: using guessed type int dword_4D9DF0;
// 4D9DF4: using guessed type int dword_4D9DF4;
// 4D9DF8: using guessed type int pFILE_points_log;
// 4D9DFC: using guessed type int pFILE_subgame_log;
// 4D9E08: using guessed type int dword_4D9E08;

//----- (00412DC0) --------------------------------------------------------
void __cdecl NewConnectionRequest(struct in_addr in, __int16 port)
{
  int v2; // ebp
  int v3; // edi
  PLAYER **v4; // esi
  char *v5; // ebx
  PLAYER *v6; // eax
  int v7; // ecx
  PLAYER *v8; // [esp+10h] [ebp-10h]

  v2 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v3 = 0;
    v4 = (PLAYER **)ZonePlayers;
    v5 = (char *)&unk_4CA234;
    do
    {
      if ( (*v4)->in_addr.S_un.S_addr == in && (*v4)->port == port )
      {
        printf("Connection broken because same ip/port requested another connection\n");
        sub_41D780((*v4)->lpNetworkData);
        v8 = *v4;
        if ( *v4 )
        {
          DisconnectPlayer(*v4);
          operator delete(v8);
        }
        --ZonePlayerCount;
        memcpy(v4, v5, 4 * (v3 + ZonePlayerCount));
        --v2;
        v3 -= 0x3FFFFFFF;
        v5 -= 4;
        --v4;
      }
      ++v2;
      v3 += 0x3FFFFFFF;
      v5 += 4;
      ++v4;
    }
    while ( v2 < ZonePlayerCount );
  }
  v6 = (PLAYER *)operator new(65536u);
  if ( v6 )
  {
    init_new_player(v6);
  }
  else
  {
    v7 = ZonePlayerCount;
    ZonePlayers[ZonePlayerCount] = 0;
    ZonePlayerCount = v7 + 1;
  }
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (00412EF0) --------------------------------------------------------
int __cdecl sub_412EF0(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  if ( *(&ZonePlayerList + *(_DWORD *)(a3 + 46)) )
    result = sub_415800(a1, a2);
  return result;
}

//----- (00412F20) --------------------------------------------------------
void __cdecl ServerMainloop()
{
  int (*v0)(void); // ebp
  int i; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // edi
  struct PLAYER **v5; // esi
  unsigned int v6; // esi
  int v7; // edi
  PLAYER **v8; // esi
  int v9; // eax
  int v10; // edi
  char *v11; // esi
  unsigned int v12; // kr08_4
  int v13; // edi
  int *v14; // esi
  int v15; // edi
  int *v16; // esi
  int (*v17)(void); // ebp
  int v18; // ebx
  int v19; // esi
  int *v20; // ebp
  char *v21; // edi
  __int64 v22; // rax
  unsigned int v23; // eax
  void **v24; // esi
  int v25; // edi
  int *v26; // esi
  struct TEXT_FILE_STRUCT **v27; // esi
  struct TEXT_FILE_STRUCT *v28; // ecx
  int v29; // edi
  struct PLAYER **v30; // esi
  unsigned int v31; // eax
  int v32; // esi
  PLAYER *p; // [esp+10h] [ebp-1F4h]
  PLAYER *pa; // [esp+10h] [ebp-1F4h]
  unsigned int pb; // [esp+10h] [ebp-1F4h]
  unsigned int v36; // [esp+14h] [ebp-1F0h]
  unsigned int v37; // [esp+18h] [ebp-1ECh]
  unsigned int v38; // [esp+1Ch] [ebp-1E8h]
  unsigned int v39; // [esp+20h] [ebp-1E4h]
  int v40[4]; // [esp+24h] [ebp-1E0h] BYREF
  char v41; // [esp+34h] [ebp-1D0h]
  int v42; // [esp+38h] [ebp-1CCh] BYREF
  int v43; // [esp+3Ch] [ebp-1C8h] BYREF
  __int16 v44[226]; // [esp+40h] [ebp-1C4h] BYREF

  ((void (*)(void))GetTickCount)();
  ((void (*)(void))GetTickCount)();
  v36 = ((int (*)(void))GetTickCount)() / 0xAu;
  ((void (*)(void))GetTickCount)();
  ((void (*)(void))GetTickCount)();
  v38 = ((int (*)(void))GetTickCount)() / 0xAu;
  ((void (*)(void))GetTickCount)();
  v37 = 0;
  dword_4D6C10 = 0;
  if ( !bServerIsRunning )
  {
    v0 = (int (*)(void))GetTickCount;
    for ( i = 0; ; i = 0 )
    {
      if ( bRecycleServer )
        return;
      v39 = v0() / 0xAu;
      if ( console_input_wrapper() )
      {
        v2 = getch();
        if ( (!v2 || v2 == 224) && getch() == 136 )
        {
          printf("Shutting down server...\n");
          bServerIsRunning = 1;
          return;
        }
      }
      if ( BillingConnectionStructPointer )
      {
        if ( IsBillingServerDisconnected(BillingConnectionStructPointer, (int)v0) )
        {
          WriteSubGameLog("Connection to billing server broken\n");
          bRecycleServer = 1;
        }
        v3 = GetBillerLastReconnectTime(BillingConnectionStructPointer);
        if ( (int)(v0() / 0xAu - v3) > dwBilling_ReconnectTime )
        {
          WriteSubGameLog("Connection to billing server timed out\n");
          bRecycleServer = 1;
        }
        if ( bRecycleServer )
        {
          v4 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v5 = (struct PLAYER **)ZonePlayers;
            do
            {
              if ( (*v5)->lpCurrentArena )
                SendMessage(*v5, "NOTICE: Server recycling, please log back in shortly.", 1);
              ++v4;
              ++v5;
            }
            while ( v4 < ZonePlayerCount );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)ServerPacketAttachment);
        }
      }
      ProcessZonePings((int)SeverListenerPortPlusOneSocket, ZonePlayerCountt);
      v6 = v0() / 0xAu;
      if ( PlayerDoNetworkOps((struct_v9 *)ServerPacketAttachment) )
      {
        while ( (int)(v0() / 0xAu - v6) < dwCPU_ProcessMaxTime
             && PlayerDoNetworkOps((struct_v9 *)ServerPacketAttachment) )
          ;
      }
      v7 = 0;
      if ( ZonePlayerCount > 0 )
      {
        v8 = (PLAYER **)ZonePlayers;
        do
        {
          if ( *(_DWORD *)&(*v8)->field_EA[19] )
            SendWeaponPacket(*v8);
          ++v7;
          ++v8;
        }
        while ( v7 < ZonePlayerCount );
      }
      v9 = dword_4CBB04;
      dword_439E00 += dword_4D68C0;
      v10 = 0;
      dword_438F08 += dword_4CA228;
      dword_4D68C0 = 0;
      dword_4CA228 = 0;
      dword_432ED8 += dword_4CBB04;
      if ( dword_4CBB04 > 0 )
      {
        v11 = byte_4B0C01;
        do
        {
          if ( *(&ZonePlayerList + *(_DWORD *)(v11 - 25)) )
          {
            j_lpfnFixExport20(v11 - 21, *v11, *v11);
            v9 = dword_4CBB04;
          }
          ++v10;
          v11 += 26;
        }
        while ( v10 < v9 );
      }
      dword_4CBB04 = 0;
      if ( (int)abs32(v0() / 0xAu - v36) > 30 )
      {
        v12 = v0();
        dword_4D9DE8 = 0;
        v36 = v12 / 0xA;
        if ( ZonePlayerCount > 0 )
        {
          v13 = 0;
          v14 = ZonePlayers;
          v0 = (int (*)(void))&unk_4CA234;
          do
          {
            if ( CheckUserStopPlaying((PLAYER *)*v14) )
            {
              p = (PLAYER *)*v14;
              --ZonePlayerCount;
              memcpy(v14, v0, 4 * (v13 + ZonePlayerCount));
              if ( p )
              {
                DisconnectPlayer(p);
                operator delete(p);
              }
              --i;
              v13 -= 0x3FFFFFFF;
              v0 = (int (*)(void))((char *)v0 - 4);
              --v14;
            }
            ++i;
            v13 += 0x3FFFFFFF;
            v0 = (int (*)(void))((char *)v0 + 4);
            ++v14;
          }
          while ( i < ZonePlayerCount );
          i = 0;
        }
        if ( ArenaArrayLength > 0 )
        {
          v15 = 0;
          v16 = ArenaArray;
          sub_415820();
          do
          {
            if ( sub_402560(*v16) )
            {
              if ( *(_BYTE *)(*v16 + offsetof(ARENA, name)) )
                WriteSubGameLog("Private arena dropped: %s\n", (const char *)(*v16 + offsetof(ARENA, name)));
              else
                WriteSubGameLog("Arena dropped\n");
              pa = (PLAYER *)*v16;
              if ( *v16 )
              {
                ArenaShutdownArena(*v16);
                operator delete(pa);
              }
              --ArenaArrayLength;
              memcpy(v16, v0, 4 * (v15 + ArenaArrayLength));
              --i;
              v15 -= 0x3FFFFFFF;
              v0 = (int (*)(void))((char *)v0 - 4);
              --v16;
            }
            ++i;
            v15 += 0x3FFFFFFF;
            v0 = (int (*)(void))((char *)v0 + 4);
            ++v16;
          }
          while ( i < ArenaArrayLength );
        }
      }
      lpfnFixExport18();
      ++dword_4332E8;
      if ( (int)(((int (*)(void))GetTickCount)() / 0xAu - dword_4D9DE4) > 6000 )
      {
        v17 = (int (*)(void))GetTickCount;
        memset(TotalSentForEachPacketType, 0, sizeof(TotalSentForEachPacketType));
        v18 = 0;
        memset(TotalSentSizeForEachPacketType, 0, sizeof(TotalSentSizeForEachPacketType));
        dword_432ED8 = 0;
        dword_439E00 = 0;
        dword_4332E8 = 0;
        dword_438F08 = 0;
        dword_4D9CB8 = 0;
        dword_4D9DE4 = ((int (*)(void))GetTickCount)() / 0xAu;
        sub_41BFA0(ServerPacketAttachment);
        if ( MachineIdArrayCount <= 0 )
          goto SKIP_KICKED_USERS;
        v19 = 0;
        v20 = dword_4AD738;
        v21 = (char *)&unk_4AD744;
        do
        {
          v22 = (int)(((int (*)(void))GetTickCount)() / 0xAu - dword_4AD73C[v19]);
          if ( (int)((HIDWORD(v22) ^ v22) - HIDWORD(v22)) > dword_4AD740[v19] )
          {
            --MachineIdArrayCount;
            memcpy(v20, v21, 12 * MachineIdArrayCount - v19 * 4);
            --v18;
            v19 -= 3;
            v21 -= 12;
            v20 -= 3;
          }
          ++v18;
          v19 += 3;
          v21 += 12;
          v20 += 3;
        }
        while ( v18 < MachineIdArrayCount );
      }
      v17 = (int (*)(void))GetTickCount;
SKIP_KICKED_USERS:
      if ( (int)abs32(v17() / 0xAu - v37) > 6000 )
      {
        v23 = v17();
        memset(v44, 0, 0x1C0u);
        v37 = v23 / 0xA;
        v44[224] = 0;
        v44[1] = ZonePlayerCountt;
        v44[2] = BillingConnectionStructPointer != 0;
        *(_DWORD *)&v44[3] = 134;
        v44[0] = ServerListenPort;
        strncpy((char *)&v44[5], &BillingServerName, 0x20u);
        HIBYTE(v44[20]) = 0;
        strncpy((char *)&v44[21], DirectoryNamePassword, 0x10u);
        HIBYTE(v44[28]) = 0;
        strncpy((char *)&v44[45], DirectoryDescription, 0xFAu);
        HIBYTE(v44[169]) = 0;
        v24 = (void **)&unk_432EB0;
        do
        {
          if ( *v24 )
          {
            SendDirectoryServerZoneUpdatePacket(*v24, v44, strlen((const char *)&v44[45]) + 91);
            GetSocketRecvLag((SOCKET)*v24, &v43);
          }
          ++v24;
        }
        while ( (int)v24 < (int)&dwMisc_DisableSharewareShips );
      }
      if ( (int)abs32(v17() / 0xAu - v38) > 18000 || dword_4D6C10 )
      {
        pb = v17() / 0xAu;
        if ( BillerSocket && !BillingConnectionStructPointer )
          SendDirectoryServerZoneUpdatePacket(BillerSocket, 0, 0);
        dword_4CA22C = 1;
        dword_4D6C10 = 0;
        v38 = v17() / 0xAu;
        if ( IsFileLastWrittenTime(&aServerIni, (int)&unk_432EA8) )
        {
          printf("INI settings different, re-reading\n");
          LoadServerIni();
          SetPacketAttachmentEncryptMode((int)ServerPacketAttachment, CommsEncryptMode);
          sub_41C000((void *)ServerPacketAttachment, (signed int)dwComms_TransportBufferSize);
        }
        if ( IsFileLastWrittenTime(Filename, (int)&unk_4332F0) )
        {
          printf("Master CFG settings different, re-reading\n");
          LoadArenaSettings((struct_ArenaSettings *)&unk_439430, (struct_ArenaSettings *)FileName, Filename);
          v25 = 0;
          if ( ArenaArrayLength > 0 )
          {
            v26 = ArenaArray;
            do
            {
              if ( !_strcmpi((const char *)(*v26 + 110830), Filename) )
                *(_DWORD *)(*v26 + 65288) = 1;
              ++v25;
              ++v26;
            }
            while ( v25 < ArenaArrayLength );
          }
        }
        v27 = (struct TEXT_FILE_STRUCT **)dword_4CCAC8;
        do
        {
          v28 = *(v27 - 1);
          if ( v28 )
            LoadTextFile(v28, 0);
          if ( *v27 )
            LoadTextFile(*v27, 0);
          v27 += 1009;
        }
        while ( (int)v27 < (int)&unk_4D6870 );
        LoadTextFile((struct TEXT_FILE_STRUCT *)IDBlockPointer, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)ObscenePointer, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)PermitPointer, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)ModeratePointer, 0);
        LoadTextFile((struct TEXT_FILE_STRUCT *)ReservedPointer, 0);
        v40[0] = 16;
        v40[1] = 0;
        v40[2] = 0;
        v40[3] = 0;
        v41 = 0;
        if ( IsFileLastWrittenTime("news.txt", (int)&unk_4D6C14) )
        {
          if ( memory )
            efree(memory);
          memory = CompressFile("news.txt", (int *)&NewsTxtFileSize, &NewsTxtFileChecksum, v40, 0x11u, 1, 0);
        }
        if ( BillerSocket && !BillingConnectionStructPointer && GetSocketRecvLag((SOCKET)BillerSocket, &v42) >= 0 )
        {
          v29 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v30 = (struct PLAYER **)ZonePlayers;
            do
            {
              if ( (*v30)->lpCurrentArena )
                SendMessage(*v30, "NOTICE: Server recycling in order to restore scores, please log back in.", 1);
              ++v29;
              ++v30;
            }
            while ( v29 < ZonePlayerCount );
          }
          SendPacketsToEverybody((struct PACKET_ATTACHMENT *)ServerPacketAttachment);
          bRecycleServer = 1;
        }
        v31 = v17();
        printf("Re-read Settings: %d ms\n", 10 * (v31 / 0xA - pb));
        fflush(&unk_42F788);
      }
      DLL_FILE_SERVER_MAIN_LOOP_HOOK_SERVER_PACKET_ATTACHMENT_PARAM(ServerPacketAttachment);
      v32 = v17() / 0xAu - v39;
      if ( v32 <= 2 || dwCPU_SleepPerIteration )
        Sleep(CPUSleepTime);
      if ( v32 > dwCPU_SlowIterationWarningLevel )
        WriteSubGameLog("Slow iteration warning: %d ms\n", 10 * v32);
      if ( bServerIsRunning )
        return;
      v0 = (int (*)(void))GetTickCount;
    }
  }
}
// 4DC214: invalid function type has been ignored
// 402560: using guessed type int __thiscall sub_402560(_DWORD);
// 40DF00: using guessed type int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD);
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41F620: using guessed type _DWORD __cdecl fflush(_DWORD);
// 42EED4: using guessed type int (*lpfnFixExport18)(void);
// 42EED8: using guessed type int (__thiscall *DLL_FILE_SERVER_MAIN_LOOP_HOOK_SERVER_PACKET_ATTACHMENT_PARAM)(_DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F98: using guessed type int bServerIsRunning;
// 4399C4: using guessed type int MachineIdArrayCount;
// 439E00: using guessed type int dword_439E00;
// 439E04: using guessed type int dwCPU_SlowIterationWarningLevel;
// 439E10: using guessed type int CommsEncryptMode;
// 439E68: using guessed type int dwBilling_ReconnectTime;
// 4AD738: using guessed type int dword_4AD738[];
// 4AD73C: using guessed type int dword_4AD73C[];
// 4AD740: using guessed type int dword_4AD740[];
// 4CA228: using guessed type int dword_4CA228;
// 4CA22C: using guessed type int dword_4CA22C;
// 4CA230: using guessed type int ZonePlayers[];
// 4CB234: using guessed type int dwCPU_SleepPerIteration;
// 4CBB04: using guessed type int dword_4CBB04;
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68C0: using guessed type int dword_4D68C0;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6BF4: using guessed type int dwCPU_ProcessMaxTime;
// 4D6C04: using guessed type int NewsTxtFileChecksum;
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9DE4: using guessed type int dword_4D9DE4;
// 4D9DE8: using guessed type int dword_4D9DE8;

//----- (00413860) --------------------------------------------------------
int __cdecl IncreaseRadarValueShowHomeOverFourThousand()
{
  int result; // eax
  int v1; // edi
  char *v2; // esi

  result = dword_4CBB04;
  v1 = 0;
  dword_432ED8 += dword_4CBB04;
  if ( dword_4CBB04 > 0 )
  {
    v2 = &byte_4B0C01;
    do
    {
      if ( *(&ZonePlayerList + *(_DWORD *)(v2 - 25)) )
      {
        j_lpfnFixExport20(v2 - 21, *v2, *v2);
        result = dword_4CBB04;
      }
      ++v1;
      v2 += 26;
    }
    while ( v1 < result );
  }
  dword_4CBB04 = 0;
  return result;
}
// 40DF00: using guessed type int __stdcall j_lpfnFixExport20(_DWORD, _DWORD, _DWORD);
// 432ED8: using guessed type int dword_432ED8;
// 4B0C01: using guessed type char byte_4B0C01;
// 4CBB04: using guessed type int dword_4CBB04;

//----- (004138C0) --------------------------------------------------------
void __cdecl ServerUninitialize()
{
  int v0; // eax
  _BOOL1 v1; // cc
  PLAYER **v2; // edi
  int v3; // ebx
  PLAYER *v4; // esi
  int v5; // ebx
  int *v6; // edi
  void *v7; // esi
  CHAR *v8; // esi
  WORLD *v9; // esi
  void *v10; // esi
  struct BILLING_SERVER_STRUCT *v11; // esi
  void *v12; // esi
  SOCKET **v13; // edi
  SOCKET *v14; // esi
  void *v15; // esi
  void *v16; // esi
  void *v17; // esi
  void *v18; // esi
  void *v19; // esi
  TEXT_FILE_STRUCT **v20; // ebx
  void *v21; // esi
  TEXT_FILE_STRUCT *v22; // esi
  LPVOID *v23; // esi
  int v24; // edi
  struct BMP_FILE_STRUCT *v25; // esi

  v0 = ZonePlayerCount;
  v1 = ZonePlayerCount <= 0;
  ZonePlayerCount = 0;
  if ( !v1 )
  {
    v2 = (PLAYER **)ZonePlayers;
    v3 = v0;
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        DisconnectPlayer(*v2);
        operator delete(v4);
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v5 = 0;
  if ( ArenaArrayLength > 0 )
  {
    v6 = ArenaArray;
    do
    {
      v7 = (void *)*v6;
      if ( *v6 )
      {
        ArenaShutdownArena(*v6);
        operator delete(v7);
      }
      ++v5;
      ++v6;
    }
    while ( v5 < ArenaArrayLength );
  }
  ArenaArrayLength = 0;
  if ( pFILE_points_log )
  {
    fclose(pFILE_points_log);
    pFILE_points_log = 0;
  }
  v8 = (CHAR *)ServerPacketAttachment;
  if ( ServerPacketAttachment )
  {
    CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)ServerPacketAttachment);
    operator delete(v8);
  }
  v9 = SeverListenerPortPlusOneSocket;
  if ( SeverListenerPortPlusOneSocket )
  {
    CloseSocketWrapper((SOCKET *)SeverListenerPortPlusOneSocket);
    operator delete(v9);
  }
  v10 = BillerSocket;
  if ( BillerSocket )
  {
    CloseSocketWrapper((SOCKET *)BillerSocket);
    operator delete(v10);
  }
  v11 = BillingConnectionStructPointer;
  if ( BillingConnectionStructPointer )
  {
    CleanUpBilling(BillingConnectionStructPointer);
    operator delete(v11);
  }
  v12 = dword_4D9DC4;
  if ( dword_4D9DC4 )
  {
    CleanUpPacketAttachment((struct PACKET_ATTACHMENT *)dword_4D9DC4);
    operator delete(v12);
  }
  v13 = (SOCKET **)&unk_432EB0;
  do
  {
    v14 = *v13;
    if ( *v13 )
    {
      CloseSocketWrapper(*v13);
      operator delete(v14);
    }
    ++v13;
  }
  while ( (int)v13 < (int)&dwMisc_DisableSharewareShips );
  v15 = (void *)ObscenePointer;
  if ( ObscenePointer )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)ObscenePointer);
    operator delete(v15);
  }
  v16 = (void *)PermitPointer;
  if ( PermitPointer )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)PermitPointer);
    operator delete(v16);
  }
  v17 = (void *)ModeratePointer;
  if ( ModeratePointer )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)ModeratePointer);
    operator delete(v17);
  }
  v18 = (void *)ReservedPointer;
  if ( ReservedPointer )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)ReservedPointer);
    operator delete(v18);
  }
  v19 = (void *)IDBlockPointer;
  if ( IDBlockPointer )
  {
    CleanTextFileMemory((TEXT_FILE_STRUCT *)IDBlockPointer);
    operator delete(v19);
  }
  if ( memory )
  {
    efree(memory);
    memory = 0;
  }
  v20 = (TEXT_FILE_STRUCT **)dword_4CCAC8;
  do
  {
    v21 = *(v20 - 1);
    if ( v21 )
    {
      CleanTextFileMemory(*(v20 - 1));
      operator delete(v21);
    }
    v22 = *v20;
    if ( *v20 )
    {
      CleanTextFileMemory(*v20);
      operator delete(v22);
    }
    v23 = (LPVOID *)(v20 - 1008);
    v24 = 3;
    do
    {
      if ( *v23 )
      {
        efree(*v23);
        *v23 = 0;
      }
      ++v23;
      --v24;
    }
    while ( v24 );
    v20 += 1009;
  }
  while ( (int)v20 < (int)&unk_4D6870 );
  v25 = BMPFile;
  if ( BMPFile )
  {
    sub_406B30((int)BMPFile);
    operator delete(v25);
  }
  efree((LPVOID)dword_438DFC);
  efree((LPVOID)big_global_buffer);
  CleanUpMemory();
  j_WSACleanup();
  if ( pFILE_subgame_log )
    fclose(pFILE_subgame_log);
  pFILE_subgame_log = 0;
}
// 41B220: using guessed type int j_WSACleanup(void);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4CA230: using guessed type int ZonePlayers[];
// 4CCAC8: using guessed type int dword_4CCAC8[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9DF8: using guessed type int pFILE_points_log;
// 4D9DFC: using guessed type int pFILE_subgame_log;

//----- (00413B50) --------------------------------------------------------
void __usercall sub_413B50(int a1@<ebp>, int a2@<edi>, unsigned int a3@<esi>, int a4, int a5)
{
  int v5; // eax
  struct PLAYER **v6; // esi
  int v7; // edx
  struct PLAYER **k; // eax
  int v9; // ecx
  int *j; // eax
  int v11; // esi
  int v12; // ecx
  int *i; // eax
  int v14; // ebp
  char v15; // al
  __int16 v16; // ax
  _DWORD *v17; // ebx
  PLAYER **v18; // esi
  int v19; // eax
  points_data *v20; // eax
  int v21; // ecx
  PLAYER *v22; // edi
  _BOOL1 v23; // cc
  int v24; // [esp+14h] [ebp-834h]
  int v25; // [esp+18h] [ebp-830h]
  char *v26; // [esp+1Ch] [ebp-82Ch]
  char v27[2048]; // [esp+48h] [ebp-800h] BYREF

  switch ( *(_BYTE *)a4 )
  {
    case 1:
      v12 = 0;
      if ( ZonePlayerCount > 0 )
      {
        for ( i = ZonePlayers; ; ++i )
        {
          v14 = *i;
          if ( *(_DWORD *)(*i + offsetof(PLAYER, connection_id)) == *(_DWORD *)(a4 + 2) )
            break;
          if ( ++v12 >= ZonePlayerCount )
            return;
        }
        v15 = *(_BYTE *)(a4 + 1);
        switch ( v15 )
        {
          case 0:
          case 6:
            v17 = (_DWORD *)(v14 + 547);
            qmemcpy((void *)(v14 + 375), (const void *)(a4 + 6), 0xACu);
            if ( a5 == 192 )
            {
              *v17 = *(_DWORD *)(a4 + 178);
              *(_DWORD *)(v14 + 551) = *(_DWORD *)(a4 + 182);
              *(_DWORD *)(v14 + 555) = *(_DWORD *)(a4 + 186);
              *(_WORD *)(v14 + 559) = *(_WORD *)(a4 + 190);
            }
            else
            {
              *v17 = 0;
              *(_DWORD *)(v14 + 551) = 0;
              *(_DWORD *)(v14 + 555) = 0;
              *(_WORD *)(v14 + 559) = 0;
            }
            if ( dwMisc_DisableSharewareScores && *(_DWORD *)(v14 + 72) )
            {
              *v17 = 0;
              *(_DWORD *)(v14 + 551) = 0;
              *(_DWORD *)(v14 + 555) = 0;
              *(_WORD *)(v14 + 559) = 0;
            }
            *(_DWORD *)(v14 + 561) = *v17;
            *(_DWORD *)(v14 + 565) = *(_DWORD *)(v14 + 551);
            *(_DWORD *)(v14 + 569) = *(_DWORD *)(v14 + 555);
            *(_WORD *)(v14 + 573) = *(_WORD *)(v14 + 559);
            v25 = 0;
            if ( ZonePlayerCount > 0 )
            {
              v24 = 0;
              v18 = (PLAYER **)ZonePlayers;
              v26 = (char *)&unk_4CA234;
              do
              {
                if ( *v18 != (PLAYER *)v14 && !_strcmpi((*v18)->player_name, (const char *)(v14 + 375)) )
                {
                  WriteSubGameLog(
                    "Player %s already on, kicking them off (lost connection probably)\n",
                    (const char *)(v14 + 375));
                  v19 = *(_DWORD *)(v14 + 28);
                  if ( v19 )
                  {
                    if ( !*(_DWORD *)(v19 + 109754) )
                    {
                      v20 = &(*v18)->score;
                      if ( (unsigned __int16)v20->wins
                         + (*v18)->score.points
                         + (*v18)->score.flag_points
                         + (unsigned __int16)(*v18)->score.losses > *(unsigned __int16 *)v17
                                                                  + *(unsigned __int16 *)(v14 + 549)
                                                                  + *(_DWORD *)(v14 + 557)
                                                                  + *(_DWORD *)(v14 + 553) )
                      {
                        *v17 = *(_DWORD *)&v20->wins;
                        *(_DWORD *)(v14 + 551) = *(_DWORD *)&v20->flags;
                        *(_DWORD *)(v14 + 555) = *(int *)((char *)&v20->points + 2);
                        *(_WORD *)(v14 + 559) = HIWORD(v20->flag_points);
                        v21 = (int)(*v18)->field_231;
                        *(_DWORD *)(v14 + 561) = *(_DWORD *)v21;
                        *(_DWORD *)(v14 + 565) = *(_DWORD *)(v21 + 4);
                        *(_DWORD *)(v14 + 569) = *(_DWORD *)(v21 + 8);
                        *(_WORD *)(v14 + 573) = *(_WORD *)(v21 + 12);
                      }
                    }
                  }
                  v22 = *v18;
                  if ( *v18 )
                  {
                    DisconnectPlayer(*v18);
                    operator delete(v22);
                  }
                  --ZonePlayerCount;
                  memcpy(v18, v26, 4 * (v24 + ZonePlayerCount));
                  --v25;
                  v24 -= 0x3FFFFFFF;
                  v26 -= 4;
                  --v18;
                }
                v24 += 0x3FFFFFFF;
                ++v18;
                v23 = ++v25 < ZonePlayerCount;
                v26 += 4;
              }
              while ( v23 );
            }
            if ( dwPermission_PermissionMode == 2 && !*(_DWORD *)(v14 + 639) && sub_407420(PermitPointer, v14 + 675) < 0 )
              goto LABEL_60;
            break;
          case 2:
            *(_DWORD *)(v14 + 789) = 18;
            *(_DWORD *)(v14 + 172) = ((int (*)(void))GetTickCount)() / 0xAu;
            break;
          case 3:
            WriteSubGameLog("Player kicked off for IP block: %s\n", (const char *)(v14 + 675));
            *(_DWORD *)(v14 + 789) = 11;
            *(_DWORD *)(v14 + 56) = 1;
            break;
          case 8:
            *(_DWORD *)(v14 + 547) = 0;
            *(_DWORD *)(v14 + 551) = 0;
            *(_DWORD *)(v14 + 555) = 0;
            *(_WORD *)(v14 + 559) = 0;
            *(_DWORD *)(v14 + 561) = *(_DWORD *)(v14 + 547);
            *(_DWORD *)(v14 + 565) = *(_DWORD *)(v14 + 551);
            v16 = *(_WORD *)(v14 + 559);
            *(_DWORD *)(v14 + 569) = *(_DWORD *)(v14 + 555);
            *(_WORD *)(v14 + 573) = v16;
            qmemcpy((void *)(v14 + 375), (const void *)(a4 + 6), 0xACu);
            strcpy((char *)(v14 + 375), (const char *)(v14 + 675));
            *(_DWORD *)(v14 + 16) = -1;
            if ( dwPermission_PermissionMode == 2 && !*(_DWORD *)(v14 + 639) )
LABEL_60:
              *(_DWORD *)(v14 + 747) = 1;
            break;
          default:
            break;
        }
        sub_419A51(*(_DWORD *)(v14 + 639) == 0);
      }
      break;
    case 2:
      WriteSubGameLog("Shutdown packet received, shutting down server...\n");
      bServerIsRunning = 1;
      break;
    case 3:
      if ( *(_BYTE *)(a4 + 5) == 1 )
      {
        if ( sub_407420(PermitPointer, a4 + 6) < 0 )
        {
          AddLineTextFile((struct TEXT_FILE_STRUCT *)PermitPointer, (char *)(a4 + 6));
          WriteTextFileToFile((struct TEXT_FILE_STRUCT *)PermitPointer);
        }
      }
      else if ( *(_BYTE *)(a4 + 5) == 2 )
      {
        if ( *(_BYTE *)(a4 + 7) == 58 )
          process_text_packet(a4, a1, a2, a3, 0, 7u, 0, (char *)(a4 + 7), *(char *)(a4 + 6));
        else
          process_text_packet(a4, a1, a2, a3, 0, 0, 0, (char *)(a4 + 7), *(char *)(a4 + 6));
      }
      break;
    case 4:
      bRecycleServer = 1;
      break;
    case 8:
      v9 = 0;
      if ( ZonePlayerCount > 0 )
      {
        for ( j = ZonePlayers; ; ++j )
        {
          v11 = *j;
          if ( *(_DWORD *)(*j + 16) == *(_DWORD *)(a4 + 1) )
            break;
          if ( ++v9 >= ZonePlayerCount )
            return;
        }
        WriteSubGameLog("Player kicked off by billing server, reason #%d\n", *(_DWORD *)(a4 + 5));
        *(_DWORD *)(v11 + 789) = 21;
        *(_DWORD *)(v11 + 56) = 1;
      }
      break;
    case 9:
      v7 = 0;
      if ( ZonePlayerCount > 0 )
      {
        for ( k = (struct PLAYER **)ZonePlayers; (*k)->connection_id != *(_DWORD *)(a4 + 1); ++k )
        {
          if ( ++v7 >= ZonePlayerCount )
            return;
        }
        SendMessage(*k, (const char *)(a4 + 5), 0);
      }
      break;
    case 0xA:
      v5 = 0;
      v6 = (struct PLAYER **)ZonePlayers;
      if ( ZonePlayerCount > 0 )
      {
        while ( (*v6)->connection_id != *(_DWORD *)(a4 + 1) )
        {
          ++v5;
          ++v6;
          if ( v5 >= ZonePlayerCount )
            return;
        }
        sprintf(v27, "%d:%s", *(char *)(a4 + 5), (const char *)(a4 + 6));
        SendChannelMessage(*v6, v27);
      }
      break;
    default:
      return;
  }
}
// 4DC214: invalid function type has been ignored
// 413FA1: conditional instruction was optimized away because of 'eax.4==0'
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4332F4: using guessed type int bRecycleServer;
// 438F98: using guessed type int bServerIsRunning;
// 439E0C: using guessed type int dwPermission_PermissionMode;
// 439E6C: using guessed type int dwPermission_MininumSecondsToLogin;
// 4AD728: using guessed type int dwPermission_PermissionMaxPoints;
// 4CA230: using guessed type int ZonePlayers[];
// 4D6C04: using guessed type int NewsTxtFileChecksum;
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (00414270) --------------------------------------------------------
void FormatMessageArena(ARENA *arena, const char *Format, ...)
{
  const struct tm *v2; // eax
  char *v3; // eax
  int v4; // edi
  char *v5; // esi
  int v6; // eax
  time_t v7; // [esp+Ch] [ebp-484h] BYREF
  char v8[128]; // [esp+10h] [ebp-480h] BYREF
  char v9[512]; // [esp+90h] [ebp-400h] BYREF
  char v10[512]; // [esp+290h] [ebp-200h] BYREF
  va_list va; // [esp+49Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  time(&v7);
  v2 = localtime(&v7);
  strcpy(v8, asctime(v2));
  v3 = strstr(v8, " 199");
  if ( v3 || (v3 = strstr(v8, " 200")) != 0 )
    *v3 = 0;
  vsprintf(v9, Format, va);
  sprintf(v10, "%s:  %s", v8, v9);
  v4 = 0;
  if ( arena->nPlayersHere > 0 )
  {
    v5 = arena->PlayerArray;
    do
    {
      v6 = *(_DWORD *)(*(_DWORD *)v5 + 809);
      if ( v6 )
        fprintf(v6, "%s", v10);
      ++v4;
      v5 += 4;
    }
    while ( v4 < arena->nPlayersHere );
  }
}
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 41F850: using guessed type _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD);

//----- (00414390) --------------------------------------------------------
void WriteSubGameLog(const char *Format, ...)
{
  int v1; // eax
  const struct tm *v2; // eax
  char *v3; // eax
  char *v4; // edx
  char *v5; // eax
  char v6; // cl
  time_t v7; // [esp+8h] [ebp-484h] BYREF
  char v8[128]; // [esp+Ch] [ebp-480h] BYREF
  char v9[512]; // [esp+8Ch] [ebp-400h] BYREF
  char v10[512]; // [esp+28Ch] [ebp-200h] BYREF
  va_list va; // [esp+494h] [ebp+8h] BYREF

  va_start(va, Format);
  v1 = pFILE_subgame_log;
  if ( pFILE_subgame_log )
    goto subgame_log_is_open;
  if ( dwMisc_ServerLog )
  {
    v1 = fopen("subgame.log", "at");
    pFILE_subgame_log = v1;
  }
  if ( v1 )
  {
subgame_log_is_open:
    if ( !dwMisc_ServerLog )
    {
      fclose(v1);
      pFILE_subgame_log = 0;
    }
  }
  time(&v7);
  v2 = localtime(&v7);
  strcpy(v8, asctime(v2));
  v3 = strstr(v8, " 199");
  if ( v3 || (v3 = strstr(v8, " 200")) != 0 )
    *v3 = 0;
  vsprintf(v10, Format, va);
  sprintf(v9, "%s:  %s", v8, v10);
  if ( pFILE_subgame_log )
    fprintf(pFILE_subgame_log, "%s", v9);
  printf("%s", v9);
  v4 = (char *)&dword_4D6C20[64 * dword_438F94];
  strcpy(v4, v9);
  v5 = v4;
  if ( *v4 >= 32 )
  {
    do
      v6 = *++v5;
    while ( v6 >= 32 );
  }
  *v5 = 0;
  dword_438F94 = (dword_438F94 + 1) % 48;
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 41F850: using guessed type _DWORD __cdecl vsprintf(_DWORD, _DWORD, _DWORD);
// 438F94: using guessed type int dword_438F94;
// 4D68BC: using guessed type int dwMisc_ServerLog;
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9DFC: using guessed type int pFILE_subgame_log;

//----- (00414540) --------------------------------------------------------
bool __cdecl IsOffensiveName(char *a1)
{
  char *v1; // esi
  char *v2; // edi
  _DWORD *v4; // ecx
  int v5; // edi
  int v6; // esi
  const char *v7; // eax
  bool result; // eax
  char v9[400]; // [esp+8h] [ebp-190h] BYREF

  v1 = a1;
  v2 = v9;
  if ( *a1 )
  {
    do
    {
      if ( isalpha(*v1) )
        *v2++ = toupper(*v1);
    }
    while ( *++v1 );
  }
  v4 = (_DWORD *)ObscenePointer;
  *v2 = 0;
  v5 = sub_407260(v4);
  v6 = 0;
  if ( v5 <= 0 )
    return 0;
  while ( 1 )
  {
    v7 = (const char *)sub_407270((_DWORD *)ObscenePointer, v6);
    result = (bool)strstr(v9, v7);
    if ( result )
      break;
    if ( ++v6 >= v5 )
      return result;
  }
  return 1;
}

//----- (004145E0) --------------------------------------------------------
signed int __cdecl IsBannedIPAddress(int SecurityArrayIndex, const char *a2)
{
  int v2; // ebp
  int v3; // ebx
  _DWORD *v4; // edx
  unsigned int v5; // kr04_4
  signed int v6; // esi
  int v7; // eax
  const char *v8; // edx
  unsigned int v9; // ecx
  _DWORD *v11; // edx
  unsigned int v12; // kr10_4
  signed int v13; // esi
  int v14; // ebp
  const char *v15; // edx
  unsigned int v16; // ecx
  int v17; // [esp+14h] [ebp-4h]
  int v18; // [esp+14h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+4h]

  v2 = 0;
  v3 = 1009 * SecurityArrayIndex;
  v4 = (_DWORD *)dword_4CCAC8[1009 * SecurityArrayIndex];
  if ( !v4 )
    goto LABEL_17;
  v19 = 1;
  v5 = strlen(a2) + 1;
  v6 = v5 - 1;
  if ( v5 == 1 )
  {
    v19 = 0;
  }
  else
  {
    v7 = sub_407260(v4);
    v17 = v7;
    if ( v7 )
    {
      if ( v7 > 0 )
      {
        while ( 1 )
        {
          v8 = (const char *)sub_407270((_DWORD *)dword_4CCAC4[v3], v2);
          if ( v6 >= (int)strlen(v8) )
            v9 = strlen(v8);
          else
            v9 = v6;
          if ( !memcmp(a2, v8, v9) )
            v19 = 0;
          if ( ++v2 >= v17 )
            break;
          v6 = v5 - 1;
        }
      }
    }
    else
    {
      v19 = 0;
    }
  }
  if ( v19 )
    return 1;
LABEL_17:
  v11 = (_DWORD *)dword_4CCAC4[v3];
  if ( !v11 )
    return 0;
  v12 = strlen(a2) + 1;
  v13 = v12 - 1;
  if ( v12 == 1 )
    return 0;
  v14 = 0;
  v18 = sub_407260(v11);
  if ( v18 <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = (const char *)sub_407270((_DWORD *)dword_4CCAC4[v3], v14);
    v16 = v13 >= (int)strlen(v15) ? strlen(v15) : v13;
    if ( !memcmp(a2, v15, v16) )
      break;
    if ( ++v14 >= v18 )
      return 0;
    v13 = v12 - 1;
  }
  return 1;
}
// 4CCAC4: using guessed type int dword_4CCAC4[];
// 4CCAC8: using guessed type int dword_4CCAC8[];

//----- (00414750) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl ProtocolViolation()
{
  return lpfnFixExport15();
}
// 4148B2: positive sp value 400 has been found
// 42EEC8: using guessed type int (*lpfnFixExport15)(void);

//----- (004148D0) --------------------------------------------------------
void __usercall process_text_packet(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, Player *p, DWORD msg_type, DWORD target_index, char *msg, DWORD arg5)
{
  void *v9; // esp
  char *v10; // ebx
  int v11; // edi
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // eax
  const char *v16; // ebx
  struct BILLING_SERVER_STRUCT *v17; // edx
  int v18; // eax
  int v19; // esi
  signed int v20; // ebx
  int v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // eax
  int v25; // ecx
  int v26; // esi
  int v27; // edi
  int v28; // esi
  int v29; // ecx
  int v30; // eax
  char v31; // al
  char *v32; // ebx
  char v33; // al
  char v34; // al
  char *v35; // ebx
  char v36; // al
  char v37; // al
  _BYTE *v38; // ebx
  char v39; // al
  struct TEXT_FILE_STRUCT *v40; // ebx
  const char *v41; // edx
  const char *v42; // edi
  int v43; // edi
  int i; // esi
  const char *v45; // eax
  int j; // esi
  const char *v47; // ebx
  _BOOL1 v48; // zf
  int v49; // esi
  char v50; // al
  const char *v51; // ebx
  char v52; // al
  int v53; // esi
  char v54; // al
  const char *v55; // ebx
  char v56; // al
  int v57; // eax
  int v58; // eax
  int v59; // ecx
  int v60; // eax
  __int16 v61; // ax
  char v62; // dl
  int v63; // eax
  const char *v64; // [esp+8h] [ebp-16628h]
  int v65; // [esp+10h] [ebp-16620h]
  int v66; // [esp+20h] [ebp-16610h] BYREF
  int v67; // [esp+24h] [ebp-1660Ch]
  int v68; // [esp+28h] [ebp-16608h]
  int v69[3]; // [esp+2Ch] [ebp-16604h] BYREF
  int v70; // [esp+38h] [ebp-165F8h] BYREF
  int v71; // [esp+40h] [ebp-165F0h] BYREF
  int v72[14]; // [esp+44h] [ebp-165ECh] BYREF
  char buf[3]; // [esp+7Ch] [ebp-165B4h] BYREF
  char v74[20]; // [esp+7Fh] [ebp-165B1h] BYREF
  char v75[20]; // [esp+93h] [ebp-1659Dh] BYREF
  int v76; // [esp+A7h] [ebp-16589h]
  int v77; // [esp+ABh] [ebp-16585h]
  __int16 v78; // [esp+AFh] [ebp-16581h]
  __int16 v79; // [esp+B1h] [ebp-1657Fh]
  __int16 v80; // [esp+B3h] [ebp-1657Dh]
  __int16 v81; // [esp+B5h] [ebp-1657Bh]
  __int16 v82; // [esp+B7h] [ebp-16579h]
  __int16 v83; // [esp+B9h] [ebp-16577h]
  char v84[256]; // [esp+BCh] [ebp-16574h] BYREF
  char msga[320]; // [esp+1BCh] [ebp-16474h] BYREF
  char v86[2]; // [esp+2FCh] [ebp-16334h] BYREF
  char v87[510]; // [esp+2FEh] [ebp-16332h] BYREF
  char v88[90408]; // [esp+4FCh] [ebp-16134h] BYREF
  unsigned int v89; // [esp+16624h] [ebp-Ch]
  int (*v90)(); // [esp+16628h] [ebp-8h]
  int v91; // [esp+1662Ch] [ebp-4h]
  void *retaddr; // [esp+16630h] [ebp+0h]

  v91 = -1;
  v90 = unknown_libname_14;
  v89 = __readfsdword(0);
  v9 = alloca(91632);
  v69[1] = a1;
  v10 = msg;
  v69[0] = a2;
  v68 = a4;
  v67 = a3;
  if ( p && *(_DWORD *)((char *)p + 639) && *msg == '8'
    || strlen(msg) > 0xFA
    || (v11 = target_index,
        nullsub_2(p, msg_type, target_index, msg, arg5),
        v66 = a4,
        v63 = (*(int (__stdcall **)(char *, Player *, DWORD, DWORD))&lpfnFixFunctionArray_lpfnFixExport0)(
                msg,
                p,
                msg_type,
                target_index),
        !v63) )
  {
return_something:
    JUMPOUT(0x4199E0);
  }
  if ( p )
  {
    v12 = 0;
    if ( (target_index & 0x80000000) == 0 && (int)target_index < 1024 )
      v12 = (int)*(&ZonePlayerList + target_index);
    v13 = dwBilling_LogMessages;
    if ( dwBilling_LogMessages <= *(_DWORD *)((char *)p + 543) )
      v13 = *(_DWORD *)((char *)p + 543);
    if ( v12 && *(_DWORD *)(v12 + 543) )
    {
      if ( v13 )
      {
LABEL_17:
        v14 = -1;
        switch ( v89 )
        {
          case 3u:
            v14 = -2;
            break;
          case 4u:
            v14 = -3;
            break;
          case 5u:
            if ( v12 )
              v14 = *(_DWORD *)(v12 + 539);
            break;
          case 9u:
            v14 = -4;
            break;
          default:
            break;
        }
        if ( v13 == 3
          || v13 == 2 && (v89 == 3 || v89 == 4 || v89 == 5 || v89 == 9 || *msg == 42)
          || v13 == 1 && (v89 == 5 || *msg == 42) )
        {
          v15 = *(_DWORD *)((char *)p + 539);
          if ( v15 >= 0 )
          {
            if ( BillingConnectionStructPointer )
              SendBillerUnknownPacket(BillingConnectionStructPointer, v15, v14, msg);
          }
        }
        goto LABEL_36;
      }
      v13 = *msg != 42;
    }
    if ( !v13 )
      goto LABEL_36;
    goto LABEL_17;
  }
LABEL_36:
  if ( *msg != 42 )
    JUMPOUT(0x417ADA);
  if ( p )
  {
    if ( !*(_DWORD *)((char *)p + 639) )
      JUMPOUT(0x4179AC);
    v10 = (char *)v91;
    if ( !*(_DWORD *)((char *)p + 635) )
      JUMPOUT(0x416DC5);
    v11 = (int)v90;
    if ( !*(_DWORD *)((char *)p + 631) )
      goto cmd_szone;
  }
  if ( !_memicmp(v10, "**", 2u) && p )
  {
    v16 = v10 + 2;
    v86[1] = (char)retaddr;
    v86[0] = 2;
    v17 = BillingConnectionStructPointer;
    strcpy(v87, v16);
    if ( v17 )
      SendBillerUserPrivateChatPacket(v17, *((_DWORD *)p + 4), dwBilling_GroupID, v86, strlen(v16) + 3);
    goto return_something;
  }
  if ( !_memicmp(v10, "*energy", 7u) && p )
  {
    if ( v89 == 5 )
    {
      v18 = (int)*(&ZonePlayerList + v11);
      if ( v18 )
      {
        v19 = *(_DWORD *)(v18 + 68);
        *(_DWORD *)(v18 + 68) = v19 == 0;
        if ( v19 )
          v64 = "Showing Energy OFF for %s";
        else
          v64 = "Showing Energy ON for %s";
        sprintf(v84, v64, v18 + 375);
        goto send_msg_to_player;
      }
    }
    else if ( *((_DWORD *)p + 7) )
    {
      *((_DWORD *)p + 17) = *((_DWORD *)p + 17) == 0;
      goto send_msg_to_player;
    }
cmd_szone:
    JUMPOUT(0x415FAF);
  }
  if ( !_memicmp(v10, "*stat", 5u) && p )
  {
    v20 = ((int (*)(void))GetTickCount)() / 0xAu - dword_4D9DE4;
    v68 = v20;
    if ( v20 <= 0 )
    {
      v20 = 1;
      v68 = 1;
    }
    v21 = *((_DWORD *)p + 7);
    v67 = 0;
    if ( *(int *)(v21 + 65292) > 0 )
    {
      v22 = 0;
      v23 = 64288;
      do
      {
        v24 = GetRelAckDiff(*(struct CONNECTION **)(*(_DWORD *)(v23 + v21) + 40), 0);
        v23 += 4;
        v25 = v24 + v67;
        v21 = *((_DWORD *)p + 7);
        v67 = v25;
        ++v22;
      }
      while ( v22 < *(_DWORD *)(v21 + 65292) );
      v67 = 10 * v67 / *(_DWORD *)(*((_DWORD *)p + 7) + 65292);
    }
    GetPacketStatistics((struct PACKET_ATTACHMENT *)ServerPacketAttachment, v72, &v66, &v71, &v70, v69);
    sprintf(
      msga,
      "Send:%d(%d)  Recv:%d(%d)  RelOut:%.1f  Multi:%.1f\n",
      100 * v72[0] / v20,
      100 * v66 / v20,
      100 * v71 / v20,
      100 * v70 / v20,
      (double)((long double)v67 * 0.1),
      (double)((long double)v69[0] * 100.0 / (long double)v68));
    SendMessage((struct PLAYER *)p, msga, 0);
    v26 = 0;
    if ( encryption )
      v26 = GetRelAckDiff(encryption, 0);
    sprintf(
      msga,
      "Iterations:%d  Players:%d  BillingRelOut:%d  Wave:%d\n",
      100 * dword_4332E8 / v20,
      ZonePlayerCount,
      v26,
      100 * dword_4D9CB8 / v20);
    SendMessage((struct PLAYER *)p, msga, 0);
    sprintf(
      msga,
      "Screen:%d  Radar:%d  Double:%d  Timer:%d\n",
      100 * dword_439E00 / v20,
      100 * dword_432ED8 / v20,
      100 * dword_438F08 / v20,
      v20 / 100);
    SendMessage((struct PLAYER *)p, msga, 0);
    v27 = 0;
    v28 = 0;
    if ( ArenaArrayLength > 0 )
    {
      v68 = (int)ArenaArray;
      do
      {
        v27 += GetArenaMemoryTotal(*(ARENA **)v68);
        ++v28;
        v68 += 4;
      }
      while ( v28 < ArenaArrayLength );
    }
    sprintf(msga, "MemoryUsage:%dk\n", v27);
    SendMessage((struct PLAYER *)p, msga, 0);
    v29 = 0;
    msga[0] = 0;
    v68 = 0;
    do
    {
      v30 = TotalSentForEachPacketType[v29];
      if ( v30 )
      {
        sprintf(buf, "%d:%d(%d)  ", v29, 100 * TotalSentSizeForEachPacketType[v29] / v20, 100 * v30 / v20);
        if ( strlen(msga) + strlen(buf) > 0x4B )
        {
          SendMessage((struct PLAYER *)p, msga, 0);
          msga[0] = 0;
        }
        strcat(msga, buf);
        v29 = v68;
      }
      v68 = ++v29;
    }
    while ( v29 < 256 );
    if ( !msga[0] )
      goto cmd_szone;
    goto LABEL_173;
  }
  if ( !_memicmp(v10, "*addword", 8u) )
  {
    v31 = v10[8];
    v32 = v10 + 8;
    v91 = (int)v32;
    if ( v31 == 32 )
    {
      do
        v33 = *++v32;
      while ( v33 == 32 );
      v91 = (int)v32;
    }
    if ( *v32 )
    {
      AddLineTextFile((struct TEXT_FILE_STRUCT *)ObscenePointer, v32);
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)ObscenePointer);
      if ( p )
      {
        sprintf(v84, "Obscene Word Added: %s", v32);
        goto send_msg_to_player;
      }
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*addmachine", 0xBu) )
  {
    v34 = v10[11];
    v35 = v10 + 11;
    v91 = (int)v35;
    if ( v34 == 32 )
    {
      do
        v36 = *++v35;
      while ( v36 == 32 );
      v91 = (int)v35;
    }
    if ( *v35 )
    {
      AddLineTextFile((struct TEXT_FILE_STRUCT *)IDBlockPointer, v35);
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)IDBlockPointer);
      if ( p )
      {
        sprintf(v84, "MachineId Block Added: %s", v35);
        goto send_msg_to_player;
      }
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*removemachine", 0xEu) )
  {
    v37 = v10[14];
    v38 = v10 + 14;
    v91 = (int)v38;
    if ( v37 == 32 )
    {
      do
        v39 = *++v38;
      while ( v39 == 32 );
      v91 = (int)v38;
    }
    if ( !*v38 )
      goto cmd_szone;
    v40 = 0;
    v68 = sub_407260((_DWORD *)IDBlockPointer);
    if ( v68 > 0 )
    {
      do
      {
        v41 = (const char *)sub_407270((_DWORD *)IDBlockPointer, (int)v40);
        v42 = (const char *)v91;
        if ( strlen((const char *)v91) >= strlen(v41) )
          v42 = v41;
        if ( !memcmp((const void *)v91, v41, strlen(v42)) )
        {
          ListMachineSomething(v40, v65);
          --v68;
        }
        else
        {
          v40 = (struct TEXT_FILE_STRUCT *)((char *)v40 + 1);
        }
      }
      while ( (int)v40 < v68 );
    }
    WriteTextFileToFile((struct TEXT_FILE_STRUCT *)IDBlockPointer);
    if ( !p )
      goto cmd_szone;
send_msg_to_player:
    JUMPOUT(0x415FA8);
  }
  if ( !_memicmp(v10, "*listmachine", 0xCu) && p )
  {
    v43 = sub_407260((_DWORD *)IDBlockPointer);
    for ( i = 0; i < v43; ++i )
    {
      v45 = (const char *)sub_407270((_DWORD *)IDBlockPointer, i);
      SendMessage((struct PLAYER *)p, v45, 0);
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*log", 4u) && p )
  {
    for ( j = 0; j < 48; ++j )
    {
      if ( LOBYTE(dword_4D6C20[64 * ((j + dword_438F94) % 48)]) )
        SendMessage((struct PLAYER *)p, (const char *)&dword_4D6C20[64 * ((j + dword_438F94) % 48)], 0);
    }
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*shutdown", 9u) )
  {
    if ( p )
      SendMessage((struct PLAYER *)p, "Shutting down server...", 0);
    printf("Shutting down server...\n");
    v47 = v10 + 9;
    bRecycleServer = 1;
    bServerIsRunning = 1;
    ShutdownSpawnCmdLine[0] = 0;
    v48 = *v47 == 32;
    v91 = (int)v47;
    if ( v48 )
      v91 = (int)++v47;
    if ( *v47 )
      strcpy(ShutdownSpawnCmdLine, v47);
    goto cmd_szone;
  }
  if ( !_memicmp(v10, "*lowbandwidth", 0xDu) )
  {
    if ( v89 != 5 )
      goto cmd_szone;
    v49 = (int)*(&ZonePlayerList + v11);
    if ( !v49 )
      goto cmd_szone;
    v50 = v10[13];
    v51 = v10 + 13;
    v91 = (int)v51;
    if ( v50 == 32 )
    {
      do
        v52 = *++v51;
      while ( v52 == 32 );
      v91 = (int)v51;
    }
    if ( *v51 )
      *(_DWORD *)(v49 + 52) = atoi(v51);
    else
      *(_DWORD *)(v49 + 52) = 1;
    sprintf(v88, "Player Marked As Low Bandwidth: %d", *(_DWORD *)(v49 + 52));
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*messagelogging", 0xFu) )
  {
    if ( v89 != 5 )
      goto cmd_szone;
    v53 = (int)*(&ZonePlayerList + v11);
    if ( !v53 )
      goto cmd_szone;
    v54 = v10[15];
    v55 = v10 + 15;
    v91 = (int)v55;
    if ( v54 == 32 )
    {
      do
        v56 = *++v55;
      while ( v56 == 32 );
      v91 = (int)v55;
    }
    v57 = atoi(v55);
    *(_DWORD *)(v53 + 543) = v57;
    sprintf(v88, (const char *)&lpfnFixExport8, v57);
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*thor ", 6u) && p )
  {
    v58 = atoi(v10 + 6);
    if ( v89 != 5 )
    {
      if ( *((_DWORD *)p + 7) )
      {
        *(_DWORD *)((char *)p + 643) = v58;
        sprintf(v84, "Thor Adjust %d", v58);
        goto send_msg_to_player;
      }
      goto cmd_szone;
    }
    v59 = (int)*(&ZonePlayerList + v11);
    if ( !v59 )
      goto cmd_szone;
    *(_DWORD *)(v59 + 643) = v58;
    sprintf(v84, "Thor Adjust %d for %s", v58, (const char *)(v59 + 375));
LABEL_173:
    JUMPOUT(0x415FA7);
  }
  v60 = _memicmp(v10, "*mirror", 7u);
  if ( !v60 && p )
  {
    LOBYTE(v60) = *(_DWORD *)((char *)p + 651) == 0;
    *(_DWORD *)((char *)p + 651) = v60;
    if ( v60 )
    {
      v61 = *(_WORD *)((char *)p + 279);
      buf[0] = 3;
      v78 = 1014;
      v82 = -1;
      buf[2] = 0;
      v79 = v61;
      buf[1] = 2;
      v80 = 0;
      v81 = 0;
      v76 = 0;
      v83 = 0;
      v77 = 0;
      strncpy(v74, "(Mirror)", 0x14u);
      v74[19] = 0;
      strncpy(v75, "Sysop", 0x14u);
      v75[19] = 0;
      PlayerSendPacket((PLAYER *)p, buf, 64, 1);
    }
    else
    {
      LOBYTE(v66) = 4;
      *(_WORD *)((char *)&v66 + 1) = 1014;
      PlayerSendPacket((PLAYER *)p, &v66, 3, 1);
    }
    goto send_msg_to_player;
  }
  if ( !_memicmp(v10, "*ufo", 4u) && p )
  {
    if ( v89 == 5 )
    {
      if ( !*(&ZonePlayerList + v11) )
        goto return_something;
      *((_DWORD *)p + 19) = v11;
    }
    else
    {
      *((_DWORD *)p + 19) = -1;
    }
    *((_DWORD *)p + 15) = *((_DWORD *)p + 15) == 0;
    v62 = *((_BYTE *)p + 60);
    LOBYTE(v66) = 37;
    BYTE1(v66) = v62;
    PlayerSendPacket((PLAYER *)p, &v66, 2, 1);
    goto cmd_szone;
  }
  CommandHandler_2(v10, (PLAYER *)p, v11, 5u, (int)p, msg_type, target_index, (int)msg, arg5);
}
// 414B0B: control flows out of bounds to 4199E0
// 414B94: control flows out of bounds to 415FA8
// 414F4A: control flows out of bounds to 415FA7
// 41517A: control flows out of bounds to 415FAF
// 414A36: control flows out of bounds to 417ADA
// 414A48: control flows out of bounds to 4179AC
// 414A61: control flows out of bounds to 416DC5
// 4DC214: invalid function type has been ignored
// 42EE8C: invalid function type has been ignored
// 414A57: conditional instruction was optimized away because of 'ebp.4!=0'
// 414A70: conditional instruction was optimized away because of 'ebp.4!=0'
// 414C33: conditional instruction was optimized away because of 'ecx.4>=1'
// 4150FF: variable 'v65' is possibly undefined
// 419A50: using guessed type int __cdecl nullsub_2(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 42948E: using guessed type int unknown_libname_14();
// 42EEAC: using guessed type int (__stdcall *lpfnFixExport8)(int, int, int, int);
// 432ED8: using guessed type int dword_432ED8;
// 4332E8: using guessed type int dword_4332E8;
// 4332F4: using guessed type int bRecycleServer;
// 438F08: using guessed type int dword_438F08;
// 438F94: using guessed type int dword_438F94;
// 438F98: using guessed type int bServerIsRunning;
// 439E00: using guessed type int dword_439E00;
// 4CBB00: using guessed type int dwBilling_LogMessages;
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C20: using guessed type int dword_4D6C20[];
// 4D9CB8: using guessed type int dword_4D9CB8;
// 4D9DCC: using guessed type int ZonePlayerCount;
// 4D9DE4: using guessed type int dword_4D9DE4;

//----- (00415740) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __thiscall init_new_player(PLAYER *this)
{
  PLAYER *v1; // eax
  struct in_addr v2; // [esp-Ch] [ebp-Ch]
  __int16 v3; // [esp-8h] [ebp-8h]
  NetData *v4; // [esp-4h] [ebp-4h]

  v1 = CreateNewPlayer(this, v2, v3, v4);
  ((void (__thiscall *)(PLAYER *))lpfnFixExport5)(v1);
  JUMPOUT(0x412EBD);
}
// 415745: positive sp value C has been found
// 41574D: control flows out of bounds to 412EBD
// 415740: variable 'v2' is possibly undefined
// 415740: variable 'v3' is possibly undefined
// 415740: variable 'v4' is possibly undefined
// 42EEA0: using guessed type int (*lpfnFixExport5)();

//----- (00415770) --------------------------------------------------------
// this function loads fix.dll, and it is inside a nop'd out command handler.
// 22 function addrs in the array.
char *__cdecl fix_dll_loader(const char *a1, const char *a2)
{
  HMODULE v2; // eax
  unsigned int v3; // edi
  FARPROC v4; // eax

  v2 = LoadLibraryA(&lpfnFixFunctionArray_lpfnFixExport0);
  v3 = 0;
  v4 = GetProcAddress(v2, lpfnFixExport2);
  if ( !v4 )
    JUMPOUT(0x64);
  do
  {
    *((_DWORD *)&lpfnFixFunctionArray_lpfnFixExport0 + v3) = *((_DWORD *)v4 + v3);
    ++v3;
  }
  while ( v3 < 0x16 );
  return strstr(a1, a2);
}
// 415792: control flows out of bounds to 64

//----- (004157E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge create_arena(ARENA *a1@<ecx>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  char *v10; // [esp-4h] [ebp-4h]

  Create(a1, v10);
  ((void (__thiscall *)(int))lpfnFixExport3[0])(a10);
  JUMPOUT(0x40E9B6);
}
// 4157E5: positive sp value 4 has been found
// 4157EF: control flows out of bounds to 40E9B6
// 4157E0: variable 'v10' is possibly undefined
// 42EE98: using guessed type int (*lpfnFixExport3[3])();

//----- (00415800) --------------------------------------------------------
int __cdecl sub_415800(int a1, int a2)
{
  return lpfnFixExport1(a1, a2);
}
// 42EE90: using guessed type int (__stdcall *lpfnFixExport1)(_DWORD, _DWORD);

//----- (00415820) --------------------------------------------------------
int __cdecl sub_415820()
{
  return ((int (*)(void))lpfnFixExport2)();
}
// 42EE94: invalid function type has been ignored

//----- (00415850) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge sub_415850(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4, int a5, int a6, int a7)
{
  int v7; // [esp-20h] [ebp-20h]
  int v8; // [esp-1Ch] [ebp-1Ch]
  int v9; // [esp-18h] [ebp-18h]
  int v10; // [esp-14h] [ebp-14h]
  int v11; // [esp-10h] [ebp-10h]
  int v12; // [esp-Ch] [ebp-Ch]
  int v13; // [esp-8h] [ebp-8h]
  int v14; // [esp-4h] [ebp-4h]

  encrypt_init(a1, v7, v8, v9, v10, v11, v12, v13, v14);
  if ( *(_DWORD *)(a3 + 66) >= 0x10u )
    qmemcpy((void *)(a3 + 70), (const void *)(a2 + 8), 0x5Cu);
  JUMPOUT(0x41BA88);
}
// 415855: positive sp value 20 has been found
// 41586A: control flows out of bounds to 41BA88
// 415850: variable 'v7' is possibly undefined
// 415850: variable 'v8' is possibly undefined
// 415850: variable 'v9' is possibly undefined
// 415850: variable 'v10' is possibly undefined
// 415850: variable 'v11' is possibly undefined
// 415850: variable 'v12' is possibly undefined
// 415850: variable 'v13' is possibly undefined
// 415850: variable 'v14' is possibly undefined

//----- (00415870) --------------------------------------------------------
void __userpurge sub_415870(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // [esp+0h] [ebp-Ch]
  int v6; // [esp+4h] [ebp-8h]
  int v7; // [esp+8h] [ebp-4h]

  if ( !lpfnFixExport9(v5, v6, v7) )
  {
    --*(_DWORD *)(a1 + 2670);
    JUMPOUT(0x41BC2D);
  }
  JUMPOUT(0x41BC25);
}
// 415884: control flows out of bounds to 41BC25
// 41588F: control flows out of bounds to 41BC2D
// 415877: variable 'v5' is possibly undefined
// 415877: variable 'v6' is possibly undefined
// 415877: variable 'v7' is possibly undefined
// 42EEB0: using guessed type int (__stdcall *lpfnFixExport9)(_DWORD, _DWORD, _DWORD);

//----- (004158A0) --------------------------------------------------------
void __userpurge sub_4158A0(int a1@<ebx>, int a2@<esi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, char a11)
{
  STACK[0x42C] = lpfnFixExport8(a1, a2, STACK[0x42C], (int)&a11);
  JUMPOUT(0x41C632);
}
// 4158BC: control flows out of bounds to 41C632
// 42EEAC: using guessed type int (__stdcall *lpfnFixExport8)(int, int, int, int);

//----- (00415920) --------------------------------------------------------
void __userpurge sub_415920(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  if ( *(int *)(a1 + 62) > 0 )
    JUMPOUT(0x41BBAD);
  JUMPOUT(0x41BC22);
}
// 415931: control flows out of bounds to 41BBAD
// 415924: control flows out of bounds to 41BC22

//----- (00415A26) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall CommandHandler_2(char *a1@<ebx>, PLAYER *a2@<ebp>, int a3@<edi>, unsigned int a4@<esi>, int a5, int a6, int a7, int a8, char a9)
{
  _WORD *v9; // ecx
  int v10; // eax
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  bool v15; // ecx
  int v16; // eax
  int v17; // edx
  bool v18; // ecx
  char v19; // cl
  char *v20; // eax
  char *i; // edx
  char v22; // cl
  char v23; // cl
  char *v24; // eax
  _BYTE *j; // edx
  char v26; // cl
  char v27; // cl
  _BYTE *v28; // eax
  char *k; // edx
  char *v30; // eax
  char v31; // al
  char *v32; // esi
  char *l; // ecx
  char v34; // al
  char v35; // al
  _BYTE *v36; // esi
  _BYTE *m; // ecx
  char v38; // al
  _BYTE *v39; // esi
  char *n; // ecx
  char *v41; // ebx
  struct CONNECTION **v42; // edx
  char v43; // al
  char *v44; // ebx
  char v45; // al
  ARENA *v46; // eax
  unsigned int v47; // kr14_4
  int v48; // edi
  PLAYER **v49; // ebx
  int v50; // ecx
  int v51; // esi
  const char *v52; // eax
  int v53; // eax
  int v54; // ecx
  int v55; // eax
  struct CONNECTION *v56; // ecx
  int v57; // edi
  int v58; // edx
  int v59; // edi
  long double v60; // fst7
  int v61; // eax
  int v62; // ecx
  int v63; // eax
  long double v64; // fst7
  int v65; // ecx
  int v66; // edx
  int v67; // edi
  time_t v68; // eax
  int v69; // edi
  int v70; // ecx
  int v71; // ecx
  const char *v72; // eax
  int v73; // ecx
  int v74; // eax
  int v75; // edx
  char v76; // al
  const char *v77; // edi
  char v78; // al
  char v79; // al
  _BOOL1 v80; // zf
  __int16 v81; // ax
  int v82; // edi
  int v83; // eax
  int v84; // ecx
  int v85; // edx
  int v86; // eax
  int v87; // eax
  int v88; // ecx
  int v89; // edx
  int v90; // eax
  int v91; // eax
  const char *v92; // eax
  char v93; // al
  char *v94; // edi
  char v95; // al
  ARENA *v96; // eax
  unsigned int v97; // kr2C_4
  char v98; // al
  char *v99; // edi
  char v100; // al
  char v101; // al
  const char *v102; // edi
  char v103; // al
  struct TEXT_FILE_STRUCT *v104; // eax
  __int16 v105; // ax
  PLAYER *v106; // esi
  int v107; // edx
  char v108; // al
  const char *v109; // edi
  char v110; // al
  int v111; // esi
  int v112; // edx
  PLAYER *v113; // esi
  int v114; // edi
  int v115; // eax
  int v116; // esi
  int v117; // eax
  struct ARENA *v118; // ecx
  int v119; // edi
  struct ARENA **v120; // esi
  PLAYER *v121; // ecx
  int v122; // edi
  PLAYER **v123; // esi
  PLAYER *v124; // ecx
  int v125; // ecx
  int v126; // eax
  const char *v127; // edi
  int v128; // ebx
  int v129; // eax
  int v130; // eax
  ARENA *v131; // eax
  int v132; // esi
  unsigned int v133; // edi
  const char *v134; // esi
  int v135; // edx
  int v136; // [esp-16604h] [ebp-1661Ch]
  int v137; // [esp-16600h] [ebp-16618h]
  const char *v138; // [esp-165FCh] [ebp-16614h]
  bool v139; // [esp-165F8h] [ebp-16610h]
  time_t v140; // [esp-165F8h] [ebp-16610h]
  int v141; // [esp-165F4h] [ebp-1660Ch]
  int v142; // [esp-165E4h] [ebp-165FCh] BYREF
  float v143; // [esp-165E0h] [ebp-165F8h] BYREF
  int v144; // [esp-165DCh] [ebp-165F4h] BYREF
  int v145; // [esp-165D8h] [ebp-165F0h] BYREF
  _BYTE v146[5]; // [esp-165D4h] [ebp-165ECh] BYREF
  int v147; // [esp-165CCh] [ebp-165E4h] BYREF
  int v148; // [esp-165C8h] [ebp-165E0h]
  int v149; // [esp-165C4h] [ebp-165DCh] BYREF
  int v150; // [esp-165C0h] [ebp-165D8h] BYREF
  _DWORD v151[12]; // [esp-165BCh] [ebp-165D4h] BYREF
  int v152; // [esp-1658Ch] [ebp-165A4h] BYREF
  char v153[64]; // [esp-16588h] [ebp-165A0h] BYREF
  CHAR v154[256]; // [esp-16548h] [ebp-16560h] BYREF
  char v155; // [esp-16448h] [ebp-16460h] BYREF
  __int16 v156; // [esp-16447h] [ebp-1645Fh]
  _BYTE v157[96]; // [esp-16445h] [ebp-1645Dh] BYREF
  char v158[64]; // [esp-16348h] [ebp-16360h] BYREF
  char v159; // [esp-16308h] [ebp-16320h] BYREF
  char v160; // [esp-16307h] [ebp-1631Fh] BYREF
  char v161; // [esp-16306h] [ebp-1631Eh] BYREF
  __int16 v162; // [esp-16305h] [ebp-1631Dh]
  char v163[251]; // [esp-16303h] [ebp-1631Bh] BYREF
  char v164; // [esp-16208h] [ebp-16220h]
  char v165[15]; // [esp-16207h] [ebp-1621Fh] BYREF
  char v166; // [esp-161F8h] [ebp-16210h]
  struct _STARTUPINFOA v167[11]; // [esp-16108h] [ebp-16120h] BYREF
  _DWORD v168[22402]; // [esp-15E08h] [ebp-15E20h] BYREF

  if ( _memicmp(a1, "*super", 6u) || !a2 )
  {
    if ( _memicmp(a1, "*sysop", 6u) )
    {
      if ( _memicmp(a1, "*smoderator", 0xBu) )
      {
        if ( _memicmp(a1, "*s*", 3u) && _memicmp(a1, "*g*", 3u) )
        {
          if ( !_memicmp(a1, "*set ", a4) )
          {
            v19 = a1[5];
            v20 = a1 + 5;
            for ( i = v158; v19; ++v20 )
            {
              if ( v19 == 58 )
                break;
              *i = v19;
              v19 = v20[1];
              ++i;
            }
            v22 = *v20;
            *i = 0;
            if ( !v22 )
              return;
            v23 = v20[1];
            v24 = v20 + 1;
            for ( j = v151; v23; ++v24 )
            {
              if ( v23 == 58 )
                break;
              *j = v23;
              v23 = v24[1];
              ++j;
            }
            v26 = *v24;
            *j = 0;
            if ( !v26 )
              return;
            v27 = v24[1];
            v28 = v24 + 1;
            for ( k = &v155; v27; ++v28 )
            {
              *k = v27;
              v27 = v28[1];
              ++k;
            }
            *k = 0;
            GetModuleFileNameA(0, (LPSTR)v167, 0x100u);
            v30 = strrchr((const char *)v167, 92);
            if ( v30 )
              *v30 = 0;
            else
              LOBYTE(v167[0].cb) = 0;
            sprintf(v154, "%s\\server.cfg", (const char *)v167);
            if ( _strcmpi(v158, "All") )
            {
              WritePrivateProfileStringA(v158, (LPCSTR)v151, &v155, v154);
            }
            else
            {
              WritePrivateProfileStringA("Warbird", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Javelin", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Spider", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Leviathan", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Weasel", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Terrier", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Lancaster", (LPCSTR)v151, &v155, v154);
              WritePrivateProfileStringA("Shark", (LPCSTR)v151, &v155, v154);
            }
            if ( a2 )
              SendMessage(a2, "Change complete", 0);
          }
        }
        else
        {
          v31 = a1[3];
          v32 = a1 + 3;
          for ( l = v158; v31; ++v32 )
          {
            if ( v31 == 58 )
              break;
            *l = v31;
            v31 = v32[1];
            ++l;
          }
          v34 = *v32;
          *l = 0;
          if ( !v34 )
            return;
          v35 = v32[1];
          v36 = v32 + 1;
          for ( m = v151; v35; ++v36 )
          {
            if ( v35 == 58 )
              break;
            *m = v35;
            v35 = v36[1];
            ++m;
          }
          *m = 0;
          if ( !_memicmp(a1, "*s*", 3u) )
          {
            if ( !*v36 )
              return;
            v38 = v36[1];
            v39 = v36 + 1;
            for ( n = v153; v38; ++v39 )
            {
              *n = v38;
              v38 = v39[1];
              ++n;
            }
            *n = 0;
            WritePrivateProfileStringA(v158, (LPCSTR)v151, v153, &aServerIni);
            dword_4D6C10 = 1;
          }
          if ( a2 )
          {
            GetPrivateProfileStringA(v158, (LPCSTR)v151, "InvalidTag", (LPSTR)v167, 0x40u, &aServerIni);
            sprintf(&v155, "%s:%s:%s", v158, (const char *)v151, (const char *)v167);
            SendMessage(a2, &v155, 0);
          }
        }
      }
      else if ( a6 == a4 )
      {
        v16 = (int)*(&ZonePlayerList + a3);
        if ( v16 )
        {
          v17 = *(_DWORD *)(v16 + 635);
          v18 = v17 == 0;
          *(_DWORD *)(v16 + 635) = v18;
          *(_DWORD *)(v16 + 639) = v18;
          if ( v17 )
            SendMessage(a2, "Player Super Moderator Mode OFF", 0);
          else
            SendMessage(a2, "Player Super Moderator Mode ON", 0);
        }
      }
    }
    else if ( a6 == a4 )
    {
      v13 = (int)*(&ZonePlayerList + a3);
      if ( v13 )
      {
        v14 = *(_DWORD *)(v13 + 631);
        v15 = v14 == 0;
        *(_DWORD *)(v13 + 631) = v15;
        *(_DWORD *)(v13 + 635) = v15;
        *(_DWORD *)(v13 + 639) = v15;
        if ( v14 )
          SendMessage(a2, "Player Sysop Mode OFF", 0);
        else
          SendMessage(a2, "Player Sysop Mode ON", 0);
      }
    }
  }
  else
  {
    qmemcpy(v168, (const void *)(a2->lpCurrentArena + 108194), 0x594u);
    v9 = (_WORD *)&v168[4] + 1;
    v144 = 8;
    do
    {
      *(v9 - 1) = 0;
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
      v9[3] = 0;
      v9[29] = 0;
      v9[4] = 0;
      v9[33] = 10;
      v9[34] = 10;
      v9[35] = 10;
      v9[36] = 10;
      v9[9] = 0;
      v9[10] = 0;
      v9[12] = 0;
      v10 = (__int16)v9[14];
      v9 += 72;
      *(v9 - 58) = 5 * v10 / 2;
      *(v9 - 57) *= 3;
      *(v9 - 56) *= 16;
      *(v9 - 54) = *(v9 - 59);
      *(v9 - 53) = *(v9 - 58);
      *(v9 - 52) = *(v9 - 57);
      *(v9 - 50) = *(v9 - 55);
      *(v9 - 51) = *(v9 - 56);
      *(v9 - 61) = 0;
      *((_BYTE *)v9 - 50) = 0x80;
      *((_BYTE *)v9 - 49) = 117;
      *((_BYTE *)v9 - 48) = 0x80;
      *((_BYTE *)v9 - 47) = 0x80;
      *((_BYTE *)v9 - 46) = 0x80;
      *((_BYTE *)v9 - 45) = 0x80;
      *((_BYTE *)v9 - 44) = 0x80;
      *((_BYTE *)v9 - 43) = 0x80;
      *(v9 - 44) = 0;
      v11 = *(_DWORD *)(v9 - 17) & 0xFFFFFE1F;
      BYTE1(v11) |= 2u;
      *(_DWORD *)(v9 - 17) = v11;
      v12 = v144;
      *(v9 - 33) = 100;
      *(v9 - 32) = 999;
      *(v9 - 31) = 0;
      v144 = v12 - 1;
    }
    while ( v12 != 1 );
    v168[289] = 0;
    v168[300] = 0;
    v168[299] = 0;
    v168[290] = 0;
    HIWORD(v168[316]) = 0;
    BYTE1(v168[343]) = 0x80;
    HIBYTE(v168[343]) = 0x80;
    PlayerSendPacket(a2, v168, 1428, 1);
  }
  if ( !_memicmp((const void *)a8, "*szone", 6u) && a2 )
  {
    v41 = (char *)(a8 + 6);
    if ( *(_BYTE *)(a8 + 6) == 32 )
      v41 = (char *)(a8 + 7);
    if ( *v41 == 95 )
      *v41 = 32;
    if ( a2->bIsSysop || *v41 != 42 || !_memicmp(v41, "*permit", 7u) || !_memicmp(v41, "*revoke", 7u) )
    {
      v160 = a9;
      v159 = 2;
      v42 = (struct CONNECTION **)BillingConnectionStructPointer;
      strcpy(&v161, v41);
      if ( v42 )
        SendBillerZoneRevokePermitPacket(v42, a2->connection_id, dwBilling_ScoreID, (int)&v159, strlen(v41) + 3);
    }
    return;
  }
  if ( _memicmp((const void *)a8, "*zone", 5u) )
  {
    if ( _memicmp((const void *)a8, "*where", 6u) || !a2 )
    {
      if ( _memicmp((const void *)a8, "*info", 5u) || !a2 )
      {
        if ( _memicmp((const void *)a8, "*getlist", 8u) || !a2 )
        {
          if ( _memicmp((const void *)a8, "*putlist", 8u) || !a2 )
          {
            if ( _memicmp((const void *)a8, "*getmodlist", 0xBu) || !a2 )
            {
              if ( _memicmp((const void *)a8, "*putmodlist", 0xBu) || !a2 )
              {
                if ( _memicmp((const void *)a8, "*recycle", 8u) )
                {
                  if ( _memicmp((const void *)a8, "*moderator", 0xAu) )
                  {
                    if ( _memicmp((const void *)a8, "*restart", 8u) || !a2 )
                    {
                      if ( _memicmp((const void *)a8, "*prize", 6u) )
                      {
                        if ( !_memicmp((const void *)a8, "*trace", 6u) && a2 )
                        {
                          if ( a2->hProcess && GetExitCodeProcess((HANDLE)a2->hProcess, (LPDWORD)v146) )
                          {
                            if ( *(_DWORD *)v146 == 259 )
                              TerminateProcess((HANDLE)a2->hProcess, 0);
                            CloseHandle((HANDLE)a2->hProcess);
                            a2->hProcess = 0;
                            *(_DWORD *)a2->field_4 = 0;
                            *(_DWORD *)&a2->field_4[4] = 0;
                            *(_DWORD *)&a2->field_4[8] = 0;
                          }
                          if ( a6 == 5 )
                          {
                            v91 = (int)*(&ZonePlayerList + a7);
                            if ( v91 )
                            {
                              v92 = get_text_ip(*(struct in_addr *)(v91 + 755));
                              sprintf(v154, "SUBGAME2 /SPAWN tracert %s > spawn.log", v92);
                              memset(v167, 0, 0x44u);
                              v167[0].cb = 68;
                              v167[0].lpTitle = "Spawned TRACERT";
                              CreateProcessA(0, v154, 0, 0, 0, 0x20u, 0, 0, v167, (LPPROCESS_INFORMATION)a2);
                              SendMessage(a2, "SPAWN STARTED", 0);
                            }
                          }
                        }
                      }
                      else
                      {
                        v76 = *(_BYTE *)(a8 + 6);
                        v77 = (const char *)(a8 + 6);
                        a8 += 6;
                        if ( v76 == 32 )
                        {
                          do
                            v78 = *++v77;
                          while ( v78 == 32 );
                          a8 = (int)v77;
                        }
                        v79 = *v77;
                        v80 = *v77 == 35;
                        v146[0] = 32;
                        *(_WORD *)&v146[3] = 0;
                        *(_WORD *)&v146[1] = 1;
                        if ( v80 )
                        {
                          *(_WORD *)&v146[3] = atoi(v77 + 1);
                        }
                        else if ( isdigit(v79) )
                        {
                          *(_WORD *)&v146[1] = atoi(v77);
                        }
                        if ( !a2->bIsSysop )
                        {
                          v81 = *(_WORD *)&v146[1];
                          *(_WORD *)&v146[1] = 100;
                          if ( v81 <= 100 )
                            *(_WORD *)&v146[1] = v81;
                        }
                        if ( a2 )
                          SendMessage(a2, "Granting prize(s)", 0);
                        if ( a6 == 5 )
                        {
                          v82 = (int)*(&ZonePlayerList + a7);
                          if ( v82 )
                          {
                            PlayerSendPacket((PLAYER *)v82, v146, 5, 1);
                            *(_DWORD *)(v82 + 773) = 1;
                          }
                        }
                        else if ( a6 == 3 )
                        {
                          SendReliablePacketToMyFrequency(a2, v146, 5u, 1);
                          PlayerSendPacket(a2, v146, 5, 1);
                          v83 = a2->lpCurrentArena;
                          v84 = 0;
                          if ( *(int *)(v83 + 65292) > 0 )
                          {
                            v85 = 64288;
                            do
                            {
                              v86 = *(_DWORD *)(v85 + v83);
                              ++v84;
                              v85 += 4;
                              *(_DWORD *)(v86 + 773) = 1;
                              v83 = a2->lpCurrentArena;
                            }
                            while ( v84 < *(_DWORD *)(v83 + 65292) );
                          }
                        }
                        else
                        {
                          ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, v146, 5, 1);
                          v87 = a2->lpCurrentArena;
                          v88 = 0;
                          if ( *(int *)(v87 + 65292) > 0 )
                          {
                            v89 = 64288;
                            do
                            {
                              v90 = *(_DWORD *)(v89 + v87);
                              ++v88;
                              v89 += 4;
                              *(_DWORD *)(v90 + 773) = 1;
                              v87 = a2->lpCurrentArena;
                            }
                            while ( v88 < *(_DWORD *)(v87 + 65292) );
                          }
                        }
                      }
                    }
                    else
                    {
                      *(_DWORD *)(a2->lpCurrentArena + 65350) = 0;
                    }
                  }
                  else if ( a6 == 5 )
                  {
                    v74 = (int)*(&ZonePlayerList + a7);
                    if ( v74 )
                    {
                      v75 = *(_DWORD *)(v74 + 639);
                      *(_DWORD *)(v74 + 639) = v75 == 0;
                      if ( v75 )
                        SendMessage(a2, "Player Moderator Mode OFF", 0);
                      else
                        SendMessage(a2, "Player Moderator Mode ON", 0);
                    }
                  }
                }
                else
                {
                  if ( a2 )
                    SendMessage(a2, "Recycling Server", 0);
                  bRecycleServer = 1;
                }
              }
              else
              {
                v159 = 25;
                strncpy(v165, "moderate.txt", 0x10u);
                v166 = 0;
                strncpy(&v160, "moderate.txt", 0x100u);
                v164 = 0;
                PlayerSendPacket(a2, &v159, 273, 1);
              }
            }
            else
            {
              SendMessage(a2, "File sent: moderate.txt (please wait...)", 0);
              SendFile(&a2->hProcess, "moderate.txt");
            }
          }
          else
          {
            v159 = 25;
            strncpy(&v160, "permit.txt", 0x100u);
            v164 = 0;
            strncpy(v165, "permit.txt", 0x10u);
            v166 = 0;
            PlayerSendPacket(a2, &v159, 273, 1);
          }
        }
        else
        {
          SendMessage(a2, "File sent: permit.txt (please wait...)", 0);
          SendFile(&a2->hProcess, "permit.txt");
        }
      }
      else if ( a6 == 5 )
      {
        v51 = (int)*(&ZonePlayerList + a7);
        if ( v51 )
        {
          v139 = *(_DWORD *)(v51 + 72) != 0;
          v137 = *(_DWORD *)(v51 + 279);
          v136 = *(_DWORD *)(v51 + 769);
          v52 = get_text_ip(*(struct in_addr *)(v51 + 755));
          sprintf(
            v154,
            "IP:%s  TimeZoneBias:%d  Freq:%d  TypedName:%s  Demo:%d",
            v52,
            v136,
            v137,
            (const char *)(v51 + 699),
            v139);
          if ( a2->bIsSysop )
            sprintf(&v154[strlen(v154)], "  MachineId:%d", *(_DWORD *)(v51 + 761));
          SendMessage(a2, v154, 0);
          v53 = a2->lpCurrentArena;
          if ( *(int *)(v53 + 109910) > 0 )
          {
            sprintf(
              v154,
              "DeathsLeft:%d  KillsNeeded:%d",
              *(_DWORD *)(v51 + 785),
              *(_DWORD *)(v53 + 109930) - *(_DWORD *)(v51 + 212));
            SendMessage(a2, v154, 0);
          }
          sprintf(
            v154,
            "Ping:%dms  LowPing:%dms  HighPing:%dms  AvePing:%dms",
            10 * *(__int16 *)(v51 + 330),
            10 * *(__int16 *)(v51 + 334),
            10 * *(__int16 *)(v51 + 336),
            10 * *(__int16 *)(v51 + 332));
          SendMessage(a2, v154, 0);
          sprintf(
            v154,
            "S2CAveLatency:%dms  C2SAveLatency:%dms",
            *(__int16 *)(v51 + 328),
            10 * *(_DWORD *)(v51 + 793) / (*(_DWORD *)(v51 + 797) + 1));
          v54 = *(_DWORD *)(v51 + 291);
          v55 = 1000;
          if ( v54 > 200 )
            v55 = 1000 * *(_DWORD *)(v51 + 295) / v54;
          v145 = 1000 - v55;
          sub_41D720(*(_DWORD *)(v51 + 40), (int)&v142, (int)&v144);
          v142 = 1000 - v142;
          v56 = *(struct CONNECTION **)(v51 + 40);
          v144 = 1000 - v144;
          v57 = GetRelAckDiff(v56, (int)&v150);
          sprintf(
            v154,
            "LOSS: S2C:%.1f%%  C2S:%.1f%%",
            (double)((long double)v142 * 0.1),
            (double)((long double)v144 * 0.1));
          if ( a2->bIsSysop )
            sprintf(
              &v154[strlen(v154)],
              "  S2CWeapons:%.1f%%  S2C_RelOut:%d(%d)",
              (double)((long double)v145 * 0.1),
              v57,
              v150);
          SendMessage(a2, v154, 0);
          if ( a2->bIsSmod )
          {
            GetPacketCountInfoSomething(
              *(struct CONNECTION **)(v51 + 40),
              (int)&v152,
              (int)&v145,
              (int)&v147,
              (int)&v149);
            sprintf(v154, "S2C:%d-->%d  C2S:%d-->%d", v152, v149, v147, v145);
            SendMessage(a2, v154, 0);
            v58 = *(_DWORD *)(v51 + 200);
            v59 = *(_DWORD *)(v51 + 196);
            v60 = 0.0;
            v143 = 0.0;
            v148 = v58;
            *(_DWORD *)v146 = v59 + v58;
            if ( v59 + v58 > 0 )
              v143 = (long double)v148 * 100.0 / (long double)*(int *)v146;
            v61 = *(_DWORD *)(v51 + 208);
            v62 = *(_DWORD *)(v51 + 204);
            *(_DWORD *)v146 = v61;
            v148 = v62 + v61;
            if ( v62 + v61 > 0 )
              v60 = (long double)*(int *)v146 * 100.0 / (long double)v148;
            sprintf(
              v154,
              "C2S CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v58,
              v59,
              v143,
              v61,
              v62,
              (double)v60);
            SendMessage(a2, v154, 0);
            v63 = *(__int16 *)(v51 + 326);
            v64 = 0.0;
            v65 = *(__int16 *)(v51 + 324);
            v143 = 0.0;
            *(_DWORD *)v146 = v65;
            v148 = v65 + v63;
            if ( v65 + v63 > 0 )
              v143 = (long double)*(int *)v146 * 100.0 / (long double)v148;
            v66 = *(_DWORD *)(v51 + 320);
            v67 = *(_DWORD *)(v51 + 316);
            *(_DWORD *)v146 = v67;
            v148 = v67 + v66;
            if ( v67 + v66 > 0 )
              v64 = (long double)*(int *)v146 * 100.0 / (long double)v148;
            sprintf(
              v154,
              "S2C CURRENT: Slow:%d Fast:%d %.1f%%   TOTAL: Slow:%d Fast:%d %.1f%%",
              v65,
              v63,
              v143,
              v67,
              v66,
              (double)v64);
            SendMessage(a2, v154, 0);
          }
          v140 = *(_DWORD *)(v51 + 765);
          v68 = time(0);
          v69 = (__int64)difftime(v68, v140);
          sprintf(&v155, "TIME: Session:%5d:%02d:00", v69 / 3600, v69 / 60 % 60);
          if ( a2->bIsSysop )
          {
            v70 = v69 + *(_DWORD *)(v51 + 519);
            sprintf(
              &v155 + strlen(&v155),
              "  Total:%5d:%02d:00  Created: %d-%d-%d %02d:%02d:%02d",
              v70 / 3600,
              v70 / 60 % 60,
              *(unsigned __int16 *)(v51 + 525),
              *(unsigned __int16 *)(v51 + 527),
              *(__int16 *)(v51 + 523),
              *(unsigned __int16 *)(v51 + 529),
              *(unsigned __int16 *)(v51 + 531),
              *(unsigned __int16 *)(v51 + 533));
          }
          SendMessage(a2, &v155, 0);
          if ( a2->bIsSysop )
          {
            v71 = *(_DWORD *)(v51 + 44);
            v151[0] = "Unknown";
            v151[1] = "SlowModem";
            v151[2] = "FastModem";
            v151[3] = "UnknownModem";
            v151[4] = "UnknownNotRAS";
            v151[5] = "ISDN";
            v151[6] = &off_42EA3C;
            v151[7] = "Switch";
            v72 = "InvalidValue";
            if ( v71 < 5 )
              v72 = (const char *)v151[v71];
            sprintf(
              v154,
              "Bytes/Sec:%d  LowBandwidth:%d  MessageLogging:%d  ConnectType:%s",
              *(_DWORD *)(*(_DWORD *)(v51 + 40) + 2690),
              *(_DWORD *)(v51 + 52),
              *(_DWORD *)(v51 + 543),
              v72);
            SendMessage(a2, v154, 0);
            if ( *(int *)(a2->lpCurrentArena + 109754) > 0 )
            {
              sprintf(
                v154,
                "BEST SCORE Points:%d  Win:%d  Lose:%d",
                *(_DWORD *)(v51 + 567) + *(_DWORD *)(v51 + 571),
                *(unsigned __int16 *)(v51 + 561),
                *(unsigned __int16 *)(v51 + 563));
              SendMessage(a2, v154, 0);
            }
            v73 = *(_DWORD *)(v51 + 40);
            v143 = 0.0;
            v145 = 0;
            v149 = 0;
            v147 = 0;
            sub_41D560(v73, &v143, &v145);
            GetASyncS2CInfoSomething(*(struct CONNECTION **)(v51 + 40), (int)&v149, (int)&v147);
            if ( SLODWORD(v143) > 0 || v149 > 0 )
            {
              sprintf(v154, "Async C2S:%d of %d  S2C:%d of %d", v145, v143, v147, v149);
              SendMessage(a2, v154, 0);
            }
          }
        }
      }
    }
    else if ( a6 == 5 )
    {
      v50 = (int)*(&ZonePlayerList + a7);
      if ( v50 )
      {
        sprintf(
          v153,
          "%s: %c%d",
          (const char *)(v50 + 675),
          10 * (*(__int16 *)(v50 + 232) / 16) / 512 + 'A',
          10 * (*(__int16 *)(v50 + 228) / 16) / 512 + 1);
        SendMessage(a2, v153, 0);
      }
    }
  }
  else
  {
    v43 = *(_BYTE *)(a8 + 5);
    v44 = (char *)(a8 + 5);
    a8 += 5;
    if ( v43 == 32 )
    {
      do
        v45 = *++v44;
      while ( v45 == 32 );
      a8 = (int)v44;
    }
    if ( a2 )
    {
      v46 = (ARENA *)a2->lpCurrentArena;
      if ( v46 )
        FormatMessageArena(v46, "%s\n", v44);
    }
    if ( *v44 == 95 )
      *v44 = 32;
    v161 = a9;
    v159 = 7;
    v160 = 0;
    v162 = -1;
    strcpy(v163, v44);
    v47 = strlen(v44) + 1;
    v48 = 0;
    if ( ZonePlayerCount > 0 )
    {
      v49 = (PLAYER **)ZonePlayers;
      do
      {
        if ( (*v49)->lpCurrentArena )
          PlayerSendPacket(*v49, &v159, v47 - 1 + 6, 1);
        ++v48;
        ++v49;
      }
      while ( v48 < ZonePlayerCount );
    }
  }
  if ( _memicmp((const void *)a8, "*arena", 6u) )
  {
    if ( !_memicmp((const void *)a8, "*permit", 7u) )
    {
      v98 = *(_BYTE *)(a8 + 7);
      v99 = (char *)(a8 + 7);
      a8 += 7;
      if ( v98 == 32 )
      {
        do
          v100 = *++v99;
        while ( v100 == 32 );
        a8 = (int)v99;
      }
      if ( *v99 )
      {
        AddLineTextFile((struct TEXT_FILE_STRUCT *)PermitPointer, v99);
        WriteTextFileToFile((struct TEXT_FILE_STRUCT *)PermitPointer);
        if ( !a2 )
          return;
        sprintf(v154, "Permission Added: %s", v99);
        SendMessage(a2, v154, 0);
      }
      goto exit_handler;
    }
    if ( _memicmp((const void *)a8, "*revoke", 7u) )
    {
      if ( _memicmp((const void *)a8, "*banner", 7u) || !a2 )
      {
        if ( _memicmp((const void *)a8, "*shutup", 7u) || !a2 )
        {
          if ( _memicmp((const void *)a8, "*lock", 5u) || !a2 )
          {
            if ( _memicmp((const void *)a8, "*timer", 6u) || !a2 )
            {
              if ( _memicmp((const void *)a8, "*spec", 5u) || !a2 )
              {
                if ( _memicmp((const void *)a8, "*kill", 5u) || !a2 )
                {
                  if ( _memicmp((const void *)a8, "*flagreset", 0xAu) )
                  {
                    if ( _memicmp((const void *)a8, "*shipreset", 0xAu) )
                    {
                      if ( _memicmp((const void *)a8, "*scorereset", 0xBu) )
                      {
                        if ( _memicmp((const void *)a8, "*timereset", 0xAu) )
                        {
                          if ( _memicmp((const void *)a8, "*beginlog", 9u) || !a2 )
                          {
                            if ( !_memicmp((const void *)a8, "*endlog", 7u) )
                            {
                              if ( !a2 )
                                return;
                              v130 = a2->beginlog_file_ptr;
                              if ( v130 )
                              {
                                fprintf(v130, "Name               Win  Lose  Points\n");
                                fprintf(a2->beginlog_file_ptr, "---------------- ----- ----- -------\n");
                                v131 = (ARENA *)a2->lpCurrentArena;
                                if ( v131 )
                                {
                                  v132 = 0;
                                  if ( v131->nPlayersHere > 0 )
                                  {
                                    v133 = offsetof(ARENA, PlayerArray);
                                    do
                                    {
                                      fprintf(
                                        a2->beginlog_file_ptr,
                                        "%-16.16s %5d %5d %7d\n",
                                        (const char *)(*(_DWORD *)&v131->field_0[v133] + 375),
                                        *(unsigned __int16 *)(*(_DWORD *)&v131->field_0[v133] + offsetof(PLAYER, score)),
                                        *(unsigned __int16 *)(*(_DWORD *)&v131->field_0[v133] + 0x225),
                                        *(_DWORD *)(*(_DWORD *)&v131->field_0[v133] + 0x22D)
                                      + *(_DWORD *)(*(_DWORD *)&v131->field_0[v133] + 0x229));
                                      v131 = (ARENA *)a2->lpCurrentArena;
                                      ++v132;
                                      v133 += 4;
                                    }
                                    while ( v132 < v131->nPlayersHere );
                                  }
                                }
                                fprintf(a2->beginlog_file_ptr, "\nLOG FINISHED\n");
                                fclose(a2->beginlog_file_ptr);
                                a2->beginlog_file_ptr = 0;
                                sprintf(
                                  &v155,
                                  "Logging session closed, sending file: %s",
                                  (const char *)&a2->beginlog_file_name);
                                SendMessage(a2, &v155, 0);
                                SendFile(&a2->hProcess, (char *)&a2->beginlog_file_name);
                              }
                            }
                          }
                          else
                          {
                            v126 = a2->beginlog_file_ptr;
                            v127 = (const char *)(a8 + 9);
                            a8 += 9;
                            if ( v126 )
                              fclose(v126);
                            v128 = rand();
                            v129 = rand();
                            sprintf(&a2->beginlog_file_name, "SS%d.log", v129 + v128);
                            a2->beginlog_file_ptr = fopen(&a2->beginlog_file_name, "wt");
                            sprintf(&v155, "Logging session to: %s", (const char *)&a2->beginlog_file_name);
                            SendMessage(a2, &v155, 0);
                            fprintf(a2->beginlog_file_ptr, "LOG STARTED:%s\n", v127);
                          }
                        }
                        else
                        {
                          if ( !a2 )
                            return;
                          v125 = a2->lpCurrentArena;
                          if ( v125 )
                          {
                            if ( *(int *)(v125 + 109754) <= 0 )
                              SendMessage(a2, "Invalid command, this is not a timed game", 0);
                            else
                              sub_405360(v125, 1);
                          }
                        }
                      }
                      else if ( a6 == 5 )
                      {
                        if ( a2 )
                          SendMessage(a2, "Player score reset", 0);
                        v124 = *(&ZonePlayerList + a7);
                        if ( v124 )
                          SendResetScoresPacket(v124);
                      }
                      else
                      {
                        if ( !a2 )
                          return;
                        ArenaScoreReset((struct ARENA *)a2->lpCurrentArena, 1);
                      }
                    }
                    else
                    {
                      LOBYTE(v142) = 27;
                      if ( a6 == 5 )
                      {
                        if ( a2 )
                          SendMessage(a2, "Player ship reset", 0);
                        v121 = *(&ZonePlayerList + a7);
                        if ( v121 )
                          PlayerSendPacket(v121, &v142, 1, 1);
                      }
                      else if ( a2 )
                      {
                        SendMessage(a2, "All ships reset", 0);
                        ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, (char *)&v142, 1, 1);
                      }
                      else
                      {
                        v122 = 0;
                        if ( ZonePlayerCount > 0 )
                        {
                          v123 = (PLAYER **)ZonePlayers;
                          do
                          {
                            if ( (*v123)->lpCurrentArena )
                              PlayerSendPacket(*v123, &v142, 1, 1);
                            ++v122;
                            ++v123;
                          }
                          while ( v122 < ZonePlayerCount );
                        }
                      }
                    }
                  }
                  else if ( a2 )
                  {
                    SendMessage(a2, "Flag game being reset", 0);
                    v118 = (struct ARENA *)a2->lpCurrentArena;
                    if ( v118 )
                      ResetFlagGame(v118);
                  }
                  else
                  {
                    v119 = 0;
                    if ( ArenaArrayLength > 0 )
                    {
                      v120 = (struct ARENA **)ArenaArray;
                      do
                      {
                        ResetFlagGame(*v120);
                        ++v119;
                        ++v120;
                      }
                      while ( v119 < ArenaArrayLength );
                    }
                  }
                }
                else if ( a6 == 5 )
                {
                  v113 = *(&ZonePlayerList + a7);
                  if ( v113 )
                  {
                    if ( a2->bIsSysop || !v113->bIsSmod )
                    {
                      v113->dwDisconnectReason = 4;
                      *(_DWORD *)&v113->field_2C[12] = 1;
                      WriteSubGameLog("Player kicked off by moderator: %s\n", v113->player_name);
                      SendMessage(a2, "Player kicked off", 0);
                      if ( *(_BYTE *)(a8 + 5) == 32 )
                      {
                        v114 = atoi((const char *)(a8 + 6));
                        if ( v114 > 0 )
                        {
                          v115 = MachineIdArrayCount;
                          if ( MachineIdArrayCount < 1000 )
                          {
                            dword_4AD738[3 * MachineIdArrayCount] = *(_DWORD *)v113->field_2F9;
                            v116 = 3 * v115;
                            dword_4AD73C[v116] = ((int (*)(void))GetTickCount)() / 0xAu;
                            v117 = MachineIdArrayCount + 1;
                            dword_4AD740[v116] = 6000 * v114;
                            MachineIdArrayCount = v117;
                          }
                        }
                      }
                    }
                    else
                    {
                      SendMessage(v113, "Moderator attempted to kick you off", 0);
                    }
                  }
                }
              }
              else if ( a6 == 5 )
              {
                v111 = (int)*(&ZonePlayerList + a7);
                if ( v111 )
                {
                  if ( a2->bIsSysop || !*(_DWORD *)(v111 + 635) )
                  {
                    if ( *(_DWORD *)(v111 + 275) != 8 )
                      SetPlayerShip((struct PLAYER *)v111, 8);
                    v112 = *(_DWORD *)(v111 + 747);
                    *(_DWORD *)(v111 + 747) = v112 == 0;
                    if ( v112 )
                      SendMessage(a2, "Player free to enter arena", 0);
                    else
                      SendMessage(a2, "Player locked in spectator mode", 0);
                  }
                }
              }
            }
            else
            {
              v108 = *(_BYTE *)(a8 + 6);
              v109 = (const char *)(a8 + 6);
              a8 += 6;
              if ( v108 == 32 )
              {
                do
                  v110 = *++v109;
                while ( v110 == 32 );
                a8 = (int)v109;
              }
              if ( *v109 )
              {
                *(_DWORD *)(a2->lpCurrentArena + 65362) = 6000 * atoi(v109);
                *(_DWORD *)(a2->lpCurrentArena + 65370) = ((int (*)(void))GetTickCount)() / 0xAu;
                *(_DWORD *)(a2->lpCurrentArena + 65366) = 0;
              }
            }
          }
          else if ( a2->lpCurrentArena )
          {
            if ( _memicmp((const void *)a8, "*lockpublic", 0xBu) )
            {
              if ( _memicmp((const void *)a8, "*lockteam", 9u) )
              {
                if ( _memicmp((const void *)a8, "*lockprivate", 0xCu) )
                {
                  if ( _memicmp((const void *)a8, "*lockall", 8u) )
                  {
                    if ( _memicmp((const void *)a8, "*lockspec", 9u) )
                    {
                      if ( !*(_BYTE *)(a8 + 5) )
                      {
                        *(_DWORD *)(a2->lpCurrentArena + 65374) = *(_DWORD *)(a2->lpCurrentArena + 65374) == 0;
                        if ( *(_DWORD *)(a2->lpCurrentArena + 65374) )
                          SendMessage(a2, "Arena LOCKED", 0);
                        else
                          SendMessage(a2, "Arena UNLOCKED", 0);
                      }
                    }
                    else
                    {
                      *(_DWORD *)(a2->lpCurrentArena + 65590) = *(_DWORD *)(a2->lpCurrentArena + 65590) == 0;
                      if ( *(_DWORD *)(a2->lpCurrentArena + 65590) )
                        SendMessage(a2, "Message lock applies to spectators only.", 0);
                      else
                        SendMessage(a2, "Message lock applies to everybody.", 0);
                    }
                  }
                  else
                  {
                    *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
                    *(_DWORD *)(a2->lpCurrentArena + 65582) = *(_DWORD *)(a2->lpCurrentArena + 65578);
                    if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                      SendMessage(a2, "All Messages LOCKED", 0);
                    else
                      SendMessage(a2, "All Messages UNLOCKED", 0);
                  }
                }
                else
                {
                  *(_DWORD *)(a2->lpCurrentArena + 65586) = *(_DWORD *)(a2->lpCurrentArena + 65586) == 0;
                  if ( *(_DWORD *)(a2->lpCurrentArena + 65586) )
                    SendMessage(a2, "Private Messages LOCKED", 0);
                  else
                    SendMessage(a2, "Private Messages UNLOCKED", 0);
                }
              }
              else
              {
                *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
                if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                  SendMessage(a2, "Team Messages LOCKED", 0);
                else
                  SendMessage(a2, "Team Messages UNLOCKED", 0);
              }
            }
            else
            {
              *(_DWORD *)(a2->lpCurrentArena + 65578) = *(_DWORD *)(a2->lpCurrentArena + 65578) == 0;
              if ( *(_DWORD *)(a2->lpCurrentArena + 65578) )
                SendMessage(a2, "Public Messages LOCKED", 0);
              else
                SendMessage(a2, "Public Messages UNLOCKED", 0);
            }
          }
        }
        else if ( a6 == 5 )
        {
          v106 = *(&ZonePlayerList + a7);
          if ( v106 )
          {
            if ( v106->bIsSysop || v106->bIsSmod && !a2->bIsSysop )
            {
              sprintf(&v155, "%s tried to shut you up", a2->player_name);
              SendMessage(v106, &v155, 0);
            }
            else
            {
              v107 = v106->bIsSilenced;
              v106->bIsSilenced = v107 == 0;
              if ( v107 )
                v138 = "%s can now speak";
              else
                v138 = "%s has been silenced";
              sprintf(&v155, v138, v106->player_name);
              SendMessage(a2, &v155, 0);
            }
          }
        }
      }
      else
      {
        *(_DWORD *)&a2->field_2C[4] = 1;
        v105 = a2->field_14;
        v155 = 31;
        v156 = v105;
        qmemcpy(v157, &a2->field_18F[24], sizeof(v157));
        ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, &v155, 99, 1);
      }
      goto exit_handler;
    }
    v101 = *(_BYTE *)(a8 + 7);
    v102 = (const char *)(a8 + 7);
    a8 += 7;
    if ( v101 == 32 )
    {
      do
        v103 = *++v102;
      while ( v103 == 32 );
      a8 = (int)v102;
    }
    if ( *v102 )
    {
      if ( !strcmp(v102, (const char *)L"*") )
      {
        CleanTextFileMemory((TEXT_FILE_STRUCT *)PermitPointer);
      }
      else
      {
        v104 = (struct TEXT_FILE_STRUCT *)sub_407420(PermitPointer, (int)v102);
        if ( (int)v104 >= 0 )
          ListMachineSomething(v104, v141);
      }
      WriteTextFileToFile((struct TEXT_FILE_STRUCT *)PermitPointer);
      if ( !a2 )
        return;
      SendMessage(a2, "Permission revoked", 0);
    }
exit_handler:
    if ( a2 )
    {
      v134 = (const char *)(a8 + 1);
      if ( !_strcmpi((const char *)(a8 + 1), szSysopPassword) )
      {
        WriteSubGameLog("%s> SYSOP LOGGED IN\n", a2->player_name);
        a2->bIsSysop = 1;
        a2->bIsModerator = 1;
        a2->bIsSmod = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_SupermoderatorPassword) )
      {
        WriteSubGameLog("%s> SUPER MODERATOR LOGGED IN\n", a2->player_name);
        a2->bIsModerator = 1;
        a2->bIsSmod = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_ModeratorPassword) )
      {
        WriteSubGameLog("%s> MODERATOR LOGGED IN\n", a2->player_name);
        a2->bIsModerator = 1;
      }
      if ( !_strcmpi(v134, lpszPassword_EnergyPassword) )
      {
        WriteSubGameLog("%s> ENERGY VIEWING TURNED ON/OFF\n", a2->player_name);
        if ( a2->lpCurrentArena )
        {
          v135 = *(_DWORD *)a2->field_44;
          *(_DWORD *)a2->field_44 = v135 == 0;
          if ( v135 )
            SendMessage(a2, "Showing Energy OFF", 0);
          else
            SendMessage(a2, "Showing Energy ON", 0);
        }
      }
    }
    return;
  }
  v93 = *(_BYTE *)(a8 + 6);
  v94 = (char *)(a8 + 6);
  a8 += 6;
  if ( v93 == 32 )
  {
    do
      v95 = *++v94;
    while ( v95 == 32 );
    a8 = (int)v94;
  }
  if ( *v94 == 95 )
    *v94 = 32;
  if ( a2 )
  {
    v96 = (ARENA *)a2->lpCurrentArena;
    if ( v96 )
      FormatMessageArena(v96, "%s\n", v94);
  }
  v161 = a9;
  v159 = 7;
  v160 = 0;
  v162 = -1;
  strcpy(v163, (const char *)a8);
  v97 = strlen((const char *)a8) + 1;
  if ( a2 )
  {
    ArenaSendPacket((struct ARENA *)a2->lpCurrentArena, &v159, v97 + 5, 1);
    goto exit_handler;
  }
}
// 4199F8: positive sp value 1660C has been found
// 4DC214: invalid function type has been ignored
// 415A26: could not find valid save-restore pair for ebx
// 4179DE: conditional instruction was optimized away because of 'eax.4!=0'
// 416FCE: variable 'v141' is possibly undefined
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42E820: using guessed type wchar_t asc_42E820[2];
// 42EA3C: using guessed type void *off_42EA3C;
// 4332F4: using guessed type int bRecycleServer;
// 4399C4: using guessed type int MachineIdArrayCount;
// 4AD738: using guessed type int dword_4AD738[];
// 4AD73C: using guessed type int dword_4AD73C[];
// 4AD740: using guessed type int dword_4AD740[];
// 4CA230: using guessed type int ZonePlayers[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D6C10: using guessed type int dword_4D6C10;
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (00419A51) --------------------------------------------------------
void __usercall sub_419A51(char a1@<zf>)
{
  if ( !a1 )
    JUMPOUT(0x4141DD);
  JUMPOUT(0x4141E5);
}
// 419A66: control flows out of bounds to 4141E5
// 419A56: control flows out of bounds to 4141DD

//----- (00419A70) --------------------------------------------------------
int __userpurge sub_419A70@<eax>(int a1@<edx>, PLAYER *a2@<ecx>, int a3@<ebp>, void *a4, int a5, BOOL a6)
{
  *(_BYTE *)(a1 + 6) = *(_DWORD *)(a3 + 1026);
  return PlayerSendPacket(a2, a4, a5, a6);
}

//----- (00419DA0) --------------------------------------------------------
// updates the points a player has, logging if necessary
void __cdecl UpdatePoints(struct PLAYER *player, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  ARENA *v5; // ecx
  int v6[4]; // [esp+Ch] [ebp-10h] BYREF

  v3 = a3 + player->score.flag_points;
  player->score.points += a2;
  player->score.flag_points = v3;
  if ( dwMisc_LogPoints && BillingConnectionStructPointer )
  {
    v4 = pFILE_points_log;
    if ( !pFILE_points_log )
    {
      v4 = fopen("points.log", "ab");
      pFILE_points_log = v4;
    }
    v5 = (ARENA *)player->lpCurrentArena;
    if ( v5 && v5->bRecordPointsToLog )
    {
      if ( v4 )
      {
        v6[0] = player->dwUserID;
        v6[1] = a2;
        v6[2] = a3;
        v6[3] = time(0);
        fwrite(v6, 16, 1, pFILE_points_log);
      }
    }
  }
  else if ( pFILE_points_log )
  {
    fclose(pFILE_points_log);
    pFILE_points_log = 0;
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41DFB0: using guessed type _DWORD __cdecl fwrite(LPCVOID lpBuffer, _DWORD, _DWORD, _DWORD);
// 439DF8: using guessed type int dwMisc_LogPoints;
// 4D9DF8: using guessed type int pFILE_points_log;

//----- (00419E80) --------------------------------------------------------
unsigned int __cdecl LoadServerIni()
{
  unsigned int v0; // edi
  int v1; // eax
  unsigned int v2; // edi
  int v3; // eax
  unsigned int v4; // edi
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  unsigned int v8; // esi
  int v9; // eax
  unsigned int v10; // eax
  unsigned int result; // eax
  CHAR Default[16]; // [esp+8h] [ebp-10h] BYREF

  CustomArenaMode = GetPrivateProfileIntWrapper("Custom", "ArenaMode", 0, &aServerIni);
  dwArena_ArenaMaxPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMaxPlayers", 0x3Cu, &aServerIni);
  dwArena_ArenaDesiredPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaDesiredPlayers", 0x28u, &aServerIni);
  dwArena_ArenaMinimumPlayers = GetPrivateProfileIntWrapper("Arena", "ArenaMinimumPlayers", 0xFu, &aServerIni);
  bArena_SpawnKeepScore = GetPrivateProfileIntWrapper("Arena", "SpawnKeepScores", 0, &aServerIni);
  dwArena_MaxArenas = GetPrivateProfileIntWrapper("Arena", "MaxArenas", 0x64u, &aServerIni);
  dwArena_MaxArenasMemory = GetPrivateProfileIntWrapper("Arena", "MaxArenasMemory", 0xFA00u, &aServerIni);
  dwComms_MaxQueueToLogIn = GetPrivateProfileIntWrapper("Comms", "MaxQueueToLogin", 0x10u, &aServerIni);
  *(_DWORD *)&dwComms_PacketHistoryMax = GetPrivateProfileIntWrapper("Comms", "PacketHistoryMax", 0x7D0u, &aServerIni);
  dwComms_IncomingBufferSize = GetPrivateProfileIntWrapper("Comms", "IncomingBufferSize", 0x20000u, &aServerIni);
  dwComms_OutgoingBufferSize = GetPrivateProfileIntWrapper("Comms", "OutgoingBufferSize", 0x20000u, &aServerIni);
  dwComms_TransportBufferSize = (LPCSTR)GetPrivateProfileIntWrapper("Comms", "TransportBufferSize", 0xA0u, &aServerIni);
  CommsEncryptMode = GetPrivateProfileIntWrapper("Comms", "EncryptMode", 1u, &aServerIni);
  dwBilling_LogMessages = GetPrivateProfileIntWrapper("Billing", "LogMessages", 0, &aServerIni);
  dwMisc_DisableShareware = GetPrivateProfileIntWrapper("Misc", "DisableSharewareNames", 0, &aServerIni);
  dwMisc_DisableSharewareShips = GetPrivateProfileIntWrapper("Misc", "DisableSharewareShips", 0, &aServerIni);
  dwMisc_DisableSharewareScores = GetPrivateProfileIntWrapper("Misc", "DisableSharewareScores", 0, &aServerIni);
  dwPermission_AllowBadMachineID = GetPrivateProfileIntWrapper("Permission", "AllowBadMachineId", 1u, &aServerIni);
  dwMisc_RegisterKickShareware = GetPrivateProfileIntWrapper("Misc", "RegisterKickShareware", 1u, &aServerIni);
  dwMisc_MaxSharewarePlayers = GetPrivateProfileIntWrapper("Misc", "MaxSharewarePlayers", 0xFFFFFFFF, &aServerIni);
  dwMisc_MaxSharewareTime = GetPrivateProfileIntWrapper("Misc", "MaxSharewareTime", 0x15F90u, &aServerIni);
  MiscMaxPlayers = GetPrivateProfileIntWrapper("Misc", "MaxPlayers", 0x78u, &aServerIni);
  dwMisc_MenuKickoutDelay = GetPrivateProfileIntWrapper("Misc", "MenuKickOutDelay", 0x2EE0u, &aServerIni);
  dwMisc_LogPoints = GetPrivateProfileIntWrapper("Misc", "LogPoints", 0, &aServerIni);
  dwMisc_PointUpdateDiff = GetPrivateProfileIntWrapper("Misc", "PointUpdateDiff", 0x1F4u, &aServerIni);
  dwMisc_JackpotBroadcastPoints = GetPrivateProfileIntWrapper("Misc", "JackpotBroadcastPoints", 0, &aServerIni);
  dwMisc_ServerLog = GetPrivateProfileIntWrapper("Misc", "ServerLog", 0, &aServerIni);
  MiscKeepAliveDelay = GetPrivateProfileIntWrapper("Misc", "KeepAliveDelay", 0x190u, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Misc",
    "DefaultLevelFile",
    "changeme.lvl",
    &aMisc_DefaultLevelFile,
    0x100u,
    &aServerIni);
  dwCPU_ProcessMaxTime = GetPrivateProfileIntWrapper("CPU", "ProcessMaxTime", 4u, &aServerIni);
  dwCPU_SleepPerIteration = GetPrivateProfileIntWrapper("CPU", "SleepPerIteration", 0, &aServerIni);
  CPUSleepTime = GetPrivateProfileIntWrapper("CPU", "SleepTime", 0, &aServerIni);
  dwCPU_SlowIterationWarningLevel = GetPrivateProfileIntWrapper("CPU", "SlowIterationWarningLevel", 0x64u, &aServerIni);
  dwPermission_AllowLowBandwidth = GetPrivateProfileIntWrapper("Permission", "AllowLowBandwidth", 1u, &aServerIni);
  dwPermission_MininumSecondsToLogin = GetPrivateProfileIntWrapper(
                                         "Permission",
                                         "MinimumSecondsToLogin",
                                         0,
                                         &aServerIni);
  dwPermission_PermissionMaxPoints = GetPrivateProfileIntWrapper("Permission", "PermissionMaxPoints", 0, &aServerIni);
  dwPermission_PermissionMode = GetPrivateProfileIntWrapper("Permission", "PermissionMode", 0, &aServerIni);
  dword_4B061C = GetPrivateProfileIntWrapper("Permission", "AutoPermissionPoints", 0, &aServerIni);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionIDList",
    L"0",
    lpszPermission_AutoPermissionIDList,
    0x200u,
    &aServerIni);
  GetPrivateProfileStringWrapper(
    "Permission",
    "AutoPermissionMessage",
    "Congratulations",
    lpszPermission_AutoPermissionMessage,
    0x100u,
    &aServerIni);
  v0 = ((int (*)(void))GetTickCount)() / 0xAu;
  v1 = rand();
  sprintf(Default, "%d", abs32(v0 + v1));
  GetPrivateProfileStringWrapper("Password", "SysopPassword", Default, szSysopPassword, 0x40u, &aServerIni);
  v2 = ((int (*)(void))GetTickCount)() / 0xAu;
  v3 = rand();
  sprintf(Default, "%d", abs32(v2 + v3));
  GetPrivateProfileStringWrapper("Password", "EnergyPassword", Default, lpszPassword_EnergyPassword, 0x40u, &aServerIni);
  v4 = ((int (*)(void))GetTickCount)() / 0xAu;
  v5 = rand();
  sprintf(Default, "%d", abs32(v4 + v5));
  GetPrivateProfileStringWrapper(
    "Password",
    "ModeratorPassword",
    Default,
    lpszPassword_ModeratorPassword,
    0x40u,
    &aServerIni);
  v6 = ((int (*)(void))GetTickCount)() / 0xAu;
  v7 = rand();
  sprintf(Default, "%d", abs32(v6 + v7));
  GetPrivateProfileStringWrapper(
    "Password",
    "SuperModeratorPassword",
    Default,
    lpszPassword_SupermoderatorPassword,
    0x40u,
    &aServerIni);
  v8 = ((int (*)(void))GetTickCount)() / 0xAu;
  v9 = rand();
  sprintf(Default, "%d", abs32(v8 + v9));
  GetPrivateProfileStringWrapper("Password", "VIPPassword", Default, lpszPassword_VIPPassword, 0x40u, &aServerIni);
  GetPrivateProfileStringWrapper("Billing", "IP", "127.0.0.1", &lpszIP_Billing, 0x80u, &aServerIni);
  GetPrivateProfileStringWrapper("Billing", "Password", "money", lpsz_Billing_Password, 0x20u, &aServerIni);
  GetPrivateProfileStringWrapper("Billing", "ServerName", "Unknown", (LPSTR)&BillingServerName, 0x80u, &aServerIni);
  dwBilling_Port = GetPrivateProfileIntWrapper("Billing", "Port", 0x384u, &aServerIni);
  v10 = rand();
  dwBilling_ServerID = GetPrivateProfileIntWrapper("Billing", "ServerId", v10, &aServerIni);
  dwBilling_GroupID = GetPrivateProfileIntWrapper("Billing", "GroupId", 1u, &aServerIni);
  dwBilling_ScoreID = GetPrivateProfileIntWrapper("Billing", "ScoreId", 0, &aServerIni);
  dwBilling_ReconnectTime = GetPrivateProfileIntWrapper("Billing", "ReconnectTime", 0x2EE0u, &aServerIni);
  dwBilling_AttemptTime = GetPrivateProfileIntWrapper("Billing", "AttemptTime", 0x2710u, &aServerIni);
  dwAdvertise_SendMode = GetPrivateProfileIntWrapper("Advertise", "SendMode", 0, &aServerIni);
  dwAdvertise_DisplayMode = GetPrivateProfileIntWrapper("Advertise", "DisplayMode", 2u, &aServerIni);
  dwAdvertise_Duration = GetPrivateProfileIntWrapper("Advertise", "Duration", 0x2EE0u, &aServerIni);
  GetPrivateProfileStringWrapper("Directory", "IP", "sscentral.vie.com", lpszDirectory_IP, 0x200u, &aServerIni);
  GetPrivateProfileStringWrapper("Directory", "Description", "None", DirectoryDescription, 0x100u, &aServerIni);
  GetPrivateProfileStringWrapper("Directory", "NamePassword", &::Default, DirectoryNamePassword, 0x80u, &aServerIni);
  result = GetPrivateProfileIntWrapper("Directory", "Port", 0x137Fu, &aServerIni);
  dwDirectory_Port = result;
  return result;
}
// 4DC214: invalid function type has been ignored
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 4327A0: using guessed type int dwAdvertise_SendMode;
// 432ED0: using guessed type int dwMisc_DisableSharewareShips;
// 4332EC: using guessed type int dwArena_ArenaMinimumPlayers;
// 438E00: using guessed type int bArena_SpawnKeepScore;
// 438E04: using guessed type int dwPermission_AllowBadMachineID;
// 438F0C: using guessed type int dwBilling_AttemptTime;
// 438F90: using guessed type int dwComms_MaxQueueToLogIn;
// 4393A0: using guessed type int dwArena_ArenaMaxPlayers;
// 439428: using guessed type int dwMisc_MaxSharewarePlayers;
// 439DF0: using guessed type int dwBilling_Port;
// 439DF8: using guessed type int dwMisc_LogPoints;
// 439E04: using guessed type int dwCPU_SlowIterationWarningLevel;
// 439E08: using guessed type int dwArena_MaxArenasMemory;
// 439E0C: using guessed type int dwPermission_PermissionMode;
// 439E10: using guessed type int CommsEncryptMode;
// 439E64: using guessed type int MiscMaxPlayers;
// 439E68: using guessed type int dwBilling_ReconnectTime;
// 439E6C: using guessed type int dwPermission_MininumSecondsToLogin;
// 4AD728: using guessed type int dwPermission_PermissionMaxPoints;
// 4B0618: using guessed type int MiscKeepAliveDelay;
// 4B061C: using guessed type int dword_4B061C;
// 4CB234: using guessed type int dwCPU_SleepPerIteration;
// 4CB8FC: using guessed type int dwMisc_PointUpdateDiff;
// 4CBB00: using guessed type int dwBilling_LogMessages;
// 4D58B0: using guessed type int CustomArenaMode;
// 4D68BC: using guessed type int dwMisc_ServerLog;
// 4D68C4: using guessed type int dwMisc_MaxSharewareTime;
// 4D68C8: using guessed type int dwMisc_MenuKickoutDelay;
// 4D6BF0: using guessed type int dwPermission_AllowLowBandwidth;
// 4D6BF4: using guessed type int dwCPU_ProcessMaxTime;
// 4D6BF8: using guessed type int dwArena_MaxArenas;
// 4D6BFC: using guessed type int dwMisc_JackpotBroadcastPoints;
// 4D6C00: using guessed type int dwMisc_RegisterKickShareware;
// 4D6C08: using guessed type int dwMisc_DisableShareware;
// 4D6C18: using guessed type int dwArena_ArenaDesiredPlayers;
// 4D9C20: using guessed type int dwAdvertise_Duration;
// 4D9DC8: using guessed type int dwAdvertise_DisplayMode;
// 4D9DD0: using guessed type int dwMisc_DisableSharewareScores;

//----- (0041A730) --------------------------------------------------------
void __cdecl LoadTemplateSSS()
{
  int v0; // eax
  int v1; // edi
  char *v2; // eax
  char v3; // cl
  char *i; // edx
  char v5; // cl
  char *j; // edx
  char v7; // cl
  char *k; // edx
  char v9; // cl
  char *l; // edx
  char v11; // dl
  char *m; // ecx
  int v13; // eax
  char *v14; // esi
  char *v15; // esi
  char *v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // eax
  int v20; // eax
  char v21; // [esp+8h] [ebp-888h]
  char v22; // [esp+Ch] [ebp-884h]
  char v23[64]; // [esp+10h] [ebp-880h] BYREF
  char v24[64]; // [esp+50h] [ebp-840h] BYREF
  char v25[256]; // [esp+90h] [ebp-800h] BYREF
  char v26[256]; // [esp+190h] [ebp-700h] BYREF
  char v27[512]; // [esp+290h] [ebp-600h] BYREF
  char v28; // [esp+490h] [ebp-400h] BYREF
  char v29; // [esp+491h] [ebp-3FFh] BYREF

  dword_4D9DD4 = 0;
  v0 = fopen("template.sss", "rt");
  v1 = v0;
  if ( v0 )
  {
    if ( (*(_BYTE *)(v0 + 12) & 0x10) == 0 )
    {
      do
      {
        if ( fgets(&v28, 1024, v1) && (isalpha(v28) || v28 == 42 || v28 == 43) )
        {
          v24[0] = 0;
          v23[0] = 0;
          v26[0] = 0;
          v25[0] = 0;
          v27[0] = 0;
          v2 = &v28;
          v21 = 0;
          if ( v28 == 42 )
          {
            v21 = 1;
            v2 = &v29;
          }
          v22 = 1;
          if ( *v2 == 43 )
          {
            v22 = 0;
            ++v2;
          }
          v3 = *v2;
          for ( i = v24; v3 != 58; ++v2 )
          {
            if ( !v3 )
              break;
            *i = v3;
            v3 = v2[1];
            ++i;
          }
          *i = 0;
          if ( v2 )
            ++v2;
          v5 = *v2;
          for ( j = v23; v5 != 58; ++v2 )
          {
            if ( !v5 )
              break;
            *j = v5;
            v5 = v2[1];
            ++j;
          }
          *j = 0;
          if ( v2 )
            ++v2;
          v7 = *v2;
          for ( k = v26; v7 != 58; ++v2 )
          {
            if ( !v7 )
              break;
            *k = v7;
            v7 = v2[1];
            ++k;
          }
          *k = 0;
          if ( v2 )
            ++v2;
          v9 = *v2;
          for ( l = v25; v9 != 58; ++v2 )
          {
            if ( !v9 )
              break;
            *l = v9;
            v9 = v2[1];
            ++l;
          }
          *l = 0;
          if ( v2 )
            ++v2;
          v11 = *v2;
          for ( m = v27; v11 >= 32; ++v2 )
          {
            *m = v11;
            v11 = v2[1];
            ++m;
          }
          *m = 0;
          v13 = 338 * dword_4D9DD4;
          byte_439FC0[v13] = v21;
          byte_439FC1[v13] = v22;
          v14 = &dword_439E70[v13];
          strncpy(&dword_439E70[v13], v24, 0x20u);
          v14[31] = 0;
          v15 = &byte_439E90 + 338 * dword_4D9DD4;
          strncpy(v15, v23, 0x28u);
          v15[39] = 0;
          v16 = &byte_439EC0 + 338 * dword_4D9DD4;
          strncpy(v16, v27, 0x100u);
          v16[255] = 0;
          v17 = dword_4D9DD4;
          v18 = 338 * dword_4D9DD4;
          if ( v26[0] )
          {
            v19 = atoi(v26);
            v17 = dword_4D9DD4;
            *(int *)((char *)&dword_439EB8 + v18) = v19;
          }
          else
          {
            *(int *)((char *)&dword_439EB8 + 338 * dword_4D9DD4) = -999;
          }
          if ( v25[0] )
          {
            v20 = atoi(v25);
            v17 = dword_4D9DD4;
            *(int *)((char *)&dword_439EBC + 338 * dword_4D9DD4) = v20;
          }
          else
          {
            *(int *)((char *)&dword_439EBC + v18) = -999;
          }
          dword_4D9DD4 = v17 + 1;
        }
      }
      while ( (*(_BYTE *)(v1 + 12) & 0x10) == 0 );
    }
    fclose(v1);
  }
  printf("Template.sss read, %d entries found\n", dword_4D9DD4);
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41EC60: using guessed type _DWORD __cdecl fgets(_DWORD, _DWORD, _DWORD);
// 439EB8: using guessed type int dword_439EB8;
// 439EBC: using guessed type int dword_439EBC;
// 4D9DD4: using guessed type int dword_4D9DD4;

//----- (0041AA20) --------------------------------------------------------
int __cdecl sub_41AA20()
{
  int v0; // ebx
  struct BMP_FILE_STRUCT *v1; // eax
  struct BMP_FILE_STRUCT *v2; // eax
  int result; // eax
  int v4; // ebp
  unsigned int v5; // edx
  int i; // edi
  int j; // esi
  int v8; // ecx
  unsigned int v9; // [esp+10h] [ebp-24h] BYREF
  int v10[4]; // [esp+14h] [ebp-20h] BYREF
  char v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+30h] [ebp-4h]

  v0 = 0;
  if ( _access(&aMisc_DefaultLevelFile, 0) )
  {
    printf(
      "Could not find specified level file (%s), make sure a level file with this name is in the server directory.",
      &aMisc_DefaultLevelFile);
    exit(1);
  }
  v10[0] = 42;
  v10[1] = 0;
  v10[2] = 0;
  v10[3] = 0;
  v11 = 0;
  strcpy((char *)v10 + 1, &aMisc_DefaultLevelFile);
  dword_438DFC = (int)CompressFile(&aMisc_DefaultLevelFile, &dword_4D9DE0, &dword_4399E8, v10, 0x11u, 1, 0);
  v1 = (struct BMP_FILE_STRUCT *)operator new(0x110u);
  v9 = (unsigned int)v1;
  v12 = 0;
  if ( v1 )
    LoadBMPHeader(v1, &aMisc_DefaultLevelFile);
  else
    v2 = 0;
  v12 = -1;
  BMPFile = v2;
  big_global_buffer = (int)emalloc(0x100000);
  memset((void *)big_global_buffer, 0, 0x100000u);
  result = sub_406BE0(BMPFile);
  v4 = result;
  if ( result > 0 )
  {
    do
    {
      GetTileValue(BMPFile, v0, (int *)&v9);
      result = v9;
      if ( (v9 & 0xFF000000) != -1442840576 )
      {
        *(_BYTE *)((v9 & 0xFFF) + (((v9 >> 12) & 0xFFF) << 10) + big_global_buffer) = HIBYTE(v9);
        v5 = v9;
        result = v9 & 0xFF000000;
        if ( (v9 & 0xFF000000) >= 0xD8000000 )
        {
          for ( i = 0; i < 7; ++i )
          {
            for ( j = 0; j < 7; ++j )
            {
              v8 = i + (v5 & 0xFFF);
              result = j + ((v5 >> 12) & 0xFFF);
              if ( v8 < 1024 && result < 1024 )
              {
                result = big_global_buffer + v8 + (result << 10);
                if ( !*(_BYTE *)result )
                {
                  *(_BYTE *)result = -16;
                  v5 = v9;
                }
              }
            }
          }
        }
      }
      ++v0;
    }
    while ( v0 < v4 );
  }
  return result;
}
// 41AB07: variable 'v2' is possibly undefined
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);
// 4399E8: using guessed type int dword_4399E8;
// 4D9DE0: using guessed type int dword_4D9DE0;

//----- (0041AC10) --------------------------------------------------------
void __cdecl LoadAdvertisements()
{
  int v0; // esi
  HANDLE v1; // ebx
  int v2; // esi
  int v3; // edi
  int v4; // ebp
  char *v5; // ebx
  int v6; // eax
  int v7; // esi
  _BOOL1 v8; // zf
  int v9; // eax
  int v10; // eax
  int v11; // esi
  HANDLE v12; // ebx
  int v13; // esi
  int v14; // edi
  int v15; // ebp
  char *v16; // ebx
  int v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // eax
  int v21; // esi
  HANDLE v22; // ebx
  int v23; // esi
  int v24; // edi
  int v25; // ebp
  char *v26; // ebx
  int v27; // eax
  int v28; // esi
  int v29; // eax
  int v30; // eax
  unsigned int v31; // [esp+10h] [ebp-8C0h]
  unsigned int v32; // [esp+10h] [ebp-8C0h]
  unsigned int v33; // [esp+10h] [ebp-8C0h]
  int v34; // [esp+14h] [ebp-8BCh]
  char *v35; // [esp+14h] [ebp-8BCh]
  char *v36; // [esp+14h] [ebp-8BCh]
  char *v37; // [esp+18h] [ebp-8B8h]
  int v38; // [esp+18h] [ebp-8B8h]
  int v39; // [esp+18h] [ebp-8B8h]
  int v40; // [esp+1Ch] [ebp-8B4h]
  int v41; // [esp+1Ch] [ebp-8B4h]
  int v42; // [esp+1Ch] [ebp-8B4h]
  int v43; // [esp+20h] [ebp-8B0h]
  int v44; // [esp+20h] [ebp-8B0h]
  int v45; // [esp+20h] [ebp-8B0h]
  int v46; // [esp+24h] [ebp-8ACh]
  int v47; // [esp+24h] [ebp-8ACh]
  int v48; // [esp+24h] [ebp-8ACh]
  char v49[10]; // [esp+28h] [ebp-8A8h] BYREF
  LONG lDistanceToMove; // [esp+32h] [ebp-89Eh]
  char v51[4]; // [esp+38h] [ebp-898h] BYREF
  unsigned int v52; // [esp+3Ch] [ebp-894h]
  int v53; // [esp+40h] [ebp-890h]
  CHAR FileName[128]; // [esp+50h] [ebp-880h] BYREF
  char v55[2048]; // [esp+D0h] [ebp-800h] BYREF

  v0 = 0;
  dword_4D9DEC = 0;
  dword_4D9DF0 = 0;
  dword_4D9DF4 = 0;
  v43 = 0;
  do
  {
    sprintf(FileName, "b_ad%d.bmp", v0);
    if ( _access(FileName, 0) )
    {
      v10 = dword_4D9DF4;
    }
    else
    {
      v1 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v1, 24, v51);
      v2 = v53;
      v31 = v52;
      v3 = 4 * ((int)(v52 + 3) / 4);
      v46 = v3;
      DeleteObject(v1);
      v4 = v31 * v2 + 10;
      v5 = (char *)emalloc(v4);
      *v5 = 48;
      v5[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v5 + 1) = v31;
      *((_WORD *)v5 + 2) = v2;
      *(_DWORD *)(v5 + 6) = dwAdvertise_Duration;
      v6 = fopen(FileName, "rb");
      v34 = v6;
      if ( v6 )
      {
        fread(v49, 1, 14, v6);
        fseek(v34, lDistanceToMove, 0);
        v7 = v2 - 1;
        if ( v7 >= 0 )
        {
          v37 = &v5[v31 * v7 + 10];
          v40 = v7 + 1;
          while ( 1 )
          {
            fread(v55, 1, v3, v34);
            qmemcpy(v37, v55, v31);
            v8 = v40 == 1;
            v37 -= v31;
            --v40;
            if ( v8 )
              break;
            v3 = v46;
          }
        }
        fclose(v34);
      }
      v9 = dword_4D9DF4;
      v0 = v43;
      dword_438FA4[2 * dword_4D9DF4] = v4;
      *(&dword_438FA0 + 2 * v9) = v5;
      v10 = v9 + 1;
      dword_4D9DF4 = v10;
    }
    v43 = ++v0;
  }
  while ( v0 < 128 );
  printf("%d both advertisements found\n", v10);
  v11 = 0;
  v44 = 0;
  do
  {
    sprintf(FileName, "s_ad%d.bmp", v11);
    if ( _access(FileName, 0) )
    {
      v20 = dword_4D9DEC;
    }
    else
    {
      v12 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v12, 24, v51);
      v13 = v53;
      v32 = v52;
      v14 = 4 * ((int)(v52 + 3) / 4);
      v47 = v14;
      DeleteObject(v12);
      v15 = v32 * v13 + 10;
      v16 = (char *)emalloc(v15);
      *v16 = 48;
      v16[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v16 + 1) = v32;
      *((_WORD *)v16 + 2) = v13;
      *(_DWORD *)(v16 + 6) = dwAdvertise_Duration;
      v17 = fopen(FileName, "rb");
      v38 = v17;
      if ( v17 )
      {
        fread(v49, 1, 14, v17);
        fseek(v38, lDistanceToMove, 0);
        v18 = v13 - 1;
        if ( v18 >= 0 )
        {
          v35 = &v16[v32 * v18 + 10];
          v41 = v18 + 1;
          while ( 1 )
          {
            fread(v55, 1, v14, v38);
            qmemcpy(v35, v55, v32);
            v8 = v41 == 1;
            v35 -= v32;
            --v41;
            if ( v8 )
              break;
            v14 = v47;
          }
        }
        fclose(v38);
      }
      v19 = dword_4D9DEC;
      v11 = v44;
      buf_sz[2 * dword_4D9DEC] = v15;
      *(&buf + 2 * v19) = v16;
      v20 = v19 + 1;
      dword_4D9DEC = v20;
    }
    v44 = ++v11;
  }
  while ( v11 < 128 );
  printf("%d shareware advertisements found\n", v20);
  v21 = 0;
  v45 = 0;
  do
  {
    sprintf(FileName, "r_ad%d.bmp", v21);
    if ( _access(FileName, 0) )
    {
      v30 = dword_4D9DF0;
    }
    else
    {
      v22 = LoadImageA(0, FileName, 0, 0, 0, 0x2010u);
      GetObjectA(v22, 24, v51);
      v23 = v53;
      v33 = v52;
      v24 = 4 * ((int)(v52 + 3) / 4);
      v48 = v24;
      DeleteObject(v22);
      v25 = v33 * v23 + 10;
      v26 = (char *)emalloc(v25);
      *v26 = 48;
      v26[1] = dwAdvertise_DisplayMode;
      *((_WORD *)v26 + 1) = v33;
      *((_WORD *)v26 + 2) = v23;
      *(_DWORD *)(v26 + 6) = dwAdvertise_Duration;
      v27 = fopen(FileName, "rb");
      v39 = v27;
      if ( v27 )
      {
        fread(v49, 1, 14, v27);
        fseek(v39, lDistanceToMove, 0);
        v28 = v23 - 1;
        if ( v28 >= 0 )
        {
          v36 = &v26[v33 * v28 + 10];
          v42 = v28 + 1;
          while ( 1 )
          {
            fread(v55, 1, v24, v39);
            qmemcpy(v36, v55, v33);
            v8 = v42 == 1;
            v36 -= v33;
            --v42;
            if ( v8 )
              break;
            v24 = v48;
          }
        }
        fclose(v39);
      }
      v29 = dword_4D9DF0;
      v21 = v45;
      dword_432AAC[2 * dword_4D9DF0] = v25;
      *(&dword_432AA8 + 2 * v29) = v26;
      v30 = v29 + 1;
      dword_4D9DF0 = v30;
    }
    v45 = ++v21;
  }
  while ( v21 < 128 );
  printf("%d registered advertisements found\n", v30);
}
// 41DA90: using guessed type _DWORD printf(const char *, ...);
// 41DC00: using guessed type _DWORD sprintf(_DWORD, const char *, ...);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 4D9C20: using guessed type int dwAdvertise_Duration;
// 4D9DC8: using guessed type int dwAdvertise_DisplayMode;
// 4D9DEC: using guessed type int dword_4D9DEC;
// 4D9DF0: using guessed type int dword_4D9DF0;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0041B150) --------------------------------------------------------
void __cdecl CleanUpMemory()
{
  int v0; // esi
  LPVOID *v1; // edi
  int v2; // edi
  LPVOID *v3; // esi
  int v4; // edi
  LPVOID *v5; // esi

  v0 = 0;
  if ( dword_4D9DF0 > 0 )
  {
    v1 = &dword_432AA8;
    do
    {
      if ( *v1 )
        efree(*v1);
      ++v0;
      v1 += 2;
    }
    while ( v0 < dword_4D9DF0 );
  }
  v2 = 0;
  dword_4D9DF0 = 0;
  if ( dword_4D9DEC > 0 )
  {
    v3 = &buf;
    do
    {
      if ( *v3 )
        efree(*v3);
      ++v2;
      v3 += 2;
    }
    while ( v2 < dword_4D9DEC );
  }
  v4 = 0;
  dword_4D9DEC = 0;
  if ( dword_4D9DF4 > 0 )
  {
    v5 = &dword_438FA0;
    do
    {
      if ( *v5 )
        efree(*v5);
      ++v4;
      v5 += 2;
    }
    while ( v4 < dword_4D9DF4 );
  }
  dword_4D9DF4 = 0;
}
// 4D9DEC: using guessed type int dword_4D9DEC;
// 4D9DF0: using guessed type int dword_4D9DF0;
// 4D9DF4: using guessed type int dword_4D9DF4;

//----- (0041B200) --------------------------------------------------------
int __cdecl InitWinsock()
{
  struct WSAData WSAData; // [esp+0h] [ebp-190h] BYREF

  return WSAStartup(0x101u, &WSAData);
}

//----- (0041B230) --------------------------------------------------------
int *__thiscall setup_stuff_and_socket(int *this, int lpfnNewConnectionRequest, int lpfnOnEachPacket, int a4, int a5, int dwSendBufSz, int dwRecvBufSz, int optval)
{
  int v9; // eax
  void *v10; // edi
  int v11; // eax
  int v12; // edi
  char *v13; // eax
  _DWORD *v14; // ecx
  int v15; // edx
  void *v16; // edi
  int v17; // ecx
  int v18; // eax
  SOCKET v19; // eax
  u_short v20; // cx
  SOCKET v22; // [esp-14h] [ebp-34h]
  SOCKET v23; // [esp-14h] [ebp-34h]
  SOCKET v24; // [esp-14h] [ebp-34h]
  u_long argp; // [esp+Ch] [ebp-14h] BYREF
  struct sockaddr name; // [esp+10h] [ebp-10h] BYREF

  v9 = optval + 5;
  this[11] = optval + 5;
  this[12] = 0;
  v10 = emalloc(540 * v9);
  v11 = this[11];
  this[10] = (int)v10;
  memset(v10, 0, 4 * ((unsigned int)(540 * v11) >> 2));
  *this = lpfnNewConnectionRequest;
  this[8] = 0;
  this[8980] = 0;
  this[1] = lpfnOnEachPacket;
  this[3] = a4;
  this[2] = a5;
  this[8979] = ((int (*)(void))GetTickCount)() / 0xAu;
  this[9] = 500;
  this[8975] = 0;
  this[8976] = 0;
  this[8977] = 0;
  this[8978] = 0;
  this[4] = 0;
  memset(this + 13, 0, 0x8C00u);
  v12 = this[3];
  this[8974] = 0;
  this[8973] = 0;
  v13 = (char *)operator new(3190 * v12);
  if ( v13 )
  {
    if ( v12 - 1 >= 0 )
    {
      v14 = v13 + 50;
      v15 = v12;
      do
      {
        *v14 = 0;
        v14 = (_DWORD *)((char *)v14 + 3190);
        --v15;
      }
      while ( v15 );
    }
    v16 = v13;
  }
  else
  {
    v16 = 0;
  }
  v17 = this[3];
  this[5] = (int)v16;
  memset(v16, 0, 3190 * v17);
  v18 = this[3];
  this[8982] = 0;
  this[8981] = (int)emalloc(4 * v18);
  v19 = socket(AF_INET, SOCK_DGRAM, 0);
  this[6] = v19;
  argp = 1;
  ioctlsocket(v19, -2147195266, &argp);
  v22 = this[6];
  optval = -1;
  setsockopt(v22, 6, SO_DEBUG, (const char *)&optval, 4);
  v23 = this[6];
  optval = dwSendBufSz;
  setsockopt(v23, 0xFFFF, SO_SNDBUF, (const char *)&optval, 4);
  v24 = this[6];
  optval = dwRecvBufSz;
  setsockopt(v24, 0xFFFF, SO_RCVBUF, (const char *)&optval, 4);
  v20 = *((_WORD *)this + 4);
  name.sa_family = 2;
  *(_WORD *)name.sa_data = ntohs(v20);
  *(_DWORD *)&name.sa_data[2] = ntohl(0);
  bind(this[6], &name, 16);
  return this;
}
// 4DC214: invalid function type has been ignored
// 41E6C0: using guessed type void *__cdecl operator new(unsigned int);

//----- (0041B440) --------------------------------------------------------
void __thiscall CleanUpPacketAttachment(struct PACKET_ATTACHMENT *packetAttachment)
{
  int v2; // ebx
  int i; // esi
  int v4; // ebx
  LPVOID *v5; // esi

  v2 = 0;
  for ( i = *((_DWORD *)packetAttachment + 5); v2 < *((_DWORD *)packetAttachment + 3); i += 3190 )
  {
    if ( *(_DWORD *)(i + 50) )
      sub_41C360(i);
    ++v2;
  }
  closesocket(*((_DWORD *)packetAttachment + 6));
  operator delete(*((void **)packetAttachment + 5));
  v4 = 0;
  if ( *((int *)packetAttachment + 8974) > 0 )
  {
    v5 = (LPVOID *)((char *)packetAttachment + 180);
    do
    {
      if ( *v5 )
      {
        efree(*v5);
        *v5 = 0;
      }
      ++v4;
      v5 += 35;
    }
    while ( v4 < *((_DWORD *)packetAttachment + 8974) );
  }
  efree(*((LPVOID *)packetAttachment + 8981));
  efree(*((LPVOID *)packetAttachment + 10));
}

//----- (0041B4E0) --------------------------------------------------------
int __thiscall SetPacketAttachmentEncryptMode(int this, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(this + 32) = a2;
  return result;
}

//----- (0041B4F0) --------------------------------------------------------
struct CONNECTION *__thiscall SomethingBillerServer(PACKET_ATTACHMENT *packetAttachment, const char *name, u_short hostshort, int a4, int a5)
{
  const char *v5; // edi
  int v7; // ebp
  struct hostent *v8; // eax
  int v9; // ecx
  int v10; // edi
  _DWORD *v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  unsigned int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v21; // [esp-10h] [ebp-2Ch]
  int v22; // [esp-Ch] [ebp-28h]
  int v23; // [esp-4h] [ebp-20h]
  int ElementToFind; // [esp+10h] [ebp-Ch] BYREF
  __int16 v25; // [esp+14h] [ebp-8h]
  int v26; // [esp+16h] [ebp-6h]

  v5 = name;
  v7 = inet_addr(name);
  if ( v7 == -1 )
  {
    v8 = gethostbyname(v5);
    if ( !v8 )
      return 0;
    v7 = **(_DWORD **)v8->h_addr_list;
  }
  v9 = *((_DWORD *)packetAttachment + 3);
  v10 = 0;
  if ( v9 <= 0 )
  {
LABEL_8:
    v10 = -1;
  }
  else
  {
    v11 = (_DWORD *)(*((_DWORD *)packetAttachment + 5) + 50);
    while ( *v11 )
    {
      ++v10;
      v11 = (_DWORD *)((char *)v11 + 3190);
      if ( v10 >= v9 )
        goto LABEL_8;
    }
  }
  if ( v10 == -1 )
    return 0;
  v23 = a5;
  v12 = *((_DWORD *)packetAttachment + 5) + 3190 * v10;
  v22 = a4;
  LOWORD(v13) = ntohs(hostshort);
  encrypt_init((char *)v12, (int)packetAttachment, 1, v10, v7, v13, v22, 1, v23);
  v14 = *((_DWORD *)packetAttachment + 8982);
  v15 = 0;
  if ( v14 )
  {
    v16 = *(_DWORD *)v12;
    v25 = *(_WORD *)(v12 + 4);
    ElementToFind = v16;
    v21 = v14;
    v17 = *((_DWORD *)packetAttachment + 8981);
    v26 = *(_DWORD *)(v12 + 46);
    v18 = BinarySearch((int)&ElementToFind, v17, v21, 4, DifferentCompareFunction, (unsigned int *)&name);
    v19 = *((_DWORD *)packetAttachment + 8981);
    v15 = (v18 - v19) >> 2;
    memcpy(
      (void *)(v19 + 4 * v15 + 4),
      (const void *)(v19 + 4 * v15),
      4 * (*((_DWORD *)packetAttachment + 8982) + 0x3FFFFFFF * v15));
  }
  *(_DWORD *)(*((_DWORD *)packetAttachment + 8981) + 4 * v15) = v12;
  ++*((_DWORD *)packetAttachment + 8982);
  return (struct CONNECTION *)v12;
}
// 41B578: variable 'v13' is possibly undefined

//----- (0041B620) --------------------------------------------------------
void __thiscall DumpPacketHistory(struct PACKET_ATTACHMENT *packetAttachment, const char *Filename)
{
  int v3; // eax
  int v4; // ecx
  int v5; // ebp
  int v6; // edx
  int v7; // ecx
  int v8; // esi
  int v9; // edi
  struct in_addr *v10; // ebp
  const char *v11; // eax
  int v12; // [esp+0h] [ebp-4h]
  int v13; // [esp+8h] [ebp+4h]

  v3 = fopen(Filename, "wt");
  v12 = v3;
  if ( v3 )
  {
    v4 = *((_DWORD *)packetAttachment + 11);
    v5 = 0;
    v13 = 0;
    if ( v4 > 0 )
    {
      do
      {
        v6 = (*((_DWORD *)packetAttachment + 12) + v5) % v4;
        v7 = *((_DWORD *)packetAttachment + 10);
        v8 = 540 * v6;
        v9 = *(__int16 *)(v7 + 540 * v6 + 536);
        if ( v9 > 0 )
        {
          v10 = (struct in_addr *)(v7 + 540 * v6);
          v11 = inet_ntoa(v10[133]);
          fprintf(v12, "%16s,%5d %3d: ", v11, *(__int16 *)(*((_DWORD *)packetAttachment + 10) + v8 + 538), v9);
          do
          {
            fprintf(v12, "%02x ", v10->S_un.S_un_b.s_b1);
            v10 = (struct in_addr *)((char *)v10 + 1);
            --v9;
          }
          while ( v9 );
          fprintf(v12, (const char *)L"\n");
          v5 = v13;
        }
        v4 = *((_DWORD *)packetAttachment + 11);
        v13 = ++v5;
      }
      while ( v5 < v4 );
      v3 = v12;
    }
    fclose(v3);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (0041B700) --------------------------------------------------------
char *__thiscall PlayerReadPackets(struct PACKET_ATTACHMENT *packetAttachment, int *RecvLength, int *RemoteIP, int *RemotePort)
{
  int v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  char *result; // eax
  int v13; // [esp+8h] [ebp-14h] BYREF
  char v14[2]; // [esp+Ch] [ebp-10h] BYREF
  __int16 v15; // [esp+Eh] [ebp-Eh]
  int v16; // [esp+10h] [ebp-Ch]

  v5 = *((_DWORD *)packetAttachment + 12);
  v6 = *(_DWORD *)CONTAINING_RECORD(packetAttachment, PLAYER, field_4)->field_2C;
  v13 = 16;
  v7 = 540 * v5;
  v8 = HackedRecvFrom(*((_DWORD *)packetAttachment + 6), 540 * v5 + v6, 512, 0, (int)v14, (int)&v13);
  v9 = v8;
  if ( v8 == -1 )
    return 0;
  *(_WORD *)(*((_DWORD *)packetAttachment + 0xA) + v7 + 536) = v8;
  v10 = *((_DWORD *)packetAttachment + 0xA);
  *((_DWORD *)packetAttachment + 12) = (*((_DWORD *)packetAttachment + 12) + 1) % *((_DWORD *)packetAttachment + 0xB);
  *(_DWORD *)(v10 + v7 + 532) = v16;
  *(_WORD *)(*((_DWORD *)packetAttachment + 0xA) + v7 + 538) = v15;
  *RemoteIP = v16;
  *(_WORD *)RemotePort = v15;
  *RecvLength = v9;
  v11 = *((_DWORD *)packetAttachment + 8978);
  *((_DWORD *)packetAttachment + 8977) += v9;
  result = (char *)(v7 + *((_DWORD *)packetAttachment + 0xA));
  *((_DWORD *)packetAttachment + 8978) = v11 + 1;
  return result;
}

//----- (0041B7D0) --------------------------------------------------------
#error "41B8C4: call analysis failed (funcsize=121)"

//----- (0041B930) --------------------------------------------------------
void __thiscall PlayerHandlePacket(PLAYER *p, BYTE *packet, DWORD dwBytesRead, DWORD dwIPAddress, int wSrcPort)
{
  int v6; // eax
  int *v7; // eax
  int v8; // ebp
  unsigned int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  _DWORD *v15; // eax
  unsigned int v16; // kr00_4
  unsigned int v17; // eax
  unsigned int v18; // [esp-4h] [ebp-38h]
  unsigned int v19; // [esp+20h] [ebp-14h] BYREF
  DWORD v20; // [esp+28h] [ebp-Ch] BYREF
  __int16 v21; // [esp+2Ch] [ebp-8h]
  int v22; // [esp+2Eh] [ebp-6h]
  int v23; // [esp+38h] [ebp+4h]

  v20 = dwIPAddress;
  v6 = *(_DWORD *)&p[27].field_2C[1];
  v21 = wSrcPort;
  v18 = *(int *)((char *)&p[27].lpNetworkData + 1);
  v22 = -1;
  v7 = (int *)BinarySearch((int)&v20, v18, v6, 4, DifferentCompareFunction, &v19);
  if ( v19 )
    v8 = *v7;
  else
    v8 = 0;
  if ( *packet || packet[1] != 1 )
  {
    if ( v8 )
    {
      v16 = ((int (*)(void))GetTickCount)();
      ++*(_DWORD *)(v8 + 2670);
      v17 = *(_DWORD *)(v8 + 66);
      *(_DWORD *)(v8 + 58) = v16 / 0xA;
      if ( v17 >= 0x10 )
        sub_415870(v8, (int)packet, dwBytesRead, dwIPAddress, wSrcPort);
      else
        sub_415920(v8, (int)packet, dwBytesRead, dwIPAddress, wSrcPort);
    }
    return;
  }
  v23 = 0;
  if ( (int)dwBytesRead >= 8 )
    v23 = *((__int16 *)packet + 3);
  if ( v23 != 1 )
    goto LABEL_9;
  v11 = *(_DWORD *)p->lpArenaPointer2;
  if ( v11 )
  {
    v12 = v11 - 1;
    if ( !v12 )
    {
      v10 = abs32(*(_DWORD *)(packet + 2));
      goto LABEL_15;
    }
    if ( v12 == 1 )
    {
LABEL_9:
      v10 = -abs32(*(_DWORD *)(packet + 2));
LABEL_15:
      *(_DWORD *)(packet + 2) = v10;
    }
  }
  if ( v8 && *(_DWORD *)(v8 + 62) == *(_DWORD *)(packet + 2) )
  {
    lpfnFixExport11(&v19, v8, *(_DWORD *)(packet + 2));
  }
  else
  {
    v13 = *(_DWORD *)&p->field_4[8];
    v14 = 0;
    if ( v13 <= 0 )
    {
LABEL_23:
      v14 = -1;
    }
    else
    {
      v15 = (_DWORD *)(*(_DWORD *)&p->field_14 + 50);
      while ( *v15 )
      {
        ++v14;
        v15 = (_DWORD *)((char *)v15 + 3190);
        if ( v14 >= v13 )
          goto LABEL_23;
      }
    }
    if ( v14 != -1 )
    {
      if ( p->hProcess )
        sub_415850(
          (char *)(*(_DWORD *)&p->field_14 + 3190 * v14),
          (int)packet,
          *(_DWORD *)&p->field_14 + 3190 * v14,
          v23,
          dwBytesRead,
          dwIPAddress,
          wSrcPort);
    }
  }
}
// 4DC214: invalid function type has been ignored
// 42EEB8: using guessed type int (__thiscall *lpfnFixExport11)(_DWORD, _DWORD, _DWORD);

//----- (0041BC40) --------------------------------------------------------
void __thiscall ProcessRegularPackets(struct PACKET_ATTACHMENT *packetAttachment, char *buffer, int packetLength, struct CONNECTION *encryption, int a5)
{
  void (__cdecl *v6)(char *, int, struct CONNECTION *); // eax
  char *v7; // ebp
  int v8; // ecx
  char *v9; // esi
  char *v10; // edi

  v6 = (void (__cdecl *)(char *, int, struct CONNECTION *))*((_DWORD *)packetAttachment + 1);
  if ( v6 )
  {
    v7 = buffer;
    v6(buffer, packetLength, encryption);
  }
  else
  {
    *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 46) = packetLength;
    *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 47) = encryption;
    if ( a5 )
    {
      v7 = buffer;
      a5 = 0;
      *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = buffer;
    }
    else
    {
      v7 = buffer;
      if ( (unsigned int)packetLength >= 0x80 )
      {
        *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = emalloc(packetLength);
        v8 = packetLength;
        v9 = buffer;
        v10 = (char *)*((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45);
      }
      else
      {
        v8 = packetLength;
        v9 = buffer;
        *((_DWORD *)packetAttachment + 35 * *((_DWORD *)packetAttachment + 8974) + 45) = 0;
        v10 = (char *)packetAttachment + 140 * *((_DWORD *)packetAttachment + 8974) + 52;
      }
      qmemcpy(v10, v9, v8);
    }
    ++*((_DWORD *)packetAttachment + 8974);
  }
  if ( a5 )
    efree(v7);
}

//----- (0041BD80) --------------------------------------------------------
#error "41BEDB: call analysis failed (funcsize=170)"

//----- (0041BFA0) --------------------------------------------------------
int __thiscall sub_41BFA0(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[8975] = 0;
  this[8976] = 0;
  this[8977] = 0;
  this[8978] = 0;
  this[4] = 0;
  return result;
}

//----- (0041BFC0) --------------------------------------------------------
void __thiscall GetPacketStatistics(struct PACKET_ATTACHMENT *packetAttachment, int *TotalPacketSendLength, int *TotalPacketSendCalls, int *TotalPacketRecvLength, int *TotalPacketRecvCalls, int *TotalPacketClustersCalls)
{
  *TotalPacketSendLength = *((_DWORD *)packetAttachment + 8975);
  *TotalPacketRecvLength = *((_DWORD *)packetAttachment + 8977);
  *TotalPacketSendCalls = *((_DWORD *)packetAttachment + 8976);
  *TotalPacketRecvCalls = *((_DWORD *)packetAttachment + 8978);
  *TotalPacketClustersCalls = *((_DWORD *)packetAttachment + 4);
}

//----- (0041C000) --------------------------------------------------------
#error "41C06A: call analysis failed (funcsize=51)"

//----- (0041C0B0) --------------------------------------------------------
#error "41C11A: call analysis failed (funcsize=46)"

//----- (0041C150) --------------------------------------------------------
int __cdecl DifferentCompareFunction(int connection, int ConnectionsArray)
{
  unsigned int *v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  int v5; // edx

  v2 = *(unsigned int **)ConnectionsArray;
  v3 = **(_DWORD **)ConnectionsArray;
  if ( *(_DWORD *)connection > v3 )
    return 1;
  if ( *(_DWORD *)connection < v3 )
    return -1;
  v5 = *(_DWORD *)(connection + 6);
  result = *(unsigned __int16 *)(connection + 4) - *((unsigned __int16 *)v2 + 2);
  if ( v5 != -1 && !result )
    result = v5 - *(unsigned int *)((char *)v2 + 46);
  return result;
}

//----- (0041C1A0) --------------------------------------------------------
int __thiscall encrypt_init(char *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v10; // ecx
  _WORD *v11; // edi
  int v12; // edx
  int result; // eax
  int v14; // [esp+20h] [ebp+14h]

  *(_DWORD *)(this + 66) = a8;
  *(_DWORD *)(this + 42) = a2;
  *(_DWORD *)(this + 50) = a3;
  *(_DWORD *)(this + 46) = a4;
  *(_DWORD *)this = a5;
  v10 = a7;
  *((_WORD *)this + 2) = a6;
  *(_DWORD *)(this + 6) = a9;
  *(_DWORD *)(this + 10) = 9999999;
  *(_DWORD *)(this + 14) = 0;
  *(_DWORD *)(this + 18) = 0;
  *(_DWORD *)(this + 22) = 0;
  *(_DWORD *)(this + 26) = 0;
  *(_DWORD *)(this + 30) = 0;
  *(_DWORD *)(this + 34) = 0;
  *(_DWORD *)(this + 38) = 0;
  *(_DWORD *)(this + 62) = a7;
  v11 = this + 70;
  v14 = 260;
  do
  {
    v12 = 16807 * (v10 % 127773) - 2836 * (v10 / 127773) + 123;
    v10 = v12;
    if ( v12 <= 0 )
      v10 = v12 + 0x7FFFFFFF;
    *v11++ = v10;
    --v14;
  }
  while ( v14 );
  *(_DWORD *)(this + 54) = 0;
  *(_DWORD *)(this + 58) = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)(this + 54) = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)(this + 590) = 0;
  *(_DWORD *)(this + 594) = 0;
  *(_DWORD *)(this + 2690) = 0;
  *(_DWORD *)(this + 2694) = 0;
  *(_DWORD *)(this + 2698) = 0;
  *(_DWORD *)(this + 2702) = ((int (*)(void))GetTickCount)() / 0xAu;
  *(_DWORD *)(this + 598) = 0;
  *(_DWORD *)(this + 602) = 0;
  *(_DWORD *)(this + 606) = 0;
  *(_DWORD *)(this + 614) = 0;
  *(_DWORD *)(this + 610) = 0;
  memset(this + 618, 0, 0x400u);
  memset(this + 1642, 0, 0x400u);
  *(_DWORD *)(this + 2682) = 1000;
  *(_DWORD *)(this + 2686) = 1000;
  *(_DWORD *)(this + 3090) = this + 2706;
  result = 0;
  *(_DWORD *)(this + 2666) = 0;
  *(_DWORD *)(this + 2670) = 0;
  *(_DWORD *)(this + 2674) = 0;
  *(_DWORD *)(this + 2678) = 0;
  memset(this + 3094, 0, 0x50u);
  *(_DWORD *)(this + 3174) = 0;
  *(_DWORD *)(this + 3178) = 0;
  *(_DWORD *)(this + 3182) = 0;
  *(_DWORD *)(this + 3186) = 0;
  return result;
}
// 4DC214: invalid function type has been ignored

//----- (0041C360) --------------------------------------------------------
void *__thiscall sub_41C360(int this)
{
  int v2; // eax
  int v3; // ebp
  int v4; // esi
  void *v5; // eax
  LPVOID *v6; // esi
  int v7; // ebp
  int v8; // esi
  __int16 v9; // dx
  int v10; // eax
  int v11; // edx
  void *result; // eax
  int v13; // ecx
  int v14; // esi
  char *v15; // [esp-8h] [ebp-28h]
  int v16; // [esp-4h] [ebp-24h]
  int v17; // [esp+0h] [ebp-20h]
  int v18; // [esp+4h] [ebp-1Ch]
  int v19; // [esp+8h] [ebp-18h]
  int v20; // [esp+Ch] [ebp-14h]
  char buf[4]; // [esp+10h] [ebp-10h] BYREF
  int ElementToFind; // [esp+14h] [ebp-Ch] BYREF
  __int16 v23; // [esp+18h] [ebp-8h]
  int v24; // [esp+1Ah] [ebp-6h]

  v2 = *(_DWORD *)(this + 3090) - this - 2706;
  if ( v2 > 2 )
  {
    if ( *(unsigned __int8 *)(this + 2708) + 3 == v2 )
    {
      v16 = *(_DWORD *)(this + 3090) - this - 2709;
      v15 = (char *)(this + 2709);
    }
    else
    {
      v16 = *(_DWORD *)(this + 3090) - this - 2706;
      v15 = (char *)(this + 2706);
    }
    WriteToNetwork(this, v15, v16, v17, v18, v19, v20, *(int *)buf, ElementToFind, v23);
    *(_DWORD *)(this + 3090) = this + 2706;
  }
  if ( *(_DWORD *)(this + 50) == 2 )
  {
    buf[0] = 0;
    buf[1] = 7;
    WriteToNetwork(this, buf, 2, v17, v18, v19, v20, *(int *)buf, ElementToFind, v23);
  }
  v3 = 0;
  if ( *(int *)(this + 3174) > 0 )
  {
    v4 = this + 3094;
    do
    {
      if ( *(_DWORD *)(v4 + 12) )
        efree(*(LPVOID *)v4);
      ++v3;
      v4 += 20;
    }
    while ( v3 < *(_DWORD *)(this + 3174) );
  }
  v5 = *(void **)(this + 3178);
  *(_DWORD *)(this + 3174) = 0;
  if ( v5 )
    efree(v5);
  *(_DWORD *)(this + 3178) = 0;
  *(_DWORD *)(this + 3182) = 0;
  *(_DWORD *)(this + 3186) = 0;
  v6 = (LPVOID *)(this + 618);
  v7 = 256;
  do
  {
    if ( v6[256] )
    {
      efree(v6[256]);
      v6[256] = 0;
    }
    if ( *v6 )
    {
      efree(*v6);
      *v6 = 0;
    }
    ++v6;
    --v7;
  }
  while ( v7 );
  if ( *(_DWORD *)(this + 594) )
  {
    efree(*(LPVOID *)(this + 594));
    *(_DWORD *)(this + 594) = 0;
  }
  v8 = *(_DWORD *)(this + 42);
  v9 = *(_WORD *)(this + 4);
  v10 = *(_DWORD *)(this + 46);
  ElementToFind = *(_DWORD *)this;
  v23 = v9;
  v11 = *(_DWORD *)(v8 + 35928);
  v24 = v10;
  result = (void *)BinarySearch(
                     (int)&ElementToFind,
                     *(_DWORD *)(v8 + 35924),
                     v11,
                     4,
                     DifferentCompareFunction,
                     (unsigned int *)buf);
  if ( *(_DWORD *)buf )
  {
    v13 = *(_DWORD *)(v8 + 35928) - 1;
    *(_DWORD *)(v8 + 35928) = v13;
    v14 = *(_DWORD *)(v8 + 35924);
    result = memcpy(
               (void *)(v14 + 4 * (((int)result - v14) >> 2)),
               (const void *)(v14 + 4 * (((int)result - v14) >> 2) + 4),
               4 * (v13 + 0x3FFFFFFF * (((int)result - v14) >> 2)));
  }
  *(_DWORD *)(this + 50) = 0;
  return result;
}
// 41C3A1: variable 'v17' is possibly undefined
// 41C3A1: variable 'v18' is possibly undefined
// 41C3A1: variable 'v19' is possibly undefined
// 41C3A1: variable 'v20' is possibly undefined

//----- (0041C510) --------------------------------------------------------
int __thiscall sub_41C510(int this)
{
  return *(_DWORD *)(this + 50);
}

//----- (0041C520) --------------------------------------------------------
int __thiscall sub_41C520(int this)
{
  return *(_DWORD *)(this + 66);
}

//----- (0041C530) --------------------------------------------------------
// NetworkData.GetRelAckDiff()
int __thiscall GetRelAckDiff(struct CONNECTION *encryption, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = *(_DWORD *)((char *)encryption + 614);
  return CONTAINING_RECORD(encryption, NETDATA, field_0)->current_ack
       - CONTAINING_RECORD(encryption, NETDATA, field_0)->pending_ack;
}

//----- (0041C560) --------------------------------------------------------
// NetworkData.WriteToNetwork
void __userpurge WriteToNetwork(int a1@<ecx>, char *buf, int len, int a4, int a5, int a6, int a7, int a8, int a9, char a10)
{
  int v11; // ebp
  _BOOL1 v12; // cc
  char *v13; // eax
  int v14; // esi
  char *v15; // edx
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  char *v19; // eax
  int v20; // esi
  char *v21; // edx
  int v22; // ecx
  int v23; // esi
  int v24; // edi
  unsigned int v25; // kr00_4
  int v26; // ecx
  int v27; // eax
  __int64 v28; // rax
  int v29; // ecx
  int v30; // edi
  int v31; // edx
  _DWORD *v32; // edi
  __int16 v33; // cx
  int v34; // eax
  SOCKET v35; // [esp-24h] [ebp-43Ch]
  char v36; // [esp+7h] [ebp-411h]
  struct sockaddr to; // [esp+8h] [ebp-410h] BYREF
  char v38; // [esp+18h] [ebp-400h] BYREF
  char v39; // [esp+19h] [ebp-3FFh] BYREF
  char v40[1022]; // [esp+1Ah] [ebp-3FEh] BYREF

  if ( *(_DWORD *)(a1 + 50) != 4 )
  {
    v11 = *(_DWORD *)(a1 + 62);
    if ( *(_DWORD *)(a1 + 66) >= 0x10u )
    {
      sub_4158A0(a1, (int)buf, (int)buf, len, a4, a5, a6, a7, a8, a9, a10);
    }
    else
    {
      v36 = *buf;
      if ( *buf )
      {
LABEL_7:
        qmemcpy(&v38, buf, len);
        if ( v36 )
        {
          v19 = &v39;
          v20 = a1 + 70;
          v21 = &v39 + 4 * ((unsigned int)(len + 2) >> 2);
          v22 = v11;
          if ( &v39 != v21 )
          {
            v23 = v20 - (_DWORD)&v39;
            do
            {
              v24 = *(_DWORD *)&v19[v23];
              v19 += 4;
              v22 ^= v24 ^ *((_DWORD *)v19 - 1);
              *((_DWORD *)v19 - 1) = v22;
            }
            while ( v19 != v21 );
          }
        }
        else
        {
          v13 = v40;
          v14 = a1 + 70;
          v15 = &v40[4 * ((unsigned int)(len + 1) >> 2)];
          v16 = v11;
          if ( v40 != v15 )
          {
            v17 = v14 - (_DWORD)v40;
            do
            {
              v18 = *(_DWORD *)&v13[v17];
              v13 += 4;
              v16 ^= v18 ^ *((_DWORD *)v13 - 1);
              *((_DWORD *)v13 - 1) = v16;
            }
            while ( v13 != v15 );
          }
        }
        buf = &v38;
      }
      else
      {
        v12 = buf[1] <= 2;
        while ( !v12 )
        {
          v12 = v11 <= 0;
          if ( v11 > 0 )
            goto LABEL_7;
        }
      }
      v25 = ((int (*)(void))GetTickCount)();
      v26 = *(_DWORD *)(a1 + 2666) + 1;
      v27 = len + *(_DWORD *)(a1 + 2694);
      *(_DWORD *)(a1 + 54) = v25 / 0xA;
      *(_DWORD *)(a1 + 2666) = v26;
      *(_DWORD *)(a1 + 2694) = v27;
      v28 = (int)(*(_DWORD *)(a1 + 2702) - ((int (*)(void))GetTickCount)() / 0xAu);
      v29 = (HIDWORD(v28) ^ v28) - HIDWORD(v28);
      if ( v29 >= 100 )
      {
        v30 = *(_DWORD *)(a1 + 2694);
        v31 = *(_DWORD *)(a1 + 2698);
        *(_DWORD *)(a1 + 2698) = v30;
        *(_DWORD *)(a1 + 2690) = 100 * (v30 - v31) / v29;
        *(_DWORD *)(a1 + 2702) = ((int (*)(void))GetTickCount)() / 0xAu;
      }
      v32 = *(_DWORD **)(a1 + 42);
      v33 = *(_WORD *)(a1 + 4);
      *(_DWORD *)&to.sa_data[2] = *(_DWORD *)a1;
      *(_WORD *)to.sa_data = v33;
      v35 = v32[6];
      to.sa_family = 2;
      sendto(v35, buf, len, 0, &to, 16);
      v34 = v32[8976] + 1;
      v32[8975] += len;
      v32[8976] = v34;
    }
  }
}
// 4DC214: invalid function type has been ignored
// 41C560: using guessed type char var_3FE[1022];

//----- (0041C730) --------------------------------------------------------
void __thiscall NetDataHandleCorePacket(NETDATA *nd, void *packet, int packet_sz, int a4)
{
  int v5; // ecx
  void *v6; // esi
  int v7; // edi
  int v8; // ecx
  char *v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int i; // esi
  int v22; // eax
  int v23; // ebx
  __int16 v24; // di
  _WORD *v25; // eax
  unsigned int v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // eax
  __int64 v30; // rax
  __int64 v31; // rax
  int v32; // edi
  char *v33; // esi
  void *v34; // eax
  int v35; // edi
  char *v36; // esi
  void *v37; // eax
  char *v38; // esi
  char *v39; // ebx
  int v40; // edx
  char *v41; // esi
  char *v42; // edi
  char buf[2]; // [esp+10h] [ebp-Ch] BYREF
  int v44; // [esp+12h] [ebp-Ah]

  v5 = *(_DWORD *)&nd->field_0[50];
  if ( v5 == 4 )
  {
LABEL_12:
    v6 = packet;
    goto free_ptr_return;
  }
  v6 = packet;
  if ( !*(_BYTE *)packet )
  {
    v7 = packet_sz;
    if ( packet_sz <= 1 )
      goto free_ptr_return;
    switch ( *((_BYTE *)packet + 1) )
    {
      case 2:
        if ( v5 != 1 )
          goto free_ptr_return;
        v8 = *(_DWORD *)((char *)packet + 2);
        if ( abs32(*(_DWORD *)&nd->field_0[62]) != abs32(v8) )
          goto free_ptr_return;
        *(_DWORD *)&nd->field_0[62] = v8;
        v9 = &nd->field_0[70];
        v10 = 260;
        do
        {
          v8 = 16807 * (v8 % 127773) - 2836 * (v8 / 127773) + 123;
          if ( v8 <= 0 )
            v8 += 0x7FFFFFFF;
          *(_WORD *)v9 = v8;
          v9 += 2;
          --v10;
        }
        while ( v10 );
        *(_DWORD *)&nd->field_0[50] = 2;
        break;
      case 3:
        if ( (unsigned int)packet_sz < 6 )
          goto free_ptr_return;
        v16 = *(_DWORD *)((char *)packet + 2);
        buf[1] = 4;
        v44 = v16;
        buf[0] = 0;
        SendPacketCluster((struct CONNECTION *)nd, buf, 6u);
        v17 = *(_DWORD *)((char *)packet + 2);
        if ( v17 > *(_DWORD *)&nd->field_0[602] )
          *(_DWORD *)&nd->field_0[602] = v17;
        v18 = *(_DWORD *)((char *)packet + 2);
        v19 = *(_DWORD *)&nd->field_0[598];
        if ( v19 > v18 )
          goto free_ptr_return;
        if ( v19 == v18 )
        {
          NetDataHandleCorePacket(nd, (char *)packet + 6, v7 - 6, 0);
          v20 = *(_DWORD *)&nd->field_0[598] + 1;
          *(_DWORD *)&nd->field_0[598] = v20;
          for ( i = ((v20 >> 31) ^ (unsigned __int8)abs32(v20)) - (v20 >> 31);
                *(_DWORD *)&nd->field_266[4 * i + 4];
                i = ((v22 >> 31) ^ (unsigned __int8)abs32(v22)) - (v22 >> 31) )
          {
            NetDataHandleCorePacket(
              nd,
              (void *)(*(_DWORD *)&nd->field_266[4 * i + 4] + 2),
              **(__int16 **)&nd->field_266[4 * i + 4],
              0);
            efree(*(LPVOID *)&nd->field_266[4 * i + 4]);
            *(_DWORD *)&nd->field_266[4 * i + 4] = 0;
            v22 = *(_DWORD *)&nd->field_0[598] + 1;
            *(_DWORD *)&nd->field_0[598] = v22;
          }
        }
        else
        {
          v23 = ((v18 >> 31) ^ (unsigned __int8)abs32(v18)) - (v18 >> 31);
          if ( !*(_DWORD *)&nd->field_266[4 * v23 + 4] )
          {
            v24 = v7 - 6;
            v25 = emalloc(v24 + 2);
            *(_DWORD *)&nd->field_266[4 * v23 + 4] = v25;
            *v25 = v24;
            qmemcpy((void *)(*(_DWORD *)&nd->field_266[4 * v23 + 4] + 2), (char *)packet + 6, v24);
          }
        }
        break;
      case 4:
        if ( (unsigned int)packet_sz < 6 )
          goto free_ptr_return;
        v11 = *(_DWORD *)((char *)packet + 2);
        if ( nd->pending_ack > v11 || v11 >= nd->current_ack )
          goto free_ptr_return;
        v12 = ((v11 >> 31) ^ (unsigned __int8)abs32(v11)) - (v11 >> 31);
        v13 = *(_DWORD *)&nd->field_266[4 * v12 + 1028];
        if ( v13 )
        {
          *(_DWORD *)nd->field_266 -= *(__int16 *)(v13 + 4);
          efree(*(LPVOID *)&nd->field_266[4 * v12 + 1028]);
          *(_DWORD *)&nd->field_266[4 * v12 + 1028] = 0;
          v14 = nd->current_ack;
          if ( nd->pending_ack < v14 )
          {
            do
            {
              v15 = nd->pending_ack;
              if ( *(_DWORD *)&nd->field_266[4 * (((v15 >> 31) ^ (unsigned __int8)abs32(v15)) - (v15 >> 31)) + 1028] )
                break;
              nd->pending_ack = v15 + 1;
            }
            while ( v15 + 1 < v14 );
          }
        }
        break;
      case 5:
        JUMPOUT(0x4159F0);
      case 6:
        v26 = ((int (*)(void))GetTickCount)() / 0xAu;
        v27 = *(_DWORD *)&nd->field_0[30];
        v28 = v26 - *(_DWORD *)((char *)packet + 2);
        ++*(_DWORD *)&nd->field_0[26];
        v29 = *(_DWORD *)&nd->field_0[34];
        *(_DWORD *)&nd->field_0[30] = v28 + v27;
        if ( !v29 || v28 < v29 )
          *(_DWORD *)&nd->field_0[34] = v28;
        if ( v28 > *(_DWORD *)&nd->field_0[38] )
          *(_DWORD *)&nd->field_0[38] = v28;
        if ( v28 <= *(_DWORD *)&nd->field_0[10] + 1
          || (v30 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&nd->field_0[22]),
              (int)((HIDWORD(v30) ^ v30) - HIDWORD(v30)) > 12000) )
        {
          if ( v28 < 2 * *(_DWORD *)&nd->field_0[10]
            || (v31 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)&nd->field_0[22]),
                (int)((HIDWORD(v31) ^ v31) - HIDWORD(v31)) > 60000) )
          {
            *(_DWORD *)&nd->field_0[14] = *(_DWORD *)((char *)packet + 6)
                                        + v28 * (1000 - *(_DWORD *)(*(_DWORD *)&nd->field_0[42] + 36)) / 1000
                                        - v26;
            *(_DWORD *)&nd->field_0[22] = ((int (*)(void))GetTickCount)() / 0xAu;
            *(_DWORD *)&nd->field_0[10] = v28;
          }
        }
        goto LABEL_12;
      case 7:
        *(_DWORD *)&nd->field_0[50] = 4;
        goto free_ptr_return;
      case 8:
      case 9:
        JUMPOUT(0x415970);
      case 0xA:
        JUMPOUT(0x4158E0);
      case 0xB:
        v32 = 0;
        if ( *(int *)&nd->field_A36[560] > 0 )
        {
          v33 = &nd->field_A36[480];
          do
          {
            if ( *((_DWORD *)v33 + 3) )
              efree(*(LPVOID *)v33);
            ++v32;
            v33 += 20;
          }
          while ( v32 < *(_DWORD *)&nd->field_A36[560] );
          v6 = packet;
        }
        v34 = (void *)nd->lpIncTransferData;
        *(_DWORD *)&nd->field_A36[560] = 0;
        if ( v34 )
          efree(v34);
        nd->lpIncTransferData = 0;
        nd->dwIncTransferSize = 0;
        nd->dwIncTransferBytesRcvd = 0;
        LOWORD(packet_sz) = 3072;
        WriteData((struct CONNECTION *)nd, &packet_sz, 2u, 1);
        goto free_ptr_return;
      case 0xC:
        v35 = 0;
        if ( *(int *)&nd->field_A36[560] > 0 )
        {
          v36 = &nd->field_A36[480];
          do
          {
            if ( *((_DWORD *)v36 + 3) )
              efree(*(LPVOID *)v36);
            ++v35;
            v36 += 20;
          }
          while ( v35 < *(_DWORD *)&nd->field_A36[560] );
          v6 = packet;
        }
        v37 = (void *)nd->lpIncTransferData;
        *(_DWORD *)&nd->field_A36[560] = 0;
        if ( v37 )
          efree(v37);
        nd->lpIncTransferData = 0;
        nd->dwIncTransferSize = 0;
        nd->dwIncTransferBytesRcvd = 0;
        goto free_ptr_return;
      case 0xE:
        v38 = (char *)packet + 2;
        v39 = (char *)packet + packet_sz;
        while ( 1 )
        {
          v40 = (unsigned __int8)*v38;
          v41 = v38 + 1;
          v42 = &v41[v40];
          if ( &v41[v40] > v39 )
            break;
          NetDataHandleCorePacket(nd, v41, v40, 0);
          v38 = v42;
        }
        goto LABEL_12;
      default:
        goto free_ptr_return;
    }
    goto LABEL_12;
  }
  ProcessRegularPackets(
    *(struct PACKET_ATTACHMENT **)&nd->field_0[42],
    (char *)packet,
    packet_sz,
    (struct CONNECTION *)nd,
    a4);
  a4 = 0;
free_ptr_return:
  if ( a4 )
    efree(v6);
}
// 41C773: control flows out of bounds to 4158E0
// 41C773: control flows out of bounds to 415970
// 41C773: control flows out of bounds to 4159F0
// 4DC214: invalid function type has been ignored

//----- (0041CE60) --------------------------------------------------------
void __thiscall SendBiDirectionalCorePackets(struct CONNECTION *connection)
{
  int v2; // eax
  __int64 v3; // rax
  int v4; // edx
  __int64 v5; // rax
  int v6; // eax
  unsigned int v7; // kr00_4
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ebx
  int v12; // ecx
  unsigned int v13; // edx
  int v14; // eax
  signed int v15; // ebx
  unsigned int v16; // esi
  int v17; // ecx
  signed int v18; // edi
  int v19; // ebx
  int i; // edi
  int v21; // ecx
  int v22; // [esp+0h] [ebp-220h]
  int v23; // [esp+4h] [ebp-21Ch]
  int v24; // [esp+8h] [ebp-218h]
  int v25; // [esp+Ch] [ebp-214h]
  long double buf; // [esp+10h] [ebp-210h] BYREF
  int v27; // [esp+1Ah] [ebp-206h]
  char v28[2]; // [esp+20h] [ebp-200h] BYREF
  int v29; // [esp+22h] [ebp-1FEh]
  char v30[506]; // [esp+26h] [ebp-1FAh] BYREF

  v2 = *(_DWORD *)((char *)connection + 50);
  if ( v2 == 1 )
  {
    v3 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)((char *)connection + 54));
    if ( (int)((HIDWORD(v3) ^ v3) - HIDWORD(v3)) > 100 )
    {
      v4 = *(_DWORD *)((char *)connection + 62);
      LOWORD(buf) = 256;
      *(_DWORD *)((char *)&buf + 2) = v4;
      WORD3(buf) = 1;
      WriteToNetwork((int)connection, (char *)&buf, 8, v22, v23, v24, v25, SLODWORD(buf), SDWORD1(buf), SBYTE8(buf));
    }
  }
  else if ( v2 == 2 )
  {
    if ( *(_DWORD *)((char *)connection + 6) )
    {
      if ( (v5 = (int)(((int (*)(void))GetTickCount)() / 0xAu - *(_DWORD *)((char *)connection + 18)),
            v6 = (HIDWORD(v5) ^ v5) - HIDWORD(v5),
            v6 > 2000)
        || v6 > 500 && *(int *)((char *)connection + 10) > 300
        || v6 > 50 && *(int *)((char *)connection + 10) > 1000 )
      {
        *(_DWORD *)((char *)connection + 18) = ((int (*)(void))GetTickCount)() / 0xAu;
        LOWORD(buf) = 1280;
        v7 = ((int (*)(void))GetTickCount)();
        v8 = *(_DWORD *)((char *)connection + 2670);
        *(_DWORD *)((char *)&buf + 2) = v7 / 0xA;
        *(_DWORD *)((char *)&buf + 6) = *(_DWORD *)((char *)connection + 2666) + 1;
        HIWORD(v27) = HIWORD(v8);
        WriteToNetwork((int)connection, (char *)&buf, 14, v22, v23, v24, v25, SLODWORD(buf), SDWORD1(buf), SBYTE8(buf));
      }
    }
    while ( *(int *)((char *)connection + 3174) > 0 )
    {
      v9 = *(_DWORD *)((char *)connection + 614);
      if ( v9 >= 2048
        || *(_DWORD *)((char *)connection + offsetof(NETDATA, current_ack))
         - *(_DWORD *)((char *)connection + offsetof(NETDATA, pending_ack)) >= 128
        || *(_DWORD *)((char *)connection + 3110) && v9 > 256 )
      {
        break;
      }
      v10 = *(_DWORD *)((char *)connection + 3102);
      v29 = *(_DWORD *)((char *)connection + 3098);
      v28[0] = 0;
      v28[1] = 10;
      v11 = 480;
      if ( v29 - v10 <= 480 )
        v11 = v29 - v10;
      qmemcpy(v30, (const void *)(*(_DWORD *)((char *)connection + 3102) + *(_DWORD *)((char *)connection + 3094)), v11);
      WriteData(connection, v28, v11 + 6, 1);
      v12 = *(_DWORD *)((char *)connection + 3098);
      v13 = v11 + *(_DWORD *)((char *)connection + 3102);
      *(_DWORD *)((char *)connection + 3102) = v13;
      if ( v13 == v12 )
      {
        if ( *(_DWORD *)((char *)connection + 3106) )
          efree(*(LPVOID *)((char *)connection + 3094));
        v14 = *(_DWORD *)((char *)connection + 3174) - 1;
        *(_DWORD *)((char *)connection + 3174) = v14;
        memcpy((char *)connection + 3094, (char *)connection + 3114, 20 * v14);
      }
    }
    if ( *(_DWORD *)((char *)connection + 610) < *(_DWORD *)((char *)connection + 606) )
    {
      LODWORD(buf) = 0;
      v15 = 90;
      v16 = ((int (*)(void))GetTickCount)() / 0xAu;
      v17 = *(_DWORD *)((char *)connection
                      + 4
                      * (((*(int *)((char *)connection + 610) >> 31) ^ (unsigned __int8)abs32(*(_DWORD *)((char *)connection + 610)))
                       - (*(int *)((char *)connection + 610) >> 31))
                      + 1642);
      v18 = *(__int16 *)(v17 + 4);
      if ( v18 > 256 )
        v15 = 170;
      if ( (int)abs32(v16 - *(_DWORD *)v17) <= v15 )
      {
        v19 = LODWORD(buf);
      }
      else
      {
        *(_DWORD *)v17 = v16;
        SendPacketCluster(connection, (const void *)(v17 + 6), v18);
        v19 = 1;
      }
      for ( i = *(_DWORD *)((char *)connection + 610) + 1; i < *(_DWORD *)((char *)connection + 606); ++i )
      {
        if ( v19 >= 3 )
          break;
        v21 = *(_DWORD *)((char *)connection + 4 * (((i >> 31) ^ (unsigned __int8)abs32(i)) - (i >> 31)) + 1642);
        if ( v21 )
        {
          if ( (int)abs32(v16 - *(_DWORD *)v21) > 200 )
          {
            *(_DWORD *)v21 = v16;
            SendPacketCluster(connection, (const void *)(v21 + 6), *(__int16 *)(v21 + 4));
          }
          ++v19;
        }
      }
    }
  }
}
// 4DC214: invalid function type has been ignored
// 41CEBC: variable 'v22' is possibly undefined
// 41CEBC: variable 'v23' is possibly undefined
// 41CEBC: variable 'v24' is possibly undefined
// 41CEBC: variable 'v25' is possibly undefined

//----- (0041D190) --------------------------------------------------------
// NetworkData.WriteData()
int __thiscall WriteData(struct CONNECTION *encryptionn, const void *buf, unsigned int len, int a4)
{
  unsigned int v4; // edi
  signed int v6; // esi
  unsigned int v7; // ebp
  int v9; // esi
  unsigned int *v10; // eax
  unsigned int *v11; // ebp
  unsigned int v12; // edx
  _WORD *v13; // ebp
  char *v14; // ebp
  int v15; // edx
  signed int i; // [esp+10h] [ebp-1FCh]
  unsigned int v17; // [esp+10h] [ebp-1FCh]
  bool v18; // [esp+14h] [ebp-1F8h]
  char bufa[2]; // [esp+18h] [ebp-1F4h] BYREF
  char v20[498]; // [esp+1Ah] [ebp-1F2h] BYREF

  v4 = len;
  if ( (int)len > 496 )
  {
    v6 = 0;
    for ( i = 0; ; v6 = i )
    {
      v7 = v4 - v6;
      if ( (int)(v4 - v6) >= 480 )
        v7 = 480;
      bufa[1] = (v7 == v4 - v6) + 8;
      bufa[0] = 0;
      qmemcpy(v20, (char *)buf + v6, v7);
      if ( !WriteData(encryptionn, bufa, v7 + 2, 1) )
        break;
      i += v7;
      if ( i >= (int)len )
        return 1;
      v4 = len;
    }
    return 0;
  }
  if ( a4 )
  {
    if ( CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack
       - CONTAINING_RECORD(encryptionn, NETDATA, field_0)->pending_ack >= 255 )
      return 0;
    v18 = *(_DWORD *)((char *)encryptionn + 614) < 4096;
    v17 = len + 6;
    v9 = ((CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack >> 31) ^ (unsigned __int8)abs32(CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack))
       - (CONTAINING_RECORD(encryptionn, NETDATA, field_0)->current_ack >> 31);
    v10 = (unsigned int *)emalloc(len + 12);
    *(_DWORD *)((char *)encryptionn + 4 * v9 + 1642) = v10;
    v11 = v10;
    if ( v18 )
      v12 = ((int (*)(void))GetTickCount)() / 0xAu;
    else
      v12 = 0;
    *v11 = v12;
    v13 = v11 + 1;
    *v13 = v17;
    v14 = (char *)(v13 + 1);
    *v14 = 0;
    v14[1] = 3;
    *(_DWORD *)(v14 + 2) = *(_DWORD *)((char *)encryptionn + offsetof(NETDATA, current_ack));
    qmemcpy(v14 + 6, buf, len);
    v15 = *(_DWORD *)((char *)encryptionn + offsetof(NETDATA, current_ack)) + 1;
    *(_DWORD *)((char *)encryptionn + 614) += v17;
    *(_DWORD *)((char *)encryptionn + 606) = v15;
    if ( v18 )
      SendPacketCluster(encryptionn, v14, v17);
  }
  else
  {
    SendPacketCluster(encryptionn, buf, len);
  }
  return 1;
}
// 4DC214: invalid function type has been ignored
// 41D1B7: conditional instruction was optimized away because of '%arg_4.4>=1F1'

//----- (0041D370) --------------------------------------------------------
// Player.LogReliablePackets()
void __thiscall LogReliablePackets(struct CONNECTION *encryption, const char *Filename)
{
  char *v2; // edi
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // edi
  unsigned __int8 *v7; // esi

  v2 = (char *)encryption;
  v3 = fopen(Filename, "wt");
  if ( v3 )
  {
    v4 = *(_DWORD *)(v2 + offsetof(NETDATA, pending_ack));
    if ( v4 < *(_DWORD *)(v2 + offsetof(NETDATA, current_ack)) )
    {
      do
      {
        v5 = *(_DWORD *)&v2[4 * (((v4 >> 31) ^ (unsigned __int8)abs32(v4)) - (v4 >> 31)) + 1642];
        if ( v5 )
        {
          v6 = *(__int16 *)(v5 + 4);
          fprintf(v3, "%10d %4d: ", *(_DWORD *)v5, v6);
          v7 = (unsigned __int8 *)(v5 + 6);
          if ( v6 > 0 )
          {
            do
            {
              fprintf(v3, "%02x ", *v7++);
              --v6;
            }
            while ( v6 );
          }
          fprintf(v3, (const char *)L"\n");
          v2 = (char *)encryption;
        }
        else
        {
          fprintf(v3, "Acknowledged\n");
        }
        ++v4;
      }
      while ( v4 < *(_DWORD *)(v2 + 606) );
    }
    fclose(v3);
  }
}
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41ECE0: using guessed type _DWORD fprintf(_DWORD, const char *, ...);
// 42B4C0: using guessed type wchar_t asc_42B4C0[2];

//----- (0041D440) --------------------------------------------------------
int __thiscall SendHugeChunkPacketAllocated(int this, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = *(_DWORD *)(this + 3174);
  if ( v4 < 4 )
  {
    *(_DWORD *)(this + 20 * v4 + 3094) = a2;
    *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3098) = a3;
    *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3102) = 0;
    *(_DWORD *)(this + 20 * *(_DWORD *)(this + 3174) + 3106) = 1;
    *(_DWORD *)(this + 20 * (*(_DWORD *)(this + 3174))++ + 3110) = a4;
    SendBiDirectionalCorePackets((struct CONNECTION *)this);
    JUMPOUT(0x41D4BB);
  }
  return sub_41D4C3(a2, a3, a4);
}
// 41D4B6: control flows out of bounds to 41D4BB
// 41D4C3: using guessed type int __stdcall sub_41D4C3(int, int, int);

//----- (0041D4C3) --------------------------------------------------------
int __stdcall sub_41D4C3(int a1, int a2, int a3)
{
  return 0;
}
// 41D4C3: using guessed type int __stdcall sub_41D4C3(int, int, int);

//----- (0041D4D0) --------------------------------------------------------
void __thiscall GetMapLvlRequest(struct CONNECTION *encryption, char *a2, int a3, int a4)
{
  int v4; // eax

  v4 = *(_DWORD *)((char *)encryption + 3174);
  if ( v4 < 4 )
  {
    *(_DWORD *)((char *)encryption + 20 * v4 + 3094) = a2;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3098) = a3;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3102) = 0;
    *(_DWORD *)((char *)encryption + 20 * *(_DWORD *)((char *)encryption + 3174) + 3106) = 0;
    *(_DWORD *)((char *)encryption + 20 * (*(_DWORD *)((char *)encryption + 3174))++ + 3110) = a4;
    SendBiDirectionalCorePackets(encryption);
  }
}

//----- (0041D560) --------------------------------------------------------
int __thiscall sub_41D560(int this, _DWORD *a2, _DWORD *a3)
{
  int result; // eax

  *a2 = *(_DWORD *)(this + 3182);
  result = *(_DWORD *)(this + 3186);
  *a3 = result;
  return result;
}

//----- (0041D580) --------------------------------------------------------
void __thiscall GetASyncS2CInfoSomething(struct CONNECTION *encryption, int ASyncS2CEnd, int ASyncS2CStart)
{
  if ( *(int *)((char *)encryption + 3174) <= 0 )
  {
    *(_DWORD *)ASyncS2CEnd = 0;
    *(_DWORD *)ASyncS2CStart = 0;
  }
  else
  {
    *(_DWORD *)ASyncS2CEnd = *(_DWORD *)((char *)encryption + 3098);
    *(_DWORD *)ASyncS2CStart = *(_DWORD *)((char *)encryption + 3102);
  }
}

//----- (0041D5C0) --------------------------------------------------------
int __thiscall sub_41D5C0(int this)
{
  return *(_DWORD *)(this + 3174);
}

//----- (0041D5D0) --------------------------------------------------------
#error "41D6C0: call analysis failed (funcsize=84)"

//----- (0041D6D0) --------------------------------------------------------
#error "41D70B: call analysis failed (funcsize=26)"

//----- (0041D720) --------------------------------------------------------
int __thiscall sub_41D720(int this, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)a2 = *(_DWORD *)(this + 2682);
  result = *(_DWORD *)(this + 2686);
  *(_DWORD *)a3 = result;
  return result;
}

//----- (0041D740) --------------------------------------------------------
void __thiscall GetPacketCountInfoSomething(struct CONNECTION *this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a2 = *(_DWORD *)((char *)this + 2666);
  *(_DWORD *)a3 = *(_DWORD *)((char *)this + 2670);
  *(_DWORD *)a4 = *(_DWORD *)((char *)this + 2674);
  *(_DWORD *)a5 = *(_DWORD *)((char *)this + 2678);
}

//----- (0041D780) --------------------------------------------------------
void __thiscall sub_41D780(int this)
{
  *(_DWORD *)(this + 50) = 4;
}

//----- (0041D790) --------------------------------------------------------
char *__cdecl get_text_ip(struct in_addr in)
{
  return inet_ntoa(in);
}

//----- (0041D7A0) --------------------------------------------------------
int __thiscall GetSubspaceEXEChecksum(int this, char *Filename)
{
  char *v2; // eax
  int OutSize; // [esp+0h] [ebp-4h] BYREF

  OutSize = this;
  v2 = CompressFile(Filename, &OutSize, (int *)&Filename, 0, 0, 0, 0);
  if ( v2 )
    efree(v2);
  return (int)Filename;
}
// 41D7A0: inconsistent function type and number of purged bytes

//----- (0041D7E0) --------------------------------------------------------
char *__cdecl CompressFile(const char *Filename, int *OutSize, int *CRC_32, const void *Buffer, unsigned int bytes, int DoFileCompression, int FileSize)
{
  unsigned int v7; // edi
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // edi
  char *result; // eax
  int v12; // eax
  unsigned int v13; // ebx
  char *v14; // esi
  void *v15; // edi
  void *v16; // ebp
  unsigned int v17; // [esp+0h] [ebp-Ch]
  _DWORD *v18; // [esp+4h] [ebp-8h]
  void *memory; // [esp+8h] [ebp-4h]
  const void *retaddr; // [esp+Ch] [ebp+0h]

  v18 = v8;
  v17 = v7;
  v9 = fopen(Filename, "rb");
  v10 = v9;
  if ( v9 )
  {
    v12 = _fileno(v9);
    v13 = _filelength(v12);
    v14 = (char *)emalloc(v13);
    memory = v14;
    fread(v14, v13, 1, v10);
    fclose(v10);
    if ( FileSize )
      *(_DWORD *)FileSize = v13;
    if ( CRC_32 )
      *CRC_32 = CRC32(v14, v13);
    if ( DoFileCompression )
    {
      FileSize = (int)(4 * v13) / 3 + 12;
      v15 = ExpandMemory(0, FileSize, 1);
      if ( compress(v15, &FileSize, v14, v13) )
      {
        efree(v15);
        memory = 0;
      }
      else
      {
        v17 = (unsigned int)CRC_32;
        memory = ExpandMemory(v15, (int)CRC_32, 1);
      }
      *v18 = &Filename[v17];
      v16 = emalloc((int)&Filename[v17]);
      if ( retaddr )
        qmemcpy(v16, retaddr, (unsigned int)Filename);
      qmemcpy((void *)&Filename[(_DWORD)v16], memory, v17);
      efree(memory);
    }
    else
    {
      *OutSize = v13 + bytes;
      v16 = emalloc(v13 + bytes);
      if ( Buffer )
        qmemcpy(v16, Buffer, bytes);
      qmemcpy((char *)v16 + bytes, v14, v13);
    }
    efree(memory);
    result = (char *)v16;
  }
  else
  {
    if ( CRC_32 )
      *CRC_32 = 0;
    if ( FileSize )
      *(_DWORD *)FileSize = 0;
    *OutSize = bytes;
    result = (char *)emalloc(bytes);
    if ( Buffer )
      qmemcpy(result, Buffer, bytes);
  }
  return result;
}
// 41D7E0: could not find valid save-restore pair for edi
// 41D7E0: could not find valid save-restore pair for esi
// 41D7E5: variable 'v8' is possibly undefined
// 41D7E6: variable 'v7' is possibly undefined
// 41D9E0: using guessed type int __cdecl compress(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DCA0: using guessed type _DWORD __cdecl fclose(_DWORD);
// 41DD20: using guessed type _DWORD __cdecl fread(_DWORD, _DWORD, _DWORD, _DWORD);
// 41DE90: using guessed type _DWORD __cdecl fopen(_DWORD, _DWORD);
// 41FD60: using guessed type _DWORD __cdecl _filelength(_DWORD);
// 428DF0: using guessed type _DWORD __cdecl _fileno(_DWORD);

//----- (0041DA50) --------------------------------------------------------
int __cdecl srand(int a1)
{
  int result; // eax

  result = a1;
  rand_seed = a1;
  return result;
}
// 42F744: using guessed type int rand_seed;

//----- (0041F4F0) --------------------------------------------------------
char *__cdecl RunCommandPrompt(char *argumentsPointer)
{
  char *result; // eax
  char *v2; // eax
  int v3[4]; // [esp+0h] [ebp-10h] BYREF

  result = getenv(aCom);
  v3[0] = (int)result;
  if ( argumentsPointer )
  {
    v3[1] = (int)"/c";
    v3[2] = (int)argumentsPointer;
    v3[3] = 0;
    if ( !result
      || (result = (char *)_spawnve(0, result, v3, 0), result == (char *)-1)
      && (dword_4D9E28 == 2 || dword_4D9E28 == 13) )
    {
      v2 = "command.com";
      if ( (dword_4D9E34 & 0x8000) == 0 )
        v2 = "cmd.exe";
      v3[0] = (int)v2;
      result = (char *)_spawnvpe(0, v2, v3, 0);
    }
  }
  else if ( result )
  {
    result = (char *)(_access(result, 0) == 0);
  }
  return result;
}
// 4234E0: using guessed type _DWORD __cdecl _spawnvpe(_DWORD, char *, _DWORD, _DWORD);
// 4236D0: using guessed type _DWORD __cdecl _spawnve(_DWORD, char *lpFileName, _DWORD, _DWORD);
// 4D9E28: using guessed type int dword_4D9E28;
// 4D9E34: using guessed type int dword_4D9E34;

//----- (00422060) --------------------------------------------------------
void sub_422060()
{
  _DWORD v0[8]; // [esp-Ch] [ebp-24h] BYREF
  int v1; // [esp+14h] [ebp-4h]

  v0[7] = (char *)&loc_42A127 + 1;
  v0[6] = unknown_libname_5;
  v0[5] = __readfsdword(0);
  v0[3] = v0;
  v1 = 0;
  if ( dword_4D9ECC )
  {
    v1 = 1;
    dword_4D9ECC();
    v1 = 0;
  }
  v1 = -1;
  sub_4220CE();
}
// 425408: using guessed type int __cdecl unknown_libname_5(int, int, int);
// 4D9ECC: using guessed type int (*dword_4D9ECC)(void);

//----- (004220CE) --------------------------------------------------------
// attributes: thunk
void sub_4220CE()
{
  abort();
}

//----- (004220F0) --------------------------------------------------------
void sub_4220F0()
{
  _DWORD v0[8]; // [esp-Ch] [ebp-24h] BYREF
  int v1; // [esp+14h] [ebp-4h]

  v0[7] = &unk_42A140;
  v0[6] = unknown_libname_5;
  v0[5] = __readfsdword(0);
  v0[3] = v0;
  v1 = 0;
  if ( off_42FA24 )
  {
    v1 = 1;
    off_42FA24();
    v1 = 0;
  }
  v1 = -1;
  sub_42215E();
}
// 425408: using guessed type int __cdecl unknown_libname_5(int, int, int);
// 42FA24: using guessed type int (*off_42FA24)(void);

//----- (0042215E) --------------------------------------------------------
// attributes: thunk
void sub_42215E()
{
  sub_422060();
}

//----- (00423F40) --------------------------------------------------------
bool __cdecl DateFunction(_DWORD *a1)
{
  bool result; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp-28h] [ebp-30h]
  int v6; // [esp-24h] [ebp-2Ch]
  int v7; // [esp-20h] [ebp-28h]
  int v8; // [esp-1Ch] [ebp-24h]
  int v9; // [esp-18h] [ebp-20h]
  int v10; // [esp-14h] [ebp-1Ch]

  if ( !dword_431C8C )
    return 0;
  v2 = a1[5];
  if ( v2 != dword_431D20 || v2 != dword_431D30 )
  {
    if ( dword_4D9F08 )
    {
      if ( stru_4D9F10.DaylightDate.wYear )
      {
        v10 = stru_4D9F10.DaylightDate.wDay;
        v9 = 0;
        v8 = 0;
        v7 = stru_4D9F10.DaylightDate.wMonth;
        v6 = a1[5];
        v5 = 0;
      }
      else
      {
        v10 = 0;
        v9 = stru_4D9F10.DaylightDate.wDayOfWeek;
        v8 = stru_4D9F10.DaylightDate.wDay;
        v7 = stru_4D9F10.DaylightDate.wMonth;
        v6 = a1[5];
        v5 = 1;
      }
      cvtdate(
        1,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        stru_4D9F10.DaylightDate.wHour,
        stru_4D9F10.DaylightDate.wMinute,
        stru_4D9F10.DaylightDate.wSecond,
        stru_4D9F10.DaylightDate.wMilliseconds);
      if ( stru_4D9F10.StandardDate.wYear )
        cvtdate(
          0,
          0,
          a1[5],
          stru_4D9F10.StandardDate.wMonth,
          0,
          0,
          stru_4D9F10.StandardDate.wDay,
          stru_4D9F10.StandardDate.wHour,
          stru_4D9F10.StandardDate.wMinute,
          stru_4D9F10.StandardDate.wSecond,
          stru_4D9F10.StandardDate.wMilliseconds);
      else
        cvtdate(
          0,
          1,
          a1[5],
          stru_4D9F10.StandardDate.wMonth,
          stru_4D9F10.StandardDate.wDay,
          stru_4D9F10.StandardDate.wDayOfWeek,
          0,
          stru_4D9F10.StandardDate.wHour,
          stru_4D9F10.StandardDate.wMinute,
          stru_4D9F10.StandardDate.wSecond,
          stru_4D9F10.StandardDate.wMilliseconds);
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      cvtdate(0, 1, a1[5], 10, 5, 0, 0, 2, 0, 0, 0);
    }
  }
  v3 = a1[7];
  if ( dword_431D24 < dword_431D34 )
  {
    if ( v3 >= dword_431D24 && v3 <= dword_431D34 )
    {
      if ( v3 > dword_431D24 && v3 < dword_431D34 )
        return 1;
      goto LABEL_25;
    }
    return 0;
  }
  if ( v3 < dword_431D34 || v3 > dword_431D24 )
    return 1;
  if ( v3 > dword_431D34 && v3 < dword_431D24 )
    return 0;
LABEL_25:
  v4 = 1000 * (*a1 + 60 * (a1[1] + 60 * a1[2]));
  if ( v3 == dword_431D24 )
    result = v4 >= dword_431D28;
  else
    result = v4 < dword_431D38;
  return result;
}
// 4241B0: using guessed type _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 431C8C: using guessed type int dword_431C8C;
// 431D20: using guessed type int dword_431D20;
// 431D24: using guessed type int dword_431D24;
// 431D28: using guessed type int dword_431D28;
// 431D30: using guessed type int dword_431D30;
// 431D34: using guessed type int dword_431D34;
// 431D38: using guessed type int dword_431D38;
// 4D9F08: using guessed type int dword_4D9F08;

//----- (00427220) --------------------------------------------------------
int __cdecl sub_427220(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_432150);
}
// 427050: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00427240) --------------------------------------------------------
int __cdecl sub_427240(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_432168);
}
// 427050: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00427260) --------------------------------------------------------
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *Str)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &Str, Str, 0, 0, 0, 0);
  return sub_427220((int)v3, (int)Result);
}
// 427F20: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004272A0) --------------------------------------------------------
int __cdecl sub_4272A0(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_427240((int)v3, a1);
}
// 427F20: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00428F50) --------------------------------------------------------
int __cdecl getch()
{
  int result; // eax
  int v1; // esi
  unsigned __int8 *v2; // eax
  DWORD NumberOfEventsRead; // [esp+10h] [ebp-1Ch] BYREF
  DWORD Mode; // [esp+14h] [ebp-18h] BYREF
  struct _INPUT_RECORD Buffer; // [esp+18h] [ebp-14h] BYREF

  if ( dword_432780 == -1 )
  {
    result = (int)hConsoleHandle;
    if ( hConsoleHandle != (HANDLE)-1 )
    {
      if ( hConsoleHandle == (HANDLE)-2 )
      {
        __initconin();
        result = (int)hConsoleHandle;
      }
      GetConsoleMode((HANDLE)result, &Mode);
      SetConsoleMode(hConsoleHandle, 0);
      if ( ReadConsoleInputA(hConsoleHandle, &Buffer, 1u, &NumberOfEventsRead) )
      {
        while ( NumberOfEventsRead )
        {
          if ( Buffer.EventType == 1 && Buffer.Event.KeyEvent.bKeyDown )
          {
            v1 = (unsigned __int8)Buffer.Event.KeyEvent.uChar.AsciiChar;
            if ( Buffer.Event.KeyEvent.uChar.AsciiChar )
              goto LABEL_14;
            v2 = (unsigned __int8 *)_getextendedkeycode(&Buffer.Event);
            if ( v2 )
            {
              v1 = *v2;
              dword_432780 = v2[1];
              goto LABEL_14;
            }
          }
          if ( !ReadConsoleInputA(hConsoleHandle, &Buffer, 1u, &NumberOfEventsRead) )
            break;
        }
      }
      v1 = -1;
LABEL_14:
      SetConsoleMode(hConsoleHandle, Mode);
      result = v1;
    }
  }
  else
  {
    result = (unsigned __int8)dword_432780;
    dword_432780 = -1;
  }
  return result;
}
// 429150: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 4292D0: using guessed type int __initconin(void);
// 432780: using guessed type int dword_432780;

//----- (00429060) --------------------------------------------------------
int __cdecl console_input_wrapper()
{
  HANDLE v1; // eax
  int v2; // eax
  void *v3; // esp
  int *v4; // edi
  DWORD v5; // eax
  int *i; // esi
  int v7; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+4h] [ebp-Ch] BYREF
  DWORD nLength; // [esp+8h] [ebp-8h] BYREF
  DWORD NumberOfEventsRead; // [esp+Ch] [ebp-4h] BYREF

  if ( dword_432780 != -1 )
    return 1;
  v1 = hConsoleHandle;
  if ( hConsoleHandle == (HANDLE)-2 )
  {
    __initconin();
    v1 = hConsoleHandle;
  }
  if ( v1 != (HANDLE)-1 )
  {
    if ( GetNumberOfConsoleInputEvents(v1, &nLength) )
    {
      if ( nLength )
      {
        v2 = 20 * nLength + 3;
        LOBYTE(v2) = v2 & 0xFC;
        v3 = alloca(v2);
        v4 = &v7;
        if ( &v7 )
        {
          if ( PeekConsoleInputA(hConsoleHandle, (PINPUT_RECORD)&v7, nLength, &NumberOfEventsRead) )
          {
            v5 = NumberOfEventsRead;
            if ( NumberOfEventsRead )
            {
              if ( NumberOfEventsRead <= nLength )
              {
                for ( i = &v8; ; i += 5 )
                {
                  if ( *(_WORD *)v4 == 1 && *i )
                  {
                    if ( *((_BYTE *)i + 10) || _getextendedkeycode(i) )
                      return 1;
                    v5 = NumberOfEventsRead;
                  }
                  --v5;
                  v4 += 5;
                  NumberOfEventsRead = v5;
                  if ( !v5 )
                    return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 4290F5: conditional instruction was optimized away because of '%NumberOfEventsRead.4!=0'
// 429150: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 4292D0: using guessed type int __initconin(void);
// 432780: using guessed type int dword_432780;

//----- (100010E0) --------------------------------------------------------
unsigned int __thiscall sub_100010E0(int *this, unsigned __int8 *a2, int a3)
{
  unsigned int result; // eax
  int v6; // edi
  int v7; // ecx

  result = a3 - 1;
  if ( a3 )
  {
    v6 = a3;
    do
    {
      result = (unsigned int)*this >> 8;
      v7 = result ^ dword_1002122C[*a2++ ^ (unsigned __int8)*this];
      --v6;
      *this = v7;
    }
    while ( v6 );
  }
  return result;
}

//----- (10001120) --------------------------------------------------------
unsigned int __thiscall sub_10001120(int *this, const char *a2)
{
  const char *v2; // edx
  unsigned int v4; // kr04_4
  unsigned int result; // eax
  int v6; // edi
  int v7; // ecx

  v2 = a2;
  v4 = strlen(a2) + 1;
  result = v4 - 1;
  if ( v4 != 1 )
  {
    v6 = v4 - 2 + 1;
    do
    {
      result = (unsigned int)*this >> 8;
      v7 = result ^ dword_1002122C[*(unsigned __int8 *)v2++ ^ (unsigned __int8)*this];
      --v6;
      *this = v7;
    }
    while ( v6 );
  }
  return result;
}

//----- (10001240) --------------------------------------------------------
_DWORD *__thiscall sub_10001240(_DWORD *this, const char *a2)
{
  const char *v2; // eax
  _BOOL1 v4; // zf
  char *v5; // eax

  v2 = a2;
  v4 = a2 == 0;
  this[1] = a2;
  *this = &off_1002192C;
  if ( !v4 )
  {
    v5 = (char *)*sub_10005140(&a2, "%s", v2);
    if ( !v5 )
      v5 = LevelFiles;
    sub_100052C0(aTx, "D:\\Src\\Inc\\Except.cpp", (char *)0x21, v5, 0);
    sub_100033A0(&a2);
  }
  return this;
}
// 1002192C: using guessed type void *off_1002192C;

//----- (10001320) --------------------------------------------------------
_DWORD *__thiscall sub_10001320(_DWORD *this)
{
  sub_10001240(this, 0);
  *this = &off_10021930;
  sub_100052C0("false", "D:\\Src\\Inc\\Except.cpp", (char *)0x33, "Memory error", 0);
  return this;
}
// 10021930: using guessed type void *off_10021930;

//----- (10001350) --------------------------------------------------------
void *__thiscall ReadsScrty1File(void *this, int a2, int a3, int a4, int a5)
{
  sub_10001240(this, 0);
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a4;
  *((_DWORD *)this + 4) = a5;
  *(_DWORD *)this = &off_10021934;
  if ( a3 )
  {
    strncpy_0((char *)this + 20, (const char *)a3, 0x103u);
    *((_BYTE *)this + 279) = 0;
  }
  else
  {
    *((_BYTE *)this + 20) = 0;
  }
  return this;
}
// 10021934: using guessed type void *off_10021934;

//----- (10001A50) --------------------------------------------------------
int __thiscall sub_10001A50(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
  {
    result = FIX_DLL_KERNEL32_dll_CloseHandle(*this);
    *this = -1;
  }
  return result;
}
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);

//----- (10001A80) --------------------------------------------------------
int __thiscall ReadScrty1File(void *this, char *FileName, int a3, int a4)
{
  int result; // eax
  int v6; // eax
  char v7[280]; // [esp+8h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_CreateFileA(FileName, 0x80000000, a3, 0, a4, 0x80, 0);
  *(_DWORD *)this = result;
  if ( result == -1 )
  {
    v6 = FIX_DLL_KERNEL32_dll_GetLastError();
    ReadsScrty1File(v7, 0, (int)FileName, 0, v6);
    _CxxThrowException(v7, (_ThrowInfo *)&unk_10022240);
  }
  return result;
}
// 10021014: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CreateFileA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);

//----- (10001D90) --------------------------------------------------------
int __thiscall sub_10001D90(_DWORD *this)
{
  int result; // eax
  int v2; // eax
  char pExceptionObject[280]; // [esp+0h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_GetFileSize(*this, 0);
  if ( result == -1 )
  {
    v2 = FIX_DLL_KERNEL32_dll_GetLastError();
    ReadsScrty1File(pExceptionObject, 5, 0, 0, v2);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&pThrowInfo);
  }
  return result;
}
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 1002102C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileSize)(_DWORD, _DWORD);

//----- (10001DE0) --------------------------------------------------------
int __thiscall ReadScrty1FileOffset(void *this, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+4h] [ebp-11Ch] BYREF
  char v7[12]; // [esp+8h] [ebp-118h] BYREF

  result = FIX_DLL_KERNEL32_dll_ReadFile(*(_DWORD *)this, a2, a3, &v6, 0);
  if ( !result )
  {
    v4 = FIX_DLL_KERNEL32_dll_GetLastError();
    ReadsScrty1File(v7, 2, 0, 0, v4);
    _CxxThrowException(v7, (_ThrowInfo *)&pThrowInfo);
  }
  if ( v6 != a3 )
  {
    v5 = FIX_DLL_KERNEL32_dll_GetLastError();
    ReadsScrty1File(v7, 3, 0, 0, v5);
    _CxxThrowException(v7, (_ThrowInfo *)&pThrowInfo);
  }
  return result;
}
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 10021030: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001F70) --------------------------------------------------------
bool __thiscall sub_10001F70(void *this)
{
  return FIX_DLL_KERNEL32_dll_DeleteFileA(this) != 0;
}
// 10021038: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_DeleteFileA)(_DWORD);

//----- (10002090) --------------------------------------------------------
int __thiscall sub_10002090(_DWORD *this)
{
  __int64 v1; // kr00_8
  __int64 v2; // rax
  __int64 v4; // [esp+0h] [ebp-10h] BYREF
  char v5[8]; // [esp+8h] [ebp-8h] BYREF

  FIX_DLL_KERNEL32_dll_GetFileTime(*this, 0, 0, v5);
  FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime(v5, &v4);
  v1 = v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      LODWORD(v2) = -1;
  }
  else
  {
    LODWORD(v2) = 0;
  }
  return v2;
}
// 10021044: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD);
// 10021048: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileTime)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100024F0) --------------------------------------------------------
char __thiscall sub_100024F0(_DWORD *this, char *a2, int a3)
{
  int v4; // eax
  int v5; // ebp
  char *v7; // esi
  char *v8; // eax
  int v9; // eax
  char pExceptionObject[12]; // [esp+14h] [ebp-128h] BYREF
  int v11; // [esp+20h] [ebp-11Ch] BYREF
  _BYTE v12[280]; // [esp+24h] [ebp-118h] BYREF

  if ( !FIX_DLL_KERNEL32_dll_ReadFile(*this, a2, a3 - 2, &v11, 0) )
  {
    v4 = FIX_DLL_KERNEL32_dll_GetLastError();
    ReadsScrty1File(v12, 2, 0, 0, v4);
    _CxxThrowException(v12, (_ThrowInfo *)&pThrowInfo);
  }
  v5 = v11;
  if ( !v11 )
    return 0;
  a2[v11] = 0;
  v7 = strchr_0(a2, 13);
  v8 = strchr_0(a2, 10);
  if ( (v8 >= v7 || !v8) && v7 || (v7 = v8) != 0 )
  {
    *v7 = 0;
    if ( FIX_DLL_KERNEL32_dll_SetFilePointer(*this, &v7[(v8 == v7 + 1) - v5 - (_DWORD)a2 + 1], 0, 1) == -1 )
    {
      v9 = FIX_DLL_KERNEL32_dll_GetLastError();
      ReadsScrty1File(pExceptionObject, 5, 0, 0, v9);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&pThrowInfo);
    }
  }
  return 1;
}
// 10021010: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 10021030: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ReadFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100027F0) --------------------------------------------------------
_BOOL1 __thiscall sub_100027F0(void *this)
{
  int v1; // eax
  _BOOL1 v2; // bl
  char v4[400]; // [esp+8h] [ebp-190h] BYREF

  v1 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v4);
  v2 = v1 != -1;
  if ( v1 != -1 )
    FIX_DLL_KERNEL32_dll_FindClose(v1);
  return v2;
}
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (10002830) --------------------------------------------------------
int __thiscall sub_10002830(void *this)
{
  __int64 v1; // kr00_8
  int v2; // esi
  __int64 v4; // [esp+10h] [ebp-19Ch] BYREF
  int v5; // [esp+18h] [ebp-194h]
  _DWORD v6[3]; // [esp+1Ch] [ebp-190h] BYREF
  _DWORD v7[95]; // [esp+30h] [ebp-17Ch] BYREF

  v5 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v6);
  if ( v5 == -1 )
    return 0;
  FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime(v7, &v4);
  v1 = v4 - 116444736000000000i64;
  if ( (((unsigned __int64)(v4 - 116444736000000000i64) >> 32) & 0x80000000) == 0i64 )
  {
    if ( SHIDWORD(v1) < 10000000 )
      v2 = v1 / 10000000;
    else
      v2 = -1;
  }
  else
  {
    v2 = 0;
  }
  if ( v5 != -1 )
    FIX_DLL_KERNEL32_dll_FindClose(v5);
  return v2;
}
// 10021044: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FileTimeToLocalFileTime)(_DWORD, _DWORD);
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (100028D0) --------------------------------------------------------
int __thiscall sub_100028D0(void *this)
{
  int v1; // eax
  int v2; // esi
  _DWORD v4[100]; // [esp+Ch] [ebp-190h] BYREF

  v1 = FIX_DLL_KERNEL32_dll_FindFirstFileA(this, v4);
  if ( v1 == -1 )
    return 0;
  v2 = v4[8];
  FIX_DLL_KERNEL32_dll_FindClose(v1);
  return v2;
}
// 10021058: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindClose)(_DWORD);
// 1002105C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FindFirstFileA)(_DWORD, _DWORD);

//----- (10002A10) --------------------------------------------------------
unsigned int __thiscall sub_10002A10(_BYTE *this, int a2, _BYTE *a3)
{
  _BYTE *v3; // esi
  unsigned int result; // eax
  _BYTE *v5; // edx
  int v6; // edi
  char v7; // cl
  char v8; // cl
  _BOOL1 v10; // zf

  v3 = this;
  result = 0;
  v5 = this;
  v6 = a2 - (_DWORD)this;
  do
  {
    v7 = v5[v6];
    *v5 = v7;
    if ( !v7 )
      break;
    ++result;
    ++v5;
  }
  while ( result < 0x104 );
  if ( result < 0x103 )
  {
    if ( result )
    {
      v8 = v3[result - 1];
      if ( v8 != 92 && v8 != 47 )
        v3[result++] = 92;
    }
  }
  for ( ; result < 0x104; ++a3 )
  {
    v10 = *a3 == 0;
    v3[result] = *a3;
    if ( v10 )
      break;
    ++result;
  }
  v3[259] = 0;
  return result;
}

//----- (10002B80) --------------------------------------------------------
void __thiscall sub_10002B80(_BYTE *this)
{
  char v1; // dl
  _BYTE *v2; // esi
  _BYTE *v3; // eax

  v1 = *this;
  v2 = 0;
  if ( !*this )
    goto LABEL_9;
  v3 = this;
  do
  {
    if ( v1 == 92 || *v3 == 47 )
      v2 = v3;
    v1 = *++v3;
  }
  while ( v1 );
  if ( v2 )
    *v2 = 0;
  else
LABEL_9:
    *this = 0;
}

//----- (10002CC0) --------------------------------------------------------
int __cdecl sub_10002CC0(int a1)
{
  int result; // eax
  int pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = FIX_DLL_KERNEL32_dll_LocalAlloc(0, a1);
  if ( !result )
  {
    sub_10001320(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVmemory_exception__);
  }
  return result;
}
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 10022298: using guessed type __TI_flags _TI2_AVmemory_exception__;

//----- (10002D10) --------------------------------------------------------
int __fastcall sub_10002D10(int *a1, int a2)
{
  int result; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  if ( *a1 )
    result = FIX_DLL_KERNEL32_dll_LocalReAlloc(*a1, a2, 2);
  else
    result = FIX_DLL_KERNEL32_dll_LocalAlloc(0, a2);
  *a1 = result;
  if ( !result )
  {
    FIX_DLL_KERNEL32_dll_GetLastError();
    sub_10001320(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVmemory_exception__);
  }
  return result;
}
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD, _DWORD);
// 10022298: using guessed type __TI_flags _TI2_AVmemory_exception__;

//----- (10002D60) --------------------------------------------------------
int __thiscall sub_10002D60(void *this)
{
  return FIX_DLL_KERNEL32_dll_LocalFree(this);
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10002D70) --------------------------------------------------------
int __cdecl sub_10002D70(int a1)
{
  return FIX_DLL_KERNEL32_dll_LocalFree(a1);
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10002E30) --------------------------------------------------------
char *__fastcall sub_10002E30(_BYTE *a1, int a2, char *a3, char a4, int a5)
{
  char *v5; // eax
  void *v7; // edx
  char *v8; // esi
  int v9; // ebx
  char *v11; // eax
  int v12; // eax
  char v13; // al

  v5 = a3;
  v7 = a1;
  v8 = a3;
  if ( a1 )
    *a1 = 0;
  v9 = a5 + 1;
  if ( a5 != -1 )
  {
    do
    {
      v8 = v5;
      v5 = strchr_0(v5, a4);
      if ( !v5 )
        break;
      ++v5;
      --v9;
    }
    while ( v9 );
    v7 = a1;
  }
  if ( v9 > 1 )
    return 0;
  while ( *v8 == 32 || *v8 == 9 )
    ++v8;
  if ( v7 )
  {
    if ( v5 )
    {
      v11 = v5 - 1;
    }
    else
    {
      v11 = strchr_0(v8, 0);
      v7 = a1;
    }
    v12 = v11 - v8;
    if ( a2 > v12 )
      a2 = v12 + 1;
    memcpy_0(v7, v8, a2 - 1);
    do
    {
      a1[--a2] = 0;
      if ( !a2 )
        break;
      v13 = a1[a2 - 1];
    }
    while ( v13 == 32 || v13 == 9 || a4 == 10 && v13 == 13 );
  }
  return v8;
}

//----- (10003000) --------------------------------------------------------
char *__fastcall strncpyt(void *dst, void *src, int len)
{
  if ( strlen((const char *)src) < len )
    return strcpy((char *)dst, (const char *)src);
  memcpy_0(dst, src, len);
  *((char *)dst + len - 1) = 0;
  return (char *)dst;
}

//----- (10003060) --------------------------------------------------------
char *__fastcall sub_10003060(const char *a1, const char *a2, signed int a3)
{
  signed int v4; // ecx
  size_t v6; // esi
  char *v7; // ebx

  v4 = strlen(a1);
  if ( v4 >= a3 )
    return (char *)a1;
  v6 = a3 - v4;
  v7 = (char *)&a1[v4];
  if ( strlen(a2) < a3 - v4 )
    return strcpy(v7, a2);
  memcpy_0(v7, a2, v6);
  v7[v6 - 1] = 0;
  return v7;
}

//----- (100030E0) --------------------------------------------------------
char *__fastcall sub_100030E0(char *a1, const char *a2)
{
  int v4; // ebp
  char *result; // eax
  char *v6; // edi
  int v7; // edi
  unsigned int v8; // [esp+14h] [ebp-8h]
  unsigned int v9; // [esp+18h] [ebp-4h]

  v9 = 0;
  v8 = strlen(a2);
  v4 = tolower_0(*a2);
  if ( !*a1 )
    return 0;
  v6 = a1;
  if ( a1 )
  {
    while ( _memicmp_0(v6, a2, v8) )
    {
      v6 = strchr_0(v6 + 1, v4);
      if ( !v6 )
        goto LABEL_8;
    }
    v9 = (unsigned int)v6;
  }
LABEL_8:
  v7 = toupper_0(*a2);
  if ( v7 == v4 || !a1 )
  {
LABEL_12:
    a1 = 0;
  }
  else
  {
    while ( _memicmp_0(a1, a2, v8) )
    {
      a1 = strchr_0(a1 + 1, v7);
      if ( !a1 )
        goto LABEL_12;
    }
  }
  result = (char *)v9;
  if ( !v9 || v9 >= (unsigned int)a1 && a1 )
    result = a1;
  return result;
}

//----- (10003220) --------------------------------------------------------
char __fastcall sub_10003220(char *a1, int a2, char a3)
{
  char result; // al

  for ( result = *a1; result; ++a1 )
  {
    if ( result == a2 )
      *a1 = a3;
    result = a1[1];
  }
  return result;
}

//----- (10003240) --------------------------------------------------------
char *__thiscall sub_10003240(char *this)
{
  char *result; // eax
  char i; // dl

  result = this;
  for ( i = *this; i >= 48; i = *++result )
  {
    if ( i > 57 )
      break;
  }
  return result;
}

//----- (10003260) --------------------------------------------------------
_BYTE *__thiscall sub_10003260(_BYTE *this)
{
  _BYTE *result; // eax

  for ( result = this; *result == 32 || *result == 9; ++result )
    ;
  return result;
}

//----- (10003280) --------------------------------------------------------
char *__fastcall sub_10003280(char *a1)
{
  char *result; // eax

  for ( result = strchr_0(a1, 0) - 1; result >= a1; *result-- = 0 )
  {
    if ( *result != 32 && *result != 9 )
      break;
  }
  return result;
}

//----- (100033A0) --------------------------------------------------------
int __thiscall sub_100033A0(_DWORD *this)
{
  int result; // eax

  result = FIX_DLL_KERNEL32_dll_LocalFree(*this);
  *this = 0;
  return result;
}
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10003E70) --------------------------------------------------------
int sub_10003E70(const char **a1, char *a2, ...)
{
  int result; // eax
  unsigned int v3; // kr04_4
  int v4; // eax
  unsigned int v5; // ecx
  int *v6; // esi
  char *v7; // edi
  unsigned int v8; // edx
  unsigned int v9; // kr08_4
  unsigned int v10; // kr0C_4
  int v11; // eax
  int v12; // [esp+0h] [ebp-814h] BYREF
  int pExceptionObject; // [esp+4h] [ebp-810h] BYREF
  int v14; // [esp+8h] [ebp-80Ch] BYREF
  char v15[8]; // [esp+Ch] [ebp-808h] BYREF
  char v16[2048]; // [esp+14h] [ebp-800h] BYREF
  va_list va; // [esp+820h] [ebp+Ch] BYREF

  va_start(va, a2);
  _vsnprintf(v16, 0x800u, a2, va);
  v16[2047] = 0;
  if ( *a1 )
  {
    v9 = strlen(*a1) + 1;
    v10 = strlen(v16) + 1;
    v11 = FIX_DLL_KERNEL32_dll_LocalReAlloc(*a1, v10 + v9 - 1, 2);
    *a1 = (const char *)v11;
    if ( !v11 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError();
      sub_10001320(&v12);
      _CxxThrowException(&v12, (_ThrowInfo *)&_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v11 + v10 - 1 + v9 - 1) = 0;
    result = 0;
    v6 = &v14;
    v8 = strlen((const char *)&v14) + 1;
    v7 = (char *)&(*a1)[strlen(*a1)];
    v5 = v8;
  }
  else
  {
    if ( !v16 )
    {
      result = FIX_DLL_KERNEL32_dll_LocalFree(v16);
      *a1 = 0;
      return result;
    }
    v3 = strlen(v16) + 1;
    v4 = FIX_DLL_KERNEL32_dll_LocalAlloc(0, v3 - 1 + 2);
    *a1 = (const char *)v4;
    if ( !v4 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError();
      sub_10001320(&pExceptionObject);
      _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v4 + v3) = 0;
    result = 0;
    v5 = strlen(v15) + 1;
    v6 = (int *)v15;
    v7 = (char *)*a1;
    LOBYTE(v8) = v5;
  }
  qmemcpy(v7, v6, 4 * (v5 >> 2) + (v8 & 3));
  return result;
}
// 10001320: using guessed type int __thiscall sub_10001320(_DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD, _DWORD);
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);
// 10022298: using guessed type __TI_flags _TI2_AVmemory_exception__;

//----- (10005120) --------------------------------------------------------
void __cdecl sub_10005120(int a1, int a2)
{
  JUMPOUT(0x10004F40);
}
// 10005128: control flows out of bounds to 10004F40

//----- (10005140) --------------------------------------------------------
const char **sub_10005140(const char **a1, char *a2, ...)
{
  const char *v2; // edx
  _BOOL1 v3; // zf
  unsigned int v4; // kr04_4
  int v5; // eax
  unsigned int v6; // ecx
  int *v7; // esi
  char *v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // kr08_4
  unsigned int v11; // kr0C_4
  int v12; // eax
  int v14; // [esp+0h] [ebp-820h] BYREF
  int pExceptionObject; // [esp+4h] [ebp-81Ch] BYREF
  int v16; // [esp+8h] [ebp-818h] BYREF
  char v17[8]; // [esp+Ch] [ebp-814h] BYREF
  char v18[2056]; // [esp+14h] [ebp-80Ch] BYREF
  int v19; // [esp+81Ch] [ebp-4h]
  va_list va; // [esp+82Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  *a1 = 0;
  v19 = 0;
  _vsnprintf(v18, 0x800u, a2, va);
  v2 = *a1;
  v3 = *a1 == 0;
  v18[2047] = 0;
  if ( !v3 )
  {
    v10 = strlen(v2) + 1;
    v11 = strlen(v18) + 1;
    v12 = FIX_DLL_KERNEL32_dll_LocalReAlloc(v2, v11 + v10 - 1, 2);
    *a1 = (const char *)v12;
    if ( !v12 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError();
      sub_10001320(&v14);
      _CxxThrowException(&v14, (_ThrowInfo *)&_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v12 + v11 - 1 + v10 - 1) = 0;
    v7 = &v16;
    v9 = strlen((const char *)&v16) + 1;
    v8 = (char *)&(*a1)[strlen(*a1)];
    v6 = v9;
    goto LABEL_10;
  }
  if ( v18 )
  {
    v4 = strlen(v18) + 1;
    v5 = FIX_DLL_KERNEL32_dll_LocalAlloc(0, v4 - 1 + 2);
    *a1 = (const char *)v5;
    if ( !v5 )
    {
      FIX_DLL_KERNEL32_dll_GetLastError();
      sub_10001320(&pExceptionObject);
      _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI2_AVmemory_exception__);
    }
    *(_BYTE *)(v5 + v4) = 0;
    v6 = strlen(v17) + 1;
    v7 = (int *)v17;
    v8 = (char *)*a1;
    LOBYTE(v9) = v6;
LABEL_10:
    qmemcpy(v8, v7, 4 * (v6 >> 2) + (v9 & 3));
    return a1;
  }
  FIX_DLL_KERNEL32_dll_LocalFree(v18);
  *a1 = 0;
  return a1;
}
// 10001320: using guessed type int __thiscall sub_10001320(_DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 10021088: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalAlloc)(_DWORD, _DWORD);
// 1002108C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LocalReAlloc)(_DWORD, _DWORD, _DWORD);
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);
// 10022298: using guessed type __TI_flags _TI2_AVmemory_exception__;

//----- (100052C0) --------------------------------------------------------
char __fastcall sub_100052C0(const char *a1, const char *a2, char *a3, const char *a4, char a5)
{
  char *v5; // eax

  sub_10005140((const char **)&a3, "ASSERTFAILURE(%s) in %s(%u)", a1, a2, a3);
  if ( a4 )
    sub_10003E70((const char **)&a3, ": %s", a4);
  v5 = a3;
  if ( !a3 )
    v5 = LevelFiles;
  sub_10005120((int)"%s\n", (int)v5);
  if ( a5 )
  {
    _assert((void *)"false", (void *)"D:\\Src\\Inc\\Misc.cpp", 0x335u);
    JUMPOUT(0x10016FE0);
  }
  _assert((void *)"false", (void *)"D:\\Src\\Inc\\Misc.cpp", 0x343u);
  FIX_DLL_KERNEL32_dll_LocalFree(a3);
  return 0;
}
// 1000534B: control flows out of bounds to 10016FE0
// 10021090: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_LocalFree)(_DWORD);

//----- (10005390) --------------------------------------------------------
void __fastcall sub_10005390(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // ecx
  unsigned int v6; // esi
  int v7; // ebx
  unsigned int v9; // ecx
  unsigned int v10; // eax
  _BYTE *v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  char v15; // dl
  int v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+1Ch] [ebp+8h]

  v5 = a3;
  v6 = 1790562961 * a4 + 985938188;
  v7 = 0;
  v16 = a1;
  v17 = 0;
  if ( a3 > 1 )
  {
    do
    {
      v9 = v5 - v7;
      v6 = 69069 * v6 + 17009;
      if ( v9 > 0x10001 )
        v10 = v6 / (0xFFFFFFFF / (v9 - 1) + 1);
      else
        v10 = (v9 * HIWORD(v6)) >> 16;
      v11 = (_BYTE *)(a1 + a2 * v10);
      if ( a2 )
      {
        v12 = a1;
        v13 = a2;
        v14 = v12 - (_DWORD)v11;
        do
        {
          v15 = v11[v14];
          v11[v14] = *v11;
          *v11++ = v15;
          --v13;
        }
        while ( v13 );
        a1 = v16;
        v7 = v17;
      }
      v5 = a3;
      ++v7;
      a1 += a2;
      v17 = v7;
      v16 = a1;
    }
    while ( v7 + 1 < a3 );
  }
}

//----- (10005460) --------------------------------------------------------
_DWORD *__thiscall sub_10005460(_DWORD *this, int a2)
{
  *this = a2;
  this[1] = 0;
  this[102] = 0;
  this[104] = 0;
  memset(this + 2, 0, 0x190u);
  return this;
}

//----- (10005490) --------------------------------------------------------
int __thiscall sub_10005490(_DWORD *this)
{
  int result; // eax

  result = 0;
  this[1] = 0;
  this[102] = 0;
  this[104] = 0;
  memset(this + 2, 0, 0x190u);
  return result;
}

//----- (100054B0) --------------------------------------------------------
int __thiscall sub_100054B0(_DWORD *this, int a2)
{
  unsigned int v3; // ebp
  int result; // eax
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int i; // edx
  int v9; // ecx

  v3 = sub_100082E0();
  result = this[104];
  if ( result )
  {
    v5 = *this / 0x64u;
    v6 = this[1];
    v7 = v3 / v5 % 0x64;
    if ( v3 - v6 < *this )
    {
      for ( i = v6 / v5 % 0x64; i != v7; this[i + 2] = 0 )
      {
        if ( ++i >= 0x64 )
          i = 0;
        this[102] -= this[i + 2];
      }
    }
    else if ( this[102] )
    {
      memset(this + 2, 0, 0x190u);
      this[102] = 0;
    }
    result = a2;
    this[v7 + 2] += a2;
    v9 = this[102];
    this[1] = v3;
    this[102] = a2 + v9;
  }
  else
  {
    this[104] = 1;
    this[103] = v3;
  }
  return result;
}

//----- (10005590) --------------------------------------------------------
int __thiscall sub_10005590(unsigned int *this)
{
  __int64 v2; // rax

  LODWORD(v2) = this[104];
  if ( (_DWORD)v2 == 2 )
    goto LABEL_7;
  if ( !(_DWORD)v2 )
    return v2;
  LODWORD(v2) = sub_100082E0() - this[103];
  if ( (unsigned int)v2 > *this )
  {
    this[104] = 2;
LABEL_7:
    sub_100054B0(this, 0);
    LODWORD(v2) = this[102];
    return v2;
  }
  if ( (_DWORD)v2 )
    v2 = (__int64)((long double)this[102] * (long double)*this / (long double)(unsigned int)v2);
  return v2;
}

//----- (10005630) --------------------------------------------------------
int __thiscall sub_10005630(_DWORD *this)
{
  sub_100054B0(this, 0);
  return this[102];
}

//----- (10005650) --------------------------------------------------------
int __thiscall sub_10005650(_DWORD *this)
{
  int result; // eax

  if ( this[104] )
    result = sub_100082E0() - this[103];
  else
    result = 0;
  return result;
}

//----- (10005670) --------------------------------------------------------
_DWORD *__thiscall sub_10005670(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[3] = 0;
  *this = -1;
  this[1] = 0;
  this[2] = 0;
  return result;
}

//----- (10005690) --------------------------------------------------------
int __thiscall sub_10005690(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(*this);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (100056A0) --------------------------------------------------------
int __thiscall sub_100056A0(void *this)
{
  return j_FIX_DLL_WSOCK32_dll_ord_0008(this);
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);

//----- (100056B0) --------------------------------------------------------
u_long __thiscall sub_100056B0(u_long netlong)
{
  return ntohl_0(netlong);
}

//----- (100056C0) --------------------------------------------------------
int __thiscall sub_100056C0(void *this)
{
  return j_FIX_DLL_WSOCK32_dll_ord_0009(this);
}
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (100056D1) --------------------------------------------------------
// attributes: thunk
int sub_100056D1()
{
  return j_FIX_DLL_WSOCK32_dll_ord_000F();
}
// 1001599C: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_000F(void);

//----- (100056E0) --------------------------------------------------------
_DWORD *__thiscall sub_100056E0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[3] = 0;
  *this = -1;
  this[1] = 0;
  this[2] = 0;
  this[6] = 0;
  this[5] = 0;
  return result;
}

//----- (10005700) --------------------------------------------------------
int __thiscall sub_10005700(int *this)
{
  int result; // eax
  int v3; // esi

  result = sub_10002D70(this[6]);
  v3 = *this;
  if ( v3 != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(v3);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10005750) --------------------------------------------------------
char __thiscall sub_10005750(_DWORD *this, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-4h] BYREF

  v5 = 1;
  if ( !j_FIX_DLL_WSOCK32_dll_ord_000C(a2, -2147195266, &v5) )
    return 1;
  this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
  this[1] = 6;
  j_FIX_DLL_WSOCK32_dll_ord_006F();
  sub_10005120((int)"Socket: %s error %d\n", v5);
  return 0;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);

//----- (100057B0) --------------------------------------------------------
void __thiscall sub_100057B0(_DWORD *this, int a2)
{
  a2 = (unsigned __int8)a2;
  if ( j_FIX_DLL_WSOCK32_dll_ord_0015(*this, 6, 1, &a2, 4) )
  {
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"SetTCPNoDelay");
  }
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159AE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100057F0) --------------------------------------------------------
char __thiscall sub_100057F0(int *this)
{
  int v2; // eax

  if ( *this != -1 )
    return 1;
  v2 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
  *this = v2;
  if ( v2 != -1 )
    return 1;
  this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
  j_FIX_DLL_WSOCK32_dll_ord_006F();
  sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
  if ( this[2] == 10024 )
    this[1] = 3;
  else
    this[1] = 6;
  return 0;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);

//----- (10005850) --------------------------------------------------------
_DWORD *__thiscall sub_10005850(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *this = *a2;
  this[1] = a2[1];
  this[2] = a2[2];
  this[3] = a2[3];
  this[4] = a2[4];
  this[5] = a2[5];
  this[6] = a2[6];
  a2[4] = 0;
  a2[3] = 0;
  *a2 = -1;
  a2[1] = 0;
  a2[2] = 0;
  a2[6] = 0;
  a2[5] = 0;
  return result;
}

//----- (100058A0) --------------------------------------------------------
char __thiscall sub_100058A0(int *this, int a2)
{
  int v3; // eax
  char v5[2]; // [esp+0h] [ebp-18h] BYREF
  __int16 v6; // [esp+2h] [ebp-16h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  if ( *this == -1 )
  {
    v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
    *this = v3;
    if ( v3 == -1 )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
      if ( this[2] == 10024 )
      {
        this[1] = 3;
        return 0;
      }
      goto LABEL_7;
    }
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v7 = j_FIX_DLL_WSOCK32_dll_ord_0008(a2);
  v6 = j_FIX_DLL_WSOCK32_dll_ord_0009(0);
  if ( j_FIX_DLL_WSOCK32_dll_ord_0002(*this, v5, 16) == -1 )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Bind");
LABEL_7:
    this[1] = 6;
    return 0;
  }
  return 1;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);

//----- (10005980) --------------------------------------------------------
char __thiscall sub_10005980(int *this, int *a2)
{
  int v3; // eax
  char result; // al
  _DWORD *v5; // edi
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  _BYTE v12[8]; // [esp-8h] [ebp-44h] BYREF
  int *v13; // [esp+0h] [ebp-3Ch] BYREF
  int v14; // [esp+8h] [ebp-34h]
  int v15; // [esp+Ch] [ebp-30h]
  char v16; // [esp+24h] [ebp-18h] BYREF
  __int16 v17; // [esp+26h] [ebp-16h]
  int v18[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( *this == -1 && (v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0), *this = v3, v3 == -1) )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
    v14 = j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
    if ( this[2] == 10024 )
      this[1] = 3;
    else
      this[1] = 6;
    result = 0;
  }
  else
  {
    v5 = (_DWORD *)this[6];
    this[3] = *a2;
    this[4] = a2[1];
    if ( !v5 )
      v5 = this + 3;
    v18[0] = 2;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = 0;
    v18[0] = j_FIX_DLL_WSOCK32_dll_ord_0008(*v5);
    LOWORD(v6) = *((_WORD *)v5 + 2);
    v17 = j_FIX_DLL_WSOCK32_dll_ord_0009(v6);
    v7 = *this;
    v15 = 16;
    v14 = (int)&v16;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0004(v7) == -1 )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      v13 = (int *)j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"Connect");
      v8 = this[2];
      if ( v8 == 10061 || v8 == 10051 )
      {
        if ( this[6] )
          this[1] = 4;
        else
          this[1] = 1;
        result = 0;
      }
      else
      {
        this[1] = 6;
        result = 0;
      }
    }
    else
    {
      v9 = *this;
      v18[0] = 1;
      if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v9, -2147195266, v18) )
      {
        this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
        this[1] = 6;
        j_FIX_DLL_WSOCK32_dll_ord_006F();
        sub_10005120((int)"Socket: %s error %d\n", (int)"Connect/ioctlsocket");
        result = 0;
      }
      else if ( this[6] )
      {
        this[5] = 1;
        while ( 1 )
        {
          v10 = this[5];
          v13 = this;
          if ( v10 == 9 || !v10 )
          {
            if ( v12 != (_BYTE *)-16 )
              v14 = 0;
          }
          else if ( v12 != (_BYTE *)-16 )
          {
            if ( v10 == 1 )
            {
              v14 = 6;
            }
            else if ( v10 == 2 || v10 == 4 || v10 == 6 )
            {
              v14 = 2;
            }
            else
            {
              v14 = 1;
            }
          }
          v11 = sub_100065F0((int)&v13, 1, 0x7530u);
          if ( v11 < 0 || v11 && !sub_100077B0(this, v14) )
            break;
          if ( this[5] == 9 )
            goto LABEL_37;
        }
        this[5] = 0;
        result = 0;
      }
      else
      {
LABEL_37:
        this[5] = 9;
        result = 1;
      }
    }
  }
  return result;
}
// 10005A2E: variable 'v6' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159C0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD);

//----- (10005BD0) --------------------------------------------------------
char __thiscall sub_10005BD0(int *this, int a2)
{
  int v3; // eax
  char result; // al
  int v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // edi
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // [esp-18h] [ebp-3Ch]
  int v12; // [esp-14h] [ebp-38h]
  int v13; // [esp-4h] [ebp-28h]
  int v14; // [esp-4h] [ebp-28h]
  int v15; // [esp-4h] [ebp-28h]
  int v16; // [esp-4h] [ebp-28h]
  int v17; // [esp+0h] [ebp-24h] BYREF
  int v18; // [esp+8h] [ebp-1Ch]
  int v19; // [esp+Ch] [ebp-18h]
  int v20[3]; // [esp+10h] [ebp-14h] BYREF
  _DWORD *v21; // [esp+1Ch] [ebp-8h]

  if ( *this == -1 && (v3 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0), *this = v3, v3 == -1) )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v13, v17);
    j_FIX_DLL_WSOCK32_dll_ord_006F(v14, v17);
    sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
    if ( this[2] == 10024 )
      this[1] = 3;
    else
      this[1] = 6;
    result = 0;
  }
  else
  {
    v5 = *this;
    v20[0] = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v5, -2147195266, v20) )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v15, v17);
      this[1] = 6;
      j_FIX_DLL_WSOCK32_dll_ord_006F(v16, v17);
      sub_10005120((int)"Socket: %s error %d\n", (int)"AsyncConnect/ioctlsocket");
      result = 0;
    }
    else
    {
      v6 = v21;
      v7 = (_DWORD *)this[6];
      this[3] = *v21;
      this[4] = v6[1];
      if ( !v7 )
        v7 = this + 3;
      v18 = 2;
      v19 = 0;
      v20[0] = 0;
      v20[1] = 0;
      v18 = j_FIX_DLL_WSOCK32_dll_ord_0008(*v7);
      LOWORD(v8) = *((_WORD *)v7 + 2);
      HIWORD(v17) = j_FIX_DLL_WSOCK32_dll_ord_0009(v8);
      if ( j_FIX_DLL_WSOCK32_dll_ord_0004(*this) != -1 || (v9 = j_FIX_DLL_WSOCK32_dll_ord_006F(&v17, 16), v9 == 10035) )
      {
        this[5] = 1;
        result = 1;
      }
      else
      {
        this[2] = v9;
        j_FIX_DLL_WSOCK32_dll_ord_006F(v11, v12);
        sub_10005120((int)"Socket: %s error %d\n", (int)"AsyncConnect/connect");
        v10 = this[2];
        if ( v10 == 10061 || v10 == 10051 )
        {
          if ( this[6] )
            this[1] = 4;
          else
            this[1] = 1;
          this[5] = 0;
          result = 0;
        }
        else
        {
          this[1] = 6;
          this[5] = 0;
          result = 0;
        }
      }
    }
  }
  return result;
}
// 10005BD0: could not find valid save-restore pair for edi
// 10005BF2: variable 'v13' is possibly undefined
// 10005BFA: variable 'v14' is possibly undefined
// 10005C58: variable 'v15' is possibly undefined
// 10005C67: variable 'v16' is possibly undefined
// 10005CCE: variable 'v8' is possibly undefined
// 10005D00: variable 'v11' is possibly undefined
// 10005D00: variable 'v12' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A2: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_006F(_DWORD, _DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159C0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0004(_DWORD);

//----- (10005DA0) --------------------------------------------------------
_BOOL1 __thiscall sub_10005DA0(int *this, _DWORD *a2)
{
  int v3; // eax
  int v4; // esi
  _BOOL1 result; // al
  u_long v6; // eax
  u_long *v7; // esi
  int v8; // [esp-Ah] [ebp-24h]
  __int16 v9; // [esp+0h] [ebp-1Ah]
  u_long netlong; // [esp+2h] [ebp-18h]
  int v11; // [esp+6h] [ebp-14h] BYREF
  char v12[8]; // [esp+Ah] [ebp-10h] BYREF
  u_long *v13; // [esp+12h] [ebp-8h]

  v3 = this[6];
  if ( v3 )
  {
    *a2 = *(_DWORD *)(v3 + 288);
    a2[1] = *(_DWORD *)(v3 + 292);
    v4 = this[5];
    result = v4 == 9 || v4 == 8;
  }
  else
  {
    v8 = *this;
    v11 = 16;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0006(v8, v12, &v11) )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      this[1] = 6;
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"GetLocalAddress");
      result = 0;
    }
    else
    {
      v6 = ntohl_0(netlong);
      v7 = v13;
      *v13 = v6;
      v7[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(v9);
      result = 1;
    }
  }
  return result;
}
// 10005E37: variable 'netlong' is possibly undefined
// 10005E47: variable 'v9' is possibly undefined
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159C6: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0006(_DWORD, _DWORD, _DWORD);

//----- (10005E60) --------------------------------------------------------
char __thiscall sub_10005E60(int *this, int a2, int a3)
{
  int v4; // eax
  int v5; // eax
  int v7; // eax
  char v8[2]; // [esp+0h] [ebp-24h] BYREF
  __int16 v9; // [esp+2h] [ebp-22h]
  int v10; // [esp+8h] [ebp-1Ch]
  int v11; // [esp+Ch] [ebp-18h]
  int v12[5]; // [esp+10h] [ebp-14h] BYREF

  if ( *this == -1 )
  {
    v4 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 1, 0);
    *this = v4;
    if ( v4 == -1 )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
      v5 = this[2];
LABEL_4:
      if ( v5 == 10024 )
      {
        this[1] = 3;
        return 0;
      }
LABEL_14:
      this[1] = 6;
      return 0;
    }
  }
  v7 = *this;
  v12[0] = 1;
  if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v7, -2147195266, v12) )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
    this[1] = 6;
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Listen/ioctlsocket");
    return 0;
  }
  v11 = 0;
  v12[0] = 0;
  v12[1] = 0;
  v10 = j_FIX_DLL_WSOCK32_dll_ord_0008(v12[4]);
  v9 = j_FIX_DLL_WSOCK32_dll_ord_0009(v12[2]);
  if ( j_FIX_DLL_WSOCK32_dll_ord_0002(*this, v8, 16) == -1 )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Listen/bind");
    if ( this[2] == 10048 )
    {
      this[1] = 2;
      return 0;
    }
    goto LABEL_14;
  }
  if ( j_FIX_DLL_WSOCK32_dll_ord_000D(*this, 100) == -1 )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Listen/listen");
    v5 = this[2];
    if ( v5 == 10048 )
    {
      this[1] = 2;
      return 0;
    }
    goto LABEL_4;
  }
  return 1;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);
// 100159CC: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000D(_DWORD, _DWORD);

//----- (10006000) --------------------------------------------------------
char __thiscall sub_10006000(int *this, int a2)
{
  int v3; // edi
  int v4; // eax
  char result; // al
  int *v6; // esi
  int v7; // [esp-6h] [ebp-2Ch]
  _BYTE v8[6]; // [esp+0h] [ebp-26h]
  int v9; // [esp+6h] [ebp-20h] BYREF
  int v10; // [esp+Eh] [ebp-18h] BYREF
  int *v11; // [esp+12h] [ebp-14h]
  char v12[16]; // [esp+16h] [ebp-10h] BYREF

  *(_DWORD *)&v8[2] = &v10;
  v7 = *this;
  v10 = 16;
  v3 = j_FIX_DLL_WSOCK32_dll_ord_0001(v7, v12);
  if ( v3 == -1 )
  {
    v4 = j_FIX_DLL_WSOCK32_dll_ord_006F();
    this[2] = v4;
    if ( v4 != 10035 )
    {
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"Accept");
    }
    if ( this[2] == 10024 )
      this[1] = 3;
    else
      this[1] = 6;
    result = 0;
  }
  else
  {
    v9 = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v3, -2147195266, &v9) )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      this[1] = 6;
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"Accept/ioctlsocket");
      result = 0;
    }
    else
    {
      v6 = v11;
      *v11 = v3;
      v6[5] = 9;
      v6[3] = ntohl_0((u_long)&v10);
      v6[4] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(*(_DWORD *)v8);
      result = 1;
    }
  }
  return result;
}
// 100060E6: variable 'v8' is possibly undefined
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);
// 100159D2: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0001(_DWORD, _DWORD);

//----- (10006100) --------------------------------------------------------
int __thiscall sub_10006100(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int result; // eax

  v3 = a3;
  if ( a3 > 2048 )
    v3 = 2048;
  v5 = j_FIX_DLL_WSOCK32_dll_ord_0013(*this, a2, v3, 0);
  if ( v5 >= 0 )
    return v5;
  v6 = j_FIX_DLL_WSOCK32_dll_ord_006F();
  this[2] = v6;
  if ( v6 == 10004 || v6 == 10035 )
    return 0;
  if ( v6 != 10053 && v6 != 10054 )
  {
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Send");
  }
  v7 = this[2];
  if ( v7 != 10050 && v7 != 10052 && v7 != 10065 && v7 != 10053 && v7 != 10054 && v7 != 10060 )
  {
    this[1] = 6;
    return v5;
  }
  result = v5;
  this[1] = 1;
  return result;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159D8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0013(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100061C0) --------------------------------------------------------
int __thiscall sub_100061C0(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int v5; // edi
  int result; // eax
  int v7; // eax
  int v8; // eax

  v4 = j_FIX_DLL_WSOCK32_dll_ord_0010(*this, a2, a3, 0);
  v5 = v4;
  if ( !v4 )
  {
    this[1] = 1;
    this[2] = 0;
    return -1;
  }
  if ( v4 >= 0 )
    return v5;
  v7 = j_FIX_DLL_WSOCK32_dll_ord_006F();
  this[2] = v7;
  if ( v7 == 10004 || v7 == 10035 )
    return 0;
  if ( v7 != 10053 && v7 != 10054 )
  {
    j_FIX_DLL_WSOCK32_dll_ord_006F();
    sub_10005120((int)"Socket: %s error %d\n", (int)"Receive");
  }
  v8 = this[2];
  if ( v8 != 10050 && v8 != 10052 && v8 != 10053 && v8 != 10060 && v8 != 10054 )
  {
    this[1] = 6;
    return v5;
  }
  result = v5;
  this[1] = 1;
  return result;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159DE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0010(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006280) --------------------------------------------------------
u_long *__thiscall sub_10006280(u_long *this, _BYTE *a2, u_long a3)
{
  const char *v4; // eax
  unsigned __int32 v5; // eax
  _BYTE *v6; // eax
  int v7; // eax

  this[1] = a3;
  v4 = sub_10003260(a2);
  v5 = inet_addr_0(v4);
  *this = v5;
  if ( v5 == -1 )
  {
    v6 = sub_10003260(a2);
    v7 = j_FIX_DLL_WSOCK32_dll_ord_0034(v6);
    if ( !v7 )
    {
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"Address/gethostbyname");
      this[1] = 0;
      *this = 0;
      return this;
    }
    *this = ***(_DWORD ***)(v7 + 12);
  }
  *this = ntohl_0(*this);
  return this;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159E4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0034(_DWORD);

//----- (10006300) --------------------------------------------------------
u_long *__thiscall sub_10006300(u_long *this, void *src)
{
  char *v3; // eax
  char *v4; // edi
  const char *v5; // eax
  char v6; // al
  unsigned int v7; // eax
  const char *v8; // eax
  unsigned __int32 v9; // eax
  _BYTE *v10; // eax
  int v11; // eax
  int v13; // [esp-4h] [ebp-90h]
  char dst[128]; // [esp+Ch] [ebp-80h] BYREF

  strncpyt(dst, src, 128);
  v3 = strchr_0(dst, 58);
  v4 = v3;
  if ( !v3 )
    goto LABEL_10;
  v5 = sub_10003260(v3 + 1);
  this[1] = atol_1(v5);
  if ( sub_10003260(dst) == v4 )
    goto LABEL_10;
  v6 = *sub_10003260(v4 + 1);
  if ( v6 < 48 )
    goto LABEL_10;
  if ( v6 > 57 )
    goto LABEL_10;
  v7 = this[1];
  if ( !v7 || v7 > 0xFFFF )
    goto LABEL_10;
  *v4 = 0;
  sub_10003280(dst);
  v8 = sub_10003260(dst);
  v9 = inet_addr_0(v8);
  *this = v9;
  if ( v9 == -1 )
  {
    v10 = sub_10003260(dst);
    v11 = j_FIX_DLL_WSOCK32_dll_ord_0034(v10);
    if ( !v11 )
    {
      j_FIX_DLL_WSOCK32_dll_ord_006F(v13);
      sub_10005120((int)"Socket: %s error %d\n", (int)"Address/gethostbyname");
LABEL_10:
      this[1] = 0;
      *this = 0;
      return this;
    }
    *this = ***(_DWORD ***)(v11 + 12);
  }
  *this = ntohl_0(*this);
  return this;
}
// 100063AD: variable 'v13' is possibly undefined
// 100159E4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0034(_DWORD);

//----- (10006410) --------------------------------------------------------
char *__thiscall sub_10006410(_DWORD *this, char *a2)
{
  sprintf_0(a2, "%u.%u.%u.%u", HIBYTE(*this), (unsigned __int8)BYTE2(*this), BYTE1(*this), (unsigned __int8)*this);
  return a2;
}

//----- (10006450) --------------------------------------------------------
char *__thiscall sub_10006450(_DWORD *this, char *a2)
{
  sprintf_0(
    a2,
    "%u.%u.%u.%u:%u",
    HIBYTE(*this),
    (unsigned __int8)BYTE2(*this),
    BYTE1(*this),
    (unsigned __int8)*this,
    this[1]);
  return a2;
}

//----- (10006490) --------------------------------------------------------
char *__fastcall sub_10006490(char *a1, unsigned int a2)
{
  sprintf_0(a1, "%u.%u.%u.%u", HIBYTE(a2), BYTE2(a2), BYTE1(a2), (unsigned __int8)a2);
  return a1;
}

//----- (100064D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int32 __fastcall sub_100064D0(char *a1, const char **a2)
{
  char *v2; // esi
  __int32 v4; // edi
  char v5; // al
  __int32 i; // edi
  char v7; // al
  const char *v8; // esi
  __int32 v9; // edi
  char j; // al
  char v11; // cl
  const char *v12; // esi
  __int32 v13; // edi
  char k; // al
  char v15; // dl
  const char *v16; // esi
  __int32 v17; // edi
  char l; // al

  v2 = a1;
  if ( *a1 < 48 || *a1 > 57 )
    return 0;
  v4 = atol_1(a1);
  v5 = *v2;
  for ( i = v4 << 24; v5 >= 48; v5 = *++v2 )
  {
    if ( v5 > 57 )
      break;
  }
  v7 = *v2;
  v8 = v2 + 1;
  if ( v7 != 46 || *v8 < 48 || *v8 > 57 )
    return 0;
  v9 = (atol_1(v8) << 16) | i;
  for ( j = *v8; j >= 48; j = *++v8 )
  {
    if ( j > 57 )
      break;
  }
  v11 = *v8;
  v12 = v8 + 1;
  if ( v11 != 46 || *v12 < 48 || *v12 > 57 )
    return 0;
  v13 = (atol_1(v12) << 8) | v9;
  for ( k = *v12; k >= 48; k = *++v12 )
  {
    if ( k > 57 )
      break;
  }
  v15 = *v12;
  v16 = v12 + 1;
  if ( v15 != 46 || *v16 < 48 || *v16 > 57 )
    return 0;
  v17 = atol_1(v16) | v13;
  if ( a2 )
  {
    for ( l = *v16; l >= 48; l = *++v16 )
    {
      if ( l > 57 )
        break;
    }
    *a2 = v16;
  }
  return v17;
}
// 100065B2: positive sp value 10 has been found

//----- (100065C0) --------------------------------------------------------
_BYTE *__thiscall sub_100065C0(_DWORD *this)
{
  _BYTE **v1; // eax
  _BYTE *result; // eax
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[1] = (int)this;
  v3[0] = j_FIX_DLL_WSOCK32_dll_ord_0008(*this);
  v1 = (_BYTE **)((int (__cdecl *)(int *, int, int))j_FIX_DLL_WSOCK32_dll_ord_0033)(v3, 4, 2);
  if ( !v1 || (result = *v1) == 0 || !*result )
    result = 0;
  return result;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 100159F0: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0033(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100065F0) --------------------------------------------------------
int __fastcall sub_100065F0(int a1, int a2, unsigned int a3)
{
  int v3; // ebx
  int v4; // esi
  int result; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // edx
  int **v9; // eax
  int *v10; // ecx
  int v11; // edi
  _BOOL1 v12; // cc
  int *v13; // ecx
  int v14; // edi
  int *v15; // esi
  int v16; // eax
  int v17; // eax
  int v18; // eax
  char v19[8]; // [esp+8h] [ebp-3020h] BYREF
  int v20; // [esp+10h] [ebp-3018h]
  int v21[2]; // [esp+14h] [ebp-3014h] BYREF
  int v22[1018]; // [esp+1Ch] [ebp-300Ch] BYREF
  char v23[28]; // [esp+1004h] [ebp-2024h] BYREF
  int v24[1016]; // [esp+1020h] [ebp-2008h] BYREF
  char v25[36]; // [esp+2000h] [ebp-1028h] BYREF
  int v26[1025]; // [esp+2024h] [ebp-1004h] BYREF

  v3 = a2;
  v4 = a1;
  v20 = a1;
  if ( !a2 )
  {
    FIX_DLL_KERNEL32_dll_Sleep(a3);
    return 0;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v22[0] = 0;
  v24[0] = 0;
  v26[0] = 0;
  v9 = (int **)a1;
  v21[0] = v3;
  do
  {
    v10 = v9[2];
    if ( ((unsigned __int8)v10 & 1) != 0 && v6 < 0x400 )
    {
      v22[v6 + 1] = **v9;
      v4 = v20;
      v6 = ++v22[0];
    }
    if ( ((unsigned __int8)v10 & 2) != 0 && v7 < 0x400 )
    {
      v24[v7 + 1] = **v9;
      v4 = v20;
      v7 = ++v24[0];
    }
    if ( ((unsigned __int8)v10 & 4) != 0 && v8 < 0x400 )
    {
      v26[v8 + 1] = **v9;
      v8 = ++v26[0];
    }
    v9 += 3;
    --v21[0];
  }
  while ( v21[0] );
  v21[0] = a3 / 0x3E8;
  v21[1] = 1000 * (a3 % 0x3E8);
  v11 = j_FIX_DLL_WSOCK32_dll_ord_0012(1, v22, v24, v26, v21);
  v12 = v11 <= 0;
  if ( v11 < 0 )
  {
    if ( j_FIX_DLL_WSOCK32_dll_ord_006F() != 10004 && j_FIX_DLL_WSOCK32_dll_ord_006F() != 10035 )
    {
      if ( j_FIX_DLL_WSOCK32_dll_ord_006F() == 10038 )
      {
        if ( v3 == 1 )
        {
          v13 = *(int **)v4;
          *(_DWORD *)(v4 + 8) = 4;
          sub_10005120((int)"Socket: WSAENOTSOCK bug detected for socket %d\n", *v13);
          result = 1;
        }
        else
        {
          v14 = 0;
          if ( !v3 )
            goto LABEL_26;
          do
          {
            if ( (int)sub_100065F0(0) <= 0 )
              *(_DWORD *)(v4 + 8) = 0;
            else
              v14 = 1;
            v4 += 12;
            --v3;
          }
          while ( v3 );
          if ( !v14 )
LABEL_26:
            FIX_DLL_KERNEL32_dll_Sleep(a3);
          result = v14;
        }
        return result;
      }
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"Select");
    }
    v12 = v11 <= 0;
  }
  if ( v12 )
    return v11;
  v15 = (int *)(v4 + 8);
  do
  {
    if ( (*(_BYTE *)v15 & 1) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v15 - 2), v19) )
    {
      v16 = *v15;
      LOBYTE(v16) = *v15 & 0xFE;
      *v15 = v16;
    }
    if ( (*(_BYTE *)v15 & 2) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v15 - 2), v23) )
    {
      v17 = *v15;
      LOBYTE(v17) = *v15 & 0xFD;
      *v15 = v17;
    }
    if ( (*(_BYTE *)v15 & 4) != 0 && !j_FIX_DLL_WSOCK32_dll_ord_0097(*(_DWORD *)*(v15 - 2), v25) )
    {
      v18 = *v15;
      LOBYTE(v18) = *v15 & 0xFB;
      *v15 = v18;
    }
    v15 += 3;
    --v3;
  }
  while ( v3 );
  return 1;
}
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159F6: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0097(_DWORD, _DWORD);
// 10021074: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_Sleep)(_DWORD);

//----- (10006880) --------------------------------------------------------
_BOOL1 __thiscall sub_10006880(int *this, int a2, int a3)
{
  int v3; // eax
  int v5; // edx
  int v6; // eax
  _BOOL1 result; // al
  int v8; // eax
  int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // [esp-1Ch] [ebp-68h]
  int v15; // [esp-1Ch] [ebp-68h]
  int *v16; // [esp-18h] [ebp-64h]
  int v17; // [esp-18h] [ebp-64h]
  int v18[6]; // [esp+0h] [ebp-4Ch] BYREF
  char v19[4]; // [esp+18h] [ebp-34h] BYREF
  int v20; // [esp+1Ch] [ebp-30h]
  int v21; // [esp+20h] [ebp-2Ch]
  int v22; // [esp+24h] [ebp-28h]
  int v23[9]; // [esp+28h] [ebp-24h] BYREF

  v3 = a2;
  this[3] = *(_DWORD *)a2;
  v5 = *(_DWORD *)(v3 + 4);
  v6 = *(int *)((char *)this + 86);
  this[4] = v5;
  if ( v6 )
  {
    *((_BYTE *)this + 20) = this[3] == 0;
    result = *(_DWORD *)(v6 + 20) == 9;
  }
  else if ( *this == -1 && (v8 = j_FIX_DLL_WSOCK32_dll_ord_0017(2, 2, 0), *this = v8, v8 == -1) )
  {
    this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v21, v22);
    v20 = j_FIX_DLL_WSOCK32_dll_ord_006F(v21, v22);
    sub_10005120((int)"Socket: %s error %d\n", (int)"CreateSocket");
    if ( this[2] == 10024 )
      this[1] = 3;
    else
      this[1] = 6;
    result = 0;
  }
  else
  {
    v9 = *this;
    a2 = 1;
    if ( j_FIX_DLL_WSOCK32_dll_ord_000C(v9, -2147195266, &a2) )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v21, v22);
      this[1] = 6;
      v20 = j_FIX_DLL_WSOCK32_dll_ord_006F(v21, v22);
      sub_10005120((int)"Socket: %s error %d\n", (int)"AsyncConnect/ioctlsocket");
      result = 0;
    }
    else
    {
      v23[0] = 0x10000;
      v23[1] = 0x10000;
      j_FIX_DLL_WSOCK32_dll_ord_0015(*this, 0xFFFF, 4097, v23, 4);
      j_FIX_DLL_WSOCK32_dll_ord_0015(*this, 0xFFFF, 4098, v19, 4);
      v10 = ((unsigned int)this + 37) & 0xFFFFFFF0;
      *(_DWORD *)v10 = 0;
      *(_DWORD *)(v10 + 4) = 0;
      *(_DWORD *)(v10 + 8) = 0;
      *(_DWORD *)(v10 + 12) = 0;
      *(_WORD *)v10 = 2;
      v11 = j_FIX_DLL_WSOCK32_dll_ord_0008(this[3]);
      *(_DWORD *)(v10 + 4) = v11;
      LOWORD(v11) = *((_WORD *)this + 8);
      *(_WORD *)(v10 + 2) = j_FIX_DLL_WSOCK32_dll_ord_0009(v11);
      if ( !this[3] || v19[0] )
      {
        v13 = *this;
        v16 = (int *)(((unsigned int)this + 37) & 0xFFFFFFF0);
        *((_BYTE *)this + 20) = 1;
        v14 = v13;
      }
      else
      {
        v12 = *this;
        HIWORD(v18[0]) = 0;
        v18[1] = 0;
        v18[2] = 0;
        v16 = v18;
        *((_BYTE *)this + 20) = 0;
        v18[3] = 0;
        LOWORD(v18[0]) = 2;
        v14 = v12;
      }
      if ( j_FIX_DLL_WSOCK32_dll_ord_0002(v14, v16, 16) >= 0 )
      {
        result = 1;
      }
      else
      {
        j_FIX_DLL_WSOCK32_dll_ord_006F(v15, v17);
        sub_10005120((int)"Socket: %s error %d\n", (int)"bind");
        result = 0;
      }
    }
  }
  return result;
}
// 10006A21: variable 'v15' is possibly undefined
// 10006A21: variable 'v17' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 100159A2: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_006F(_DWORD, _DWORD);
// 100159A8: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000C(_DWORD, _DWORD, _DWORD);
// 100159AE: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0015(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100159B4: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0017(_DWORD, _DWORD, _DWORD);
// 100159BA: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0002(_DWORD, _DWORD, _DWORD);

//----- (10006A60) --------------------------------------------------------
int __thiscall sub_10006A60(_DWORD *this, void *a2, signed int a3)
{
  _DWORD *v4; // ecx
  int result; // eax

  v4 = *(_DWORD **)((char *)this + 86);
  if ( v4 )
    result = sub_10007160(v4, a2, a3, this + 3);
  else
    result = j_FIX_DLL_WSOCK32_dll_ord_0014();
  return result;
}

//----- (10006AA0) --------------------------------------------------------
signed int __thiscall sub_10006AA0(_DWORD *this, void *a2, signed int a3, int a4)
{
  int *v5; // ecx
  char v7; // al
  int v8; // ebp
  int v9; // ecx
  __int16 v10; // [esp+0h] [ebp-102Ah]
  int v11; // [esp+12h] [ebp-1018h] BYREF
  int v12[4]; // [esp+16h] [ebp-1014h] BYREF
  int v13; // [esp+26h] [ebp-1004h] BYREF
  int v14; // [esp+2Ah] [ebp-1000h]

  v5 = *(int **)((char *)this + 86);
  if ( !v5 )
  {
    if ( a4 )
    {
      v14 = *this;
      v13 = 1;
      v12[1] = 1000 * a4;
      v12[0] = 0;
      if ( j_FIX_DLL_WSOCK32_dll_ord_0012(v14 + 1, &v13, 0, 0, v12) <= 0 )
        return 0;
    }
    v7 = *((_BYTE *)this + 20);
    v11 = 16;
    if ( v7 )
    {
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0011(*this, a2, a3, 0, ((unsigned int)this + 37) & 0xFFFFFFF0);
      if ( v8 <= 0 )
        return 0;
      this[3] = ntohl_0(*(_DWORD *)((((unsigned int)this + 37) & 0xFFFFFFF0) + 4));
      LOWORD(v9) = *(_WORD *)((((unsigned int)this + 37) & 0xFFFFFFF0) + 2);
      this[4] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(v9);
    }
    else
    {
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0011(*this, a2, a3, 0, v12);
      if ( *(_WORD *)((((unsigned int)this + 37) & 0xFFFFFFF0) + 2) != v10
        || *(int **)((((unsigned int)this + 37) & 0xFFFFFFF0) + 4) != &v11 )
      {
        return 0;
      }
    }
    if ( v8 > 0 )
      return v8;
    return 0;
  }
  if ( *((_BYTE *)this + 20) )
  {
    this[4] = 0;
    this[3] = 0;
  }
  return sub_10007240(v5, a2, a3, this + 3, a4);
}
// 10006B9C: variable 'v9' is possibly undefined
// 10006BD5: variable 'v10' is possibly undefined
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);
// 10015A08: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0011(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10006C10) --------------------------------------------------------
int __thiscall sub_10006C10(char *this, _DWORD *a2)
{
  u_long v3; // eax
  int result; // eax

  this[20] = 0;
  this[21] = 1;
  memcpy_0(this + 22, (char *)a2 + 22, 0x40u);
  *(_DWORD *)this = *a2;
  *((_DWORD *)this + 1) = a2[1];
  *((_DWORD *)this + 2) = a2[2];
  v3 = ntohl_0(*(_DWORD *)(((unsigned int)(this + 37) & 0xFFFFFFF0) + 4));
  *((_DWORD *)this + 3) = v3;
  LOWORD(v3) = *(_WORD *)(((unsigned int)(this + 37) & 0xFFFFFFF0) + 2);
  result = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(v3);
  *((_DWORD *)this + 4) = result;
  *(_DWORD *)(this + 86) = *(_DWORD *)((char *)a2 + 86);
  return result;
}
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);

//----- (10006C80) --------------------------------------------------------
int __thiscall sub_10006C80(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // esi
  int v4; // eax
  int result; // eax

  this[3] = *a2;
  v3 = ((unsigned int)this + 37) & 0xFFFFFFF0;
  this[4] = a2[1];
  *(_DWORD *)v3 = 0;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_WORD *)v3 = 2;
  v4 = j_FIX_DLL_WSOCK32_dll_ord_0008(this[3]);
  *(_DWORD *)(v3 + 4) = v4;
  LOWORD(v4) = *((_WORD *)this + 8);
  result = j_FIX_DLL_WSOCK32_dll_ord_0009(v4);
  *(_WORD *)(v3 + 2) = result;
  return result;
}
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (10006CD0) --------------------------------------------------------
int __thiscall sub_10006CD0(int *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 && !*((_BYTE *)this + 21) )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(result);
  *this = -1;
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10006CF0) --------------------------------------------------------
char __thiscall sub_10006CF0(int *this, _DWORD *a2)
{
  int v3; // eax
  int v4; // ecx
  char result; // al
  u_long v6; // eax
  u_long *v7; // esi
  int v8; // [esp-Ah] [ebp-24h]
  __int16 v9; // [esp+0h] [ebp-1Ah]
  u_long netlong; // [esp+2h] [ebp-18h]
  int v11; // [esp+6h] [ebp-14h] BYREF
  char v12[8]; // [esp+Ah] [ebp-10h] BYREF
  u_long *v13; // [esp+12h] [ebp-8h]

  v3 = *(int *)((char *)this + 86);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 24);
    *a2 = *(_DWORD *)(v4 + 288);
    a2[1] = *(_DWORD *)(v4 + 292);
    result = 1;
  }
  else
  {
    v8 = *this;
    v11 = 16;
    if ( j_FIX_DLL_WSOCK32_dll_ord_0006(v8, v12, &v11) )
    {
      this[2] = j_FIX_DLL_WSOCK32_dll_ord_006F();
      this[1] = 6;
      j_FIX_DLL_WSOCK32_dll_ord_006F();
      sub_10005120((int)"Socket: %s error %d\n", (int)"GetLocalAddress");
      result = 0;
    }
    else
    {
      v6 = ntohl_0(netlong);
      v7 = v13;
      *v13 = v6;
      v7[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(v9);
      result = 1;
    }
  }
  return result;
}
// 10006D71: variable 'netlong' is possibly undefined
// 10006D81: variable 'v9' is possibly undefined
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);
// 100159A2: using guessed type int j_FIX_DLL_WSOCK32_dll_ord_006F(void);
// 100159C6: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0006(_DWORD, _DWORD, _DWORD);

//----- (10006DA0) --------------------------------------------------------
_DWORD *__thiscall sub_10006DA0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[3] = 0;
  *this = -1;
  this[1] = 0;
  this[2] = 0;
  *(_DWORD *)((char *)this + 86) = 0;
  *((_BYTE *)this + 21) = 0;
  return result;
}

//----- (10006DC0) --------------------------------------------------------
char __thiscall sub_10006DC0(_BYTE *this)
{
  char result; // al

  if ( *(_DWORD *)this != -1 && !this[21] )
    j_FIX_DLL_WSOCK32_dll_ord_0003(*(_DWORD *)this);
  result = this[21];
  *(_DWORD *)this = -1;
  if ( result )
    *(_DWORD *)this = -1;
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10006DF0) --------------------------------------------------------
int *__thiscall sub_10006DF0(int *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // esi
  _BOOL1 v5; // zf
  void *v6; // eax
  int *v7; // ecx
  int v8; // eax
  int *v9; // esi
  int v10; // eax
  int v11; // eax
  int v12; // edx
  int v14; // [esp-Ch] [ebp-40h]
  int v15; // [esp-Ch] [ebp-40h]
  int v16; // [esp-8h] [ebp-3Ch]
  int v17; // [esp-8h] [ebp-3Ch]
  int v18[3]; // [esp+0h] [ebp-34h] BYREF
  __int64 v19; // [esp+Ch] [ebp-28h] BYREF
  int v20; // [esp+14h] [ebp-20h]
  int v21[6]; // [esp+18h] [ebp-1Ch] BYREF
  int v22; // [esp+30h] [ebp-4h]

  LODWORD(v19) = this;
  this[4] = 0;
  this[3] = 0;
  *this = -1;
  this[1] = 0;
  this[2] = 0;
  this[6] = 0;
  this[5] = 0;
  v22 = 0;
  this[10] = 0;
  this[9] = 0;
  this[8] = 0;
  LOBYTE(v22) = 1;
  v3 = sub_10002CC0(90);
  if ( v3 )
  {
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 12) = 0;
    *(_DWORD *)v3 = -1;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 86) = 0;
    *(_BYTE *)(v3 + 21) = 0;
  }
  else
  {
    v3 = 0;
  }
  this[7] = v3;
  if ( !this[5] )
  {
    sub_10002D70(this[6]);
    v4 = (_DWORD *)a2;
    v5 = a2 == 0;
    this[6] = 0;
    if ( !v5 )
    {
      if ( *v4 )
      {
        v6 = (void *)sub_10002CC0(301);
        this[6] = (int)v6;
        qmemcpy(v6, v4, 0x88u);
        *(_DWORD *)(this[6] + 284) = 0;
        *(_DWORD *)(this[6] + 297) = 3;
      }
    }
  }
  v7 = (int *)this[7];
  HIDWORD(v19) = 1;
  v20 = 1;
  if ( sub_10006880(v7, (int)&v19 + 4, 0) )
  {
    v9 = (int *)this[7];
    v10 = *(int *)((char *)v9 + 86);
    if ( v10 )
    {
      v11 = *(_DWORD *)(v10 + 24);
      HIDWORD(v19) = *(_DWORD *)(v11 + 288);
      v20 = *(_DWORD *)(v11 + 292);
    }
    else
    {
      v12 = *v9;
      a2 = 16;
      if ( j_FIX_DLL_WSOCK32_dll_ord_0006(v12, v21, &a2) )
      {
        v9[2] = j_FIX_DLL_WSOCK32_dll_ord_006F(v14, v16);
        v9[1] = 6;
        j_FIX_DLL_WSOCK32_dll_ord_006F(v15, v17);
        sub_10005120((int)"Socket: %s error %d\n", (int)"GetLocalAddress");
      }
      else
      {
        ntohl_0(HIDWORD(v19));
        v18[1] = (unsigned __int16)j_FIX_DLL_WSOCK32_dll_ord_000F(*(_DWORD *)((char *)&v19 + 2));
      }
    }
    v18[0] = 0;
    sub_10005BD0(this, (int)v18);
  }
  else
  {
    v8 = this[7];
    this[1] = *(_DWORD *)(v8 + 4);
    this[2] = *(_DWORD *)(v8 + 8);
    this[5] = 0;
  }
  return this;
}
// 10006F35: variable 'v14' is possibly undefined
// 10006F35: variable 'v16' is possibly undefined
// 10006F44: variable 'v15' is possibly undefined
// 10006F44: variable 'v17' is possibly undefined
// 1001599C: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_000F(_DWORD);
// 100159A2: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_006F(_DWORD, _DWORD);
// 100159C6: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0006(_DWORD, _DWORD, _DWORD);

//----- (10006FB0) --------------------------------------------------------
int __thiscall sub_10006FB0(int *this)
{
  int v2; // edi
  char v3; // al
  int result; // eax
  int v5; // esi

  v2 = this[7];
  if ( v2 )
  {
    if ( *(_DWORD *)v2 != -1 && !*(_BYTE *)(v2 + 21) )
      j_FIX_DLL_WSOCK32_dll_ord_0003(*(_DWORD *)v2);
    v3 = *(_BYTE *)(v2 + 21);
    *(_DWORD *)v2 = -1;
    if ( v3 )
      *(_DWORD *)v2 = -1;
    sub_10002D70(v2);
  }
  sub_10002D60((void *)this[8]);
  this[8] = 0;
  this[10] = 0;
  this[9] = 0;
  result = sub_10002D70(this[6]);
  v5 = *this;
  if ( v5 != -1 )
    result = j_FIX_DLL_WSOCK32_dll_ord_0003(v5);
  return result;
}
// 10015984: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0003(_DWORD);

//----- (10007060) --------------------------------------------------------
char __thiscall sub_10007060(_DWORD *this)
{
  int v2; // eax
  int v3; // eax
  char result; // al
  int v5; // edi
  int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // [esp+0h] [ebp-10h] BYREF
  _DWORD *v10; // [esp+4h] [ebp-Ch] BYREF
  int v11; // [esp+Ch] [ebp-4h]

  v10 = this;
  v2 = this[5];
  if ( v2 == 9 || !v2 )
  {
    if ( &v9 != (int *)-12 )
      v11 = 0;
    v5 = this[7];
    if ( v5 && v2 == 9 )
    {
      v6 = this[6];
      v7 = (v5 + 37) & 0xFFFFFFF0;
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v6 + 288);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 292);
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 4) = 0;
      *(_DWORD *)(v7 + 8) = 0;
      *(_DWORD *)(v7 + 12) = 0;
      *(_WORD *)v7 = 2;
      v8 = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(v5 + 12));
      *(_DWORD *)(v7 + 4) = v8;
      LOWORD(v8) = *(_WORD *)(v5 + 16);
      *(_WORD *)(v7 + 2) = j_FIX_DLL_WSOCK32_dll_ord_0009(v8);
    }
    result = 1;
  }
  else
  {
    if ( &v9 != (int *)-12 )
    {
      if ( v2 == 1 )
      {
        v11 = 6;
      }
      else if ( v2 == 2 || v2 == 4 || v2 == 6 )
      {
        v11 = 2;
      }
      else
      {
        v11 = 1;
      }
    }
    v3 = sub_100065F0((int)&v10, 1, 0);
    if ( v3 < 0 || v3 && !sub_100077B0(this, v11) )
    {
      this[5] = 0;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10007060: could not find valid save-restore pair for edi
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);

//----- (10007160) --------------------------------------------------------
int __thiscall sub_10007160(_DWORD *this, void *a2, signed int a3, _DWORD *a4)
{
  int result; // eax
  size_t v6; // esi
  int v7; // ecx
  int v8; // edx
  char v9; // al
  int v10; // eax
  char v11[10]; // [esp+4h] [ebp-800h] BYREF
  char v12[2038]; // [esp+Eh] [ebp-7F6h] BYREF

  result = this[7];
  if ( result )
  {
    v6 = a3;
    v11[0] = 0;
    v7 = *a4;
    v11[1] = 0;
    v11[2] = 0;
    v11[4] = HIBYTE(v7);
    v11[5] = BYTE2(v7);
    v8 = a4[1];
    v11[6] = BYTE1(v7);
    LOBYTE(v7) = *(_BYTE *)a4;
    v9 = *((_BYTE *)a4 + 4);
    v11[3] = 1;
    v11[7] = v7;
    v11[8] = BYTE1(v8);
    v11[9] = v9;
    if ( a3 > 2000 )
      v6 = 2000;
    memcpy_0(v12, a2, v6);
    v10 = this[7];
    if ( *(_DWORD *)(v10 + 86) )
      result = sub_10007160(v11, v6 + 10, v10 + 12);
    else
      result = j_FIX_DLL_WSOCK32_dll_ord_0014();
  }
  return result;
}

//----- (10007240) --------------------------------------------------------
signed int __thiscall sub_10007240(int *this, void *a2, signed int a3, int *a4, int a5)
{
  int v5; // ebp
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  int **v9; // eax
  int *v10; // esi
  size_t v11; // eax
  signed int v12; // edi
  int v14; // ebp
  int v15; // ebx
  int v16; // esi
  int *v17; // edi
  int v18; // ebx
  int *v19; // esi
  int v20; // ebp
  int v21; // ebx
  size_t v22; // eax
  signed int v23; // ebp
  int *v24; // [esp+10h] [ebp-808h] BYREF
  int *v25; // [esp+14h] [ebp-804h]
  char v26[10]; // [esp+18h] [ebp-800h] BYREF
  _BYTE v27[2038]; // [esp+22h] [ebp-7F6h] BYREF

  v5 = (int)this;
  v6 = 0;
  v7 = this[10];
  v25 = this;
  if ( v7 <= 0 )
  {
LABEL_12:
    if ( *(_DWORD *)(v5 + 28) )
    {
      v14 = sub_10006AA0(v26, 2048, a5);
      if ( v14 >= 11 && !v26[2] && v26[3] == 1 )
      {
        v15 = (unsigned __int8)v26[9] | ((unsigned __int8)v26[8] << 8);
        v16 = (unsigned __int8)v26[7] | (((unsigned __int8)v26[6] | (((unsigned __int8)v26[5] | ((unsigned __int8)v26[4] << 8)) << 8)) << 8);
        if ( *a4 == v16 && a4[1] == v15 || !*a4 )
        {
          v22 = a3;
          v23 = v14 - 10;
          if ( v23 <= a3 )
            v22 = v23;
          memcpy_0(a2, v27, v22);
          *a4 = v16;
          a4[1] = v15;
          return v23;
        }
        v17 = (int *)sub_10002CC0(v14 + 3);
        *v17 = v16;
        v17[1] = v15;
        v17[2] = v14 - 10;
        memcpy_0(v17 + 3, v27, v14 - 10);
        v18 = v25[10];
        v19 = v25 + 8;
        if ( v18 >= v25[9] )
        {
          sub_10002D10(v25 + 8, 4 * v18 + 128);
          v25[9] += 32;
        }
        v20 = 4 * v18;
        memcpy_0((void *)(*v19 + 4 * v18 + 4), (const void *)(*v19 + 4 * v18), 4 * (v19[2] + 0x3FFFFFFF * v18));
        v21 = *v19;
        ++v19[2];
        memcpy_0((void *)(v21 + v20), &v24, 4u);
        *(_DWORD *)(*v19 + v20) = v17;
      }
    }
    return 0;
  }
  v8 = *a4;
  v24 = (int *)(v5 + 32);
  v9 = *(int ***)(v5 + 32);
  while ( 1 )
  {
    v10 = *v9;
    if ( v8 == **v9 )
    {
      if ( a4[1] == v10[1] )
        break;
      v5 = (int)v25;
    }
    if ( !v8 )
      break;
    ++v6;
    ++v9;
    if ( v6 >= v7 )
      goto LABEL_12;
  }
  *a4 = *v10;
  v11 = a3;
  a4[1] = v10[1];
  v12 = v10[2];
  if ( v12 <= a3 )
    v11 = v10[2];
  memcpy_0(a2, v10 + 3, v11);
  sub_10002D70((int)v10);
  sub_10008190(v24, v6);
  return v12;
}
// 10006AA0: using guessed type _DWORD __stdcall sub_10006AA0(_DWORD, _DWORD, _DWORD);

//----- (10007470) --------------------------------------------------------
void *__thiscall sub_10007470(void *this)
{
  char v3; // [esp+8h] [ebp-190h] BYREF

  if ( (unsigned int)FIX_DLL_KERNEL32_dll_GetVersion() >= 0x80000000 )
    dword_100243E8 = 64;
  if ( j_FIX_DLL_WSOCK32_dll_ord_0073(2) || (unsigned __int8)&v3 != 2 )
  {
    dword_100243E8 = 64;
    j_FIX_DLL_WSOCK32_dll_ord_0073(257);
  }
  return this;
}
// 10015A0E: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD);
// 100210AC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetVersion)(void);
// 100243E8: using guessed type int dword_100243E8;

//----- (100074E0) --------------------------------------------------------
int sub_100074E0()
{
  char v1; // [esp+0h] [ebp-198h]

  if ( (unsigned int)FIX_DLL_KERNEL32_dll_GetVersion() >= 0x80000000 )
    dword_100243E8 = 64;
  if ( j_FIX_DLL_WSOCK32_dll_ord_0073(2) || v1 != 2 )
  {
    dword_100243E8 = 64;
    j_FIX_DLL_WSOCK32_dll_ord_0073(257);
  }
  return atexit(sub_10007540);
}
// 10007512: variable 'v1' is possibly undefined
// 10015A0E: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0073(_DWORD);
// 100210AC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetVersion)(void);
// 100243E8: using guessed type int dword_100243E8;

//----- (10007550) --------------------------------------------------------
int __thiscall sub_10007550(int this)
{
  int result; // eax

  LOBYTE(result) = *(_BYTE *)(this + 8);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 137) = ((_BYTE)result != 0) + 1;
  *(_BYTE *)(this + 138) = 0;
  *(_BYTE *)(this + 139) = 2;
  *(_DWORD *)(this + 284) = ((_BYTE)result != 0) + 3;
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  return result;
}

//----- (100075A0) --------------------------------------------------------
int __thiscall sub_100075A0(int this)
{
  const char *v2; // esi
  char *v3; // ebx
  int result; // eax

  v2 = (const char *)(this + 8);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 137) = strlen((const char *)(this + 8));
  strcpy((char *)(this + 138), v2);
  v3 = (char *)(*(unsigned __int8 *)(this + 137) + this + 138);
  *v3 = strlen((const char *)(this + 72));
  strcpy(v3 + 1, (const char *)(this + 72));
  result = (int)&v3[(unsigned __int8)*v3 - this - 135];
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = result;
  return result;
}

//----- (10007650) --------------------------------------------------------
char __thiscall sub_10007650(int this, _DWORD *a2)
{
  char result; // al

  *(_BYTE *)(this + 137) = *(_BYTE *)(this + 297);
  *(_BYTE *)(this + 136) = 5;
  *(_BYTE *)(this + 138) = 0;
  *(_BYTE *)(this + 139) = 1;
  *(_BYTE *)(this + 140) = HIBYTE(*a2);
  *(_BYTE *)(this + 141) = BYTE2(*a2);
  *(_BYTE *)(this + 142) = BYTE1(*a2);
  *(_BYTE *)(this + 143) = *(_BYTE *)a2;
  *(_BYTE *)(this + 144) = BYTE1(a2[1]);
  result = *((_BYTE *)a2 + 4);
  *(_BYTE *)(this + 145) = result;
  *(_BYTE *)(this + 296) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = 10;
  return result;
}

//----- (100076D0) --------------------------------------------------------
int __thiscall sub_100076D0(_DWORD *this, _DWORD *a2, char a3)
{
  int result; // eax
  void *v5; // eax

  result = this[5];
  if ( !result )
  {
    result = sub_10002D70(this[6]);
    this[6] = 0;
    if ( a2 )
    {
      if ( *a2 )
      {
        v5 = (void *)sub_10002CC0(301);
        this[6] = v5;
        qmemcpy(v5, a2, 0x88u);
        *(_DWORD *)(this[6] + 284) = 0;
        result = this[6];
        *(_DWORD *)(result + 297) = a3 != 0 ? 3 : 1;
      }
    }
  }
  return result;
}

//----- (10007740) --------------------------------------------------------
char __thiscall sub_10007740(_DWORD *this, _DWORD *a2)
{
  int v2; // eax

  v2 = this[5];
  if ( v2 == 9 || !v2 )
  {
    if ( a2 )
      *a2 = 0;
    LOBYTE(v2) = 0;
  }
  else if ( a2 )
  {
    if ( v2 == 1 )
    {
      *a2 = 6;
    }
    else if ( v2 == 2 || v2 == 4 || v2 == 6 )
    {
      *a2 = 2;
      LOBYTE(v2) = 1;
    }
    else
    {
      *a2 = 1;
      LOBYTE(v2) = 1;
    }
  }
  else
  {
    LOBYTE(v2) = 1;
  }
  return v2;
}

//----- (100077B0) --------------------------------------------------------
char __thiscall sub_100077B0(_DWORD *this, char a2)
{
  int v3; // eax
  int v4; // eax
  char result; // al
  int v6; // eax
  char v7; // cl
  int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  char v14; // al
  char *v15; // ebx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  char v19; // al
  unsigned __int16 v20; // ax
  int v21; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // eax
  unsigned int i; // esi
  char *v26; // eax
  int v27; // eax
  int v28; // edx
  int v29; // edi
  unsigned int j; // esi
  char *v31; // eax
  int v32; // eax
  unsigned int m; // esi
  char *v34; // eax
  int v35; // eax
  int v36; // edx
  int v37; // edi
  unsigned int k; // esi
  char *v39; // eax
  int v40; // eax
  unsigned __int8 v41; // bl
  int v42; // edi
  unsigned int l; // esi
  char *v44; // eax
  int v45; // edx
  int v46; // [esp-4h] [ebp-98h]
  int v47; // [esp-4h] [ebp-98h]
  int v48; // [esp-4h] [ebp-98h]
  int v49; // [esp-4h] [ebp-98h]
  int v50; // [esp-4h] [ebp-98h]
  char Str[128]; // [esp+14h] [ebp-80h] BYREF

  v3 = this[5];
  if ( v3 == 9 )
    return 1;
  if ( v3 != 1 )
    goto LABEL_8;
  if ( (a2 & 4) != 0 )
  {
    v4 = -(this[6] != 0);
    this[2] = 0;
    this[1] = (v4 & 3) + 1;
    return 0;
  }
  if ( (a2 & 2) == 0 )
    return 1;
  v6 = this[6];
  if ( !v6 )
  {
LABEL_88:
    this[5] = 9;
    return 1;
  }
  v7 = *(_BYTE *)(v6 + 8);
  *(_BYTE *)(v6 + 136) = 5;
  *(_BYTE *)(v6 + 138) = 0;
  *(_BYTE *)(v6 + 137) = (v7 != 0) + 1;
  *(_BYTE *)(v6 + 139) = 2;
  *(_BYTE *)(v6 + 296) = 0;
  *(_DWORD *)(v6 + 280) = 0;
  *(_DWORD *)(v6 + 284) = (v7 != 0) + 3;
  this[5] = 2;
LABEL_8:
  if ( !this[6] )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              v8 = this[6];
              v9 = *(_DWORD *)(v8 + 280);
              v10 = *(_DWORD *)(v8 + 284);
              if ( v9 >= v10 )
                goto LABEL_19;
              v11 = 0;
              if ( *(_BYTE *)(v8 + 296) )
              {
                if ( (a2 & 1) != 0 )
                {
                  v12 = sub_100061C0(this, v9 + v8 + 136, v10 - v9);
                  goto LABEL_17;
                }
              }
              else if ( (a2 & 2) != 0 )
              {
                v12 = sub_10006100(this, v9 + v8 + 136, v10 - v9);
LABEL_17:
                v11 = v12;
                if ( v12 < 0 )
                {
                  this[1] = 4;
                  return 0;
                }
                goto LABEL_18;
              }
LABEL_18:
              *(_DWORD *)(this[6] + 280) += v11;
              v8 = this[6];
              v10 = *(_DWORD *)(v8 + 284);
              if ( *(_DWORD *)(v8 + 280) < v10 )
                return 1;
LABEL_19:
              v13 = this[5];
              if ( v13 != 2 )
                break;
              *(_BYTE *)(v8 + 296) = 1;
              *(_DWORD *)(v8 + 280) = 0;
              *(_DWORD *)(v8 + 284) = 2;
              this[5] = 3;
            }
            if ( v13 != 3 )
              break;
            v14 = *(_BYTE *)(v8 + 137);
            if ( v14 != 2 || !*(_BYTE *)(v8 + 8) )
            {
              if ( v14 )
              {
                v24 = this[6];
                this[5] = 0;
                this[1] = 4;
                this[2] = 256;
                Str[0] = 0;
                if ( v24 )
                {
                  if ( *(_BYTE *)(v24 + 296) )
                  {
                    for ( i = 0; i < *(_DWORD *)(v24 + 280); ++i )
                    {
                      if ( i >= 0x14 )
                        break;
                      v46 = *(unsigned __int8 *)(v24 + i + 136);
                      v26 = strchr_0(Str, 0);
                      sprintf_0(v26, "%02x ", v46);
                      v24 = this[6];
                    }
                  }
                }
                sub_10005120((int)"Socket: Socks error %d%s%s\n", 256);
                this[1] = 5;
                return 0;
              }
              v17 = *(_BYTE *)(v8 + 297);
              *(_BYTE *)(v8 + 136) = 5;
              *(_BYTE *)(v8 + 137) = v17;
              *(_BYTE *)(v8 + 138) = 0;
              *(_BYTE *)(v8 + 139) = 1;
              *(_BYTE *)(v8 + 140) = HIBYTE(this[3]);
              *(_BYTE *)(v8 + 141) = BYTE2(this[3]);
              *(_BYTE *)(v8 + 142) = BYTE1(this[3]);
              *(_BYTE *)(v8 + 143) = *((_BYTE *)this + 12);
              *(_BYTE *)(v8 + 144) = BYTE1(this[4]);
              *(_BYTE *)(v8 + 145) = *((_BYTE *)this + 16);
              goto LABEL_32;
            }
            *(_BYTE *)(v8 + 136) = 5;
            *(_BYTE *)(v8 + 137) = strlen((const char *)(v8 + 8));
            strcpy((char *)(v8 + 138), (const char *)(v8 + 8));
            v15 = (char *)(*(unsigned __int8 *)(v8 + 137) + v8 + 138);
            *v15 = strlen((const char *)(v8 + 72));
            strcpy(v15 + 1, (const char *)(v8 + 72));
            v16 = (unsigned __int8)*v15;
            *(_BYTE *)(v8 + 296) = 0;
            *(_DWORD *)(v8 + 280) = 0;
            *(_DWORD *)(v8 + 284) = &v15[v16 - v8 - 135];
            this[5] = 4;
          }
          if ( v13 != 4 )
            break;
          *(_BYTE *)(v8 + 296) = 1;
          *(_DWORD *)(v8 + 280) = 0;
          *(_DWORD *)(v8 + 284) = 2;
          this[5] = 5;
        }
        if ( v13 != 5 )
          break;
        if ( *(_BYTE *)(v8 + 137) )
        {
          v27 = this[6];
          Str[0] = 0;
          v28 = *(unsigned __int8 *)(v27 + 137);
          this[5] = 0;
          this[1] = 4;
          v29 = v28 + 512;
          this[2] = v28 + 512;
          if ( v27 )
          {
            if ( *(_BYTE *)(v27 + 296) )
            {
              for ( j = 0; j < *(_DWORD *)(v27 + 280); ++j )
              {
                if ( j >= 0x14 )
                  break;
                v47 = *(unsigned __int8 *)(v27 + j + 136);
                v31 = strchr_0(Str, 0);
                sprintf_0(v31, "%02x ", v47);
                v27 = this[6];
              }
            }
          }
          sub_10005120((int)"Socket: Socks error %d%s%s\n", v29);
          this[1] = 5;
          return 0;
        }
        v18 = *(_BYTE *)(v8 + 297);
        *(_BYTE *)(v8 + 136) = 5;
        *(_BYTE *)(v8 + 137) = v18;
        *(_BYTE *)(v8 + 138) = 0;
        *(_BYTE *)(v8 + 139) = 1;
        *(_BYTE *)(v8 + 140) = HIBYTE(this[3]);
        *(_BYTE *)(v8 + 141) = BYTE2(this[3]);
        *(_BYTE *)(v8 + 142) = BYTE1(this[3]);
        *(_BYTE *)(v8 + 143) = *((_BYTE *)this + 12);
        *(_BYTE *)(v8 + 144) = BYTE1(this[4]);
        *(_BYTE *)(v8 + 145) = *((_BYTE *)this + 16);
LABEL_32:
        *(_BYTE *)(v8 + 296) = 0;
        *(_DWORD *)(v8 + 280) = 0;
        *(_DWORD *)(v8 + 284) = 10;
        this[5] = 6;
      }
      if ( v13 != 6 )
        break;
      *(_BYTE *)(v8 + 296) = 1;
      *(_DWORD *)(v8 + 280) = 0;
      *(_DWORD *)(v8 + 284) = 5;
      this[5] = 7;
    }
    if ( v13 != 7 && v13 != 8 )
      break;
    if ( v10 == 5 )
    {
      v19 = *(_BYTE *)(v8 + 139);
      switch ( v19 )
      {
        case 1:
          *(_DWORD *)(v8 + 284) = 10;
          break;
        case 3:
          *(_DWORD *)(v8 + 284) = *(unsigned __int8 *)(v8 + 140) + 6;
          break;
        case 4:
          *(_DWORD *)(v8 + 284) = 22;
          break;
        default:
          v35 = this[6];
          Str[0] = 0;
          v36 = *(unsigned __int8 *)(v35 + 139);
          this[5] = 0;
          this[1] = 4;
          v37 = v36 + 768;
          this[2] = v36 + 768;
          if ( v35 )
          {
            if ( *(_BYTE *)(v35 + 296) )
            {
              for ( k = 0; k < *(_DWORD *)(v35 + 280); ++k )
              {
                if ( k >= 0x14 )
                  break;
                v49 = *(unsigned __int8 *)(v35 + k + 136);
                v39 = strchr_0(Str, 0);
                sprintf_0(v39, "%02x ", v49);
                v35 = this[6];
              }
            }
          }
          sub_10005120((int)"Socket: Socks error %d%s%s\n", v37);
          return 0;
      }
    }
    else
    {
      if ( *(_BYTE *)(v8 + 137) )
      {
        v40 = this[6];
        Str[0] = 0;
        v41 = *(_BYTE *)(v40 + 137);
        this[5] = 0;
        this[1] = 4;
        v42 = v41 + 512;
        this[2] = v42;
        if ( v40 )
        {
          if ( *(_BYTE *)(v40 + 296) )
          {
            for ( l = 0; l < *(_DWORD *)(v40 + 280); ++l )
            {
              if ( l >= 0x14 )
                break;
              v50 = *(unsigned __int8 *)(v40 + l + 136);
              v44 = strchr_0(Str, 0);
              sprintf_0(v44, "%02x ", v50);
              v40 = this[6];
            }
          }
        }
        sub_10005120((int)"Socket: Socks error %d%s%s\n", v42);
        if ( v41 == 2 )
        {
          this[1] = 5;
          result = 0;
        }
        else
        {
          if ( v41 == 3 || v41 == 4 || v41 == 5 || v41 == 6 )
            this[1] = 1;
          result = 0;
        }
        return result;
      }
      HIBYTE(v20) = *(_BYTE *)(v8 + 140);
      LOBYTE(v20) = *(_BYTE *)(v8 + 141);
      v21 = *(unsigned __int8 *)(v8 + 143) | ((*(unsigned __int8 *)(v8 + 142) | (v20 << 8)) << 8);
      HIWORD(v22) = 0;
      BYTE1(v22) = *(_BYTE *)(v8 + 144);
      LOBYTE(v22) = *(_BYTE *)(v8 + 145);
      if ( *(_DWORD *)(v8 + 297) != 2 )
      {
        v45 = this[6];
        *(_DWORD *)(v45 + 288) = v21;
        *(_DWORD *)(v45 + 292) = v22;
        goto LABEL_88;
      }
      if ( v13 != 7 )
      {
        this[3] = v21;
        this[4] = v22;
        goto LABEL_88;
      }
      *(_DWORD *)(v8 + 288) = v21;
      *(_DWORD *)(v8 + 292) = v22;
      v23 = this[6];
      *(_BYTE *)(v23 + 296) = 1;
      *(_DWORD *)(v23 + 280) = 0;
      *(_DWORD *)(v23 + 284) = 5;
      this[5] = 8;
    }
  }
  v32 = this[6];
  this[5] = 0;
  this[1] = 4;
  this[2] = 1024;
  Str[0] = 0;
  if ( v32 )
  {
    if ( *(_BYTE *)(v32 + 296) )
    {
      for ( m = 0; m < *(_DWORD *)(v32 + 280); ++m )
      {
        if ( m >= 0x14 )
          break;
        v48 = *(unsigned __int8 *)(v32 + m + 136);
        v34 = strchr_0(Str, 0);
        sprintf_0(v34, "%02x ", v48);
        v32 = this[6];
      }
    }
  }
  sub_10005120((int)"Socket: Socks error %d%s%s\n", 1024);
  return 0;
}
// 100078AC: conditional instruction was optimized away because of 'al.1!=0'

//----- (10008030) --------------------------------------------------------
char __thiscall sub_10008030(_DWORD *this, int a2)
{
  int v3; // eax
  unsigned int i; // esi
  char *v5; // eax
  int v7; // [esp-4h] [ebp-90h]
  char Str[128]; // [esp+Ch] [ebp-80h] BYREF

  Str[0] = 0;
  v3 = this[6];
  this[5] = 0;
  this[1] = 4;
  this[2] = a2;
  if ( v3 )
  {
    if ( *(_BYTE *)(v3 + 296) )
    {
      for ( i = 0; i < *(_DWORD *)(v3 + 280); ++i )
      {
        if ( i >= 0x14 )
          break;
        v7 = *(unsigned __int8 *)(v3 + i + 136);
        v5 = strchr_0(Str, 0);
        sprintf_0(v5, "%02x ", v7);
        v3 = this[6];
      }
    }
  }
  sub_10005120((int)"Socket: Socks error %d%s%s\n", a2);
  return 0;
}

//----- (100080F0) --------------------------------------------------------
char __thiscall sub_100080F0(int *this, int a2)
{
  int v2; // eax
  char result; // al
  int v4[2]; // [esp+0h] [ebp-88h] BYREF
  char v5; // [esp+8h] [ebp-80h]

  v2 = this[6];
  if ( v2 )
  {
    v4[1] = 0;
    v4[0] = a2;
    *(_DWORD *)(v2 + 297) = 2;
    result = sub_10005BD0(this, (int)v4);
  }
  else
  {
    this[5] = 0;
    this[1] = 4;
    this[2] = 1280;
    v5 = 0;
    sub_10005120((int)"Socket: Socks error %d%s%s\n", 1280);
    result = 0;
  }
  return result;
}

//----- (10008170) --------------------------------------------------------
int __thiscall sub_10008170(int this)
{
  int result; // eax

  sub_10002D60(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (10008190) --------------------------------------------------------
int __thiscall sub_10008190(int *this, int a2)
{
  int result; // eax
  int v4; // ecx
  int v5; // eax
  _DWORD v6[7]; // [esp-Ch] [ebp-1Ch] BYREF

  v6[3] = v6;
  memcpy_0((void *)(*this + 4 * a2), (const void *)(*this + 4 * (a2 + 1)), 4 * (this[2] + 0x3FFFFFFF * (a2 + 1)));
  result = this[2] - 1;
  this[2] = result;
  v4 = result;
  if ( result )
  {
    result = this[1];
    if ( result - v4 > 32 )
    {
      v5 = result - 16;
      this[1] = v5;
      v6[6] = 0;
      result = sub_10002D10(this, 4 * v5);
    }
  }
  return result;
}

//----- (1000821E) --------------------------------------------------------
void *sub_1000821E()
{
  return &loc_1000820B;
}

//----- (10008230) --------------------------------------------------------
int sub_10008230()
{
  long double v0; // fst7
  int result; // eax
  __int64 v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-Ch] BYREF

  if ( byte_10029268
    && (HIDWORD(v2) = &v3, FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency())
    && (LODWORD(v2) = &v4, FIX_DLL_KERNEL32_dll_QueryPerformanceCounter())
    && v2 > 1000 )
  {
    v0 = (long double)v2;
    byte_10029268 = 1;
    dword_10029250 = v3;
    dword_10029254 = v4;
    dbl_10029260 = dbl_10021948 / v0;
    dbl_10029258 = dbl_10021940 / v0;
    result = FIX_DLL_KERNEL32_dll_GetTickCount() - 1000000;
    dword_1002926C = result;
  }
  else
  {
    byte_10029268 = 0;
    result = FIX_DLL_KERNEL32_dll_GetTickCount() - 1000000;
    dword_1002926C = result;
  }
  return result;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(void);
// 100210B4: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceFrequency)(void);
// 10021940: using guessed type double dbl_10021940;
// 10021948: using guessed type double dbl_10021948;
// 10029250: using guessed type int dword_10029250;
// 10029254: using guessed type int dword_10029254;
// 10029258: using guessed type double dbl_10029258;
// 10029260: using guessed type double dbl_10029260;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100082E0) --------------------------------------------------------
int sub_100082E0()
{
  __int64 v0; // rax
  __int64 v2; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_10029268 )
  {
    LODWORD(v2) = (char *)&v2 + 4;
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter();
    v2 -= qword_10029250;
    v0 = (__int64)((long double)v2 * dbl_10029258);
  }
  else
  {
    LODWORD(v0) = FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C;
  }
  return v0;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(void);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008340) --------------------------------------------------------
long double sub_10008340()
{
  __int64 v1; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_10029268 )
    return (long double)(unsigned int)(FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C) * dbl_10021940;
  LODWORD(v1) = (char *)&v1 + 4;
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter();
  v1 -= qword_10029250;
  return (long double)v1 * dbl_10029258 * dbl_10021940;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(void);
// 10021940: using guessed type double dbl_10021940;
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100083C0) --------------------------------------------------------
long double sub_100083C0()
{
  __int64 v1; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_10029268 )
    return (long double)(unsigned int)(FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C) * dbl_10021940;
  LODWORD(v1) = (char *)&v1 + 4;
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter();
  v1 -= qword_10029250;
  return (long double)v1 * dbl_10029258 * dbl_10021940;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(void);
// 10021940: using guessed type double dbl_10021940;
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008440) --------------------------------------------------------
__int64 sub_10008440()
{
  __int64 v1; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_10029268 )
    return 1193180i64 * (unsigned int)(FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C) / 1000;
  LODWORD(v1) = (char *)&v1 + 4;
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter();
  v1 -= qword_10029250;
  return (__int64)((long double)v1 * dbl_10029260 * dbl_10021950);
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (*FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(void);
// 10021950: using guessed type double dbl_10021950;
// 10029250: using guessed type __int64 qword_10029250;
// 10029260: using guessed type double dbl_10029260;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100084C0) --------------------------------------------------------
__int64 __thiscall sub_100084C0(_DWORD *this, double a2)
{
  __int64 result; // rax

  result = (__int64)((long double)(*(_QWORD *)&a2 - qword_10029250) * dbl_10029258);
  this[2] = result;
  return result;
}
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;

//----- (10008500) --------------------------------------------------------
int __thiscall sub_10008500(_DWORD *this)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  __int64 v4; // rax
  unsigned __int64 v6; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter((char *)&v6 + 4);
    v3 = HIDWORD(v6);
    v2 = v6;
    *this = v6;
    this[1] = v3;
    v6 = __PAIR64__(v3, v2) - qword_10029250;
    v4 = (__int64)((long double)(__int64)(__PAIR64__(v3, v2) - qword_10029250) * dbl_10029258);
  }
  else
  {
    LODWORD(v4) = FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C;
  }
  this[2] = v4;
  return v4;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008570) --------------------------------------------------------
_BOOL1 __thiscall sub_10008570(_DWORD *this, int a2)
{
  __int64 v3; // rax
  _DWORD v5[2]; // [esp+0h] [ebp-Ch] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v5[1]);
    *(_QWORD *)v5 -= qword_10029250;
    v3 = (__int64)((long double)*(__int64 *)v5 * dbl_10029258);
  }
  else
  {
    LODWORD(v3) = FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C;
  }
  return (int)v3 - this[2] >= a2;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100085E0) --------------------------------------------------------
char *__thiscall sub_100085E0(_DWORD *this, int a2)
{
  _DWORD v4[2]; // [esp+0h] [ebp-Ch] BYREF
  char *retaddr; // [esp+Ch] [ebp+0h]

  if ( !byte_10029268 )
    return (char *)(a2 + this[2] - (FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C));
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v4[1]);
  *(_QWORD *)v4 -= qword_10029250;
  return &retaddr[this[2] - (__int64)((long double)*(__int64 *)v4 * dbl_10029258)];
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008660) --------------------------------------------------------
int __thiscall sub_10008660(_DWORD *this)
{
  _DWORD v3[2]; // [esp+0h] [ebp-Ch] BYREF

  if ( !byte_10029268 )
    return FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C - this[2];
  FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v3[1]);
  *(_QWORD *)v3 -= qword_10029250;
  return (__int64)((long double)*(__int64 *)v3 * dbl_10029258) - this[2];
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (100086D0) --------------------------------------------------------
int __thiscall sub_100086D0(_DWORD *this, int a2)
{
  return *(_DWORD *)(a2 + 8) - this[2];
}

//----- (100086E0) --------------------------------------------------------
long double __thiscall sub_100086E0(unsigned int *this)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  long double result; // fst7
  int (*v5)(void); // edi
  unsigned int v6; // ecx
  char v7[20]; // [esp+4h] [ebp-14h] BYREF

  if ( byte_10029268 )
  {
    FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v7[4]);
    v2 = *(_DWORD *)v7;
    v3 = *(_DWORD *)&v7[4];
    *(_QWORD *)v7 -= *(_QWORD *)this;
    result = (long double)*(__int64 *)v7 * dbl_10029258;
    *this = v2;
    this[1] = v3;
    *(_DWORD *)&v7[4] = (__PAIR64__(v3, v2) - qword_10029250) >> 32;
    this[2] = (__int64)((long double)(__int64)(__PAIR64__(v3, v2) - qword_10029250) * dbl_10029258);
  }
  else
  {
    v5 = FIX_DLL_KERNEL32_dll_GetTickCount;
    *(_QWORD *)&v7[4] = FIX_DLL_KERNEL32_dll_GetTickCount() - dword_1002926C - this[2];
    *(double *)&v7[12] = (double)*(__int64 *)&v7[4];
    if ( byte_10029268 )
    {
      FIX_DLL_KERNEL32_dll_QueryPerformanceCounter(&v7[4]);
      v6 = *(_DWORD *)&v7[4];
      *this = *(_DWORD *)v7;
      this[1] = v6;
      *(_DWORD *)&v7[4] = (__PAIR64__(v6, *(unsigned int *)v7) - qword_10029250) >> 32;
      result = *(double *)&v7[8];
      this[2] = (__int64)((long double)(__int64)(__PAIR64__(v6, *(unsigned int *)v7) - qword_10029250) * dbl_10029258);
    }
    else
    {
      result = *(double *)&v7[12];
      this[2] = v5() - dword_1002926C;
    }
  }
  return result;
}
// 100086E0: could not find valid save-restore pair for ebx
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_QueryPerformanceCounter)(_DWORD);
// 10029250: using guessed type __int64 qword_10029250;
// 10029258: using guessed type double dbl_10029258;
// 10029268: using guessed type char byte_10029268;
// 1002926C: using guessed type int dword_1002926C;

//----- (10008800) --------------------------------------------------------
_DWORD *__userpurge sub_10008800@<eax>(void **a1@<ecx>, int a2@<ebx>, int a3)
{
  void **v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  int v14; // esi
  int v15; // edi
  int v16; // ecx
  int v17; // edi
  int v18; // ecx
  int v19; // edx
  int v20; // esi
  int v21; // edi
  int v22; // ecx
  int v23; // edx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // edx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  int v39; // edx
  int v40; // esi
  int v41; // ebx
  int v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // esi
  int v46; // edi
  int v47; // ecx
  int v48; // edx
  int v49; // esi
  int v50; // edi
  int v51; // ecx
  int v52; // ebx
  int v53; // esi
  int v54; // edx
  int v55; // ecx
  int v56; // edi
  int v57; // ebx
  int v58; // edx
  int v59; // ecx
  int v60; // esi
  int v61; // edi
  int v62; // ebx
  int v63; // edi
  int v64; // edx
  int v65; // ecx
  int v66; // esi
  int v67; // edi
  int v68; // edx
  int v69; // ecx
  int v70; // esi
  int v71; // edi
  int v72; // edx
  int v73; // ecx
  int v74; // esi
  int v75; // edi
  int v76; // edx
  int v77; // ecx
  int v78; // esi
  int v79; // ebp
  int v80; // ebx
  int v81; // edi
  int v82; // edx
  int i; // ecx
  _DWORD *result; // eax
  int v85; // ecx
  int v86; // edx
  int v87; // esi
  int v88; // edi
  int v89; // ecx
  int v90; // edi
  int v91; // ecx
  int v92; // edx
  int v93; // esi
  int v94; // edi
  int v95; // ecx
  int v96; // edi
  int v97; // ecx
  int v98; // edx
  int v99; // esi
  int v100; // edi
  int v101; // ecx
  int v102; // edx
  int v103; // esi
  int v104; // edi
  int v105; // ecx
  int v106; // edx
  int v107; // esi
  int v108; // edi
  int v109; // ecx
  int v110; // edx
  int v111; // ecx
  int v112; // edx
  int v113; // esi
  int v114; // edi
  int v115; // ecx
  int v116; // edx
  int v117; // ecx
  int v118; // ebx
  int v119; // edi
  int v120; // esi
  int v121; // edx
  int v122; // ecx
  int v123; // edi
  int v124; // esi
  int v125; // edx
  int v126; // ecx
  int v127; // edi
  int v128; // esi
  int v129; // ebx
  int v130; // ebp
  int v131; // ecx
  int v132; // edx
  int v133; // esi
  int v134; // edi
  int v135; // ecx
  int v136; // edx
  int v137; // esi
  int v138; // ebp
  int v139; // edi
  int v140; // ecx
  int v141; // edx
  int v142; // esi
  int v143; // edi
  int v144; // ecx
  int v145; // edx
  int v146; // esi
  int v147; // edi
  int v148; // ecx
  int v149; // edx
  int v150; // esi
  int v151; // edi
  int v152; // ebx
  int v153; // ecx
  int v154; // esi
  int v155; // edx
  int v156; // ebp
  int v157; // edx
  int v158; // edx
  int j; // ecx
  int v160; // [esp+10h] [ebp-20h]
  int v161; // [esp+10h] [ebp-20h]
  int v162; // [esp+10h] [ebp-20h]
  int v163; // [esp+10h] [ebp-20h]
  int v164; // [esp+10h] [ebp-20h]
  int v166; // [esp+20h] [ebp-10h]
  int v167; // [esp+24h] [ebp-Ch]
  int v168; // [esp+28h] [ebp-8h]
  int v169; // [esp+2Ch] [ebp-4h]

  LOBYTE(a2) = a3;
  BYTE1(a2) = a3;
  v3 = a1;
  v4 = a2 << 16;
  LOWORD(v4) = a2;
  memset32(*a1, v4, 0x14u);
  *(_DWORD *)*a1 ^= a3;
  v5 = *a1;
  v6 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v7 = v6 + __ROL4__((v6 & 0xEFCDAAC9 | ~v6 & 0x98BACD4E) + *((_DWORD *)*v3 + 1) - 107344724, 12);
  v8 = v7 + __ROL4__((v6 & v7 | ~v7 & 0xEFCDAAC9) + *((_DWORD *)*v3 + 2) - 1126481991, 17);
  v9 = __ROL4__((v8 & v7 | v6 & ~v8) + v5[3] - 1319441881, 22);
  v10 = v5[4] + ((v8 + v9) & v8 | v7 & ~(v8 + v9)) + v6 - 177010401;
  v11 = v8 + v9;
  v12 = v11 + __ROL4__(v10, 7);
  v13 = v12 + __ROL4__(v5[5] + (v12 & v11 | v8 & ~v12) + v7 + 1200080794, 12);
  v14 = v13 + __ROL4__(v5[6] + (v12 & v13 | v11 & ~v13) + v8 - 1472706653, 17);
  v15 = __ROL4__(v5[7] + (v14 & v13 | v12 & ~v14) + v11 - 45706063, 22);
  v16 = v5[8] + ((v14 + v15) & v14 | v13 & ~(v14 + v15)) + v12 + 1753258344;
  v17 = v14 + v15;
  v18 = v17 + __ROL4__(v16, 7);
  v19 = v18 + __ROL4__(v5[9] + (v18 & v17 | v14 & ~v18) + v13 - 1958414817, 12);
  v20 = v19 + __ROL4__(v5[10] + (v18 & v19 | v17 & ~v19) + v14 - 7382527, 17);
  v21 = __ROL4__(v5[11] + (v20 & v19 | v18 & ~v20) + v17 - 1987258866, 22);
  v160 = v20 + v21;
  v22 = v20 + v21 + __ROL4__(v5[12] + ((v20 + v21) & v20 | v19 & ~(v20 + v21)) + v18 + 1804605842, 7);
  v23 = v22 + __ROL4__(v5[13] + (v22 & (v20 + v21) | v20 & ~v22) + v19 - 40341469, 12);
  v24 = v23 + __ROL4__(v20 + v5[14] + (v22 & v23 | (v20 + v21) & ~v23) - 1502002626, 17);
  v25 = v24 + __ROL4__(v5[15] + (v24 & v23 | v22 & ~v24) + v160 + 1232341393, 22);
  v26 = v25 + __ROL4__(v5[1] + (v25 & v23 | v24 & ~v23) + v22 - 166648622, 5);
  v27 = v26 + __ROL4__(v5[6] + (v26 & v24 | v25 & ~v24) + v23 - 985615632, 9);
  v28 = v27 + __ROL4__(v5[11] + (v25 & v27 | v26 & ~v25) + v24 + 643714017, 14);
  v29 = v28 + __ROL4__(*v5 + (v26 & v28 | v27 & ~v26) + v25 - 374028774, 20);
  v30 = __ROL4__(v5[5] + (v29 & v27 | v28 & ~v27) + v26 - 702082579, 5);
  v31 = v5[10] + ((v29 + v30) & v28 | v29 & ~v28) + v27 + 39065059;
  v32 = v29 + v30;
  v33 = v32 + __ROL4__(v31, 9);
  v34 = v33 + __ROL4__(v5[15] + (v29 & v33 | v32 & ~v29) + v28 - 660515023, 14);
  v35 = v34 + __ROL4__(v5[4] + (v32 & v34 | v33 & ~v32) + v29 - 405538184, 20);
  v36 = __ROL4__(v5[9] + (v35 & v33 | v34 & ~v33) + v32 + 568642646, 5);
  v37 = v5[14] + ((v35 + v36) & v34 | v35 & ~v34) + v33 - 1019804058;
  v38 = v35 + v36;
  v39 = v38 + __ROL4__(v37, 9);
  v40 = v39 + __ROL4__(v5[3] + (v35 & v39 | v38 & ~v35) + v34 - 187366857, 14);
  v41 = v5[8];
  v42 = v40 + __ROL4__(v41 + (v38 & v40 | v39 & ~v38) + v35 + 1163531613, 20);
  v43 = __ROL4__(v5[13] + (v42 & v39 | v40 & ~v39) + v38 - 1456215883, 5);
  v161 = v42 + v43;
  v44 = v42 + v43 + __ROL4__(v5[2] + ((v42 + v43) & v40 | v42 & ~v40) + v39 - 51404216, 9);
  v45 = v44 + __ROL4__(v40 + v5[7] + (v42 & v44 | (v42 + v43) & ~v42) + 1735327849, 14);
  v46 = v45 + __ROL4__(v5[12] + (v161 & v45 | v44 & ~v161) + v42 - 1926673094, 20);
  v47 = v46 + __ROL4__(v5[5] + (v46 ^ v45 ^ v44) + v161 - 235259662, 4);
  v48 = v47 + __ROL4__(v44 + v41 + (v47 ^ v46 ^ v45) - 2022574287, 11);
  v49 = v48 + __ROL4__(v5[11] + (v47 ^ v46 ^ v48) + v45 + 1832738962, 16);
  v50 = v49 + __ROL4__(v46 + v5[14] + (v47 ^ v49 ^ v48) - 35309124, 23);
  v51 = v50 + __ROL4__(v5[1] + (v50 ^ v49 ^ v48) + v47 - 1531024396, 4);
  v52 = v51 + __ROL4__(v5[4] + (v51 ^ v50 ^ v49) + v48 + 1272889881, 11);
  v53 = v52 + __ROL4__(v5[7] + (v51 ^ v50 ^ v52) + v49 - 155694384, 16);
  v54 = v53 + __ROL4__(v5[10] + (v51 ^ v53 ^ v52) + v50 - 1094730304, 23);
  v55 = v54 + __ROL4__(v51 + v5[13] + (v54 ^ v53 ^ v52) + 680755062, 4);
  v56 = v55 + __ROL4__(*v5 + (v55 ^ v54 ^ v53) + v52 - 358537654, 11);
  v57 = v56 + __ROL4__(v5[3] + (v55 ^ v54 ^ v56) + v53 - 722501323, 16);
  v58 = v57 + __ROL4__(v54 + v5[6] + (v55 ^ v57 ^ v56) + 76029109, 23);
  v59 = v58 + __ROL4__(v5[9] + (v58 ^ v57 ^ v56) + v55 - 640363895, 4);
  v60 = v59 + __ROL4__(v5[12] + (v59 ^ v58 ^ v57) + v56 - 429156267, 11);
  v61 = v5[15] + (v59 ^ v58 ^ v60) + v57 + 530742600;
  v62 = v5[2];
  v63 = v60 + __ROL4__(v61, 16);
  v64 = v63 + __ROL4__(v58 + v62 + (v59 ^ v63 ^ v60) - 995346475, 23);
  v65 = v64 + __ROL4__(v59 + *v5 + (v63 ^ (v64 | ~v60)) - 197909516, 6);
  v66 = v65 + __ROL4__(v60 + v5[7] + (v64 ^ (v65 | ~v63)) + 1126854183, 10);
  v67 = v66 + __ROL4__(v63 + v5[14] + (v65 ^ (v66 | ~v64)) - 1416355305, 15);
  v68 = v67 + __ROL4__(v64 + v5[5] + (v66 ^ (v67 | ~v65)) - 57302647, 21);
  v69 = v68 + __ROL4__(v65 + v5[12] + (v67 ^ (v68 | ~v66)) + 1700092019, 6);
  v70 = v69 + __ROL4__(v66 + v5[3] + (v68 ^ (v69 | ~v67)) - 1894986462, 10);
  v71 = v70 + __ROL4__(v67 + v5[10] + (v69 ^ (v70 | ~v68)) - 168823347, 15);
  v72 = v71 + __ROL4__(v68 + v5[1] + (v70 ^ (v71 | ~v69)) - 2054923167, 21);
  v73 = v72 + __ROL4__(v69 + v5[8] + (v71 ^ (v72 | ~v70)) + 1873117183, 6);
  v74 = v73 + __ROL4__(v70 + v5[15] + (v72 ^ (v73 | ~v71)) - 181606576, 10);
  v75 = v74 + __ROL4__(v71 + v5[6] + (v73 ^ (v74 | ~v72)) - 1560197980, 15);
  v76 = v75 + __ROL4__(v72 + v5[13] + (v74 ^ (v75 | ~v73)) + 1309167633, 21);
  v77 = v76 + __ROL4__(v73 + v5[4] + (v75 ^ (v76 | ~v74)) - 145391822, 6);
  v78 = v77 + __ROL4__(v74 + v5[11] + (v76 ^ (v77 | ~v75)) + 1161491333, 10);
  v79 = v62 + (v77 ^ (v78 | ~v76));
  v166 = v77 + 1731535537;
  v80 = v5[9];
  v81 = v78 + __ROL4__(v75 + v79 + 718766859, 15);
  v169 = v78 + 288511430;
  v168 = v81 - 1732588210;
  v167 = __ROL4__(v80 + (v78 ^ (v81 | ~v77)) + v76 - 346631647, 21) + v81 - 271734071;
  v82 = a3;
  for ( i = 0; i < 20; ++i )
  {
    v5[i] ^= v82 + *(&v166 + (i & 3));
    v5 = *a1;
    v82 = *((_DWORD *)*a1 + i);
  }
  sub_1000BB70();
  *(_DWORD *)*a1 ^= a3;
  result = *a1;
  v85 = __ROL4__(*(_DWORD *)*a1 - 681945657, 7) - 271734071;
  v86 = v85 + __ROL4__((v85 & 0xEFCDAAC9 | ~v85 & 0x98BACD4E) + *((_DWORD *)*a1 + 1) - 107344724, 12);
  v87 = v86 + __ROL4__((v85 & v86 | ~v86 & 0xEFCDAAC9) + *((_DWORD *)*a1 + 2) - 1126481991, 17);
  v88 = __ROL4__((v87 & v86 | v85 & ~v87) + *((_DWORD *)*a1 + 3) - 1319441881, 22);
  v89 = *((_DWORD *)*a1 + 4) + ((v87 + v88) & v87 | v86 & ~(v87 + v88)) + v85 - 177010401;
  v90 = v87 + v88;
  v91 = v90 + __ROL4__(v89, 7);
  v92 = v91 + __ROL4__(v86 + (v91 & v90 | v87 & ~v91) + *((_DWORD *)*a1 + 5) + 1200080794, 12);
  v93 = v92 + __ROL4__(v87 + (v91 & v92 | v90 & ~v92) + *((_DWORD *)*a1 + 6) - 1472706653, 17);
  v94 = __ROL4__(*((_DWORD *)*a1 + 7) + (v93 & v92 | v91 & ~v93) + v90 - 45706063, 22);
  v95 = *((_DWORD *)*a1 + 8) + ((v93 + v94) & v93 | v92 & ~(v93 + v94)) + v91 + 1753258344;
  v96 = v93 + v94;
  v97 = v96 + __ROL4__(v95, 7);
  v98 = v97 + __ROL4__(*((_DWORD *)*a1 + 9) + (v97 & v96 | v93 & ~v97) + v92 - 1958414817, 12);
  v99 = v98 + __ROL4__(*((_DWORD *)*a1 + 10) + (v97 & v98 | v96 & ~v98) + v93 - 7382527, 17);
  v100 = __ROL4__(*((_DWORD *)*a1 + 11) + (v99 & v98 | v97 & ~v99) + v96 - 1987258866, 22);
  v162 = v99 + v100;
  v101 = v99 + v100 + __ROL4__(*((_DWORD *)*a1 + 12) + ((v99 + v100) & v99 | v98 & ~(v99 + v100)) + v97 + 1804605842, 7);
  v102 = v101 + __ROL4__(*((_DWORD *)*a1 + 13) + (v101 & (v99 + v100) | v99 & ~v101) + v98 - 40341469, 12);
  v103 = v102 + __ROL4__(v99 + *((_DWORD *)*a1 + 14) + (v101 & v102 | (v99 + v100) & ~v102) - 1502002626, 17);
  v104 = v103 + __ROL4__(*((_DWORD *)*a1 + 15) + (v103 & v102 | v101 & ~v103) + v162 + 1232341393, 22);
  v105 = v104 + __ROL4__(*((_DWORD *)*a1 + 1) + (v104 & v102 | v103 & ~v102) + v101 - 166648622, 5);
  v106 = v105 + __ROL4__(v102 + (v105 & v103 | v104 & ~v103) + *((_DWORD *)*a1 + 6) - 985615632, 9);
  v107 = v106 + __ROL4__(*((_DWORD *)*a1 + 11) + (v104 & v106 | v105 & ~v104) + v103 + 643714017, 14);
  v108 = v107 + __ROL4__(*(_DWORD *)*a1 + (v105 & v107 | v106 & ~v105) + v104 - 374028774, 20);
  v109 = __ROL4__(*((_DWORD *)*a1 + 5) + (v108 & v106 | v107 & ~v106) + v105 - 702082579, 5);
  v110 = *((_DWORD *)*a1 + 10) + ((v108 + v109) & v107 | v108 & ~v107) + v106 + 39065059;
  v111 = v108 + v109;
  v112 = v111 + __ROL4__(v110, 9);
  v113 = v112 + __ROL4__(*((_DWORD *)*a1 + 15) + (v108 & v112 | v111 & ~v108) + v107 - 660515023, 14);
  v114 = v113 + __ROL4__(*((_DWORD *)*a1 + 4) + (v111 & v113 | v112 & ~v111) + v108 - 405538184, 20);
  v115 = __ROL4__(*((_DWORD *)*a1 + 9) + (v114 & v112 | v113 & ~v112) + v111 + 568642646, 5);
  v163 = v114 + v115;
  v116 = v114 + v115 + __ROL4__(*((_DWORD *)*a1 + 14) + ((v114 + v115) & v113 | v114 & ~v113) + v112 - 1019804058, 9);
  v117 = v116 + __ROL4__(*((_DWORD *)*a1 + 3) + v113 + (v114 & v116 | (v114 + v115) & ~v114) - 187366857, 14);
  v118 = *((_DWORD *)*a1 + 8);
  v119 = v117 + __ROL4__(v118 + (v163 & v117 | v116 & ~v163) + v114 + 1163531613, 20);
  v120 = __ROL4__(*((_DWORD *)*a1 + 13) + (v119 & v116 | v117 & ~v116) + v163 - 1456215883, 5);
  v164 = v119 + v120;
  v121 = v119 + v120 + __ROL4__(v116 + ((v119 + v120) & v117 | v119 & ~v117) + *((_DWORD *)*a1 + 2) - 51404216, 9);
  v122 = v121 + __ROL4__(v117 + *((_DWORD *)*a1 + 7) + (v119 & v121 | (v119 + v120) & ~v119) + 1735327849, 14);
  v123 = v122 + __ROL4__(*((_DWORD *)*a1 + 12) + (v164 & v122 | v121 & ~v164) + v119 - 1926673094, 20);
  v124 = v123 + __ROL4__(*((_DWORD *)*a1 + 5) + (v123 ^ v122 ^ v121) + v164 - 235259662, 4);
  v125 = v124 + __ROL4__(v121 + v118 + (v124 ^ v123 ^ v122) - 2022574287, 11);
  v126 = v125 + __ROL4__(*((_DWORD *)*a1 + 11) + (v124 ^ v123 ^ v125) + v122 + 1832738962, 16);
  v127 = v126 + __ROL4__(v123 + *((_DWORD *)*a1 + 14) + (v124 ^ v126 ^ v125) - 35309124, 23);
  v128 = v127 + __ROL4__(*((_DWORD *)*a1 + 1) + (v127 ^ v126 ^ v125) + v124 - 1531024396, 4);
  v129 = v128 + __ROL4__(v125 + (v128 ^ v127 ^ v126) + *((_DWORD *)*a1 + 4) + 1272889881, 11);
  v130 = v129 + __ROL4__(*((_DWORD *)*a1 + 7) + (v128 ^ v127 ^ v129) + v126 - 155694384, 16);
  v131 = v130 + __ROL4__(*((_DWORD *)*a1 + 10) + (v128 ^ v130 ^ v129) + v127 - 1094730304, 23);
  v132 = v131 + __ROL4__(*((_DWORD *)*a1 + 13) + (v131 ^ v130 ^ v129) + v128 + 680755062, 4);
  v133 = v132 + __ROL4__(v129 + (v132 ^ v131 ^ v130) + *(_DWORD *)*a1 - 358537654, 11);
  v134 = v133 + __ROL4__(v130 + (v132 ^ v131 ^ v133) + *((_DWORD *)*a1 + 3) - 722501323, 16);
  v135 = v134 + __ROL4__(v131 + *((_DWORD *)*a1 + 6) + (v132 ^ v134 ^ v133) + 76029109, 23);
  v136 = v135 + __ROL4__(*((_DWORD *)*a1 + 9) + (v135 ^ v134 ^ v133) + v132 - 640363895, 4);
  v137 = v136 + __ROL4__(*((_DWORD *)*a1 + 12) + (v136 ^ v135 ^ v134) + v133 - 429156267, 11);
  v138 = *((_DWORD *)*a1 + 2);
  v139 = v137 + __ROL4__(*((_DWORD *)*a1 + 15) + (v136 ^ v135 ^ v137) + v134 + 530742600, 16);
  v140 = v139 + __ROL4__(v138 + (v136 ^ v139 ^ v137) + v135 - 995346475, 23);
  v141 = v140 + __ROL4__(*(_DWORD *)*a1 + (v139 ^ (v140 | ~v137)) + v136 - 197909516, 6);
  v142 = v141 + __ROL4__(*((_DWORD *)*a1 + 7) + (v140 ^ (v141 | ~v139)) + v137 + 1126854183, 10);
  v143 = v142 + __ROL4__(*((_DWORD *)*a1 + 14) + (v141 ^ (v142 | ~v140)) + v139 - 1416355305, 15);
  v144 = v143 + __ROL4__(*((_DWORD *)*a1 + 5) + (v142 ^ (v143 | ~v141)) + v140 - 57302647, 21);
  v145 = v144 + __ROL4__(*((_DWORD *)*a1 + 12) + (v143 ^ (v144 | ~v142)) + v141 + 1700092019, 6);
  v146 = v145 + __ROL4__(v142 + (v144 ^ (v145 | ~v143)) + *((_DWORD *)*a1 + 3) - 1894986462, 10);
  v147 = v146 + __ROL4__(*((_DWORD *)*a1 + 10) + (v145 ^ (v146 | ~v144)) + v143 - 168823347, 15);
  v148 = v147 + __ROL4__(*((_DWORD *)*a1 + 1) + (v146 ^ (v147 | ~v145)) + v144 - 2054923167, 21);
  v149 = v148 + __ROL4__(*((_DWORD *)*a1 + 8) + (v147 ^ (v148 | ~v146)) + v145 + 1873117183, 6);
  v150 = v149 + __ROL4__(*((_DWORD *)*a1 + 15) + (v148 ^ (v149 | ~v147)) + v146 - 181606576, 10);
  v151 = v150 + __ROL4__(v147 + (v149 ^ (v150 | ~v148)) + *((_DWORD *)*a1 + 6) - 1560197980, 15);
  v152 = v151 + __ROL4__(*((_DWORD *)*a1 + 13) + (v150 ^ (v151 | ~v149)) + v148 + 1309167633, 21);
  v153 = v152 + __ROL4__(*((_DWORD *)*a1 + 4) + (v151 ^ (v152 | ~v150)) + v149 - 145391822, 6);
  v154 = v153 + __ROL4__(*((_DWORD *)*a1 + 11) + (v152 ^ (v153 | ~v151)) + v150 + 1161491333, 10);
  v155 = v151 + (v153 ^ (v154 | ~v152)) + v138 + 718766859;
  v156 = *((_DWORD *)*a1 + 9);
  v157 = v154 + __ROL4__(v155, 15);
  v166 = v153 + 1731535537;
  v169 = v154 + 288511430;
  v167 = __ROL4__(v156 + (v154 ^ (v157 | ~v153)) + v152 - 346631647, 21) + v157 - 271734071;
  v168 = v157 - 1732588210;
  v158 = a3;
  for ( j = 0; j < 20; ++j )
  {
    result[j] ^= v158 + *(&v166 + (j & 3));
    result = *a1;
    v158 = *((_DWORD *)*a1 + j);
  }
  return result;
}

//----- (10009680) --------------------------------------------------------
char __thiscall ContinuumEncrypt(void *this, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // ecx
  char *v7; // esi
  _DWORD *v8; // ebx
  int v9; // edx
  int *v10; // edx
  unsigned int v11; // edi
  int v12; // ebp
  int *v13; // edx
  int v14; // edi
  int v15; // edx
  int *v16; // esi
  unsigned int v17; // edi
  char v18; // dl
  int v21; // [esp+18h] [ebp+4h]
  unsigned int v22; // [esp+1Ch] [ebp+8h]
  int v23; // [esp+20h] [ebp+Ch]

  v4 = a4;
  v5 = 0;
  v6 = 0;
  v7 = (char *)a2;
  v8 = (_DWORD *)a3;
  if ( a4 > 7 )
  {
    v9 = a3 - a2;
    v21 = a3 - a2;
    v22 = a4 >> 3;
    while ( 1 )
    {
      v5 ^= *v8;
      v6 ^= *(_DWORD *)&v7[v9 + 4];
      v10 = *(int **)this;
      v11 = *(_DWORD *)this + 80;
      if ( *(_DWORD *)this < v11 )
      {
        do
        {
          v12 = *v10;
          v10 += 2;
          v5 = __ROL4__(v5 + v12, v6);
          v6 = __ROL4__(v6 + *(v10 - 1), v5);
        }
        while ( (unsigned int)v10 < v11 );
        v4 = a4;
      }
      *(_DWORD *)v7 = v5;
      *((_DWORD *)v7 + 1) = v6;
      v8 += 2;
      v7 += 8;
      v4 -= 8;
      a4 = v4;
      if ( !--v22 )
        break;
      v9 = v21;
    }
  }
  if ( v4 > 3 )
  {
    v5 ^= *v8;
    v13 = *(int **)this;
    if ( *(_DWORD *)this < (unsigned int)(*(_DWORD *)this + 80) )
    {
      do
      {
        v14 = *v13;
        v13 += 2;
        v5 = __ROL4__(v5 + v14, v6);
        v6 += *(v13 - 1);
      }
      while ( (unsigned int)v13 < *(_DWORD *)this + 80 );
    }
    *(_DWORD *)v7 = v5;
    ++v8;
    v7 += 4;
    v4 -= 4;
  }
  if ( v4 )
  {
    v15 = v7 - (char *)v8;
    v23 = v7 - (char *)v8;
    do
    {
      LOBYTE(v5) = *(_BYTE *)v8 ^ v5;
      v16 = *(int **)this;
      v17 = *(_DWORD *)this + 80;
      if ( *(_DWORD *)this < v17 )
      {
        do
        {
          v18 = *(_BYTE *)v16;
          v16 += 2;
          LOBYTE(v5) = v6 + v18 + v5;
          v6 += *(v16 - 1);
        }
        while ( (unsigned int)v16 < v17 );
        v15 = v23;
      }
      *((_BYTE *)v8 + v15) = v5;
      v8 = (_DWORD *)((char *)v8 + 1);
      --v4;
    }
    while ( v4 );
  }
  return v5;
}

//----- (10009790) --------------------------------------------------------
unsigned int __thiscall ContinuumDecrypt(void *this, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax
  int *v5; // ebx
  int i; // ebp
  int v8; // ecx
  int v9; // eax
  _DWORD *ExpandedKeyBackwards; // edx
  int v11; // ebx
  unsigned int v12; // ecx
  _BOOL1 v13; // zf
  int v14; // edi
  int v15; // ecx
  unsigned int ExpandedKeyy; // edx
  _DWORD *v17; // eax
  int v18; // ebp
  char *v19; // edi
  char v20; // bl
  int v21; // ecx
  unsigned int v22; // esi
  unsigned int v23; // edx
  _BYTE *v24; // eax
  int v25; // ebp
  int v26; // edx
  char v27; // dl
  int v28; // [esp+10h] [ebp-Ch]
  int v30; // [esp+18h] [ebp-4h]
  unsigned int v31; // [esp+20h] [ebp+4h]
  int v32; // [esp+24h] [ebp+8h]
  char *v33; // [esp+24h] [ebp+8h]
  unsigned int v34; // [esp+28h] [ebp+Ch]

  result = a4;
  v5 = (int *)a2;
  i = 0;
  v28 = 0;
  v32 = a2;
  if ( a4 > 7 )
  {
    v30 = a2 - a3;
    v31 = a4 >> 3;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      ExpandedKeyBackwards = (_DWORD *)(*(_DWORD *)this + 80);
      if ( (unsigned int)ExpandedKeyBackwards > *(_DWORD *)this )
      {
        do
        {
          v11 = *(ExpandedKeyBackwards - 1);
          ExpandedKeyBackwards -= 2;
          v9 = __ROR4__(v9, v8) - v11;
          v8 = __ROR4__(v8, v9) - *ExpandedKeyBackwards;
        }
        while ( (unsigned int)ExpandedKeyBackwards > *(_DWORD *)this );
        v5 = (int *)v32;
      }
      a3 += 8;
      *v5 = v28 ^ v8;
      v5 += 2;
      *(_DWORD *)(v30 + a3 - 4) = i ^ v9;
      i = *(_DWORD *)(a3 - 4);
      v12 = a4 - 8;
      v13 = v31 == 1;
      v28 = *(_DWORD *)(a3 - 8);
      v32 = (int)v5;
      a4 -= 8;
      --v31;
    }
    while ( !v13 );
    result = v12;
  }
  if ( result > 3 )
  {
    v14 = *(_DWORD *)a3;
    v15 = i;
    ExpandedKeyy = *(_DWORD *)this;
    v17 = (_DWORD *)(*(_DWORD *)this + 80);
    if ( *(_DWORD *)this < (unsigned int)v17 )
    {
      do
      {
        v18 = *(_DWORD *)(ExpandedKeyy + 4);
        ExpandedKeyy += 8;
        v15 += v18;
      }
      while ( ExpandedKeyy < (unsigned int)v17 );
    }
    for ( i = v15; (unsigned int)v17 > *(_DWORD *)this; v14 = __ROR4__(v14, v15) - *v17 )
    {
      v15 -= *(v17 - 1);
      v17 -= 2;
    }
    a3 += 4;
    *v5 = v28 ^ v14;
    v28 = *(_DWORD *)(a3 - 4);
    ++v5;
    result = a4 - 4;
  }
  v19 = (char *)a3;
  if ( result )
  {
    v34 = result;
    v33 = (char *)v5 - a3;
    do
    {
      v20 = *v19;
      v21 = i;
      v22 = *(_DWORD *)this;
      v23 = *(_DWORD *)this;
      v24 = (_BYTE *)(*(_DWORD *)this + 80);
      if ( *(_DWORD *)this < (unsigned int)v24 )
      {
        do
        {
          v25 = *(_DWORD *)(v23 + 4);
          v23 += 8;
          v21 += v25;
        }
        while ( v23 < (unsigned int)v24 );
      }
      for ( i = v21; (unsigned int)v24 > v22; v20 -= v21 + *v24 )
      {
        v26 = *((_DWORD *)v24 - 1);
        v24 -= 8;
        v21 -= v26;
      }
      v19[(_DWORD)v33] = v20 ^ v28;
      v27 = *v19++;
      result = v34 - 1;
      v13 = v34 == 1;
      LOBYTE(v28) = v27;
      --v34;
    }
    while ( !v13 );
  }
  return result;
}

//----- (10009920) --------------------------------------------------------
_DWORD *__thiscall ContinuumEncryptMD5Step3(void *this, int a2)
{
  _DWORD *result; // eax
  int v3; // edx
  int v4; // esi
  int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // edx
  int v21; // esi
  int v22; // edi
  int v23; // ebx
  int v24; // edx
  int v25; // esi
  int v26; // edi
  int v27; // ebx
  int v28; // edx
  int v29; // esi
  int v30; // edi
  int v31; // ebx
  int v32; // ecx
  int v33; // esi
  int v34; // ecx
  int v35; // esi
  int v36; // edi
  int v37; // edx
  int v38; // ebx
  int v39; // ecx
  int v40; // esi
  int v41; // edi
  int v42; // ebx
  int v43; // ecx
  int v44; // esi
  int v45; // edi
  int v46; // ebx
  int v47; // ecx
  int v48; // esi
  int v49; // edi
  int v50; // edx
  int v51; // ecx
  int v52; // esi
  int v53; // edi
  int v54; // edx
  int v55; // ecx
  int v56; // esi
  int v57; // ebp
  int v58; // edi
  int v59; // edx
  int v60; // ecx
  int v61; // esi
  int v62; // edi
  int v63; // edx
  int v64; // ecx
  int v65; // esi
  int v66; // edi
  int v67; // edx
  int v68; // ecx
  int v69; // esi
  int v70; // edi
  int v71; // ebx
  int v72; // edx
  int v73; // esi
  int v74; // ecx
  int v75; // ebp
  int v76; // edi
  int v77; // ecx
  int v78; // edx
  int i; // ecx
  int v80; // [esp+10h] [ebp-20h]
  int v81; // [esp+10h] [ebp-20h]
  int v82; // [esp+10h] [ebp-20h]
  int v84[4]; // [esp+20h] [ebp-10h]

  **(_DWORD **)this ^= a2;
  result = *(_DWORD **)this;
  v3 = __ROL4__(**(_DWORD **)this - 681945657, 7) - 271734071;
  v4 = v3 + __ROL4__((v3 & 0xEFCDAAC9 | ~v3 & 0x98BACD4E) + *(_DWORD *)(*(_DWORD *)this + 4) - 107344724, 12);
  v5 = v4 + __ROL4__((v3 & v4 | ~v4 & 0xEFCDAAC9) + *(_DWORD *)(*(_DWORD *)this + 8) - 1126481991, 17);
  v6 = *(_DWORD *)(*(_DWORD *)this + 16);
  v7 = __ROL4__((v5 & v4 | v3 & ~v5) + *(_DWORD *)(*(_DWORD *)this + 12) - 1319441881, 22);
  v8 = v6 + ((v5 + v7) & v5 | v4 & ~(v5 + v7)) + v3 - 177010401;
  v9 = v5 + v7;
  v10 = v9 + __ROL4__(v8, 7);
  v11 = v10 + __ROL4__(result[5] + (v10 & v9 | v5 & ~v10) + v4 + 0x4787C79A, 12);
  v12 = v11 + __ROL4__(result[6] + (v10 & v11 | v9 & ~v11) + v5 - 1472706653, 17);
  v13 = __ROL4__(result[7] + (v12 & v11 | v10 & ~v12) + v9 - 45706063, 22);
  v14 = result[8] + ((v12 + v13) & v12 | v11 & ~(v12 + v13)) + v10 + 1753258344;
  v15 = v12 + v13;
  v16 = v15 + __ROL4__(v14, 7);
  v17 = v16 + __ROL4__(result[9] + (v16 & v15 | v12 & ~v16) + v11 - 1958414817, 12);
  v18 = v17 + __ROL4__(result[10] + (v16 & v17 | v15 & ~v17) + v12 - 7382527, 17);
  v19 = __ROL4__(result[11] + (v18 & v17 | v16 & ~v18) + v15 - 1987258866, 22);
  v80 = v18 + v19;
  v20 = v18 + v19 + __ROL4__(result[12] + ((v18 + v19) & v18 | v17 & ~(v18 + v19)) + v16 + 1804605842, 7);
  v21 = v20 + __ROL4__(result[13] + (v20 & (v18 + v19) | v18 & ~v20) + v17 - 40341469, 12);
  v22 = v21 + __ROL4__(v18 + result[14] + (v20 & v21 | (v18 + v19) & ~v21) - 1502002626, 17);
  v23 = v22 + __ROL4__(result[15] + (v22 & v21 | v20 & ~v22) + v80 + 1232341393, 22);
  v24 = v23 + __ROL4__(result[1] + (v23 & v21 | v22 & ~v21) + v20 - 166648622, 5);
  v25 = v24 + __ROL4__(result[6] + (v24 & v22 | v23 & ~v22) + v21 - 985615632, 9);
  v26 = v25 + __ROL4__(result[11] + (v23 & v25 | v24 & ~v23) + v22 + 643714017, 14);
  v27 = v26 + __ROL4__(*result + (v24 & v26 | v25 & ~v24) + v23 - 374028774, 20);
  v28 = __ROL4__(result[5] + (v27 & v25 | v26 & ~v25) + v24 - 702082579, 5);
  v81 = v27 + v28;
  v29 = v27 + v28 + __ROL4__(result[10] + ((v27 + v28) & v26 | v27 & ~v26) + v25 + 39065059, 9);
  v30 = v29 + __ROL4__(result[15] + (v27 & v29 | (v27 + v28) & ~v27) + v26 - 660515023, 14);
  v31 = v30 + __ROL4__(result[4] + ((v27 + v28) & v30 | v29 & ~(v27 + v28)) + v27 - 405538184, 20);
  v32 = __ROL4__(result[9] + (v31 & v29 | v30 & ~v29) + v81 + 568642646, 5);
  v33 = result[14] + ((v31 + v32) & v30 | v31 & ~v30) + v29 - 1019804058;
  v34 = v31 + v32;
  v35 = v34 + __ROL4__(v33, 9);
  v36 = v35 + __ROL4__(result[3] + (v31 & v35 | v34 & ~v31) + v30 - 187366857, 14);
  v37 = result[8];
  v38 = v36 + __ROL4__(v37 + (v34 & v36 | v35 & ~v34) + v31 + 1163531613, 20);
  v39 = __ROL4__(result[13] + (v38 & v35 | v36 & ~v35) + v34 - 1456215883, 5);
  v82 = v38 + v39;
  v40 = v38 + v39 + __ROL4__(result[2] + ((v38 + v39) & v36 | v38 & ~v36) + v35 - 51404216, 9);
  v41 = v40 + __ROL4__(v36 + result[7] + (v38 & v40 | (v38 + v39) & ~v38) + 1735327849, 14);
  v42 = v41 + __ROL4__(result[12] + (v82 & v41 | v40 & ~v82) + v38 - 1926673094, 20);
  v43 = v42 + __ROL4__(result[5] + (v42 ^ v41 ^ v40) + v82 - 235259662, 4);
  v44 = v43 + __ROL4__(v40 + v37 + (v43 ^ v42 ^ v41) - 2022574287, 11);
  v45 = v44 + __ROL4__(result[11] + (v43 ^ v42 ^ v44) + v41 + 1832738962, 16);
  v46 = v45 + __ROL4__(v42 + result[14] + (v43 ^ v45 ^ v44) - 35309124, 23);
  v47 = v46 + __ROL4__(result[1] + (v46 ^ v45 ^ v44) + v43 - 1531024396, 4);
  v48 = v47 + __ROL4__(result[4] + (v47 ^ v46 ^ v45) + v44 + 1272889881, 11);
  v49 = v48 + __ROL4__(result[7] + (v47 ^ v46 ^ v48) + v45 - 155694384, 16);
  v50 = v49 + __ROL4__(result[10] + (v47 ^ v49 ^ v48) + v46 - 1094730304, 23);
  v51 = v50 + __ROL4__(v47 + result[13] + (v50 ^ v49 ^ v48) + 680755062, 4);
  v52 = v51 + __ROL4__(*result + (v51 ^ v50 ^ v49) + v48 - 358537654, 11);
  v53 = v52 + __ROL4__(result[3] + (v51 ^ v50 ^ v52) + v49 - 722501323, 16);
  v54 = v53 + __ROL4__(v50 + result[6] + (v51 ^ v53 ^ v52) + 76029109, 23);
  v55 = v54 + __ROL4__(result[9] + (v54 ^ v53 ^ v52) + v51 - 640363895, 4);
  v56 = v55 + __ROL4__(result[12] + (v55 ^ v54 ^ v53) + v52 - 429156267, 11);
  v57 = result[2];
  v58 = v56 + __ROL4__(result[15] + (v55 ^ v54 ^ v56) + v53 + 530742600, 16);
  v59 = v58 + __ROL4__(v57 + (v55 ^ v58 ^ v56) + v54 - 995346475, 23);
  v60 = v59 + __ROL4__(*result + (v58 ^ (v59 | ~v56)) + v55 - 197909516, 6);
  v61 = v60 + __ROL4__(result[7] + (v59 ^ (v60 | ~v58)) + v56 + 1126854183, 10);
  v62 = v61 + __ROL4__(result[14] + (v60 ^ (v61 | ~v59)) + v58 - 1416355305, 15);
  v63 = v62 + __ROL4__(result[5] + (v61 ^ (v62 | ~v60)) + v59 - 57302647, 21);
  v64 = v63 + __ROL4__(result[12] + (v62 ^ (v63 | ~v61)) + v60 + 1700092019, 6);
  v65 = v64 + __ROL4__(result[3] + (v63 ^ (v64 | ~v62)) + v61 - 1894986462, 10);
  v66 = v65 + __ROL4__(result[10] + (v64 ^ (v65 | ~v63)) + v62 - 168823347, 15);
  v67 = v66 + __ROL4__(result[1] + (v65 ^ (v66 | ~v64)) + v63 - 2054923167, 21);
  v68 = v67 + __ROL4__(result[8] + (v66 ^ (v67 | ~v65)) + v64 + 1873117183, 6);
  v69 = v68 + __ROL4__(result[15] + (v67 ^ (v68 | ~v66)) + v65 - 181606576, 10);
  v70 = v69 + __ROL4__(result[6] + (v68 ^ (v69 | ~v67)) + v66 - 1560197980, 15);
  v71 = v70 + __ROL4__(result[13] + (v69 ^ (v70 | ~v68)) + v67 + 1309167633, 21);
  v72 = v71 + __ROL4__(result[4] + (v70 ^ (v71 | ~v69)) + v68 - 145391822, 6);
  v73 = v72 + __ROL4__(result[11] + (v71 ^ (v72 | ~v70)) + v69 + 1161491333, 10);
  v74 = v57 + (v72 ^ (v73 | ~v71));
  v75 = result[9];
  v76 = v73 + __ROL4__(v74 + v70 + 718766859, 15);
  v84[0] = v72 + 1731535537;
  v84[3] = v73 + 288511430;
  v77 = __ROL4__(v75 + (v73 ^ (v76 | ~v72)) + v71 - 346631647, 21) + v76 - 271734071;
  v78 = a2;
  v84[1] = v77;
  v84[2] = v76 - 1732588210;
  for ( i = 0; i < 20; ++i )
  {
    result[i] ^= v78 + v84[i & 3];
    result = *(_DWORD **)this;
    v78 = *(_DWORD *)(*(_DWORD *)this + 4 * i);
  }
  return result;
}

//----- (1000A060) --------------------------------------------------------
size_t __thiscall sub_1000A060(void *this, char *a2, _BYTE *a3, size_t a4)
{
  char v5; // cl
  size_t result; // eax
  char v7; // bl
  size_t v8; // ecx
  size_t v9; // esi
  char v10; // cl
  unsigned __int8 v11; // [esp+8h] [ebp-210h]
  char v12; // [esp+Ch] [ebp-20Ch] BYREF
  char v13[523]; // [esp+Dh] [ebp-20Bh] BYREF

  if ( !*a3 && ((v5 = a3[1], v5 == 1) || v5 == 16 || v5 == 17) )
  {
    memcpy_0(a2, a3, a4);
    result = a4;
  }
  else
  {
    v7 = 0;
    v11 = 0;
    if ( a4 )
    {
      v8 = a4;
      do
      {
        --v8;
        v7 = byte_1002182C[(unsigned __int8)*a3 ^ v11];
        v11 = v7;
      }
      while ( v8 );
    }
    memcpy_0(v13, a3, a4);
    v9 = a4 + 1;
    v12 = v7;
    ContinuumEncrypt(this, (int)a2, (int)&v12, a4 + 1);
    if ( !*a2 && ((v10 = a2[1], v10 == 1) || v10 == 16 || v10 == 17) || *a2 == -1 )
    {
      memcpy_0(a2 + 1, a2, v9);
      *a2 = -1;
      v9 = a4 + 2;
    }
    result = v9;
  }
  return result;
}

//----- (1000A150) --------------------------------------------------------
size_t __thiscall sub_1000A150(void *this, void *a2, int *a3, size_t a4)
{
  int v4; // edi
  char v5; // bl
  size_t v6; // esi
  char v7; // dl
  unsigned int v8; // esi
  char v10; // dl
  int *v11; // ecx
  int v12; // eax
  int v13; // edx
  char v14; // cl
  unsigned int v15; // edx
  int *v16; // [esp-8h] [ebp-224h]
  size_t v17; // [esp-4h] [ebp-220h]
  unsigned __int8 v18; // [esp+Ch] [ebp-210h]
  unsigned __int8 v19; // [esp+Ch] [ebp-210h]
  char v20; // [esp+10h] [ebp-20Ch] BYREF
  unsigned __int8 v21[523]; // [esp+11h] [ebp-20Bh] BYREF

  v4 = (int)a3;
  if ( !*(_BYTE *)a3 && ((v5 = *((_BYTE *)a3 + 1), v5 == 1) || v5 == 16 || v5 == 17) )
  {
    v6 = a4;
    v17 = a4;
    v16 = a3;
  }
  else
  {
    if ( *(_BYTE *)a3 == 0xFF && ((v7 = *((_BYTE *)a3 + 1)) == 0 || v7 == -1) )
    {
      v4 = (int)a3 + 1;
      v8 = a4 - 1;
    }
    else
    {
      v8 = a4;
    }
    if ( !v8 )
      return 0;
    ContinuumDecrypt(this, (int)&v20, v4, v8);
    v10 = 0;
    v18 = 0;
    v11 = (int *)v21;
    if ( v8 != 1 )
    {
      v12 = v8 - 2 + 1;
      do
      {
        v13 = v18 ^ *(unsigned __int8 *)v11;
        v11 = (int *)((char *)v11 + 1);
        --v12;
        v10 = byte_1002182C[v13];
        v18 = v10;
      }
      while ( v12 );
    }
    if ( v20 != v10 )
    {
      v14 = 0;
      v19 = 0;
      if ( v8 > 1 )
      {
        v15 = v8 - 1;
        do
        {
          --v15;
          v14 = byte_1002182C[v21[0] ^ v19];
          v19 = v14;
        }
        while ( v15 );
      }
      if ( v20 != v14 )
        return 0;
    }
    v6 = v8 - 1;
    v17 = v6;
    v16 = (int *)v21;
  }
  memcpy_0(a2, v16, v17);
  return v6;
}

//----- (1000A270) --------------------------------------------------------
char __thiscall sub_1000A270(_DWORD *this, const char *a2)
{
  const char *v2; // ebp
  int v4; // edi
  _DWORD *i; // esi

  v2 = a2;
  if ( !*a2 )
    a2 = "$pub";
  v4 = 0;
  if ( !this[259] )
    return 0;
  for ( i = this + 3;
        unknown_libname_69(a2, i) && (!*v2 || unknown_libname_69(i, "$pvt") || !unknown_libname_69(v2, "$login"));
        i += 8 )
  {
    if ( (unsigned int)++v4 >= this[259] )
      return 0;
  }
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000A300) --------------------------------------------------------
bool __thiscall sub_1000A300(int this, int a2)
{
  return *(_DWORD *)(this + 4) == *(_DWORD *)(a2 + 4)
      && *(_DWORD *)(this + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(this + 1036) == *(_DWORD *)(a2 + 1036)
      && *(_BYTE *)(this + 1041) == *(_BYTE *)(a2 + 1041)
      && *(_BYTE *)(this + 1040) == *(_BYTE *)(a2 + 1040)
      && !memcmp((const void *)(this + 12), (const void *)(a2 + 12), 0x400u);
}

//----- (1000A370) --------------------------------------------------------
_DWORD *__thiscall sub_1000A370(_DWORD *this)
{
  this[4184] = this + 4185;
  this[6433] = 0;
  this[6434] = 32;
  `eh vector constructor iterator'(
    this + 6435,
    0x1B8u,
    300,
    (void (__thiscall *)(void *))sub_1000A420,
    (void (__thiscall *)(void *))sub_1000A440);
  *this = &off_10021958;
  this[4183] = 0;
  this[39435] = 0;
  this[39693] = FIX_DLL_KERNEL32_dll_GetTickCount();
  this[39694] = 0;
  this[39696] = 0;
  this[39695] = 0;
  this[39692] = 0;
  return this;
}
// 100170B8: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10021958: using guessed type void *off_10021958;

//----- (1000A420) --------------------------------------------------------
_DWORD *__thiscall sub_1000A420(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[107] = 0;
  this[10] = this + 11;
  this[108] = 16;
  return result;
}

//----- (1000A440) --------------------------------------------------------
int __thiscall sub_1000A440(_DWORD *this)
{
  _DWORD *v2; // ecx
  int result; // eax

  v2 = (_DWORD *)this[10];
  if ( v2 != this + 11 )
  {
    result = sub_10002D60(v2);
    this[10] = this + 11;
  }
  this[107] = 0;
  this[108] = 16;
  return result;
}

//----- (1000A470) --------------------------------------------------------
int __thiscall sub_1000A470(void *this, LPCSTR lpFileName)
{
  int v2; // ebp
  void (*v3)(void); // ebx
  int v4; // esi
  unsigned int i; // eax
  char *v6; // esi
  int v7; // esi
  int v8; // ebp
  int v9; // edx
  int v10; // eax
  int (__cdecl *v11)(CHAR *, const char *, int, LPCSTR); // ebp
  int v12; // eax
  int v13; // eax
  int v14; // edx
  unsigned int v15; // eax
  int j; // ebp
  char *v17; // esi
  char *v18; // edi
  char *v19; // edx
  int result; // eax
  char v21; // cl
  int v22; // eax
  unsigned int v23; // edi
  _DWORD *v24; // esi
  _DWORD *v25; // ecx
  _BYTE v26[5]; // [esp+1h] [ebp-43E1h]
  CHAR *v27; // [esp+6h] [ebp-43DCh]
  int v28; // [esp+22h] [ebp-43C0h] BYREF
  int *v29; // [esp+26h] [ebp-43BCh]
  const char *v30; // [esp+2Ah] [ebp-43B8h]
  int v31; // [esp+2Eh] [ebp-43B4h]
  LPCSTR v32; // [esp+32h] [ebp-43B0h] BYREF
  CHAR *v33; // [esp+36h] [ebp-43ACh]
  const char *v34; // [esp+3Ah] [ebp-43A8h] BYREF
  int v35; // [esp+3Eh] [ebp-43A4h]
  LPCSTR v36; // [esp+42h] [ebp-43A0h]
  CHAR v37[8]; // [esp+4Ah] [ebp-4398h] BYREF
  _DWORD v38[2]; // [esp+52h] [ebp-4390h] BYREF
  char *v39; // [esp+5Ah] [ebp-4388h]
  int v40; // [esp+5Eh] [ebp-4384h]
  int v41; // [esp+66h] [ebp-437Ch]
  int v42[2]; // [esp+6Ah] [ebp-4378h] BYREF
  u_long v43; // [esp+72h] [ebp-4370h] BYREF
  int v44; // [esp+76h] [ebp-436Ch]
  CHAR AppName[16]; // [esp+7Ah] [ebp-4368h] BYREF
  CHAR v46[24]; // [esp+8Ah] [ebp-4358h] BYREF
  CHAR ReturnedString[400]; // [esp+A2h] [ebp-4340h] BYREF
  char v48[8]; // [esp+232h] [ebp-41B0h] BYREF
  char v49; // [esp+23Ah] [ebp-41A8h] BYREF
  char v50[16728]; // [esp+28Ah] [ebp-4158h] BYREF

  v2 = (int)this;
  v42[1] = (int)this;
  v42[0] = FIX_DLL_KERNEL32_dll_GetTickCount();
  memset(v50, 0, sizeof(v50));
  v3 = *(void (**)(void))GetPrivateProfileStringA_0;
  v4 = 0;
  v44 = 0;
  GetPrivateProfileStringA_0("Peers", "MyArenas", LevelFiles, ReturnedString, 0x1FFu, lpFileName);
  for ( i = *(_DWORD *)(v2 + 158768); i < 0x20; ++v4 )
  {
    if ( !sub_10002E30((_BYTE *)(32 * i + v2 + 157744), 32, v46, 44, v4) )
      break;
    if ( *(_BYTE *)(32 * *(_DWORD *)(v2 + 158768) + v2 + 157744) )
      ++*(_DWORD *)(v2 + 158768);
    i = *(_DWORD *)(v2 + 158768);
  }
  v6 = 0;
  v41 = 0;
  v39 = v50;
  do
  {
    sprintf_0(AppName, "Peer%d", v6);
    ((void (__stdcall *)(CHAR *, const char *, char *, CHAR *, int, LPCSTR))v3)(
      AppName,
      "Address",
      LevelFiles,
      v46,
      511,
      lpFileName);
    sub_10006300(&v43, v46);
    if ( v43 )
    {
      v7 = (int)v39;
      v8 = v40 + 1;
      v36 = lpFileName;
      v39 += 2091;
      v9 = v44;
      *(_DWORD *)(v7 + 4) = v43;
      v10 = v42[0];
      v35 = 0;
      v40 = v8;
      v11 = (int (__cdecl *)(CHAR *, const char *, int, LPCSTR))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
      v34 = "SendOnly";
      v33 = AppName;
      *(_DWORD *)(v7 + 8) = v9;
      *(_DWORD *)(v7 + 1058) = v10;
      *(_BYTE *)(v7 + 2090) = 0;
      v12 = v11(v33, v34, v35, v36);
      v32 = lpFileName;
      v31 = 1;
      v30 = "SendPlayerList";
      v29 = v42;
      *(_BYTE *)(v7 + 1041) = v12 != 0;
      v13 = v11((CHAR *)v29, v30, v31, v32);
      v14 = v38[0];
      *(_WORD *)(v7 + 1042) = 2;
      v28 = v14;
      *(_BYTE *)(v7 + 1040) = v13 != 0;
      *(_DWORD *)(v7 + 1046) = j_FIX_DLL_WSOCK32_dll_ord_0008(v28);
      v27 = (CHAR *)v38;
      *(_WORD *)(v7 + 1044) = j_FIX_DLL_WSOCK32_dll_ord_0009(v38[0]);
      v3();
      v28 = -1;
      sub_10001120(&v28, v37);
      *(_DWORD *)v7 = v28;
      ((void (__cdecl *)(const char **, const char *, char *, CHAR *, int, LPCSTR))v3)(
        &v34,
        "Arenas",
        LevelFiles,
        v37,
        511,
        lpFileName);
      v15 = *(_DWORD *)(v7 + 1036);
      for ( j = 0; v15 < 0x20; ++j )
      {
        if ( !sub_10002E30((_BYTE *)(32 * v15 + v7 + 12), 32, (char *)&v32, 44, j) )
          break;
        if ( *(_BYTE *)(32 * *(_DWORD *)(v7 + 1036) + v7 + 12) )
          ++*(_DWORD *)(v7 + 1036);
        v15 = *(_DWORD *)(v7 + 1036);
      }
      v6 = LevelFiles;
      v2 = 511;
    }
    ++v6;
  }
  while ( (unsigned int)v6 < 8 );
  v26[4] = 0;
  *(_DWORD *)v26 = v27 != *(CHAR **)(v2 + 16732);
  if ( v27 == *(CHAR **)(v2 + 16732) )
  {
    v17 = &v50[-v2 + 936];
    v18 = &v50[-v2 + 941];
    v19 = &v49;
    result = v2 + 12;
    while ( *(_DWORD *)&v26[1] < (unsigned int)v27 )
    {
      if ( *((_DWORD *)v19 - 1) == *(_DWORD *)(result - 4)
        && *(_DWORD *)v19 == *(_DWORD *)result
        && *(_DWORD *)&v17[result] == *(_DWORD *)(result + 1028)
        && v18[result] == *(_BYTE *)(result + 1033)
        && v50[result + 940 - v2] == *(_BYTE *)(result + 1032)
        && !memcmp(&v48[result - v2], (const void *)(result + 4), 0x400u) )
      {
        v21 = v26[0];
      }
      else
      {
        v21 = 1;
        v26[0] = 1;
      }
      result += 2091;
      v19 += 2091;
      ++*(_DWORD *)&v26[1];
      if ( v21 )
        goto LABEL_30;
      v18 = &v50[-v2 + 941];
      v17 = &v50[-v2 + 936];
    }
  }
  else
  {
LABEL_30:
    memcpy_0((void *)(v2 + 4), v48, 0x4158u);
    v22 = *(_DWORD *)(v2 + 157740);
    v23 = 0;
    *(_DWORD *)(v2 + 16732) = v27;
    if ( v22 )
    {
      v24 = (_DWORD *)(v2 + 26168);
      do
      {
        v25 = (_DWORD *)*(v24 - 97);
        if ( v25 != v24 - 96 )
        {
          sub_10002D60(v25);
          *(v24 - 97) = v24 - 96;
        }
        *v24 = 0;
        v24[1] = 16;
        ++v23;
        v24 += 110;
      }
      while ( v23 < *(_DWORD *)(v2 + 157740) );
    }
    result = 0;
    *(_DWORD *)(v2 + 157740) = 0;
    *(_DWORD *)(v2 + 158784) = 0;
  }
  return result;
}
// 1000A7BF: conditional instruction was optimized away because of 'cl.1==0'
// 1000A6E6: variable 'v27' is possibly undefined
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 10015996: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0009(_DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;

//----- (1000A860) --------------------------------------------------------
char __thiscall sub_1000A860(unsigned __int16 *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  unsigned int v7; // edx
  unsigned __int16 *i; // ecx
  unsigned __int16 *v9; // ecx
  int v10; // esi
  int v11; // ebp

  v6 = 0;
  v7 = *((_DWORD *)this + 4183);
  if ( v7 )
  {
    for ( i = this + 524; *(_DWORD *)(i + 1) != a4 || *i != a5; i = (unsigned __int16 *)((char *)i + 2091) )
    {
      if ( ++v6 >= v7 )
        return v6;
    }
    v6 *= 697;
    v9 = &this[v6];
    v10 = (int)v9 + v6 + 4;
    if ( (unsigned __int16 *)((char *)v9 + v6) != (unsigned __int16 *)-4 )
    {
      v6 = *(_DWORD *)v10;
      if ( *(_DWORD *)(a2 + 2) == *(_DWORD *)v10 )
      {
        v6 = *(_DWORD *)(a2 + 8);
        if ( *(_DWORD *)(v10 + 4 * (unsigned __int8)v6 + 1062) != v6 )
        {
          *(_DWORD *)(v10 + 4 * (unsigned __int8)v6 + 1062) = v6;
          *(_DWORD *)(v10 + 1058) = FIX_DLL_KERNEL32_dll_GetTickCount();
          LOBYTE(v6) = *(_BYTE *)(v10 + 1041);
          *(_BYTE *)(v10 + 2090) = 0;
          if ( !(_BYTE)v6 )
          {
            LOBYTE(v6) = *(_BYTE *)(a2 + 7);
            switch ( (_BYTE)v6 )
            {
              case 1:
                LOBYTE(v6) = sub_1000AAA0(this, (int *)(a2 + 12), a3 - 12, v10);
                break;
              case 2:
              case 3:
                v11 = *(unsigned __int8 *)(a2 + 7);
                LOBYTE(v6) = a3 - 12;
                if ( (unsigned int)(a3 - 12) >= 2 )
                {
                  v6 = (int)memchr((const void *)(a2 + 13), 0, a3 - 13);
                  if ( v6 )
                  {
                    if ( v11 == 2 )
                    {
                      LOBYTE(v6) = (*(int (__thiscall **)(unsigned __int16 *, int, _DWORD))(*(_DWORD *)this + 8))(
                                     this,
                                     a2 + 13,
                                     *(unsigned __int8 *)(a2 + 12));
                    }
                    else if ( v11 == 3 )
                    {
                      LOBYTE(v6) = (*(int (__thiscall **)(unsigned __int16 *, int))(*(_DWORD *)this + 4))(this, a2 + 13);
                    }
                  }
                }
                break;
              case 4:
                LOBYTE(v6) = a3 - 12;
                if ( (unsigned int)(a3 - 12) >= 2 )
                {
                  *((_DWORD *)this + 39696) -= *(_DWORD *)(v10 + 2086);
                  LOWORD(v6) = *(_WORD *)(a2 + 12);
                  *(_DWORD *)(v10 + 2086) = (unsigned __int16)v6;
                  *((_DWORD *)this + 39696) += (unsigned __int16)v6;
                }
                break;
            }
          }
        }
      }
    }
  }
  return v6;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000A9F0) --------------------------------------------------------
void *__thiscall sub_1000A9F0(void *this, unsigned __int8 *a2, unsigned int a3, int a4, void *a5)
{
  void *result; // eax
  unsigned __int8 *v7; // edi

  result = (void *)a3;
  if ( a3 >= 2 )
  {
    v7 = a2 + 1;
    result = memchr(a2 + 1, 0, a3 - 1);
    if ( result )
    {
      result = a5;
      if ( a5 == (void *)2 )
      {
        result = (void *)(*(int (__thiscall **)(void *, unsigned __int8 *, _DWORD))(*(_DWORD *)this + 8))(this, v7, *a2);
      }
      else if ( a5 == (void *)3 )
      {
        result = (void *)(*(int (__thiscall **)(void *, unsigned __int8 *))(*(_DWORD *)this + 4))(this, v7);
      }
    }
  }
  return result;
}

//----- (1000AA50) --------------------------------------------------------
int __thiscall sub_1000AA50(_DWORD *this, _WORD *a2, unsigned int a3, int a4)
{
  int result; // eax

  if ( a3 >= 2 )
  {
    HIWORD(result) = 0;
    this[39696] -= *(_DWORD *)(a4 + 2086);
    LOWORD(result) = *a2;
    *(_DWORD *)(a4 + 2086) = (unsigned __int16)*a2;
    this[39696] += (unsigned __int16)result;
  }
  return result;
}

//----- (1000AAA0) --------------------------------------------------------
char __thiscall sub_1000AAA0(_DWORD *this, int *a2, int a3, int a4)
{
  int *v4; // ebx
  int v5; // edi
  unsigned int v6; // ebp
  char *v7; // eax
  int v8; // edx
  void *v9; // ebx
  char *v10; // esi
  _BYTE *v11; // ebx
  unsigned int v12; // edx
  int v13; // ebp
  unsigned int v14; // eax
  _DWORD *v15; // ecx
  int v16; // eax
  void *v17; // ecx
  int v18; // ecx
  signed int v19; // eax
  char *v20; // edi
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // ecx
  unsigned int v24; // eax
  int v25; // eax
  int v26; // ecx
  void *v27; // esi
  void *v29; // [esp+10h] [ebp-48h] BYREF
  int v30; // [esp+14h] [ebp-44h]
  _DWORD *v31; // [esp+18h] [ebp-40h]
  int v32; // [esp+1Ch] [ebp-3Ch]
  char v33[24]; // [esp+20h] [ebp-38h] BYREF
  char dst[32]; // [esp+38h] [ebp-20h] BYREF
  unsigned int v35; // [esp+5Ch] [ebp+4h]
  _DWORD *v36; // [esp+60h] [ebp+8h]

  v4 = a2;
  v5 = (int)this;
  v31 = this;
  v35 = (unsigned int)a2 + a3;
  v6 = v35;
  v7 = (char *)FIX_DLL_KERNEL32_dll_GetTickCount();
  v32 = (int)v7;
  if ( (int)(v35 - (_DWORD)v4) <= 6 )
    return (char)v7;
  while ( 2 )
  {
    v8 = *v4;
    v9 = v4 + 1;
    v30 = v8;
    v7 = (char *)memchr(v9, 0, v6 - (_DWORD)v9);
    v10 = v7;
    if ( !v7 )
      return (char)v7;
    LOBYTE(v7) = (unsigned __int8)strncpyt(dst, v9, 32);
    v11 = v10 + 1;
    if ( (unsigned int)(v10 + 1) >= v6 )
      return (char)v7;
    v12 = *(_DWORD *)(v5 + 157740);
    v13 = 0;
    v14 = 0;
    v36 = 0;
    if ( !v12 )
      goto LABEL_19;
    v15 = (_DWORD *)(v5 + 25740);
    while ( 1 )
    {
      if ( !*v15 )
      {
        if ( !v13 )
        {
          v36 = v15;
          v13 = (int)v15;
        }
        goto LABEL_14;
      }
      if ( *v15 == a4 && v15[1] == v30 )
        break;
LABEL_14:
      ++v14;
      v15 += 110;
      if ( v14 >= v12 )
        goto LABEL_18;
    }
    v16 = 55 * v14;
    v13 = v5 + 8 * v16 + 25740;
    if ( v5 + 8 * v16 != -25740 )
      goto LABEL_21;
    v13 = (int)v36;
LABEL_18:
    if ( !v13 )
    {
LABEL_19:
      *(_DWORD *)(v5 + 157740) = v12 + 1;
      v13 = v5 + 440 * v12 + 25740;
    }
    *(_DWORD *)(v13 + 4) = v30;
    *(_DWORD *)v13 = a4;
LABEL_21:
    *(_DWORD *)(v5 + 158784) -= *(_DWORD *)(v13 + 428);
    strcpy((char *)(v13 + 8), dst);
    v17 = *(void **)(v13 + 40);
    if ( v17 != (void *)(v13 + 44) )
    {
      sub_10002D60(v17);
      *(_DWORD *)(v13 + 40) = v13 + 44;
    }
    v18 = v32;
    v19 = v35 - (_DWORD)v11;
    *(_DWORD *)(v13 + 428) = 0;
    *(_DWORD *)(v13 + 432) = 16;
    for ( *(_DWORD *)(v13 + 436) = v18; v19 > 0; v19 = v35 - (_DWORD)(v20 + 1) )
    {
      if ( !*v11 )
        break;
      v20 = (char *)memchr(v11, 0, v19);
      if ( !v20 )
        break;
      v21 = *(_DWORD *)(v13 + 428);
      v22 = *(_DWORD *)(v13 + 432);
      if ( v21 >= v22 && v21 + 1 > v22 )
      {
        v23 = *(_DWORD *)(v13 + 40);
        v24 = v21 + 16;
        *(_DWORD *)(v13 + 432) = v24;
        if ( v23 == v13 + 44 )
          *(_DWORD *)(v13 + 40) = 0;
        v29 = *(void **)(v13 + 40);
        sub_10002D10((int *)&v29, 24 * v24);
        if ( !*(_DWORD *)(v13 + 40) )
          memcpy_0(v29, (const void *)(v13 + 44), 24 * *(_DWORD *)(v13 + 428));
        *(_DWORD *)(v13 + 40) = v29;
      }
      v25 = *(_DWORD *)(v13 + 428);
      v26 = *(_DWORD *)(v13 + 40);
      *(_DWORD *)(v13 + 428) = v25 + 1;
      v27 = (void *)(v26 + 24 * v25);
      memcpy_0(v27, v33, 0x18u);
      strncpyt(v27, v11, 24);
      v11 = v20 + 1;
    }
    v31[39696] += *(_DWORD *)(v13 + 428);
    LOBYTE(v7) = *v11;
    if ( !*v11 )
    {
      v4 = (int *)(v11 + 1);
      if ( (int)(v35 - (_DWORD)v4) > 6 )
      {
        v6 = v35;
        v5 = (int)v31;
        continue;
      }
    }
    return (char)v7;
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000AD20) --------------------------------------------------------
char __thiscall sub_1000AD20(_DWORD *this, const char *a2, _DWORD *a3, _DWORD *a4)
{
  const char *v4; // eax
  const char *v5; // ebp
  unsigned int v6; // edi
  _DWORD *v7; // esi
  int v8; // ebp
  _DWORD *i; // ebx
  unsigned int v10; // edi
  _DWORD *v11; // esi
  char *v12; // edx
  _DWORD *v14; // [esp+10h] [ebp-8h]
  const char *v15; // [esp+14h] [ebp-4h]

  v4 = a2;
  v14 = this;
  v5 = a2;
  if ( !*a2 )
    v5 = "$pub";
  v6 = 0;
  if ( this[39692] )
  {
    v7 = this + 39436;
    while ( unknown_libname_69(v5, v7) && (!*a2 || unknown_libname_69(v7, "$pvt") || !unknown_libname_69(a2, "$login")) )
    {
      ++v6;
      v7 += 8;
      if ( v6 >= v14[39692] )
      {
        this = v14;
        v4 = a2;
        goto LABEL_11;
      }
    }
    return 0;
  }
LABEL_11:
  v8 = 0;
  if ( !this[4183] )
    return 0;
  for ( i = this + 4; ; i = (_DWORD *)((char *)i + 2091) )
  {
    v15 = v4;
    if ( !*v4 )
      v15 = "$pub";
    v10 = 0;
    if ( i[256] )
      break;
LABEL_23:
    if ( (unsigned int)++v8 >= this[4183] )
      return 0;
  }
  v11 = i;
  while ( unknown_libname_69(v15, v11) && (!*a2 || unknown_libname_69(v11, "$pvt") || !unknown_libname_69(a2, "$login")) )
  {
    ++v10;
    v11 += 8;
    if ( v10 >= i[256] )
    {
      this = v14;
      v4 = a2;
      goto LABEL_23;
    }
  }
  v12 = (char *)v14 + 1394 * v8;
  *a3 = *(_DWORD *)&v12[697 * v8 + 8];
  *a4 = *(_DWORD *)&v12[697 * v8 + 12];
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000AEA0) --------------------------------------------------------
unsigned int __thiscall sub_1000AEA0(char *this)
{
  int v2; // edx
  unsigned int result; // eax
  int v4; // ebx
  int v5; // eax
  int *v6; // eax
  int v7; // ebx
  unsigned int v8; // edi
  int v9; // eax
  int v10; // ebx
  char *v11; // esi
  int v12; // eax
  int v13; // edx
  int *v14; // eax
  int v15; // esi
  int v16; // ecx
  int v17; // edi
  int v18; // edx
  int v19; // eax
  char *v20; // ecx
  unsigned int v21; // ecx
  char *v22; // edx
  _BOOL1 v23; // cf
  unsigned int v24; // ecx
  char *v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // edi
  int v29; // ebx
  char *v30; // esi
  char *v31; // ecx
  int v32; // eax
  unsigned int v33; // edi
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ebx
  char *v37; // esi
  char *v38; // esi
  int v39; // eax
  unsigned int v40; // edx
  _BOOL1 v41; // zf
  unsigned int v42; // ebx
  char *v43; // edi
  void (__thiscall **v44)(void *, char *, int, int); // edx
  void (__thiscall **v45)(void *, char *, int, int); // eax
  int v46; // [esp+10h] [ebp-628h] BYREF
  int v47; // [esp+14h] [ebp-624h]
  unsigned int v48; // [esp+18h] [ebp-620h] BYREF
  int v49; // [esp+1Ch] [ebp-61Ch]
  int v50; // [esp+20h] [ebp-618h] BYREF
  char v51[2]; // [esp+24h] [ebp-614h] BYREF
  int v52; // [esp+26h] [ebp-612h]
  char v53; // [esp+2Ah] [ebp-60Eh]
  char v54; // [esp+2Bh] [ebp-60Dh]
  int v55; // [esp+2Ch] [ebp-60Ch]
  __int16 v56; // [esp+30h] [ebp-608h]
  char v57[32]; // [esp+44h] [ebp-5F4h] BYREF
  char v58[2]; // [esp+64h] [ebp-5D4h] BYREF
  int v59; // [esp+66h] [ebp-5D2h]
  char v60; // [esp+6Ah] [ebp-5CEh]
  char v61; // [esp+6Bh] [ebp-5CDh]
  int v62; // [esp+6Ch] [ebp-5CCh]
  char v63; // [esp+70h] [ebp-5C8h] BYREF
  char v64[2]; // [esp+636h] [ebp-2h] BYREF

  v2 = FIX_DLL_KERNEL32_dll_GetTickCount();
  result = *((_DWORD *)this + 39694);
  v4 = 0;
  v46 = v2;
  if ( (!result || (int)(v2 - result) >= 1000) && *((_DWORD *)this + 4183) )
  {
    v5 = *((_DWORD *)this + 6433);
    *((_DWORD *)this + 39694) = v2;
    v49 = 0;
    if ( v5 )
    {
      v47 = 0;
      do
      {
        v6 = (int *)(v4 + *((_DWORD *)this + 4184));
        if ( v2 - *v6 >= 1000 )
        {
          *v6 = v2;
          v7 = *((_DWORD *)this + 4184) + v4;
          v8 = 0;
          v9 = *(_DWORD *)(v7 + 8);
          v10 = v7 + 12;
          v50 = v9;
          if ( *((_DWORD *)this + 4183) )
          {
            v11 = this + 1046;
            do
            {
              v12 = v50;
              *(_DWORD *)(v10 + 2) = *(_DWORD *)(v11 - 1042);
              (**(void (__thiscall ***)(void *, int, int, char *))this)(this, v10, v12, v11);
              ++v8;
              v11 += 2091;
            }
            while ( v8 < *((_DWORD *)this + 4183) );
          }
          v13 = v47;
          v14 = (int *)(v47 + *((_DWORD *)this + 4184) + 4);
          v15 = *v14 + 1;
          *v14 = v15;
          if ( v15 >= 3 )
          {
            v16 = v13;
            v47 = v13 - 281;
            v17 = *((_DWORD *)this + 4184);
            v50 = v13 + 281;
            v18 = *((_DWORD *)this + 6433);
            --v49;
            memcpy_0((void *)(v17 + v16), (const void *)(v17 + v16 + 281), 281 * v18 - (v16 + 281));
            v19 = *((_DWORD *)this + 6433) - 1;
            *((_DWORD *)this + 6433) = v19;
            if ( v19 )
            {
              if ( (unsigned int)(*((_DWORD *)this + 6434) - v19) > 0x20 )
              {
                v21 = *((_DWORD *)this + 6434) - 16;
                *((_DWORD *)this + 6434) = v21;
                if ( v21 > 0x20 )
                {
                  v48 = *((_DWORD *)this + 4184);
                  sub_10002D10((int *)&v48, 281 * v21);
                  *((_DWORD *)this + 4184) = v48;
                }
                else
                {
                  v22 = (char *)*((_DWORD *)this + 4184);
                  if ( v22 != this + 16740 )
                  {
                    memcpy_0(this + 16740, v22, 281 * v19);
                    sub_10002D60(*((void **)this + 4184));
                    *((_DWORD *)this + 4184) = this + 16740;
                  }
                  *((_DWORD *)this + 6434) = 32;
                }
              }
            }
            else
            {
              v20 = (char *)*((_DWORD *)this + 4184);
              if ( v20 != this + 16740 )
              {
                sub_10002D60(v20);
                *((_DWORD *)this + 4184) = this + 16740;
              }
              *((_DWORD *)this + 6433) = 0;
              *((_DWORD *)this + 6434) = 32;
            }
          }
        }
        v2 = v46;
        v4 = v47 + 281;
        v23 = (unsigned int)++v49 < *((_DWORD *)this + 6433);
        v47 += 281;
      }
      while ( v23 );
    }
    v24 = 0;
    if ( *((_DWORD *)this + 4183) )
    {
      v25 = this + 2090;
      do
      {
        if ( v2 - *((_DWORD *)v25 - 257) > 60000 )
        {
          v25[4] = 1;
          *((_DWORD *)this + 39696) -= *(_DWORD *)v25;
          *(_DWORD *)v25 = 0;
        }
        ++v24;
        v25 += 2091;
      }
      while ( v24 < *((_DWORD *)this + 4183) );
    }
    v26 = *((_DWORD *)this + 39435);
    v27 = v26 - 1;
    if ( v26 >= 0 )
    {
      v28 = *((_DWORD *)this + 39435);
      v29 = v27 + 2;
      v30 = &this[440 * v27 + 26168];
      do
      {
        if ( *((_DWORD *)v30 - 107) && v2 - *((_DWORD *)v30 + 2) > 10000 )
        {
          *((_DWORD *)this + 39696) -= *(_DWORD *)v30;
          v31 = (char *)*((_DWORD *)v30 - 97);
          if ( v31 != v30 - 384 )
          {
            sub_10002D60(v31);
            *((_DWORD *)v30 - 97) = v30 - 384;
          }
          *(_DWORD *)v30 = 0;
          *((_DWORD *)v30 + 1) = 16;
          *((_DWORD *)v30 - 107) = 0;
          v32 = *((_DWORD *)this + 39435);
          if ( v28 == v32 )
            *((_DWORD *)this + 39435) = v32 - 1;
          v2 = v46;
        }
        --v29;
        v30 -= 440;
        --v28;
      }
      while ( v29 );
    }
    v33 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 12))(this);
    v34 = *((_DWORD *)this + 39695);
    v48 = v33;
    if ( v34 >= v33 )
      *((_DWORD *)this + 39695) = 0;
    v35 = *(_DWORD *)this;
    v47 = *((_DWORD *)this + 39695);
    v62 = *((_DWORD *)this + 39693);
    v55 = v62 + 1;
    v60 = -1;
    v53 = -1;
    v58[0] = 0;
    v58[1] = 1;
    v61 = 1;
    v51[0] = 0;
    v51[1] = 1;
    v54 = 4;
    *((_DWORD *)this + 39693) = v62 + 2;
    v56 = (*(int (__thiscall **)(char *))(v35 + 24))(this);
    v36 = 0;
    v37 = &v63;
    while ( v33 )
    {
      if ( (*(unsigned __int8 (__thiscall **)(char *, char *, int *, int *, _DWORD))(*(_DWORD *)this + 16))(
             this,
             v57,
             &v50,
             &v46,
             *((_DWORD *)this + 39695)) )
      {
        if ( v36 && &v37[14 * v50] >= v64 )
          break;
        *(_DWORD *)v37 = v46;
        strcpy(v37 + 4, v57);
        v38 = strchr_0(v37 + 4, 0) + 1;
        v39 = (*(int (__thiscall **)(char *, char *, int, _DWORD))(*(_DWORD *)this + 20))(
                this,
                v38,
                v64 - v38,
                *((_DWORD *)this + 39695));
        v33 = v48;
        v37 = &v38[v39];
        ++v36;
      }
      v40 = (*((_DWORD *)this + 39695) + 1) % v33;
      v41 = v40 == v47;
      *((_DWORD *)this + 39695) = v40;
      if ( v41 || v64 - v37 < 100 )
        break;
    }
    result = *((_DWORD *)this + 4183);
    v42 = 0;
    if ( result )
    {
      v43 = this + 4;
      do
      {
        if ( v43[1040] && v48 )
        {
          v44 = *(void (__thiscall ***)(void *, char *, int, int))this;
          v59 = *(_DWORD *)v43;
          (*v44)(this, v58, v37 - v58, (int)(v43 + 1042));
        }
        else
        {
          v45 = *(void (__thiscall ***)(void *, char *, int, int))this;
          v52 = *(_DWORD *)v43;
          (*v45)(this, v51, 14, (int)(v43 + 1042));
        }
        result = *((_DWORD *)this + 4183);
        ++v42;
        v43 += 2091;
      }
      while ( v42 < result );
    }
  }
  return result;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000B3B0) --------------------------------------------------------
unsigned int __thiscall sub_1000B3B0(_DWORD *this, int a2, int a3)
{
  unsigned int v4; // ebx
  unsigned int result; // eax
  char *v6; // edi

  v4 = 0;
  result = this[4183];
  if ( result )
  {
    v6 = (char *)this + 1046;
    do
    {
      *(_DWORD *)(a2 + 2) = *(_DWORD *)(v6 - 1042);
      (*(void (__thiscall **)(_DWORD *, int, int, char *))*this)(this, a2, a3, v6);
      result = this[4183];
      ++v4;
      v6 += 2091;
    }
    while ( v4 < result );
  }
  return result;
}

//----- (1000B400) --------------------------------------------------------
char *__thiscall sub_1000B400(char *this, char a2, void *src, char a4)
{
  char *result; // eax
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  char *v11; // eax
  int v12; // eax
  int *v13; // esi
  _DWORD *v14; // ebx
  unsigned int v15; // ebp
  int v16; // ecx
  char *v17; // esi
  void *v18; // [esp+10h] [ebp-124h] BYREF
  char *v19; // [esp+14h] [ebp-120h]
  char v20[284]; // [esp+18h] [ebp-11Ch] BYREF

  result = (char *)*((_DWORD *)this + 4183);
  if ( result )
  {
    v6 = FIX_DLL_KERNEL32_dll_GetTickCount();
    v7 = *((_DWORD *)this + 6434);
    v8 = v6;
    v9 = *((_DWORD *)this + 6433);
    if ( v9 >= v7 && v9 + 1 > v7 )
    {
      v10 = v9 + 32;
      v11 = (char *)*((_DWORD *)this + 4184);
      *((_DWORD *)this + 6434) = v10;
      if ( v11 == this + 16740 )
        *((_DWORD *)this + 4184) = 0;
      v18 = (void *)*((_DWORD *)this + 4184);
      sub_10002D10((int *)&v18, 281 * v10);
      if ( !*((_DWORD *)this + 4184) )
        memcpy_0(v18, this + 16740, 281 * *((_DWORD *)this + 6433));
      *((_DWORD *)this + 4184) = v18;
    }
    v12 = *((_DWORD *)this + 6433);
    v13 = (int *)(*((_DWORD *)this + 4184) + 281 * v12);
    *((_DWORD *)this + 6433) = v12 + 1;
    memcpy_0(v13, v20, 0x119u);
    *v13 = v8;
    v13[1] = 1;
    v14 = v13 + 3;
    *((_BYTE *)v13 + 13) = 1;
    *((_BYTE *)v13 + 12) = 0;
    *((_BYTE *)v13 + 18) = -1;
    *((_BYTE *)v13 + 19) = a2;
    v13[5] = (*((_DWORD *)this + 39693))++;
    *((_BYTE *)v13 + 24) = a4;
    strncpyt((char *)v13 + 25, src, 256);
    v15 = 0;
    result = &strchr_0((const char *)v13 + 25, 0)[-11 - (_DWORD)v13];
    v13[2] = (int)result;
    v16 = *((_DWORD *)this + 4183);
    v19 = result;
    if ( v16 )
    {
      v17 = this + 1046;
      while ( 1 )
      {
        *(_DWORD *)((char *)v14 + 2) = *(_DWORD *)(v17 - 1042);
        (**(void (__thiscall ***)(void *, _DWORD *, char *, char *))this)(this, v14, result, v17);
        result = (char *)*((_DWORD *)this + 4183);
        ++v15;
        v17 += 2091;
        if ( v15 >= (unsigned int)result )
          break;
        result = v19;
      }
    }
  }
  return result;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000B5B0) --------------------------------------------------------
char __thiscall sub_1000B5B0(char *this, char *a2, char *a3, const char *a4)
{
  char *v4; // edx
  int v5; // ebp
  unsigned int *i; // esi
  unsigned int v7; // ebx
  int v8; // edi
  char result; // al
  char *v10; // ebp
  int v11; // [esp+10h] [ebp-8h]

  v4 = this;
  v11 = strlen(a4);
  if ( v11 > 23 )
    v11 = 23;
  v5 = 0;
  if ( !*((_DWORD *)v4 + 39435) )
    return 0;
  for ( i = (unsigned int *)(v4 + 26168); ; i += 110 )
  {
    v7 = 0;
    if ( *i )
      break;
LABEL_10:
    if ( (unsigned int)++v5 >= *((_DWORD *)v4 + 39435) )
      return 0;
  }
  v8 = 0;
  while ( _memicmp_0((const void *)(v8 + *(i - 97)), a4, v11) )
  {
    ++v7;
    v8 += 24;
    if ( v7 >= *i )
    {
      v4 = this;
      goto LABEL_10;
    }
  }
  v10 = &this[440 * v5];
  if ( *sub_10003240(v10 + 25748) )
    strcpy(a2, v10 + 25748);
  else
    sprintf_0(a2, "Public %s", v10 + 25748);
  result = 1;
  strcpy(a3, (const char *)(*((_DWORD *)v10 + 6445) + 24 * v7));
  return result;
}

//----- (1000B6E0) --------------------------------------------------------
int __thiscall sub_1000B6E0(_DWORD *this, char *a2, char a3)
{
  char *v3; // edx
  unsigned int v4; // ebx
  const char *v5; // ebp
  char *v6; // eax
  _DWORD *v8; // [esp+4h] [ebp-4h]

  v3 = a2;
  v4 = 0;
  v8 = this;
  if ( this[39435] )
  {
    v5 = (const char *)(this + 6437);
    do
    {
      if ( *((_DWORD *)v5 - 2) && (*v5 != 35 || a3) )
      {
        if ( *((_DWORD *)v5 + 105) )
        {
          strcpy(v3, v5);
          v6 = strchr_0(v3, 0) + 1;
          *(_WORD *)v6 = *((_WORD *)v5 + 210);
          this = v8;
          v3 = v6 + 2;
        }
      }
      ++v4;
      v5 += 440;
    }
    while ( v4 < this[39435] );
  }
  return v3 - a2;
}

//----- (1000B780) --------------------------------------------------------
int __thiscall sub_1000B780(char **this)
{
  char *v2; // ecx
  int result; // eax

  v2 = *this;
  if ( v2 != (char *)(this + 1) )
  {
    result = sub_10002D60(v2);
    *this = (char *)(this + 1);
  }
  this[2249] = 0;
  this[2250] = (char *)32;
  return result;
}

//----- (1000B7B0) --------------------------------------------------------
int sub_1000B7B0()
{
  dword_101A9508 = 0;
  dword_101A9504 = 0;
  dword_101A9500 = 0;
  return atexit((void (*)(void))sub_1000B7D0);
}
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (1000B7D0) --------------------------------------------------------
int sub_1000B7D0(void)
{
  int result; // eax

  sub_10002D60((void *)dword_101A9500);
  result = 0;
  dword_101A9500 = 0;
  dword_101A9508 = 0;
  dword_101A9504 = 0;
  return result;
}
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (1000B7F0) --------------------------------------------------------
int sub_1000B7F0()
{
  sub_1000B8B0(byte_1003E438);
  return atexit(sub_1000B810);
}

//----- (1000B810) --------------------------------------------------------
void sub_1000B810(void)
{
  char *v0; // ecx

  `eh vector destructor iterator'(&byte_1003E438[25740], 0x1B8u, 300, (void (__thiscall *)(void *))sub_1000A440);
  v0 = *(char **)&byte_1003E438[16736];
  if ( v0 != &byte_1003E438[16740] )
  {
    sub_10002D60(v0);
    *(_DWORD *)&byte_1003E438[16736] = &byte_1003E438[16740];
  }
  *(_DWORD *)&byte_1003E438[25732] = 0;
  *(_DWORD *)&byte_1003E438[25736] = 32;
}
// 1001713A: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *));

//----- (1000B8B0) --------------------------------------------------------
_DWORD *__thiscall sub_1000B8B0(_DWORD *this)
{
  sub_1000A370(this);
  *this = &off_10021A50;
  return this;
}
// 10021A50: using guessed type int (__stdcall *off_10021A50)(int, int, int);

//----- (1000B8D0) --------------------------------------------------------
int __stdcall sub_1000B8D0(PLAYER *src)
{
  int result; // eax
  _BOOL1 v3; // cc
  char v4[3]; // [esp+0h] [ebp-110h] BYREF
  __int16 v5; // [esp+3h] [ebp-10Dh]
  char dst[251]; // [esp+5h] [ebp-10Bh] BYREF
  int buf_sz; // [esp+100h] [ebp-10h]
  void *buf; // [esp+104h] [ebp-Ch]
  int v9; // [esp+108h] [ebp-8h]
  int *v10; // [esp+10Ch] [ebp-4h]
  PLAYER *srca; // [esp+118h] [ebp+8h]

  result = ZonePlayerCount;
  v9 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v10 = ZonePlayers;
    do
    {
      srca = (PLAYER *)*v10;
      if ( *v10 )
      {
        if ( *(_DWORD *)(*v10 + 639) )
        {
          v4[0] = 7;
          v4[1] = 7;
          v4[2] = 0;
          v5 = -1;
          strncpyt(dst, src, 250);
          buf_sz = strlen(dst) + 6;
          buf = v4;
          PlayerSendPacket(srca, v4, buf_sz, 1);
        }
      }
      result = v9 + 1;
      v3 = ++v9 < ZonePlayerCount;
      ++v10;
    }
    while ( v3 );
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (1000B9A0) --------------------------------------------------------
int __stdcall sub_1000B9A0(char *msg, char msg_type)
{
  int result; // eax
  int v3; // edi
  struct PLAYER **v4; // esi

  result = ZonePlayerCount;
  v3 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v4 = (struct PLAYER **)ZonePlayers;
    do
    {
      if ( *v4 )
        SendMessage(*v4, msg, msg_type);
      result = ZonePlayerCount;
      ++v3;
      ++v4;
    }
    while ( v3 < ZonePlayerCount );
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (1000B9F0) --------------------------------------------------------
LPCSTR __stdcall sub_1000B9F0(int a1, int a2, int a3)
{
  LPCSTR result; // eax

  result = ServerPacketAttachment;
  if ( ServerPacketAttachment )
    result = (LPCSTR)j_FIX_DLL_WSOCK32_dll_ord_0014();
  return result;
}

//----- (1000BA20) --------------------------------------------------------
int sub_1000BA20()
{
  return ArenaArrayLength;
}

//----- (1000BA30) --------------------------------------------------------
char __stdcall sub_1000BA30(char *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v4; // ebx

  v4 = ArenaArray[a4];
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(v4 + 64256) )
    strcpy(a1, (const char *)(v4 + 64256));
  else
    sprintf_0(a1, "%d", a4);
  *a2 = *(_DWORD *)(v4 + 65292);
  *a3 = *(_DWORD *)(v4 + 121261);
  return 1;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000BAB0) --------------------------------------------------------
int __stdcall sub_1000BAB0(char *a1, int a2, int a3)
{
  _BYTE *v3; // ebx
  int v4; // ebp
  size_t v5; // kr04_4
  _BOOL1 v6; // cc
  char *v8; // [esp+10h] [ebp-8h]
  char *v10; // [esp+1Ch] [ebp+4h]
  int v11; // [esp+20h] [ebp+8h]

  v3 = a1;
  v4 = ArenaArray[a3];
  v8 = &a1[a2];
  v11 = 0;
  if ( *(int *)(v4 + 65292) > 0 )
  {
    v10 = (char *)(v4 + 64288);
    do
    {
      if ( *(_DWORD *)v10 )
      {
        v5 = strlen((const char *)(*(_DWORD *)v10 + 375)) + 1;
        if ( v8 - v3 < (int)(v5 + 1) )
          break;
        memcpy_0(v3, (const void *)(*(_DWORD *)v10 + 375), v5);
        v3 += v5;
      }
      v6 = ++v11 < *(_DWORD *)(v4 + 65292);
      v10 += 4;
    }
    while ( v6 );
  }
  *v3 = 0;
  return v3 - a1 + 1;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000BB60) --------------------------------------------------------
int sub_1000BB60()
{
  return ZonePlayerCount;
}
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (1000BB70) --------------------------------------------------------
int sub_1000BB70()
{
  return 0;
}

//----- (1000BB80) --------------------------------------------------------
void __thiscall sub_1000BB80(struct BILLING_SERVER_STRUCT *this, int a2, const char *a3)
{
  biller_user_command(this, a2, a3);
}

//----- (1000BBA0) --------------------------------------------------------
int __thiscall WriteDataProxyRemoveLater(struct CONNECTION *this, void *buf, int buf_sz, BOOL bReliable)
{
  return WriteData(this, buf, buf_sz, bReliable);
}

//----- (1000BBC0) --------------------------------------------------------
#error "1000BBD5: call analysis failed (funcsize=12)"

//----- (1000BBE0) --------------------------------------------------------
void __thiscall sub_1000BBE0(struct CONNECTION *this, char *a2, int a3, int a4)
{
  GetMapLvlRequest(this, a2, a3, a4);
}

//----- (1000BC00) --------------------------------------------------------
void __usercall sub_1000BC00(int a1@<ecx>, int a2@<edi>)
{
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  sub_41D6D0(a1, (int)&savedregs, a2);
}

//----- (1000BC20) --------------------------------------------------------
void __thiscall biller_player_login(void *this, const void *playerName, const void *a3, int a4, int a5, int a6, char buf_sz, signed int buf, int a9, void *classptr)
{
  _BOOL1 v11; // zf
  __int16 v12; // dx
  size_t v13; // esi
  char v14[2]; // [esp+0h] [ebp-158h] BYREF
  int v15; // [esp+2h] [ebp-156h]
  int dst; // [esp+6h] [ebp-152h] BYREF
  int v17[11]; // [esp+26h] [ebp-132h] BYREF
  char v18; // [esp+52h] [ebp-106h]
  char v19; // [esp+53h] [ebp-105h]
  __int16 v20; // [esp+54h] [ebp-104h]
  int v21; // [esp+56h] [ebp-102h] BYREF
  int buf_sza; // [esp+174h] [ebp+1Ch]

  if ( buf >= 0 )
  {
    v15 = a4;
    v14[0] = 4;
    v14[1] = buf_sz;
    strncpyt(&dst, (void *)playerName, 32);
    strncpyt(v17, (void *)a3, 32);
    v17[10] = a6;
    v19 = (char)classptr;
    v11 = *(_BYTE *)a9 == 9;
    v17[9] = a5;
    v12 = *(_WORD *)(a9 + 75);
    v17[8] = buf;
    v18 = 0;
    v20 = v12;
    if ( v11 )
    {
      buf_sza = 86;
    }
    else
    {
      v13 = *(_DWORD *)(a9 + 77) - 101;
      if ( v13 > 0x100 )
        v13 = 256;
      memcpy_0(&v21, (const void *)(a9 + 101), v13);
      buf_sza = v13 + 86;
    }
    WriteData(*((struct CONNECTION **)this + 1), v14, buf_sza, 1);
  }
}

//----- (1000BD10) --------------------------------------------------------
int __thiscall sub_1000BD10(struct struc_2 *this, char *lpszSection, char *lpszKey, int DefaultVal)
{
  return GetCFGSettingInteger(this, lpszSection, lpszKey, DefaultVal);
}

//----- (1000BD30) --------------------------------------------------------
int __thiscall sub_1000BD30(PLAYER *this, void *buf, int buf_sz, BOOL bSendReliable)
{
  return PlayerSendPacket(this, buf, buf_sz, bSendReliable);
}

//----- (1000BD50) --------------------------------------------------------
void __thiscall sub_1000BD50(struct PLAYER *this, signed int ship)
{
  struct PLAYER *v2; // esi
  int v3; // eax

  v2 = this;
  v3 = FIX_DLL_KERNEL32_dll_GetTickCount();
  *(_DWORD *)&v2->field_341[52] = v3;
  *(_DWORD *)&v2->field_341[197] = v3 + 5000;
  SetPlayerShip(this, ship);
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000BD90) --------------------------------------------------------
void __thiscall sub_1000BD90(int this, signed int a2)
{
  *(_DWORD *)(this + 885) = FIX_DLL_KERNEL32_dll_GetTickCount();
  PlayerChangeFrequency((struct PLAYER *)this, a2);
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (1000BDC0) --------------------------------------------------------
void __thiscall sub_1000BDC0(PLAYER *this)
{
  SendResetScoresPacket(this);
}

//----- (1000BDE0) --------------------------------------------------------
int __thiscall sub_1000BDE0(int *this, char *filename)
{
  char v3[4]; // [esp+0h] [ebp-108h] BYREF
  char *msg; // [esp+100h] [ebp-8h]
  struct PLAYER *v5; // [esp+104h] [ebp-4h]

  v5 = (struct PLAYER *)this;
  sprintf_0(v3, "File sent: %s (please wait...)", filename);
  msg = v3;
  SendMessage(v5, v3, 0);
  return SendFile(&v5->hProcess, filename);
}

//----- (1000BE30) --------------------------------------------------------
void __thiscall sub_1000BE30(struct PLAYER *this, char *msg, char msg_type)
{
  SendMessage(this, msg, msg_type);
}

//----- (1000BE50) --------------------------------------------------------
void __thiscall sub_1000BE50(PLAYER *this, char *reason, char something)
{
  SendArenaMessagePlayer(this, reason, something);
}

//----- (1000BE70) --------------------------------------------------------
int __thiscall sub_1000BE70(PLAYER *this, void *src, void *buf, char buf_sz)
{
  char v5[3]; // [esp+0h] [ebp-104h] BYREF
  __int16 v6; // [esp+3h] [ebp-101h]
  char dst[251]; // [esp+5h] [ebp-FFh] BYREF
  PLAYER *player; // [esp+100h] [ebp-4h]

  player = this;
  v5[2] = buf_sz;
  v5[0] = 7;
  v5[1] = (char)buf;
  v6 = -1;
  strncpyt(dst, src, 250);
  return PlayerSendPacket(player, v5, strlen(dst) + 6, 1);
}

//----- (1000BEF0) --------------------------------------------------------
void __thiscall sub_1000BEF0(PLAYER *this, BYTE *pkt, DWORD pkt_sz)
{
  PlayerHandleGamePacket(this, pkt, pkt_sz);
}

//----- (1000BF10) --------------------------------------------------------
void __thiscall sub_1000BF10(struct PLAYER *this, int a2)
{
  SendAdvertisement(this, a2);
}

//----- (1000BF30) --------------------------------------------------------
int __thiscall sub_1000BF30(PLAYER *this, void *buf)
{
  _BYTE v3[257]; // [esp+0h] [ebp-118h] BYREF
  int dst[4]; // [esp+101h] [ebp-17h] BYREF
  PLAYER *player; // [esp+114h] [ebp-4h]

  player = this;
  v3[0] = 25;
  strncpyt(dst, buf, 16);
  strncpyt(&v3[1], buf, 256);
  return PlayerSendPacket(player, v3, 273, 1);
}

//----- (1000BF90) --------------------------------------------------------
void __thiscall sub_1000BF90(int this, int a2)
{
  __int16 v2; // ax
  __int16 v3; // si
  __int16 v4; // dx
  ARENA *v5; // ecx
  char v6; // [esp+0h] [ebp-18h] BYREF
  __int16 v7; // [esp+1h] [ebp-17h]
  int v8; // [esp+3h] [ebp-15h]
  int v9; // [esp+7h] [ebp-11h]
  __int16 v10; // [esp+Bh] [ebp-Dh]
  __int16 v11; // [esp+Dh] [ebp-Bh]
  void *buf; // [esp+10h] [ebp-8h]
  ARENA *arena; // [esp+14h] [ebp-4h]

  *(_DWORD *)(this + 557) = a2;
  v9 = a2;
  v2 = *(_WORD *)(this + 547);
  *(_DWORD *)(this + 553) = 0;
  v3 = *(_WORD *)(this + 20);
  v8 = 0;
  v4 = *(_WORD *)(this + 549);
  v5 = *(ARENA **)(this + 28);
  v10 = v2;
  v6 = 9;
  v7 = v3;
  v11 = v4;
  buf = &v6;
  arena = v5;
  ArenaSendPacket(v5, &v6, 15, 1);
}

//----- (1000C000) --------------------------------------------------------
void __thiscall sub_1000C000(void *this, char *reason)
{
  _DWORD *v2; // esi
  unsigned int v3; // edx
  int v4; // eax
  _BOOL1 v5; // sf

  v2 = this;
  v3 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
  if ( v3 - *(_DWORD *)((char *)v2 + 655) >= 0x96 )
  {
    *(_DWORD *)((char *)v2 + 655) = v3;
    *(_DWORD *)((char *)v2 + 659) = 0;
  }
  else
  {
    v4 = *(_DWORD *)((char *)v2 + 659) + 1;
    v5 = *(_DWORD *)((char *)v2 + 659) - 6 < 0;
    *(_DWORD *)((char *)v2 + 659) = v4;
    if ( !(v5 ^ __OFSUB__(v4, 7) | (v4 == 7)) )
    {
      *(_DWORD *)((char *)v2 + 789) = 33;
      v2[14] = 1;
      if ( (_BYTE)reason )
      {
        off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)v2 + 375);
        SendArenaMessagePlayer((PLAYER *)this, "WARNING: You have been disconnected for message flooding", 0);
      }
    }
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000C0B0) --------------------------------------------------------
char __thiscall sub_1000C0B0(int this, int a2)
{
  int v3; // eax
  int *i; // edx

  v3 = 0;
  for ( i = (int *)(this + 861); *i >= 0; ++i )
  {
    if ( *i == a2 )
    {
      memcpy_0((void *)(4 * v3 + this + 861), (const void *)(4 * v3 + this + 865), 20 - 4 * v3);
      *(_DWORD *)(this + 881) = -1;
      return 0;
    }
    if ( (unsigned int)++v3 >= 6 )
      return 0;
  }
  *(_DWORD *)(this + 4 * v3 + 861) = a2;
  return 1;
}
// 1000C111: conditional instruction was optimized away because of 'eax.4<6u'

//----- (1000C130) --------------------------------------------------------
char __thiscall sub_1000C130(int this, int a2)
{
  int v3; // eax
  int *i; // edx

  v3 = 0;
  for ( i = (int *)(this + 1295); *i >= 0; ++i )
  {
    if ( *i == a2 )
    {
      memcpy_0((void *)(4 * v3 + this + 1295), (const void *)(4 * v3 + this + 1299), 20 - 4 * v3);
      *(_DWORD *)(this + 1315) = -1;
      return 0;
    }
    if ( (unsigned int)++v3 >= 6 )
      return 0;
  }
  *(_DWORD *)(this + 4 * v3 + 1295) = a2;
  return 1;
}
// 1000C191: conditional instruction was optimized away because of 'eax.4<6u'

//----- (1000C1B0) --------------------------------------------------------
char *__thiscall sub_1000C1B0(PLAYER *this, char a2)
{
  ARENA *v2; // edx
  int v4; // esi
  int v5; // eax
  int *v6; // ecx

  byte_101A939C = 0;
  if ( !this )
    return &byte_101A939C;
  v2 = (ARENA *)this->lpCurrentArena;
  if ( !v2 )
    return &byte_101A939C;
  if ( v2->name[offsetof(ARENA, field_0)] )
  {
    strcpy(&byte_101A939C, v2->name);
    if ( !a2 && byte_101A939C == '#' )
    {
      strcpy(&byte_101A939C, "(Private arena)");
      return &byte_101A939C;
    }
  }
  else
  {
    v4 = -1;
    v5 = 0;
    if ( ArenaArrayLength > 0 )
    {
      v6 = ArenaArray;
      do
      {
        if ( (ARENA *)*v6 == v2 )
          v4 = v5;
        ++v5;
        ++v6;
      }
      while ( v5 < ArenaArrayLength );
    }
    sprintf_0(&byte_101A939C, "Public %d", v4);
  }
  return &byte_101A939C;
}
// 4D68D0: using guessed type int ArenaArray[];

//----- (1000C290) --------------------------------------------------------
char __fastcall find_player_request(PLAYER *requester, char *target_name)
{
  signed int v2; // edi
  PLAYER **v3; // ebx
  PLAYER *v4; // esi
  char result; // al
  char *v6; // eax
  char v7[4]; // [esp+0h] [ebp-CCh] BYREF
  int v8[3]; // [esp+80h] [ebp-4Ch] BYREF
  int v9[3]; // [esp+A0h] [ebp-2Ch] BYREF
  int v10; // [esp+C0h] [ebp-Ch]
  struct PLAYER *v11; // [esp+C4h] [ebp-8h]
  char *msg; // [esp+C8h] [ebp-4h]

  v11 = requester;
  v2 = strlen(target_name);
  msg = target_name;
  if ( v2 > ' ' )
    v2 = 32;
  v10 = 0;
  if ( ZonePlayerCount <= 0 )
  {
LABEL_10:
    if ( sub_1000B5B0(byte_1003E438, (char *)v9, (char *)v8, target_name) )
    {
      if ( !v11->bIsModerator && LOBYTE(v9[0]) == '#' )
        strcpy((char *)v9, "(Private arena)");
      sprintf_0(v7, "%s - %s", (const char *)v8, (const char *)v9);
      msg = v7;
      SendMessage(v11, v7, 0);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v3 = (PLAYER **)ZonePlayers;
    while ( 1 )
    {
      v4 = *v3;
      if ( *v3 )
      {
        if ( v4->lpCurrentArena && !_memicmp_0(v4->player_name, msg, v2) )
          break;
      }
      ++v3;
      if ( ++v10 >= ZonePlayerCount )
      {
        target_name = msg;
        goto LABEL_10;
      }
    }
    v6 = sub_1000C1B0(v4, v11->bIsModerator != 0);
    sprintf_0(v7, "%s - %s", v4->player_name, v6);
    msg = v7;
    SendMessage(v11, v7, 0);
    result = 1;
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (1000C400) --------------------------------------------------------
int __thiscall sub_1000C400(char *this, int a2, void *a3)
{
  int *v3; // esi
  int v4; // ebx
  int i; // ebp

  v3 = (int *)&this[12 * a2];
  v4 = 0;
  if ( v3[70] <= 0 )
    return 0;
  for ( i = 0; _memicmp_0((const void *)(v3[68] + i + 6), a3, strlen((const char *)(v3[68] + i + 6))); i += 38 )
  {
    if ( ++v4 >= v3[70] )
      return 0;
  }
  return v3[68] + 38 * v4;
}

//----- (1000C480) --------------------------------------------------------
int __thiscall sub_1000C480(int this)
{
  const CHAR *v2; // esi
  int v3; // eax
  int (__cdecl *v4)(const char *, const char *, int, const CHAR *); // edi
  unsigned __int32 v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  const CHAR *v9; // eax
  int v10; // eax
  char *v11; // eax
  char v12; // cl
  _BOOL1 v13; // zf
  int v14; // eax
  int v15; // edx
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int *v20; // ecx
  int v21; // edx
  int v22; // ecx
  int *v23; // eax
  int j; // eax
  int v25; // eax
  int v26; // edi
  const CHAR *v27; // eax
  char *v28; // edi
  char *v29; // eax
  int v30; // esi
  int v31; // eax
  _DWORD *v32; // edi
  int v33; // esi
  int v34; // eax
  _BYTE *v35; // edi
  void *v36; // ecx
  int *v37; // ebx
  int v38; // edi
  int result; // eax
  int v40; // [esp+0h] [ebp-910h] BYREF
  CHAR ReturnedString[1024]; // [esp+Ch] [ebp-904h] BYREF
  char src[1024]; // [esp+40Ch] [ebp-504h] BYREF
  int v43; // [esp+80Ch] [ebp-104h] BYREF
  int v44[9]; // [esp+810h] [ebp-100h] BYREF
  _BYTE v45[32]; // [esp+834h] [ebp-DCh] BYREF
  char tmp_str[64]; // [esp+854h] [ebp-BCh] BYREF
  char v47[28]; // [esp+894h] [ebp-7Ch] BYREF
  int dst[8]; // [esp+8B0h] [ebp-60h] BYREF
  _BOOL1 v49; // [esp+8D0h] [ebp-40h]
  const CHAR *v50; // [esp+8D4h] [ebp-3Ch]
  int v51; // [esp+8D8h] [ebp-38h] BYREF
  char *v52; // [esp+8DCh] [ebp-34h]
  int v53; // [esp+8E0h] [ebp-30h]
  void *v54; // [esp+8E4h] [ebp-2Ch]
  int a2; // [esp+8E8h] [ebp-28h] BYREF
  int *v56; // [esp+8ECh] [ebp-24h]
  int i; // [esp+8F0h] [ebp-20h]
  _DWORD *v58; // [esp+8F4h] [ebp-1Ch]
  int k; // [esp+8F8h] [ebp-18h]
  char v60; // [esp+8FEh] [ebp-12h]
  _BOOL1 v61; // [esp+8FFh] [ebp-11h]
  int *v62; // [esp+900h] [ebp-10h]
  int v63; // [esp+90Ch] [ebp-4h]

  v2 = (const CHAR *)(this + 4);
  v62 = &v40;
  v50 = (const CHAR *)(this + 4);
  sub_1000A470(byte_1003E438, (LPCSTR)(this + 4));
  sub_10002D60(*(void **)(this + 272));
  *(_DWORD *)(this + 272) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 276) = 0;
  sub_10002D60(*(void **)(this + 284));
  *(_DWORD *)(this + 284) = 0;
  *(_DWORD *)(this + 292) = 0;
  *(_DWORD *)(this + 288) = 0;
  sub_10002D60(*(void **)(this + 296));
  *(_DWORD *)(this + 296) = 0;
  *(_DWORD *)(this + 304) = 0;
  *(_DWORD *)(this + 300) = 0;
  sub_10002D60(*(void **)(this + 308));
  *(_DWORD *)(this + 308) = 0;
  *(_DWORD *)(this + 316) = 0;
  *(_DWORD *)(this + 312) = 0;
  i = 69069 * *(_DWORD *)(this + 440) + 17009;
  *(_DWORD *)(this + 440) = i;
  v3 = FIX_DLL_KERNEL32_dll_GetTickCount();
  v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
  *(_DWORD *)(this + 440) = i ^ v3;
  *(_BYTE *)(this + 468) = v4("Validation", "CheckMod", 0, v2) != 0;
  *(_BYTE *)(this + 469) = v4("Validation", "CheckSMod", 0, v2) != 0;
  *(_BYTE *)(this + 470) = v4("Validation", "CheckSysop", 0, v2) != 0;
  *(_BYTE *)(this + 475) = v4("Misc", "CheckWeapons", 0, v2) != 0;
  *(_BYTE *)(this + 477) = v4("Misc", "CheckPrizeDistribution", 0, v2) != 0;
  *(_BYTE *)(this + 476) = v4("Misc", "ForceObsceneCheck", 0, v2) != 0;
  *(_DWORD *)(this + 400) = 10 * v4("Misc", "ShipTypeSwitchResetPeriod", 0, v2);
  *(_DWORD *)(this + 404) = v4("Misc", "CheckFastBombing", 0, v2);
  *(_DWORD *)(this + 408) = 10 * v4("Misc", "FastBombingThreshold", 30, v2);
  *(_DWORD *)(this + 396) = v4("Misc", "TimerDropFlagTerritoryRadius", -1, v2);
  *(_BYTE *)(this + 474) = v4("Misc", "AllowPubScorereset", 0, v2) != 0;
  *(_BYTE *)(this + 473) = v4("Misc", "AllowPvtScorereset", 0, v2) != 0;
  *(_BYTE *)(this + 471) = v4("Misc", "NoAntiInSafe", 0, v2) != 0;
  *(_BYTE *)(this + 472) = v4("Misc", "LockFreqs", 0, v2) != 0;
  *(_BYTE *)(this + 478) = v4("Misc", "AllowVIEClients", 1, v2) != 0;
  *(_BYTE *)(this + 479) = v4("Misc", "NoFlagRewardLimit", 0, v2) != 0;
  *(_BYTE *)(this + 480) = v4("Misc", "TrackFlood", 0, v2) != 0;
  *(_BYTE *)(this + 481) = v4("Misc", "ForceContinuumOnly", 0, v2) != 0;
  *(_BYTE *)(this + 482) = v4("Misc", "AllVips", 0, v2) != 0;
  *(_BYTE *)(this + 483) = v4("Misc", "AllowPrerelease", 1, v2) != 0;
  *(_DWORD *)(this + 428) = v4("Comms", "FlushTime", 0, v2);
  *(_DWORD *)(this + 432) = 1000 * v4("Comms", "BandwithIdleTime", 0, v2);
  *(_DWORD *)(this + 436) = v4("Comms", "SelectTime", 0, v2);
  *(_DWORD *)(this + 444) = v4("Comms", "SyncJitter", 0, v2);
  *(_DWORD *)(this + 456) = v4("Routing", "PosSendRadar", 100, v2);
  *(_DWORD *)(this + 452) = v4("Routing", "PosSendEdge", 30, v2);
  *(_DWORD *)(this + 448) = v4("Routing", "PosSendClose", 20, v2);
  *(_DWORD *)(this + 460) = v4("Routing", "ClosePosPixels", 250, v2);
  *(_DWORD *)(this + 464) = v4("Routing", "QueuePositions", 0, v2);
  GetPrivateProfileStringA_0("Billing", "IP", LevelFiles, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 412) = inet_addr_0(tmp_str);
  GetPrivateProfileStringA_0("Misc", "ServerIP", LevelFiles, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 416) = inet_addr_0(tmp_str);
  GetPrivateProfileStringA_0("Misc", "BindIP", LevelFiles, tmp_str, 0x3Fu, v2);
  v5 = inet_addr_0(tmp_str);
  *(_DWORD *)(this + 420) = v5;
  if ( v5 == -1 )
    *(_DWORD *)(this + 420) = 0;
  GetPrivateProfileStringA_0("Misc", "BotsIP", LevelFiles, tmp_str, 0x3Fu, v2);
  *(_DWORD *)(this + 424) = inet_addr_0(tmp_str);
  v6 = v4("Misc", "PositionDataAccess", 0, v2);
  if ( v6 == 2 )
    v51 = 639;
  else
    v51 = v6 != 1 ? 631 : 635;
  v7 = FIX_DLL_KERNEL32_dll_GetCurrentProcessId();
  v58 = (_DWORD *)FIX_DLL_KERNEL32_dll_OpenProcess(2035711, 0, v7);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v58, 4305937, this + 420, 4, 0);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v58, 4240126, &v51, 4, 0);
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v58, 4256527, &v51, 4, 0);
  v8 = &unk_10024A24;
  if ( !*(_BYTE *)(this + 479) )
    v8 = &unk_10024A20;
  FIX_DLL_KERNEL32_dll_WriteProcessMemory(v58, &loc_403507, v8, 2, 0);
  FIX_DLL_KERNEL32_dll_CloseHandle(v58);
  v58 = &unk_1002197C;
  do
  {
    v9 = (const CHAR *)*(v58 - 1);
    ReturnedString[0] = 0;
    GetPrivateProfileStringA_0("Validation", v9, LevelFiles, ReturnedString, 0x3FFu, v2);
    for ( i = 0; sub_10002E30(v47, 64, ReturnedString, 44, i); ++i )
    {
      v10 = atol_1(v47);
      if ( v10 > 2 )
        v10 = 2;
      v52 = (char *)(2 - v10);
      v60 = 1;
      v61 = 1;
      v11 = sub_10003240(v47);
      v12 = *v11;
      v13 = *v11 == 35;
      v54 = v11;
      if ( v13 )
      {
        v54 = ++v11;
        v61 = 0;
      }
      else if ( v12 == 47 )
      {
        v54 = ++v11;
        v60 = 0;
      }
      if ( *v11 == 42 )
      {
        v14 = this + 12 * *v58;
        v15 = *(_DWORD *)(v14 + 280);
        a2 = 0;
        k = v14;
        if ( v15 <= 0 )
        {
LABEL_25:
          v18 = *(_DWORD *)(this + 12 * *v58 + 280);
          v19 = *(_DWORD *)(this + 12 * *v58 + 276);
          v20 = (int *)(this + 12 * *v58 + 272);
          v56 = v20;
          k = v18;
          if ( v18 >= v19 )
          {
            sub_10002D10(v20, 2 * (v18 + 2 * (9 * v18 + 288) + 32));
            v56[1] += 32;
            v18 = k;
            v20 = v56;
          }
          k = 38 * v18;
          v21 = *v20;
          v22 = v20[2];
          v53 = v21;
          memcpy_0(
            (void *)(v21 + 2 * (v18 + 2 * (9 * v18 + 9) + 1)),
            (const void *)(v21 + 38 * v18),
            38 * v22 - 38 * v18);
          v23 = v56;
          ++v56[2];
          v43 = 0;
          LOWORD(v44[0]) = 0;
          memcpy_0((void *)(*v23 + k), &v43, 0x26u);
          v53 = *v56 + k;
          strncpyt((void *)(v53 + 6), v54, 32);
          v17 = v53;
        }
        else
        {
          v56 = 0;
          while ( _memicmp_0(
                    (char *)v56 + *(_DWORD *)(v14 + 272) + 6,
                    v54,
                    strlen((const char *)v56 + *(_DWORD *)(v14 + 272) + 6)) )
          {
            v16 = *(_DWORD *)(k + 280);
            ++a2;
            v56 = (int *)((char *)v56 + 38);
            if ( a2 >= v16 )
              goto LABEL_24;
            v14 = k;
          }
          v17 = *(_DWORD *)(k + 272) + 38 * a2;
          if ( !v17 )
          {
LABEL_24:
            v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
            goto LABEL_25;
          }
          v4 = (int (__cdecl *)(const char *, const char *, int, const CHAR *))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
        }
        for ( j = (int)v52; j >= 0; --j )
        {
          if ( v60 )
            *(_BYTE *)(v17 + j) |= 1u;
          if ( v61 )
            *(_BYTE *)(v17 + j + 3) |= 1u;
        }
      }
    }
    v58 += 2;
  }
  while ( v58 < dword_1002199C );
  v25 = v4("Misc", "LocalChatPrefix", 0, v2);
  v26 = v25;
  if ( v25 )
  {
    sprintf_0((char *)(this + 332), "$$%08x$", v25);
    sprintf_0((char *)(this + 364), "$$%08x$", v26 + 1);
  }
  sub_10002D60(*(void **)(this + 320));
  *(_DWORD *)(this + 320) = 0;
  *(_DWORD *)(this + 328) = 0;
  *(_DWORD *)(this + 324) = 0;
  for ( k = 0; k < 2; ++k )
  {
    v61 = k == 1;
    v27 = "StaffChat";
    if ( k != 1 )
      v27 = "LocalChat";
    GetPrivateProfileStringA_0("Misc", v27, LevelFiles, src, 0x3FFu, v2);
    v28 = src;
    if ( src[0] )
    {
      do
      {
        v29 = strchr_0(v28, 44);
        v52 = v29;
        if ( v29 )
          *v29 = 0;
        v49 = v61;
        strncpyt(dst, v28, 32);
        v31 = *(_DWORD *)(this + 324);
        v32 = (_DWORD *)(this + 320);
        i = *(_DWORD *)(this + 328);
        v30 = i;
        if ( i >= v31 )
        {
          sub_10002D10((int *)(this + 320), 33 * (i + 32));
          *(_DWORD *)(this + 324) += 32;
        }
        v33 = i + 32 * v30;
        memcpy_0((void *)(32 * (i + 1) + *v32 + i + 1), (const void *)(*v32 + v33), 33 * *(_DWORD *)(this + 328) - v33);
        ++*(_DWORD *)(this + 328);
        memcpy_0((void *)(*v32 + v33), v44, 0x21u);
        v34 = (int)v52;
        v35 = (_BYTE *)(*v32 + v33);
        qmemcpy(v35, dst, 0x20u);
        v35[32] = v49;
        if ( !v34 )
          break;
        v28 = (char *)(v34 + 1);
      }
      while ( *(_BYTE *)(v34 + 1) );
      v2 = v50;
    }
  }
  v36 = *(void **)(this + 484);
  v37 = (int *)(this + 484);
  sub_10002D60(v36);
  *v37 = 0;
  v37[2] = 0;
  v37[1] = 0;
  GetPrivateProfileStringA_0("Misc", "AlertCommand", LevelFiles, src, 0x3FFu, v2);
  for ( i = 0; sub_10002E30(v45, 32, src, 44, i); ++i )
  {
    if ( v45[0] )
    {
      v38 = v37[2];
      if ( v38 >= v37[1] )
      {
        sub_10002D10(v37, 32 * (v38 + 32));
        v37[1] += 32;
      }
      memcpy_0((void *)(*v37 + 32 * (v38 + 1)), (const void *)(*v37 + 32 * v38), 32 * (v37[2] + 0x7FFFFFF * v38));
      ++v37[2];
      memcpy_0((void *)(*v37 + 32 * v38), &dst[1], 0x20u);
      qmemcpy((void *)(*v37 + 32 * v38), v45, 0x20u);
    }
  }
  byte_101B3054 = 0;
  result = sub_100028D0("sid.dat");
  if ( result == 128 )
  {
    v63 = 1;
    a2 = -1;
    ReadScrty1File(&a2, "sid.dat", 1, 3);
    ReadScrty1FileOffset(&a2, (int)&unk_10029270, 128);
    byte_101B3054 = 1;
    result = sub_10001A50(&a2);
  }
  return result;
}
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
// 100210C0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteProcessMemory)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210C4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_OpenProcess)(_DWORD, _DWORD, _DWORD);
// 100210C8: using guessed type int (*FIX_DLL_KERNEL32_dll_GetCurrentProcessId)(void);
// 101B3054: using guessed type char byte_101B3054;

//----- (1000CF20) --------------------------------------------------------
int __thiscall sub_1000CF20(char *this, void *a2, unsigned __int8 a3, _DWORD *a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ebp
  char *v7; // esi
  int v8; // ecx
  int v9; // ebp
  int *v10; // esi
  int i; // ebx
  int result; // eax
  int v13; // ecx
  int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  char v17; // [esp+28h] [ebp+Ch]

  v4 = 0;
  if ( *(_DWORD *)((char *)a4 + 631) )
    v15 = 2;
  else
    v15 = *(_DWORD *)((char *)a4 + 635) != 0;
  v5 = a4[7];
  if ( !v5 || (v17 = 1, !*(_BYTE *)(v5 + 64256)) )
    v17 = 0;
  v6 = 0;
  v14 = 0;
  v7 = &this[12 * (v17 != 0) + 24];
  if ( *((int *)v7 + 70) > 0 )
  {
    while ( _memicmp_0(
              (const void *)(*((_DWORD *)v7 + 68) + v4 + 6),
              a2,
              strlen((const char *)(*((_DWORD *)v7 + 68) + v4 + 6))) )
    {
      ++v6;
      v4 += 38;
      if ( v6 >= *((_DWORD *)v7 + 70) )
        goto LABEL_14;
    }
    v8 = *((_DWORD *)v7 + 68) + 38 * v6;
    if ( v8 && *(_BYTE *)(v8 + 2 * a3 + a3 + v15) )
      v14 = 1;
  }
LABEL_14:
  v9 = 0;
  v10 = (int *)&this[12 * (v17 != 0)];
  if ( v10[70] <= 0 )
    return v14;
  for ( i = 0; _memicmp_0((const void *)(i + v10[68] + 6), a2, strlen((const char *)(i + v10[68] + 6))); i += 38 )
  {
    if ( ++v9 >= v10[70] )
      return v14;
  }
  v13 = v10[68] + 38 * v9;
  if ( !v13 )
    return v14;
  result = v14;
  if ( *(_BYTE *)(v13 + 2 * a3 + a3 + v15) )
    result = v14 | 2;
  return result;
}

//----- (1000D0B0) --------------------------------------------------------
char *__thiscall sub_1000D0B0(char *this, int a2)
{
  _BYTE *v3; // esi
  _BYTE *v5; // [esp+0h] [ebp-8h]

  v3 = this + 4;
  this[4] = 0;
  *(_DWORD *)this = &off_10021A6C;
  if ( !((int (__cdecl *)(_DWORD, char *, int))FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(0, this + 4, 260) )
    *v3 = 0;
  sub_10002B80(v3);
  sub_10002A10(v3, (int)v3, v5);
  *((_DWORD *)this + 66) = -1;
  *((_DWORD *)this + 67) = FIX_DLL_KERNEL32_dll_GetTickCount() - 15000;
  return this;
}
// 1000D0E3: variable 'v5' is possibly undefined
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;

//----- (1000D110) --------------------------------------------------------
int __thiscall sub_1000D110(char *this)
{
  int result; // eax

  result = FIX_DLL_KERNEL32_dll_GetTickCount();
  if ( result - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = result;
    result = sub_10002830(this + 4);
    if ( result != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = result;
      off_10024608("Ext: Re-reading %s\n", this + 4);
      result = (**(int (__thiscall ***)(char *))this)(this);
    }
  }
  return result;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000D170) --------------------------------------------------------
int __thiscall sub_1000D170(_DWORD *this)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edi
  int v4; // esi
  int v5; // eax
  _DWORD *v6; // eax
  _BYTE *v7; // eax
  char *v8; // eax
  _BYTE *v9; // eax
  int i; // edi
  int v11; // esi
  int v12; // ecx
  int v13; // ebx
  int v14; // eax
  int *v15; // esi
  int v16; // edi
  int v17; // ebx
  _DWORD *v18; // edi
  int j; // eax
  int k; // eax
  int v22; // [esp-Ch] [ebp-11Ch] BYREF
  int v23[4]; // [esp+0h] [ebp-110h] BYREF
  char v24; // [esp+10h] [ebp-100h] BYREF
  char v25[127]; // [esp+11h] [ebp-FFh] BYREF
  char v26[32]; // [esp+90h] [ebp-80h] BYREF
  void *v27; // [esp+B0h] [ebp-60h]
  int v28; // [esp+B4h] [ebp-5Ch]
  int v29; // [esp+B8h] [ebp-58h]
  char dst[32]; // [esp+BCh] [ebp-54h] BYREF
  void *v31; // [esp+DCh] [ebp-34h]
  int v32; // [esp+E0h] [ebp-30h]
  int v33; // [esp+E4h] [ebp-2Ch]
  int v34[4]; // [esp+E8h] [ebp-28h] BYREF
  _DWORD *v35; // [esp+F8h] [ebp-18h]
  int a2[2]; // [esp+FCh] [ebp-14h] BYREF
  int v37; // [esp+10Ch] [ebp-4h]

  v1 = (int)this;
  v2 = this[70];
  v3 = 0;
  a2[1] = (int)&v22;
  v35 = this;
  if ( v2 > 0 )
  {
    v4 = 0;
    do
    {
      sub_10015680(*(_DWORD *)(v1 + 272) + v4 + 32);
      ++v3;
      v4 += 44;
    }
    while ( v3 < *(_DWORD *)(v1 + 280) );
  }
  sub_10002D60(*(void **)(v1 + 272));
  *(_DWORD *)(v1 + 272) = 0;
  *(_DWORD *)(v1 + 280) = 0;
  *(_DWORD *)(v1 + 276) = 0;
  v37 = 1;
  a2[0] = -1;
  ReadScrty1File(a2, (char *)(v1 + 4), 3, 3);
  while ( sub_100024F0(a2, &v24, 128) )
  {
    v29 = 0;
    v28 = 0;
    v27 = 0;
    LOBYTE(v37) = 2;
    if ( (isalpha_0(v24) || (sub_100172AC(), v5)) && strlen(&v24) < 0x20 )
    {
      strcpy(v26, &v24);
      sub_10003280(v26);
      v6 = (_DWORD *)sub_100157A0(v1 + 272, *(_DWORD *)(v1 + 280));
      sub_100156A0(v6, (int)v26);
    }
    else if ( v24 == 43 )
    {
      v33 = 0;
      v32 = 0;
      v31 = 0;
      LOBYTE(v37) = 3;
      v7 = sub_10003260(v25);
      strncpyt(dst, v7, 32);
      sub_10003220(dst, 58, 0);
      if ( strchr_0(&v24, 58) )
      {
        v8 = strchr_0(&v24, 58);
        v9 = sub_10003260(v8 + 1);
        strncpyt(v34, v9, 16);
        sub_10003280((char *)v34);
        for ( i = 0; i < *(_DWORD *)(v1 + 280); ++i )
        {
          v11 = 44 * i;
          if ( !unknown_libname_69(*(_DWORD *)(v1 + 272) + 44 * i, dst) )
          {
            v12 = *(_DWORD *)(v1 + 272);
            v13 = *(_DWORD *)(v11 + v12 + 40);
            v14 = *(_DWORD *)(v11 + v12 + 36);
            v15 = (int *)(v11 + v12 + 32);
            if ( v13 >= v14 )
            {
              sub_10002D10(v15, 16 * (v13 + 32));
              v15[1] += 32;
            }
            v16 = 16 * v13;
            memcpy_0((void *)(*v15 + 16 * (v13 + 1)), (const void *)(*v15 + 16 * v13), 16 * (v15[2] + 0xFFFFFFF * v13));
            v17 = *v15;
            ++v15[2];
            memcpy_0((void *)(v17 + v16), v23, 0x10u);
            v1 = (int)v35;
            v18 = (_DWORD *)(*v15 + v16);
            *v18 = v34[0];
            v18[1] = v34[1];
            v18[2] = v34[2];
            v18[3] = v34[3];
            break;
          }
        }
      }
      LOBYTE(v37) = 2;
      for ( j = 0; j < v33; ++j )
        ;
      sub_10002D60(v31);
      v31 = 0;
      v33 = 0;
      v32 = 0;
    }
    LOBYTE(v37) = 1;
    for ( k = 0; k < v29; ++k )
      ;
    sub_10002D60(v27);
    v27 = 0;
    v29 = 0;
    v28 = 0;
  }
  return sub_10001A50(a2);
}
// 1000D253: variable 'v5' is possibly undefined
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);

//----- (1000D470) --------------------------------------------------------
int __thiscall sub_1000D470(int this)
{
  int result; // eax

  sub_10002D60(*(void **)(this + 32));
  result = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 36) = 0;
  return result;
}

//----- (1000D490) --------------------------------------------------------
char __thiscall sub_1000D490(char *this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // edi
  int v6; // ebx
  int v8; // ecx
  int v9; // eax
  int v10; // ebx
  int i; // esi

  v3 = FIX_DLL_KERNEL32_dll_GetTickCount();
  if ( v3 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v3;
    v4 = sub_10002830(this + 4);
    if ( v4 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v4;
      off_10024608("Ext: Re-reading %s\n", this + 4);
      (**(void (__thiscall ***)(char *))this)(this);
    }
  }
  v5 = *((_DWORD *)this + 68);
  v6 = 0;
  if ( *((int *)this + 70) > 0 )
  {
    while ( unknown_libname_69(v5, a2 + 375) )
    {
      ++v6;
      v5 += 44;
      if ( v6 >= *((_DWORD *)this + 70) )
        return 0;
    }
    v8 = *(_DWORD *)(v5 + 40);
    if ( !v8 )
      return 1;
    v9 = *(_DWORD *)(a2 + 28);
    if ( v9 )
    {
      v10 = 0;
      if ( v8 > 0 )
      {
        for ( i = 0; unknown_libname_69(v9 + 64256, *(_DWORD *)(v5 + 32) + i); i += 16 )
        {
          v9 = *(_DWORD *)(a2 + 28);
          if ( *(_BYTE *)(v9 + 64256) )
          {
            if ( *(_BYTE *)(i + *(_DWORD *)(v5 + 32)) == 64 )
              break;
          }
          if ( ++v10 >= *(_DWORD *)(v5 + 40) )
            return 0;
        }
        return 1;
      }
    }
  }
  return 0;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000D590) --------------------------------------------------------
char __thiscall sub_1000D590(char *this, int a2)
{
  int v3; // eax
  int v4; // eax
  const char *v5; // ebp
  int v6; // ebx

  v3 = FIX_DLL_KERNEL32_dll_GetTickCount();
  if ( v3 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v3;
    v4 = sub_10002830(this + 4);
    if ( v4 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v4;
      off_10024608("Ext: Re-reading %s\n", this + 4);
      (**(void (__thiscall ***)(void *))this)(this);
    }
  }
  v5 = (const char *)*((_DWORD *)this + 68);
  v6 = 0;
  if ( *((int *)this + 70) <= 0 )
    return 0;
  while ( unknown_libname_69(v5, a2) && strcmp(v5, "*!") )
  {
    ++v6;
    v5 += 44;
    if ( v6 >= *((_DWORD *)this + 70) )
      return 0;
  }
  return 1;
}
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000D660) --------------------------------------------------------
int sub_1000D660()
{
  sub_1000D680(byte_101B0720, (int)"moderate.txt");
  return atexit((void (*)(void))sub_1000D770);
}

//----- (1000D680) --------------------------------------------------------
char *__thiscall sub_1000D680(char *this, int a2)
{
  _BYTE *v3; // edi
  int (*v4)(void); // ebp
  int v5; // eax
  int v6; // eax
  _BYTE *v8; // [esp+18h] [ebp-8h]

  v3 = this + 4;
  this[4] = 0;
  *(_DWORD *)this = &off_10021A6C;
  if ( !((int (__cdecl *)(_DWORD, char *, int))FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(0, this + 4, 260) )
    *v3 = 0;
  sub_10002B80(v3);
  sub_10002A10(v3, (int)v3, v8);
  v4 = FIX_DLL_KERNEL32_dll_GetTickCount;
  *((_DWORD *)this + 66) = -1;
  *((_DWORD *)this + 67) = v4() - 15000;
  *((_DWORD *)this + 70) = 0;
  *((_DWORD *)this + 69) = 0;
  *((_DWORD *)this + 68) = 0;
  *(_DWORD *)this = off_10021A70;
  v5 = v4();
  if ( v5 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v5;
    v6 = sub_10002830(v3);
    if ( v6 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v6;
      off_10024608("Ext: Re-reading %s\n", v3);
      (**(void (__thiscall ***)(void *))this)(this);
    }
  }
  return this;
}
// 1000D6CF: variable 'v8' is possibly undefined
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;
// 10021A70: using guessed type int (*off_10021A70[2])();
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000D770) --------------------------------------------------------
int sub_1000D770(void)
{
  int v0; // ebx
  int v1; // ebp
  int v2; // esi
  int result; // eax

  v0 = 0;
  if ( *(int *)&byte_101B0720[280] > 0 )
  {
    v1 = 0;
    do
    {
      v2 = *(_DWORD *)&byte_101B0720[272] + v1 + 32;
      sub_10002D60(*(void **)v2);
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 8) = 0;
      *(_DWORD *)(v2 + 4) = 0;
      ++v0;
      v1 += 44;
    }
    while ( v0 < *(_DWORD *)&byte_101B0720[280] );
  }
  result = sub_10002D60(*(void **)&byte_101B0720[272]);
  *(_DWORD *)&byte_101B0720[272] = 0;
  *(_DWORD *)&byte_101B0720[280] = 0;
  *(_DWORD *)&byte_101B0720[276] = 0;
  return result;
}

//----- (1000D7F0) --------------------------------------------------------
int sub_1000D7F0()
{
  sub_1000D680(byte_1003E318, (int)"smod.txt");
  return atexit(unknown_libname_57);
}

//----- (1000D820) --------------------------------------------------------
int sub_1000D820()
{
  sub_1000D680(byte_10065080, (int)"sysop.txt");
  return atexit(unknown_libname_58);
}

//----- (1000D850) --------------------------------------------------------
int sub_1000D850()
{
  sub_1000D680((char *)&dword_101A93E0, (int)"vip.txt");
  return atexit(unknown_libname_59);
}
// 101A93E0: using guessed type int dword_101A93E0;

//----- (1000D880) --------------------------------------------------------
int sub_1000D880()
{
  sub_1000D8A0((char *)&dword_101A51A8, (int)"server.ini");
  return atexit(sub_1000DA00);
}
// 101A51A8: using guessed type int dword_101A51A8;

//----- (1000D8A0) --------------------------------------------------------
char *__thiscall sub_1000D8A0(char *this, int a2)
{
  _BYTE *v3; // edi
  int (*v4)(void); // ebp
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  _BYTE *v9; // [esp+18h] [ebp-8h]

  v3 = this + 4;
  this[4] = 0;
  *(_DWORD *)this = &off_10021A6C;
  if ( !((int (__cdecl *)(_DWORD, char *, int))FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(0, this + 4, 260) )
    *v3 = 0;
  sub_10002B80(v3);
  sub_10002A10(v3, (int)v3, v9);
  v4 = FIX_DLL_KERNEL32_dll_GetTickCount;
  *((_DWORD *)this + 66) = -1;
  *((_DWORD *)this + 67) = v4() - 15000;
  `eh vector constructor iterator'(
    this + 272,
    0xCu,
    4,
    (void (__thiscall *)(void *))sub_10015610,
    (void (__thiscall *)(void *))sub_10015620);
  *((_DWORD *)this + 82) = 0;
  *((_DWORD *)this + 81) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_DWORD *)this + 110) = 305419896;
  *((_DWORD *)this + 123) = 0;
  *((_DWORD *)this + 122) = 0;
  *((_DWORD *)this + 121) = 0;
  *(_DWORD *)this = &off_10021A74;
  v5 = v4();
  sprintf_0(this + 332, "$$%08x$", v5);
  sprintf_0(this + 364, "$$%08x$", v5 + 1);
  v6 = v4();
  if ( v6 - *((_DWORD *)this + 67) >= 15000 )
  {
    *((_DWORD *)this + 67) = v6;
    v7 = sub_10002830(v3);
    if ( v7 != *((_DWORD *)this + 66) )
    {
      *((_DWORD *)this + 66) = v7;
      off_10024608("Ext: Re-reading %s\n", v3);
      (**(void (__thiscall ***)(void *))this)(this);
    }
  }
  return this;
}
// 1000D8EF: variable 'v9' is possibly undefined
// 100170B8: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021A6C: using guessed type void *off_10021A6C;
// 10021A74: using guessed type int (*off_10021A74)();
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (1000DA00) --------------------------------------------------------
void sub_1000DA00(void)
{
  sub_10002D60((void *)*(&dword_101A51A8 + 121));
  *(&dword_101A51A8 + 121) = 0;
  *(&dword_101A51A8 + 123) = 0;
  *(&dword_101A51A8 + 122) = 0;
  sub_10002D60((void *)*(&dword_101A51A8 + 80));
  *(&dword_101A51A8 + 80) = 0;
  *(&dword_101A51A8 + 82) = 0;
  *(&dword_101A51A8 + 81) = 0;
  `eh vector destructor iterator'(&dword_101A51A8 + 68, 0xCu, 4, (void (__thiscall *)(void *))sub_10015620);
}
// 1001713A: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, _DWORD, void (__thiscall *)(void *));
// 101A51A8: using guessed type int dword_101A51A8;

//----- (1000DAB0) --------------------------------------------------------
int __thiscall sub_1000DAB0(int this)
{
  int v1; // ebp
  __int16 *v2; // esi
  char *v3; // edx
  char **v4; // eax
  int v5; // ebp
  int result; // eax
  int v7; // [esp+10h] [ebp-8h]

  v1 = -46 - this;
  v2 = (__int16 *)(this + 46);
  v7 = 8;
  while ( 1 )
  {
    *v2 = 5 * *v2 / 2;
    v2[1] *= 3;
    v2[2] *= 16;
    v2[4] = *(v2 - 1);
    v2[5] = *v2;
    v2[6] = v2[1];
    v2[7] = v2[2];
    v2[8] = v2[3];
    v2[19] = 10;
    v2[20] = 10;
    v2[21] = 10;
    v2[22] = 10;
    v2[25] = 100;
    v2[26] = 999;
    v3 = (char *)v2 + v1;
    v4 = (char **)&unk_1002461C;
    do
    {
      v5 = (int)*v4++;
      *(_WORD *)&v3[this + 18 + v5] = 0;
    }
    while ( v4 < off_10024650 );
    *((_BYTE *)v2 + 66) = 0x80;
    *((_BYTE *)v2 + 67) = 117;
    *((_BYTE *)v2 + 68) = 0x80;
    *((_BYTE *)v2 + 69) = 0x80;
    *((_BYTE *)v2 + 70) = 0x80;
    *((_BYTE *)v2 + 71) = 0x80;
    *((_BYTE *)v2 + 72) = 0x80;
    *((_BYTE *)v2 + 73) = 0x80;
    *(_DWORD *)(v2 + 41) = *(_DWORD *)(v2 + 41) & 0xFFFFFE1F | 2;
    v2 += 72;
    if ( !--v7 )
      break;
    v1 = -46 - this;
  }
  result = 0;
  *(_BYTE *)(this + 1373) = 0x80;
  *(_BYTE *)(this + 1375) = 0x80;
  *(_DWORD *)(this + 1156) = 0;
  *(_DWORD *)(this + 1200) = 0;
  *(_DWORD *)(this + 1196) = 0;
  *(_DWORD *)(this + 1160) = 0;
  *(_WORD *)(this + 1266) = 0;
  return result;
}
// 10024650: using guessed type char *off_10024650[12];

//----- (1000DBE0) --------------------------------------------------------
char __fastcall sub_1000DBE0(PLAYER *a1, const char *a2)
{
  int v5; // eax
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax

  if ( !a1 )
    return 0;
  if ( a1->bIsSysop || a1->bIsSmod || a1->bIsModerator )
  {
    v5 = FIX_DLL_KERNEL32_dll_GetTickCount();
    if ( v5 - dword_101A52B4 >= 15000 )
    {
      dword_101A52B4 = v5;
      v6 = sub_10002830(ap);
      if ( v6 != dword_101A52B0 )
      {
        dword_101A52B0 = v6;
        off_10024608("Ext: Re-reading %s\n", ap);
        (*(void (__thiscall **)(int *))dword_101A51A8)(&dword_101A51A8);
      }
    }
    if ( a1->bIsSysop )
    {
      if ( byte_101A537E && !sub_1000D490(byte_10065080, (int)a1) && dword_10065198 )
      {
        v7 = sub_1000C1B0(a1, 1);
        off_10024608("Ext: Not authorized sysop %s (%s) - %.150s\n", a1->player_name, v7, a2);
        return 0;
      }
    }
    else if ( a1->bIsSmod )
    {
      if ( byte_101A537D && !sub_1000D490(byte_10065080, (int)a1) && !sub_1000D490(byte_1003E318, (int)a1) )
      {
        v8 = sub_1000C1B0(a1, 1);
        off_10024608("Ext: Not authorized smod %s (%s) - %.150s\n", a1->player_name, v8, a2);
        return 0;
      }
    }
    else if ( a1->bIsModerator
           && byte_101A537C
           && !sub_1000D490(byte_10065080, (int)a1)
           && !sub_1000D490(byte_1003E318, (int)a1)
           && !sub_1000D490(byte_101B0720, (int)a1) )
    {
      v9 = sub_1000C1B0(a1, 1);
      off_10024608("Ext: Not authorized mod %s (%s) - %.150s\n", a1->player_name, v9, a2);
      return 0;
    }
  }
  return 1;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 10065198: using guessed type int dword_10065198;
// 101A51A8: using guessed type int dword_101A51A8;
// 101A52B0: using guessed type int dword_101A52B0;
// 101A52B4: using guessed type int dword_101A52B4;
// 101A537C: using guessed type char byte_101A537C;
// 101A537D: using guessed type char byte_101A537D;
// 101A537E: using guessed type char byte_101A537E;

//----- (1000DD90) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __stdcall fix_export_0(char *player, int *requester, s2c_sendto *buf, PLAYER *buf_sz)
{
  char *v4; // edi
  int *v5; // ebx
  unsigned int v6; // edx
  int v7; // eax
  char *v8; // ebx
  int *v9; // esi
  int v10; // eax
  char v11; // cl
  char *v12; // ebx
  int v13; // eax
  _BOOL1 v14; // cc
  int result; // eax
  s2c_sendto *v16; // esi
  int v17; // ebx
  const char *v18; // esi
  const char *v19; // edi
  int *v20; // ebx
  char *v21; // eax
  int v22; // esi
  int *v23; // ebx
  int v24; // edx
  int v25; // eax
  char v26; // al
  char *v27; // esi
  char *v28; // ebx
  char *v29; // eax
  char *v30; // eax
  int v31; // edi
  int v32; // eax
  int v33; // esi
  _BOOL1 v34; // zf
  char v35; // cl
  const char *v36; // edi
  char *v37; // eax
  s2c_sendto *v38; // esi
  char v39; // al
  int *v40; // edx
  int v41; // eax
  char *v42; // eax
  unsigned int v43; // kr08_4
  int *v44; // eax
  int v45; // ecx
  PLAYER *v46; // esi
  PLAYER *v47; // ebx
  char v48; // al
  char *v49; // eax
  char *v50; // ecx
  char *v51; // eax
  char *v52; // eax
  s2c_sendto *v53; // esi
  char *v54; // eax
  char *v55; // edi
  const void *v56; // edi
  PLAYER *v57; // ebx
  const char *v58; // esi
  int v59; // edi
  const char *v60; // eax
  const char *v61; // eax
  __int32 v62; // eax
  int v63; // ecx
  __int32 v64; // eax
  int v65; // eax
  PLAYER *v66; // eax
  _BYTE *v67; // edi
  const char *v68; // eax
  int v69; // eax
  int v70; // esi
  int v71; // edi
  int v72; // ebx
  int v73; // edx
  __int16 v74; // ax
  int v75; // eax
  int v76; // eax
  int v77; // eax
  int v78; // ecx
  int v79; // eax
  int v80; // eax
  int v81; // ecx
  int v82; // ecx
  int v83; // eax
  int v84; // esi
  char *v85; // edi
  const char *v86; // edi
  u_long v87; // esi
  __int32 v88; // ebx
  char *v89; // eax
  unsigned int v90; // ebx
  int v91; // edi
  int *v92; // esi
  __int32 v93; // eax
  int v94; // ecx
  int *i; // edx
  const char *v96; // eax
  __int32 v97; // eax
  __int16 v98; // ax
  PLAYER *v99; // edi
  PLAYER *v100; // eax
  __int16 v101; // ax
  PLAYER *v102; // ecx
  unsigned int v103; // ebx
  const char *v104; // esi
  char v105; // al
  _WORD *v106; // edi
  char *v107; // eax
  PLAYER *v108; // edx
  PLAYER **v109; // ebx
  PLAYER *v110; // esi
  const char *v111; // edi
  char *v112; // eax
  char *v113; // esi
  _BYTE *v114; // eax
  int v115; // eax
  int v116; // ecx
  int v117; // ebx
  PLAYER *v118; // esi
  int v119; // eax
  int v120; // edx
  char *v121; // esi
  unsigned int v122; // eax
  int *v123; // ebx
  int v124; // edx
  int v125; // eax
  int v126; // ebx
  unsigned int v127; // esi
  unsigned int v128; // edx
  char *v129; // eax
  int v130; // ecx
  const char *v131; // eax
  int v132; // eax
  int v133; // ecx
  int v134; // esi
  int v135; // edx
  int v136; // ecx
  int v137; // eax
  int v138; // eax
  const char *v139; // eax
  int v140; // eax
  int v141; // eax
  int v142; // ecx
  int v143; // esi
  PLAYER **v144; // eax
  unsigned int v145; // eax
  int *v146; // ecx
  unsigned int v147; // eax
  int v148; // esi
  int *v149; // ecx
  char v150; // bl
  int v151; // edi
  int v152; // edi
  int v153; // ebx
  int v154; // edi
  char *v155; // edi
  int v156; // esi
  char *v157; // eax
  const char *v158; // eax
  int v159; // eax
  int v160; // esi
  int v161; // ebx
  int v162; // eax
  const char *v163; // [esp-10h] [ebp-94Ch]
  const char *v164; // [esp-Ch] [ebp-948h]
  unsigned int v165; // [esp-Ch] [ebp-948h]
  int v166; // [esp-8h] [ebp-944h]
  int v167; // [esp+Ch] [ebp-930h]
  int v168[355]; // [esp+24h] [ebp-918h] BYREF
  int v169; // [esp+5B8h] [ebp-384h] BYREF
  int v170; // [esp+5C4h] [ebp-378h] BYREF
  char v171[4]; // [esp+5C8h] [ebp-374h] BYREF
  char v172[4]; // [esp+5CEh] [ebp-36Eh] BYREF
  int v173; // [esp+687h] [ebp-2B5h] BYREF
  int v174; // [esp+6B9h] [ebp-283h] BYREF
  char v175[5]; // [esp+6CCh] [ebp-270h] BYREF
  int dst[28]; // [esp+6D1h] [ebp-26Bh] BYREF
  char v177[4]; // [esp+74Ch] [ebp-1F0h] BYREF
  char v178[4]; // [esp+78Ch] [ebp-1B0h] BYREF
  s2c_sendto s2c_sendto_pkt; // [esp+7ACh] [ebp-190h] BYREF
  char src[248]; // [esp+7CCh] [ebp-170h] BYREF
  int v181; // [esp+8CCh] [ebp-70h]
  int v182; // [esp+8D0h] [ebp-6Ch]
  int v183; // [esp+8D4h] [ebp-68h]
  int v184; // [esp+8D8h] [ebp-64h]
  int v185; // [esp+8DCh] [ebp-60h]
  int v186; // [esp+8E0h] [ebp-5Ch]
  int v187; // [esp+8E4h] [ebp-58h]
  int v188; // [esp+8E8h] [ebp-54h]
  int v189; // [esp+8ECh] [ebp-50h]
  int v190; // [esp+8F0h] [ebp-4Ch]
  int v191; // [esp+8F4h] [ebp-48h]
  int v192; // [esp+8F8h] [ebp-44h]
  int v193; // [esp+8FCh] [ebp-40h]
  int v194; // [esp+900h] [ebp-3Ch]
  int v195; // [esp+904h] [ebp-38h]
  int v196; // [esp+908h] [ebp-34h]
  int v197; // [esp+90Ch] [ebp-30h]
  int v198; // [esp+910h] [ebp-2Ch]
  int v199; // [esp+914h] [ebp-28h]
  int v200; // [esp+918h] [ebp-24h]
  __int128 v201; // [esp+91Ch] [ebp-20h] BYREF
  int *v202; // [esp+92Ch] [ebp-10h]
  _BYTE v203[5]; // [esp+930h] [ebp-Ch] BYREF
  PLAYER *v204; // [esp+938h] [ebp-4h]
  char *playera; // [esp+944h] [ebp+8h]
  char *playerb; // [esp+944h] [ebp+8h]
  char *playerc; // [esp+944h] [ebp+8h]
  char *playerd; // [esp+944h] [ebp+8h]
  char *playere; // [esp+944h] [ebp+8h]
  char *playerf; // [esp+944h] [ebp+8h]
  char *playerg; // [esp+944h] [ebp+8h]
  char player_3; // [esp+947h] [ebp+Bh]

  v4 = sub_10003260(player);
  playera = v4;
  if ( *v4 != 63 )
  {
    if ( *v4 != 42 )
      return 1;
    if ( requester && !*(int *)((char *)requester + 639) )
    {
      v43 = FIX_DLL_KERNEL32_dll_GetTickCount();
      v44 = requester;
      if ( v43 / 0xA - *(int *)((char *)requester + 655) >= 0x96 )
      {
        *(int *)((char *)requester + 655) = v43 / 0xA;
        *(int *)((char *)v44 + 659) = 0;
      }
      else
      {
        v45 = *(int *)((char *)requester + 659) + 1;
        *(int *)((char *)requester + 659) = v45;
        if ( v45 > 7 )
        {
          *(int *)((char *)v44 + 789) = 33;
          v44[14] = 1;
          off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)v44 + 375);
          v204 = (PLAYER *)"WARNING: You have been disconnected for message flooding";
          SendArenaMessagePlayer((PLAYER *)requester, "WARNING: You have been disconnected for message flooding", 0);
        }
      }
    }
    goto LABEL_103;
  }
  v5 = requester;
  if ( requester && !*(int *)((char *)requester + 631) )
  {
    v6 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
    if ( v6 - *(int *)((char *)v5 + 655) >= 0x96 )
    {
      *(int *)((char *)v5 + 655) = v6;
      *(int *)((char *)v5 + 659) = 0;
    }
    else
    {
      v7 = *(int *)((char *)v5 + 659) + 1;
      *(int *)((char *)v5 + 659) = v7;
      if ( v7 > 7 )
      {
        *(int *)((char *)v5 + 789) = 33;
        v5[14] = 1;
        off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)v5 + 375);
        v204 = (PLAYER *)"WARNING: You have been disconnected for message flooding";
        SendArenaMessagePlayer((PLAYER *)requester, "WARNING: You have been disconnected for message flooding", 0);
      }
    }
  }
  if ( !unknown_libname_69(v4, "?arena") && v5 )
  {
    byte_101B083C = 47;
    playerb = 0;
    v8 = byte_101B083D;
    if ( ArenaArrayLength > 0 )
    {
      v9 = ArenaArray;
      buf = (s2c_sendto *)ArenaArray;
      do
      {
        v10 = *v9;
        if ( *v9 )
        {
          v11 = *(_BYTE *)(v10 + 64256);
          if ( v11 != 35 || *(int *)((char *)requester + 639) || v10 == requester[7] )
          {
            if ( v11 )
            {
              strcpy(v8, (const char *)(v10 + 64256));
              v9 = (int *)&buf->type;
            }
            else
            {
              sprintf_0(v8, "%d", playerb);
            }
            v12 = strchr_0(v8, 0) + 1;
            v13 = *v9;
            if ( *v9 == requester[7] )
              *(_WORD *)v12 = -*(_WORD *)(v13 + 65292);
            else
              *(_WORD *)v12 = *(_WORD *)(v13 + 65292);
            v8 = v12 + 2;
          }
        }
        ++v9;
        v14 = (int)++playerb < ArenaArrayLength;
        buf = (s2c_sendto *)v9;
      }
      while ( v14 );
    }
    buf = (s2c_sendto *)(v8
                       - &byte_101B083C
                       + sub_1000B6E0(
                           byte_1003E438,
                           v8,
                           *(int *)((char *)requester + offsetof(PLAYER, bIsModerator)) != 0));
    PlayerSendPacket((PLAYER *)requester, &byte_101B083C, (int)buf, 1);
    return 0;
  }
  v16 = buf;
  if ( (int)buf <= 2 )
    goto LABEL_29;
  if ( v5 )
  {
    if ( isalpha_0(v4[1]) )
    {
      SendMessage((struct PLAYER *)requester, "Send commands as public chat. Command ignored.", 0);
      return 0;
    }
LABEL_29:
    if ( v5 )
    {
      if ( v5[7] )
      {
        if ( v16 == (s2c_sendto *)2 )
        {
          v204 = 0;
          if ( dword_101A5394 > 0 )
          {
            v17 = 0;
            do
            {
              v18 = (const char *)(v17 + dword_101A538C);
              if ( !_memicmp_0(
                      v4 + 1,
                      (const void *)(v17 + dword_101A538C),
                      strlen((const char *)(v17 + dword_101A538C))) )
              {
                v19 = sub_10003260(&v4[strlen(v18) + 1]);
                if ( *v19 )
                {
                  v20 = requester;
                  v21 = sub_1000C1B0((PLAYER *)requester, 1);
                  sprintf_0(src, "%s: (%s) (%s): ", v18, (const char *)v20 + 375, v21);
                  sub_10003060(src, v19, 256);
                  v22 = 0;
                  if ( ZonePlayerCount > 0 )
                  {
                    v23 = ZonePlayers;
                    do
                    {
                      playerc = (char *)*v23;
                      if ( *v23 && *(_DWORD *)(*v23 + 639) )
                      {
                        v175[0] = 7;
                        v175[1] = 7;
                        v175[2] = 0;
                        *(_WORD *)&v175[3] = -1;
                        strncpyt(dst, src, 250);
                        buf_sz = (PLAYER *)(strlen((const char *)dst) + 6);
                        buf = (s2c_sendto *)v175;
                        PlayerSendPacket((PLAYER *)playerc, v175, (int)buf_sz, 1);
                      }
                      ++v22;
                      ++v23;
                    }
                    while ( v22 < ZonePlayerCount );
                  }
                  sub_1000B400(byte_1003E438, 3, src, 0);
                  SendMessage((struct PLAYER *)requester, "Message has been sent to online moderators", 0);
                  off_10024608("Ext: %.150s\n", src);
                }
                return 0;
              }
              v17 += 32;
              v204 = (PLAYER *)((char *)v204 + 1);
            }
            while ( (int)v204 < dword_101A5394 );
            v5 = requester;
          }
        }
      }
      if ( !_memicmp_0(v4, "?lag", 4u) )
      {
        sprintf_0(
          src,
          "PING Current:%d ms  Average:%d ms  Low:%d ms  High:%d ms  S2C: %d.%d%%  C2S: %d.%d%%",
          10 * *((__int16 *)requester + 165),
          10 * *((__int16 *)requester + 166),
          10 * *((__int16 *)requester + 167),
          10 * *((__int16 *)requester + 168),
          (1000 - *(int *)((char *)requester + 801)) / 10,
          (1000 - *(int *)((char *)requester + 801)) % 10,
          (1000 - *(int *)((char *)requester + 805)) / 10,
          (1000 - *(int *)((char *)requester + 805)) % 10);
        SendMessage((struct PLAYER *)requester, src, 0);
        return 0;
      }
      if ( !_memicmp_0(v4, "?obscene", 8u) )
      {
        v24 = *(int *)((char *)v5 + 627);
        *((_BYTE *)v5 + 1013) = 0;
        v204 = (PLAYER *)"Obscenity block ON";
        *(int *)((char *)v5 + 627) = v24 == 0;
        if ( v24 )
          v204 = (PLAYER *)"Obscenity block OFF";
        SendMessage((struct PLAYER *)requester, (const char *)v204, 0);
      }
      if ( !_memicmp_0(v4, "?getnews", 8u) )
      {
        if ( *(int *)((char *)v5 + 275) == 8 )
        {
          buf = (s2c_sendto *)"news.txt";
          sprintf_0(v175, "File sent: %s (please wait...)", "news.txt");
          SendMessage((struct PLAYER *)requester, v175, 0);
          SendFile(requester, &buf->type);
        }
        else
        {
          SendMessage((struct PLAYER *)requester, "Must be in spectator mode to get news", 0);
        }
        return 0;
      }
      v25 = v5[7];
      if ( v25
        && (byte_101A5382 && !*(_BYTE *)(v25 + 64256) || byte_101A5381 && *(_BYTE *)(v25 + 64256))
        && !_memicmp_0(v4, "?scorereset", 0xBu) )
      {
        SendResetScoresPacket((PLAYER *)requester);
        SendMessage((struct PLAYER *)requester, "Score reset", 0);
        return 0;
      }
      if ( !_memicmp_0(v4, "?chat", 5u) )
      {
        v26 = v4[5];
        if ( (v26 == 32 || v26 == 61) && BillingConnectionStructPointer && dword_101A52F0 )
        {
          memcpy_0(v171, v4, 6u);
          v27 = v4 + 6;
          v28 = v172;
          playerd = v4 + 6;
          if ( v4[6] )
          {
            do
            {
              if ( v28 >= (char *)&v173 )
                break;
              v29 = strchr_0(v27, 44);
              buf = (s2c_sendto *)v29;
              if ( v29 )
                *v29 = 0;
              strncpyt(&s2c_sendto_pkt, v27, 32);
              v30 = strrchr_0(&s2c_sendto_pkt.type, 47);
              if ( v30 )
                *v30 = 0;
              sub_10003280(&s2c_sendto_pkt.type);
              v31 = 0;
              if ( dword_101A52F0 > 0 )
              {
                v32 = dword_101A52E8;
                v33 = 0;
                while ( 1 )
                {
                  v34 = unknown_libname_69(v33 + v32, &s2c_sendto_pkt) == 0;
                  v32 = dword_101A52E8;
                  if ( v34 && (!*(_BYTE *)(v33 + dword_101A52E8 + 32) || *(int *)((char *)requester + 639)) )
                    break;
                  ++v31;
                  v33 += 33;
                  if ( v31 >= dword_101A52F0 )
                    goto LABEL_85;
                }
                v35 = *(_BYTE *)(v31 + 32 * v31 + dword_101A52E8 + 32);
                v36 = (const char *)&unk_101A5314;
                if ( !v35 )
                  v36 = (const char *)&unk_101A52F4;
                strcpy(v28, v36);
                v28 = strchr_0(v28, 0);
LABEL_85:
                v27 = playerd;
              }
              strncpyt(v28, v27, 32);
              v37 = strchr_0(v28, 0);
              v38 = buf;
              v28 = v37;
              if ( !buf )
                break;
              *v37 = 44;
              v39 = v38->ip_addr;
              ++v28;
              v27 = (char *)&v38->ip_addr;
              playerd = v27;
            }
            while ( v39 );
          }
          v40 = requester;
          *v28 = 0;
          v41 = v40[4];
          buf = (s2c_sendto *)v171;
          HIWORD(requester) = HIWORD(BillingConnectionStructPointer);
          biller_user_command(BillingConnectionStructPointer, v41, v171);
          return 0;
        }
      }
      if ( !_memicmp_0(v4, "?find", 5u) )
      {
        v42 = sub_10003260(v4 + 5);
        if ( find_player_request((PLAYER *)v5, v42) )
          return 0;
      }
    }
  }
  if ( _memicmp_0(v4, "?get", 4u) && _memicmp_0(v4, "?set", 4u) && _memicmp_0(v4, "?recycle", 8u) )
    return 1;
LABEL_103:
  v46 = 0;
  v204 = 0;
  if ( buf == (s2c_sendto *)5 && (int)buf_sz >= 0 )
  {
    v46 = *(&ZonePlayerList + (_DWORD)buf_sz);
    v204 = v46;
  }
  v47 = (PLAYER *)requester;
  if ( !sub_1000DBE0((PLAYER *)requester, v4) )
    return 0;
  v48 = sub_1000CF20((char *)&dword_101A51A8, v4, buf == (s2c_sendto *)5, v47);
  if ( (v48 & 2) != 0 )
  {
    v49 = sub_1000C1B0(v47, 1);
    off_10024608("Ext: Ignoring %s (%s): %.150s\n", v47->player_name, v49, v4);
    return 0;
  }
  if ( (v48 & 1) != 0 )
  {
    if ( v46 )
    {
      v50 = v46->player_name;
      v51 = " to ";
    }
    else
    {
      v50 = LevelFiles;
      v51 = LevelFiles;
    }
    v164 = v50;
    v163 = v51;
    v52 = sub_1000C1B0(v47, 1);
    off_10024608("Ext: %s (%s)%s%s: %.150s\n", v47->player_name, v52, v163, v164, v4);
  }
  if ( v46 && !v46->lpCurrentArena )
    return 0;
  if ( !v47->bIsModerator )
    return 1;
  if ( !v47->bIsSysop )
    goto cmd_locate;
  if ( !_memicmp_0(v4 + 4, "file ", 4u) && *v4 == 42 )
  {
    v53 = (s2c_sendto *)sub_10003260(v4 + 9);
    buf = v53;
    sub_10003280(&v53->type);
    if ( !v53->type
      || strchr_0(&v53->type, 92)
      || strchr_0(&v53->type, 47)
      || strchr_0(&v53->type, 58)
      || strchr_0(&v53->type, 42)
      || strchr_0(&v53->type, 63) )
    {
      SendMessage((struct PLAYER *)requester, "Invalid file name", 0);
      result = 0;
    }
    else
    {
      v54 = strrchr_0(&v53->type, 46);
      v55 = v54;
      if ( !v54
        || unknown_libname_69(v54, ".exe")
        && unknown_libname_69(v55, ".com")
        && unknown_libname_69(v55, ".bat")
        && unknown_libname_69(v55, ".cmd")
        && unknown_libname_69(v55, ".dll")
        && unknown_libname_69(v55, ".pif")
        && unknown_libname_69(v55, ".lnk") )
      {
        v56 = playera + 1;
        if ( _memicmp_0(playera + 1, "put", 3u) )
        {
          if ( _memicmp_0(v56, "get", 3u) )
          {
            if ( !_memicmp_0(v56, "del", 3u) && sub_10001F70(v53) )
            {
              sprintf_0(src, "File deleted: %s", &v53->type);
              SendMessage((struct PLAYER *)requester, src, 0);
            }
            result = 0;
          }
          else
          {
            sprintf_0(v171, "File sent: %s (please wait...)", &v53->type);
            SendMessage((struct PLAYER *)requester, v171, 0);
            SendFile(requester, &buf->type);
            result = 0;
          }
        }
        else
        {
          LOBYTE(v169) = 25;
          strncpyt(&v174, v53, 16);
          strncpyt((char *)&v169 + 1, v53, 256);
          PlayerSendPacket((PLAYER *)requester, &v169, 273, 1);
          result = 0;
        }
      }
      else
      {
        SendMessage((struct PLAYER *)requester, "Not allowed file type", 0);
        result = 0;
      }
    }
    return result;
  }
  v57 = v204;
  if ( !_memicmp_0(v4, "*einfo", 6u) && v204 )
  {
    v58 = "Continuum";
    if ( v204->dwClientVersion != 1 )
      v58 = (const char *)&off_100251F4;
    v59 = *(_DWORD *)&v204->field_44[32];
    v165 = (((int (__cdecl *)(_DWORD))FIX_DLL_KERNEL32_dll_GetTickCount)(*(_DWORD *)&v204[1].field_341[486])
          - *(_DWORD *)&v57->field_341[494])
         / 0x3E8u;
    v60 = sub_10010A70(v57);
    sprintf_0(
      src,
      "%s: UserId: %d  Res: %dx%d  Client: %s %d.%d  Proxy: %s  Idle: %d s  Timer drift: %d\n",
      v57->player_name,
      v57->dwUserID,
      v57->dwXRes,
      v57->dwYRes,
      v58,
      v59 / 100,
      v59 % 100,
      v60,
      v165,
      v166);
    buf = (s2c_sendto *)src;
    SendMessage((struct PLAYER *)requester, src, 0);
    v4 = playera;
  }
  if ( !_memicmp_0(v4, "*points", 7u) && v57 )
  {
    v61 = sub_10003260(v4 + 7);
    v62 = atol_1(v61);
    v63 = v57->score.points;
    v64 = v57->score.flag_points + v62;
    *(_WORD *)((char *)&v201 + 1) = v57->field_14;
    v57->score.points = 0;
    LOBYTE(v201) = 9;
    *(_DWORD *)((char *)&v201 + 3) = 0;
    HIBYTE(buf) = 1;
    v65 = v63 + v64 < 0 ? 0 : v63 + v64;
    LOWORD(v63) = v57->score.losses;
    v57->score.flag_points = v65;
    *(_DWORD *)((char *)&v201 + 7) = v65;
    *(_WORD *)((char *)&v201 + 11) = v57->score.wins;
    v66 = (PLAYER *)v57->lpCurrentArena;
    *(_WORD *)((char *)&v201 + 13) = v63;
    v202 = (int *)&v201;
    buf_sz = v66;
    ArenaSendPacket((struct ARENA *)v66, (char *)&v201, 15, HIBYTE(buf));
  }
  if ( !_memicmp_0(v4, "*bandwidth", 0xAu) && v57 )
  {
    v67 = v4 + 10;
    if ( *sub_10003260(v67) )
    {
      v68 = sub_10003260(v67);
      v69 = atol_1(v68);
      if ( v69 > 200 )
        *(_DWORD *)&v57->field_341[189] = v69;
    }
    sprintf_0(src, "BANDWIDTH: %d", *(_DWORD *)&v57->field_341[189]);
    buf = (s2c_sendto *)src;
    SendMessage((struct PLAYER *)requester, src, 0);
    v4 = playera;
  }
  if ( !_memicmp_0(v4, "*version", 8u) )
  {
    buf = (s2c_sendto *)"1.34.14b (Thu May  6 14:31:45 2004)";
    SendMessage((struct PLAYER *)requester, "1.34.14b (Thu May  6 14:31:45 2004)", 0);
  }
  if ( !_memicmp_0(v4, "*shutdown", 8u) && sub_100027F0("noshutdown") )
    return 0;
  if ( _memicmp_0(v4, "*lag", 4u) )
    goto LABEL_235;
  if ( v57 )
    goto LABEL_235;
  v70 = 0;
  v71 = 0x7FFFFFFF;
  *(_DWORD *)&s2c_sendto_pkt.arena_name[11] = -1;
  v190 = -1;
  v194 = -1;
  *(_QWORD *)((char *)&v201 + 4) = 0xFFFFFFFFi64;
  v198 = -1;
  v182 = -1;
  v186 = -1;
  v72 = 0x7FFFFFFF;
  *(_DWORD *)&s2c_sendto_pkt.arena_name[7] = 0x7FFFFFFF;
  *(_DWORD *)&s2c_sendto_pkt.arena_name[15] = 0;
  v189 = 0x7FFFFFFF;
  v191 = 0;
  v192 = 0;
  v193 = 0x7FFFFFFF;
  v195 = 0;
  v196 = 0;
  LODWORD(v201) = 0x7FFFFFFF;
  HIDWORD(v201) = 0;
  v197 = 0x7FFFFFFF;
  v199 = 0;
  v200 = 0;
  v181 = 0x7FFFFFFF;
  v183 = 0;
  v184 = 0;
  v185 = 0x7FFFFFFF;
  v187 = 0;
  v188 = 0;
  buf_sz = 0;
  if ( ZonePlayerCount <= 0 )
    goto LABEL_235;
  buf = (s2c_sendto *)ZonePlayers;
  do
  {
    v73 = *(_DWORD *)&buf->type;
    v74 = *(_WORD *)(*(_DWORD *)&buf->type + 330);
    if ( !v74 )
      goto LABEL_214;
    if ( v74 >= 0 && v74 <= 200 )
    {
      *(_DWORD *)&s2c_sendto_pkt.arena_name[15] += v74;
      ++v70;
      if ( v74 < *(int *)&s2c_sendto_pkt.arena_name[7] )
        *(_DWORD *)&s2c_sendto_pkt.arena_name[7] = v74;
      if ( v74 > *(int *)&s2c_sendto_pkt.arena_name[11] )
        *(_DWORD *)&s2c_sendto_pkt.arena_name[11] = v74;
    }
    v75 = *(__int16 *)(v73 + 332);
    if ( v75 >= 0 && v75 <= 200 )
    {
      ++HIDWORD(v201);
      DWORD2(v201) += v75;
      if ( v75 < (int)v201 )
        LODWORD(v201) = v75;
      if ( v75 > SDWORD1(v201) )
        DWORD1(v201) = v75;
    }
    v76 = *(__int16 *)(v73 + 334);
    if ( v76 >= 0 && v76 <= 200 )
    {
      ++v192;
      v191 += v76;
      if ( v76 < v189 )
        v189 = v76;
      if ( v76 > v190 )
        v190 = v76;
    }
    v77 = *(__int16 *)(v73 + 336);
    if ( v77 >= 0 && v77 <= 200 )
    {
      ++v196;
      v195 += v77;
      if ( v77 < v193 )
        v193 = v77;
      if ( v77 > v194 )
        v194 = v77;
    }
    v78 = *(_DWORD *)(v73 + 801);
    v79 = 1000 - v78;
    if ( 1000 - v78 >= 0 && v79 <= 1000 )
    {
      ++v200;
      v199 += v79;
      if ( v79 < v197 )
        v197 = 1000 - v78;
      if ( v79 > v198 )
        v198 = 1000 - v78;
    }
    v80 = 1000 - *(_DWORD *)(v73 + 805);
    if ( v80 >= 0 && v80 <= 1000 )
    {
      ++v184;
      v183 += v80;
      if ( v80 < v72 )
        v72 = v80;
      if ( v80 > v182 )
        v182 = v80;
    }
    v81 = *(_DWORD *)(v73 + 291);
    if ( v81 > 200 )
    {
      v82 = 1000 - 1000 * *(_DWORD *)(v73 + 295) / v81;
      if ( v82 < 0 || v82 > 1000 )
        goto LABEL_214;
    }
    else
    {
      v82 = 0;
    }
    ++v188;
    v187 += v82;
    if ( v82 < v71 )
      v71 = v82;
    if ( v82 > v186 )
      v186 = v82;
LABEL_214:
    v14 = (int)&buf_sz->hProcess + 1 < ZonePlayerCount;
    buf_sz = (PLAYER *)((char *)buf_sz + 1);
    buf = (s2c_sendto *)((char *)buf + 4);
  }
  while ( v14 );
  v185 = v71;
  v181 = v72;
  if ( v70 )
  {
    buf = (s2c_sendto *)"             Ave    Min    Max";
    SendMessage((struct PLAYER *)requester, "             Ave    Min    Max", 0);
    buf = (s2c_sendto *)(*(_DWORD *)&s2c_sendto_pkt.arena_name[15] / v70);
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "Cur ping",
      (double)((long double)(*(_DWORD *)&s2c_sendto_pkt.arena_name[15] / v70) * dbl_10021A80),
      (double)((long double)*(int *)&s2c_sendto_pkt.arena_name[7] * dbl_10021A80),
      (double)((long double)*(int *)&s2c_sendto_pkt.arena_name[11] * dbl_10021A80));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( HIDWORD(v201) )
      buf = (s2c_sendto *)(SDWORD2(v201) / SHIDWORD(v201));
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "Ave ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)(int)v201 * dbl_10021A80),
      (double)((long double)SDWORD1(v201) * dbl_10021A80));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( v192 )
      buf = (s2c_sendto *)(v191 / v192);
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "Min ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)v189 * dbl_10021A80),
      (double)((long double)v190 * dbl_10021A80));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( v196 )
      buf = (s2c_sendto *)(v195 / v196);
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "Max ping",
      (double)((long double)(int)buf * dbl_10021A80),
      (double)((long double)v193 * dbl_10021A80),
      (double)((long double)v194 * dbl_10021A80));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( v200 )
      buf = (s2c_sendto *)(v199 / v200);
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "S2C",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v197 * dbl_10021A78),
      (double)((long double)v198 * dbl_10021A78));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( v184 )
      buf = (s2c_sendto *)(v183 / v184);
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "C2S",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v181 * dbl_10021A78),
      (double)((long double)v182 * dbl_10021A78));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
    if ( v188 )
      buf = (s2c_sendto *)(v187 / v188);
    else
      buf = 0;
    sprintf_0(
      v177,
      "%10s: %6.1f %6.1f %6.1f",
      "S2CWeapons",
      (double)((long double)(int)buf * dbl_10021A78),
      (double)((long double)v185 * dbl_10021A78),
      (double)((long double)v186 * dbl_10021A78));
    buf = (s2c_sendto *)v177;
    SendMessage((struct PLAYER *)requester, v177, 0);
  }
LABEL_235:
  if ( !_memicmp_0(playera, "*rstat", 6u) )
  {
    v83 = FIX_DLL_KERNEL32_dll_GetTickCount();
    v84 = v83 - dword_10029300;
    if ( v83 == dword_10029300 )
      v84 = 1;
    sprintf_0(src, "Timer: %d", v84);
    buf = (s2c_sendto *)src;
    SendMessage((struct PLAYER *)requester, src, 0);
    sprintf_0(
      src,
      "Counts:  %5d %5d %5d %5d",
      1000 * dword_101B3040 / v84,
      1000 * dword_101B3044 / v84,
      1000 * dword_101B3048 / v84,
      1000 * dword_101B304C / v84);
    buf = (s2c_sendto *)src;
    SendMessage((struct PLAYER *)requester, src, 0);
    sprintf_0(
      src,
      "Trigger: %5d %5d %5d %5d",
      1000 * dword_100292F0[0] / v84,
      1000 * dword_100292F4 / v84,
      1000 * dword_100292F8 / v84,
      1000 * dword_100292FC / v84);
    buf = (s2c_sendto *)src;
    SendMessage((struct PLAYER *)requester, src, 0);
  }
  if ( !_memicmp_0(playera, "*tmode ", 7u) && v204 )
  {
    LOWORD(buf) = 5120;
    BYTE2(buf) = 'A';
    HIBYTE(buf) = atol_1(playera + 7);
    buf_sz = (PLAYER *)&buf;
    PlayerSendPacket(v204, &buf, 4, 1);
  }
  if ( !_memicmp_0(playera, "*sendto ", 8u) )
  {
    if ( v204 )
    {
      v85 = strchr_0(playera, ',');
      if ( *v85 )
      {
        *v85 = 0;
        v86 = v85 + 1;
        v87 = inet_addr_0(playera + 8);
        v88 = atol_1(v86);
        buf = (s2c_sendto *)strchr_0(v86, ',');
        if ( v87 != -1 )
        {
          if ( v88 )
          {
            memset(&s2c_sendto_pkt, 0, 0x1Cu);
            HIBYTE(s2c_sendto_pkt.unused) = 0;
            s2c_sendto_pkt.type = 59;
            s2c_sendto_pkt.ip_addr = ntohl_0(v87);
            s2c_sendto_pkt.port_num = v88;
            if ( buf )
            {
              s2c_sendto_pkt.join_type = -3;
              strncpyt(s2c_sendto_pkt.arena_name, &buf->ip_addr, 16);
            }
            else
            {
              s2c_sendto_pkt.join_type = -1;
            }
            buf = &s2c_sendto_pkt;
            PlayerSendPacket(v204, &s2c_sendto_pkt, 29, 1);
          }
        }
      }
    }
  }
cmd_locate:
  if ( !_memicmp_0(playera, "*locate ", 8u) && *sub_10003260(playera + 8) )
  {
    v89 = sub_10003260(playera + 8);
    find_player_request((PLAYER *)requester, v89);
    goto LABEL_291;
  }
  if ( !_memicmp_0(playera, "*listban", 8u) )
  {
    v90 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
    v91 = 0;
    if ( MachineIdArrayCount > 0 )
    {
      v92 = dword_4AD73C;
      do
      {
        sprintf_0(src, (const char *)&loc_10025018, *(v92 - 1), (int)(v90 - *v92) / 100, v92[1] / 100);
        SendMessage((struct PLAYER *)requester, src, 0);
        ++v91;
        v92 += 3;
      }
      while ( v91 < MachineIdArrayCount );
    }
    return 0;
  }
  if ( _memicmp_0(playera, (char *)&loc_1002500A + 2, 0xBu) )
  {
    if ( !_memicmp_0(playera, "*relkills", 9u) )
    {
      v96 = sub_10003260(playera + 9);
      v97 = atol_1(v96);
      *(int *)((char *)requester + 1018) = v97;
      buf = (s2c_sendto *)"Reliable kill messages ON";
      if ( !v97 )
        buf = (s2c_sendto *)"Reliable kill messages OFF";
      SendMessage((struct PLAYER *)requester, &buf->type, 0);
LABEL_291:
      v99 = v204;
LABEL_292:
      if ( *(int *)((char *)requester + 635) )
      {
        if ( !_memicmp_0(playera, "*listmod", 8u) )
        {
          buf = 0;
          if ( ZonePlayerCount > 0 )
          {
            v109 = (PLAYER **)ZonePlayers;
            do
            {
              v110 = *v109;
              if ( *v109 && v110->lpCurrentArena && v110->bIsModerator )
              {
                v111 = "Mod";
                if ( v110->bIsSmod )
                  v111 = "SMod";
                if ( v110->bIsSysop )
                  v111 = "Sysop";
                v112 = sub_1000C1B0(v110, 1);
                sprintf_0(src, "%s - %s - %s", v110->player_name, v111, v112);
                buf_sz = (PLAYER *)src;
                SendMessage((struct PLAYER *)requester, src, 0);
                v99 = v204;
              }
              ++v109;
              buf = (s2c_sendto *)((char *)buf + 1);
            }
            while ( (int)buf < ZonePlayerCount );
          }
        }
        v113 = playera;
        if ( !_memicmp_0(playera, "*zone", 5u) )
        {
          v114 = sub_10003260(playera + 5);
          sub_1000B400(byte_1003E438, 2, v114, 0);
        }
      }
      else
      {
        v113 = playera;
      }
      if ( !_memicmp_0(v113, "*specall", 8u) )
      {
        v115 = requester[7];
        if ( v115 )
        {
          v116 = *(_DWORD *)(v115 + 65292);
          buf = 0;
          if ( v116 > 0 )
          {
            v117 = 64288;
            do
            {
              buf_sz = *(PLAYER **)(v115 + v117);
              v118 = buf_sz;
              if ( buf_sz && buf_sz->dwShip != 8 && (*(int *)((char *)requester + 631) || !buf_sz->bIsSmod) )
              {
                v119 = FIX_DLL_KERNEL32_dll_GetTickCount();
                *(_DWORD *)&v118->field_341[52] = v119;
                *(_DWORD *)&v118->field_341[197] = v119 + 5000;
                SetPlayerShip(buf_sz, 8);
              }
              v115 = requester[7];
              v120 = *(_DWORD *)(v115 + 65292);
              v117 += 4;
              buf = (s2c_sendto *)((char *)buf + 1);
            }
            while ( (int)buf < v120 );
          }
        }
      }
      v121 = playera;
      v122 = _memicmp_0(playera, "*flags", 6u);
      v123 = requester;
      if ( !v122 )
      {
        v124 = requester[7];
        if ( v124 )
        {
          strcpy(src, "UNCARRIED FLAGS:");
          v125 = *(_DWORD *)(v124 + 108190);
          buf = 0;
          if ( v125 > 0 )
          {
            v126 = 0;
            do
            {
              if ( *(int *)(v124 + v126 + 100006) < 0 )
              {
                v127 = *(_DWORD *)(v124 + v126 + 99998);
                if ( v127 < 0x400 )
                {
                  v128 = *(_DWORD *)(v124 + v126 + 100002);
                  if ( v128 < 0x400 && strlen(src) < 0xFA )
                  {
                    v167 = (int)(20 * v128) / 1024 + 1;
                    v129 = strchr_0(src, 0);
                    sprintf_0(v129, " %c%d", (int)(20 * v127) / 1024 + 65, v167);
                  }
                }
              }
              v124 = requester[7];
              v130 = *(_DWORD *)(v124 + 108190);
              v126 += 16;
              buf = (s2c_sendto *)((char *)buf + 1);
            }
            while ( (int)buf < v130 );
          }
          buf = (s2c_sendto *)src;
          SendMessage((struct PLAYER *)requester, src, 0);
          v121 = playera;
          v123 = requester;
          v99 = v204;
        }
      }
      if ( v99 && v99->lpCurrentArena )
      {
        if ( *(int *)((char *)v123 + 631)
          || *(int *)((char *)v123 + 635) && !v99->bIsSysop
          || (player_3 = 0, !v99->bIsSmod) )
        {
          player_3 = 1;
        }
        if ( _memicmp_0(v121, "*setship ", 9u) )
        {
          if ( _memicmp_0(v121, "*setfreq ", 9u) )
          {
            if ( *(int *)((char *)v123 + 631) )
            {
              if ( !_memicmp_0(v121, "*ufo", 4u) )
              {
                v142 = *(_DWORD *)&v99->field_2C[16];
                BYTE2(requester) = 37;
                HIBYTE(requester) = v142 == 0;
                *(_DWORD *)&v99->field_2C[16] = v142 == 0;
                PlayerSendPacket(v204, (char *)&requester + 2, 2, 1);
                return 0;
              }
              if ( *(int *)((char *)v123 + 631) && !_memicmp_0(v121, "*super", 6u) )
              {
                memcpy_0(v168, (const void *)(v123[7] + 108194), 0x594u);
                sub_1000DAB0((int)v168);
                requester = v168;
                PlayerSendPacket(v204, v168, 1428, 1);
                return 0;
              }
            }
            if ( _memicmp_0(v121, "*watchgreen", 0xBu) )
            {
              v147 = _memicmp_0(v121, "*watchdamage", 0xCu);
              if ( v147 )
              {
                if ( !_memicmp_0(v121, "*lag", 4u) )
                {
                  v151 = *(_DWORD *)&v99->field_117[12];
                  if ( v151 > 200 )
                    v152 = 1000 - 1000 * *(_DWORD *)&v204->field_117[16] / v151;
                  else
                    v152 = 0;
                  sprintf_0(
                    src,
                    "PING Current:%d ms  Average:%d ms  Low:%d ms  High:%d ms  S2C: %d.%d%%  C2S: %d.%d%%  S2CWeapons: %d.%d%%",
                    10 * *(__int16 *)&v204->field_117[51],
                    10 * *(__int16 *)&v204->field_117[53],
                    10 * *(__int16 *)&v204->field_117[55],
                    10 * *(__int16 *)&v204->field_117[57],
                    (1000 - *(_DWORD *)&v204->field_319[8]) / 10,
                    (1000 - *(_DWORD *)&v204->field_319[8]) % 10,
                    (1000 - *(_DWORD *)&v204->field_319[12]) / 10,
                    (1000 - *(_DWORD *)&v204->field_319[12]) % 10,
                    v152 / 10,
                    v152 % 10);
                  SendMessage((struct PLAYER *)requester, src, 0);
                  return 0;
                }
                if ( !_memicmp_0(v121, "*greeninfo", 0xAu) )
                {
                  src[0] = 0;
                  v153 = 1;
                  playerg = &v204->field_341[64];
                  do
                  {
                    v154 = v204->lpCurrentArena;
                    if ( *(_BYTE *)(v153 + v154 + 109593) )
                    {
                      sprintf_0(
                        v178,
                        "%d:%d(%d) ",
                        v153,
                        *(_DWORD *)playerg,
                        *(_DWORD *)playerg
                      - (unsigned int)*(unsigned __int8 *)(v153 + v154 + 109593)
                      * *(_DWORD *)&v204->field_341[176]
                      / *(_DWORD *)(v154 + 111602));
                      strcat(src, v178);
                      if ( !(v153 % 7) )
                      {
                        buf = (s2c_sendto *)src;
                        SendMessage((struct PLAYER *)requester, src, 0);
                        src[0] = 0;
                      }
                    }
                    ++v153;
                    playerg += 4;
                  }
                  while ( v153 < 29 );
                  return 1;
                }
                if ( !_memicmp_0(v121, "*warn ", 6u) )
                {
                  sprintf_0(src, "MODERATOR WARNING: %.150s -%s", v121 + 6, (const char *)v123 + 375);
                  v175[0] = 7;
                  v175[1] = 8;
                  v175[2] = 1;
                  *(_WORD *)&v175[3] = -1;
                  strncpyt(dst, src, 250);
                  buf = (s2c_sendto *)(strlen((const char *)dst) + 6);
                  PlayerSendPacket(v204, v175, (int)buf, 1);
                  SendMessage((struct PLAYER *)requester, "Player warned", 0);
                  return 1;
                }
                if ( _memicmp_0(v121, "*warpto ", 8u) )
                {
                  if ( !_memicmp_0(v121, "*tinfo", 6u) )
                  {
                    SendMessage((struct PLAYER *)requester, " ServerTime    UserTime        Diff", 0);
                    v160 = *(_DWORD *)&v99->field_341[202];
                    v161 = 32;
                    do
                    {
                      v160 &= 0x1Fu;
                      v162 = *(_DWORD *)&v99->field_341[4 * v160 + 334];
                      if ( v162 || *(_DWORD *)&v99->field_341[4 * v160 + 206] )
                      {
                        sprintf_0(
                          src,
                          "%11d %11d %11d",
                          v162,
                          *(_DWORD *)&v99->field_341[4 * v160 + 206],
                          v162 - *(_DWORD *)&v99->field_341[4 * v160 + 206]);
                        SendMessage((struct PLAYER *)requester, src, 0);
                      }
                      LOBYTE(v160) = v160 + 1;
                      --v161;
                    }
                    while ( v161 );
                  }
                }
                else
                {
                  v155 = sub_10003260(v121 + 8);
                  v156 = atol_1(v155);
                  v157 = sub_10003240(v155);
                  v158 = sub_10003260(v157);
                  v159 = atol_1(v158);
                  if ( v156 > 0 && v159 > 0 )
                  {
                    v203[0] = 50;
                    *(_WORD *)&v203[1] = v156 & 0x3FF;
                    *(_WORD *)&v203[3] = v159 & 0x3FF;
                    requester = (int *)v203;
                    PlayerSendPacket(v204, v203, 5, 1);
                    return 1;
                  }
                }
              }
              else
              {
                v148 = v123[5];
                v149 = (int *)&v99->field_341[462];
                while ( *v149 >= 0 )
                {
                  if ( *v149 == v148 )
                  {
                    memcpy_0(&v99->field_341[4 * v147 + 462], &v99->field_341[4 * v147 + 466], 20 - 4 * v147);
                    *(_DWORD *)&v99->field_341[482] = -1;
LABEL_392:
                    v150 = 0;
                    playerf = "Damage logging OFF";
                    goto LABEL_393;
                  }
                  ++v147;
                  ++v149;
                  if ( v147 >= 6 )
                    goto LABEL_392;
                }
                *(_DWORD *)&v99->field_341[4 * v147 + 462] = v148;
                v150 = 1;
                playerf = "Damage logging ON";
LABEL_393:
                SendMessage((struct PLAYER *)requester, playerf, 0);
                if ( v150 )
                {
                  BYTE2(requester) = 55;
                  HIBYTE(requester) = 1;
                  PlayerSendPacket(v204, (char *)&requester + 2, 2, 1);
                  return 1;
                }
              }
            }
            else
            {
              v143 = 0;
              v144 = &ZonePlayerList;
              while ( *v144 != (PLAYER *)v123 )
              {
                ++v144;
                ++v143;
                if ( (int)v144 >= (int)&unk_4D6858 )
                  return 1;
              }
              if ( v143 < 1000 )
              {
                v145 = 0;
                v146 = (int *)&v99->field_341[28];
                while ( *v146 >= 0 )
                {
                  if ( *v146 == v143 )
                  {
                    memcpy_0(&v99->field_341[4 * v145 + 28], &v99->field_341[4 * v145 + 32], 20 - 4 * v145);
                    *(_DWORD *)&v99->field_341[48] = -1;
LABEL_383:
                    playere = "Green logging OFF";
                    goto LABEL_384;
                  }
                  ++v145;
                  ++v146;
                  if ( v145 >= 6 )
                    goto LABEL_383;
                }
                *(_DWORD *)&v99->field_341[4 * v145 + 28] = v143;
                playere = "Green logging ON";
LABEL_384:
                SendMessage((struct PLAYER *)requester, playere, 0);
                return 1;
              }
            }
          }
          else
          {
            v139 = sub_10003260(v121 + 9);
            v140 = atol_1(v139);
            requester = (int *)v140;
            if ( v140 >= 0 && v140 <= 9999 )
            {
              if ( player_3 )
              {
                if ( v99->dwShip == 8 )
                {
                  *(_DWORD *)&v99->field_341[52] = FIX_DLL_KERNEL32_dll_GetTickCount();
                  PlayerChangeFrequency(v204, (signed int)requester);
                }
                else
                {
                  *(_DWORD *)v99->field_117 = v140;
                  requester = (int *)v99->dwShip;
                  v141 = FIX_DLL_KERNEL32_dll_GetTickCount();
                  *(_DWORD *)&v99->field_341[52] = v141;
                  *(_DWORD *)&v99->field_341[197] = v141 + 5000;
                  SetPlayerShip(v204, (signed int)requester);
                }
                result = 1;
              }
              else
              {
                sprintf_0(src, "%s attempted to change your freq to %d", (const char *)v123 + 375, v140);
                requester = (int *)src;
                SendMessage(v204, src, 0);
                result = 1;
              }
              return result;
            }
          }
        }
        else
        {
          v131 = sub_10003260(v121 + 9);
          v132 = atol_1(v131);
          v133 = v99->lpCurrentArena;
          if ( !v133
            || (v134 = *(_DWORD *)(v133 + 121111), v134 > 0)
            && (v135 = *(_DWORD *)(v133 + 121115), v135 > 0)
            && (v99->dwXRes > v134 || v99->dwYRes > v135)
            || (*(_BYTE *)(v133 + 121247) || byte_101A5389)
            && v99->dwClientVersion != 1
            && !*(_DWORD *)&v99->field_341[193]
            || (v136 = *(_DWORD *)(v133 + 121256)) != 0
            && *(_DWORD *)&v99->field_18F[120] < v136
            && BillingConnectionStructPointer )
          {
            if ( !*(int *)((char *)v123 + 631) )
            {
              v137 = FIX_DLL_KERNEL32_dll_GetTickCount();
              *(_DWORD *)&v99->field_341[52] = v137;
              *(_DWORD *)&v99->field_341[197] = v137 + 5000;
              SetPlayerShip(v204, 8);
              return 1;
            }
          }
          if ( v132 >= 1 && v132 <= 8 && v99->dwShip != v132 - 1 )
          {
            if ( player_3 )
            {
              requester = (int *)(v132 - 1);
              v138 = FIX_DLL_KERNEL32_dll_GetTickCount();
              *(_DWORD *)&v99->field_341[52] = v138;
              *(_DWORD *)&v99->field_341[197] = v138 + 5000;
              SetPlayerShip(v204, (signed int)requester);
            }
            else
            {
              sprintf_0(src, "%s attempted to change your ship to %d", (const char *)v123 + 375, v132);
              requester = (int *)src;
              SendMessage(v204, src, 0);
            }
            return 1;
          }
        }
      }
      return 1;
    }
    if ( _memicmp_0(playera, "*objon ", 7u) )
    {
      if ( _memicmp_0(playera, "*objoff ", 8u) )
      {
        if ( !_memicmp_0(playera, "*objset ", 8u) )
        {
          LOBYTE(v170) = 53;
          v103 = 0;
          v104 = sub_10003260(playera + 8);
          v105 = *v104;
          if ( *v104 )
          {
            v106 = (_WORD *)((char *)&v170 + 1);
            do
            {
              if ( v103 >= 0x80 )
                break;
              *v106 = *v106 & 0x7FFF | ((v105 == 45) << 15);
              if ( *v104 == 45 || *v104 == 43 )
                ++v104;
              *v106 ^= (*v106 ^ atol_1(v104)) & 0x7FFF;
              v107 = strchr_0(v104, 44);
              if ( !v107 )
                break;
              v104 = sub_10003260(v107 + 1);
              v105 = *v104;
              ++v103;
              ++v106;
            }
            while ( *v104 );
            if ( v103 )
            {
              if ( v204 )
              {
                buf_sz = (PLAYER *)(2 * v103 + 1);
                buf = (s2c_sendto *)&v170;
                PlayerSendPacket(v204, &v170, (int)buf_sz, 1);
              }
              else
              {
                *(_DWORD *)v203 = 2 * v103 + 1;
                v108 = (PLAYER *)requester[7];
                HIBYTE(buf) = 1;
                v202 = &v170;
                buf_sz = v108;
                ArenaSendPacket((struct ARENA *)v108, (char *)&v170, *(int *)v203, 1);
              }
            }
          }
        }
        goto LABEL_291;
      }
      v203[2] |= 0x80u;
      v203[0] = 53;
      v101 = atol_1(playera + 8);
      v99 = v204;
      *(_WORD *)&v203[1] ^= (*(_WORD *)&v203[1] ^ v101) & 0x7FFF;
      if ( !v204 )
      {
        v102 = (PLAYER *)requester[7];
        HIBYTE(buf) = 1;
        v202 = (int *)v203;
        buf_sz = v102;
        ArenaSendPacket((struct ARENA *)v102, v203, 3, 1);
        goto LABEL_292;
      }
    }
    else
    {
      *(_WORD *)&v203[1] &= 0x7FFFu;
      v203[0] = 53;
      v98 = atol_1(playera + 7);
      v99 = v204;
      *(_WORD *)&v203[1] ^= (*(_WORD *)&v203[1] ^ v98) & 0x7FFF;
      if ( !v204 )
      {
        v100 = (PLAYER *)requester[7];
        HIBYTE(buf) = 1;
        v202 = (int *)v203;
        buf_sz = v100;
        ArenaSendPacket((struct ARENA *)v100, v203, 3, 1);
        goto LABEL_292;
      }
    }
    buf = (s2c_sendto *)v203;
    PlayerSendPacket(v204, v203, 3, 1);
    goto LABEL_292;
  }
  v93 = atol_1(playera + 11);
  v94 = 0;
  if ( MachineIdArrayCount > 0 )
  {
    for ( i = dword_4AD738; *i != v93; i += 3 )
    {
      if ( ++v94 >= MachineIdArrayCount )
        return 0;
    }
    memcpy_0(
      (void *)(4 * (3 * v94 + 1226190)),
      (const void *)(4 * (3 * v94 + 1226193)),
      12 * MachineIdArrayCount - 4 * (3 * v94 + 3));
    --MachineIdArrayCount;
    SendMessage((struct PLAYER *)requester, aBanRem, 0);
  }
  return 0;
}
// 100103C1: positive sp value 1C has been found
// 1000FBDE: conditional instruction was optimized away because of 'ecx.4!=0'
// 1000FF74: conditional instruction was optimized away because of 'eax.4<6u'
// 1001003D: conditional instruction was optimized away because of 'eax.4<6u'
// 1000EAC9: variable 'v166' is possibly undefined
// 4399C4: using guessed type int MachineIdArrayCount;
// 4AD738: using guessed type int dword_4AD738[];
// 4AD73C: using guessed type int dword_4AD73C[];
// 4CA230: using guessed type int ZonePlayers[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10021A78: using guessed type double dbl_10021A78;
// 10021A80: using guessed type double dbl_10021A80;
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 100251F4: using guessed type void *off_100251F4;
// 100292F0: using guessed type int dword_100292F0[];
// 100292F4: using guessed type int dword_100292F4;
// 100292F8: using guessed type int dword_100292F8;
// 100292FC: using guessed type int dword_100292FC;
// 10029300: using guessed type int dword_10029300;
// 101A51A8: using guessed type int dword_101A51A8;
// 101A52E8: using guessed type int dword_101A52E8;
// 101A52F0: using guessed type int dword_101A52F0;
// 101A5381: using guessed type char byte_101A5381;
// 101A5382: using guessed type char byte_101A5382;
// 101A5389: using guessed type char byte_101A5389;
// 101A538C: using guessed type int dword_101A538C;
// 101A5394: using guessed type int dword_101A5394;
// 101B083C: using guessed type char byte_101B083C;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;
// 101B304C: using guessed type int dword_101B304C;

//----- (10010460) --------------------------------------------------------
int __thiscall sub_10010460(int *this, int a2, int a3)
{
  int result; // eax

  result = a2;
  if ( a2 >= 0 && a2 <= a3 )
  {
    ++this[3];
    this[2] += a2;
    if ( a2 < *this )
      *this = a2;
    if ( a2 > this[1] )
      this[1] = a2;
  }
  return result;
}

//----- (10010490) --------------------------------------------------------
void __thiscall sub_10010490(int *this, struct PLAYER *a2, double a3, char *msg)
{
  int v4; // esi
  char v5[4]; // [esp+1Ch] [ebp-84h] BYREF
  int v6; // [esp+9Ch] [ebp-4h]

  v4 = this[3];
  if ( v4 )
    v6 = this[2] / v4;
  else
    v6 = 0;
  sprintf_0(
    v5,
    "%10s: %6.1f %6.1f %6.1f",
    msg,
    (double)((long double)v6 * a3),
    (double)((long double)*this * a3),
    (double)((long double)this[1] * a3));
  SendMessage(a2, v5, 0);
}

//----- (10010510) --------------------------------------------------------
_DWORD *__thiscall sub_10010510(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0x7FFFFFFF;
  this[1] = -1;
  this[2] = 0;
  this[3] = 0;
  return result;
}

//----- (10010530) --------------------------------------------------------
void __thiscall sub_10010530(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // ecx
  _BOOL1 v4; // zf
  const char *v5; // ecx
  const char *v6; // edi
  const char *v7; // edx
  const char *v8; // ecx
  unsigned int v9; // edx
  int v10; // edx
  _BOOL1 v11; // sf
  int v12; // eax
  char v13[4]; // [esp+0h] [ebp-140h] BYREF
  char v14[4]; // [esp+100h] [ebp-40h] BYREF

  if ( *(int *)((char *)this + 275) < 8 && FIX_DLL_KERNEL32_dll_GetTickCount() - *(_DWORD *)((char *)this + 885) >= 5000 )
  {
    v3 = a2 & 0x1F;
    v4 = v3 == 2;
    if ( v3 > 2 )
    {
      if ( v3 > 4 )
      {
        if ( v3 > 8 )
          sprintf_0(v14, "Unknown weapon %d", a2);
        else
          sprintf_0(v14, (&off_1002465C)[v3]);
      }
      else
      {
        v6 = "bouncing ";
        if ( (a2 & 0x80u) == 0 )
          v6 = LevelFiles;
        v7 = "mine";
        if ( (a2 & 0x8000) == 0 )
          v7 = "bomb";
        v4 = v3 == 4;
        v8 = "Prox ";
        if ( !v4 )
          v8 = LevelFiles;
        sprintf_0(
          v14,
          "%sL%d %s with %d %sL%d shrap",
          v8,
          ((a2 >> 5) & 3) + 1,
          v7,
          (a2 >> 10) & 0x1F,
          v6,
          ((a2 >> 8) & 3) + 1);
      }
    }
    else
    {
      v5 = "Bouncing ";
      if ( !v4 )
        v5 = LevelFiles;
      sprintf_0(v14, "%sL%d bullet", v5, ((a2 >> 5) & 3) + 1);
    }
    sprintf_0(v13, "Illegal %s weapon: %s", off_10024650[*(_DWORD *)((char *)this + 275)], v14);
    sub_100151C0(v13, (int)this);
    v9 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
    if ( v9 - *(_DWORD *)((char *)this + 655) >= 0x96 )
    {
      *(_DWORD *)((char *)this + 655) = v9;
      *(_DWORD *)((char *)this + 659) = 0;
    }
    else
    {
      v10 = *(_DWORD *)((char *)this + 659) + 1;
      v11 = *(_DWORD *)((char *)this + 659) - 6 < 0;
      *(_DWORD *)((char *)this + 659) = v10;
      if ( !(v11 ^ __OFSUB__(v10, 7) | (v10 == 7)) )
      {
        *(_DWORD *)((char *)this + 789) = 33;
        this[14] = 1;
      }
    }
    v12 = this[7];
    if ( !v12 || *(_DWORD *)(v12 + 109802) )
    {
      this[14] = 1;
      *(_DWORD *)((char *)this + 789) = 30;
    }
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024650: using guessed type char *off_10024650[12];

//----- (100106E0) --------------------------------------------------------
void __thiscall sub_100106E0(_DWORD *this, char a2)
{
  int (*v3)(void); // edi
  const char *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  _BOOL1 v7; // sf
  int v8; // eax
  char v9[4]; // [esp+0h] [ebp-100h] BYREF

  if ( *(int *)((char *)this + 275) < 8 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetTickCount;
    if ( FIX_DLL_KERNEL32_dll_GetTickCount() - *(_DWORD *)((char *)this + 885) >= 5000 )
    {
      v4 = LevelFiles;
      if ( (a2 & 0x40) != 0 )
      {
        v4 = "Ufo";
      }
      else if ( (a2 & 8) != 0 )
      {
        v4 = "AntiWarp";
      }
      else if ( (a2 & 4) != 0 )
      {
        v4 = "XRadar";
      }
      else if ( (a2 & 2) != 0 )
      {
        v4 = "Cloak";
      }
      else if ( (a2 & 1) != 0 )
      {
        v4 = "Stealth";
      }
      sprintf_0(v9, "Illegal %s equipment: %s", off_10024650[*(_DWORD *)((char *)this + 275)], v4);
      sub_100151C0(v9, (int)this);
      v5 = v3() / 0xAu;
      if ( v5 - *(_DWORD *)((char *)this + 655) >= 0x96 )
      {
        *(_DWORD *)((char *)this + 655) = v5;
        *(_DWORD *)((char *)this + 659) = 0;
      }
      else
      {
        v6 = *(_DWORD *)((char *)this + 659) + 1;
        v7 = *(_DWORD *)((char *)this + 659) - 6 < 0;
        *(_DWORD *)((char *)this + 659) = v6;
        if ( !(v7 ^ __OFSUB__(v6, 7) | (v6 == 7)) )
        {
          *(_DWORD *)((char *)this + 789) = 33;
          this[14] = 1;
        }
      }
      v8 = this[7];
      if ( !v8 || *(_DWORD *)(v8 + 109802) )
      {
        this[14] = 1;
        *(_DWORD *)((char *)this + 789) = 31;
      }
    }
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024650: using guessed type char *off_10024650[12];

//----- (10010810) --------------------------------------------------------
int __thiscall sub_10010810(_DWORD *this, int a2)
{
  int result; // eax

  result = this[7];
  if ( !result || *(_DWORD *)(result + 109802) )
  {
    result = a2;
    this[14] = 1;
    *(_DWORD *)((char *)this + 789) = a2;
  }
  return result;
}

//----- (10010840) --------------------------------------------------------
_BOOL1 __fastcall sub_10010840(_BYTE *a1)
{
  char v1; // al
  int v2; // edx

  v1 = 0;
  v2 = 22;
  do
  {
    v1 ^= *a1++;
    --v2;
  }
  while ( v2 );
  return v1 == 0;
}

//----- (10010860) --------------------------------------------------------
_BOOL1 __thiscall sub_10010860(_DWORD *this)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax

  v1 = this[7];
  if ( !v1 )
    return 1;
  v2 = *(_DWORD *)(v1 + 121111);
  if ( v2 <= 0 )
    return 1;
  v3 = *(_DWORD *)(v1 + 121115);
  if ( v3 <= 0 )
    return 1;
  return *(_DWORD *)((char *)this + 619) <= v2 && *(_DWORD *)((char *)this + 623) <= v3;
}

//----- (100108A0) --------------------------------------------------------
void __thiscall sub_100108A0(struct PLAYER *this)
{
  int v1; // eax
  int v2; // edx
  char v3[4]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v4; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v1 = this->lpCurrentArena;
  v2 = *(_DWORD *)(v1 + 121111);
  v4 = this;
  sprintf_0(v3, "Maximum allowed screen resolution is %dx%d in this arena", v2, *(_DWORD *)(v1 + 121115));
  msg = v3;
  SendMessage(v4, v3, 0);
}

//----- (100108F0) --------------------------------------------------------
bool __thiscall sub_100108F0(_DWORD *this)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  int v4; // eax
  bool result; // eax

  v1 = this[7];
  result = 0;
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 121111);
    if ( v2 <= 0
      || (v3 = *(_DWORD *)(v1 + 121115), v3 <= 0)
      || *(_DWORD *)((char *)this + 619) <= v2 && *(_DWORD *)((char *)this + 623) <= v3 )
    {
      if ( !*(_BYTE *)(v1 + 121247) && !byte_101A5389 || this[6] == 1 || *(_DWORD *)((char *)this + 1026) )
      {
        v4 = *(_DWORD *)(v1 + 121256);
        if ( !v4 || *(_DWORD *)((char *)this + 519) >= v4 || !BillingConnectionStructPointer )
          result = 1;
      }
    }
  }
  return result;
}
// 1001091E: conditional instruction was optimized away because of 'eax.4!=0'
// 101A5389: using guessed type char byte_101A5389;

//----- (10010970) --------------------------------------------------------
void __thiscall sub_10010970(struct PLAYER *this)
{
  char v1[4]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v2; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v2 = this;
  sprintf_0(v1, "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
  msg = v1;
  SendMessage(v2, v1, 0);
}

//----- (100109B0) --------------------------------------------------------
void __thiscall sub_100109B0(struct PLAYER *this)
{
  int v1; // eax
  char v2[4]; // [esp+0h] [ebp-108h] BYREF
  struct PLAYER *v3; // [esp+100h] [ebp-8h]
  char *msg; // [esp+104h] [ebp-4h]

  v1 = this->lpCurrentArena;
  v3 = this;
  sprintf_0(
    v2,
    "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
    *(_DWORD *)(v1 + 121256) / 3600);
  msg = v2;
  SendMessage(v3, v2, 0);
}

//----- (10010A10) --------------------------------------------------------
char __thiscall sub_10010A10(unsigned __int8 *this)
{
  const char *v2; // edi
  _BOOL1 v3; // zf
  _BOOL1 v4; // dl
  char *v5; // eax

  v2 = (const char *)(this + 2);
  v3 = isalnum(this[2]) == 0;
  this[33] = 0;
  v4 = !v3;
  if ( *v2 )
  {
    v5 = (char *)v2;
    do
    {
      if ( (unsigned __int8)*v5 < 0x20u || (unsigned __int8)*v5 > 0x7Eu )
      {
        *v5 = 95;
        v4 = 0;
      }
    }
    while ( *++v5 );
  }
  if ( v4 )
    return 1;
  off_10024608("Ext: Player with invalid name tying to enter: %s\n", v2);
  return 0;
}
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (10010A70) --------------------------------------------------------
const char *__thiscall sub_10010A70(_DWORD *this)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // ecx

  v1 = this[25];
  if ( v1 < 37 )
    return "Undetermined";
  if ( v1 > 100 )
    return "Undetermined";
  v2 = this[10];
  if ( !v2 )
    return "Undetermined";
  v3 = *(_DWORD *)((char *)this + 1319);
  if ( !v3 )
    return "SOCKS5 proxy";
  v4 = *(_DWORD *)((char *)this + 1323);
  if ( !v4 )
    return "SOCKS5 proxy";
  if ( (v3 & 0xFF000000) == 2130706432 || v3 == *(_DWORD *)v2 )
    return "Using proxy at localhost";
  if ( !dword_101A5348 )
    return "ServerIP is not set in server.ini";
  if ( v3 != dword_101A5348 )
    return "Using custom proxy";
  if ( v4 == *(unsigned __int16 *)(v2 + 4) )
    return "Not using proxy";
  return "Using NAT";
}
// 101A5348: using guessed type int dword_101A5348;

//----- (10010B00) --------------------------------------------------------
// first chance packet handler, eventually calls out to subgames packet handler for game packets (408e90)
void __thiscall fix_04(int this, int player, DWORD pkt_sz)
{
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v6; // ecx
  unsigned int v7; // eax
  int v8; // edx
  int *v9; // eax
  int v10; // eax
  unsigned int v11; // edx
  int v12; // ecx
  char v13; // al
  unsigned int v14; // esi
  int v15; // edi
  _BYTE *v16; // ecx
  char v17; // al
  int v18; // edx
  char *v19; // edi
  _BYTE *v20; // ecx
  char v21; // al
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // edx
  int v25; // eax
  _BOOL1 v26; // sf
  int v27; // esi
  int v28; // edi
  char v29; // al
  _BYTE *v30; // ecx
  int v31; // edx
  char v32; // al
  int v33; // ecx
  int v34; // edx
  int v35; // eax
  int v36; // esi
  int v37; // eax
  unsigned int v38; // edx
  int v39; // eax
  int v40; // ebx
  int v41; // eax
  int v42; // esi
  char v43; // cl
  int v44; // eax
  __int16 v45; // di
  int v46; // esi
  int v47; // eax
  const char *v48; // eax
  int v49; // eax
  int *v50; // edi
  const char *v51; // eax
  int v52; // edx
  int v53; // eax
  long double v54; // fst7
  unsigned int v55; // esi
  unsigned __int8 *v56; // edi
  int *v57; // ebx
  long double v58; // fst7
  long double v59; // fst6
  int v60; // eax
  int v61; // edx
  int v62; // ecx
  int v63; // ecx
  __int16 v64; // ax
  _BOOL1 v65; // zf
  _BOOL1 v66; // al
  char *v67; // esi
  char v68; // al
  unsigned int v69; // ecx
  char v70; // dl
  char *v71; // edi
  const char *v72; // esi
  int v73; // ecx
  int v74; // eax
  int v75; // eax
  int v76; // ebx
  int v77; // edx
  char *v78; // esi
  _BOOL1 v79; // dl
  _BYTE *v80; // eax
  unsigned int v82; // ebx
  unsigned int v83; // eax
  int v84; // ecx
  int *v85; // eax
  int v86; // eax
  unsigned int v87; // esi
  int v88; // eax
  int v89; // eax
  _BOOL1 v90; // cc
  int v91; // edx
  _BOOL1 v92; // dl
  _BYTE *v93; // eax
  unsigned int v95; // ebx
  int v96; // ecx
  unsigned __int16 v97; // cx
  int v98; // eax
  int v99; // eax
  int v100; // eax
  char *v101; // eax
  unsigned int v102; // eax
  int v103; // ecx
  int v104; // eax
  int v105; // eax
  char *v106; // ecx
  int v107; // eax
  char *v108; // edx
  struct CONNECTION *v109; // eax
  unsigned int v110; // ebx
  unsigned int v111; // eax
  int v112; // ecx
  int *v113; // eax
  int v114; // eax
  unsigned int v115; // esi
  unsigned int v116; // ebx
  unsigned int v117; // eax
  int v118; // ecx
  int *v119; // eax
  int v120; // eax
  unsigned int v121; // esi
  char v122; // al
  unsigned __int16 v123; // ax
  struct ARENA *v124; // ebx
  int v125; // eax
  int v126; // eax
  int v127; // eax
  char v128; // al
  unsigned int v129; // ecx
  char v130; // al
  char *v131; // edi
  char *v132; // esi
  DWORD v133; // eax
  int v134; // ecx
  int v135; // eax
  int *v136; // esi
  int v137; // ecx
  int v138; // edi
  unsigned int i; // ebx
  int v140; // eax
  char v141[128]; // [esp+Ch] [ebp-140h] BYREF
  char v142[28]; // [esp+8Ch] [ebp-C0h] BYREF
  char v143; // [esp+A8h] [ebp-A4h] BYREF
  __int16 v144; // [esp+A9h] [ebp-A3h]
  int v145; // [esp+ABh] [ebp-A1h]
  char v146[13]; // [esp+AFh] [ebp-9Dh] BYREF
  char v147[16]; // [esp+BCh] [ebp-90h] BYREF
  char v148[64]; // [esp+CCh] [ebp-80h] BYREF
  char v149[28]; // [esp+10Ch] [ebp-40h] BYREF
  char v150; // [esp+128h] [ebp-24h]
  char v151; // [esp+12Bh] [ebp-21h]
  _BYTE buf_sz[7]; // [esp+12Ch] [ebp-20h] BYREF
  int v153; // [esp+134h] [ebp-18h] BYREF
  PLAYER *p; // [esp+138h] [ebp-14h]
  char *reason[2]; // [esp+13Ch] [ebp-10h]
  int v156; // [esp+144h] [ebp-8h] BYREF
  int v157; // [esp+148h] [ebp-4h]

  v3 = player;
  v4 = *(char *)player;
  p = (PLAYER *)this;
  if ( byte_101A5388 && v4 < 0x2E )
  {
    v6 = *(_DWORD *)(this + 755);
    v7 = ((-25033 * (v6 ^ HIWORD(*(_DWORD *)(this + 755)))) >> 5) & 0x7FF;
    v8 = dword_101A5398[2 * v7];
    reason[1] = (char *)v7;
    if ( v8 == v6 )
    {
LABEL_7:
      v9 = (int *)(8 * v7 + 270160796);
      if ( v9 )
      {
        v10 = *v9;
        v11 = dword_10021998[v4] + *(_DWORD *)(v10 + 8);
        *(_DWORD *)(v10 + 8) = v11;
        if ( v11 > 0x1388 )
          *(_DWORD *)(v10 + 8) = 4 * v11;
      }
    }
    else
    {
      while ( 1 )
      {
        if ( !v8 )
        {
          dword_101A9398 = 8 * v7 + 270160792;
          goto LABEL_10;
        }
        v7 = ((_WORD)v7 + 1) & 0x7FF;
        if ( (char *)v7 == reason[1] )
          break;
        v8 = dword_101A5398[2 * v7];
        if ( v8 == v6 )
          goto LABEL_7;
      }
      dword_101A9398 = 0;
    }
  }
LABEL_10:
  v156 = FIX_DLL_KERNEL32_dll_GetTickCount();
  if ( (v4 == 26 || v4 == 30 || v4 == 3 || v4 == 4) && *(_DWORD *)(this + 275) == 8 )
  {
    v12 = v156;
  }
  else
  {
    v12 = v156;
    *(_DWORD *)(this + 1327) = v156;
  }
  v13 = *(_BYTE *)v3;
  if ( *(_BYTE *)v3 != 3 )
  {
    switch ( v13 )
    {
      case 15:
        v38 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
        if ( v38 - *(_DWORD *)(this + 655) >= 0x96 )
        {
          *(_DWORD *)(this + 655) = v38;
          *(_DWORD *)(this + 659) = 0;
        }
        else
        {
          v39 = *(_DWORD *)(this + 659) + 1;
          v26 = *(_DWORD *)(this + 659) - 6 < 0;
          *(_DWORD *)(this + 659) = v39;
          if ( !(v26 ^ __OFSUB__(v39, 7) | (v39 == 7)) )
          {
            *(_DWORD *)(this + 789) = 33;
            *(_DWORD *)(this + 56) = 1;
            off_10024608("Ext: Played kicked off for message flooding: %s\n", (const char *)(this + 375));
            reason[1] = "WARNING: You have been disconnected for message flooding";
            SendArenaMessagePlayer(p, "WARNING: You have been disconnected for message flooding", 0);
          }
        }
        if ( byte_101A5380 )
        {
          if ( !*(_DWORD *)(this + 635) )
          {
            v40 = *(_DWORD *)(this + 28);
            if ( v40 )
            {
              if ( *(_DWORD *)(v40 + 65374) )
                return;
            }
          }
        }
        if ( *(_WORD *)(v3 + 1) > 0x270Fu )
          return;
        break;
      case 21:
        if ( dword_101A5334 >= 0 )
        {
          v41 = *(_DWORD *)(this + 28);
          if ( v41 )
          {
            v42 = *(_DWORD *)(v41 + 109758);
            *(_DWORD *)(v41 + 109758) = dword_101A5334;
            PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz);
            *(_DWORD *)(*(_DWORD *)(this + 28) + 109758) = v42;
            return;
          }
        }
        break;
      case 6:
        if ( pkt_sz < 6 || !*(_DWORD *)(this + 28) )
          return;
        *(_BYTE *)(v3 + pkt_sz - 1) = 0;
        v43 = *(_BYTE *)(v3 + 1);
        if ( v43 == 4 || v43 == 5 )
        {
          if ( *(_WORD *)(v3 + 3) >= 0x400u )
            return;
          v44 = (int)*(&ZonePlayerList + *(unsigned __int16 *)(v3 + 3));
          if ( !v44 || *(_DWORD *)(v44 + 28) != *(_DWORD *)(this + 28) )
            return;
        }
        else
        {
          *(_WORD *)(v3 + 3) = 0;
        }
        if ( !*(_DWORD *)(this + 639)
          && !*(_DWORD *)(*(_DWORD *)(this + 28) + 109742)
          && (*(_BYTE *)(v3 + 2) < 0x96u || v43 != 3) )
        {
          *(_BYTE *)(v3 + 2) = 0;
        }
        break;
      case 7:
        v45 = *(_WORD *)(v3 + 9);
        v46 = abs16(v45);
        if ( v46 < 29 )
        {
          v47 = *(_DWORD *)(this + 28);
          if ( v47 && !*(_BYTE *)(v47 + v46 + 109593) && !*(_DWORD *)(this + 635) && byte_101A5383 )
          {
            v48 = (const char *)L"-";
            if ( v45 >= 0 )
              v48 = LevelFiles;
            sprintf_0(v142, "Illegal green: %s%s", v48, (const char *)dword_10024680[v46]);
            sub_100151C0(v142, this);
            v49 = *(_DWORD *)(this + 28);
            if ( !v49 || *(_DWORD *)(v49 + 109802) )
            {
              *(_DWORD *)(this + 56) = 1;
              *(_DWORD *)(this + 789) = 32;
            }
          }
          v50 = (int *)(this + 861);
          if ( *(int *)(this + 861) >= 0 )
          {
            v51 = (const char *)L"-";
            if ( *(__int16 *)(player + 9) >= 0 )
              v51 = LevelFiles;
            sprintf_0(v142, "%s picked up %s%s", (const char *)(this + 375), v51, (const char *)dword_10024680[v46]);
            reason[1] = 0;
            do
            {
              if ( *v50 < 0 )
                break;
              v157 = (int)*(&ZonePlayerList + *v50);
              if ( v157 && *(_DWORD *)(v157 + 639) )
              {
                *(_DWORD *)buf_sz = v142;
                SendMessage((struct PLAYER *)v157, v142, 0);
              }
              ++v50;
              ++reason[1];
            }
            while ( reason[1] < (char *)6 );
          }
          ++*(_DWORD *)(this + 4 * v46 + 893);
          v52 = *(_DWORD *)(this + 1009) + 1;
          *(_DWORD *)(this + 1009) = v52;
          reason[1] = (char *)v52;
          if ( byte_101A5385 )
          {
            if ( (v52 & 0xF) == 0 && v52 > 100 )
            {
              v53 = *(_DWORD *)(this + 28);
              if ( v53 )
              {
                v54 = (long double)(int)reason[1];
                *(_QWORD *)reason = *(unsigned int *)(v53 + 111602);
                v55 = 1;
                v56 = (unsigned __int8 *)(v53 + 109594);
                v57 = (int *)(this + 897);
                v58 = v54 / (long double)*(__int64 *)reason * dbl_10021A88;
                while ( 1 )
                {
                  v157 = *v57;
                  if ( v157 > 10 )
                  {
                    reason[1] = (char *)*v56;
                    v59 = (long double)(int)reason[1] * v58 / (long double)v157;
                    if ( (unsigned int)(__int64)v59 < 0x32 || (unsigned int)(__int64)v59 > 0xC8 )
                      break;
                  }
                  ++v55;
                  ++v56;
                  ++v57;
                  if ( v55 >= 0x1D )
                    goto LABEL_269;
                }
                sprintf_0(
                  v142,
                  "Abnormal green distribution: %s %d%%",
                  (const char *)dword_10024680[v55],
                  (unsigned int)(__int64)v59);
              }
            }
          }
        }
        break;
      case 24:
        v60 = *(_DWORD *)(this + 28);
        *(_DWORD *)(this + 885) = v12;
        if ( v60 && !*(_DWORD *)(v60 + 65374) )
          *(_DWORD *)(this + 1030) = v12 + 5000;
        if ( *(_BYTE *)(v3 + 1) != 8 && v60 )
        {
          v61 = *(_DWORD *)(v60 + 121111);
          if ( v61 > 0 )
          {
            v62 = *(_DWORD *)(v60 + 121115);
            if ( v62 > 0 && (*(_DWORD *)(this + 619) > v61 || *(_DWORD *)(this + 623) > v62) && !*(_DWORD *)(this + 631) )
            {
              sprintf_0(
                v141,
                "Maximum allowed screen resolution is %dx%d in this arena",
                *(_DWORD *)(v60 + 121111),
                *(_DWORD *)(v60 + 121115));
              player = (int)v141;
              SendMessage(p, v141, 0);
              return;
            }
          }
          if ( (*(_BYTE *)(v60 + 121247) || byte_101A5389)
            && *(_DWORD *)(this + 24) != 1
            && !*(_DWORD *)(this + 631)
            && !*(_DWORD *)(this + 1026) )
          {
            sprintf_0(
              v141,
              "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
            player = (int)v141;
            SendMessage(p, v141, 0);
            return;
          }
          v63 = *(_DWORD *)(v60 + 121256);
          if ( v63 )
          {
            if ( *(_DWORD *)(this + 519) < v63 && BillingConnectionStructPointer && !*(_DWORD *)(this + 635) )
            {
              sprintf_0(
                v141,
                "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
                *(_DWORD *)(v60 + 121256) / 3600);
              player = (int)v141;
              SendMessage(p, v141, 0);
              return;
            }
          }
        }
        break;
      case 5:
        *(_DWORD *)(this + 1030) = v12 + 15000;
        v64 = *(_WORD *)(v3 + 3);
        if ( v64 < 0 || v64 > 10000 )
        {
          sprintf_0(v148, "Illegal death bounty %d, changed to 100", v64);
          sub_100151C0(v148, this);
          *(_WORD *)(v3 + 3) = 100;
        }
        break;
      case 1:
        v65 = pkt_sz == 27;
        *(_BYTE *)(v3 + 25) = 0;
        v66 = !v65 || *(_BYTE *)(v3 + 26);
        v67 = (char *)(v3 + 10);
        *(_BYTE *)(this + 1034) = v66;
        sub_10003280((char *)(v3 + 10));
        v68 = *(_BYTE *)(v3 + 10);
        reason[1] = (char *)(v3 + 10);
        if ( v68 )
        {
          v157 = v3 + 11;
          do
          {
            if ( !isalnum(v68) && (*v67 != 35 || v67 != (char *)(v3 + 10)) )
            {
              v69 = strlen((const char *)v157) + 1;
              v70 = v69;
              v69 >>= 2;
              qmemcpy(reason[1], (const void *)v157, 4 * v69);
              v71 = &reason[1][4 * v69];
              --reason[1];
              qmemcpy(v71, (const void *)(v157 + 4 * v69), v70 & 3);
              v67 = reason[1];
              v3 = player;
              --v157;
            }
            v68 = *++v67;
            reason[1] = v67;
            ++v157;
          }
          while ( v68 );
        }
        v72 = (const char *)(v3 + 10);
        *(_DWORD *)(this + 1030) = v156 + 15000;
        if ( sub_100027F0((void *)(v3 + 10)) )
          *v72 = 0;
        v73 = *(_DWORD *)(this + 635);
        if ( v73 || *(_DWORD *)(this + 1026) || *(_DWORD *)(this + 24) != 1 || *(_DWORD *)(this + 100) == Scrty1Version )
        {
          v74 = *(_DWORD *)(this + 40);
          if ( !v74
            || v73
            || *(_DWORD *)(this + 1026)
            || (v75 = *(_DWORD *)(v74 + 66), v75 == 17)
            || byte_101A5386 && v75 == 1 )
          {
            if ( sub_1000AD20(byte_1003E438, v72, buf_sz, &v153)
              || (PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz), (v76 = *(_DWORD *)(this + 28)) != 0)
              && (v72 = (const char *)(v76 + 64256),
                  sub_1000AD20(byte_1003E438, (const char *)(v76 + 64256), buf_sz, &v153)) )
            {
              memset(v149, 0, sizeof(v149));
              v150 = 0;
              *(_DWORD *)&v149[1] = *(_DWORD *)buf_sz;
              *(_WORD *)&v149[7] = *(_WORD *)(player + 8);
              *(_WORD *)&v149[5] = v153;
              v149[0] = 59;
              strcpy(&v149[9], v72);
              player = (int)v149;
              PlayerSendPacket(p, v149, 29, 1);
            }
          }
          else
          {
            sub_100151C0("Incompatible network protocol attempting to enter game", this);
            *(_DWORD *)(this + 56) = 1;
            *(_DWORD *)(this + 789) = 36;
          }
        }
        else
        {
          sub_100151C0("Incompatible Continuum version attempting to enter game", this);
          *(_DWORD *)(this + 56) = 1;
          *(_DWORD *)(this + 789) = 35;
        }
        return;
      case 9:
        v77 = *(unsigned __int8 *)(v3 + 2);
        v78 = (char *)(v3 + 2);
        reason[1] = (char *)(v3 + 2);
        v65 = isalnum(v77) == 0;
        *(_BYTE *)(v3 + 33) = 0;
        v79 = !v65;
        if ( *(_BYTE *)(v3 + 2) )
        {
          v80 = (_BYTE *)(v3 + 2);
          do
          {
            if ( *v80 < 0x20u || *v80 > 0x7Eu )
            {
              *v80 = 95;
              v79 = 0;
            }
          }
          while ( *++v80 );
        }
        if ( v79 )
        {
          *(_DWORD *)(v3 + 77) = pkt_sz;
          PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz);
          if ( BillingConnectionStructPointer )
          {
            v88 = FIX_DLL_KERNEL32_dll_GetTickCount();
            if ( v88 - dword_101A94EC >= 15000 )
            {
              dword_101A94EC = v88;
              v89 = sub_10002830(byte_101A93E4);
              if ( v89 != dword_101A94E8 )
              {
                dword_101A94E8 = v89;
                off_10024608("Ext: Re-reading %s\n", byte_101A93E4);
                (*(void (__thiscall **)(int *))dword_101A93E0)(&dword_101A93E0);
              }
            }
            player = dword_101A94F0;
            pkt_sz = 0;
            if ( dword_101A94F8 > 0 )
            {
              while ( unknown_libname_69(player, v78) && strcmp((const char *)player, "*!") )
              {
                v90 = (int)++pkt_sz < dword_101A94F8;
                player += 44;
                if ( !v90 )
                  return;
                v78 = reason[1];
              }
              *(_DWORD *)(this + 1026) = 1;
            }
          }
          return;
        }
        off_10024608("Ext: Player with invalid name tying to enter: %s\n", (const char *)(v3 + 2));
        v82 = *(_DWORD *)(this + 755);
        v83 = ((-25033 * (v82 ^ HIWORD(v82))) >> 5) & 0x7FF;
        v84 = dword_101A5398[2 * v83];
        if ( v84 != v82 )
        {
          while ( v84 )
          {
            v83 = ((_WORD)v83 + 1) & 0x7FF;
            if ( v83 == (((-25033 * (v82 ^ HIWORD(v82))) >> 5) & 0x7FF) )
              goto LABEL_291;
            v84 = dword_101A5398[2 * v83];
            if ( v84 == v82 )
              goto LABEL_205;
          }
          dword_101A9398 = 8 * v83 + 270160792;
          return;
        }
        goto LABEL_205;
      case 36:
        v91 = *(unsigned __int8 *)(v3 + 2);
        reason[1] = (char *)(v3 + 2);
        v65 = isalnum(v91) == 0;
        *(_BYTE *)(v3 + 33) = 0;
        v92 = !v65;
        if ( *(_BYTE *)(v3 + 2) )
        {
          v93 = (_BYTE *)(v3 + 2);
          do
          {
            if ( *v93 < 0x20u || *v93 > 0x7Eu )
            {
              *v93 = 95;
              v92 = 0;
            }
          }
          while ( *++v93 );
        }
        if ( v92 )
        {
          if ( *(_DWORD *)(this + 40) )
          {
            if ( sub_1000AD20(byte_1003E438, "$login", &v156, &v153) )
            {
              memset(v149, 0, sizeof(v149));
              v150 = 0;
              v149[0] = 59;
              *(_DWORD *)&v149[1] = v156;
              *(_WORD *)&v149[5] = v153;
              *(_WORD *)&v149[7] = -1;
              player = (int)v149;
              PlayerSendPacket(p, v149, 29, 1);
            }
            else
            {
              *(_DWORD *)(this + 1319) = j_FIX_DLL_WSOCK32_dll_ord_0008(*(_DWORD *)(v3 + 89));
              LOBYTE(v97) = 0;
              HIBYTE(v97) = *(_WORD *)(v3 + 93);
              *(_DWORD *)(this + 1323) = HIBYTE(*(unsigned __int16 *)(v3 + 93)) | v97;
              if ( byte_101A538A || byte_101A538B && *(unsigned __int16 *)(v3 + 75) > Scrty1Version )
                *(_DWORD *)(this + 1026) = 1;
              v98 = *(_DWORD *)(this + 1026);
              buf_sz[0] = 52;
              if ( v98 )
                *(_WORD *)&buf_sz[1] = *(_WORD *)(v3 + 75);
              else
                *(_WORD *)&buf_sz[1] = Scrty1Version;
              *(_DWORD *)&buf_sz[3] = dword_4CCAE4;
              v157 = (int)buf_sz;
              PlayerSendPacket(p, buf_sz, 7, 1);
              *(_DWORD *)(v3 + 77) = pkt_sz;
              PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz);
              if ( BillingConnectionStructPointer )
              {
                v99 = FIX_DLL_KERNEL32_dll_GetTickCount();
                if ( v99 - dword_101A94EC >= 15000 )
                {
                  dword_101A94EC = v99;
                  v100 = sub_10002830(byte_101A93E4);
                  if ( v100 != dword_101A94E8 )
                  {
                    dword_101A94E8 = v100;
                    off_10024608("Ext: Re-reading %s\n", byte_101A93E4);
                    (*(void (__thiscall **)(int *))dword_101A93E0)(&dword_101A93E0);
                  }
                }
                pkt_sz = dword_101A94F0;
                v157 = 0;
                if ( dword_101A94F8 > 0 )
                {
                  while ( unknown_libname_69(pkt_sz, reason[1]) && strcmp((const char *)pkt_sz, "*!") )
                  {
                    v90 = ++v157 < dword_101A94F8;
                    pkt_sz += 44;
                    if ( !v90 )
                      goto LABEL_255;
                  }
                  *(_DWORD *)(this + 1026) = 1;
LABEL_255:
                  v3 = player;
                }
              }
              if ( *(_DWORD *)(this + 635) || *(_DWORD *)(*(_DWORD *)(this + 40) + 66) == 17 )
              {
                *(_BYTE *)(this + 1623) = *(_WORD *)(v3 + 75) >= 0x26u;
              }
              else
              {
                sub_100151C0("Invalid login packet received", this);
                *(_DWORD *)(this + 56) = 1;
                *(_DWORD *)(this + 789) = 37;
              }
            }
            return;
          }
        }
        else
        {
          off_10024608("Ext: Player with invalid name tying to enter: %s\n", (const char *)(v3 + 2));
        }
        v95 = *(_DWORD *)(this + 755);
        v83 = ((-25033 * (v95 ^ HIWORD(v95))) >> 5) & 0x7FF;
        v96 = dword_101A5398[2 * v83];
        if ( v96 != v95 )
        {
          while ( v96 )
          {
            v83 = ((_WORD)v83 + 1) & 0x7FF;
            if ( v83 == (((-25033 * (v95 ^ HIWORD(v95))) >> 5) & 0x7FF) )
              goto LABEL_291;
            v96 = dword_101A5398[2 * v83];
            if ( v96 == v95 )
              goto LABEL_205;
          }
          dword_101A9398 = 8 * v83 + 270160792;
          return;
        }
LABEL_205:
        v85 = (int *)(8 * v83 + 270160796);
        if ( v85 )
        {
          v86 = *v85;
          v87 = *(_DWORD *)(v86 + 8) + 500;
          *(_DWORD *)(v86 + 8) = v87;
          if ( v87 > 0x1388 )
            *(_DWORD *)(v86 + 8) = 4 * v87;
        }
        return;
      case 14:
        if ( pkt_sz < 4 )
        {
          sub_100151C0("Server crash attempt", this);
          return;
        }
        break;
      case 22:
        if ( !*(_DWORD *)(this + 28) )
          return;
        *(_BYTE *)(v3 + 16) = 0;
        if ( *(_DWORD *)(this + 635) )
          break;
        v101 = sub_100030E0((char *)(v3 + 1), ".lvl");
LABEL_268:
        if ( !v101 )
          return;
        break;
      case 12:
        if ( pkt_sz == 3 && *(_WORD *)(v3 + 1) )
        {
          v102 = *(unsigned __int16 *)(v3 + 1) - 1;
          if ( v102 < 0x10 )
          {
            v103 = *(_DWORD *)(this + 28);
            if ( v103 )
            {
              v104 = *(_DWORD *)(v103 + 4 * v102 + 121119);
              if ( v104 >= 0 )
              {
                v105 = 32 * v104;
                v106 = *(char **)(v105 + dword_101A9500 + 28);
                v107 = dword_101A9500 + v105;
                if ( v106 )
                {
                  v108 = *(char **)(v107 + 20);
                  v109 = *(struct CONNECTION **)(this + 40);
                  reason[1] = v108;
                  pkt_sz = (DWORD)v106;
                  HIWORD(player) = HIWORD(v109);
                  GetMapLvlRequest(v109, v106, (int)v108, 0);
                }
              }
            }
          }
          return;
        }
        break;
      case 29:
        v101 = *(char **)(this + 28);
        goto LABEL_268;
      case 11:
        if ( *(_DWORD *)(this + 24) >= 0xAu )
        {
          sub_100151C0("Server crash attempt", this);
          v110 = *(_DWORD *)(this + 755);
          v111 = ((-25033 * (v110 ^ HIWORD(v110))) >> 5) & 0x7FF;
          v112 = dword_101A5398[2 * v111];
          if ( v112 == v110 )
          {
LABEL_287:
            v113 = (int *)(8 * v111 + 270160796);
            if ( v113 )
            {
              v114 = *v113;
              v115 = *(_DWORD *)(v114 + 8) + 500;
              *(_DWORD *)(v114 + 8) = v115;
              if ( v115 > 0x1388 )
                *(_DWORD *)(v114 + 8) = 4 * v115;
            }
          }
          else
          {
            while ( 1 )
            {
              if ( !v112 )
              {
                dword_101A9398 = 8 * v111 + 270160792;
                return;
              }
              v111 = ((_WORD)v111 + 1) & 0x7FF;
              if ( v111 == (((-25033 * (v110 ^ HIWORD(v110))) >> 5) & 0x7FF) )
                break;
              v112 = dword_101A5398[2 * v111];
              if ( v112 == v110 )
                goto LABEL_287;
            }
LABEL_291:
            dword_101A9398 = 0;
          }
          return;
        }
        break;
      case 25:
        if ( pkt_sz != 97 )
        {
          sub_100151C0("Packet tampering (25)", this);
          return;
        }
        v116 = *(_DWORD *)(this + 755);
        v117 = ((-25033 * (v116 ^ HIWORD(v116))) >> 5) & 0x7FF;
        v118 = dword_101A5398[2 * v117];
        if ( v118 == v116 )
        {
LABEL_299:
          v119 = (int *)(8 * v117 + 270160796);
          if ( v119 )
          {
            v120 = *v119;
            v121 = *(_DWORD *)(v120 + 8) + 500;
            *(_DWORD *)(v120 + 8) = v121;
            if ( v121 > 0x1388 )
              *(_DWORD *)(v120 + 8) = 4 * v121;
          }
        }
        else
        {
          while ( 1 )
          {
            if ( !v118 )
            {
              dword_101A9398 = 8 * v117 + 270160792;
              goto LABEL_269;
            }
            v117 = ((_WORD)v117 + 1) & 0x7FF;
            if ( v117 == (((-25033 * (v116 ^ HIWORD(v116))) >> 5) & 0x7FF) )
              break;
            v118 = dword_101A5398[2 * v117];
            if ( v118 == v116 )
              goto LABEL_299;
          }
          dword_101A9398 = 0;
        }
        break;
      case 10:
        if ( *(_DWORD *)(this + 635) )
        {
          if ( pkt_sz >= 4 )
          {
            v122 = *(_BYTE *)(v3 + 3);
            if ( v122 != 16 && v122 != 25 )
            {
              v123 = *(_WORD *)(v3 + 1);
              if ( v123 >= 0x400u )
              {
                if ( v123 == 0xFFFF )
                {
                  v124 = *(struct ARENA **)(this + 28);
                  if ( v124 )
                  {
                    v151 = 1;
                    *(_DWORD *)buf_sz = pkt_sz - 3;
                    v157 = v3 + 3;
                    reason[1] = (char *)v124;
                    ArenaSendPacket(v124, (char *)(v3 + 3), pkt_sz - 3, 1);
                  }
                }
              }
              else
              {
                reason[1] = (char *)*(&ZonePlayerList + *(unsigned __int16 *)(v3 + 1));
                if ( reason[1] )
                {
                  *(_DWORD *)buf_sz = pkt_sz - 3;
                  v157 = v3 + 3;
                  PlayerSendPacket((PLAYER *)reason[1], (void *)(v3 + 3), pkt_sz - 3, 1);
                }
              }
            }
          }
        }
        break;
      case 4:
        *(_DWORD *)(this + 4 * *(_DWORD *)(this + 1035) + 1039) = *(_DWORD *)(v3 + 1);
        *(_DWORD *)(this + 4 * *(_DWORD *)(this + 1035) + 1167) = v12 / 10;
        *(_DWORD *)(this + 1035) = ((unsigned __int8)*(_DWORD *)(this + 1035) + 1) & 0x1F;
        return;
      case 26:
        v125 = *(_DWORD *)(this + 28);
        if ( v125 )
        {
          if ( *(_DWORD *)(this + 1026) )
            *(_DWORD *)(v3 + 9) = dword_4CBB28[1009 * *(_DWORD *)(this + 24) + 2 * *(_DWORD *)(v125 + 65332)];
          if ( pkt_sz >= 0x2E )
          {
            v126 = *(_DWORD *)(v3 + 42);
            if ( v126 != *(_DWORD *)(*(_DWORD *)(this + 28) + 121265) )
            {
              if ( v126 )
              {
                sub_100151C0("WARNING: Level checksum mismatch ", this);
                v127 = *(_DWORD *)(this + 28);
                if ( !v127 || *(_DWORD *)(v127 + 109802) )
                {
                  *(_DWORD *)(this + 56) = 1;
                  *(_DWORD *)(this + 789) = 34;
                }
              }
            }
          }
        }
        *(_DWORD *)(this + 2648) = *(__int16 *)(v3 + 40);
        break;
      case 27:
        v128 = *(_BYTE *)(v3 + 1);
        if ( *(_DWORD *)(this + 1026) && v128 == 27 )
          return;
        switch ( v128 )
        {
          case 1:
            sub_100151C0("Disconnected due low framerate", this);
            return;
          case 60:
            sub_100151C0("Timer synchronization error", this);
            return;
          case 61:
            v129 = strlen("Process debugger ") + 1;
            v130 = v129;
            v129 >>= 2;
            qmemcpy(v147, "Process debugger ", 4 * v129);
            v132 = &aProcessDebugger[4 * v129];
            v131 = &v147[4 * v129];
            LOBYTE(v129) = v130;
            v133 = pkt_sz;
            v90 = pkt_sz <= 2;
            qmemcpy(v131, v132, v129 & 3);
            if ( !v90 )
            {
              v134 = player;
              *(_BYTE *)(player + v133 - 1) = 0;
              sub_10003060(v147, (const char *)(v134 + 2), 80);
            }
            sub_100151C0(v147, this);
            v135 = *(_DWORD *)(this + 28);
            if ( !v135 || *(_DWORD *)(v135 + 109802) )
            {
              *(_DWORD *)(this + 56) = 1;
              *(_DWORD *)(this + 789) = 33;
            }
            return;
        }
        break;
      default:
        if ( v13 == 50 && pkt_sz >= 0xE && pkt_sz <= 0x5F )
        {
          v136 = (int *)(this + 1295);
          if ( *(int *)(this + 1295) < 0 )
          {
            HIWORD(player) = 55;
            pkt_sz = (DWORD)&player + 2;
            PlayerSendPacket(p, (char *)&player + 2, 2, 1);
          }
          else
          {
            v137 = *(_DWORD *)(v3 + 1);
            v144 = *(_WORD *)(this + 20);
            v143 = 56;
            v145 = v137;
            player = pkt_sz - 5;
            memcpy_0(v146, (const void *)(v3 + 5), pkt_sz - 5);
            v138 = player;
            for ( i = 0; i < 6; ++i )
            {
              if ( *v136 < 0 )
                break;
              v140 = (int)*(&ZonePlayerList + *v136);
              player = v140;
              if ( v140 && *(_DWORD *)(v140 + 639) )
              {
                reason[1] = (char *)(v138 + 7);
                pkt_sz = (DWORD)&v143;
                PlayerSendPacket((PLAYER *)player, &v143, v138 + 7, 1);
              }
              ++v136;
            }
          }
          return;
        }
        break;
    }
LABEL_269:
    PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz);
    return;
  }
  reason[1] = *(char **)(this + 28);
  if ( !reason[1] )
    return;
  v14 = *(unsigned __int16 *)(v3 + 20);
  *(_DWORD *)buf_sz = v14 & 0x1F;
  if ( (v14 & 0x1F) == 0 )
    goto LABEL_47;
  if ( !byte_101A5383 )
    goto LABEL_54;
  if ( *(_DWORD *)(this + 635) )
    goto LABEL_47;
  v15 = *(_DWORD *)(this + 275);
  v157 = v14 & 0x7F;
  if ( ((unsigned __int8)(1 << v15) & reason[1][v157 + 120983]) == 0 )
  {
    v16 = (_BYTE *)player;
    v17 = 0;
    v18 = 22;
    do
    {
      v17 ^= *v16++;
      --v18;
    }
    while ( v18 );
    if ( !v17 )
    {
LABEL_28:
      sub_10010530((_DWORD *)this, v14);
      return;
    }
    goto LABEL_47;
  }
  if ( *(_DWORD *)buf_sz != 4 && *(_DWORD *)buf_sz != 3 )
    goto LABEL_47;
  v19 = &reason[1][16 * v15 + 120839];
  if ( (v14 & 0x7C00) > *(_DWORD *)v19 || (v14 & *((_DWORD *)v19 + 1)) != 0 )
  {
    v20 = (_BYTE *)player;
    v21 = 0;
    v22 = 22;
    do
    {
      v21 ^= *v20++;
      --v22;
    }
    while ( v22 );
    if ( !v21 )
      goto LABEL_28;
  }
  if ( !dword_101A533C )
  {
LABEL_47:
    if ( byte_101A5383 )
    {
      v27 = player;
      v28 = *(unsigned __int8 *)(player + 11) & *(_DWORD *)(16 * *(_DWORD *)(this + 275)
                                                          + *(_DWORD *)(this + 28)
                                                          + 120847);
      if ( v28 )
      {
        if ( !*(_DWORD *)(this + 635) )
        {
          v29 = 0;
          v30 = (_BYTE *)player;
          v31 = 22;
          do
          {
            v29 ^= *v30++;
            --v31;
          }
          while ( v31 );
          if ( !v29 )
          {
            sub_100106E0((_DWORD *)this, v28);
            return;
          }
        }
      }
      goto LABEL_55;
    }
LABEL_54:
    v27 = player;
LABEL_55:
    if ( byte_101A537F )
    {
      v32 = *(_BYTE *)(v27 + 11);
      if ( (v32 & 0x20) != 0 && (v32 & 8) != 0 )
      {
        *(_BYTE *)(v27 + 11) = v32 & 0xF7;
        *(_BYTE *)(v27 + 10) ^= 8u;
      }
    }
    if ( *(__int16 *)(v27 + 16) < 0 )
      *(_WORD *)(v27 + 16) = 0;
    v33 = *(_DWORD *)(this + 28);
    v34 = *(_DWORD *)(v33 + 121248);
    if ( v34 && *(_DWORD *)(this + 275) != 8 )
    {
      v35 = *(_DWORD *)(this + 1030);
      if ( v35 )
      {
        v36 = v156 - v35;
        if ( v156 - v35 >= *(_DWORD *)(v33 + 121252) )
        {
          if ( (v34 & 1) != 0 )
          {
            sprintf_0(v148, "No data for %d ms", v156 - v35);
            sub_100151C0(v148, this);
          }
          if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 121248) & 2) != 0 )
          {
            v37 = FIX_DLL_KERNEL32_dll_GetTickCount();
            *(_DWORD *)(this + 885) = v37;
            *(_DWORD *)(this + 1030) = v37 + 5000;
            SetPlayerShip(p, 8);
            reason[1] = "You have been put in spectator mode due to no data (C2S)";
            SendMessage(p, "You have been put in spectator mode due to no data (C2S)", 0);
            off_10024608("Ext: No data for %d ms, put in spectator mode: %s\n", v36, (const char *)(this + 375));
          }
          if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 121248) & 4) != 0 )
          {
            *(_DWORD *)(this + 56) = 1;
            *(_DWORD *)(this + 789) = 39;
            off_10024608("Ext: No data for %d ms, kicked off: %s\n", v36, (const char *)(this + 375));
          }
        }
      }
      if ( v156 - *(_DWORD *)(this + 1030) > 0 )
        *(_DWORD *)(this + 1030) = v156;
    }
    PlayerHandleGamePacket(p, (BYTE *)player, pkt_sz);
    if ( v156 - *(_DWORD *)(this + 1327) >= dword_101A5358 )
    {
      if ( dword_101A5358 )
        *(_DWORD *)(this + 777) = 1;
    }
    return;
  }
  v23 = v156 - *(_DWORD *)(this + 889);
  if ( v23 >= *((_DWORD *)v19 + 3) )
    goto LABEL_46;
  if ( (dword_101A533C & 1) != 0 )
  {
    sprintf_0(v148, "Possible fastbombing %d", v23 / 10);
    sub_100151C0(v148, this);
    v24 = FIX_DLL_KERNEL32_dll_GetTickCount() / 0xAu;
    if ( v24 - *(_DWORD *)(this + 655) >= 0x96 )
    {
      *(_DWORD *)(this + 655) = v24;
      *(_DWORD *)(this + 659) = 0;
    }
    else
    {
      v25 = *(_DWORD *)(this + 659) + 1;
      v26 = *(_DWORD *)(this + 659) - 6 < 0;
      *(_DWORD *)(this + 659) = v25;
      if ( !(v26 ^ __OFSUB__(v25, 7) | (v25 == 7)) )
      {
        *(_DWORD *)(this + 789) = 33;
        *(_DWORD *)(this + 56) = 1;
      }
    }
  }
  if ( (dword_101A533C & 4) != 0 )
  {
    *(_DWORD *)(this + 789) = 34;
    *(_DWORD *)(this + 56) = 1;
  }
  *(_DWORD *)(this + 889) = v156;
  if ( (dword_101A533C & 2) == 0 )
  {
LABEL_46:
    *(_DWORD *)(this + 889) = v156;
    goto LABEL_47;
  }
}
// 100113EE: conditional instruction was optimized away because of 'eax.4!=0'
// 10011459: conditional instruction was optimized away because of 'eax.4!=0'
// 4CCAE4: using guessed type int dword_4CCAE4;
// 1001598A: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0008(_DWORD);
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10021998: using guessed type int dword_10021998[];
// 10021A88: using guessed type double dbl_10021A88;
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 10024680: using guessed type int dword_10024680[];
// 100258A0: using guessed type wchar_t asc_100258A0[2];
// 101A5334: using guessed type int dword_101A5334;
// 101A533C: using guessed type int dword_101A533C;
// 101A5358: using guessed type int dword_101A5358;
// 101A537F: using guessed type char byte_101A537F;
// 101A5380: using guessed type char byte_101A5380;
// 101A5383: using guessed type char byte_101A5383;
// 101A5385: using guessed type char byte_101A5385;
// 101A5386: using guessed type char byte_101A5386;
// 101A5388: using guessed type char byte_101A5388;
// 101A5389: using guessed type char byte_101A5389;
// 101A538A: using guessed type char byte_101A538A;
// 101A538B: using guessed type char byte_101A538B;
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;
// 101A93E0: using guessed type int dword_101A93E0;
// 101A94E8: using guessed type int dword_101A94E8;
// 101A94EC: using guessed type int dword_101A94EC;
// 101A94F0: using guessed type int dword_101A94F0;
// 101A94F8: using guessed type int dword_101A94F8;
// 101A9500: using guessed type int dword_101A9500;
// 101C8060: using guessed type int Scrty1Version;
// 10010B00: using guessed type char var_90[16];

//----- (100122C0) --------------------------------------------------------
_DWORD *__thiscall sub_100122C0(_BYTE *this)
{
  _BYTE *v1; // ebx
  _DWORD *v2; // eax
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // ebp
  _DWORD *v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  _DWORD *v14; // ecx
  _DWORD *result; // eax
  int v16; // esi
  int v17; // edx
  _BOOL1 v18; // [esp+12h] [ebp-Eh]
  _BOOL1 v19; // [esp+13h] [ebp-Dh]
  char v20; // [esp+14h] [ebp-Ch]
  unsigned int v22; // [esp+1Ch] [ebp-4h]

  v1 = this;
  v18 = this[109603] != 0;
  v19 = this[109609] != 0;
  v2 = this + 109982;
  v3 = 24;
  do
  {
    v4 = v2[1];
    if ( v4 == 10 && *v2 )
    {
      v18 = 1;
    }
    else if ( v4 == 16 && *v2 )
    {
      v19 = 1;
    }
    v2 += 6;
    --v3;
  }
  while ( v3 );
  v5 = 0;
  v22 = 0;
  do
  {
    v6 = v5 & 0x1F;
    v7 = ((v5 >> 5) & 3) + 1;
    v20 = 0;
    v8 = 1;
    v9 = v1 + 108322;
    do
    {
      if ( v6 > 2 )
      {
        if ( v6 > 4 )
        {
          switch ( v6 )
          {
            case 5u:
              if ( *((_BYTE *)v9 - 15) || *((_BYTE *)v9 - 8) )
                goto LABEL_42;
              break;
            case 6u:
              if ( *((_BYTE *)v9 - 13) || *((_BYTE *)v9 - 3) )
                goto LABEL_42;
              break;
            case 7u:
              if ( *((_BYTE *)v9 - 14) || *((_BYTE *)v9 - 7) )
                goto LABEL_42;
              break;
            default:
              if ( v6 == 8 && (*((_BYTE *)v9 - 12) || *((_BYTE *)v9 - 4)) )
                goto LABEL_42;
              break;
          }
        }
        else
        {
          v12 = *v9;
          if ( (*v9 & 0xC00000u) < ((*v9 >> 2) & 0xC00000u) )
            v13 = HIBYTE(v12);
          else
            v13 = v12 >> 22;
          v1 = this;
          if ( v7 <= (v13 & 3) + (this[109583] != 0) && (v6 == 3 || v19) )
          {
LABEL_42:
            v20 |= v8;
            goto LABEL_43;
          }
        }
      }
      else
      {
        v10 = *v9;
        if ( (*v9 & 0xC0000u) < ((*v9 >> 2) & 0xC0000u) )
          v11 = v10 >> 20;
        else
          v11 = v10 >> 18;
        v1 = this;
        if ( v7 <= (v11 & 3) + (this[109582] != 0) && (v6 == 1 || v18) )
          goto LABEL_42;
      }
LABEL_43:
      v8 *= 2;
      v9 += 36;
    }
    while ( v8 <= 0x80 );
    v1[v22 + 120983] = v20;
    v5 = v22 + 1;
    v22 = v5;
  }
  while ( v5 < 0x80 );
  memset(v1 + 120839, 0, 0x90u);
  v14 = v1 + 108322;
  result = v1 + 120839;
  v16 = 8;
  do
  {
    if ( !v18 )
      result[1] |= 0x80u;
    if ( !*((_BYTE *)v14 - 16) )
      result[1] |= 0x8000u;
    *result = (*v14 & 0x1F) << 10;
    result[2] = 64;
    if ( (*v14 & 0x3000) == 0 )
      result[2] = 65;
    if ( (*v14 & 0xC00) == 0 )
      result[2] |= 2u;
    if ( (*v14 & 0xC000) == 0 )
      result[2] |= 4u;
    if ( (*v14 & 0x30000) == 0 )
      result[2] |= 8u;
    v17 = 10 * *((__int16 *)v14 - 20) - dword_101A5340;
    v14 += 36;
    result[3] = v17;
    result += 4;
    --v16;
  }
  while ( v16 );
  return result;
}
// 101A5340: using guessed type int dword_101A5340;

//----- (10012520) --------------------------------------------------------
unsigned int __thiscall sub_10012520(int this)
{
  int *v2; // ecx
  int v3; // edx
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int result; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edi
  int *v10; // ebx
  int v11; // esi
  int v12; // [esp+10h] [ebp-324h]
  int v13[200]; // [esp+14h] [ebp-320h] BYREF

  memset(v13, 0, sizeof(v13));
  if ( *(int *)(this + 65292) > 0 )
  {
    v2 = (int *)(this + 64288);
    v3 = *(_DWORD *)(this + 65292);
    do
    {
      v4 = *v2;
      if ( *v2 )
      {
        if ( *(_DWORD *)(v4 + 275) != 8 )
        {
          v5 = *(_DWORD *)(v4 + 279);
          if ( v5 < 0xC8 )
            ++v13[v5];
        }
      }
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  v6 = *(_DWORD *)(this + 109378);
  v12 = 1000000;
  if ( v6 )
    result = sub_100174D1() % v6;
  else
    result = 0;
  v8 = 0;
  v9 = 10000;
  v10 = v13;
  do
  {
    if ( v8 >= *(_DWORD *)(this + 109378) )
      break;
    v11 = *v10;
    if ( *v10 < *(unsigned __int8 *)(this + 109567) )
    {
      if ( v8 >= *(_DWORD *)(this + 109706) )
        v11 += v9;
      if ( v11 < v12 )
      {
        v12 = v11;
        result = v8;
      }
    }
    v9 += 100;
    ++v8;
    ++v10;
  }
  while ( v9 < 0x7530 );
  return result;
}

//----- (100125F0) --------------------------------------------------------
unsigned int __thiscall sub_100125F0(char *FileName)
{
  void *v2; // ecx
  int v3; // esi
  int v4; // eax
  unsigned __int8 *v5; // ebx
  _BYTE *v6; // edx
  unsigned int result; // eax
  _DWORD v8[4]; // [esp-Ch] [ebp-28h] BYREF
  int v9; // [esp+4h] [ebp-18h] BYREF
  int a2[2]; // [esp+8h] [ebp-14h] BYREF
  int v11; // [esp+18h] [ebp-4h]

  v2 = (void *)*((_DWORD *)FileName + 7);
  a2[1] = (int)v8;
  v8[3] = FileName;
  if ( v2 )
  {
    sub_10012DA0(v2);
    sub_10002D70(*((_DWORD *)FileName + 7));
    *((_DWORD *)FileName + 7) = 0;
  }
  *((_DWORD *)FileName + 5) = 0;
  *((_DWORD *)FileName + 7) = 0;
  *((_DWORD *)FileName + 6) = 0;
  v11 = 0;
  off_10024608("Ext: Loading level file: %s\n", FileName);
  a2[0] = -1;
  LOBYTE(v11) = 1;
  ReadScrty1File(a2, FileName, 1, 3);
  v3 = sub_10001D90(a2);
  *((_DWORD *)FileName + 5) = v3 + 17;
  v4 = sub_10002CC0(v3 + 17);
  v5 = (unsigned __int8 *)(v4 + 17);
  *((_DWORD *)FileName + 7) = v4;
  ReadScrty1FileOffset(a2, v4 + 17, v3);
  v9 = -1;
  sub_100010E0(&v9, v5, v3);
  *((_DWORD *)FileName + 4) = ~v9;
  *((_DWORD *)FileName + 6) = sub_10002090(a2);
  sub_10001A50(a2);
  v6 = (_BYTE *)*((_DWORD *)FileName + 7);
  result = strlen(FileName) + 1;
  qmemcpy(v6 + 1, FileName, result);
  *v6 = 42;
  return result;
}
// 10024608: using guessed type int (*off_10024608)(const char *, ...);

//----- (10012730) --------------------------------------------------------
int __thiscall sub_10012730(void *this)
{
  int result; // eax

  result = sub_10002830(this);
  if ( result != *((_DWORD *)this + 6) )
    result = sub_100125F0((char *)this);
  return result;
}

//----- (10012750) --------------------------------------------------------
PLAYER *__thiscall CtmPlayerJustConnected(PLAYER *p)
{
  PLAYER *v1; // ebx
  char *v2; // esi
  const CHAR *v3; // ebp
  int v4; // eax
  int (*v5)(void); // esi
  bool v6; // eax
  char *v7; // esi
  int v8; // eax
  char *v9; // edi
  char *v10; // eax
  char *v11; // ebx
  __int32 v12; // edi
  char *v13; // eax
  _BYTE *v14; // eax
  void *v15; // ebx
  char *v16; // edi
  const char *v17; // ebp
  int v18; // eax
  int v19; // esi
  int v20; // edi
  int v21; // edx
  int v22; // esi
  unsigned __int8 *v23; // edx
  unsigned int v24; // ecx
  int v25; // esi
  unsigned __int8 v26; // al
  int v28; // [esp+4h] [ebp-1C8h]
  int v29; // [esp+8h] [ebp-1C4h]
  int v30; // [esp+8h] [ebp-1C4h]
  char *v31; // [esp+Ch] [ebp-1C0h]
  unsigned __int8 v32; // [esp+10h] [ebp-1BCh]
  int v33[2]; // [esp+14h] [ebp-1B8h] BYREF
  const char *KeyName; // [esp+1Ch] [ebp-1B0h] BYREF
  const char *v35; // [esp+20h] [ebp-1ACh]
  int v36; // [esp+24h] [ebp-1A8h] BYREF
  const CHAR *v37; // [esp+28h] [ebp-1A4h]
  const char *v38; // [esp+2Ch] [ebp-1A0h]
  const char *v39; // [esp+30h] [ebp-19Ch]
  int v40; // [esp+34h] [ebp-198h]
  const CHAR *v41; // [esp+38h] [ebp-194h]
  int ReturnedString[2]; // [esp+3Ch] [ebp-190h] BYREF
  LPCSTR v43; // [esp+44h] [ebp-188h] BYREF
  LPCSTR v44; // [esp+48h] [ebp-184h]
  LPCSTR v45; // [esp+4Ch] [ebp-180h]
  LPSTR v46; // [esp+50h] [ebp-17Ch]
  DWORD v47; // [esp+54h] [ebp-178h]
  LPCSTR v48; // [esp+58h] [ebp-174h]
  const char *v49; // [esp+5Ch] [ebp-170h]
  const char *v50; // [esp+60h] [ebp-16Ch]
  int v51; // [esp+64h] [ebp-168h]
  const CHAR *v52; // [esp+68h] [ebp-164h]
  PLAYER *v53; // [esp+8Ch] [ebp-140h]

  v1 = p;
  v2 = &p[90].field_44[152];
  v3 = &p[83].field_18F[124];
  v53 = p;
  off_1002460C(&p[83].field_18F[124], &p[90].field_44[152]);
  if ( !v1[48].field_18F[65] || !CustomArenaMode )
    *(_DWORD *)&v1[83].field_341[458] = *(_DWORD *)v2;
  v4 = dword_1006507C;
  if ( !dword_1006507C )
  {
    v4 = FIX_DLL_KERNEL32_dll_GetTickCount();
    dword_1006507C = v4;
  }
  v5 = (int (*)(void))FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
  *(_DWORD *)&v1[91].field_117[43] = v4;
  ++dword_1006507C;
  v52 = v3;
  v51 = 0;
  v50 = "SaveSpawnScore";
  v49 = "Misc";
  *(_DWORD *)&v1[90].field_44[144] = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(
                                       "Misc",
                                       "MaxPlayers",
                                       dwArena_ArenaMaxPlayers,
                                       v3);
  v6 = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(v49, v50, v51, v52) && v1[48].field_18F[65];
  v48 = v3;
  v47 = 159;
  v46 = &v1[90].field_44[156];
  v45 = LevelFiles;
  v44 = "GreetMessage";
  v43 = "Misc";
  *(_DWORD *)&v1[90].field_44[148] = v6;
  GetPrivateProfileStringA_0(v43, v44, v45, v46, v47, v48);
  v44 = v3;
  v43 = 0;
  ReturnedString[1] = (int)"MaxYRes";
  ReturnedString[0] = (int)"Misc";
  *(_DWORD *)&v1[91].field_44[104] = ((int (__cdecl *)(const char *, const char *, _DWORD, const CHAR *))v5)(
                                       "Misc",
                                       "MaxXRes",
                                       0,
                                       v3);
  v41 = v3;
  v40 = 0;
  v39 = "ContinuumOnly";
  v38 = "Misc";
  *(_DWORD *)&v1[91].field_44[108] = v5();
  v37 = v3;
  v36 = 0;
  v35 = "MinUsage";
  KeyName = "Misc";
  v1[91].field_117[29] = ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(v38, v39, v40, v41) != 0;
  v33[1] = (int)v3;
  v33[0] = 0;
  *(_DWORD *)&v1[91].field_117[38] = 3600
                                   * ((int (__cdecl *)(const char *, const char *, int, const CHAR *))v5)(
                                       KeyName,
                                       v35,
                                       v36,
                                       v37);
  v29 = (int)v3;
  *(_DWORD *)&v1[91].field_117[30] = ((int (__cdecl *)(const char *, const char *))v5)("Latency", "C2SNoDataAction");
  *(_DWORD *)&v1[91].field_117[34] = 10 * ((int (__cdecl *)(const char *, const char *))v5)("Latency", "C2SNoDataTime");
  v1[91].field_117[42] = ((int (__cdecl *)(const char *, const char *, _DWORD, const CHAR *))v5)(
                           "Misc",
                           "StartInSpec",
                           0,
                           v3) != 0;
  v7 = &v1[90].player_name[9];
  memset(&v1[90].player_name[9], 0, 0x34Cu);
  v1[90].field_341[395] = 0;
  v8 = 0;
  do
  {
    sprintf_0((char *)&KeyName, "PeriodicMessage%d", v8);
    GetPrivateProfileStringA_0("Misc", (LPCSTR)&KeyName, LevelFiles, (LPSTR)ReturnedString, 0xFFu, v3);
    if ( LOBYTE(ReturnedString[0]) )
    {
      v9 = sub_10003260(ReturnedString);
      *(_DWORD *)(v7 + 161) = 60000 * atol_1(v9);
      v10 = sub_10003240(v9);
      v11 = sub_10003260(v10);
      v12 = 60000 * atol_1(v11);
      v13 = sub_10003240(v11);
      v14 = sub_10003260(v13);
      v15 = v14;
      v7[160] = *v14 == 42;
      if ( *v14 == 42 )
      {
        v15 = v14 + 1;
        v7[160] = 1;
      }
      else
      {
        v7[160] = 0;
      }
      *(_DWORD *)(v7 + 165) = v12 - *(_DWORD *)(v7 + 161) + FIX_DLL_KERNEL32_dll_GetTickCount();
      strncpyt(v7, v15, 160);
      if ( *(_DWORD *)(v7 + 161) && *v7 )
        v7 += 169;
      v1 = 0;
    }
    v8 = ++v29;
  }
  while ( v29 < 5 );
  sub_100122C0(v1);
  memset(&v1[91].field_44[112], 0xFFu, 0x40u);
  GetPrivateProfileStringA_0("Misc", "LevelFiles", LevelFiles, (LPSTR)&v43, 0xFFu, v3);
  v30 = 0;
  if ( sub_10002E30(v33, 16, (char *)&v43, 44, 0) )
  {
    v16 = &v1[91].field_EA[10];
    v31 = &v1[91].field_EA[10];
    do
    {
      v17 = (const char *)v33;
      v32 = 0;
      if ( LOBYTE(v33[0]) == 43 )
      {
        v32 = 1;
        v17 = (char *)v33 + 1;
      }
      if ( *v17 )
      {
        v18 = dword_101A9508;
        v19 = 0;
        v28 = 0;
        if ( dword_101A9508 <= 0 )
          goto LABEL_30;
        while ( unknown_libname_69(v19 + dword_101A9500, v17) )
        {
          v18 = dword_101A9508;
          v19 += 32;
          if ( ++v28 >= dword_101A9508 )
            goto LABEL_30;
        }
        v18 = dword_101A9508;
        if ( v28 < dword_101A9508 )
        {
          v22 = dword_101A9500 + 32 * v28;
          if ( sub_10002830((void *)v22) != *(_DWORD *)(v22 + 24) )
            sub_100125F0((char *)v22);
        }
        else
        {
LABEL_30:
          v20 = v18;
          if ( v18 >= dword_101A9504 )
          {
            sub_10002D10(&dword_101A9500, 32 * (v18 + 32));
            dword_101A9504 += 32;
            v18 = dword_101A9508;
          }
          memcpy_0(
            (void *)(dword_101A9500 + 32 * (v20 + 1)),
            (const void *)(32 * v20 + dword_101A9500),
            32 * (v18 + 0x7FFFFFF * v20));
          ++dword_101A9508;
          memcpy_0((void *)(32 * v20 + dword_101A9500), &v36, 0x20u);
          v21 = 32 * v20 + dword_101A9500;
          strcpy((char *)v21, v17);
          *(_DWORD *)(v21 + 20) = 0;
          *(_DWORD *)(v21 + 28) = 0;
          sub_100125F0((char *)v21);
          v16 = v31;
        }
        *((_DWORD *)v16 - 16) = v28;
        *(_DWORD *)v16 = v32;
      }
      ++v30;
      v16 += 4;
      v31 = v16;
    }
    while ( sub_10002E30(v33, 16, (char *)&v43, 44, v30) );
  }
  v23 = *(unsigned __int8 **)&v1[90].field_44[140];
  v24 = -1;
  v25 = 0x100000;
  do
  {
    v26 = *v23;
    if ( *v23 && (v26 < 0xA1u || v26 == 0xAB) )
      v24 = dword_1002122C[*v23 ^ (unsigned __int8)v24] ^ (v24 >> 8);
    ++v23;
    --v25;
  }
  while ( v25 );
  *(_DWORD *)&v1[91].field_117[47] = v24;
  return v1;
}
// 4393A0: using guessed type int dwArena_ArenaMaxPlayers;
// 4D58B0: using guessed type int CustomArenaMode;
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100210B8: using guessed type int FIX_DLL_KERNEL32_dll_GetPrivateProfileIntA;
// 1002460C: using guessed type int (__cdecl *off_1002460C)(_DWORD, _DWORD);
// 1006507C: using guessed type int dword_1006507C;
// 101A9500: using guessed type int dword_101A9500;
// 101A9504: using guessed type int dword_101A9504;
// 101A9508: using guessed type int dword_101A9508;

//----- (10012C40) --------------------------------------------------------
void __thiscall sub_10012C40(int this, PLAYER *player)
{
  char *v3; // edi
  unsigned int v4; // ecx
  char v5; // al
  char *v6; // edi
  char *v7; // esi
  int v8; // eax
  int *v9; // ecx
  _DWORD *v10; // ebx
  int v11; // edx
  unsigned int v12; // ecx
  char v13; // al
  _DWORD *v14; // edi
  const void *v15; // esi
  int v16; // eax
  _BOOL1 v17; // cf
  int v18; // eax
  int v19[106]; // [esp+0h] [ebp-1BCh] BYREF
  char v20; // [esp+1A8h] [ebp-14h]
  int v21; // [esp+1ACh] [ebp-10h]
  void *buf; // [esp+1B0h] [ebp-Ch]
  int v23; // [esp+1B4h] [ebp-8h]
  int buf_sz; // [esp+1B8h] [ebp-4h]

  memset(v19, 0, sizeof(v19));
  v20 = 0;
  v3 = (char *)(this + 111086);
  v4 = strlen((const char *)(this + 111086)) + 1;
  v5 = v4;
  v4 >>= 2;
  qmemcpy((char *)v19 + 1, v3, 4 * v4);
  v7 = &v3[4 * v4];
  v6 = (char *)&v19[v4] + 1;
  LOBYTE(v4) = v5;
  v8 = *(_DWORD *)(this + 111614);
  qmemcpy(v6, v7, v4 & 3);
  *(int *)((char *)&v19[4] + 1) = *(_DWORD *)(this + 111618);
  v9 = (int *)(this + 121119);
  v23 = 25;
  *(int *)((char *)&v19[5] + 1) = v8;
  v21 = 0;
  v10 = (int *)((char *)&v19[10] + 1);
  buf_sz = this + 121119;
  do
  {
    if ( *v9 < 0 )
      break;
    v11 = dword_101A9500 + 32 * *v9;
    if ( player->field_341[201] || !v9[16] )
    {
      v12 = strlen((const char *)v11) + 1;
      v13 = v12;
      v12 >>= 2;
      buf = v10 - 4;
      qmemcpy(v10 - 4, (const void *)v11, 4 * v12);
      v15 = (const void *)(v11 + 4 * v12);
      v14 = &v10[v12 - 4];
      LOBYTE(v12) = v13;
      v16 = v23;
      qmemcpy(v14, v15, v12 & 3);
      *v10 = *(_DWORD *)(v11 + 16);
      v9 = (int *)buf_sz;
      v10[1] = *(_DWORD *)(v11 + 20);
      v23 = v16 + 24;
    }
    ++v9;
    v10 += 6;
    v17 = (unsigned int)++v21 < 0x10;
    buf_sz = (int)v9;
  }
  while ( v17 );
  v18 = *(_DWORD *)&player->field_44[32];
  LOBYTE(v19[0]) = 41;
  if ( v18 < 37 || v18 == 134 )
    buf_sz = 21;
  else
    buf_sz = v23;
  buf = v19;
  PlayerSendPacket(player, v19, buf_sz, 1);
  if ( dwAdvertise_SendMode == 3 || dwAdvertise_SendMode == 1 )
    SendAdvertisement(player, 1);
}
// 4327A0: using guessed type int dwAdvertise_SendMode;
// 101A9500: using guessed type int dword_101A9500;

//----- (10012DA0) --------------------------------------------------------
int __thiscall sub_10012DA0(void *this)
{
  int result; // eax
  int v2; // ebx
  int v3; // esi
  void **v4; // edi
  char *v5; // ebp
  _BOOL1 v6; // cc
  unsigned int v7; // [esp+0h] [ebp-10h]
  int *v8; // [esp+4h] [ebp-Ch]
  int v9; // [esp+8h] [ebp-8h]

  result = ZonePlayerCount;
  v9 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v8 = ZonePlayers;
    do
    {
      v2 = 0;
      if ( *v8 )
      {
        v3 = *(_DWORD *)(*v8 + 40);
        if ( v3 )
        {
          if ( *(_DWORD *)(v3 + 3174) )
          {
            v7 = 0;
            v4 = (void **)(v3 + 3094);
            v5 = (char *)(v3 + 3114);
            do
            {
              if ( *v4 == this )
              {
                memcpy_0(v4, v5, 60 - v2);
                v2 -= 20;
                v5 -= 20;
                --*(_DWORD *)(v3 + 3174);
                --v7;
                v4 -= 5;
              }
              v2 += 20;
              v5 += 20;
              v4 += 5;
              ++v7;
            }
            while ( v7 < *(_DWORD *)(v3 + 3174) );
          }
        }
      }
      result = v9 + 1;
      v6 = ++v9 < ZonePlayerCount;
      ++v8;
    }
    while ( v6 );
  }
  return result;
}
// 10012DEB: conditional instruction was optimized away because of 'eax.4!=0'
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;

//----- (10012E80) --------------------------------------------------------
int __stdcall sub_10012E80(void *memory)
{
  sub_10012DA0(memory);
  return off_10024618(memory);
}
// 10024618: using guessed type int (__cdecl *off_10024618)(_DWORD);

//----- (10012EA0) --------------------------------------------------------
// Player.JoinArena()
int __thiscall Fix_44(PLAYER *p, ARENA *arena)
{
  _BOOL1 v2; // zf
  int result; // eax
  int v4[7]; // [esp+0h] [ebp-20h] BYREF
  PLAYER *player; // [esp+1Ch] [ebp-4h]

  *(_WORD *)((char *)v4 + 1) = p->field_14;
  v2 = p->dwClientVersion == 1;
  player = p;
  LOBYTE(v4[0]) = 1;
  if ( v2 && *(int *)&p->field_44[32] >= 37 )
  {
    strcpy((char *)v4 + 3, (const char *)(p->lpCurrentArena + 64256));
    v4[6] = (int)v4;
    result = PlayerSendPacket(player, v4, strlen((const char *)v4 + 3) + 4, 1);
  }
  else
  {
    v4[5] = (int)v4;
    result = PlayerSendPacket(player, v4, 3, 1);
  }
  return result;
}

//----- (10012F40) --------------------------------------------------------
int __thiscall Fix_10(PLAYER *this)
{
  int v2; // eax
  int (*v3)(void); // ebx
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v15; // cl
  char *v16; // eax
  int v17; // eax
  int v18; // edi
  __int16 v19; // ax
  int v20; // ecx
  int result; // eax
  char v22[4]; // [esp+0h] [ebp-108h] BYREF
  char *msg; // [esp+100h] [ebp-8h]
  PLAYER *player; // [esp+104h] [ebp-4h]

  player = this;
  v2 = unknown_libname_69(this->player_name, "^banned");
  v3 = FIX_DLL_KERNEL32_dll_GetTickCount;
  if ( v2 )
  {
    v5 = this->lpCurrentArena;
    if ( v5 )
    {
      v6 = *(_DWORD *)(v5 + 121111);
      if ( v6 <= 0 || (v7 = *(_DWORD *)(v5 + 121115), v7 <= 0) || this->dwXRes <= v6 && this->dwYRes <= v7 )
      {
        if ( (*(_BYTE *)(v5 + 121247) || byte_101A5389) && this->dwClientVersion != 1 )
        {
          v9 = FIX_DLL_KERNEL32_dll_GetTickCount();
          *(_DWORD *)&this->field_341[52] = v9;
          *(_DWORD *)&this->field_341[197] = v9 + 5000;
          SetPlayerShip(player, 8);
          sprintf_0(
            v22,
            "This arena is Continuum-only. Please get Continuum client from http://www.subspace.net to play here");
          msg = v22;
          SendMessage(player, v22, 0);
        }
        else
        {
          v10 = *(_DWORD *)(v5 + 121256);
          if ( v10 && *(_DWORD *)&this->field_18F[120] < v10 && BillingConnectionStructPointer )
          {
            v11 = FIX_DLL_KERNEL32_dll_GetTickCount();
            *(_DWORD *)&this->field_341[52] = v11;
            *(_DWORD *)&this->field_341[197] = v11 + 5000;
            SetPlayerShip(player, 8);
            sprintf_0(
              v22,
              "To play in this arena you need at least %d hours of usage. Type ?usage to see your current usage",
              *(_DWORD *)(this->lpCurrentArena + 121256) / 3600);
            msg = v22;
            SendMessage(player, v22, 0);
          }
          else if ( *(_BYTE *)(v5 + 121260) )
          {
            v12 = FIX_DLL_KERNEL32_dll_GetTickCount();
            *(_DWORD *)&this->field_341[52] = v12;
            *(_DWORD *)&this->field_341[197] = v12 + 5000;
            SetPlayerShip(player, 8);
          }
        }
      }
      else
      {
        v8 = FIX_DLL_KERNEL32_dll_GetTickCount();
        *(_DWORD *)&this->field_341[52] = v8;
        *(_DWORD *)&this->field_341[197] = v8 + 5000;
        SetPlayerShip(player, 8);
        sprintf_0(
          v22,
          "Maximum allowed screen resolution is %dx%d in this arena",
          *(_DWORD *)(this->lpCurrentArena + 121111),
          *(_DWORD *)(this->lpCurrentArena + 121115));
        msg = v22;
        SendMessage(player, v22, 0);
      }
    }
  }
  else
  {
    *(_DWORD *)&this->field_2B7[52] = 1;
    this->bIsSilenced = 1;
    v4 = v3();
    *(_DWORD *)&this->field_341[52] = v4;
    *(_DWORD *)&this->field_341[197] = v4 + 5000;
    SetPlayerShip(player, 8);
  }
  if ( this->field_341[180] )
    this->bWaveMessages = 1;
  v13 = v3();
  *(_DWORD *)&this->field_341[52] = v13;
  *(_DWORD *)&this->field_341[56] = v13 - 1000000;
  memset(&this->field_341[28], 0xFFu, 0x18u);
  memset(&this->field_341[462], 0xFFu, 0x18u);
  v14 = this->lpCurrentArena;
  if ( v14 )
  {
    v15 = *(_BYTE *)(v14 + 119834);
    v16 = (char *)(v14 + 119834);
    if ( v15 )
    {
      msg = v16;
      SendMessage(player, v16, 0);
    }
  }
  memset(&this->field_341[60], 0, 0x74u);
  *(_DWORD *)&this->field_341[176] = 0;
  v17 = this->lpCurrentArena;
  if ( v17 )
  {
    *(_DWORD *)&this->field_341[189] = *(_DWORD *)(v17 + 109874);
    v18 = MiscKeepAliveDelay;
    *(_DWORD *)&this->field_341[181] = MiscKeepAliveDelay;
    v19 = *(_WORD *)(v17 + 109544);
    if ( v19 > 200 )
    {
      v20 = v19 - 20;
      if ( v18 > v20 / 3 )
        *(_DWORD *)&this->field_341[181] = v20 / 3;
    }
  }
  *(_DWORD *)&this->field_341[197] = v3() + 15000;
  result = -1;
  *(_DWORD *)&this[1].field_117[11] = 0;
  *(_DWORD *)&this->field_44[16] = -1;
  *(_DWORD *)&this->field_44[12] = -1;
  return result;
}
// 10013033: conditional instruction was optimized away because of 'eax.4!=0'
// 100130A4: conditional instruction was optimized away because of 'eax.4!=0'
// 10013132: conditional instruction was optimized away because of 'eax.4!=0'
// 4B0618: using guessed type int MiscKeepAliveDelay;
// 1001FD00: using guessed type _DWORD __cdecl unknown_libname_69(_DWORD, _DWORD);
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 101A5389: using guessed type char byte_101A5389;

//----- (10013250) --------------------------------------------------------
int __thiscall sub_10013250(int this)
{
  PLAYER *v1; // ebx
  int result; // eax
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  __int16 *v7; // esi
  int v8; // edx
  unsigned __int16 v9; // ax
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // di
  __int16 v13; // dx
  int v14; // ebx
  int v15; // edx
  unsigned __int16 v16; // cx
  int v17; // ecx
  unsigned __int16 *v18; // ecx
  __int16 v19; // bx
  int v20; // edx
  unsigned __int16 v21; // cx
  unsigned int v22; // ecx
  int v23; // ecx
  int *v24; // esi
  unsigned __int16 v25; // ax
  unsigned __int16 v26; // ax
  __int16 v27; // cx
  __int16 v28; // di
  _WORD *v29; // ecx
  unsigned __int16 v30; // dx
  __int16 v31; // bx
  unsigned __int16 v32; // dx
  __int16 v33; // bx
  int v34; // edx
  int v35; // ebx
  int v36; // edx
  unsigned __int16 v37; // cx
  int v38; // ecx
  int v39; // ecx
  unsigned int v40; // ecx
  _BYTE v41[96]; // [esp+0h] [ebp-DCh] BYREF
  _BYTE v42[88]; // [esp+60h] [ebp-7Ch] BYREF
  _BYTE *v43; // [esp+B8h] [ebp-24h]
  int v44; // [esp+BCh] [ebp-20h]
  int v45; // [esp+C0h] [ebp-1Ch]
  int v46; // [esp+C4h] [ebp-18h]
  int v47; // [esp+C8h] [ebp-14h]
  PLAYER *player; // [esp+CCh] [ebp-10h]
  void *buf; // [esp+D0h] [ebp-Ch]
  char v50; // [esp+D7h] [ebp-5h]
  int buf_sz; // [esp+D8h] [ebp-4h]

  v1 = (PLAYER *)this;
  result = *(_DWORD *)(this + 1619);
  v3 = 0;
  player = (PLAYER *)this;
  if ( result )
  {
    v4 = FIX_DLL_KERNEL32_dll_GetTickCount();
    v5 = *(_DWORD *)&v1[1].field_117[11];
    v6 = v4 / 1024;
    result = 0;
    v50 = v6;
    v45 = 0;
    v46 = 0;
    v44 = 0;
    if ( v5 )
    {
      v47 = (int)&v41[1];
      v43 = &v42[1];
      v7 = &v1[1].field_14;
      while ( 1 )
      {
        if ( *((_BYTE *)v7 - 13) == 5 )
        {
          if ( (v7[3] & 0x1F) != 0 )
          {
            ++*(_DWORD *)&v1->field_117[8];
            v8 = *((unsigned __int8 *)v7 - 14);
            buf = (char *)v7 - 13;
            buf_sz = v8;
            PlayerSendPacket(player, (char *)v7 - 13, v8, 0);
          }
          else if ( (*(_BYTE *)v7 & 0x40) == 0
                 && (v9 = *(__int16 *)((char *)v7 - 9), buf = (void *)v9, v9 <= 0x3FFFu)
                 && (v10 = v7[1], (unsigned __int16)v10 <= 0x3FFFu)
                 && (v11 = *(__int16 *)((char *)v7 - 3), v11 <= 0x1FFF)
                 && v11 >= -8191
                 && (v12 = *(__int16 *)((char *)v7 - 7), v12 <= 0x1FFF)
                 && v12 >= -8191
                 && v1[1].field_117[15]
                 && *((_BYTE *)v7 - 14) == 21
                 && (buf_sz = *(unsigned __int16 *)((char *)v7 - 5), v1[1].field_117[buf_sz + 16] == (_BYTE)v6) )
          {
            v13 = buf_sz;
            if ( (unsigned __int16)buf_sz > 0xFFu || *(_BYTE *)v7 )
            {
              v18 = (unsigned __int16 *)v47;
              ++v45;
              v47 += 11;
              buf_sz = *v18;
              *v18 = (*(unsigned __int8 *)v7 << 10) | v13 & 0x3FF;
              v19 = *(__int16 *)((char *)v7 - 11);
              buf_sz = v18[1];
              v20 = *(__int16 *)((char *)v7 - 3);
              v18[1] = ((*(_BYTE *)(v7 - 6) & 0x3F) << 10) | (v19 - *((unsigned __int8 *)v7 + 1)) & 0x3FF;
              v1 = player;
              *((_DWORD *)v18 + 1) = (unsigned __int16)buf & 0x3FFF | (((v20 << 14) | v10 & 0x3FFF) << 14);
              *((_BYTE *)v18 + 10) = v20 >> 6;
              v18[4] = v12 & 0x3FFF ^ ((unsigned __int16)(v20 >> 4) << 14);
            }
            else
            {
              v14 = v46;
              v15 = (int)v43;
              v43 += 10;
              *(_BYTE *)v15 = *((_BYTE *)v7 - 5);
              v16 = *(_WORD *)(v15 + 1);
              v46 = v14 + 1;
              LOWORD(v14) = *(__int16 *)((char *)v7 - 11);
              buf_sz = v16;
              v17 = *(__int16 *)((char *)v7 - 3);
              *(_WORD *)(v15 + 1) = ((*(_BYTE *)(v7 - 6) & 0x3F) << 10) | (v14 - *((unsigned __int8 *)v7 + 1)) & 0x3FF;
              v1 = player;
              *(_DWORD *)(v15 + 3) = (unsigned __int16)buf & 0x3FFF | (((v17 << 14) | v10 & 0x3FFF) << 14);
              *(_BYTE *)(v15 + 9) = v17 >> 6;
              *(_WORD *)(v15 + 7) = v12 & 0x3FFF ^ ((unsigned __int16)(v17 >> 4) << 14);
            }
          }
          else
          {
            v21 = *(__int16 *)((char *)v7 - 5);
            buf_sz = (int)v7 - 13;
            v1[1].field_117[v21 + 16] = v6;
            buf = (void *)*((unsigned __int8 *)v7 - 14);
            PlayerSendPacket(player, (void *)buf_sz, (int)buf, 0);
          }
        }
        v22 = *(_DWORD *)&v1[1].field_117[11];
        v7 += 18;
        if ( ++v44 >= v22 )
          break;
        LOBYTE(v6) = v50;
      }
      v3 = v45;
      LOBYTE(v6) = v50;
      result = v46;
    }
    v23 = *(_DWORD *)&v1[1].field_117[11];
    v44 = 0;
    if ( v23 )
    {
      v43 = &v42[10 * result + 1];
      buf = &v41[10 * v3 + 1 + v3];
      v24 = &v1[1].connection_id;
      while ( 1 )
      {
        if ( *((_BYTE *)v24 - 9) == 40 )
        {
          if ( (*(_BYTE *)v24 & 0x40) == 0
            && (v25 = *(_WORD *)((char *)v24 - 5), v47 = v25, v25 <= 0x3FFFu)
            && (v26 = *(_WORD *)((char *)v24 + 3), v26 <= 0x3FFFu)
            && (v27 = *(_WORD *)((char *)v24 + 5), v27 <= 0x1FFF)
            && v27 >= -8191
            && (v28 = *(_WORD *)((char *)v24 + 1), v28 <= 0x1FFF)
            && v28 >= -8191
            && v1[1].field_117[15]
            && *((_BYTE *)v24 - 10) == 16
            && v1[1].field_117[*((unsigned __int8 *)v24 - 1) + 16] == (_BYTE)v6 )
          {
            if ( *(_BYTE *)v24 )
            {
              v29 = buf;
              ++v45;
              v30 = *(_WORD *)buf;
              buf = (char *)buf + 11;
              v31 = *((unsigned __int8 *)v24 - 1);
              buf_sz = v30;
              v32 = v29[1];
              *v29 = (*(unsigned __int8 *)v24 << 10) | v31 & 0x3FF;
              v33 = *(_WORD *)((char *)v24 - 7);
              buf_sz = v32;
              v34 = *(__int16 *)((char *)v24 + 5);
              v29[1] = ((*(_BYTE *)(v24 - 2) & 0x3F) << 10) | (v33 - *((unsigned __int8 *)v24 - 3)) & 0x3FF;
              v1 = player;
              *((_DWORD *)v29 + 1) = v47 & 0x3FFF | (((v34 << 14) | v26 & 0x3FFF) << 14);
              *((_BYTE *)v29 + 10) = v34 >> 6;
              v29[4] = v28 & 0x3FFF ^ ((unsigned __int16)(v34 >> 4) << 14);
            }
            else
            {
              v35 = v46;
              v36 = (int)v43;
              v43 += 10;
              *(_BYTE *)v36 = *((_BYTE *)v24 - 1);
              v37 = *(_WORD *)(v36 + 1);
              v46 = v35 + 1;
              LOWORD(v35) = *(_WORD *)((char *)v24 - 7);
              buf_sz = v37;
              v38 = *(__int16 *)((char *)v24 + 5);
              *(_WORD *)(v36 + 1) = ((*(_BYTE *)(v24 - 2) & 0x3F) << 10) | (v35 - *((unsigned __int8 *)v24 - 3)) & 0x3FF;
              v1 = player;
              *(_DWORD *)(v36 + 3) = v47 & 0x3FFF | (((v38 << 14) | v26 & 0x3FFF) << 14);
              *(_BYTE *)(v36 + 9) = v38 >> 6;
              *(_WORD *)(v36 + 7) = v28 & 0x3FFF ^ ((unsigned __int16)(v38 >> 4) << 14);
            }
          }
          else
          {
            v39 = *((unsigned __int8 *)v24 - 1);
            buf_sz = (int)v24 - 9;
            v1[1].field_117[v39 + 16] = v6;
            v47 = *((unsigned __int8 *)v24 - 10);
            PlayerSendPacket(player, (void *)buf_sz, v47, 0);
          }
        }
        v40 = *(_DWORD *)&v1[1].field_117[11];
        v24 += 9;
        if ( ++v44 >= v40 )
          break;
        LOBYTE(v6) = v50;
      }
      v3 = v45;
      result = v46;
    }
    *(_DWORD *)&v1[1].field_117[11] = 0;
    if ( result )
    {
      v42[0] = 57;
      buf = (void *)(10 * result + 1);
      buf_sz = (int)v42;
      result = PlayerSendPacket(player, v42, (int)buf, 0);
    }
    if ( v3 )
    {
      v41[0] = 58;
      buf = (void *)(11 * v3 + 1);
      buf_sz = (int)v41;
      result = PlayerSendPacket(player, v41, (int)buf, 0);
    }
  }
  return result;
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);

//----- (100137F0) --------------------------------------------------------
void __thiscall sub_100137F0(int this)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // esi
  int v8; // ebx
  _BOOL1 v9; // zf
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // cl
  int v12[2]; // [esp+0h] [ebp-20h]
  int v13; // [esp+8h] [ebp-18h]
  int v14; // [esp+Ch] [ebp-14h]
  int v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  int v17; // [esp+18h] [ebp-8h]
  char v18; // [esp+1Fh] [ebp-1h]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  if ( *(_DWORD *)(this + 1619) )
  {
    v2 = FIX_DLL_KERNEL32_dll_GetTickCount();
    v3 = *(_DWORD *)(this + 1619);
    v14 = v2;
    v18 = 0;
    LOWORD(v12[0]) = 0;
    BYTE2(v12[0]) = 0;
    v15 = 0;
    if ( v3 )
    {
      v4 = this + 1336;
      v17 = this + 1336;
      v16 = v3;
      do
      {
        v13 = v14 - *(_DWORD *)(v4 - 5);
        if ( v13 >= dword_101A5368[0] )
        {
          if ( *(_BYTE *)v4 == 5 )
            v5 = *(__int16 *)(v4 + 15);
          else
            v5 = *(__int16 *)(v4 + 12);
          v6 = abs32(*(__int16 *)(this + 232) - *(__int16 *)(v4 + 4));
          v7 = abs32(*(__int16 *)(this + 228) - v5);
          v8 = 0;
          if ( v6 >= *(_DWORD *)(this + 619) / 2 + 32 || v7 >= *(_DWORD *)(this + 623) / 2 + 32 )
          {
            v8 = 2;
          }
          else
          {
            if ( v6 > v7 )
              v6 = v7;
            if ( v6 > dword_101A5374 )
              v8 = 1;
          }
          if ( v13 >= dword_101A5368[v8] )
          {
            v18 = 1;
            v15 = v8;
          }
          ++*((_BYTE *)v12 + v8);
          v4 = v17;
        }
        v4 += 36;
        v9 = v16 == 1;
        v17 = v4;
        --v16;
      }
      while ( !v9 );
      if ( v18 )
      {
        v10 = BYTE1(v12[0]);
        v11 = v12[0];
        ++dword_100292F0[v15];
        dword_101B3040 += v11;
        dword_101B3048 += BYTE2(v12[0]);
        dword_101B3044 += v10;
        sub_10013250(this);
        sub_41D6D0(*(_DWORD *)(this + 40), (int)&savedregs, this);
      }
    }
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100292F0: using guessed type int dword_100292F0[];
// 101A5374: using guessed type int dword_101A5374;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;

//----- (10013980) --------------------------------------------------------
void __userpurge sub_10013980(int a1@<ecx>, int a2@<edi>, unsigned __int8 *buf, unsigned int buf_sz, int a5)
{
  int v5; // esi
  int v6; // eax
  unsigned int v7; // eax
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  v5 = a1;
  if ( !*(_DWORD *)(a1 + 777) && *(_DWORD *)(a1 + 28) )
  {
    v6 = *buf;
    if ( (v6 == 5 || v6 == 40) && buf_sz <= 0x1F && (v7 = *(_DWORD *)(a1 + 1619), v7 < 8) && dword_101A5378 )
    {
      memcpy_0((void *)(a1 + 36 * v7 + 1336), buf, buf_sz);
      *(_BYTE *)(v5 + 36 * *(_DWORD *)(v5 + 1619) + 1335) = buf_sz;
      *(_DWORD *)(v5 + 36 * (*(_DWORD *)(v5 + 1619))++ + 1331) = FIX_DLL_KERNEL32_dll_GetTickCount();
      sub_100137F0(v5);
    }
    else
    {
      sub_10013250(a1);
      PlayerSendPacket((PLAYER *)a1, buf, buf_sz, 0);
      if ( dword_101A5378 )
        sub_41D6D0(*(_DWORD *)(v5 + 40), (int)&savedregs, a2);
      ++dword_100292FC;
    }
  }
}
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100292FC: using guessed type int dword_100292FC;
// 101A5378: using guessed type int dword_101A5378;

//----- (10013A70) --------------------------------------------------------
int __thiscall Fix_PlayerInit(int this)
{
  *(_DWORD *)(this + 1026) = 0;
  *(_DWORD *)(this + 2648) = 0;
  memset((void *)(this + 861), 0xFFu, 0x18u);
  memset((void *)(this + 1295), 0xFFu, 0x18u);
  *(_BYTE *)(this + 1013) = byte_101A5384;
  *(_DWORD *)(this + 1014) = MiscKeepAliveDelay;
  *(_DWORD *)(this + 1018) = 0;
  *(_DWORD *)(this + 1035) = 0;
  *(_DWORD *)(this + 1022) = 2500;
  memset((void *)(this + 1039), 0, 0x80u);
  memset((void *)(this + 1167), 0, 0x80u);
  *(_DWORD *)(this + 1619) = 0;
  *(_BYTE *)(this + 1623) = 0;
  memset((void *)(this + 1624), 0, 0x400u);
  return this;
}
// 4B0618: using guessed type int MiscKeepAliveDelay;
// 101A5384: using guessed type char byte_101A5384;

//----- (10013B10) --------------------------------------------------------
int __cdecl sub_10013B10()
{
  int GetTickCount; // esi
  int v1; // edi
  int v2; // edx
  int *v3; // ecx
  int result; // eax
  ARENA *v5; // ebx
  _BOOL1 v6; // cc
  char *v7; // edi
  PLAYER *v8; // esi
  ARENA *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  char *v13; // ecx
  int v14; // edi
  char **v15; // esi
  int v16; // edi
  char *v17; // esi
  int v18; // eax
  _BOOL1 v19; // cf
  int i; // ebx
  int v21; // esi
  char v22[4]; // [esp+0h] [ebp-118h] BYREF
  int v23; // [esp+100h] [ebp-18h]
  ARENA **v24; // [esp+104h] [ebp-14h]
  int v25; // [esp+108h] [ebp-10h]
  PLAYER *v26; // [esp+10Ch] [ebp-Ch]
  char *msg; // [esp+110h] [ebp-8h]
  char *v28; // [esp+114h] [ebp-4h]

  GetTickCount = FIX_DLL_KERNEL32_dll_GetTickCount();
  v1 = 0;
  v25 = GetTickCount;
  ContinuumEncryptKey = GetTickCount ^ (69069 * ContinuumEncryptKey + 17009);
  if ( dword_101A5338 && (GetTickCount - dword_101C8064 >= dword_101A5338 || !dword_101C8064) )
  {
    v2 = 0;
    if ( ZonePlayerCount > 0 )
    {
      v3 = ZonePlayers;
      do
      {
        if ( *v3 )
          *(_DWORD *)(*v3 + 751) = 0;
        ++v2;
        ++v3;
      }
      while ( v2 < ZonePlayerCount );
    }
    dword_101C8064 = GetTickCount;
  }
  result = dword_101C8068;
  if ( GetTickCount - dword_101C8068 >= 30000 || !dword_101C8068 )
  {
    dword_101C8068 = GetTickCount;
    v23 = 0;
    if ( ArenaArrayLength > 0 )
    {
      v24 = (ARENA **)ArenaArray;
      do
      {
        v5 = *v24;
        if ( *v24 )
        {
          if ( *(_DWORD *)&v5[1].field_0[249] || *(_DWORD *)&v5[1].field_0[253] )
          {
            v6 = v5->nPlayersHere <= 0;
            v28 = 0;
            if ( !v6 )
            {
              v7 = v5->PlayerArray;
              do
              {
                v8 = *(PLAYER **)v7;
                v26 = *(PLAYER **)v7;
                if ( v26 )
                {
                  if ( v25 - *(_DWORD *)&v8->field_341[52] >= 60000 )
                  {
                    v9 = (ARENA *)v8->lpCurrentArena;
                    if ( v9 )
                    {
                      v10 = *(_DWORD *)&v9[1].field_0[249];
                      if ( v10 > 0 )
                      {
                        v11 = *(_DWORD *)&v9[1].field_0[253];
                        if ( v11 > 0 && (v8->dwXRes > v10 || v8->dwYRes > v11) && !v8->bIsSysop )
                        {
                          sprintf_0(
                            v22,
                            "Maximum allowed screen resolution is %dx%d in this arena",
                            *(_DWORD *)&v9[1].field_0[249],
                            *(_DWORD *)&v9[1].field_0[253]);
                          msg = v22;
                          SendMessage(v26, v22, 0);
                          *(_DWORD *)&v8->field_2C[12] = 1;
                          v8->dwDisconnectReason = 38;
                          off_10024608("Ext: Played kicked off for exceeding res limit: %s\n", v8->player_name);
                        }
                      }
                    }
                  }
                }
                v12 = v5->nPlayersHere;
                v7 += 4;
                ++v28;
              }
              while ( (int)v28 < v12 );
              GetTickCount = v25;
            }
          }
          if ( *(_DWORD *)&v5->field_1D40F[7] != *(_DWORD *)v5->dwLastConfigReadTime )
          {
            off_10024608("Ext: Re-reading %s\n", v5->szConfigFile);
            CtmPlayerJustConnected((PLAYER *)v5);
          }
          v13 = &v5->field_1D40F[171];
          v28 = &v5->field_1D40F[171];
          v26 = 0;
          do
          {
            if ( !*v13 )
              break;
            if ( GetTickCount - *(_DWORD *)(v13 + 165) >= *(_DWORD *)(v13 + 161) )
            {
              if ( v13[160] )
              {
                v14 = 0;
                if ( ZonePlayerCount > 0 )
                {
                  v15 = (char **)ZonePlayers;
                  do
                  {
                    msg = *v15;
                    if ( msg )
                    {
                      SendMessage((struct PLAYER *)msg, v28, 0);
                      v13 = v28;
                    }
                    ++v14;
                    ++v15;
                  }
                  while ( v14 < ZonePlayerCount );
                }
              }
              else
              {
                v16 = 0;
                if ( v5->nPlayersHere > 0 )
                {
                  v17 = v5->PlayerArray;
                  do
                  {
                    msg = *(char **)v17;
                    if ( msg )
                    {
                      SendMessage((struct PLAYER *)msg, v28, 0);
                      v13 = v28;
                    }
                    ++v16;
                    v17 += 4;
                  }
                  while ( v16 < v5->nPlayersHere );
                }
              }
              v18 = v25;
              *(_DWORD *)(v13 + 165) = v25;
              GetTickCount = v18;
            }
            v13 += 169;
            v19 = (unsigned int)&v26->hProcess + 1 < 5;
            v26 = (PLAYER *)((char *)v26 + 1);
            v28 = v13;
          }
          while ( v19 );
          v1 = 0;
        }
        v6 = ++v23 < ArenaArrayLength;
        ++v24;
      }
      while ( v6 );
    }
    result = dword_101A9508;
    for ( i = 0; i < dword_101A9508; v1 += 32 )
    {
      v21 = v1 + dword_101A9500;
      if ( sub_10002830((void *)(v1 + dword_101A9500)) != *(_DWORD *)(v21 + 24) )
        sub_100125F0((char *)v21);
      result = dword_101A9508;
      ++i;
    }
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 101A5338: using guessed type int dword_101A5338;
// 101A5360: using guessed type int ContinuumEncryptKey;
// 101A9500: using guessed type int dword_101A9500;
// 101A9508: using guessed type int dword_101A9508;
// 101C8064: using guessed type int dword_101C8064;
// 101C8068: using guessed type int dword_101C8068;

//----- (10013E40) --------------------------------------------------------
void __cdecl BillingServerRecievedPacket(PLAYER *player, int classptr)
{
  char v2; // al
  int v3; // edx
  int *i; // ecx
  char v5; // al
  char *v6; // ebx
  char *v7; // esi
  unsigned int v8; // kr04_4
  unsigned int v9; // ecx
  int v10; // edi
  char *v11; // esi
  char v12; // dl
  int v13; // edi
  struct ARENA **v14; // esi
  struct ARENA *v15; // eax
  int v16; // edx
  int *v17; // ecx
  int v18; // eax
  int v19; // edi
  PLAYER **v20; // esi
  PLAYER *v21; // eax
  int v22; // ecx
  size_t v23; // esi
  int v24; // edx
  int *v25; // ecx
  _DWORD *v26; // eax
  char v27[6]; // [esp+0h] [ebp-10Ch] BYREF
  int dst; // [esp+6h] [ebp-106h] BYREF
  void *buf; // [esp+100h] [ebp-Ch]
  _DWORD buf_sz[2]; // [esp+104h] [ebp-8h] BYREF
  PLAYER *msg; // [esp+114h] [ebp+8h]
  int classptra; // [esp+118h] [ebp+Ch]

  v2 = player->hProcess;
  if ( LOBYTE(player->hProcess) == 9 )
  {
    v3 = 0;
    if ( ZonePlayerCount > 0 )
    {
      for ( i = ZonePlayers; !*i || *(_DWORD *)(*i + 16) != *(int *)((char *)&player->hProcess + 1); ++i )
      {
        if ( ++v3 >= ZonePlayerCount )
          return;
      }
      v5 = player->field_4[1];
      v6 = &player->field_4[1];
      classptra = v3;
      msg = (PLAYER *)&player->field_4[1];
      if ( v5 == 36 )
      {
        if ( !memcmp(v6, &unk_101A52F4, 0xBu) )
        {
          v6 += 3;
          msg = (PLAYER *)v6;
          memcpy_0(v6, "(local) ", 8u);
          v3 = classptra;
        }
        if ( !memcmp(v6, &unk_101A5314, 0xBu) )
        {
          msg = (PLAYER *)(v6 + 3);
          memcpy_0(v6 + 3, "(staff) ", 8u);
          v3 = classptra;
        }
      }
      SendMessage((struct PLAYER *)ZonePlayers[v3], (const char *)msg, 0);
    }
  }
  else
  {
    switch ( v2 )
    {
      case '4':
        v7 = (char *)&player->hProcess + 4 * BYTE1(player->hProcess) + BYTE1(player->hProcess) + 2;
        if ( 5 * BYTE1(player->hProcess) + 2 < classptr )
        {
          if ( memchr(v7, 0, classptr + (char *)player - v7) )
          {
            v27[0] = 10;
            strncpyt(&dst, v7, 250);
            v8 = strlen((const char *)&dst) + 1;
            v9 = v8 + 6;
            v10 = 0;
            if ( BYTE1(player->hProcess) )
            {
              v11 = &player->field_4[2];
              while ( 1 )
              {
                v12 = *v11;
                *(_DWORD *)&v27[1] = *((_DWORD *)v11 - 1);
                v27[5] = v12;
                off_10024610(v27, v9);
                ++v10;
                v11 += 5;
                if ( v10 >= BYTE1(player->hProcess) )
                  break;
                v9 = v8 + 6;
              }
            }
          }
        }
        break;
      case '1':
        if ( classptr == 9 && *(int *)((char *)&player->hProcess + 1) == -*(_DWORD *)&player->field_4[1] )
        {
          off_10024608("Ext: Scorereset request received from billing server\n");
          v13 = 0;
          if ( ArenaArrayLength > 0 )
          {
            v14 = (struct ARENA **)ArenaArray;
            do
            {
              v15 = *v14;
              if ( *v14 && !v15->name[0] )
                ArenaScoreReset(v15, 1);
              ++v13;
              ++v14;
            }
            while ( v13 < ArenaArrayLength );
          }
          v16 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v17 = ZonePlayers;
            do
            {
              if ( *v17 )
              {
                v18 = *v17 + 589;
                *(_DWORD *)v18 = 0;
                *(_DWORD *)(v18 + 4) = 0;
                *(_DWORD *)(v18 + 8) = 0;
                *(_WORD *)(v18 + 12) = 0;
              }
              ++v16;
              ++v17;
            }
            while ( v16 < ZonePlayerCount );
          }
        }
        break;
      case '2':
        v19 = 0;
        if ( ZonePlayerCount > 0 )
        {
          v20 = (PLAYER **)ZonePlayers;
          do
          {
            v21 = *v20;
            if ( *v20 )
            {
              v22 = *(int *)((char *)&player->hProcess + 1);
              if ( v22 == -1 || v21->connection_id == v22 )
              {
                buf_sz[0] = classptr - 5;
                buf = &player->field_4[1];
                PlayerSendPacket(v21, &player->field_4[1], classptr - 5, 1);
              }
            }
            ++v19;
            ++v20;
          }
          while ( v19 < ZonePlayerCount );
        }
        break;
      case '3':
        if ( BillingConnectionStructPointer )
          *((_DWORD *)BillingConnectionStructPointer + 7) = 0;
        v23 = classptr - 1;
        if ( (unsigned int)(classptr - 1) >= 0x200 )
          v23 = 512;
        memcpy_0(&unk_101A9517, (char *)&player->hProcess + 1, v23);
        dword_101B0718 = v23 + 7;
        if ( byte_101B3054 && v23 >= 0x80 )
          memcpy_0(&unk_101A9517, &unk_10029270, 0x80u);
        LOBYTE(buf_sz[0]) = 21;
        *(_DWORD *)((char *)buf_sz + 1) = 3;
        WriteData(*((struct CONNECTION **)BillingConnectionStructPointer + 1), buf_sz, 5u, 1);
        break;
      default:
        if ( v2 == 1 && player->field_4[2] == 94 )
        {
          v24 = 0;
          if ( ZonePlayerCount > 0 )
          {
            v25 = ZonePlayers;
            do
            {
              v26 = (_DWORD *)*v25;
              if ( *v25
                && v26[4] == *(int *)((char *)&player->hProcess + 2)
                && *(_DWORD *)((char *)v26 + 639)
                && !*(_DWORD *)((char *)v26 + 635) )
              {
                *(_DWORD *)((char *)v26 + 639) = 0;
              }
              ++v24;
              ++v25;
            }
            while ( v24 < ZonePlayerCount );
          }
        }
        off_10024610(player, classptr);
        break;
    }
  }
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D68D0: using guessed type int ArenaArray[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 10024610: using guessed type int (__cdecl *off_10024610)(_DWORD, _DWORD);
// 101B0718: using guessed type int dword_101B0718;
// 101B3054: using guessed type char byte_101B3054;

//----- (10014200) --------------------------------------------------------
int __stdcall fix_1c(SOCKET Sockett, char *pkt, int a3, int flags, struct sockaddr *from, int *fromlen)
{
  int *v6; // eax
  _DWORD *v7; // ecx
  struct sockaddr *v8; // ebx
  char *v9; // esi
  int result; // eax
  char v11; // al
  int v12; // eax
  unsigned int v13; // edx
  int v14; // ecx
  char v15; // al
  va_list v16; // eax
  unsigned int v17; // eax
  int v18; // ecx
  _DWORD **v19; // eax
  _DWORD *v20; // edi
  unsigned int v21; // eax
  int v22; // ecx
  unsigned int v23; // edx
  unsigned int v24; // eax
  unsigned int i; // esi
  unsigned int v26; // ecx
  int v27; // ecx
  unsigned __int8 v28; // dl
  unsigned int v29; // ecx
  unsigned int v30; // eax
  int v31; // edx
  unsigned int *v32; // eax
  _DWORD *v33; // eax
  int v34; // ecx
  int v35; // esi
  int v36; // edx
  _DWORD *v37; // eax
  _DWORD *v38; // eax
  _DWORD *v39; // esi
  int v40; // edx
  int v41; // ecx
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  int v44; // edi
  int v45; // ecx
  int v46; // edx
  int v47; // ecx
  unsigned int v48; // edi
  unsigned int v49; // ecx
  unsigned __int8 v50; // al
  _BOOL1 v51; // cc
  const char *v52; // ecx
  struct BILLING_SERVER_STRUCT *v53; // eax
  int v54; // ecx
  char *PacketBuffer; // edi
  char PacketType; // al
  int ContinuumEncryptKeyy; // ecx
  unsigned int PickedScrty1Offset; // esi
  int v59; // eax
  unsigned int v60; // edx
  __int16 ProtocolVersion; // cx
  unsigned int v62; // eax
  unsigned int v63; // eax
  char *v64; // eax
  int Md5EncryptKey; // esi
  int v66; // eax
  unsigned int v67; // ecx
  unsigned int v68; // eax
  char *pktt; // ecx
  char *pktttt; // edi
  void *MD5Buffer; // edi
  const void *v72; // edx
  char *pkttt; // edi
  int v74; // [esp-Ch] [ebp-88h] BYREF
  char v75[4]; // [esp+0h] [ebp-7Ch] BYREF
  _WORD PacketBuffer2[6]; // [esp+40h] [ebp-3Ch]
  _WORD PacketBuffer1[7]; // [esp+4Ch] [ebp-30h]
  unsigned int v78; // [esp+5Ah] [ebp-22h]
  int v79; // [esp+60h] [ebp-1Ch]
  int pkt_size; // [esp+64h] [ebp-18h]
  int a2[2]; // [esp+68h] [ebp-14h] BYREF
  int v82; // [esp+78h] [ebp-4h]

  a2[1] = (int)&v74;
  if ( !byte_101B303C )
  {
    dword_1002930C = 0;
    dword_10029308 = 0;
    memset(dword_101A5398, 0, 0x4000u);
    byte_101B303C = 1;
    dword_10029310 = 20;
    v6 = (int *)&unk_101A9718;
    do
    {
      v7 = (int *)((char *)v6 + dword_10029310);
      *v7 = 0;
      v7[1] = dword_1002930C;
      if ( dword_1002930C )
        *(_DWORD *)(dword_10029310 + dword_1002930C) = v6;
      else
        dword_10029308 = (int)v6;
      dword_1002930C = (int)v6;
      v6 += 7;
    }
    while ( v6 < &dword_101B0718 );
    dword_101C806C = FIX_DLL_KERNEL32_dll_GetTickCount() - 30000;
    dword_101B3050 = 0;
    dword_101A51A0 = 0;
    v82 = 1;
    a2[0] = -1;
    ReadScrty1File(a2, "scrty1", 1, 3);
    ReadScrty1FileOffset(a2, (int)&Scrty1Version, 4);
    ReadScrty1FileOffset(a2, (int)Step1Bytes, 86016);
    dword_101A51A0 = 1;
    ReadScrty1FileOffset(a2, (int)Step1AndStep2, 86016);
    dword_101B3050 = 1;
    sub_10001A50(a2);
    v82 = -1;
  }
  v8 = from;
  v9 = pkt;
  result = recvfrom_0(Sockett, pkt, 2048, flags, from, fromlen);
  pkt_size = result;
  if ( result <= 0 )
    return result;
  while ( 1 )
  {
    if ( result > 7 && !*v9 && v9[1] == 1 && v9[6] == -1 )
    {
      sub_1000A860(
        (unsigned __int16 *)byte_1003E438,
        (int)v9,
        result,
        *(_DWORD *)&v8->sa_data[2],
        *(unsigned __int16 *)v8->sa_data);
      goto LABEL_131;
    }
    if ( result > 512 )
      goto LABEL_131;
    LOBYTE(a2[0]) = !*v9 && ((v11 = v9[1], v11 == 1) || v11 == 6 || v11 == 17);
    v12 = FIX_DLL_KERNEL32_dll_GetTickCount();
    v13 = *(_DWORD *)&v8->sa_data[2];
    v14 = v12;
    v79 = v12;
    HIBYTE(from) = 0;
    if ( v13 == dword_101A5344 )
    {
      v15 = *v9;
      if ( *v9 == 4 )
      {
        v16 = "Recycle request from billing server ignored";
      }
      else if ( v15 == 2 )
      {
        v16 = "Shutdown request from billing server ignored";
      }
      else
      {
        if ( v15 )
          goto LABEL_37;
        switch ( v9[1] )
        {
          case 7:
            v16 = "Disconnect request from billing server ignored";
            break;
          case 1:
            v16 = "Client connection request from billing server ignored";
            break;
          case 6:
            v16 = LevelFiles;
            break;
          default:
            goto LABEL_37;
        }
      }
      if ( v16 )
      {
        if ( v14 - dword_101C806C > 10000 )
        {
          if ( *v16 )
          {
            dword_101C806C = v14;
            sub_100151C0(v16, 0);
          }
        }
        goto LABEL_131;
      }
    }
LABEL_37:
    v17 = ((4294942263 * (v13 ^ HIWORD(v13))) >> 5) & 0x7FF;
    v18 = dword_101A5398[2 * v17];
    if ( v18 != v13 )
    {
      while ( 1 )
      {
        if ( !v18 )
        {
          dword_101A9398 = 8 * v17 + 270160792;
          goto LABEL_42;
        }
        v17 = ((_WORD)v17 + 1) & 0x7FF;
        if ( v17 == (((4294942263 * (v13 ^ HIWORD(v13))) >> 5) & 0x7FF) )
          break;
        v18 = dword_101A5398[2 * v17];
        if ( v18 == v13 )
          goto LABEL_41;
      }
      dword_101A9398 = 0;
LABEL_42:
      v20 = (_DWORD *)dword_1002930C;
      v21 = ((unsigned int)(-25033 * (*(_DWORD *)dword_1002930C ^ HIWORD(*(_DWORD *)dword_1002930C))) >> 5) & 0x7FF;
      v22 = dword_101A5398[2 * v21];
      if ( v22 == *(_DWORD *)dword_1002930C )
      {
LABEL_51:
        if ( 8 * v21 != -270160796 )
        {
          v23 = (int)(8 * v21 + 270160796 - (_DWORD)dword_101A5398 - 4) >> 3;
          v24 = ((_WORD)v23 + 1) & 0x7FF;
          dword_101A5398[2 * v23] = 0;
          for ( i = dword_101A5398[2 * v24]; i; i = dword_101A5398[2 * v24] )
          {
            v26 = ((-25033 * (i ^ HIWORD(i))) >> 5) & 0x7FF;
            if ( (v26 <= v23 || v26 > v24) && (v23 < v24 || v26 <= v23 && v26 > v24) )
            {
              dword_101A5398[2 * v23] = dword_101A5398[2 * v24];
              dword_101A539C[2 * v23] = dword_101A539C[2 * v24];
              v23 = v24;
              dword_101A5398[2 * v24] = 0;
            }
            v24 = ((_WORD)v24 + 1) & 0x7FF;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          if ( !v22 )
          {
            dword_101A9398 = 8 * v21 + 270160792;
            goto LABEL_60;
          }
          v21 = ((_WORD)v21 + 1) & 0x7FF;
          if ( v21 == (((unsigned int)(-25033 * (*(_DWORD *)dword_1002930C ^ HIWORD(*(_DWORD *)dword_1002930C))) >> 5) & 0x7FF) )
            break;
          v22 = dword_101A5398[2 * v21];
          if ( v22 == *(_DWORD *)dword_1002930C )
            goto LABEL_51;
        }
        dword_101A9398 = 0;
      }
LABEL_60:
      v27 = v79;
      *v20 = *(_DWORD *)&v8->sa_data[2];
      v28 = a2[0];
      *(_DWORD *)(dword_1002930C + 12) = v27;
      *(_DWORD *)(dword_1002930C + 4) = v28;
      *(_DWORD *)(dword_1002930C + 8) = 1;
      *(_DWORD *)(dword_1002930C + 16) = 0;
      v29 = *(_DWORD *)&v8->sa_data[2];
      v30 = ((-25033 * (v29 ^ HIWORD(v29))) >> 5) & 0x7FF;
      v31 = dword_101A5398[2 * v30];
      if ( v31 == v29 )
      {
LABEL_64:
        if ( 8 * v30 == -270160796 )
        {
          v32 = (unsigned int *)dword_101A9398;
LABEL_66:
          if ( v32 )
          {
            *v32 = v29;
            v33 = (_DWORD *)(dword_101A9398 + 4);
LABEL_71:
            *v33 = dword_1002930C;
            v34 = dword_1002930C;
            v35 = dword_10029310;
            v36 = *(_DWORD *)(dword_1002930C + dword_10029310 + 4);
            v37 = (_DWORD *)(dword_1002930C + dword_10029310);
            if ( v36 )
            {
              *(_DWORD *)(dword_10029310 + v36) = *v37;
              v35 = dword_10029310;
            }
            else
            {
              dword_10029308 = *v37;
            }
            if ( *v37 )
            {
              *(_DWORD *)(v35 + *v37 + 4) = v37[1];
              v35 = dword_10029310;
            }
            else
            {
              dword_1002930C = v37[1];
            }
            v38 = (_DWORD *)(v34 + v35);
            v38[1] = 0;
            *v38 = dword_10029308;
            if ( dword_10029308 )
              *(_DWORD *)(dword_10029310 + dword_10029308 + 4) = v34;
            else
              dword_1002930C = v34;
            dword_10029308 = v34;
            goto LABEL_108;
          }
        }
      }
      else
      {
        while ( 1 )
        {
          if ( !v31 )
          {
            v32 = (unsigned int *)(8 * v30 + 270160792);
            dword_101A9398 = (int)v32;
            goto LABEL_66;
          }
          v30 = ((_WORD)v30 + 1) & 0x7FF;
          if ( v30 == (((-25033 * (v29 ^ HIWORD(*(_DWORD *)&v8->sa_data[2]))) >> 5) & 0x7FF) )
            break;
          v31 = dword_101A5398[2 * v30];
          if ( v31 == v29 )
            goto LABEL_64;
        }
        dword_101A9398 = 0;
      }
      v33 = 0;
      goto LABEL_71;
    }
LABEL_41:
    v19 = (_DWORD **)(8 * v17 + 270160796);
    if ( !v19 )
      goto LABEL_42;
    v39 = *v19;
    v40 = dword_10029310;
    v41 = *(_DWORD *)((char *)*v19 + dword_10029310 + 4);
    v42 = (_DWORD *)((char *)*v19 + dword_10029310);
    if ( v41 )
    {
      *(_DWORD *)(dword_10029310 + v41) = *v42;
      v40 = dword_10029310;
    }
    else
    {
      dword_10029308 = *v42;
    }
    if ( *v42 )
    {
      *(_DWORD *)(v40 + *v42 + 4) = v42[1];
      v40 = dword_10029310;
    }
    else
    {
      dword_1002930C = v42[1];
    }
    v43 = (_DWORD *)((char *)v39 + v40);
    v43[1] = 0;
    *v43 = dword_10029308;
    if ( dword_10029308 )
      *(_DWORD *)(dword_10029310 + dword_10029308 + 4) = v39;
    else
      dword_1002930C = (int)v39;
    dword_10029308 = (int)v39;
    v44 = v39[3];
    if ( v79 - v44 >= 60000 )
    {
      v45 = (v79 - v44) / 60000;
      v46 = v39[2] >> v45;
      v39[1] >>= v45;
      v39[2] = v46;
      v39[3] = v44 + 60000 * v45;
    }
    if ( pkt[1] != 6 )
      v39[1] += LOBYTE(a2[0]);
    v47 = v39[2] + 1;
    v39[2] = v47;
    v48 = v47;
    v49 = v39[1];
    if ( v49 > 0x1E || v48 > 0x1388 )
    {
      v50 = v8->sa_data[2];
      if ( v50 != 127 && *v39 != dword_101A5350 )
      {
        HIBYTE(from) = dword_101A5344 != *v39;
        if ( (v49 > 0x32 || v48 > 0x1388) && !v39[4] )
        {
          v51 = v49 <= 0x14;
          v52 = "Connection";
          if ( v51 )
            v52 = "Packet";
          sprintf_0(
            v75,
            "WARNING: %s flood from %d.%d.%d.%d",
            v52,
            v50,
            (unsigned __int8)v8->sa_data[3],
            (unsigned __int8)v8->sa_data[4],
            (unsigned __int8)v8->sa_data[5]);
          sub_100151C0(v75, 0);
          v39[4] = 1;
        }
      }
    }
    if ( LOBYTE(a2[0]) && CommsEncryptMode == 2 && !*(_DWORD *)(pkt + 2) || HIBYTE(from) )
      goto LABEL_131;
LABEL_108:
    if ( !LOBYTE(a2[0]) )
      return pkt_size;
    v53 = BillingConnectionStructPointer;
    if ( BillingConnectionStructPointer )
    {
      v54 = *((_DWORD *)BillingConnectionStructPointer + 7);
      if ( v54 && (unsigned int)(v79 - v54) > 0x3E8 )
      {
        *((_DWORD *)BillingConnectionStructPointer + 7) = 0;
        dword_101B0718 = 7;
      }
      if ( *((_DWORD *)v53 + 7) )
        goto LABEL_131;
    }
    PacketBuffer = pkt;
    PacketType = pkt[1];
    if ( PacketType == 1 )
    {
      ContinuumEncryptKeyy = ContinuumEncryptKey;
      PickedScrty1Offset = 10 * ContinuumEncryptKeyCounter;
      *(char **)((char *)&IPAddressTable + PickedScrty1Offset) = *(char **)&v8->sa_data[2];
      v59 = 69069 * ContinuumEncryptKeyy + 17009;
      v60 = ContinuumEncryptKeyCounter | v59 & 0xFFFE0000;
      ArrayOfWords[PickedScrty1Offset / 2] = HIWORD(v60);
      ContinuumEncryptKey = v59;
      if ( pkt_size >= 8 )
      {
        ProtocolVersion = *((_WORD *)PacketBuffer + 3);
        if ( ProtocolVersion == 0x10 && dword_101A51A0 )// Continuum Step 1 Array from Scrty1 File
        {
          ContinuumEncryptKey = 69069 * v59 + 17009;
          v62 = (unsigned int)(HIWORD(ContinuumEncryptKey) << 10) >> 16;
          *(_DWORD *)&PacketBuffer1[3] = 0;
          *(_DWORD *)&PacketBuffer1[1] = v60;
          *(char **)((char *)&Scrty1FileBytes + PickedScrty1Offset) = (char *)v62;
          *(_DWORD *)&PacketBuffer1[3] = Step1Bytes[v62].Key;
          PacketBuffer1[0] = 4096;
          goto LABEL_124;
        }
        if ( ProtocolVersion == 0x11 && dword_101B3050 )// Continuum Step 1 & 2 Array from Scrty1 File
        {
          ContinuumEncryptKey = 69069 * v59 + 17009;
          *(_DWORD *)&PacketBuffer2[3] = 0;
          v63 = (unsigned int)(HIWORD(ContinuumEncryptKey) << 10) >> 16;
          PacketBuffer2[5] = 0;
          *(_DWORD *)&PacketBuffer2[1] = v60;
          *(char **)((char *)&Scrty1FileBytes + PickedScrty1Offset) = (char *)v63;
          *(_DWORD *)&PacketBuffer2[3] = Step1AndStep2[v63].Key;
          PacketBuffer2[0] = 4096;
          PacketBuffer2[5] = 1;
          goto LABEL_124;
        }
      }
      v64 = *(char **)(PacketBuffer + 2);
      *(char **)((char *)&Scrty1FileBytes + PickedScrty1Offset) = v64;
      if ( (unsigned int)v64 < 1024 )
      {
LABEL_125:
        ContinuumEncryptKeyCounter = (ContinuumEncryptKeyCounter + 1) & 0x1FFFF;
        goto LABEL_131;
      }
      v78 = v60;
      PacketBuffer1[6] = 1280;
LABEL_124:
      j_FIX_DLL_WSOCK32_dll_ord_0014();
      goto LABEL_125;
    }
    if ( PacketType != 0x11 || !dword_101A51A0 )
      break;
    Md5EncryptKey = *(_DWORD *)(pkt + 2);
    v66 = Md5EncryptKey & 131071;
    v67 = 10 * (Md5EncryptKey & 131071);
    if ( *(char **)((char *)&IPAddressTable + v67) == *(char **)&v8->sa_data[2]// IP Matches
      && ArrayOfWords[v67 / 2] == HIWORD(Md5EncryptKey)// ServerKey Matches
      && *(unsigned int *)((char *)&Scrty1FileBytes + v67) < 0x400 )
    {
      pktt = pkt;
      v51 = pkt_size < 8;
      pkt[1] = 1;
      *(_DWORD *)(pktt + 2) = Md5EncryptKey;
      pktt[7] = 0;
      if ( !v51 && *((_WORD *)pktt + 3) && dword_101B3050 )
      {
        pktttt = pkt;
        pkt[6] = 0x11;                          // 0x0011 - Continuum New
        MD5Buffer = pktttt + 8;
        v72 = (const void *)(84 * *(_DWORD *)((char *)&Scrty1FileBytes + 10 * v66) + 0x101B3064);
      }
      else
      {
        pkttt = pkt;
        pkt[6] = 0x10;                          // 0x0010 - Continuum Old
        MD5Buffer = pkttt + 8;
        v72 = (const void *)(84 * *(_DWORD *)((char *)&Scrty1FileBytes + 10 * v66) + 0x1002931C);
      }
      memcpy_0(MD5Buffer, v72, 0x50u);
      unknown_libname_56(&pkt, (int)MD5Buffer);
      ContinuumEncryptMD5Step3(&pkt, Md5EncryptKey);
      return 88;
    }
LABEL_131:
    v9 = pkt;
    result = recvfrom_0(Sockett, pkt, 2048, flags, v8, fromlen);
    pkt_size = result;
    if ( result <= 0 )
      return result;
  }
  v68 = 10 * (*(_DWORD *)(pkt + 2) & 0x1FFFF);
  if ( *(char **)((char *)&IPAddressTable + v68) != *(char **)&v8->sa_data[2]
    || ArrayOfWords[v68 / 2] != HIWORD(*(_DWORD *)(pkt + 2))
    || *(unsigned int *)((char *)&Scrty1FileBytes + v68) < 1024 )
  {
    return pkt_size;
  }
  *(char **)((char *)&IPAddressTable + v68) = 0;
  PacketBuffer[1] = 1;
  *(_DWORD *)(PacketBuffer + 2) = *(char **)((char *)&Scrty1FileBytes + v68);
  PacketBuffer[6] = 1;
  PacketBuffer[7] = 0;
  return 8;
}
// 100143FC: conditional instruction was optimized away because of 'al.1==0'
// 1001440D: conditional instruction was optimized away because of 'al.1==0'
// 439E10: using guessed type int CommsEncryptMode;
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 10029308: using guessed type int dword_10029308;
// 1002930C: using guessed type int dword_1002930C;
// 10029310: using guessed type int dword_10029310;
// 101A51A0: using guessed type int dword_101A51A0;
// 101A5344: using guessed type int dword_101A5344;
// 101A5350: using guessed type int dword_101A5350;
// 101A5360: using guessed type int ContinuumEncryptKey;
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;
// 101B0718: using guessed type int dword_101B0718;
// 101B303C: using guessed type char byte_101B303C;
// 101B3050: using guessed type int dword_101B3050;
// 101B3058: using guessed type int ContinuumEncryptKeyCounter;
// 101C8060: using guessed type int Scrty1Version;
// 101C806C: using guessed type int dword_101C806C;

//----- (10014C30) --------------------------------------------------------
int __fastcall sub_10014C30(unsigned int a1, int a2)
{
  int result; // eax
  int v3; // esi
  unsigned int v4; // esi

  result = ((-25033 * (a1 ^ HIWORD(a1))) >> 5) & 0x7FF;
  v3 = dword_101A5398[2 * result];
  if ( v3 == a1 )
  {
LABEL_5:
    result = 8 * result + 270160796;
    if ( result )
    {
      result = *(_DWORD *)result;
      v4 = a2 + *(_DWORD *)(result + 8);
      *(_DWORD *)(result + 8) = v4;
      if ( v4 > 0x1388 )
        *(_DWORD *)(result + 8) = 4 * v4;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( !v3 )
      {
        result = 8 * result + 270160792;
        dword_101A9398 = result;
        return result;
      }
      result = ((_WORD)result + 1) & 0x7FF;
      if ( result == (((-25033 * (a1 ^ HIWORD(a1))) >> 5) & 0x7FF) )
        break;
      v3 = dword_101A5398[2 * result];
      if ( v3 == a1 )
        goto LABEL_5;
    }
    dword_101A9398 = 0;
  }
  return result;
}
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;

//----- (10014CC0) --------------------------------------------------------
int __stdcall sub_10014CC0(int a1, struct struc_2 *a2)
{
  int v2; // ecx
  unsigned int v3; // edx
  __int16 v4; // cx
  _BOOL1 v5; // dl
  __int16 v6; // ax
  int v7; // eax
  __int16 v8; // dx
  unsigned int v9; // edx
  unsigned int v10; // edi
  _DWORD *v11; // ebx
  __int16 v12; // ax
  int v13; // ecx
  __int16 v14; // dx
  _BOOL1 v15; // cc
  __int16 v16; // ax
  unsigned int v17; // edx
  const char **v18; // edi
  __int16 *v19; // esi
  char v20; // al
  __int16 v21; // cx
  int result; // eax
  char v23[4]; // [esp+0h] [ebp-40h] BYREF
  const char *v24; // [esp+20h] [ebp-20h]
  const char *v25; // [esp+24h] [ebp-1Ch]
  const char *v26; // [esp+28h] [ebp-18h]
  char *v27; // [esp+2Ch] [ebp-14h]
  const char *v28; // [esp+30h] [ebp-10h]
  char *v29; // [esp+34h] [ebp-Ch]
  char *lpszKey; // [esp+38h] [ebp-8h]
  char *lpszSection; // [esp+3Ch] [ebp-4h]

  lpszKey = "HideFlags";
  lpszSection = "Spectator";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xFD | (2 * (GetCFGSettingInteger(a2, "Spectator", "HideFlags", 0) & 1));
  lpszKey = "NoXRadar";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xFB | (4 * (GetCFGSettingInteger(a2, "Spectator", "NoXRadar", 0) & 1));
  lpszKey = "ExactDamage";
  *(_BYTE *)(a1 + 1) ^= (GetCFGSettingInteger(a2, "Bullet", "ExactDamage", 0) ^ *(_BYTE *)(a1 + 1)) & 1;
  lpszKey = "SlowFrameRate";
  v2 = GetCFGSettingInteger(a2, "Misc", "SlowFrameRate", 0);
  if ( v2 > 35 )
    v2 = 35;
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xC7 | (8 * ((v2 / 5) & 7));
  lpszKey = "MaxTimerDrift";
  if ( (unsigned int)GetCFGSettingInteger(a2, "Misc", "MaxTimerDrift", 15) > 0x23 )
  {
    v3 = 35;
  }
  else
  {
    lpszKey = "MaxTimerDrift";
    v3 = GetCFGSettingInteger(a2, "Misc", "MaxTimerDrift", 15);
  }
  v4 = *(_WORD *)(a1 + 2);
  lpszKey = "NegativeClientSlowPacketTime";
  *(_WORD *)(a1 + 2) = v4 ^ ((unsigned __int8)v4 ^ (unsigned __int8)(v3 / 5 - 1)) & 7;
  *(_BYTE *)(a1 + 1358) = GetCFGSettingInteger(a2, "Latency", lpszKey, 0);
  lpszKey = "DisableWallPass";
  v5 = GetCFGSettingInteger(a2, "Soccer", "DisableWallPass", 0) != 0;
  v6 = *(_WORD *)(a1 + 2);
  lpszKey = "DisableBallKilling";
  *(_WORD *)(a1 + 2) = v6 & 0xFFF7 | (8 * v5);
  v7 = GetCFGSettingInteger(a2, "Soccer", lpszKey, 0);
  v8 = *(_WORD *)(a1 + 2);
  lpszKey = "AntiWarpSettleDelay";
  *(_WORD *)(a1 + 2) = v8 & 0xFFEF | (16 * (v7 != 0));
  v9 = GetCFGSettingInteger(a2, "Misc", lpszKey, 0) / 10;
  if ( v9 >= 0xFF )
    LOBYTE(v9) = -1;
  *(_BYTE *)(a1 + 1392) = v9;
  lpszKey = "DisableScreenshot";
  *(_BYTE *)(a1 + 1) = *(_BYTE *)(a1 + 1) & 0xBF | ((GetCFGSettingInteger(a2, "Misc", "DisableScreenshot", 0) != 0) << 6);
  lpszKey = v23;
  v10 = 0;
  v29 = v23;
  lpszSection = "Spawn";
  v27 = v23;
  v28 = "Spawn";
  v11 = (_DWORD *)(a1 + 1236);
  do
  {
    sprintf_0(v23, "Team%d-X", v10);
    v26 = (const char *)GetCFGSettingInteger(a2, "Spawn", lpszKey, 0);
    sprintf_0(v23, "Team%d-Y", v10);
    v25 = (const char *)GetCFGSettingInteger(a2, lpszSection, v29, 0);
    sprintf_0(v23, "Team%d-Radius", v10);
    v24 = (const char *)GetCFGSettingInteger(a2, v28, v27, 0);
    v12 = (__int16)v26;
    if ( (unsigned int)v26 > 0x3FF )
      v12 = 1023;
    v13 = *v11 ^ ((unsigned __int16)v12 ^ (unsigned __int16)*v11) & 0x3FF;
    v14 = (__int16)v25;
    v15 = (unsigned int)v25 <= 0x3FF;
    *v11 = v13;
    if ( !v15 )
      v14 = 1023;
    v16 = (__int16)v24;
    v17 = v13 & 0xFFF003FF | ((v14 & 0x3FF) << 10);
    v15 = (unsigned int)v24 <= 0x1FF;
    *v11 = v17;
    if ( !v15 )
      v16 = 511;
    *v11 = v17 & 0xFFFFF | ((v16 & 0x1FF) << 20);
    ++v10;
    ++v11;
  }
  while ( v10 < 4 );
  v24 = "SeeBombLevel";
  v25 = "DisableFastShooting";
  v26 = "Radius";
  v18 = (const char **)off_100246F8;
  v19 = (__int16 *)(a1 + 32);
  do
  {
    *v19 ^= ((unsigned __int8)GetCFGSettingInteger(a2, *v18, v24, 0) ^ (unsigned __int8)*v19) & 3;
    *v19 = *v19 & 0xFFFB | (4 * (GetCFGSettingInteger(a2, *v18, v25, 0) & 1));
    v20 = GetCFGSettingInteger(a2, *v18, v26, 0);
    v21 = *v19;
    ++v18;
    v19 += 72;
    result = v21 & 0xFC07 | (8 * (v20 & 0x7F));
    *(v19 - 72) = result;
  }
  while ( (int)v18 < (int)FIX_DLL_Cmd );
  return result;
}
// 100246F8: using guessed type char *off_100246F8[8];
// 10024718: using guessed type int FIX_DLL_Cmd[22];

//----- (100150F0) --------------------------------------------------------
size_t __stdcall sub_100150F0(int a1, _BYTE *a2, size_t a3, char *a4)
{
  unknown_libname_56(&a1, a1 + 70);
  return sub_1000A060(&a1, a4, a2, a3);
}

//----- (10015120) --------------------------------------------------------
size_t __stdcall sub_10015120(int a1, void *a2, size_t a3)
{
  unknown_libname_56(&a1, a1 + 70);
  return sub_1000A150(&a1, a2, (int *)a2, a3);
}

//----- (10015150) --------------------------------------------------------
#error "100151AB: call analysis failed (funcsize=27)"

//----- (100151C0) --------------------------------------------------------
int __cdecl sub_100151C0(va_list ap, int a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  int *v5; // eax
  int v6; // eax
  unsigned int v7; // ecx
  time_t v8; // eax
  char *v9; // esi
  int result; // eax
  PLAYER *v11; // eax
  _BOOL1 v12; // cc
  char src[512]; // [esp+0h] [ebp-30Ch] BYREF
  char v14[3]; // [esp+200h] [ebp-10Ch] BYREF
  __int16 v15; // [esp+203h] [ebp-109h]
  int dst[62]; // [esp+205h] [ebp-107h] BYREF
  void *buf; // [esp+300h] [ebp-Ch]
  PLAYER *player; // [esp+304h] [ebp-8h]
  int buf_sz; // [esp+308h] [ebp-4h]
  PLAYER **apa; // [esp+314h] [ebp+8h]
  int v21; // [esp+318h] [ebp+Ch]

  if ( a2 )
  {
    v2 = *(_DWORD *)(a2 + 755);
    v3 = ((-25033 * (v2 ^ HIWORD(v2))) >> 5) & 0x7FF;
    v4 = dword_101A5398[2 * v3];
    if ( v4 == v2 )
    {
LABEL_6:
      v5 = (int *)(8 * v3 + 270160796);
      if ( v5 )
      {
        v6 = *v5;
        v7 = *(_DWORD *)(v6 + 8) + 500;
        *(_DWORD *)(v6 + 8) = v7;
        if ( v7 > 0x1388 )
          *(_DWORD *)(v6 + 8) = 4 * v7;
      }
    }
    else
    {
      while ( 1 )
      {
        if ( !v4 )
        {
          dword_101A9398 = 8 * v3 + 270160792;
          goto LABEL_9;
        }
        v3 = ((_WORD)v3 + 1) & 0x7FF;
        if ( v3 == (((-25033 * (v2 ^ HIWORD(*(_DWORD *)(a2 + 755)))) >> 5) & 0x7FF) )
          break;
        v4 = dword_101A5398[2 * v3];
        if ( v4 == v2 )
          goto LABEL_6;
      }
      dword_101A9398 = 0;
    }
LABEL_9:
    v8 = time_0(0);
    sprintf_0(
      src,
      "%s (%s)(%d)(%d.%d.%d.%d)(sec=%d)",
      ap,
      (const char *)(a2 + 675),
      *(_DWORD *)(a2 + 761),
      (unsigned __int8)v2,
      BYTE1(v2),
      BYTE2(v2),
      HIBYTE(v2),
      v8 - *(_DWORD *)(a2 + 765));
    v9 = src;
  }
  else
  {
    v9 = ap;
  }
  off_10024608("%s\n", v9);
  result = ZonePlayerCount;
  v21 = 0;
  if ( ZonePlayerCount > 0 )
  {
    apa = (PLAYER **)ZonePlayers;
    do
    {
      v11 = *apa;
      player = *apa;
      if ( player && v11->lpCurrentArena )
      {
        if ( v11->bIsSysop )
        {
          v14[0] = 7;
          v14[1] = 8;
          v14[2] = 0;
          v15 = -1;
          strncpyt(dst, v9, 250);
          buf_sz = strlen((const char *)dst) + 6;
          buf = v14;
          PlayerSendPacket(player, v14, buf_sz, 1);
        }
      }
      result = v21 + 1;
      v12 = ++v21 < ZonePlayerCount;
      ++apa;
    }
    while ( v12 );
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 10024608: using guessed type int (*off_10024608)(const char *, ...);
// 101A5398: using guessed type int dword_101A5398[];
// 101A9398: using guessed type int dword_101A9398;

//----- (10015390) --------------------------------------------------------
int sub_10015390()
{
  int v0; // ebx
  int v1; // edi
  int *v2; // esi
  int result; // eax

  v0 = FIX_DLL_KERNEL32_dll_GetTickCount();
  if ( v0 - dword_101C8070 >= dword_101A5354 || !dword_101C8070 )
  {
    dword_101C8070 = v0;
    SendPacketsToEverybody((struct PACKET_ATTACHMENT *)ServerPacketAttachment);
  }
  v1 = 0;
  if ( ZonePlayerCount > 0 )
  {
    v2 = ZonePlayers;
    do
    {
      if ( *(_DWORD *)(*v2 + 1619) )
        sub_100137F0(*v2);
      ++v1;
      ++v2;
    }
    while ( v1 < ZonePlayerCount );
  }
  result = dword_10029300;
  if ( v0 - dword_10029300 >= 60000 || !dword_10029300 )
  {
    result = 0;
    dword_100292F0[0] = 0;
    dword_101B3040 = 0;
    dword_100292F4 = 0;
    dword_101B3044 = 0;
    dword_100292F8 = 0;
    dword_101B3048 = 0;
    dword_10029300 = v0;
    dword_100292FC = 0;
    dword_101B304C = 0;
  }
  return result;
}
// 4CA230: using guessed type int ZonePlayers[];
// 4D9DCC: using guessed type int ZonePlayerCount;
// 10021084: using guessed type int (*FIX_DLL_KERNEL32_dll_GetTickCount)(void);
// 100292F0: using guessed type int dword_100292F0[];
// 100292F4: using guessed type int dword_100292F4;
// 100292F8: using guessed type int dword_100292F8;
// 100292FC: using guessed type int dword_100292FC;
// 10029300: using guessed type int dword_10029300;
// 101A5354: using guessed type int dword_101A5354;
// 101B3040: using guessed type int dword_101B3040;
// 101B3044: using guessed type int dword_101B3044;
// 101B3048: using guessed type int dword_101B3048;
// 101B304C: using guessed type int dword_101B304C;
// 101C8070: using guessed type int dword_101C8070;

//----- (10015450) --------------------------------------------------------
int sub_10015450()
{
  int result; // eax
  int v1; // edx
  int v2; // ecx
  int v3[2]; // [esp+0h] [ebp-10Ch] BYREF
  int v4; // [esp+8h] [ebp-104h] BYREF
  int v5[64]; // [esp+Ch] [ebp-100h]

  sub_1000AEA0(byte_1003E438);
  result = dword_10065078 + ZonePlayerCount;
  ZonePlayerCountt = dword_10065078 + ZonePlayerCount;
  v1 = dword_101A535C;
  if ( dword_101A535C )
  {
    v4 = 0;
    v2 = 1;
    v5[0] = *((_DWORD *)ServerPacketAttachment + 6);
    v4 = 1;
    if ( BillingConnectionStructPointer && *(_DWORD *)BillingConnectionStructPointer )
    {
      v5[1] = *(_DWORD *)(*(_DWORD *)BillingConnectionStructPointer + 24);
      v2 = 2;
      v4 = 2;
    }
    if ( SeverListenerPortPlusOneSocket )
    {
      v5[v2] = *(_DWORD *)SeverListenerPortPlusOneSocket;
      ++v4;
    }
    v3[0] = 0;
    v3[1] = 1000 * v1;
    result = ((int (__cdecl *)(_DWORD, int *, _DWORD, _DWORD, int *))j_FIX_DLL_WSOCK32_dll_ord_0012)(0, &v4, 0, 0, v3);
  }
  return result;
}
// 100154C7: conditional instruction was optimized away because of 'ecx.4 in (1..2)'
// 4D9DCC: using guessed type int ZonePlayerCount;
// 100159FC: using guessed type int __cdecl j_FIX_DLL_WSOCK32_dll_ord_0012(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10065078: using guessed type int dword_10065078;
// 101A535C: using guessed type int dword_101A535C;

//----- (10015510) --------------------------------------------------------
#error "1001557A: call analysis failed (funcsize=41)"

//----- (10015590) --------------------------------------------------------
int __stdcall sub_10015590(int a1, int a2, int a3)
{
  if ( a2 == 1 )
    sub_10016FAF((int)"-------------------:  Extended version %s\n", (int)"1.34.14b (Thu May  6 14:31:45 2004)");
  return 1;
}

//----- (10015610) --------------------------------------------------------
_DWORD *__thiscall sub_10015610(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[2] = 0;
  this[1] = 0;
  *this = 0;
  return result;
}

//----- (10015620) --------------------------------------------------------
int __thiscall sub_10015620(int this)
{
  int result; // eax

  sub_10002D60(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (10015680) --------------------------------------------------------
int __thiscall sub_10015680(int this)
{
  int result; // eax

  sub_10002D60(*(void **)this);
  result = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (100156A0) --------------------------------------------------------
_DWORD *__thiscall sub_100156A0(_DWORD *this, int a2)
{
  _DWORD *v2; // edi
  _BYTE *v3; // eax
  int v4; // ecx
  int v5; // esi
  void *v6; // ecx
  int v7; // ebx
  int *v8; // esi
  _DWORD *v9; // ebp
  int v10; // ebx
  _DWORD *v11; // edx
  void *v13; // [esp-18h] [ebp-3Ch]
  _DWORD *v14; // [esp+10h] [ebp-14h]
  int v15[4]; // [esp+14h] [ebp-10h] BYREF
  int v16; // [esp+28h] [ebp+4h]

  v2 = this;
  v14 = this;
  v3 = this;
  v4 = a2 - (_DWORD)this;
  v5 = 32;
  do
  {
    *v3 = v3[v4];
    ++v3;
    --v5;
  }
  while ( v5 );
  v6 = (void *)v2[8];
  v7 = *(_DWORD *)(a2 + 40);
  v8 = v2 + 8;
  v15[0] = *(_DWORD *)(a2 + 32);
  sub_10002D60(v6);
  v2[8] = 0;
  v2[10] = 0;
  v2[9] = 0;
  if ( !v7 )
    return v2;
  v9 = (_DWORD *)v15[0];
  v16 = v7;
  do
  {
    v10 = v2[10];
    if ( v10 >= v2[9] )
    {
      sub_10002D10(v8, 16 * (v10 + 32));
      v2[9] += 32;
    }
    memcpy_0((void *)(v2[8] + 16 * (v10 + 1)), (const void *)(16 * v10 + v2[8]), 16 * (v2[10] + 0xFFFFFFF * v10));
    v13 = (void *)(16 * v10 + *v8);
    ++v2[10];
    memcpy_0(v13, v15, 0x10u);
    v11 = (_DWORD *)(16 * v10 + *v8);
    *v11 = *v9;
    v11[1] = v9[1];
    v11[2] = v9[2];
    v11[3] = v9[3];
    v9 += 4;
    --v16;
  }
  while ( v16 );
  return v14;
}

//----- (100157A0) --------------------------------------------------------
int __thiscall sub_100157A0(int this, int a2)
{
  int v3; // eax
  int v4; // ebx
  int v5; // edx
  int v6; // esi
  char v8[32]; // [esp+Ch] [ebp-2Ch] BYREF
  void *v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v3 = *(_DWORD *)(this + 8);
  if ( v3 >= *(_DWORD *)(this + 4) )
  {
    sub_10002D10((int *)this, 4 * (v3 + 2 * (5 * v3 + 160) + 32));
    *(_DWORD *)(this + 4) += 32;
  }
  memcpy_0(
    (void *)(*(_DWORD *)this + 4 * (a2 + 2 * (5 * a2 + 5) + 1)),
    (const void *)(*(_DWORD *)this + 44 * a2),
    44 * *(_DWORD *)(this + 8) - 44 * a2);
  v4 = *(_DWORD *)this;
  v5 = *(_DWORD *)(this + 8) + 1;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  *(_DWORD *)(this + 8) = v5;
  memcpy_0((void *)(v4 + 44 * a2), v8, 0x2Cu);
  v6 = *(_DWORD *)this + 44 * a2;
  sub_10002D60(v9);
  return v6;
}

//----- (10015A20) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char *__cdecl strncpy_0(char *a1, const char *a2, size_t a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  char *v5; // esi
  char *v6; // edi
  unsigned int v7; // ecx
  char v8; // al
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // edx
  char *v13; // [esp-4h] [ebp-8h]
  char *v14; // [esp+0h] [ebp-4h]
  unsigned int retaddr; // [esp+4h] [ebp+0h]

  v3 = retaddr;
  if ( !retaddr )
    return v13;
  v4 = retaddr;
  v5 = v14;
  v6 = v13;
  if ( ((unsigned __int8)v14 & 3) == 0 )
  {
    v7 = retaddr >> 2;
    if ( retaddr >> 2 )
      goto LABEL_21;
LABEL_10:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return v13;
    }
    while ( --v4 )
LABEL_17:
      *v6++ = v8;
    return v13;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return v13;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return a1;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
LABEL_9:
    v4 &= 3u;
    if ( v4 )
      goto LABEL_10;
    return v13;
  }
  while ( 1 )
  {
LABEL_21:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto LABEL_20;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto LABEL_30;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto LABEL_30;
    }
LABEL_20:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto LABEL_9;
  }
  *(_DWORD *)v6 = 0;
LABEL_30:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
LABEL_31:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto LABEL_17;
  return a1;
}
// 10015B1D: positive sp value C has been found
// 10015A2D: variable 'v14' is possibly undefined
// 10015A37: variable 'v13' is possibly undefined

//----- (10015B1E) --------------------------------------------------------
void __stdcall _JumpToContinuation(void *a1, struct EHRegistrationNode *a2)
{
  __asm { jmp     eax }
}

//----- (10015BB6) --------------------------------------------------------
int __usercall __CxxFrameHandler_0@<eax>(struct _s_FuncInfo *a1@<eax>, void *a2@<ecx>, int a3@<ebx>, EXCEPTION_RECORD *a4, struct EHRegistrationNode *a5, struct _CONTEXT *a6, void *a7)
{
  return __InternalCxxFrameHandler_0(a2, a3, a4, a5, a6, a7, a1, 0, 0, 0);
}

//----- (10015C06) --------------------------------------------------------
void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *a1, const struct _s_FuncInfo *a2, void *a3, int a4, unsigned __int32 a5)
{
  return (void *)unknown_libname_65(a3, a1, a5);
}
// 10017F50: using guessed type _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD);

//----- (10015C5A) --------------------------------------------------------
int __usercall CatchGuardHandler@<eax>(void *a1@<ecx>, int a2@<ebx>, struct EHExceptionRecord *a3, struct CatchGuardRN *a4, void *a5)
{
  return __InternalCxxFrameHandler_0(
           a1,
           a2,
           (PEXCEPTION_RECORD)a3,
           *((struct EHRegistrationNode **)a4 + 3),
           (struct _CONTEXT *)a5,
           0,
           *((struct _s_FuncInfo **)a4 + 2),
           *((_DWORD *)a4 + 4),
           a4,
           0);
}

//----- (10015D33) --------------------------------------------------------
int __usercall TranslatorGuardHandler@<eax>(void *a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, int a5)
{
  if ( (ExceptionRecord->ExceptionFlags & 0x66) == 0 )
  {
    __InternalCxxFrameHandler_0(
      a1,
      a2,
      ExceptionRecord,
      *((struct EHRegistrationNode **)TargetFrame + 3),
      (struct _CONTEXT *)a5,
      0,
      *((struct _s_FuncInfo **)TargetFrame + 2),
      *((_DWORD *)TargetFrame + 4),
      *((PVOID *)TargetFrame + 5),
      1u);
    if ( !*((_DWORD *)TargetFrame + 9) )
      unknown_libname_60(TargetFrame, ExceptionRecord);
    __asm { jmp     dword ptr [ebx+18h] }
  }
  *((_DWORD *)TargetFrame + 9) = 1;
  return 1;
}
// 10015B67: using guessed type _DWORD __stdcall unknown_libname_60(_DWORD, _DWORD);

//----- (10015DA8) --------------------------------------------------------
const struct _s_TryBlockMapEntry *__thiscall _GetRangeOfTrysToCheck(void *this, const struct _s_FuncInfo *a2, int a3, int a4, unsigned int *a5, unsigned int *a6)
{
  unsigned int v7; // esi
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v12; // [esp+0h] [ebp-4h]
  unsigned int v13; // [esp+Ch] [ebp+8h]

  v7 = *((_DWORD *)a2 + 3);
  v8 = *((_DWORD *)a2 + 4);
  v9 = v7;
  v13 = v7;
  v12 = v7;
  if ( a3 >= 0 )
  {
    do
    {
      if ( v7 == -1 )
        sub_10018002((int)this, v8, (int)a2, -1);
      this = (void *)a4;
      --v7;
      if ( *(_DWORD *)(v8 + 20 * v7 + 4) < a4 && a4 <= *(_DWORD *)(v8 + 20 * v7 + 8) || v7 == -1 )
      {
        --a3;
        v12 = v13;
        v13 = v7;
      }
    }
    while ( a3 >= 0 );
    v9 = v12;
  }
  v10 = v7 + 1;
  *a5 = v10;
  *a6 = v9;
  if ( v9 > *((_DWORD *)a2 + 3) || v10 > v9 )
    sub_10018002((int)a6, v8, (int)a2, v10);
  return (const struct _s_TryBlockMapEntry *)(v8 + 20 * v10);
}

//----- (10015E24) --------------------------------------------------------
int __cdecl _global_unwind2_0(PVOID TargetFrame)
{
  return j_FIX_DLL_KERNEL32_dll_RtlUnwind();
}

//----- (10015E44) --------------------------------------------------------
int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (10015E66) --------------------------------------------------------
int __cdecl _local_unwind2_0(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // esi
  unsigned int v6; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v7)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]
  int v8; // [esp+0h] [ebp-14h]

  v7 = _unwind_handler;
  v6 = __readfsdword(0);
  while ( 1 )
  {
    result = a1;
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 == -1 || v4 == a2 )
      break;
    v5 = 3 * v4;
    v8 = *(_DWORD *)(v3 + 4 * v5);
    *(_DWORD *)(a1 + 12) = v8;
    if ( !*(_DWORD *)(v3 + 4 * v5 + 4) )
    {
      ((void (__stdcall *)(int))loc_10015EFA)(257);
      (*(void (__cdecl **)(unsigned int, int (__cdecl *)(int, int, int, _DWORD *), int, int))(v3 + 4 * v5 + 8))(
        v6,
        v7,
        v8,
        a1);
    }
  }
  return result;
}
// 10015EBA: variable 'v6' is possibly undefined
// 10015EBA: variable 'v7' is possibly undefined
// 10015EBA: variable 'a1' is possibly undefined

//----- (10015ECE) --------------------------------------------------------
int __cdecl _abnormal_termination_0()
{
  int result; // eax
  unsigned int v1; // ecx

  result = 0;
  v1 = __readfsdword(0);
  if ( *(int (__cdecl **)(int, int, int, _DWORD *))(v1 + 4) == _unwind_handler
    && *(_DWORD *)(v1 + 8) == *(_DWORD *)(*(_DWORD *)(v1 + 12) + 12) )
  {
    result = 1;
  }
  return result;
}

//----- (10015EF1) --------------------------------------------------------
int __userpurge sub_10015EF1@<eax>(int result@<eax>, int a2@<ecx>, int a3@<ebp>, int a4)
{
  dword_10025D60[2] = a2;
  dword_10025D60[1] = result;
  dword_10025D60[3] = a3;
  return result;
}

//----- (10015F12) --------------------------------------------------------
void _cinit_0()
{
  if ( off_10025DCC )
    off_10025DCC();
  sub_10016018((void (**)(void))&unk_10024034, (unsigned int)&loc_10024044 + 4);
  sub_10016018((void (**)(void))&unk_10024000, (unsigned int)&loc_1002402B + 5);
}
// 10025DCC: using guessed type int (*off_10025DCC)(void);

//----- (10015F3F) --------------------------------------------------------
void __cdecl sub_10015F3F(UINT a1)
{
  doexit_0(a1, 0, 0);
}

//----- (10015F50) --------------------------------------------------------
void __cdecl sub_10015F50(UINT a1)
{
  doexit_0(a1, 1, 0);
}

//----- (10015F7F) --------------------------------------------------------
void __cdecl doexit_0(UINT uExitCode, int a2, int a3)
{
  int v3; // eax
  void (**v4)(void); // esi

  if ( dword_101C80BC == 1 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetCurrentProcess(uExitCode);
    FIX_DLL_KERNEL32_dll_TerminateProcess(v3);
  }
  dword_101C80B8 = 1;
  byte_101C80B4 = a3;
  if ( !a2 )
  {
    if ( dword_101C9718 )
    {
      v4 = (void (**)(void))(dword_101C9714 - 4);
      if ( dword_101C9714 - 4 >= (unsigned int)dword_101C9718 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ( (unsigned int)v4 >= dword_101C9718 );
      }
    }
    sub_10016018((void (**)(void))((char *)&unk_1002404B + 1), (unsigned int)&loc_10024053 + 1);
  }
  sub_10016018((void (**)(void))&unk_10024058, (unsigned int)&loc_1002405F + 1);
  if ( !a3 )
  {
    dword_101C80BC = 1;
    FIX_DLL_KERNEL32_dll_ExitProcess(uExitCode);
  }
}
// 10021148: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_ExitProcess)(_DWORD);
// 1002114C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_TerminateProcess)(_DWORD);
// 10021150: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetCurrentProcess)(_DWORD);
// 101C80B4: using guessed type char byte_101C80B4;
// 101C80B8: using guessed type int dword_101C80B8;
// 101C80BC: using guessed type int dword_101C80BC;
// 101C9714: using guessed type int dword_101C9714;
// 101C9718: using guessed type int dword_101C9718;

//----- (10016018) --------------------------------------------------------
void __cdecl sub_10016018(void (**a1)(void), unsigned int a2)
{
  while ( (unsigned int)a1 < a2 )
  {
    if ( *a1 )
      (*a1)();
    ++a1;
  }
}

//----- (10016163) --------------------------------------------------------
int __cdecl atol_0(const char *String)
{
  int v3; // esi
  const char *v4; // edi
  int v5; // ebp
  int v6; // ebx
  int result; // eax

  while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * *(unsigned __int8 *)String) & 8 : _isctype_0(*(unsigned __int8 *)String, 8) )
    ++String;
  v3 = *(unsigned __int8 *)String;
  v4 = String + 1;
  v5 = v3;
  if ( v3 == 45 || v3 == 43 )
    v3 = *(unsigned __int8 *)v4++;
  v6 = 0;
  while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * v3) & 4 : _isctype_0(v3, 4) )
  {
    v6 = v3 + 10 * v6 - 48;
    v3 = *(unsigned __int8 *)v4++;
  }
  result = v6;
  if ( v5 == 45 )
    result = -v6;
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100161EE) --------------------------------------------------------
__int32 __stdcall atol_1(const char *a1)
{
  return atol_0(a1);
}

//----- (100162D0) --------------------------------------------------------
char *__cdecl strchr_0(const char *Str, int Val)
{
  const char *v2; // edx
  char v3; // cl
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  unsigned int v7; // eax
  char *result; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax

  v2 = Str;
  if ( ((unsigned __int8)Str & 3) != 0 )
  {
    while ( 1 )
    {
      v3 = *v2++;
      if ( v3 == (_BYTE)Val )
        JUMPOUT(0x100162C0);
      if ( !v3 )
        break;
      if ( ((unsigned __int8)v2 & 3) == 0 )
        goto LABEL_5;
    }
LABEL_9:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
LABEL_5:
      while ( 1 )
      {
        v4 = (((unsigned __int8)Val << 8) | (unsigned __int8)Val | ((((unsigned __int8)Val << 8) | (unsigned __int8)Val) << 16)) ^ *(_DWORD *)v2;
        v5 = *(_DWORD *)v2 + 2130640639;
        v6 = v5 ^ ~*(_DWORD *)v2;
        v2 += 4;
        if ( (((v4 + 2130640639) ^ ~v4) & 0x81010100) != 0 )
          break;
        v7 = v6 & 0x81010100;
        if ( v7 && ((v7 & 0x1010100) != 0 || (v5 & 0x80000000) == 0) )
          goto LABEL_9;
      }
      v9 = *((_DWORD *)v2 - 1);
      if ( (_BYTE)v9 == (_BYTE)Val )
        break;
      if ( !(_BYTE)v9 )
        goto LABEL_9;
      if ( BYTE1(v9) == (_BYTE)Val )
        return (char *)(v2 - 3);
      if ( !BYTE1(v9) )
        goto LABEL_9;
      v10 = HIWORD(v9);
      if ( (_BYTE)v10 == (_BYTE)Val )
        return (char *)(v2 - 2);
      if ( !(_BYTE)v10 )
        goto LABEL_9;
      if ( BYTE1(v10) == (_BYTE)Val )
        return (char *)(v2 - 1);
      if ( !BYTE1(v10) )
        goto LABEL_9;
    }
    result = (char *)(v2 - 4);
  }
  return result;
}
// 100162ED: control flows out of bounds to 100162C0

//----- (1001638C) --------------------------------------------------------
int __cdecl vsprintf_0(char *a1, const char *a2, va_list a3)
{
  int v3; // eax
  _BOOL1 v4; // sf
  int v5; // esi
  FILE v7; // [esp+0h] [ebp-20h] BYREF

  v7._base = a1;
  v7._ptr = a1;
  v7._flag = 66;
  v7._cnt = 0x7FFFFFFF;
  v3 = _output_0(&v7, (int)a2, (int)a3);
  v4 = --v7._cnt < 0;
  v5 = v3;
  if ( v4 )
    _flsbuf_0(0, &v7);
  else
    *v7._ptr = 0;
  return v5;
}

//----- (100163DD) --------------------------------------------------------
int __cdecl sub_100163DD(int a1)
{
  int result; // eax

  result = dword_101C8100;
  dword_101C8100 = a1;
  return result;
}
// 101C8100: using guessed type int dword_101C8100;

//----- (100163ED) --------------------------------------------------------
int (*__cdecl sub_100163ED(int (*a1)()))()
{
  int (*result)(); // eax

  result = off_10025DF0[0];
  off_10025DF0[0] = a1;
  return result;
}
// 10025DF0: using guessed type int (*off_10025DF0[2])();

//----- (100163FD) --------------------------------------------------------
int __cdecl sub_100163FD(int a1)
{
  int result; // eax

  result = dword_101C80FC;
  dword_101C80FC = a1;
  return result;
}
// 101C80FC: using guessed type int dword_101C80FC;

//----- (1001640D) --------------------------------------------------------
int (*__cdecl sub_1001640D(int (*a1)()))()
{
  int (*result)(); // eax

  result = off_10025DF4;
  off_10025DF4 = a1;
  return result;
}
// 10025DF4: using guessed type int (*off_10025DF4)();

//----- (100164A4) --------------------------------------------------------
char *__thiscall sub_100164A4(char *this)
{
  return this + 8;
}

//----- (100164A8) --------------------------------------------------------
_DWORD *__thiscall sub_100164A8(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_10021A94;
  return result;
}
// 10021A94: using guessed type void *(__thiscall *off_10021A94)(type_info *__hidden this, unsigned int);

//----- (100164B3) --------------------------------------------------------
void *__thiscall sub_100164B3(void *this, int a2)
{
  return this;
}

//----- (100164B8) --------------------------------------------------------
// #API: RaiseException()
// #API: RaiseException()
void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo)
{
  _DWORD v2[8]; // [esp+0h] [ebp-20h] BYREF

  qmemcpy(v2, &unk_10021A98, sizeof(v2));
  v2[6] = pExceptionObject;
  v2[7] = pThrowInfo;
  FIX_DLL_KERNEL32_dll_RaiseException(v2[0], v2[1], v2[4], &v2[5]);
}
// 10021154: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_RaiseException)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100165F0) --------------------------------------------------------
#error "10016748: invalid basic block (funcsize=104)"

//----- (1001692D) --------------------------------------------------------
int __cdecl toupper_0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // [esp-8h] [ebp-Ch]
  int v6; // [esp+0h] [ebp-4h] BYREF

  if ( dword_101C8114 )
  {
    v2 = a1;
    if ( (a1 >= 256
       || ((int)dword_10026004 <= 1 ? (v3 = *(_BYTE *)(dword_10025DF8 + 2 * a1) & 2) : (v3 = _isctype_0(a1, 2)), v3))
      && (*(char *)(dword_10025DF8 + 2 * BYTE1(v2) + 1) >= 0 ? (LOWORD(a1) = (unsigned __int8)v2, v5 = 1) : (LOBYTE(a1) = BYTE1(v2), *(_WORD *)((char *)&a1 + 1) = (unsigned __int8)v2, v5 = 2),
          (v4 = __crtLCMapStringA_0(dword_101C8114, 0x200u, (LPCSTR)&a1, v5, (LPSTR)&v6, 3, 0, 1)) != 0) )
    {
      if ( v4 == 1 )
        result = (unsigned __int8)v6;
      else
        result = (unsigned __int16)v6;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = a1;
    if ( a1 >= 97 && a1 <= 122 )
      result = a1 - 32;
  }
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;
// 101C8114: using guessed type int dword_101C8114;

//----- (10016A01) --------------------------------------------------------
int __cdecl tolower_0(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+0h] [ebp-4h] BYREF

  if ( dword_101C8114 )
  {
    v2 = a1;
    if ( (a1 >= 256
       || ((int)dword_10026004 <= 1 ? (v3 = *(_BYTE *)(dword_10025DF8 + 2 * a1) & 1) : (v3 = _isctype_0(a1, 1)), v3))
      && (*(char *)(dword_10025DF8 + 2 * BYTE1(v2) + 1) >= 0 ? (LOWORD(a1) = (unsigned __int8)v2, v4 = 1) : (LOBYTE(a1) = BYTE1(v2), *(_WORD *)((char *)&a1 + 1) = (unsigned __int8)v2, v4 = 2),
          (v5 = __crtLCMapStringA_0(dword_101C8114, 0x100u, (LPCSTR)&a1, v4, (LPSTR)&v6, 3, 0, 1)) != 0) )
    {
      if ( v5 == 1 )
        result = (unsigned __int8)v6;
      else
        result = (unsigned __int16)v6;
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = a1;
    if ( a1 >= 65 && a1 <= 90 )
      result = a1 + 32;
  }
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;
// 101C8114: using guessed type int dword_101C8114;

//----- (10016B75) --------------------------------------------------------
int sprintf_0(char *a1, const char *a2, ...)
{
  int v2; // eax
  _BOOL1 v3; // sf
  int v4; // esi
  FILE v6; // [esp+0h] [ebp-20h] BYREF
  va_list va; // [esp+30h] [ebp+10h] BYREF

  va_start(va, a2);
  v6._base = a1;
  v6._ptr = a1;
  v6._flag = 66;
  v6._cnt = 0x7FFFFFFF;
  v2 = _output_0(&v6, (int)a2, (int)va);
  v3 = --v6._cnt < 0;
  v4 = v2;
  if ( v3 )
    _flsbuf_0(0, &v6);
  else
    *v6._ptr = 0;
  return v4;
}

//----- (10016FAF) --------------------------------------------------------
int __cdecl sub_10016FAF(int a1, int a2)
{
  int v2; // edi
  int v3; // ebx

  v2 = _stbuf_0((int)&File);
  v3 = _output_0(&File, a1, (int)&a2);
  _ftbuf_0(v2, (int)&File);
  return v3;
}

//----- (10016FF7) --------------------------------------------------------
unsigned int sub_10016FF7()
{
  unsigned int result; // eax

  _cfltcvt_init_0();
  dword_101C80C4 = _ms_p5_mp_test_fdiv_0();
  result = sub_10019CC7();
  __asm { fnclex }
  return result;
}
// 101C80C4: using guessed type int dword_101C80C4;

//----- (1001700F) --------------------------------------------------------
void *_cfltcvt_init_0()
{
  void *result; // eax

  result = &unk_1001A105;
  off_10026334[0] = (int (*)())&unk_10019D9A;
  off_10026330[0] = (int (*)())&unk_1001A105;
  dword_10026338 = (int)&unk_10019E00;
  off_1002633C[0] = (int (*)())&unk_10019D40;
  dword_10026340 = (int)&unk_10019DE8;
  dword_10026344 = (int)&unk_1001A105;
  return result;
}
// 10026330: using guessed type int (*off_10026330[6])();
// 10026334: using guessed type int (*off_10026334[5])();
// 10026338: using guessed type int dword_10026338;
// 1002633C: using guessed type int (*off_1002633C[3])();
// 10026340: using guessed type int dword_10026340;
// 10026344: using guessed type int dword_10026344;

//----- (10017122) --------------------------------------------------------
void __usercall sub_10017122(int a1@<ebp>)
{
  if ( !*(_DWORD *)(a1 - 32) )
    __ArrayUnwind(
      *(void **)(a1 + 8),
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(a1 - 28),
      *(void (__thiscall **)(void *))(a1 + 24));
}
// 100171BA: using guessed type void __stdcall __ArrayUnwind(void *, unsigned int, _DWORD, void (__thiscall *)(void *));

//----- (1001722E) --------------------------------------------------------
int __cdecl isalpha_0(int a1)
{
  int result; // eax

  if ( (int)dword_10026004 <= 1 )
    result = *(_WORD *)(dword_10025DF8 + 2 * a1) & 0x103;
  else
    result = _isctype_0(a1, 259);
  return result;
}
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100172AC) --------------------------------------------------------
void sub_100172AC()
{
  if ( dword_10026004 > 1 )
    JUMPOUT(0x100172B5);
  JUMPOUT(0x100172C3);
}
// 100172B3: control flows out of bounds to 100172B5
// 100172B3: control flows out of bounds to 100172C3
// 10026004: using guessed type int dword_10026004;

//----- (100174A0) --------------------------------------------------------
char *__cdecl strrchr_0(const char *a1, int a2)
{
  unsigned int v2; // ecx
  const char *v3; // edi
  _BOOL1 v4; // zf
  char *v5; // edi
  char *result; // eax

  v2 = strlen(a1) + 1;
  v3 = &a1[v2 - 1];
  do
  {
    if ( !v2 )
      break;
    v4 = *v3-- == (unsigned __int8)a2;
    --v2;
  }
  while ( !v4 );
  v5 = (char *)(v3 + 1);
  if ( *v5 == (_BYTE)a2 )
    result = v5;
  else
    result = 0;
  return result;
}

//----- (100174D1) --------------------------------------------------------
int sub_100174D1()
{
  dword_10025DE0 = 214013 * dword_10025DE0 + 2531011;
  return (dword_10025DE0 >> 16) & 0x7FFF;
}
// 10025DE0: using guessed type int dword_10025DE0;

//----- (100174EF) --------------------------------------------------------
time_t __cdecl time_0(time_t *a1)
{
  int v1; // eax
  int v2; // eax
  time_t result; // eax
  _DWORD v4[38]; // [esp+0h] [ebp-CCh] BYREF
  __int16 v5; // [esp+9Ah] [ebp-32h]
  int v6; // [esp+A8h] [ebp-24h]
  int v7; // [esp+ACh] [ebp-20h] BYREF
  int v8; // [esp+B0h] [ebp-1Ch]
  int v9; // [esp+B4h] [ebp-18h]
  int v10; // [esp+B8h] [ebp-14h]
  int v11; // [esp+BCh] [ebp-10h] BYREF
  unsigned __int16 v12; // [esp+C2h] [ebp-Ah]
  unsigned __int16 v13; // [esp+C4h] [ebp-8h]
  unsigned __int16 v14; // [esp+C6h] [ebp-6h]
  unsigned __int16 v15; // [esp+C8h] [ebp-4h]

  FIX_DLL_KERNEL32_dll_GetLocalTime(&v11);
  FIX_DLL_KERNEL32_dll_GetSystemTime(&v7);
  if ( HIWORD(v9) == word_101C80DA && (_WORD)v9 == word_101C80D8 && HIWORD(v8) == word_101C80D6 && v7 == dword_101C80D0 )
  {
    v1 = dword_101C80C8;
  }
  else
  {
    v2 = FIX_DLL_KERNEL32_dll_GetTimeZoneInformation(v4);
    if ( v2 == -1 )
      v1 = -1;
    else
      v1 = v2 == 2 && v5 && v6;
    dword_101C80D0 = v7;
    *(&dword_101C80D0 + 1) = v8;
    *(&dword_101C80D0 + 2) = v9;
    *(&dword_101C80D0 + 3) = v10;
    dword_101C80C8 = v1;
  }
  result = __loctotime_t_0((unsigned __int16)v11, HIWORD(v11), v12, v13, v14, v15, v1);
  if ( a1 )
    *a1 = result;
  return result;
}
// 10021004: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetLocalTime)(_DWORD);
// 10021158: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD);
// 1002115C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetSystemTime)(_DWORD);
// 101C80C8: using guessed type int dword_101C80C8;
// 101C80D0: using guessed type int dword_101C80D0;
// 101C80D6: using guessed type __int16 word_101C80D6;
// 101C80D8: using guessed type __int16 word_101C80D8;
// 101C80DA: using guessed type __int16 word_101C80DA;

//----- (10017683) --------------------------------------------------------
int __stdcall FIX_DLL_start(int a1, int a2, int a3)
{
  _BOOL1 v4; // zf
  int v6; // eax
  int v7; // [esp+18h] [ebp+Ch]

  if ( a2 )
  {
    if ( a2 != 1 && a2 != 2 )
      goto LABEL_10;
    if ( dword_101C9708 && !dword_101C9708(a1, a2, a3) )
      return 0;
    v4 = _CRT_INIT(a1, a2, a3) == 0;
  }
  else
  {
    v4 = dword_101C80E0 == 0;
  }
  if ( v4 )
    return 0;
LABEL_10:
  v6 = sub_10015590(a1, a2, a3);
  v7 = v6;
  if ( a2 != 1 )
  {
LABEL_13:
    if ( !a2 || a2 == 3 )
    {
      if ( !_CRT_INIT(a1, a2, a3) )
        v7 = 0;
      if ( v7 )
      {
        if ( dword_101C9708 )
          v7 = dword_101C9708(a1, a2, a3);
      }
    }
    return v7;
  }
  if ( !v6 )
  {
    _CRT_INIT(a1, 0, a3);
    goto LABEL_13;
  }
  return v7;
}
// 100175CB: using guessed type _DWORD __stdcall _CRT_INIT(_DWORD, _DWORD, _DWORD);
// 101C80E0: using guessed type int dword_101C80E0;
// 101C9708: using guessed type int (__stdcall *dword_101C9708)(_DWORD, _DWORD, _DWORD);

//----- (10017720) --------------------------------------------------------
void __cdecl _amsg_exit_0(int rterrnum)
{
  int v1; // esi

  if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
    _FF_MSGBANNER_0(v1);
  _NMSG_WRITE_0(v1, rterrnum);
  off_10025DE4(255);
}
// 10017737: variable 'v1' is possibly undefined
// 10025DE4: using guessed type int (__cdecl *off_10025DE4)(_DWORD);
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;

//----- (10017753) --------------------------------------------------------
int __usercall __InternalCxxFrameHandler_0@<eax>(void *a1@<ecx>, int a2@<ebx>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6, struct _s_FuncInfo *a7, int a8, PVOID TargetFrame, unsigned __int8 a10)
{
  if ( *(_DWORD *)a7 != 429065504 )
    sub_10018002((int)a1, a2, 429065504, (int)a7);
  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )
  {
    if ( *((_DWORD *)a7 + 1) )
    {
      if ( !a8 )
        sub_10017A9A(a1, (int)a4, (int)a6, (int)a7, -1);
    }
  }
  else if ( *((_DWORD *)a7 + 3) )
  {
    if ( ExceptionRecord->ExceptionCode == -529697949 && ExceptionRecord->ExceptionInformation[0] > 0x19930520 )
    {
      a1 = *(void **)(ExceptionRecord->ExceptionInformation[2] + 8);
      if ( a1 )
        return ((int (__cdecl *)(PEXCEPTION_RECORD, struct EHRegistrationNode *, struct _CONTEXT *, void *, struct _s_FuncInfo *, int, PVOID, _DWORD))a1)(
                 ExceptionRecord,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 TargetFrame,
                 a10);
    }
    FindHandler(
      (const struct _s_FuncInfo *)a1,
      a2,
      429065504,
      (int)a7,
      ExceptionRecord,
      a4,
      a5,
      a6,
      a7,
      a10,
      a8,
      TargetFrame);
  }
  return 1;
}
// 10017787: variable 'a1' is possibly undefined

//----- (100177EE) --------------------------------------------------------
void __usercall FindHandler(const struct _s_FuncInfo *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a6, struct _CONTEXT *a7, void *a8, const struct _s_FuncInfo *a9, char a10, int a11, PVOID TargetFrame)
{
  PEXCEPTION_RECORD v12; // esi
  bool v13; // eax
  int v14; // edi
  const struct _s_TryBlockMapEntry *v15; // ebx
  int *v16; // eax
  const struct _s_CatchableType **v17; // edi
  int v18; // [esp-10h] [ebp-28h]
  unsigned int v19; // [esp+0h] [ebp-18h] BYREF
  int v20; // [esp+4h] [ebp-14h]
  int v21; // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+10h] [ebp-8h]
  unsigned int v24; // [esp+14h] [ebp-4h] BYREF
  const struct _s_HandlerType *v25; // [esp+20h] [ebp+8h]

  LOBYTE(v20) = 0;
  v21 = *((_DWORD *)a6 + 2);
  if ( v21 < -1 || (a1 = a9, v21 >= *((_DWORD *)a9 + 1)) )
    sub_10018002((int)a1, a2, a3, a4);
  v12 = ExceptionRecord;
  if ( ExceptionRecord->ExceptionCode != -529697949 )
    goto LABEL_35;
  if ( ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->ExceptionInformation[0] == 429065504
    && !ExceptionRecord->ExceptionInformation[2] )
  {
    v12 = (PEXCEPTION_RECORD)dword_101C80F4;
    if ( !dword_101C80F4 )
      return;
    a7 = (struct _CONTEXT *)dword_101C80F8;
    LOBYTE(v20) = 1;
    v13 = sub_1001AB9E(dword_101C80F4, 1);
    a1 = (const struct _s_FuncInfo *)v18;
    if ( !v13 )
      sub_10018002(v18, -529697949, 429065504, (int)v12);
    if ( v12->ExceptionCode != -529697949 )
      goto LABEL_35;
    if ( v12->NumberParameters == 3 && v12->ExceptionInformation[0] == 429065504 && !v12->ExceptionInformation[2] )
      sub_10018002((int)a1, -529697949, 429065504, (int)v12);
  }
  if ( v12->ExceptionCode != -529697949 || v12->NumberParameters != 3 || v12->ExceptionInformation[0] != 429065504 )
  {
LABEL_35:
    if ( a10 )
      sub_10017F9C((int)a1, -529697949, 429065504, (int)v12);
    else
      FindHandlerForForeignException(a1, v12, a6, a7, a8, a9, v21, a11, TargetFrame);
    return;
  }
  v14 = v21;
  v15 = _GetRangeOfTrysToCheck(a1, a9, a11, v21, &v24, &v19);
  while ( v24 < v19 )
  {
    if ( *(_DWORD *)v15 <= v14 && v14 <= *((_DWORD *)v15 + 1) )
    {
      v25 = (const struct _s_HandlerType *)*((_DWORD *)v15 + 4);
      v22 = *((_DWORD *)v15 + 3);
      if ( v22 > 0 )
      {
        while ( 1 )
        {
          v16 = *(int **)(v12->ExceptionInformation[2] + 12);
          v17 = (const struct _s_CatchableType **)(v16 + 1);
          v23 = *v16;
          if ( v23 > 0 )
            break;
LABEL_27:
          --v22;
          v25 = (const struct _s_HandlerType *)((char *)v25 + 16);
          if ( v22 <= 0 )
            goto LABEL_30;
        }
        while ( !TypeMatch(v25, *v17, (const struct _s_ThrowInfo *)v12->ExceptionInformation[2]) )
        {
          --v23;
          ++v17;
          if ( v23 <= 0 )
            goto LABEL_27;
        }
        CatchIt(
          (struct EHExceptionRecord *)v12,
          a6,
          a7,
          a8,
          a9,
          v25,
          *v17,
          v15,
          a11,
          (struct EHRegistrationNode *)TargetFrame,
          v20);
      }
LABEL_30:
      v14 = v21;
    }
    ++v24;
    v15 = (const struct _s_TryBlockMapEntry *)((char *)v15 + 20);
  }
  if ( a10 )
    unknown_libname_64(v12);
}
// 10017861: variable 'v18' is possibly undefined
// 10017882: variable 'a1' is possibly undefined
// 10017A3D: using guessed type _DWORD __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *);
// 10017B4E: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);
// 10017EC3: using guessed type _DWORD __cdecl unknown_libname_64(_DWORD);
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017995) --------------------------------------------------------
unsigned int __thiscall FindHandlerForForeignException(void *this, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a3, struct _CONTEXT *a4, void *a5, const struct _s_FuncInfo *a6, int a7, int a8, PVOID TargetFrame)
{
  unsigned int result; // eax
  const struct _s_TryBlockMapEntry *i; // esi
  int v11; // eax
  int v12; // ecx
  unsigned int v13; // [esp+0h] [ebp-8h] BYREF
  unsigned int v14; // [esp+4h] [ebp-4h] BYREF

  if ( !dword_101C80FC
    || (result = _CallSETranslator(
                   (struct EHExceptionRecord *)ExceptionRecord,
                   a3,
                   a4,
                   a5,
                   a6,
                   a8,
                   (struct EHRegistrationNode *)TargetFrame)) == 0 )
  {
    for ( i = _GetRangeOfTrysToCheck(this, a6, a8, a7, &v14, &v13);
          ;
          i = (const struct _s_TryBlockMapEntry *)((char *)i + 20) )
    {
      result = v14;
      if ( v14 >= v13 )
        break;
      if ( a7 >= *(_DWORD *)i && a7 <= *((_DWORD *)i + 1) )
      {
        v11 = *((_DWORD *)i + 4) + 16 * *((_DWORD *)i + 3);
        v12 = *(_DWORD *)(v11 - 12);
        if ( !v12 || !*(_BYTE *)(v12 + 8) )
          CatchIt(
            (struct EHExceptionRecord *)ExceptionRecord,
            a3,
            a4,
            a5,
            a6,
            (const struct _s_HandlerType *)(v11 - 16),
            0,
            i,
            a8,
            (struct EHRegistrationNode *)TargetFrame,
            1u);
      }
      ++v14;
    }
  }
  return result;
}
// 100179D8: variable 'this' is possibly undefined
// 10015C7F: using guessed type _DWORD __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, _DWORD, struct EHRegistrationNode *);
// 10017B4E: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);
// 101C80FC: using guessed type int dword_101C80FC;

//----- (10017A9A) --------------------------------------------------------
unsigned int __thiscall sub_10017A9A(void *this, int a2, int a3, int a4, int a5)
{
  unsigned int result; // eax
  int v6; // esi
  int v7; // eax
  int v8; // [esp-Ch] [ebp-28h] BYREF
  int v9; // [esp+0h] [ebp-1Ch]
  int *v10; // [esp+4h] [ebp-18h]
  unsigned int v11; // [esp+Ch] [ebp-10h]
  void *v12; // [esp+10h] [ebp-Ch]
  void *v13; // [esp+14h] [ebp-8h]
  int v14; // [esp+18h] [ebp-4h]

  v14 = -1;
  v13 = &unk_10021C28;
  v12 = &unknown_libname_67;
  result = __readfsdword(0);
  v11 = result;
  v10 = &v8;
  v6 = *(_DWORD *)(a2 + 8);
  v9 = v6;
  while ( v6 != a5 )
  {
    if ( v6 <= -1 || v6 >= *(_DWORD *)(a4 + 4) )
      sub_10018002((int)this, a2, a4, v6);
    v14 = 0;
    v7 = *(_DWORD *)(*(_DWORD *)(a4 + 8) + 8 * v6 + 4);
    if ( v7 )
      unknown_libname_65(v7, a2, 259);
    v14 = -1;
    result = *(_DWORD *)(a4 + 8);
    v6 = *(_DWORD *)(result + 8 * v6);
    v9 = v6;
  }
  *(_DWORD *)(a2 + 8) = v6;
  return result;
}
// 10017ADB: variable 'this' is possibly undefined
// 10017F50: using guessed type _DWORD __stdcall unknown_libname_65(_DWORD, _DWORD, _DWORD);

//----- (10017BC9) --------------------------------------------------------
void *__cdecl sub_10017BC9(_DWORD *a1, struct EHRegistrationNode *a2, int a3, const struct _s_FuncInfo *a4, void *a5, int a6, unsigned __int32 a7)
{
  int v8; // [esp-Ch] [ebp-38h] BYREF
  void *v9; // [esp+0h] [ebp-2Ch]
  int v10; // [esp+4h] [ebp-28h]
  int v11; // [esp+8h] [ebp-24h]
  int v12; // [esp+Ch] [ebp-20h]
  int v13; // [esp+10h] [ebp-1Ch]
  int *v14; // [esp+14h] [ebp-18h]
  unsigned int v15; // [esp+1Ch] [ebp-10h]
  void *v16; // [esp+20h] [ebp-Ch]
  void *v17; // [esp+24h] [ebp-8h]
  int v18; // [esp+28h] [ebp-4h]
  int savedregs; // [esp+2Ch] [ebp+0h] BYREF

  v18 = -1;
  v17 = &unk_10021C38;
  v16 = &unknown_libname_67;
  v15 = __readfsdword(0);
  v14 = &v8;
  v9 = a5;
  v11 = 0;
  v10 = *((_DWORD *)a2 - 1);
  v13 = dword_101C80F4;
  v12 = dword_101C80F8;
  dword_101C80F4 = (int)a1;
  dword_101C80F8 = a3;
  v18 = 1;
  v9 = _CallCatchBlock2(a2, a4, a5, a6, a7);
  v18 = -1;
  sub_10017C8F(0, (int)&savedregs, a1, (int)a2);
  return v9;
}
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017C8F) --------------------------------------------------------
int __usercall sub_10017C8F@<eax>(int a1@<ebx>, int a2@<ebp>, _DWORD *a3@<edi>, int a4@<esi>)
{
  int result; // eax

  *(_DWORD *)(a4 - 4) = *(_DWORD *)(a2 - 40);
  dword_101C80F4 = *(_DWORD *)(a2 - 28);
  result = *(_DWORD *)(a2 - 32);
  dword_101C80F8 = result;
  if ( *a3 == -529697949 && a3[4] == 3 && a3[5] == 429065504 && *(_DWORD *)(a2 - 36) == a1 && *(_DWORD *)(a2 - 44) != a1 )
  {
    _abnormal_termination_0();
    result = unknown_libname_64(a3);
  }
  return result;
}
// 10017EC3: using guessed type _DWORD __cdecl unknown_libname_64(_DWORD);
// 101C80F4: using guessed type int dword_101C80F4;
// 101C80F8: using guessed type int dword_101C80F8;

//----- (10017CFF) --------------------------------------------------------
void __usercall BuildCatchObject(struct EHExceptionRecord *a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, const struct _s_HandlerType *a4, const struct _s_CatchableType *a5)
{
  int v5; // eax
  int v6; // eax
  char **v7; // edi
  struct EHExceptionRecord *v8; // esi
  bool v9; // eax
  int v10; // ecx
  bool v11; // eax
  char *v12; // eax
  bool v13; // eax
  bool v14; // eax
  bool v15; // eax
  bool v16; // eax
  char *v17; // eax
  bool v18; // eax
  bool v19; // eax
  bool v20; // eax
  int v21; // [esp-18h] [ebp-30h]
  int v22; // [esp-14h] [ebp-2Ch]
  int v23; // [esp-14h] [ebp-2Ch]
  const struct PMD *v24; // [esp-14h] [ebp-2Ch]
  int v25; // [esp-14h] [ebp-2Ch]
  int v26; // [esp-14h] [ebp-2Ch]
  int v27; // [esp-14h] [ebp-2Ch]
  int v28; // [esp-14h] [ebp-2Ch]
  size_t v29; // [esp-14h] [ebp-2Ch]
  int v30; // [esp-14h] [ebp-2Ch]
  int v31; // [esp-14h] [ebp-2Ch]
  int v32; // [esp-14h] [ebp-2Ch]
  _DWORD v33[9]; // [esp-10h] [ebp-28h] BYREF
  int v34; // [esp+14h] [ebp-4h]

  v34 = -1;
  v33[8] = &unk_10021C50;
  v33[7] = &unknown_libname_67;
  v33[6] = __readfsdword(0);
  v33[4] = v33;
  v5 = *((_DWORD *)a4 + 1);
  if ( !v5 )
    return;
  if ( !*(_BYTE *)(v5 + 8) )
    return;
  v6 = *((_DWORD *)a4 + 2);
  if ( !v6 )
    return;
  v7 = (char **)((char *)a3 + v6 + 12);
  v34 = 0;
  if ( (*(_BYTE *)a4 & 8) != 0 )
  {
    v8 = a2;
    v9 = sub_1001AB9E(*((_DWORD *)a2 + 6), 1);
    v10 = v22;
    if ( v9 )
    {
      v11 = sub_1001ABBA((int)v7, 1);
      v10 = v23;
      if ( v11 )
      {
        v12 = (char *)*((_DWORD *)a2 + 6);
        *v7 = v12;
        v24 = (const struct _s_CatchableType *)((char *)a5 + 8);
LABEL_8:
        *v7 = AdjustPointer(v12, v24);
        return;
      }
    }
    goto LABEL_25;
  }
  v8 = a5;
  if ( (*(_BYTE *)a5 & 1) == 0 )
  {
    a1 = a2;
    v21 = *((_DWORD *)a2 + 6);
    if ( !*((_DWORD *)a5 + 6) )
    {
      v15 = sub_1001AB9E(v21, 1);
      v10 = v27;
      if ( v15 )
      {
        v16 = sub_1001ABBA((int)v7, 1);
        v10 = v28;
        if ( v16 )
        {
          v29 = *((_DWORD *)a5 + 5);
          v17 = AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
          memcpy_0(v7, v17, v29);
          return;
        }
      }
      goto LABEL_25;
    }
    v18 = sub_1001AB9E(v21, 1);
    v10 = v30;
    if ( v18 )
    {
      v19 = sub_1001ABBA((int)v7, 1);
      v10 = v31;
      if ( v19 )
      {
        v20 = sub_1001ABD6(*((_DWORD *)a5 + 6));
        v10 = v32;
        if ( v20 )
        {
          if ( (*(_BYTE *)a5 & 4) != 0 )
          {
            AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
            sub_10015B60(v7, *((_DWORD *)a5 + 6));
          }
          else
          {
            AdjustPointer(*((void **)a2 + 6), (const struct _s_CatchableType *)((char *)a5 + 8));
            sub_10015B59(v7, *((_DWORD *)a5 + 6));
          }
          return;
        }
      }
    }
LABEL_25:
    sub_10018002(v10, (int)a1, (int)v7, (int)v8);
    return;
  }
  a1 = a2;
  v13 = sub_1001AB9E(*((_DWORD *)a2 + 6), 1);
  v10 = v25;
  if ( !v13 )
    goto LABEL_25;
  v14 = sub_1001ABBA((int)v7, 1);
  v10 = v26;
  if ( !v14 )
    goto LABEL_25;
  memcpy_0(v7, *((const void **)a2 + 6), *((_DWORD *)a5 + 5));
  if ( *((_DWORD *)a5 + 5) == 4 )
  {
    v12 = *v7;
    if ( *v7 )
    {
      v24 = (const struct _s_CatchableType *)((char *)a5 + 8);
      goto LABEL_8;
    }
  }
}
// 10017D66: variable 'v22' is possibly undefined
// 10017D78: variable 'v23' is possibly undefined
// 10017DB2: variable 'v25' is possibly undefined
// 10017DC4: variable 'v26' is possibly undefined
// 10017E0A: variable 'v27' is possibly undefined
// 10017E1C: variable 'v28' is possibly undefined
// 10017E44: variable 'v30' is possibly undefined
// 10017E52: variable 'v31' is possibly undefined
// 10017E5F: variable 'v32' is possibly undefined
// 10015B59: using guessed type _DWORD __cdecl sub_10015B59(_DWORD, _DWORD);
// 10015B60: using guessed type _DWORD __cdecl sub_10015B60(_DWORD, _DWORD);

//----- (10017F2A) --------------------------------------------------------
char *__cdecl AdjustPointer(void *a1, const struct PMD *a2)
{
  int v2; // edx
  char *result; // eax

  v2 = *((_DWORD *)a2 + 1);
  result = (char *)a1 + *(_DWORD *)a2;
  if ( v2 >= 0 )
    result += v2 + *(_DWORD *)(*(_DWORD *)((char *)a1 + v2) + *((_DWORD *)a2 + 2));
  return result;
}

//----- (10017F9C) --------------------------------------------------------
void __usercall sub_10017F9C(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  int *v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  unsigned int v9; // [esp+8h] [ebp-10h]
  void *v10; // [esp+Ch] [ebp-Ch]
  void *v11; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  v11 = &unk_10021C70;
  v10 = &unknown_libname_67;
  v9 = __readfsdword(0);
  v8 = a1;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  v7 = &v4;
  v12 = 0;
  if ( dword_101C8100 )
  {
    dword_101C8100(v4, v5, v6, v7, v8, v9, v10, v11, 1);
    v12 = 0;
  }
  v12 = -1;
  JUMPOUT(0x10016FE0);
}
// 10017FED: control flows out of bounds to 10016FE0
// 101C8100: invalid function type has been ignored
// 101C8100: using guessed type int (__cdecl *dword_101C8100)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018002) --------------------------------------------------------
void __usercall sub_10018002(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  int *v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  unsigned int v9; // [esp+8h] [ebp-10h]
  void *v10; // [esp+Ch] [ebp-Ch]
  void *v11; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  v11 = &unk_10021C88;
  v10 = &unknown_libname_67;
  v9 = __readfsdword(0);
  v8 = a1;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  v7 = &v4;
  v12 = 0;
  if ( off_10025DF4 )
  {
    off_10025DF4(v4, v5, v6, v7, v8, v9, v10, v11, 1);
    v12 = 0;
  }
  v12 = -1;
  sub_10017F9C(a1, a2, a3, a4);
}
// 10018053: variable 'a1' is possibly undefined
// 10025DF4: using guessed type int (__cdecl *off_10025DF4)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10018058) --------------------------------------------------------
int __cdecl _isctype_0(int a1, int a2)
{
  int v2; // ecx
  int v3; // eax
  int result; // eax
  int v5; // [esp-4h] [ebp-8h]
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = v2;
  if ( (unsigned int)(a1 + 1) <= 0x100 )
  {
    v3 = *(unsigned __int16 *)(dword_10025DF8 + 2 * a1);
    return a2 & v3;
  }
  if ( *(char *)(dword_10025DF8 + 2 * BYTE1(a1) + 1) >= 0 )
  {
    LOWORD(v6) = (unsigned __int8)a1;
    v5 = 1;
  }
  else
  {
    LOBYTE(v6) = BYTE1(a1);
    *(_WORD *)((char *)&v6 + 1) = (unsigned __int8)a1;
    v5 = 2;
  }
  result = __crtGetStringTypeA_0(1u, (LPCSTR)&v6, v5, (LPWORD)&a1 + 1, 0, 0, 1);
  if ( result )
  {
    v3 = HIWORD(a1);
    return a2 & v3;
  }
  return result;
}
// 1001805B: variable 'v2' is possibly undefined
// 10025DF8: using guessed type int dword_10025DF8;

//----- (100180CD) --------------------------------------------------------
int __cdecl _flsbuf_0(int a1, FILE *a2)
{
  FILE *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  char *v6; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = a2;
  v3 = a2->_flag;
  v4 = a2->_file;
  if ( (v3 & 0x82) == 0 || (v3 & 0x40) != 0 )
    goto LABEL_24;
  if ( (v3 & 1) == 0 )
    goto LABEL_6;
  a2->_cnt = 0;
  if ( (v3 & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(v3) = v3 | 0x20;
    v2->_flag = v3;
    return -1;
  }
  LOBYTE(v3) = v3 & 0xFE;
  v2->_ptr = v2->_base;
  v2->_flag = v3;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  a2 = 0;
  LOBYTE(v5) = v5 & 0xEF | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (FILE *)&unk_10026040 && v2 != &stru_10026060 || !_isatty_0(v4)) )
    _getbuf_0(v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    v6 = v2->_base;
    v7 = v2->_ptr - v6;
    v2->_ptr = v6 + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = &unk_10026350;
      else
        v8 = (_BYTE *)(dword_101C85E0[v4 >> 5] + 8 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        _lseek_0(v4, 0, 2);
    }
    else
    {
      a2 = (FILE *)_write_0(v4, v6, v7);
    }
    *v2->_base = a1;
  }
  else
  {
    v7 = 1;
    a2 = (FILE *)_write_0(v4, &a1, 1u);
  }
  if ( a2 == (FILE *)v7 )
    return (unsigned __int8)a1;
  v2->_flag |= 0x20u;
  return -1;
}
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (100181E2) --------------------------------------------------------
int __cdecl _output_0(FILE *File, int a2, int a3)
{
  int v3; // esi
  char v4; // bl
  char *v5; // edi
  _BOOL1 v6; // zf
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // esi
  char *v12; // eax
  int v13; // ecx
  _WORD *i; // eax
  int v15; // edx
  char *v16; // edi
  __int16 v17; // ax
  __int16 *v18; // eax
  char *v19; // ecx
  unsigned int v20; // eax
  int v21; // eax
  int v22; // esi
  _BYTE *j; // eax
  int v24; // edx
  _WORD *v25; // eax
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  int v28; // eax
  int v29; // ebx
  unsigned __int64 v30; // kr08_8
  char *v31; // eax
  char *v32; // eax
  char v33; // bl
  int v34; // esi
  wchar_t *v35; // ebx
  int v36; // edi
  wchar_t v37; // ax
  int v38; // eax
  const char *v41; // [esp-10h] [ebp-258h]
  char v42; // [esp+0h] [ebp-248h] BYREF
  _BYTE v43[11]; // [esp+1h] [ebp-247h] BYREF
  char v44; // [esp+1FFh] [ebp-49h] BYREF
  int v45[2]; // [esp+200h] [ebp-48h] BYREF
  __int64 v46; // [esp+208h] [ebp-40h]
  char v47[4]; // [esp+210h] [ebp-38h] BYREF
  int v48; // [esp+214h] [ebp-34h]
  int v49; // [esp+218h] [ebp-30h]
  int v50; // [esp+21Ch] [ebp-2Ch]
  int v51; // [esp+220h] [ebp-28h]
  int v52; // [esp+224h] [ebp-24h]
  int v53; // [esp+228h] [ebp-20h]
  int v54; // [esp+22Ch] [ebp-1Ch]
  char v55[2]; // [esp+232h] [ebp-16h] BYREF
  int v56; // [esp+234h] [ebp-14h] BYREF
  int v57; // [esp+238h] [ebp-10h]
  int v58; // [esp+23Ch] [ebp-Ch]
  char *v59; // [esp+240h] [ebp-8h]
  int v60; // [esp+244h] [ebp-4h]
  char *v61; // [esp+254h] [ebp+Ch]

  v3 = 0;
  v4 = *(_BYTE *)a2;
  v5 = (char *)(a2 + 1);
  v6 = *(_BYTE *)a2 == 0;
  v58 = 0;
  v56 = 0;
  v61 = (char *)(a2 + 1);
  if ( !v6 )
  {
    v7 = v57;
    while ( 1 )
    {
      if ( v56 < 0 )
        return v56;
      if ( v4 < 32 || v4 > 120 )
        v8 = 0;
      else
        v8 = byte_10021C80[v4] & 0xF;
      v49 = byte_10021CA0[8 * v8 + v3] >> 4;
      switch ( v49 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v57 = -1;
          v48 = 0;
          v51 = 0;
          v53 = 0;
          v54 = 0;
          v60 = 0;
          v52 = 0;
          goto LABEL_180;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v60 |= 2u;
              break;
            case '#':
              LOBYTE(v60) = v60 | 0x80;
              break;
            case '+':
              v60 |= 1u;
              break;
            case '-':
              v60 |= 4u;
              break;
            case '0':
              v60 |= 8u;
              break;
          }
          goto LABEL_180;
        case 3:
          if ( v4 == 42 )
          {
            v9 = sub_100189C1(&a3);
            v53 = v9;
            if ( v9 >= 0 )
              goto LABEL_180;
            v60 |= 4u;
            v10 = -v9;
          }
          else
          {
            v10 = v4 + 10 * v53 - 48;
          }
          v53 = v10;
          goto LABEL_180;
        case 4:
          v57 = 0;
          goto LABEL_180;
        case 5:
          if ( v4 == 42 )
          {
            v57 = sub_100189C1(&a3);
            if ( v57 < 0 )
              v57 = -1;
          }
          else
          {
            v57 = v4 + 10 * v7 - 48;
          }
          goto LABEL_180;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v60) |= 0x80u;
                v61 = v5 + 2;
              }
              else
              {
                v49 = 0;
LABEL_42:
                v52 = 0;
                if ( *(char *)(dword_10025DF8 + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char_0(v4, File, (int)&v56);
                  v4 = *v5;
                  v61 = v5 + 1;
                }
                write_char_0(v4, File, (int)&v56);
              }
              break;
            case 'h':
              v60 |= 0x20u;
              break;
            case 'l':
              v60 |= 0x10u;
              break;
            case 'w':
              BYTE1(v60) |= 8u;
              break;
          }
          goto LABEL_180;
        case 7:
          if ( v4 <= 103 )
          {
            if ( v4 >= 101 )
              goto LABEL_65;
            if ( v4 > 88 )
            {
              if ( v4 == 90 )
              {
                v18 = (__int16 *)sub_100189C1(&a3);
                if ( v18 )
                {
                  v19 = (char *)*((_DWORD *)v18 + 1);
                  if ( v19 )
                  {
                    if ( (v60 & 0x800) != 0 )
                    {
                      v20 = (unsigned int)*v18 >> 1;
                      v59 = v19;
                      v58 = v20;
                      v52 = 1;
                      goto LABEL_157;
                    }
                    v52 = 0;
                    v59 = v19;
                    v21 = *v18;
                    goto LABEL_156;
                  }
                }
                v59 = (char *)dword_10026010;
                v41 = (const char *)dword_10026010;
LABEL_96:
                v21 = strlen(v41);
                goto LABEL_156;
              }
              if ( v4 == 99 )
                goto LABEL_69;
              if ( v4 != 100 )
                goto LABEL_157;
LABEL_123:
              v60 |= 0x40u;
LABEL_124:
              v58 = 10;
              goto LABEL_125;
            }
            if ( v4 != 88 )
            {
              if ( v4 != 67 )
              {
                if ( v4 == 69 || v4 == 71 )
                {
                  v48 = 1;
                  v4 += 32;
LABEL_65:
                  v60 |= 0x40u;
                  v16 = &v42;
                  v59 = &v42;
                  if ( v7 >= 0 )
                  {
                    if ( !v7 && v4 == 103 )
                      v57 = 1;
                  }
                  else
                  {
                    v57 = 6;
                  }
                  a3 += 8;
                  v45[0] = *(_DWORD *)(a3 - 8);
                  v45[1] = *(_DWORD *)(a3 - 4);
                  off_10026330(v45, &v42, v4, v57, v48);
                  v22 = v60 & 0x80;
                  if ( (v60 & 0x80) != 0 && !v57 )
                    off_1002633C(&v42);
                  if ( v4 == 103 && !v22 )
                    off_10026334(&v42);
                  if ( v42 == 45 )
                  {
                    BYTE1(v60) |= 1u;
                    v16 = v43;
                    v59 = v43;
                  }
                  v41 = v16;
                  goto LABEL_96;
                }
                if ( v4 != 83 )
                  goto LABEL_157;
                if ( (v60 & 0x830) == 0 )
                  BYTE1(v60) |= 8u;
LABEL_55:
                v11 = v57;
                if ( v57 == -1 )
                  v11 = 0x7FFFFFFF;
                v12 = (char *)sub_100189C1(&a3);
                v13 = (int)v12;
                v59 = v12;
                if ( (v60 & 0x810) != 0 )
                {
                  if ( !v12 )
                  {
                    v13 = dword_10026014;
                    v59 = (char *)dword_10026014;
                  }
                  v52 = 1;
                  for ( i = (_WORD *)v13; ; ++i )
                  {
                    v15 = v11--;
                    if ( !v15 || !*i )
                      break;
                  }
                  v21 = ((int)i - v13) >> 1;
                }
                else
                {
                  if ( !v12 )
                  {
                    v13 = dword_10026010;
                    v59 = (char *)dword_10026010;
                  }
                  for ( j = (_BYTE *)v13; ; ++j )
                  {
                    v24 = v11--;
                    if ( !v24 || !*j )
                      break;
                  }
                  v21 = (int)&j[-v13];
                }
LABEL_156:
                v58 = v21;
                goto LABEL_157;
              }
              if ( (v60 & 0x830) == 0 )
                BYTE1(v60) |= 8u;
LABEL_69:
              if ( (v60 & 0x810) != 0 )
              {
                v17 = sub_100189DE(&a3);
                v58 = wctomb_0(&v42, v17);
                if ( v58 < 0 )
                  v51 = 1;
              }
              else
              {
                v42 = sub_100189C1(&a3);
                v58 = 1;
              }
              v59 = &v42;
              goto LABEL_157;
            }
            goto LABEL_114;
          }
          if ( v4 == 105 )
            goto LABEL_123;
          if ( v4 == 110 )
          {
            v25 = (_WORD *)sub_100189C1(&a3);
            if ( (v60 & 0x20) != 0 )
              *v25 = v56;
            else
              *(_DWORD *)v25 = v56;
            v51 = 1;
            goto LABEL_180;
          }
          if ( v4 != 111 )
          {
            if ( v4 != 112 )
            {
              if ( v4 == 115 )
                goto LABEL_55;
              if ( v4 == 117 )
                goto LABEL_124;
              if ( v4 != 120 )
                goto LABEL_157;
              v50 = 39;
              goto LABEL_115;
            }
            v57 = 8;
LABEL_114:
            v50 = 7;
LABEL_115:
            v58 = 16;
            if ( (v60 & 0x80u) != 0 )
            {
              v55[0] = 48;
              v54 = 2;
              v55[1] = v50 + 81;
            }
            goto LABEL_125;
          }
          v58 = 8;
          if ( (v60 & 0x80u) != 0 )
            BYTE1(v60) |= 2u;
LABEL_125:
          if ( (v60 & 0x8000) == 0 )
          {
            if ( (v60 & 0x20) != 0 )
            {
              if ( (v60 & 0x40) != 0 )
                LODWORD(v26) = (__int16)sub_100189C1(&a3);
              else
                LODWORD(v26) = (unsigned __int16)sub_100189C1(&a3);
            }
            else
            {
              if ( (v60 & 0x40) == 0 )
              {
                v26 = (unsigned int)sub_100189C1(&a3);
                goto LABEL_135;
              }
              LODWORD(v26) = sub_100189C1(&a3);
            }
            v26 = (int)v26;
          }
          else
          {
            v26 = sub_100189CE(&a3);
          }
LABEL_135:
          if ( (v60 & 0x40) != 0 && v26 < 0 )
          {
            HIDWORD(v27) = -(int)v26;
            BYTE1(v60) |= 1u;
            LODWORD(v27) = (unsigned __int64)-v26 >> 32;
          }
          else
          {
            v27 = __PAIR64__(v26, HIDWORD(v26));
          }
          if ( (v60 & 0x8000) == 0 )
            LODWORD(v27) = 0;
          if ( v57 >= 0 )
            v60 &= 0xFFFFFFF7;
          else
            v57 = 1;
          if ( !v27 )
            v54 = 0;
          v59 = &v44;
          while ( 1 )
          {
            v28 = v57--;
            if ( v28 <= 0 && !v27 )
              break;
            v46 = v58;
            v29 = __PAIR64__(v27, HIDWORD(v27)) % v58 + 48;
            v30 = __PAIR64__(v27, HIDWORD(v27)) / v58;
            v27 = __PAIR64__(v30, HIDWORD(v30));
            if ( v29 > 57 )
              LOBYTE(v29) = v50 + v29;
            v31 = v59--;
            *v31 = v29;
          }
          v32 = (char *)(&v44 - v59++);
          v58 = (int)v32;
          if ( (v60 & 0x200) != 0 && (*v59 != 48 || !v32) )
          {
            --v59;
            v21 = (int)(v32 + 1);
            *v59 = 48;
            goto LABEL_156;
          }
LABEL_157:
          if ( v51 )
            goto LABEL_180;
          v33 = v60;
          if ( (v60 & 0x40) == 0 )
            goto LABEL_166;
          if ( (v60 & 0x100) != 0 )
          {
            v55[0] = 45;
LABEL_165:
            v54 = 1;
            goto LABEL_166;
          }
          if ( (v60 & 1) != 0 )
          {
            v55[0] = 43;
            goto LABEL_165;
          }
          if ( (v60 & 2) != 0 )
          {
            v55[0] = 32;
            goto LABEL_165;
          }
LABEL_166:
          v34 = v53 - v54 - v58;
          if ( (v60 & 0xC) == 0 )
            write_multi_char_0(32, v53 - v54 - v58, File, &v56);
          write_string_0((int)v55, v54, File, (int)&v56);
          if ( (v33 & 8) != 0 && (v33 & 4) == 0 )
            write_multi_char_0(48, v34, File, &v56);
          if ( v52 && v58 > 0 )
          {
            v35 = (wchar_t *)v59;
            v36 = v58 - 1;
            do
            {
              v37 = *v35++;
              v38 = wctomb_0(v47, v37);
              if ( v38 <= 0 )
                break;
              write_string_0((int)v47, v38, File, (int)&v56);
            }
            while ( v36-- );
          }
          else
          {
            write_string_0((int)v59, v58, File, (int)&v56);
          }
          if ( (v60 & 4) != 0 )
            write_multi_char_0(32, v34, File, &v56);
LABEL_180:
          v4 = *v61;
          v5 = v61 + 1;
          v6 = *v61++ == 0;
          if ( v6 )
            return v56;
          v7 = v57;
          v3 = v49;
          break;
        default:
          goto LABEL_180;
      }
    }
  }
  return v56;
}
// 10026330: invalid function type has been ignored
// 1002633C: invalid function type has been ignored
// 10026334: invalid function type has been ignored
// 10025DF8: using guessed type int dword_10025DF8;
// 10026010: using guessed type int dword_10026010;
// 10026014: using guessed type int dword_10026014;
// 10026330: using guessed type int (__cdecl *off_10026330)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10026334: using guessed type int (__cdecl *off_10026334)(_DWORD);
// 1002633C: using guessed type int (__cdecl *off_1002633C)(_DWORD);

//----- (10018923) --------------------------------------------------------
int __cdecl write_char_0(int a1, FILE *File, int a3)
{
  int v4; // eax
  _BOOL1 v5; // zf
  int result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf_0(a1, File);
  }
  else
  {
    *File->_ptr++ = a1;
    v4 = (unsigned __int8)a1;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *(_DWORD *)a3 = -1;
  else
    ++*(_DWORD *)a3;
  return result;
}

//----- (10018958) --------------------------------------------------------
int __cdecl write_multi_char_0(int a1, int a2, FILE *a3, _DWORD *a4)
{
  int result; // eax
  int i; // edi

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    result = write_char_0(a1, a3, (int)a4);
    if ( *a4 == -1 )
      break;
  }
  return result;
}

//----- (10018989) --------------------------------------------------------
int __cdecl write_string_0(int a1, int a2, FILE *File, int a4)
{
  int result; // eax
  int i; // ebx
  int v7; // eax

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    v7 = *(char *)a1++;
    result = write_char_0(v7, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}

//----- (100189C1) --------------------------------------------------------
int __cdecl sub_100189C1(_DWORD *a1)
{
  *a1 += 4;
  return *(_DWORD *)(*a1 - 4);
}

//----- (100189CE) --------------------------------------------------------
__int64 __cdecl sub_100189CE(_DWORD *a1)
{
  *a1 += 8;
  return *(_QWORD *)(*a1 - 8);
}

//----- (100189DE) --------------------------------------------------------
__int16 __cdecl sub_100189DE(_DWORD *a1)
{
  *a1 += 4;
  return *(_WORD *)(*a1 - 4);
}

//----- (100189EC) --------------------------------------------------------
void __cdecl sub_100189EC(unsigned int a1)
{
  int v1; // esi
  _DWORD *v2; // eax
  _BYTE *v3; // eax
  int v4; // [esp-4h] [ebp-Ch]
  void **v5; // [esp+4h] [ebp-4h] BYREF

  v1 = a1;
  if ( a1 )
  {
    if ( dword_101C86E8 == 3 )
    {
      v2 = (_DWORD *)__sbh_find_block_0(a1);
      v4 = v1;
      if ( v2 )
      {
        sub_1001B27A(v2, v1);
        return;
      }
    }
    else
    {
      if ( dword_101C86E8 == 2 )
      {
        v3 = (_BYTE *)sub_1001C3CC(a1, &v5, &a1);
        if ( v3 )
        {
          sub_1001C423((int)v5, a1, v3);
          return;
        }
      }
      v4 = v1;
    }
    FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, v4);
  }
}
// 10021164: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10018B48) --------------------------------------------------------
int __cdecl __crtLCMapStringA_0(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR lpDestStr, int cchDest, UINT CodePage, int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  LPSTR v17; // [esp-D8h] [ebp-D8h]
  int v18; // [esp-D4h] [ebp-D4h]
  _BYTE v19[48]; // [esp-B0h] [ebp-B0h] BYREF
  _BYTE v20[72]; // [esp-80h] [ebp-80h] BYREF
  _DWORD v21[5]; // [esp-38h] [ebp-38h] BYREF
  _BYTE *v22; // [esp-24h] [ebp-24h]
  _BYTE *v23; // [esp-20h] [ebp-20h]
  int v24; // [esp-1Ch] [ebp-1Ch]
  _BYTE *v25; // [esp-18h] [ebp-18h]
  unsigned int v26; // [esp-10h] [ebp-10h]
  void *v27; // [esp-Ch] [ebp-Ch]
  void *v28; // [esp-8h] [ebp-8h]
  int v29; // [esp-4h] [ebp-4h]

  v29 = -1;
  v28 = &unk_10021D20;
  v27 = &unknown_libname_67;
  v26 = __readfsdword(0);
  v25 = v21;
  if ( dword_101C8108 )
  {
LABEL_6:
    if ( cbMultiByte > 0 )
      cbMultiByte = (int)strncnt_0(lpMultiByteStr, (_BYTE *)cbMultiByte);
    if ( dword_101C8108 == 2 )
      return FIX_DLL_KERNEL32_dll_LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest);
    if ( dword_101C8108 != 1 )
      return 0;
    if ( !CodePage )
      CodePage = dword_101C8124;
    v9 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, a8 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
    v10 = v9;
    v24 = v9;
    if ( !v9 )
      return 0;
    v11 = 2 * v9 + 3;
    LOBYTE(v11) = v11 & 0xFC;
    v12 = alloca(v11);
    v25 = v20;
    v22 = v20;
    v29 = -1;
    if ( !v20 )
      return 0;
    if ( !FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, v22, v10) )
      return 0;
    v13 = FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v10, 0, 0);
    v14 = v13;
    v21[4] = v13;
    if ( !v13 )
      return 0;
    if ( (dwMapFlags & 0x400) != 0 )
    {
      if ( cchDest
        && (v13 > cchDest || !FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v10, lpDestStr, cchDest)) )
      {
        return 0;
      }
    }
    else
    {
      v15 = 2 * v13 + 3;
      LOBYTE(v15) = v15 & 0xFC;
      v16 = alloca(v15);
      v25 = v19;
      v23 = v19;
      v29 = -1;
      if ( !v19 || !FIX_DLL_KERNEL32_dll_LCMapStringW(Locale, dwMapFlags, v22, v24, v19, v14) )
        return 0;
      if ( cchDest )
      {
        v18 = cchDest;
        v17 = lpDestStr;
      }
      else
      {
        v18 = 0;
        v17 = 0;
      }
      v14 = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(CodePage, 544, v19, v14, v17, v18, 0, 0);
      if ( !v14 )
        return 0;
    }
    return v14;
  }
  if ( FIX_DLL_KERNEL32_dll_LCMapStringW(0, 256, &unk_10021D18, 1, 0, 0) )
  {
    dword_101C8108 = 1;
    goto LABEL_6;
  }
  if ( FIX_DLL_KERNEL32_dll_LCMapStringA(0, 256, &unk_10021D14, 1, 0, 0) )
  {
    dword_101C8108 = 2;
    goto LABEL_6;
  }
  return 0;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021174: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021178: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LCMapStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8108: using guessed type int dword_101C8108;

//----- (10018D6C) --------------------------------------------------------
_BYTE *__cdecl strncnt_0(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *result; // eax

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = a2;
  else
    result = (_BYTE *)(v2 - a1);
  return result;
}

//----- (10018D97) --------------------------------------------------------
_DWORD *__cdecl sub_10018D97(unsigned int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  unsigned int v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // eax
  void **v13; // [esp+Ch] [ebp-4h] BYREF

  if ( !a1 )
    return sub_10019098((size_t)a2);
  v3 = (unsigned int)a2;
  if ( !a2 )
  {
    sub_100189EC(a1);
    return 0;
  }
  if ( dword_101C86E8 == 3 )
  {
    while ( 1 )
    {
      v4 = 0;
      if ( v3 <= 0xFFFFFFE0 )
        break;
LABEL_26:
      if ( !dword_101C8280 )
        return v4;
      if ( !sub_1001C9B1(v3) )
        return 0;
    }
    v5 = (_DWORD *)__sbh_find_block_0(a1);
    v6 = v5;
    if ( !v5 )
    {
LABEL_22:
      if ( !v3 )
        v3 = 1;
      v3 = (v3 + 15) & 0xFFFFFFF0;
      v4 = (_DWORD *)FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
LABEL_25:
      if ( v4 )
        return v4;
      goto LABEL_26;
    }
    if ( v3 > dword_101C85C4 )
      goto LABEL_15;
    v4 = (_DWORD *)a1;
    if ( __sbh_resize_block_0(v5, a1, v3) )
      goto LABEL_21;
    v4 = __sbh_alloc_block_0(v3);
    if ( v4 )
    {
      v7 = *(_DWORD *)(a1 - 4) - 1;
      if ( v7 >= v3 )
        v7 = v3;
      ((void (__cdecl *)(_DWORD *, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v7);
      v6 = (_DWORD *)__sbh_find_block_0(a1);
      sub_1001B27A(v6, a1);
    }
    else
    {
LABEL_15:
      if ( !v3 )
        v3 = 1;
      v3 = (v3 + 15) & 0xFFFFFFF0;
      v4 = (_DWORD *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
      if ( v4 )
      {
        v8 = *(_DWORD *)(a1 - 4) - 1;
        if ( v8 >= v3 )
          v8 = v3;
        ((void (__cdecl *)(_DWORD *, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v8);
        sub_1001B27A(v6, a1);
      }
    }
LABEL_21:
    if ( v6 )
      goto LABEL_25;
    goto LABEL_22;
  }
  if ( dword_101C86E8 != 2 )
  {
    do
    {
      result = 0;
      if ( v3 <= 0xFFFFFFE0 )
      {
        if ( !v3 )
          v3 = 1;
        v3 = (v3 + 15) & 0xFFFFFFF0;
        result = (_DWORD *)FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
        if ( result )
          return result;
      }
      if ( !dword_101C8280 )
        return result;
    }
    while ( sub_1001C9B1(v3) );
    return 0;
  }
  if ( (unsigned int)a2 <= 0xFFFFFFE0 )
    v3 = ((unsigned int)a2 + 15) & 0xFFFFFFF0;
  while ( 1 )
  {
    v4 = 0;
    if ( v3 > 0xFFFFFFE0 )
      goto LABEL_49;
    v9 = (_BYTE *)sub_1001C3CC(a1, &v13, (unsigned int *)&a2);
    v10 = v9;
    if ( !v9 )
    {
      v4 = (_DWORD *)FIX_DLL_KERNEL32_dll_HeapReAlloc(dword_101C86E4, 0, a1, v3);
      goto LABEL_48;
    }
    if ( v3 < dword_10028384 )
    {
      if ( sub_1001C794((int)v13, a2, v9, v3 >> 4) )
        return (_DWORD *)a1;
      v4 = (_DWORD *)sub_1001C468(v3 >> 4);
      if ( v4 )
        break;
    }
    v4 = (_DWORD *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
    if ( !v4 )
      goto LABEL_49;
    v12 = 16 * (unsigned __int8)*v10;
    if ( v12 >= v3 )
      v12 = v3;
    ((void (__cdecl *)(_DWORD *, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v12);
    sub_1001C423((int)v13, (int)a2, v10);
LABEL_48:
    if ( v4 )
      return v4;
LABEL_49:
    if ( !dword_101C8280 )
      return v4;
    if ( !sub_1001C9B1(v3) )
      return 0;
  }
  v11 = 16 * (unsigned __int8)*v10;
  if ( v11 >= v3 )
    v11 = v3;
  ((void (__cdecl *)(_DWORD *, unsigned int, unsigned int))loc_1001C9D0)(v4, a1, v11);
  sub_1001C423((int)v13, (int)a2, v10);
  return v4;
}
// 10018EE7: conditional instruction was optimized away because of '%arg_4.4 in (1..FFFFFFE0)'
// 10018E45: conditional instruction was optimized away because of 'edi.4!=0'
// 10018F76: conditional instruction was optimized away because of 'edi.4!=0'
// 1002117C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapReAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10028384: using guessed type int dword_10028384;
// 101C85C4: using guessed type int dword_101C85C4;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10019037) --------------------------------------------------------
int __cdecl sub_10019037(unsigned int a1)
{
  int result; // eax
  unsigned __int8 *v2; // eax
  void **v3; // [esp+0h] [ebp-8h] BYREF
  unsigned int v4; // [esp+4h] [ebp-4h] BYREF

  if ( dword_101C86E8 == 3 )
  {
    if ( __sbh_find_block_0(a1) )
      result = *(_DWORD *)(a1 - 4) - 9;
    else
      result = FIX_DLL_KERNEL32_dll_HeapSize(dword_101C86E4, 0, a1);
  }
  else if ( dword_101C86E8 == 2 && (v2 = (unsigned __int8 *)sub_1001C3CC(a1, &v3, &v4)) != 0 )
  {
    result = 16 * *v2;
  }
  else
  {
    result = FIX_DLL_KERNEL32_dll_HeapSize(dword_101C86E4, 0, a1);
  }
  return result;
}
// 10021184: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_HeapSize)(_DWORD, _DWORD, _DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (10019098) --------------------------------------------------------
_DWORD *__cdecl sub_10019098(size_t a1)
{
  return _nh_malloc_0(a1, dword_101C8280);
}

//----- (100190AA) --------------------------------------------------------
_DWORD *__cdecl _nh_malloc_0(size_t Size, int a2)
{
  _DWORD *result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = sub_100190D6(Size);
    if ( result || !a2 )
      break;
    if ( !sub_1001C9B1(Size) )
      return 0;
  }
  return result;
}

//----- (100190D6) --------------------------------------------------------
_DWORD *__cdecl sub_100190D6(unsigned int a1)
{
  int v1; // esi
  _DWORD *result; // eax
  unsigned int v3; // esi

  v1 = a1;
  if ( dword_101C86E8 == 3 )
  {
    if ( a1 <= dword_101C85C4 )
    {
      result = __sbh_alloc_block_0(a1);
      if ( result )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_101C86E8 != 2 )
  {
LABEL_12:
    if ( !a1 )
      v1 = 1;
    v3 = (v1 + 15) & 0xFFFFFFF0;
    return (_DWORD *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  }
  if ( a1 )
    v3 = (a1 + 15) & 0xFFFFFFF0;
  else
    v3 = 16;
  if ( v3 > dword_10028384 )
    return (_DWORD *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  result = (_DWORD *)sub_1001C468(v3 >> 4);
  if ( !result )
    return (_DWORD *)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, v3);
  return result;
}
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10028384: using guessed type int dword_10028384;
// 101C85C4: using guessed type int dword_101C85C4;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001914A) --------------------------------------------------------
int __cdecl fflush_0(FILE *a1)
{
  if ( !a1 )
    return flsall_0(0);
  if ( _flush_0(a1) )
    return -1;
  if ( (a1->_flag & 0x4000) != 0 )
    return -(_commit_0(a1->_file) != 0);
  return 0;
}

//----- (10019185) --------------------------------------------------------
int __cdecl _flush_0(_DWORD *a1)
{
  int v1; // ebx
  const void *v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (a1[3] & 3) == 2 && (a1[3] & 0x108) != 0 )
  {
    v2 = (const void *)a1[2];
    if ( *a1 - (int)v2 > 0 )
    {
      v3 = *a1 - (_DWORD)v2;
      if ( _write_0(a1[4], v2, v3) == v3 )
      {
        v4 = a1[3];
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          a1[3] = v4;
        }
      }
      else
      {
        a1[3] |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = a1[2];
  a1[1] = 0;
  *a1 = v5;
  return v1;
}

//----- (100191EA) --------------------------------------------------------
int __cdecl flsall_0(int a1)
{
  int v1; // esi
  int v2; // ebx
  int i; // edi
  FILE *v4; // eax
  int v5; // ecx
  int result; // eax

  v1 = 0;
  v2 = 0;
  for ( i = 0; v1 < dword_101C9700; ++v1 )
  {
    v4 = *(FILE **)(dword_101C86EC + 4 * v1);
    if ( v4 )
    {
      v5 = v4->_flag;
      if ( (v5 & 0x83) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( fflush_0(v4) != -1 )
            ++v2;
        }
        else if ( !a1 && (v5 & 2) != 0 && fflush_0(*(FILE **)(dword_101C86EC + 4 * v1)) == -1 )
        {
          i = -1;
        }
      }
    }
  }
  result = v2;
  if ( a1 != 1 )
    result = i;
  return result;
}
// 101C86EC: using guessed type int dword_101C86EC;
// 101C9700: using guessed type int dword_101C9700;

//----- (10019257) --------------------------------------------------------
int fprintf_0(FILE *a1, const char *a2, ...)
{
  int v2; // esi
  int v3; // edi
  va_list va; // [esp+18h] [ebp+10h] BYREF

  va_start(va, a2);
  v2 = _stbuf_0((int)a1);
  v3 = _output_0(a1, (int)a2, (int)va);
  _ftbuf_0(v2, (int)a1);
  return v3;
}

//----- (10019527) --------------------------------------------------------
int __cdecl raise_0(int a1)
{
  int v1; // edi
  void (__cdecl *v3)(int); // esi
  int *v4; // eax
  _DWORD *v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // edx

  v1 = a1;
  switch ( a1 )
  {
    case 2:
      v3 = (void (__cdecl *)(int))dword_101C8130;
      v4 = &dword_101C8130;
      break;
    case 4:
    case 8:
    case 11:
      v5 = siglookup_0(a1);
      v3 = (void (__cdecl *)(int))v5[2];
      v4 = v5 + 2;
      break;
    case 15:
      v3 = (void (__cdecl *)(int))dword_101C813C;
      v4 = &dword_101C813C;
      break;
    case 21:
      v3 = (void (__cdecl *)(int))dword_101C8134;
      v4 = &dword_101C8134;
      break;
    case 22:
      v3 = (void (__cdecl *)(int))dword_101C8138;
      v4 = &dword_101C8138;
      break;
    default:
      return -1;
  }
  if ( v3 == (void (__cdecl *)(int))1 )
    return 0;
  if ( !v3 )
    sub_10015F50(3u);
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    v6 = dword_101C8284;
    dword_101C8284 = 0;
    if ( a1 != 8 )
    {
LABEL_29:
      *v4 = 0;
      v3(v1);
      if ( v1 != 11 && v1 != 4 )
        return 0;
      goto LABEL_33;
    }
    v7 = dword_10028414;
    dword_10028414 = 140;
    a1 = v7;
  }
  else
  {
    v6 = a1;
  }
  if ( v1 != 8 )
    goto LABEL_29;
  if ( dword_10028408 < dword_10028408 + dword_1002840C )
  {
    v8 = dword_1002840C;
    v9 = (_DWORD *)(12 * dword_10028408 + 268600216);
    do
    {
      *v9 = 0;
      v9 += 3;
      --v8;
    }
    while ( v8 );
  }
  ((void (__cdecl *)(int, int))v3)(8, dword_10028414);
LABEL_33:
  dword_101C8284 = v6;
  if ( v1 == 8 )
    dword_10028414 = a1;
  return 0;
}
// 1001961C: conditional instruction was optimized away because of 'edi.4!=8'
// 10019617: variable 'v4' is possibly undefined
// 10028408: using guessed type int dword_10028408;
// 1002840C: using guessed type int dword_1002840C;
// 10028414: using guessed type int dword_10028414;
// 101C8130: using guessed type int dword_101C8130;
// 101C8134: using guessed type int dword_101C8134;
// 101C8138: using guessed type int dword_101C8138;
// 101C813C: using guessed type int dword_101C813C;
// 101C8284: using guessed type int dword_101C8284;

//----- (10019654) --------------------------------------------------------
_DWORD *__cdecl siglookup_0(int a1)
{
  _DWORD *result; // eax

  result = &unk_10028390;
  if ( dword_10028394 != a1 )
  {
    do
      result += 3;
    while ( (unsigned int)result < 12 * dword_10028410 + 268600208 && result[1] != a1 );
  }
  if ( (unsigned int)result >= 12 * dword_10028410 + 268600208 || result[1] != a1 )
    result = 0;
  return result;
}
// 10028394: using guessed type int dword_10028394;
// 10028410: using guessed type int dword_10028410;

//----- (10019699) --------------------------------------------------------
int __crtMessageBoxA_0()
{
  int v0; // ebx
  int v1; // eax
  int v2; // edi
  int (*v3)(void); // esi
  const char *v5; // [esp+0h] [ebp-1Ch]
  int v6; // [esp+4h] [ebp-18h]
  const char *v7; // [esp+8h] [ebp-14h]

  v0 = 0;
  if ( !dword_101C8144 )
  {
    v1 = FIX_DLL_KERNEL32_dll_LoadLibraryA("user32.dll");
    v2 = v1;
    if ( !v1 )
      return 0;
    v3 = FIX_DLL_KERNEL32_dll_GetProcAddress;
    v7 = "MessageBoxA";
    v6 = v1;
    dword_101C8144 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_GetProcAddress();
    if ( !dword_101C8144 )
      return 0;
    v5 = "GetActiveWindow";
    dword_101C8148 = (int (*)(void))((int (__cdecl *)(int))v3)(v2);
    dword_101C814C = (int (__cdecl *)(_DWORD))((int (__cdecl *)(int, const char *))v3)(v2, "GetLastActivePopup");
  }
  if ( dword_101C8148 )
  {
    v0 = dword_101C8148();
    if ( v0 )
    {
      if ( dword_101C814C )
        v0 = dword_101C814C(v0);
    }
  }
  return dword_101C8144(v0, v5, v6, v7);
}
// 10019714: variable 'v5' is possibly undefined
// 10019714: variable 'v6' is possibly undefined
// 10019714: variable 'v7' is possibly undefined
// 1002113C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_LoadLibraryA)(_DWORD);
// 10021140: using guessed type int (*FIX_DLL_KERNEL32_dll_GetProcAddress)(void);
// 101C8144: using guessed type int (__cdecl *dword_101C8144)(_DWORD, _DWORD, _DWORD, _DWORD);
// 101C8148: using guessed type int (*dword_101C8148)(void);
// 101C814C: using guessed type int (__cdecl *dword_101C814C)(_DWORD);

//----- (10019A40) --------------------------------------------------------
int __cdecl _stbuf_0(int a1)
{
  int v1; // eax
  int *v2; // edi
  _DWORD *v3; // eax
  int v4; // edi

  if ( !_isatty_0(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( (_UNKNOWN *)a1 == &unk_10026040 )
  {
    v1 = 0;
  }
  else
  {
    if ( (FILE *)a1 != &stru_10026060 )
      return 0;
    v1 = 1;
  }
  ++dword_101C812C;
  if ( (*(_WORD *)(a1 + 12) & 0x10C) != 0 )
    return 0;
  v2 = (int *)(4 * v1 + 270303568);
  if ( dword_101C8150[v1] || (v3 = sub_10019098(0x1000u), (*v2 = (int)v3) != 0) )
  {
    v4 = *v2;
    *(_DWORD *)(a1 + 24) = 4096;
    *(_DWORD *)(a1 + 8) = v4;
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)a1 = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
    *(_DWORD *)(a1 + 4) = 2;
  }
  *(_WORD *)(a1 + 12) |= 0x1102u;
  return 1;
}
// 101C812C: using guessed type int dword_101C812C;
// 101C8150: using guessed type int dword_101C8150[];

//----- (10019ACD) --------------------------------------------------------
int __cdecl _ftbuf_0(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
    {
      result = _flush_0((_DWORD *)a2);
      *(_BYTE *)(a2 + 13) &= 0xEEu;
      *(_DWORD *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  else
  {
    result = a2;
    if ( (*(_BYTE *)(a2 + 13) & 0x10) != 0 )
      result = _flush_0((_DWORD *)a2);
  }
  return result;
}

//----- (10019B0A) --------------------------------------------------------
int *__usercall _FF_MSGBANNER_0@<eax>(int a1@<esi>)
{
  int *result; // eax

  result = (int *)dword_101C80EC;
  if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
  {
    _NMSG_WRITE_0(a1, 0xFCu);
    if ( dword_101C8158 )
      dword_101C8158();
    result = _NMSG_WRITE_0(a1, 0xFFu);
  }
  return result;
}
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C8158: using guessed type int (*dword_101C8158)(void);

//----- (10019B43) --------------------------------------------------------
int *__usercall _NMSG_WRITE_0@<eax>(int a1@<esi>, DWORD NumberOfBytesWritten)
{
  int v2; // ecx
  int *result; // eax
  int v4; // esi
  char *v5; // edi
  const char **v6; // esi
  int v7; // eax
  _DWORD v8[10]; // [esp-3Ch] [ebp-1E0h] BYREF
  const char *v9; // [esp-14h] [ebp-1B8h]
  size_t v10; // [esp-10h] [ebp-1B4h]
  DWORD *v11; // [esp-Ch] [ebp-1B0h]
  int v12; // [esp-8h] [ebp-1ACh]
  int v13; // [esp-4h] [ebp-1A8h]
  char v14[260]; // [esp+0h] [ebp-1A4h] BYREF
  char v15[160]; // [esp+104h] [ebp-A0h] BYREF

  v2 = 0;
  result = dword_100262A0;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v2;
  }
  while ( (int)result < (int)off_10026330 );
  v13 = a1;
  v4 = 2 * v2;
  if ( NumberOfBytesWritten == dword_100262A0[2 * v2] )
  {
    result = (int *)dword_101C80EC;
    if ( dword_101C80EC == 1 || !dword_101C80EC && dword_101C80F0 == 1 )
    {
      v6 = (const char **)&dword_100262A4[v4];
      v12 = 0;
      v11 = &NumberOfBytesWritten;
      v10 = strlen(*v6);
      v9 = *v6;
      v7 = FIX_DLL_KERNEL32_dll_GetStdHandle();
      result = (int *)FIX_DLL_KERNEL32_dll_WriteFile(v7, -12, v9, v10, &NumberOfBytesWritten);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !FIX_DLL_KERNEL32_dll_GetModuleFileNameA(0, v14, 260, v13) )
        strcpy(v14, "<program name unknown>");
      v5 = v14;
      if ( strlen(v14) + 1 > 0x3C )
      {
        v5 = (char *)v8 + strlen(v14) + 1;
        strncpy_0(v5, "...", 3u);
      }
      strcpy(v15, "Runtime Error!\n\nProgram: ");
      strcat(v15, v5);
      strcat(v15, "\n\n");
      strcat(v15, (const char *)dword_100262A4[v4]);
      v8[1] = 73744;
      v8[0] = "Microsoft Visual C++ Runtime Library";
      result = (int *)__crtMessageBoxA_0();
    }
  }
  return result;
}
// 10019B43: could not find valid save-restore pair for esi
// 1002100C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021138: using guessed type int (*FIX_DLL_KERNEL32_dll_GetStdHandle)(void);
// 100262A0: using guessed type int dword_100262A0[];
// 100262A4: using guessed type int dword_100262A4[];
// 10026330: using guessed type int (*off_10026330[6])();
// 101C80EC: using guessed type int dword_101C80EC;
// 101C80F0: using guessed type int dword_101C80F0;

//----- (10019CC7) --------------------------------------------------------
unsigned int sub_10019CC7()
{
  return sub_1001D070(0x10000u, 196608);
}

//----- (10019D17) --------------------------------------------------------
// #STR: "IsProcessorFeaturePresent", "KERNEL32"
// #API: GetModuleHandleA(), GetProcAddress()
int __cdecl _ms_p5_mp_test_fdiv_0()
{
  int v0; // eax
  int (__cdecl *v1)(_DWORD); // eax

  v0 = FIX_DLL_KERNEL32_dll_GetModuleHandleA("KERNEL32");
  if ( !v0 || (v1 = (int (__cdecl *)(_DWORD))FIX_DLL_KERNEL32_dll_GetProcAddress(v0, "IsProcessorFeaturePresent")) == 0 )
    JUMPOUT(0x10019CD9);
  return v1(0);
}
// 10019D3B: control flows out of bounds to 10019CD9
// 10021134: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD);
// 10021140: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetProcAddress)(_DWORD, _DWORD);

//----- (1001A25C) --------------------------------------------------------
int __cdecl __loctotime_t_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  int v9; // ecx
  int v10; // eax
  int v12[8]; // [esp+0h] [ebp-24h] BYREF
  int v13; // [esp+2Ch] [ebp+8h]

  v7 = a1 - 1900;
  if ( a1 - 1900 < 70 || v7 > 138 )
    return -1;
  v8 = a3 + dword_10028534[a2];
  if ( (v7 & 3) == 0 && a2 > 2 )
    ++v8;
  sub_1001D891();
  v12[7] = v8;
  v12[5] = a1 - 1900;
  v12[2] = a4;
  v12[4] = a2 - 1;
  v9 = dword_10028450 + 60 * (a5 + 60 * (a4 + 24 * (((a1 - 1901) >> 2) + v8 + 365 * (a1 - 1900)))) + a6 + 2085978496;
  v13 = v9;
  if ( a7 == 1 || a7 == -1 && dword_10028454 && (v10 = _isindst(v12), v9 = v13, v10) )
    v9 += dword_10028458;
  return v9;
}
// 1001DB04: using guessed type _DWORD __cdecl _isindst(_DWORD);
// 10028450: using guessed type int dword_10028450;
// 10028454: using guessed type int dword_10028454;
// 10028458: using guessed type int dword_10028458;
// 10028534: using guessed type int dword_10028534[];

//----- (1001A31E) --------------------------------------------------------
char __cdecl sub_1001A31E(int a1)
{
  int v1; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  v1 = FIX_DLL_KERNEL32_dll_GetModuleHandleA(0);
  if ( *(_WORD *)v1 == 23117 )
  {
    v2 = *(_DWORD *)(v1 + 60);
    if ( v2 )
    {
      v1 += v2;
      *(_BYTE *)a1 = *(_BYTE *)(v1 + 26);
      LOBYTE(v1) = *(_BYTE *)(v1 + 27);
      *(_BYTE *)(a1 + 1) = v1;
    }
  }
  return v1;
}
// 10021134: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleHandleA)(_DWORD);

//----- (1001A34B) --------------------------------------------------------
int sub_1001A34B()
{
  int result; // eax
  char *i; // ecx
  char v2; // al
  char *v3; // eax
  char *j; // ecx
  char v5; // al
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // ecx
  char v9[4240]; // [esp+4h] [ebp-122Ch] BYREF
  char v10[260]; // [esp+1094h] [ebp-19Ch] BYREF
  int v11[37]; // [esp+1198h] [ebp-98h] BYREF
  char v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  v11[0] = 148;
  if ( FIX_DLL_KERNEL32_dll_GetVersionExA(v11) && v11[4] == 2 && v11[1] >= 5u )
    return 1;
  if ( !FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA() )
    goto LABEL_29;
  for ( i = v9; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", v9, 0x16u) )
  {
    v3 = v9;
  }
  else
  {
    FIX_DLL_KERNEL32_dll_GetModuleFileNameA(0, v10, 260, "__MSVCRT_HEAP_SELECT");
    for ( j = v10; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr_0(v9, v10);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr_0(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = v6 + 1;
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = strtol(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_1001A31E((int)v12);
    result = 3 - (v12[0] < 6u);
  }
  return result;
}
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 1002112C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetVersionExA)(_DWORD);
// 10021130: using guessed type int (*FIX_DLL_KERNEL32_dll_GetEnvironmentVariableA)(void);

//----- (1001A493) --------------------------------------------------------
int __cdecl sub_1001A493(int a1)
{
  int v1; // eax
  void **v2; // eax

  dword_101C86E4 = FIX_DLL_KERNEL32_dll_HeapCreate(a1 == 0, 4096);
  if ( !dword_101C86E4 )
    return 0;
  v1 = sub_1001A34B();
  dword_101C86E8 = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_1001C170();
  }
  if ( !v2 )
  {
    FIX_DLL_KERNEL32_dll_HeapDestroy(dword_101C86E4);
    return 0;
  }
  return 1;
}
// 1001B207: using guessed type int __cdecl __sbh_heap_init(_DWORD);
// 10021124: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapCreate)(_DWORD, _DWORD);
// 10021128: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD);
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001A4F0) --------------------------------------------------------
int __usercall sub_1001A4F0@<eax>(int a1@<ebx>, int a2@<ebp>)
{
  int v2; // ebx
  void (__cdecl *v3)(int, _DWORD, int); // ebp
  void (__cdecl *v4)(_DWORD, int, int, int, int); // edi
  _DWORD *v5; // esi
  void **v6; // esi
  void *v7; // eax

  if ( dword_101C86E8 == 3 )
  {
    v2 = 0;
    v3 = (void (__cdecl *)(int, _DWORD, int))FIX_DLL_KERNEL32_dll_HeapFree;
    if ( dword_101C85BC > 0 )
    {
      v4 = (void (__cdecl *)(_DWORD, int, int, int, int))FIX_DLL_KERNEL32_dll_VirtualFree;
      v5 = (_DWORD *)(dword_101C85C0 + 12);
      do
      {
        v4(*v5, 0x100000, 0x4000, a2, a1);
        ((void (__cdecl *)(_DWORD, _DWORD, int))v4)(*v5, 0, 0x8000);
        v3(dword_101C86E4, 0, v5[1]);
        v5 += 5;
        ++v2;
      }
      while ( v2 < dword_101C85BC );
    }
    v3(dword_101C86E4, 0, dword_101C85C0);
  }
  else if ( dword_101C86E8 == 2 )
  {
    v6 = &off_10026360;
    do
    {
      v7 = v6[4];
      if ( v7 )
        FIX_DLL_KERNEL32_dll_VirtualFree(v7, 0, 0x8000);
      v6 = (void **)*v6;
    }
    while ( v6 != &off_10026360 );
  }
  return FIX_DLL_KERNEL32_dll_HeapDestroy(dword_101C86E4);
}
// 1001A4F0: could not find valid save-restore pair for ebx
// 1001A4F0: could not find valid save-restore pair for ebp
// 1001A528: variable 'a2' is possibly undefined
// 1001A528: variable 'a1' is possibly undefined
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021128: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapDestroy)(_DWORD);
// 10021164: using guessed type int FIX_DLL_KERNEL32_dll_HeapFree;
// 10026360: using guessed type void *off_10026360;
// 101C85BC: using guessed type int dword_101C85BC;
// 101C85C0: using guessed type int dword_101C85C0;
// 101C86E4: using guessed type int dword_101C86E4;
// 101C86E8: using guessed type int dword_101C86E8;

//----- (1001A598) --------------------------------------------------------
int _ioinit_0()
{
  _DWORD *v0; // esi
  unsigned int i; // eax
  int v2; // esi
  _BYTE *v3; // ebp
  _DWORD *v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // eax
  unsigned int j; // ecx
  int k; // edi
  int v9; // eax
  int l; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // edi
  int v15; // eax
  int v17[4]; // [esp+10h] [ebp-44h] BYREF
  int v18; // [esp+40h] [ebp-14h]
  _DWORD *v19; // [esp+44h] [ebp-10h]

  v0 = sub_10019098(0x100u);
  if ( !v0 )
    _amsg_exit_0(27);
  dword_101C85E0[0] = (int)v0;
  dword_101C86E0 = 32;
  for ( i = (unsigned int)(v0 + 64); (unsigned int)v0 < i; i = dword_101C85E0[0] + 256 )
  {
    *((_BYTE *)v0 + 4) = 0;
    *v0 = -1;
    *((_BYTE *)v0 + 5) = 10;
    v0 += 2;
  }
  FIX_DLL_KERNEL32_dll_GetStartupInfoA(v17);
  if ( HIWORD(v18) && v19 )
  {
    v2 = *v19;
    v3 = v19 + 1;
    v4 = (_DWORD *)((char *)v19 + *v19 + 4);
    if ( (int)*v19 >= 2048 )
      v2 = 2048;
    if ( dword_101C86E0 < v2 )
    {
      v5 = &unk_101C85E4;
      while ( 1 )
      {
        v6 = sub_10019098(0x100u);
        if ( !v6 )
          break;
        dword_101C86E0 += 32;
        *v5 = v6;
        for ( j = (unsigned int)(v6 + 64); (unsigned int)v6 < j; j = *v5 + 256 )
        {
          *((_BYTE *)v6 + 4) = 0;
          *v6 = -1;
          *((_BYTE *)v6 + 5) = 10;
          v6 += 2;
        }
        ++v5;
        if ( dword_101C86E0 >= v2 )
          goto LABEL_19;
      }
      v2 = dword_101C86E0;
    }
LABEL_19:
    for ( k = 0; k < v2; ++v4 )
    {
      if ( *v4 != -1 && (*v3 & 1) != 0 && ((*v3 & 8) != 0 || FIX_DLL_KERNEL32_dll_GetFileType(*v4)) )
      {
        v9 = dword_101C85E0[k >> 5] + 8 * (k & 0x1F);
        *(_DWORD *)v9 = *v4;
        *(_BYTE *)(v9 + 4) = *v3;
      }
      ++k;
      ++v3;
    }
  }
  for ( l = 0; l < 3; ++l )
  {
    v11 = dword_101C85E0[0] + 8 * l;
    if ( *(_DWORD *)v11 == -1 )
    {
      *(_BYTE *)(v11 + 4) = -127;
      if ( l )
        v12 = -(l != 1) - 11;
      else
        v12 = -10;
      v13 = FIX_DLL_KERNEL32_dll_GetStdHandle(v12);
      v14 = v13;
      if ( v13 == -1
        || (v15 = FIX_DLL_KERNEL32_dll_GetFileType(v13)) == 0
        || (*(_DWORD *)v11 = v14, (unsigned __int8)v15 == 2) )
      {
        *(_BYTE *)(v11 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)v15 == 3 )
      {
        *(_BYTE *)(v11 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v11 + 4) |= 0x80u;
    }
  }
  return FIX_DLL_KERNEL32_dll_SetHandleCount(dword_101C86E0);
}
// 10021114: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetStartupInfoA)(_DWORD);
// 10021118: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetFileType)(_DWORD);
// 1002111C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_SetHandleCount)(_DWORD);
// 10021138: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetStdHandle)(_DWORD);
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001A766) --------------------------------------------------------
void _setenvp_0()
{
  char *v0; // esi
  int v1; // edi
  char **v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  char *v6; // eax

  if ( !dword_101C9710 )
    sub_1001E4BC();
  v0 = dword_101C80E4;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = (char **)sub_10019098(4 * v1 + 4);
  dword_101C809C = (int)v2;
  if ( !v2 )
    _amsg_exit_0(9);
  for ( i = dword_101C80E4; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = (char *)sub_10019098(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit_0(9);
      strcpy(*v2++, i);
    }
  }
  sub_100189EC((unsigned int)dword_101C80E4);
  dword_101C80E4 = 0;
  *v2 = 0;
  dword_101C970C = 1;
}
// 101C809C: using guessed type int dword_101C809C;
// 101C970C: using guessed type int dword_101C970C;
// 101C9710: using guessed type int dword_101C9710;

//----- (1001A81F) --------------------------------------------------------
int _setargv_0()
{
  unsigned __int8 *v0; // edi
  unsigned __int8 **v1; // esi
  int result; // eax
  int v3; // [esp+0h] [ebp-8h] BYREF
  int v4; // [esp+4h] [ebp-4h] BYREF

  if ( !dword_101C9710 )
    sub_1001E4BC();
  ((void (__cdecl *)(_DWORD, void *, int))FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(0, &unk_101C816C, 260);
  dword_101C80AC = (int)&unk_101C816C;
  v0 = (unsigned __int8 *)&unk_101C816C;
  if ( *(_BYTE *)dword_101C9704 )
    v0 = (unsigned __int8 *)dword_101C9704;
  parse_cmdline_0(v0, 0, 0, &v4, &v3);
  v1 = (unsigned __int8 **)sub_10019098(v3 + 4 * v4);
  if ( !v1 )
    _amsg_exit_0(8);
  parse_cmdline_0(v0, v1, (unsigned __int8 *)&v1[v4], &v4, &v3);
  result = v4 - 1;
  dword_101C8094 = (int)v1;
  dword_101C8090 = v4 - 1;
  return result;
}
// 100210CC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetModuleFileNameA)(_DWORD, _DWORD, _DWORD, _DWORD);
// 101C8090: using guessed type int dword_101C8090;
// 101C8094: using guessed type int dword_101C8094;
// 101C80AC: using guessed type int dword_101C80AC;
// 101C9704: using guessed type int dword_101C9704;
// 101C9710: using guessed type int dword_101C9710;

//----- (1001A8B8) --------------------------------------------------------
_DWORD *__cdecl parse_cmdline_0(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  _DWORD *result; // eax
  int v17; // [esp+14h] [ebp+8h]
  bool v18; // [esp+24h] [ebp+18h]

  *a5 = 0;
  v6 = a3;
  v7 = a2;
  *a4 = 1;
  v8 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v7 = ++a2;
  }
  if ( *a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_101C84A1[v9] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_101C84A1[v10] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = v7;
    }
    ++*a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_101C84A1[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_101C84A1[v15] & 4) != 0 )
        {
          ++v8;
          ++*a5;
        }
        ++*a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*a4;
  return result;
}
// 1001A961: conditional instruction was optimized away because of 'dl.1 in (==9|==20)'

//----- (1001AA6C) --------------------------------------------------------
_DWORD *__crtGetEnvironmentStringsA_0()
{
  int (*v0)(void); // ebp
  unsigned int v1; // ebx
  int v2; // esi
  int v3; // edi
  _WORD *i; // eax
  int (__cdecl *v5)(_DWORD, _DWORD, int, int); // edi
  size_t v6; // eax
  _DWORD *v7; // eax
  _BYTE *j; // eax
  size_t v10; // ebp
  _DWORD *v11; // eax
  _DWORD *v12; // esi
  unsigned int v13; // [esp+0h] [ebp-48h]
  int v14; // [esp+24h] [ebp-24h]

  v0 = FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  if ( dword_101C8270 )
  {
    if ( dword_101C8270 == 1 )
      goto LABEL_7;
    if ( dword_101C8270 != 2 )
      return 0;
  }
  else
  {
    v2 = FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW();
    if ( v2 )
    {
      dword_101C8270 = 1;
LABEL_7:
      if ( v2 || (v2 = v0()) != 0 )
      {
        for ( i = (_WORD *)v2; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        v5 = (int (__cdecl *)(_DWORD, _DWORD, int, int))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
        v6 = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(0, 0, v2, (((int)i - v2) >> 1) + 1, 0, 0, 0, 0);
        if ( v6 )
        {
          v7 = sub_10019098(v6);
          if ( v7 )
          {
            v13 = (unsigned int)v7;
            if ( !v5(0, 0, v2, v14) )
            {
              sub_100189EC(v13);
              v13 = 0;
            }
            v1 = v13;
          }
        }
        FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW(v2);
        return (_DWORD *)v1;
      }
      return 0;
    }
    v3 = FIX_DLL_KERNEL32_dll_GetEnvironmentStrings();
    if ( !v3 )
      return 0;
    dword_101C8270 = 2;
  }
  if ( !v3 )
  {
    v3 = FIX_DLL_KERNEL32_dll_GetEnvironmentStrings();
    if ( !v3 )
      return 0;
  }
  for ( j = (_BYTE *)v3; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v10 = (size_t)&j[-v3 + 1];
  v11 = sub_10019098(v10);
  v12 = v11;
  if ( v11 )
    ((void (__cdecl *)(_DWORD *, int, size_t))loc_1001C9D0)(v11, v3, v10);
  else
    v12 = 0;
  FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA(v3);
  return v12;
}
// 1001AB21: variable 'v14' is possibly undefined
// 10021104: using guessed type int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStringsW)(void);
// 10021108: using guessed type int (*FIX_DLL_KERNEL32_dll_GetEnvironmentStrings)(void);
// 1002110C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsW)(_DWORD);
// 10021110: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_FreeEnvironmentStringsA)(_DWORD);
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8270: using guessed type int dword_101C8270;

//----- (1001AB9E) --------------------------------------------------------
bool __cdecl sub_1001AB9E(int a1, int a2)
{
  return FIX_DLL_KERNEL32_dll_IsBadReadPtr(a1, a2) == 0;
}
// 10021018: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadReadPtr)(_DWORD, _DWORD);

//----- (1001ABBA) --------------------------------------------------------
bool __cdecl sub_1001ABBA(int a1, int a2)
{
  return FIX_DLL_KERNEL32_dll_IsBadWritePtr(a1, a2) == 0;
}
// 10021100: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadWritePtr)(_DWORD, _DWORD);

//----- (1001ABD6) --------------------------------------------------------
bool __cdecl sub_1001ABD6(int a1)
{
  return FIX_DLL_KERNEL32_dll_IsBadCodePtr(a1) == 0;
}
// 100210F8: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_IsBadCodePtr)(_DWORD);

//----- (1001ABEE) --------------------------------------------------------
int __cdecl __crtGetStringTypeA_0(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  _BYTE v15[60]; // [esp-70h] [ebp-70h] BYREF
  _DWORD v16[5]; // [esp-34h] [ebp-34h] BYREF
  int v17; // [esp-20h] [ebp-20h]
  int v18; // [esp-1Ch] [ebp-1Ch] BYREF
  _BYTE *v19; // [esp-18h] [ebp-18h]
  unsigned int v20; // [esp-10h] [ebp-10h]
  void *v21; // [esp-Ch] [ebp-Ch]
  void *v22; // [esp-8h] [ebp-8h]
  int v23; // [esp-4h] [ebp-4h]

  v23 = -1;
  v22 = &unk_10022090;
  v21 = &unknown_libname_67;
  v20 = __readfsdword(0);
  v19 = v16;
  v7 = dword_101C8274;
  if ( !dword_101C8274 )
  {
    if ( FIX_DLL_KERNEL32_dll_GetStringTypeW(1, &unk_10021D18, 1, &v18) )
    {
      v7 = 1;
    }
    else
    {
      if ( !FIX_DLL_KERNEL32_dll_GetStringTypeA(0, 1, &unk_10021D14, 1, &v18) )
        return 0;
      v7 = 2;
    }
    dword_101C8274 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = dword_101C8124;
      v10 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, a7 != 0 ? 9 : 1, lpMultiByteStr, cbMultiByte, 0, 0);
      v17 = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        v19 = v15;
        v16[4] = v15;
        memset(v15, 0, v11);
        v23 = -1;
        if ( v15 )
        {
          v14 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(CodePage, 1, lpMultiByteStr, cbMultiByte, v15, v17);
          if ( v14 )
            return FIX_DLL_KERNEL32_dll_GetStringTypeW(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_101C8114;
  return FIX_DLL_KERNEL32_dll_GetStringTypeA(v8, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType);
}
// 100210F0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeW)(_DWORD, _DWORD, _DWORD, _DWORD);
// 100210F4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetStringTypeA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8114: using guessed type int dword_101C8114;
// 101C8124: using guessed type int dword_101C8124;
// 101C8274: using guessed type int dword_101C8274;

//----- (1001AD37) --------------------------------------------------------
int __cdecl _lseek_0(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  unsigned int v6; // eax

  if ( a1 < (unsigned int)dword_101C86E0
    && (v3 = 8 * (a1 & 0x1F), (*(_BYTE *)(dword_101C85E0[a1 >> 5] + v3 + 4) & 1) != 0) )
  {
    v4 = _get_osfhandle_0(a1);
    if ( v4 == -1 )
    {
      dword_101C8074 = 9;
    }
    else
    {
      v5 = FIX_DLL_KERNEL32_dll_SetFilePointer(v4, a2, 0, a3);
      if ( v5 == -1 )
        v6 = FIX_DLL_KERNEL32_dll_GetLastError();
      else
        v6 = 0;
      if ( !v6 )
      {
        *(_BYTE *)(dword_101C85E0[a1 >> 5] + v3 + 4) &= 0xFDu;
        return v5;
      }
      _dosmaperr_0(v6);
    }
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 10021010: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetFilePointer)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001ADD1) --------------------------------------------------------
int __cdecl _write_0(int a1, const void *a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  int v4; // esi
  char v5; // al
  int v7; // eax
  int *v8; // eax
  char *v9; // ecx
  char v10; // cl
  int v11; // edi
  int v12[3]; // [esp+0h] [ebp-414h] BYREF
  int v13; // [esp+404h] [ebp-10h]
  int v14; // [esp+408h] [ebp-Ch] BYREF
  int v15; // [esp+40Ch] [ebp-8h]
  char *v16; // [esp+410h] [ebp-4h]
  int v17; // [esp+41Ch] [ebp+8h]

  if ( a1 < (unsigned int)dword_101C86E0
    && (v3 = (_DWORD *)(4 * (a1 >> 5) + 270304736),
        v4 = 8 * (a1 & 0x1F),
        v5 = *(_BYTE *)(dword_101C85E0[a1 >> 5] + v4 + 4),
        (v5 & 1) != 0) )
  {
    v15 = 0;
    v13 = 0;
    if ( !a3 )
      return 0;
    if ( (v5 & 0x20) != 0 )
      _lseek_0(a1, 0, 2);
    v7 = v4 + dword_101C85E0[a1 >> 5];
    if ( *(char *)(v7 + 4) >= 0 )
    {
      if ( FIX_DLL_KERNEL32_dll_WriteFile(*(_DWORD *)v7, a2, a3, &v14, 0) )
      {
        v17 = 0;
        v15 = v14;
      }
      else
      {
        v17 = FIX_DLL_KERNEL32_dll_GetLastError();
      }
    }
    else
    {
      v16 = (char *)a2;
      v17 = 0;
      while ( 1 )
      {
        v8 = v12;
        do
        {
          if ( v16 - (_BYTE *)a2 >= a3 )
            break;
          v9 = v16++;
          v10 = *v9;
          if ( v10 == 10 )
          {
            ++v13;
            *(_BYTE *)v8 = 13;
            v8 = (int *)((char *)v8 + 1);
          }
          *(_BYTE *)v8 = v10;
          v8 = (int *)((char *)v8 + 1);
        }
        while ( (char *)v8 - (char *)v12 < 1024 );
        v11 = (char *)v8 - (char *)v12;
        if ( !FIX_DLL_KERNEL32_dll_WriteFile(*(_DWORD *)(*v3 + v4), v12, (char *)v8 - (char *)v12, &v14, 0) )
          break;
        v15 += v14;
        if ( v14 < v11 || v16 - (_BYTE *)a2 >= a3 )
          goto LABEL_17;
      }
      v17 = FIX_DLL_KERNEL32_dll_GetLastError();
    }
LABEL_17:
    if ( v15 )
      return v15 - v13;
    if ( v17 )
    {
      if ( v17 == 5 )
      {
        dword_101C8074 = 9;
        dword_101C8078 = 5;
      }
      else
      {
        _dosmaperr_0(v17);
      }
    }
    else
    {
      if ( (*(_BYTE *)(*v3 + v4 + 4) & 0x40) != 0 && *(_BYTE *)a2 == 26 )
        return 0;
      dword_101C8074 = 28;
      dword_101C8078 = 0;
    }
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 1001AE4C: conditional instruction was optimized away because of '%arg_8.4!=0'
// 1002100C: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_WriteFile)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001AF7E) --------------------------------------------------------
int __cdecl _getbuf_0(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  ++dword_101C812C;
  v1 = sub_10019098(0x1000u);
  a1[2] = v1;
  if ( v1 )
  {
    a1[3] |= 8u;
    a1[6] = 4096;
  }
  else
  {
    a1[3] |= 4u;
    a1[2] = a1 + 5;
    a1[6] = 2;
  }
  result = a1[2];
  a1[1] = 0;
  *a1 = result;
  return result;
}
// 101C812C: using guessed type int dword_101C812C;

//----- (1001AFC2) --------------------------------------------------------
int __cdecl _isatty_0(int a1)
{
  int result; // eax

  if ( a1 < (unsigned int)dword_101C86E0 )
    result = *(_BYTE *)(dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 0x40;
  else
    result = 0;
  return result;
}
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001AFE8) --------------------------------------------------------
int __cdecl wctomb_0(char *a1, wchar_t a2)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    if ( !dword_101C8114 )
    {
      if ( a2 <= 0xFFu )
      {
        *a1 = a2;
        return 1;
      }
      goto LABEL_7;
    }
    a1 = 0;
    result = FIX_DLL_KERNEL32_dll_WideCharToMultiByte(dword_101C8124, 544, &a2, 1, result, dword_10026004, 0, &a1);
    if ( !result || a1 )
    {
LABEL_7:
      dword_101C8074 = 42;
      return -1;
    }
  }
  return result;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10026004: using guessed type int dword_10026004;
// 101C8074: using guessed type int dword_101C8074;
// 101C8114: using guessed type int dword_101C8114;
// 101C8124: using guessed type int dword_101C8124;

//----- (1001B24F) --------------------------------------------------------
unsigned int __cdecl __sbh_find_block_0(int a1)
{
  unsigned int result; // eax

  for ( result = dword_101C85C0; result < dword_101C85C0 + 20 * dword_101C85BC; result += 20 )
  {
    if ( (unsigned int)(a1 - *(_DWORD *)(result + 12)) < 0x100000 )
      return result;
  }
  return 0;
}
// 101C85BC: using guessed type int dword_101C85BC;
// 101C85C0: using guessed type int dword_101C85C0;

//----- (1001B27A) --------------------------------------------------------
_DWORD *__cdecl sub_1001B27A(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  _BOOL1 v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  void (__cdecl *v18)(_DWORD, _DWORD, int); // esi
  _DWORD *v19; // eax
  _DWORD *v20; // [esp+Ch] [ebp-10h]
  int v21; // [esp+10h] [ebp-Ch]
  int v22; // [esp+14h] [ebp-8h]
  int v23; // [esp+18h] [ebp-4h]
  char *v24; // [esp+28h] [ebp+Ch]
  int *v25; // [esp+28h] [ebp+Ch]
  char v26; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v20 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v23 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v21 = *(int *)((char *)v3 + v5);
    v22 = *(_DWORD *)(a2 - 8);
    v24 = (char *)v3 + v5;
    if ( (v21 & 1) == 0 )
    {
      v7 = (v21 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v23;
        v6 = v24;
      }
      v5 += v21;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v23 = v5;
      *(_DWORD *)(*((_DWORD *)v24 + 1) + 8) = *((_DWORD *)v24 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v22 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v25 = (int *)((char *)v3 - v22);
      v14 = (v22 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v23 = v22 + v5;
      v13 = ((v22 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v25[1] == v25[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v25[2] + 4) = v25[1];
        *(_DWORD *)(v25[1] + 8) = v25[2];
      }
      v3 = v25;
    }
    if ( (v22 & 1) != 0 || v14 != v13 )
    {
      v17 = &v20[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v26 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v26 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v26 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v26 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v23;
    *(int *)((char *)v3 + v23 - 4) = v23;
    result += 129 * v4 + 81;
    v10 = (*v20)-- == 1;
    if ( v10 )
    {
      if ( dword_101C85B8 )
      {
        v18 = (void (__cdecl *)(_DWORD, _DWORD, int))FIX_DLL_KERNEL32_dll_VirtualFree;
        FIX_DLL_KERNEL32_dll_VirtualFree(*((_DWORD *)dword_101C85B8 + 3) + (dword_101C85AC << 15), 0x8000, 0x4000);
        *((_DWORD *)dword_101C85B8 + 2) |= 0x80000000 >> dword_101C85AC;
        *(_DWORD *)(*((_DWORD *)dword_101C85B8 + 4) + 4 * dword_101C85AC + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_101C85B8 + 4) + 67);
        v19 = dword_101C85B8;
        if ( !*(_BYTE *)(*((_DWORD *)dword_101C85B8 + 4) + 67) )
        {
          *((_DWORD *)dword_101C85B8 + 1) &= 0xFFFFFFFE;
          v19 = dword_101C85B8;
        }
        if ( v19[2] == -1 )
        {
          v18(v19[3], 0, 0x8000);
          FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, *((_DWORD *)dword_101C85B8 + 4));
          memcpy_0(
            dword_101C85B8,
            (char *)dword_101C85B8 + 20,
            20 * dword_101C85BC - (_DWORD)dword_101C85B8 + dword_101C85C0 - 20);
          --dword_101C85BC;
          if ( a1 > dword_101C85B8 )
            a1 -= 5;
          dword_101C85B0 = dword_101C85C0;
        }
      }
      result = a1;
      dword_101C85AC = v4;
      dword_101C85B8 = a1;
    }
  }
  return result;
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 101C85AC: using guessed type int dword_101C85AC;
// 101C85B0: using guessed type int dword_101C85B0;
// 101C85BC: using guessed type int dword_101C85BC;
// 101C85C0: using guessed type int dword_101C85C0;

//----- (1001B5A3) --------------------------------------------------------
_DWORD *__cdecl __sbh_alloc_block_0(int a1)
{
  int v1; // ecx
  unsigned int v2; // esi
  _DWORD *i; // ebx
  _BOOL1 v4; // zf
  _BOOL1 v5; // zf
  _BOOL1 v6; // zf
  _DWORD *v8; // eax
  int v9; // edx
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // edi
  int v13; // ecx
  int *v14; // edx
  int v15; // ecx
  int v16; // esi
  unsigned int v17; // ebx
  _BYTE *v18; // edi
  unsigned int v19; // ebx
  _BYTE *v20; // edi
  int v21; // ebx
  _DWORD *v22; // ecx
  char v23; // cl
  _DWORD *v24; // edx
  int v25; // [esp+0h] [ebp-14h]
  int v26; // [esp+0h] [ebp-14h]
  signed int v27; // [esp+4h] [ebp-10h]
  unsigned int v28; // [esp+8h] [ebp-Ch]
  _DWORD *v29; // [esp+8h] [ebp-Ch]
  unsigned int v30; // [esp+Ch] [ebp-8h]
  int v31; // [esp+Ch] [ebp-8h]
  unsigned int v32; // [esp+10h] [ebp-4h]
  int v33; // [esp+10h] [ebp-4h]
  _DWORD *v34; // [esp+1Ch] [ebp+8h]

  v32 = dword_101C85C0 + 20 * dword_101C85BC;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> ((v27 >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (_DWORD *)dword_101C85B0;
  v34 = (_DWORD *)dword_101C85B0;
  if ( dword_101C85B0 < (unsigned int)(dword_101C85C0 + 20 * dword_101C85BC) )
  {
    do
    {
      if ( v2 & *i | v30 & i[1] )
        break;
      i += 5;
      v34 = i;
    }
    while ( (unsigned int)i < v32 );
  }
  if ( i == (_DWORD *)v32 )
  {
    for ( i = (_DWORD *)dword_101C85C0; ; i += 5 )
    {
      v4 = i == (_DWORD *)dword_101C85B0;
      v34 = i;
      if ( (unsigned int)i >= dword_101C85B0 )
        break;
      if ( v2 & *i | v30 & i[1] )
      {
        v4 = i == (_DWORD *)dword_101C85B0;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == (_DWORD *)v32;
        if ( (unsigned int)i >= v32 )
          break;
        if ( i[2] )
        {
          v5 = i == (_DWORD *)v32;
          break;
        }
        i += 5;
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (_DWORD *)dword_101C85C0; ; i += 5 )
        {
          v6 = i == (_DWORD *)dword_101C85B0;
          v34 = i;
          if ( (unsigned int)i >= dword_101C85B0 )
            break;
          if ( i[2] )
          {
            v6 = i == (_DWORD *)dword_101C85B0;
            break;
          }
        }
        if ( v6 )
        {
          i = (_DWORD *)__sbh_alloc_new_region();
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      *(_DWORD *)i[4] = __sbh_alloc_new_group(i);
      if ( *(_DWORD *)i[4] == -1 )
        return 0;
    }
  }
  dword_101C85B0 = (int)i;
  v8 = (_DWORD *)i[4];
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      v34[1] &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = v14;
    *(_DWORD *)(v14[1] + 8) = v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          i[1] |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && i == dword_101C85B8 && v33 == dword_101C85AC )
    dword_101C85B8 = 0;
  *v8 = v33;
  return v24 + 1;
}
// 1001B8AC: using guessed type int __sbh_alloc_new_region(void);
// 1001B95D: using guessed type _DWORD __cdecl __sbh_alloc_new_group(_DWORD);
// 101C85AC: using guessed type int dword_101C85AC;
// 101C85B0: using guessed type int dword_101C85B0;
// 101C85BC: using guessed type int dword_101C85BC;
// 101C85C0: using guessed type int dword_101C85C0;

//----- (1001BA58) --------------------------------------------------------
int __cdecl __sbh_resize_block_0(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  int v12; // ebx
  _BOOL1 v13; // zf
  unsigned int v14; // ebx
  _BYTE *v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  char v20; // cl
  int v21; // edx
  int *v22; // eax
  int v24; // ecx
  int *v25; // ebx
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // ebx
  _BYTE *v29; // esi
  int v30; // ebx
  _BYTE *v31; // ecx
  unsigned int v32; // ebx
  unsigned int v33; // ecx
  _DWORD *v34; // eax
  char v35; // cl
  int v36; // [esp+0h] [ebp-Ch]
  int v37; // [esp+4h] [ebp-8h]
  int v38; // [esp+8h] [ebp-4h]
  int v39; // [esp+8h] [ebp-4h]
  int *v40; // [esp+18h] [ebp+Ch]
  char v41; // [esp+1Bh] [ebp+Fh]
  int v42; // [esp+1Ch] [ebp+10h]
  unsigned int v43; // [esp+1Ch] [ebp+10h]
  int v44; // [esp+1Ch] [ebp+10h]
  char v45; // [esp+1Fh] [ebp+13h]

  v3 = a1[4];
  v4 = (a3 + 23) & 0xFFFFFFF0;
  v5 = (unsigned int)(a2 - a1[3]) >> 15;
  v36 = 516 * v5 + v3 + 324;
  v6 = *(_DWORD *)(a2 - 4) - 1;
  v42 = v6;
  v7 = *(_DWORD *)(v6 + a2 - 4);
  v8 = v6 + a2 - 4;
  v38 = v7;
  if ( v4 <= v6 )
  {
    if ( v4 < v6 )
    {
      v44 = v6 - v4;
      v24 = v4 + 1;
      *(_DWORD *)(a2 - 4) = v4 + 1;
      v25 = (int *)(a2 + v4 - 4);
      v40 = v25;
      v26 = (v44 >> 4) - 1;
      *(v25 - 1) = v24;
      if ( v26 > 0x3F )
        v26 = 63;
      if ( (v38 & 1) == 0 )
      {
        v27 = (v38 >> 4) - 1;
        if ( v27 > 0x3F )
          v27 = 63;
        if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
        {
          if ( v27 >= 0x20 )
          {
            v31 = (_BYTE *)(v27 + v3 + 4);
            v32 = ~(0x80000000 >> (v27 - 32));
            *(_DWORD *)(v3 + 4 * v5 + 196) &= v32;
            v13 = (*v31)-- == 1;
            if ( v13 )
              a1[1] &= v32;
          }
          else
          {
            v28 = 0x80000000 >> v27;
            v29 = (_BYTE *)(v27 + v3 + 4);
            v30 = ~v28;
            *(_DWORD *)(v3 + 4 * v5 + 68) &= v30;
            v13 = (*v29)-- == 1;
            if ( v13 )
              *a1 &= v30;
          }
          v25 = v40;
        }
        *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
        *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
        v44 += v38;
        v26 = (v44 >> 4) - 1;
        if ( v26 > 0x3F )
          v26 = 63;
      }
      v33 = v36 + 8 * v26;
      v25[1] = *(_DWORD *)(v33 + 4);
      v25[2] = v33;
      *(_DWORD *)(v33 + 4) = v25;
      *(_DWORD *)(v25[1] + 8) = v25;
      if ( v25[1] == v25[2] )
      {
        v41 = *(_BYTE *)(v26 + v3 + 4);
        *(_BYTE *)(v26 + v3 + 4) = v41 + 1;
        if ( v26 >= 0x20 )
        {
          if ( !v41 )
            a1[1] |= 0x80000000 >> (v26 - 32);
          v34 = (_DWORD *)(v3 + 4 * v5 + 196);
          v35 = v26 - 32;
        }
        else
        {
          if ( !v41 )
            *a1 |= 0x80000000 >> v26;
          v34 = (_DWORD *)(v3 + 4 * v5 + 68);
          v35 = v26;
        }
        *v34 |= 0x80000000 >> v35;
      }
      *v25 = v44;
      *(int *)((char *)v25 + v44 - 4) = v44;
    }
  }
  else
  {
    if ( (v7 & 1) != 0 || v4 > v6 + v7 )
      return 0;
    v9 = (v7 >> 4) - 1;
    v37 = v9;
    if ( v9 > 0x3F )
    {
      v9 = 63;
      v37 = 63;
    }
    if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
    {
      if ( v9 >= 0x20 )
      {
        v14 = 0x80000000 >> (v9 - 32);
        v15 = (_BYTE *)(v37 + v3 + 4);
        v16 = ~v14;
        *(_DWORD *)(v3 + 4 * v5 + 196) &= v16;
        v13 = (*v15)-- == 1;
        if ( v13 )
          a1[1] &= v16;
      }
      else
      {
        v10 = 0x80000000 >> v9;
        v11 = (_BYTE *)(v37 + v3 + 4);
        v12 = ~v10;
        *(_DWORD *)(v3 + 4 * v5 + 68) &= v12;
        v13 = (*v11)-- == 1;
        if ( v13 )
          *a1 &= v12;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
    v39 = v42 - v4 + v38;
    if ( v39 <= 0 )
    {
      v21 = a2;
    }
    else
    {
      v17 = (v39 >> 4) - 1;
      v18 = a2 + v4 - 4;
      if ( v17 > 0x3F )
        v17 = 63;
      v43 = v36 + 8 * v17;
      *(_DWORD *)(a2 + v4) = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v43;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(a2 + v4) + 8) = a2 + v4 - 4;
      if ( *(_DWORD *)(a2 + v4) == *(_DWORD *)(a2 + v4 - 4 + 8) )
      {
        v45 = *(_BYTE *)(v17 + v3 + 4);
        *(_BYTE *)(v17 + v3 + 4) = v45 + 1;
        if ( v17 >= 0x20 )
        {
          if ( !v45 )
            a1[1] |= 0x80000000 >> (v17 - 32);
          v19 = (_DWORD *)(v3 + 4 * v5 + 196);
          v20 = v17 - 32;
        }
        else
        {
          if ( !v45 )
            *a1 |= 0x80000000 >> v17;
          v19 = (_DWORD *)(v3 + 4 * v5 + 68);
          v20 = v17;
        }
        *v19 |= 0x80000000 >> v20;
      }
      v21 = a2;
      v22 = (int *)(a2 + v4 - 4);
      *v22 = v39;
      *(int *)((char *)v22 + v39 - 4) = v39;
    }
    *(_DWORD *)(v21 - 4) = v4 + 1;
    *(_DWORD *)(v21 + v4 - 8) = v4 + 1;
  }
  return 1;
}

//----- (1001C170) --------------------------------------------------------
void **sub_1001C170()
{
  void **v0; // esi
  int (__stdcall *v1)(int, int, int, int); // ebp
  int v2; // eax
  _DWORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // edx

  if ( dword_10026370 == -1 )
  {
    v0 = &off_10026360;
  }
  else
  {
    v0 = (void **)FIX_DLL_KERNEL32_dll_HeapAlloc(dword_101C86E4, 0, 8224);
    if ( !v0 )
      return 0;
  }
  v1 = FIX_DLL_KERNEL32_dll_VirtualAlloc;
  v2 = FIX_DLL_KERNEL32_dll_VirtualAlloc(0, dword_400000, 0x2000, 4);
  v3 = (_DWORD *)v2;
  if ( !v2 )
  {
LABEL_19:
    if ( v0 != &off_10026360 )
      FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, v0);
    return 0;
  }
  if ( !v1(v2, 0x10000, 4096, 4) )
  {
    FIX_DLL_KERNEL32_dll_VirtualFree(v3, 0, 0x8000);
    goto LABEL_19;
  }
  if ( v0 == &off_10026360 )
  {
    if ( !off_10026360 )
      off_10026360 = &off_10026360;
    if ( !dword_10026364 )
      dword_10026364 = (int)&off_10026360;
  }
  else
  {
    *v0 = &off_10026360;
    v0[1] = (void *)dword_10026364;
    dword_10026364 = (int)v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = (char *)dword_400000 + (_DWORD)v3;
  v4 = (int *)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = v3;
  v0[2] = v0 + 6;
  v5 = 0;
  do
  {
    v6 = v5++ >= 16 ? -1 : 240;
    *v4 = v6;
    v4[1] = 241;
    v4 += 2;
  }
  while ( v5 < 1024 );
  memset(v3, 0, 0x10000u);
  while ( v3 < (_DWORD *)((char *)v0[4] + 0x10000) )
  {
    *((_BYTE *)v3 + 248) = -1;
    *v3 = v3 + 2;
    v3[1] = 240;
    v3 += 1024;
  }
  return v0;
}
// 10021164: invalid function type has been ignored
// 100210EC: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 10021180: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapAlloc)(_DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10026364: using guessed type int dword_10026364;
// 10026370: using guessed type int dword_10026370;

//----- (1001C2B4) --------------------------------------------------------
int __cdecl sub_1001C2B4(void **a1)
{
  int result; // eax

  result = FIX_DLL_KERNEL32_dll_VirtualFree(a1[4], 0, 0x8000);
  if ( (void **)dword_10028380 == a1 )
  {
    result = (int)a1[1];
    dword_10028380 = result;
  }
  if ( a1 == &off_10026360 )
  {
    dword_10026370 = -1;
  }
  else
  {
    *(_DWORD *)a1[1] = *a1;
    *((_DWORD *)*a1 + 1) = a1[1];
    result = FIX_DLL_KERNEL32_dll_HeapFree(dword_101C86E4, 0, a1);
  }
  return result;
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10021164: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_HeapFree)(_DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10026370: using guessed type int dword_10026370;
// 10028380: using guessed type int dword_10028380;

//----- (1001C30A) --------------------------------------------------------
void __cdecl sub_1001C30A(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = (_DWORD *)dword_10026364;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && FIX_DLL_KERNEL32_dll_VirtualFree(v1[4] + i, 4096, 0x4000) )
        {
          *v2 = -1;
          --dword_101C8278;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_1001C2B4((void **)v5);
      }
    }
  }
  while ( v1 != (_DWORD *)dword_10026364 && a1 > 0 );
}
// 10021120: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualFree)(_DWORD, _DWORD, _DWORD);
// 10026364: using guessed type int dword_10026364;
// 101C8278: using guessed type int dword_101C8278;

//----- (1001C3CC) --------------------------------------------------------
unsigned int __cdecl sub_1001C3CC(unsigned int a1, void ***a2, unsigned int *a3)
{
  void **v3; // ecx

  v3 = &off_10026360;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_10026360 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 10026360: using guessed type void *off_10026360;

//----- (1001C423) --------------------------------------------------------
void __cdecl sub_1001C423(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  _BOOL1 v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_101C8278 == 32 )
    sub_1001C30A(16);
}
// 101C8278: using guessed type int dword_101C8278;

//----- (1001C468) --------------------------------------------------------
int __cdecl sub_1001C468(unsigned int a1)
{
  _DWORD *v1; // esi
  int v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  int result; // eax
  void **v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  int i; // esi
  void **v11; // ecx
  int v12; // eax
  void **v13; // eax
  _BOOL1 v14; // cf
  void **v15; // eax
  _BYTE *v16; // ecx
  unsigned int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = (_DWORD *)dword_10028380;
  do
  {
    v2 = v1[4];
    if ( v2 == -1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = v2 + (((char *)v3 - (char *)v1 - 24) >> 3 << 12);
      v18 = v4;
      if ( v3 < v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = sub_1001C670(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              dword_10028380 = (int)v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = v1 + 6;
      v17 = v1[2];
      v19 = v1[4];
      if ( (unsigned int)(v1 + 6) < v17 )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = sub_1001C670(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < v17 );
      }
    }
    v1 = (_DWORD *)*v1;
  }
  while ( v1 != (_DWORD *)dword_10028380 );
  v7 = &off_10026360;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_10026360 )
    {
      v15 = sub_1001C170();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        dword_10028380 = (int)v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return (int)(v16 + 256);
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (int)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( FIX_DLL_KERNEL32_dll_VirtualAlloc(i, v20 << 12, 4096, 4) != i )
    return 0;
  v11 = (void **)v8;
  if ( v20 > 0 )
  {
    v12 = i + 4;
    do
    {
      *(_BYTE *)(v12 + 244) = -1;
      *(_DWORD *)(v12 - 4) = v12 + 4;
      *(_DWORD *)v12 = 240;
      *v11 = (void *)240;
      v11[1] = (void *)241;
      v12 += 4096;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  dword_10028380 = (int)v7;
  v13 = v7 + 2054;
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == (void *)-1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = (void *)(v14 ? (unsigned int)v11 : 0);
  *(_BYTE *)(i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  *(_DWORD *)(i + 4) -= a1;
  result = i + 256;
  *(_DWORD *)i = i + a1 + 8;
  return result;
}
// 100210EC: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_VirtualAlloc)(_DWORD, _DWORD, _DWORD, _DWORD);
// 10026360: using guessed type void *off_10026360;
// 10028380: using guessed type int dword_10028380;

//----- (1001C670) --------------------------------------------------------
int __cdecl sub_1001C670(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+0h] [ebp-4h]
  unsigned int v17; // [esp+Ch] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (1001C794) --------------------------------------------------------
int __cdecl sub_1001C794(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  _BOOL1 v8; // zf
  int v9; // eax
  int v11; // [esp+0h] [ebp-4h]

  v4 = (unsigned __int8)*a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * (((int)a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( a2 + 62 >= (_DWORD *)&a3[a4] )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2 )
        {
          if ( v6 >= (_BYTE *)a2 + 248 )
          {
            a2[1] = 0;
            *a2 = a2 + 2;
          }
          else
          {
            v9 = 0;
            *a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            a2[1] = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (1001C9B1) --------------------------------------------------------
bool __cdecl sub_1001C9B1(int a1)
{
  return dword_101C827C && dword_101C827C(a1);
}
// 101C827C: using guessed type int (__cdecl *dword_101C827C)(_DWORD);

//----- (1001CD05) --------------------------------------------------------
int __cdecl _commit_0(int a1)
{
  int v1; // eax
  int result; // eax

  if ( (unsigned int)a1 >= dword_101C86E0 || (*(_BYTE *)(dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 1) == 0 )
    goto LABEL_8;
  v1 = _get_osfhandle_0(a1);
  if ( FIX_DLL_KERNEL32_dll_FlushFileBuffers(v1) )
    result = 0;
  else
    result = FIX_DLL_KERNEL32_dll_GetLastError();
  if ( result )
  {
    dword_101C8078 = result;
LABEL_8:
    dword_101C8074 = 9;
    result = -1;
  }
  return result;
}
// 10021024: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_FlushFileBuffers)(_DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001CD5C) --------------------------------------------------------
int __cdecl _freebuf_0(_iobuf *stream)
{
  int result; // eax

  result = stream->_flag;
  if ( (result & 0x83) != 0 && (result & 8) != 0 )
  {
    sub_100189EC((unsigned int)stream->_base);
    LOWORD(stream->_flag) &= 0xFBF7u;
    result = 0;
    stream->_ptr = 0;
    stream->_base = 0;
    stream->_cnt = 0;
  }
  return result;
}

//----- (1001D03B) --------------------------------------------------------
unsigned int __cdecl _control87_0(unsigned int a1, unsigned int a2)
{
  int v2; // eax
  unsigned int v3; // esi
  char v5; // [esp+0h] [ebp-4h]

  LOBYTE(v2) = _abstract_cw_0(v5);
  v3 = a2 & a1 | ~a2 & v2;
  _hw_cw_0(v3);
  return v3;
}
// 1001D047: variable 'v5' is possibly undefined
// 1001D053: variable 'v2' is possibly undefined

//----- (1001D070) --------------------------------------------------------
unsigned int __cdecl sub_1001D070(unsigned int a1, int a2)
{
  return _control87_0(a1, a2 & 0xFFF7FFFF);
}

//----- (1001D0B0) --------------------------------------------------------
char __cdecl _abstract_cw_0(char a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    result |= 1u;
  return result;
}

//----- (1001D142) --------------------------------------------------------
char __cdecl _hw_cw_0(int a1)
{
  char result; // al

  result = (a1 & 0x10) != 0;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 2) != 0 )
    result |= 0x10u;
  if ( (a1 & 1) != 0 )
    result |= 0x20u;
  if ( (a1 & 0x80000) != 0 )
    result |= 2u;
  return result;
}

//----- (1001D200) --------------------------------------------------------
int __cdecl _ZeroTail_0(int a1, int a2)
{
  int v2; // esi
  _DWORD *i; // eax

  if ( (~(-1 << (31 - a2 % 32)) & *(_DWORD *)(a1 + 4 * (a2 / 32))) == 0 )
  {
    v2 = a2 / 32 + 1;
    if ( v2 >= 3 )
      return 1;
    for ( i = (_DWORD *)(a1 + 4 * v2); !*i; ++i )
    {
      if ( ++v2 >= 3 )
        return 1;
    }
  }
  return 0;
}

//----- (1001D249) --------------------------------------------------------
int __cdecl _IncMan_0(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  unsigned int *v4; // edi

  result = __addl_0(*(_DWORD *)(a1 + 4 * (a2 / 32)), 1 << (31 - a2 % 32), (unsigned int *)(a1 + 4 * (a2 / 32)));
  v3 = a2 / 32 - 1;
  if ( v3 >= 0 )
  {
    v4 = (unsigned int *)(a1 + 4 * v3);
    do
    {
      if ( !result )
        break;
      result = __addl_0(*v4, 1u, v4);
      --v3;
      --v4;
    }
    while ( v3 >= 0 );
  }
  return result;
}

//----- (1001D29F) --------------------------------------------------------
int __cdecl _RoundMan_0(int a1, int a2)
{
  int v2; // edi
  int v4; // edx
  _DWORD *v5; // eax
  char v6; // si
  int v8; // [esp+0h] [ebp-8h]
  int v9; // [esp+4h] [ebp-4h]
  _DWORD *v10; // [esp+14h] [ebp+Ch]

  v2 = a2 - 1;
  v9 = 0;
  v4 = a2 % 32;
  v8 = a2 / 32;
  v5 = (_DWORD *)(a1 + 4 * (a2 / 32));
  v10 = v5;
  v6 = 31 - v4;
  if ( ((1 << (31 - v4)) & *v5) != 0 )
  {
    if ( !_ZeroTail_0(a1, a2 + 1) )
      v9 = _IncMan_0(a1, v2);
    v5 = v10;
  }
  *v5 &= -1 << v6;
  if ( v8 + 1 < 3 )
    memset((void *)(a1 + 4 * (v8 + 1)), 0, 4 * (3 - (v8 + 1)));
  return v9;
}

//----- (1001D888) --------------------------------------------------------
void sub_1001D888()
{
  _amsg_exit_0(2);
}

//----- (1001D891) --------------------------------------------------------
void sub_1001D891()
{
  if ( !dword_101C8370 )
  {
    _tzset_0();
    ++dword_101C8370;
  }
}
// 101C8370: using guessed type int dword_101C8370;

//----- (1001D8A6) --------------------------------------------------------
void __cdecl _tzset_0()
{
  int v0; // edi
  char *v1; // eax
  const char *v2; // esi
  int (__stdcall *v3)(_DWORD, int, void *, int, char *, int, _DWORD, int *); // esi
  size_t v4; // eax
  char *v5; // eax
  const char *v6; // esi
  int v7; // ecx
  char v8; // al
  int v9; // eax
  int v10; // [esp+10h] [ebp-4h] BYREF

  v0 = 0;
  dword_101C82B8 = 0;
  dword_100284F8 = -1;
  dword_100284E8 = -1;
  v1 = getenv_0("TZ");
  v2 = v1;
  if ( !v1 )
  {
    if ( FIX_DLL_KERNEL32_dll_GetTimeZoneInformation(&dword_101C82C0) == -1 )
      return;
    dword_10028450 = 60 * dword_101C82C0;
    dword_101C82B8 = 1;
    if ( word_101C8306 )
      dword_10028450 = 60 * dword_101C8314 + 60 * dword_101C82C0;
    if ( word_101C835A && dword_101C8368 )
    {
      dword_10028454 = 1;
      dword_10028458 = 60 * (dword_101C8368 - dword_101C8314);
    }
    else
    {
      dword_10028454 = 0;
      dword_10028458 = 0;
    }
    v3 = (int (__stdcall *)(_DWORD, int, void *, int, char *, int, _DWORD, int *))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
    if ( !FIX_DLL_KERNEL32_dll_WideCharToMultiByte(dword_101C8124, 544, &unk_101C82C4, -1, off_100284DC, 63, 0, &v10)
      || v10 )
    {
      *off_100284DC = 0;
    }
    else
    {
      off_100284DC[63] = 0;
    }
    if ( v3(dword_101C8124, 544, &unk_101C8318, -1, off_100284E0, 63, 0, &v10) && !v10 )
    {
      off_100284E0[63] = 0;
      return;
    }
LABEL_41:
    *off_100284E0 = 0;
    return;
  }
  if ( *v1 && (!dword_101C836C || strcmp(v1, dword_101C836C)) )
  {
    sub_100189EC((unsigned int)dword_101C836C);
    v4 = strlen(v2);
    v5 = (char *)sub_10019098(v4 + 1);
    dword_101C836C = v5;
    if ( v5 )
    {
      strcpy(v5, v2);
      strncpy_0(off_100284DC, v2, 3u);
      v6 = v2 + 3;
      off_100284DC[3] = 0;
      if ( *v6 == 45 )
      {
        ++v6;
        v0 = 1;
      }
      v7 = 3600 * atol_0(v6);
      dword_10028450 = v7;
      while ( 1 )
      {
        v8 = *v6;
        if ( *v6 != 43 && (v8 < 48 || v8 > 57) )
          break;
        ++v6;
      }
      if ( *v6 == 58 )
      {
        v7 = 60 * atol_0(++v6) + dword_10028450;
        dword_10028450 = v7;
        while ( *v6 >= 48 && *v6 <= 57 )
          ++v6;
        if ( *v6 == 58 )
        {
          v7 = atol_0(++v6) + dword_10028450;
          dword_10028450 = v7;
          while ( *v6 >= 48 && *v6 <= 57 )
            ++v6;
        }
      }
      if ( v0 )
        dword_10028450 = -v7;
      v9 = *v6;
      dword_10028454 = v9;
      if ( v9 )
      {
        strncpy_0(off_100284E0, v6, 3u);
        off_100284E0[3] = 0;
        return;
      }
      goto LABEL_41;
    }
  }
}
// 10021158: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_GetTimeZoneInformation)(_DWORD);
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10028450: using guessed type int dword_10028450;
// 10028454: using guessed type int dword_10028454;
// 10028458: using guessed type int dword_10028458;
// 100284E8: using guessed type int dword_100284E8;
// 100284F8: using guessed type int dword_100284F8;
// 101C82B8: using guessed type int dword_101C82B8;
// 101C82C0: using guessed type int dword_101C82C0;
// 101C8306: using guessed type __int16 word_101C8306;
// 101C8314: using guessed type int dword_101C8314;
// 101C835A: using guessed type __int16 word_101C835A;
// 101C8368: using guessed type int dword_101C8368;

//----- (1001DCB0) --------------------------------------------------------
int __cdecl cvtdate_0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int result; // eax
  int v19; // eax
  _BOOL1 v20; // sf
  int v21; // ecx
  int v22; // [esp+18h] [ebp+10h]

  if ( a2 == 1 )
  {
    v22 = a3 & 3;
    if ( (a3 & 3) != 0 )
      v12 = dword_10028534[a4];
    else
      v12 = dword_10028500[a4];
    v13 = v12 + 1;
    v14 = (365 * a3 + ((a3 - 1) >> 2) + v12 + 1 - 25563) % 7;
    if ( v14 > a6 )
      v15 = a6 + 7 * a5 - v14 + v13;
    else
      v15 = v13 + a6 + 7 * a5 - v14 - 7;
    if ( a5 == 5 )
    {
      if ( v22 )
        v16 = dword_10028538[a4];
      else
        v16 = dword_10028504[a4];
      if ( v15 > v16 )
        v15 -= 7;
    }
  }
  else
  {
    if ( (a3 & 3) != 0 )
      v17 = dword_10028534[a4];
    else
      v17 = dword_10028500[a4];
    v15 = a7 + v17;
  }
  if ( a1 == 1 )
  {
    dword_100284EC = v15;
    dword_100284E8 = a3;
    result = a11 + 1000 * (a10 + 60 * (a9 + 60 * a8));
    dword_100284F0 = result;
    return result;
  }
  dword_100284FC = v15;
  v19 = 1000 * (a10 + dword_10028458 + 60 * (a9 + 60 * a8));
  v20 = a11 + v19 < 0;
  result = a11 + v19;
  dword_10028500[0] = result;
  if ( v20 )
  {
    result += 86400000;
    v21 = v15 - 1;
    dword_10028500[0] = result;
LABEL_24:
    dword_100284FC = v21;
    goto LABEL_25;
  }
  if ( result >= 86400000 )
  {
    result -= 86400000;
    v21 = v15 + 1;
    dword_10028500[0] = result;
    goto LABEL_24;
  }
LABEL_25:
  dword_100284F8 = a3;
  return result;
}
// 10028458: using guessed type int dword_10028458;
// 100284E8: using guessed type int dword_100284E8;
// 100284EC: using guessed type int dword_100284EC;
// 100284F0: using guessed type int dword_100284F0;
// 100284F8: using guessed type int dword_100284F8;
// 100284FC: using guessed type int dword_100284FC;
// 10028500: using guessed type int dword_10028500[];
// 10028534: using guessed type int dword_10028534[];

//----- (1001E030) --------------------------------------------------------
char *__cdecl strstr_0(const char *a1, const char *a2)
{
  char v2; // dl
  const char *v3; // edi
  char v4; // dh
  const char *v5; // ecx
  char *v6; // esi
  char v7; // al
  char v9; // ah
  char v10; // al
  char v11; // al

  v2 = *a2;
  v3 = a1;
  if ( !*a2 )
    return (char *)a1;
  v4 = a2[1];
  if ( !v4 )
    JUMPOUT(0x100162D6);
LABEL_3:
  v5 = a2;
  v6 = (char *)(v3 + 1);
  if ( *v3 == v2 )
    goto LABEL_9;
  if ( *v3 )
  {
    while ( 2 )
    {
      v7 = *v6++;
      while ( v7 == v2 )
      {
LABEL_9:
        v7 = *v6++;
        if ( v7 == v4 )
        {
          v3 = v6 - 1;
          while ( 1 )
          {
            v9 = v5[2];
            if ( !v9 )
              break;
            v10 = *v6;
            v6 += 2;
            if ( v10 != v9 )
              goto LABEL_3;
            v11 = v5[3];
            if ( !v11 )
              break;
            v5 += 2;
            if ( v11 != *(v6 - 1) )
              goto LABEL_3;
          }
          return (char *)(v3 - 1);
        }
      }
      if ( v7 )
        continue;
      break;
    }
  }
  return 0;
}
// 1001E09E: control flows out of bounds to 100162D6

//----- (1001E0E8) --------------------------------------------------------
int __cdecl _setmbcp_0(int a1)
{
  int v1; // eax
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  _BOOL1 v5; // cc
  int *v6; // ecx
  unsigned __int8 v7; // dl
  unsigned int j; // eax
  int v9; // esi
  int *v10; // ebx
  int *i; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // eax
  unsigned int v14; // edi
  char v15; // dl
  int v16; // eax
  int *v17; // esi
  unsigned int k; // eax
  unsigned int v20; // [esp+0h] [ebp-18h] BYREF
  char v21; // [esp+6h] [ebp-12h]
  int v22; // [esp+7h] [ebp-11h] BYREF
  unsigned int v23; // [esp+14h] [ebp-4h]
  int v24; // [esp+20h] [ebp+8h]

  v1 = getSystemCP_0(a1);
  v2 = v1;
  v24 = v1;
  if ( v1 == dword_101C837C )
    return 0;
  if ( !v1 )
  {
LABEL_30:
    setSBCS_0();
LABEL_31:
    setSBUpLow();
    return 0;
  }
  v3 = 0;
  v4 = &unk_10028578;
  do
  {
    if ( *v4 == v2 )
    {
      memset(&unk_101C84A0, 0, 0x100u);
      v23 = 0;
      v9 = 12 * v3;
      *((_BYTE *)&unk_101C84A0 + 256) = 0;
      v10 = &dword_10028588[12 * v3];
      do
      {
        for ( i = v10; *(_BYTE *)i; i = (int *)((char *)i + 2) )
        {
          v12 = *((_BYTE *)i + 1);
          if ( !v12 )
            break;
          v13 = *(unsigned __int8 *)i;
          v14 = v12;
          if ( v13 <= v12 )
          {
            v15 = byte_10028570[v23];
            do
              byte_101C84A1[v13++] |= v15;
            while ( v13 <= v14 );
          }
        }
        ++v23;
        v10 += 2;
      }
      while ( v23 < 4 );
      dword_101C838C = 1;
      dword_101C837C = v24;
      v16 = CPtoLCID_0(v24);
      v17 = &dword_1002857C[v9];
      dword_101C8380[0] = *v17++;
      dword_101C8380[1] = *v17;
      dword_101C85A4 = v16;
      dword_101C8380[2] = v17[1];
      goto LABEL_31;
    }
    v4 += 12;
    ++v3;
  }
  while ( (int)v4 < (int)&unk_10028668 );
  if ( FIX_DLL_KERNEL32_dll_GetCPInfo(v2, &v20) == 1 )
  {
    v5 = v20 <= 1;
    dword_101C837C = v2;
    memset(&unk_101C84A0, 0, 0x100u);
    *((_BYTE *)&unk_101C84A0 + 256) = 0;
    dword_101C85A4 = 0;
    if ( v5 )
    {
      dword_101C838C = 0;
    }
    else
    {
      if ( v21 )
      {
        v6 = &v22;
        do
        {
          v7 = *(_BYTE *)v6;
          if ( !*(_BYTE *)v6 )
            break;
          for ( j = *((unsigned __int8 *)v6 - 1); j <= v7; ++j )
            byte_101C84A1[j] |= 4u;
          v6 = (int *)((char *)v6 + 2);
        }
        while ( *((_BYTE *)v6 - 1) );
      }
      for ( k = 1; k < 0xFF; ++k )
        byte_101C84A1[k] |= 8u;
      dword_101C85A4 = CPtoLCID_0(v2);
      dword_101C838C = 1;
    }
    dword_101C8380[0] = 0;
    dword_101C8380[1] = 0;
    dword_101C8380[2] = 0;
    goto LABEL_31;
  }
  if ( dword_101C8374 )
    goto LABEL_30;
  return -1;
}
// 1001E327: using guessed type int setSBUpLow(void);
// 100210E4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD);
// 1002857C: using guessed type int dword_1002857C[];
// 10028588: using guessed type int dword_10028588[];
// 101C8374: using guessed type int dword_101C8374;
// 101C838C: using guessed type int dword_101C838C;
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001E281) --------------------------------------------------------
int __cdecl getSystemCP_0(int a1)
{
  int result; // eax

  result = a1;
  dword_101C8374 = 0;
  switch ( a1 )
  {
    case -2:
      dword_101C8374 = 1;
      result = FIX_DLL_KERNEL32_dll_GetOEMCP();
      break;
    case -3:
      dword_101C8374 = 1;
      result = FIX_DLL_KERNEL32_dll_GetACP();
      break;
    case -4:
      result = dword_101C8124;
      dword_101C8374 = 1;
      break;
  }
  return result;
}
// 100210DC: using guessed type int (*FIX_DLL_KERNEL32_dll_GetOEMCP)(void);
// 100210E0: using guessed type int (*FIX_DLL_KERNEL32_dll_GetACP)(void);
// 101C8374: using guessed type int dword_101C8374;

//----- (1001E2CB) --------------------------------------------------------
int __cdecl CPtoLCID_0(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}

//----- (1001E2FE) --------------------------------------------------------
int setSBCS_0()
{
  int result; // eax

  memset(&unk_101C84A0, 0, 0x100u);
  *((_BYTE *)&unk_101C84A0 + 256) = 0;
  result = 0;
  dword_101C837C = 0;
  dword_101C838C = 0;
  dword_101C85A4 = 0;
  dword_101C8380[0] = 0;
  dword_101C8380[1] = 0;
  dword_101C8380[2] = 0;
  return result;
}
// 101C837C: using guessed type int dword_101C837C;
// 101C838C: using guessed type int dword_101C838C;
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001E4BC) --------------------------------------------------------
int sub_1001E4BC()
{
  int result; // eax

  if ( !dword_101C9710 )
  {
    result = _setmbcp_0(-3);
    dword_101C9710 = 1;
  }
  return result;
}
// 101C9710: using guessed type int dword_101C9710;

//----- (1001E4D8) --------------------------------------------------------
_DWORD *__cdecl _dosmaperr_0(unsigned int a1)
{
  int v1; // edx
  _DWORD *result; // eax

  v1 = 0;
  dword_101C8078 = a1;
  result = &unk_10028668;
  do
  {
    if ( a1 == *result )
    {
      result = (_DWORD *)dword_1002866C[2 * v1];
      dword_101C8074 = (int)result;
      return result;
    }
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_100287D0 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || (dword_101C8074 = 8, a1 > 0xCA) )
      dword_101C8074 = 22;
  }
  else
  {
    dword_101C8074 = 13;
  }
  return result;
}
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;

//----- (1001E53F) --------------------------------------------------------
int _alloc_osfhnd_0()
{
  int v0; // ebx
  int v1; // edi
  int v2; // esi
  int *v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edx
  _DWORD *v6; // eax
  unsigned int v7; // edx

  v0 = -1;
  v1 = 0;
  v2 = 0;
  v3 = dword_101C85E0;
  while ( 1 )
  {
    v4 = *v3;
    if ( !*v3 )
      break;
    v5 = v4 + 256;
    while ( v4 < v5 )
    {
      if ( (*(_BYTE *)(v4 + 4) & 1) == 0 )
      {
        *(_DWORD *)v4 = -1;
        v0 = v2 + ((int)(v4 - *v3) >> 3);
        if ( v0 != -1 )
          return v0;
        break;
      }
      v4 += 8;
    }
    ++v3;
    ++v1;
    v2 += 32;
    if ( (int)v3 >= (int)&dword_101C86E0 )
      return v0;
  }
  v6 = sub_10019098(0x100u);
  if ( v6 )
  {
    dword_101C86E0 += 32;
    v7 = (unsigned int)(v6 + 64);
    dword_101C85E0[v1] = (int)v6;
    while ( (unsigned int)v6 < v7 )
    {
      *((_BYTE *)v6 + 4) = 0;
      *v6 = -1;
      *((_BYTE *)v6 + 5) = 10;
      v6 += 2;
      v7 = dword_101C85E0[v1] + 256;
    }
    v0 = 32 * v1;
  }
  return v0;
}
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001E5D4) --------------------------------------------------------
int __usercall _set_osfhnd_0@<eax>(int a1@<ebx>, int a2, HANDLE hHandle)
{
  int v4; // [esp-Ch] [ebp-14h]
  HANDLE v5; // [esp-8h] [ebp-10h]

  if ( a2 < (unsigned int)dword_101C86E0 && *(_DWORD *)(dword_101C85E0[a2 >> 5] + 8 * (a2 & 0x1F)) == -1 )
  {
    if ( dword_101C80F0 == 1 )
    {
      switch ( a2 )
      {
        case 0:
          v5 = hHandle;
          v4 = -10;
          goto LABEL_10;
        case 1:
          v5 = hHandle;
          v4 = -11;
          goto LABEL_10;
        case 2:
          v5 = hHandle;
          v4 = -12;
LABEL_10:
          FIX_DLL_KERNEL32_dll_SetStdHandle(v4, v5, a1);
          break;
      }
    }
    *(_DWORD *)(dword_101C85E0[a2 >> 5] + 8 * (a2 & 0x1F)) = hHandle;
    return 0;
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 1001E5D4: could not find valid save-restore pair for ebx
// 100210D8: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001E64B) --------------------------------------------------------
int __cdecl _free_osfhnd_0(int a1)
{
  int v1; // eax
  int v3; // [esp-8h] [ebp-10h]

  if ( a1 < (unsigned int)dword_101C86E0 )
  {
    v1 = 8 * (a1 & 0x1F) + dword_101C85E0[a1 >> 5];
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 && *(_DWORD *)v1 != -1 )
    {
      if ( dword_101C80F0 == 1 )
      {
        switch ( a1 )
        {
          case 0:
            v3 = -10;
            goto LABEL_11;
          case 1:
            v3 = -11;
            goto LABEL_11;
          case 2:
            v3 = -12;
LABEL_11:
            ((void (__cdecl *)(int, _DWORD))FIX_DLL_KERNEL32_dll_SetStdHandle)(v3, 0);
            break;
        }
      }
      *(_DWORD *)(dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F)) = -1;
      return 0;
    }
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 100210D8: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetStdHandle)(_DWORD, _DWORD, _DWORD);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C80F0: using guessed type int dword_101C80F0;
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001E6C5) --------------------------------------------------------
int __cdecl _get_osfhandle_0(int a1)
{
  int v1; // eax

  if ( a1 < (unsigned int)dword_101C86E0 )
  {
    v1 = dword_101C85E0[a1 >> 5] + 8 * (a1 & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  dword_101C8078 = 0;
  dword_101C8074 = 9;
  return -1;
}
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];
// 101C86E0: using guessed type int dword_101C86E0;

//----- (1001E79F) --------------------------------------------------------
int __cdecl fclose_0(FILE *a1)
{
  int v1; // edi
  int v2; // eax
  int result; // eax

  v1 = -1;
  v2 = a1->_flag;
  if ( (v2 & 0x40) != 0 )
  {
    result = -1;
  }
  else
  {
    if ( (v2 & 0x83) != 0 )
    {
      v1 = _flush_0(a1);
      _freebuf_0(a1);
      if ( _close_0(a1->_file) >= 0 )
      {
        if ( a1->_tmpfname )
        {
          sub_100189EC((unsigned int)a1->_tmpfname);
          a1->_tmpfname = 0;
        }
      }
      else
      {
        v1 = -1;
      }
    }
    result = v1;
  }
  a1->_flag = 0;
  return result;
}

//----- (1001E7F5) --------------------------------------------------------
int __cdecl __addl_0(unsigned int a1, unsigned int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = 0;
  v4 = a1 + a2;
  if ( a1 + a2 < a1 || v4 < a2 )
    result = 1;
  *a3 = v4;
  return result;
}

//----- (1001E816) --------------------------------------------------------
int __cdecl __add_12_0(unsigned int *a1, unsigned int *a2)
{
  if ( __addl_0(*a1, *a2, a1) && __addl_0(a1[1], 1u, a1 + 1) )
    ++a1[2];
  if ( __addl_0(a1[1], a2[1], a1 + 1) )
    ++a1[2];
  return __addl_0(a1[2], a2[2], a1 + 2);
}

//----- (1001E874) --------------------------------------------------------
_DWORD *__cdecl __shl_12_0(_DWORD *a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edi
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = a1;
  v2 = a1[1];
  v3 = *a1;
  *a1 *= 2;
  v4 = (v3 >> 31) | (2 * v2);
  v5 = a1[2];
  a1[1] = v4;
  a1[2] = (v2 >> 31) | (2 * v5);
  return result;
}

//----- (1001E8A2) --------------------------------------------------------
int *__cdecl __shr_12_0(int *a1)
{
  int *result; // eax
  unsigned int v2; // edx
  int v3; // edi
  int v4; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[1];
  a1[1] = *(__int64 *)(a1 + 1) >> 1;
  v4 = (v3 << 31) | ((unsigned int)*a1 >> 1);
  a1[2] = v2 >> 1;
  *a1 = v4;
  return result;
}

//----- (1001E8CF) --------------------------------------------------------
__int16 __cdecl __mtold12_0(char *a1, int a2, int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // eax
  __int16 result; // ax
  unsigned int v8; // [esp+0h] [ebp-10h] BYREF
  int v9; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]
  int v12; // [esp+20h] [ebp+10h]

  v11 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = *(_DWORD *)(a3 + 8);
      __shl_12_0((_DWORD *)a3);
      __shl_12_0((_DWORD *)a3);
      __add_12_0((unsigned int *)a3, &v8);
      __shl_12_0((_DWORD *)a3);
      v9 = 0;
      v10 = 0;
      v8 = *a1;
      __add_12_0((unsigned int *)a3, &v8);
      ++a1;
      --v12;
    }
    while ( v12 );
  }
  while ( !*(_DWORD *)(a3 + 8) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 8) = HIWORD(v4);
    v5 = (v4 << 16) | HIWORD(*(_DWORD *)a3);
    v6 = *(_DWORD *)a3 << 16;
    v11 += 65520;
    *(_DWORD *)(a3 + 4) = v5;
    *(_DWORD *)a3 = v6;
  }
  while ( (*(_DWORD *)(a3 + 8) & 0x8000) == 0 )
  {
    __shl_12_0((_DWORD *)a3);
    v11 += 0xFFFF;
  }
  result = v11;
  *(_WORD *)(a3 + 10) = v11;
  return result;
}

//----- (1001E996) --------------------------------------------------------
int __cdecl __strgtold12_0(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7)
{
  char *v7; // edi
  int v8; // eax
  char v9; // cl
  char v10; // bl
  int *v12; // eax
  int *v14; // eax
  int v15; // eax
  char *v16; // ecx
  int v17; // esi
  int v18; // eax
  _BOOL1 v20; // zf
  int v21; // eax
  int v22; // eax
  int v23; // eax
  char *v24; // ebx
  unsigned int v25; // esi
  __int16 v26; // ax
  __int16 v27; // dx
  __int16 v28; // ax
  int result; // eax
  int v30; // [esp-10h] [ebp-6Ch]
  int v31; // [esp-10h] [ebp-6Ch]
  int v32[3]; // [esp+0h] [ebp-5Ch] BYREF
  char v33; // [esp+17h] [ebp-45h]
  _WORD v34[3]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v35; // [esp+22h] [ebp-3Ah]
  int v36; // [esp+26h] [ebp-36h]
  int v37; // [esp+2Ch] [ebp-30h]
  int v38; // [esp+30h] [ebp-2Ch]
  int v39; // [esp+34h] [ebp-28h]
  int v40; // [esp+38h] [ebp-24h]
  int v41; // [esp+3Ch] [ebp-20h]
  int v42; // [esp+40h] [ebp-1Ch]
  int v43; // [esp+44h] [ebp-18h]
  int v44; // [esp+48h] [ebp-14h]
  int v45; // [esp+4Ch] [ebp-10h]
  int *v46; // [esp+50h] [ebp-Ch]
  int v47; // [esp+54h] [ebp-8h]
  unsigned int v48; // [esp+58h] [ebp-4h]

  v7 = a3;
  v46 = v32;
  v8 = 0;
  v39 = 0;
  v43 = 1;
  v48 = 0;
  v45 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v37 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  while ( 1 )
  {
    v9 = *v7;
    if ( *v7 != 32 && v9 != 9 && v9 != 10 && v9 != 13 )
      break;
    ++v7;
  }
  while ( 2 )
  {
    v10 = *v7++;
    switch ( v8 )
    {
      case 0:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_10026008 )
          goto LABEL_12;
        if ( v10 == 43 )
        {
          v39 = 0;
          v8 = 2;
          continue;
        }
        if ( v10 == 45 )
        {
          v39 = 0x8000;
          v8 = 2;
          continue;
        }
        if ( v10 != 48 )
          goto LABEL_108;
        goto LABEL_35;
      case 1:
        v45 = 1;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == byte_10026008 )
          goto LABEL_46;
        if ( v10 == 43 || v10 == 45 )
          goto LABEL_30;
        if ( v10 != 48 )
          goto LABEL_25;
        goto LABEL_35;
      case 2:
        if ( v10 >= 49 && v10 <= 57 )
        {
LABEL_10:
          v30 = 3;
LABEL_80:
          v8 = v30;
LABEL_81:
          --v7;
        }
        else
        {
          if ( v10 == byte_10026008 )
          {
LABEL_12:
            v31 = 5;
            goto LABEL_89;
          }
          if ( v10 != 48 )
          {
LABEL_93:
            v7 = a3;
            goto LABEL_110;
          }
LABEL_35:
          v8 = 1;
        }
        continue;
      case 3:
        v45 = 1;
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 >= 0x19 )
          {
            ++v47;
          }
          else
          {
            v12 = v46;
            ++v48;
            v46 = (int *)((char *)v46 + 1);
            *(_BYTE *)v12 = v10 - 48;
          }
          v10 = *v7++;
        }
        if ( v10 != byte_10026008 )
          goto LABEL_57;
LABEL_46:
        v8 = 4;
        continue;
      case 4:
        v45 = 1;
        v40 = 1;
        if ( !v48 )
        {
          while ( v10 == 48 )
          {
            --v47;
            v10 = *v7++;
          }
        }
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
        {
          if ( v48 < 0x19 )
          {
            v14 = v46;
            ++v48;
            v46 = (int *)((char *)v46 + 1);
            --v47;
            *(_BYTE *)v14 = v10 - 48;
          }
          v10 = *v7++;
        }
LABEL_57:
        if ( v10 == 43 || v10 == 45 )
        {
LABEL_30:
          --v7;
          v31 = 11;
        }
        else
        {
LABEL_25:
          if ( v10 <= 67 || v10 > 69 && (v10 <= 99 || v10 > 101) )
          {
LABEL_108:
            --v7;
            goto LABEL_110;
          }
          v31 = 6;
        }
        goto LABEL_89;
      case 5:
        v40 = 1;
        if ( (int)dword_10026004 <= 1 )
          v15 = *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4;
        else
          v15 = _isctype_0((unsigned __int8)v10, 4);
        if ( !v15 )
          goto LABEL_93;
        v8 = 4;
        goto LABEL_81;
      case 6:
        v16 = v7 - 2;
        a3 = v7 - 2;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 43 )
          goto LABEL_88;
        if ( v10 == 45 )
          goto LABEL_87;
        if ( v10 != 48 )
          goto LABEL_109;
LABEL_70:
        v31 = 8;
        goto LABEL_89;
      case 7:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 48 )
          goto LABEL_70;
        goto LABEL_93;
      case 8:
        v41 = 1;
        while ( v10 == 48 )
          v10 = *v7++;
        if ( v10 < 49 || v10 > 57 )
          goto LABEL_108;
LABEL_79:
        v30 = 9;
        goto LABEL_80;
      case 9:
        v41 = 1;
        v17 = 0;
        while ( 2 )
        {
          if ( (int)dword_10026004 <= 1 )
            v18 = *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4;
          else
            v18 = _isctype_0((unsigned __int8)v10, 4);
          if ( v18 )
          {
            v17 = v10 + 10 * v17 - 48;
            if ( v17 <= 5200 )
            {
              v10 = *v7++;
              continue;
            }
            v17 = 5201;
          }
          break;
        }
        v42 = v17;
        while ( (int)dword_10026004 <= 1 ? *(_BYTE *)(dword_10025DF8 + 2 * (unsigned __int8)v10) & 4 : _isctype_0((unsigned __int8)v10, 4) )
          v10 = *v7++;
        goto LABEL_108;
      case 11:
        if ( !a7 )
        {
          --v7;
          v8 = 10;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_110;
          continue;
        }
        v16 = v7 - 1;
        a3 = v7 - 1;
        if ( v10 == 43 )
        {
LABEL_88:
          v31 = 7;
LABEL_89:
          v8 = v31;
          continue;
        }
        if ( v10 == 45 )
        {
LABEL_87:
          v43 = -1;
          v8 = 7;
          continue;
        }
LABEL_109:
        v7 = v16;
LABEL_110:
        v20 = v45 == 0;
        *a2 = v7;
        if ( v20 )
        {
          v27 = 0;
          v26 = 0;
          v25 = 0;
          v24 = 0;
          v44 = 4;
        }
        else
        {
          if ( v48 <= 0x18 )
          {
            v21 = (int)v46;
          }
          else
          {
            if ( v33 >= 5 )
              ++v33;
            v48 = 24;
            v21 = (int)v46 - 1;
            ++v47;
          }
          if ( v48 )
          {
            while ( !*(_BYTE *)--v21 )
            {
              --v48;
              ++v47;
            }
            __mtold12_0((char *)v32, v48, (int)v34);
            v22 = v42;
            if ( v43 < 0 )
              v22 = -v42;
            v23 = v47 + v22;
            if ( !v41 )
              v23 += a5;
            if ( !v40 )
              v23 -= a6;
            if ( v23 > 5200 )
            {
              v38 = 1;
              goto LABEL_127;
            }
            if ( v23 >= -5200 )
            {
              __multtenpow12_0(v34, v23, a4);
              v27 = v34[0];
              v24 = *(char **)&v34[1];
              v25 = v35;
              v26 = v36;
            }
            else
            {
              v37 = 1;
LABEL_127:
              v24 = a3;
              v25 = (unsigned int)a3;
              v26 = (__int16)a3;
              v27 = (__int16)a3;
            }
          }
          else
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
          }
          if ( v38 )
          {
            v24 = 0;
            v26 = 0x7FFF;
            v25 = 0x80000000;
            v27 = 0;
            v44 = 2;
          }
          else if ( v37 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
            v44 = 1;
          }
        }
        v28 = v39 | v26;
        *(_DWORD *)(a1 + 6) = v25;
        *(_DWORD *)(a1 + 2) = v24;
        *(_WORD *)(a1 + 10) = v28;
        result = v44;
        *(_WORD *)a1 = v27;
        return result;
      default:
        goto LABEL_91;
    }
  }
}
// 10025DF8: using guessed type int dword_10025DF8;
// 10026008: using guessed type char byte_10026008;

//----- (1001EEA3) --------------------------------------------------------
int __cdecl _I10_OUTPUT_0(__int128 a1, char a2, int a3)
{
  int v3; // ebx
  __int16 v4; // cx
  unsigned __int16 v5; // dx
  int v6; // edi
  int v7; // esi
  _BOOL1 v8; // zf
  int v9; // edi
  int v10; // esi
  int v11; // esi
  int v12; // eax
  char v13; // al
  _BYTE *v14; // ecx
  char v15; // cl
  _BYTE *v16; // eax
  _BOOL1 v17; // cc
  _BYTE *v18; // ecx
  char v19; // al
  const char *v21; // [esp-10h] [ebp-2Ch]
  const char *v22; // [esp-10h] [ebp-2Ch]
  char v23[12]; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v24[3]; // [esp+Ch] [ebp-10h] BYREF
  int v25; // [esp+18h] [ebp-4h]

  v3 = a3;
  v4 = WORD4(a1) & 0x8000;
  v23[0] = -52;
  v23[1] = -52;
  v23[2] = -52;
  v23[3] = -52;
  v23[4] = -52;
  v23[5] = -52;
  v23[6] = -52;
  v23[7] = -52;
  v23[8] = -52;
  v23[9] = -52;
  v23[10] = -5;
  v23[11] = 63;
  v25 = 1;
  v5 = WORD4(a1) & 0x7FFF;
  if ( (SWORD4(a1) & 0x8000u) == 0 )
    *(_BYTE *)(a3 + 2) = 32;
  else
    *(_BYTE *)(a3 + 2) = 45;
  v6 = DWORD1(a1);
  if ( !v5 && !(_QWORD)a1 )
    goto LABEL_6;
  if ( v5 == 0x7FFF )
  {
    *(_WORD *)v3 = 1;
    if ( (v6 != 0x80000000 || (_DWORD)a1) && (v6 & 0x40000000) == 0 )
    {
      v21 = "1#SNAN";
LABEL_22:
      strcpy((char *)(v3 + 4), v21);
      *(_BYTE *)(v3 + 3) = 6;
      return 0;
    }
    if ( v4 && v6 == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        v22 = "1#IND";
LABEL_19:
        strcpy((char *)(v3 + 4), v22);
        *(_BYTE *)(v3 + 3) = 5;
        return 0;
      }
    }
    else if ( v6 == 0x80000000 && !(_DWORD)a1 )
    {
      v22 = "1#INF";
      goto LABEL_19;
    }
    v21 = "1#QNAN";
    goto LABEL_22;
  }
  LOWORD(v24[0]) = 0;
  HIWORD(v24[2]) = v5;
  v7 = (77 * (HIBYTE(v5) + 2 * HIBYTE(DWORD1(a1))) + 19728 * v5 - 323162868) >> 16;
  *(_QWORD *)((char *)v24 + 2) = a1;
  __multtenpow12_0(v24, -(__int16)v7, 1);
  if ( HIWORD(v24[2]) >= 0x3FFFu )
  {
    LOWORD(v7) = v7 + 1;
    __ld12mul_0((int)v24, (int)v23);
  }
  v8 = (a2 & 1) == 0;
  *(_WORD *)v3 = v7;
  if ( v8 )
  {
    v9 = HIDWORD(a1);
    goto LABEL_29;
  }
  v9 = (__int16)v7 + HIDWORD(a1);
  if ( v9 > 0 )
  {
LABEL_29:
    if ( v9 > 21 )
      v9 = 21;
    v10 = HIWORD(v24[2]) - 16382;
    HIWORD(v24[2]) = 0;
    a3 = 8;
    do
    {
      __shl_12_0(v24);
      --a3;
    }
    while ( a3 );
    if ( v10 < 0 )
    {
      v11 = (unsigned __int8)-(char)v10;
      if ( v11 > 0 )
      {
        do
        {
          __shr_12_0((int *)v24);
          --v11;
        }
        while ( v11 );
      }
    }
    v12 = v3 + 4;
    a3 = v3 + 4;
    if ( v9 + 1 > 0 )
    {
      HIDWORD(a1) = v9 + 1;
      do
      {
        LODWORD(a1) = v24[0];
        *(_QWORD *)((char *)&a1 + 4) = *(_QWORD *)&v24[1];
        __shl_12_0(v24);
        __shl_12_0(v24);
        __add_12_0(v24, (unsigned int *)&a1);
        __shl_12_0(v24);
        v13 = HIBYTE(v24[2]);
        v14 = (_BYTE *)a3;
        HIBYTE(v24[2]) = 0;
        ++a3;
        v8 = HIDWORD(a1)-- == 1;
        *v14 = v13 + 48;
      }
      while ( !v8 );
      v12 = a3;
    }
    v15 = *(_BYTE *)(v12 - 1);
    v16 = (_BYTE *)(v12 - 2);
    v17 = v15 < 53;
    v18 = (_BYTE *)(v3 + 4);
    if ( v17 )
    {
      while ( v16 >= v18 )
      {
        if ( *v16 != 48 )
        {
          if ( v16 >= v18 )
            goto LABEL_47;
          break;
        }
        --v16;
      }
      *(_WORD *)v3 = 0;
      *(_BYTE *)(v3 + 2) = 32;
      *(_BYTE *)(v3 + 3) = 1;
      *v18 = 48;
      goto LABEL_54;
    }
    while ( v16 >= v18 )
    {
      if ( *v16 != 57 )
      {
        if ( v16 >= v18 )
          goto LABEL_46;
        break;
      }
      *v16-- = 48;
    }
    ++v16;
    ++*(_WORD *)v3;
LABEL_46:
    ++*v16;
LABEL_47:
    v19 = (_BYTE)v16 - v3 - 3;
    *(_BYTE *)(v3 + 3) = v19;
    *(_BYTE *)(v19 + v3 + 4) = 0;
    return v25;
  }
LABEL_6:
  *(_WORD *)v3 = 0;
  *(_BYTE *)(v3 + 2) = 32;
  *(_BYTE *)(v3 + 3) = 1;
  *(_BYTE *)(v3 + 4) = 48;
LABEL_54:
  *(_BYTE *)(v3 + 5) = 0;
  return 1;
}

//----- (1001F136) --------------------------------------------------------
char *__cdecl getenv_0(const char *a1)
{
  const char **v1; // esi
  size_t v2; // edi

  v1 = (const char **)dword_101C809C;
  if ( dword_101C970C )
  {
    if ( dword_101C809C || dword_101C80A4 && !__wtomb_environ_0() && (v1 = (const char **)dword_101C809C) != 0 )
    {
      if ( a1 )
      {
        v2 = strlen(a1);
        while ( *v1 )
        {
          if ( strlen(*v1) > v2
            && (*v1)[v2] == 61
            && !_mbsnbicoll_0((const unsigned __int8 *)*v1, (const unsigned __int8 *)a1, v2) )
          {
            return (char *)&(*v1)[v2 + 1];
          }
          ++v1;
        }
      }
    }
  }
  return 0;
}
// 101C809C: using guessed type int dword_101C809C;
// 101C80A4: using guessed type int dword_101C80A4;
// 101C970C: using guessed type int dword_101C970C;

//----- (1001F1B3) --------------------------------------------------------
int __cdecl _close_0(int a1)
{
  int v1; // esi
  int v2; // ebp
  int v3; // eax
  unsigned int v4; // ebp

  if ( (unsigned int)a1 < dword_101C86E0
    && (v1 = 8 * (a1 & 0x1F), (*(_BYTE *)(dword_101C85E0[a1 >> 5] + v1 + 4) & 1) != 0) )
  {
    if ( _get_osfhandle_0(a1) == -1
      || (a1 == 1 || a1 == 2) && (v2 = _get_osfhandle_0(2), _get_osfhandle_0(1) == v2)
      || (v3 = _get_osfhandle_0(a1), FIX_DLL_KERNEL32_dll_CloseHandle(v3)) )
    {
      v4 = 0;
    }
    else
    {
      v4 = FIX_DLL_KERNEL32_dll_GetLastError();
    }
    _free_osfhnd_0(a1);
    *(_BYTE *)(dword_101C85E0[a1 >> 5] + v1 + 4) = 0;
    if ( !v4 )
      return 0;
    _dosmaperr_0(v4);
  }
  else
  {
    dword_101C8078 = 0;
    dword_101C8074 = 9;
  }
  return -1;
}
// 10021000: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_CloseHandle)(_DWORD);
// 10021028: using guessed type int (*FIX_DLL_KERNEL32_dll_GetLastError)(void);
// 101C8074: using guessed type int dword_101C8074;
// 101C8078: using guessed type int dword_101C8078;
// 101C85E0: using guessed type int dword_101C85E0[];

//----- (1001F266) --------------------------------------------------------
int __cdecl __ld12mul_0(int a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // di
  int result; // eax
  int v8; // ecx
  int v9; // edi
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // ebx
  _BYTE v13[12]; // [esp+0h] [ebp-24h] BYREF
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+10h] [ebp-14h]
  int v16; // [esp+14h] [ebp-10h]
  unsigned __int16 *v17; // [esp+18h] [ebp-Ch]
  unsigned __int16 *v18; // [esp+1Ch] [ebp-8h]
  _WORD *v19; // [esp+20h] [ebp-4h]
  int v20; // [esp+2Ch] [ebp+8h]
  int v21; // [esp+2Ch] [ebp+8h]
  int i; // [esp+30h] [ebp+Ch]

  v4 = *(_WORD *)(a2 + 10);
  v15 = 0;
  *(_DWORD *)v13 = 0;
  *(_DWORD *)&v13[4] = 0;
  *(_DWORD *)&v13[8] = 0;
  v5 = *(_WORD *)(a1 + 10);
  v6 = v5 ^ v4;
  result = v5 & 0x7FFF;
  v8 = v4 & 0x7FFF;
  v9 = v6 & 0x8000;
  v10 = v8 + result;
  v20 = v8 + result;
  if ( (unsigned __int16)result < 0x7FFFu && (unsigned __int16)v8 < 0x7FFFu && v10 <= 0xBFFDu )
  {
    if ( v10 <= 0x3FBFu )
    {
      result = 0;
LABEL_16:
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      return result;
    }
    if ( (_WORD)result || (++v20, (*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0) )
    {
      result = 0;
    }
    else
    {
      result = 0;
      if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
        goto LABEL_45;
    }
    if ( !(_WORD)v8 )
    {
      ++v20;
      if ( (*(_DWORD *)(a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD *)(a2 + 4) && !*(_DWORD *)a2 )
        goto LABEL_16;
    }
    v16 = 0;
    v19 = &v13[4];
    for ( i = 5; i > 0; --i )
    {
      v18 = (unsigned __int16 *)(a1 + 2 * v16);
      v17 = (unsigned __int16 *)(a2 + 8);
      v14 = i;
      do
      {
        if ( __addl_0(*((_DWORD *)v19 - 1), *v17 * *v18, (unsigned int *)v19 - 1) )
          ++*v19;
        ++v18;
        --v17;
        --v14;
      }
      while ( v14 );
      ++v19;
      ++v16;
    }
    v21 = v20 + 49154;
    if ( (__int16)v21 <= 0 )
      goto LABEL_49;
    do
    {
      if ( v13[11] < 0 )
        break;
      __shl_12_0(v13);
      v21 += 0xFFFF;
    }
    while ( (__int16)v21 > 0 );
    if ( (__int16)v21 <= 0 )
    {
LABEL_49:
      v21 += 0xFFFF;
      if ( (v21 & 0x8000u) != 0 )
      {
        v11 = -(__int16)v21;
        v21 -= (__int16)v21;
        v12 = v11;
        do
        {
          if ( (v13[0] & 1) != 0 )
            ++v15;
          __shr_12_0((int *)v13);
          --v12;
        }
        while ( v12 );
        if ( v15 )
          v13[0] |= 1u;
      }
    }
    if ( *(_WORD *)v13 > 0x8000u || (*(_DWORD *)v13 & 0x1FFFF) == 98304 )
    {
      if ( *(_DWORD *)&v13[2] == -1 )
      {
        *(_DWORD *)&v13[2] = 0;
        if ( *(_DWORD *)&v13[6] == -1 )
        {
          *(_DWORD *)&v13[6] = 0;
          if ( *(_WORD *)&v13[10] == 0xFFFF )
          {
            ++v21;
            *(_WORD *)&v13[10] = 0x8000;
          }
          else
          {
            ++*(_WORD *)&v13[10];
          }
        }
        else
        {
          ++*(_DWORD *)&v13[6];
        }
      }
      else
      {
        ++*(_DWORD *)&v13[2];
      }
    }
    result = v21;
    if ( (unsigned __int16)v21 < 0x7FFFu )
    {
      result = v9 | v21;
      *(_WORD *)a1 = *(_WORD *)&v13[2];
      *(_DWORD *)(a1 + 2) = *(_DWORD *)&v13[4];
      *(_DWORD *)(a1 + 6) = *(_DWORD *)&v13[8];
LABEL_45:
      *(_WORD *)(a1 + 10) = result;
      return result;
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = (_WORD)v9 != 0 ? -32768 : 2147450880;
  return result;
}
// 1001F32F: conditional instruction was optimized away because of '%arg_4.4>=1'

//----- (1001F486) --------------------------------------------------------
void __cdecl __multtenpow12_0(_WORD *a1, int a2, int a3)
{
  char *v3; // ebx
  char v4; // al
  int v5; // eax
  char *v6; // esi
  _DWORD *v7; // esi
  __int64 v8; // [esp+0h] [ebp-Ch] BYREF
  int v9; // [esp+8h] [ebp-4h]

  v3 = (char *)&unk_100287D0 - 96;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      a2 = -a2;
      v3 = (char *)&unk_10028930 - 96;
    }
    if ( !a3 )
      *a1 = 0;
    while ( a2 )
    {
      v4 = a2;
      v3 += 84;
      a2 >>= 3;
      v5 = v4 & 7;
      if ( v5 )
      {
        v6 = &v3[12 * v5];
        if ( *(_WORD *)v6 >= 0x8000u )
        {
          LODWORD(v8) = *(_DWORD *)v6;
          v7 = v6 + 4;
          HIDWORD(v8) = *v7;
          v9 = v7[1];
          --*(_DWORD *)((char *)&v8 + 2);
          v6 = (char *)&v8;
        }
        __ld12mul_0((int)a1, (int)v6);
      }
    }
  }
}

//----- (1001F502) --------------------------------------------------------
int __cdecl _mbsnbicoll_0(const unsigned __int8 *a1, const unsigned __int8 *a2, size_t a3)
{
  int result; // eax
  int v4; // eax

  if ( !a3 )
    return 0;
  v4 = __crtCompareStringA_0(
         dword_101C85A4,
         1,
         (unsigned __int8 *)a1,
         (_BYTE *)a3,
         (unsigned __int8 *)a2,
         a3,
         dword_101C837C);
  if ( v4 )
    result = v4 - 2;
  else
    result = 0x7FFFFFFF;
  return result;
}
// 101C85A4: using guessed type int dword_101C85A4;

//----- (1001F541) --------------------------------------------------------
int __wtomb_environ_0()
{
  _DWORD *v0; // esi
  int v1; // eax
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx
  size_t v3; // eax
  char *v4; // eax
  char *lpMultiByteStr; // [esp+0h] [ebp-44h]

  v0 = (_DWORD *)dword_101C80A4;
  v1 = *(_DWORD *)dword_101C80A4;
  if ( !*(_DWORD *)dword_101C80A4 )
    return 0;
  v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_WideCharToMultiByte;
  while ( 1 )
  {
    v3 = ((int (__cdecl *)(int, _DWORD, int, int, _DWORD, _DWORD, _DWORD, _DWORD))v2)(1, 0, v1, -1, 0, 0, 0, 0);
    if ( !v3 )
      break;
    v4 = (char *)sub_10019098(v3);
    if ( !v4 )
      break;
    lpMultiByteStr = v4;
    if ( !v2(1, 0, *v0, -1) )
      break;
    __crtsetenv_0(lpMultiByteStr, 0);
    v1 = v0[1];
    ++v0;
    if ( !v1 )
      return 0;
  }
  return -1;
}
// 1002116C: using guessed type int (__stdcall *FIX_DLL_KERNEL32_dll_WideCharToMultiByte)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C80A4: using guessed type int dword_101C80A4;

//----- (1001F5AF) --------------------------------------------------------
int __cdecl __crtCompareStringA_0(int a1, int a2, unsigned __int8 *a3, _BYTE *a4, unsigned __int8 *a5, int a6, int a7)
{
  int v7; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 v10; // dl
  unsigned __int8 *i; // eax
  unsigned __int8 v12; // dl
  int v13; // eax
  int v14; // eax
  void *v15; // esp
  int (__cdecl *v16)(int, int, unsigned __int8 *, int, _DWORD, _DWORD); // esi
  int v17; // eax
  int v18; // esi
  int v19; // eax
  void *v20; // esp
  _BYTE v21[36]; // [esp-C4h] [ebp-C4h] BYREF
  int v22; // [esp-A0h] [ebp-A0h]
  _DWORD v23[5]; // [esp-94h] [ebp-94h] BYREF
  int v24; // [esp-80h] [ebp-80h]
  int v25; // [esp-4Ch] [ebp-4Ch] BYREF
  unsigned int v26; // [esp-3Ch] [ebp-3Ch] BYREF
  _BYTE v27[14]; // [esp-36h] [ebp-36h] BYREF
  _BYTE *v28; // [esp-28h] [ebp-28h]
  _DWORD *v29; // [esp-24h] [ebp-24h]
  int v30; // [esp-20h] [ebp-20h]
  int v31; // [esp-1Ch] [ebp-1Ch]
  int *v32; // [esp-18h] [ebp-18h]
  unsigned int v33; // [esp-10h] [ebp-10h]
  void *v34; // [esp-Ch] [ebp-Ch]
  void *v35; // [esp-8h] [ebp-8h]
  int v36; // [esp-4h] [ebp-4h]

  v36 = -1;
  v35 = &unk_10022100;
  v34 = &unknown_libname_67;
  v33 = __readfsdword(0);
  v32 = &v25;
  if ( !dword_101C8378 )
  {
    if ( FIX_DLL_KERNEL32_dll_CompareStringW(0, 0, &unk_10021D18, 1, &unk_10021D18, 1) )
    {
      dword_101C8378 = 1;
    }
    else
    {
      if ( !FIX_DLL_KERNEL32_dll_CompareStringA(0, 0, &unk_10021D14, 1, &unk_10021D14, 1) )
        return 0;
      dword_101C8378 = 2;
    }
  }
  v7 = (int)a4;
  if ( (int)a4 > 0 )
    v7 = (int)sub_1001F82C(a3, a4);
  if ( a6 > 0 )
    a6 = (int)sub_1001F82C(a5, (_BYTE *)a6);
  if ( dword_101C8378 == 2 )
    return FIX_DLL_KERNEL32_dll_CompareStringA(a1, a2, a3, v7, a5, a6);
  if ( dword_101C8378 == 1 )
  {
    if ( !a7 )
      a7 = dword_101C8124;
    if ( !v7 || !a6 )
    {
      if ( v7 == a6 )
        return 2;
      if ( a6 > 1 )
        return 1;
      if ( v7 > 1 )
      {
LABEL_31:
        v23[3] = 3;
        return v24;
      }
      if ( !FIX_DLL_KERNEL32_dll_GetCPInfo(a7, &v26) )
        return 0;
      if ( v7 > 0 )
      {
        if ( v26 >= 2 )
        {
          v9 = v27;
          if ( v27[0] )
          {
            while ( 1 )
            {
              v10 = v9[1];
              if ( !v10 )
                break;
              if ( *a3 >= *v9 && *a3 <= v10 )
                return 2;
              v9 += 2;
              if ( !*v9 )
                goto LABEL_31;
            }
          }
        }
        goto LABEL_31;
      }
      if ( a6 > 0 )
      {
        if ( v26 >= 2 )
        {
          for ( i = v27; *i; i += 2 )
          {
            v12 = i[1];
            if ( !v12 )
              break;
            if ( *a5 >= *i && *a5 <= v12 )
              return 2;
          }
        }
        return 1;
      }
    }
    v13 = FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 9, a3, v7, 0, 0);
    v31 = v13;
    if ( v13 )
    {
      v14 = 2 * v13 + 3;
      LOBYTE(v14) = v14 & 0xFC;
      v15 = alloca(v14);
      v32 = v23;
      v29 = v23;
      v36 = -1;
      if ( v23 )
      {
        v22 = v7;
        v16 = (int (__cdecl *)(int, int, unsigned __int8 *, int, _DWORD, _DWORD))FIX_DLL_KERNEL32_dll_MultiByteToWideChar;
        if ( FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 1, a3, v22, v29, v31) )
        {
          v17 = v16(a7, 9, a5, a6, 0, 0);
          v18 = v17;
          v30 = v17;
          if ( v17 )
          {
            v19 = 2 * v17 + 3;
            LOBYTE(v19) = v19 & 0xFC;
            v20 = alloca(v19);
            v32 = (int *)v21;
            v28 = v21;
            v36 = -1;
            if ( v21 )
            {
              if ( FIX_DLL_KERNEL32_dll_MultiByteToWideChar(a7, 1, a5, a6, v21, v18) )
                return FIX_DLL_KERNEL32_dll_CompareStringW(a1, a2, v29, v31, v21, v18);
            }
          }
        }
      }
    }
  }
  return 0;
}
// 100210D0: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210D4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_CompareStringA)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100210E4: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_GetCPInfo)(_DWORD, _DWORD);
// 10021170: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_MultiByteToWideChar)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101C8378: using guessed type int dword_101C8378;

//----- (1001F82C) --------------------------------------------------------
_BYTE *__cdecl sub_1001F82C(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *result; // eax

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    result = a2;
  else
    result = (_BYTE *)(v2 - a1);
  return result;
}

//----- (1001F857) --------------------------------------------------------
int __cdecl __crtsetenv_0(char *lpMultiByteStr, int a2)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // esi
  _DWORD *v4; // eax
  bool v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  size_t v14; // eax
  char *v15; // eax
  unsigned int v16; // esi
  unsigned __int8 *v17; // eax
  unsigned int v18; // [esp-10h] [ebp-18h]
  unsigned __int8 *v19; // [esp+0h] [ebp-8h]
  unsigned int v20; // [esp+4h] [ebp-4h]

  if ( !lpMultiByteStr )
    return -1;
  v2 = _mbschr_0((const unsigned __int8 *)lpMultiByteStr, 0x3Du);
  v3 = v2;
  v19 = v2;
  if ( !v2 || lpMultiByteStr == (char *)v2 )
    return -1;
  v4 = (_DWORD *)dword_101C809C;
  v5 = v3[1] == 0;
  if ( dword_101C809C == dword_101C80A0 )
  {
    v4 = copy_environ_0((_DWORD *)dword_101C809C);
    dword_101C809C = (int)v4;
  }
  if ( !v4 )
  {
    if ( a2 && dword_101C80A4 )
    {
      if ( __wtomb_environ_0() )
        return -1;
    }
    else
    {
      if ( v5 )
        return 0;
      v7 = sub_10019098(4u);
      dword_101C809C = (int)v7;
      if ( !v7 )
        return -1;
      *v7 = 0;
      if ( !dword_101C80A4 )
      {
        v8 = sub_10019098(4u);
        dword_101C80A4 = (int)v8;
        if ( !v8 )
          return -1;
        *v8 = 0;
      }
    }
  }
  v9 = (_DWORD *)dword_101C809C;
  v20 = dword_101C809C;
  v10 = findenv_0((unsigned __int8 *)lpMultiByteStr, v3 - (unsigned __int8 *)lpMultiByteStr);
  v11 = v10;
  if ( v10 >= 0 && *v9 )
  {
    if ( !v5 )
    {
      v9[v10] = lpMultiByteStr;
      goto LABEL_31;
    }
    v18 = v9[v10];
    v12 = &v9[v10];
    sub_100189EC(v18);
    while ( *v12 )
    {
      ++v11;
      *v12 = v12[1];
      ++v12;
    }
    v13 = sub_10018D97(v20, (_DWORD *)(4 * v11));
    if ( !v13 )
    {
LABEL_31:
      if ( a2 )
      {
        v14 = strlen(lpMultiByteStr);
        v15 = (char *)sub_10019098(v14 + 2);
        v16 = (unsigned int)v15;
        if ( v15 )
        {
          strcpy(v15, lpMultiByteStr);
          v17 = &v19[v16 - (_DWORD)lpMultiByteStr];
          *v17 = 0;
          FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA(v16, !v5 ? v17 + 1 : 0);
          sub_100189EC(v16);
        }
      }
      return 0;
    }
LABEL_30:
    dword_101C809C = (int)v13;
    goto LABEL_31;
  }
  if ( !v5 )
  {
    if ( v10 < 0 )
      v11 = -v10;
    v13 = sub_10018D97((unsigned int)v9, (_DWORD *)(4 * v11 + 8));
    if ( !v13 )
      return -1;
    v13[v11] = lpMultiByteStr;
    v13[v11 + 1] = 0;
    goto LABEL_30;
  }
  return 0;
}
// 1001F541: using guessed type int __wtomb_environ_0(void);
// 100210FC: using guessed type int (__cdecl *FIX_DLL_KERNEL32_dll_SetEnvironmentVariableA)(_DWORD, _DWORD);
// 101C809C: using guessed type int dword_101C809C;
// 101C80A0: using guessed type int dword_101C80A0;
// 101C80A4: using guessed type int dword_101C80A4;

//----- (1001F9DE) --------------------------------------------------------
int __cdecl findenv_0(unsigned __int8 *a1, size_t a2)
{
  _DWORD *v2; // esi
  const unsigned __int8 *v3; // eax
  char v4; // al

  v2 = (_DWORD *)dword_101C809C;
  v3 = *(const unsigned __int8 **)dword_101C809C;
  if ( !*(_DWORD *)dword_101C809C )
    return -(((int)v2 - dword_101C809C) >> 2);
  while ( 1 )
  {
    if ( !_mbsnbicoll_0(a1, v3, a2) )
    {
      v4 = *(_BYTE *)(*v2 + a2);
      if ( v4 == 61 || !v4 )
        break;
    }
    v3 = (const unsigned __int8 *)v2[1];
    ++v2;
    if ( !v3 )
      return -(((int)v2 - dword_101C809C) >> 2);
  }
  return ((int)v2 - dword_101C809C) >> 2;
}
// 101C809C: using guessed type int dword_101C809C;

//----- (1001FA36) --------------------------------------------------------
_DWORD *__cdecl copy_environ_0(_DWORD *a1)
{
  int v1; // ecx
  int *v3; // eax
  int v4; // edx
  _DWORD *v5; // esi
  _DWORD *v6; // ebp
  const char *v7; // eax
  const char **v8; // ebx

  v1 = 0;
  if ( !a1 )
    return 0;
  v3 = a1 + 1;
  if ( *a1 )
  {
    do
    {
      v4 = *v3;
      ++v1;
      ++v3;
    }
    while ( v4 );
  }
  v5 = sub_10019098(4 * v1 + 4);
  v6 = v5;
  if ( !v5 )
    _amsg_exit_0(9);
  v7 = (const char *)*a1;
  v8 = (const char **)a1;
  while ( v7 )
  {
    ++v8;
    *v5 = _strdup_0(v7);
    v7 = *v8;
    ++v5;
  }
  *v5 = 0;
  return v6;
}

//----- (1001FA9D) --------------------------------------------------------
unsigned __int8 *__cdecl _mbschr_0(const unsigned __int8 *a1, unsigned int a2)
{
  const unsigned __int8 *i; // ecx
  unsigned __int16 v4; // ax
  unsigned __int8 v5; // dl

  if ( !dword_101C838C )
    return (unsigned __int8 *)strchr_0((const char *)a1, a2);
  for ( i = a1; ; ++i )
  {
    v4 = *i;
    if ( !*i )
      break;
    if ( (byte_101C84A1[(unsigned __int8)v4] & 4) != 0 )
    {
      v5 = *++i;
      if ( !v5 )
        return 0;
      if ( a2 == (v5 | (v4 << 8)) )
        return (unsigned __int8 *)(i - 1);
    }
    else if ( a2 == *i )
    {
      return (unsigned __int8 *)(*i == a2 ? i : 0);
    }
  }
  return (unsigned __int8 *)(*i == a2 ? i : 0);
}
// 101C838C: using guessed type int dword_101C838C;

//----- (1001FB10) --------------------------------------------------------
char *__cdecl _strdup_0(const char *a1)
{
  size_t v1; // eax
  char *v2; // eax
  char *result; // eax

  if ( a1 && (v1 = strlen(a1), (v2 = (char *)sub_10019098(v1 + 1)) != 0) )
    result = strcpy(v2, a1);
  else
    result = 0;
  return result;
}

//----- (1001FC60) --------------------------------------------------------
unsigned int __cdecl _memicmp_0(const void *a1, const void *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // al
  int v8; // eax
  int v9; // ebx
  int v11; // [esp-14h] [ebp-14h]
  unsigned int v12; // [esp-10h] [ebp-10h]

  v3 = a3;
  if ( a3 )
  {
    if ( *((_DWORD *)&unk_101C810C + 2) )
    {
      v8 = 0;
      v9 = 0;
      while ( 1 )
      {
        LOBYTE(v8) = *(_BYTE *)a1;
        a1 = (char *)a1 + 1;
        LOBYTE(v9) = *(_BYTE *)a2;
        a2 = (char *)a2 + 1;
        if ( (_BYTE)v8 != (_BYTE)v9 )
        {
          v12 = v3;
          v11 = v8;
          v9 = tolower_0(v9);
          v8 = tolower_0(v11);
          v3 = v12;
          if ( (_BYTE)v8 != (_BYTE)v9 )
            break;
        }
        if ( !--v3 )
          return v3;
      }
      v3 = -1;
      if ( (unsigned __int8)v8 >= (unsigned __int8)v9 )
        v3 = 1;
    }
    else
    {
      while ( 1 )
      {
        v6 = *(_BYTE *)a1;
        a1 = (char *)a1 + 1;
        v7 = *(_BYTE *)a2;
        a2 = (char *)a2 + 1;
        if ( v6 != v7 )
        {
          if ( v6 >= 0x41u && v6 <= 0x5Au )
            v6 += 32;
          if ( v7 >= 0x41u && v7 <= 0x5Au )
            v7 += 32;
          if ( v6 != v7 )
            break;
        }
        if ( !--v3 )
          return v3;
      }
      v3 = -1;
      if ( v6 >= v7 )
        v3 = 1;
    }
  }
  return v3;
}

//----- (1001FED0) --------------------------------------------------------
int __usercall SEH_10008190@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6)
{
  return __CxxFrameHandler_0((struct _s_FuncInfo *)&unk_10022468, a1, a2, a3, a4, a5, a6);
}

//----- (1001FF28) --------------------------------------------------------
int __usercall SEH_1000C480@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6)
{
  return __CxxFrameHandler_0((struct _s_FuncInfo *)&unk_10022510, a1, a2, a3, a4, a5, a6);
}

//----- (1001FF58) --------------------------------------------------------
int __usercall SEH_1000D170@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6)
{
  return __CxxFrameHandler_0((struct _s_FuncInfo *)&unk_10022570, a1, a2, a3, a4, a5, a6);
}

//----- (10020008) --------------------------------------------------------
int __usercall SEH_100125F0@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6)
{
  return __CxxFrameHandler_0((struct _s_FuncInfo *)&unk_10022670, a1, a2, a3, a4, a5, a6);
}

//----- (10020028) --------------------------------------------------------
int __usercall fix_1c_SEH@<eax>(void *a1@<ecx>, int a2@<ebx>, EXCEPTION_RECORD *a3, struct EHRegistrationNode *a4, struct _CONTEXT *a5, void *a6)
{
  return __CxxFrameHandler_0((struct _s_FuncInfo *)&unk_100226D0, a1, a2, a3, a4, a5, a6);
}

// nfuncs=979 queued=598 decompiled=598 lumina nreq=0 worse=0 better=0
#error "There were 11 decompilation failure(s) on 598 function(s)"
